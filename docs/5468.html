<html>
<head>
<title>JavaScript — Method to Call Backend Logic in Sequential Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript —在顺序循环中调用后端逻辑的方法</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/javascript-method-to-call-backend-logic-in-sequential-loop-4c2c627c6783?source=collection_archive---------0-----------------------#2018-06-21">https://medium.com/oracledevs/javascript-method-to-call-backend-logic-in-sequential-loop-4c2c627c6783?source=collection_archive---------0-----------------------#2018-06-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3724" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们从JavaScript调用后端REST服务时，默认情况下调用是异步执行的。这意味着它不会等到收到后端的响应，而是继续执行代码。在大多数情况下，这是预期的和期望的功能。但这可能是一个需求，你想以同步的方式调用后端。示例—在循环中多次调用后端服务，只有在前一个调用完成后才能调用下一个调用。使用默认异步功能，循环将在第一次REST调用之前完成。</p><p id="985d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是调用后端REST服务的例子(通过Oracle JET API，在后台使用JQuery)。呼叫进行了三次，成功的回叫打印了一条消息。在每次循环迭代结束时，还会打印一条消息:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/6c4ad115a1a204294c95e17bf4bcd3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACIm_h1pd-DCQ0Or2rszuA.png"/></div></div></figure><p id="3e45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">循环中执行了三个后端REST调用:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jo"><img src="../Images/2ba415496eac047e64312f99b5812e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vsD-VEZE4yQvj6Vekgb7g.png"/></div></div></figure><p id="6bf6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从第一次迭代开始，循环比REST调用早完成，我们可以从日志中看到这一点:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jp"><img src="../Images/a195cdb57ade507857273d727a6ec656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzhHm9-ewgzcrnMSb8uNHw.png"/></div></div></figure><p id="5bb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于大多数情况，这可能是有效的和预期的行为。但是根据后端逻辑，您可能希望保证在第一次迭代调用未完成之前，不会调用第二次迭代的调用。这可以通过指定异步函数和在循环中使用Promise来实现。我们应该使用<em class="jq">等待新的承诺</em>语法，并通过调用<em class="jq"> next() </em>在成功回调中解决它:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jr"><img src="../Images/8853693ce6f5676b64a14746de2b0a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IpR2bimtN-dK41Dy6ktkg.png"/></div></div></figure><p id="0f68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着promise的应用，循环按顺序执行——只有在调用后端服务成功回调之后，才开始下一个循环迭代。您可以从日志中看到:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es js"><img src="../Images/2654255988d77273561dcb77a82e22ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17KoF8blWFU2QRnygRByYg.png"/></div></div></figure><p id="9213" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码可以在我的GutHub <a class="ae jt" href="https://github.com/abaranovskis-redsamurai/synchloopapp/blob/master/src/js/viewModels/dashboard.js" rel="noopener ugc nofollow" target="_blank">库</a>上找到。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="b971" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jq">原载于2018年6月21日</em><a class="ae jt" href="https://andrejusb.blogspot.com/2018/06/javascript-method-to-call-backend-logic.html" rel="noopener ugc nofollow" target="_blank"><em class="jq">andrejusb.blogspot.com</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>