<html>
<head>
<title>Unit testing protected lifecycle methods with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin对受保护的生命周期方法进行单元测试</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/unit-testing-activity-lifecycle-4e740f71e68a?source=collection_archive---------1-----------------------#2017-12-29">https://medium.com/google-developer-experts/unit-testing-activity-lifecycle-4e740f71e68a?source=collection_archive---------1-----------------------#2017-12-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/c26bebb54f15c260c67d8744b2f0e861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8nabgD5q0kY3WbcY9fTjog.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://www.flickr.com/photos/frosch50/13186200564/in/photolist-m6dJ2A-kwcXyz-iu6par-9H1XE9-dkgwmL-4Tcrbg-cgwYAq-8HzfZA-87hipg-9GY5bR-epR51-53ztX7-WpHuPX-ouuo2D-kLtd1D-8gYDbE-6y3NFm-6xV2ux-iNiEMr-6JKCZQ-pCVgHJ-6FNE9J-SH6zhq-deMmGo-95D8wL-efUWNa-8xn66X-TepKGd-WpJabg-hw8Rdd-UFPEZa-Xf5Jbz-213G3GT-7FT2xd-wbwpc-VPwQ1J-YhLwU6-8kmkoG-Verhpq-9GY3xP-8kmkm9-aiyRiY-8kj6oX-X5FqSX-eavcZZ-8knhRj-8kmkeA-eWipDq-ofVP8N-yjMM7" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/frosch50/13186200564</a></figcaption></figure><p id="6d68" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">开发人员经常讨论在哪里停止单元测试。是不是应该只考Java水平，到了一个Android类就停下来？我们需要做浓缩咖啡测试，对吗？</p><p id="a15a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当我进行测试驱动开发时，我不想停下来。停下来会让我慢下来。甚至执行UI测试也意味着减慢我的速度。</p><p id="5e16" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，当编写一个Android应用程序，或者向其中添加一个新特性时，我想要测试驻留在<em class="jo">活动</em>中的代码。当然这段代码应该非常有限。所有代码都应该转移到特定的类中，比如演示者。但是仍然有代码留下。即使应用我最喜欢的模型:MVVM与Android数据绑定<em class="jo">活动</em>仍然必须将模型和布局绑定在一起。或者它可能会转发某些生命周期事件。</p><p id="07a5" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这不是一个大问题，因为在相当长的一段时间里，我们可以对许多android类进行单元测试，即使不需要<a class="ae ip" href="https://github.com/robolectric/robolectric" rel="noopener ugc nofollow" target="_blank"> Robolectric </a>。你可以从纯java单元测试中调用一个<em class="jo">活动</em>的<em class="jo"> onCreate() </em>方法，猜猜会发生什么？没什么！因为所有代码都被删除了，所有的最终修饰符也是如此。自己看吧，只要打开<em class="jo"> build/generated </em>文件夹，你就会发现一个<em class="jo">可模仿的android jar </em>文件，它是为你的测试动态生成的。</p><p id="f8ca" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">假设我有一个这样的测试:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fce7" class="jy jz hh ju b fi ka kb l kc kd">@Test<br/>fun `should inflate layout`() {<br/>    val tested = <em class="jo">spy</em>(MainActivity())<br/>    <strong class="ju hi">tested.onCreate</strong>(null)<br/>    <strong class="ju hi">verify</strong>(tested).<strong class="ju hi">setContentView</strong>(R.layout.<em class="jo">activity_main</em>)<br/>}</span></pre><p id="a5d4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里，我们希望确保<em class="jo">活动</em>扩展了一个特定的布局(我还检查了onCreate是否可以处理一个null bundle)。这是我在做TDD时会写的东西，因为我不得不强迫自己写测试，强迫自己写特定的代码。</p><p id="6e6b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">但是当你试着写这个的时候，你会看到:</p><blockquote class="ke"><p id="6526" class="kf kg hh bd kh ki kj kk kl km kn jn dx translated"><strong class="ak"> <em class="ko">无法访问‘onCreate’:它在‘main activity’</em></strong>中受保护</p></blockquote><p id="c5c5" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ha bi translated">这完全说得通。</p><p id="0729" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在Java中，欺骗系统是很容易的。让测试类和我们正在测试的<em class="jo">活动</em>在同一个包中。</p><p id="31cd" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">科特林让我们的生活变得更艰难，它不再接受这一点。这是正确的，这个方法被标记为<em class="jo"> protected </em>以从子类中覆盖它，但是它不能从位于其中一个子类的同一个包中的每个类中访问。</p><p id="0026" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">但是我们如何解决这个测试呢？</p><p id="ee80" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我可以在子类中改变这些方法的可见性。但我会为考试做些事情。我们应该避免的事情。</p><p id="6085" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">有一个更好的方法:包规则仍然适用于在最初的<em class="jo">活动</em>类中声明方法的地方。所以<em class="jo"> android.app </em>包里的所有人还是可以调用<em class="jo"> onCreate() </em>。</p><p id="dd1c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当然，您不希望将所有的测试都转移到那个系统包中。所以我们需要的是一座桥，当我们使用Kotlin时，我们可以建造一座优雅的桥:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="029f" class="jy jz hh ju b fi ka kb l kc kd"><strong class="ju hi">package android.app</strong><br/><br/>import android.os.Bundle<br/><br/>fun <strong class="ju hi">Activity.onCreate</strong>(bundle: Bundle?) = <strong class="ju hi">this</strong>.<strong class="ju hi">onCreate</strong>(bundle)</span></pre><p id="9bf6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这个代码片段定义了一个与我们的生命周期方法同名的扩展函数，然后调用它。请记住，扩展函数只是静态函数，因此对于JVM来说，不存在名称冲突。</p><p id="6c18" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们在测试中需要做的就是导入这个方法，并保持代码的其余部分不变:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fb91" class="jy jz hh ju b fi ka kb l kc kd">import<strong class="ju hi"> android.app.onCreate</strong></span><span id="e672" class="jy jz hh ju b fi ku kb l kc kd">@Test<br/>fun `should inflate layout`() {<br/>    val tested = <em class="jo">spy</em>(MainActivity())<br/>    <strong class="ju hi">tested.<em class="jo">onCreate</em></strong>(null)<br/>    <strong class="ju hi">verify</strong>(tested).<strong class="ju hi">setContentView</strong>(R.layout.<em class="jo">activity_main</em>)<br/>}</span></pre><p id="adf6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在您正在调用的<em class="jo"> onCreate </em>正在使用我们的小间接方式，而不会损害测试的可读性。</p><p id="034f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果你懒得自己写这个，请随意使用我的版本，它为所有受保护的方法实现了一个桥，包括<em class="jo"> onActivityResult </em>:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7e49" class="jy jz hh ju b fi ka kb l kc kd">repositories {<br/>    maven {url <strong class="ju hi">"https://jitpack.io"</strong>}<br/>}</span><span id="7f2b" class="jy jz hh ju b fi ku kb l kc kd">testImplementation <strong class="ju hi">'com.github.dpreussler:android-tdd-utils:v0.1'</strong></span></pre><p id="63b3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">PS:在尝试调用<em class="jo">appcompactivity</em>的<em class="jo"> onCreate() </em>时会遇到一些问题。原因:可模仿的罐子在这方面没有帮助。我们将在以后的博客中研究如何解决这个问题。敬请关注。</p></div></div>    
</body>
</html>