<html>
<head>
<title>How To Do Pagination in Postgres with Golang in 4 Common Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Postgres中用Golang以4种常见方式分页</h1>
<blockquote>原文：<a href="https://medium.easyread.co/how-to-do-pagination-in-postgres-with-golang-in-4-common-ways-12365b9fb528?source=collection_archive---------0-----------------------#2020-05-26">https://medium.easyread.co/how-to-do-pagination-in-postgres-with-golang-in-4-common-ways-12365b9fb528?source=collection_archive---------0-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2e96" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Postgres上分页的几个例子，带Benchmark，用Golang写的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/60c96cb75b13616e54c0caccfb0379a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hayUe6QTgRGqgtdJ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@gitsela?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ergita Sela</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="21c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">大家好</em>，我已经很久没有发表文章了。有很多事情正在发生，像疫情和更多的东西。这个疫情在精神上影响了我，这种自我隔离让我疲惫不堪，压力重重。我希望这部《新冠肺炎·疫情》能在今年圣诞节前结束。😭</p><p id="4074" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个难得的场合，在战胜了无聊和懒惰之后，我找到了完成这篇文章的精神。从我开始，当我在当前的工作中构建我们的新应用程序时，我对一些事情很好奇，在这一部分，它是关于分页的。比如如何根据我的理解更好的处理分页，LOL。* <em class="lp">我提出的想法可能不是最好的，所以如果你们有更好的方法，比我丰富的经验，把你们的评论放在阿雅下面！！</em></p><p id="ba74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TBH，在我以前的工作中，我从来没有关心过更多的细节，因为我们都有相同的观点，我们只喜欢在我以前的公司有10名工程师，所以我们可以有相同的观点。但现在我关心这个问题，因为我现在的工作中有很多工程师，每个人都有不同的观点。</p><p id="25bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我很好奇，在应用程序之上的Postgres上构建分页的更好方法是什么，就我的情况而言，我在应用程序中使用Golang。</p><p id="69d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上，有两种著名的分页方式:</p><ul class=""><li id="9c19" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">基于光标的分页</li><li id="1c1c" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">基于偏移量的分页</li></ul><p id="d05a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将只介绍后端工程师通常使用的四种不同的分页方式，或者至少是我目前所知道的，因为我知道如何编码。</p><ul class=""><li id="13ca" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">用页码做分页，挺常见的；用户只发页码，我们内部处理；我在数据库级别使用偏移。</li><li id="3f7e" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">使用偏移和限制进行分页，这在<strong class="kv io"> RDBMS </strong>特性中很常见。用户将从查询参数中直接发送偏移量。</li><li id="d931" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">使用一个简单的查询进行分页，将自动增量ID作为PK，这在数据库的自动增量ID中很常见。即ID被视为光标。</li><li id="eec9" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">使用UUID作为主键，结合创建的时间戳进行分页，也称为seek-pagination方法或keyset分页方法。并且该组合键将被散列成光标串。</li></ul><p id="8ffb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我在这里要做的是，我将创建这四个分页实现，并从代码中做一个小的基准测试；我用Golang基准。这篇文章的目标只是为了满足我的好奇心LOL。我知道我可以看别人的文章，但我想用我的版本来做。</p><p id="1a43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TL；速度三角形定位法(dead reckoning)</p><ul class=""><li id="b4dc" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">这里使用的所有代码都已经被推送到我的Github库，<a class="ae ks" href="https://github.com/bxcodec/go-postgres-pagination-example" rel="noopener ugc nofollow" target="_blank">github.com/bxcodec/go-postgres-pagination-example</a></li><li id="a9f7" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">结论可以在这篇文章的底部看到</li></ul></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="d617" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">REST API上的分页</h1><p id="a464" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">为了给你一些上下文，如果你不知道分页是用于什么的话，请使用<em class="lp">。分页是用来给你的回复分页的，LOL。我不知道如何更好地表达。</em></p><p id="19b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将创建一个例子；假设我在REST API中有这个端点。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="cc76" class="nn mm in nj b gy no np l nq nr"><strong class="nj io">GET /payments</strong></span></pre><p id="165b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个端点将从API获取所有的支付。我们知道，在拥有大量数据集的大规模应用中，这些支付可能有数千或数百万个数据行。作为用户，我想获取我的付款清单。</p><p id="56bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从数据库的角度来看，查询所有记录将花费大量时间。我可以想象，如果我们有一百万条记录并获取所有数据，这将需要多长时间。因此，在这种情况下，人们引入了他们所谓的分页。它就像书本上的书页，每一页都包含一串单词。</p><p id="ad65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是对于这个端点，每个页面将包含一个支付细节列表，所以我们仍然可以更快地获取支付，但是可能会被截断成多个页面，直到我们可以获取所有的支付记录。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="9396" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">page=1</strong> // to fetch payments in page 1<br/>GET /payments?<strong class="nj io">page=2</strong> // to fetch payments in page 2<br/>GET /payments?<strong class="nj io">page=3</strong> // to fetch payments in page 3<br/>... etc</span></pre><p id="1529" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可能在任何端点中都见过这种风格，或者类似这样的风格。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="a0ad" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">limit=10</strong> // initial request for fetch payment<br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=randomCursorString</strong> // with cursor<br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=newrandomCursorString</strong> // for next page<br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=anotherNewrandomCursorStrin</strong>g<br/>... etc</span></pre><p id="406d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有更多，这就是我们所说的分页。我们将数据列表截断成几个片段并发送给客户端，因此我们仍然保持应用程序的性能，客户端在获取数据时不会丢失跟踪。</p><h2 id="01c2" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">1.带页码的分页</h2><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="c4f2" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">page=1</strong> // to fetch payments in page 1<br/>GET /payments?<strong class="nj io">page=2</strong> // to fetch payments in page 2<br/>GET /payments?<strong class="nj io">page=3</strong> // to fetch payments in page 3<br/>... etc</span></pre><p id="77bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你见过上面这样的分页吗？TBH，我从未见过这样的分页，如果我没记错的话，在公共API中没有。但是，大约4年前，在我毕业后的第一次工作测试中，我曾经创建过这种风格的分页。</p><p id="a34d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，后端的逻辑相当复杂，但从用户体验来看，它会简化，</p><ul class=""><li id="869d" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">首先，我将设置默认限制，比如10。<em class="lp">每页是10项</em> s</li><li id="104c" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">并且每个页码将被乘以默认限制</li><li id="1eaf" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">然后我会用它作为数据库的偏移量。</li><li id="3825" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">并且，用户可以根据所请求的页码获取项目。</li></ul><p id="fd8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我尝试为这种方法构建一个简单的应用程序。用<strong class="kv io"> 10万行数据</strong>，我试着对它进行基准测试。</p><p id="8a37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">基准测试结果</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Benchmark Result using Go for PageNumber pagination</figcaption></figure><p id="63dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的缺点是</strong></p><ul class=""><li id="f1e0" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">就性能而言，不建议这样做。数据集越大，资源消耗越大。</li></ul><p id="2675" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是使用这种方法的好处是，用户感觉就像打开一本书，他们只需要传递页码。</p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h2 id="f0a5" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">2.带偏移量和限制的分页</h2><p id="efbf" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">带有偏移量和限制的分页对于工程师来说很常见。这是因为RDBMS支持偏移和查询限制的特性。</p><p id="7cb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从应用程序级别来看，没有额外的逻辑，只是将偏移量和限制传递给数据库，并让数据库进行分页。</p><p id="2de9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常是什么样子，</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="007a" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">limit=10</strong> // initial <br/>GET /payments?<strong class="nj io">limit=10&amp;offset=10</strong> //fetch the next 10 items<br/>GET /payments?<strong class="nj io">limit=10&amp;offset=20</strong> //fetch the next 10 items again<br/>... etc</span></pre><p id="51fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在客户端，他们只需要添加偏移量参数，API将根据给定的偏移量返回项目。</p><p id="11f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从数据库层面来看，RDBMS，看起来像下面这样，</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="d47a" class="nn mm in nj b gy no np l nq nr"><strong class="nj io">SELECT</strong><br/>    *<br/><strong class="nj io">FROM</strong><br/>    payments<br/><strong class="nj io">ORDER</strong> <strong class="nj io">BY</strong> created_time<br/><strong class="nj io">LIMIT</strong> 10<br/><strong class="nj io">OFFSET</strong> 20;</span></pre><p id="1a2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">基准测试结果</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Benchmark Result using Go for LimitOffset pagination</figcaption></figure><p id="460b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方式的缺点</strong></p><ul class=""><li id="18d2" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">就性能而言，不建议这样做。数据集越大，资源消耗越大。</li></ul><p id="4eb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的好处</strong></p><ul class=""><li id="019b" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">非常容易实现；不需要在服务器上做复杂的逻辑工作</li></ul></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h2 id="f3cf" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">3.使用ID的自动增量主键分页</h2><p id="0ef0" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">这种分页方法也很常见。我们将表设置为自动递增，将其用作页面标识符/光标。</p><p id="a213" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如何在休息时使用</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="23fc" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">limit=10</strong><br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=last_id_from_previous_fetch</strong><br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=last_id_from_previous_fetch</strong><br/>... etc</span></pre><p id="0b5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它在数据库查询级别看起来如何</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="4a0c" class="nn mm in nj b gy no np l nq nr"><strong class="nj io">SELECT</strong><br/>    *<br/><strong class="nj io">FROM</strong><br/>    payments<br/><strong class="nj io">WHERE</strong><br/>  Id &gt; 10<br/><strong class="nj io">LIMIT</strong> 20<!-- --> </span></pre><p id="e42f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者下降</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="eda8" class="nn mm in nj b gy no np l nq nr"><strong class="nj io">SELECT</strong><br/>    *<br/><strong class="nj io">FROM</strong><br/>    payments<br/><strong class="nj io">WHERE</strong><br/>  Id &lt; 100<br/><strong class="nj io">ORDER</strong> <strong class="nj io">BY</strong> Id <strong class="nj io">DESC</strong><br/><strong class="nj io">LIMIT</strong> 20</span></pre><p id="43d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">基准测试结果</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Benchmark Result using Go for AutoIncrement pagination</figcaption></figure><p id="396b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的缺点</strong></p><ul class=""><li id="c170" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">这种分页方法的唯一缺点是，当使用自动递增的id时，在微服务和分布式系统中会有问题。<br/>带有<code class="fe of og oh nj b"><strong class="kv io">20</strong></code>的相似id可以存在于服务支付和服务用户中。它在相同的应用程序上下文中是唯一的。如果每个ID都使用UUID，那就不一样了，它是“<em class="lp">实际上唯一的”</em>(这意味着重复生成UUID的可能性非常小)。所以有些人试图用UUID来代替PK。点击阅读关于UUID和自动增量键<a class="ae ks" href="https://medium.com/@Mareks_082/auto-increment-keys-vs-uuid-a74d81f7476a" rel="noopener">的更多详情</a></li></ul><p id="f496" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的好处</strong></p><ul class=""><li id="5f53" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">易于实现，不需要在服务器中做复杂的逻辑事情。</li><li id="29b5" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">据我所知，最好的分页方式是使用自动增量ID，这样性能更好。</li></ul></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h2 id="8d38" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">4.结合创建时间戳的UUID分页</h2><p id="4c62" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">我不确定这是否很常见，但是我看到一些文章做了这种分页。上下文是该表没有使用自动增量id，而是使用UUID。但是，人们想知道如何进行分页，添加一个自动递增编号的新列是一种资源浪费。所以对我自己来说，我所做的是，使用我的行的创建的时间戳，并将其与PK相结合，这就是UUID。</p><p id="c76f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是数据库模式</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">payment.sql schema with UUID and timestamp</figcaption></figure><p id="1c8d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了更快的查询，我用多个表做了一个索引，这是PK和创建的时间戳；从上面的模式可以看出，我做了一个名为<code class="fe of og oh nj b">idx_payment_pagination</code>的索引。</p><p id="14ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以逻辑是，</p><ul class=""><li id="9f9e" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">我将使用UUID，它是我的主键，并将它与<code class="fe of og oh nj b">create </code>时间戳结合起来</li><li id="400f" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">把这两个组合成一个字符串，然后我把它编码成一个base64字符串</li><li id="1145" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">并将编码后字符串作为下一页的光标返回，这样用户就可以使用它来获取他们请求的下一页。</li></ul><p id="ece4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我如何在应用程序级别上制作光标的示例</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a23a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是它在REST端点中的样子。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="e0df" class="nn mm in nj b gy no np l nq nr">GET /payments?<strong class="nj io">limit=10</strong><br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=base64_string_from_previous_result</strong><br/>GET /payments?<strong class="nj io">limit=10&amp;cursor=base64_string_from_previous_result</strong><br/>... etc</span></pre><p id="668f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是在数据库中，查询看起来像这样，</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="905d" class="nn mm in nj b gy no np l nq nr"><strong class="nj io">SELECT</strong> *<br/><strong class="nj io">FROM</strong> payments<br/><strong class="nj io">WHERE</strong> created_time &lt;= '2020-05-16 03:15:06'  // created timestamp<br/><strong class="nj io">AND</strong> id &lt; '2a1aa856-ad26-4760-9bd9-b2fe1c1ca5aa'  // this is UUID<br/><strong class="nj io">ORDER BY </strong>created_time <strong class="nj io">DESC</strong>, id <strong class="nj io">DESC</strong><br/><strong class="nj io">LIMIT</strong> 2</span></pre><p id="245f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">基准测试结果</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Benchmark Result using Go for Keyset pagination</figcaption></figure><p id="81b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的缺点</strong></p><ul class=""><li id="c178" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">性能可能不会像使用自动增量id那样最佳。但是即使我们有数百万的数据，这也是一致的</li><li id="9f45" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">非常复杂和高级，我们需要理解索引，因为如果我们不添加索引，这个查询在一个大数据集上会非常耗时。此外，我们在处理时间戳时需要小心。即使这样，我在查询时间戳时仍然会遇到一些问题。</li></ul><p id="5153" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这种分页方法的好处</strong></p><ul class=""><li id="f077" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">ID是UUID，因此它在组织的微服务中几乎是全球唯一的。</li><li id="e5f5" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">从开始到查询数据的最后一页，性能是一致的</li></ul></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="11b2" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">结论</h1><p id="e0dd" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">好吧，在做了所有的基准测试后，我得出了一些结论。</p><h2 id="83f6" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">1.性能:从快到慢</h2><p id="7d01" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">从基准测试结果来看(使用Golang基准测试工具)，速度更快的是使用autoincrement PK。见下图；以纳秒为单位的每个操作所需的平均时间的图表越小越快。这个图表可能不是一个很好的代表，如果我把它放在第95、97等百分位，应该会更好，但我是从基准测试结果中得到这个值的。所以我认为这已经足够好了。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5047" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">带有自动增量ID的分页速度更快，其次是UUID/创建时间、页码和LimitOffset。这只是10万行数据。随着数据的增长，它也会变得更大。因此，在只有100K数据的情况下，即使仍不到1秒，与极限偏移相比，使用自动增量时的差异已经很大。</p><h2 id="2e45" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">2.发展:从快到慢</h2><p id="1118" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">实施难度由易到难</p><ul class=""><li id="06ff" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><strong class="kv io">使用Offset </strong>，因为我们只是将Offset和limit直接传递给数据库。</li><li id="34cc" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">使用页码</strong>，这是自以为是；有些人可能有不同的逻辑，但对于我来说，我把这个放在前两个。</li><li id="32ef" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">使用自动增量ID </strong></li><li id="c326" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">使用带有创建时间的UUID</strong></li></ul><h2 id="a06d" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">代码工件</h2><p id="0381" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">对于代码，我已经把它推到了我的GitHub库，可以在这里找到，<a class="ae ks" href="https://github.com/bxcodec/go-postgres-pagination-example" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/go-postgres-pagination-example</a></p><h2 id="6232" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">我在做这件事时面临的问题是</h2><p id="dbab" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">在做所有这些事情的时候，显然我会面临一些问题，但是我已经解决了它们，我也了解了它们。我写了我在这里学到的东西，也写在了本文中:<a class="ae ks" href="https://medium.com/easyread/til-becareful-on-postgres-query-for-less-than-or-equal-on-timestamp-9e486b657fc" rel="noopener"> TIL:小心Postgres查询，for Less Or Equal on Timestamp</a></p><h2 id="9701" class="nn mm in bd mn ns nt dn mr nu nv dp mv lc nw nx mx lg ny nz mz lk oa ob nb oc bi translated">作者建议</h2><p id="df2d" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">作为一名软件工程师，同时也是这篇文章的作者，我建议在做分页的时候使用autoincrement ID，但是如果你的系统或者你不想使用autoincrement ID作为PK，你可以考虑使用keyset分页；在我的例子中，使用UUID +创建时间时间戳。</p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="7a99" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">参考</h1><ol class=""><li id="b210" class="lq lr in kv b kw nd kz ne lc oi lg oj lk ok lo ol lw lx ly bi translated">大量的Stackoverflow答案，我忘了是哪一个，但是所有的答案都与Postgres的分页相关。</li><li id="7db1" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo ol lw lx ly bi translated">【jOOQ使用Seek方法实现更快的SQL分页</li><li id="0d27" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo ol lw lx ly bi translated"><a class="ae ks" href="https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/" rel="noopener ugc nofollow" target="_blank"> REST API设计:过滤、排序、分页</a></li></ol></div></div>    
</body>
</html>