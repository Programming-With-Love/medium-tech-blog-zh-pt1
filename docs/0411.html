<html>
<head>
<title>Collections and sequences in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林中的集合和序列</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/collections-and-sequences-in-kotlin-55db18283aca?source=collection_archive---------0-----------------------#2019-07-24">https://medium.com/androiddevelopers/collections-and-sequences-in-kotlin-55db18283aca?source=collection_archive---------0-----------------------#2019-07-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/9ba06927c89a1359b18d24bf055b14b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKfqCRN80uIePQ2_BsZB5w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Collections vs sequences</figcaption></figure><div class=""/><p id="baae" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用集合是一项常见的任务，Kotlin标准库提供了许多非常有用的功能。它还提供了两种<strong class="iv hx"> <em class="jr">方式</em> </strong>来处理集合，基于它们是如何被评估的:<strong class="iv hx">急切地</strong>——用<code class="du js jt ju jv b"><a class="ae jw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" rel="noopener ugc nofollow" target="_blank">Collection</a></code> <a class="ae jw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" rel="noopener ugc nofollow" target="_blank"> s </a>，和<strong class="iv hx">懒散地</strong>——用<code class="du js jt ju jv b"><a class="ae jw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html" rel="noopener ugc nofollow" target="_blank">Sequence</a></code> <a class="ae jw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html" rel="noopener ugc nofollow" target="_blank"> s </a>。请继续阅读，了解这两者之间的区别，您应该在何时使用哪一种，以及它们各自的性能含义。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="29b7" class="ke kf hw bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">集合与序列</h1><p id="589a" class="pw-post-body-paragraph it iu hw iv b iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm lg jo jp jq ha bi translated">急切求值和懒惰求值的区别在于<em class="jr">何时对集合执行</em>每个转换。</p><p id="dbbf" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">集合</strong>被<em class="jr">急切地</em>评估——每个操作在被调用时被执行，操作的结果被存储在一个新的集合中。集合上的转换是<a class="ae jw" href="https://kotlinlang.org/docs/reference/inline-functions.html" rel="noopener ugc nofollow" target="_blank">内联函数</a>。例如，看看<code class="du js jt ju jv b"><a class="ae jw" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/common/src/generated/_Collections.kt#L1312" rel="noopener ugc nofollow" target="_blank">map</a></code>是如何实现的，我们可以看到它是一个<code class="du js jt ju jv b">inline</code>函数，它创建了一个新的<code class="du js jt ju jv b">ArrayList</code>:</p><pre class="lh li lj lk fd ll jv lm ln aw lo bi"><span id="f27d" class="lp kf hw jv b fi lq lr l ls lt">public <strong class="jv hx">inline</strong> fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {<br/>  return mapTo(<strong class="jv hx">ArrayList</strong>&lt;R&gt;(collectionSizeOrDefault(10)), transform)<br/>}</span></pre><p id="d2d7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">序列</strong>被<em class="jr">延迟</em>评估。它们有两种操作:<strong class="iv hx">中间</strong>和<strong class="iv hx">终端</strong>。中间操作不在现场进行；它们只是被储存起来。只有当一个终端操作被调用时，中间操作才会在一行中的每个元素上被触发<strong class="iv hx">，最终应用终端操作。中间操作(如<code class="du js jt ju jv b">map</code>、<code class="du js jt ju jv b">distinct</code>、<code class="du js jt ju jv b">groupBy</code>等)返回另一个序列，而终端操作(如<code class="du js jt ju jv b">first</code>、<code class="du js jt ju jv b">toList</code>、<code class="du js jt ju jv b">count</code>等)不返回。</strong></p><p id="f223" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">序列不包含对集合项目的引用。它们是基于原始集合的迭代器创建的，并保存对所有需要执行的中间操作的引用。</p><p id="5aea" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">与集合上的转换不同，序列上的中间转换不是内联函数—内联函数不能存储，序列需要存储它们。看看像<code class="du js jt ju jv b"><a class="ae jw" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/common/src/generated/_Sequences.kt#L860" rel="noopener ugc nofollow" target="_blank">map</a></code>这样的中间操作是如何实现的，我们可以看到转换函数保存在一个<code class="du js jt ju jv b">Sequence</code>的新实例中:</p><pre class="lh li lj lk fd ll jv lm ln aw lo bi"><span id="3f77" class="lp kf hw jv b fi lq lr l ls lt">public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt;{      <br/>   return <strong class="jv hx">TransformingSequence</strong>(this, transform)<br/>}</span></pre><p id="5625" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像<code class="du js jt ju jv b"><a class="ae jw" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/common/src/generated/_Sequences.kt#L117" rel="noopener ugc nofollow" target="_blank">first</a></code>这样的终结操作遍历序列的元素，直到谓词条件匹配。</p><pre class="lh li lj lk fd ll jv lm ln aw lo bi"><span id="abe2" class="lp kf hw jv b fi lq lr l ls lt">public inline fun &lt;T&gt; Sequence&lt;T&gt;.first(predicate: (T) -&gt; Boolean): T {<br/>   for (element in this) if (predicate(element)) return element<br/>   throw NoSuchElementException(“Sequence contains no element matching the predicate.”)<br/>}</span></pre><p id="bc1b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们看看像<code class="du js jt ju jv b"><a class="ae jw" href="http://transformingsequence" rel="noopener ugc nofollow" target="_blank">TransformingSequence</a></code>(在上面的<code class="du js jt ju jv b">map</code>中使用)这样的序列是如何实现的，我们将会看到当在序列迭代器上调用next时，存储的转换也被应用。</p><pre class="lh li lj lk fd ll jv lm ln aw lo bi"><span id="20c1" class="lp kf hw jv b fi lq lr l ls lt">internal class TransformingIndexedSequence&lt;T, R&gt; <br/>constructor(private val sequence: Sequence&lt;T&gt;, private val <strong class="jv hx">transformer</strong>: (Int, T) -&gt; R) : Sequence&lt;R&gt; {</span><span id="5c70" class="lp kf hw jv b fi lu lr l ls lt">override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; {<br/>   …<br/>   override fun <strong class="jv hx">next()</strong>: R {<br/>     return <strong class="jv hx">transformer</strong>(checkIndexOverflow(index++), iterator.next())<br/>   }<br/>   …<br/>}</span></pre><p id="4ee5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不管您使用的是集合还是序列，Kotlin标准库都为两者提供了相当广泛的操作，比如<code class="du js jt ju jv b">find</code>、<code class="du js jt ju jv b">filter</code>、<code class="du js jt ju jv b">groupBy</code>等等。在实现你自己的版本之前，确保你已经检查过了。</p><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/bee6686c43ae3d0b94ed5c6a74bc3d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cW3fdJErm_N2hIUp"/></div></div></figure><h1 id="da34" class="ke kf hw bd kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ma kz la lb bi translated">集合和序列</h1><p id="0141" class="pw-post-body-paragraph it iu hw iv b iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm lg jo jp jq ha bi translated">假设我们有一个不同形状的物体列表。我们想把形状变成黄色，然后取第一个正方形。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Collections vs sequences</figcaption></figure><p id="9762" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们看看每个操作如何、何时应用于集合，何时应用于序列</p><h2 id="4d90" class="lp kf hw bd kg md me mf kk mg mh mi ko je mj mk ks ji ml mm kw jm mn mo la mp bi translated">收集</h2><ul class=""><li id="25ee" class="mq mr hw iv b iw lc ja ld je ms ji mt jm mu jq mv mw mx my bi translated">调用——创建一个新的数组列表。我们遍历初始集合的所有项目，通过复制原始对象并更改颜色来转换它，然后将其添加到新列表中。</li><li id="2dce" class="mq mr hw iv b iw mz ja na je nb ji nc jm nd jq mv mw mx my bi translated"><code class="du js jt ju jv b">first</code>被调用——我们遍历每一项，直到找到第一个方块</li></ul><h2 id="64f7" class="lp kf hw bd kg md me mf kk mg mh mi ko je mj mk ks ji ml mm kw jm mn mo la mp bi translated">顺序</h2><ul class=""><li id="79e4" class="mq mr hw iv b iw lc ja ld je ms ji mt jm mu jq mv mw mx my bi translated"><code class="du js jt ju jv b">asSequence</code> —基于原始集合的迭代器创建序列</li><li id="2868" class="mq mr hw iv b iw mz ja na je nb ji nc jm nd jq mv mw mx my bi translated"><code class="du js jt ju jv b">map</code>被调用—转换被添加到序列需要执行的操作列表中，但操作<strong class="iv hx">未执行</strong></li><li id="22ff" class="mq mr hw iv b iw mz ja na je nb ji nc jm nd jq mv mw mx my bi translated"><code class="du js jt ju jv b">first</code>被调用——这是一个终端操作，因此，所有的中间操作都在集合的每个元素上被触发。我们应用map遍历初始集合，然后首先遍历每个集合。因为第二个元素满足第一个元素的条件，所以我们不再对集合的其余部分应用映射。</li></ul><p id="87c4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当处理序列时，不会创建中间集合，因为项目是逐个评估的，所以只对某些输入执行映射。</p><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ne"><img src="../Images/b55c90e3d4d8daa2dd71c423814d0df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hdSVv06ug45AzTTr"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Collections vs sequences — eager vs lazy evaluation</figcaption></figure><h1 id="a74d" class="ke kf hw bd kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ma kz la lb bi translated">表演</h1><h2 id="7f5e" class="lp kf hw bd kg md me mf kk mg mh mi ko je mj mk ks ji ml mm kw jm mn mo la mp bi translated">变换的顺序</h2><p id="cbc8" class="pw-post-body-paragraph it iu hw iv b iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm lg jo jp jq ha bi translated">不管您使用的是集合还是序列，转换的顺序都很重要。在上面的例子中，<code class="du js jt ju jv b">first</code>不需要发生在<code class="du js jt ju jv b">map</code>之后，因为它不是<code class="du js jt ju jv b">map</code>转换的结果。如果我们颠倒业务逻辑的顺序，首先调用集合，然后转换结果，那么我们只创建一个新对象—黄色方块。当使用序列时——我们避免创建两个新对象，当使用集合时，我们避免创建一个全新的列表。</p><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/ccb2302b616bd72bd491167c894b4c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F4tikgy89TZZnUWP"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Order of transformations matters — avoid unnecessary work</figcaption></figure><p id="7a4c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因为终端操作可以提前完成处理，而中间操作是延迟计算的，所以在某些情况下，与集合相比，序列可以帮助您避免不必要的工作。确保您总是检查转换的顺序以及它们之间的依赖关系！</p><h2 id="98b8" class="lp kf hw bd kg md me mf kk mg mh mi ko je mj mk ks ji ml mm kw jm mn mo la mp bi translated">内联和大型数据集的后果</h2><p id="04bd" class="pw-post-body-paragraph it iu hw iv b iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm lg jo jp jq ha bi translated">集合操作使用内联函数，因此操作的字节码以及传递给它的lambda的字节码将被内联。序列不使用内联函数，因此，为每个操作创建新的<code class="du js jt ju jv b">Function</code>对象。</p><p id="8609" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一方面，集合为每个转换创建一个新的列表，而序列只保留一个对转换函数的引用。</p><p id="ea24" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当使用1-2个操作符的<strong class="iv hx">小集合</strong>时，这些差异没有太大的影响，所以使用<strong class="iv hx">集合</strong>应该没问题。但是，当使用<strong class="iv hx">大型列表</strong>时，中间集合的创建会变得很昂贵；在这种情况下，使用<strong class="iv hx">序列</strong>。</p><p id="69e2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不幸的是，我不知道有任何基准测试研究可以帮助我们更好地理解不同大小的集合或操作链如何影响集合与序列的性能。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><p id="3fe2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">集合急切地评估您的数据，而序列则懒洋洋地这样做。根据数据的大小，选择一个最合适的:集合——对于小的列表或序列——对于大的列表或序列，并注意转换的顺序。</p></div></div>    
</body>
</html>