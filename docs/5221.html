<html>
<head>
<title>Scheduled Events and Queue Processing— Mendix and Me</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预定事件和队列处理— Mendix和我</h1>
<blockquote>原文：<a href="https://medium.com/mendix/scheduled-events-and-queue-processing-mendix-and-me-16e9bd3776b3?source=collection_archive---------0-----------------------#2022-12-23">https://medium.com/mendix/scheduled-events-and-queue-processing-mendix-and-me-16e9bd3776b3?source=collection_archive---------0-----------------------#2022-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="aaa7" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">好吧，这种情况不常出现。然而，当它发生时，它可能会产生有问题的后果。如果它发生在生产环境中，可能会导致生产环境停止。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0835d3b614dd0a49b97a93dd71b8d33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYIDkQ6fYSI9VcJ8WDHMog.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Scheduled Events and Queue Processing — Mendix and Me</figcaption></figure><h2 id="6663" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">用例</strong></h2><p id="86be" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">在队列中运行进程(在Mendix中，我在下面使用术语queue来表示各种队列。我用它来指代进程队列和任务队列)是非常有用的东西。一方面，您可以将长时间运行的流程移至后台，为用户提供更流畅的体验；另一方面，您可以创建批处理，将大型操作(数据迁移、定期同步等)拆分为小型工作包。这样，您可以确保事务不会变得太大(这会导致系统崩溃)。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lp"><img src="../Images/eb3a34f70ca44560a99269ae61fb4435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqX8dZoGdHtZaEc_3iVmBA.png"/></div></div></figure><h2 id="544a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">这和预定事件有什么关系？</strong></h2><p id="cffc" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">我遇到过好几次的一个具体用例是定期在后台运行的数据同步。我们的应用程序需要以一定的时间间隔从API中检索数据，然后在本地处理它。由于上面提到的原因，这个处理应该在工作包中完成。如果您已经处理过队列，解决方案是显而易见的。预定事件以固定的时间间隔从API中检索数据，创建工作包，然后在队列中处理它们。</p><p id="a233" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">这可能是最终的解决方案，没有什么你应该做“不同”。预定事件的典型微流如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/e783423cb2f3b7fb638c88421ad75194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pqniLF9RqWE0cAgA.png"/></div></div></figure><p id="f954" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">首先，我们导入数据，然后我们创建工作包，最后我们在队列中执行它们的处理。</p><h2 id="bafe" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">但是你为什么要写一篇关于它的博客文章呢？</strong></h2><p id="9e6a" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">好吧，是什么让一个预定事件发生，也是什么让一个预定事件发生问题:它周期性地重复。</p><p id="7a51" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">这通常正是我们想要用预定事件创建的行为。它应该每X秒/分钟/小时/天/…运行一次。但是，如果预定事件的执行时间比它被执行的时间长，该怎么办呢？</p><h2 id="e171" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">标准案例</strong></h2><p id="fa67" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">当然，Mendix已经考虑到了上述问题，并建立了一种机制来解决这个问题。当您创建计划事件时，您可以定义它在这种情况下的行为。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lw"><img src="../Images/3b1aa707a6d69ed54dc3a8a7f58e7eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EmWjutUkArHsfJFl.png"/></div></div></figure><blockquote class="lx"><p id="250b" class="ly lz hu bd ma mb mc md me mf mg lo ek translated">“On overlap”设置允许我们定义当执行时间超过周期时事件应该如何表现。您可以选择是跳过还是延迟事件的下一次执行。</p></blockquote><p id="c72a" class="pw-post-body-paragraph kx ky hu bd b kz mh iv lb lc mi iy le kk mj lg lh ko mk lj lk ks ml lm ln lo hn dt translated">如果选择“跳过下一个”，则在当前事件执行完毕之前，不会执行任何事件。之后继续正常周期。如果选择延迟，以下执行将被延迟。它们被放入一种队列中，并在第一次执行完成后立即被处理(这也有一定的风险，但这不是这里的重点)。</p><h2 id="136d" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">现在排队怎么办？</strong></h2><p id="bde3" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">如果工作包是在预定的事件中创建的，并且在队列中被处理，那么事件就不可能知道是否所有的事情都已经被处理了。它只能决定工作包的创建是否已经完成。如果现在包的实际处理时间比事件的两次执行之间的时间长，那么每次执行都会有越来越多的工作包被放入队列。大量的工作不断增加，从未得到处理。</p><p id="5187" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">使用默认的计划事件配置无法解决此问题。是的，你可以选择一个更长的时期作为预防措施。但是首先事情并不总是可预测的，用户可能希望数据尽快同步。</p><h2 id="069a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">该怎么办？</strong></h2><p id="e6fc" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">为了避免上面提到的问题，我们需要手动重新创建微流中预定事件通常自动执行的操作。我们必须查明前一次执行是否已经完成。为此，我们给批处理对象一个属性，作为处理是否已经完成的指示器。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/50931031cd19e37d2b0e91e738a39292.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/0*L8uofea7TyvfVQfK.png"/></div></figure><p id="626e" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">在其最简单的形式中，这只是一个布尔属性。当创建批处理时，属性被设置为false，在处理完成后，我们将其设置为true。对于上面给出的微流程，我们引入了一个数据库查询来检查是否还有未执行的批处理。整个事情看起来是这样的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/6da5ccf2059ecfe6ed23e6893d5c2ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BfW7bTT5jeWUy0JW.png"/></div></div></figure><p id="106a" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">我们首先统计是否还有批次没有处理。如果没有剩余的，我们执行第一个例子中使用的微流。在队列的实际执行中，我们当然要设置Finished属性。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/4c80be4978ba2b006f1ed7812c4f52d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ese0AwDv5Uv21Pz3.png"/></div></div></figure><p id="f3c0" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">现在，我们已经以一种非常简单的方式重新创建了用于队列的“跳过下一个”行为，并且不再冒由于事件执行过于频繁而使队列溢出的风险。</p><h2 id="ddb7" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">但是“延迟下一个”呢？</strong></h2><p id="d514" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">即使我建议在大多数情况下不要使用Delay next，为了完整起见，我还是想引入一个Delay Next变体。为此，我们必须在预定事件微流中构建一个循环，在这个循环中，我们一次又一次地检查前面的处理是否完成。我强烈建议使用延迟，因为否则数据库查询会一个接一个地执行，直到出现期望的结果。这会给系统带来巨大的负担。在<a class="ae mn" href="https://marketplace.mendix.com/link/component/170" rel="noopener ugc nofollow" target="_blank">社区Commons </a>中，有一个名为Delay的Java动作为我们做了这件事。它让系统等待。</p><p id="a312" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">有了这个延迟和循环，我们的事件微流现在看起来像这样:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lv"><img src="../Images/3e26eb60c9bec1e74c74f0a4a9a30d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e-br4dVq7yCIuh4E.png"/></div></div></figure><p id="8da1" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">不是中止执行，而是一次又一次地检查数据库，直到没有尚未处理的批处理。一旦出现这种情况，就会执行事件的实际逻辑。因此，事件的两种行为都可以用简单的方法扩展到队列，我们可以防止队列由于太多的事件执行而过载</p><p id="56d6" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">当然，你不需要在每个事件中都这样。这是一个小特例。但是，每当您非常频繁地运行一个事件并且可能处理大量数据时，您应该考虑实现这样一种机制。它可以很快实施，可能会让你远离严重的问题。</p><p id="ab4e" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">我希望这是一个有趣的或其他的。一如既往，我很高兴收到反馈和评论。</p></div><div class="ab cl mo mp hb mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><p id="8155" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated"><em class="mv">原文于2022年12月23日在</em> <a class="ae mn" href="https://mendixandme.de/index.php/2022/12/23/scheduled-events-und-queue-prozesse/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">用德语发表https://mendixamme . de</em></a><em class="mv">。</em></p><h2 id="674a" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">阅读更多</h2><div class="mw mx fm fo my mz"><a href="https://docs.mendix.com/refguide/scheduled-events/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">预定事件</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">配置计划事件的选项</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="mw mx fm fo my mz"><a href="https://docs.mendix.com/refguide/task-queue/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">任务排队</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">任务队列的概念和用法</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="mw mx fm fo my mz"><a href="https://docs.mendix.com/refguide/retrieve/#332-range" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">恢复</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">这种活性可用于微流和纳流。1简介检索活动可用于获取一个…</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">docs.mendix.com</p></div></div></div></a></div></div><div class="ab cl mo mp hb mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><p id="098c" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated"><em class="mv">来自发布者- </em></p><p id="81f9" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated"><em class="mv">如果你喜欢这篇文章，你可以在我们的</em> <a class="ae mn" href="https://medium.com/mendix" rel="noopener"> <em class="mv">中页</em> </a> <em class="mv">找到更多喜欢的。对于精彩的视频和直播会话，您可以前往</em><a class="ae mn" href="https://www.mendix.com/live/" rel="noopener ugc nofollow" target="_blank"><em class="mv">MxLive</em></a><em class="mv">或我们的社区</em><a class="ae mn" href="https://www.youtube.com/c/MendixCommunity/community" rel="noopener ugc nofollow" target="_blank"><em class="mv">Youtube PAG</em></a><em class="mv">e .</em></p><p id="e9bc" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated"><em class="mv">希望入门的创客，可以注册一个</em> <a class="ae mn" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="mv">免费账号</em> </a> <em class="mv">，通过我们的</em> <a class="ae mn" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="mv">学苑</em> </a> <em class="mv">获得即时学习。</em></p><p id="7721" class="pw-post-body-paragraph kx ky hu bd b kz lq iv lb lc lr iy le kk ls lg lh ko lt lj lk ks lu lm ln lo hn dt translated">有兴趣更多地参与我们的社区吗？加入我们的 <a class="ae mn" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="mv"> Slack社区频道</em> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>