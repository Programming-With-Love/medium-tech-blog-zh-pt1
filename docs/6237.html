<html>
<head>
<title>GokuL: Extending time series data storage to serve beyond one day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GokuL:将时间序列数据存储扩展到一天以上</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/gokul-extending-time-series-data-storage-to-serve-beyond-one-day-52264307364d?source=collection_archive---------2-----------------------#2019-12-12">https://medium.com/pinterest-engineering/gokul-extending-time-series-data-storage-to-serve-beyond-one-day-52264307364d?source=collection_archive---------2-----------------------#2019-12-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6361" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">姜灏张睿，郭健莫尼勒·穆克什·桑哈维|实时分析团队</p><p id="3d87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，开发人员严重依赖Statsboard来监控他们的系统，并在问题发生时得到提醒。去年，我们<a class="ae jc" rel="noopener" href="/pinterest-engineering/goku-building-a-scalable-and-high-performant-time-series-database-system-a8ff5758a181">推出了我们的时间序列数据库</a>(又名悟空)，它存储并提供最近一天的数据。尽管这涵盖了90%以上的查询，但仍有开发人员希望查询一天之外的数据的情况(如周与周的比较、年度容量规划或调查几天或几周前的问题等。)</p><p id="3521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为回应，我们建立了GokuL——一个基于磁盘的Goku版本，用于长期数据。GokuL用C++编写，使用RocksDB作为存储引擎，高效支持一天以上的查询。</p><h1 id="b08e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">GokuL的新特性</h1><h2 id="ee6f" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">数据汇总</h2><p id="6fdb" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">汇总是使用一个聚合器将特定时间间隔内的多个数据点转换为一个数据点的过程。例如，假设我们有10个数据点(0，1)、(60，2)、(120，3)、(180，4)、(240，5)、(300，6)、(360，7)、(420，8)、(480，9)、(540，10)，我们希望以5分钟的时间间隔进行汇总，并对聚合器求和。汇总后的数据点变为(0，15)，(300，40)。</p><p id="34a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然原始数据是最准确的，但它在资源和存储方面成本很高，并且查询速度很慢。从更长的时间跨度来看，数据的时间粒度越粗越好，但是您希望以更低的成本实现更快的查询体验。我们在GokuL中引入了内置的roll up支持作为我们的解决方案。数据越老，时间粒度就越粗，所以我们在GokuL中设置了可配置的时间粒度。以下是我们在Pinterest中使用的设置:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/fc37c5dccab6fe302c366ed9928cbb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjayfNz9aLuXBx-I_QhONw.png"/></div></div></figure><p id="ec2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果开发人员在某些情况下喜欢原始数据，比如周与周之间的比较，我们仍然保留24天的原始数据。</p><p id="8f13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在查询GokuL时，客户端需要在查询中设置<strong class="ig hi"> rollupAggregator </strong>和<strong class="ig hi"> rollupInterval </strong>，以获取相应的汇总数据。</p><h2 id="60e9" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">体系结构</h2><p id="1a6d" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">整个悟空生态系统如下图所示:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lg"><img src="../Images/278e7b7acf12cf868fa961a630a07942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mg9C9RJpgC5c_WDk"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lh"><img src="../Images/0750c3a44f339d9ea71d54450cd9dffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lAf3sKZsZfmA9plk"/></div></div></figure><h2 id="243a" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">分层数据</h2><p id="cc49" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">悟空中的数据被分成多个桶，每个桶的长度为两个小时。要读取的桶取决于时间范围。在GokuL中，除了数据存储，我们还引入了另一个概念——层。在一个层中，数据被划分到存储桶中，但是不同的层可能具有不同的存储桶大小。对于分层数据，我们引入了一种称为压缩的新流程，将较低层的多个存储桶合并到较高层的一个存储桶中。压实过程中也会发生卷起。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es li"><img src="../Images/dc66cef4b5e792dcd01afd44ede00ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*HN7hpliD5SjyURLFT7B7tg.png"/></div></figure><p id="dd14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可用的层设置如下，并且都可以调整。</p><ol class=""><li id="96a9" class="lj lk hh ig b ih ii il im ip ll it lm ix ln jb lo lp lq lr bi translated">桶大小(秒)</li><li id="dd1c" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">以秒为单位的汇总间隔</li><li id="d7cd" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">是否在该层保留原始数据</li><li id="d533" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">需要合并到下一层的存储桶数量</li><li id="5a60" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">保留在该层中的存储桶数量</li></ol><h2 id="754c" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">悟空压缩机服务</h2><p id="0cd5" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">为了进行压缩，我们开发了另一个名为Goku Compactor的服务。对于第0层的压缩，该服务从EFS自动气象站下载短期悟空数据，合并到第1层存储桶并上传到S3。对于其他层的压缩，该服务从S3下载，压缩后上传到S3。通过将数据压缩与在线服务分离，压缩可以充分利用资源，但不会影响在线服务性能。</p><p id="628a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">压缩使用大量CPU和内存。为了保护悟空压缩机，我们使用两个线程池。一个池有更多的线程用于轻量级压缩，另一个池有更少的线程用于重量级压缩。</p><p id="f3e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为压缩不会一直运行，所以我们使用自动缩放来最小化成本。</p><p id="c7c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在压缩过程中，Goku Compactor会生成sst文件，然后由GokuL使用。</p><h2 id="1983" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">RocksDB关键和价值设计</h2><p id="bb76" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">生成的sst文件中有三种类型的数据:a .字典；b .时间序列数据；倒排索引。我们为每个碎片和桶生成这些数据。</p><p id="1bff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于每个指标名称、标记键和标记值，我们将为其分配一个唯一的4字节id。例如，如果我们有以下时间序列:</p><p id="f71e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="lx">TC . proc . stat . CPU . total { host = host 1，host _ type = infra-Goku-a-prod }</em>T3】</strong></p><p id="1c1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">T5】TC . proc . stat . CPU . total { host = host 2，host _ type = infra-Goku-d-prod }</strong></p><p id="1f36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lx">鸵鸟. metrics . Goku . ms _ short _ query _ root . p90 { host = host 1，host _ type = infra-Goku-a-prod }</em></strong></p><p id="55b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">生成的字典将是:</p><p id="180a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">TC . proc . stat . CPU . total =&gt;1</em></p><p id="da74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">鸵鸟. metrics . Goku . ms _ short _ query _ root . p90 =&gt;2</em></p><p id="0415" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">主机= &gt; 3 </em></p><p id="7d53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">主机1 = &gt; 4 </em></p><p id="9152" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx"> host_type = &gt; 5 </em></p><p id="8a3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">infra-Goku-a-prod = 6</p><p id="1573" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">主机2 = &gt; 7 </em></p><p id="6ed3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">infra-goku-d-prod = &gt; 8 </p><p id="d3bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于不同的目的，我们在RocksDB中存储了word到id的映射和反向映射。</p><p id="2965" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像小悟空一样，我们用<a class="ae jc" href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf" rel="noopener ugc nofollow" target="_blank">大猩猩</a>编码对时间序列数据进行编码。关键字的格式为<em class="lx">【汇总聚集器类型】【指标名称字典id】【时间序列id】</em>。汇总聚合器类型是1字节的聚合器枚举。对于原始数据，聚合器设置为None。时序id是一个4字节的整数，范围从0到指标名称的基数。</p><p id="7460" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">倒排索引键的格式为[ <em class="lx">度量名字典id </em> ][ <em class="lx">标记键字典id </em> ][ <em class="lx">标记值字典id(可选)</em> ]。这些值是编码的时间序列id，用在具有相同指标名称字典id的数据关键字中。我们使用本<a class="ae jc" href="http://static.googleusercontent.com/media/research.google.com/en//people/jeff/WSDM09-keynote.pdf" rel="noopener ugc nofollow" target="_blank">主题演讲</a>中提到的Group Varint编码算法。当只有标签键id时，索引键用于有效地应用通配符过滤器(例如，<em class="lx"> host=* </em>)。</p><p id="08ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们的数据是分层和分桶的，所以在生成这些键时，我们将<em class="lx">【magic(1字节)】【tier(1字节)】【bucket(4字节)】</em>添加到每个RocksDB键的前面。幻数是一个字节，用来标识不同类型的密钥。</p><h2 id="7a48" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">数据保持</h2><p id="6e5e" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">如前所述，我们为汇总数据设置TTL，并为不同的层设置不同的TTL。</p><p id="55a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现这个目标，我们实现了一个RocksDB <a class="ae jc" href="https://github.com/facebook/rocksdb/wiki/Compaction-Filter" rel="noopener ugc nofollow" target="_blank">压缩过滤器</a>。压缩过滤器用于根据每层的<em class="lx">保留的桶数</em>参数检查key中的桶是否过期。如果过期，该密钥将在压缩过程中被删除。</p><h2 id="5a07" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">集群管理</h2><p id="2dc9" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">GokuL在Goku中使用相同的两层分片策略来提供水平可伸缩性、并行聚合和限制查询扇出。</p><p id="7bc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Rocksplicator用于管理集群中的碎片。它通过自动碎片管理和恢复能力减少了我们的操作负载。(关于Rocksplicator的更多细节可以在<a class="ae jc" rel="noopener" href="/pinterest-engineering/open-sourcing-rocksplicator-a-real-time-rocksdb-data-replicator-558cd3847a9d">开源Rocksplicator，一个实时RocksDB数据复制器</a>和<a class="ae jc" rel="noopener" href="/pinterest-engineering/automated-cluster-management-and-recovery-for-rocksplicator-f1f8fd35c833">Rocksplicator的自动集群管理和恢复</a>中找到)</p><h2 id="1d8b" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">查询过程</h2><p id="30ce" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">GokuL使用与悟空相同的查询引擎。但是，我们在悟空根中重新实现了路由逻辑(见下图)。悟空根按照以下步骤处理查询。</p><ol class=""><li id="318f" class="lj lk hh ig b ih ii il im ip ll it lm ix ln jb lo lp lq lr bi translated">如果时间范围同时触及悟空和悟空，则将查询拆分为两个查询；</li><li id="fbfc" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">分别向相应的Goku和GokuL叶子发送查询，并对叶子进行聚合；</li><li id="f303" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">从树叶聚集结果并合并成一个查询结果</li></ol><p id="9d14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在内部，我们有两个悟空集群和两个悟空集群。如果一个叶查询失败，悟空根将故障转移到持有相同碎片的另一个集群的叶。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/52359def64e57319f8e501a108d49e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcNDTrxW7A51LT_CKx_T0w.png"/></div></div></figure><h2 id="248b" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">服务器保护</h2><p id="7c37" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">时间序列查询有时非常昂贵，并且当时间范围更大时会变得更糟。它们会占用过多的内存和cpu资源，使其他查询处于饥饿状态，并使进程崩溃。GokuL采用以下方法来保护自己。</p><p id="2543" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">流水线查询执行</strong></p><p id="5728" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们实现了流水线执行，逐批读取、解码和聚集数据。通过这样做，它能够在执行每个操作符后释放内存，从而将内存不足错误的风险降至最低。此外，通过在同一管道中并行化数据IO和计算，它可以更有效地使用CPU。</p><p id="7d4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">提前终止</strong></p><p id="613c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使使用流水线执行，一些查询也会导致cpu和内存使用量激增。例如，获取每个时间序列而不进行聚合的查询。这些查询有一些共同的特征:高基数或大量插值。目前，我们将终止一个查询，只要它达到两个阈值之一:a .基数限制；b .内存使用限制。</p><h2 id="d6c2" class="kb je hh bd jf kc kd ke jj kf kg kh jn ip ki kj jr it kk kl jv ix km kn jz ko bi translated">表演</h2><p id="c9b3" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们在OpenTSDB和GokuL上评估了一些不同时间范围的常见查询。以下是基准测试期间的一些设置。</p><p id="1a30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">硬件</strong></p><p id="6c7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OpenTSDB+h base:c 5.2x large+I 3.2x large</p><p id="10f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GokuL:3.2倍大</p><p id="8df7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">查询</strong></p><p id="1585" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">时间范围为2天、4天、7天和14天的查询。</p><p id="f80b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结果</strong></p><p id="a39c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GokuL比OpenTSDB快30-100倍，具体取决于查询。</p><h1 id="78f3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">下一步是什么</h1><p id="15ab" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><strong class="ig hi">分页支持</strong></p><p id="2866" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我们现有的服务器保护方法在大多数情况下工作良好，但我们失去了处理一些高基数和昂贵查询的能力。目前，我们需要要求用户重写他们的查询，或者我们必须调整阈值。</p><p id="f56a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了处理这些查询并且不使我们的系统崩溃，我们可以在时间尺度上进行分页。给定一个长范围的查询，我们可以返回一个子范围的结果和一个延续令牌给客户端。下一次，客户端向GokuL提供这个continuation token来获取下一个子范围的结果。</p><p id="d51d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过分页，不仅减轻了服务器的负载，也减轻了客户端的负载。因为客户端不需要在绘制图形之前等待所有数据就绪。相反，他们可以一部分一部分地画图。</p><p id="8b33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">查询缓存</strong></p><p id="b23d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在GokuL中执行查询很快，但是如果缓存了热查询数据结果，速度可能会更快。GokuL将像原始数据一样基于时间对缓存数据进行分区，这也可以使分页查询更快。我们的目标是使缓存层足够抽象，这样我们就可以很容易地采用不同的缓存系统，比如本地内存或memcached。</p><p id="c5c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">鸣谢:非常感谢visibility团队的Brian Overstreet、、Humsheen Geo、Dai Nguyen和Nomy Abbas帮助在Statsboard上推出GokuL，并感谢Serving Systems团队的、、、韩、帮助我们了解和采用Rocksplicator。</em></p><blockquote class="lz"><p id="1874" class="ma mb hh bd mc md me mf mg mh mi jb dx translated">我们正在建造世界上第一个视觉发现引擎。全球超过3.2亿人使用Pinterest来梦想、计划和准备他们在生活中想做的事情。来加入我们吧！</p></blockquote></div></div>    
</body>
</html>