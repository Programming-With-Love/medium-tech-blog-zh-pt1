<html>
<head>
<title>Elm II: Making a Todo List!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elm II:制作待办事项列表！</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/elm-ii-todo-list-redux-ed1aae2dabbd?source=collection_archive---------7-----------------------#2018-10-29">https://medium.com/quick-code/elm-ii-todo-list-redux-ed1aae2dabbd?source=collection_archive---------7-----------------------#2018-10-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ac24ca7ad56959e9a4781c0dd3dd5190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHwGSKa_TKaz2TJ-eMdcvg.png"/></div></div></figure><p id="d7a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上周我们学习了榆树的基本知识。Elm是一种可以用于前端web开发的函数式语言。它的语法非常接近Haskell。尽管正如我们所探索的，它缺少一些关键的语言特性。</p><p id="bc31" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本周，我们将制作一个简单的Todo List应用程序来展示Elm是如何工作的。我们将看到如何应用我们所学的基础知识，并进一步发展。</p><p id="37ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是没有后端前端也没多大用！看看我们的<a class="ae jn" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>来学习一些很酷的Haskell后端库！</p><h1 id="2613" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">待办事项类型</h1><p id="5605" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在我们开始之前，让我们定义我们的类型。我们将有一个基本的<code class="du kr ks kt ku b">Todo</code>类型，用一个字符串作为它的名字。我们还将为表单的状态创建一个类型。这包括我们的项目列表以及“待办事项”，包含以下形式的文本:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="cad9" class="ld jp hh ku b fi le lf l lg lh">module Types exposing<br/>  ( Todo(..)<br/>  , TodoListState(..)<br/>  , TodoListMessage(..)<br/>  )</span><span id="78f7" class="ld jp hh ku b fi li lf l lg lh">type Todo = Todo <br/>  { todoName : String }</span><span id="1e57" class="ld jp hh ku b fi li lf l lg lh">type TodoListState = TodoListState<br/>  { todoList : List Todo<br/>  , newTodo : Maybe Todo<br/>  }</span></pre><p id="86b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还想定义一个消息类型。这些是我们将从<code class="du kr ks kt ku b">view</code>发送的消息，用于更新我们的模型。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="144f" class="ld jp hh ku b fi le lf l lg lh">type TodoListMessage =<br/>  AddedTodo Todo |<br/>  FinishedTodo Todo |<br/>  UpdatedNewTodo (Maybe Todo)</span></pre><h1 id="8e63" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">榆树的建筑</h1><p id="cb9d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在让我们回顾一下Elm的架构是如何工作的。上周我们用<code class="du kr ks kt ku b">sandbox</code>函数描述了我们的程序。这个简单的函数有三个输入。它有一个初始状态(我们使用了一个基本的<code class="du kr ks kt ku b">Int</code>)、一个<code class="du kr ks kt ku b">update</code>函数和一个<code class="du kr ks kt ku b">view</code>函数。<code class="du kr ks kt ku b">update</code>函数接受一个<code class="du kr ks kt ku b">Message</code>和我们现有的模型，并返回更新后的模型。<code class="du kr ks kt ku b">view</code>函数获取我们的模型，并以HTML的形式呈现出来。视图的结果类型是<code class="du kr ks kt ku b">Html Message</code>。您应该将这种类型理解为“可以发送类型为<code class="du kr ks kt ku b">Message</code>的消息的渲染HTML”。这个表达式的结果类型是一个<code class="du kr ks kt ku b">Program</code>，由我们的模型和消息类型参数化。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="dd55" class="ld jp hh ku b fi le lf l lg lh">sandbox :<br/>  { init : model<br/>  , update : msg -&gt; model -&gt; model<br/>  , view : model -&gt; Html msg<br/>  }<br/>  -&gt; Program () model msg</span></pre><p id="6bc7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<code class="du kr ks kt ku b">sandbox</code>程序虽然不允许我们与外界交流太多！换句话说，没有<code class="du kr ks kt ku b">IO</code>，除了渲染DOM！所以我们可以使用一些更高级的函数来创建一个<code class="du kr ks kt ku b">Program</code>。对于一个普通的应用程序，你需要使用<code class="du kr ks kt ku b">application</code>函数，见<a class="ae jn" href="https://github.com/elm/browser/blob/master/src/Browser.elm#L200" rel="noopener ugc nofollow" target="_blank">这里的</a>。对于我们本周要做的单页例子，我们几乎可以不用<code class="du kr ks kt ku b">sandbox</code>。但是我们将展示如何使用<code class="du kr ks kt ku b">element</code>函数来至少在我们的系统中获得一些效果。<code class="du kr ks kt ku b">element</code>函数看起来很像<code class="du kr ks kt ku b">sandbox</code>，有一些变化:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="46ff" class="ld jp hh ku b fi le lf l lg lh">element :<br/>  { init : flags -&gt; (model, Cmd msg)<br/>  , view : model -&gt; Html msg<br/>  , update : msg -&gt; model -&gt; (model, Cmd msg)<br/>  , subscriptions : model -&gt; Sub msg<br/>  }<br/>  -&gt; Program flags model msg</span></pre><p id="d0d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，我们有用于<code class="du kr ks kt ku b">init</code>、<code class="du kr ks kt ku b">view</code>和<code class="du kr ks kt ku b">update</code>的函数。但是有几个签名有点不同。我们的<code class="du kr ks kt ku b">init</code>函数现在接受程序标志。我们不会用这些。但是它们允许您将Elm项目嵌入到一个更大的Javascript项目中。标志是从Javascript传递到Elm程序的信息。</p><p id="0741" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du kr ks kt ku b">init</code>也会产生一个模型和一个<code class="du kr ks kt ku b">Cmd</code>元素。这将允许我们在初始化应用程序时运行“命令”。你可以认为这些命令是副作用，它们也可以产生我们的消息类型。</p><p id="d1bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到的另一个变化是<code class="du kr ks kt ku b">update</code>函数也可以像新模型一样产生命令。最后，我们有最后一个元素<code class="du kr ks kt ku b">subscriptions</code>。这允许我们订阅外部事件，比如时钟滴答声和HTTP请求。下周我们会看到更多。现在，让我们布置一下应用程序的框架，并记下所有的类型签名。(进口清单见附录)。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="248b" class="ld jp hh ku b fi le lf l lg lh">main : Program () TodoListState TodoListMessage<br/>main = Browser.element <br/>  { init = todoInit<br/>  , update = todoUpdate<br/>  , view = todoView<br/>  , subscriptions = todoSubscriptions<br/>  }</span><span id="264a" class="ld jp hh ku b fi li lf l lg lh">todoInit : () -&gt; (TodoListState, Cmd TodoListMessage)</span><span id="c37b" class="ld jp hh ku b fi li lf l lg lh">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)</span><span id="c5b6" class="ld jp hh ku b fi li lf l lg lh">todoView : TodoListState -&gt; Html TodoListMessage</span><span id="1719" class="ld jp hh ku b fi li lf l lg lh">todoSubscriptions : TodoListState -&gt; Sub TodoListMessage</span></pre><p id="5b17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">初始化我们的程序很容易。我们将忽略这些标志，并返回一个没有任务的状态和正在进行的任务的<code class="du kr ks kt ku b">Nothing</code>。我们将返回<code class="du kr ks kt ku b">Cmd.none</code>，表明初始化我们的状态没有影响。我们还将为订阅填写<code class="du kr ks kt ku b">Sub.none</code>。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="fd43" class="ld jp hh ku b fi le lf l lg lh">todoInit : () -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoInit _ = <br/>  let st = TodoListState { todoList = [], newTodo = Nothing }<br/>  in (st, Cmd.none)</span><span id="fd80" class="ld jp hh ku b fi li lf l lg lh">todoSubscriptions : TodoListState -&gt; Sub TodoListMessage<br/>todoSubscriptions _ = Sub.none</span></pre><h1 id="8aeb" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">填充视图</h1><p id="6807" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在对于我们的视图，我们将把基本的模型组件转换成HTML。当我们有一个Todo元素列表时，我们将在一个有序列表中显示它们。我们会为他们每个人列出一个清单。该项目将说明项目的名称，并给出一个“完成”按钮。单击该按钮，我们可以发送一条消息来完成该待办事项:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="29be" class="ld jp hh ku b fi le lf l lg lh">todoItem : Todo -&gt; Html TodoListMessage<br/>todoItem (Todo todo) = li [] <br/>  [ text todo.todoName<br/>  , button [onClick (FinishedTodo (Todo todo))] [text "Done"]<br/>  ]</span></pre><p id="b869" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们把添加待办事项的输入表单放在一起。首先，我们将确定输入中的值以及是否禁用done按钮。然后我们将定义一个函数，将输入字符串转换成一个新的<code class="du kr ks kt ku b">Todo</code>项。这将发送更改新待办事项的消息。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="cdff" class="ld jp hh ku b fi le lf l lg lh">todoForm : Maybe Todo -&gt; Html TodoListMessage<br/>todoForm maybeTodo = <br/>  let (value_, isEnabled_) = case maybeTodo of<br/>                              Nothing -&gt; ("", False)<br/>                              Just (Todo t) -&gt; (t.todoName, True)<br/>      changeTodo newString = case newString of<br/>                               "" -&gt; UpdatedNewTodo Nothing<br/>                               s -&gt; UpdatedNewTodo (Just (Todo { todoName = s }))<br/>  in ...</span></pre><p id="ed7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将制作表单的HTML。输入元素本身将绑定到我们的<code class="du kr ks kt ku b">onChange</code>函数中，该函数将更新我们的状态。“添加”按钮将发送添加新待办事项的消息。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="8e77" class="ld jp hh ku b fi le lf l lg lh">todoForm : Maybe Todo -&gt; Html TodoListMessage<br/>todoForm maybeTodo = <br/>  let (value_, isEnabled_) = ...<br/>      changeTodo newString = ...<br/>  in div []<br/>       [ input [value value_, onInput changeTodo] []<br/>       , button [disabled (not isEnabled_), onClick (AddedTodo (Todo {todoName = value_}))] <br/>          [text "Add"]<br/>       ]</span></pre><p id="ba88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们可以在<code class="du kr ks kt ku b">view</code>函数中将所有的视图代码放在一起。我们有待办事项列表，然后添加表单。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0a0f" class="ld jp hh ku b fi le lf l lg lh">todoView : TodoListState -&gt; Html TodoListMessage<br/>todoView (TodoListState { todoList, newTodo }) = div []<br/>  [ ol [] (List.map todoItem todoList)<br/>  , todoForm newTodo<br/>  ]</span></pre><h1 id="1747" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">更新模型</h1><p id="c9b6" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们需要做的最后一件事是写出我们的<code class="du kr ks kt ku b">update</code>函数。这只是处理一条消息并相应地更新状态。我们需要三个箱子:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="59cc" class="ld jp hh ku b fi le lf l lg lh">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  (AddedTodo newTodo_) -&gt; ...<br/>  (FinishedTodo doneTodo) -&gt; ...<br/>  (UpdatedNewTodo newTodo_) -&gt; ...</span></pre><p id="cdc6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每一种情况都很简单。对于添加Todo，我们将把它附加在列表的前面:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="532c" class="ld jp hh ku b fi le lf l lg lh">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  (AddedTodo newTodo_) -&gt;<br/>    let st = TodoListState { todoList = newTodo_ :: todoList<br/>                           , newTodo = Nothing<br/>                           }<br/>  (FinishedTodo doneTodo) -&gt; ...<br/>  (UpdatedNewTodo newTodo_) -&gt; ...</span></pre><p id="b55f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们完成一个待办事项时，我们将通过过滤名称相等来将其从列表中删除。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="e59e" class="ld jp hh ku b fi le lf l lg lh">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  (AddedTodo newTodo_) -&gt; ...<br/>  (FinishedTodo doneTodo) -&gt;<br/>    let st = TodoListState { todoList = List.filter (todosNotEqual doneTodo) todoList<br/>                           , newTodo = newTodo<br/>                           }<br/>    in (st, Cmd.none)<br/>  (UpdatedNewTodo newTodo_) -&gt; ..</span><span id="a672" class="ld jp hh ku b fi li lf l lg lh">todosNotEqual : Todo -&gt; Todo -&gt; Bool<br/>todosNotEqual (Todo t1) (Todo t2) = t1.todoName /= t2.todoName</span></pre><p id="904d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更新新的待办事项是最容易的！我们需要做的就是在州内更换它。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="a308" class="ld jp hh ku b fi le lf l lg lh">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  (AddedTodo newTodo_) -&gt; ...<br/>  (FinishedTodo doneTodo) -&gt; ...<br/>  (UpdatedNewTodo newTodo_) -&gt; ..<br/>    (TodoListState { todoList = todoList, newTodo = newTodo_ }, Cmd.none)</span></pre><p id="054f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就这样，我们完成了！我们有一个用于待办事项列表的基本程序。</p><h1 id="cfa4" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="731b" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">这就完成了我们的基本Todo应用程序！从Elm开始，我们还需要学习更多的东西。下周，我们将看到如何实现任何站点都需要的一些重要类型的效果。我们将看到Elm效果系统的介绍，并使用它来发送HTTP请求。</p><p id="4df2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想了解更多关于在Haskell中构建酷产品的想法，请看一下我们的<a class="ae jn" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>。它介绍了许多主题的一些库，包括数据库和解析！</p><h1 id="2b5d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">附录:进口</h1><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="e160" class="ld jp hh ku b fi le lf l lg lh">import Browser<br/>import Html exposing (Html, button, div, text, ol, li, input)<br/>import Html.Attributes exposing (value, disabled)<br/>import Html.Events exposing (onClick, onInput)</span></pre></div></div>    
</body>
</html>