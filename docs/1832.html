<html>
<head>
<title>NgRx vs Observable Services: Stately Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx与可观察服务:庄严的事务</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/ngrx-vs-observable-services-stately-matters-8e6b7a35723b?source=collection_archive---------2-----------------------#2022-01-24">https://medium.com/capital-one-tech/ngrx-vs-observable-services-stately-matters-8e6b7a35723b?source=collection_archive---------2-----------------------#2022-01-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="ac0b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><em class="iw">比较应用程序中处理数据流的两种流行方式</em></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b8d0b7e7570aa74d6972bd2f460fb216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v-3YDdaADZtQtcOX.jpg"/></div></div></figure><p id="628e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">关于维护应用程序中的状态，拥有单一的真实来源是一件好事，但这可能会带来麻烦的开销。</p><p id="888a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">就像生活中的所有事情一样，在发展中你不能鱼和熊掌兼得。当然，如果有一个解决方案可以帮助开发者解决常见的问题，比如事件汤和变更检测，而不需要任何额外的工作，那就太好了。但是，唉，这不是世界的方式。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kf"><img src="../Images/07090accb8cdb19998679cff031f9a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1CbiQdAvKc01H-gwUIz1Q.png"/></div></div></figure><p id="99c4" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我今天要谈论的两个流行的维护状态和优化数据流的解决方案是<a class="ae kg" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>和<a class="ae kg" href="https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/" rel="noopener ugc nofollow" target="_blank">可观察服务</a>，前者采用redux风格的方法，后者包含应用程序“片段”的期望状态，订阅可以在其中创建。</p><p id="214e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">对于本文，我实现了一个迷你聊天应用程序来演示NgRx和observable services之间的代码差异。我还将讨论我实现这两个目标的经验。</p><h1 id="1e3f" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">NgRx是什么？</h1><p id="3578" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">我无法改进来自<a class="ae kg" href="https://ngrx.io/docs" rel="noopener ugc nofollow" target="_blank"> NgRx文档的定义，所以让我直接引用它们</a> -</p><p id="658e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="le">“NgRx是一个在Angular中构建反应式应用的框架。NgRx为</em>提供了库</p><ul class=""><li id="0aa1" class="lf lg hh jl b jm jn jp jq js lh jw li ka lj ke lk ll lm ln bi translated"><em class="le">管理全局和局部状态。</em></li><li id="26df" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated"><em class="le">隔离副作用，促进更干净的组件架构。</em></li><li id="2c44" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated"><em class="le">实体收藏管理。</em></li><li id="618b" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated"><em class="le">与角路由器集成。</em></li><li id="2495" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated"><em class="le">在构建许多不同类型的应用程序时，增强开发人员体验的开发人员工具。”</em></li></ul><h1 id="54d2" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">什么是可观察的服务？</h1><p id="aa05" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">Angular中的可观察服务是可以注入到应用程序中的单例服务。它提供了访问器来操作数据(比如向数组中添加一个项)和存储数据。</p><h1 id="74aa" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">我们的示例迷你聊天应用程序</h1><p id="8cdd" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">是时候看看他们两个的行动了！今天，我们将使用一个基本的“聊天”应用程序，它不消耗任何服务/后端API。使用此应用程序，您可以:</p><ol class=""><li id="4e16" class="lf lg hh jl b jm jn jp jq js lh jw li ka lj ke lt ll lm ln bi translated">查看预设频道列表</li><li id="f3ec" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">更新频道名称</li><li id="33c4" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">从内存缓存中读取消息</li><li id="35c1" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">发送消息</li><li id="eec5" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">切换频道</li></ol><p id="aa44" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">对于每个“特性”,我将分析每个实现之间的差异。</p><h1 id="4bc2" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">可观察服务的结构与NgRx的结构</h1><h2 id="116b" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/9fdd9e2cfbdbedccbacac7ddefdd1051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EorzxzAHbAbZid6j"/></div></div></figure><p id="5f83" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">所需要做的就是运行两次<code class="du mj mk ml mm b">ng g s &lt;service_name&gt;</code>，一次用于通道服务，另一次用于消息服务。只需要两个服务——一个处理通道相关的逻辑，另一个处理消息。</p><h2 id="3e57" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/36df69902515320f0ae66c5de70e3a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpCFvBejYpBwCcK7ag1ehA.png"/></div></div></figure><p id="083f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这里还有更多的工作要做——记住，这是<em class="le">不包括</em>减速器和效果的规格。生成的每个文件都包含有自己特定职责的代码。文件很多，但至少我在遵循<a class="ae kg" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"># single responsibility principle</a>。</p><h1 id="22b9" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能分解——可观察服务与NgRx</h1><p id="60b5" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">在这里，我将讨论每个特性在方法上的差异。</p><h1 id="375a" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能1:查看预设频道列表</h1><h2 id="646a" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><p id="b0c3" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">我有一个频道列表，它存储在<code class="du mj mk ml mm b">ChannelService</code>的一个本地成员变量中。我通过监听<code class="du mj mk ml mm b">channelsChanged$</code>可观察信号来获取频道和频道更新。</p><p id="7196" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/9bd5a7a0cfa8e0be634a27a4fe281d58" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/9 BD 5a 7a 0 CFA 8 E0 be 634 a 27 a4 Fe 281d 58</a></p><p id="1671" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">最后，在组件中，我订阅了频道，</p><p id="a63f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/2d1ce87c027dc62f6526d721506f7434" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/2 D1 ce 87 c 027 DC 62 f 6526d 721506 f 7434</a></p><h2 id="1e9c" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><p id="5998" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">首先，我定义状态是什么样子，然后提供默认值:</p><p id="76c8" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/e4795abe3289c4c372ac50fedd8d1ce3" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/e 4795 Abe 3289 C4 c 372 AC 50 fedd 8 D1 ce 3</a></p><p id="ec62" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">然后，我必须创建一种方法来获取通道，这是通过一个选择器来完成的。这可以被认为是一个“查询”:</p><p id="c2de" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/94b60cee9528f346e20d3c03cbe9d92d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/94b 60 ce e 9528 f 346 e 20d 3c 03 CBE 9d 92d</a></p><p id="9053" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">最后，在组件中，我告诉商店使用我创建的选择器来获取这部分数据。</p><p id="6e1c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><code class="du mj mk ml mm b">this.selectedChannelId$ = store.pipe(select(selectCurrentChannelId));</code></p><p id="7a84" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">不算太坏。</p><h1 id="d260" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能2:更新频道名称</h1><h2 id="beb2" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><ol class=""><li id="e295" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">在服务中创建<code class="du mj mk ml mm b">updateChannel</code>方法。</li><li id="6a2b" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">从组件调用方法。</li></ol><p id="c5a1" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">例:<a class="ae kg" href="https://gist.github.com/michael-mckenna/cde3fe5383307ae39461804c2fcb61ef" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/CD E3 Fe 5383307 AE 39461804 C2 fcb 61 ef</a></p><p id="62e1" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">请注意如何使用spread运算符。这通过返回一个新数组来触发变化检测。</p><h2 id="af04" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><ol class=""><li id="6aca" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">创建一个<code class="du mj mk ml mm b">UpdateChannel</code>动作。</li><li id="9f93" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">在reducer中添加逻辑以更新相应的通道。</li><li id="589c" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">在组件中调度<code class="du mj mk ml mm b">UpdateChannel</code>动作。</li></ol><p id="cce4" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我知道这次应该更新哪个频道，因为我为频道硬编码了一些id。我不必更新选定的频道，因为对该频道的引用没有改变。</p><h1 id="2384" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能3:阅读消息</h1><h2 id="3987" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><ol class=""><li id="7d83" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">创建一个<code class="du mj mk ml mm b">MessageService</code>。</li><li id="d365" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">为了获取消息，我使用通道id作为键，使用消息数组作为一个<code class="du mj mk ml mm b">messageDB</code>变量中的值。<code class="du mj mk ml mm b">messages</code>字符串数组用于跟踪当前通道的消息，并处理<code class="du mj mk ml mm b">messageSubject</code>中的推送和返回值。</li><li id="7b2c" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">订阅可从消息列表组件中观察到的<code class="du mj mk ml mm b">messages$</code>。</li></ol><p id="d4de" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这里我建立了<code class="du mj mk ml mm b">messageDB</code>以及<code class="du mj mk ml mm b">messages</code> getter和setter。我还从用户改变频道时发生的<code class="du mj mk ml mm b">messageDB</code>中获得当前频道的消息:</p><p id="3045" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/cae21c80099a9da7212036fe42b0d061" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/CAE 21 c 80099 a9 da 7212036 Fe 42 b 0d 061</a></p><p id="b4bd" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">然后在组件中:</p><p id="8c16" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/54fd4a985b1199bc1de35c426e7130c2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/54fd 4a 985 b 1199 BC 1 de 35 c 426 e 7130 c 2</a></p><h2 id="49a7" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><p id="a5ce" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">这有点复杂。然而，一旦把所有的部分放在一起，就有意义了。逻辑的核心是<a class="ae kg" href="https://ngrx.io/guide/entity/adapter" rel="noopener ugc nofollow" target="_blank"> EntityAdapter </a>。</p><ol class=""><li id="5019" class="lf lg hh jl b jm jn jp jq js lh jw li ka lj ke lt ll lm ln bi translated">创建实体适配器，并设置主键。在这种情况下，我希望channel ID成为主键。该值将是一个包含<code class="du mj mk ml mm b">entities</code>的对象，这是我们的消息数组所在的位置。我使用的是一个拥有<code class="du mj mk ml mm b">channelId</code>和一个<code class="du mj mk ml mm b">Message</code>数组的<code class="du mj mk ml mm b">MessageContainer</code>对象。<code class="du mj mk ml mm b">channelId</code>作为消息的唯一标识符。此处举例:<a class="ae kg" href="https://gist.github.com/michael-mckenna/b7389299c534a97625a6de783b84fa20" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/b 7389299 c 534 a 97625 a6de 783 b 84 fa 20</a></li><li id="0512" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">创建选择器。我必须利用选择器组合，这是一种从选择器中创建选择器的奇特方式。我有一个获取所选通道ID的选择器，一个获取<code class="du mj mk ml mm b">MessageContainers</code>(每个通道的消息)列表，然后我使用这两个获取所选通道的消息。这里举例:<a class="ae kg" href="https://gist.github.com/michael-mckenna/056baea580d6d7bc0f5013f8dee0bf4d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/056 baea 580 d6d 7 BC 0 f 5013 f 8 dee 0 BF 4d</a></li><li id="5fc2" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">要获取消息，我只需使用在(2)中创建的组合选择器。这里举例:<a class="ae kg" href="https://gist.github.com/michael-mckenna/db93226b0796572d627495c316c088a6" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/db 93226 b 0796572d 627495 c 316 c 088 a 6</a></li></ol><h1 id="d077" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能4:添加消息</h1><h2 id="1410" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><ol class=""><li id="10b8" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">给<code class="du mj mk ml mm b">MessageService</code>添加一个函数来添加消息。</li><li id="54ab" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">从组件中调用这个服务函数。</li></ol><p id="3552" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kg" href="https://gist.github.com/michael-mckenna/400b175683f7c2504016cce1c5ca86fb" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/400 b 175683 f7c 2504016 CCE 1c 5 ca 86 FB</a></p><h2 id="7f34" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><ol class=""><li id="9e4b" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">创建一个<code class="du mj mk ml mm b">AddMessage</code>动作。</li><li id="2d83" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">在消息缩减器中添加一个case，将消息添加到所选通道ID对应的实体的消息数组中。</li><li id="6f85" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">从组件调度操作。例:<a class="ae kg" href="https://gist.github.com/michael-mckenna/d04e8706c2d04ceba7cfe38c0d6f12c9" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/d04e 8706 C2 d 04 ceba 7 cfe 38 c 0d 6 f 12 c 9</a></li></ol><h1 id="50ae" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">功能5:切换频道</h1><h2 id="0c07" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务:</h2><ol class=""><li id="83af" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">在<code class="du mj mk ml mm b">MessageService</code>中，添加一个<code class="du mj mk ml mm b">selectedChannelId</code>属性。这在调用<code class="du mj mk ml mm b">getInitialMessagsForChannel(channelId: number)</code>时被设置。</li><li id="8fee" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">当用户选择一个频道时，我在<code class="du mj mk ml mm b">ChannelService</code>和<code class="du mj mk ml mm b">MessageService</code>中记录该频道的ID。当<code class="du mj mk ml mm b">ChannelService</code>中的值更新时，它会更新上面列出的函数中<code class="du mj mk ml mm b">MessageService</code>中的值。这样做的缺点是会产生紧耦合。</li></ol><p id="29af" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">参见此处第24–26行:<a class="ae kg" href="https://gist.github.com/michael-mckenna/cae21c80099a9da7212036fe42b0d061#file-message-service-ts-L24-L27" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Michael-mckenna/CAE 21 c 80099 a9 da 7212036 Fe 42 b 0d 061 #文件-消息-服务-ts-L24-L27 </a></p><h2 id="ec94" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx:</h2><ol class=""><li id="565c" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lt ll lm ln bi translated">创建一个<code class="du mj mk ml mm b">SelectChannelId</code>通道动作<em class="le">和</em>消息动作(记住，在这两种状态下都将跟踪所选的通道id)。</li><li id="a67b" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">在缩减器中增加一个case，设置通道缩减器和消息缩减器中的<code class="du mj mk ml mm b">selectedChannelId</code>。</li><li id="9a23" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">创建<code class="du mj mk ml mm b">selectChannel</code>选择器。</li><li id="eea5" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lt ll lm ln bi translated">一些新的东西——创造一个<code class="du mj mk ml mm b">selectChannel$</code> <a class="ae kg" href="https://ngrx.io/guide/effects" rel="noopener ugc nofollow" target="_blank">效果</a>。我想在通道状态中设置选定的通道id，但我也需要在消息状态中设置。这被称为<a class="ae kg" href="https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect" rel="noopener ugc nofollow" target="_blank">副作用</a>(因此NgRx给它起了这个名字)。创建的效果调度一个新的动作，该动作被消息缩减器获取，因此它也可以更新它选择的通道id。另一种方法需要将消息状态与通道状态相结合。但是，这种方法会有问题，因为消息状态依赖于另一个状态的值来组成它的选择器，这是一种反模式。</li></ol><h1 id="de5c" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">关于NgRx与可观察服务的最终想法</h1><p id="76f1" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">这些都是基于我个人使用两者的经验，可能并不适用于所有的团队或用例。</p><h1 id="d18d" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">可观察到的服务利弊</h1><h2 id="6047" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务的优点:</h2><p id="ded1" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">可观察服务方法的实现要快得多。它更苗条，学习曲线非常短。相对快速地完成一件事是值得的。</p><h2 id="60cb" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">可观察服务的缺点:</h2><p id="c5b2" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">我遇到了如何处理跨通道存储消息的问题。我希望消息被缓存，这样当返回到一个频道时，它们“已经”在那里了。我用一个使用<a class="ae kg" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkt" rel="noopener ugc nofollow" target="_blank">记录</a>类型的假数据库实现了一个解决方案，最终不喜欢它，然后想出了一个以我创建的<code class="du mj mk ml mm b">messageDB</code>结束的解决方案。仍然不确定是否有更好的方法。</p><p id="0ef2" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我还遇到了一个问题，在跟踪所选频道的id时，我必须耦合<code class="du mj mk ml mm b">ChannelService</code>和<code class="du mj mk ml mm b">MessageService</code>。要是有一个他们可以阅读的中央商店就好了。🤔</p><p id="b337" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我可以看到大型应用程序的服务快速增长。这就需要仔细规划如何以及何时创建服务。您不会希望让单个服务过载</p><h1 id="d6c1" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">NgRx利弊</h1><h2 id="f62b" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx的优点:</h2><p id="cbfc" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">没有紧密耦合。</p><p id="dc90" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">应用程序流中的每个逻辑位都存储在各自的组件中(例如，缩减器、效果等)。这有助于确保在代码中什么应该放在哪里没有问题。这反过来有助于分解应用程序流，因此您只需在任何时间点关注拼图的各个部分，而不是试图在短期内存中保留大部分流，就像大型可观察服务的情况一样。</p><p id="c893" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">单向数据流和干净的副作用处理。这与第一点有关，但是有一种机制来处理副作用并帮助最小化事件混乱有助于保持代码的整洁。</p><h2 id="c4ce" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx的缺点:</h2><p id="98a8" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated"><em class="le">(故事时间—TL；dr it was way longer)我一直在从事一个使用NgRx的成熟项目，这仍然比可观察的服务实现花费了更长的时间。我从来没有参与过从零开始设置商店(所有的动作、状态、选择器、效果和减少器)的项目，所以设置一切需要一个学习曲线。有一次，我不得不学习一个叫做实体适配器的新概念(用于获取给定了特定通道ID的消息)，这也需要一个学习过程。</em></p><p id="f665" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了客观地看待问题，我规划了应用程序结构，创建了组件，创建了UI设计，并首先添加了可观察到的服务逻辑，整个过程仍然比只添加NgRx实现要快(NgRx实现重用了UI并在很大程度上重用了组件)。</p><p id="3245" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">然而，这并不一定意味着NgRx更差，这只是因为它花了更长的时间！这可能更多地表明了我必须经历的两条学习曲线。</p><h2 id="65c0" class="lu ki hh bd kj lv lw lx kn ly lz ma kr js mb mc kt jw md me kv ka mf mg kx mh bi translated">NgRx的更多缺点:</h2><ul class=""><li id="0814" class="lf lg hh jl b jm kz jp la js mo jw mp ka mq ke lk ll lm ln bi translated">在大型应用程序中，跟踪发生的一系列动作/效果/减少会变得很困难。一旦熟悉了代码库，这一点就变得很清楚了，但是对于新的开发人员来说，或者对于重新阅读不久前编写的代码的开发人员来说，仍然需要一个较长的学习曲线。</li><li id="66c7" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated">所有的文件。如前所述，这个真的没有办法。这只是必要的文件夹结构是建立在尽可能好的方式，以方便导航。随着代码库越来越大，这变得越来越重要，因为文件的数量将呈指数级增长。</li><li id="a584" class="lf lg hh jl b jm lo jp lp js lq jw lr ka ls ke lk ll lm ln bi translated">总体上写更多的代码。您必须编写动作、效果、减少器和选择器，然后为它们中的每一个编写测试。然而，因为这些组件都是解耦的，并被分解成更小的纯函数，这使得编写测试更容易，也使得测试更干净。</li></ul><h1 id="fcbe" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">我应该使用可观察服务还是NgRx？</h1><p id="f3ef" class="pw-post-body-paragraph jj jk hh jl b jm kz ii jo jp la il jr js lb ju jv jw lc jy jz ka ld kc kd ke ha bi translated">你可能已经听过一遍又一遍了，但是<em class="le">使用任何对你的团队有效的东西</em>。问自己正确的问题会有所帮助。</p><p id="7bef" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果你的团队中没有人有使用NgRx/redux的经验，但是你真的想使用它，你能抽出额外的时间来学习它吗？你的组织需要自动化的单元测试吗(例如Karma，Cypress)，或者你依赖手工测试来应付吗？NgRx已经有许多文件和组件，每个都需要有一个相关的单元测试，所以您需要记住维护这个大型测试套件所需的额外工作。</p></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><p id="ab27" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="le">披露声明:2022资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="351d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="le">最初发表于</em><a class="ae kg" href="https://www.capitalone.com/tech/software-engineering/comparison-of-ngrx-and-observable-services/" rel="noopener ugc nofollow" target="_blank">T5【https://www.capitalone.com】</a><em class="le">。</em></p></div></div>    
</body>
</html>