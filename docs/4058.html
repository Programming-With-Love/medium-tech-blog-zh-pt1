<html>
<head>
<title>Event-driven programming for Android (part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android的事件驱动编程(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/event-driven-programming-for-android-part-ii-b1e05698e440?source=collection_archive---------1-----------------------#2015-01-28">https://medium.com/google-developer-experts/event-driven-programming-for-android-part-ii-b1e05698e440?source=collection_archive---------1-----------------------#2015-01-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f7c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(这是由三部分组成的系列文章的第二部分)</p><p id="b34c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一篇文章中，我们简要介绍了事件驱动编程。现在让我们看看一些实际的代码以及如何使用EventBus执行基本操作。</p><p id="f19d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我将介绍在事件驱动编程中起核心作用的实体。请参考取自EventBus存储库的下图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a242e3a81c7fa39248fcd173e87634b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9fw9-AbGIqjEskbK-Rf6A.png"/></div></div></figure><p id="e631" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一条<strong class="ig hi">事件总线</strong>这是连接所有其他实体的中央通信通道。</p><p id="f0c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi">事件</strong>。这是将要发生的动作，实际上可以是任何事情(应用程序启动、接收一些数据、用户交互……)</p><p id="aed6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi">用户</strong>。<strong class="ig hi">用户</strong>正在<strong class="ig hi">事件总线</strong>处监听。如果他们看到一个事件在传播，他们就会被触发。</p><p id="7b10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi">发布器</strong>，它将<strong class="ig hi">事件</strong>发送到<strong class="ig hi">事件总线</strong>。</p><p id="f17d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从实用的角度来看，一切都很清楚，所以让我们看看这是如何符合一个基本示例的:</p><ul class=""><li id="3121" class="jo jp hh ig b ih ii il im ip jq it jr ix js jb jt ju jv jw bi translated">加载两个片段的应用程序。</li><li id="5708" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">第二个片段包含一个<strong class="ig hi"> TextView </strong>，当一个按钮被点击时它将被更新。</li><li id="a2f4" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">当一个新的片段进入场景时，<strong class="ig hi">动作条</strong>标题会改变。</li></ul><h2 id="9132" class="kc kd hh bd ke kf kg kh ki kj kk kl km ip kn ko kp it kq kr ks ix kt ku kv kw bi translated">托管活动</h2><p id="9a86" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">宿主活动需要在它的方法onCreate event bus中注册。</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="1df1" class="kc kd hh ld b fi lh li l lj lk">EventBus.getDefault().register(this);</span></pre><p id="2860" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主机活动现在将准备好从总线读取数据。我们还需要在onDestroy方法中取消注册总线</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="2350" class="kc kd hh ld b fi lh li l lj lk">EventBus.getDefault().unregister(this);</span></pre><p id="d228" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该活动将捕获两个不同的事件:一个更新ActionBar标题，另一个加载第一个片段。我们将在Event上编写两个方法来处理事件:</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="8dce" class="kc kd hh ld b fi lh li l lj lk">public void onEvent(ShowFragmentEvent event) {<br/>    getFragmentManager().beginTransaction().replace(R.id.container, event.getFragment()).addToBackStack(null).commit();<br/> }</span><span id="7423" class="kc kd hh ld b fi ll li l lj lk">public void onEvent(UpdateActionBarTitleEvent e) {<br/>    getActionBar().setTitle(e.getTitle()); <br/>}</span></pre><h2 id="00d1" class="kc kd hh bd ke kf kg kh ki kj kk kl km ip kn ko kp it kq kr ks ix kt ku kv kw bi translated">这些事件</h2><p id="e8e2" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">每个事件都需要在其类中声明。事件中可以包含变量。</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="f815" class="kc kd hh ld b fi lh li l lj lk">public final class ShowFragmentEvent {<br/> private Fragment fragment;</span><span id="d166" class="kc kd hh ld b fi ll li l lj lk">  public ShowFragmentEvent(Fragment fragment) {<br/>    this.fragment = fragment;<br/>  }</span><span id="1ac5" class="kc kd hh ld b fi ll li l lj lk">  public Fragment getFragment() {<br/>    return fragment;<br/>  }<br/>}</span></pre><h2 id="6fc7" class="kc kd hh bd ke kf kg kh ki kj kk kl km ip kn ko kp it kq kr ks ix kt ku kv kw bi translated">这些碎片</h2><p id="c848" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">我们现在需要创建碎片。第一个片段将包含一个打开第二个片段的按钮，最新的片段将包含一个按钮，当按下时，更新一个TextView。这些片段还需要注册和注销EventBus，因此为了实现更清晰的结构，所有内容都将封装在BaseFragment中。</p><p id="d06c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们创建更多的动作。第一个片段将使用以下函数打开第二个片段:</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="93ef" class="kc kd hh ld b fi lh li l lj lk"><a class="ae lm" href="http://twitter.com/OnClick" rel="noopener ugc nofollow" target="_blank">@OnClick</a>(R.id.first_button)<br/> public void firstButtonClick() {<br/>    EventBus.getDefault().post(new ShowFragmentEvent(new SecondFragment()));<br/> }</span></pre><p id="1a38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，这里我使用了来自<a class="ae lm" href="https://github.com/JakeWharton/butterknife" rel="noopener ugc nofollow" target="_blank"> ButterKnife </a>的注释。它产生了更加干净整洁的代码。如果你还没用过，现在就应该开始用了。</p><p id="9b5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个片段的按钮将向EventBus发送一个事件来更改TextView。</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="c408" class="kc kd hh ld b fi lh li l lj lk">EventBus.getDefault().post(new UpdateTextEvent(getString(R.string.text_updated)));</span></pre><p id="efcc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个片段也需要监听这个事件，所以当它被接收时，它可以相应地改变文本。</p><pre class="jd je jf jg fd lc ld le lf aw lg bi"><span id="2e8f" class="kc kd hh ld b fi lh li l lj lk">public void onEvent(UpdateTextEvent event) {<br/>    textView.setText(event.getTitle()); <br/>}</span></pre><p id="6211" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有一个基本的应用程序，其中有两个片段通过事件进行通信，还有一个片段通过事件进行更新。我已经把代码上传到<a class="ae lm" href="https://github.com/kikoso/eventbus-sample" rel="noopener ugc nofollow" target="_blank"> GitHub </a>了，大家可以去看看。</p><p id="a161" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个关键问题是如何升级事件驱动的架构。在下一篇文章中，我将提出一个清晰易懂的架构来支持Android中的事件驱动编程。</p></div></div>    
</body>
</html>