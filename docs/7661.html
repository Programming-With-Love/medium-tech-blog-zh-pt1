<html>
<head>
<title>Testing the right way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以正确的方式测试</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/testing-the-right-way-d121334834a?source=collection_archive---------4-----------------------#2016-12-17">https://medium.com/walmartglobaltech/testing-the-right-way-d121334834a?source=collection_archive---------4-----------------------#2016-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/447d86abda8bd92635fda3803a535a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vpjSiIqMBBEBaltJ4Aer1w.jpeg"/></div><figcaption class="hm hn et er es ho hp bd b be z dx">Photo Credit : <a class="ae hq" href="https://pixabay.com/en/board-school-uni-learn-work-test-361516/" rel="noopener ugc nofollow" target="_blank">Test right way</a></figcaption></figure><div class=""/><p id="4aa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">很多时候，我们发现人们错误地测试他们的应用程序。这包括我自己，直到几个月前。为了进行健壮的测试，理解我们在测试什么是非常重要的。我将通过下面的几个场景来演示这一点:</p><p id="5340" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">1.<strong class="is hu">前端开发</strong>:前端开发人员应该只关注前端的测试。例如，如果页面上有一个更新信息的按钮，那么测试范围应该由前端的变化来限定，并且应该与任何后端的依赖项(比如信息是否实际上是由后端保存的)隔离开来。这个测试用例应该看起来像这样:</p><ul class=""><li id="de23" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">打开网页</li><li id="e7d2" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">输入信息X</li><li id="b960" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">点击“更新”按钮</li><li id="07ba" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">显示断言“成功”文本。</li></ul><p id="ff02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.<strong class="is hu">后端开发</strong>:类似地，后端代码应该只关注测试后端部分。因此，这里的测试应该类似于:</p><ul class=""><li id="4312" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">打开到后端的连接。</li><li id="d159" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用信息X执行API</li><li id="a50a" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">断言“X”被更新</li></ul><p id="32b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是你能100%保证两个组件都经过测试的唯一方法。</p><p id="b857" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">3.<strong class="is hu">混合:</strong>如果我们混合这些范围，得出如下结果:</p><ul class=""><li id="d89c" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">打开网页</li><li id="0cca" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">更新信息x。</li><li id="4ebc" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">等待应用程序返回。</li><li id="9c6f" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">断言“X”是否已更新。</li></ul><p id="f3a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以上是可行的，但却成为了对网络的依赖性、web服务的可用性以及延迟或HTTP响应的牺牲品，这些都不在我们的控制之下。结果将是不可靠的、难以维护的和不可靠的测试。这种测试属于集成测试的范畴，只有当您拥有非常健壮和故障安全的代码，并且有足够的时间延迟来解决网络和系统延迟时，这种测试才能发挥作用。这种测试是存在的，但是根据<a class="ae hq" href="http://martinfowler.com/bliki/TestPyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>的原则，这种测试应该减少。</p><h1 id="b43d" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">嘲弄</h1><p id="711a" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">模拟在测试中起着非常重要的作用。如何使用模拟？让我们来看一下场景。在前端测试的第一个场景中，模拟将只包含后端API应该返回的响应。因此，不用真正调用后端API，只需假设响应并将其保存在一个名为mock或fixture的文件中，然后使用它执行前端测试。</p><p id="7bf0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在第二种情况下，情况会完全相反。模拟将包含前端应该发送的模拟信息。基本上，你是在测试API提供一个断言“我不在乎你从哪里调用我，当你调用我(正确)时，我会更新这条信息”。</p><h2 id="3bbf" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">模拟服务器</h2><p id="efd8" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">有很多模拟服务器可以使用，它们提供模拟基础设施和即插即用的测试调优。但是很多时候，我们不正确地使用这些模拟服务器，并期望它们以某种方式运行，因此我们的测试是绿色的。但是相信我，模拟服务器只是为了方便您不用手动创建设备。模拟服务器没有也不应该有基于测试逻辑转换模拟响应的逻辑。如果发生这种情况，那么模拟服务器就不是模拟服务器。这是另一回事。</p><h1 id="fcb0" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">摘要</h1><p id="cf66" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">正确的测试涉及到它自己的设计原则，必须仔细考虑。它包括为你的应用程序建立一个心智模型，并思考你希望对你的应用程序确定什么。如果你了解你的应用程序的范围和你的控制边界，那么测试就变得容易了。幸运的是，我们有很多为我们做基础工作的框架。大多数现代语言，如Java、Node、iOS、Ruby on Rails或Python，都有很好的测试框架。如果我们很好地使用这些工具，并遵循这里提到的指导方针，我们可以创建易于使用、可维护和健壮的测试用例。</p></div></div>    
</body>
</html>