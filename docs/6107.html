<html>
<head>
<title>Evolving MySQL Compression — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发展MySQL压缩—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/evolving-mysql-compression-part-1-7f8b09666589?source=collection_archive---------0-----------------------#2016-10-18">https://medium.com/pinterest-engineering/evolving-mysql-compression-part-1-7f8b09666589?source=collection_archive---------0-----------------------#2016-10-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="07ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Robert Wultsch | Pinterest工程师</p><p id="6027" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest基础设施工程师管理着超过750亿个Pins不断增长的人们兴趣、想法和意图数据库中的动态对象。Pin作为一个1.2 KB的JSON blob存储在<a class="ae jc" href="https://engineering.pinterest.com/blog/sharding-pinterest-how-we-scaled-our-mysql-fleet/" rel="noopener ugc nofollow" target="_blank">分片的MySQL数据库</a>中。几年前，随着我们的快速发展，我们的分片MySQL数据库空间不足，必须做出改变。一种选择是扩大硬件规模(以及我们的支出)。我们选择的另一个选项是使用MySQL InnoDB页面压缩。这花费了一点延迟，但是节省了磁盘空间。然而，我们认为我们可以做得更好。因此，我们创建了一种新形式的MySQL压缩，现在可供Percona MySQL Server 5.6的用户使用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fe8000083db0ee93e009a563d326f748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*3NHbHf73alsMu0Uf.png"/></div></figure><h2 id="2998" class="jl jm hh bd jn jo jp jq jr js jt ju jv ip jw jx jy it jz ka kb ix kc kd ke kf bi translated">JSON对开发者是高效的，对机器不是</h2><p id="78aa" class="pw-post-body-paragraph ie if hh ig b ih kg ij ik il kh in io ip ki ir is it kj iv iw ix kk iz ja jb ha bi translated">作为一家小型初创公司，Pinterest在没有一名专门负责维护和维护MySQL的工程师的情况下，构建了自己的MySQL环境，并将其扩展到数千万个Pinners。这证明了MySQL的易用性，但这也意味着重要的改变是不切实际的。特别是，如果没有专门工具的知识，向MySQL表添加列是不可能的，比如来自<a class="ae jc" href="https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html" rel="noopener ugc nofollow" target="_blank"> Percona </a>、<a class="ae jc" href="http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或(我最喜欢的，因为我帮助构建了它)<a class="ae jc" href="https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/" rel="noopener ugc nofollow" target="_blank">脸书</a>的在线模式更改脚本。</p><p id="607d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将几乎所有Pin数据存储在JSON blob中解决了无法向MySQL表添加列的问题。这种灵活性是以存储效率为代价的。例如，我们将名为“uploaded_to_s3”的字段存储为布尔值。如果我们在MySQL中将它存储为一个布尔值，这个字段将只使用1个字节。使用下面的JSON表示，我们将24个字节写入磁盘，主要是因为字段名存储在JSON blob中。大约20%的插针大小来自字段名。</p><p id="c4e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">boolean uploaded_to_s3如何存储在JSON中</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="263b" class="jl jm hh km b fi kq kr l ks kt">, ‘"uploaded_to_s3": true</span></pre><h2 id="c586" class="jl jm hh bd jn jo jp jq jr js jt ju jv ip jw jx jy it jz ka kb ix kc kd ke kf bi translated">InnoDB页面压缩</h2><p id="8e18" class="pw-post-body-paragraph ie if hh ig b ih kg ij ik il kh in io ip ki ir is it kj iv iw ix kk iz ja jb ha bi translated">按照正常配置，InnoDB以16KB的页面“思考”,并试图压缩用户定义数量的页面，并将它们推到单个页面的空间中。(要深入了解InnoDB页面压缩是如何工作的，我建议阅读这些<a class="ae jc" href="https://dev.mysql.com/doc/refman/5.6/en/innodb-compression-internals.html" rel="noopener ugc nofollow" target="_blank">好文档</a>。)</p><p id="d4a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，我们发现InnoDB页面压缩有几个明显的缺点:</p><ul class=""><li id="30d9" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">InnoDB的缓冲池(它的内存缓存)存储压缩和未压缩的页面。如果一个页面中的数据被相对快速地反复读取，这是很有帮助的，因为数据不需要多次解压缩，但是这并不节省内存。在我们的例子中，我们在MySQL前面有一个重要的缓存层(由<a class="ae jc" href="http://www.slideshare.net/InfoQ/building-highlyresilient-systems-at-pinterest" rel="noopener ugc nofollow" target="_blank"> Mcrouter </a>管理),所以重复读取的情况很少发生。</li><li id="8dbf" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">基本的工作单元仍然是一个16KB的页面。这意味着，如果要压缩的一组页面不适合16KB或更少，压缩将失败，并且不会实现任何节省。这还意味着，如果表的压缩率配置为2:1，但页面恰好压缩得非常好(出于我们的思想实验的目的，甚至可能一直压缩到一个字节)，磁盘上的大小仍然是16KB。换句话说，压缩比实际上仍然只有2:1。</li><li id="2f82" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">一般来说，使用InnoDB压缩的表的延迟更高，尤其是在高并发工作负载下。针对我们的生产工作负载进行的压力测试显示，超过32个活动并发连接时，延迟显著增加，吞吐量相应下降。因为我们有很多过剩的产能，所以这不是一个主要问题。</li></ul><h2 id="1cdc" class="jl jm hh bd jn jo jp jq jr js jt ju jv ip jw jx jy it jz ka kb ix kc kd ke kf bi translated">可供选择的事物</h2><p id="552c" class="pw-post-body-paragraph ie if hh ig b ih kg ij ik il kh in io ip ki ir is it kj iv iw ix kk iz ja jb ha bi translated">我们考虑使用其他公司已经尝试过的方法<a class="ae jc" href="https://eng.uber.com/schemaless-part-two/" rel="noopener ugc nofollow" target="_blank">，客户端在发送数据到MySQL之前压缩JSON。虽然这通过将负载转移到客户端来减少数据库上的负载，但是改造中间件的成本，特别是以牺牲新特性为代价，在我们的情况下太高了。我们需要一种不需要对数据库客户端进行任何更改的解决方案。</a></p><p id="a8d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们详细讨论了修改MySQL以允许列级压缩。这种方法有不同的好处和一些权衡:</p><ul class=""><li id="b43e" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">我们将认识到压缩带来的最大磁盘空间节省。</li><li id="9517" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">对于包含压缩数据的页面，我们只在内存中存储一个副本，因此RAM的使用效率比使用未压缩和页面压缩的InnoDB更高。</li><li id="8b78" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">对于每次读取，我们都需要解压缩数据，而每次写入都需要压缩操作。如果我们需要用许多解压缩操作进行大型顺序扫描，这将是特别有害的。</li></ul><p id="e694" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，阿里巴巴的翟发布了一个包含在Percona服务器中的补丁。我们使用生产工作负载修补、编译和测试了MySQL。结果是与InnoDB页面压缩类似的压缩节省(约50%)，但对于我们的工作负载来说，性能更好。这很有帮助，但我们还想到了另一个改进。</p><h2 id="b1f6" class="jl jm hh bd jn jo jp jq jr js jt ju jv ip jw jx jy it jz ka kb ix kc kd ke kf bi translated">改善列压缩</h2><p id="fb23" class="pw-post-body-paragraph ie if hh ig b ih kg ij ik il kh in io ip ki ir is it kj iv iw ix kk iz ja jb ha bi translated">Zlib是InnoDB页面压缩和阿里巴巴的列压缩补丁使用的压缩库。Zlib实现节省的部分原因是实现了LZ77，并通过引用更早出现的字符串来替换重复出现的字符串。回顾以前出现的字符串的能力对于页面压缩非常有用，但是对于列压缩就不那么有用了，因为字段名(以及其他字符串)不太可能在给定行的同一列中重复出现。</p><p id="abff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Zlib版本1.2.7.1于2013年初发布，增加了使用预定义“字典”来预填充LZ77回顾窗口的能力。这似乎很有希望，因为我们可以用字段名和其他常见的字符串“预热”回看窗口。我们使用<a class="ae jc" href="https://docs.python.org/3.4/library/zlib.html" rel="noopener ugc nofollow" target="_blank"> Python Zlib库</a>和一个由任意Pin JSON blob组成的简单预定义字典进行了一些测试。压缩节省从大约50%增加到大约66%，成本似乎相对较低。</p><p id="e6a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们与Percona合作创建了一个带有可选预定义字典的列压缩规范，然后与Percona签订了构建该特性的合同。</p><h2 id="81ef" class="jl jm hh bd jn jo jp jq jr js jt ju jv ip jw jx jy it jz ka kb ix kc kd ke kf bi translated">初步测试和前进道路</h2><p id="6e27" class="pw-post-body-paragraph ie if hh ig b ih kg ij ik il kh in io ip ki ir is it kj iv iw ix kk iz ja jb ha bi translated">一旦列压缩的alpha版本准备就绪，我们对这一变化进行了基准测试，发现它产生了预期的空间节省，并在高并发性下将吞吐量提高了一倍。唯一的缺点是大型扫描(mysqldump、ETL等)。)的性能受到了一点影响。今年早些时候，我们在<a class="ae jc" href="http://www.slideshare.net/denshikarasu/less-is-more-novel-approaches-to-mysql-compression-for-modern-data-sets" rel="noopener ugc nofollow" target="_blank">佩尔科纳直播</a>上展示了我们的发现。下面是我们演示中的一个图表，显示了我们在256、128、32、16、8、4和1个客户端并发时的生产工作负载的只读版本。TokuDB是黄色的，InnoDB页面压缩是红色的，其他行是带有各种字典的列压缩。总体而言，在高度并发的工作负载上，列压缩的峰值大约是吞吐量的两倍。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/3314c2df53450b4f02aa7434c8b66e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HLDO8GY1m1humemg.png"/></div></div></figure><p id="37bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的下一篇文章中，我们将讨论如何使用一个更简单的压缩字典来增加压缩节省。</p><p id="6447" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ln">鸣谢:感谢建议使用Zlib的预定义词典，感谢Ernie Souhrada进行基准测试，感谢Zhai编写原始补丁并将其发布到Percona邮件列表，感谢Percona添加预定义词典功能并愿意将其包含在他们的发布中。</em></p></div></div>    
</body>
</html>