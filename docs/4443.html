<html>
<head>
<title>Exploring Lazy Staggered Grids in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Jetpack Compose中的惰性交错网格</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-lazy-staggered-grids-in-jetpack-compose-5940d5a393be?source=collection_archive---------0-----------------------#2022-11-02">https://medium.com/google-developer-experts/exploring-lazy-staggered-grids-in-jetpack-compose-5940d5a393be?source=collection_archive---------0-----------------------#2022-11-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/00ca4208cf03f37842a8d4e8aa4222e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x8A9248a5dhJuBjQ.png"/></div></div></figure><p id="3265" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Jetpack Compose的版本<strong class="ir hi"> 1.3.0 </strong>中，我们看到添加了两个受欢迎的组件，即<strong class="ir hi">LazyVerticalStaggeredGrid</strong>和<strong class="ir hi">LazyHorizontalStaggeredGrid</strong>。这两个组件都允许我们以交错的方式组合内容列表，允许我们轻松地组合具有一定高度/宽度范围的项目，同时还支持惰性组合。</p><blockquote class="jn jo jp"><p id="da5e" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">这最初发布在<a class="ae ju" href="http://joebirch.co/android/exploring-lazy-staggered-grids-in-jetpack-compose/" rel="noopener ugc nofollow" target="_blank">joebirch.co</a></p></blockquote><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jv"><img src="../Images/cb0ae4d25147f445d7e70b04611598cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HoSEVUGv5oMAgnID.png"/></div></div></figure><p id="0931" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博文中，我们将看看这些新的可组合API，了解它们给可组合API带来了什么，以便我们可以在自己的应用程序中使用它们。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><p id="d6f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们开始研究这些网格组件之前，我们需要将compose foundation依赖项添加到我们的项目中。惰性网格支持是在<strong class="ir hi"> 1.3.0 </strong>中添加的，当我们在项目中声明使用这些API时，我们将在版本中使用它。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="93a7" class="km kn hh ki b fi ko kp l kq kr">implementation 'androidx.compose.foundation:foundation:1.3.0'</span></pre><p id="69a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经将它添加到我们的项目中，我们将可以访问两个惰性网格组件——LazyVerticalStaggeredGrid和LazyHorizontalStaggeredGrid。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="cf3f" class="km kn hh ki b fi ko kp l kq kr">@Composable<br/>fun LazyVerticalStaggeredGrid(<br/>    columns: StaggeredGridCells,<br/>    modifier: Modifier = Modifier,<br/>    state: LazyStaggeredGridState =    <br/>        rememberLazyStaggeredGridState(),<br/>    contentPadding: PaddingValues = PaddingValues(0.dp),<br/>    verticalArrangement: Arrangement.Vertical = <br/>        Arrangement.spacedBy(0.dp),<br/>    horizontalArrangement: Arrangement.Horizontal = <br/>        Arrangement.spacedBy(0.dp),<br/>    flingBehavior: FlingBehavior =<br/>        ScrollableDefaults.flingBehavior(),<br/>    userScrollEnabled: Boolean = true,<br/>    content: LazyStaggeredGridScope.() -&gt; Unit<br/>)<br/><br/>@Composable<br/>fun LazyHorizontalStaggeredGrid(<br/>    rows: StaggeredGridCells,<br/>    modifier: Modifier = Modifier,<br/>    state: LazyStaggeredGridState = <br/>        rememberLazyStaggeredGridState(),<br/>    contentPadding: PaddingValues = PaddingValues(0.dp),<br/>    verticalArrangement: Arrangement.Vertical = <br/>        Arrangement.spacedBy(0.dp),<br/>    horizontalArrangement: Arrangement.Horizontal = <br/>        Arrangement.spacedBy(0.dp),<br/>    flingBehavior: FlingBehavior = <br/>        ScrollableDefaults.flingBehavior(),<br/>    userScrollEnabled: Boolean = true,<br/>    content: LazyStaggeredGridScope.() -&gt; Unit<br/>)</span></pre><p id="eb02" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从这些组件的来源我们可以看到，这些组件的参数几乎是相同的。唯一的区别是<strong class="ir hi"> StaggeredGridCells </strong>参数的参数名，它是为正在编写的网格类型定制的。</p><ul class=""><li id="0312" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi">行/列</strong>—<strong class="ir hi">staggered grid cells</strong>引用，用于配置网格单元的组成方式。这或者是固定数量的单元，或者是用于计算在当前配置下屏幕上可以容纳多少行/列的维度</li><li id="4c25" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">修饰符</strong>–应用于可组合组件的修饰符引用</li><li id="58d8" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">state</strong>–LazyStaggeredGridState引用，用于保存网格组件的当前状态</li><li id="065a" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">内容填充</strong>–应用于网格内容区域的填充</li><li id="5682" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">vertical arrangement</strong>–用于声明网格项目在垂直轴上的组成方式</li><li id="1017" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">horizontal arrangement</strong>–用于声明网格的项目在水平轴上应该如何组成</li><li id="e855" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">fling behavior</strong>–用于指定网格的fling behavior</li><li id="45a6" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">userScrollEnabled</strong>–是否可以通过用户输入滚动网格</li><li id="4487" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">内容</strong>–网格内要合成的内容</li></ul><p id="9d34" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里只需要<strong class="ir hi"> StaggeredGridCells </strong>和<strong class="ir hi"> content </strong>参数，因此您可以用最少的努力启动并运行一个惰性网格布局。在这篇文章的接下来的部分中，我们将探索这些论点中的大部分，并组成一个网格来显示我们提供给它的数据的可视化。</p><h1 id="6c3c" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置网格数据</h1><p id="bf2d" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">在我们开始编写UI之前，我们将设置一个简单的数据类，用于保存要编写的每个单元格项的信息。我们将创建一个新的类<strong class="ir hi"> GridItem </strong>。这将包含三条信息:</p><ul class=""><li id="e218" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi">id</strong>–可用于识别物品的唯一标识符</li><li id="5321" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">颜色</strong>–合成项目时使用的颜色</li><li id="2fae" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">尺寸</strong>–用于项目的尺寸，包括高度或宽度</li></ul><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="49eb" class="km kn hh ki b fi ko kp l kq kr">class GridItem(<br/>    val id: String,<br/>    val color: Color,<br/>    val size: Dp<br/>)</span></pre><p id="cb48" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了一个表示每个网格项的数据类，接下来我们可以声明将用于该项的可视化表示的composable。为此，我们将创建一个新的composable，它将简单地组成一个<strong class="ir hi">框</strong>，使用来自<strong class="ir hi"> GridItem </strong>引用的<strong class="ir hi">颜色</strong>和<strong class="ir hi">大小</strong>来配置composable的样式。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="1a63" class="km kn hh ki b fi ko kp l kq kr">@Composable<br/>fun Item(<br/>    modifier: Modifier = Modifier,<br/>    item: GridItem<br/>) {<br/>    Box(<br/>        modifier = modifier<br/>            .background(item.color)<br/>            .height(item.size)<br/>    )<br/>}</span></pre><p id="c9bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们有了一个数据类来保存网格中每一项的信息，还有一个composable来在我们的UI中组合这些信息。</p><p id="b324" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong>:为了让这篇博文简单，我们不会建立一个<strong class="ir hi"> GridItem </strong>实例的列表。这只是为了举例说明。</p><h1 id="3080" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构成网格</h1><p id="3514" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">现在我们已经定义了上面的部分，我们可以继续编写<strong class="ir hi">LazyVerticalStaggeredGrid</strong>。现在，我们将只提供所需的参数，这样我们就可以启动并运行我们的可组合组件。我们将从为<code class="du mi mj mk ki b">columns</code>参数提供一个值开始，使用<strong class="ir hi"> StaggeredGridCells将列数固定为2。修正了</strong>类。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="7a96" class="km kn hh ki b fi ko kp l kq kr">LazyVerticalStaggeredGrid(<br/>    columns = StaggeredGridCells.Fixed(2)<br/>) {<br/><br/>}</span></pre><h1 id="3c8c" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构成网格项目</h1><p id="521b" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">现在我们已经有了LazyVerticalStaggeredGrid,接下来我们将在网格中组合条目。为此，我们将使用来自<strong class="ir hi"> LazyStaggeredGridScope </strong>的<strong class="ir hi"> items </strong>函数，将传递给可组合函数的<strong class="ir hi"> GridItem </strong>引用列表传递给该函数。然后，我们将使用这个引用为网格中的每个单元格组成一个<strong class="ir hi">项</strong>。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="4518" class="km kn hh ki b fi ko kp l kq kr">val items: List&lt;GridItem&gt; = ...<br/><br/>LazyVerticalStaggeredGrid(<br/>    columns = StaggeredGridCells.Fixed(2)<br/>) {<br/>    items(items) {<br/>        Item(item = it)<br/>    }<br/>}</span></pre><p id="c024" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在这些项目被组合，我们将能够看到一个包含我们的项目的组合网格-这将以交错网格格式组合。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jv"><img src="../Images/1c2d16abc631b6996f5b0780b4068815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Je0X3y6U2TaJFkhx.png"/></div></div></figure><h1 id="ccda" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用间距</h1><p id="6c1d" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">从上一节我们可以看到，网格中的项目没有应用填充或间距。如果这种可视化表示与您试图实现的设计不匹配，您可能需要对交错网格应用一些额外的配置。这可以使用<strong class="ir hi">内容填充</strong>、<strong class="ir hi">垂直排列</strong>和<strong class="ir hi">水平排列</strong>参数来完成。我们首先使用<strong class="ir hi"> contentPadding </strong>参数将填充应用到网格的内容区域。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="d59d" class="km kn hh ki b fi ko kp l kq kr">LazyVerticalStaggeredGrid(<br/>    columns = StaggeredGridCells.Fixed(2),<br/>    contentPadding = PaddingValues(16.dp),<br/>    verticalArrangement = Arrangement.spacedBy(16.dp),<br/>    horizontalArrangement = Arrangement.spacedBy(16.dp),<br/>)</span></pre><p id="d7da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用此功能后，我们可以看到内容的外部边缘应用了填充，从而在内容边缘和容器之间创建了一些视觉空间。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jv"><img src="../Images/7615253fc938e3a0ea287489f4a09091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-ZhJVjBA05-ocwIa.png"/></div></div></figure><p id="ba4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们希望在容器本身中增加一些空间——允许项目之间有视觉间隙，这样它们就不会接触到。为此，我们将利用<strong class="ir hi">垂直排列</strong>和<strong class="ir hi">水平排列</strong>参数。对于每一项，我们需要提供一个<strong class="ir hi">排列</strong>参考，我们将以<strong class="ir hi">排列.空间的形式完成，通过</strong>允许我们指定一个用于项目间距的尺寸值。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="332a" class="km kn hh ki b fi ko kp l kq kr">LazyVerticalStaggeredGrid(<br/>    columns = StaggeredGridCells.Fixed(2),<br/>    contentPadding = PaddingValues(16.dp),<br/>    verticalArrangement = Arrangement.spacedBy(16.dp),<br/>    horizontalArrangement = Arrangement.spacedBy(16.dp)<br/>)</span></pre><p id="4dfe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们已经提供了垂直轴和水平轴的值，所以我们现在可以看到这个间距应用于我们的网格的子网格。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/900c0a367128301f163a6296f6b06771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*FQKD28ekAasaPsA_.gif"/></div></figure><h1 id="dfdd" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">控制单元配置</h1><p id="dc79" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">正如我们之前看到的，惰性网格组件允许您使用<strong class="ir hi"> StaggeredGridCells </strong>引用来控制要组成的行/列的数量。到目前为止，我们已经使用它来设置固定的列数，但是我们可以使用它来基于设备的当前配置动态地控制列数。这可以通过对<strong class="ir hi"> StaggeredGridCells </strong>类使用<strong class="ir hi"> Adaptive </strong>类型来实现，这允许我们为单元格项指定最小大小。在LazyVerticalStaggeredGrid 的情况下，这意味着子网格的宽度至少需要达到这个大小，剩余的可用宽度在子网格之间分配。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="9d0d" class="km kn hh ki b fi ko kp l kq kr">val cellConfiguration = if (LocalConfiguration.current.orientation == ORIENTATION_LANDSCAPE) {<br/>    StaggeredGridCells.Adaptive(minSize = 175.dp)<br/>} else StaggeredGridCells.Fixed(2)</span></pre><p id="f97f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，在这种情况下，如果有600dp可用，将有3列各为200dp。</p><p id="b2e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这样的配置，我们现在可以将它传递给网格的<code class="du mi mj mk ki b">columns</code>参数。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="3fa2" class="km kn hh ki b fi ko kp l kq kr">LazyVerticalStaggeredGrid(<br/>    columns = cellConfiguration,<br/>    ...<br/>)</span></pre><p id="891e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在编写本例时，我们现在可以看到，在横向模式下，应用了<strong class="ir hi">自适应</strong>逻辑，我们根据设备配置编写了多列。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jv"><img src="../Images/55c7fe649b1f40dc021f84791731c5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qpjP7DsSZ6_UYp-l.png"/></div></div></figure><h1 id="2e1c" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">组成水平网格</h1><p id="4843" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">在这篇文章中，我们一直关注<strong class="ir hi">的LazyVerticalStaggeredGrid </strong>，我们也简单提到了<strong class="ir hi">LazyHorizontalStaggeredGrid</strong>的存在。我们可以将这个可组合对象切换出来，我们需要做的就是将参数<code class="du mi mj mk ki b">columns</code>的名称改为<code class="du mi mj mk ki b">rows</code>。</p><pre class="jw jx jy jz fd kh ki kj kk aw kl bi"><span id="b526" class="km kn hh ki b fi ko kp l kq kr">val cellConfiguration = if (LocalConfiguration.current.orientation == ORIENTATION_LANDSCAPE) {<br/>    StaggeredGridCells.Adaptive(minSize = 175.dp)<br/>} else StaggeredGridCells.Fixed(2)<br/><br/>LazyHorizontalStaggeredGrid(<br/>    rows = cellConfiguration,<br/>    contentPadding = PaddingValues(16.dp),<br/>    verticalArrangement = Arrangement.spacedBy(16.dp),<br/>    horizontalArrangement = Arrangement.spacedBy(16.dp),<br/>) {<br/>    items(items, key = { it.id }) {<br/>        item(<br/>            item = it<br/>        )<br/>    }<br/>}</span></pre><p id="bcd9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们可以看到屏幕上现在有一个水平的惰性网格，允许我们在水平轴上滚动子项目。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es mm"><img src="../Images/324004c65b0493a72f9e6995ce336cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*-iQIEIiADtm2570s.gif"/></div></figure><h1 id="e698" class="lg kn hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">包扎</h1><p id="f0a3" class="pw-post-body-paragraph ip iq hh ir b is md iu iv iw me iy iz ja mf jc jd je mg jg jh ji mh jk jl jm ha bi translated">在这篇文章中，我们已经看到了Jetpack Compose中新的惰性交错网格API，由<strong class="ir hi">LazyVerticalStaggeredGrid</strong>和<strong class="ir hi">LazyHorizontalStaggeredGrid</strong>组件组成。我们已经学习了如何在这些容器中配置子项的排列，以及如何控制组成子项时使用的行数/列数。</p><p id="e115" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我个人喜欢看到交错网格在应用程序中的使用，所以我很期待看到这些新的组件是如何在应用程序中使用的！</p></div></div>    
</body>
</html>