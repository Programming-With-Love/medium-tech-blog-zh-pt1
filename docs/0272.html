<html>
<head>
<title>Android Data Binding: 2-way Your Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:双向方式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-2-way-your-way-ccac20f6313?source=collection_archive---------0-----------------------#2016-10-05">https://medium.com/androiddevelopers/android-data-binding-2-way-your-way-ccac20f6313?source=collection_archive---------0-----------------------#2016-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/52cdb34d5af2282437406bff04619031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBBCyHOqsDjeW_NzbAeD-w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="1e56" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">制作自定义双向绑定属性</h2></div><p id="69b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可能还记得上一篇文章<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-lets-flip-this-thing-dc17792d6c24#.jnjdgyoo8">中的内容</a>，双向数据绑定允许您自动将用户输入的数据传输回您的数据模型。当<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-custom-setters-55a25a7aea47#.966qs44lp">我写了关于自定义设置器的文章</a>时，你们中的一些人已经意识到这对于双向数据绑定是不够的。我本打算把这个留到以后，但我不想让你一直等着。</p><h2 id="5fdb" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">颜色选择器刷新程序</h2><p id="df0a" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">正如您在<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-custom-setters-55a25a7aea47#.8x1b2k7ex">自定义设置器</a>文章中所知道的，我有一个自定义视图ColorPicker，它有一个属性“color ”,并支持一个“OnColorChangeListener ”,当用户选择新的颜色时，它会发出通知:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="b46d" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>ColorPicker <strong class="lj ht">extends </strong>View {<br/>    <strong class="lj ht">private int color</strong>;<br/><br/>    <strong class="lj ht">public void </strong>setColor(<strong class="lj ht">int </strong>color) {<br/>        <strong class="lj ht">this</strong>.<strong class="lj ht">color </strong>= color;<br/>        invalidate();<br/>    }<br/><br/>    <strong class="lj ht">public int </strong>getColor() {<br/>        <strong class="lj ht">return color</strong>;<br/>    }</span><span id="fd1a" class="ke kf hs lj b fi lr lo l lp lq"><strong class="lj ht">    public void </strong>addListener(OnColorChangeListener listener) {<br/>        //...<br/>    }</span><span id="b902" class="ke kf hs lj b fi lr lo l lp lq"><strong class="lj ht">    public void </strong>removeListener(OnColorChangeListener listener) {<br/>        //...<br/>    }</span><span id="09f0" class="ke kf hs lj b fi lr lo l lp lq">    //...<br/>}</span></pre><p id="046b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我想使用双向绑定“@={expression}”语法支持color属性的双向绑定:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="ff44" class="ke kf hs lj b fi ln lo l lp lq">&lt;<strong class="lj ht">com.example.myapp.ColorPicker<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <em class="ls">app:color="@={color}"</em></strong>/&gt;</span></pre><h2 id="5f33" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">我们用什么吸气剂？</h2><p id="0713" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">如果我们有一个简单的getter匹配属性中使用的类型，我们可以使用InverseBindingMethod:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="58b8" class="ke kf hs lj b fi ln lo l lp lq">@InverseBindingMethods({<br/>  @InverseBindingMethod(type = ColorPicker.<strong class="lj ht">class</strong>,<br/>                        attribute = <strong class="lj ht">"color",<br/>                        </strong>method = <strong class="lj ht">"getColor"</strong>)<br/>})<br/><strong class="lj ht">public class </strong>ColorPickerBindingAdapters {<br/>}</span></pre><p id="1d50" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里，我已经明确地将方法属性设置为“getColor”InverseBindingMethod根据属性名将方法名默认为getter，所以即使我没有显式设置它，它也会默认为“getColor”。</p><p id="9c23" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果需要做比调用getter方法更复杂的事情，就需要使用InverseBindingAdapter。这里，我已经将颜色(无论是什么类型)转换成了整数。我还需要一个常规的绑定适配器来转换另一个方向:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="75cf" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>ColorPickerBindingAdapters {<br/>    @InverseBindingAdapter(attribute = <strong class="lj ht">"color"</strong>)<br/>    <strong class="lj ht">public static int </strong>getColor(ColorPicker view) {<br/>        <strong class="lj ht">return </strong>convertColorToInt(view.getColor());<br/>    }<br/>    <br/>    @BindingAdapter(<strong class="lj ht">"color"</strong>)<br/>    <strong class="lj ht">public static void </strong>setColor(ColorPicker view, <strong class="lj ht">int </strong>color) {<br/>        view.setColor(convertIntToColor(color));<br/>    }<br/>}</span></pre><figure class="le lf lg lh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/9a3ebb63e78603b37c7fc606f82d13cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lz9De-Vmkn4Ec7O5D_kFCQ.jpeg"/></div></div></figure><h2 id="381d" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">钩住事件</h2><p id="5f19" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">既然数据绑定知道getter使用哪种方法，它还必须连接一个侦听器来知道值何时改变。幸运的是，在前一篇文章中，我们在ColorPicker <a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-custom-setters-55a25a7aea47#.966qs44lp">中连接了一个监听器。然而，数据绑定并不真正理解“onColorChange”是什么，所以我们必须使用它的InverseBindingListener来挂钩数据更改事件。</a></p><p id="6d61" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于每个双向绑定，都会生成一个合成事件属性，其名称与该属性相同，但带有后缀“AttrChanged”在这种情况下，事件属性是“colorAttrChanged”这允许我们创建一个BindingAdapter来将事件监听器关联到视图。我也不想像以前一样失去分配“onColorChange”事件的能力，所以绑定适配器必须寻找两种事件类型:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="d154" class="ke kf hs lj b fi ln lo l lp lq">@BindingAdapter(value = {<strong class="lj ht">"onColorChange"</strong>, <strong class="lj ht">"colorAttrChanged"</strong>},<br/>                requireAll = <strong class="lj ht">false</strong>)<br/><strong class="lj ht">public static void </strong>setListeners(ColorPicker view,<br/>              <strong class="lj ht">final </strong>OnColorChangeListener onColorChangeListener,<br/>              <strong class="lj ht">final </strong>InverseBindingListener inverseBindingListener) {<br/>    ColorPicker.OnColorChangeListener newListener;<br/>    <strong class="lj ht">if </strong>(inverseBindingListener == <strong class="lj ht">null</strong>) {<br/>        newListener = onColorChangeListener;<br/>    } <strong class="lj ht">else </strong>{<br/>        newListener = <strong class="lj ht">new </strong>ColorPicker.OnColorChangeListener() {<br/>            @Override<br/>            <strong class="lj ht">public void </strong>onColorChange(ColorPicker colorPicker,<br/>                                      <strong class="lj ht">int </strong>newColor) {<br/>                <strong class="lj ht">if </strong>(onColorChangeListener != <strong class="lj ht">null</strong>) {<br/>                    onColorChangeListener.onColorChange(colorPicker,<br/>                                                        newColor);<br/>                }<br/>                inverseBindingListener.onChange();<br/>            }<br/>        };<br/>    }<br/>    <br/>    ColorPicker.OnColorChangeListener oldListener = <br/>            ListenerUtil.<em class="ls">trackListener</em>(view, newListener,<br/>                                       R.id.colorChangeListener);<br/>    <br/>    <strong class="lj ht">if </strong>(oldListener != <strong class="lj ht">null</strong>) {<br/>        view.removeListener(oldListener);<br/>    }<br/>    <strong class="lj ht">if </strong>(newListener != <strong class="lj ht">null</strong>) {<br/>        view.addListener(newListener);<br/>    }<br/>}</span></pre><p id="b2cb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当使用双向绑定表达式时，数据绑定框架将为“colorAttrChanged”属性分配InverseBindingListener。既然我们已经将监听器连接到onColorChanged事件，数据绑定框架将知道何时将值赋回模型。</p><figure class="le lf lg lh fd hj er es paragraph-image"><div class="er es lt"><img src="../Images/8b686ef13bd2d121c2d198564e70a72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*mdPpPx8DZwGUX_CejLILuw.jpeg"/></div></figure><h2 id="97c2" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">防止无限循环</h2><p id="10b8" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">用户做出更改后，事件被触发，值被接收，然后在模型上设置该值。<a class="ae kd" rel="noopener" href="/p/9de4ff3fe038/">如前一篇文章中所讨论的，一个可观察模型然后通知</a>有一个变更，数据绑定框架将该值分配给视图。然后，视图再次通知一个变更，再次接收值，然后再次在模型上设置值。整个事情永远这样继续下去，每一帧一次。这对电池寿命不好。</p><p id="1b66" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">不幸的是，Android数据绑定不会自动处理这一点，所以您必须打破循环。您可以通过在视图的setter中进行检查，或者在通知代码中没有值更改时不通知来实现这一点。但是，您不能总是控制视图的源，因此您可以在使用绑定适配器设置值之前进行检查:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e3cf" class="ke kf hs lj b fi ln lo l lp lq">@BindingAdapter(<strong class="lj ht">"color"</strong>)<br/><strong class="lj ht">public static void </strong>setColor(ColorPicker view, <strong class="lj ht">int </strong>color) {<br/>    <strong class="lj ht">if </strong>(color != view.getColor()) {<br/>        view.setColor(color);<br/>    }<br/>}</span></pre><h2 id="217b" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">概述</h2><p id="67fe" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">现在，您已经准备好为自定义视图的属性启用双向数据绑定了。</p><ol class=""><li id="3f29" class="lu lv hs jj b jk jl jn jo jq lw ju lx jy ly kc lz ma mb mc bi translated">添加一个InverseBindingMethod或InverseBindingAdapter来标识如何从视图中检索数据。</li><li id="58b5" class="lu lv hs jj b jk md jn me jq mf ju mg jy mh kc lz ma mb mc bi translated">添加一个BindingAdapter来连接InverseBindingListener，以侦听属性值的更改。</li><li id="c907" class="lu lv hs jj b jk md jn me jq mf ju mg jy mh kc lz ma mb mc bi translated">通过在BindingAdapter或视图的setter中添加值检查来确保没有无限循环。</li></ol></div></div>    
</body>
</html>