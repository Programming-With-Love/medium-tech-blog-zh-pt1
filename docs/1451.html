<html>
<head>
<title>The Conversation Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对话工厂</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/the-conversation-factory-68310ff24748?source=collection_archive---------4-----------------------#2017-06-21">https://medium.com/capital-one-tech/the-conversation-factory-68310ff24748?source=collection_archive---------4-----------------------#2017-06-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="28c0" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">多种设备类型的高级架构和开发实践</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/eed550fb027a6e5294a9f316c6989e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sc9JTfA0L7Oak7TTe2C8cw.png"/></div></div></figure><p id="30b6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通往互联网的大门正在移动和扩大。随着人工智能和人机界面处于早期革命阶段，语音和多模式对话界面正在爆炸式增长。一年半前，当我在Capital One的团队开始研究反应式回合制对话用户界面时，我们发现几乎所有的界面都有类似的结构。我们利用这些构造，创建了我们称之为<em class="ke">对话工厂</em>的东西，它是一组模式和抽象，可以应用于所有符合这种范式的对话ui。这些模式和抽象允许我们在开发新的渠道和多模式设备时保持速度和质量，这些渠道和设备结合了语音和视觉体验。</p><p id="9894" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的代码库是使用可靠的工程原理和实践设计的，允许我们引入对话工厂，而不会在整个技能中产生连锁反应。技能设计的其余部分超出了本博客的范围，但是必须理解深思熟虑的设计必须应用于代码库的所有层。</p><p id="0d3f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用序列图，我们展示了对话工厂组件之间的交互:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es kf"><img src="../Images/9d4023a7b402ada3c7615b5ccad460ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcTu1LQeG3J3b9UvViDYCQ.png"/></div></div></figure><ul class=""><li id="7a5a" class="kg kh hh jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><strong class="jk hi">意图中间件</strong> — Express.js中间件组件，负责将传入的请求路由到适当的意图处理器。它使用AdapterFactory为请求的通道创建一组适当的交互工厂。这个适配器被传递给匹配的意图处理程序。</li><li id="510c" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hi"> AdapterFactory </strong> —该组件负责检查传入的请求，以确定应该创建哪个通道特定的InteractionAdapter。</li><li id="9857" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hi"> InteractionAdapter </strong> —抽象出获取关于传入请求的信息所需的交互:用户上下文、意图、插槽/实体等。</li><li id="24bf" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hi"> DisplayFactory </strong> —用于创建平台特定显示的接口。</li><li id="2fa6" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hi"> SpeechFactory </strong> —用于创建平台特定的SSML/语音的接口。</li><li id="bc94" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hi"> IntentHandler </strong> —每个意图都有一个处理程序，用于根据用户上下文和入站实体确定适当的返回响应。</li></ul><h1 id="14e6" class="ku kv hh bd kw kx ky kz la lb lc ld le in lf io lg iq lh ir li it lj iu lk ll bi translated">工厂</h1><p id="85d2" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">类图快速展示了我们的实现是什么样子的。为了简洁起见，这不是一个完整的类图，只是用来显示一些实现细节:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es kf"><img src="../Images/f616eb04c0b54d044e6e80e447de1b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYH4UK3W0vRchsP2QQWDiw.png"/></div></div></figure><p id="7530" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一些类型脚本代码片段来说明我们的抽象。</p><h2 id="5286" class="lr kv hh bd kw ls lt lu la lv lw lx le jr ly lz lg jv ma mb li jz mc md lk me bi translated">语音工厂</h2><p id="b09c" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">虽然所有的声音平台都支持SSML，但并不是所有的平台都同样支持SSML。对于我们的技能，我们说一个账号的最后四位数字用于多账户响应:<em class="ke">“…你的风险账户以1 2 3 4结尾。”</em> SSML允许我们通知语音引擎把数字<em class="ke">【一二三四】</em>说成字符，而不是把它们说成数字“<em class="ke">一千二百三十四。”</em>除了这种特定于Capital One的需求之外，我们发现每个平台上的日期表示也有所不同。我们只对这两个进行了抽象，但是有了SpeechFactory，我们可以在需要的时候很容易地添加新的实现。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="1e44" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">export interface </strong>SpeechFactory {</span><span id="fc58" class="lr kv hh mg b fi mo ml l mm mn">    speakLastFour(lastFour: <strong class="mg hi">string</strong>): <strong class="mg hi">string</strong>;</span><span id="c64d" class="lr kv hh mg b fi mo ml l mm mn">    speakDate(date: <strong class="mg hi">string</strong>, format?: <strong class="mg hi">string</strong>): <strong class="mg hi">string</strong>;</span><span id="1496" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><h2 id="7c82" class="lr kv hh bd kw ls lt lu la lv lw lx le jr ly lz lg jv ma mb li jz mc md lk me bi translated">显示工厂</h2><p id="54f2" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">随着Cortana的全面上市和Echo Show等多模式设备的发布，我们还必须抽象出我们的技能如何向客户显示相关信息。它可以像技能卡上的文本一样简单，也可以是Cortana画布或Echo Show屏幕上的更丰富的UI。我们抽象了所有用例，并在一个界面中表示它们，因此我们可以添加大量依赖于通道的实现，并在每个通道上显示支持。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="b0a0" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">export interface </strong>DisplayFactory {</span><span id="7663" class="lr kv hh mg b fi mo ml l mm mn">    showTransactionList(transactions: Transaction[]): <strong class="mg hi">any</strong>;</span><span id="243d" class="lr kv hh mg b fi mo ml l mm mn">    showAccountSummary(accounts: Account[], currencyType?: CurrencyType, balanceType?: <strong class="mg hi">string</strong>): <strong class="mg hi">any</strong>;</span><span id="6948" class="lr kv hh mg b fi mo ml l mm mn">    showOwe(accounts: Account[]): <strong class="mg hi">any</strong>;</span><span id="a646" class="lr kv hh mg b fi mo ml l mm mn">    showPayBill(account: Account, payBillData?: PayBillData): <strong class="mg hi">any</strong>;</span><span id="66c7" class="lr kv hh mg b fi mo ml l mm mn">    showPayConfirm(account: Account, payBillData?: PayBillData): <strong class="mg hi">any</strong>;</span><span id="685e" class="lr kv hh mg b fi mo ml l mm mn">    showPaySuccess(confirmationCode: <strong class="mg hi">string</strong>): <strong class="mg hi">any</strong>;</span><span id="aa4b" class="lr kv hh mg b fi mo ml l mm mn">    showSpent(transactionResponse: TransactionResponse, sessionData: TransactionSessionData): <strong class="mg hi">any</strong>;</span><span id="a78a" class="lr kv hh mg b fi mo ml l mm mn">    showFailure(): <strong class="mg hi">any</strong>;</span><span id="8a15" class="lr kv hh mg b fi mo ml l mm mn">    showHelp(): <strong class="mg hi">any</strong>;</span><span id="1903" class="lr kv hh mg b fi mo ml l mm mn">    showAccountSelector(accounts: Account[]): <strong class="mg hi">any</strong>;</span><span id="f688" class="lr kv hh mg b fi mo ml l mm mn">    showPayoff(accountList: Account[]): <strong class="mg hi">any</strong>;</span><span id="4b97" class="lr kv hh mg b fi mo ml l mm mn">    showEasterEgg(): <strong class="mg hi">any</strong>;</span><span id="1138" class="lr kv hh mg b fi mo ml l mm mn">    showGoodbye(): <strong class="mg hi">any</strong>;</span><span id="7f64" class="lr kv hh mg b fi mo ml l mm mn">    showWelcomePin(): <strong class="mg hi">any</strong>;</span><span id="ac28" class="lr kv hh mg b fi mo ml l mm mn">    showWrongPin(): <strong class="mg hi">any</strong>;</span><span id="ab78" class="lr kv hh mg b fi mo ml l mm mn">    showLockout(): <strong class="mg hi">any</strong>;</span><span id="24fe" class="lr kv hh mg b fi mo ml l mm mn">    showWelcome(): <strong class="mg hi">any</strong>;</span><span id="b85c" class="lr kv hh mg b fi mo ml l mm mn">    showAbandonment(): <strong class="mg hi">any</strong>;</span><span id="d458" class="lr kv hh mg b fi mo ml l mm mn">    showEntitlementsLockout(): <strong class="mg hi">any</strong>;</span><span id="5c24" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="8a45" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的设计团队与我们的客户一起进行了大量的用户实验，以确定他们如何结合语音体验与视觉显示进行交互；这些发现令人着迷。我们发现，客户如何与技能交互很大程度上取决于设备和UI功能的接近程度。借助抽象层，我们可以提供依赖于通道和设备特性的适当体验。</p><h2 id="765e" class="lr kv hh bd kw ls lt lu la lv lw lx le jr ly lz lg jv ma mb li jz mc md lk me bi translated">交互适配器</h2><p id="78b8" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">对话工厂的核心和灵魂是交互适配器，它是负责检索必要数据以提供响应或代表客户执行任务的通道不可知代码和与该平台交互的通道特定实现细节之间的纽带。</p><p id="8777" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们发现了语音平台的响应回合制范例之间的共同行为，并将其抽象到这个基类中。</p><p id="7114" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">ask()方法接受语音响应，并识别适配器以保持对话打开，因为我们正在等待响应。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="2287" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public </strong>ask(speech: <strong class="mg hi">string</strong>) {</span><span id="ea95" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.safeAppendSpeech(speech);</span><span id="7c52" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.askTell = "Ask";</span><span id="cd90" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="3b39" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">tell()方法接受语音响应，但不知道对话是否应该保持开放，这是由特定于通道的实现决定的，通常取决于调用技能的方式(Ask vs Open)。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="d998" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public </strong>tell(speech: <strong class="mg hi">string</strong>) {</span><span id="e7c8" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.safeAppendSpeech(speech);</span><span id="862d" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.askTell = "Tell";</span><span id="250d" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="c6ed" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，我们发现重新提示在各种渠道中很常见，并引入了一种方法来接受该语音，即reprompt()。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="2676" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public </strong>reprompt(repromptSpeech: <strong class="mg hi">string</strong>) {</span><span id="c893" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.repromptSpeech = repromptSpeech;</span><span id="bdd8" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="2f5b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">除了这些基本方法之外，我们还有一些其他方法来帮助支持各种原因的特定用例，例如保持对话框打开、抑制重新提示以及在发送响应后发送回调。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="81fe" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public </strong>sendCallback(callback: <strong class="mg hi">any</strong>) {</span><span id="4fd1" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.callback = callback;</span><span id="5012" class="lr kv hh mg b fi mo ml l mm mn">}</span><span id="58f5" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public </strong>shouldNotReprompt(value: <strong class="mg hi">boolean</strong>): <strong class="mg hi">void </strong>{</span><span id="c70f" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.doNotReprompt = value;</span><span id="35f9" class="lr kv hh mg b fi mo ml l mm mn">}</span><span id="af08" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public </strong>shouldKeepDialogOpen(value: <strong class="mg hi">boolean</strong>): <strong class="mg hi">void </strong>{</span><span id="d078" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.askTell = value ? "Ask" : "Tell";</span><span id="a7f0" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="35d5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们遵从特定于通道的实现来提供关于入站消息的细节，例如意图、参数(实体/槽)、对话上下文和用户上下文。除了提供关于入站消息的这些细节之外，适配器还负责为语音和显示提供特定于通道/功能的工厂。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="bbe5" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public abstract </strong>getIntent(): <strong class="mg hi">string</strong>;</span><span id="bcfe" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getArgument(key: <strong class="mg hi">string</strong>): <strong class="mg hi">any</strong>;</span><span id="66c8" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>clearArgument(key: <strong class="mg hi">string</strong>): <strong class="mg hi">void</strong>;</span><span id="ba60" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getState(key?: <strong class="mg hi">string</strong>): <strong class="mg hi">any</strong>;</span><span id="66ba" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>clearState(): <strong class="mg hi">void</strong>;</span><span id="d5cb" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getUserContext(): UserContext;</span><span id="27fe" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>send(speech?: <strong class="mg hi">string</strong>): <strong class="mg hi">void</strong>;</span><span id="0e5e" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getSpeechFactory(): SpeechFactory;</span><span id="e713" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getDisplayFactory(): DisplayFactory;</span><span id="d5e8" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>getPlatformId(): <strong class="mg hi">string</strong>;</span><span id="c563" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>showLinkingCard(): <strong class="mg hi">void</strong>;</span><span id="4745" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">public abstract </strong>display(display: <strong class="mg hi">any</strong>): <strong class="mg hi">void</strong>;</span></pre><h1 id="fbeb" class="ku kv hh bd kw kx ky kz la lb lc ld le in lf io lg iq lh ir li it lj iu lk ll bi translated">示例实现</h1><p id="240c" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">在上一节中，我们确定了如何抽象特定于通道的实现，以允许我们在对现有代码影响最小的情况下快速添加新的通道和功能。在接下来的几节中，我们将看一个部分具体的例子，然后看它们是如何联系在一起的。</p><h2 id="0192" class="lr kv hh bd kw ls lt lu la lv lw lx le jr ly lz lg jv ma mb li jz mc md lk me bi translated">MsbotInteractionAdapter</h2><p id="c1ca" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">构造函数接受Bot框架会话对象和参数，它们在传入的intent请求中提供。我们使用这些来提取意图、实体和用户信息，以帮助满足我们对InteractionAdapter的契约要求。我们还创建适当的显示和语音工厂。虽然我们只有一个用于Cortana的显示和语音工厂，但是我们可以询问传入的设备类型、支持的功能或用户偏好的请求，以实例化各种各样的实现，从而提供我们想要的确切体验。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="3057" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">constructor</strong>(<strong class="mg hi">protected </strong>session: builder.Session, <strong class="mg hi">protected </strong>botArgs: <strong class="mg hi">any</strong>) {</span><span id="7d4d" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">super</strong>();</span><span id="4dcc" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.intent = botArgs.intent;</span><span id="c595" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.state = JSON.stringify(botArgs.privateConversationData);</span><span id="ed08" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.speechFactory = <strong class="mg hi">new </strong>MsbotSpeechFactory();</span><span id="19ca" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.displayFactory = <strong class="mg hi">new </strong>MsbotDisplayFactory(<strong class="mg hi">this</strong>, session);</span><span id="d9a3" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">this</strong>.context = {</span><span id="8b7a" class="lr kv hh mg b fi mo ml l mm mn">        clientCorrelationId: session.message.sourceEvent.clientActivityId,</span><span id="9358" class="lr kv hh mg b fi mo ml l mm mn">        userId: session.message.user.id,</span><span id="4523" class="lr kv hh mg b fi mo ml l mm mn">    } <strong class="mg hi">as </strong>UserContext;</span><span id="5fd8" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="560b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">必须实现的其他InteractionAdapter方法都包含桥接我们的非通道特定方法调用和MS Bot框架特定会话和botArg对象的代码。请查看<a class="ae mp" href="https://github.com/Microsoft/BotBuilder/tree/master/Node/examples" rel="noopener ugc nofollow" target="_blank"> Bot Builder框架示例</a>，了解如何询问会话对象以支持您的技能需求。</p><h1 id="6e37" class="ku kv hh bd kw kx ky kz la lb lc ld le in lf io lg iq lh ir li it lj iu lk ll bi translated">在实践中</h1><p id="256a" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">现在我们已经看到了抽象，让我们看看它是如何在没有特定于通道的细节进入我们的意图处理程序的情况下结合在一起的。</p><h2 id="197a" class="lr kv hh bd kw ls lt lu la lv lw lx le jr ly lz lg jv ma mb li jz mc md lk me bi translated">帐户余额意向处理程序</h2><p id="3058" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们将使用帐户余额的基本用例来说明。我们如何协调我们的API、缓存集群和数据库来获取填充响应所需的信息，这超出了本讨论的范围。</p><ul class=""><li id="925d" class="kg kh hh jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><strong class="jk hi">查询入站消息</strong></li></ul><p id="667d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这段代码中，我们提取了ProductType和LastFour的参数(实体),因为这将决定我们在响应中如何/向用户呈现什么。然后，我们使用一个服务来检索必要的数据，并引导数据响应为用户构建响应。</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="37b6" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">const </strong>lastFour = adapter.getArgument("LastFour");</span><span id="a12f" class="lr kv hh mg b fi mo ml l mm mn"><strong class="mg hi">const </strong>productType = adapter.getArgument("ProductType");</span><span id="0962" class="lr kv hh mg b fi mo ml l mm mn">accounts.getAccount(adapter.getUserContext(), {accountType, lastFour, productType})</span><span id="a4dc" class="lr kv hh mg b fi mo ml l mm mn">    .then(accountList =&gt; buildAccountBalanceResponse(adapter, accountList, accountType, adapter.getArgument("CurrencyType")))</span><span id="7985" class="lr kv hh mg b fi mo ml l mm mn">    .catch(error =&gt; handleDataRetrievalError(error, adapter, <strong class="mg hi">true</strong>));</span></pre><ul class=""><li id="61e1" class="kg kh hh jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><strong class="jk hi">大厦响应</strong></li></ul><p id="428b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在构建响应时，会调用交互适配器提供的显示工厂，这样我们就可以构建适合通道的可视响应。然后我们调用另一个helper方法来汇总账户总数</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="ae34" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">function </strong>buildAccountBalanceResponse(adapter: InteractionAdapter, accountList: Account[], accountType: AccountType, currencyType: CurrencyType) {</span><span id="28aa" class="lr kv hh mg b fi mo ml l mm mn">    adapter.getDisplayFactory().showAccountSummary(accountList, currencyType);</span><span id="7ce6" class="lr kv hh mg b fi mo ml l mm mn">    adapter.send(accountList</span><span id="cec8" class="lr kv hh mg b fi mo ml l mm mn">            .map(account =&gt; readAccountTotal(adapter.getSpeechFactory(), account, accountList.length &gt; 1, isBank(account.accountType) ? currencyType : undefined))</span><span id="84c7" class="lr kv hh mg b fi mo ml l mm mn">            .join(""));</span><span id="9afe" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><p id="a717" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个帮助器方法负责查看所有不同的帐户类型，并为该响应收集语音。我们在这里隐藏了一些代码，以保持它针对信用卡:</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="9919" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">function </strong>readAccountTotal(speechFactory: SpeechFactory, account: Account, useMulti: <strong class="mg hi">boolean</strong>, currencyType: CurrencyType) {</span><span id="6367" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">const </strong>balance = formatCurrency(account.accountBalance, currencyType);</span><span id="53a5" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">const </strong>balanceName = isBank(account.accountType) ? "available" : isCardAccountType(account.accountType) ? "current" : "principal";</span><span id="9e00" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">const </strong>suffix = getSuffix(account.accountType);</span><span id="221e" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">const </strong>productName = isLoan(account.accountType) ? "" : ` ${account.toSpeech(speechFactory, useMulti)}`;</span><span id="c08c" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">return </strong>`Your ${balanceName}${productName} balance is ${balance}${suffix}.  `;</span></pre><p id="c19c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后，我们遵从帐户模型的toSpeech()方法，传入语音工厂以确保最后四个被正确读取:</p><pre class="ix iy iz ja fd mf mg mh mi aw mj bi"><span id="a112" class="lr kv hh mg b fi mk ml l mm mn"><strong class="mg hi">public </strong>toSpeech(speechFactory: SpeechFactory, sayLast4 = <strong class="mg hi">false</strong>) {</span><span id="a894" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">const </strong>last4Speech = sayLast4 ? ` ending in ${speechFactory.speakLastFour(<strong class="mg hi">this</strong>.lastFour)}` : "";</span><span id="77d2" class="lr kv hh mg b fi mo ml l mm mn">    <strong class="mg hi">if </strong>(<strong class="mg hi">this</strong>.accountType === AccountType.CREDIT) {</span><span id="b9c8" class="lr kv hh mg b fi mo ml l mm mn">        <strong class="mg hi">return </strong>`${<strong class="mg hi">this</strong>.productName} card${last4Speech}`;</span><span id="2137" class="lr kv hh mg b fi mo ml l mm mn">    }</span><span id="ae03" class="lr kv hh mg b fi mo ml l mm mn">    ...</span><span id="c9e2" class="lr kv hh mg b fi mo ml l mm mn">}</span></pre><h1 id="a82b" class="ku kv hh bd kw kx ky kz la lb lc ld le in lf io lg iq lh ir li it lj iu lk ll bi translated">摘要</h1><p id="facc" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">多模态对话界面正在爆炸，许多AI/NLP提供商正在这个领域涌现。在多模态对话和各种人工智能/自然语言处理提供者的背景下，为重用、速度和质量构建软件需要在几个层面上进行深思熟虑的决策。在Capital One，我们利用解决方案架构以及模式和抽象，使我们能够在快速变化的环境中继续保持速度和质量。</p></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="e61c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em></p><p id="0172" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">欲了解更多关于Capital One的API、开源、社区活动和开发者文化，请访问我们的一站式开发者门户DevExchange。</em><a class="ae mp" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="ke"/></a></p></div></div>    
</body>
</html>