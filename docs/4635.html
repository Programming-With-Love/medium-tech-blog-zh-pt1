<html>
<head>
<title>The Single Biggest Mistake Programmers Make Every Day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员每天犯的最大错误</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/the-single-biggest-mistake-programmers-make-every-day-62366b432308?source=collection_archive---------2-----------------------#2015-11-05">https://medium.com/javascript-scene/the-single-biggest-mistake-programmers-make-every-day-62366b432308?source=collection_archive---------2-----------------------#2015-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/258c0ea01501dd4ca3fc0930d6a7e7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-o-C-S0wOxk0A9c3BG1-w.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Oops — Craig Sunter (CC BY-ND 2.0)</figcaption></figure><div class=""/><p id="6d82" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我最近在一个会议上教了一个大师班。这一天的前半天，我站在全班面前，谈论JavaScript的两大支柱:<a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.nofip7b3x">原型OO </a>和<a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.8d1nquob2">函数式编程</a>。</p><p id="0173" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在后半部分，我让学生们组队合作开发一个应用程序项目。作业是记住课程中的几个要点:</p><ul class=""><li id="4fd6" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hx">不要导出任何类。如果你需要实例化任何东西，使用工厂函数。</strong></li><li id="51e0" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">尽可能使用纯函数。一个纯函数不会改变自身以外的任何东西。纯函数不会产生副作用。给定相同的输入，纯函数将总是返回相同的输出。</li><li id="5d20" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">注意有多少程序状态可以用<strong class="iv hx">事物列表来表示。</strong></li></ul><p id="e6fc" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在开始练习任务后，我花了一天的时间在房间里走来走去，帮助团队进步。我注意到一个一致的主题，这启发了我在Twitter上提出的一个问题:</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="314a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我得到了一些很好的回应。以下是一些我最喜欢的:</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="km kl l"/></div></figure><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="km kl l"/></div></figure><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="km kl l"/></div></figure><p id="7480" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我个人最喜欢的是:</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="km kl l"/></div></figure><p id="6561" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">布伦丹·艾希似乎也很喜欢:</p><figure class="kg kh ki kj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kn"><img src="../Images/32430d599f91e6aca92c85e6df5e2aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhPtKNTCDzCVB8T2_LTH5Q.png"/></div></div></figure><p id="af6b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我相信每个程序员时常犯的最大的错误就是<strong class="iv hx">把事情变得过于复杂</strong>。</p><h2 id="c885" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">保持简单愚蠢</h2><p id="55d3" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">有一个共同的设计原则(根据维基百科)起源于美国海军:</p><blockquote class="lo lp lq"><p id="3b50" class="it iu lr iv b iw ix iy iz ja jb jc jd ls jf jg jh lt jj jk jl lu jn jo jp jq ha bi translated"><a class="ae jr" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank"><strong class="iv hx">K</strong></a><strong class="iv hx">ISS—K</strong>eep<strong class="iv hx">I</strong>t<strong class="iv hx">S</strong>imple，<strong class="iv hx"> S </strong> tupid</p></blockquote><p id="827c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我认为这还不够，所以我说“保持它<strong class="iv hx">愚蠢简单】</strong>。</p><p id="8ec9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我的意思是，你应该想出最简单的方法来实现目标，然后让它变得更简单。</p><blockquote class="lo lp lq"><p id="d23d" class="it iu lr iv b iw ix iy iz ja jb jc jd ls jf jg jh lt jj jk jl lu jn jo jp jq ha bi translated">“完美不是在没有更多可以增加的时候，而是在没有更多可以减少的时候。”<br/> ~安东尼·德·圣埃克苏佩里</p></blockquote><h2 id="3c03" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">什么是简单代码？</h2><p id="9d7b" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">简单，源自拉丁语<em class="lr"> simplus，</em>最初指由一种成分制成的药物，尤指由一种植物制成的药物。我这里指的意思是“不复杂，不复合；单身。”简单vs复杂可以简洁地总结为:<strong class="iv hx">一件事</strong> vs <strong class="iv hx">很多事。</strong></p><p id="dd4e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">有一点</strong>就是<em class="lr">简单。</em></p><p id="c1ec" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">很多事情</strong>都是<em class="lr">复杂的。</em></p><p id="0d64" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我说你应该保持代码尽可能简单时，我的意思是什么？我相信所有的代码都应该是简单的(如<em class="lr"> easy </em>):</p><ul class=""><li id="7c34" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hx">简单易懂。</strong></li><li id="ff08" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">使用简单。</strong></li><li id="19c7" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">简单重复使用。</strong></li><li id="edf9" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">简单延伸。</strong></li></ul><p id="7bf2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让事情<em class="lr">变得简单</em>的最好方法是让你的代码<strong class="iv hx">简单，</strong>就像<strong class="iv hx">做一件事情</strong>(点)。</p><h2 id="4731" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">该过程</h2><p id="7f1c" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">我第一次在教室里走动时，注意到学生们被困在兔子洞里。一个团队被困在创建构建过程中。另一个人被所有的数据结构困住了。另一个是在有任何功能让数据流通过之前，试图找出如何将功能数据流应用于问题。</p><p id="133a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">所有的团队都会从Kent Beck的建议中受益，他是<a class="ae jr" href="http://amzn.to/1Ok0rjY" rel="noopener ugc nofollow" target="_blank">“测试驱动的开发实例”</a>的作者:</p><ol class=""><li id="d80d" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq lv jy jz ka bi translated">让它发挥作用。</li><li id="ab76" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq lv jy jz ka bi translated">做正确的事。</li><li id="7761" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq lv jy jz ka bi translated">动作快点。</li></ol><p id="e24c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">第一步应该是让它发挥作用。最好的方法就是简化。现在就做最简单的事情，这会让你朝着目标前进。</p><h2 id="9dfc" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">“让它工作”是什么意思？</h2><p id="1cf5" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">因为我喜欢即时反馈，所以我总是从一些简单的单元测试开始，当我有一个可行的解决方案时，这些测试会立即提醒我。在单元测试期间，我决定我所说的“让它工作”是什么意思。该解决方案需要满足的最低要求是什么？</p><p id="063a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">练习作业是一个简单的scrum签入应用程序。我有意选择这个应用程序，因为它可以让学生练习一些简单的函数式编程，<a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">避免在开发人员通常依赖类和类继承的情况下使用<em class="lr">` class `</em></a>:UI代码。</p><p id="3cca" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在敏捷开发中，我们努力实现最小有效量的过程，以实现<a class="ae jr" rel="noopener" href="/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021">高速开发</a>。</p><p id="4724" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">scrum会议是这个最小过程的一个常见元素。它的目的是允许团队成员互相检查。在每个工作日，每个小团队都要回答三个问题:</p><ul class=""><li id="734a" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated">上个工作日你做了什么？</li><li id="d95e" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">你今天要做什么？</li><li id="3a1b" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">有什么阻挡你吗？</li></ul><p id="811c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">checkin应用程序让你不用开会就可以进行scrum签入。</p><p id="5c39" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们从第一步开始:用户必须能够识别自己。为此，我们可能需要某种类型的登录屏幕。</p><p id="75a9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这个应用程序的情况下，我鼓励学生使用React，我提供了<a class="ae jr" href="https://github.com/ericelliott/react-pure-component-starter" rel="noopener ugc nofollow" target="_blank"> React纯组件启动器</a>作为应用程序的起点。</p><p id="5b86" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在此基础上，第一步是创建一个React组件，该组件显示用户名的文本字段和一个“登录”按钮。</p><p id="22b6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我相信你应该总是首先从测试开始，这一信念得到了微软和IBM研究的支持。你可以在我的博客<a class="ae jr" rel="noopener" href="/javascript-scene/what-every-unit-test-needs-f6cd34d9836d">“每个单元测试必须回答的五个问题”</a>中了解更多。</p><p id="2543" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你应该从能回答这个问题的测试开始，“它有用吗？”</p><p id="dd09" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我总是从简单的、人类可读的需求描述开始我的单元测试。在这种情况下，这些可能看起来像这样:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="8e56" class="ko kp hw lx b fi mb mc l md me">`should display a text input field for the user's name.`<br/>`should display a "Sign In" button.`</span></pre><p id="83a4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦按钮被按下，我们应该创建一些代表当前登录用户的应用程序状态:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="1bd5" class="ko kp hw lx b fi mb mc l md me">`should save current logged-in user in client state.`</span></pre><p id="e73c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，对于我们的一个应用视图,“让它工作”意味着什么，我们已经有了一个很好的定义。在进入应用程序的其余部分之前，我们应该通过这些测试。</p><p id="4900" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">课程:</p><ul class=""><li id="5420" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hx">了解问题。</strong>知道“让它工作”是什么意思。</li><li id="8cc5" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">从头开始。如果任务是识别当前用户正在做什么，第一步可能是识别当前用户是谁。</strong></li><li id="d7df" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">一次做一件事。不要试图把所有的app需求都挤进你写的第一个模块里。你完成的应用程序可能会包含许多模块。保持每个模块小而集中，一次专注于一个模块。</li><li id="3413" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">从小做起，迭代。</strong>写一个测试。让它过去。重构。让它工作。做正确的事。动作快点。一步一步来。继续采取这些步骤，直到工作完成。</li></ul><h1 id="bcc8" class="mf kp hw bd kq mg mh mi ku mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv bi translated">简单易懂</h1><p id="d1f7" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated"><strong class="iv hx">每行做一件事。</strong></p><p id="ef21" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">每个功能做一件事。</strong>例如，如果您需要使用查询参数的值，您应该使用一个函数从URL中提取查询参数的值，而不是将该逻辑与使用该值的函数混合。</p><p id="b87b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">用一个变量只代表一件事。</strong>有时，创建一个变量来表示一些数据，然后使用该变量作为一个临时位置来存储从一种表示到另一种表示的转换值，这很有吸引力。例如，您可能需要一个查询字符串参数值，并从存储整个URL开始，然后只存储查询字符串，然后是值。最好为URL使用一个变量，为查询字符串使用另一个变量，最后使用一个变量来存储值。</p><p id="4d86" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这就是为什么在ES6中我更喜欢<em class="lr"> `const` </em>而不是<em class="lr"> `let` </em>。在JavaScript中，<em class="lr"> `const` </em>意味着变量不能被重新赋值。(不要与不可变的值混淆。不像那些由Immutable.js和Mori产生的真正的不可变数据类型，一个<em class="lr"> `const` </em>对象可以有变异的属性。)</p><p id="4e17" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lr"> `const` </em>是变量不会被重新分配的信号。<em class="lr"> `let '，</em>是变量<em class="lr">可能被重新分配</em>的信号，如循环中的计数器，或算法中的值交换。如果我不需要重新赋值，<em class="lr"> `const` </em>是我的默认选择，而不是<em class="lr"> `let` </em>，因为我希望代码中的用法尽可能清晰。我在ES6里不用<em class="lr"> `var` </em>。循环在块范围内是有价值的，但是我想不出有什么情况比<em class="lr"> `let` </em>更喜欢【T20 . ` var`。</p><p id="29b2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有时，一个函数可能会表现出隐藏的复杂性，这意味着它做的不止一件事，但它并不是立即显而易见的。一个函数可以通过多种方式产生副作用，或者产生一系列复杂的可能结果。让我们来探索如何简化函数的效果。</p><h2 id="77c0" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">避免副作用</h2><p id="710d" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">任何程序的本质都是取一些数据作为输入，产生一些数据作为输出。</p><p id="5934" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是程序最简单的地方。</p><p id="0891" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">函数的本质是取一些数据作为输入，产生一些数据作为输出。</p><p id="11f3" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此，最简单的实现可能是函数。</p><p id="30c6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果一个函数符合这个定义，就很容易理解:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="169b" class="ko kp hw lx b fi mb mc l md me">foo(...inputs) =&gt; output</span></pre><p id="3ec4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">根据上面的签名，函数<em class="lr"> `foo()` </em>接受任意数量的参数作为输入，并返回一些输出。这很容易理解:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="5a4c" class="ko kp hw lx b fi mb mc l md me">const result = foo(a, b, c);</span></pre><p id="0c1c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，自变量<em class="lr"> `a` </em>、<em class="lr"> `b` </em>、<em class="lr"> `c` </em>进去，出来的是<em class="lr"> `result` </em>。但是如果事情不只是这样呢？如果<em class="lr"> `a` </em>是一个数组，而<em class="lr"> `foo()` </em>要对它进行变异，那会怎么样？那么<em class="lr"> `foo()` </em>的效果就不能单纯看它的函数签名来理解了。为了理解<em class="lr"> `foo()` </em>的影响，你还必须追溯<em class="lr"> `a` </em>的完整一生。</p><p id="8db7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在JavaScript中，数组和对象是通过引用传递的，所以如果您改变数组或对象参数，它不仅仅影响函数内部的变量。它还会影响使用对同一变量的引用的任何其他函数。</p><p id="5f31" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在编程行话中，<em class="lr"> `a` </em>的变异被称为<strong class="iv hx">副作用。副作用并不明显可见，所以当它们引起一个bug时，可能很难追踪到根本原因。</strong></p><p id="09aa" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此，最简单的功能不会引起<strong class="iv hx">副作用。</strong></p><p id="196e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">副作用包括在函数外部可见的任何状态变化。这包括记录消息、在屏幕上显示内容以及抛出异常。</p><p id="d91d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果一个函数有可能抛出异常，那么这个事实应该清楚地记录下来。如果有可能避免一个异常，并且<strong class="iv hx">仍然使得函数可以安全地使用</strong>，那么你应该选择这个过程而不是抛出。这允许您的函数遵守健壮性原则:</p><blockquote class="mw"><p id="4a74" class="mx my hw bd mz na nb nc nd ne nf jq dx translated">"接受的要开明，送出的要保守。"</p></blockquote><p id="8930" class="pw-post-body-paragraph it iu hw iv b iw ng iy iz ja nh jc jd je ni jg jh ji nj jk jl jm nk jo jp jq ha bi translated">我的解释更笼统一些:</p><blockquote class="mw"><p id="1de6" class="mx my hw bd mz na nb nc nd ne nf jq dx translated">“做最坏的打算。好好表现。”</p></blockquote><p id="44e1" class="pw-post-body-paragraph it iu hw iv b iw ng iy iz ja nh jc jd je ni jg jh ji nj jk jl jm nk jo jp jq ha bi translated">简而言之，如果发生了任何没有被函数签名传达的变化，这就是副作用。</p><p id="3ee6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只要有可能，我们应该<strong class="iv hx">避免副作用。</strong></p><h2 id="a44a" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">支持一致性</h2><p id="b5e4" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">如果你用相同的输入多次调用同一个函数，而它返回不同的输出，原因并不总是显而易见的。一些函数依赖于随机输入，或者根据它被调用的时间，或者函数签名中没有指定的一些外部变量的值，输出有所不同。</p><p id="d03b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这样的函数很难调试。只要有可能，确保您的函数在相同的输入下总是返回相同的输出。</p><p id="0dde" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个特征意味着这样的函数是<strong class="iv hx">幂等的</strong>。也就是多次调用函数的结果和调用一次函数是一样的。</p><p id="8f24" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">没有副作用的幂等函数有一个特性叫做<strong class="iv hx">引用透明</strong>。这意味着如果你有一个函数调用:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="4fb7" class="ko kp hw lx b fi mb mc l md me">const foo = f(a);</span></pre><p id="b0f0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以用<em class="lr"> `f(a)` </em>的结果替换那个函数调用，而不改变程序的含义。因此，例如，如果<em class="lr"> `f(a)` </em>的结果是<em class="lr"> `42`, </em>您可以将上面的代码改为:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="90a9" class="ko kp hw lx b fi mb mc l md me">const foo = 42;</span></pre><p id="e067" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你的程序仍然会像预期的那样工作。</p><h2 id="cd36" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">纯函数是最简单的函数</h2><p id="91c9" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">没有副作用并表现出参照透明性的函数称为<strong class="iv hx">纯函数。</strong></p><p id="84c7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">一个纯函数:</strong></p><ul class=""><li id="3068" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated">给定相同的输入，将总是返回相同的输出(不依赖于共享的可变状态或熵)。</li><li id="c80a" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">不会产生副作用。</li></ul><p id="f484" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最简单的函数是纯函数。如果一个问题可以用纯函数来解决，那么纯函数很有可能是这个问题最简单的解决方案。</p><h1 id="02d6" class="mf kp hw bd kq mg mh mi ku mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv bi translated">简单易用</h1><p id="b993" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">简单易用意味着代码应该有一个清晰和集中的API。代码做<strong class="iv hx">一件事</strong>，它有一个简单的接口来完成那件事。</p><h2 id="5ecd" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">避免特别的多态性</h2><p id="ff0f" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">在JavaScript中可以使用<strong class="iv hx">特别多态</strong>来创建一个做许多不同事情的函数。例如，jQuery接受许多不同类型的jQuery函数输入。</p><p id="71c9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你传递一个函数，它会在页面就绪时被触发。如果传递一个字符串，它会被解释为DOM选择器，依此类推。</p><p id="f04f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">jQuery在这里应该有一点余地，因为它是在JavaScript有一个好的模块格式之前编写的，但是现在，如果您可以这样做，不是更清楚吗？</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="db05" class="ko kp hw lx b fi mb mc l md me">import { pageReady, $ } from 'jQuery';</span><span id="6964" class="ko kp hw lx b fi nl mc l md me">pageReady(() =&gt; {<br/>  $('.your-selector').on('click', () =&gt; {<br/>    doStuff();<br/>  });<br/>});</span></pre><p id="870f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当然，有经验的jQuery开发者都知道<em class="lr">` $(fn)；`</em>表示<em class="lr"> `$(文档)。就绪(fn)；`</em>，但是新开发者呢？难道你不应该能够浏览一些代码，并根据事物的名称猜测其含义吗？</p><p id="070e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">即席多态性意味着在函数内部，您查看输入，并根据它们的类型或值，遵循条件逻辑的不同分支。特殊多态性增加了函数的复杂性，迫使您编写不必要的条件逻辑，并使您无法为希望函数扮演的每个不同角色编写语义名称。</p><p id="cf0f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们的新标准模块意味着创建和使用更小、更集中的模块比将一堆松散相关的任务组合成一个功能更容易。</p><h2 id="fb8f" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">封装私有数据</h2><p id="9ba5" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">我认为从一个模块中导出的对象也应该作为该模块的文档。换句话说，它应该公开支持的接口，并且<strong class="iv hx">只公开支持的接口。</strong></p><p id="fe1e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">关于私有实现细节的事情是，它们比公共API更有可能有突破性的改变，如果可以避免的话，应该避免突破性的改变。</p><p id="3985" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在JavaScript中，有一个常见的约定是在私有属性前面加上下划线:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="35c5" class="ko kp hw lx b fi mb mc l md me">const foo = () =&gt; {<br/>  return {<br/>    _secret: ‘yeah, nobody could possibly find this…’,<br/>    getSecret () {<br/>      return this._secret;<br/>    }<br/>  };<br/>};</span><span id="c1c9" class="ko kp hw lx b fi nl mc l md me">const bar = foo();</span><span id="e74b" class="ko kp hw lx b fi nl mc l md me">console.log(bar._secret); // yeah, nobody could possibly find this…</span></pre><p id="c883" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">私有下划线约定有缺陷，原因有两个:</strong></p><ul class=""><li id="dbbf" class="js jt hw iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hx">新手不知道下划线是什么意思，就忽略了。</strong></li><li id="267e" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">有经验的开发者认为对他们不适用。“我知道我在做什么。这个警告只是针对新手的。”所以他们也忽略了。承认吧，有经验的开发者。你以前做过这个。我也是。向你们三个比我们其他人更守纪律的人道歉。；)</strong></li></ul><p id="c8fe" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">与常见的误解相反，JavaScript支持真正的封装。</p><p id="e2c1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像对象一样，闭包也是一种包含状态的机制。在JavaScript中，每当函数访问在直接函数作用域之外定义的变量时，就会使用闭包。使用闭包很容易:只需在另一个函数中定义一个函数，然后通过返回或者传递给另一个函数来公开内部函数。内部函数使用的变量将对它可用，即使在外部函数已经完成运行之后。</p><p id="e586" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可以使用闭包通过工厂函数在JavaScript中创建数据隐私:</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="c0e1" class="ko kp hw lx b fi mb mc l md me">const counter = function counter() {<br/>  let count = 0;<br/>  return {<br/>    getCount() {<br/>      return count;<br/>    },<br/>    increment() {<br/>      count += 1;<br/>      return this;<br/>    }<br/>  };<br/>};</span><span id="1821" class="ko kp hw lx b fi nl mc l md me">const myCounter = counter();<br/>console.log(typeof myCounter.count); // undefined -- private!</span><span id="e687" class="ko kp hw lx b fi nl mc l md me">myCounter.increment().increment().increment();<br/>console.log(myCounter.getCount()); // 3</span></pre><p id="8b52" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这在构造函数中也适用，但是<a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">工厂更好</a>。</p><h2 id="19d6" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">纯函数&gt;函数&gt;工厂&gt;类</h2><p id="11fb" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">请注意，当您从左向右移动时，这些东西的复杂性会增加。从左侧开始，仅在需要时向右移动<strong class="iv hx"/>。</p><blockquote class="lo lp lq"><p id="131a" class="it iu lr iv b iw ix iy iz ja jb jc jd ls jf jg jh lt jj jk jl lu jn jo jp jq ha bi translated">“有时候，优雅的实现只是一个函数。不是方法。不是一个班。不是框架。只是一个功能。”~约翰·卡马克</p></blockquote><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="69dc" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这句话值得再读两遍。将它铭刻在你的脑海中，这样你每次实现新功能时都会想起它。</p><p id="e12a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于模块接口，我更喜欢纯函数而不是有状态或副作用的函数，常规函数而不是工厂，我<a class="ae jr" rel="noopener" href="/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b">从不导出一个<em class="lr"> `class` </em> </a>。</p><p id="5197" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">注意:</strong> <a class="ae jr" rel="noopener" href="/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a"> <em class="lr">你永远不需要在JavaScript中导出一个‘类’。</em>T13】</a></p><h1 id="9bf5" class="mf kp hw bd kq mg mh mi ku mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv bi translated"><strong class="ak">简单复用</strong></h1><p id="1dc5" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">易于重用意味着您应该能够将代码提取到它自己的模块中，将其导入到其他地方，并且在使用它时不会破坏一堆东西或进行耗时的重构。理想情况下，这应该是一个剪切、一个粘贴和几个<em class="lr"> `import` </em>语句。</p><p id="61ba" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果一个函数依赖于任何外部状态，那就没那么简单了。您需要更改函数签名，找到所有调用点，并传入所有需要的参数。</p><p id="d9c4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果函数有副作用，并且依赖于时间(相对于时钟时间，或者相对于其他操作或函数调用的运行时间)，那就更成问题，更难解决。</p><p id="7f81" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于它们独立于共享状态、定时和类似的因素，纯函数显然比不纯函数更容易重用。</p><h1 id="6cc0" class="mf kp hw bd kq mg mh mi ku mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv bi translated">易于扩展</h1><p id="3533" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">为了稳定性，API应该对突破性的改变关闭，但对扩展开放。对于函数来说，这可能意味着将命名的选项传递给函数，而不是传递一系列参数，这样就可以避免传递一堆在函数调用点可能是也可能不是语义命名的值。</p><p id="5ccc" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用options对象还允许您避免为可选参数传递<em class="lr"> `null` </em>。</p><p id="91af" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">什么读起来更好？</p><pre class="kg kh ki kj fd lw lx ly lz aw ma bi"><span id="5d6d" class="ko kp hw lx b fi mb mc l md me">// Individual arguments<br/>const item = createFilmItem(title, null, null, recommendedPrice);</span><span id="2d5a" class="ko kp hw lx b fi nl mc l md me">// Options object<br/>const item = createFilmItem({ title, recommendedPrice });</span></pre><p id="c884" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">第一个例子使用了函数signature: <em class="lr"> `(title: String，releaseDate？:日期，运行时间？:Number，recommendedPrice: Number) = &gt;电影`</em></p><p id="64cb" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用单独的参数而不是options对象迫使您传递不需要传递(或不能传递，因为信息不可用)的可选值的<em class="lr"> `null` </em>值占位符。</p><p id="e18f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对比第二个函数签名:<em class="lr">` createfilmitem({ title:String，releaseDate？:日期，运行时间？:Number，recommendedPrice: Number }) = &gt;电影`</em></p><p id="6d25" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用options对象为将来的API扩展留下了很大的灵活性。</p><p id="b13f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lr">读取函数签名有困难吗？查看</em> <a class="ae jr" href="https://github.com/ericelliott/rtype#reading-function-signatures" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Rtype:读取函数签名</em> </a> <em class="lr">中的文档以获得解释。</em></p><h2 id="dd01" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">导出工厂而不是类</h2><p id="5c16" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">正如我在之前提到过<a class="ae jr" rel="noopener" href="/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b">很多次</a><a class="ae jr" rel="noopener" href="/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf"/><a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">，<em class="lr"> `class` </em>提供<em class="lr"> `extends` </em>就像球可以扔，椅子可以坐，但是<em class="lr"> `extends` </em>将粗心的开发人员引向<strong class="iv hx">脆弱的基类问题</strong>，<strong class="iv hx">大猩猩香蕉问题</strong>等等…</a></p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="nm kl l"/></div></figure><p id="08fe" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不要引诱你的用户撞上糟糕的OO设计的岩石(如果有足够的时间和进化，<strong class="iv hx">所有的类分类设计对于新的用例来说都是错误的</strong>)。</p><p id="8467" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">相反，通过导出一些易于扩展或组合成新对象的东西来为它们的成功做准备。如果不需要实例状态，导出一个纯函数或普通函数。如果你确实需要实例状态，尝试一个stamp:参见Stamp规范。</p><p id="55b1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx">在JavaScript中，任何函数都可以实例化并返回对象。</strong>当你在没有构造函数(例如ES6 <em class="lr"> `class` </em>)的情况下这样做时，它被称为<strong class="iv hx">工厂函数。</strong> ` <em class="lr">级</em>`无法与工厂的力量和灵活性竞争——特别是邮票。</p><p id="7dd7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于工厂增加了灵活性，从类实现到工厂实现的重构通常是可取的。例如，添加多态性(<a class="ae jr" href="https://gist.github.com/ericelliott/e994ee541d0ed365f5fd" rel="noopener ugc nofollow" target="_blank">示例</a>)，或者切换到对象池以<a class="ae jr" href="https://www.youtube.com/watch?v=RWmzxyMf2cE" rel="noopener ugc nofollow" target="_blank">避免垃圾收集器</a>。</p><p id="715d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是因为ES6类抛出错误，如果你省略<em class="lr"> `new，</em>并且你控制之外的代码可能使用构造函数使能的特性，比如<em class="lr"> `instanceof，</em> <strong class="iv hx">从一个类切换到一个工厂是一个突破性的改变</strong>。</p><p id="e6ab" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">省点事吧。<strong class="iv hx">一开始就出口工厂。</strong></p><p id="df48" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><a class="ae jr" href="https://github.com/stampit-org/stamp-specification#stamp-specification-composables" rel="noopener ugc nofollow" target="_blank">带有图章的工厂组成</a>为API扩展提供了极大的灵活性；比<em class="lr">` class`</em>-甚至比实验性的特征如职业装饰者还要多。</p><h1 id="9cf3" class="mf kp hw bd kq mg mh mi ku mj mk ml ky mm mn mo lb mp mq mr le ms mt mu lh mv bi translated">结论</h1><p id="fee3" class="pw-post-body-paragraph it iu hw iv b iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ln jo jp jq ha bi translated">简化您的代码。从最简单的实现开始，只有当问题需要时，才朝着更复杂的解决方案前进。</p><h2 id="9a0b" class="ko kp hw bd kq kr ks kt ku kv kw kx ky je kz la lb ji lc ld le jm lf lg lh li bi translated">请记住:</h2><ul class=""><li id="43bb" class="js jt hw iv b iw lj ja lk je nn ji no jm np jq jx jy jz ka bi translated"><strong class="iv hx">保持愚蠢简单(吻)</strong></li><li id="c04d" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">让它工作，让它正确，让它快速。</li><li id="114a" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">理解问题。(</strong>知道“让它工作”是什么意思。)</li><li id="3527" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">从头开始。</strong></li><li id="4c03" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">从测试开始。</strong></li><li id="b6ea" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">做一件事(DOT)。</strong></li><li id="e0a0" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">从小做起，迭代。</strong></li><li id="669f" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hx">纯功能&gt;功能&gt;工厂&gt;类</strong></li></ul><p id="3785" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一周中的每一天，简单胜过聪明。</p></div><div class="ab cl nq nr go ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ha hb hc hd he"><h1 id="fef7" class="mf kp hw bd kq mg nx mi ku mj ny ml ky mm nz mo lb mp oa mr le ms ob mu lh mv bi translated"><a class="ae jr" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">跟随埃里克·埃利奥特学习JavaScript】</a></h1><ul class=""><li id="da2b" class="js jt hw iv b iw lj ja lk je nn ji no jm np jq jx jy jz ka bi translated">在线课程+定期网络广播</li><li id="250e" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">软件测试</li><li id="c5f8" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">JavaScript的两大支柱(原型OO +函数式编程)</li><li id="5e91" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">通用JavaScript</li><li id="9672" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">结节</li><li id="1a8a" class="js jt hw iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">反应</li></ul></div><div class="ab cl nq nr go ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ha hb hc hd he"><p id="dfa6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hx"><em class="lr">Eric Elliott</em></strong><em class="lr">著有</em> <a class="ae jr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="lr">【编程JavaScript应用】</em> </a> <em class="lr"> (O'Reilly)，以及</em> <a class="ae jr" href="https://leanpub.com/learn-javascript-react-nodejs-es6/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">【学习JavaScript通用App开发用Node，ES6，&amp;【React】</em></a><em class="lr">。他曾参与的软件项目有</em><strong class="iv hx"><em class="lr">Adobe Systems</em></strong><em class="lr"/><strong class="iv hx"><em class="lr">Zumba Fitness</em></strong><em class="lr"/><strong class="iv hx"><em class="lr">华尔街日报</em></strong><em class="lr"/><strong class="iv hx"><em class="lr">ESPN</em></strong><em class="lr"/><strong class="iv hx"><em class="lr">BBC</em></strong></p><p id="61a2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>