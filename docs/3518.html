<html>
<head>
<title>The Secret Sauce of Micro Frontends: Doing it by the books</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端的秘方:照章办事</h1>
<blockquote>原文：<a href="https://medium.com/globant/the-secret-sauce-of-micro-frontends-doing-it-by-the-books-249eba69a0fd?source=collection_archive---------0-----------------------#2020-10-07">https://medium.com/globant/the-secret-sauce-of-micro-frontends-doing-it-by-the-books-249eba69a0fd?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b32f" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">摘录自微前端小队的开放MRS RFC。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/65c13361a8884a67b79496911e9ccef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuvriqPdUaBd3dGoTwZdEQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Calculated decisions for architecting Micro Frontends</figcaption></figure><h1 id="6f79" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">对微前端规则手册的需求</h1><p id="41a6" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi la translated">那是一个晴朗的日子，我们正在研究关于微前端的成熟标准。研究的主要原因之一是为我们未来的工作奠定基础，以创建一个完整、稳定、文明和可生产的微前端生态系统。</p><p id="44f4" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">经过几次尝试和失败后，我们登陆了由<a class="ae lo" href="https://openmrs.org/" rel="noopener ugc nofollow" target="_blank"> OpenMRS </a>团队管理的微前端<a class="ae lo" href="https://github.com/openmrs/openmrs-rfc-frontend/tree/master/text" rel="noopener ugc nofollow" target="_blank">RFC</a>中的一个。通读它帮助我们认识到这正是医生要求的，因此，我们决定重新使用OpenMRS微前端团队的成果，而不是重新发明轮子。这也是因为该团队一直在使用<a class="ae lo" href="https://github.com/openmrs/openmrs-rfc-frontend/tree/master/text" rel="noopener ugc nofollow" target="_blank"> openmrs-frontend-rfc </a>进行所有的<a class="ae lo" href="https://wiki.openmrs.org/display/projects/Frontend+-+SPA+and+Microfrontends" rel="noopener ugc nofollow" target="_blank">决策</a>，这导致了当前开放mrs微前端生态系统的稳定性。</p><p id="801c" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">是的，这是本文的核心内容。欢迎您踏上一段旅程，这不仅能帮助您消化当前的<a class="ae lo" href="https://docs.google.com/presentation/d/1sv0n_15Zp9HNusdSagOXnBO7Kbh2qURMQj3a8OR8ndo/edit#slide=id.g5681fc88ca_0_190" rel="noopener ugc nofollow" target="_blank"> Open MRS frontends RFC </a>，还能让您通过遵循最佳实践，将您的需求映射到一个稳定且定义良好的微前端架构。</p><p id="2165" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">相信我，这不是一次性阅读，当您在会议室时，请将它作为参考点，思考与微前端相关的最常见问题之一，例如:</p><ul class=""><li id="21c0" class="lp lq hh kg b kh lj kk lk kn lr kr ls kv lt kz lu lv lw lx bi translated">我们如何构建一个微前端生态系统？</li><li id="1bbd" class="lp lq hh kg b kh ly kk lz kn ma kr mb kv mc kz lu lv lw lx bi translated">建立一个微前端生态系统需要哪些不同的构件？</li><li id="7f7e" class="lp lq hh kg b kh ly kk lz kn ma kr mb kv mc kz lu lv lw lx bi translated">在有循环连接点的web应用程序中，如何扩展前端团队？</li><li id="9666" class="lp lq hh kg b kh ly kk lz kn ma kr mb kv mc kz lu lv lw lx bi translated">如何部署微前端？</li><li id="62ac" class="lp lq hh kg b kh ly kk lz kn ma kr mb kv mc kz lu lv lw lx bi translated">还有更多的…</li></ul><blockquote class="md"><p id="0613" class="me mf hh bd mg mh mi mj mk ml mm kz dx translated">希望你已经准备好了，准备好用你的枪来锻炼你的脑细胞。让我们折断一条腿。</p></blockquote></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><h1 id="116f" class="jm jn hh bd jo jp mu jr js jt mv jv jw in mw io jy iq mx ir ka it my iu kc kd bi translated">一次展开一页</h1><p id="6aed" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">让我们探讨一下在构建微前端生态系统时需要考虑的关键点，以及我们如何采用它们。以防你刚到这里还不知道微前端到底是什么，<a class="ae lo" href="https://www.youtube.com/watch?v=3EUfbnHi6Wg&amp;list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU" rel="noopener ugc nofollow" target="_blank">这里有一个由<a class="mz na ge" href="https://medium.com/u/a142a504a37c?source=post_page-----249eba69a0fd--------------------------------" rel="noopener" target="_blank">乔尔·丹宁</a>所做的惊人解释</a>。我们继续。</p><h2 id="a4ba" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">规则一:单页应用程序(SPA)</h2><p id="6a04" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">生态系统中的每个微前端本身应该是一个<a class="ae lo" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">单页面应用</a>。这样做的好处是无缝的用户体验，因为浏览器将负责按照JavaScript中提到的指令呈现DOM。此外，web应用程序的路由和导航将在客户端处理，因此避免了服务器往返获取给定路由的DOM。</p><p id="1f08" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">使用<a class="ae lo" href="http://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>、<a class="ae lo" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> ReactJS </a>、<a class="ae lo" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>或<a class="ae lo" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">svelet</a>可以很容易地为微前端生态系统创建这样一个SPA。</p><p id="4a0a" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">实施挑战</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es np"><img src="../Images/904033cbe6456f4c3bc3db5af734bea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uUXfPvdhwt1XUhY4MC1Ug.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Multiple Angular Applications</figcaption></figure><p id="f5f7" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi"> <em class="nq">挑战1 </em> </strong></p><p id="d264" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">让我们考虑这样一个场景，我们需要在一个页面上加载几个Angular应用程序，这样用户就可以获得无缝的用户体验，而无需往返服务器以在浏览器中呈现DOM元素。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es np"><img src="../Images/2ed095d558a9373656457868e356b594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4X5EaRNvEQENb5qcFesSA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">angular-application-1 loaded as a Micro Frontend</figcaption></figure><p id="6460" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi"> <em class="nq">挑战二</em> </strong></p><p id="8d27" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">除此之外，一个Angular应用程序，比如说“angular-application-1”有自己的导航界面，允许用户独立浏览“angular-application-1”。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es np"><img src="../Images/8461595704e9433941d048c6d83b8187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tG4fCNqXrxcUROmwGwD8oQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">angular-application-1 has its own route /users</figcaption></figure><p id="5b43" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi"> <em class="nq">挑战3 </em> </strong></p><p id="f1f2" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">此外，一旦用户导航到给定的路线，比如说'/users '，它应该由' angular-application-1 '再次加载，而不需要任何服务器往返来呈现DOM。</p><p id="b8c6" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">一个可能的解决方案</strong></p><p id="ba81" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">使用<a class="ae lo" href="http://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">单spa </a>可以很好地解决上述实施挑战，这被认为是建立微前端生态系统的最佳解决方案之一。其<a class="ae lo" href="https://single-spa.js.org/docs/create-single-spa" rel="noopener ugc nofollow" target="_blank"> CLI </a>提供了一个名为<a class="ae lo" href="https://single-spa.js.org/docs/create-single-spa#--moduletype" rel="noopener ugc nofollow" target="_blank"> root-config </a>的应用，该应用使用<a class="ae lo" href="https://single-spa.js.org/docs/configuration/#registering-applications" rel="noopener ugc nofollow" target="_blank">单spa库</a>来注册微前端。这将帮助我们解决<strong class="kg hi"> <em class="nq">挑战1。</em> </strong>另一方面，<strong class="kg hi"> <em class="nq">挑战2 </em> </strong>和<strong class="kg hi"> <em class="nq">挑战3 </em> </strong>可以通过按照<a class="ae lo" href="https://single-spa.js.org/docs/ecosystem-angular#angular-cli" rel="noopener ugc nofollow" target="_blank">单spa规范</a>创建Angular微前端，使用Angular框架提供的<a class="ae lo" href="https://angular.io/guide/router" rel="noopener ugc nofollow" target="_blank">路由库</a>来解决。</p><h2 id="ad99" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">规则二:浏览器内模块</h2><p id="1352" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">在正常情况下，Angular、React、Vue或Svelte应用程序的编译会生成index.html、静态资产(如图像和JavaScript文件),其路径会加载到生成的index.html中。然而，根据我们在规则I中了解到的，index.html页面应该只为root-config加载，而对于所有其他微前端，应该只加载JavaScript，它在内部定义了需要为给定微前端呈现的DOM。我们如何在不渲染每个微前端的index.html文件的情况下，加载微前端构建过程生成的JavaScript文件？</p><p id="f6f2" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">实施挑战</strong></p><p id="e966" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">编译“根配置”、“角度应用-1”和“角度应用-2”将产生以下输出:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nr"><img src="../Images/a2e7c3863259347491cbabc6bc34edb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuK40qkYNANflniSzZ_dhQ.jpeg"/></div></div></figure><p id="14d9" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">这里的挑战是加载主要的。*.“根配置”中的“角度-应用-一”和“角度-应用-二”的js文件。我们所说的“当需要时”是指当用户导航到需要“root-config”来加载给定微前端的路由时。</p><p id="b966" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">一个可能的解决方案</strong></p><p id="8b7e" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">正如开放MRS前端RFC所提议的，这里应该使用浏览器内的JavaScript模块<a class="ae lo" href="https://www.sitepoint.com/understanding-es6-modules/" rel="noopener ugc nofollow" target="_blank"/>,这将允许JavaScript代码在容器内的延迟加载，这样它就不会向外部世界(窗口)暴露任何变量或逻辑，除非有明确的意图。因为浏览器并不支持JavaScript模块，这就是为什么建议使用<a class="ae lo" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank"> SystemJS </a>的原因，这样就可以加载<a class="ae lo" href="https://github.com/WICG/import-maps#the-import-map" rel="noopener ugc nofollow" target="_blank">导入图</a>中提到的浏览器内模块。除此之外，我们预测最近在Webpack 5中引入的<a class="ae lo" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">模块联盟</a>是一个更好的选择，因为它支持动态加载和依赖关系的解析，以及与SystemJS相比的受控定制。</p><h2 id="106d" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">规则三:导入地图</h2><p id="b3e5" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">从Rule II实现挑战来看，很明显每个微前端最后都被编译成一个JavaScript文件。现在，对于<a class="ae lo" href="https://www.youtube.com/watch?v=QHunH3MFPZs&amp;list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&amp;index=5" rel="noopener ugc nofollow" target="_blank">生产部署</a>，很明显，这些微前端(JS文件)将被推送到blob存储提供商(如Google Storage Bucket)或内容交付网络(CDN)提供商。这里的一个挑战是，我们如何通知SystemJS这些单个微前端的当前位置。</p><p id="6e55" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">实施挑战</strong></p><p id="dab2" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">例如，为规则I和规则II中的挑战创建和构建的微前端，即“角度应用-1”和“角度应用-2”部署在Google存储桶上。现在，我们如何通知“root-config”中使用的SystemJS关于这些微前端的位置？解决方法是<a class="ae lo" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">导入地图</a>。</p><p id="c7b2" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">导入映射是微前端到其位置的映射。在下面的例子中，定义了一个导入映射，说明了微前端的名称及其位置。</p><pre class="ix iy iz ja fd ns nt nu nv aw nw bi"><span id="bedc" class="nb jn hh nt b fi nx ny l nz oa">&lt;script type="systemjs-importmap"&gt;<br/>      {<br/>        "imports": {<br/>          "@mfe/angular-application-one": "http://api.googlestoragebucket.com/main-es5.js"<br/>        }<br/>      }<br/>    &lt;/script&gt;</span></pre><blockquote class="ob oc od"><p id="6c8c" class="ke kf nq kg b kh lj ii kj kk lk il km oe ll kp kq of lm kt ku og ln kx ky kz ha bi translated">尝试一下</p></blockquote><ul class=""><li id="28fe" class="lp lq hh kg b kh lj kk lk kn lr kr ls kv lt kz lu lv lw lx bi translated">Angular with SystemJS、Single-spa和Docker —即将发布动手实验</li></ul><h2 id="6285" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">规则四:带设计库的风格指南</h2><p id="597e" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">当多个小团队在不同的微前端工作时，团队很可能会偏离为产品定义的品牌指导方针和设计系统，从而导致不一致的用户体验。因此，建议创建一个“风格指南”微前端，定义需要在所有微前端中使用的设计系统。设计系统为'<a class="ae lo" href="https://ant.design/" rel="noopener ugc nofollow" target="_blank"> Ant </a>'、<a class="ae lo" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Material </a>或'<a class="ae lo" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>等，定义了全局CSS类，应由所有微前端继承。</p><p id="bac1" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">仅定义设计系统并不能保证一致性，因为微前端生态系统中使用的各个组件的不同行为可能会让用户感到困惑。例如，对于多选下拉菜单，一个设计微前端的团队可以选择芯片来显示所选选项，而另一个团队可能只选择显示下拉菜单中所选选项的数量。现在，为了避免这种不一致的用户体验，应该将可重用组件添加到样式指南中，并在所有微前端中使用，从而消除用户体验不满意的风险。</p><p id="5685" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">等等！！我们刚刚讨论了可重用组件，但是我们如何决定在风格指南中使用哪个框架来设计这些可重用组件。它应该是有棱角的，有反应的，脆弱的还是苗条的？答案是，<em class="nq">看情况</em>。如果生态系统中的所有微前端都是使用单个框架构建的，例如ReactJS，那么使用相同的框架来创建样式指南。然而，如果你的微前端生态系统是一个多框架生态系统，那么这些可重用的组件应该是框架不可知的，即使用<a class="ae lo" href="https://www.webcomponents.org/" rel="noopener ugc nofollow" target="_blank"> Web组件</a>或<a class="ae lo" href="https://single-spa.js.org/docs/parcels-overview/" rel="noopener ugc nofollow" target="_blank">单组件</a>构建。使用web组件或单spa-parcles使开发团队能够创建与框架无关的组件，允许这些组件与Angular、ReactJS、Vue或Svelte一起使用。</p><h2 id="ce6a" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">规则五:实用模块</h2><p id="7956" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">我们确实创建了一个集中的位置来加载跨微前端使用的所有全局CSS和组件，但是对于所有微前端都可用的应用程序的实用方法和共享状态呢？对于实用方法，我们指的是用于执行业务计算的方法、通用枚举(如CustomerType)和类(如在60%的微前端(在银行应用程序中)中使用的Customer)。我们是否应该为所有微前端复制逻辑，或者必须有一个集中的位置，用于与所有微前端共享所有横切关注点？</p><p id="0806" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated"><strong class="kg hi">一个可能的解决方案</strong></p><p id="399b" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">可以使用支持开箱即用的打字稿的<a class="ae lo" href="https://single-spa.js.org/docs/module-types/#utilities" rel="noopener ugc nofollow" target="_blank">单spa实用模块</a>将实用模块创建为浏览器内模块。可以在这个实用模块中创建一个redux存储，使所有微前端能够共享状态。除此之外，验证和授权用户的逻辑也可以使用实用程序模块共享。此外，实用模块还可以用于分析、错误报告和推送通知，这些都是应用程序中常见的交叉问题。</p></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><p id="a645" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">你所探索的只是冰山一角。我正在为上面讨论的所有概念创建动手实验，以便架构师和开发人员都可以使用本文作为进入微前端世界的入门。如果您希望在这些动手实验发布时收到更新，请随时关注。</p><p id="87c4" class="pw-post-body-paragraph ke kf hh kg b kh lj ii kj kk lk il km kn ll kp kq kr lm kt ku kv ln kx ky kz ha bi translated">编码快乐！！</p><h2 id="1c52" class="nb jn hh bd jo nc nd ne js nf ng nh jw kn ni nj jy kr nk nl ka kv nm nn kc no bi translated">推荐读物</h2><ul class=""><li id="a0a9" class="lp lq hh kg b kh ki kk kl kn oh kr oi kv oj kz lu lv lw lx bi translated">你知道我们可以共享微前端之间的依赖关系，以减少最终的包大小，这里是你怎么做。</li></ul><div class="ok ol ez fb om on"><a rel="noopener follow" target="_blank" href="/globant/the-secret-sauce-of-micro-frontends-preventing-bundle-bloat-using-systemjs-and-single-spa-5fdf15b2a82a"><div class="oo ab dw"><div class="op ab oq cl cj or"><h2 class="bd hi fi z dy os ea eb ot ed ef hg bi translated">微前端的秘方:使用SystemJS和Single-spa防止捆绑包膨胀</h2><div class="ou l"><h3 class="bd b fi z dy os ea eb ot ed ef dx translated">先决条件</h3></div><div class="ov l"><p class="bd b fp z dy os ea eb ot ed ef dx translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb jg on"/></div></div></a></div></div></div>    
</body>
</html>