<html>
<head>
<title>Understanding Android’s vector image format: VectorDrawable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Android的矢量图像格式:VectorDrawable</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68?source=collection_archive---------0-----------------------#2018-11-27">https://medium.com/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68?source=collection_archive---------0-----------------------#2018-11-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/511ed9b384cd619aaa5269c8262ec235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9YTPhelGjw4AoXlHeuqig.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="9e26" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android设备有各种尺寸、形状和屏幕密度。这就是为什么我非常喜欢使用独立于分辨率的矢量资源。但是它们到底是什么呢？它们的好处是什么？有哪些成本？我应该什么时候使用它们？<em class="js">你是如何创造和使用它们的？在这一系列的帖子中，我想探讨这些问题，并解释为什么我认为你的应用程序中的绝大多数资产应该是向量，以及如何充分利用它们。</em></p><h1 id="88bb" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">光栅与矢量</h1><p id="15aa" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">大多数图像格式(png、jpeg、bmp、gif、webp等)都是光栅格式，这意味着它们将图像描述为固定的像素网格。因此，它们是以特定的分辨率定义的，并且<em class="js">不理解</em>任何关于它们内容的东西，只是每个像素的颜色。然而，矢量图形<em class="js">将图像描述为在抽象画布大小上定义的一系列形状。</em></p><h1 id="1c3d" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么是vector？</h1><p id="ec5f" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">矢量资产有3个主要优势，它们是:</p><ul class=""><li id="0757" class="kw kx hx iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">锋利的</li><li id="ee04" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">小的</li><li id="68d9" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">动态的</li></ul><h2 id="909a" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated"><strong class="ak">锋利</strong></h2><p id="9445" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">矢量图像大小调整优雅；因为它们描述了抽象画布大小的图像，所以您可以放大或缩小画布，然后以该大小重新绘制图像。但是，当您调整栅格资源大小时，它们可能会恶化。缩小栅格资产往往是可以的(因为您丢弃了信息)，但放大它们会导致模糊或条带等假象，因为它们必须对缺失的像素进行插值。</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/0284a7309397fb8323566ca03beb8b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_ol_Ajp2SsMNx3DHKUgfQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Artifacts from (extreme) scaling up a raster image (left) vs a vector image (right)</figcaption></figure><p id="e550" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是为什么在Android上，我们需要为不同密度的屏幕提供每个栅格资源的多个版本:</p><ul class=""><li id="829a" class="kw kx hx iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">res/drawable-mdpi/foo.png</li><li id="768d" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">res/drawable-hdpi/foo.png</li><li id="ceaf" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">res/drawable-xhdpi/foo.png</li><li id="4e53" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi">…</li></ul><p id="838c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android选择最接近的<strong class="iw hy">较大的</strong>密度，并按比例缩小(如果需要)。随着设备屏幕密度越来越高的趋势，应用程序制造商必须不断创造、包括和发布相同资产的更大版本。请注意，许多现代设备并不基于精确的密度桶(例如，Pixel 3 XL为552dpi，介于xxhdpi &amp; xxxhdpi之间)，因此资产通常会被缩放。</p><p id="7808" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为矢量资源可以很好地调整大小，所以您可以包含单个资源，因为它可以在任何和所有屏幕密度下工作。</p><h2 id="892c" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated"><strong class="ak">小</strong></h2><p id="3c8e" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">矢量资源通常比栅格资源更紧凑，因为您只需要包含一个版本，而且它们的压缩效果很好。</p><p id="a5f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如<a class="ae hu" href="https://github.com/google/iosched/commit/78c5d25dfbb4bf8193c46c3fb8b73c9871c44ad6" rel="noopener ugc nofollow" target="_blank">这里有一个来自<a class="ae hu" href="https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched" rel="noopener ugc nofollow" target="_blank">谷歌输入输出应用</a>的变化</a>，我们将一些图标从光栅png转换为矢量，节省了482KB。虽然这听起来没什么，但这只是一个小图标；较大的图像(如插图)会有较大的节省。</p><p id="c0c6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此<a class="ae hu" href="https://github.com/google/iosched/blob/71f0c4cc20c5d75bc7b211e99fcf5205330109a0/android/src/main/res/drawable-nodpi/attending_in_person.png" rel="noopener ugc nofollow" target="_blank">插图</a>例如来自上一年I/O应用程序的启动流程，例如:</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div class="er es md"><img src="../Images/5fe17a91a60bc6e006d48546d1d17ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tzT8u-ungCXb_CHGAyAiPA.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustrations can be good candidates for vectors</figcaption></figure><p id="85ff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们不能用一个<code class="du me mf mg mh b">VectorDrawable</code>来代替它，因为渐变在那个时候并没有得到广泛的支持(剧透:现在是了！)所以我们不得不推出光栅版本😔。如果我们能够使用一个向量，这将是一个更好的<em class="js">结果的30%大小:</em></p><ul class=""><li id="c96b" class="kw kx hx iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">光栅:下载大小= 53.9KB(原始文件大小= 54.8KB)</li><li id="6ecb" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">Vector:下载大小= 3.7KB(原始文件大小= 15.8KB)</li></ul><blockquote class="mi mj mk"><p id="c103" class="iu iv js iw b ix iy iz ja jb jc jd je ml jg jh ji mm jk jl jm mn jo jp jq jr ha bi translated">请注意，虽然<a class="ae hu" href="https://developer.android.com/platform/technology/app-bundle/" rel="noopener ugc nofollow" target="_blank"> Android应用捆绑包的</a>密度配置分割通过仅向设备提供所需的密度资产带来了类似的好处，但<code class="du me mf mg mh b">VectorDrawable</code>通常仍会更小，并且还消除了不断创建更大栅格资产的需要。</p></blockquote><h2 id="b561" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated"><strong class="ak">动态</strong></h2><p id="acb7" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">由于矢量图像描述了它们的内容，而不是将它们“扁平化”成像素，它们为有趣的新可能性打开了大门，如动画、交互性或动态主题化。在以后的文章中会有更多的介绍。</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mo"><img src="../Images/eef83a9e988fb3490d7585bc837b00be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rJQEzHNMyBrZxjzpPDb84w.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Vectors maintain the image structure so individual elements can be themed or animated</figcaption></figure><h1 id="7444" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">权衡取舍</h1><p id="5ea4" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">向量确实有一些需要考虑的缺点:</p><h2 id="3f35" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated"><strong class="ak">解码</strong></h2><p id="8fa4" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">如前所述，矢量资产描述了它们的内容，因此在使用之前需要对它们进行膨胀和绘制。</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mp"><img src="../Images/8f27a5fd2aa35a54d35a7bde4df97202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsKMU2enRRjNVo09fEb08A.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The steps involved in decoding a vector before rendering</figcaption></figure><p id="bc0d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这有两个步骤:</p><ol class=""><li id="a01b" class="kw kx hx iw b ix iy jb jc jf ky jj kz jn la jr mq lc ld le bi translated"><strong class="iw hy">通货膨胀</strong>。你的向量文件必须被读取并解析成一个<code class="du me mf mg mh b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable" rel="noopener ugc nofollow" target="_blank">VectorDrawable</a> </code>模型，它模拟了你声明的<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/graphics/drawable/static/src/main/java/androidx/vectordrawable/graphics/drawable/VectorDrawableCompat.java#1809" rel="noopener ugc nofollow" target="_blank">路径</a>、<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/graphics/drawable/static/src/main/java/androidx/vectordrawable/graphics/drawable/VectorDrawableCompat.java#1440" rel="noopener ugc nofollow" target="_blank">组</a>等。</li><li id="533e" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr mq lc ld le bi translated"><strong class="iw hy">图纸</strong>。然后，必须通过执行<code class="du me mf mg mh b">Canvas</code>绘图命令来绘制这些模型对象。</li></ol><p id="4c67" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这两个步骤都与向量的复杂度和你执行的操作类型成比例。如果你使用非常复杂的形状，将它解析成一个<code class="du me mf mg mh b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/Path" rel="noopener ugc nofollow" target="_blank">Path</a></code>将花费更长的时间。类似地，更多的绘图操作将花费更长的时间来执行(并且一些操作更昂贵，例如剪辑操作)。我们将在本系列关于分析这些成本的后续文章中再次讨论这个问题。</p><p id="ab14" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于静态向量，绘制阶段只需要执行一次，然后就可以缓存到一个<code class="du me mf mg mh b">Bitmap</code>中。动画向量不能进行这种优化，因为它们的属性必然会改变，需要重新绘制。</p><p id="1e45" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相比之下，像png这样的光栅资产只需要解码文件的内容，这已经随着时间的推移得到了高度优化。</p><p id="3d00" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是光栅与矢量的本质权衡。向量提供了上述好处，但代价是渲染成本更高。在Android的早期，设备功能较弱，屏幕密度差别不大。如今，Android设备功能更加强大，屏幕密度也多种多样。这就是为什么我认为是时候让所有应用程序转向矢量资产了。</p><h2 id="b172" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated"><strong class="ak">适宜性</strong></h2><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/179a8188d9dedf40a79634eb74f09cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyZVYFWUF5bH9DYpwW16aQ.png"/></div></div></figure><p id="54de" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于格式的本质，向量在描述一些资产方面非常出色，比如简单的图标等。他们很不擅长对照片类型的图像进行编码，很难用一系列形状来描述它们的内容，使用光栅格式(比如webp)可能会更有效。这当然是一个范围，取决于你的资产的复杂程度。</p><h2 id="ac3f" class="lk ju hx bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">转换</h2><p id="df31" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">没有设计工具(据我所知)直接创建<code class="du me mf mg mh b">VectorDrawable</code> s，这意味着有一个从其他格式转换的步骤。这可能会使设计人员和开发人员之间的工作流程变得复杂。我们将在以后的文章中深入探讨这个话题。</p><h1 id="4931" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么不是SVG？</h1><p id="0991" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">如果您曾经使用过矢量图像格式，您可能会遇到SVG格式(可缩放矢量图形)，这是web上的行业标准。它具有成熟的工具，但是它也是一个庞大的标准。它包括许多复杂的功能，如执行任意javascript，模糊和过滤效果或嵌入其他图像，甚至动画gif。Android在受限的移动设备上运行，因此支持SVG规范的整体性并不是一个现实的目标。</p><p id="b123" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，SVG包含了一个<a class="ae hu" href="https://www.w3.org/TR/SVG/paths.html" rel="noopener ugc nofollow" target="_blank">路径规范</a>，它定义了如何描述和绘制形状。有了这个API，你可以表达大多数矢量图形。这本质上是Android支持的:SVG的路径规范(加上一些补充)。</p><p id="4b64" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，通过定义自己的格式，<code class="du me mf mg mh b">VectorDrawable</code>可以与Android平台特性集成。例如，使用Android资源系统引用<code class="du me mf mg mh b">@colors</code>、<code class="du me mf mg mh b">@dimens</code>或<code class="du me mf mg mh b">@strings</code>，使用标准<code class="du me mf mg mh b">Animator</code>处理主题属性或<code class="du me mf mg mh b">AnimatedVectorDrawable</code></p><h1 id="5eab" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><code class="du me mf mg mh b">VectorDrawable</code>的能力</h1><p id="e7df" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">如上所述，<code class="du me mf mg mh b">VectorDrawable</code>支持<a class="ae hu" href="https://www.w3.org/TR/SVG/paths.html" rel="noopener ugc nofollow" target="_blank"> SVGs路径规范</a>，允许您指定一个或多个要绘制的形状。它以XML文档的形式创作，如下所示:</p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="2b21" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，您需要指定资产的固有大小，这是如果您在<code class="du me mf mg mh b">wrap_content</code> <code class="du me mf mg mh b">ImageView</code>中设置它的大小。第二个<code class="du me mf mg mh b">viewport</code>尺寸定义了虚拟画布，或定义所有后续绘图命令的坐标空间。内在尺寸和视口尺寸可以不同(但是应该是相同的比例)，如果你真的想的话，你可以在1*1的画布上定义你的向量。</p><p id="146a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du me mf mg mh b">&lt;vector&gt;</code>元素包含一个或多个<code class="du me mf mg mh b">&lt;path&gt;</code>元素。它们可以被命名(供以后参考，如动画)，但关键是必须指定一个描述形状的<code class="du me mf mg mh b">pathData</code>元素。这个看起来神秘的字符串可以被认为是在虚拟画布上控制笔的一系列命令:</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/aa3e9c0d8c0190d6b603ae3e2c6015b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6BxPXqBgeJIpMoiYLoOygA.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Visualizing path operations</figcaption></figure><p id="c081" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述命令移动虚拟笔，然后画一条线到另一个点，提起并移动笔，然后画另一条线。仅用4个最常用的命令，我们就可以描述几乎任何形状(有更多的命令参见<a class="ae hu" href="https://www.w3.org/TR/SVG/paths.html#PathData" rel="noopener ugc nofollow" target="_blank">规范</a>):</p><ul class=""><li id="a3c6" class="kw kx hx iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated"><code class="du me mf mg mh b">M</code>移到</li><li id="9223" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><code class="du me mf mg mh b">L</code>行到</li><li id="d542" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><code class="du me mf mg mh b">C</code>(三次贝塞尔)曲线</li><li id="d415" class="kw kx hx iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><code class="du me mf mg mh b">Z</code>关闭(直线到第一点)</li></ul><p id="8dd6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">(大写命令使用绝对坐标&amp;小写使用相对坐标)</em></p><p id="8a68" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可能想知道您是否需要关心这种程度的细节——您不就是从SVG文件中获得这些细节的吗？虽然你不需要能够阅读路径并理解它将画出什么，但对<code class="du me mf mg mh b">VectorDrawable</code>正在做什么有一个基本的了解对于理解我们稍后将会看到的一些高级特性是非常有帮助和必要的。</p><p id="0af4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">路径本身不会绘制任何东西，它们需要被描边和/或填充。</p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="e07d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本系列的第2部分将更详细地介绍填充/描边路径的不同方式。</p><p id="9b1f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您还可以定义路径组。这允许您定义将应用于组内所有路径的变换。</p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="1b3a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，您不能旋转/缩放/平移单个路径。如果你想要这种行为，你需要把他们放在一个组里。这些变换对于静态图像没有什么意义，因为静态图像可以直接将它们“烘焙”到它们的路径中——但是对于动画来说，它们非常有用。</p><p id="3ac2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还可以定义<code class="du me mf mg mh b">clip-path</code> s，即屏蔽同组中其他路径<em class="js">可以画到的区域。它们的定义方式与<code class="du me mf mg mh b">path</code> s完全相同。</em></p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="9370" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得注意的一个限制是剪辑路径不是抗锯齿的。</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/f691c9ea103a697c8cf78c32920d8151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfAEoYPOzVBf2Ne2-lKE3w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demonstrating non-anti-aliased clip path</figcaption></figure><p id="2c13" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个例子(为了显示效果，我已经把它放大了)展示了两种绘制相机快门图标的方法。第一个绘制路径，第二个绘制实心正方形，遮罩为百叶窗形状。蒙版可以帮助创建有趣的效果(尤其是当动画时)，但它相对昂贵，所以如果你可以通过以不同的方式绘制形状来避免它，那么就这样做。</p><p id="9f48" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">路径可以被修剪；那只是画出整个路径的一个子集。您可以修剪填充路径，但结果可能会令人惊讶！更常见的是修剪描边路径。</p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/ff7a8c91a80986eecbf24dbe7a1b83ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7BaeX8n1mu2j7UTMRq-cLA.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Trimming paths</figcaption></figure><p id="9f33" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以从路径的起点或终点进行修剪，或者对任何修剪应用偏移。它们被定义为路径[0，1]的一部分。了解设置不同的修剪值如何改变所绘制的线条部分。另请注意，偏移可以使微调值“环绕”。同样，这个属性对于静态图像没有多大意义，但是对于动画来说却很方便。</p><p id="0f4f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根<code class="du me mf mg mh b">vector</code>元素支持一个<code class="du me mf mg mh b">alpha</code>属性[0，1]。组没有alpha属性，但是单个路径支持<code class="du me mf mg mh b">fillAlpha</code> / <code class="du me mf mg mh b">strokeAlpha</code>。</p><figure class="lz ma mb mc fd hj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h1 id="ea36" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">宣布独立</h1><p id="8644" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">所以希望这篇文章能让你了解什么是矢量资产，它们的好处和利弊。Android的矢量格式是有能力的，并且有广泛的支持。考虑到市场上设备的多样性，使用矢量资产应该是您的默认选择，只有在特殊情况下才求助于栅格。在接下来的帖子中加入我们，了解更多信息:</p><div class="hg hh ez fb hi mu"><a rel="noopener follow" target="_blank" href="/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hy fi z dy mz ea eb na ed ef hw bi translated">绘制路径:渲染Android VectorDrawables</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在上一篇文章中，我们研究了Android的VectorDrawable格式，探讨了它的优点和功能。</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">medium.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ho mu"/></div></div></a></div><div class="hg hh ez fb hi mu"><a rel="noopener follow" target="_blank" href="/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hy fi z dy mz ea eb na ed ef hw bi translated">在Android应用中使用矢量资源</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在之前的帖子中，我们已经了解了Android的VectorDrawable图像格式及其功能:</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">medium.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni ho mu"/></div></div></a></div><p id="1332" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">即将推出:为Android创建矢量资产<br/>即将推出:剖析Android </em> <code class="du me mf mg mh b"><em class="js">VectorDrawable</em></code> <em class="js"> s </em></p></div></div>    
</body>
</html>