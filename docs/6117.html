<html>
<head>
<title>Distributed tracing at Pinterest with new open source tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用新的开源工具在Pinterest进行分布式追踪</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/distributed-tracing-at-pinterest-with-new-open-source-tools-a4f8a5562f6b?source=collection_archive---------0-----------------------#2017-02-14">https://medium.com/pinterest-engineering/distributed-tracing-at-pinterest-with-new-open-source-tools-a4f8a5562f6b?source=collection_archive---------0-----------------------#2017-02-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a5e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest工程师苏曼·卡鲁穆里</p><p id="6f3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest后端由部署在数万台机器上的数百个微服务组成。对Pinterest home feed的一个简单请求可以对几十个后端服务进行数百次网络调用。虽然我们知道执行一个请求需要多长时间，但是以前我们不知道为什么一个请求会很慢。为了收集这些数据，我们构建了Pintrace，这是一个分布式跟踪管道，可以在我们的Python和Java后端服务处理请求时跟踪请求。我们还构建了Pintrace collector来帮助我们调试性能问题。Pintrace collector是一个Spark作业，它从Kafka读取跨度，将它们聚合成轨迹，并存储在Elasticsearch后端。今天，我们在Github 上开源<a class="ae jc" href="https://github.com/openzipkin/zipkin-sparkstreaming" rel="noopener ugc nofollow" target="_blank"> Pintrace collector，并将代码贡献给OpenZipkin社区。通过向社区发布它，我们希望其他人也能像我们一样从这个项目中受益。</a></p><h2 id="d341" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">背景</h2><p id="f0f5" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">追踪延迟的来源可能非常具有挑战性，因为缓慢可能是由我们的任何一个后端服务引起的。我们的度量标准(<a class="ae jc" href="http://opentsdb.net/" rel="noopener ugc nofollow" target="_blank"> OpenTSDB </a>)和日志记录(<a class="ae jc" href="https://www.elastic.co/products/kibana" rel="noopener ugc nofollow" target="_blank"> ELK </a>)基础设施提供了后端如何处理请求的粗粒度视图，但是在Pintrace之前，很难查明请求缓慢的原因。</p><p id="07d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这一挑战，我们求助于分布式跟踪，这种跟踪跟踪延迟问题并显示请求在哪里花费时间。除了请求延迟信息之外，它还通过捕获请求因果关系信息(即，哪些下游请求作为请求的一部分被执行)来提供对请求执行的细粒度可见性。Pintrace是我们内部的分布式跟踪管道，在我们的Python和Java后端服务处理请求时跟踪请求。</p><p id="0a88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们研究细节之前，让我们定义一些术语。注释是在请求过程中发生的事件。例如，向服务器发送请求就是一个注释。一个span表示一个逻辑操作，并包含一组属于该操作的注释。例如，由“客户端发送”和“客户端接收”注释组成的RPC调用被表示为一个span。轨迹是跨度的图形。请求执行通常被捕获为跟踪。跟踪中的所有跨度都具有相同的跟踪ID。关于如何构造跟踪的更多细节，请查看<a class="ae jc" href="http://opentracing.io/documentation/" rel="noopener ugc nofollow" target="_blank"> OpenTracing的介绍</a>。</p><h2 id="7229" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">Pintrace:追踪管道</h2><p id="4683" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">构建分布式跟踪基础结构包括设置跟踪管道。跟踪管道由两个主要组件组成——源代码工具和跟踪处理后端。</p><p id="3db2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码工具负责跨服务跟踪请求，并在请求沿着各种服务被处理时生成事件(跨度)。跟踪处理后端负责聚集生成的范围，将它们处理成跟踪并存储它们。可以在UI中搜索和可视化存储的轨迹。</p><p id="41e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pintrace跟踪管道由下图所示的几个组件组成。蓝色部分是内部制造的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/349b88f8dbdbe264ca1a1403203d19e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*B4fU1MSobZDkOrK8.png"/></div></div></figure><h2 id="c126" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">源代码检测</h2><p id="6e75" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">设置跟踪管道时，源代码检测是主要工作。该工具负责生成属于具有相同跟踪ID的同一请求的范围。为了实现这一点，该工具执行三项任务:(a)将跟踪ID与每个请求一起传播(b)为该组件执行的每个逻辑操作生成跨度，并将生成的跨度发送到后端。前两项职责由追踪器执行。记录器实现第三种责任。在Pinterest，我们使用名为<a class="ae jc" href="https://engineering.pinterest.com/blog/real-time-analytics-pinterest" rel="noopener ugc nofollow" target="_blank"> Singer </a>的分析工具记录Kafka的跨度。</p><p id="62fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pintrace backend由用Python、Java、Go、Node和C++编写的Thrift服务组成，每种服务使用不同的框架。为了跨这些服务跟踪请求，我们为每个语言框架组合实现了一个跟踪器。Pinterest对每种语言都有一个通用的框架，我们感兴趣的大多数服务都是用Python和Java编写的，所以我们只需要使用Python和Java框架。当我们第一次开始构建Pintrace时，最初的目标是跟踪网络请求延迟，所以我们只关注于捕获Python和Java应用程序中请求的网络活动。</p><h2 id="483e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">Python工具</h2><p id="d370" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们的Java服务由一个名为ngapi的整体Python应用程序提供前端支持，ngapi是一个HTTP服务，它处理所有传入我们后端的请求。为了满足请求，ngapi通过Thrift与几个Java服务进行对话，并实现了一个基于Python gevent库的定制web框架。由于它是一个定制的框架，我们实现了自己的跟踪器来跟踪通过它的请求。</p><p id="d46c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<a class="ae jc" href="http://opentracing.io/" rel="noopener ugc nofollow" target="_blank">开放跟踪API </a>为我们的网络框架编写了一个跟踪程序。跟踪程序使用Finagle提供的自定义节俭包装器将跟踪ID从HTTP接口传播到Java节俭服务。此外，跟踪程序生成的范围涵盖了所有的credit、Memcache和HTTP请求。为了报告这些跨度，我们编写了一个记录器，将生成的跨度转换为<a class="ae jc" href="https://github.com/openzipkin/zipkin-api/blob/master/thrift/zipkinCore.thrift" rel="noopener ugc nofollow" target="_blank"> Zipkin格式</a>，并使用Singer将它们记录到卡夫卡。</p><p id="4f02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于ngapi在monorepo中进行管理，并作为一个整体应用程序进行部署，因此启用跟踪的更改将在所有前端服务中一步到位。<br/>爪哇示踪剂及记录器</p><p id="72df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的Java服务使用一个名为“服务框架”的内部框架，这是一个围绕着推特的Finagle库的包装。由于Finagle附带了一个Zipkin跟踪程序，我们没有为我们的Java服务构建新的跟踪程序。默认情况下，Finagle tracer会将收集到的跨度写入到scribe或日志文件中，但是因为我们想使用Singer将跨度写入到Kafka，所以我们编写了一个跨度记录器，将跨度记录到Singer中。</p><p id="6b8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦跟踪器和记录器就位，我们就在服务框架中启用它们。然而，我们的服务框架缺乏一种在所有应用程序中同时启用跟踪的方法。为了避免在100多个应用程序中重复这个逻辑，我们更新了服务框架，使其具有全局配置并启用了跟踪。然后，我们更新了我们的Java应用程序，以使用更新后的服务框架中的全局配置。在Java中启用跟踪最困难的部分是在数百个应用程序中进行更改，并努力在整个组织中部署更改。</p><h2 id="2a9e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">取样器</h2><p id="a17b" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">尽管我们的客户端工具具有非常小的延迟开销，但是通过捕获跨度并记录它们，会增加两位数的计算开销。为了减少这种开销以及存储生成的跟踪的成本，我们只跟踪一小部分整体请求。</p><p id="1093" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">采样器组件决定应该跟踪哪些请求，并随机选择我们所有后端请求的0%到1%(通常是0.3%)。该费率可使用<a class="ae jc" href="https://engineering.pinterest.com/blog/serving-configuration-data-scale-high-availability" rel="noopener ugc nofollow" target="_blank">决策器框架</a>动态调整。我们还在开发机器上对所有请求进行采样，以便开发人员可以将跟踪作为日常活动的一部分。</p><h2 id="7d97" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">跟踪处理后端</h2><p id="4571" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">如上图所示，跟踪处理后端负责聚合集群中数千台机器的跨度，将它们处理成跟踪，并存储和可视化它们。</p><h2 id="df1b" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">辛格-卡夫卡管道</h2><p id="52b4" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Singer-Kafka管道负责聚合跨越数千台机器的多个进程生成的跨度，并将它们写入Kafka主题。我们使用<a class="ae jc" href="https://engineering.pinterest.com/blog/real-time-analytics-pinterest" rel="noopener ugc nofollow" target="_blank"> Singer </a>作为我们的span聚合渠道。Python和Java记录器将跨度记录到本地文件中。安装在每台主机上的Singer守护进程跟踪这些文件，并将跨度写入Kafka主题。</p><h2 id="feb8" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">Pintrace收集器</h2><p id="203f" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们使用OpenZipkin后端来获取跨度，但是捕获的轨迹揭示了一些问题。例如，我们的一些仪器可能有故障。在这种情况下，我们希望修复故障量程或丢弃量程，直到修复仪器。即使仔细取样，以我们的规模，我们也能看到很多类似的痕迹。与其存储这些跟踪，不如在接收时进一步对跟踪进行采样，并且只存储高价值的跟踪，这样会更划算。</p><p id="14b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些功能很难添加到我们的后端，所以我们建立了Pintrace collector，这是一个Spark作业，它从Kafka读取跨度，将它们聚集成轨迹并存储在Elasticsearch后端。我们选择Spark来实现管道，因为它足够灵活和可伸缩，可以实现所需的过滤、按跟踪ID分组跨度以及为分析目的聚合时间窗口的跨度。作为一个额外的好处，Spark作业允许我们对跨度运行实时分析，而无需存储它们。</p><p id="3fef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示了Pintrace collector的内部架构。StreamFactory是一个可扩展的接口，它从Kafka或任何其他传输中获取数据。然后，使用数据质量检查器对摄取的跨度进行处理，以确保它们的格式正确。可选地，过滤步骤基于诸如服务名称或跨度上的注释之类的标准来过滤跨度。聚合阶段按时间或跟踪ID对跨度进行分组。最终的消费者阶段将数据保存到存储系统，如ElasticSearch服务。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kp"><img src="../Images/9c8c880caf99f5ade2691c7fdcf53ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/0*CvWetFALjoL6vmYT.png"/></div></figure><h2 id="aafc" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">Zipkin UI</h2><p id="9bcf" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">如架构图所示，我们使用<a class="ae jc" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="noopener ugc nofollow" target="_blank"> Zipkin UI </a>来搜索和查看存储在ElasticSearch集群中的踪迹。我们也为Zipkin UI贡献了一些<a class="ae jc" href="https://github.com/openzipkin/zipkin/commits?author=mansu" rel="noopener ugc nofollow" target="_blank">的</a> <a class="ae jc" href="https://github.com/openzipkin/zipkin/commits?author=naoman" rel="noopener ugc nofollow" target="_blank">错误修复</a>。</p><h2 id="026a" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">开源Pintrace收集器</h2><p id="306a" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在过去的一年中，我们注意到<a class="ae jc" href="https://github.com/openzipkin" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>社区中的其他人正在寻找我们在Pintrace中实现的相同解决方案，例如更高级的采样和流处理，以支持viz general可视化。我们希望与社区分享我们的工作，同时利用其集体专业知识。为了尽可能的开放，我们在<a class="ae jc" href="https://github.com/openzipkin/zipkin-sparkstreaming" rel="noopener ugc nofollow" target="_blank"> zipkin-sparkstreaming </a>代码库下直接将我们的代码贡献给OpenZipkin。我们鼓励您观看或与我们合作构建Zipkin-spark。我们希望你能像我们一样发现Pintrace收集器的用处。我们迫不及待地想看到来自社区的新想法。</p><p id="215e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如需继续阅读，请阅读第2部分:<a class="ae jc" href="https://hackernoon.com/applications-of-pin-trace-data-3b9e6dc2744b" rel="noopener ugc nofollow" target="_blank">(引脚)跟踪数据的应用</a></p><p id="ca35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kq">鸣谢:本项目的贡献者有</em><a class="ae jc" href="https://github.com/naoman" rel="noopener ugc nofollow" target="_blank"><em class="kq">Naoman Abbas</em><em class="kq"/></a><a class="ae jc" href="https://github.com/phoebetse" rel="noopener ugc nofollow" target="_blank"><em class="kq">Phoebe Tse</em></a><em class="kq"/><a class="ae jc" href="https://github.com/ashleyswinning" rel="noopener ugc nofollow" target="_blank"><em class="kq">Ashley Huynh</em></a><em class="kq"/><a class="ae jc" href="https://github.com/alejandrogarciasalas" rel="noopener ugc nofollow" target="_blank"><em class="kq">Alejandro Garcia Salas</em></a><em class="kq"/><a class="ae jc" href="https://github.com/eudotong" rel="noopener ugc nofollow" target="_blank"><em class="kq">Emmanuel Udo tong我们还要感谢</em> </a><a class="ae jc" href="https://github.com/adriancole" rel="noopener ugc nofollow" target="_blank"> <em class="kq">阿德里安·科尔</em> </a> <em class="kq">在项目期间给予的反馈和建议。</em></p></div></div>    
</body>
</html>