<html>
<head>
<title>Auto-updatable, self-contained CLI with Java 11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Java 11的可自动更新的独立CLI</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/auto-updatable-self-contained-cli-with-java-11-765afb545e52?source=collection_archive---------0-----------------------#2018-08-05">https://medium.com/oracledevs/auto-updatable-self-contained-cli-with-java-11-765afb545e52?source=collection_archive---------0-----------------------#2018-08-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7dbc7c5c2d20cc42df3f14cfca6ce5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZqIAFSLGBjADpNTsnu9Pw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/LqKhnDzSF-8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Sortino</a> on <a class="ae it" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5981" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="bb4f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在过去的11个月中，我们已经看到了Java的两个主要版本——Java 9和Java 10。到9月份，我们将会以Java 11的形式发布另一个版本，这都要归功于新的6个月发布系列。每个新版本都引入了激动人心的特性来帮助现代Java开发人员。让我们尝试一下这些特性，构建一个可自动更新的、自包含的命令行界面。</p><p id="e79a" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">我们CLI的最低可行功能集定义如下:</p><ul class=""><li id="c9f3" class="kv kw hh ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">通过调用免费币台API显示当前比特币价格指数</li><li id="011e" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">检查是否有新的更新，如果有，自动更新CLI</li><li id="74a6" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">为CLI提供定制的Java运行时映像，使其自包含</li></ul><h1 id="996b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">先决条件</h1><p id="ef9c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了跟进，你需要一份JDK 11号早期版本的拷贝。您还需要gradle的最新版本(撰写本文时为4.9)。当然，您可以使用自己喜欢的方式构建Java应用程序。虽然不是必需的，但是熟悉<a class="ae it" href="http://openjdk.java.net/projects/jigsaw/" rel="noopener ugc nofollow" target="_blank"> JPMS </a>和<a class="ae it" href="https://docs.oracle.com/javase/10/tools/jlink.htm" rel="noopener ugc nofollow" target="_blank"> JLink </a>会很有帮助，因为我们将使用模块系统来构建一个定制的运行时映像。</p><h1 id="bb79" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">我们走吧</h1><p id="ffa7" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们首先创建一个提供最新比特币价格指数的类。在内部，它读取一个配置文件来获取coin desk REST API的URL，并构建一个http客户端来检索最新价格。该类利用了新的fluent HTTP客户端类，这些客户端类是“java.net.http”模块的一部分。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7f14" class="ls iv hh lo b fi lt lu l lv lw">var bpiRequest = HttpRequest.newBuilder()<br/>        .uri(new URI(config.getProperty("bpiURL")))<br/>        .GET()<br/>        .build();<br/><br/>var bpiApiClient = HttpClient.newHttpClient();<br/><br/>bpiApiClient<br/>    .sendAsync(bpiRequest,<br/>        HttpResponse.BodyHandlers.ofString())<br/>    .thenApply(response -&gt; toJson(response))<br/>    .thenApply(bpiJson -&gt; <br/>        bpiJson.getJsonObject("usd").getString("rate"));</span></pre><p id="0d11" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">按照Java标准，这段代码实际上非常简洁。我们使用新的fluent builders创建一个GET请求，调用API，将响应转换为JSON，并以美元货币拉动当前的比特币价格。</p><p id="512c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">为了构建一个模块化的jar并设置我们使用“jlink ”,我们需要添加一个“module-info.java”文件来指定CLI对其他模块的依赖性。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2476" class="ls iv hh lo b fi lt lu l lv lw">module ud.bpi.cli {<br/>    requires java.net.http;<br/>    requires org.glassfish.java.json;<br/>}</span></pre><p id="c362" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">从代码片段中，我们观察到我们的CLI模块需要Java 11中附带的http模块和一个外部JSON库。</p><p id="dc8f" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">现在，让我们把注意力转向实现一个自动更新类。这个类应该提供一些方法。一种方法是与中央存储库通信并检查是否有较新版本的CLI，另一种方法是下载最新版本。下面的代码片段显示了使用新的HTTP客户端接口下载远程文件是多么容易。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="b1fb" class="ls iv hh lo b fi lt lu l lv lw">CompletableFuture&lt;Boolean&gt; update(String downloadToFile) {<br/>    try {<br/>        HttpRequest request = HttpRequest.<em class="lx">newBuilder</em>()<br/>                .uri(new URI("http://localhost:8080/2.zip"))<br/>                .GET()<br/>                .build();<br/><br/>        return HttpClient.<em class="lx">newHttpClient</em>()<br/>                .sendAsync(request, HttpResponse.BodyHandlers<br/>                        .<em class="lx">ofFile</em>(Paths.<em class="lx">get</em>(downloadToFile)))<br/>                .thenApply(response -&gt; {<br/>                    unzip(response.body());<br/>                    return true;<br/>                });<br/><br/>    } catch (URISyntaxException ex) {<br/>        return CompletableFuture.<em class="lx">failedFuture</em>(ex);<br/>    }<br/>}</span></pre><p id="de89" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">Java 11中新的预定义HTTP主体处理程序可以将响应主体转换成常见的高级Java对象。我们使用了HttpResponse。BodyHandlers.ofFile()方法下载一个包含最新版本CLI的zip文件。</p><p id="bb63" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">让我们通过使用一个启动器类将这些类放在一起。它为我们的CLI提供了一个入口点，并实现了应用程序流。当应用程序启动时，这个类调用它的launch()方法来检查新的更新。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2b86" class="ls iv hh lo b fi lt lu l lv lw">void launch() {<br/>    var autoUpdater = new AutoUpdater();<br/><br/>    try {<br/><br/>        if (autoUpdater.check().get()) {<br/>            System.<em class="lx">exit</em>(autoUpdater.update().get() ? 100 : -1);<br/>        }<br/><br/>    } catch (InterruptedException | ExecutionException ex) {<br/>        throw new RuntimeException(ex);<br/>    }<br/>}</span></pre><p id="d0c8" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">如您所见，如果有新版本的CLI可用，我们下载新版本并通过传入自定义退出代码100来退出JVM。一个简单的包装器脚本将检查这个退出代码并重新运行CLI。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4239" class="ls iv hh lo b fi lt lu l lv lw"><strong class="lo hi">#!/bin/sh</strong></span><span id="463d" class="ls iv hh lo b fi ly lu l lv lw">...</span><span id="9d37" class="ls iv hh lo b fi ly lu l lv lw">start<br/>EXIT_STATUS=$?<br/><br/><strong class="lo hi">if [ $</strong>{EXIT_STATUS} <strong class="lo hi">-eq </strong>100<strong class="lo hi"> ]</strong>; <strong class="lo hi">then<br/>    </strong><em class="lx">start<br/></em><strong class="lo hi">fi</strong></span></pre><p id="4c3c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">最后，我们将使用“jlink”创建一个运行时映像，其中包含执行CLI所需的所有内容。jlink是Java提供的一个新的命令行工具，它将查看传递给它的选项，以将一组模块及其依赖项组装和优化到一个定制的运行时映像中。在这个过程中，它会构建一个自定义的JRE，从而使我们的CLI变得独立。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="0f6c" class="ls iv hh lo b fi lt lu l lv lw"><em class="lx">jlink </em>--module-path build/libs/:<strong class="lo hi">$</strong>{JAVA_HOME}/jmods \<br/>      --add-modules ud.bpi.cli,org.glassfish.java.json \<br/>      --launcher bpi=ud.bpi.cli/ud.bpi.cli.Launcher \<br/>      --output images</span></pre><p id="49c3" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">让我们看看传递给jlink的选项:</p><ul class=""><li id="bfe9" class="kv kw hh ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">“module-path”告诉jlink查看包含java模块的指定文件夹</li><li id="c8bf" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">“add-modules”告诉jlink哪些用户定义的模块将包含在自定义映像中</li><li id="b2f6" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">“launcher”用于指定将用于启动我们的CLI的脚本的名称，以及包含应用程序的main方法的类的完整路径</li><li id="5ea7" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">“输出”用于指定保存新创建的自包含自定义图像的文件夹名称</li></ul><p id="065c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">当我们运行第一个版本的CLI时，如果没有可用的更新，CLI将显示如下内容:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es et"><img src="../Images/3cec8859c5ab0f3d01c222bca7c7332f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYVOv3BT043JeKJj21FQkg.png"/></div></div></figure><p id="d328" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">假设我们发布了CLI的新版本(2)并将其推送到中央回购。现在，当您重新运行CLI时，您将看到如下内容:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/aaec65e22af598e4e17b802f8f9c75f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuXEM2XZAAG_zw599yWukw.png"/></div></div></figure><p id="dc1e" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">瞧啊。应用程序发现有新版本可用，并自动更新自己。然后，它会重新启动CLI。正如你所看到的，新版本增加了一个向上/向下箭头指示器，让用户知道比特币价格指数的表现如何。</p><p id="38f0" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">前往<a class="ae it" href="https://github.com/udaychandra/auto-updater-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获取源代码并进行实验。</p></div></div>    
</body>
</html>