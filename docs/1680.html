<html>
<head>
<title>Coordinator Pattern in Android with Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中使用Kotlin协程的协调模式</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coordinator-pattern-in-android-with-kotlin-coroutines-fcdf79a089de?source=collection_archive---------0-----------------------#2019-05-15">https://medium.com/capital-one-tech/coordinator-pattern-in-android-with-kotlin-coroutines-fcdf79a089de?source=collection_archive---------0-----------------------#2019-05-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6684ab69849af7d33180e65e1160539d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pIGvQs9IVFttDQs8"/></div></div></figure><p id="6a35" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Capital One，我的团队为企业构建Android SDKs。最近，我们遇到了一个有趣的情况，UI流必须是动态的，这意味着与服务器的每次交互都将返回一个包含SDK需要显示的下一个屏幕的响应。我们知道，如果设计得不好，这个问题很容易导致糟糕的代码。因此，受汉尼斯·多尔夫曼的协调员<a class="ae jn" href="http://hannesdorfmann.com/android/coordinators-android" rel="noopener ugc nofollow" target="_blank">模式</a>的启发，我们转向了一种动态响应API响应的方法。</p><p id="1d16" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举个例子，我们的SDK是使用内部的模型-视图-意图(MVI)框架构建的。该框架使用redux <a class="ae jn" href="https://redux.js.org/introduction/three-principles" rel="noopener ugc nofollow" target="_blank">原则</a>设计，支持结构化并发。</p><p id="504e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文重点介绍我们使用Kotlin协程解决动态导航的方法。</p><p id="ef2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">如果你不熟悉协程，</em><a class="ae jn" rel="noopener" href="/@elizarov"><em class="jo">Roman Eliza ROV</em></a><em class="jo">有大量的文章和视频非常好地解释了这个概念。</em></p><h1 id="78cc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak"> <em class="kn">一种基于协程的</em>解决方案</strong></h1><p id="c09c" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated"><em class="jo">协调器包含在视图之间导航的业务逻辑。</em></p><p id="29d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个协调器使用一个<strong class="ir hi">协程</strong> <strong class="ir hi">参与者</strong>来按顺序处理异步<strong class="ir hi"> <em class="jo">意图</em> </strong>，这些都在流程生命周期的<strong class="ir hi">范围内</strong>。</p><h2 id="e383" class="kt jq hh bd jr ku kv kw jv kx ky kz jz ja la lb kd je lc ld kh ji le lf kl lg bi translated"><strong class="ak">组件</strong></h2><p id="b630" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated">下图是我们将要讨论的各种组件的参考。</p><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/8cd911109f17ab1268e7a21dcc2148f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oq55RBh_NKH9LFxn"/></div></div></figure><ul class=""><li id="cba1" class="lm ln hh ir b is it iw ix ja lo je lp ji lq jm lr ls lt lu bi translated">根协调器的作用范围是<em class="jo">应用/ SDK的</em>协程上下文，负责通过根导航器基于业务规则调用特定的流协调器。</li><li id="90e3" class="lm ln hh ir b is lv iw lw ja lx je ly ji lz jm lr ls lt lu bi translated">流协调器的作用范围是<em class="jo">活动视图模型</em>，并且与所有子视图模型共享。基本上，他们负责在流程中的视图之间导航。</li><li id="a14f" class="lm ln hh ir b is lv iw lw ja lx je ly ji lz jm lr ls lt lu bi translated">Flow Navigator是一个无状态组件，它只拥有向流的活动添加视图/片段的逻辑。它们由流协调器调用。</li></ul><h1 id="01c9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">协调者</h1><p id="92f9" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated">下面的代码示例代表了一个由根协调器启动的登录活动流中使用的协调器。为了保持这篇文章的简短和集中，我们将只讨论其中一个协调器，因为它们都遵循相似的设计原则。</p><h2 id="078c" class="kt jq hh bd jr ku kv kw jv kx ky kz jz ja la lb kd je lc ld kh ji le lf kl lg bi translated"><strong class="ak"> <em class="kn">建造师</em> </strong></h2><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/8742ef5a01bb5862792c9e4b091e0791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k_TG2rOlDP8XlZAj"/></div></div></figure><p id="4874" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">范围</em>与主活动的视图模型相关联，并在子片段视图模型之间共享。onFlowComplete lambda由RootCoordinator提供，它应该在流结束时被调用。这样，流的退出和进入由RootCoordinator控制。</p><h2 id="9201" class="kt jq hh bd jr ku kv kw jv kx ky kz jz ja la lb kd je lc ld kh ji le lf kl lg bi translated"><strong class="ak"> <em class="kn">意图</em> </strong></h2><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/f81aeca5b76bca0aaa507f515734e379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dZbzZcNjYtFfVDgQ"/></div></div></figure><p id="7255" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些是我们的协调员用来计算结果的。它们可以由用户操作或一些异步操作(如API响应)创建。</p><h2 id="1f7c" class="kt jq hh bd jr ku kv kw jv kx ky kz jz ja la lb kd je lc ld kh ji le lf kl lg bi translated"><strong class="ak"> <em class="kn">演员</em> </strong></h2><p id="c3e1" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated"><em class="jo">异步编程界能拿奥斯卡的演员；)</em></p><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/334a6e51ef4d098e3dd794105659125e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wVfsGsSPY-8QmB0W"/></div></div></figure><p id="a26a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的协调器也有一个actor，它将被延迟初始化，并具有无限的通道容量。我们选择的容量基于我们的使用案例，因为我们不想放弃任何意图。一个参与者顺序处理意图，并通过<code class="du mc md me mf b">copy(…)</code>扩展函数计算新的状态，从而确保不会发生并发的状态突变。理想情况下，每个意图都将映射到一个由SignInFlowNavigator提供的导航操作。</p><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/885ce410e640a7f7917361d05c2f994b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eK0cLOPTAIJEAN8n"/></div></div></figure><p id="a895" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协调器还公开了一个函数，用于将意图添加到参与者的队列中。</p><p id="eb63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">更多关于协程演员的内容可以在这里阅读</em><a class="ae jn" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/shared-mutable-state-and-concurrency.md#actors" rel="noopener ugc nofollow" target="_blank"><em class="jo"/></a><em class="jo">。</em></p><h1 id="6be7" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">航海家</h1><p id="cd91" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated">现在让我们看看登录活动流中使用的导航器，它由登录协调器调用。为了保持这篇文章的简短和集中，我们将只讨论其中一个导航器，因为它们都遵循相似的设计原则。</p><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/a0687e40cf1a5d6a755c8cc22e3741a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xeQoFTWDcproQ7N-"/></div></div></figure><p id="b0e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">导航器是无状态的，其范围类似于SignInFlowCoordinator，尽管它们不拥有业务逻辑。像协调器一样，它通过参与者处理它的意图。您可能已经注意到，我们还传入了一个activityFetcher，它公开了当活动不可用或不处于有效的生命周期状态时导航器挂起的<code class="du mc md me mf b">CompletableDeferred&lt;AppCompatActivity&gt;</code>。</p><h1 id="9976" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">结论</strong></h1><p id="46a4" class="pw-post-body-paragraph ip iq hh ir b is ko iu iv iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm ha bi translated">上面讨论的方法只是协调器概念的一种可能的实现。这种方法有助于简化视图模型和活动/片段，消除重复，并抽象导航逻辑。</p><p id="d066" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我的团队正在招聘Android开发人员。如果你知道谁可能感兴趣，请把链接发给他们，并把我介绍给他们！</p></div></div>    
</body>
</html>