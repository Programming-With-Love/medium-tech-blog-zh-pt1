<html>
<head>
<title>React Native Location Tracking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本地位置跟踪</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/react-native-location-tracking-14ab2c9e2db8?source=collection_archive---------0-----------------------#2018-05-18">https://medium.com/quick-code/react-native-location-tracking-14ab2c9e2db8?source=collection_archive---------0-----------------------#2018-05-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e157" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用react native和react-native-maps构建实时位置跟踪应用程序</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/82387cb8aa84b2d379b55af1050468de.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/1*2Nha7uGKIJkGorDmgh2qLA.gif"/></div><figcaption class="je jf et er es jg jh bd b be z dx">Tracks user’s location and draws the path as the location changes</figcaption></figure><p id="b345" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你一直在使用React Native，你一定用过或者听说过react-native-maps。React native maps是一个React native包，为react native提供Google Maps API。使用静态谷歌地图是非常常见的，但今天我们将使用谷歌地图的一个广泛使用的功能，使用React native进行位置跟踪。</p><blockquote class="ke kf kg"><p id="ac59" class="ji jj kh jk b jl jm ii jn jo jp il jq ki js jt ju kj jw jx jy kk ka kb kc kd ha bi translated">在这里找到项目回购<a class="ae kl" href="https://github.com/vikrantnegi/react-native-location-tracking" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><h2 id="1a7f" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">入门指南</h2><p id="80ab" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">首先创建一个React原生项目，并随意命名。我用的是react-native-cli，但是<a class="ae kl" href="https://github.com/react-community/create-react-native-app" rel="noopener ugc nofollow" target="_blank"> create-react-native-app </a>应该也可以。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="3102" class="km kn hh ln b fi lr ls l lt lu">react-native init locationTracking</span></pre><h2 id="70f6" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">安装react-native-maps</h2><p id="1493" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">首先，从npm下载这个库:</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="25c5" class="km kn hh ln b fi lr ls l lt lu">npm install react-native-maps --save</span></pre><p id="265f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">安装react-native-maps需要在原生iOS和Android文件中添加代码。遵循react-native-maps提供的<a class="ae kl" href="https://github.com/react-community/react-native-maps/blob/master/docs/installation.md" rel="noopener ugc nofollow" target="_blank">安装</a>说明。安装后，确保项目成功构建，然后再继续。</p><p id="44aa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">安装react-native-maps不是一项简单的任务。如果你是第一次这样做，我建议仔细阅读安装说明。相信我，这将是本教程最艰巨的任务。如果你遇到任何错误，请使用谷歌。😅在<a class="ae kl" href="https://blog.coursesity.com/best-react-native-tutorials/" rel="noopener ugc nofollow" target="_blank"> best react-native教程</a>的帮助下，你将能够开发适用于Android和iOS的全功能应用。</p><h2 id="8a20" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">使用反应原生映射</h2><p id="b304" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">很好，现在您已经成功安装了react-native-maps。让我们进入有趣的部分，真正的奇迹发生了。😃</p><p id="d0e8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们首先设置一些将用于这个项目的初始状态。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="ce48" class="km kn hh ln b fi lr ls l lt lu">constructor(props) {<br/>  super(props);</span><span id="4b4b" class="km kn hh ln b fi lv ls l lt lu">  <em class="kh">this</em>.state = {<br/>    latitude: LATITUDE,<br/>    longitude: LONGITUDE,<br/>    routeCoordinates: [],<br/>    distanceTravelled: 0,<br/>    prevLatLng: {},<br/>    coordinate: new AnimatedRegion({<br/>     latitude: LATITUDE,<br/>     longitude: LONGITUDE<br/>    })<br/>  };<br/>}</span></pre><p id="acaf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们稍后将在应用程序中使用这些状态，这里唯一感兴趣的是<code class="du lw lx ly ln b">new AnimatedRegion</code>，它将帮助我们在位置更新时制作标记动画。</p><h2 id="4810" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">注意位置变化</h2><p id="d94f" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">现在我们需要获得用户每次移动的位置坐标。谷歌地图地理定位API有<code class="du lw lx ly ln b">watchPosition</code>方法，这将帮助我们在位置坐标发生变化时获取它们。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="fff0" class="km kn hh ln b fi lr ls l lt lu">componentDidMount() {<br/>  this.watchID = navigator.geolocation.watchPosition(<br/>    position =&gt; {<br/>      const { coordinate, routeCoordinates, distanceTravelled } =   this.state;<br/>      const { latitude, longitude } = position.coords;<br/>      <br/>      const newCoordinate = {<br/>        latitude,<br/>        longitude<br/>      };</span><span id="4107" class="km kn hh ln b fi lv ls l lt lu">      if (Platform.OS === "android") {<br/>        if (this.marker) {<br/>          this.marker._component.animateMarkerToCoordinate(<br/>            newCoordinate,<br/>            500<br/>          );<br/>         }<br/>       } else {<br/>         coordinate.timing(newCoordinate).start();<br/>       }</span><span id="ea8b" class="km kn hh ln b fi lv ls l lt lu">       this.setState({<br/>         latitude,<br/>         longitude,<br/>         routeCoordinates: routeCoordinates.concat([newCoordinate]),<br/>         distanceTravelled:<br/>         distanceTravelled + this.calcDistance(newCoordinate),<br/>         prevLatLng: newCoordinate<br/>       });<br/>     },<br/>     error =&gt; console.log(error),<br/>     { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }<br/>  );<br/>}</span></pre><p id="594b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">无论何时用户的位置发生变化,<code class="du lw lx ly ln b">watchPosition</code>都会给我们提供相关信息。然后我们使用ES6 <a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>从<code class="du lw lx ly ln b">position.coords</code>中获取<code class="du lw lx ly ln b">latitude &amp; longitude</code>。同样，我们会从初始状态得到<code class="du lw lx ly ln b">coordinate, routeCoordinates &amp; distanceTravelled</code>。</p><p id="30dc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后我们将创建<code class="du lw lx ly ln b">newCoordinate</code>变量，它将存储我们从<code class="du lw lx ly ln b">position.coords</code>接收到的这些新的更新的位置坐标。现在我们已经得到了更新坐标，我们将动画标记这些新的坐标。Android和iOS对此有不同的处理方式，所以我们将使用<code class="du lw lx ly ln b"><a class="ae kl" href="https://facebook.github.io/react-native/docs/platform-specific-code.html" rel="noopener ugc nofollow" target="_blank">Platform Specific Code</a></code>来处理。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="c399" class="km kn hh ln b fi lr ls l lt lu">if (Platform.OS === "android") {<br/>  if (this.marker) {<br/>  this.marker._component.animateMarkerToCoordinate(<br/>    newCoordinate,<br/>    500<br/>   );<br/>  }<br/>} else {<br/>  coordinate.timing(newCoordinate).start();<br/>}</span></pre><p id="7917" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在是用新的状态更新初始状态的时候了。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="a9e3" class="km kn hh ln b fi lr ls l lt lu">this.setState({<br/>  latitude,<br/>  longitude,<br/>  routeCoordinates: routeCoordinates.concat([newCoordinate]),<br/>  distanceTravelled: distanceTravelled + this.calcDistance(newCoordinate),<br/>  prevLatLng: newCoordinate<br/>});</span></pre><h2 id="d573" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">计算行驶距离</h2><p id="2f4b" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">我们使用了<code class="du lw lx ly ln b">distanceTravelled</code>状态变量来存储用户走过的距离。为了计算这个距离，我们将创建一个新函数<code class="du lw lx ly ln b">calcDistance</code>，它将<code class="du lw lx ly ln b">newLatLng</code>作为参数，将<code class="du lw lx ly ln b">prevLatLng</code>作为状态变量，并将返回距离。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="13ee" class="km kn hh ln b fi lr ls l lt lu">calcDistance = newLatLng =&gt; {<br/>  const { prevLatLng } = this.state;<br/>  return haversine(prevLatLng, newLatLng) || 0;<br/>};</span></pre><p id="ebc1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">看着这个函数，你可能想知道什么时候计算距离变得如此复杂。显然，由于地球的曲率，借助<code class="du lw lx ly ln b">latitude</code>和<code class="du lw lx ly ln b">longitude</code>计算距离并不那么简单。地球有一些曲线😝。</p><p id="787d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了使用<code class="du lw lx ly ln b">latitude</code>和<code class="du lw lx ly ln b">longitude</code>计算距离，我们需要使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank">哈弗辛公式</a>。如果你像我一样纠结于数学😅，有一个以<code class="du lw lx ly ln b">haversine</code> npm包的形式出现的希望，它可以帮助我们使用<code class="du lw lx ly ln b">latitude</code>和<code class="du lw lx ly ln b">longitude</code>计算距离。使用以下命令安装<code class="du lw lx ly ln b">haversine</code> npm包。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="c0ba" class="km kn hh ln b fi lr ls l lt lu">npm install haversine</span></pre><h2 id="a6dd" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">渲染<code class="du lw lx ly ln b">MapView</code></h2><p id="9b6f" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">因为<code class="du lw lx ly ln b">&lt;MapView&gt;</code>组件需要<code class="du lw lx ly ln b">region</code>道具，该道具接受带有位置坐标的<code class="du lw lx ly ln b">object</code>。我们将创建一个函数，返回所需的所有必要信息。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="eb7f" class="km kn hh ln b fi lr ls l lt lu">getMapRegion = () =&gt; ({<br/>  latitude: this.state.latitude,<br/>  longitude: this.state.longitude,<br/>  latitudeDelta: LATITUDE_DELTA,<br/>  longitudeDelta: LONGITUDE_DELTA<br/>});</span></pre><p id="7e92" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们有了渲染地图所需的所有信息。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="9381" class="km kn hh ln b fi lr ls l lt lu">&lt;MapView<br/>  style={styles.map}<br/>  showUserLocation<br/>  followUserLocation<br/>  loadingEnabled<br/>  region={this.getMapRegion()}<br/>&gt;</span><span id="9f54" class="km kn hh ln b fi lv ls l lt lu">  &lt;Polyline coordinates={this.state.routeCoordinates} strokeWidth={5} /&gt;<br/>  &lt;Marker.Animated<br/>    ref={marker =&gt; {<br/>      this.marker = marker;<br/>    }}<br/>    coordinate={this.state.coordinate}<br/>  /&gt;<br/>&lt;/MapView&gt;</span></pre><p id="0391" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们还使用谷歌地图<code class="du lw lx ly ln b"><a class="ae kl" href="https://github.com/react-community/react-native-maps/blob/master/docs/polyline.md" rel="noopener ugc nofollow" target="_blank">Polyline</a></code>来绘制用户移动的路径。<code class="du lw lx ly ln b">Polyline</code>有一个<code class="du lw lx ly ln b">coordinate</code>道具，它接受一个坐标数组，我们可以从<code class="du lw lx ly ln b">routeCoordinates</code>中得到这个数组。我们还将<code class="du lw lx ly ln b">strokeWidth</code>设置为，这样我们可以清楚地看到路径。</p><p id="d4d1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，为了显示动画标记，我们将使用<code class="du lw lx ly ln b">Marker.Animated</code>组件来显示用户当前位置的标记。它有<code class="du lw lx ly ln b">coordinate</code>道具，可以从状态中获取<code class="du lw lx ly ln b">coordinate</code>对象。</p><h2 id="391f" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">显示旅行距离</h2><p id="4f1d" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">最后，为了显示用户走过的距离，我们将设置一个应用了适当样式的<code class="du lw lx ly ln b">View</code>。</p><pre class="ix iy iz ja fd lm ln lo lp aw lq bi"><span id="d5b9" class="km kn hh ln b fi lr ls l lt lu">&lt;View style={styles.buttonContainer}&gt;<br/>  &lt;TouchableOpacity style={[styles.bubble, styles.button]}&gt;<br/>    &lt;Text style={styles.bottomBarContent}&gt;<br/>      {parseFloat(this.state.distanceTravelled).toFixed(2)} km<br/>    &lt;/Text&gt;<br/>  &lt;/TouchableOpacity&gt;<br/>&lt;/View&gt;</span></pre><h2 id="ed31" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">测试</h2><p id="4788" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">现在我们已经准备好了所有必要的部分，我们终于可以运行我们的应用程序了。</p><p id="07a8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了在iOS模拟器上测试该应用程序，我们将使用iOS模拟器中可用的定位模式。运行应用程序后，进入模拟器中的<code class="du lw lx ly ln b">Debug</code> &gt; <code class="du lw lx ly ln b">Location</code> &gt; <code class="du lw lx ly ln b">Freeway Drive</code>设置，打开此功能。这样做应该会产生类似下面的结果。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/82387cb8aa84b2d379b55af1050468de.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/1*2Nha7uGKIJkGorDmgh2qLA.gif"/></div></figure><p id="6737" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于Android，这并不简单，因为Android模拟器没有内置的功能来测试动态位置变化。为了测试它，你可以通过步行一段距离来手动改变你的位置，或者你可以使用第三方模拟定位应用程序。我能够在Android上使用<a class="ae kl" href="https://play.google.com/store/apps/details?id=com.theappninjas.gpsjoystick&amp;hl=en_IN" rel="noopener ugc nofollow" target="_blank"> GPS操纵杆</a>应用程序来测试这一点。</p><h2 id="43d5" class="km kn hh bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg bi translated">结论</h2><p id="3b80" class="pw-post-body-paragraph ji jj hh jk b jl lh ii jn jo li il jq jr lj jt ju jv lk jx jy jz ll kb kc kd ha bi translated">我们已经成功创建了一个React本机应用程序，它可以跟踪用户位置并绘制路径。它还可以计算用户行进的距离。</p><p id="9ac6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我已经跳过了这个应用程序需要的样式和一些其他样板代码，但是你可以在GitHub repo <a class="ae kl" href="https://github.com/vikrantnegi/react-native-location-tracking" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="964e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望这能帮助你理解谷歌地图API。也许你可以从中获得灵感来建造一些令人惊叹的东西。请随时留下任何反馈，我一直在寻找更好的解决方案！</p><p id="ec43" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">编辑:我在Sitepoint上发表了一篇后续文章，扩展了本文的功能。</p><ul class=""><li id="052c" class="mg mh hh jk b jl jm jo jp jr mi jv mj jz mk kd ml mm mn mo bi translated">【React Native和PubNub的实时位置跟踪</li></ul><p id="72ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">查看我的其他文章:</p><ul class=""><li id="2765" class="mg mh hh jk b jl jm jo jp jr mi jv mj jz mk kd ml mm mn mo bi translated"><a class="ae kl" href="https://medium.freecodecamp.org/how-to-build-a-react-native-flatlist-with-realtime-searching-ability-81ad100f6699" rel="noopener ugc nofollow" target="_blank"> React Native FlatList具备实时搜索能力</a></li><li id="e0c9" class="mg mh hh jk b jl mp jo mq jr mr jv ms jz mt kd ml mm mn mo bi translated"><a class="ae kl" href="https://medium.freecodecamp.org/how-to-build-react-native-charts-with-dynamic-tooltips-64aefc550c95" rel="noopener ugc nofollow" target="_blank">用动态工具提示反应原生图表</a></li><li id="1812" class="mg mh hh jk b jl mp jo mq jr mr jv ms jz mt kd ml mm mn mo bi translated"><a class="ae kl" href="https://medium.freecodecamp.org/how-to-create-a-beautifully-animated-loader-in-react-native-21da37a8f6b0" rel="noopener ugc nofollow" target="_blank">如何在React Native中创建一个漂亮的动画加载器</a></li></ul></div></div>    
</body>
</html>