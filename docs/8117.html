<html>
<head>
<title>Scaling the Walmart Inventory Reservations API for Peak Traffic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对高峰流量扩展沃尔玛库存预订API</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/scaling-the-walmart-inventory-reservations-api-for-peak-traffic-9ba37833ef9d?source=collection_archive---------0-----------------------#2022-05-03">https://medium.com/walmartglobaltech/scaling-the-walmart-inventory-reservations-api-for-peak-traffic-9ba37833ef9d?source=collection_archive---------0-----------------------#2022-05-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b41871b1577317c80ddce732a636e3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGKqDqVJAnNSIaq22GX0Zg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/iR8m2RRo-z4" rel="noopener ugc nofollow" target="_blank">Jake Givens</a> on <a class="ae it" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5e09" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当<strong class="iw hi">顾客</strong>在<strong class="iw hi">Walmart.com</strong>网站或手机app上下单时，就会发出<strong class="iw hi">库存</strong>预约电话。这捕获了对客户购物车中商品的需求。在感恩节假期或任何销售活动(例如，PS5或Xbox活动)期间，库存预订请求的数量可能非常高。在这篇文章中，我想解释一下我们是如何克服扩展问题，现在能够无缝处理高峰流量的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="06e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在进行优化之前，让我们了解一下可销售库存是如何计算的。</p><p id="c72f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">可供销售=现有库存—订单进行中</strong></p><p id="5606" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的公式简单地计算了可供销售的单位。现有库存根据库存摄取馈送进行更新。库存信息可以来自沃尔玛商店、配送中心或市场界面。需求\进行中的订单根据库存预订的数量进行更新。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="a6fc" class="ki kj hh ke b fi kk kl l km kn">{</span><span id="cd4e" class="ki kj hh ke b fi ko kl l km kn">"id": "5a3adr7sehfe4y9a8ezb80da8sch6afz",</span><span id="d431" class="ki kj hh ke b fi ko kl l km kn">"sId": "65CED97DC02248478EAF8242FC808601-ss-1",//partition key</span><span id="c254" class="ki kj hh ke b fi ko kl l km kn">"onHand" : 10,</span><span id="7994" class="ki kj hh ke b fi ko kl l km kn">"ordersInProgress" : 4,</span><span id="0731" class="ki kj hh ke b fi ko kl l km kn">"availableToSell" : 6</span><span id="747e" class="ki kj hh ke b fi ko kl l km kn">...other fields omitted</span><span id="aa80" class="ki kj hh ke b fi ko kl l km kn">}</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="1054" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">库存预订服务的第一个设计很简单。这是一个<strong class="iw hi">水平扩展的API </strong>，其中每个实例试图<strong class="iw hi">执行</strong>保留<strong class="iw hi">命令</strong>和<strong class="iw hi">命令</strong> ( <em class="kp">执行命令和应用事件概念是</em> <a class="ae it" href="https://microservices.io/patterns/data/event-sourcing.html" rel="noopener ugc nofollow" target="_blank"> <em class="kp">事件源</em> </a> <em class="kp">模式</em>的一部分)并将已执行的<strong class="iw hi">保留</strong> <strong class="iw hi">事件</strong>写入事件集合(CosmosDB容器)。一旦预留事件被写入，则<strong class="iw hi">快照</strong>服务将<strong class="iw hi">在库存快照上应用</strong>预留事件。这意味着来自reserved事件的数量被聚合到库存快照上的ordersInProgress字段中(参见上面的JSON)。</p><figure class="jz ka kb kc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/859af46b156e70b12f75fc049c55ef08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uk3x0vDIcQC_0YV-YaWhlA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Reservation API without sticky session and header-based routing</figcaption></figure><p id="d4f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过这种方法，我们很快注意到，当API调用的数量增加时，会有大量的<strong class="iw hi">写争用</strong>。这意味着，如果有多个实例试图在同一个<strong class="iw hi">分区键</strong>上写入保留事件，它们将会因冲突而重试。</p><p id="ccc8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了克服这种写争用，我们在新设计中利用了分散-收集技术。库存预订API被分成<strong class="iw hi">主预订API </strong>和<strong class="iw hi">行预订API </strong>。当主预订API接收到一个预订请求时，它将拆分按数据库分区键sellingId分组的预订行，并调用行预订API。主预订API中的每个行项目都通过一个定制的HTTP头路由到行预订API。这个<strong class="iw hi"> HTTP头</strong>由<strong class="iw hi"> Istio </strong> sidecar识别，使用一致的基于哈希的<strong class="iw hi">目的地规则</strong>将请求路由到同一个<strong class="iw hi"> Kubernetes </strong> pod。</p><figure class="jz ka kb kc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/8529fadd2b90519e6693585df79b2ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUWEFz_04CTSwYRugINPNA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Main and Line Reservation API with sticky session using batch-id header</figcaption></figure><p id="82a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过进行这种设计更改，我们可以确保只有一个实例接收对同一个分区键的请求。然后在同一个pod中，传入的请求被路由到运行<strong class="iw hi"> MailBoxProcessor </strong>的同一个<strong class="iw hi">线程</strong>。该技术用于实现<strong class="iw hi">内存并发</strong>。使用这个请求，路由试图写入分布式数据存储(CosmosDB)中的单个分区的进程\线程的数量减少到一个。</p><figure class="jz ka kb kc fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/abeac9f0096243910849fa8068334fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*z2gIZ8TbRtAh2SIz5L6fTg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Mailbox processing using actor pattern</figcaption></figure><p id="d298" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然我们可以通过这种设计减少写争用，但是我们遇到的下一个瓶颈是从单个实例写入数据库的保留事件的数量。CosmosDB的每分区吞吐量上限为<strong class="iw hi"> 10，000 ru</strong>。这意味着，如果每个保留的事件文档写入将使用<strong class="iw hi"> 5个RUs，</strong>，那么我们的写入吞吐量将被限制在每秒10，000/5= 2，000个订单(OPS)。这意味着对于任何商品，我们每分钟只能接受<strong class="iw hi">2000份订单</strong>或<strong class="iw hi"> 12万份订单(OPM)。</strong></p><p id="ab4e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了克服每个分区的写限制，我们创建的另一个<strong class="iw hi">优化</strong>是对保留的事件进行批处理，并创建一个单独的<strong class="iw hi"> batchReserved </strong>事件，它可以将多个保留作为一个单独的文档写入。这意味着我们可以将写入吞吐量提高到2000次以上。我们对它进行了压力测试，以处理超过5，000次操作或超过300，000次OPM。</p><p id="79db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我想强调的另一个优化是T2快照缓存。在执行保留命令之前，必须从数据库中读取分区键的当前状态或快照。由于每个预留调用都会发生快照读取，并且只有一个实例负责处理单个分区键的预留，因此在该实例中会维护一个具有<strong class="iw hi"> TTL </strong>的内存快照缓存。并且有一个异步后台进程使快照缓存与数据库保持同步。这种优化减少了快照读取的总数，并降低了预订服务的读取RUs成本。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="fd3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">总而言之，</strong>下面列出了可以应用于任何<strong class="iw hi">重写API </strong>的所有优化。</p><ol class=""><li id="37c5" class="kt ku hh iw b ix iy jb jc jf kv jj kw jn kx jr ky kz la lb bi translated">分散——用粘性会话收集API请求，这样数据库分区总是由同一个实例处理。</li><li id="9555" class="kt ku hh iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">使用带有邮箱的actor模式的内存中并发将单个分区的处理限制为单个线程。这也有助于相同分区请求的批处理。</li><li id="9bc7" class="kt ku hh iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">内存中的快照状态缓存可减少读取次数。</li></ol><p id="5f5c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些优化之所以成为可能，是因为我们优秀团队的共同努力:Shanawaaz Mohammed、Devesh Singh、Ammad Shaikh、Shanil Sharma、Mohammad Tariq和Murali Gadde。</p></div></div>    
</body>
</html>