<html>
<head>
<title>DataStore and Kotlin serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据存储和Kotlin序列化</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c?source=collection_archive---------4-----------------------#2022-02-09">https://medium.com/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c?source=collection_archive---------4-----------------------#2022-02-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/2299991abb14db357c1c152c75cb62f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8lWMtxkqO0QNOmu8L6R5Pg.png"/></div></div></figure><div class=""/><p id="5398" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"> <strong class="ir ht"> Jetpack DataStore系列</strong> </a>的以下帖子中，我们将涵盖几个额外的概念，以了解DataStore如何与其他API交互，以便您可以在<strong class="ir ht">生产环境</strong>中使用它。在本帖中，我们将重点关注<a class="ae jn" href="https://kotlinlang.org/docs/serialization.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">科特林连载</strong> </a>。在这篇文章中，我们将参考<a class="ae jn" href="https://developer.android.com/codelabs/android-preferences-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">首选项</strong> </a>和<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">原型</strong></a>codelab，获取代码示例。</p><h1 id="7748" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">具有Kotlin序列化的数据存储</h1><p id="e201" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在我们之前的帖子中，我们已经介绍了<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore#datastore-preferences" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Preferences </strong> </a>和<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore#datastore-typed" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto</strong></a>DataStore方法如何构造和序列化持久化的数据:Proto使用由 <a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">协议缓冲区</strong></a><strong class="ir ht"/>支持的<strong class="ir ht">类型化对象，而Preferences使用<strong class="ir ht">键值对</strong>作为我们的数据表示，类似于<code class="du kr ks kt ku b">SharedPreferences</code>。在幕后，<strong class="ir ht">两种实现都使用协议缓冲区将数据保存在磁盘上的一个文件中。</strong>但是，DataStore也允许你定制这个，使用数据类和<a class="ae jn" href="https://kotlinlang.org/docs/serialization.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Kotlin序列化</strong> </a>，给你Proto DataStore的<strong class="ir ht">类型安全优势</strong>，但是不必使用protobufs。让我们来看看对于这些方法中的每一种，默认情况下序列化是如何工作的:</strong></p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kv"><img src="../Images/b45e37467ce3395e219fa7b05b019e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-fzytirSRwcmbkvOfeGew.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">Serialization options with DataStore</figcaption></figure><p id="a849" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Preferences DataStore通过在其底层Proto实现之上添加一个附加层<strong class="ir ht">来简化protobufs的工作。这样，您可以从使用数据存储库</strong>中获得<strong class="ir ht">的很多好处，但是使用类似于<code class="du kr ks kt ku b">SharedPreferences</code>的方式来组织数据，使用<strong class="ir ht">键值对</strong>。</strong></p><p id="7c9f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们看看Preferences API的<code class="du kr ks kt ku b"><a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:datastore/datastore-preferences-core/src/main/java/androidx/datastore/preferences/core/PreferencesSerializer.kt;l=36?q=PreferencesSerializer&amp;sq=" rel="noopener ugc nofollow" target="_blank">PreferencesSerializer</a></code>和我们的自定义原型<code class="du kr ks kt ku b">UserPreferencesSerializer</code>，你会注意到它们几乎做了同样的事情。<code class="du kr ks kt ku b">PreferencesSerializer</code>只是增加了一个将<strong class="ir ht">键值对转换成proto buf</strong>的步骤，反之亦然:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="970f" class="lg jp hs bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">使用Kotlin序列化实现数据存储</h2><p id="5f32" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果你想使用<a class="ae jn" href="https://kotlinlang.org/docs/serialization.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Kotlin序列化</strong> </a>来组织你的数据，你需要做的就是定义一个<strong class="ir ht">完全不可变的数据类</strong>并实现一个数据存储<code class="du kr ks kt ku b">Serializer</code>。</p><p id="ec67" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据存储依赖于为数据类自动生成的<code class="du kr ks kt ku b">equals</code>和<code class="du kr ks kt ku b">hashCode</code>。数据类还生成<code class="du kr ks kt ku b">toString</code>和<code class="du kr ks kt ku b">copy</code>函数，这些函数对于调试和更新数据很有用:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="e961" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">🚨确保你的类是不可变的非常重要，因为数据存储与可变类型不兼容。由于数据不一致和竞争条件，对数据存储使用可变类型将导致<strong class="ir ht">错误。默认情况下，数据类<strong class="ir ht">不一定是不可变的</strong>，所以要确保在任何地方都使用val，而不是vars:</strong></p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="0c78" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">数组是可变的</strong>，所以你不应该暴露它们。即使我们使用只读的<code class="du kr ks kt ku b">List</code>作为数据类的成员，它仍然是可变的。相反，你应该考虑使用<strong class="ir ht">不可变/持久集合</strong>:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="37bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用可变类型作为数据类的成员使其可变。相反，你应该确保所有的成员都是不可变的类型。</p><p id="042f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin序列化支持<strong class="ir ht"> </strong> <a class="ae jn" href="https://kotlinlang.org/docs/serialization.html#formats" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">多种格式</strong> </a>，包括JSON和<a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>。在这个例子中，我们将继续使用JSON。</p><p id="bc79" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使用Kotlin序列化在JSON中读写数据类，需要用<code class="du kr ks kt ku b">@Serializable</code>注释数据类，并覆盖<code class="du kr ks kt ku b">Serializer’s</code> <code class="du kr ks kt ku b">writeTo()</code>和<code class="du kr ks kt ku b">readFrom()</code>。这里有一个关于<code class="du kr ks kt ku b">UserPreferences</code>的例子:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="68ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">⚠️ <strong class="ir ht"> Parcelables与DataStore一起使用是不安全的</strong>，因为不同Android版本之间的数据格式可能会有所不同。</p><p id="2bf3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在构建数据存储时，将新创建的<code class="du kr ks kt ku b">UserPreferencesSerializer</code>传递到数据存储中:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8c8c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">读取数据看起来与使用protobufs相同:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="1362" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用生成的<code class="du kr ks kt ku b">.copy()</code>函数来更新数据:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="cd4e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用带有Kotlin序列化和数据类<strong class="ir ht">的DataStore可以减少样板文件并帮助简化您的代码</strong>，但是，您必须小心不要通过可变性引入<strong class="ir ht">错误。您需要做的就是定义您的数据类并实现序列化程序。</strong></p><h1 id="ca55" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">待续</h1><p id="cae1" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们已经介绍了<a class="ae jn" href="https://kotlinlang.org/docs/serialization.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Kotlin序列化</strong> </a>以及如何使用它来<strong class="ir ht">构建数据存储持久化数据的必要步骤——使用完全不可变的数据类</strong>，用<code class="du kr ks kt ku b"><a class="ae jn" href="http://twitter.com/Serializable" rel="noopener ugc nofollow" target="_blank">@Serializable</a></code>注释将它们写入JSON，覆盖我们的<code class="du kr ks kt ku b">Serializer’s</code> <code class="du kr ks kt ku b">writeTo()</code>和<code class="du kr ks kt ku b">readFrom()</code>，最后将它们传递给我们的数据存储实例。</p><p id="f3ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">加入我们系列的下一篇文章，我们将研究如何与数据存储库进行<strong class="ir ht">同步工作。</strong></p><p id="5b63" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在这里找到我们Jetpack DataStore系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack DataStore简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项DataStore </a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型DataStore</a><br/><a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">DataStore和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c"> DataStore和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c"> DataStore和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa"> DataStore和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8"> DataStore和测试</a></p></div></div>    
</body>
</html>