<html>
<head>
<title>Apache Beam with GCP Dataflow and Pubsub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有GCP数据流和公共订阅的Apache Beam</h1>
<blockquote>原文：<a href="https://medium.com/globant/apache-beam-with-gcp-dataflow-and-pubsub-c10235a7b598?source=collection_archive---------0-----------------------#2022-09-06">https://medium.com/globant/apache-beam-with-gcp-dataflow-and-pubsub-c10235a7b598?source=collection_archive---------0-----------------------#2022-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2650e816898384c087cf464a2a3cfa4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNOFSTrvGigQX0xsQ2T9CQ.png"/></div></div></figure></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="f8c0" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated"><strong class="ak">简介</strong></h1><p id="a693" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在本文中，我们将看看如何在Java中使用apache beam创建数据流管道。我们还将了解如何构建和部署管道，使用beam测试框架编写集成测试用例，并且我们还将研究一些高级概念，如使用元组标签来划分管道。</p><ul class=""><li id="7689" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><a class="ae ld" href="https://beam.apache.org/get-started/beam-overview/" rel="noopener ugc nofollow" target="_blank"> Apache beam </a> —这是一个用于在更短的时间内创建分布式批处理和流式生产就绪管道的框架，它非常灵活，支持多个源和接收器，并支持各种<strong class="jw hi">分布式处理后端</strong>，其中包括<a class="ae ld" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink </a>、<a class="ae ld" href="http://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>和<a class="ae ld" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank"> Google Cloud Dataflow </a>。</li></ul><p id="7a73" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">beam对于令人尴尬的并行数据处理任务特别有用，在这种任务中，问题可以分解成许多更小的数据束，这些数据束可以独立并行处理。您还可以将Beam用于提取、转换和加载(ETL)任务以及纯数据集成。这些任务有助于在不同的存储介质和数据源之间移动数据，将数据转换为更理想的格式，或将数据加载到新系统中。</p><ul class=""><li id="8ccb" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><a class="ae ld" href="https://cloud.google.com/dataflow#section-6" rel="noopener ugc nofollow" target="_blank"> GCP数据流</a> —这是一个用于运行apache beam管道的托管服务。据说它也是由阿帕奇横梁支撑的转轮之一。</li></ul></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="147b" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">用例</h1><p id="5e58" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">假设我们要构建一个数据流作业，该作业从GCP pubsub topic<strong class="jw hi"><em class="lh">input-topic</em></strong>读取数据，订阅名为<strong class="jw hi"><em class="lh">input-topic-sub</em></strong>，处理该数据并将消息转换为另一种格式，然后将其放回到另一个pubsub topic，名为<strong class="jw hi"><em class="lh">【output-topic</em></strong>，如果在转换过程中出现任何错误，如验证错误或格式错误的JSON错误，我们需要创建错误消息并将其放入pubsub<strong class="jw hi">也就是说，我们必须根据成功和错误来划分我们的管道。</strong></p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/472144fd8f0af35e7ab6f1355d4f719a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJVu2bt-096Hcjo6MMoROQ.png"/></div></div></figure><p id="edb9" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">例如，假设我们有一个JSON格式的输入消息，它只有两个字段，即<strong class="jw hi"> <em class="lh">名字</em> </strong>和<strong class="jw hi"> <em class="lh">姓氏</em> </strong>作为-</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4e9b" class="ls ix hh lo b fi lt lu l lv lw">{firstname: "harsh", lastname: "sharma"}</span></pre><p id="3d8c" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在，转换后的消息应该有三个字段，分别是<strong class="jw hi"> <em class="lh">全名</em> </strong>、<strong class="jw hi"> <em class="lh"> id、</em> </strong>和<strong class="jw hi"> <em class="lh">长度</em> </strong>作为-</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="620a" class="ls ix hh lo b fi lt lu l lv lw">{fullname: "Harsh Sharma", id: "Unique-Id", length: 12}</span></pre><p id="84fd" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在，如果firstname或lastname为空或者不符合标准，我们应该在错误主题上发布一条错误消息，作为-</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="0397" class="ls ix hh lo b fi lt lu l lv lw">{fields: [{field: "firstname", message:"Should not be empty"}, {field: "lastname", message:"Should not contain any special characters"}], error: "Validation Error"}</span></pre></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="edf7" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">行动中的代码</h1><ul class=""><li id="8996" class="ks kt hh jw b jx jy kb kc kf lx kj ly kn lz kr kz la lb lc bi translated"><strong class="jw hi">定义管道选项</strong></li></ul><p id="02e8" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">创建一个名为<em class="lh">nametransformoroptions</em>的类，该类扩展了<strong class="jw hi"><em class="lh">DataflowPipelineOptions</em></strong>声明inputSubscription、outputTopic、outputErrorTopic的setter和getter方法，并将其他GCP参数配置为—</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9d5e" class="ls ix hh lo b fi lt lu l lv lw">import org.apache.beam.runners.dataflow.options.DataflowPipelineOptions;<br/>import org.apache.beam.sdk.options.Default;<br/>import org.apache.beam.sdk.options.Description;<br/>import org.apache.beam.sdk.options.Validation;</span><span id="3c58" class="ls ix hh lo b fi ma lu l lv lw">public interface NameTransformerOptions extends DataflowPipelineOptions { // specific to Dataflow Runner<br/>    // inputSubscription - for input PubSubMessage<br/>    <a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("The Cloud Pub/Sub subscription to consume from. " + "The name should be in the format of "<br/>        + "projects/&lt;project-id&gt;/subscriptions/&lt;subscription-name&gt;.")<br/>    <a class="ae ld" href="http://twitter.com/Validation" rel="noopener ugc nofollow" target="_blank">@Validation</a>.Required<br/>    String getInputSubscription();<br/>    void setInputSubscription(String inputSubscription);</span><span id="ebfc" class="ls ix hh lo b fi ma lu l lv lw">//outputTopic - for Out PubSubMessage<br/>    <a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("The Cloud Pub/Sub topic to publish to. The name should be in the format of projects/&lt;project-id&gt;/topics/&lt;topic-name&gt;.")<br/>    <a class="ae ld" href="http://twitter.com/Validation" rel="noopener ugc nofollow" target="_blank">@Validation</a>.Required<br/>    String getOutputTopic();<br/>    void setOutputTopic(String outputTopic);</span><span id="33e8" class="ls ix hh lo b fi ma lu l lv lw">// outputErrorTopic - for error during message processing<br/>    <a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("The Output error topic Pub/Sub to publish errors to")<br/>    <a class="ae ld" href="http://twitter.com/Validation" rel="noopener ugc nofollow" target="_blank">@Validation</a>.Required<br/>    String getOutputErrorTopic();<br/>    void setOutputErrorTopic(String outputErrorTopic);</span><span id="348b" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("Windowing delay in minutes for allowed lateness.")<br/>    <a class="ae ld" href="http://twitter.com/Default" rel="noopener ugc nofollow" target="_blank">@Default</a>.Long(60)<br/>    Long getAllowedWindowDelayInMins();<br/>    void setAllowedWindowDelayInMins(Long allowedWindowDelayInMins);</span><span id="238e" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("Window time in seconds. ")<br/>    <a class="ae ld" href="http://twitter.com/Default" rel="noopener ugc nofollow" target="_blank">@Default</a>.Long(10)<br/>    Long getWindowTimeInSeconds();<br/>    void setWindowTimeInSeconds(Long windowTimeInSeconds);</span><span id="628b" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("Max No. of elements in window")<br/>    <a class="ae ld" href="http://twitter.com/Default" rel="noopener ugc nofollow" target="_blank">@Default</a>.Integer(1000)<br/>    Integer getWindowElementsSizeLimit();<br/>    void setWindowElementsSizeLimit(Integer windowElementsSizeLimit);</span><span id="bb53" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Description" rel="noopener ugc nofollow" target="_blank">@Description</a>("Pub/Sub max batch size ")<br/>    <a class="ae ld" href="http://twitter.com/Default" rel="noopener ugc nofollow" target="_blank">@Default</a>.Integer(10)<br/>    Integer getPubSubMaxBatchSize();<br/>    void setPubSubMaxBatchSize(Integer pubSubMaxBatchSize);<br/>}</span></pre><ul class=""><li id="d67c" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><strong class="jw hi">创建输入输出的DTO</strong></li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2b66" class="ls ix hh lo b fi lt lu l lv lw"><a class="ae ld" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class InputDto implements Serializable { // Serializable is needed for PTransform<br/>    private static final long serialVersionUID = -33331355L;      </span><span id="2fd3" class="ls ix hh lo b fi ma lu l lv lw">@NotBlank(message="Should not be empty") @SpecialChar(message="Should not contain any special char")//Custom Validator<br/>private String firstname;</span><span id="313c" class="ls ix hh lo b fi ma lu l lv lw">@NotBlank(message="Should not be empty") @SpecialChar(message="Should not contain any special char")<br/>private String lastname;<br/>}</span><span id="17e1" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class OutputDto implements Serializable {<br/>    private static final long serialVersionUID = -13331355L;<br/>    private String id;<br/>    private String fullname;<br/>    private Integer length;<br/>    private ErrorDto errorDto; // report error<br/>}</span><span id="2989" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class ErrorDto implements Serializable {<br/>    private static final long serialVersionUID = -23331355L;<br/>    private List&lt;FieldError&gt; fields;<br/>    private String error;<br/>}</span><span id="5e2e" class="ls ix hh lo b fi ma lu l lv lw"><a class="ae ld" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class FieldError implements Serializable {<br/>    private static final long serialVersionUID = -23331355L;<br/>    private String field;<br/>    private String message;<br/>}</span></pre><ul class=""><li id="5795" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><strong class="jw hi">创建管道— </strong></li></ul><p id="1969" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">我们正在创建具有所需选项的管道。另外，我们需要<strong class="jw hi">注册编码员</strong>。原因是阿帕奇波束移动中的数据。它既可以保存在磁盘上，也可以在工作线程之间转移。编码器负责这两个操作，因为它解释了如何将数据写入磁盘或通过网络传输并转换回对象。每个p集合&lt; T &gt;操作都需要编码器。没有它，管道就不会执行，因为运行者不知道如何将Java对象转换成持久格式。</p><p id="0195" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">例如下面的InputDtoCoder用于<strong class="jw hi">序列化和反序列化</strong>输入的dto —</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9649" class="ls ix hh lo b fi lt lu l lv lw">import com.demo.dto.InputDto;<br/>import com.demo.util.JsonUtil;<br/>import org.apache.beam.sdk.coders.CoderException;<br/>import org.apache.beam.sdk.coders.CustomCoder;<br/>import org.apache.beam.sdk.util.StreamUtils;<br/><br/>import java.io.IOException;<br/>import java.io.InputStream;<br/>import java.io.OutputStream;<br/>import java.nio.charset.StandardCharsets;<br/><br/>public class InputDtoCoder extends CustomCoder&lt;InputDto&gt; {<br/>    private static final long <em class="lh">serialVersionUID </em>= -83328263L;<br/><br/>    @Override<br/>    public void encode(InputDto value, OutputStream outStream) throws IOException {<br/>        if (value == null) {<br/>            throw new CoderException("* cannot encode a null object of type InputDto");<br/>        }<br/>        String json = JsonUtil.<em class="lh">serialize</em>(value);<br/>        byte[] bytes = json.getBytes();<br/><br/>        outStream.write(bytes);<br/>    }<br/><br/>    @Override<br/>    public InputDto decode(InputStream inStream) throws IOException   {<br/>        byte[] bytes = StreamUtils.<em class="lh">getBytesWithoutClosing</em>(inStream);<br/>        String json = new String(bytes, StandardCharsets.<em class="lh">UTF_8</em>);<br/>        return JsonUtil.<em class="lh">deserialize</em>(json, InputDto.class);<br/>    }<br/>}</span></pre><p id="b6bc" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">类似地，你可以为输出创建DTO，有一些编码器已经存在于beam的lib中，比如publibsubmessagewithattributescoder。</p><p id="1a32" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在，为了使用这些代码，你需要通过代码注册来注册，比如</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8124" class="ls ix hh lo b fi lt lu l lv lw">CoderRegistry coderRegistry = pipeline.getCoderRegistry()</span><span id="8627" class="ls ix hh lo b fi ma lu l lv lw">coderRegistry.registerCoderForClass(PubsubMessage.class, PubsubMessageWithAttributesCoder.<em class="lh">of</em>());<br/>coderRegistry.registerCoderForClass(InputDto.class, new InputDtoCoder());<br/>coderRegistry.registerCoderForClass(OutputDto.class, new OutputDtoCoder());</span></pre><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/7dd3d462548b87ab21ba61361b946369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*462o0pozZnBXF4_QFkYC6g.png"/></div></div></figure><p id="aaad" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">在上述管道中，有两个名为NameTransformerFunction和NameTransformerPubSubFunction转换函数</p><ul class=""><li id="e31f" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><strong class="jw hi">名称转换功能</strong></li></ul><p id="85b9" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">它将用于从有效负载获取输入pubsub消息，然后将其序列化为InputDTO消息，再将其转换为OutputDTO消息</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/954e5958f9ffd7a7b6667e4685d12d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1YFbntdljq9RDkp_zAW0Q.png"/></div></div></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/5fc1335937e80bc03c14df1c96e3d37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwGw57H66g7-o-uy4Jd25g.png"/></div></div></figure><p id="20c3" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">我创建了一个Util类来创建输出和错误对象，如下所示</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e493" class="ls ix hh lo b fi lt lu l lv lw">public static OutputDto createOutputDto(String firstName, String lastName) {<br/>    String fullName = firstName.concat(" ").concat(lastName);<br/>    OutputDto outputDto = new OutputDto();<br/>    outputDto.setFullName(fullName);<br/>    outputDto.setId(UUID.<em class="lh">randomUUID</em>().toString());<br/>    outputDto.setLength(fullName.length());<br/>    return outputDto;<br/>}</span><span id="1601" class="ls ix hh lo b fi ma lu l lv lw">public static ErrorDto createError(String error) {<br/>    ErrorDto errorDto = new ErrorDto();<br/>    errorDto.setMessage(error);<br/>    return errorDto;<br/>}<br/><br/>public static ErrorDto createError(String error, List&lt;FieldError&gt; list) {<br/>    ErrorDto errorDto = new ErrorDto();<br/>    errorDto.setMessage(error);<br/>    <em class="lh">//Any field errors<br/>    </em>errorDto.setFields(list);<br/>    return errorDto;<br/>}</span></pre><ul class=""><li id="99bc" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><strong class="jw hi">命名TransformerPubsubFunction </strong></li></ul><p id="88ed" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">用于将OutpuDTO消息转换为pubsub消息，并基于元组标签对消息进行分叉，元组标签为<strong class="jw hi"> <em class="lh"> validNameTag </em> </strong>和<strong class="jw hi"> <em class="lh"> errorNameTag </em> </strong>。</p><p id="890a" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">如果您想要输出带有标记的消息，则必须在流程上下文的输出方法中指定标记名，如果您不指定标记，则消息将标记为默认标记。</p><p id="aa8b" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在问题来了，谁来决定默认标签？答案是，当我们创建了管道并指定了不带输出标签的<strong class="jw hi"><em class="lh">(valid name tag，tuple taglist . of(error name tag))</em></strong>，第一个参数被注册为默认值，这就是为什么我们在构造函数中只传递了<em class="lh"> errorNameTag </em>。</p><p id="a883" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">此外，请注意，我们将错误对象包装在OutputDto对象中，原因是我们只希望分支发生在管道的最后阶段。</p><p id="de0c" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">同样对于转换，我们使用了<strong class="jw hi"> <em class="lh"> Jackson </em> </strong> lib对象映射器来序列化和反序列化它。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/e80d8252b984a2d8702c137f6ea0befc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yu1FQij8rUzfE6Ay0ipmsw.png"/></div></div></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/796cadd453e66bb888d3aae5106c6cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sNnW4uBbUiSnNt3c2nlkA.png"/></div></div></figure><p id="0f03" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">两个函数类都扩展了名称函数。这是一个自定义创建的类，有一些消息转换方法和一些公共常量。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/7c180485092ce3bfd6881a03bee28c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWWp1JvuOn-EWV2_n51QEg.png"/></div></div></figure></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="7194" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">整合测试</h1><p id="4a0a" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">测试是任何技术的重要方面，apache beam通过使用其测试框架，为以集成方式测试管道提供了非常强大的支持。</p><blockquote class="mh mi mj"><p id="41f7" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated">这里我只关注使用apache beam测试框架编写集成测试。</p></blockquote><ol class=""><li id="02ea" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr mn la lb lc bi translated"><strong class="jw hi">准备测试数据</strong></li></ol><p id="c867" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">在目录下用您想要执行测试的数据创建一个JSON文件，例如<strong class="jw hi">src/test/resources/valid input data . JSON</strong></p><p id="56cb" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">创建一个实用程序类，并添加读取文件数据并将其转换为Pubsub消息类型的方法</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c480" class="ls ix hh lo b fi lt lu l lv lw">public PubsubMessage pubSubMessage(String fileName) throws IOException {<br/>    String json = Resources.<em class="lh">toString</em>(Resources.<em class="lh">getResource</em>(fileName), StandardCharsets.<em class="lh">UTF_8</em>);<br/>    InputDto inputDto;<br/>    PubsubMessage pubsubMessage;<br/><br/>    try {<br/>        inputDto = JsonUtil.<em class="lh">deserialize</em>(json, InputDto.class);<br/>        <em class="lh">LOGGER</em>.log(<em class="lh">LEVEL_INFO</em>, fileName + " File Data " + json + " inputDto "+ inputDto);<br/>        pubsubMessage = new PubsubMessage(json.getBytes(), new HashMap&lt;&gt;());<br/>    } catch (JsonProcessingException e) { <em class="lh">// when we have invalid JSON send data as it is in PubSubMessage<br/>        </em>pubsubMessage = new PubsubMessage(json.getBytes(), new HashMap&lt;&gt;());<br/>    }<br/>    return pubsubMessage;<br/> }</span></pre><p id="3694" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">2.<strong class="jw hi">定义测试管道</strong></p><p id="7ac1" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">创建一个名为nametransferpipelineintegrationtest的类，并使用@RunWith(JUnit4.class)进行注释，然后启动测试管道并定义测试，如下所示</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/dcc354045bab276657a043341e695148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fPIk56xhOIb6uO5yhZLjQ.png"/></div></div></figure><p id="bc4a" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">3.<strong class="jw hi">断言数据</strong></p><p id="fc74" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">为了断言数据，要么检查消息计数，要么用预期的数据验证输出负载。</p><p id="7a45" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">为了断言有效载荷，我在PubSubAssertUtil类中创建了<strong class="jw hi"> <em class="lh"> hasData() </em> </strong>方法。</p><p id="570c" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">如果你想断言一个属性，你只需要通过<strong class="jw hi"><em class="lh">msg . get attribute(" attr 1 ")</em></strong>方法获取该属性，其余逻辑相同。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/8088ac71c0412e09a4a2b7d114831c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wC8UwUA8bUkM16DJidwSzQ.png"/></div></div></figure></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="e53c" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">构建和部署</h1><p id="e6a9" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated"><strong class="jw hi">先决条件</strong></p><p id="a5c5" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">在将您的工作部署到GCP数据流之前，您首先需要如下设置您的帐户—</p><p id="5f5e" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">a.登录您的GCP帐户。<br/> b .创建一个存储，并在其中创建两个文件夹temp和stag <br/> c .创建3个主题，一个用于输入，另外两个用于输出<br/> d .创建您所在区域的子网<br/> e .创建一个具有以下权限的服务帐户</p><ul class=""><li id="591b" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><em class="lh">“角色/发布订阅者”</em></li><li id="4edb" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">“角色/发布订阅发布者”</em></li><li id="97fe" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">“角色/发布订阅查看器”</em></li><li id="4f58" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">“角色/存储.对象创建者”</em></li><li id="cce1" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">“角色/存储.对象查看器”</em></li><li id="2b87" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">"角色/数据流.管理"</em></li><li id="0468" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">" roles/iam . service account user "</em></li><li id="351f" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh">“角色/数据流.工人”</em></li></ul><p id="be1a" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">f.如这里提到的<a class="ae ld" href="https://cloud.google.com/docs/authentication/getting-started" rel="noopener ugc nofollow" target="_blank"/>在本地设置用于验证的Google应用程序凭证。</p><p id="1ed3" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">g.在本地安装<strong class="jw hi"> gcloud </strong>实用程序，并通过以下命令进行验证-</p><ul class=""><li id="1bc6" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated"><em class="lh"> gcloud认证登录</em></li><li id="c8b1" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated"><em class="lh"> gcloud认证应用-默认登录</em></li></ul><p id="0e82" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">为了部署您的管道，您有两个选择—</p><p id="1e8a" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">* <strong class="jw hi"> <em class="lh">注意</em> </strong> <em class="lh"> —我使用Gradle作为构建工具</em></p><ol class=""><li id="1b58" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr mn la lb lc bi translated"><strong class="jw hi">使用fat/uber Jar文件</strong></li></ol><p id="c692" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">为了部署管道，您首先需要创建一个fat jar。为了创建脂肪罐，我使用了Gradle的<strong class="jw hi"> <em class="lh"> shadowJar </em> </strong>插件，如果你使用Maven，那么使用<strong class="jw hi"> <em class="lh"> shade Jar </em> </strong>插件，并在这里引用文档<a class="ae ld" href="https://maven.apache.org/plugins/maven-shade-plugin/examples/includes-excludes.html" rel="noopener ugc nofollow" target="_blank"/></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8e2a" class="ls ix hh lo b fi lt lu l lv lw">plugins <strong class="lo hi">{<br/>    </strong>id 'com.github.johnrengelman.shadow' version '7.1.2'<br/>}</span><span id="7d36" class="ls ix hh lo b fi ma lu l lv lw">//</span><span id="35d6" class="ls ix hh lo b fi ma lu l lv lw">other code for dependencies.</span><span id="807d" class="ls ix hh lo b fi ma lu l lv lw">//</span><span id="0813" class="ls ix hh lo b fi ma lu l lv lw">shadowJar <strong class="lo hi">{<br/>    </strong>archiveBaseName.set('name-transformer-job')<br/>    archiveClassifier.set('')<br/>    archiveVersion.set('')<br/>    exclude 'META-INF/INDEX.LIST'<br/>    exclude 'META-INF/LICENSE'<br/>    exclude 'META-INF/*.RSA'<br/>    exclude 'META-INF/*.SF'<br/>    exclude 'META-INF/*.DSA'<br/>    mergeServiceFiles()<br/>    manifest <strong class="lo hi">{<br/>        </strong>attributes 'Main-Class': 'com.demo.dataflow.NameTransformerDataflowApplication'<br/>        attributes 'Description': 'Dataflow job for name transformer'<br/>    <strong class="lo hi">}<br/>}</strong></span></pre><p id="0258" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在，使用下面的命令创建一个构建<strong class="jw hi">"<em class="lh">gradle clean shadow jar "</em></strong></p><p id="0d5e" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">构建成功后，转到<strong class="jw hi"> libs &gt; build </strong>文件夹，您会发现生成的jar文件，文件名为<strong class="jw hi"> name-transformer.jar </strong>，现在运行下面的命令来部署您的管道。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9aee" class="ls ix hh lo b fi lt lu l lv lw">java -jar name-transformer.jar --runner=DataFlowRunner --project=&lt;project-name&gt; --gcpTempLocation=gs://dataflow-test-bkt/temp --stagingLocation=gs://dataflow-test-bkt/stag --inputSubscription=projects/&lt;project-name&gt;/subscriptions/input-topic-sub --outputTopic=projects/&lt;project-name&gt;/topics/output-topic --region=us-east1 --windowTimeInSeconds=120 --windowElementsSizeLimit=1000 --jobName=name-transformer-job --<a class="ae ld" href="mailto:serviceAccount=sns-siq-axis-adapter@exemplary-oven-338907.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">serviceAccount=name-transformer-service-account@</a>&lt;project-name&gt;<a class="ae ld" href="mailto:serviceAccount=sns-siq-axis-adapter@exemplary-oven-338907.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">.iam.gserviceaccount.com</a>  --defaultWorkerLogLevel=DEBUG --subnetwork=regions/us-east1/subnetworks/default --usePublicIps=false --outputErrorTopic=projects/&lt;project-name&gt;/topics/error-topic</span></pre><p id="d10f" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">执行上述命令后，转到GCP云控制台的数据流部分，您将看到一个名为name-transformer-job的新创建的作业。</p><p id="11f0" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">2.<strong class="jw hi">模板化方法</strong></p><p id="4dc9" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">在模板化方法中，我们首先需要创建一个模板，然后一旦创建了模板，我们就需要使用该模板来部署我们的工作。因此，为了创建一个模板，我们首先需要添加一个名为execute的新Gradle任务。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6eeb" class="ls ix hh lo b fi lt lu l lv lw">task execute (type:JavaExec) <strong class="lo hi">{</strong><br/>        main = System.<em class="lh">getProperty</em>("mainClass")<br/>        classpath = sourceSets.main.runtimeClasspath<br/>        systemProperties System.<em class="lh">getProperties</em>()<br/>        args System.<em class="lh">getProperty</em>("exec.args").split()<br/><strong class="lo hi">}</strong></span></pre><p id="d401" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">使用以下命令运行任务以生成模板</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bdad" class="ls ix hh lo b fi lt lu l lv lw">gradlew execute -DmainClass=com.demo.dataflow.NameTransformerDataflowApplication -Dexec.args="--runner=DataFlowRunner --project=&lt;project-name&gt; --gcpTempLocation=gs://dataflow-test-bkt/temp --stagingLocation=gs://dataflow-test-bkt/stag --inputSubscription=projects/&lt;project-name&gt;/subscriptions/input-topic-sub --outputTopic=projects/&lt;project-name&gt;/topics/output-topic --region=us-east1 --windowTimeInSeconds=120 --windowElementsSizeLimit=1000 --jobName=name-transformer-job --serviceAccount=name-transformer-service-account@&lt;project-name&gt;.iam.gserviceaccount.com  --defaultWorkerLogLevel=DEBUG --subnetwork=regions/us-east1/subnetworks/default --usePublicIps=false --outputErrorTopic=projects/&lt;project-name&gt;/topics/error-topic --templateLocation=gs://dataflow-test-bkt/name-transformer-job.template"</span></pre><p id="a829" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">你可以看到我已经添加了一个名为<strong class="jw hi"> templateLocation </strong>的新参数，并为其分配了带有存储桶位置的模板名称。现在，一旦您执行了上面的命令，名为<strong class="jw hi"><em class="lh">name-transformer-job . template</em></strong>文件的模板就已经在您的bucket中创建好了。</p><p id="a9f8" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">现在，为了部署创建的模板，使用以下命令—</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bb59" class="ls ix hh lo b fi lt lu l lv lw">gcloud beta dataflow jobs run name-transformer-job --project=&lt;project-name&gt; --region=us-east1 --staging-location=gs://dataflow-test-bkt/stag --service-account-email=name-transformer-service-account@&lt;project-name&gt;.iam.gserviceaccount.com --gcs-location=gs://dataflow-test-bkt/name-transformer-job.template</span></pre><p id="d615" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">执行上述命令后，转到GCP云控制台的数据流部分，您将看到一个名为<strong class="jw hi"> name-transformer-job </strong>的新创建的作业。</p><blockquote class="mh mi mj"><p id="2a0b" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated">如果您想为您的工作创建CICD管道，模板化方法是最合适的。</p></blockquote><p id="381c" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated"><strong class="jw hi">数据流作业的图形视图</strong></p><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/bf298666229a679460bc5fd0f0e39534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*j30FDueDqESpdD3TQOB0cQ.png"/></div></figure></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="2eaf" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">处理大量数据</h1><p id="9cc5" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">如您所知，数据流主要用于需要处理大量数据的<strong class="jw hi">大数据</strong>用例，主要是<a class="ae ld" href="https://memgraph.com/blog/batch-processing-vs-stream-processing" rel="noopener ugc nofollow" target="_blank"> <strong class="jw hi">批处理(有界数据)或流(无界数据)</strong> </a>。现在，让我们了解数据流如何处理大量数据，以及我们需要在beams管道中做什么配置才能充分利用它。</p><p id="1a19" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">答案很简单，数据流是无服务器的，它可以根据处理负载在多个工作节点之间分配工作。它会根据负载自动旋转新节点，但是如果您想要控制工作节点和其他配置，那么在apache beam中有大量选项可供配置。</p><ul class=""><li id="3132" class="ks kt hh jw b jx ku kb kv kf kw kj kx kn ky kr kz la lb lc bi translated">在DataflowPipelineWorkerPoolOptions中，有一个名为<strong class="jw hi"> setMaxNumWorkers </strong>的选项来设置最大工作节点</li><li id="3382" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated">如果要将自动缩放算法AutoscalingAlgorithmType更改为<strong class="jw hi">基本或<em class="lh">基于吞吐量的</em> </strong></li><li id="bb10" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated">如果你想改变优化，那么<strong class="jw hi">设置FlexRSGoal </strong>为<strong class="jw hi"> <em class="lh">速度优化或成本优化</em> </strong></li><li id="94d3" class="ks kt hh jw b jx mq kb mr kf ms kj mt kn mu kr kz la lb lc bi translated">对于流式操作，您可以根据您的使用情况更改<a class="ae ld" href="https://colab.research.google.com/github/apache/beam/blob/master/examples/notebooks/tour-of-beam/windowing.ipynb#scrollTo=5UC_aGanx6oE https://www.waitingforcode.com/apache-beam/coders-apache-beam/read" rel="noopener ugc nofollow" target="_blank"> <strong class="jw hi">窗口策略</strong> </a>。</li></ul></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="5da0" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">结论</h1><p id="4522" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">这就是我们如何使用元组标签在管道中进行分支，并通过Apache Beam和GCP数据流部署生产就绪的管道。我们还看到了如何使用apache beam测试框架编写集成测试用例。</p><p id="2ed8" class="pw-post-body-paragraph ju jv hh jw b jx ku jz ka kb kv kd ke kf le kh ki kj lf kl km kn lg kp kq kr ha bi translated">希望你喜欢这篇报道。如果你有任何问题/意见，请给我留言！</p></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><h1 id="144c" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">参考</h1><blockquote class="mh mi mj"><p id="6b46" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><strong class="jw hi">阿帕奇光束</strong></p><p id="1501" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><a class="ae ld" href="https://beam.apache.org/get-started/beam-overview/" rel="noopener ugc nofollow" target="_blank">https://beam.apache.org/get-started/beam-overview/</a></p><p id="ee08" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=HKPpohFFDoY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=HKPpohFFDoY</a></p><p id="29e1" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><a class="ae ld" href="https://www.waitingforcode.com/apache-beam/coders-apache-beam/read" rel="noopener ugc nofollow" target="_blank">https://www . waiting for code . com/Apache-beam/coders-Apache-beam/read</a></p><p id="e3a6" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><a class="ae ld" href="https://colab.research.google.com/github/apache/beam/blob/master/examples/notebooks/tour-of-beam/windowing.ipynb#scrollTo=5UC_aGanx6oE" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/github/Apache/beam/blob/master/examples/notebooks/tour-of-beam/windowing . ipynb # scroll to = 5UC _ aganx 6 OE</a><br/>T3】https://www . waiting for code . com/Apache-beam/coders-Apache-beam/read</p><p id="1768" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><a class="ae ld" href="https://beam.apache.org/releases/javadoc/2.0.0/org/apache/beam/sdk/values/TupleTag.html" rel="noopener ugc nofollow" target="_blank">https://beam . Apache . org/releases/javadoc/2 . 0 . 0/org/Apache/beam/SDK/values/tuple tag . html</a></p><p id="3715" class="ju jv lh jw b jx ku jz ka kb kv kd ke mk le kh ki ml lf kl km mm lg kp kq kr ha bi translated"><strong class="jw hi">数据流</strong><br/><a class="ae ld" href="https://cloud.google.com/sdk/gcloud/reference/dataflow/jobs" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/sdk/gcloud/reference/dataflow/jobs</a></p></blockquote></div></div>    
</body>
</html>