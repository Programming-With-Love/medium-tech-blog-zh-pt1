<html>
<head>
<title>Top Node.js Interview Questions You Must Prepare For 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Top Node.js你必须准备的面试问题</h1>
<blockquote>原文：<a href="https://medium.com/edureka/node-js-interview-questions-cbfb78f2714f?source=collection_archive---------4-----------------------#2019-08-14">https://medium.com/edureka/node-js-interview-questions-cbfb78f2714f?source=collection_archive---------4-----------------------#2019-08-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/892e9d195d271e987252584968bcf5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7ltlG7cAknLytss60k935A.png"/></div><figcaption class="il im et er es in io bd b be z dx">Node.js Interview Questions — Edureka</figcaption></figure><p id="0a5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">服务器端脚本工具Node.js使用JavaScript——一种受全球数百万开发人员欢迎的语言——确保它的学习曲线低得多，即使对于完全的初学者也是如此。使用Node.js，可以轻松构建任何东西，从简单的命令行程序到复杂的企业级web应用程序。这就是为什么大多数行业需要一个经过认证的Node.js开发人员来管理整个服务器端。Node.js也带来了不同层次的就业机会。如果你打算在不久的将来参加Node.js面试，我们在这里帮助你列出2019年你必须准备的50个Node.js面试问题。</p><p id="3dab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇Node.js面试问题文章中，我根据问题的难度将问题分为3个部分:</p><ul class=""><li id="a9e2" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Node.js面试问题—初学者水平</li><li id="bb93" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Node.js面试问题—中等水平</li><li id="2a8b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Node.js面试问题—高级水平</li></ul><p id="4b25" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我开始这篇Node.js面试问题的文章之前，让我向最近可能参加过Node.js面试的读者提出一个请求。所以，如果你遇到了在采访中被问到但在这篇文章中没有的问题，请在下面的评论区提出这些问题。我们将努力尽早回答这些问题，以便其他人也能从中受益。</p><p id="dded" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们开始吧。</p><h1 id="e523" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Node.js面试问题—初学者水平</h1><h2 id="49bf" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">1.区分JavaScript和Node.js。</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es ln"><img src="../Images/19d9cbb95351e731c565b133036560d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU-UrH8G5-TiAXKh_wiodg.png"/></div></div></figure><p id="c846" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Node.js是在Chrome的V8 JavaScript引擎上开发的强大框架，它将JavaScript直接编译成本机代码。它是一个轻量级框架，用于创建服务器端web应用程序，并扩展JavaScript API以提供常见的服务器端功能。它通常用于大型应用程序开发，尤其是视频流网站、单页面应用程序和其他web应用程序。</p><h2 id="ac5a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">2.Node.js是什么？</h2><p id="786a" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js是在<strong class="ir hi"> Chrome的V8 JavaScript引擎</strong>上开发的强大框架，它将JavaScript直接编译成本机代码。它是一个轻量级框架，用于创建服务器端web应用程序，并扩展JavaScript API以提供常见的服务器端功能。它通常用于大型应用程序开发，尤其是视频流网站、单页面应用程序和其他web应用程序。</p><h2 id="0577" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">3.列出使用Node.js的主要好处？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mb"><img src="../Images/bf8160b6403659d607c20c43438233a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfBl_frZOMQ4m_hv0pMqog.png"/></div></div></figure><h2 id="a868" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">4.Angular和Node.js有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mb"><img src="../Images/1b30fe621af9892accdb8affd097704b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zvK_FM-rq7bvOQoL4MSFA.png"/></div></div></figure><h2 id="286c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">5.为什么Node.js是单线程的？</h2><p id="8764" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js使用单线程模型来支持异步处理。使用异步处理，应用程序可以在web负载下执行得更好，可伸缩性更强。因此，Node.js使用单线程模型方法，而不是典型的基于线程的实现。</p><h2 id="9696" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">6.Node.js是如何工作的？</h2><p id="e6a5" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js是一个虚拟机，它使用JavaScript作为脚本语言，运行在v8环境中。它在单线程事件循环和非阻塞I/O上工作，提供高速率，因为它可以处理更多的并发请求。此外，通过使用“HTTP”模块，Node.js可以在任何独立的web服务器上运行。</p><h2 id="7613" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">7.Node.js可以用在哪里？</h2><p id="586f" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js可用于开发:</p><ul class=""><li id="cebd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">实时网络应用</li><li id="3cfb" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">网络应用</li><li id="a27b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">分布式系统</li><li id="f2de" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">通用应用</li></ul><h2 id="a3a7" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">8.Node.js中有多少种类型的API函数？</h2><p id="d6c6" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中有两种类型的API函数:</p><ul class=""><li id="8c9b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">异步、非阻塞函数</li><li id="2337" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">同步、阻塞功能</li></ul><h2 id="b5bf" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">9.异步和非阻塞的区别是什么？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mb"><img src="../Images/6ba6f2412ce730a4f3ad53df8da75075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvNG_2kmctRNXPGFjrmewg.png"/></div></div></figure><h2 id="4cc3" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">10.package.json是什么？</h2><p id="207a" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的<strong class="ir hi"> package.json文件</strong>是整个应用程序的核心。它基本上是包含项目元数据的清单文件，我们在其中定义包的属性。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/62c9b579323cb4ad67e8a923bc1bb1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E457ycW6tVswuCWaJKbrjw.png"/></div></div></figure><h2 id="fd01" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">11.你所理解的事件驱动编程是什么？</h2><p id="1b80" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">事件驱动编程是一种大量利用事件来触发各种功能的编程方法。事件可以是鼠标点击、按键等等。当事件发生时，会执行一个已经注册到元素的回调函数。这种方法主要遵循发布-订阅模式。由于事件驱动编程，Node.js比其他技术更快。</p><h2 id="5de7" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">12.Node.js中的事件循环是什么，它是如何工作的？</h2><p id="7101" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的事件循环处理应用程序中的所有异步回调。这是Node.js最重要的方面之一，也是Node.js拥有非阻塞I/O的原因。由于Node.js是一种事件驱动的语言，您可以轻松地将侦听器附加到事件，然后当事件发生时，回调将由特定的侦听器执行。每当调用setTimeout、http.get和fs.readFile等函数时，Node.js都会执行事件循环，然后继续执行下一个代码，而不等待输出。整个操作完成后，Node.js接收输出，然后执行回调函数。这就是为什么所有的回调函数都放在一个循环的队列中。一旦收到响应，它们就会被逐一执行。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es md"><img src="../Images/c66ccebeca45b25791fa9f7d9811ef31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4_Hm5AuF7S-UbtyVdDjPQ.png"/></div></div></figure><h2 id="729a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">13.在Node.js的上下文中解释REPL</h2><p id="4cd8" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的REPL代表<strong class="ir hi"> R </strong> ead、<strong class="ir hi"> E </strong> val、<strong class="ir hi"> P </strong> rint、<strong class="ir hi"> L </strong> oop。它代表一个计算机环境，如窗口控制台或Unix/Linux shell，在这里可以输入任何命令，然后系统可以输出响应。默认情况下，Node.js与REPL环境捆绑在一起。REPL可以执行下列任务:</p><ul class=""><li id="ec15" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi"> Read: </strong>读取用户的输入，将其解析成JavaScript数据结构，然后存储在内存中。</li><li id="4810" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> Eval: </strong>接收并评估数据结构。</li><li id="cddc" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">打印:</strong>打印最终结果。</li><li id="661d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">循环:</strong>循环提供的命令，直到<em class="me"> CTRL+C </em>被按下两次。</li></ul><h2 id="ca45" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">14.列出应该使用事件循环异步完成的任务？</h2><p id="3a6d" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">下面是必须使用事件循环异步完成的任务列表:</p><ul class=""><li id="cf50" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">输入输出操作</li><li id="d2e4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">繁重的计算</li><li id="6d1e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">任何需要封锁的东西</li></ul><h2 id="1c38" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">15.列出Node.js中使用哪个“控制流”控制函数调用的步骤？</h2><ol class=""><li id="f6fe" class="jn jo hh ir b is lw iw lx ja mf je mg ji mh jm mi jt ju jv bi translated">控制执行顺序</li><li id="3792" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">收集数据</li><li id="1639" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">限制并发</li><li id="e894" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">调用程序中的下一步</li></ol><h1 id="36db" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Node.js面试问题—中等水平</h1><h2 id="0e94" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">16.你对测试金字塔的理解是什么？</h2><p id="e6a1" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">测试金字塔基本上是一个图表，它描述了为了项目的成功开发需要编写多少单元测试、集成测试和端到端测试的比率。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/2e906a966eb2e7719960837cf4e7f7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*YKDSS3v49w5VAQ9B7YUg4g.png"/></div></figure><h2 id="e54d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">17.Node.js中的错误优先回调是什么？</h2><p id="d18a" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的错误优先回调用于传递错误和数据。您需要传递给这些函数的第一个参数必须是一个错误对象，而其他参数代表相关数据。因此，您可以传递错误对象来检查是否有任何错误并处理它。如果没有问题，你可以继续进行随后的争论。</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="d81d" class="kz kc hh ml b fi mp mq l mr ms">var myPost = new Post({title: 'edureka'});<br/>myPost.save(function(err,myInstance){<br/>if(err){<br/>//handle error and return<br/>}<br/>//go ahead with `myInstance`<br/>});</span></pre><h2 id="085b" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">18.解释module.exports的用途？</h2><p id="2180" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的一个模块用于将所有相关的代码封装到一个单独的代码单元中，通过将所有相关的函数转移到一个单独的文件中，可以对该代码单元进行解释。例如，假设您有一个名为greet.js的文件，其中包含如下所示的两个函数:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="9883" class="kz kc hh ml b fi mp mq l mr ms">module.exports = {<br/>greetInHindi: function(){<br/>return "NAMASTE";<br/>},<br/>greetInKorean: function(){<br/>return "ANNYEONGHASEYO";<br/>}};</span></pre><p id="4161" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，module.exports提供了两个函数，可以使用下面的代码将它们导入到另一个文件中:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="56c6" class="kz kc hh ml b fi mp mq l mr ms">var eduGreets = require ("./greet.js");<br/>eduGreets.greetInHindi() //NAMASTE<br/>eduGreets.greetInKorean() //ANNYEONGHASEYO</span></pre><h2 id="1b5a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">19.Node.js中的Reactor Pattern你是怎么理解的？</h2><p id="5964" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated"><strong class="ir hi">node . js中的反应器模式</strong>基本上是一个非阻塞I/O操作的概念。这种模式提供了一个与每个I/O操作相关联的处理程序，一旦产生了I/O请求，它就会被提交给一个<em class="me">解复用器</em>。这个解复用器是一个通知接口，它能够以非阻塞I/O模式处理并发性。它还有助于以事件的形式收集每个请求，然后将每个事件放入队列中。从而导致事件队列的生成。同时，我们有我们的事件循环，它迭代事件队列中的事件。</p><h2 id="9e34" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">20.“前端”和“后端”开发有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mb"><img src="../Images/0835f667832a191ff164ffed22eaa33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPOJkvvxLZxLlRDRMhPw1A.png"/></div></div></figure><h2 id="606b" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">21.Node.js的LTS版本是什么？</h2><p id="49f8" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated"><strong class="ir hi"> LTS </strong>看台<strong class="ir hi">L</strong>ONG<strong class="ir hi">T</strong>erm<strong class="ir hi">S</strong>node . js的支持版本，接收所有关键的错误修复以及安全更新和性能改进。这些版本至少支持18个月，主要关注稳定性和安全性。对LTS版本的修改仅限于错误修复、安全升级、npm和文档更新、性能改进等。</p><h2 id="1a31" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">22.列出Node.js中主要的安全实现？</h2><p id="059b" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的主要安全实现有:</p><ol class=""><li id="77c8" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mi jt ju jv bi translated">认证</li><li id="5781" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">错误处理</li></ol><h2 id="0a0f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">23.你所理解的回调地狱是什么？</h2><p id="3028" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">回调地狱也被称为末日金字塔。这是一种由密集嵌套的回调导致的模式，不可读且难以处理。它通常包含多个嵌套的回调函数，这反过来使得代码难以阅读和调试。这是由异步逻辑的不正确实现引起的。</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="f641" class="kz kc hh ml b fi mp mq l mr ms">async_A(function(){<br/>async_B(function(){<br/>async_C(function(){<br/>async_D(function(){<br/>....<br/>});<br/>});<br/>});<br/>});</span></pre><h2 id="e047" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">24.解释一下libuv。</h2><p id="dab8" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Libuv是Node.js的一个多平台支持库，主要用于异步I/O。它最初是为Node.js开发的，随着时间的推移，它已广泛应用于其他系统，如Luvit、pyuv、Julia等。Libuv基本上是基于平台的围绕libev/ IOCP的抽象，为用户提供基于libev的API。libuv的一些重要特性是:</p><ul class=""><li id="6def" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">全功能事件循环支持</li><li id="1411" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">文件系统事件</li><li id="8884" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">异步文件和文件系统操作</li><li id="bf3f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">异步TCP和UDP套接字</li><li id="a027" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">子进程</li></ul><h2 id="65bf" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">25.解释Node.js中中间件的概念？</h2><p id="7d5d" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">一般来说，中间件是一个接收请求和响应对象的功能。换句话说，在应用程序的请求-响应周期中，这些函数可以访问各种请求和响应对象以及周期的下一个函数。中间件的下一个功能是借助一个变量来表示的，这个变量通常叫做next。中间件功能最常执行的任务是:</p><ul class=""><li id="a3ef" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">执行任何类型的代码</li><li id="5017" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">更新或修改请求和响应对象</li><li id="a8ba" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">完成请求-响应循环</li><li id="0510" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">调用堆栈中的下一个中间件</li></ul><h2 id="2630" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">26.解释URL模块的概念。</h2><p id="dcb1" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js的<strong class="ir hi"> URL模块</strong>为<strong class="ir hi"> URL </strong>解析和解析提供了各种实用工具。它是一个内置模块，有助于将网址拆分成可读格式:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="7d2b" class="kz kc hh ml b fi mp mq l mr ms">var url = require('url');</span></pre><p id="c37c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例如:</strong></p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="feb2" class="kz kc hh ml b fi mp mq l mr ms">var url = require('url');<br/>var adrs = '<a class="ae mt" href="http://localhost:8082/default.htm?year=2019&amp;month=april'" rel="noopener ugc nofollow" target="_blank">http://localhost:8082/default.htm?year=2019&amp;month=april'</a>;<br/>var q = url.parse(adr, true);<br/>console.log(q.host); //returns 'localhost:8082'<br/>console.log(q.pathname); //returns '/default.htm'<br/>console.log(q.search); //returns '?year=2019 and month=april'<br/>var qdata = q.query; //returns an object: { year: 2019, month: 'april' }<br/>console.log(qdata.month); //returns 'april'</span></pre><h2 id="5fb3" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">27.你对ESLint的理解是什么？</h2><p id="19e5" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">ESLint是一个开源项目，最初由Nicholas C. Zakas在2013年开发，旨在通过一个插件为JavaScript提供一个林挺实用程序。Node.js中的Linters是搜索某些bug类的好工具，尤其是那些与变量作用域相关的bug类。</p><h2 id="35ed" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">28.对于Node.js，Google为什么要用V8引擎？</h2><p id="6646" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">谷歌使用V8，因为它是一个Chrome运行时引擎，可以将JavaScript代码转换为本机代码。这反过来加快了应用程序的执行和响应过程，并为您提供了一个快速运行的应用程序。</p><h2 id="84f9" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">29.解释控制流函数的工作原理。</h2><p id="1984" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，控制流函数基本上是在异步函数调用之间执行的代码。下面是执行它必须遵循的步骤:</p><ol class=""><li id="f4af" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mi jt ju jv bi translated">首先，必须控制执行的顺序。</li><li id="5047" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">然后，需要收集所需的数据。</li><li id="d991" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">接下来，必须限制并发性。</li><li id="e8eb" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">一旦完成，就必须调用程序的下一步。</li></ol><h2 id="06ed" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">30.列出async.queue作为输入的两个参数？</h2><p id="9d22" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">下面是async.queue作为输入的两个参数:</p><ol class=""><li id="07b4" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mi jt ju jv bi translated">任务功能</li><li id="6962" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated">并发值</li></ol><h2 id="891d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">31.Node.js中spawn()和fork()方法的区别？</h2><p id="99fa" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，spawn()用于通过提供的命令集启动一个新进程。该方法不会创建新的V8实例，只有一个节点模块副本在处理器上是活动的。当您的子流程向节点返回大量数据时，您可以调用此方法。</p><p id="a97c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="4c47" class="kz kc hh ml b fi mp mq l mr ms">child_process.spawn(command[, args][, options])</span></pre><p id="938a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而Node.js中的fork()是spawn()的一个特殊实例，它执行V8引擎的一个新实例。这种方法仅仅意味着多个工作者在单个节点代码库上运行各种任务。</p><p id="8c3e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="56dc" class="kz kc hh ml b fi mp mq l mr ms">child_process.fork(modulePath[, args][, options])</span></pre><h2 id="8dd1" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">32.Node.js中的全局对象你是怎么理解的？</h2><p id="adb3" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，Globals是本质上是全局的对象，在应用程序的所有模块中都可用。您可以在应用程序中直接使用这些对象，而不必显式包含它们。全局对象可以是模块、函数、字符串、对象等。此外，其中一些对象可以在模块范围内，而不是在全局范围内。</p><h2 id="833f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">33.解释Node.js中存根的概念。</h2><p id="edca" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，存根基本上是用于模拟模块或组件行为的程序或函数。在任何测试用例中，存根提供函数的固定答案。</p><h2 id="3609" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">34.assert在Node.js中是如何工作的？</h2><p id="e43a" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，assert用于编写测试。它只在任何运行的测试用例失败时提供反馈。这个模块给你一组断言测试，然后用来测试不变量。它基本上由Node.js内部使用，但是使用require('assert ')代码，它也可以用于其他应用程序。</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="9f07" class="kz kc hh ml b fi mp mq l mr ms">var assert = require('assert');<br/>function mul(a, b) {<br/>return a * b;<br/>}<br/>var result = mul(1,2);<br/>assert( result === 2, 'one multiplied by two is two');</span></pre><h2 id="66ca" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">35.定义测试金字塔的概念。根据HTTP APIs解释实现它们的过程。</h2><p id="fe7c" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">测试<strong class="ir hi">金字塔</strong>基本上是一个由迈克·科恩开发的概念。据此，与通过GUI运行的高级端到端<strong class="ir hi">测试</strong>相比，你应该有更多的低级单元<strong class="ir hi">测试</strong>。</p><p id="2c7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就HTTP APIs而言，它可以定义为:</p><ul class=""><li id="1a4d" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">每个模型有更多的低级单元测试</li><li id="8fb4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">测试模型交互的较少集成测试</li><li id="6032" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">用于测试实际HTTP端点的较少的验收测试</li></ul><h2 id="ca7d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">36.解释ExpressJS包的用途？</h2><p id="26f4" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Express.js是一个构建在Node.js之上的框架，有助于管理服务器和服务器端应用程序中的路由之间的数据流。它是一个轻量级的灵活框架，提供了web和移动应用程序开发所需的广泛特性。Express.js是在名为Node.js的中间件模块上开发的。connect模块进一步利用一个<strong class="ir hi"> http </strong>模块与Node.js通信。因此，如果您正在使用任何基于connect的中间件模块，那么您可以很容易地与Express.js集成。</p><h2 id="6692" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">37.区分process.nextTick()和setImmediate()？</h2><p id="6ff4" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，process.nextTick()和setImmediate()都是计时器模块的函数，帮助在预定义的一段时间后执行代码。但是这些功能在执行时有所不同。process.nextTick函数等待动作的执行，直到事件循环中的下一次循环，或者一旦事件循环完成，它将调用回调函数。另一方面，setImmediate()用于在事件循环的下一个周期执行回调方法，该方法最终将其返回到事件循环，以便执行I/O操作。</p><h2 id="dffa" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">38.解释一下Node.js中缓冲类的用法？</h2><p id="7a4c" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的Buffer类用于以类似于整数数组的方式存储原始数据。但是它对应于位于V8堆之外的原始内存分配。它是一个易于访问的全局类，可以在应用程序中访问，而无需导入缓冲模块。使用Buffer类是因为纯JavaScript与二进制数据不兼容。因此，当处理TCP流或文件系统时，有必要处理八进制流。</p><h2 id="9a1f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">39.Node.js如何处理子线程？</h2><p id="c6ab" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">一般来说，Node.js是一个单线程进程，不公开子线程或线程管理方法。但是您仍然可以使用spawn()将子线程用于一些特定的异步I/O任务，这些任务在后台执行，通常不执行任何JS代码，也不会妨碍应用程序中的主事件循环。如果您仍然想在应用程序中使用线程概念，您必须显式包含一个名为ChildProcess的模块。</p><h2 id="05c6" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">40.解释Node.js中的stream及其各种类型。</h2><p id="9104" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js中的流是类似于数组和字符串的数据集合。使用这些对象，您可以连续地从源读取数据或向目标写入数据。它可能不会立即可用，也不需要存储在内存中。这些流对于读取和处理大量数据特别有用。在Node.js中，有四种基本类型的流:</p><ol class=""><li id="d18e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mi jt ju jv bi translated"><em class="me">可读:</em>用于从数据源读取大块数据。</li><li id="a8d0" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated"><em class="me">可写:</em>用于将大块数据写入目标。</li><li id="a76b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated"><em class="me">双工:</em>用于两种功能；读和写。</li><li id="8842" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mi jt ju jv bi translated"><em class="me">转换:</em>是一个双工流，用于修改数据。</li></ol><h1 id="9d9f" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Node.js面试问题—高级水平</h1><h2 id="4e35" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">41.NODE_ENV有什么用？</h2><p id="904f" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">如果项目处于生产阶段，Node.js会推广使用NODE_ENV变量来标记它的约定。这有助于在项目开发过程中做出更好的判断。此外，当您将NODE_ENV设置为生产时，您的应用程序的执行速度往往会提高3倍。</p><h2 id="079e" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">42.Node.js中readFile与createReadStream的区别？</h2><p id="7165" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js提供了两种读取和执行文件的方法，分别是使用readFile和CreateStream。readFile()是一个完全缓冲的进程，只有当整个文件被推入缓冲区并被读取时，它才返回响应。这是一个占用大量内存的过程，如果文件很大，处理速度会非常慢。而createReadStream是部分缓冲的，它将整个过程视为一个事件序列。整个文件被分割成块，然后处理这些块并作为响应一个接一个地发送回去。一旦完成，它们最终会从缓冲区中移除。与readFile不同，createReadStream对于处理大文件非常有效。</p><h2 id="8b8d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">43.列出Node.js的各种计时特性。</h2><p id="0b2d" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js提供了一个Timers模块，其中包含了在指定的时间段后执行代码的各种函数。下面我列出了该模块提供的各种功能:</p><ul class=""><li id="e21b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">setTimeout/clear time out</strong>—用于在指定的毫秒数后调度代码执行</li><li id="a30b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">setInterval/clearInterval</strong>—用于多次执行一个代码块</li><li id="c43c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">set immediate/clear immediate</strong>—用于在当前事件循环周期结束时执行代码</li><li id="518e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> process.nextTick </strong> —用于调度需要在事件循环的下一次迭代中调用的回调函数</li></ul><h2 id="dd93" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">44.解释Node.js中Punycode的概念？</h2><p id="4c6a" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，Punycode是一种编码语法，用于将Unicode (UTF-8)字符串转换为基本的ASCII字符串。这很重要，因为主机名只能理解ASCII字符。因此，Node.js版本0.6.2以后，它与默认的节点包捆绑在一起。如果您想在以前的版本中使用它，您可以通过使用下面的代码轻松地做到这一点。</p><p id="3a3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="956b" class="kz kc hh ml b fi mp mq l mr ms">punycode = require('punycode');</span></pre><h2 id="5116" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">45.Node.js和Ajax的区别？</h2><p id="2e26" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js和Ajax最基本的区别在于，Node.js是服务器端JavaScript，而Ajax是客户端技术。简单来说，Ajax主要用于更新或修改网页内容，而无需刷新网页。另一方面，Node.js需要开发通常由服务器而不是web浏览器执行的服务器软件。</p><h2 id="37da" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">46.Node.js提供任何调试器吗？</h2><p id="0f7f" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">Node.js提供了一个简单的基于TCP的协议和内置的调试客户端。为了调试您的JavaScript文件，您可以使用下面的debug参数，后跟您想要调试的<strong class="ir hi"> js </strong>文件名。</p><p id="423f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="ecbc" class="kz kc hh ml b fi mp mq l mr ms">node debug [script.js | -e "script"<!-- --> <!-- -->| &lt;host&gt; : &lt;port&gt; ]</span></pre><h2 id="16fc" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">47.描述Node.js的退出代码。</h2><p id="b46d" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在Node.js中，退出代码是一组用于完成特定流程的特定代码。这些过程也可以包括全局对象。下面是Node.js中使用的一些退出代码:</p><ul class=""><li id="b0ed" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">未捕获的致命异常</li><li id="2636" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">不用的</li><li id="157b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">致命错误</li><li id="1332" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">内部异常处理程序运行时失败</li><li id="b4a6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">内部JavaScript评估失败</li></ul><h2 id="1070" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">48.你所理解的Node.js中的一个事件发射器是什么？</h2><p id="5f5c" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">EventEmitter是一个Node.js类，它包含所有能够发出事件的对象。这些对象包含一个eventEmitter.on()函数，通过该函数可以将多个函数附加到由对象发出的命名事件。每当EventEmitter对象抛出一个事件时，该特定事件的所有附属函数都会被同步调用。以下代码显示了如何在您的应用程序中使用EventEmitter:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="57ce" class="kz kc hh ml b fi mp mq l mr ms">const EventEmitter = require('events');<br/>class MyEmitter extends EventEmitter { }<br/>const myEmitter = new MyEmitter();<br/>myEmitter.on('event', () =&gt; {<br/>console.log('an event occurred!');<br/>});<br/>myEmitter.emit('event');</span></pre><h2 id="98a5" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">49.Node.js支持加密吗？</h2><p id="cdd9" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">是的，Node.js通过一个名为Crypto的模块支持加密技术。该模块提供了各种加密功能，如加密、解密、签名和验证功能，以及一组用于开放SSL散列HMAC的包装器等。例如:</p><p id="076f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="702c" class="kz kc hh ml b fi mp mq l mr ms">const crypto = require'crypto');<br/>const secret = 'akerude';<br/>const hash = crypto.createHmac('swaEdu', secret).update('Welcome to Edureka').digest('hex');<br/>console.log(hash);</span></pre><h2 id="0fcf" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">50.解释为什么Express的“应用程序”和“服务器”必须分开。</h2><p id="1dd4" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">express“app”和“server”必须分开，因为这样做可以将API声明与网络相关的配置分开，这在以下方面有好处:</p><ul class=""><li id="558b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">它允许在进程中测试API，而不必执行网络调用</li><li id="96d4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">更快的测试执行</li><li id="d2bb" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">获得更广泛的代码覆盖度量</li><li id="489a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">允许在灵活和不同的网络条件下部署相同的API</li><li id="6067" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">更好的关注点分离和更干净的代码</li></ul><p id="484f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">API声明应该位于app.js中:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="37c4" class="kz kc hh ml b fi mp mq l mr ms">var app = express();<br/>app.use(bodyParser.json());<br/>app.use("/api/events", events.API);<br/>app.use("/api/forms", forms);</span></pre><p id="1ccf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">服务器网络声明应该位于/bin/www:</p><pre class="lo lp lq lr fd mk ml mm mn aw mo bi"><span id="a64a" class="kz kc hh ml b fi mp mq l mr ms">var app = require('../app');<br/>var http = require('http');<br/>//Get port from environment and store in Express<br/>var port = normalizePort(process.env.PORT || '8000');<br/>app.set('port', port);<br/>//Create HTTP server.<br/>var server = http.createServer(app);</span></pre><p id="db04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到此，我们来结束这篇文章。我希望你发现它的信息量大，有助于增加你的知识。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考<a class="ae mt" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=top-node-js-interview-questions-2016" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="b1d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Node.js的各个方面</p><blockquote class="mu mv mw"><p id="de6a" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 1。</em> <a class="ae mt" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> <em class="hh"> NodeJS教程</em> </a></p><p id="4f28" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 2。</em> <a class="ae mt" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762"> <em class="hh">使用Node.js和MySQL </em> </a>构建CRUD应用程序</p><p id="da00" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 3。</em> <a class="ae mt" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c"> <em class="hh">使用节点构建CRUD应用程序。JS和MongoDB </em> </a></p><p id="05e7" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 4。</em> <a class="ae mt" rel="noopener" href="/edureka/node-js-requests-6b94862307a2"> <em class="hh">最佳3种方式让Node.js请求</em> </a></p><p id="f314" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 5。</em> <a class="ae mt" rel="noopener" href="/edureka/node-js-docker-tutorial-72e7542d69d8"> <em class="hh">如何对Node.js App进行Dockerize？</em>T29】</a></p><p id="168a" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 6。</em> <a class="ae mt" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5"> <em class="hh">用Node.js构建REST API</em></a></p><p id="bb0b" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 7 </em>。<a class="ae mt" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">从头开始构建Node.js】</a></p><p id="4b21" class="ip iq me ir b is it iu iv iw ix iy iz mx jb jc jd my jf jg jh mz jj jk jl jm ha bi translated"><em class="hh"> 8。</em><a class="ae mt" rel="noopener" href="/edureka/learn-node-js-b3a9c6fb632c"><em class="hh">express . js</em></a></p></blockquote></div><div class="ab cl na nb go nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ha hb hc hd he"><p id="fd94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="me">最初发表于</em><a class="ae mt" href="https://www.edureka.co/blog/interview-questions/top-node-js-interview-questions-2016/" rel="noopener ugc nofollow" target="_blank"><em class="me">https://www.edureka.co</em></a><em class="me">。</em></p></div></div>    
</body>
</html>