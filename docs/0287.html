<html>
<head>
<title>Lessons learned while converting to Kotlin with Android Studio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Android Studio转换到Kotlin的经验教训</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/lessons-learned-while-converting-to-kotlin-with-android-studio-f0a3cb41669?source=collection_archive---------2-----------------------#2017-06-21">https://medium.com/androiddevelopers/lessons-learned-while-converting-to-kotlin-with-android-studio-f0a3cb41669?source=collection_archive---------2-----------------------#2017-06-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f740" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">使用Android Studio提升您的Kotlin转换能力</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/ae6f1ccb690e55beeefb4ad5d42b3bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Dt8JaHzWXJGID-NTVIuPw.png"/></div></div></figure><p id="ff8f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我使用Android Studio中的<a class="ae ke" href="https://developer.android.com/kotlin/get-started.html#convert-to-kotlin-code" rel="noopener ugc nofollow" target="_blank">将Java文件转换为Kotlin </a>工具将一个简单的应用程序从Java转换为Kotlin时，我很兴奋终于尝试了流行语言Kotlin。我尝试了一下，这是我转换这个项目的故事。</p><p id="0685" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我很快发现Android Studio中的工具可以完美地转换我的大部分Java类。有几个地方需要清理，我从转换中学到了一些新的关键字！</p><p id="e79e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我将与你分享这些见解:</p><ul class=""><li id="ddf7" class="kf kg hh jk b jl jm jo jp jr kh jv ki jz kj kd kk kl km kn bi translated"><strong class="jk hi"> <em class="ko">长</em> </strong> s变成了<strong class="jk hi"> <em class="ko"> int </em> </strong> s</li><li id="8f03" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated"><em class="ko"> lateinit </em>关键字</li><li id="b7d9" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated"><em class="ko">内部</em>关键字</li><li id="4e48" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated">伴随物体</li><li id="4d9c" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated">清理范围</li><li id="1b6c" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated">惰性装载</li><li id="a36c" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd kk kl km kn bi translated">解构</li></ul><p id="1418" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我们开始之前，如果你对Kotlin代码背后实际发生的事情有疑问，你可以在Android Studio中通过进入<strong class="jk hi"> <em class="ko">工具→ Kotlin →显示Kotlin字节码</em> </strong>来检查它。</p><h2 id="105d" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated">渴望</h2><p id="19b9" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">我几乎错过了第一个变化，因为它是如此之小。转换器神奇地将我的一个类中的一个<strong class="jk hi"> <em class="ko"> long </em> </strong>常量换成一个<strong class="jk hi"> <em class="ko"> int </em> </strong>并在每次使用时将其强制转换回一个<strong class="jk hi"> <em class="ko"> long </em> </strong>。呀！</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="54bc" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">companion object </strong>{<br/>    <strong class="lv hi">private val TIMER_DELAY </strong>= 3000<br/>}</span><span id="9ee3" class="ku kv hh lv b fi md ma l mb mc">//...</span><span id="91cf" class="ku kv hh lv b fi md ma l mb mc">handler.postDelayed(<strong class="lv hi">{<br/>    //...<br/>}</strong>, <strong class="lv hi">TIMER_DELAY</strong>.toLong())</span></pre><p id="df8c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好消息是什么？它通过使用<strong class="jk hi"> <em class="ko"> val </em> </strong>关键字来识别常量。</p><p id="6145" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">坏消息呢？在我的整个活动中有不必要的铸造，我期待科特林的类型安全比它更先进。</p><p id="05eb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我以为科特林的类型安全比这聪明。可能转换器还不够智能？</p><p id="42a8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">解决这个问题很简单；我只需要在变量声明的末尾添加一个“L”(类似于Java)。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="39e3" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">companion object </strong>{<br/>    <strong class="lv hi">private val TIMER_DELAY </strong>= 3000L<br/>}</span><span id="dfe7" class="ku kv hh lv b fi md ma l mb mc">//...</span><span id="fee2" class="ku kv hh lv b fi md ma l mb mc">handler.postDelayed(<strong class="lv hi">{<br/>    //...<br/>}</strong>, <strong class="lv hi">TIMER_DELAY</strong>)</span></pre><h2 id="fb65" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated">迟做比不做好</h2><p id="d150" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">Kotlin最大的特性之一，<a class="ae ke" href="https://kotlinlang.org/docs/reference/null-safety.html" rel="noopener ugc nofollow" target="_blank">空安全</a>，旨在消除空引用的危险。这是由一个类型系统完成的，该系统区分可以保存null的引用(可为null的引用)和不能保存null的引用(非null引用)。</p><p id="e0fc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大多数时候你希望你的引用是非空的，这样你就不会遇到NPE(空指针异常)。</p><p id="613d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是，在某些情况下，空引用可能会有所帮助，例如，从onClick()事件(如AsyncTask)初始化变量。有几种方法可以处理空引用:</p><ol class=""><li id="7bd3" class="kf kg hh jk b jl jm jo jp jr kh jv ki jz kj kd me kl km kn bi translated">好老的<em class="ko"> if </em>语句在访问一个属性之前检查空引用(你应该习惯于那些来自编写Java的)。</li><li id="82cc" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd me kl km kn bi translated">一个很酷的<a class="ae ke" href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls" rel="noopener ugc nofollow" target="_blank">安全呼叫接线员</a>(语法<em class="ko">？。</em>)，它会在后台为您执行空值检查。如果对象是空引用，则返回空(不是空指针异常)。不再有那些讨厌的<em class="ko"> if </em>语句。</li><li id="c097" class="kf kg hh jk b jl kp jo kq jr kr jv ks jz kt kd me kl km kn bi translated">使用<strong class="jk hi"> <em class="ko">强制返回一个<em class="ko"> NullPointerException </em>！！</em> </strong>运算符。因此，您基本上正在编写熟悉的Java代码，需要执行步骤1。</li></ol><p id="4329" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">确切地知道哪种模式实施空安全并不容易，因此转换器默认采用最简单的解决方案(选项3 ),并让开发人员以最适合其用例的方式处理空安全。</p><p id="5107" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我意识到让我的Kotlin代码抛出一个空指针异常与这种语言的好处背道而驰，所以我深入研究，看看是否有比我已经发现的更好的东西。</p><p id="1ca0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我发现了强大的关键词<strong class="jk hi"> <em class="ko"> lateinit </em> </strong>。使用<strong class="jk hi"> <em class="ko"> lateinit </em> </strong>，Kotlin允许你在构造函数被调用后<a class="ae ke" href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" rel="noopener ugc nofollow" target="_blank">初始化非空属性</a>，所以我正在远离空属性。</p><p id="c80f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这意味着我得到了上面选项2的好处(<em class="ko">？。</em>语法)而不必写多余的“？."。我只是处理方法，就好像它们从来不是空的，没有样板文件检查，并且使用我习惯使用的相同语法。</p><p id="3188" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用<strong class="jk hi"> <em class="ko"> lateinit </em> </strong>是移除<strong class="jk hi"> <em class="ko">的简单方法！！</em> </strong>运算符来自你的Kotlin代码。有关如何移除<strong class="jk hi"> <em class="ko">的更多提示！！</em> </strong>操作符并清理你的代码，查看<a class="ae ke" href="https://android.jlelse.eu/how-to-remove-all-from-your-kotlin-code-87dc2c9767fb?gi=26743d7b8c09" rel="noopener ugc nofollow" target="_blank">大卫·瓦夫拉的帖子</a>。</p><h2 id="180f" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated">内部的内部</h2><p id="f62e" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">因为我一次转换一个类，所以我对转换后的Kotlin类如何与剩余的Java类一起工作很感兴趣。</p><p id="c0a4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我听说Kotlin已经完成了Java互操作性，所以我希望它不会有明显的变化。</p><p id="6412" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Kotlin中，片段中有一个公共方法转换成了一个<a class="ae ke" href="https://kotlinlang.org/docs/reference/visibility-modifiers.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> <em class="ko">内部</em> </strong> </a>函数。在Java中，该方法没有任何<a class="ae ke" href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" rel="noopener ugc nofollow" target="_blank">访问修饰符</a>，所以它是包私有的。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="0055" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public class </strong>ErrorFragment extends Fragment {<br/>    void setErrorContent() <strong class="lv hi">{<br/>        //...<br/>    }<br/></strong>}</span></pre><p id="1948" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">转换器识别出没有访问修饰符，并认为通过对<a class="ae ke" href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#visibility" rel="noopener ugc nofollow" target="_blank">访问可见性</a>应用<strong class="jk hi"> <em class="ko">内部</em> </strong>关键字，它应该只在模块/包内可见。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="2e69" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">class </strong>ErrorFragment : Fragment() {<br/>    <strong class="lv hi">internal fun </strong>setErrorContent() {<br/>        <em class="ko">//...</em><br/>    <strong class="lv hi">}<br/></strong>}</span></pre><p id="0e64" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个新关键字是什么意思？查看反编译的字节码，我们很快看到方法名从<em class="ko"> setErrorContent() </em>变为<em class="ko">set error content $ production _ sources _ for _ module _ app()</em>。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="1123" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public final void </strong>setErrorContent$production_sources_for_module_app() {<br/>   <strong class="lv hi">//...</strong><br/>}</span></pre><p id="42b7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好消息是，在其他Kotlin类中，我们只需要知道原始方法名。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="afef" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">mErrorFragment</strong>.setErrorContent()</span></pre><p id="00a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">科特林将为我们翻译成幕后生成的名字。再次查看反编译的代码，我们看到了翻译。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="da73" class="ku kv hh lv b fi lz ma l mb mc">// Accesses the ErrorFragment instance and invokes the actual method<br/>ErrorActivity.<em class="ko">access$getMErrorFragment$p</em>(ErrorActivity.<strong class="lv hi">this</strong>)<br/>    .setErrorContent$production_sources_for_module_app();</span></pre><p id="d242" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Kotlin为我们处理了方法名的更改，但是其他Java类呢？</p><p id="b516" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从Java类中，您不能调用<em class="ko">error fragment . set error content()</em>，因为那个“内部”方法实际上并不存在(方法名已经改变)。</p><p id="26df" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如我们在Android Studio的智能感知框中看到的那样，setErrorContent() 方法对Java类不再可见，所以您必须使用生成的(笨拙的)方法名。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/8cc77db4059a740a67bcf8cf4c0694ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WwibbTRArE2IE93n."/></div></div></figure><p id="98d8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">尽管Kotlin和Java可以很好地协同工作，但是当从Java类调用Kotlin类时，围绕<em class="ko"> internal </em>关键字可能会出现一些意外的行为。</p><p id="c78f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您计划分阶段迁移到Kotlin，请记住这一点。</p><h2 id="0a61" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated">伴侣会使事情复杂化</h2><p id="1d20" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">Kotlin不允许<a class="ae ke" href="https://kotlinlang.org/docs/reference/classes.html#companion-objects" rel="noopener ugc nofollow" target="_blank">公共静态变量/方法</a>，这是我们通常在Java中习惯的。相反，它有一个<a class="ae ke" href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank">伴随对象</a>的概念，处理Java中的静态和接口行为。</p><p id="22b2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您在一个<a class="ae ke" href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-fields" rel="noopener ugc nofollow" target="_blank"> Java类</a>中创建一个常量并将其转换为Kotlin，转换器不会意识到<strong class="jk hi"> <em class="ko"> static final </em> </strong>变量是打算用作常量的，这会导致Kotlin和Java之间奇怪的互操作性。</p><p id="8f84" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当你在Java中需要一个常量时，你创建一个静态的最终变量:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="5ad9" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public class </strong>DetailsActivity <strong class="lv hi">extends </strong>Activity {<br/>    <strong class="lv hi">public static final </strong>String <strong class="lv hi"><em class="ko">SHARED_ELEMENT_NAME </em></strong>= <strong class="lv hi">"hero"</strong>;<br/>    <strong class="lv hi">public static final </strong>String <strong class="lv hi"><em class="ko">MOVIE </em></strong>= <strong class="lv hi">"Movie"</strong>;<br/><br/>    <em class="ko">//...</em><br/><br/>}</span></pre><p id="8f1f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在转换之后，你会看到它们在一个同伴类中结束。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="856b" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">class </strong>DetailsActivity : Activity() {<br/><br/>    <strong class="lv hi">companion object </strong>{<br/>        <strong class="lv hi">val SHARED_ELEMENT_NAME </strong>= <strong class="lv hi">"hero"<br/>        val MOVIE </strong>= <strong class="lv hi">"Movie"<br/>    </strong>}<br/><br/>    <strong class="lv hi">//...</strong><br/>}</span></pre><p id="8ab6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当被其他Kotlin类使用时，它的工作方式与您预期的一样。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="9e2d" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">val </strong>intent = Intent(<em class="ko">context</em>, DetailsActivity::<strong class="lv hi">class</strong>.<em class="ko">java</em>)<br/>intent.putExtra(DetailsActivity.<strong class="lv hi">MOVIE</strong>, item)</span></pre><p id="c575" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，因为Kotlin将常量转换成它自己的伴生类，所以从Java类访问常量<strong class="jk hi">并不直观。</strong></p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="7b21" class="ku kv hh lv b fi lz ma l mb mc">intent.putExtra(DetailsActivity.<strong class="lv hi">Companion.getMOVIE()</strong>, item)</span></pre><p id="a45c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们反编译Kotlin类时，我们看到我们的常量变成私有的，并通过一个配套的包装类公开。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="f4a3" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public final class </strong>DetailsActivity <strong class="lv hi">extends </strong>Activity {<br/>   @NotNull<br/>   <strong class="lv hi">private static final </strong>String <strong class="lv hi"><em class="ko">SHARED_ELEMENT_NAME </em></strong>= <strong class="lv hi">"hero"</strong>;<br/>   @NotNull<br/>   <strong class="lv hi">private static final </strong>String <strong class="lv hi"><em class="ko">MOVIE </em></strong>= <strong class="lv hi">"Movie"</strong>;<br/>   <strong class="lv hi">public static final </strong>DetailsActivity.Companion <strong class="lv hi"><em class="ko">Companion </em></strong>= <strong class="lv hi">new </strong>DetailsActivity.Companion((DefaultConstructorMarker)<strong class="lv hi">null</strong>);</span><span id="6a88" class="ku kv hh lv b fi md ma l mb mc">   <strong class="lv hi">//...</strong><br/><br/>   <strong class="lv hi">public static final class </strong>Companion {<br/>      @NotNull<br/>      <strong class="lv hi">public final </strong>String getSHARED_ELEMENT_NAME() {<br/>         <strong class="lv hi">return </strong>DetailsActivity.<strong class="lv hi"><em class="ko">SHARED_ELEMENT_NAME</em></strong>;<br/>      }<br/><br/>      @NotNull<br/>      <strong class="lv hi">public final </strong>String getMOVIE() {<br/>         <strong class="lv hi">return </strong>DetailsActivity.<strong class="lv hi"><em class="ko">MOVIE</em></strong>;<br/>      }<br/><br/>      <strong class="lv hi">private </strong>Companion() {<br/>      }<br/><br/>      <em class="ko">// $FF: synthetic method<br/>      </em><strong class="lv hi">public </strong>Companion(DefaultConstructorMarker $constructor_marker) {<br/>         <strong class="lv hi">this</strong>();<br/>      }<br/>   }<br/>}</span></pre><p id="ae0e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这使得我们的Java代码比它需要的更复杂。</p><p id="dfa8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好消息是，我们可以通过在同伴类中使用<a class="ae ke" href="https://kotlinlang.org/docs/reference/properties.html#compile-time-constants" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> <em class="ko"> const </em> </strong> </a>关键字来修复这些问题，并获得我们想要的行为。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="a56a" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">class </strong>DetailsActivity : Activity() {<br/><br/>    <strong class="lv hi">companion object </strong>{<br/>        <strong class="lv hi">const val SHARED_ELEMENT_NAME </strong>= <strong class="lv hi">"hero"<br/>        const val MOVIE </strong>= <strong class="lv hi">"Movie"<br/>    </strong>}<br/><br/>    <strong class="lv hi">//...</strong><br/>}</span></pre><p id="4b76" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在当我们看反编译的代码时，我们看到了我们的常量！</p><p id="b282" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">遗憾的是，我们最终仍然创建了一个空的伴生类实例。😔</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="0020" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public final class </strong>DetailsActivity <strong class="lv hi">extends </strong>Activity {<br/>   @NotNull<br/>   <strong class="lv hi">public static final </strong>String <strong class="lv hi"><em class="ko">SHARED_ELEMENT_NAME </em></strong>= <strong class="lv hi">"hero"</strong>;<br/>   @NotNull<br/>   <strong class="lv hi">public static final </strong>String <strong class="lv hi"><em class="ko">MOVIE </em></strong>= <strong class="lv hi">"Movie"</strong>;<br/>   <strong class="lv hi">public static final </strong>DetailsActivity.Companion <strong class="lv hi"><em class="ko">Companion </em></strong>= <strong class="lv hi">new </strong>DetailsActivity.Companion((DefaultConstructorMarker)<strong class="lv hi">null</strong>);</span><span id="5acf" class="ku kv hh lv b fi md ma l mb mc">   //...</span><span id="7af8" class="ku kv hh lv b fi md ma l mb mc">   <strong class="lv hi">public static final class </strong>Companion {<br/>      <strong class="lv hi">private </strong>Companion() {<br/>      }<br/><br/>      <em class="ko">// $FF: synthetic method<br/>      </em><strong class="lv hi">public </strong>Companion(DefaultConstructorMarker $constructor_marker) {<br/>         <strong class="lv hi">this</strong>();<br/>      }<br/>   }<br/>}</span></pre><p id="f605" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们现在可以像预期的那样在Java类中访问常量了！</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="c704" class="ku kv hh lv b fi lz ma l mb mc">intent.putExtra(DetailsActivity.<strong class="lv hi">MOVIE</strong>, item)</span></pre><p id="115d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">注意这只适用于<a class="ae ke" href="https://kotlinlang.org/docs/reference/properties.html#compile-time-constants" rel="noopener ugc nofollow" target="_blank">原语和字符串</a>。关于非原语的更多信息，请查看<a class="ae ke" href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#instance-fields" rel="noopener ugc nofollow" target="_blank"> @JvmField </a>和<a class="ae ke" rel="noopener" href="/@BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62"> Kotlin的隐藏成本</a>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/697ae0dc1f57f3ed7e45187717214e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1t1Yypjigwopex-E."/></div></div></figure><h2 id="98f9" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated"><strong class="ak">循环受到限制<em class="mh">直到</em> Kotlin对其进行改进</strong></h2><p id="c6a5" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">默认情况下，Kotlin使用0转换范围内的循环..N-1个界限，这可能很难保持，因为有可能引入<a class="ae ke" href="https://en.wikipedia.org/wiki/Off-by-one_error" rel="noopener ugc nofollow" target="_blank">一个误差</a>。</p><p id="afff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，在我的代码中，有一个嵌套的<em class="ko"> for </em>循环，为网格中的每一行/每一列添加卡片；相当典型的Android <em class="ko">用于</em>循环。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="9827" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">for </strong>(<strong class="lv hi">int</strong> i = 0; i &lt; <strong class="lv hi">NUM_ROWS</strong>; i++) {<br/>    //...<br/>    <strong class="lv hi">for </strong>(<strong class="lv hi">int</strong> j = 0; j &lt; <strong class="lv hi">NUM_COLS</strong>; j++) {<br/>        //...<br/>    }<br/>    //...<br/>}</span></pre><p id="f641" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">转换非常简单。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="38f6" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">for </strong>(i <strong class="lv hi">in</strong> 0..<strong class="lv hi">NUM_ROWS</strong> - 1) {<br/>    //...<br/>    <strong class="lv hi">for </strong>(j <strong class="lv hi">in</strong> 0..<strong class="lv hi">NUM_COLS</strong> - 1) {<br/>        //...<br/>    }<br/>    //...<br/>}</span></pre><p id="d01c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">转换后，代码对Java开发人员来说可能看起来很陌生，就像是用Ruby或Python编写的一样。</p><p id="2557" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在阅读了丹·卢的博客后，看来科特林的range函数默认是包含的。但是，当我读到Kotlin的<a class="ae ke" href="https://kotlinlang.org/docs/reference/ranges.html" rel="noopener ugc nofollow" target="_blank">靶场特点</a>时，我看到他们的靶场特点极其先进和灵活。</p><p id="f748" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以通过利用Kotlin的一些很酷的特性来简化转换后的代码，使其更具可读性。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="1fc5" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">for </strong>(i <strong class="lv hi">in </strong>0 <em class="ko">until </em><strong class="lv hi">NUM_ROWS</strong>) {<br/>    //...<br/>    <strong class="lv hi">for </strong>(j <strong class="lv hi">in </strong>0 <em class="ko">until </em><strong class="lv hi">NUM_COLS</strong>) {<br/>        //...<br/>    }<br/>    //...<br/>}</span></pre><p id="37ab" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ko"> until </em>函数使我们的循环具有排他性，并且更易于阅读。再也不用担心那个尴尬的负一了！</p><h1 id="3c39" class="mi kv hh bd kw mj mk ml la mm mn mo le in mp io lh iq mq ir lk it mr iu ln ms bi translated">高级技巧的有用提示</h1><h2 id="5e7c" class="ku kv hh bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo bi translated">感觉有点懒</h2><p id="3e68" class="pw-post-body-paragraph ji jj hh jk b jl lp ii jn jo lq il jq jr lr jt ju jv ls jx jy jz lt kb kc kd ha bi translated">有时延迟加载成员变量是有益的。假设您有一个管理数据列表的单例类。你不需要每次都创建列表，所以我们经常发现自己成为了一个<a class="ae ke" href="https://en.wikipedia.org/wiki/Lazy_initialization#Java" rel="noopener ugc nofollow" target="_blank">懒惰的获取者</a>。与以下内容类似的模式。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="5a7f" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">public static </strong>List&lt;Movie&gt; getList() {<br/>    <strong class="lv hi">if </strong>(<em class="ko">list </em>== <strong class="lv hi">null</strong>) {<br/>        <em class="ko">list </em>= <em class="ko">createMovies</em>();<br/>    }<br/>    <strong class="lv hi">return </strong><em class="ko">list</em>;<br/>}</span></pre><p id="5cf3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在转换器尝试转换这种模式后，代码将无法编译，因为它使<em class="ko">列表</em>不可变，然而<em class="ko"> createMovies() </em>的返回类型是可变的<em class="ko">。当方法签名期望不可变对象时，编译器不允许返回可变对象。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/e1c4e51ae4828f9ea8dddf040fdabc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ldLnjUJavNTDBOI7."/></div></div></figure><p id="c1d7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是一个非常强大的委托加载对象的模式，所以Kotlin包含了一个函数，<a class="ae ke" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank"> lazy </a>，以方便延迟加载。通过使用<em class="ko"> lazy </em>函数，代码现在可以编译了。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="0e88" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">val list</strong>: List&lt;Movie&gt; <strong class="lv hi">by </strong><em class="ko">lazy </em><strong class="lv hi">{<br/>    </strong><em class="ko">createMovies</em>()<br/><strong class="lv hi">}</strong></span></pre><p id="3077" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于最后一行是返回的对象，我们现在可以很容易地创建一个对象，用较少的样板代码进行惰性加载！</p><p id="d84d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">死亡和毁灭</strong></p><p id="2412" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你熟悉在<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> javascript </a>中析构一个数组或对象，那么<a class="ae ke" href="https://kotlinlang.org/docs/reference/multi-declarations.html" rel="noopener ugc nofollow" target="_blank">析构声明</a>会感觉非常熟悉。</p><p id="6c44" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Java中，我们使用对象并一直传递它们。然而，有时我们只需要一个对象的一些属性，却没有花时间将这些属性提取到变量中。</p><p id="c466" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于大量的属性，从getter访问属性更容易。例如:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="9321" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">final </strong>Movie movie = (Movie) getActivity()<br/>        .getIntent().getSerializableExtra(DetailsActivity.<strong class="lv hi"><em class="ko">MOVIE</em></strong>);<br/><br/>// Access properties from getters<br/>mMediaPlayerGlue.setTitle(movie.getTitle());<br/>mMediaPlayerGlue.setArtist(movie.getDescription());<br/>mMediaPlayerGlue.setVideoUrl(movie.getVideoUrl());</span></pre><p id="aa5e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，Kotlin提供了一个强大的析构函数声明，通过缩短将每个属性分配给自己的变量的样板代码，简化了对对象属性的访问。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="5191" class="ku kv hh lv b fi lz ma l mb mc"><strong class="lv hi">val </strong>(_, title, description, _, _, videoUrl) = <em class="ko">activity<br/>        </em>.<em class="ko">intent</em>.getSerializableExtra(DetailsActivity.<strong class="lv hi">MOVIE</strong>) <strong class="lv hi">as </strong>Movie<br/><br/>// Access properties via variables<strong class="lv hi"><br/>mMediaPlayerGlue</strong>.setTitle(title)<br/><strong class="lv hi">mMediaPlayerGlue</strong>.setArtist(description)<br/><strong class="lv hi">mMediaPlayerGlue</strong>.setVideoUrl(videoUrl)</span></pre><p id="8e17" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">毫不奇怪，反编译的代码是意料之中的，其中的<em class="ko"> componentX() </em>方法引用了我们数据类中的getters。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="aebd" class="ku kv hh lv b fi lz ma l mb mc">Serializable var10000 = <strong class="lv hi">this</strong>.getActivity().getIntent().getSerializableExtra(<strong class="lv hi">"Movie"</strong>);<br/>Movie var5 = (Movie)var10000;<br/>String title = var5.component2();<br/>String description = var5.component3();<br/>String videoUrl = var5.component6();</span></pre><p id="4d2c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">转换器很聪明，通过析构模型对象来简化代码。然而，我推荐阅读关于<a class="ae ke" href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11" rel="noopener ugc nofollow" target="_blank"> lambdas with destruction </a>。在Java 8中，将lambda函数的参数放在括号中用于多个参数是很常见的。在科特林，<strong class="jk hi">这可以解释为析构函数。</strong></p><p id="946b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">结论</strong></p><p id="c15a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Android Studio中使用转换工具是我学习Kotlin之旅的一个很好的起点。然而，看到产生的一些代码迫使我更深入地挖掘Kotlin，以找到编写代码的更好方法。</p><p id="d995" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我很高兴在转换后有人提醒我要校对。否则，我会编写一些不容易理解的Kotlin代码！话说回来，我的Java代码也好不了多少。😊</p><p id="c785" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你想了解更多关于Kotlin的入门知识，请查看<a class="ae ke" href="https://developer.android.com/kotlin/get-started.html" rel="noopener ugc nofollow" target="_blank">这篇博文</a>，并观看:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>