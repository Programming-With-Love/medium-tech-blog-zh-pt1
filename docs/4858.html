<html>
<head>
<title>Inheritance, composition, delegation, and traits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继承、组成、授权和特征</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/inheritance-composition-delegation-and-traits-b11c64f11b27?source=collection_archive---------0-----------------------#2018-07-30">https://blog.kotlin-academy.com/inheritance-composition-delegation-and-traits-b11c64f11b27?source=collection_archive---------0-----------------------#2018-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/84e4af783487975452b35c91c6bc02e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjxCxqZagD7NCs5gsAAGvA.jpeg"/></div></div></figure><div class=""/><p id="9be9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">共享公共行为是编程中最重要的事情之一。通过编程，我们代表了随时间变化的知识。相同知识的实例越多，改变它就越难。为了操作一个具体的例子，让我们以<code class="fe kt ku kv kw b">onDestroy</code>中RxJava订阅收集和取消订阅的常见行为为例:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="34bf" class="lf lg iy kw b gy lh li l lj lk">var subscriptions: List&lt;Subscription&gt; = listOf()</span><span id="c3fe" class="lf lg iy kw b gy ll li l lj lk">fun onDestroy() {<br/>    subscriptions.forEach { it.unsubscribe() }<br/>}</span></pre><p id="b30d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要在所有实现一些逻辑的类中使用它，因为它们都产生订阅。我们还不知道，但很快RxJava 2就会来到我们的项目中，我们需要将其更改为以下模式:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6c6f" class="lf lg iy kw b gy lh li l lj lk">val subscriptions = CompositeDisposable()</span><span id="5d3d" class="lf lg iy kw b gy ll li l lj lk">fun onDestroy() {<br/>    subscriptions.dispose()<br/>}</span><span id="f9c8" class="lf lg iy kw b gy ll li l lj lk">operator fun CompositeDisposable.plus(d: Disposable) {<br/>    subscriptions.add(d)<br/>}</span></pre><p id="c422" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这解释了为什么把以前的模式复制粘贴到我们使用的每个类中是一个非常糟糕的主意。在所有的职业中改变这一点是非常困难的。太好了，我们很聪明，我们记得代码重用；)今天我们来讨论一下我们的替代方案。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi lm"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h2 id="7392" class="lf lg iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">继承问题</h2><figure class="kx ky kz la gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/580e5458e5214949f6461f00a98eb298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpuU7E1Jr340trYfMj9Wfg.jpeg"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Classes are fashionable and look good, but they are not really liked by programmers anymore.</figcaption></figure><p id="59d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继承是OOP(面向对象编程)中重用代码最直观的方式。我们可以用它来解决这个问题，并在一个开放类中定义我们的模式:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="58eb" class="lf lg iy kw b gy lh li l lj lk">open class RxJavaUser {<br/>    var subscriptions: List&lt;Subscription&gt; = listOf()</span><span id="fc4d" class="lf lg iy kw b gy ll li l lj lk">    fun onDestroy() {<br/>        subscriptions.forEach { it.unsubscribe() }<br/>    }<br/>}</span></pre><p id="7637" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然遗传有很多不好的地方。例如，我们不能在JVM中扩展一个以上的类。结果，我们最终用<code class="fe kt ku kv kw b">Base</code>类来表示一切:<code class="fe kt ku kv kw b">BaseActivity</code>，<code class="fe kt ku kv kw b">BasePresenter</code>，<code class="fe kt ku kv kw b">BaseViewAdapter</code>，…它们中的每一个集合了子类中经常使用的方法和属性。虽然不是好模式。在一个类中混合多种功能并不好。我们可能还需要在许多基类中包括我们的订阅和取消订阅功能，如<code class="fe kt ku kv kw b">BaseActivity</code>、<code class="fe kt ku kv kw b">BaseFragment</code>等。此外，获取不需要的能力也是一种不好的做法。</p><p id="8d3e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继承的问题比较多。最大的问题是继承打破了封装。看一下下面的类:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="47dd" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">class </strong>CountingHashSet&lt;T&gt; : HashSet&lt;T&gt;() {<br/><br/>    <strong class="kw iz">var addCount </strong>= 0<br/>        <strong class="kw iz">private set<br/><br/>    override fun </strong>add(o: T): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= 1<br/>        <strong class="kw iz">return super</strong>.add(o)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>addAll(collection: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= collection.<strong class="kw iz">size<br/>        return super</strong>.addAll(collection)<br/>    }<br/>}</span></pre><p id="2498" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是用法:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2eaf" class="lf lg iy kw b gy lh li l lj lk">val countingSet = CountingHashSet()<br/>countingSet.addAll(listOf(1,2,3))<br/>print(countingSet.addCount)</span></pre><p id="0306" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果如何呢？</p><p id="2e5c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不，不是“3”。它打印“6”。</p><p id="ed55" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因是<code class="fe kt ku kv kw b">addAll</code>在引擎盖下用了<code class="fe kt ku kv kw b">add</code>的方法。那么，也许我们可以删除<code class="fe kt ku kv kw b">addAll</code>中的加法？是的，我们可以，而且我们可能应该这样做——我们和许多其他开发者和库创建者。Java创造者知道这一点，他们也知道他们不能再改变<code class="fe kt ku kv kw b">HashSet</code>实现了。它只会破坏所有依赖于其内部实现的库，并且会导致意想不到的和难以发现的错误。这就是为什么我们应该使我们的类成为最终类，以及为什么我们应该选择替代而不是继承。最常见的选择是合成。</p><h2 id="7007" class="lf lg iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">作文</h2><figure class="kx ky kz la gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/b9d7f743ab88bc5407ea9193053234f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SP5TwfjzLJaKcmnoMEq9g.jpeg"/></div></div></figure><p id="e213" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Object_composition" rel="noopener ugc nofollow" target="_blank">组合</a>是一个复杂的词，实际上意味着一个类包含另一个类的实例，并使用它的功能。例如，订阅收集和取消订阅功能可以保存在一个单独的类中，并通过组合来使用:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="8b91" class="lf lg iy kw b gy lh li l lj lk">class SubscriptionsCollector {<br/>    private var subscriptions: List&lt;Subscription&gt; = listOf()</span><span id="cf55" class="lf lg iy kw b gy ll li l lj lk">    fun add(s: Subscription) {<br/>        subscriptions += s<br/>    }</span><span id="2026" class="lf lg iy kw b gy ll li l lj lk">    fun onDestroy() {<br/>        subscriptions.forEach { it.unsubscribe() }<br/>    }<br/>}</span><span id="29ed" class="lf lg iy kw b gy ll li l lj lk">class MainPresenter {<br/>    val subscriptionsCollector = SubscriptionsCollector()</span><span id="980d" class="lf lg iy kw b gy ll li l lj lk">    fun onDestroy() {<br/>       subscriptionsCollector.onDestroy()<br/>    }</span><span id="650c" class="lf lg iy kw b gy ll li l lj lk">    //...<br/>}</span></pre><p id="f826" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我们的<code class="fe kt ku kv kw b">SubscriptionsCollector</code>和RxJava 2 <code class="fe kt ku kv kw b">CompositeDisposable</code>是同一个概念。这意味着我们将来会有额外的包装。不过还不错。优势在于我们可以控制这种包装，如果我们需要迁移到RxJava 3，那么我们只需在一个类中替换用法。</p><p id="6054" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是使用起来并不容易。我们每次都需要声明<code class="fe kt ku kv kw b">onDestroy</code>，并且我们每次想要添加另一个订阅时都需要使用<code class="fe kt ku kv kw b">subscriptionsCollector</code>。继承给出了更简单的用法。它也给出了多态行为。例如，我们可以用下面的方式使用组合来定义<code class="fe kt ku kv kw b">CountingHashSet</code>:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="640f" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">class </strong>CountingHashSet&lt;T&gt; {<br/>    <strong class="kw iz">val set </strong>= HashSet&lt;T&gt;()<br/>    <strong class="kw iz">var addCount </strong>= 0<br/>        <strong class="kw iz">private set<br/><br/>    fun </strong>add(o: T): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= 1<br/>        <strong class="kw iz">return set</strong>.add(o)<br/>    }<br/><br/>    <strong class="kw iz">fun </strong>addAll(collection: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= collection.<strong class="kw iz">size<br/>        return set</strong>.addAll(collection)<br/>    }<br/>}</span></pre><p id="8dda" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这个类不是一个<code class="fe kt ku kv kw b">MutableSet</code>并且除了<code class="fe kt ku kv kw b">add</code>和<code class="fe kt ku kv kw b">addAll</code>它没有实现任何其他功能。我们可以让它实现<code class="fe kt ku kv kw b">MutableSet</code>，但是我们会以下面的怪物结束:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="ade1" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">class </strong>CountingHashSet&lt;T&gt;: MutableSet&lt;T&gt; {<br/>    <br/>    <strong class="kw iz">val set </strong>= HashSet&lt;T&gt;()<br/>    <strong class="kw iz">var addCount </strong>= 0<br/>        <strong class="kw iz">private set<br/><br/>    override fun </strong>add(element: T): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= 1<br/>        <strong class="kw iz">return set</strong>.add(element)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>addAll(elements: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= elements.<strong class="kw iz">size<br/>        return set</strong>.addAll(elements)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>clear() {<br/>        <strong class="kw iz">set</strong>.clear()<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>iterator(): MutableIterator&lt;T&gt; {<br/>        <strong class="kw iz">return set</strong>.iterator()<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>remove(element: T): Boolean {<br/>        <strong class="kw iz">return set</strong>.remove(element)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>removeAll(elements: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">return set</strong>.removeAll(elements)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>retainAll(elements: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">return set</strong>.retainAll(elements)<br/>    }<br/><br/>    <strong class="kw iz">override val size</strong>: Int<br/>        <strong class="kw iz">get</strong>() = <strong class="kw iz">set</strong>.<strong class="kw iz">size<br/><br/>    override fun </strong>contains(element: T): Boolean {<br/>        <strong class="kw iz">return set</strong>.contains(element)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>containsAll(elements: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">return set</strong>.containsAll(elements)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>isEmpty(): Boolean {<br/>        <strong class="kw iz">return set</strong>.isEmpty()<br/>    }<br/>}</span></pre><p id="f1d2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是委托的一个例子——使用组合的模式——kot Lin支持它并允许更简单的符号。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi lm"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h2 id="4aa8" class="lf lg iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">委托</h2><figure class="kx ky kz la gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/43cf736999403087cd4ab3a8db2cfd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbaWC_xWzH28mSTcJ2v2Pg.jpeg"/></div></div></figure><p id="4f45" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的巨大类可以用下面的实现来代替:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="73f4" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">class </strong>CountingHashSet&lt;T&gt;(<br/>        <strong class="kw iz">val innerSet</strong>: MutableSet&lt;T&gt; = HashSet&lt;T&gt;()<br/>) : MutableSet&lt;T&gt; <strong class="kw iz">by innerSet</strong> {<br/><br/>    <strong class="kw iz">var addCount </strong>= 0<br/>        <strong class="kw iz">private set<br/><br/>    override fun </strong>add(element: T): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= 1<br/>        <strong class="kw iz">return innerSet</strong>.add(element)<br/>    }<br/><br/>    <strong class="kw iz">override fun </strong>addAll(elements: Collection&lt;T&gt;): Boolean {<br/>        <strong class="kw iz">addCount </strong>+= elements.<strong class="kw iz">size<br/>        return innerSet</strong>.addAll(elements)<br/>    }<br/>}</span></pre><p id="99b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它做的完全一样——没有实现的来自<code class="fe kt ku kv kw b">MutableSet</code>的方法将由只使用<code class="fe kt ku kv kw b">innerSet</code>的主体生成。结果，我们有了多态行为(我们实现了<code class="fe kt ku kv kw b">MutableSet</code>)、代码重用和简短声明。这太完美了。虽然这种模式并不常用。我们的订阅管理怎么样？我们能在那里使用它吗？嗯，我们或许可以:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="399d" class="lf lg iy kw b gy lh li l lj lk">interface SubscriptionsCollector {<br/>    var subscriptions: List&lt;Subscription&gt;<br/>    fun onDestroy()<br/>}</span><span id="c318" class="lf lg iy kw b gy ll li l lj lk">class SubscriptionsCollectorImpl {<br/>    var subscriptions: List&lt;Subscription&gt; = listOf()</span><span id="49d4" class="lf lg iy kw b gy ll li l lj lk">    fun onDestroy() {<br/>        subscriptions.forEach { it.unsubscribe() }<br/>    }<br/>}</span><span id="7e71" class="lf lg iy kw b gy ll li l lj lk">class MainPresenter(<br/>    val subscrCollector = SubscriptionsCollectorImpl()<br/>): SubscriptionsCollector by subscrCollector {<br/>    //...<br/>}</span></pre><p id="097d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种用法很可怕，它扰乱了我们的论点。定制<code class="fe kt ku kv kw b">onDestroy</code>也不直观。唯一的好处是我们可以像使用继承一样添加订阅。我绝对不会使用授权支持来解决这个问题！</p><h2 id="509c" class="lf lg iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">特征</h2><p id="f99b" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">做了这么多尝试，仍然很难找到一个好的替代方案来解决我们的问题。虽然，还有另一种技术应该是每个程序员工具箱的一部分。我们可以利用特征。在Kotlin中，接口是特征(历史上甚至使用关键字<code class="fe kt ku kv kw b">trait</code>而不是<code class="fe kt ku kv kw b">interface</code>)。在实践中，这意味着我们可以为方法定义默认体并声明属性(但是没有任何实际值，所以它们仍然必须在非抽象类中被覆盖):</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="1ba7" class="lf lg iy kw b gy lh li l lj lk">interface NumberHolder {<br/>   val number: Int<br/>   fun doubled() = number * 2<br/>}</span><span id="589c" class="lf lg iy kw b gy ll li l lj lk">class TenNumberHolder: NumberHolder {<br/>    override val number = 10<br/>}</span><span id="1a68" class="lf lg iy kw b gy ll li l lj lk">print(TenNumberHolder().doubled()) // 20</span></pre><p id="a8cb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(mixins是一个类似的概念，但是在Mixins中，我们也可以持有状态。例如，我们可以用默认值来声明属性。他们还没有得到科特林的支持。)</p><p id="5a31" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特质的概念非常强大。让我们玩一会儿吧。假设我们写了一个格斗模拟器。每一个战士都表现为一个阶级。他们都有自己的职业，同时也有自己的特点。也有不是人物的怪物。我们希望允许这些角色之间的战斗模拟。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/feace41122baf6044f418bef3f89f248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*28L9B_4u5D7K_7MU.jpg"/></div></div></figure><p id="3827" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">先说作战能力。我们可以用一个界面来表达战斗能力:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="497b" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">interface </strong>Fighter {<br/>    <strong class="kw iz">var lifePoints</strong>: Int<br/>    <strong class="kw iz">fun </strong>attack(opponent: Fighter)<br/>    <strong class="kw iz">fun </strong>turnEnd() {}<br/>}</span></pre><p id="3b79" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">怪物只是战士:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="ca79" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">data class </strong>Goblin(<strong class="kw iz">override var lifePoints</strong>: Int = 50) : Fighter {<br/><br/>    <strong class="kw iz">override fun </strong>attack(opponent: Fighter) {<br/>        <em class="mq">println</em>(<strong class="kw iz">"Goblin attack (5)"</strong>)<br/>        opponent.<strong class="kw iz">lifePoints </strong>-= 5<br/>    }<br/>}</span></pre><p id="18d0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有人物。假设他们还有名字:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="dc26" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">interface </strong>Character : Fighter {<br/>    <strong class="kw iz">val name</strong>: String<br/>        <strong class="kw iz">get</strong>() = <strong class="kw iz">this</strong>.<em class="mq">javaClass</em>.<em class="mq">name<br/></em>}</span></pre><p id="55b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于类名构造名字的行为已经是一种特征。虽然这只是一个开始。有几类人物。每个人都可以成为<code class="fe kt ku kv kw b">Sorcerer</code>和/或<code class="fe kt ku kv kw b">Warrior</code>。因为我们不能扩展一个以上的类，所以我们不能使用继承来表达<code class="fe kt ku kv kw b">Warrior</code>和<code class="fe kt ku kv kw b">Sorcerer</code>功能。我们将使用特征来代替。假设<code class="fe kt ku kv kw b">Warrior</code>可以用<code class="fe kt ku kv kw b">meleeAttack</code>。生命值取决于他的力量，所以我们也需要这样的属性:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="f1e9" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">interface </strong>Warrior : Character {<br/>    <strong class="kw iz">val strength</strong>: Int<br/><br/>    <strong class="kw iz">fun </strong>meleeAttack(opponent: Fighter) {<br/>        <em class="mq">println</em>(<strong class="kw iz">"$name melee attack with power $strength"</strong>)<br/>        opponent.<strong class="kw iz">lifePoints </strong>-= <strong class="kw iz">strength<br/>    </strong>}<br/>}</span></pre><p id="b96f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Sorcerer</code>反之，可以<code class="fe kt ku kv kw b">castSpell</code>。他需要一些法术和法力点。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="e9bc" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">interface </strong>Sorcerer : Character {<br/>    <strong class="kw iz">val spell</strong>: Spell<br/>    <strong class="kw iz">var manaPoints</strong>: Int<br/><br/>    <strong class="kw iz">fun </strong>canCastSpell() = <strong class="kw iz">manaPoints </strong>&gt; <strong class="kw iz">spell</strong>.<strong class="kw iz">manaCost<br/><br/>    fun </strong>castSpell(opponent: Fighter) {<br/>        <strong class="kw iz">if </strong>(<strong class="kw iz">manaPoints </strong>&lt; <strong class="kw iz">spell</strong>.<strong class="kw iz">manaCost</strong>) {<br/>            <em class="mq">println</em>(<strong class="kw iz">"$name tried to cast spell but not enough mana"</strong>)<br/>            <strong class="kw iz">return<br/>        </strong>}<br/>        <em class="mq">println</em>(<strong class="kw iz">"$name cast spell ${spell</strong>.<strong class="kw iz">strength}"</strong>)<br/>        <strong class="kw iz">manaPoints </strong>-= <strong class="kw iz">spell</strong>.<strong class="kw iz">manaCost<br/>        </strong>opponent.<strong class="kw iz">lifePoints </strong>-= <strong class="kw iz">spell</strong>.<strong class="kw iz">strength<br/>    </strong>}<br/><br/>    <strong class="kw iz">override fun </strong>turnEnd() {<br/>        <strong class="kw iz">manaPoints </strong>+= 1<br/>    }<br/>}</span></pre><p id="bcaf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意这里也声明了一个默认的恢复法力点的方式(在<code class="fe kt ku kv kw b">turnEnd</code>)。现在我们可以用上面的职业来声明一些角色。假设我们有明斯克，强大的战士，所以他使用<code class="fe kt ku kv kw b">meleeAttack</code>战斗:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="34e4" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">data class </strong>Minsk(<br/>        <strong class="kw iz">override var lifePoints</strong>: Int = 60<br/>) : Warrior {</span><span id="dd49" class="lf lg iy kw b gy ll li l lj lk">    <strong class="kw iz">override val strength</strong>: Int = 15<br/><br/>    <strong class="kw iz">override fun </strong>attack(opponent: Fighter) {<br/>        meleeAttack(opponent)<br/>    }<br/>}</span></pre><p id="6bd6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还有亚瑟，他既是战士又是巫师。他同时使用法术和近战攻击:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="1b6c" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">data class </strong>Artur(<br/>        <strong class="kw iz">override var lifePoints</strong>: Int = 80,<br/>        <strong class="kw iz">override var manaPoints</strong>: Int = 10<br/>) : Warrior, Sorcerer {</span><span id="b66c" class="lf lg iy kw b gy ll li l lj lk">    <strong class="kw iz">override var spell </strong>= Spell(4, 17)<br/>    <strong class="kw iz">override val strength</strong>: Int = 5<br/><br/>    <strong class="kw iz">override fun </strong>attack(opponent: Fighter) {<br/>        <strong class="kw iz">if </strong>(canCastSpell()) {<br/>            castSpell(opponent)<br/>        } <strong class="kw iz">else </strong>{<br/>            meleeAttack(opponent)<br/>        }<br/>    }<br/>}</span></pre><p id="3eac" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以模拟他们之间的打斗:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="bfc6" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">fun </strong>simulateCombat(c1: Fighter, c2: Fighter) {<br/>    <strong class="kw iz">while </strong>(c1.<strong class="kw iz">lifePoints </strong>&gt; 0 &amp;&amp; c2.<strong class="kw iz">lifePoints </strong>&gt; 0) {<br/>        c1.attack(c2)<br/>        c2.attack(c1)<br/>        c1.turnEnd()<br/>        c2.turnEnd()<br/>    }<br/>    <strong class="kw iz">val </strong>text = <strong class="kw iz">when </strong>{<br/>        c1.<strong class="kw iz">lifePoints </strong>&gt; 0 -&gt; <strong class="kw iz">"$</strong>c1<strong class="kw iz"> won"</strong><br/>        c2.<strong class="kw iz">lifePoints </strong>&gt; 0 -&gt; <strong class="kw iz">"$</strong>c2<strong class="kw iz"> won"</strong><br/>        <strong class="kw iz">else </strong>-&gt; <strong class="kw iz">"Both $</strong>c1<strong class="kw iz"> and $</strong>c2<strong class="kw iz"> are dead"<br/>    </strong>}<br/>    <em class="mq">println</em>(text)<br/>}</span><span id="ac15" class="lf lg iy kw b gy ll li l lj lk"><em class="mq">simulateCombat</em>(Artur(), Minsk())<br/>Artur cast spell 17<br/>Minsk melee attack with power 15<br/>Artur cast spell 17<br/>Minsk melee attack with power 15<br/>Artur melee attack with power 5<br/>Minsk melee attack with power 15<br/>Artur cast spell 17<br/>Minsk melee attack with power 15<br/>Artur melee attack with power 5<br/>Minsk melee attack with power 15<br/>Artur(lifePoints=5, manaPoints=3) won</span><span id="b969" class="lf lg iy kw b gy ll li l lj lk"><em class="mq">simulateCombat</em>(Goblin(), Minsk())<br/>Goblin attack (5)<br/>Minsk melee attack with power 15<br/>Goblin attack (5)<br/>Minsk melee attack with power 15<br/>Goblin attack (5)<br/>Minsk melee attack with power 15<br/>Goblin attack (5)<br/>Minsk melee attack with power 15<br/>Minsk(lifePoints=40) won</span></pre><p id="21c8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种模式非常强大，并在许多情况下得到应用。但是它有一个问题。特征不能保持状态。它们只能用于重用<strong class="jx iz">行为</strong>。如果我们回到订阅问题，我们将被迫在每个使用我们特征的类中实现<code class="fe kt ku kv kw b">subscriptions</code>:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="9f7c" class="lf lg iy kw b gy lh li l lj lk">interface RxJavaUser {<br/>    var subscriptions: List&lt;Subscription&gt;</span><span id="9cca" class="lf lg iy kw b gy ll li l lj lk">    fun onDestroy() {<br/>        subscriptions.forEach { it.unsubscribe() }<br/>    }<br/>}</span><span id="fa80" class="lf lg iy kw b gy ll li l lj lk">class MainPresenter(): RxJavaUser {<br/>    var subscriptions: List&lt;Subscription&gt; = listOf()<br/>}</span></pre><p id="be45" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着向RxJava 2的过渡，我们将被迫改变每个类中的订阅定义。不太好。</p><p id="ab33" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么最好的解决方案是什么？对不起，但是我没有一个完美的答案。我们已经看到了一些不同的尝试，它们都有一些优点和缺点。尽管我们也已经看到了这些尝试是如何以非常有用的方式使用的。我们已经看到了组合如何帮助我们克服遗传问题，表达更健康的关系。我们已经看到了委托是如何给我们带来多态行为的。最后，我们已经看到了特征，以及当我们需要表达类似于几个类的行为时，它们是多么强大。我希望你能记住继承的所有替代品，因为它们是重要的工具，能让你的代码更好，更有表现力。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://blog.kotlin-academy.com/write-for-kotlin-academy-abebd70937ce"><div class="gh gi lm"><img src="../Images/87c508a2627eaa3d0e472518952dc75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoIe6R-7DJyXGh8tYeqjA.jpeg"/></div></a></figure><h1 id="4c19" class="mr lg iy bd ln ms mt mu lq mv mw mx lt my mz na lw nb nc nd lz ne nf ng mc nh bi translated">关于作者</h1><p id="a5e7" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated"><a class="ae mj" href="http://marcinmoskala.com/" rel="noopener ugc nofollow" target="_blank">马尔金·莫斯卡兹拉</a>(<a class="ae mj" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">@马尔金莫斯卡拉</a>)是一名培训师兼顾问，目前专注于给<strong class="jx iz">在Android和高级Kotlin工作坊</strong> ( <a class="ae mj" href="https://marcinmoskala.typeform.com/to/iwKnN9" rel="noopener ugc nofollow" target="_blank">填写表格</a>，我们可以谈谈你的需求)。他还是一名演讲者，撰写了关于kot Lin Android开发的文章和书籍。</p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="53e7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae mj" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>看看我们能为您做些什么。</p><p id="7522" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解最新的<a class="ae mj" href="https://blog.kotlin-academy.com/" rel="noopener ugc nofollow" target="_blank"> Kt重大新闻。学院</a>、<a class="ae mj" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>、<a class="ae mj" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并关注。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi lm"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><p id="8c5a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想感谢杰夫·福尔克的语言审查。</p></div></div>    
</body>
</html>