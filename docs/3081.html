<html>
<head>
<title>Top Data Structures &amp; Algorithms in Java That You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的Java顶级数据结构和算法</h1>
<blockquote>原文：<a href="https://medium.com/edureka/data-structures-algorithms-in-java-d27e915db1c5?source=collection_archive---------1-----------------------#2019-07-19">https://medium.com/edureka/data-structures-algorithms-in-java-d27e915db1c5?source=collection_archive---------1-----------------------#2019-07-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/dc36df57e30104e9a467889e2a818391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_HvIY0Xt0-7frVXYqIvpTA.png"/></div><figcaption class="il im et er es in io bd b be z dx">Data Structures and Algorithms in Java — Edureka</figcaption></figure><p id="8a5c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我必须选择软件开发中最重要的一个话题，那就是数据结构和算法。你可以把它看作是每个计算机程序员都可以使用的基本工具。在编程时，我们使用<em class="jn">数据结构</em>来存储和组织数据，使用<em class="jn">算法</em>来操作这些结构中的数据。本文包含了对Java中所有常见数据结构和算法的详细回顾，以帮助读者做好准备。</p><p id="5ffd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面列出了本文中讨论的主题:</p><ul class=""><li id="422a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">Java中的数据结构</li></ul><ol class=""><li id="02d1" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">线性数据结构</li><li id="85eb" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">分层数据结构</li></ol><ul class=""><li id="11e9" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">Java中的算法</li></ul><ol class=""><li id="d1b0" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">排序算法</li><li id="c089" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">搜索算法</li></ol><h1 id="942d" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的数据结构</h1><p id="d944" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated"><em class="jn">数据结构是在计算机中存储和组织数据的一种方式，以便可以有效地使用。它提供了一种有效管理大量数据的方法。高效的数据结构是设计高效算法的关键。</em></p><p id="40a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇“Java中的数据结构和算法”文章中，我们将讨论基本的数据结构，例如:</p><ul class=""><li id="4d9e" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">线性数据结构</li></ul><ol class=""><li id="e91f" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">数组</li><li id="ed95" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">链表</li><li id="5207" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">大量</li><li id="eccc" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">行列</li></ol><ul class=""><li id="31d9" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">分层数据结构</li></ul><ol class=""><li id="662c" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">二叉树</li><li id="decf" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">很</li><li id="1639" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">哈希表</li></ol><p id="750e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们逐一检查一下。</p><h1 id="d9f0" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的线性数据结构</h1><p id="2d2f" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">Java中的线性数据结构是那些其元素是连续的并且以这样的方式排序的:只有一个<em class="jn">第一个元素</em>并且只有一个<em class="jn">下一个元素</em>，只有一个<em class="jn">最后一个元素</em>并且只有一个<em class="jn">前一个元素</em>，而所有其他元素都有一个<em class="jn">下一个</em>和一个<em class="jn">前一个</em>元素。</p><h2 id="c907" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">数组</h2><p id="cd51" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">数组是表示一组相似元素的线性数据结构，通过索引访问。在存储数据之前，必须提供数组的大小。下面列出了阵列的属性:</p><ul class=""><li id="7ecf" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">数组中的每个元素都具有相同的数据类型和大小</li><li id="2f5b" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">数组的元素存储在连续的存储位置，第一个元素从最小的存储位置开始</li><li id="115d" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">可以随机访问数组的元素</li><li id="4143" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">数组数据结构不是完全动态的</li></ul><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/fcd8a2e4516459327776b99c7df4843e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*C9OMvZAc8lC1rsSarz6xhQ.png"/></div></figure><p id="a273" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">例如</em> </strong>，我们可能想要一个视频游戏来记录该游戏的前十名得分。在这项任务中，我们可以用一个名字来代表整个组，而不是用十个不同的变量，并用指数来表示该组中的高分。</p><h2 id="c674" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">链表</h2><p id="e72c" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">链表是一个由多个节点组成的线性数据结构，其中每个元素存储自己的数据和指向下一个元素位置的指针。链表中的最后一个链接指向null，表示链的结束。链表中的一个元素称为<strong class="ir hi">节点</strong>。第一个节点称为<strong class="ir hi">头</strong>。最后一个节点叫做<strong class="ir hi">尾</strong>。</p><h2 id="69f2" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated"><strong class="ak">链表的类型</strong></h2><p id="e1b6" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">单向链表(单向)</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/e90ba39e0001b68b1f840588ceea0f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*6bY_gjEc7QaJcJsJ2TprWw.png"/></div></figure><p id="5b10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">双向链表(双向)</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/620f8bf82cad1ca9eaf6b2dc0a9d83bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*HEsVgTdSnuhaUckXf_oDPg.png"/></div></figure><p id="93b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">循环链表</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/b49bfffacc224045c4ee5c96c455a92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*AVxCKsZXq5qMTijNn2oPgQ.png"/></div></figure><p id="7064" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">这里有一个简单的例子:</em> </strong>想象一个链表就像一串连接在一起的回形针。您可以轻松地在顶部或底部添加另一个回形针。中间插一个甚至很快。你所要做的就是从中间断开链条，装上新的回形针，然后重新连接另一半。链表也是类似的。</p><h1 id="f8d0" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">大量</h1><p id="7707" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated"><strong class="ir hi"><em class="jn"/></strong>栈，一种抽象的数据结构，是按照<strong class="ir hi"> <em class="jn">【后进先出】</em> </strong>原则插入和移除的对象的集合。可以在任何时间点将对象插入到堆栈中，但是任何时候都只能移除最近插入的(即“最后一个”)对象。下面列出了堆栈的属性:</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/62abec450c254fa6920afd6597342ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*x1NgFS6Ci64R3Ov16C4tsQ.png"/></div></figure><ul class=""><li id="d0d7" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">这是一个只能在一端执行插入和删除的有序列表，称为<em class="jn">顶部</em></li><li id="6a9a" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">指针指向其顶部元素的递归数据结构</li><li id="0c28" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">遵循<strong class="ir hi"> <em class="jn">后进先出</em> </strong>的原则</li><li id="fcd5" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">支持两种最基本的方法</li></ul><ol class=""><li id="b0fc" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">push(e):将元素e插入堆栈的顶部</li><li id="047d" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">pop():移除并返回栈顶元素</li></ol><p id="5576" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">栈的实际例子包括反转一个单词，检查括号序列的正确性，在浏览器中实现后退功能等等。</p><h2 id="7e36" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">行列</h2><p id="3afb" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">队列</em> </strong>也是另一种类型的抽象数据结构。与堆栈不同，队列是根据<strong class="ir hi"> <em class="jn">先进先出(FIFO) </em> </strong>原则插入和移除的对象集合。也就是说，可以在任何时间点插入元素，但是任何时候都只能删除队列中时间最长的元素。下面列出了队列的属性:</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/a3b6356dbe604fcf1faecc58a024565a.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*TdrJ7Lg-qdyYXVJtYgay5g.png"/></div></figure><ul class=""><li id="ce2a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">通常被称为先进先出清单</li><li id="11fd" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">支持两种最基本的方法</li></ul><ol class=""><li id="ad03" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">enqueue(e):在队列的<em class="jn">后面</em>插入元素e</li><li id="2c42" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">dequeue():从队列的<em class="jn">前端</em>移除并返回元素</li></ol><p id="f67a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">队列用于两个进程之间的异步数据传输、CPU调度、磁盘调度以及多个用户共享资源并基于先来先服务的其他情况。接下来，在这篇“Java中的数据结构和算法”文章中，我们将介绍分层数据结构。</p><h1 id="f964" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的层次数据结构</h1><h2 id="e484" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">二叉树</h2><p id="311a" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">二叉树是一种分层的树形数据结构，其中<em class="jn">每个节点最多有两个子节点</em>，分别称为<em class="jn">左子节点</em>和<em class="jn">右子节点</em>。每个二叉树都有以下节点组:</p><ul class=""><li id="0bff" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">根节点:它是最顶层的节点，通常被称为主节点，因为所有其他节点都可以从根节点到达</li><li id="2ad6" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">左边的子树，也是二叉树</li><li id="89fe" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">右子树，也是二叉树</li></ul><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/ddbc2c10adb77f411c7a20d734793e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*wrVYTCbAkdiADiZUjBsBnQ.png"/></div></figure><p id="1c36" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面列出了二叉树的属性:</p><ul class=""><li id="a8fb" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">二叉树有两种遍历方式:</li></ul><ol class=""><li id="61c5" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated"><em class="jn">深度优先遍历</em>:按序(左-根-右)、前序(根-左-右)和后序(左-右-根)</li><li id="a2b7" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated"><em class="jn">广度优先遍历</em>:层次顺序遍历</li></ol><ul class=""><li id="bc79" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">树遍历的时间复杂度:O(n)</li><li id="1f82" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">级别“l”的最大节点数= 2l-1。</li></ul><p id="6ca2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">二叉树的应用包括:</p><ul class=""><li id="4dc5" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">在许多数据不断进出的搜索应用程序中使用</li><li id="5419" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">作为合成数字图像以获得视觉效果的工作流程</li><li id="c105" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">几乎每个高带宽路由器都使用它来存储路由表</li><li id="403e" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">也用于无线网络和内存分配</li><li id="73ef" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">用于压缩算法和许多其他算法</li></ul><h2 id="a761" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">二元堆</h2><p id="2203" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">二叉堆是一棵完整的二叉树，它符合堆的性质。简单来说，它是二叉树的一种变体，具有以下属性:</p><ul class=""><li id="641d" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn"> Heap是一棵完全二叉树:</em>如果一棵树的所有层次都是完全的，除了可能最深的层次之外，则称该树是完全的。二进制堆的这个属性使它适合存储在数组中。</li><li id="4a99" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated"><em class="jn">遵循堆属性:</em>二进制堆或者是<em class="jn">最小堆</em>或者是<em class="jn">最大堆</em>。</li></ul><ol class=""><li id="c556" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated">最小二进制堆:对于堆中的每个节点，节点的值小于或等于子节点的值</li><li id="50f5" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">最大二进制堆:对于堆中的每个节点，节点的值大于或等于子节点的值</li></ol><p id="3eb7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">二进制堆的流行应用包括实现有效的优先级队列、有效地找到数组中k个最小(或最大)的元素等等。</p><h2 id="fef3" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated">哈希表</h2><p id="bcc5" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">假设你有一个对象，你想给它分配一个键来使搜索变得非常容易。要存储键/值对，可以使用一个简单的数组，比如数据结构，其中键(整数)可以直接用作存储数据值的索引。但是，如果键太大，不能直接用作索引，就要使用一种叫做散列的技术。</p><p id="854f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在散列法中，通过使用<strong class="ir hi">散列函数</strong>将大密钥转换成小密钥。然后，这些值被存储在一个名为<strong class="ir hi">哈希表的数据结构中。</strong>哈希表是实现字典ADT的数据结构，字典ADT是可以将唯一键映射到值的结构。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/f547c557bc5b73bb5f9f93e6875ef075.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*PXmqp5Re8nSxcs24U0hmYg.png"/></div></figure><p id="dec2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，哈希表有两个主要组成部分:</p><ol class=""><li id="effc" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jx ju jv jw bi translated"><strong class="ir hi"> <em class="jn">桶数组:</em> </strong> <em class="jn"> </em>哈希表的桶数组是一个大小为N的数组A，其中A的每个单元格都被认为是一个“桶”，即一个键值对的集合。整数N定义了数组的容量。</li><li id="110d" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated"><strong class="ir hi"> <em class="jn"> Hash函数:</em> </strong>它是将我们映射中的每个键k映射到范围[0，n1]内的一个整数的任何函数，其中N是这个表的桶数组的容量。</li></ol><p id="d412" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们将对象放入哈希表时，不同的对象可能有相同的hashcode。这被称为<strong class="ir hi">碰撞</strong>。为了处理冲突，有像链接和开放寻址这样的技术。</p><p id="8a5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些是Java中最基本和最常用的数据结构。现在您已经了解了每一项，可以开始在Java程序中实现它们了。至此，我们已经完成了“Java中的数据结构和算法”这篇文章的第一部分。在下一部分，我们将学习基本算法以及如何在实际应用中使用它们，例如排序和搜索、分治、贪婪算法、动态规划。</p><h1 id="a84c" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的算法</h1><p id="9fd7" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">历史上，算法被用作解决复杂数学计算的工具，它与计算机科学，尤其是数据结构有着密切的联系。<em class="jn">算法是</em> <em class="jn">描述在有限时间内解决特定问题的方法的指令序列。</em>它们有两种表现方式:</p><ul class=""><li id="b657" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">流程图</em> </strong> —算法控制流程的可视化表示</li><li id="ef44" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">伪代码</em> </strong> —它是一种算法的文本表示，近似于最终的源代码</li></ul><p id="64f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">注:</em> </strong> <em class="jn">基于时间复杂度和空间复杂度来衡量算法的性能。大多数情况下，任何算法的复杂性都取决于问题和算法本身。</em></p><p id="ac39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们探讨一下Java中的两大类算法，它们是:</p><ul class=""><li id="c730" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">Java中的排序算法</li><li id="3ba4" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">Java中的搜索算法</li></ul><h1 id="a5d4" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的排序算法</h1><p id="95c4" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">排序算法是将列表元素按一定顺序排列的算法。最常用的顺序是数字顺序和词典顺序。在这篇“数据结构和算法”文章中，让我们探索一些排序算法。</p><h2 id="0ebe" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated"><strong class="ak">Java中的冒泡排序</strong></h2><p id="1eda" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">冒泡排序，通常被称为下沉排序，是最简单的排序算法。它反复遍历要排序的列表，比较每对相邻的元素，如果它们的顺序不对，就交换它们。冒泡排序得名于它过滤掉数组顶部的元素，就像浮在水面上的气泡一样。</p><p id="cc09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表冒泡排序算法的伪代码(升序排序上下文)。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="1083" class="lg ke hh md b fi mh mi l mj mk">a[] is an array of size N<br/>begin BubbleSort(a[])<br/> <br/>declare integer i, j<br/>for i = 0 to N - 1<br/>   for j = 0 to N - i - 1<br/>      if a[j] &gt; a[j+1] then <br/>         swap a[j], a[j+1]<br/>      end if<br/>   end for<br/>  return a<br/>   <br/>end BubbleSort</span></pre><p id="f5e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这段代码将N个数据项的一维数组按升序排序。外部循环在阵列上进行N-1遍。每次传递都使用一个内部循环来交换数据项，使得下一个最小的数据项“冒泡”到数组的开头。但问题是，算法需要一次完整的传递，而没有任何交换，才能知道列表已排序。</p><p id="2b72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">最坏和平均情况时间复杂度:</em> </strong></p><p id="bf6f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">O(n*n)。最坏的情况发生在数组反向排序时。</p><p id="7373" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">最佳情况时间复杂度:</em> </strong></p><p id="9fe2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">O(n)。最好的情况发生在数组已经排序的时候。</p><h1 id="17c1" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的选择排序</h1><p id="86ef" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">选择排序是搜索和排序的结合。该算法通过从未排序的部分中重复查找最小元素(考虑升序)并将其放在数组中的适当位置来对数组进行排序。</p><p id="f23e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表选择排序算法(升序排序上下文)的伪代码。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="fe80" class="lg ke hh md b fi mh mi l mj mk">a[] is an array of size N<br/>begin SelectionSort(a[])<br/> <br/> for i = 0 to n - 1<br/>   /* set current element as minimum*/<br/>      min = i    <br/>      /* find the minimum element */<br/>       for j = i+1 to n <br/>         if list[j] &lt; list[min] then<br/>            min = j;<br/>         end if<br/>      end for<br/>  /* swap the minimum element with the current element*/<br/>      if min != i  then<br/>         swap list[min], list[i]<br/>      end if<br/>   end for<br/>     <br/>end SelectionSort</span></pre><p id="e027" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从代码中可以看出，排序通过数组的次数比数组中的项数少1。内部循环查找下一个最小值，外部循环将该值放入适当的位置。选择排序从不进行超过O(n)次的交换，当内存写操作开销很大时会很有用。</p><p id="2c34" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">时间复杂度:</strong>O(n ^ 2)因为有两个嵌套循环。</p><p id="2c3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">辅助空间:</strong> O(1)。</p><h1 id="b383" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的插入排序</h1><p id="ae51" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">插入排序是一种简单的排序算法，它通过一次消耗一个输入元素来遍历列表，并构建最终的排序数组。它非常简单，在较小的数据集上更有效。这是一种稳定的原位排序技术。</p><p id="b361" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表插入排序算法(升序排序上下文)的伪代码。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="aab9" class="lg ke hh md b fi mh mi l mj mk">a[] is an array of size N<br/>begin InsertionSort(a[])<br/> <br/>for i = 1 to N<br/>   key = a[ i ]<br/>   j = i - 1<br/>   while ( j &gt;= 0 and a[ j ] &gt; key0<br/>      a[ j+1 ] = x[ j ]<br/>      j = j - 1<br/>   end while<br/>   a[ j+1 ] = key<br/>end for<br/> <br/>end InsertionSort</span></pre><p id="3666" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从代码中可以理解，插入排序算法从输入数据中删除一个元素，在排序列表中找到它所属的位置，并将其插入到那里。重复这一过程，直到没有输入元素保持未排序状态。</p><p id="aa8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">最佳情况:</strong>最佳情况是当输入是一个已经排序的数组时。在这种情况下，插入排序具有线性运行时间(即θ(n))。</p><p id="8b68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">最坏情况:</strong>最简单的最坏情况输入是一个逆序排序的数组。</p><h1 id="b669" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的快速排序</h1><p id="86e0" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">快速排序算法是一种快速的、递归的、不稳定的排序算法，其工作原理是分而治之。它选取一个元素作为轴心，并围绕该选取的轴心划分给定的数组。</p><h2 id="a3ef" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated"><strong class="ak">实现快速排序的步骤:</strong></h2><ol class=""><li id="f7e7" class="jo jp hh ir b is lb iw lc ja ml je mm ji mn jm jx ju jv jw bi translated">挑一个合适的“支点”。</li><li id="760c" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">基于此pivot元素将列表分为两个列表。小于pivot元素的每个元素都放在左侧列表中，大于pivot元素的每个元素都放在右侧列表中。如果一个元素等于pivot元素，那么它可以出现在任何列表中。这称为分区操作。</li><li id="3e51" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">递归排序每个较小的列表。</li></ol><p id="3c7a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是代表快速排序算法的伪代码。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="9a41" class="lg ke hh md b fi mh mi l mj mk">QuickSort(A as array, low as int, high as int){<br/>    if (low &lt; high){<br/>        pivot_location = Partition(A,low,high)<br/>        Quicksort(A,low, pivot_location)<br/>        Quicksort(A, pivot_location + 1, high)<br/>    }<br/>}<br/>Partition(A as array, low as int, high as int){<br/>     pivot = A[low]<br/>     left = low<br/> <br/>     for i = low + 1 to high{<br/>         if (A[i] &lt; pivot) then{<br/>             swap(A[i], A[left + 1])<br/>             left = left + 1<br/>         }<br/>     }<br/>     swap(pivot,A[left])<br/> <br/>    return (left)}</span></pre><p id="e8b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的伪代码中，<em class="jn"> partition() </em>函数执行分区操作，<em class="jn"> Quicksort() </em>函数为生成的每个较小的列表重复调用分区函数。快速排序的复杂度在一般情况下是θ(n log(n))在最坏情况下是θ(N2)。</p><h1 id="79e4" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的合并排序</h1><p id="fa43" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">Mergesort是一种快速、递归、稳定的排序算法，它也是按照分治原则工作的。与快速排序类似，合并排序将元素列表分为两个列表。这些列表被独立排序，然后被组合。在组合列表的过程中，元素被插入(或合并)到列表中的正确位置。</p><p id="2ce0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表合并排序算法的伪代码。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="691e" class="lg ke hh md b fi mh mi l mj mk">procedure MergeSort( a as array )<br/>   if ( n == 1 ) return a<br/> <br/>   var l1 as array = a[0] ... a[n/2]<br/>   var l2 as array = a[n/2+1] ... a[n]<br/> <br/>   l1 = mergesort( l1 )<br/>   l2 = mergesort( l2 )<br/> <br/>   return merge( l1, l2 )<br/>end procedure<br/> <br/>procedure merge( a as array, b as array )<br/> <br/>   var c as array<br/>   while ( a and b have elements )<br/>      if ( a[0] &gt; b[0] )<br/>         add b[0] to the end of c<br/>         remove b[0] from b<br/>      else<br/>         add a[0] to the end of c<br/>         remove a[0] from a<br/>      end if<br/>   end while<br/>    <br/>   while ( a has elements )<br/>      add a[0] to the end of c<br/>      remove a[0] from a<br/>   end while<br/>    <br/>   while ( b has elements )<br/>      add b[0] to the end of c<br/>      remove b[0] from b<br/>   end while<br/>    <br/>   return c<br/>     <br/>end procedure</span></pre><p id="e20d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> mergesort() </em>函数将列表一分为二，分别对这些列表调用<em class="jn"> mergesort() </em>，然后将它们作为参数发送给merge()函数进行组合。该算法的复杂度为O(n log (n))，具有广泛的应用前景。</p><h1 id="7c18" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的堆排序</h1><p id="319b" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">Heapsort是一种基于比较的二进制堆数据结构排序算法。你可以把它看作是改进版的f选择排序，它把输入分成一个排序的和一个未排序的区域，通过提取最大的元素并把它移动到排序的区域，迭代地缩小未排序的区域。</p><h2 id="01f2" class="lg ke hh bd kf lh li lj kj lk ll lm kn ja ln lo kr je lp lq kv ji lr ls kz lt bi translated"><strong class="ak">实施快速排序的步骤(按递增顺序):</strong></h2><ol class=""><li id="d505" class="jo jp hh ir b is lb iw lc ja ml je mm ji mn jm jx ju jv jw bi translated">用排序数组构建一个最大堆</li><li id="2fa3" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">此时，最大的项存储在堆的根。用堆的最后一项替换它，并将堆的大小减少1。最后，清理树根</li><li id="584d" class="jo jp hh ir b is jy iw jz ja ka je kb ji kc jm jx ju jv jw bi translated">重复上述步骤，直到堆的大小大于1</li></ol><p id="f4df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表堆排序算法的伪代码。</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="3e17" class="lg ke hh md b fi mh mi l mj mk">Heapsort(a as array)<br/> <br/>for (i = n / 2 - 1) to i &gt;= 0<br/>        heapify(a, n, i); <br/> <br/>    for i = n-1 to 0<br/>        swap(a[0], a[i])<br/>        heapify(a, i, 0); <br/>    end for<br/>end for<br/> <br/>heapify(a as array, n as int, i as int)<br/>    largest = i //Initialize largest as root <br/>    int l eft = 2*i + 1; // left = 2*i + 1 <br/>    int right = 2*i + 2; // right = 2*i + 2 <br/> <br/>    if (left &lt; n) and (a[left] &gt; a[largest])<br/>        largest = left<br/> <br/>    if (right &lt; n) and (a[right] &gt; a[largest])<br/>        largest = right<br/> <br/>    if (largest != i)<br/>        swap(a[i], A[largest])<br/>        Heapify(a, n, largest)<br/>end heapify</span></pre><p id="93af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除此之外，还有其他不太为人所知的排序算法，如Introsort、Counting Sort等。继续这篇“数据结构和算法”文章的下一组算法，让我们探索搜索算法。</p><h1 id="aa05" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的搜索算法</h1><p id="5d62" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">搜索是常规业务应用程序中最常见和最频繁执行的操作之一。搜索算法是用于在项目集合中查找具有指定属性的项目的算法。让我们探索两种最常用的搜索算法。</p><h1 id="b401" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的线性搜索算法</h1><p id="b741" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">线性搜索或顺序搜索是最简单的搜索算法。它包括在给定的数据结构中顺序搜索一个元素，直到找到该元素或到达该结构的末尾。如果找到了元素，则返回该项的位置，否则算法返回NULL。</p><p id="e273" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是代表Java中线性搜索的伪代码:</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="f898" class="lg ke hh md b fi mh mi l mj mk">procedure linear_search (a[] , value)<br/>for i = 0 to n-1<br/>   if a[i] = value then<br/>      print "Found "<br/>      return i<br/>   end if<br/>print "Not found"<br/>end for<br/> <br/>end linear_search</span></pre><p id="ba90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一种暴力算法。虽然它肯定是最简单的，但由于效率低下，它肯定不是最常用的。线性搜索的时间复杂度为<em class="jn"> O(N) </em>。</p><h1 id="4f40" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Java中的二分搜索法算法</h1><p id="3222" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">二分搜索法，也称为对数搜索，是一种在已经排序的数组中查找目标值位置的搜索算法。它将输入集合分成相等的两半，并将条目与列表的中间元素进行比较。如果找到了元素，搜索就在这里结束。否则，我们继续寻找元素，根据目标元素是小于还是大于中间的元素，划分并选择数组的适当分区。</p><p id="d825" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是用Java表示二分搜索法的伪代码:</p><pre class="lv lw lx ly fd mc md me mf aw mg bi"><span id="bbb3" class="lg ke hh md b fi mh mi l mj mk">Procedure binary_search<br/>   a; sorted array<br/>   n; size of array<br/>   x; value to be searched<br/> <br/>    lowerBound = 1<br/>    upperBound = n <br/> <br/>   while x not found<br/>      if upperBound &lt; lowerBound <br/>         EXIT: x does not exists.<br/>    <br/>      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2<br/>       <br/>      if A[midPoint] &lt; x set lowerBound = midPoint + 1 if A[midPoint] &gt; x<br/>         set upperBound = midPoint - 1<br/> <br/>      if A[midPoint] = x <br/>         EXIT: x found at location midPoint<br/>   end while<br/>    <br/>end procedure</span></pre><p id="889c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当上限(我们的指针)经过下限(最后一个元素)时，搜索终止，这意味着我们已经搜索了整个数组，并且该元素不存在。这是最常用的搜索算法，主要是因为它的快速搜索时间。二分搜索法的时间复杂度为<em class="jn"> O(N) </em>，这是对线性搜索的<em class="jn"> O(N) </em>时间复杂度的显著改进。</p><p id="32e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了这篇“Java中的数据结构和算法”文章的结尾。我已经介绍了Java最基本也是最重要的主题之一。希望你清楚这篇文章中与你分享的所有内容。</p><p id="9333" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">确保你尽可能多的练习，恢复你的经验。T9】</p><p id="87a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae mo" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=data-structures-algorithms-in-java" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="2327" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Java的各个方面。</p><blockquote class="mp mq mr"><p id="fb35" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">1.<a class="ae mo" rel="noopener" href="/edureka/object-oriented-programming-b29cfd50eca0">面向对象编程</a></p><p id="b720" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">2.<a class="ae mo" rel="noopener" href="/edureka/inheritance-in-java-f638d3ed559e">Java中的继承</a></p><p id="891a" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">3.<a class="ae mo" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b">Java中的多态性</a></p><p id="9244" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">4.<a class="ae mo" rel="noopener" href="/edureka/java-abstraction-d2d790c09037">Java中的抽象</a></p><p id="322a" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">5.<a class="ae mo" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> Java字符串</a></p><p id="e447" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">6.<a class="ae mo" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> Java数组</a></p><p id="758b" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">7.<a class="ae mo" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> Java集合</a></p><p id="c946" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">8.<a class="ae mo" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> Java线程</a></p><p id="1004" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">9.<a class="ae mo" rel="noopener" href="/edureka/java-servlets-62f583d69c7e">Java servlet简介</a></p><p id="11d0" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">10.<a class="ae mo" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> Servlet和JSP教程</a></p><p id="7db7" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">11.<a class="ae mo" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c">Java中的异常处理</a></p><p id="b2d6" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">12.<a class="ae mo" rel="noopener" href="/edureka/advanced-java-tutorial-f6ebac5175ec">高级Java教程</a></p><p id="1cb8" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">13.<a class="ae mo" rel="noopener" href="/edureka/java-interview-questions-1d59b9c53973"> Java面试问题</a></p><p id="eeb8" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">14.<a class="ae mo" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> Java程序</a></p><p id="8513" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">15.<a class="ae mo" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04"> Kotlin vs Java </a></p><p id="1137" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">16.<a class="ae mo" rel="noopener" href="/edureka/what-is-dependency-injection-5006b53af782">使用Spring Boot的依赖注入</a></p><p id="1667" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">17.<a class="ae mo" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7">Java中的可比性</a></p><p id="89e9" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">18.<a class="ae mo" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39">十大Java框架</a></p><p id="a616" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">19.<a class="ae mo" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> Java反射API </a></p><p id="7303" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">20.Java中的30大模式</p><p id="c36d" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">21.<a class="ae mo" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c">核心Java备忘单</a></p><p id="4146" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">22.<a class="ae mo" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0">Java中的套接字编程</a></p><p id="4266" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">23.<a class="ae mo" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> Java OOP备忘单</a></p><p id="7d78" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">24.<a class="ae mo" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb">Java中的注释</a></p><p id="af85" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">25.<a class="ae mo" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17">Java中的图书管理系统项目</a></p><p id="57d3" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">26.<a class="ae mo" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5">Java中的树</a></p><p id="d5c0" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">27.<a class="ae mo" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368">Java中的机器学习</a></p><p id="2e11" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">28.<a class="ae mo" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> Java教程</a></p><p id="daaa" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">29.<a class="ae mo" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> Java开发者技能</a></p><p id="c8eb" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">30.<a class="ae mo" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d">前55个Servlet面试问题</a></p><p id="c880" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">31.<a class="ae mo" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"> </a> <a class="ae mo" rel="noopener" href="/edureka/java-projects-db51097281e3">顶级Java项目</a></p><p id="c500" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">32.<a class="ae mo" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> Java字符串备忘单</a></p><p id="def2" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">33.<a class="ae mo" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3">Java中的嵌套类</a></p><p id="4cee" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">34.<a class="ae mo" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> Java集合面试问答</a></p><p id="3d97" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">35.<a class="ae mo" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中如何处理死锁？</a></p><p id="123c" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">36.<a class="ae mo" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e">你需要知道的50大Java集合面试问题</a></p><p id="f087" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">37.<a class="ae mo" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf">Java中的字符串池是什么概念？</a></p><p id="405d" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">38.<a class="ae mo" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95">C、C++和Java有什么区别？</a></p><p id="eb45" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">39.<a class="ae mo" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a">Java中的回文——如何检查一个数字或字符串？</a></p><p id="d752" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">40.<a class="ae mo" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e">你需要知道的顶级MVC面试问答</a></p><p id="109c" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">41.<a class="ae mo" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0">Java编程语言的十大应用</a></p><p id="b28c" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><a class="ae mo" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5"> 42。Java中的死锁</a></p><p id="5a33" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">43.<a class="ae mo" rel="noopener" href="/edureka/java-sqrt-method-59354a700571">Java中的平方和平方根</a></p><p id="bb94" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">44.<a class="ae mo" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1">Java中的类型转换</a></p><p id="91ba" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">45.<a class="ae mo" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a">Java中的运算符及其类型</a></p><p id="b77d" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">46.<a class="ae mo" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc">Java中的析构函数</a></p><p id="2860" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">47.<a class="ae mo" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3">爪哇的二分搜索法</a></p><p id="7cf4" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">48.<a class="ae mo" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684">Java中的MVC架构</a></p><p id="b57d" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">49.<a class="ae mo" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8">冬眠面试问答</a></p></blockquote></div><div class="ab cl mv mw go mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ha hb hc hd he"><p id="add6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2019年7月19日</em><a class="ae mo" href="https://www.edureka.co/blog/data-structures-algorithms-in-java/" rel="noopener ugc nofollow" target="_blank"><em class="jn">https://www.edureka.co</em></a><em class="jn">。</em></p></div></div>    
</body>
</html>