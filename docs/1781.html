<html>
<head>
<title>Using Apple’s Main Thread Checker Tool on UI Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在UI测试中使用苹果的主要线程检测工具</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-apples-main-thread-checker-tool-on-ui-tests-a89508bcd524?source=collection_archive---------5-----------------------#2021-03-01">https://medium.com/capital-one-tech/using-apples-main-thread-checker-tool-on-ui-tests-a89508bcd524?source=collection_archive---------5-----------------------#2021-03-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9a69" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用主线程检测器工具运行UI测试时识别主线程问题</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/756e3e2e24e6e9b3ef7923bd03dbfee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*daauCFrJ9WH3eKxb.png"/></div></div></figure><p id="7149" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">UI渲染是一项复杂且昂贵的操作。它需要对如此多的对象及其状态进行同步和并发处理，从性能的角度来看，有必要确保只从单个队列中执行操作。</p><p id="6380" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">引用作者<a class="ae ke" href="https://twitter.com/steipete" rel="noopener ugc nofollow" target="_blank"> Peter Steinberger </a>关于线程安全类设计的伟大文章中关于UIKit为什么不是固有线程安全的内容:</p><blockquote class="kf kg kh"><p id="cd41" class="ji jj ki jk b jl jm ii jn jo jp il jq kj js jt ju kk jw jx jy kl ka kb kc kd ha bi translated"><em class="hh">“不使UIKit成为线程安全的是苹果方面有意识的设计决定。就性能而言，让它成为线程安全不会给你带来太多好处；事实上，这会使许多事情变得更慢。UIKit与主线程绑定的事实使得编写并发程序和使用UIKit变得非常容易。你所要做的就是确保对UIKit的调用总是在主线程上进行。</em></p></blockquote><p id="73b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，UIKit(和app kit)API必须总是从主线程调用。否则，您的应用程序很可能会出现意外行为。</p><h1 id="ef7b" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">防止主线程违规</h1><p id="00de" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">假设您想要添加一个简单的方法来在代码库中的主线程上执行代码。在调用UIKit API的地方，它大概会这样写。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/c1e2f68e778e1267f72f3d339bac713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhYYJt-2uahbAClZ4tdHDQ.jpeg"/></div></div></figure><p id="7856" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于显而易见的原因，这将很快成为一种负担，并极大地膨胀您的代码库。幸运的是，苹果有一个<a class="ae ke" href="https://developer.apple.com/documentation/xcode/diagnosing_memory_thread_and_crash_issues_early" rel="noopener ugc nofollow" target="_blank">主线程检测器(MTC)工具</a>可以派上用场。</p><h1 id="7396" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">什么是主线程检测器？</h1><p id="7268" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">主线程检查器(MTC)是一个运行时工具，当应该在主线程上进行的系统API调用(如UI操作)在后台线程上被错误调用时，它会抛出警告。</p><h1 id="84ec" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">启用MTC</h1><p id="aafc" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">为你的应用启用MTC非常简单。只需打开诊断选项卡中的<em class="ki">主线程检测器</em>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/516d8e5cd1495097c0e9070b0158ab06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUS-BVn494AZgnOPIrdtmg.jpeg"/></div></div></figure><p id="5e78" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从这一点开始，每当您运行您的应用程序并且发生主线程冲突时，控制流将命中一个断点，让您知道发生了冲突。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/87b397245cb1b071d7918edfac15dc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nTCoejCThU7DkuVfMdMTg.jpeg"/></div></div></figure><h1 id="2fac" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">在UI测试中使用MTC</h1><p id="257e" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">在运行UI测试时打开MTC可以使您的UI测试为您检测这些违规，因为只有当您在运行时执行特定的代码路径时，才能检测到MTC违规。</p><p id="8eff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为您的UI测试启用MTC可以像在您的应用程序方案中打开主线程检查器选项一样简单。或者，您可以用几行代码以编程方式完成。</p><h1 id="e032" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">驻留在同一项目或工作区中的UI测试</h1><p id="7619" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">如果你的UI测试和你的应用程序位于同一个工作区，那么你可以简单地在你的应用程序的方案中勾选<em class="ki">主线程检测器</em>的复选框，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/94091f3f2f19d3bbb370d31e551c7963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h49IdaeWw_Tg6zjoFS5YFg.jpeg"/></div></div></figure><p id="1b3c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当执行UI测试时，Xcode将编译您的应用程序，并在启用MTC的情况下启动它。</p><h1 id="f16d" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">驻留在不同项目或工作区中的UI测试</h1><p id="6fdc" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">如果您的UI测试是在一个单独的项目或工作区中进行的，那么上述方法将不起作用。相反，此配置中的测试不会使用应用程序的方案设置来启动应用程序。</p><p id="e8b4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了在这个场景中启用MTC，我们需要在从UI测试工作区启动应用程序时注入我们的MTC enable标志。</p><p id="1bd8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">浏览<a class="ae ke" href="https://developer.apple.com/documentation/xcode/diagnosing_memory_thread_and_crash_issues_early" rel="noopener ugc nofollow" target="_blank">苹果文档</a>让我们对Xcode如何支持MTC有所了解:</p><p id="3558" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ki">以上dylib的路径(来自苹果的文档)是针对macOS的。对于iOS模拟器的不同版本/操作系统，我们需要动态设置dylib的路径。</em></p><p id="8d24" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，我们可以通过为架构找到正确的<em class="ki">libmainthreadchecker . dylib</em>来启用MTC，然后在启动应用程序时注入它。</p><h2 id="9a2a" class="lk kn hh bd ko ll lm ln ks lo lp lq kw jr lr ls ky jv lt lu la jz lv lw lc lx bi translated">因为主线程检测器不要求您重新编译代码，所以您可以在现有的macOS二进制文件上运行它</h2><p id="8266" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">将位于<code class="du ly lz ma mb b">/Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib</code>的动态库注入到可执行文件中。</p><h2 id="4d76" class="lk kn hh bd ko ll lm ln ks lo lp lq kw jr lr ls ky jv lt lu la jz lv lw lc lx bi translated">找到libMainThreadChecker.dylib的正确路径</h2><p id="4fcb" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">从<a class="ae ke" href="https://www.freebsd.org/cgi/man.cgi?query=dyld&amp;apropos=0&amp;sektion=0&amp;manpath=Darwin+8.0.1%2Fppc&amp;format=html" rel="noopener ugc nofollow" target="_blank"> dyld手册页</a> <strong class="jk hi"> : </strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/d0447248d86c967439d10e09a4c87566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFKQmRHJX40_WdiQ4BiSbg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx"><a class="ae ke" href="https://www.freebsd.org/copyright/freebsd-doc-license/" rel="noopener ugc nofollow" target="_blank">Copyright 1994–2021 The FreeBSD Project. All rights reserved.</a></figcaption></figure><p id="56e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在启动时，操作系统注入<strong class="jk hi"> DYLD_ROOT_PATH </strong>作为环境变量的一部分。这可以用来找到相关的<em class="ki">mainthreadchecker . dylib .</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/42bb4f69efa2f4ee519003a376df866b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wusr2EMSBFaL_SaZ813D6w.png"/></div></div></figure><h2 id="6efa" class="lk kn hh bd ko ll lm ln ks lo lp lq kw jr lr ls ky jv lt lu la jz lv lw lc lx bi translated">发布时在应用中注入DYLIBs</h2><p id="c1e6" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">你可以通过使用<strong class="jk hi"> DYLD_INSERT_LIBRARIES </strong>在你的应用中注入一个dylib。</p><p id="9f06" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">来自<a class="ae ke" href="https://www.freebsd.org/cgi/man.cgi?query=dyld&amp;apropos=0&amp;sektion=0&amp;manpath=Darwin+8.0.1%2Fppc&amp;format=html" rel="noopener ugc nofollow" target="_blank"> dyld手册页</a>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/6d6a8419ea760bfc97fcf0c08b94d19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3ajctkHxrKYtQpia-TYNw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx"><a class="ae ke" href="https://www.freebsd.org/copyright/freebsd-doc-license/" rel="noopener ugc nofollow" target="_blank">Copyright 1994–2021 The FreeBSD Project. All rights reserved.</a></figcaption></figure><p id="03f4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">结合以上两者，我们可以在从UI测试中启动SUT应用程序时注入MTC dylib，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/3bf964a1fe8af4b69820edc45db4cff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emA3ieEYjbjzl_ryYcBnEg.jpeg"/></div></div></figure><p id="ad95" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">请注意，当在独立于你的应用程序的UI测试上运行MTC时，它似乎不会工作，因为调试器没有连接到你的应用程序。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/87b397245cb1b071d7918edfac15dc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nTCoejCThU7DkuVfMdMTg.jpeg"/></div></div><figcaption class="mc md et er es me mf bd b be z dx"><em class="mh">(The above will not occur if your app is not attached to the debugger, which is the case when the UI Tests and your app project are in different workspaces.)</em></figcaption></figure><p id="69f9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">处理这种情况的一个有用的技巧是当这种违规发生时使你的应用崩溃。要实现这一点，只需将<strong class="jk hi"> MTC_CRASH_ON_REPORT </strong>传递给环境变量。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/b5b8c002a67aff33975ffe9d42d53dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKUQSCbSUs0QqYMsHIq2Uw.jpeg"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">(<em class="mh">From an extremely insightful </em><a class="ae ke" href="https://bryce.co/main-thread-checker-configuration/" rel="noopener ugc nofollow" target="_blank"><em class="mh">article</em></a><em class="mh"> from Bryce Pauken where he lists a few hidden/poorly documented, but useful MTC features</em>)</figcaption></figure><h1 id="ce7e" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">结论</h1><p id="7e45" class="pw-post-body-paragraph ji jj hh jk b jl le ii jn jo lf il jq jr lg jt ju jv lh jx jy jz li kb kc kd ha bi translated">UIKit API本质上不是线程安全的，这给开发人员清理所有ui kit API调用站点增加了额外的负担。这个问题在大型代码库中尤其严重，在大型代码库中有几个异步回调并不少见。主线程检测器工具可以帮助减轻一些风险。理解如何使用MTC将允许您更有效地使用UIKit APIs。</p></div><div class="ab cl mi mj go mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ha hb hc hd he"><p id="8a05" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ki">披露声明:2021资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="9613" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" href="https://www.freepik.com/vectors/technology" rel="noopener ugc nofollow" target="_blank"> <em class="ki">科技矢量</em> </a> <em class="ki">由故事创作—</em><a class="ae ke" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"><em class="ki">【www.freepik.com】</em></a></p></div></div>    
</body>
</html>