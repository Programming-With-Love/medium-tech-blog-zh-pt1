<html>
<head>
<title>Flyweight Structural Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻量级结构设计模式</h1>
<blockquote>原文：<a href="https://medium.com/globant/flyweight-structural-design-pattern-b62b56b0a764?source=collection_archive---------1-----------------------#2022-12-01">https://medium.com/globant/flyweight-structural-design-pattern-b62b56b0a764?source=collection_archive---------1-----------------------#2022-12-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/95dceb2dec8168a1d380412c6076043e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9iqSPIFWOkMvYqal"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@joelft?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joel Fulgencio</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b81c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">当需要创建许多相似性质的对象时，使用<a class="ae it" href="https://en.wikipedia.org/wiki/Flyweight_pattern" rel="noopener ugc nofollow" target="_blank"> Flyweight模式</a>。它提供了通过共享对象来减少内存占用和提高性能的解决方案，因为许多对象会消耗大量内存。</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><h1 id="6f6c" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">图案本身</h1><p id="2486" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">Flyweight是一种结构设计模式，它通过在多个对象之间共享状态的公共部分，而不是将所有数据保存在每个对象中，让我们可以将更多的对象放入可用的RAM中。</p><p id="eb4c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是与这种设计模式相关的正在使用的例子。</p><ul class=""><li id="dd0f" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated">在浏览器中，我们可以在网页的多个位置使用一个图像。浏览器将只加载图像一次，在其他时候，浏览器将重用缓存中的图像。现在图像是相同的，但是在多个地方使用。它的URL是一个固有属性，因为它是固定的和可共享的。图像的位置坐标、高度和宽度是外在的属性，根据它们必须呈现的上下文而变化。</li><li id="d495" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">英寸NET中，我们可以将Flyweight设计模式与由<a class="ae it" href="https://learn.microsoft.com/en-us/dotnet/standard/clr" rel="noopener ugc nofollow" target="_blank"> CLR </a>(公共语言运行时)维护的实习生池联系起来，后者包含程序中的文字字符串。这确保了在我们的代码中重复使用相同的常量字符串将使用相同的字符串引用。<code class="du lz ma mb mc b">System.String</code>类提供了一个<code class="du lz ma mb mc b">Intern</code>方法，确保一个字符串在实习生池中，并返回它的引用。</li></ul></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><h1 id="dd1f" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">UML中的Flyweight</strong></h1><p id="10b8" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">下面的UML图代表了Flyweight设计模式。</p><figure class="me mf mg mh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/cd73d935f89518699eb2be5501f19298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqm0k-Pnq3vgeddNCNfEqA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">UML Diagram of the Flyweight Design Pattern</figcaption></figure><p id="2891" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按照Flyweight设计模式的UML图，我们可以在下面找到这个模式中使用的术语的描述。</p><ul class=""><li id="a0ca" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated"><code class="du lz ma mb mc b">Flyweight</code>接口支持共享，但并不将其作为实现该接口的具体对象来实施，无论是共享的还是非共享的。</li><li id="b7ff" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><code class="du lz ma mb mc b">ConcreteFlyweight</code>类实现了<code class="du lz ma mb mc b">Flyweight</code>接口，并为固有状态增加了存储。</li><li id="c72a" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><code class="du lz ma mb mc b">unsharedConcreteFlyweight</code>类还实现了<code class="du lz ma mb mc b">Flyweight </code>接口，并为不共享的实例增加了存储空间。</li><li id="9a8c" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><code class="du lz ma mb mc b">FlyweightFactory </code>有<code class="du lz ma mb mc b">GetFlyweight</code>方法，我们要传递这个方法的密钥。将根据键检查flyweight对象是否在缓存中。如果存在，那么它将返回现有flyweight对象。如果不存在，它将创建一个新的flyweight对象，将该对象添加到缓存中，并返回该flyweight对象。</li></ul><p id="2f54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是Flyweight设计模式的状态。</p><ul class=""><li id="b720" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated"><strong class="iw hi">内在:</strong>这些是不变的东西，储存在记忆里。</li><li id="5a6c" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><strong class="iw hi">外在的:</strong>这些东西不是常数，需要即时计算，因此不会存储在内存中。</li></ul></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><h1 id="04c8" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">c#中的一个例子</strong></h1><p id="8d7a" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">下面是该示例的缓存表示。</p><figure class="me mf mg mh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/15e86d9e2897685fa512d954f1aa7ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_f3WBW3IRA8xJ5rBO9I3w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Cache Representation of the Example.</figcaption></figure><p id="f39c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们正在构建一个小型游戏应用程序来代表银河系中的恒星和行星。在游戏过程中，每颗星星和行星都将被客户端应用程序定位。恒星和行星的特征如下:</p><ul class=""><li id="dff3" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated">所有的恒星和行星都将是天体。</li><li id="67f8" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">星星的颜色是蓝色的，行星的颜色是红色的。</li><li id="c9d5" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">运行时，客户端将提供星星的位置和亮度。</li><li id="483e" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">客户端可以创建大量的恒星和行星对象。</li><li id="a895" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">该应用程序将在移动应用程序中使用，内存(RAM)是一个主要的限制。</li></ul><p id="56b6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按照要求，让我们首先把恒星和行星物体的属性结合成内在和外在状态。</p><ul class=""><li id="557a" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated"><strong class="iw hi">内禀天体:</strong>这些数值在所有恒星和行星天体中都是通用的，不会改变。星星的颜色总是蓝色的，行星的颜色是红色的，它们的形状是固定的。</li><li id="14e3" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated"><strong class="iw hi">外部对象:</strong>这些值将由客户端在运行时提供，并且在恒星和行星对象中是唯一的。我们将研究恒星和行星的位置和亮度。</li></ul><p id="7876" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> IGalaxy.cs </strong>:这是一个接口，定义了操纵对象外在状态的方法。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="5353" class="mn kj hh mc b be mo mp l mq mr">public interface IGalaxy<br/>    {<br/>        void SetBrightness(double brightness);<br/>        void SetPosition(int x, int y);<br/>    }</span></pre><p id="a3d7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> AstronomicalObject.cs: </strong>这是一个表示恒星和行星物体固有状态的类。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="2dbd" class="mn kj hh mc b be mo mp l mq mr">public class AstronomicalObject<br/>    {<br/>        private readonly int height;<br/>        private readonly int width;<br/>        private readonly string color;<br/>        public AstronomicalObject(int height, int width, string color)<br/>        {<br/>            this.height = height;<br/>            this.width = width;<br/>            this.color = color;<br/>        }<br/>    }</span></pre><p id="3a2f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">AstronomicalObjectType:</strong>枚举定义了天文对象的类型。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="b6d9" class="mn kj hh mc b be mo mp l mq mr">public enum AstronomicalObjectType<br/>    {<br/>        Star,<br/>        Planet<br/>    }</span></pre><p id="3681" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> Planet.cs: </strong>这个类表示Planet对象，实现IGalaxy接口来操作外部状态。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="a449" class="mn kj hh mc b be mo mp l mq mr"> public class Planet : IGalaxy<br/>    {<br/>        public static AstronomicalObject PlanetShape = new AstronomicalObject(30, 30, "red"); // Intrinsic State<br/>        // These are the extrinsic states<br/>        int positionX;<br/>        int positionY;<br/>        double brightness;<br/>        public void SetBrightness(double brightness)<br/>        {<br/>            this.brightness = brightness;<br/>        }<br/>        public void SetPosition(int x, int y)<br/>        {<br/>            positionX = x;<br/>            positionY = y;<br/>        }<br/>        public override string ToString()<br/>        {<br/>            return string.Format($"A Planet located at [{positionX},{positionY}] coordinate and is having a brigtness of [{brightness}]%");<br/>        }<br/>    }</span></pre><p id="241c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Star.cs :这是一个表示星星对象的类，它还实现了IGalaxy接口，允许客户端操纵外在状态，比如亮度和星星的位置。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="9ec4" class="mn kj hh mc b be mo mp l mq mr">  public class Star : IGalaxy<br/>    {<br/>        public static AstronomicalObject StarShape = new AstronomicalObject(10, 10, "blue"); // Intrinsic State<br/>        // These are the extrinsic states<br/>        int positionX;<br/>        int positionY;<br/>        double brightness;<br/>        public void SetBrightness(double brightness)<br/>        {<br/>            this.brightness = brightness;<br/>        }<br/>        public void SetPosition(int x, int y)<br/>        {<br/>            positionX = x;<br/>            positionY = y;<br/>        }<br/>        public override string ToString()<br/>        {<br/>            return string.Format($"A Star located at [{positionX},{positionY}] coordinate and is shining with [{brightness}]% brightness");<br/>        }<br/>    }</span></pre><p id="8f0c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> GalaxyFactory: </strong>这是一个工厂类，它维护行星对象的字典，如果它有一个引用，就为客户机创建一个新的字典，然后将它返回给客户机。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="6709" class="mn kj hh mc b be mo mp l mq mr"> public class GalaxyFactory<br/>    {<br/>        private static Dictionary&lt;AstronomicalObjectType, IGalaxy&gt; astronomicalObjects = new Dictionary&lt;AstronomicalObjectType, IGalaxy&gt;();<br/>        public static IGalaxy GetAstronomicalObject(AstronomicalObjectType planetoryObject)<br/>        {<br/>            if (astronomicalObjects.ContainsKey(planetoryObject))<br/>                return astronomicalObjects[planetoryObject];<br/>            else<br/>            {<br/>                IGalaxy NewObject = null;<br/>                if (planetoryObject == AstronomicalObjectType.Star)<br/>                {<br/>                    NewObject = new Star();<br/>                    astronomicalObjects.Add(AstronomicalObjectType.Star, NewObject);<br/>                }<br/>                else<br/>                {<br/>                    NewObject = new Planet();<br/>                    astronomicalObjects.Add(AstronomicalObjectType.Planet, NewObject);<br/>                }<br/>                return NewObject;<br/>            }<br/>        }<br/>    }</span></pre><p id="9ded" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> Client.cs: </strong>这是使用GalaxyFactory和IGalaxy接口与对象交互的客户端应用程序。</p><pre class="me mf mg mh fd mj mc mk bn ml mm bi"><span id="2c3e" class="mn kj hh mc b be mo mp l mq mr">class Client<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            IGalaxy star = GalaxyFactory.GetAstronomicalObject(AstronomicalObjectType.Star);<br/>            star.SetBrightness(10);<br/>            star.SetPosition(20, 80);<br/>            Console.WriteLine(star);<br/>            IGalaxy planet = GalaxyFactory.GetAstronomicalObject(AstronomicalObjectType.Planet);<br/>            planet.SetBrightness(67);<br/>            planet.SetPosition(120, 85);<br/>            Console.WriteLine(planet);<br/>            IGalaxy star2 = GalaxyFactory.GetAstronomicalObject(AstronomicalObjectType.Star);<br/>            star2.SetBrightness(65);<br/>            star2.SetPosition(67, 23);<br/>            Console.WriteLine(star2);<br/>        }<br/>    }</span></pre><h2 id="eecc" class="ms kj hh bd kk mt mu mv ko mw mx my ks jf mz na kw jj nb nc la jn nd ne le nf bi translated"><strong class="ak">输出</strong></h2><p id="ed10" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">下面是我们代码实现的输出。</p><figure class="me mf mg mh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ng"><img src="../Images/f683fc67b089ad8e1478cea2e6149a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvR3kO49LKY-CeBkrnAnfA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Application Output</figcaption></figure></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><h1 id="29d4" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">何时使用Flyweight设计模式</strong></h1><p id="257a" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">下面是我们可以使用这种设计模式的一些原因。</p><ul class=""><li id="0f5b" class="ll lm hh iw b ix iy jb jc jf ln jj lo jn lp jr lq lr ls lt bi translated">需要很多类似的对象，存储成本高。</li><li id="9c96" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">大多数状态可以保存在磁盘上或在运行时计算。</li><li id="0e7c" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">每个对象的大部分状态数据都可以是外部的。</li><li id="9758" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">几个共享的对象很容易取代许多非共享的对象。</li><li id="6364" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">每个对象的身份并不重要。</li></ul><p id="f0c5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是这种模式的优点和缺点，这也有助于决定何时以及是否使用它。</p><h2 id="a735" class="ms kj hh bd kk mt mu mv ko mw mx my ks jf mz na kw jj nb nc la jn nd ne le nf bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="883a" class="ll lm hh iw b ix lg jb lh jf nh jj ni jn nj jr lq lr ls lt bi translated">Flyweight模式通过减少对象的数量来提高应用程序的性能。</li><li id="3d48" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">Flyweight模式减少了内存占用并节省了RAM，因为公共属性是使用内在属性在对象之间共享的。</li></ul><h2 id="1f3c" class="ms kj hh bd kk mt mu mv ko mw mx my ks jf mz na kw jj nb nc la jn nd ne le nf bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="cf58" class="ll lm hh iw b ix lg jb lh jf nh jj ni jn nj jr lq lr ls lt bi translated">如果一个对象没有可共享的属性，这个模式就没有用了。</li><li id="91b3" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">如果内存不是问题，那么实现Flyweight设计对应用程序来说可能是多余的。</li><li id="efd3" class="ll lm hh iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">该模式引入了代码复杂性。</li></ul></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><h1 id="59c1" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">结论</strong></h1><p id="a3f1" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">本文告诉我们Flyweight设计模式如何通过共享相似的对象来提高性能和减少内存占用。</p></div></div>    
</body>
</html>