<html>
<head>
<title>Living without Null</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有空虚的生活</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/living-without-null-da9b695c908b?source=collection_archive---------0-----------------------#2018-04-07">https://blog.kotlin-academy.com/living-without-null-da9b695c908b?source=collection_archive---------0-----------------------#2018-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6c50ca33c99a24d70aa5d5168afde8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*reNh2_WGq-CqM41O."/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image credit <a class="ae jz" href="https://unsplash.com/@jesuskiteque?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jesus Kiteque</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="475a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">写代码时，我们通常可以避免使用<code class="fe ky kz la lb b">null</code>。它代表一种状态。</p><p id="17d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Kotlin中，有许多方法可以避免使用null。在本文中，我们将展示如何避免使用<code class="fe ky kz la lb b">null</code>来表示<em class="lc">空</em>状态。</p><p id="7fc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，链表的典型Java定义是</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Typical Java implementation of a linked list node</figcaption></figure><p id="a7e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个Java实现中，<code class="fe ky kz la lb b">null</code>代表空列表。使用<code class="fe ky kz la lb b">null</code>有效。然而，我们招致了与使用空值相关的所有危险。空指针异常是使用<code class="fe ky kz la lb b">null</code>的一个危险。有没有更好的办法？让我们探索科特林。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="a505" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Kotlin可以模拟链表的Java实现:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Kotlin implementation of a Java linked list node.</figcaption></figure><p id="d2d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像它的Java对应物一样，这种实现是有代价的。它使用可空的<code class="fe ky kz la lb b">LinkedList&lt;T&gt;?</code>。我们能进一步改进我们的代码吗？答案是肯定的。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="ad7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<code class="fe ky kz la lb b">data class </code>中移除可空类型<code class="fe ky kz la lb b">LinkedList&lt;T&gt;?</code>的一个简单方法是从代码中移除问号:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Impractical Kotlin definition of a linked list</figcaption></figure><p id="546b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第3行的<code class="fe ky kz la lb b">data class</code>定义不切实际。此外，第6行和第7行不会编译。第3行表示任何链表都有一个有效负载<code class="fe ky kz la lb b">T</code>和对另一个非空链表的引用。换句话说，链表的长度是无限的。</p><p id="3a19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的定义有错误。它不考虑空列表。让我们如下定义一个链表:</p><p id="a733" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">链表可以是:</p><ol class=""><li id="33b2" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">具有两个属性的节点:类型为<code class="fe ky kz la lb b">T</code>的非空负载和非空链表；或者</li><li id="af94" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated">终端对象。</li></ol><p id="f832" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用一个<code class="fe ky kz la lb b">sealed class</code>来强制一个链表要么是类型1要么是类型2 <em class="lc">，仅此而已</em>。首先，让我们定义一下<code class="fe ky kz la lb b">Node&lt;T&gt;</code>:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">sealed class definition with Node&lt;T&gt;</figcaption></figure><p id="b7b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们会用科特林的<code class="fe ky kz la lb b">object</code>来定义<code class="fe ky kz la lb b">Terminal</code>，因为所有的<code class="fe ky kz la lb b">Terminals</code>都是一样的。<code class="fe ky kz la lb b">Terminal</code>是独生子。</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">complete sealed class definition of a linked list</figcaption></figure><p id="d63d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了方便起见，<code class="fe ky kz la lb b">next</code>属性的默认值为<code class="fe ky kz la lb b">Terminal</code>。见第4行。我们可以在不使用<code class="fe ky kz la lb b">Terminal</code>对象的情况下编写一个<code class="fe ky kz la lb b">LinkedList </code>。见第9行。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="b6b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们探索一下链表定义的一些实际应用。例如，我们可以将<code class="fe ky kz la lb b">toString()</code>方法定义如下:</p><ol class=""><li id="1090" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">如果<code class="fe ky kz la lb b">LinkedList</code>是一个<code class="fe ky kz la lb b">Node&lt;T&gt;</code>，那么返回<code class="fe ky kz la lb b">payload</code>和<code class="fe ky kz la lb b">next</code>的连接。</li><li id="341c" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated">如果<code class="fe ky kz la lb b">LinkedList</code>是一个<code class="fe ky kz la lb b">Terminal</code>，那么返回空字符串。</li></ol><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">toString definition of a linked list</figcaption></figure><p id="fe4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尺寸是另一个例子。尺寸的定义是:</p><ol class=""><li id="ca45" class="lq lr in kc b kd ke kh ki kl ls kp lt kt lu kx lv lw lx ly bi translated">如果<code class="fe ky kz la lb b">LinkedList</code>是一个<code class="fe ky kz la lb b">Node&lt;T&gt;</code>，那么大小就是1加上节点的<code class="fe ky kz la lb b">next</code>属性的大小。</li><li id="7b91" class="lq lr in kc b kd lz kh ma kl mb kp mc kt md kx lv lw lx ly bi translated">如果<code class="fe ky kz la lb b">LinkedList</code>是一个<code class="fe ky kz la lb b">Terminal</code>，那么大小为零。</li></ol><p id="76b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用Kotlin的<code class="fe ky kz la lb b">when</code>作为表达式，我们可以递归地定义大小为</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">recursive implementation of size()</figcaption></figure><p id="dd14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将链表定义为一个<code class="fe ky kz la lb b">sealed class</code>。所以，第1行中的<code class="fe ky kz la lb b">when</code>是一个表达式。如果<code class="fe ky kz la lb b">when</code>是一个表达式，那么<code class="fe ky kz la lb b">when</code>一定是穷举的:<code class="fe ky kz la lb b">Node&lt;T&gt;</code>和<code class="fe ky kz la lb b">Terminal</code>。</p><p id="2dc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为替代，我们可以将<code class="fe ky kz la lb b">sizeRecursively()</code>的定义放在<code class="fe ky kz la lb b">sealed class</code>中:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">sizeRecursively() defined within the sealed class</figcaption></figure><p id="d618" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">功能<code class="fe ky kz la lb b">sizeRecursively()</code>可能不是很高效。它不是尾递归的。所以，<code class="fe ky kz la lb b">sizeIteratively()</code>的迭代实现可能更好:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">iterative definition of size()</figcaption></figure></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="b385" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经表明<code class="fe ky kz la lb b">null</code>代表一种状态。使用空值会带来危险，比如空指针异常。我们已经展示了我们可以通过使用一个<code class="fe ky kz la lb b">sealed class</code>来枚举一个链表的所有可能的状态。</p><p id="18d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过使用<code class="fe ky kz la lb b">sealed class</code>作为对象所有可能状态的枚举，代码不使用<code class="fe ky kz la lb b">null</code>。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="2ae5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae jz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae jz" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>在medium上关注我们。</p><figure class="ld le lf lg gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi me"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">喜欢的话记得<strong class="kc io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p></div></div>    
</body>
</html>