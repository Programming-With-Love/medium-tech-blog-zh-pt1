<html>
<head>
<title>Adapt your app for the latest privacy best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的应用适应最新的隐私最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/adapt-your-app-for-the-latest-privacy-best-practices-d7469a547314?source=collection_archive---------0-----------------------#2020-09-10">https://medium.com/androiddevelopers/adapt-your-app-for-the-latest-privacy-best-practices-d7469a547314?source=collection_archive---------0-----------------------#2020-09-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/de14acf6439dcd8e0639d02dd4c04976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mzx-wzsHjrpKtCJjG0sXwA.jpeg"/></div></div></figure><div class=""/><p id="af89" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android 11最终发布是<a class="ae jn" href="https://android-developers.googleblog.com/2020/09/android11-final-release.html" rel="noopener ugc nofollow" target="_blank">这里是</a>！这个版本建立在以前版本的隐私改进的基础上，为用户提供了更好的控制和透明度，以及帮助应用程序负责任地处理数据的护栏。</p><p id="638e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些改进中的许多都加强了适用于最近Android版本的现代最佳实践(它们并不特定于Android 11！).在本文中，我们将研究其中的4个最佳实践，以帮助您的设计经得起未来的考验，并为兼容性测试用例进行规划。</p><ol class=""><li id="b6b5" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">处理内容URI共享</li><li id="1ccc" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">增量权限请求</li><li id="f858" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">前台敏感数据访问</li><li id="d85e" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">使用可重置标识符</li></ol><p id="f7d8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">给予其他应用适当的URI权限。</strong></p><p id="1478" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着Android 11中<a class="ae jn" href="https://developer.android.com/preview/privacy/package-visibility" rel="noopener ugc nofollow" target="_blank">包可见性</a>的改变，默认情况下，针对<strong class="ir ht"> API级别30 </strong>的应用对设备上其他已安装包的可见性将受到限制。这旨在为应用程序提供更好的问责制，以“查看”设备上的其他包。</p><p id="61d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了简化迁移，为常见用例提供了一个<a class="ae jn" href="https://developer.android.com/preview/privacy/package-visibility-use-cases" rel="noopener ugc nofollow" target="_blank">实施指南</a>。一般来说，一个应用程序必须对其他已安装的包可见(使用<code class="du kc kd ke kf b"><a class="ae jn" href="https://developer.android.com/reference/android/content/pm/PackageManager" rel="noopener ugc nofollow" target="_blank">PackageManager</a></code> API验证),以便与它们交互。例如，这适用于启动服务或从属于另一个应用程序的内容提供商处读取内容。</p><p id="76c3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您的内容提供商的访问模型可能涉及发送一个隐式意图，而不是针对给定包的显式意图。因此，您的设计无法假设接收应用程序的目标API级别，该级别决定了应用程序是否受Android 11上的包可见性限制。</p><p id="fe60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了确保接收应用程序可以看到您的包，从而可以访问任何共享的URIs，您需要在意向中包含<code class="du kc kd ke kf b">FLAG_GRANT_READ_URI_PERMISSION </code>和/或<code class="du kc kd ke kf b">FLAG_GRANT_WRITE_URI_PERMISSION</code> URI标志。注意，写权限<strong class="ir ht">并不意味着读访问。一旦被意向触发，接收应用程序将被授予临时访问URIs的权限。</strong></p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="aaa4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您计划更新应用的目标SDK版本(甚至是Android 11之前的版本)时，请注意涉及与另一个应用共享内容提供商访问权限的情况，并确保授予适当的URI权限。不管内容提供商的所有者是谁，这都是适用的。</p><p id="624c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将数据访问级别限制在手头任务所需的范围内通常是一种好的做法。理想情况下，你的内容提供者应该已经拥有个人<a class="ae jn" href="https://developer.android.com/guide/topics/manifest/provider-element#gprmsn" rel="noopener ugc nofollow" target="_blank"> URI模式</a>的适当共享权限。如果是这样，你的内容提供商已经兼容Android 11了！</p><p id="c9ac" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">增量请求权限。</strong></p><p id="c9ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这项<a class="ae jn" href="https://research.google/pubs/pub46261/" rel="noopener ugc nofollow" target="_blank"> Android用户研究</a>显示，如果请求符合用户的期望，用户更有可能给予许可。因此，当应用程序中的某个功能需要权限时，最好<a class="ae jn" href="https://developer.android.com/training/permissions/requesting" rel="noopener ugc nofollow" target="_blank">请求上下文中的权限</a>。</p><p id="d871" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="km">顶级用户权限授予原因。来源:</em> <a class="ae jn" href="https://research.google/pubs/pub46261/" rel="noopener ugc nofollow" target="_blank"> <em class="km">安卓用户研究</em> </a> <em class="km">。</em></p><figure class="kg kh ki kj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kn"><img src="../Images/3cd1d9196e0b2ad29c500459ff628ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ype5k-a-T-yCQXV"/></div></div></figure><p id="be48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这尤其适用于位置访问等敏感权限。自Android 10以来，该平台引入了一种细粒度的位置模型，可以区分前台和后台的位置访问。大多数位置用例只需要前台访问，比如当用户参与一项活动时。</p><p id="5665" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实上，Google Play有一个<a class="ae jn" href="https://support.google.com/googleplay/android-developer/answer/9799150" rel="noopener ugc nofollow" target="_blank">政策</a>限制不必要的后台位置访问。要检查您的应用程序可能在哪里访问后台位置，<a class="ae jn" href="https://developer.android.com/training/location/background" rel="noopener ugc nofollow" target="_blank">请查看此清单</a>。如果您的应用程序需要背景位置，例如地理围栏用例，请确保这对您的功能至关重要。</p><p id="f9b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于适用的应用程序，他们应该首先请求前台位置，然后再请求后台位置。这种方法为用户提供了控制权限授予级别的选项。此外，您可以有策略地显示解释或设计适当的UX，以提供关于用户如何从授予附加位置权限中受益的附加上下文。</p><figure class="kg kh ki kj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ko"><img src="../Images/7166840bb7043beb80dd8be63cc05757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zr-mfyJG4PfcLyf2"/></div></div></figure><p id="b3c4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android 11对目标为<strong class="ir ht"> API级别30 </strong>的应用强制执行增量位置许可请求。任何包含<strong class="ir ht">前台位置(精细或粗略)和后台位置权限的权限请求都将被忽略，并导致以下错误消息。</strong></p><p id="bcd4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kc kd ke kf b">E/GrantPermissionsActivity: Apps targeting 30 must have foreground permission before requesting background and must request background on its own.</code></p><p id="c98d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="km">注意，同一个</em> <code class="du kc kd ke kf b"><em class="km">requestPermissions()</em></code> <em class="km"> API调用中的任何其他非位置权限也将被忽略。</em></p><p id="44eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du kc kd ke kf b">requestPermissions</code> API将一组权限作为输入参数，您可能已经有了演示以下模式的代码。我们鼓励您在必要时审核和设计一个替代的用户流。</p><p id="3a27" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果使用了<code class="du kc kd ke kf b">ActivityCompat</code>或框架API:</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="a7c8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，如果使用Jetpack活动库:</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="9de9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">正确使用位置、麦克风和摄像机。</strong></p><p id="1fad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android的设计鼓励在访问敏感数据(如麦克风、摄像头和位置)时保持透明。例如，应用程序只能在前台使用麦克风和摄像头，例如当用户可以看到用户界面时。这提高了透明度，因此用户可以在启用相关功能时做出明智的决定。</p><p id="f6d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你的应用有访问敏感数据的前台服务，确保用例涉及直接的用户交互，用户可以控制正在执行的任务。例如，在视频会议应用程序中，您可以使用前台服务来支持涉及麦克风和摄像机访问的活动会议会话。还应该有一个启示，让用户开始和停止会话，从而前台服务。</p><p id="06f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，您的应用程序必须正确设置<code class="du kc kd ke kf b">foregroundServiceType</code>属性，以指示位置、麦克风或摄像头的使用。这为需要数据的应用提供了系统可见性，并且是针对Android 11的应用的要求。了解更多关于<a class="ae jn" href="https://developer.android.com/preview/privacy/foreground-services" rel="noopener ugc nofollow" target="_blank">前台服务变更</a>。</p><p id="ba96" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在清单中声明多种数据类型的用法。</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="8bae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的实现是基于<code class="du kc kd ke kf b">WorkManager</code>中的<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/long-running" rel="noopener ugc nofollow" target="_blank">长期运行的worker </a>，那么它实际上是由一个名为<code class="du kc kd ke kf b">SystemForegroundService</code>的前台服务支持的。您应该在您的应用程序清单中包含适当的前台服务类型，该清单将与Jetpack库的AAR <a class="ae jn" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/work/workmanager/src/main/AndroidManifest.xml?source=post_page---------------------------%2F%2F%2F%2F%2F%2F&amp;autodive=0%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F" rel="noopener ugc nofollow" target="_blank">清单文件</a>合并。</p><p id="7c60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过定义适当的前台服务类型，将此元素包含在您的应用程序清单中。</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="c1f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您提升worker作为前台服务运行时，您需要将适当的前台服务类型传递到<code class="du kc kd ke kf b">ForegroundInfo</code>对象中。这些类型必须与上面的合并清单中定义的类型相同，或者是它们的子集。</p><figure class="kg kh ki kj fd hj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="f637" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">迁移掉不可重置的标识符。</strong></p><p id="5590" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android系统使用许多不可重置的硬件标识符，如IMEI，来支持各种操作系统功能。出于隐私考虑，这些标识符的持久性和唯一性使它们不适合大多数身份识别用例。</p><p id="6318" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/about/versions/10/privacy/changes#data-ids" rel="noopener ugc nofollow" target="_blank">从Android 10 </a>开始，系统对各种不可重置的标识符的访问受到限制。例如，只有拥有<code class="du kc kd ke kf b">READ_PRIVILEGED_PHONE_STATE </code>权限的特权系统应用程序才能通过<code class="du kc kd ke kf b"><a class="ae jn" href="https://developer.android.com/reference/android/telephony/TelephonyManager#getSimSerialNumber()" rel="noopener ugc nofollow" target="_blank">getSimSerialNumber()</a></code>方法访问SIM卡硬件标识符。在Android 11中，系统通过对<code class="du kc kd ke kf b"><a class="ae jn" href="https://developer.android.com/reference/android/telephony/SubscriptionInfo#getIccId()" rel="noopener ugc nofollow" target="_blank">getIccId()</a></code>方法应用类似的限制，进一步<a class="ae jn" href="https://developer.android.com/about/versions/11/behavior-changes-all#privacy" rel="noopener ugc nofollow" target="_blank">限制访问</a>，现在返回一个空字符串。</p><p id="0be9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以前可能利用该标识符将功能链接到某个SIM的应用程序应该验证与Android 11上的“空字符串”返回值的兼容性。一种替代方法是使用<code class="du kc kd ke kf b"><a class="ae jn" href="https://developer.android.com/reference/android/telephony/SubscriptionInfo#getSubscriptionId()" rel="noopener ugc nofollow" target="_blank">getSubscriptionId()</a></code>方法，该方法返回设备上给定SIM的从1开始的唯一索引值。也就是说，如果在设备上重新安装相同的SIM，它将保留先前分配的订购标识符，除非设备是出厂重置的。<a class="ae jn" href="https://developer.android.com/training/articles/user-data-ids#mobile-service-subscriptions" rel="noopener ugc nofollow" target="_blank">了解更多</a>。</p><p id="5d8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该平台和Google Play服务提供了许多具有各种唯一性、可重置性和适用于各种用例的范围的<a class="ae jn" href="https://developer.android.com/training/articles/user-data-ids#identifier-characteristics" rel="noopener ugc nofollow" target="_blank">标识符</a>。你可以查看更多的标识符<a class="ae jn" href="https://developer.android.com/training/articles/user-data-ids" rel="noopener ugc nofollow" target="_blank">用例</a>。</p><p id="cd36" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这些建议有助于你准备目标API级别的更新，并使你的应用程序设计更加隐私友好！你可以在文档中了解更多关于Android 11 和<a class="ae jn" href="https://developer.android.com/privacy/best-practices" rel="noopener ugc nofollow" target="_blank">隐私最佳实践</a>的其他<a class="ae jn" href="https://developer.android.com/about/versions/11/privacy" rel="noopener ugc nofollow" target="_blank">相关改进。</a></p><p id="0d63" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="km">感谢凯文·赫夫纳格尔和杰里米·沃克。</em></p></div></div>    
</body>
</html>