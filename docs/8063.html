<html>
<head>
<title>Priority-Based Connected Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于优先级的连通分量</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/priority-based-connected-components-8b762fda7d2f?source=collection_archive---------7-----------------------#2021-09-29">https://medium.com/walmartglobaltech/priority-based-connected-components-8b762fda7d2f?source=collection_archive---------7-----------------------#2021-09-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0dd9" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">具有边优先级和大小限制的细化连通分量</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/f32d680eec0b85ce8e552f1244c87882.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*_Rxk2qXFf1tyaJDy4Qt3rw.png"/></div><figcaption class="je jf et er es jg jh bd b be z dx">Source: Picture by <a class="ae ji" href="https://www.freepik.com/macrovector" rel="noopener ugc nofollow" target="_blank">Macrovector</a> on <a class="ae ji" href="https://www.freepik.com/free-vector/glowing-network-sign_1528929.htm" rel="noopener ugc nofollow" target="_blank">Freepik</a></figcaption></figure><p id="ba62" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi kf translated">图形理论是对图形的研究，图形是用来模拟对象之间成对关系的数学结构。图由节点/顶点和边组成。节点表示图形数据中的实体，而边表示节点之间的关系。</p><p id="32b7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">节点可以是城市、商品/产品或实体(图中的<strong class="jl hi">绿色</strong>点)。边(图中<strong class="jl hi">绿色</strong>点之间的<strong class="jl hi">线</strong>是链接这些节点的关系，比如节点可以是产品，产品之间的边可以是它们的类别。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ko"><img src="../Images/e668d6682c8ebbfaaeee0a98078a652a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*dqmKTVWUFEbEdd-pmulHBQ.png"/></div><figcaption class="je jf et er es jg jh bd b be z dx">Graph-Structure</figcaption></figure><h2 id="08d0" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">连接组件并需要对其进行优化</h2><p id="9633" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">在图论中，无向图的一个分支是一个子图，其中任意两个顶点通过路径相连，并且在图的其余部分不与任何额外的顶点相连。广度优先搜索或深度优先搜索用于在线性时间内计算图的组件。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lp"><img src="../Images/df4cfbad76118b0e57643d9d2cbdf4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*uJTF-_6oLXxv1a1VmXl3NQ.png"/></div><figcaption class="je jf et er es jg jh bd b be z dx">Source: Wikipedia, Graph with three connected-components</figcaption></figure><p id="eec5" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">到目前为止，我们已经看到了图形和连通分量。在许多领域中利用连通分量算法来根据链接边连接实体。连接的组件在<a class="ae ji" href="https://en.wikipedia.org/wiki/Computer_vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>中具有它们的应用，用于<a class="ae ji" href="https://en.wikipedia.org/wiki/Connected-component_labeling" rel="noopener ugc nofollow" target="_blank">区域检测/斑点提取</a>。在<a class="ae ji" href="https://en.wikipedia.org/wiki/Topological_sorting" rel="noopener ugc nofollow" target="_blank">拓扑排序</a>中，连接的组件也用于解决问题，如根据给定的依赖关系安排作业。连接组件也可用于<a class="ae ji" href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)" rel="noopener ugc nofollow" target="_blank">检测图中的循环</a>并解决金融部门的循环支付或洗钱等问题。</p><p id="cfec" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">虽然这绝对是一个非常有用的算法，但有时我们看到有必要改进算法，以调整边的优先级并限制组件的大小。让我列出几个可以实现这一点的场景，并阐明我们所说的优先级和限制组件大小的含义。</p><h2 id="f392" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">场景-1</h2><p id="dd49" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">对于零售公司来说，可能需要对相似的商品进行分组，以便在缺货的情况下为客户提供更好的商品替代选择。为此，我们需要定义相似项目的组。被认为是一个组的项目可以由下面的标准来定义。</p><ol class=""><li id="ccb7" class="lq lr hh jl b jm jn jp jq js ls jw lt ka lu ke lv lw lx ly bi translated">项目描述相似性(优先级-1，最高优先级)</li><li id="ff8b" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">类别描述相似性和定价相似性(优先级-2)</li><li id="4455" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">部门描述相似性和购买模式相似性(优先级-3，优先级最低)</li></ol><blockquote class="me mf mg"><p id="53dd" class="jj jk mh jl b jm jn ii jo jp jq il jr mi jt ju jv mj jx jy jz mk kb kc kd ke ha bi translated">项目可以通过上述任何一个标准进行链接，但优先选择通过优先级标准链接项目。除此之外，还可以有额外的约束，例如一个组中最多有“X”个项目(避免组变得太宽或太笨重)，以及一个项目只能是一个组的一部分(确保组是互斥的)。</p></blockquote><p id="bdb1" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果我们使用限制为“X”(当大小达到“X”时断开连接组件)的普通连接组件算法，如<a class="ae ji" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank"> DFS </a>(深度优先搜索)或<a class="ae ji" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank"> BFS </a>(广度优先搜索)，我们可能会以异构组结束，即部门内跨类别的许多项目可能会被链接。我们需要尽量减少这种情况，并优化确定的优先事项。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ml"><img src="../Images/19673e231c5d82f1bc5053352c368bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*tyc4Ldw2R2FhhvES"/></div><figcaption class="je jf et er es jg jh bd b be z dx">Product from <a class="ae ji" href="https://www.walmart.com/ip/Garanimals-Baby-Toddler-Girls-Unicorn-Mix-N-Match-Kid-Pack-Gift-Box-10-Piece-Outfit-Set-12-Months-5T/122624760?athcpid=122624760&amp;athpgid=athenaItemPage&amp;athcgid=null&amp;athznid=PWVUB&amp;athieid=v0&amp;athstid=CS020&amp;athguid=3702ca5f-007-17bb5af72f5add&amp;athancid=null&amp;athena=true" rel="noopener ugc nofollow" target="_blank">walmart.com</a></figcaption></figure><h2 id="2c54" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">其他场景</h2><p id="6cda" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">在客户服务中心也会出现类似的用例，在那里，公司根据他们的技能和定义的优先级来分配服务代理。上述场景是<a class="ae ji" href="https://getawesomesupport.com/documentation/smart-agent-assignment/smart-agent-assignment-algorithms/%29" rel="noopener ugc nofollow" target="_blank">智能代理分配</a>问题的类型。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mm"><img src="../Images/20b9c7adc5e5ef7b6f29117bacfb5415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/0*tj0n-XLVdhvhv0ZI.jpg"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">Picture on <a class="ae ji" href="https://www.freepik.com/free-vector/organic-flat-customer-support-illustration_13184981.htm" rel="noopener ugc nofollow" target="_blank">Freepik</a></figcaption></figure><blockquote class="mr"><p id="5833" class="ms mt hh bd mu mv mw mx my mz na ke dx translated">在上面的场景中，我们看到需要运行连接的组件，但是首先连接具有较高优先级边的实体，然后移动到较低优先级的实体。此外，除此之外，每个群体都需要有一个规模限制。</p></blockquote><p id="644b" class="pw-post-body-paragraph jj jk hh jl b jm nb ii jo jp nc il jr js nd ju jv jw ne jy jz ka nf kc kd ke ha bi translated">为了解决上述类似的分析挑战，我们提出了一种算法来调整边的优先级并限制组件的大小。</p><h2 id="49f0" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">基于优先级的连通分量算法细节</h2><ol class=""><li id="91b3" class="lq lr hh jl b jm lk jp ll js ng jw nh ka ni ke lv lw lx ly bi translated">该算法为用户提供了一个选项来输入节点的访问顺序，“T6”visit _ order。如果用户没有提供任何顺序，节点将按照图中输入边的顺序被访问。</li><li id="08c7" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">该算法以降序迭代优先级，即(优先级1 &gt;优先级2 &gt; …&gt;优先级n)。在每次迭代中，在步骤1中定义的“visit_order”中选择节点。</li><li id="b462" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">对于节点'<em class="mh"> X </em>'，与其具有优先级'<em class="mh"> p' </em>'的相邻节点(此节点与'<em class="mh"> X </em>'之间存在一条边)进行并运算(连接节点)，使得'<em class="mh"> p </em>'为当前最高优先级。这是使用<a class="ae ji" href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="noopener ugc nofollow" target="_blank">不相交集联合</a>数据结构有效完成的。可能在某个点，'<em class="mh">' X '</em>和邻居不是单独的节点，而是子图。在这种情况下，两个子图将合并，成为一个组件的一部分。</li><li id="5526" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">如果“<em class="mh"> X </em>”没有边连接优先级为“<em class="mh"> p </em>的邻居，则移动到“<em class="mh"> visit_order </em>中的下一个节点。</li><li id="14be" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">访问完所有节点后，执行第-3步和第-4步，获取下一个最高优先级。</li><li id="584d" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated">如果在任何阶段组件中的元素数量达到阈值(默认值= 100，可由用户修改)，则该组件将不会有任何更多的更改/链接。</li></ol><pre class="ix iy iz ja fd nj nk nl nm aw nn bi"><span id="37a7" class="kp kq hh nk b fi no np l nq nr">for priority in priorities:<br/>    for X in visit_order:<br/>        for Y in neighbour_of_X:<br/>            if edge_priority[X,Y] == priority:<br/>                Union(X,Y)</span></pre></div><div class="ab cl ns nt go nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ha hb hc hd he"><p id="38dc" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们通过一个例子来看看这个算法是如何工作的。此处的阈值设置为3，限制了组件的大小。虚线边缘表示相关的链接和优先级。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nz"><img src="../Images/c6e383df41442ca7ea876b96f7eb5098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtIhdwKa6SjS42ux7ciV7g.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">Graph and Linkages, Threshold=3</figcaption></figure><p id="3263" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在第一次迭代中，所有具有优先级为-1的边的节点被连接起来。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nz"><img src="../Images/11504ac9efc7c5d620e68ec0e2c068b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0hhBSyG_diGKfI50lPNJQ.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">1–4 and 5–9 gets connected</figcaption></figure><p id="4b7e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在下一次迭代中，该算法连接优先级为-2的节点和它们之间的边。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es oa"><img src="../Images/767fc10e3f6bf2265f0b18786a3b4b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zO_kI4BL1c8Z6ESA2tdXVA.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx">1–4–8 gets connected, 2–3–6 gets connected and both reach the threshold</figcaption></figure><p id="2933" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">当达到组件的阈值且不再有边缘时，算法停止。以上是具有设定阈值和提供边缘优先级的最终连接组件。</p><h1 id="fbae" class="ob kq hh bd kr oc od oe kv of og oh kz in oi io lc iq oj ir lf it ok iu li ol bi translated">我们可以利用的开源库</h1><p id="0c21" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">我们已经将这项工作开源到了<a class="ae ji" href="https://github.com/walmartlabs" rel="noopener ugc nofollow" target="_blank">沃尔玛公共GitHub </a>。这里是<a class="ae ji" href="https://github.com/walmartlabs/priorityY" rel="noopener ugc nofollow" target="_blank">项目库</a>的链接。</p><div class="om on ez fb oo op"><a href="https://github.com/walmartlabs/priorityY" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">GitHub — walmartlabs/priorityY:基于优先级的连接组件</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">在许多情况下，我们看到需要运行连接的组件，但首先，连接优先级更高的实体…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jc op"/></div></div></a></div><p id="6dea" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们还发布了pypi.org的库<a class="ae ji" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"/>作为可安装pip的软件包，可以在这里下载<a class="ae ji" href="https://pypi.org/project/priorityY/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6fd2" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">装置</h2><pre class="ix iy iz ja fd nj nk nl nm aw nn bi"><span id="744e" class="kp kq hh nk b fi no np l nq nr">pip install priorityY</span></pre><h2 id="e59c" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">使用</h2><p id="71a9" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">如果我们要使用<a class="ae ji" href="https://pypi.org/project/priorityY/" rel="noopener ugc nofollow" target="_blank"> priorityY包</a>实现前面显示的示例，那么我们将使用以下语法。</p><pre class="ix iy iz ja fd nj nk nl nm aw nn bi"><span id="2bde" class="kp kq hh nk b fi no np l nq nr">from priorityY import *<br/>G = [(1,4,1),(1,5,3),(2,3,2),(2,6,2),(6,7,3),(4,8,2),(5,9,1)]<br/>threshold = 3<br/>components = priority_based_linkage(G,threshold)<br/>print(components)</span></pre><h2 id="0685" class="kp kq hh bd kr ks kt ku kv kw kx ky kz js la lb lc jw ld le lf ka lg lh li lj bi translated">输出</h2><pre class="ix iy iz ja fd nj nk nl nm aw nn bi"><span id="a575" class="kp kq hh nk b fi no np l nq nr">[[1, 4, 8], [2, 3, 6], [5, 9], [7]]</span></pre><p id="b702" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">节点的<em class="mh">访视顺序</em>为可选参数。该算法以递减的顺序迭代优先级，并且在每次迭代中，如果按照图中输入边的顺序提供其他选项，则以“<em class="mh"> visit_order </em>的顺序选择节点。</p><pre class="ix iy iz ja fd nj nk nl nm aw nn bi"><span id="b0d4" class="kp kq hh nk b fi no np l nq nr"># visit_order provided<br/>components = priority_based_linkage(G,threshold,[3,4,1,5,2,9,8,7,6])</span></pre><div class="om on ez fb oo op"><a href="https://pypi.org/project/priorityY/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">优先权</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">它将一个整数作为输入，并将其打印为正方形。从优先级导入的pip安装优先级* G =…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">pypi.org</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd jc op"/></div></div></a></div><h1 id="389f" class="ob kq hh bd kr oc od oe kv of og oh kz in oi io lc iq oj ir lf it ok iu li ol bi translated">利益实现</h1><p id="59e3" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">在我们的一个数据科学应用程序中，我们使用现有的基于DFS的方法对基于优先级的连接算法进行了基线化，该方法被设计为当达到阈值时停止连接节点，而不考虑优先级。我们计算了3个指标，并发现每个指标都有显著改善。</p><ol class=""><li id="011a" class="lq lr hh jl b jm jn jp jq js ls jw lt ka lu ke lv lw lx ly bi translated"><em class="mh">质量增益百分比</em>:该指标计算连接组件的质量改进百分比。在形成连通分量中起作用的高优先级边的数量越多，质量就越高。</li><li id="b279" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated"><em class="mh">每个组件的平均质量增益百分比</em>:这个度量计算每个组件的百分比改进，并取所有组件的质量增益百分比的平均值。</li><li id="e951" class="lq lr hh jl b jm lz jp ma js mb jw mc ka md ke lv lw lx ly bi translated"><em class="mh">达到阈值的组件数量的百分比减少</em>:我们想要最小化明确达到阈值的组件数量。</li></ol><h1 id="de2d" class="ob kq hh bd kr oc od oe kv of og oh kz in oi io lc iq oj ir lf it ok iu li ol bi translated">结论</h1><p id="8daf" class="pw-post-body-paragraph jj jk hh jl b jm lk ii jo jp ll il jr js lm ju jv jw ln jy jz ka lo kc kd ke ha bi translated">这篇博文着眼于连通组件的改进版本，它考虑了边的优先级，并根据用例需求限制了组件的大小。</p><p id="cd42" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们已经将该功能公开为一个<a class="ae ji" href="https://pypi.org/project/priorityY/" rel="noopener ugc nofollow" target="_blank">开源包</a>，可以在工作中使用。<a class="ae ji" href="https://github.com/walmartlabs/priorityY" rel="noopener ugc nofollow" target="_blank">源代码</a>也可供团队在需要时扩展功能。我要感谢我的团队<a class="pf pg ge" href="https://medium.com/u/d9a59eaeb7f3?source=post_page-----8b762fda7d2f--------------------------------" rel="noopener" target="_blank"> Pravesh Garg </a>、<a class="pf pg ge" href="https://medium.com/u/7665d86d0f5f?source=post_page-----8b762fda7d2f--------------------------------" rel="noopener" target="_blank"> Somedip Karmakar </a>和<a class="pf pg ge" href="https://medium.com/u/90cea4f6b9df?source=post_page-----8b762fda7d2f--------------------------------" rel="noopener" target="_blank"> Subhasish Misra </a>在构思和验证工作的整个过程中一直在那里。此外，我们非常感谢我们的工程同行在管道方面给予我们的帮助，并使该功能在Dashboard上可用。</p><p id="bf0b" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">感谢Oscar Blass、Cory Stegemoller和Meriah Montondo帮助我们完成开源过程。</p><h1 id="90fa" class="ob kq hh bd kr oc od oe kv of og oh kz in oi io lc iq oj ir lf it ok iu li ol bi translated">参考</h1><div class="om on ez fb oo op"><a href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">图论</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">在数学中，图论是对数学结构的研究，这些数学结构用于模拟成对关系…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">en.wikipedia.org</p></div></div><div class="oy l"><div class="ph l pa pb pc oy pd jc op"/></div></div></a></div><div class="om on ez fb oo op"><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">不相交集数据结构</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">在计算机科学中，不相交集数据结构，也称为联合查找数据结构或合并查找集，是一种…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">en.wikipedia.org</p></div></div><div class="oy l"><div class="pi l pa pb pc oy pd jc op"/></div></div></a></div><div class="om on ez fb oo op"><a href="https://en.wikipedia.org/wiki/Component_%28graph_theory%29" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">组件(图论)</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">在图论中，无向图的一个分支是一个诱导子图，其中任意两个顶点都连接到…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">en.wikipedia.org</p></div></div><div class="oy l"><div class="pj l pa pb pc oy pd jc op"/></div></div></a></div><div class="om on ez fb oo op"><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">不相交集合联合(联合查找)— Prateek Garg</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">算法的效率有时取决于使用有效的数据结构。一个很好的数据结构选择…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">www.hackerearth.com</p></div></div><div class="oy l"><div class="pk l pa pb pc oy pd jc op"/></div></div></a></div><div class="om on ez fb oo op"><a href="https://www.geeksforgeeks.org/disjoint-set-data-structures/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab dw"><div class="or ab os cl cj ot"><h2 class="bd hi fi z dy ou ea eb ov ed ef hg bi translated">不相交的集合数据结构— GeeksforGeeks</h2><div class="ow l"><h3 class="bd b fi z dy ou ea eb ov ed ef dx translated">考虑一个有几个人的情况，以及要对他们执行的以下任务。添加新的友谊…</h3></div><div class="ox l"><p class="bd b fp z dy ou ea eb ov ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="oy l"><div class="pl l pa pb pc oy pd jc op"/></div></div></a></div></div></div>    
</body>
</html>