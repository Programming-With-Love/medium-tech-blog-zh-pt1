<html>
<head>
<title>Amazon SageMaker Model Endpoint Access from Oracle JET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Oracle JET访问Amazon SageMaker模型端点</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/amazon-sagemaker-model-endpoint-access-from-oracle-jet-e4ca9370cfab?source=collection_archive---------0-----------------------#2018-11-13">https://medium.com/oracledevs/amazon-sagemaker-model-endpoint-access-from-oracle-jet-e4ca9370cfab?source=collection_archive---------0-----------------------#2018-11-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="22bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你用亚马逊SageMaker 实现机器学习模型，显然你会想知道如何从外部访问训练好的模型。AWS机器学习博客上有一篇很好的文章与这个主题相关<a class="ae jc" href="https://aws.amazon.com/blogs/machine-learning/call-an-amazon-sagemaker-model-endpoint-using-amazon-api-gateway-and-aws-lambda/" rel="noopener ugc nofollow" target="_blank"> —使用亚马逊API网关和AWS Lambda </a>调用亚马逊SageMaker模型端点。我完成了描述的步骤，并为自己的模块实现了REST API。我更进一步，测试了用<a class="ae jc" href="https://www.oracle.com/webfolder/technetwork/jet/index.html" rel="noopener ugc nofollow" target="_blank"> Oracle JET </a> JavaScript免费开源工具包实现的JavaScript应用程序的API调用。</p><p id="f098" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我不会深入研究机器学习部分。我将专门关注AWS SageMaker端点。我用的是本书第二章的Jupyter笔记本— <a class="ae jc" href="https://www.manning.com/books/machine-learning-for-business" rel="noopener ugc nofollow" target="_blank">商业机器学习</a>。在笔记本的最后，当机器学习模型被创建时，我们初始化AWS端点(名称:<em class="jd">订单批准</em>)。把它想象成某种接入点。通过这个端点我们可以调用预测函数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/395e60d06384115e108c2469547fcba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hF8OWktFxn1UHHm6YG8k-g.png"/></div></div></figure><p id="a8cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等待大约5分钟，直到终点开始。然后，您应该在SageMaker中看到端点条目:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jq"><img src="../Images/5032e5a74e9c16271ba4c14d8ff83aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXWWhza7EKxKdgy17fKatg.png"/></div></div></figure><p id="b9c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如何公开端点以供外部访问？通过AWS Lambda和AWS API网关。</p><p id="654d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动气象站λ</p><p id="5962" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">转到AWS Lambda服务并创建新功能。我已经有了函数，Python 3.6设置为运行时。AWS Lambda充当端点和API之间的代理函数。在将输入数据返回给API之前，我们可以在这里准备输入数据并解析响应:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jq"><img src="../Images/299530605fe590727541616e7cd90519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFNR-gcTrVWaewhWBPMonQ.png"/></div></div></figure><p id="624e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">必须授予函数角色才能访问SageMaker资源:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jr"><img src="../Images/ac4a1baf18cc3a5e49cbcd9c5e52bd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hw8kAcjAxbtVImvnXAT0FQ.png"/></div></div></figure><p id="280c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是函数实现。端点名称被移出到环境变量中。函数获取输入，调用SageMaker端点，并对响应做一些最小的处理:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es js"><img src="../Images/43eb3b117f46a277111816b7d318788b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awZo1lHQZM0_zoIj6PDtbA.png"/></div></div></figure><p id="2dc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以测试lambda函数并提供测试有效载荷。这是我正在使用的测试载荷。这是机器学习模型的编码参数列表。描述采购订单的参数。模型决定是否需要人工批准。决策规则—如果采购订单由非IT部门的人员提出，但他们订购了IT产品，则需要人工批准。在上面提到的书中可以读到更多关于它的内容。测试有效载荷数据:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jt"><img src="../Images/ad6a78a217c24c08abd4c3821a8fa2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_r1Qgq7rKayl7whUO5L4Q.png"/></div></div></figure><p id="e72f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行测试执行，模型响应—需要手动批准采购订单:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es js"><img src="../Images/6e17a6e03c75f48151ab29f4c13087c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkZ-GOfEScx71Puvu8VOFQ.png"/></div></div></figure><p id="64e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AWS API网关</p><p id="6332" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一步是定义API网关。客户端将通过API调用Lambda函数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ju"><img src="../Images/76055edeed367c97e0478586165d3353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lh3LlZ6h4PYMnsSUvrqOWg.png"/></div></div></figure><p id="dd75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经为API网关定义了REST资源和POST方法。客户端请求将通过API调用，然后被定向到Lambda函数，该函数将根据客户端输入数据调用SageMaker预测:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/b5178ad6e7ff2cbc7bf8337241dea746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zt7aSMvg6SpwlwJpXfw-vw.png"/></div></div></figure><p id="b584" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">POST方法被设置为调用Lambda函数(上面创建了具有此名称的函数):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/3e16e198cf6d22ff9716f659b97c99ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xchTvXodkEwYO5Giy5HsIg.png"/></div></div></figure><p id="a126" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦部署了API，我们就获得了URL。确保在末尾添加REST资源名称。在Oracle JET中，我们可以使用简单的JQuery调用来执行POST方法。一旦收到异步响应，我们将显示通知消息:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jx"><img src="../Images/457e9ca60f22c251a8aac90d40a62456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-51-T4jF9R-ffNk9XqSSw.png"/></div></div></figure><p id="7202" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle JET显示从SageMaker收到的预测—当前PO需要人工审核:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jy"><img src="../Images/176e71db8289c5936065b54838e38757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5o0OTU1znHIQWl4bw21iKQ.png"/></div></div></figure><p id="e184" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从my <a class="ae jc" href="https://github.com/abaranovskis-redsamurai/amazonsagemakerjet" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo下载带有AWS SageMaker API调用的Oracle JET示例应用程序。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><p id="ae7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd">原载于2018年11月13日</em><a class="ae jc" href="https://andrejusb.blogspot.com/2018/11/amazon-sagemaker-model-endpoint-access.html" rel="noopener ugc nofollow" target="_blank"><em class="jd">【andrejusb.blogspot.com</em></a><em class="jd">。</em></p></div></div>    
</body>
</html>