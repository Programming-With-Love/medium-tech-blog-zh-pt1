<html>
<head>
<title>Building an Unbounded Channel in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建无界通道</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd?source=collection_archive---------0-----------------------#2017-05-08">https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd?source=collection_archive---------0-----------------------#2017-05-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="fd87" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在Go上发布一系列中的一个</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/d0512028f7a6431dd3804ae572ac3316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVwhiCvFneKCqgW0f3n4yw.jpeg"/></div></div></figure><p id="a37b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go中的并发性建立在三个相互依赖的特性之上:goroutines、通道和select语句。当然，也有像<em class="ke"> sync这样的帮手。等待组</em>和<em class="ke">同步。Once </em>使并发变得更简单。此外，在幕后你有标准的底层特性，比如互斥、conds和atomics。但当人们在Go中解决并发问题时，他们大多是在看goroutines、channels和selects。让我们进一步探索渠道。</p><p id="b9db" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通道有两种类型:<em class="ke">缓冲</em>和<em class="ke">非缓冲</em>。默认的无缓冲通道将值从一个goroutine传递到另一个go routine，一次传递一个。写入通道块的goroutine，直到另一个goroutine从同一通道中读取。如果读操作发生在写操作之前，读操作会阻塞，直到通道中有数据为止。</p><p id="16f0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">缓冲通道给了作者更多的灵活性。缓冲通道时，可以将一定数量的值写入通道，但在通道阻塞之前不会读取这些值。它的行为就像一个大小有限的同步队列。</p><p id="cb0c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是，如果您希望一个goroutine能够在不等待读取器的情况下写入无限量的数据，该怎么办呢？缓冲通道似乎提供了一个解决方案，因为它们允许一个goroutine继续写，而不需要等待另一个goroutine读取。问题是缓冲通道总是有界的；如果您以这种方式使用缓冲通道，您可能(并且可能最终)会遇到一个点，在这个点上，正在编写的goroutine被阻塞，等待一个读者。这就留下了一个问题:<strong class="jk hi"> <em class="ke">我如何创建一个从不阻塞通道写入的编写器？</em>T11】</strong></p><p id="fb5e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个问题比看起来要难。由于Go不会自动在缓冲通道中存储无限量的数据，我们需要在写入通道和读取通道之间放置一个中介。这带来了一些限制。</p><p id="d0c8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先是我们受限于类型<strong class="jk hi"> <em class="ke">接口{} </em> </strong>的通道。这是因为我们不能在Go中编写自己的通用函数，我们需要编写一个函数来提供功能。Go社区中关于泛型的争论由来已久，我们不打算在这里重新讨论这个问题，而只是探索什么是有效的。</p><p id="b3ff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第二个限制是我们需要把我们的单通道变成两个通道。因为Go不允许操作符重载，所以无法将我们的功能隐藏在返回单个通道的重载的 <em class="ke"> make </em> 函数之后，我们需要返回两个通道，一个是我们写入的通道(让我们调用这个通道)，另一个通道用于从我们的无界通道读取(让我们调用这个通道)。</p><p id="7fdb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然可以有多个out通道的读取器和多个in通道的写入器，但是我们需要实施一些限制:</p><ul class=""><li id="7f8b" class="kg kh hh jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated">您无法从in通道中读取</li><li id="1818" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated">您不能写入输出通道</li><li id="bdf8" class="kg kh hh jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated">你不能关闭输出频道</li></ul><p id="6b08" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">做这些事情中的任何一件都会破坏无界的通道语义，并可能引发恐慌。</p><p id="3f48" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑到这些要求，这里有一个建议的函数签名:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ku"><img src="../Images/a45d14f3aa874212ae20aa51477a8b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFQVeKwv2c5guBH-LtvPGg.png"/></div></div></figure><p id="bce3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的函数将不接受任何内容，并返回两个通道。我们不需要任何输入参数，因为只有一种可能的通道类型，<strong class="jk hi"><em class="ke">{ }</em></strong>。第一个输出参数是只写(可关闭)的输入通道，第二个输出参数是只读的输出通道。通过在返回的通道上使用通道方向标记，我们可以防止用户执行会破坏我们的无界通道的操作。这为我们的用户消除了错误的来源。</p><h1 id="98b9" class="kv kw hh bd kx ky kz la lb lc ld le lf in lg io lh iq li ir lj it lk iu ll lm bi translated"><strong class="ak">试验台</strong></h1><p id="6f18" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">在我们写代码之前，我们应该写一个测试来告诉我们代码是否工作正常。我们将使用以下代码测试我们的功能:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ls"><img src="../Images/06cae69ac8e5705c0d95ea25c3805c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDY9bgJ7BqPWfUNX_S-R0g.png"/></div></div></figure><p id="8409" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这段代码发送100个值，从0到99，然后确保它们以正确的顺序从另一端出来。它不<em class="ke">而</em>确保写和读是异步的。为了做到这一点，我们需要一个减慢书写速度的测试和一个减慢阅读速度的测试。我们可以通过创建另外两个测试来实现，一个插入<strong class="jk hi"> <em class="ke">时间。睡眠(50 *次。毫秒)</em> </strong>插入到写循环中，而另一个将相同的代码插入到读循环中。代码在其他方面是相同的。</p><p id="df91" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">既然我们已经弄清楚了我们的界面是什么样子，以及如何测试它，让我们看看如何构建这个函数。</p><h1 id="2d34" class="kv kw hh bd kx ky kz la lb lc ld le lf in lg io lh iq li ir lj it lk iu ll lm bi translated"><strong class="ak">设计</strong></h1><p id="20a6" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">为了在写入时不阻塞，我们需要在写入In通道时立即读取，并按照接收顺序存储值。存储的值的数量需要是无限的，以防读取器比写入器慢。一个无界的、有序的值列表意味着我们应该使用一个片来存储排队的数据。我们还需要启动我们自己的goroutine来从in通道进行读取。</p><p id="1092" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">到目前为止，这并不难。问题第一部分的模式是:</p><p id="0d95" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">1)在中创建<strong class="jk hi"> <em class="ke">和<strong class="jk hi">中创建<em class="ke">出</em> </strong>通道</em></strong></p><p id="d505" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">推出一款goroutine</p><p id="7d33" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> a) </strong>而 通道中的<strong class="jk hi"> <em class="ke">打开</em></strong></p><p id="240c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> i) </strong>从<strong class="jk hi"> <em class="ke">中读取</em> </strong>通道</p><p id="2161" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> ii) </strong>把从<strong class="jk hi">到<em class="ke">的数值放入</em>到</strong>通道中</p><p id="3aff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> b) </strong>关闭<strong class="jk hi"> <em class="ke">出</em> </strong>通道</p><p id="35c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> c) </strong>退出goroutine</p><p id="734a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 3) </strong>返回 中的<strong class="jk hi"> <em class="ke">和<strong class="jk hi"> <em class="ke">中的</em> </strong>通道</em></strong></p><p id="b6f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">实现这一点的代码如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lt"><img src="../Images/db3bc2bf81386a518402930bb458fdbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8SfApPmqOqF9Xc28p_HKA.png"/></div></div></figure><p id="b505" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们利用<strong class="jk hi"> <em class="ke">、</em>、</strong>、<strong class="jk hi">、<em class="ke"> ok、</em>、</strong>习语在Go中检测一个通道是否关闭。从通道中读取通常如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lu"><img src="../Images/9af06e9dc3afe534c33bb8b38d1a2832.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*S9lkBBefkfGbXPWFEfQF2g.png"/></div></figure><p id="f448" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将阻塞，直到从通道<strong class="jk hi"> <em class="ke"> ch </em> </strong>中读取一个值。然后，该值将被赋给v。当您尝试从一个关闭的通道读取时，该通道总是返回值，即该通道的零值。既然向通道写入零值是合法的，那么如何判断从通道读取的值是写入的零值，还是因为通道关闭而产生的零值呢？通过使用第二个布尔参数作为从通道读取的一部分，可以做到这一点:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lv"><img src="../Images/38554d2a0b4497e22f2bb6f1f9e02401.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*Y8r3aZk3Q5o1Nm-FL3-J6Q.png"/></div></figure><p id="550d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果<strong class="jk hi"> <em class="ke"> ok </em> </strong>为<strong class="jk hi"> <em class="ke"> true </em> </strong>，则通道打开。如果<strong class="jk hi"> <em class="ke"> ok </em> </strong>为<strong class="jk hi"> <em class="ke"> false </em> </strong>，则通道关闭。我们使用这些信息来知道何时打破循环。</p><h2 id="b499" class="lw kw hh bd kx lx ly lz lb ma mb mc lf jr md me lh jv mf mg lj jz mh mi ll mj bi translated"><strong class="ak">还有一点要注意:</strong></h2><p id="47c6" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">我们需要在<strong class="jk hi"> <em class="ke">上为</em> </strong>循环使用一个标签，这样我们就可以从<strong class="jk hi"> <em class="ke"> case </em> </strong>子句中<strong class="jk hi"> <em class="ke"> break </em> </strong>出来。如果没有使用标签，则<strong class="jk hi"> <em class="ke">中断</em> </strong>将应用于当前<strong class="jk hi"> <em class="ke">案例</em> </strong>，并且<strong class="jk hi"> <em class="ke">为</em> </strong>循环将永远运行。</p><p id="50f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们现在运行测试，它将如预期的那样失败，因为我们不再写回任何东西:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mk"><img src="../Images/df44e5cf1008aeaa10e4a01586e89491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HGz_nxzt0g66Puft54ALw.png"/></div></div></figure><h1 id="c5c0" class="kv kw hh bd kx ky kz la lb lc ld le lf in lg io lh iq li ir lj it lk iu ll lm bi translated"><strong class="ak">书写无阻塞</strong></h1><p id="a537" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">现在，我们正在对所有写入的值进行排队，我们需要某种方式将它们发送回来，这里<strong class="jk hi"> <em class="ke"> select </em> </strong>帮助我们。虽然我们通常使用<strong class="jk hi"> <em class="ke">选择</em> </strong>来同时从多个通道读取，但是也可以使用<strong class="jk hi"> <em class="ke">选择</em> </strong>来写入通道。通道写的情况就像通道读的情况一样处理；如果写入成功(被写入的通道被另一个goroutine读取)，则执行case子句中的代码。所以让写作工作的第一步看起来像:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/b096abda2c1123b7b7f43cfc27279cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYN7-9VGWTukGl9QV-nxKQ.png"/></div></div></figure><p id="6645" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以将队列 中<strong class="jk hi"> <em class="ke">的第一个值写入输出通道，当它成功时，我们将该值从队列头取出并再次循环。让我们运行测试，看看会发生什么:</em></strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mm"><img src="../Images/cafc5bb9f71b50123d6bfa42b7d82dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbMsw_8Qbbwjp7D5izs9dQ.png"/></div></div></figure><p id="557e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">哎呀。当我们试图从队列 中的<strong class="jk hi"> <em class="ke">读取第一个值时，我们会得到一个错误，因为队列</em> </strong>中的<strong class="jk hi"> <em class="ke">一开始是空的。这不仅仅是一个创业问题。如果读取者比写入者更快，队列将再次清空，我们将面临同样的问题。<strong class="jk hi"> <em class="ke">我们如何解决？</em> </strong></em></strong></p><p id="9d15" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">像许多计算机科学问题一样，解决方案是另一个间接层。与其直接读取队列 中的<strong class="jk hi"> <em class="ke">，我们可以将它封装在一个函数调用中，该函数调用在尝试获取第一个值之前检查队列是否为空。Go中的闭包使得内联函数变得很容易:</em></strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/b32dfb9168a9ec4c55b09d230ff85380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paqgIj-J6bp5N0Ig9nT1VQ.png"/></div></div></figure><p id="45d6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们看看这是如何工作的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mo"><img src="../Images/820a59d72fd50200fbfe3909e67fe50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRshMfwRO1aezo5z0yre7Q.png"/></div></div></figure><p id="14a2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">哼。看来写出<strong class="jk hi"> <em class="ke"> nil </em> </strong>值是个馊主意。它被我们的reading goroutine选中，当它试图转换成一个<strong class="jk hi"> <em class="ke"> int </em> </strong>时，测试惊慌失措。每当队列中没有任何东西时，我们不想将<strong class="jk hi"><em class="ke">【nil】</em></strong>写入<strong class="jk hi"> <em class="ke"> out </em> </strong>通道；我们根本不想写<em class="ke"/>。有什么办法可以在没有东西发送的时候阻止写入到<strong class="jk hi"> <em class="ke"> out </em> </strong>通道？</p><p id="8feb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将结合两个技巧，<strong class="jk hi"> <em class="ke"> nil </em> </strong>通道和包装功能。如果您尝试写入一个<strong class="jk hi"> <em class="ke"> nil </em> </strong>通道，写入尝试将永远阻塞。通常，这似乎是不好的行为，但是有一个地方是可以的——在<strong class="jk hi"> <em class="ke"> select </em> </strong>语句中。当没有数据要发送时，我们应该写一个<strong class="jk hi"> <em class="ke"> nil </em> </strong>通道，这样case就阻塞了，不发送任何东西。</p><p id="76cd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了根据队列的长度获得不同的行为，我们需要在通道周围有一个间接层；这听起来像是另一个功能。另外，我们的代码变得简单了一些。因为当队列 中的<strong class="jk hi"> <em class="ke">为空时，我们不再潜在地写，所以我们不再需要一个<strong class="jk hi"> <em class="ke"> if </em> </strong>语句来包装从队列中移除头部。</em></strong></p><p id="4a15" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这会产生代码:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mp"><img src="../Images/b8e76fa0d25b041266226d79713b7535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9h9GHgHOTl5kzD-XjgCfTw.png"/></div></div></figure><p id="a5c4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们看看这是如何工作的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mq"><img src="../Images/12fa92b6f7bebe034211b4e612452e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZhTLrPMVjm2N8saZT_ovw.png"/></div></div></figure><p id="ae9d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">啊哦。现在我们有一个不同的问题。我们可以读和写，但是我们关闭得太快了，因为写的比读的快。我们如何获得所有的值？</p><h1 id="5938" class="kv kw hh bd kx ky kz la lb lc ld le lf in lg io lh iq li ir lj it lk iu ll lm bi translated"><strong class="ak">清空队列</strong></h1><p id="dc37" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">显然，这段代码中有一个错误。任何时候写者比读者快，在队列 中<strong class="jk hi"> <em class="ke">就会有多个值等待读取。如果我们退出<strong class="jk hi"> <em class="ke"> for </em> </strong>循环，而不等待队列清空，那些排队的值将永远不会被写出。我们需要不断循环，直到两件事都为真:通道关闭，队列为空。</em></strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mr"><img src="../Images/effb01c1a008713378ddd48675b1c61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MD5Ch0RjKkhdzlYpI8vK_g.png"/></div></div></figure><p id="6672" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这段代码的大部分都很简单，我们能够去掉标签上的<strong class="jk hi"><em class="ke"/></strong>语句，但是通道处理和<strong class="jk hi"> <em class="ke">上的条件对于</em> </strong>语句可能需要一些解释。特别是<em class="ke"/><strong class="jk hi"><em class="ke">nil</em></strong><em class="ke">怎么回事？</em></p><p id="ae69" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">就像向一个<strong class="jk hi"> <em class="ke"> nil </em> </strong>通道写入会永远阻塞一样，从一个<strong class="jk hi"> <em class="ke"> nil </em> </strong>通道读取也会永远阻塞。通过将 中的<strong class="jk hi"> <em class="ke">设置为<strong class="jk hi"><em class="ke"/></strong><strong class="jk hi"><em class="ke">select</em></strong>语句将不再尝试从in中读取。这很好，因为我们只在通道关闭时将</em> </strong>中的<strong class="jk hi"> <em class="ke">设置为<strong class="jk hi"> <em class="ke"> nil </em> </strong>，一个关闭的通道总是返回值。从一个<strong class="jk hi"> <em class="ke"> for-select </em> </strong>循环内的一个封闭通道中读取将导致该通道被反复读取；这将严重影响性能和CPU使用率。</em></strong></p><p id="ae47" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">鉴于此，<strong class="jk hi"> <em class="ke">对于</em> </strong>的条件是有意义的。只要我们仍能读取值<strong class="jk hi"> <em class="ke"> (in！= nil) </em> </strong>或者还有值在排队<strong class="jk hi"><em class="ke">(len(in queue)&gt;0)</em></strong>。如果队列为空，通道关闭，我们就完成了，所以关闭<strong class="jk hi"> <em class="ke"> out </em> </strong>通道，退出goroutine。</p><p id="d5f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这段代码最终通过了我们的测试:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ms"><img src="../Images/1a73eb17059157f5ca74be5fe996443a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbXg_Agh27Y2sJo54-BzEA.png"/></div></div></figure><h1 id="84c1" class="kv kw hh bd kx ky kz la lb lc ld le lf in lg io lh iq li ir lj it lk iu ll lm bi translated"><strong class="ak">嗯？</strong></h1><p id="22fc" class="pw-post-body-paragraph ji jj hh jk b jl ln ii jn jo lo il jq jr lp jt ju jv lq jx jy jz lr kb kc kd ha bi translated">事实证明，如果您想要一个从不阻塞写操作的通道，缓冲通道不在实现中。那么它们有什么用呢？为什么要在Go中加入这个功能？我将在本系列的下一篇博文中讨论缓冲通道的使用。</p></div><div class="ab cl mt mu go mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ha hb hc hd he"><p id="3faa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae kf" href="https://appliedgo.net/generics/%20%20http:/blog.jonathanoliver.com/golang-has-generics/%20%20https:/github.com/golang/go/issues/15292%20%20https:/news.ycombinator.com/item?id=9622417%20%20http://stackoverflow.com/questions/3912089/why-no-generics-in-go" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> <em class="ke">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2017首都一。</em> </strong> </a></p><p id="0e42" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">欲了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。<a class="ae kf" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jk hi"><em class="ke">developer.capitalone.com/</em></strong></a></p><p id="3292" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">附加链接</strong></p><ul class=""><li id="a9d2" class="kg kh hh jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><a class="ae kf" href="https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中构建REST API</a></li></ul></div></div>    
</body>
</html>