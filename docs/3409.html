<html>
<head>
<title>Why OnCreate() of Activity and OnCreateView() of Fragment is not needed anymore…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不再需要Activity的OnCreate()和Fragment的OnCreateView()</h1>
<blockquote>原文：<a href="https://medium.com/globant/why-oncreate-of-activity-and-oncreateview-of-fragment-is-not-needed-anymore-6cdfc331102?source=collection_archive---------0-----------------------#2020-05-17">https://medium.com/globant/why-oncreate-of-activity-and-oncreateview-of-fragment-is-not-needed-anymore-6cdfc331102?source=collection_archive---------0-----------------------#2020-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2bc2c0be2e4f1081b790d4d8d6817653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDROaW1fFXybKiKJCcg3lg.jpeg"/></div></div></figure><p id="da4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从我们开始用android编程的那一天起，我们就一直在使用<code class="du jn jo jp jq b">setContentView</code>来扩展Activity类中的布局。当片段被引入时，我们不得不覆盖<code class="du jn jo jp jq b">onCreateView</code>并使用一个布局生成器从一个布局ID获取我们的视图。他们感觉有点像样板，对不对？这是解决问题的方法</p><h1 id="d8b1" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">活动</h1><p id="b9bf" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">如果我们使用OnCreate()方法只是为了扩大视图，那么我们可以删除活动的OnCreate()方法。</p><p id="6237" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">以前的</strong>:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="06a6" class="lc js hh jq b fi ld le l lf lg">class MainActivity : AppCompatActivity() {</span><span id="5b0a" class="lc js hh jq b fi lh le l lf lg">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="li">activity_main</em>)<br/>    }   <br/>}</span></pre><p id="3780" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">现在来自AndroidX : </strong></p><p id="e6a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用将布局作为参数的构造函数。首先，我们需要定义应用程序<code class="du jn jo jp jq b">build.gradle</code>文件的依赖关系。</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="1e96" class="lc js hh jq b fi ld le l lf lg">implementation 'androidx.appcompat:appcompat:1.1.0'</span></pre><p id="7600" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后在活动课上。</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="c0a5" class="lc js hh jq b fi ld le l lf lg">class MainActivity : AppCompatActivity(R.layout.<em class="li">activity_main</em>) {</span><span id="c5df" class="lc js hh jq b fi lh le l lf lg">}</span></pre><p id="0233" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong>:我们可以通过Kotlin android扩展访问视图。</p><p id="804a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Tada，布局膨胀了。</p><h1 id="c77e" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">碎片</h1><p id="dfb0" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated"><strong class="ir hi">以前的</strong>:</p><p id="2466" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">调用OnCreateView()来放大视图。</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="201a" class="lc js hh jq b fi ld le l lf lg">class MyFragment : Fragment() {<br/><br/>    override fun onCreateView(<br/>        inflater: LayoutInflater,<br/>        container: ViewGroup?, savedInstanceState: Bundle?<br/>    ): View? {<br/>        return inflater.inflate(R.layout.<em class="li">my_fragment</em>, container, false)<br/>    }</span><span id="3fb1" class="lc js hh jq b fi lh le l lf lg">    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {<br/>        super.onViewCreated(view, savedInstanceState)<br/>        val textView = view.findViewById(R.id.<em class="li">tv</em>) as TextView<br/>        textView.<em class="li">text </em>= "myText";<br/>    }<br/>}</span></pre><p id="85fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong> : <code class="du jn jo jp jq b">onViewCreated</code>只有当onCreateView()返回的视图非空时才会被调用。</p><p id="ef4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">现在来自AndroidX : </strong></p><p id="9d1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用将layout作为参数的构造函数，并消除OnCreateView()。</p><p id="3e50" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们需要定义应用程序<code class="du jn jo jp jq b">build.gradle</code>文件的依赖关系。</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="92c2" class="lc js hh jq b fi ld le l lf lg">implementation 'androidx.appcompat:appcompat:1.1.0'</span></pre><p id="21bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后在片段类里。</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="1644" class="lc js hh jq b fi ld le l lf lg">class MyFragment : Fragment(R.layout.<em class="li">my_fragment</em>) {<br/><br/>    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {<br/>        super.onViewCreated(view, savedInstanceState)<br/>        val textView = view.findViewById(R.id.<em class="li">tv</em>) as TextView<br/>        textView.<em class="li">text </em>= "myText";<br/>    }<br/>}</span></pre><p id="5223" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嘭，版面膨胀了。</p><p id="d69f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以去掉这些生命周期方法，保持代码干净🙂</p></div></div>    
</body>
</html>