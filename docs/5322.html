<html>
<head>
<title>Run a Tomcat Cluster with Redis session persistence on Oracle Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Oracle Cloud上运行具有Redis会话持久性的Tomcat集群</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/tomcat-cluster-on-oracle-cloud-with-http-session-persistence-89a97b38d13b?source=collection_archive---------0-----------------------#2017-10-13">https://medium.com/oracledevs/tomcat-cluster-on-oracle-cloud-with-http-session-persistence-89a97b38d13b?source=collection_archive---------0-----------------------#2017-10-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="82cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客展示了在<a class="ae jc" href="https://cloud.oracle.com/en_US/application-container-cloud" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Oracle应用程序容器云</strong> </a>上的一个集群Tomcat应用程序</p><ul class=""><li id="9de8" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><a class="ae jc" href="http://redis.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Redis </strong> </a>用作(HTTP)会话存储(与<strong class="ig hi"> Spring Session </strong></li><li id="fef3" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用<a class="ae jc" href="https://cloud.oracle.com/en_US/developer-service" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">Oracle Developer Cloud</strong></a>中的CI/CD特性将其部署在<strong class="ig hi"> Oracle应用容器云</strong>上</li></ul><p id="1a84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将关注HTTP会话管理(Tomcat集群上的应用程序)及其实现方面</p><ul class=""><li id="2ea9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><strong class="ig hi">持久化</strong> —使用Redis支持的存储，该存储可配置为刷新(持久化)到磁盘</li><li id="8a71" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">无状态</strong> —非粘性会话管理</li><li id="c59f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">高可用性</strong>——只要我们至少有一个活动节点，一个(应用程序)节点的故障就不会影响会话数据(因此也不会影响用户)</li><li id="faab" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">可扩展性</strong> —应用程序可以在不影响用户/会话数据的情况下进行扩展(水平或垂直)</li></ul><h1 id="9ad1" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">HTTP会话持久性</h1><h2 id="4eae" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">雄猫</h2><p id="3aad" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">它支持(开箱即用的实现)内存和持久HTTP会话存储</p><ul class=""><li id="53c0" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><strong class="ig hi">内存中</strong>:配置Tomcat使用<code class="du li lj lk ll b">org.apache.catalina.ha.tcp.SimpleTcpCluster</code>实现</li><li id="1d4b" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">持久化</strong>:使用文件或JDBC存储来持久化HTTP会话信息</li></ul><h2 id="f81f" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">Oracle应用程序容器云中的Tomcat HTTP会话存储支持</h2><p id="4d08" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">Tomcat的内存模式和持久模式都受支持</p><ul class=""><li id="fa28" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><strong class="ig hi">内存中</strong>:这是由于Oracle应用容器云中的<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/dvcjv/preparing-clustered-application-deployment.html" rel="noopener ugc nofollow" target="_blank">多播支持</a>而成为可能。详情请查看本教程</li><li id="1c5d" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">持久存储</strong>:您可以使用<a class="ae jc" href="https://cloud.oracle.com/en_US/database" rel="noopener ugc nofollow" target="_blank"> Oracle数据库云</a>(或者任何其他可以使用JDBC访问的RDBMS)作为持久HTTP会话存储。这个也有<a class="ae jc" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/cloud/apaas/java/tomcat-mysql-cluster/tomcat-mysql-cluster.html#overview" rel="noopener ugc nofollow" target="_blank">教程</a>！</li></ul><h1 id="12db" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">解决方案详细信息</h1><p id="9d2d" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">为了实现集群化Tomcat应用程序的持久HTTP会话存储，我们有几个选择</p><ol class=""><li id="b984" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lm jj jk jl bi translated">扩展Tomcat特定的接口/类(例如<code class="du li lj lk ll b">org.apache.catalina.session.ManagerBase</code>)或者使用现有的插件，例如<a class="ae jc" href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks#145-tomcat-redis-session-manager" rel="noopener ugc nofollow" target="_blank"> Redisson对Tomcat的支持</a></li></ol><p id="a175" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.构建/使用更通用的解决方案——理想情况下与运行时无关</p><h2 id="6e3c" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">Oracle应用容器云上的Spring会话和Redis组合</h2><p id="4c42" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">这篇博客展示了第二种选择。它使用了基于Redis的<a class="ae jc" href="http://docs.spring.io/spring-session/docs/1.3.1.RELEASE/reference/html5/" rel="noopener ugc nofollow" target="_blank"> Spring Session </a>的实现</p><ul class=""><li id="d597" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">基于<code class="du li lj lk ll b">Servlet </code>规范——因此是容器中立的，也就是说，它可以适用于任何符合<code class="du li lj lk ll b">Servlet </code>规范的容器(除了Tomcat)</li><li id="6150" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">一个定制的<code class="du li lj lk ll b">Servlet Filter </code>实现，负责强制使用Spring Session <code class="du li lj lk ll b">HTTPSession </code>实现</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ln"><img src="../Images/25641440e40b753268a18b51cb268a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*f_ldH2vhZ097jfxO__Yhsw.jpeg"/></div><figcaption class="lv lw et er es lx ly bd b be z dx">High level overview</figcaption></figure><p id="fd60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">项目在这里<a class="ae jc" href="https://github.com/abhirockzz/accs-tomcat-redis-springsession" rel="noopener ugc nofollow" target="_blank">可用</a>——就业务逻辑而言，它只包含</p><ul class=""><li id="01e9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">一个简单的HTTP <code class="du li lj lk ll b">Servlet</code></li><li id="0a18" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">启用Redis的(Spring)配置类</li><li id="94d6" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">另一个实用程序类，确保Servlet过滤器为每个HTTP请求服务</li></ul></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><h1 id="dca5" class="jr js hh bd jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko bi translated">应用程序打包</h1><p id="60a4" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">我们遵循<code class="du li lj lk ll b">bring-your-own-runtime</code>咒语。代码库具有以下结构</p><ul class=""><li id="a693" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">源代码(<code class="du li lj lk ll b">src </code>目录)</li><li id="6a29" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">Tomcat 8.x ( <code class="du li lj lk ll b">tom-accs</code>目录)</li><li id="6dd0" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">引导脚本(<code class="du li lj lk ll b">start.sh</code>)</li></ul><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="7c5d" class="kp js hh ll b fi mp mq l mr ms">#!/bin/bash<br/>if [ -z “$PORT” ];<br/>then<br/> PORT=”8080"<br/>fi<br/>echo “PORT set to $PORT”<br/># Update server.xml with env vars<br/>sed “s/__PORT__/${PORT}/g” server.template.xml &gt; tom-accs/conf/server.xml<br/>sh tom-accs/bin/catalina.sh run</span></pre><blockquote class="mt mu mv"><p id="d42c" class="ie if mw ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated">除了Tomcat启动脚本调用之外，start.sh脚本确保在应用程序启动期间生成具有正确环境变量的<code class="du li lj lk ll b">server.xml</code>(在我们的例子中是PORT)</p></blockquote><ul class=""><li id="4d41" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">(Tomcat) <code class="du li lj lk ll b">server.xml</code> ( <code class="du li lj lk ll b">server.xml.template</code>)的模板版本</li><li id="b383" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><code class="du li lj lk ll b">manifest.json</code> —强制部署描述符</li></ul><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="dd49" class="kp js hh ll b fi mp mq l mr ms">{<br/> “runtime”:{“majorVersion”:”8"},<br/> “command”:”sh ./start.sh”,<br/> “notes”:”Tomcat on ACCCS with Redis Session Sharing”<br/>}</span></pre><h1 id="703b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">设置</h1><h2 id="2ad2" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">Oracle开发人员云</h2><p id="b0a1" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">让我们为<em class="mw">持续构建</em>以及<em class="mw">部署</em>流程配置Oracle开发人员云。您可以参考以前的博客(这里将重点介绍这个例子的一些细节)</p><p id="1d24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">参考文献</strong></p><ul class=""><li id="7ee0" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">在Oracle开发人员云中引导应用程序— <a class="ae jc" href="https://community.oracle.com/community/cloud_computing/oracle-cloud-developer-solutions/blog/2017/05/25/getting-started-with-kafka-based-microservices-using-oracle-event-hub-cloud-application-container-cloud-developer-cloud#jive_content_id_Project__code_repository_creation" rel="noopener ugc nofollow" target="_blank">项目&amp;代码库创建</a></li><li id="29ba" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">持续集成设置— <a class="ae jc" href="https://community.oracle.com/community/cloud_computing/oracle-cloud-developer-solutions/blog/2017/05/25/getting-started-with-kafka-based-microservices-using-oracle-event-hub-cloud-application-container-cloud-developer-cloud#jive_content_id_Configure_build_job" rel="noopener ugc nofollow" target="_blank">配置构建作业</a></li><li id="cf96" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">部署设置— <a class="ae jc" href="https://community.oracle.com/community/cloud_computing/oracle-cloud-developer-solutions/blog/2017/05/25/getting-started-with-kafka-based-microservices-using-oracle-event-hub-cloud-application-container-cloud-developer-cloud#jive_content_id_Continuous_Deployment_CD_to_Application_Container_Cloud" rel="noopener ugc nofollow" target="_blank">持续部署(CD)到应用容器云</a></li></ul><h2 id="5b3d" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">构建作业配置</h2><p id="7afb" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">该应用程序的构建工作本质上是通用的，但是它有一些应用程序特定的细微差别(<strong class="ig hi">构建步骤</strong>)，这将在本节中重点介绍</p><p id="1a85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">构建步骤#1 </strong> —调用Maven构建来生成所需的工件，即本例中的WAR文件</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/b2fe7258b0b7afe81bad735b5641a390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzy9si-FDHNk2ZRu-o1wSw.png"/></div></div></figure><p id="c891" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">构建步骤# 2</strong>——将WAR文件复制到Tomcat <code class="du li lj lk ll b">webapps </code>目录中，并将所有内容压缩(为最终的云就绪工件)</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nf"><img src="../Images/7af3d619d0c3376089b5b4b3cab86092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrakJZfYXEZOHzDwrJy-ig.png"/></div></div></figure><blockquote class="mt mu mv"><p id="f6a0" class="ie if mw ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated"><em class="hh">最终结果是一个</em><strong class="ig hi"><em class="hh">zip</em></strong><em class="hh">文件，它由二进制文件(WAR文件)以及运行时文件(Tomcat安装)组成，它将在运行时执行</em></p></blockquote><h2 id="83cb" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">提供Oracle应用程序容器云(配置)描述符</h2><p id="4892" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">我们提供应用程序(规模)详细信息以及Redis坐标(主机和端口)</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es ng"><img src="../Images/ff34ffc7fb15147c081ee9f9edca163e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNw7l9VR1jvh5vhYw16gjA.png"/></div></div></figure><h2 id="688b" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">Oracle开发人员云中的部署确认</h2><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es nh"><img src="../Images/cd146c9f87d9eaca1a167aa763b7e23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*wO7Iqa09kbHQNwKwZRaZOQ.png"/></div></figure><h2 id="7816" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated"><strong class="ak">应用容器云中的部署后状态</strong></h2><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es ni"><img src="../Images/80507944e411f860bb2e86f6510cec56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HVCdnHrVlwKJ9IEcFUCTg.png"/></div></div></figure><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nj"><img src="../Images/65884cdeb138760bbfceb5267a4367dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWxvsdRWkki88KcRCtfLwA.png"/></div></div></figure><h1 id="a090" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">测试应用程序</h1><p id="e7cc" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">让我们使用<code class="du li lj lk ll b"><a class="ae jc" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank">cURL </a></code>和<code class="du li lj lk ll b"><a class="ae jc" href="https://redis.io/topics/rediscli" rel="noopener ugc nofollow" target="_blank">redis-cli</a></code>工具来测试应用程序</p><h2 id="f5b1" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">第一次访问</h2><p id="4ec4" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">我们将在我们的应用程序URL上调用一个<code class="du li lj lk ll b">HTTP GET</code></p><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="a24c" class="kp js hh ll b fi mp mq l mr ms">curl https://accs-tomcat-redis-&lt;mydomain&gt;.apaas.em2.oraclecloud.com/accs-tomcat-redis-spring/</span></pre><ul class=""><li id="5b6e" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">这将创建一个新的HTTP会话—以绿色突出显示</li><li id="b352" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">注意处理请求的ACCS实例(绿色)</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nk"><img src="../Images/ceaa4723dc5693a09107e210fcaf7240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leqh1_LAkTySavm1TYufMQ.png"/></div></div></figure><h2 id="e759" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">添加会话数据并访问应用程序</h2><p id="e8a8" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">我们现在将使用上面接收到的会话ID，将它与一个添加一些会话数据的请求一起传递——这是一个带有参数<code class="du li lj lk ll b">name </code>和<code class="du li lj lk ll b">val </code>的<code class="du li lj lk ll b">HTTP POST</code>,它们存储在HTTP会话中</p><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="43e4" class="kp js hh ll b fi mp mq l mr ms">curl -X POST -H “Cookie: SESSION=09217ecb-6b90–41bf-952f-b41b65070fa2” “https://accs-tomcat-redis-&lt;mydomain&gt;.apaas.em2.oraclecloud.com/accs-tomcat-redis-spring/?name=k1&amp;val=v1"</span></pre><p id="3522" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了访问应用程序，我们执行<code class="du li lj lk ll b">HTTP GET</code>操作，如步骤#1中的execute(以及头中的会话ID<em class="mw">)</em></p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nl"><img src="../Images/8fc201b71e1b7fd5e87208588651763e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbmnloSmoofsnQorW8xvSA.png"/></div></div></figure><blockquote class="mt mu mv"><p id="f476" class="ie if mw ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated"><em class="hh">注意，我们取回了在上一步</em>中添加的会话数据(以红色突出显示)</p></blockquote><p id="cfca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们使用<code class="du li lj lk ll b">redis-cli</code>在Redis中查看我们的会话状态。对存储会话的Redis <code class="du li lj lk ll b">Hash </code>(数据结构)执行一个<code class="du li lj lk ll b">HGETALL </code>命令(散列名称是基于会话ID的预定格式)</p><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="d51f" class="kp js hh ll b fi mp mq l mr ms">&lt;redis-host&gt;:6379&gt; hgetall spring:session:sessions:09217ecb-6b90–41bf-952f-b41b65070fa2</span></pre><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nm"><img src="../Images/3184221a67caae385afa9f956e0e0c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ten3pqOPafigin7LDSUNww.png"/></div></div></figure><blockquote class="mt mu mv"><p id="fe1e" class="ie if mw ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated"><em class="hh">注意我们在上一步中添加的会话数据(键值对</em> <strong class="ig hi"> <em class="hh"> k1 </em> </strong> <em class="hh">，</em> <strong class="ig hi">，<em class="hh"> v1 </em> </strong> <em class="hh">)，它以绿色突出显示</em></p></blockquote><h2 id="f3d4" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">添加更多数据，访问应用程序并检查Redis</h2><p id="dc8e" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">让我们冲洗并重复…</p><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="5276" class="kp js hh ll b fi mp mq l mr ms">curl -X POST -H “Cookie: SESSION=09217ecb-6b90–41bf-952f-b41b65070fa2” “https://accs-tomcat-redis-&lt;my-domain&gt;.apaas.em2.oraclecloud.com/accs-tomcat-redis-spring/?name=abhishek&amp;val=gupta"</span></pre><p id="5b8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"> Redis、</strong>中，您将看到新添加的会话数据(以红色突出显示)</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nn"><img src="../Images/097370ef241a723c03c88e72520aeedc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPVVuMeYEJb3oinCWGtmUA.png"/></div></div></figure><p id="8206" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您(显然)会看到应用程序中也反映了相同的会话数据—请注意以红色突出显示的Oracle应用程序容器云实例名称</p><ul class=""><li id="3be2" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">随后的请求由不同的实例来满足，但是</li><li id="8af4" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">会话数据是一致的，因为它是从持久性存储(Redis)中检索的</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es no"><img src="../Images/33a1e67ca95c0a6e87d2fdc7abf57116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtBai98OFg3kkijZICr6aA.png"/></div></div></figure><h2 id="4a77" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">放大并再次访问应用程序</h2><p id="0f67" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">让<em class="mw">将</em>的实例数减少到1 —详情请参考<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/csjse/exploring-application-overview-page.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es np"><img src="../Images/c1d1816583e1a1d98c3472099453c49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAPc6tEk5aNhMkrfC4VRDQ.png"/></div></div></figure><ul class=""><li id="5d2a" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">会话数据将保持一致</li><li id="a4a3" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">请求将由<em class="mw">相同的</em>应用程序容器云实例提供服务(我们现在只有一个)</li></ul><h2 id="8d79" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">添加会话数据(再次)</h2><pre class="lo lp lq lr fd ml ll mm mn aw mo bi"><span id="33ca" class="kp js hh ll b fi mp mq l mr ms">curl -X POST -H “Cookie: SESSION=09217ecb-6b90–41bf-952f-b41b65070fa2” “https://accs-tomcat-redis-&lt;my-domain&gt;.apaas.em2.oraclecloud.com/accs-tomcat-redis-spring/?name=accs&amp;val=rocks"</span></pre><p id="dd99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">检查Redis</strong>——您将看到数据被持久化在那里</p><h2 id="2d79" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">横向扩展、访问应用程序并检查Redis</h2><p id="3248" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">让我们回到我们的<em class="mw">双实例</em>拓扑——参考<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/csjse/exploring-application-overview-page.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解如何向外扩展。你会看到的</p><ul class=""><li id="ec80" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">在重复访问时，不同的应用程序容器云实例将服务于该请求</li><li id="5444" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">返回的应用程序会话数据将与上面相同</li><li id="9b4c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">Redis也将保持相同的状态</li></ul><h1 id="bef0" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">测试CI/CD流</h1><p id="31f4" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">做一些代码修改，推送给开发者云服务Git repo。这应该</p><ul class=""><li id="e8b7" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">自动触发<strong class="ig hi">构建</strong>，一旦成功将</li><li id="3e33" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">自动触发<strong class="ig hi">部署</strong>流程，以及</li><li id="4b9f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi">将新的应用程序版本重新部署</strong>到应用程序容器云</li></ul></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><h1 id="3188" class="jr js hh bd jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko bi translated">概述</h1><p id="da45" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">结局好就一切都好！我们能够使用Redis和Spring Session为Oracle应用程序容器云上的Tomcat web app配置和实施无状态、可扩展、高度可用和持久的HTTP会话管理策略</p><h1 id="989d" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">不要忘记…</h1><ul class=""><li id="61c5" class="jd je hh ig b ih ld il le ip nq it nr ix ns jb ji jj jk jl bi translated">查看Oracle应用容器云的教程<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/create-first-applications.html" rel="noopener ugc nofollow" target="_blank">——每个运行时都有一些内容！</a></li><li id="e9c3" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><a class="ae jc" href="http://bit.ly/2gR3nrV" rel="noopener ugc nofollow" target="_blank">其他关于应用容器云的博客</a></li></ul><blockquote class="mt mu mv"><p id="ac1f" class="ie if mw ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated">本文表达的观点是我个人的观点，不一定代表甲骨文的观点。</p></blockquote></div></div>    
</body>
</html>