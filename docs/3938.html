<html>
<head>
<title>SwiftUI | List | Tic-Tac-Toe Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI | List |井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/globant/swiftui-list-tic-tac-toe-game-8ad7aaa4050?source=collection_archive---------0-----------------------#2022-08-05">https://medium.com/globant/swiftui-list-tic-tac-toe-game-8ad7aaa4050?source=collection_archive---------0-----------------------#2022-08-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是井字游戏<a class="ae jc" rel="noopener" href="/globant/swiftui-complete-guide-with-tic-tac-toe-game-ae2fea4f980e">系列</a>的第7部分。到目前为止，我们创造了一个单轮井字游戏来决定赢家。让我们进行3轮游戏，获胜者将是赢得最多回合数的人。此外，我们将探索用于设计分数表的列表视图，以显示谁赢了哪一轮。</p><p id="c0c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个新的ObservableObject类，并将其命名为RoundWinnerInfo。我们只需要跟踪两个属性，这一轮和这一轮的赢家。为了设计列表行，遍历该类的实例时也要使其可识别。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9372" class="jm jn hh ji b fi jo jp l jq jr">class RoundWinnerInfo: Identifiable, ObservableObject {<br/>   var id = UUID()<br/>   var round: Int<br/>   @Published var winnerPlayer: Int = -1<br/>   init(round: Int) {<br/>      self.round = round<br/>   }<br/>}</span><span id="48f5" class="jm jn hh ji b fi js jp l jq jr">//Update GameSettings</span><span id="ce73" class="jm jn hh ji b fi js jp l jq jr">@State var rounds: [RoundWinnerInfo] = []</span><span id="069e" class="jm jn hh ji b fi js jp l jq jr">init() {<br/>   rounds = [RoundWinnerInfo(round: 1), RoundWinnerInfo(round: 2), RoundWinnerInfo(round: 3)]<br/>   setupGridDetails()<br/>}</span></pre><p id="49e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用<em class="jt">回合</em>来设计我们的比分表。创建一个新的SwiftUI文件，并将其命名为WinnerListView。创建一个名为WinnerListRow的新结构，它将是列表/表格视图的行。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="469f" class="jm jn hh ji b fi jo jp l jq jr">@Binding var round: RoundWinnerInfo</span></pre><p id="b9c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">WinnerListRow将有一个RoundWinnerInfo实例，该实例将与@State属性包装类型的all rounds数组绑定。每行有三列:回合数、玩家1和玩家2的详细信息。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f5d2" class="jm jn hh ji b fi jo jp l jq jr">var body: some View {<br/>   HStack {<br/>      Text(“\(round.round)”)<br/>         .bold()<br/>         .modifier(WinnerListRowModifier())<br/>      if round.winnerPlayer != -1 {<br/>         if round.winnerPlayer == 1 {<br/>            Image(systemName: “checkmark”)<br/>               .modifier(WinnerListRowModifier())<br/>         } else {<br/>           Text(“ — “).modifier(WinnerListRowModifier())<br/>         }</span><span id="026c" class="jm jn hh ji b fi js jp l jq jr">         if round.winnerPlayer == 2 {<br/>            Image(systemName: “checkmark”)<br/>               .modifier(WinnerListRowModifier())<br/>         } else {<br/>            Text(“ — “).modifier(WinnerListRowModifier())<br/>         }<br/>      }<br/>   }.multilineTextAlignment(.center)<br/>}</span></pre><p id="7e8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果进行了一轮游戏，我们会向获胜玩家显示复选标记，并向其他玩家显示。可以创建ViewModifier类型的结构，并且可以将修饰符组合在一起用于多个视图，WinnerListRowModifier就是这种情况的一个例子。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ad10" class="jm jn hh ji b fi jo jp l jq jr">struct WinnerListRowModifier: ViewModifier {<br/>   func body(content: Content) -&gt; some View {<br/>      content<br/>         .frame(width: 80, height: 50, alignment: .center)<br/>   }<br/>}</span></pre><p id="c778" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行已经准备好了，但是最好还有标题来完善比分表的外观。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9a8b" class="jm jn hh ji b fi jo jp l jq jr">struct WinnerListHeader: View {<br/>   var body: some View {<br/>      HStack {<br/>         Text(“Round”).modifier(WinnerListRowModifier())<br/>         Text(“Player 1”).modifier(WinnerListRowModifier())<br/>         Text(“Player 2”).modifier(WinnerListRowModifier())<br/>         Spacer()<br/>      }.multilineTextAlignment(.center)<br/>   }<br/>}</span></pre><figure class="jd je jf jg fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ju"><img src="../Images/dc48a08bc7488ea76a237388e641183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7vZUe6fMOCGO9zsJC0kiw.png"/></div></div></figure><p id="213e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到UI中有一些小故障。我们不需要列表视图产生的这种灰色。目前SwiftUI没有内置的修改器来改变/移除这种颜色，但是我们可以使用Swift代码来处理表格外观。在列表视图上添加此修饰符:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4ad7" class="jm jn hh ji b fi jo jp l jq jr">...<br/>.onAppear{<br/>   UITableView.appearance().backgroundColor = .clear<br/>}.padding(EdgeInsets(top: -30, leading: 0, bottom: 0, trailing: 0))<br/>...</span></pre><p id="7a7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">坚持住！！屏幕上的一切都是白色的。让我们将行颜色改为浅灰色，以区别于父视图。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e7ce" class="jm jn hh ji b fi jo jp l jq jr">WinnerListRow(round: round).listRowBackground(settings.disabledColor)</span></pre><figure class="jd je jf jg fd jv er es paragraph-image"><div class="er es kc"><img src="../Images/a3d216f428b44c493e806caffc00b80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*aAVaXCZ0I4CG6IJuV2WH0w.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx">Score table with dummy data</figcaption></figure><p id="e915" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的用户界面已经准备好了，但我们需要更新每一轮的获胜者，以实现上述结果。为此，我们将在游戏设置中添加更多属性:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="da98" class="jm jn hh ji b fi jo jp l jq jr">var currentRound = 0</span><span id="bac3" class="jm jn hh ji b fi js jp l jq jr">func setCurrentRound() {<br/>   currentRound = rounds.filter({$0.winnerPlayer == -1}).first?.round ?? 0<br/>}</span><span id="25b0" class="jm jn hh ji b fi js jp l jq jr">func updateRoundDetails() {<br/>   var _ = rounds.filter { round in<br/>      if round.round == currentRound {<br/>         round.winnerPlayer = winner<br/>      }<br/>      return true<br/>   }<br/>}</span></pre><p id="f724" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将在GameScreen的onAppear()上调用setCurrentRound()。每当决定了获胜者或者游戏以平局结束时，我们将调用updateRoundDetails()来设置当前回合的获胜者。</p><p id="7354" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要限制球员在3轮后比赛。为此，我们将在GameSettings中添加一个新属性isAllRoundPlayed，该属性将返回true或false，如下所示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="379a" class="jm jn hh ji b fi jo jp l jq jr">var isAllRoundPlayed: Bool {<br/>   return rounds.filter({$0.winnerPlayer != -1}).count == 3<br/>}</span></pre><p id="11cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此标志将用在“玩游戏”按钮上，以决定残疾情况:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="cdfb" class="jm jn hh ji b fi jo jp l jq jr">...<br/>.disabled(settings.isAllRoundPlayed)<br/>...</span></pre><p id="8075" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，每当玩家玩完所有三轮游戏时，此按钮会变成灰色，并且不会执行任何操作。但是如果你回到DashboardView，然后再回来，那么所有的数据都会在那里。我们需要在应用程序的某个地方重置游戏设置。</p><p id="c98f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每当推送或弹出一个新视图时，PlayButtonView的onDisappear()都会被调用，因此在这里重置设置并不是一个好的选择。另一种选择是使用DashboardView的onAppear()，因为当弹出PlayButtonView时将调用它。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="976f" class="jm jn hh ji b fi jo jp l jq jr">...<br/>.onAppear(){<br/>   settings.resetGame()<br/>}<br/>...</span></pre><figure class="jd je jf jg fd jv er es paragraph-image"><div class="er es kh"><img src="../Images/ca2cfc286e48b3acc65f0e527fcb59bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wQ_gG_2urNsVifHPvD3R2g.gif"/></div></figure><p id="5bf4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请务必查看我在这个系列中的其他文章:</p><p id="13c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-text-view-styling-lets-play-tic-tac-toe-game-7987909584fb">文本视图样式</a></p><p id="6bfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-tic-tac-toe-game-button-154a35997bc">按钮</a></p><p id="184b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-navigation-tic-tac-toe-game-d05d52cf4636">导航</a></p><p id="e58f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-shapes-tic-tac-toe-game-376073b11102">形状</a></p><p id="0789" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-drawing-tic-tac-toe-game-71fae0d46381">图纸</a></p><p id="e60d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-data-flow-tic-tac-toe-game-bace4fbeb3ac">数据流</a></p><p id="fa90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-animation-tic-tac-toe-game-4ffe37aba0b8">动画</a></p><blockquote class="ki kj kk"><p id="05b0" class="ie if jt ig b ih ii ij ik il im in io kl iq ir is km iu iv iw kn iy iz ja jb ha bi translated">如果你喜欢这篇文章，请用掌声和评论来欣赏它。这会鼓励我多写！！！！</p></blockquote></div></div>    
</body>
</html>