<html>
<head>
<title>API Gateway — The Simple One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API网关—简单的网关</h1>
<blockquote>原文：<a href="https://medium.easyread.co/api-gateway-the-simples-on-a25a2a66e3d?source=collection_archive---------8-----------------------#2018-10-29">https://medium.easyread.co/api-gateway-the-simples-on-a25a2a66e3d?source=collection_archive---------8-----------------------#2018-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8f3e0b3eb7981e645ea906f28c34992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jehblAlXk4FyRwbb"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@nknezevic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikola Knezevic</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="438b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的<a class="ae jz" href="https://medium.com/easyread/messaging-system-hands-on-35fd853a89a0" rel="noopener">上一篇</a>文章中，我解释了消息传递系统如何帮助我们的系统更具可伸缩性。</p><p id="45ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到我们使用微服务架构的时候，主要的概念是分离每个服务。分离服务后，现在我们有多个部署在不同主机上的服务。这意味着我们的客户端Web、Mobile或CLI等前端服务——应该从不同的主机检索数据。当我们有更多的服务时，这种情况会变得更加困难。我们应该记住每个服务的主机，这样我们就可以检索数据。这是系统的样子。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/540869e625f8ff630c2d03acc0a97eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kjpeE29Z871gsRq8ubo1JA.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The current system design</figcaption></figure><p id="28d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们需要一种机制来使我们的前端服务调用后端服务，而不知道后端服务托管在哪里。我们如何创造这种机制？</p><h1 id="c010" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">API网关——你逃离的大门</h1><p id="655c" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">我们能做的解决方案是使用API网关。我不想在这里解释什么是API Gateway，因为有很多很棒的文章解释了它，你可以在这里找到<a class="ae jz" href="https://microservices.io/patterns/apigateway.html" rel="noopener ugc nofollow" target="_blank"/>，<a class="ae jz" href="https://docs.microsoft.com/en-us/azure/architecture/microservices/gateway" rel="noopener ugc nofollow" target="_blank">这里</a>，和<a class="ae jz" href="https://smartbear.com/learn/api-design/api-gateways-in-microservices/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="472a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于<a class="ae jz" href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/" rel="noopener ugc nofollow" target="_blank"> Nginx的伟大文章</a>，API Gateway的目标之一就是启用请求重路由。请求重新路由将使我们的前端服务调用后端服务，API网关将为我们做这件事。当我们在服务上实现API网关时，这里将是我们的系统设计。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6cbe84d595df6c3ed1ed27ecf1ab4e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*akappoVc0eREE22MsA2ndw.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">After API Gateway implemented</figcaption></figure><h1 id="9605" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">请为我创建一个API网关</h1><p id="7f68" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">实际上，API网关提供商很少，比如<a class="ae jz" href="https://www.nginx.com/solutions/api-gateway/" rel="noopener ugc nofollow" target="_blank"> Nginx Plus </a>、<a class="ae jz" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank">亚马逊API网关</a>、<a class="ae jz" href="https://developer.ibm.com/apiconnect/" rel="noopener ugc nofollow" target="_blank"> IBM API Connect </a>和<a class="ae jz" href="https://azure.microsoft.com/en-us/services/api-management/" rel="noopener ugc nofollow" target="_blank">微软Azure API管理</a>。但在这里，我想创造我自己的东西，因为动手做的东西让我更了解它是什么样的东西。</p><p id="b96b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我想用Express JS创建自己的API网关。在此之前，我需要解释一下当前的系统是怎样的。目前，我有两个服务，Feed服务和Hashtag服务。API网关将把传入的请求重新路由给应该处理它的服务。</p><p id="714d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的Feed服务上，我有三个端点</p><ul class=""><li id="dd72" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">获取所有的饲料</li><li id="be0d" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">GET /feeds/{hashtag}</code>获取包含标签的所有提要</li><li id="442a" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">POST /feeds</code>创造新的饲料</li></ul><p id="b256" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的标签服务上，我有两个端点</p><ul class=""><li id="2d06" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">GET /hashtags </code>获取所有标签</li><li id="e617" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">GET /hashtags/{name}</code>按名字获取单个标签</li></ul><p id="f60b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目标是当前端服务向API网关发送请求时，请求将被重新路由到应该处理它的服务。请看下图，API网关是如何重新路由请求的。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/3157489fecbea49b882838f80c3f8354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKgcjXIRvTZldqu49TGnDQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">API Gateway reroute upcoming request</figcaption></figure><h2 id="f1e6" class="na le in bd lf nb nc dn lj nd ne dp ln kl nf ng lr kp nh ni lv kt nj nk lz nl bi translated"><strong class="ak">创建一个新的Express JS项目</strong></h2><p id="6f41" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">新建一个Express JS项目，可以关注官网<a class="ae jz" href="https://expressjs.com/en/starter/installing.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="56f0" class="na le in bd lf nb nc dn lj nd ne dp ln kl nf ng lr kp nh ni lv kt nj nk lz nl bi translated">创建index.js</h2><p id="acee" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">在创建index.js之前，安装<a class="ae jz" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>以使我们能够解析POST数据。运行这个命令来安装主体解析器</p><pre class="kz la lb lc gt nm mt nn no aw np bi"><span id="334b" class="na le in mt b gy nq nr l ns nt">npm install -s body-parser</span></pre><p id="025c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mq mr ms mt b">index.js</code>将成为我们的切入点。这里是我们的<code class="fe mq mr ms mt b">index.js</code></p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1fab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要运行服务器，请运行以下命令</p><pre class="kz la lb lc gt nm mt nn no aw np bi"><span id="05e3" class="na le in mt b gy nq nr l ns nt">node index.js</span></pre><p id="9204" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后访问<code class="fe mq mr ms mt b">localhost:3000</code>并确保它正常工作。现在，我们将创建路由器作为API网关的入口点。首先，在根文件夹下创建一个新目录，命名为<code class="fe mq mr ms mt b">routers</code>。其次，在<code class="fe mq mr ms mt b">router</code>目录下创建四个文件，分别是<code class="fe mq mr ms mt b">router.js</code>、<code class="fe mq mr ms mt b">apiAdapter.js</code>、<code class="fe mq mr ms mt b">feedService.js</code>和<code class="fe mq mr ms mt b">hashtagService.js</code>。这里每个文件的用途</p><ul class=""><li id="bf10" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">router.js</code>是组合所有的服务端点</li><li id="c5bc" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">apiAdapter.js</code>是为每个服务构建API端点</li><li id="b5bc" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">feedService.js</code>是重新路由请求到Feed服务的文件</li><li id="0217" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b">hashtagService.js</code>是将请求重新路由到Hashtag服务的文件</li></ul><p id="2e1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使您的<code class="fe mq mr ms mt b">router.js</code>、<code class="fe mq mr ms mt b">feedService.js</code>和<code class="fe mq mr ms mt b">hashtagService.js</code>像下面的代码一样</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="769c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更新这些文件后，尝试重新运行服务器并访问每个端点，确保一切正常。但在此之前，我们没有重新路由任何请求。那么我们该怎么做呢？</p><p id="3a10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要先安装<a class="ae jz" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>。我们使用Axios来构建HTTP客户端。要安装Axios，请运行以下命令</p><pre class="kz la lb lc gt nm mt nn no aw np bi"><span id="bdec" class="na le in mt b gy nq nr l ns nt">npm install -s axios</span></pre><p id="fed9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安装Axios之后，现在在你的<code class="fe mq mr ms mt b">apiAdapter.js</code>上写这个代码</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="834d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，更新你的<code class="fe mq mr ms mt b">feedService.js</code>和<code class="fe mq mr ms mt b">hashtagService.js</code>像下面的代码</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3746" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面代码的目的是为每个服务创建HTTP客户端。我们为每个服务构造新的Axios对象，并将<code class="fe mq mr ms mt b">BASE_URL</code>作为参数传递。<code class="fe mq mr ms mt b">BASE_URL</code>是每个服务的基本URL。因此，当API网关收到请求时，它将由之前使用<code class="fe mq mr ms mt b">BASE_URL</code>构建的Axios对象处理。搞定了。就这么简单。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="8906" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我如何使用Express JS创建自己的API网关。实际上，API网关并不仅仅用于重新路由请求。API网关还用作认证器服务、处理数据缓存和响应聚合器。</p><p id="4f72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢Jonathan Natanael Siahaan 教我如何写一个好的代码设计。哦，对了，我的存储库上的API网关已经被修改了，JWT添加来处理认证。你可以在这里找到我的完整代码</p><div class="of og gp gr oh oi"><a href="https://github.com/ecojuntak/api-gateway" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">ecojuntak/API-网关</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">使用Express JS的简单API网关。通过在GitHub上创建一个帐户，为ecojuntak/api-gateway开发做出贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jt oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://github.com/ecojuntak/hashtag-api" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">ecojuntak/hashtag-api</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">使用Golang的简单REST API。通过在GitHub上创建一个帐户，为ecojuntak/hashtag-api开发做出贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow jt oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://github.com/ecojuntak/feed-api" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">ecojuntak/feed-api</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">使用Lumen的简单REST API。在GitHub上创建一个帐户，为ecojuntak/feed-api的开发做出贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow jt oi"/></div></div></a></div><p id="de6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">卡皮·霍丁！😎 💻 ☕️</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="oz nv l"/></div></figure></div></div>    
</body>
</html>