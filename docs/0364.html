<html>
<head>
<title>Kotlin Demystified: When to use custom accessors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin揭秘:何时使用自定义访问器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/kotlin-demystified-when-to-use-custom-accessors-939a6e998899?source=collection_archive---------8-----------------------#2018-08-28">https://medium.com/androiddevelopers/kotlin-demystified-when-to-use-custom-accessors-939a6e998899?source=collection_archive---------8-----------------------#2018-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7ade95072317bc03cffd81b4449f43d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPpuzlPVoflVQc8QQHLp7Q.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/t5YUoHW6zRo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Barn Images</a> on <a class="ae it" href="https://unsplash.com/search/photos/toolbox?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1964" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在处理<a class="ae it" href="https://github.com/googlesamples/android-UniversalMusicPlayer" rel="noopener ugc nofollow" target="_blank"> UAMP </a>时，我发现出于各种原因，将几个支持库类包装在一个助手中很方便。我想从这个<a class="ae it" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/7e4820893ff26c15f4d11cf90e2a168e06f1e60f/app/src/main/java/com/example/android/uamp/MediaSessionConnection.kt" rel="noopener ugc nofollow" target="_blank">包装器</a>中得到的一个特性是快速引用“传输控制”类的能力，该类用于发出播放和暂停等命令。</p><p id="fc70" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了方便起见，我在包装器中添加了一个属性:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f73a" class="kb kc hh jx b fi kd ke l kf kg">val transportControls: MediaControllerCompat.TransportControls<br/>    = mediaController.transportControls</span></pre><p id="bc06" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需要记住的是，<code class="du kh ki kj jx b">mediaController</code>是一个<code class="du kh ki kj jx b">lateinit var</code>，因为它是在回调服务连接时创建的。因此，当应用程序运行时，这段代码会立即崩溃:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="bc6a" class="kb kc hh jx b fi kd ke l kf kg">E/AndroidRuntime: FATAL EXCEPTION: main<br/>    Process: com.example.android.uamp.next, PID: 18641<br/>    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.android.uamp.next/com.example.android.uamp.MainActivity}:<br/>    kotlin.UninitializedPropertyAccessException: lateinit property mediaController has not been initialized</span></pre><p id="1711" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/7e4820893ff26c15f4d11cf90e2a168e06f1e60f/app/src/main/java/com/example/android/uamp/MediaSessionConnection.kt#L59-L60" rel="noopener ugc nofollow" target="_blank">修复方法</a>是向该属性添加一个自定义访问器:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="9c25" class="kb kc hh jx b fi kd ke l kf kg">val transportControls: MediaControllerCompat.TransportControls<br/>    get() = mediaController.transportControls</span></pre><p id="ccc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是为什么呢？</p><p id="e44c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">理解发生了什么的最简单的方法是查看这两种变体的字节码。在Android Studio中这样做就像<strong class="iw hi">工具&gt; Kotlin &gt;显示Kotlin字节码</strong>一样简单。然后选择<strong class="iw hi">反编译</strong>按钮查看等价的Java代码。</p><p id="b8c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">没有<code class="du kh ki kj jx b">get()</code>:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0399" class="kb kc hh jx b fi kd ke l kf kg">@NotNull<br/>private final TransportControls transportControls = mediaController.getTransportControls();</span><span id="fab9" class="kb kc hh jx b fi kk ke l kf kg">@NotNull<br/>public final TransportControls getTransportControls() {<br/>    return this.transportControls;<br/>}</span></pre><p id="f5f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用<code class="du kh ki kj jx b">get()</code>:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fd1b" class="kb kc hh jx b fi kd ke l kf kg">@NotNull<br/>public final TransportControls getTransportControls() {<br/>    return mediaController.getTransportControls();<br/>}</span></pre><p id="7660" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在第一种情况下，当构造类时，一个成员变量<code class="du kh ki kj jx b">transportControls</code>正在被设置。在第二个示例中，它实际上在每次访问<code class="du kh ki kj jx b">transportControls</code>属性时都会调用<code class="du kh ki kj jx b">mediaController.getTransportControls()</code>。</p><p id="1f5a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对我来说，这正是我想做的。我不想把从<code class="du kh ki kj jx b">mediaController.getTransportControls()</code>返回的对象保存在我的对象里，我只是想让写那个代码更方便。正因为如此，代号应该是<code class="du kh ki kj jx b">val transportControls get() = ...</code>。</p><p id="fcd2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，这并不总是正确的方法。以这段代码为例:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="864a" class="kb kc hh jx b fi kd ke l kf kg">val ticket get() = findTicketInDb()</span></pre><p id="f6d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">呀！每次访问<code class="du kh ki kj jx b">ticket</code>时，代码都会在数据库中搜索车票！这可能不是我们想要的。在这种情况下，正确的方法应该是这样写:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="56b9" class="kb kc hh jx b fi kd ke l kf kg">val ticket = findTicketInDb()</span></pre><p id="100f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将在创建对象时调用<code class="du kh ki kj jx b">findTicketInDb()</code> <em class="kl">一次</em>，并在每次访问属性<code class="du kh ki kj jx b">ticket</code>时返回相同的值。</p><p id="c065" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">科特林属性可能看似简单。理解创建对象时计算一次的属性和使用自定义<code class="du kh ki kj jx b">get()</code>方法的属性(每次访问属性时计算一次)之间的区别，可能意味着编写清晰的代码和将非预期的行为引入应用程序之间的区别。</p><p id="ed7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请务必关注<a class="ae it" href="https://medium.com/androiddevelopers" rel="noopener"> Android开发者</a>出版物，获取更多精彩内容，并关注更多关于Kotlin的文章！</p></div></div>    
</body>
</html>