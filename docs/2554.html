<html>
<head>
<title>Golang Series — Empty Struct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang系列—空结构</h1>
<blockquote>原文：<a href="https://medium.easyread.co/golang-series-empty-struct-ed317e6d8600?source=collection_archive---------2-----------------------#2021-01-14">https://medium.easyread.co/golang-series-empty-struct-ed317e6d8600?source=collection_archive---------2-----------------------#2021-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9d0d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">空结构？这是什么？当我们使用时，使用空结构有什么好处？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/96afea53667928864f6950bcf268bb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_D3piIfk4g7n_AnReIxJA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://pixabay.com/photos/the-interior-of-the-boards-wall-254577/" rel="noopener ugc nofollow" target="_blank">pixabay</a></figcaption></figure><p id="dc9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大家好！在这个时候，我想分享一些与软件工程领域的技术相关的经验、想法或观点。然而，我的文章可能是一个轻松的话题，只是简短。我想分享我在Golang中使用空结构的经验和看法。</p><p id="dd38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在过去，我经常发现让我只使用没有值的键的情况，例如在一个片上有一个唯一的键。那时候，我总是使用带bool键的地图。如果我想得到唯一的int，方法如下:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="2f04" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">func </strong>UniqueInt(slice []int) []int {<br/>   mapInt := make(<strong class="lq io">map</strong>[int]bool)<br/>   <strong class="lq io">for </strong>_, v := <strong class="lq io">range </strong>slice {<br/>      mapInt[v] = <strong class="lq io">true</strong><em class="ma"><br/>   </em>}<br/><br/>   output := []int{}<br/><br/>   <strong class="lq io">for </strong>v := <strong class="lq io">range </strong>mapInt{<br/>      output= append(output, v)<br/>   }<br/><br/>   <strong class="lq io">return output</strong><br/>}</span></pre><p id="87f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，有时我会看到一些使用空结构<code class="fe mb mc md lq b"><strong class="kv io">struct{}</strong></code>的实现。为什么要用这个，有什么好处？</p><p id="6370" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从尺寸开始，<code class="fe mb mc md lq b"><strong class="kv io">empty struct</strong></code>相对于其他尺寸最小。下面是获取大小的示例代码:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a19a" class="lu lv in lq b gy lw lx l ly lz">package main</span><span id="4dc7" class="lu lv in lq b gy me lx l ly lz">import (<br/>     "fmt"<br/>     "unsafe"<br/> )<br/> <br/> func main() {<br/>     var s struct{}<br/>     var i interface{}<br/>     var b bool<br/>     fmt.Println(unsafe.Sizeof(s), unsafe.Sizeof(i), unsafe.Sizeof(b))<br/> }</span></pre><p id="c94e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e8de" class="lu lv in lq b gy lw lx l ly lz">0 16 1</span></pre><p id="aa82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以看到，空结构有<code class="fe mb mc md lq b"><strong class="kv io">0</strong></code>。而我一直用的<code class="fe mb mc md lq b"><strong class="kv io">bool</strong></code>有<code class="fe mb mc md lq b"><strong class="kv io">1</strong></code>值。</p><p id="265b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，关于内存使用。我找到了一些代码(references链接可以在References部分找到),并尝试修改它们以获得来自<code class="fe mb mc md lq b"><strong class="kv io">empty struct</strong></code>和<code class="fe mb mc md lq b"><strong class="kv io">bool</strong></code>的结果。参见下面的代码:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="7f1f" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">package </strong>main<br/><br/><strong class="lq io">import </strong>(<br/>   <strong class="lq io">"fmt"<br/>   "runtime"<br/></strong>)<br/><br/><strong class="lq io">func </strong>main() {<br/>   <em class="ma">// Below is an example of using our PrintMemUsage() function<br/>   // Print our starting memory usage (should be around 0mb)<br/>   </em>fmt.Println(<strong class="lq io">"Start"</strong>)<br/>   PrintMemUsage()<br/>   fmt.Println(<strong class="lq io">""</strong>)<br/><br/>   structContainer := make(<strong class="lq io">map</strong>[int]<strong class="lq io">struct</strong>{}, 1000000)<br/>   <strong class="lq io">for </strong>i := 0; i &lt; 1000000; i++ {<br/>      structContainer[i] = <strong class="lq io">struct</strong>{}{}<br/>   }<br/><br/>   fmt.Println(<strong class="lq io">"With 1kk empty struct{}"</strong>)<br/>   PrintMemUsage()<br/>   fmt.Println(<strong class="lq io">""</strong>)<br/><br/>   nilContainer := make(<strong class="lq io">map</strong>[int]<strong class="lq io">interface</strong>{}, 1000000)<br/>   <strong class="lq io">for </strong>i := 0; i &lt; 1000000; i++ {<br/>      nilContainer[i] = nil<br/>   }<br/><br/>   fmt.Println(<strong class="lq io">"With 1kk nil interface{}"</strong>)<br/>   PrintMemUsage()<br/>   fmt.Println(<strong class="lq io">""</strong>)<br/><br/>   boolContainer := make(<strong class="lq io">map</strong>[int]bool, 1000000)<br/>   <strong class="lq io">for </strong>i := 0; i &lt; 1000000; i++ {<br/>      boolContainer[i] = <strong class="lq io"><em class="ma">true<br/>   </em></strong>}<br/><br/>   fmt.Println(<strong class="lq io">"With 1kk true bool"</strong>)<br/>   PrintMemUsage()<br/>   fmt.Println(<strong class="lq io">""</strong>)<br/><br/>}<br/><br/><em class="ma">// PrintMemUsage outputs the current, total and OS memory being used. As well as the number<br/>// of garage collection cycles completed.<br/></em><strong class="lq io">func </strong>PrintMemUsage() {<br/>   <strong class="lq io">var </strong>m runtime.MemStats<br/>   runtime.ReadMemStats(&amp;m)<br/>   <em class="ma">// For info on each, see: https://golang.org/pkg/runtime/#MemStats<br/>   </em>fmt.Printf(<strong class="lq io">"Alloc = %v KiB"</strong>, bToMb(m.Alloc))<br/>   fmt.Printf(<strong class="lq io">"\tTotalAlloc = %v KiB"</strong>, bToMb(m.TotalAlloc))<br/>   fmt.Printf(<strong class="lq io">"\tSys = %v KiB"</strong>, bToMb(m.Sys))<br/>   fmt.Printf(<strong class="lq io">"\tNumGC = %v\n"</strong>, m.NumGC)<br/>}<br/><br/><strong class="lq io">func </strong>bToMb(b uint64) uint64 {<br/>   <strong class="lq io">return </strong>b / 1024<br/>}</span></pre><p id="4856" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们运行上面的代码时，我们会得到这样的结果:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ca0f" class="lu lv in lq b gy lw lx l ly lz">Start<br/>Alloc = 84 KiB TotalAlloc = 84 KiB Sys = 69714 KiB NumGC = 0</span><span id="12b4" class="lu lv in lq b gy me lx l ly lz">With 1kk struct{}<br/>Alloc = 21986 KiB TotalAlloc = 21999 KiB Sys = 71440 KiB NumGC = 1</span><span id="3aa4" class="lu lv in lq b gy me lx l ly lz">With 1kk nil interface{}<br/>Alloc = 56649 KiB TotalAlloc = 78576 KiB Sys = 139154 KiB NumGC = 2</span><span id="e8eb" class="lu lv in lq b gy me lx l ly lz">With 1kk bool<br/>Alloc = 80738 KiB TotalAlloc = 102665 KiB Sys = 139154 KiB NumGC = 2</span></pre><p id="5695" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据上面的数据，我们可以说<code class="fe mb mc md lq b"><strong class="kv io">empty struct</strong></code>由于Sys值而具有最低的内存使用率。从doc来看，<em class="ma"> Sys是从OS获得的内存总字节数。</em></p><p id="009c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后我们可以修改代码来查找唯一的int，如下所示:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="21ca" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">func </strong>UniqueInt(slice []int) []int {<br/>   mapInt := make(<strong class="lq io">map</strong>[int]struct{})<br/>   <strong class="lq io">for </strong>_, v := <strong class="lq io">range </strong>slice {<br/>      mapInt[v] = <strong class="lq io">struct{}{}</strong><em class="ma"><br/>   </em>}<br/><br/>   output := []int{}<br/><br/>   <strong class="lq io">for </strong>v := <strong class="lq io">range </strong>mapInt{<br/>      output= append(output, v)<br/>   }<br/><br/>   <strong class="lq io">return output</strong><br/>}</span></pre><p id="3895" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢你阅读我的文章，希望对你有用！下一个话题再见！</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="5a5f" class="mm lv in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">参考</h1><ol class=""><li id="1ae5" class="nd ne in kv b kw nf kz ng lc nh lg ni lk nj lo nk nl nm nn bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/59089869/memory-usage-nil-vs-empty-struct" rel="noopener ugc nofollow" target="_blank">内存使用:nil vs空结构{} </a></li></ol></div></div>    
</body>
</html>