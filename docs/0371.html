<html>
<head>
<title>Getting the Most from the New Multi-Camera API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用新的多摄像头API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/getting-the-most-from-the-new-multi-camera-api-5155fb3d77d9?source=collection_archive---------1-----------------------#2018-11-05">https://medium.com/androiddevelopers/getting-the-most-from-the-new-multi-camera-api-5155fb3d77d9?source=collection_archive---------1-----------------------#2018-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="84eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客文章补充了我们的<a class="ae jc" href="https://youtu.be/u38wOv2a_dA" rel="noopener ugc nofollow" target="_blank"> Android开发者峰会2018谈话</a>，该谈话是与Android相机项目经理Vinit Modi和合作伙伴开发者关系团队的Emilie Roberts合作完成的。查看我们之前的系列博文，包括<a class="ae jc" rel="noopener" href="/androiddevelopers/camera-enumeration-on-android-9a053b910cb5">相机枚举</a>、<a class="ae jc" rel="noopener" href="/androiddevelopers/understanding-android-camera-capture-sessions-and-requests-4e54d9150295">相机捕捉会话以及同时使用多个相机流的请求</a>和<a class="ae jc" rel="noopener" href="/androiddevelopers/using-multiple-camera-streams-simultaneously-bf9488a29482">。</a></p><h1 id="90b3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">多摄像机用例</h1><p id="974c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">多摄像头是随着<a class="ae jc" href="https://developer.android.com/about/versions/pie/android-9.0#camera" rel="noopener ugc nofollow" target="_blank"> Android Pie </a>推出的，自几个月前推出以来，我们现在看到市场上出现了支持API的设备，如谷歌Pixel 3和华为Mate 20系列。许多多摄像机用例与特定的硬件配置紧密相关；换句话说，并非所有的用例都与每种设备兼容——这使得多摄像头功能成为模块动态交付的绝佳候选。一些典型的使用案例包括:</p><ul class=""><li id="af53" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">变焦:根据裁剪区域或所需的焦距在相机之间切换</li><li id="7b25" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">深度:使用多个相机构建深度图</li><li id="0ed7" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">散景:使用推断的深度信息来模拟类似DSLR的窄聚焦范围</li></ul><h1 id="18b8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">逻辑和物理摄像机</h1><p id="a8bc" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">要理解多摄像头API，首先要理解逻辑摄像头和物理摄像头的区别；这个概念最好用一个例子来说明。例如，我们可以将一个有三个后置摄像头而没有前置摄像头的设备作为参考。在这个例子中，三个背部摄像机中的每一个都被认为是一个<em class="ku">物理摄像机</em>。一个<em class="ku">逻辑摄像机</em>则是两个或更多物理摄像机的组合。逻辑相机的输出可以是来自底层物理相机之一的流，或者同时来自多个底层物理相机的融合流；无论哪种方式都由摄像机HAL处理。</p><p id="4eac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">许多手机制造商还开发他们的第一方相机应用程序(通常预装在他们的设备上)。为了利用硬件的所有功能，他们有时会使用私有或隐藏的API，或者从驱动程序实现中获得其他应用程序无权访问的特殊待遇。一些设备甚至通过提供来自不同物理摄像机的融合帧流来实现逻辑摄像机的概念，但同样，这仅可用于某些特权应用。通常，只有一个物理摄像机会暴露在框架中。在Android Pie之前，第三方开发者的情况如下图所示:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/e78511842cee38f532c4611f3d09819f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jHgc12zW0MnFXf8V"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Camera capabilities typically only available to privileged applications</figcaption></figure><p id="6050" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从Android Pie开始，一些事情发生了变化。首先，<a class="ae jc" href="https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces" rel="noopener ugc nofollow" target="_blank">私有API不再适用于安卓应用。其次，随着框架中包含</a><a class="ae jc" href="https://source.android.com/devices/camera/multi-camera" rel="noopener ugc nofollow" target="_blank">多摄像头支持</a>，Android一直<a class="ae jc" href="https://source.android.com/compatibility/android-cdd#7_5_4_camera_api_behavior" rel="noopener ugc nofollow" target="_blank">强烈建议</a>手机制造商为所有面向同一方向的物理摄像头暴露一个逻辑摄像头。因此，这是第三方开发者在运行Android Pie和更高版本的设备上应该看到的内容:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/8c2027d83b1f5398f1b10de5a697449c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xnN-9_1XtmuWq-Lx"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Full developer access to all camera devices starting in Android P</figcaption></figure><p id="50b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值得注意的是，逻辑相机提供什么完全取决于相机HAL的OEM实现。例如，像Pixel 3这样的设备以这样一种方式实现其逻辑相机，即它将基于所请求的焦距和裁剪区域来选择其物理相机之一。</p><h1 id="c5ee" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">多摄像头API</h1><p id="57cb" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">新的API增加了以下新的常量、类和方法:</p><ul class=""><li id="0342" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><code class="du ll lm ln lo b">CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA</code></li><li id="5926" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ll lm ln lo b">CameraCharacteristics.getPhysicalCameraIds()</code></li><li id="bc65" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ll lm ln lo b">CameraCharacteristics.getAvailablePhysicalCameraRequestKeys()</code></li><li id="1361" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ll lm ln lo b">CameraDevice.createCaptureSession(SessionConfiguration config)</code></li><li id="917c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ll lm ln lo b">CameraCharactersitics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE</code></li><li id="ecf2" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ll lm ln lo b">OutputConfiguration</code> &amp; <code class="du ll lm ln lo b">SessionConfiguration</code></li></ul><p id="6d5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于对Android CDD的改变，多摄像头API也带来了开发者的一些期望。双摄像头设备在Android Pie之前就已经存在，但同时打开多个摄像头需要反复试验；Android上的多摄像头现在给了我们一套规则，告诉我们什么时候可以打开一对物理摄像头，只要它们是同一个逻辑摄像头的一部分。</p><p id="8c51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，我们可以预计，在大多数情况下，使用Android Pie的新设备将会暴露所有物理摄像头(除了更奇特的传感器类型，如红外摄像头)以及更容易使用的逻辑摄像头。此外，非常关键的是，我们可以预期，对于保证工作的每个流组合，属于逻辑摄像机的一个流可以被来自底层物理摄像机的两个流<strong class="ig hi">替换。让我们用一个例子更详细地介绍一下。</strong></p><h1 id="f476" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">多个流同时</h1><p id="53a4" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在我们的上一篇博文中，我们详细介绍了在一台相机中同时使用多个视频流的<a class="ae jc" rel="noopener" href="/androiddevelopers/using-multiple-camera-streams-simultaneously-bf9488a29482">规则。完全相同的规则适用于多台摄像机，值得注意的是在</a><a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA" rel="noopener ugc nofollow" target="_blank">文档</a>中有所解释:</p><blockquote class="lp lq lr"><p id="c6f8" class="ie if ku ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">对于每个保证的流组合，逻辑摄像机支持用相同大小和格式的两个物理流替换一个逻辑<a class="ae jc" href="https://developer.android.com/reference/android/graphics/ImageFormat.html#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV_420_888 </a>或原始流，每个物理流来自单独的物理摄像机，假设两个物理摄像机都支持该大小和格式。</p></blockquote><p id="5eae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，YUV或RAW类型的每个流可以用两个相同类型和大小的流来替换。例如，对于单摄像头设备，我们可以从以下保证配置的摄像头流开始:</p><ul class=""><li id="b821" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">流1: YUV类型，来自逻辑摄像机的最大大小` id = 0 '</li></ul><p id="8f16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，支持多摄像头的设备将允许我们创建一个会话，用两个物理流替换逻辑YUV流:</p><ul class=""><li id="6ecc" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">流1: YUV类型，来自物理相机的最大尺寸` id = 1 '</li><li id="afad" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">流2: YUV类型，来自物理相机的最大尺寸` id = 2 '</li></ul><p id="71e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">诀窍在于，当且仅当这两个相机是逻辑相机分组的一部分时，我们可以用两个等效的流来替换YUV或RAW流，即列在<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics#getPhysicalCameraIds()" rel="noopener ugc nofollow" target="_blank">camera characteristics . getphysicalcameraids()</a>下。</p><p id="1df8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一件要考虑的事情是，该框架提供的保证仅仅是同时从多个物理相机获取帧所需的最低要求。我们可以期待在大多数设备中支持额外的流，有时甚至允许我们独立打开多个物理相机设备。不幸的是，由于这不是框架的硬性保证，这样做将需要我们通过反复试验来执行每个设备的测试和调优。</p><h1 id="525f" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用多个物理摄像机创建会话</h1><p id="8926" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">当我们在支持多相机的设备中与物理相机交互时，我们应该打开单个<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice" rel="noopener ugc nofollow" target="_blank"> CameraDevice </a>(逻辑相机)并在单个会话中与之交互，这必须使用自SDK级别28起可用的API<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice#createCaptureSession(android.hardware.camera2.params.SessionConfiguration)" rel="noopener ugc nofollow" target="_blank">camera device . createcapturesession(session configuration config)</a>来创建。然后，<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/params/SessionConfiguration" rel="noopener ugc nofollow" target="_blank">会话配置</a>将有多个<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/params/OutputConfiguration" rel="noopener ugc nofollow" target="_blank">输出配置</a>，每个配置将有一组输出目标，以及可选的所需物理摄像机ID。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lv"><img src="../Images/7199a874c0425e7f97be244db09ab0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OY88erAolXSr5bA9"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">SessionConfiguration and OutputConfiguration model</figcaption></figure><p id="78c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">稍后，当我们分派一个捕获请求时，该请求将有一个与之相关联的输出目标。该框架将基于该请求附加了什么输出目标来确定该请求将被发送到哪个物理(或逻辑)摄像机。如果输出目标对应于作为<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/params/OutputConfiguration" rel="noopener ugc nofollow" target="_blank">输出配置</a>连同物理摄像机ID一起发送的输出目标之一，则该物理摄像机将接收并处理该请求。</p><h1 id="55af" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用一对物理摄像机</h1><p id="9e0f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">多摄像头的摄像头API中最重要的面向开发人员的新增功能之一是识别逻辑摄像头并找到其背后的物理摄像头的能力。现在，我们知道可以同时打开物理摄像机(同样，通过打开逻辑摄像机，并作为同一个会话的一部分)，并且合并流的规则也很清楚，我们可以定义一个函数来帮助我们识别可用于替换其中一个逻辑摄像机流的潜在物理摄像机对:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="018f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">物理摄像机的状态处理由逻辑摄像机控制。因此，要打开我们的“双摄像头”，我们只需打开与我们感兴趣的物理摄像头相对应的逻辑摄像头:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="962d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，除了选择打开哪个摄像机之外，与我们过去打开任何其他摄像机所做的相比，没有什么不同。现在是时候使用新的<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/params/SessionConfiguration" rel="noopener ugc nofollow" target="_blank">会话配置</a> API创建一个捕获会话了，这样我们可以告诉框架将某些目标与特定的物理摄像机id相关联:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="d9b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，我们可以回头参考一下<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.html#createCaptureSession%28android.hardware.camera2.params.SessionConfiguration%29" rel="noopener ugc nofollow" target="_blank">的文档</a>或者我们<a class="ae jc" rel="noopener" href="/androiddevelopers/using-multiple-camera-streams-simultaneously-bf9488a29482">以前的博客文章</a>来了解支持哪些流的组合。我们只需要记住，这些是针对单个逻辑摄像机上的多个流的，并且兼容性扩展到使用相同的配置，并用来自属于同一逻辑摄像机的两个物理摄像机的两个流来替换其中一个流。</p><p id="7ef7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession" rel="noopener ugc nofollow" target="_blank">摄像机会话</a>准备就绪，剩下要做的就是发送我们想要的<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CaptureRequest" rel="noopener ugc nofollow" target="_blank">捕获请求</a>。捕获请求的每个目标将从其关联的物理摄像机(如果有的话)接收数据，或者退回到逻辑摄像机。</p><h1 id="5938" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">缩放示例用例</h1><p id="337e" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了将所有这些联系到最初讨论的用例之一，让我们看看如何在我们的相机应用程序中实现一项功能，以便用户可以在不同的物理相机之间切换，以体验不同的视野，有效地捕捉不同的“缩放级别”。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ly"><img src="../Images/e5e2722b820f6bfa0ce1fc2fb855984f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*WaZN9bicOXI4mpUp"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Example of swapping cameras for zoom level use-case (from <a class="ae jc" href="https://www.youtube.com/watch?v=gJtJFEH1Cis" rel="noopener ugc nofollow" target="_blank">Pixel 3 Ad</a>)</figcaption></figure><p id="9b5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们必须选择一对我们希望允许用户在其间切换的物理摄像机。为了获得最佳效果，我们可以搜索分别提供最小和最大可用焦距的一对相机。这样，我们选择一个能够聚焦在最短距离上的摄像设备和另一个能够聚焦在最远距离上的摄像设备:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="2279" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个明智的架构是有两个<a class="ae jc" href="https://developer.android.com/reference/android/view/SurfaceView" rel="noopener ugc nofollow" target="_blank">表面视图</a>，每个流一个，在用户交互时交换，这样在任何给定时间只有一个可见。在下面的代码片段中，我们演示了如何打开逻辑摄像机、配置摄像机输出、创建摄像机会话和启动两个预览流；利用之前定义的功能:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="6630" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们需要做的就是为用户提供一个UI来在两个界面之间切换，比如一个按钮或者双击<code class="du ll lm ln lo b">SurfaceView</code>；如果我们想变得有趣，我们可以尝试执行某种形式的场景分析，并在两个流之间自动切换。</p><h1 id="0da5" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">透镜畸变</h1><p id="3353" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">所有的镜头都会产生一定程度的失真。在Android中，我们可以使用<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics#LENS_DISTORTION" rel="noopener ugc nofollow" target="_blank"> CameraCharacteristics查询镜头造成的失真。镜头失真</a>(取代了现在已经废弃的<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics#LENS_RADIAL_DISTORTION" rel="noopener ugc nofollow" target="_blank">相机特性。镜头_径向_扭曲</a>。对于逻辑相机，有理由期望失真最小，我们的应用程序可以或多或少地使用来自相机的帧。然而，对于实体相机，我们应该期待潜在的非常不同的镜头配置——尤其是在广角镜头上。</p><p id="8070" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一些设备可以通过<a class="ae jc" href="https://developer.android.com/reference/android/hardware/camera2/CaptureRequest#DISTORTION_CORRECTION_MODE" rel="noopener ugc nofollow" target="_blank">捕获请求实现自动失真校正。失真_校正_模式</a>。知道大多数设备的失真校正默认是打开的是很好的。文档中有一些更详细的信息:</p><blockquote class="lp lq lr"><p id="eba3" class="ie if ku ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">快速/高质量都意味着将应用相机设备确定失真校正。HIGH_QUALITY模式表示相机设备将使用最高质量的校正算法，即使它会降低捕获速率。快速意味着相机设备在应用校正时不会降低捕获速率。如果任何校正都会降低捕获速率，则FAST可能与OFF相同[…]该校正仅适用于YUV、JPEG或DEPTH16等已处理的输出[…]在支持此控件的设备上，此控件将默认打开。</p></blockquote><p id="b3b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们想以最高的质量拍摄一张静态照片，那么我们应该尝试将校正模式设置为HIGH_QUALITY(如果它可用的话)。下面是我们应该如何设置我们的捕获请求:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4267" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住，在此模式下设置捕捉请求会对相机产生的帧速率产生潜在影响，这就是为什么我们只在静态图像捕捉中设置失真校正。</p><h1 id="99aa" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">待续</h1><p id="2dd2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">唷！我们讨论了一系列与新的多摄像头API相关的内容:</p><ul class=""><li id="0f87" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">潜在的使用案例</li><li id="1226" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">逻辑摄像机与物理摄像机</li><li id="355e" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">多摄像头API概述</li><li id="c628" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">打开多个摄像机流的扩展规则</li><li id="1a74" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">如何为一对物理摄像机设置摄像机流</li><li id="241d" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">示例“变焦”用例交换摄像机</li><li id="792a" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">校正镜头失真</li></ul><p id="55ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，我们还没有介绍帧同步和计算深度图。这是一个值得在自己的博客上发表的话题🙂</p></div></div>    
</body>
</html>