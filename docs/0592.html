<html>
<head>
<title>Jetpack Compose — Before and after</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写-之前和之后</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f?source=collection_archive---------0-----------------------#2020-12-15">https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f?source=collection_archive---------0-----------------------#2020-12-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/468a36e3bab94d586a5114b9cbb834a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OX3QKBYPEQ6qvcSIvke1A.png"/></div></div></figure><div class=""/><div class=""><h2 id="914c" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">将Tivi示例应用程序迁移到Jetpack Compose后，构建速度、APK大小和源代码行数是如何变化的</h2></div></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><p id="9886" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><strong class="jq ht"> <em class="kk">此帖子自首次发布以来已经更新，新增了Jetpack Compose 1 . 0 . 0–rc01的更新统计数据。</em> </strong> <em class="kk">如果你想看这篇帖子的原版，请看</em> <a class="ae kl" href="https://web.archive.org/web/20210226105855/https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f" rel="noopener ugc nofollow"> <em class="kk">这里</em> </a> <em class="kk">。</em></p></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><p id="272b" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">2020年，我开始慢慢地将<a class="ae kl" href="https://tivi.app/" rel="noopener ugc nofollow" target="_blank"> Tivi </a>中的UI移植到<a class="ae kl" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>中，大约12个月后，这项任务已经完成。🎉</p><p id="2493" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">在这篇博文中，我们将回顾并比较一些关键指标，看看Compose在APK大小、构建速度和代码行数方面的表现如何。</p><h1 id="2325" class="km kn hs bd ko kp kq kr ks kt ku kv kw iy kx iz ky jb kz jc la je lb jf lc ld bi translated">该应用程序</h1><p id="364a" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">在我深入到编写方面之前，让我快速描述一下这个应用程序。</p><p id="baf0" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">Tivi是高度模块化的，每个UI“屏幕”都在它自己的Gradle模块中(名为<code class="du lj lk ll lm b">ui-$NAME</code>)。这些屏幕中的每一个都在一个<code class="du lj lk ll lm b"><a class="ae kl" href="https://developer.android.com/guide/fragments" rel="noopener ugc nofollow" target="_blank">Fragment</a></code>中实现，然后使用主<code class="du lj lk ll lm b">app</code>模块中的<a class="ae kl" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank"> AndroidX导航</a>拼凑在一起。为了让你对结构有一个概念，这里有一个应用程序模块的图表:</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ln"><img src="../Images/2c5c172f4403e017d6a148f8e53207eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fg571ukn-dDaEV7FHAyd4A.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Graph of Tivi’s module structure. Generated using <a class="ae kl" href="https://twitter.com/JakeWharton" rel="noopener ugc nofollow" target="_blank">Jake Wharton</a>’s handy <a class="ae kl" href="https://github.com/JakeWharton/SdkSearch/blob/master/gradle/projectDependencyGraph.gradle" rel="noopener ugc nofollow" target="_blank">Gradle task</a></figcaption></figure><p id="e45e" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">由于导航图是使用<a class="ae kl" href="https://developer.android.com/guide/navigation/navigation-deep-link" rel="noopener ugc nofollow" target="_blank">深度链接URIs </a>实现的，确保了解耦，所以大多数片段彼此并不了解。也许更重要的是，它还允许独立的模块编译，这有助于构建并行性。</p><p id="a599" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><em class="kk">注:Tivi的模块结构无论如何都不是完美的。UI模块(在顶部)对基本模块(在底部)的依赖太多。理想情况下，每一层都应该分开。让我继续努力。</em></p><p id="b24c" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">在我开始迁移到Compose之前，Tivi使用了所有酷的🌈用户界面💫Android开发者可用的东西:<a class="ae kl" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">数据绑定</a>、<a class="ae kl" href="https://github.com/airbnb/epoxy" rel="noopener ugc nofollow" target="_blank">环氧</a>、<a class="ae kl" href="http://material.io/develop/android/" rel="noopener ugc nofollow" target="_blank">材质设计组件</a>、<a class="ae kl" href="https://github.com/chrisbanes/insetter" rel="noopener ugc nofollow" target="_blank"> Insetter DBX </a>、<a class="ae kl" href="https://developer.android.com/training/constraint-layout/motionlayout" rel="noopener ugc nofollow" target="_blank"> MotionLayout </a>不一而足。但不幸的是，大多数都有构建成本，因为它们使用了注释处理。</p><h1 id="f8c4" class="km kn hs bd ko kp kq kr ks kt ku kv kw iy kx iz ky jb kz jc la je lb jf lc ld bi translated">迁移过程</h1><p id="f136" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">前面我提到我们刚刚完成了迁移的“第一阶段”,我这么说是什么意思呢？这个应用程序看起来几乎和我2020年2月开始使用时一样。</p><p id="11e2" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">该应用的模块化特性意味着迁移本身可以一部分一部分地完成，这正是过去11个月发生的事情，涵盖了<a class="ae kl" href="https://github.com/chrisbanes/tivi/pulls?q=compose" rel="noopener ugc nofollow" target="_blank"> 46个拉请求</a>。</p><p id="ac52" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我从一个简单的画面开始:<a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/544" rel="noopener ugc nofollow" target="_blank">剧集详情</a>，然后迁移了S <a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/583" rel="noopener ugc nofollow" target="_blank">如何详情</a>，然后'<a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/692" rel="noopener ugc nofollow" target="_blank">发现</a>，然后'<a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/711" rel="noopener ugc nofollow" target="_blank">搜索</a>，然后'<a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/720" rel="noopener ugc nofollow" target="_blank">跟着显示</a>等等。随着最近添加了对Compose 的Paging3支持，我可以迁移最终的屏幕:“列表”网格:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">Video showing the Tivi app, before and after the migration</figcaption></figure><p id="52ae" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">迁移的第一阶段导致应用程序使用<a class="ae kl" href="https://developer.android.com/guide/fragments" rel="noopener ugc nofollow" target="_blank">片段</a>和<a class="ae kl" href="https://developer.android.com/guide/navigation/navigation-getting-started" rel="noopener ugc nofollow" target="_blank">导航</a>，每个片段的UI通过Jetpack Compose实现。</p><p id="20f8" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">第二个(也是最后一个)阶段是从片段中迁移出来，直接使用<a class="ae kl" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">导航组合组件</a>。这在本PR中完成:</p><div class="hg hh ez fb hi ly"><a href="https://github.com/chrisbanes/tivi/pull/761" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd ht fi z dy md ea eb me ed ef hr bi translated">迁移到由chrisbanes Pull Request # 761 chrisbanes/tivi编写导航</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">这个PR从Tivi*中移除(几乎)所有片段，并迁移所有内容以构成导航。没有…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ho ly"/></div></div></a></div><blockquote class="mn"><p id="f582" class="mo mp hs bd mq mr ms mt mu mv mw kj dx translated">对我来说，Compose是Android上UI开发的未来是显而易见的。</p></blockquote><p id="fa32" class="pw-post-body-paragraph jo jp hs jq b jr mx it jt ju my iw jw jx mz jz ka kb na kd ke kf nb kh ki kj ha bi translated">那么，让我们来看一些指标…📊</p><h1 id="f8aa" class="km kn hs bd ko kp kq kr ks kt ku kv kw iy kx iz ky jb kz jc la je lb jf lc ld bi translated">韵律学</h1><p id="2790" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">对于下面的每个指标，我们将比较三个不同版本的应用程序:</p><ol class=""><li id="74cf" class="nc nd hs jq b jr js ju jv jx ne kb nf kf ng kj nh ni nj nk bi translated"><strong class="jq ht">预合成。</strong>这是<a class="ae kl" href="https://github.com/chrisbanes/tivi/commit/07ac27d9e7cba0eef76ef44cc9551261e2b3f9db" rel="noopener ugc nofollow" target="_blank">提交</a> <em class="kk">之前</em>我在2020年2月登陆了第一个为Tivi添加撰写支持的PR。</li><li id="ff8e" class="nc nd hs jq b jr nl ju nm jx nn kb no kf np kj nh ni nj nk bi translated"><strong class="jq ht">片段+构成。</strong>这基于标志着迁移第一阶段结束的<a class="ae kl" href="https://github.com/chrisbanes/tivi/commit/8f4d9c05aeb6ed092d9fe49a3335c8c56cfb7f03" rel="noopener ugc nofollow" target="_blank">提交</a>。我后来分支并更新了它，使用Jetpack Compose 1.0.0-beta05、AGP 7.0.0-alpha14、Gradle 7.0和Kotlin 1.4.32，以便直接比较。</li><li id="dc3f" class="nc nd hs jq b jr nl ju nm jx nn kb no kf np kj nh ni nj nk bi translated"><strong class="jq ht">完全构成。</strong>这是使用当前的树顶main <a class="ae kl" href="https://github.com/chrisbanes/tivi/commit/eb1283881454fd34004c1eff0162d6781b0efbd1" rel="noopener ugc nofollow" target="_blank">提交</a>。Tivi完全基于Compose(使用<em class="kk"> 1.0.0-rc01) </em>，app中没有片段。</li></ol><h1 id="a151" class="km kn hs bd ko kp kq kr ks kt ku kv kw iy kx iz ky jb kz jc la je lb jf lc ld bi translated">APK尺寸🗜</h1><p id="e7b2" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">你的用户最关心的指标:APK尺寸。</p><p id="a0bb" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">以下结果是在<a class="ae kl" href="https://developer.android.com/studio/build/shrink-code#shrink-resources" rel="noopener ugc nofollow" target="_blank">资源缩减</a>启用的情况下，使用<a class="ae kl" href="https://developer.android.com/studio/build/apk-analyzer" rel="noopener ugc nofollow" target="_blank"> APK分析仪</a>测得的缩小的<code class="du lj lk ll lm b">release</code> APK(使用R8)的结果。</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nq"><img src="../Images/9ab757ab2ad557ca02225767af5bbc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHXoFXOmuPojvmjtOapYrw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Chart showing APK size of Tivi</figcaption></figure><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nq"><img src="../Images/c16423e928591d2188ef1ef90dd91534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NoYE8XV00OY1JPAriyKsA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Chart showing method count of Tivi</figcaption></figure><h2 id="ed67" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">关于这些数字的一些注释:</h2><ul class=""><li id="5362" class="nc nd hs jq b jr le ju lf jx of kb og kf oh kj oi ni nj nk bi translated">我们使用从<a class="ae kl" href="https://developer.android.com/studio/build/apk-analyzer" rel="noopener ugc nofollow" target="_blank"> APK分析器</a>报告的“APK文件大小”(不是下载大小)。</li></ul><h2 id="ac68" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">APK粒度分析</h2><p id="6be0" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">当比较调整后的值与“预合成”时，我们看到使用Compose时，APK大小减少了<strong class="jq ht"> 46% </strong>，方法数量减少了<strong class="jq ht"> 17% </strong>。🤯</p><blockquote class="mn"><p id="861a" class="mo mp hs bd mq mr oj ok ol om on kj dx translated">当使用Compose时，我们看到APK大小减少了<strong class="ak"> 41% </strong>，方法数量减少了<strong class="ak"> 17% </strong></p></blockquote><p id="eb1a" class="pw-post-body-paragraph jo jp hs jq b jr mx it jt ju my iw jw jx mz jz ka kb na kd ke kf nb kh ki kj ha bi translated">这个数字显示了当你需要保留所有的<code class="du lj lk ll lm b">View</code>类时，缩小工具能有多大的帮助，以防在布局文件中使用它们。</p></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><h1 id="a3a6" class="km kn hs bd ko kp oo kr ks kt op kv kw iy oq iz ky jb or jc la je os jf lc ld bi translated">代码行📜</h1><p id="eaaa" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">现在，我知道在比较软件项目时，计算源代码行数并不是一个特别有用的统计数据，但是它确实提供了对事物如何变化的洞察。</p><p id="0286" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">对于这个测试，我使用了<a class="ae kl" href="https://github.com/AlDanial/cloc" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ht">时钟</strong> </a>工具，使用以下命令来排除任何构建、生成和配置文件:</p><pre class="lo lp lq lr fd ot lm ou ov aw ow bi"><span id="4e5e" class="nr kn hs lm b fi ox oy l oz pa">cloc . --exclude-dir=build,.idea,schemas</span></pre><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es pb"><img src="../Images/2b0e5740ae31400f474750703ba9177e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ryb9ZOTZUcgQgTKS3Zu2g.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Chart showing lines of source code in Tivi</figcaption></figure><p id="7e34" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><code class="du lj lk ll lm b">cloc</code>工具内置了对忽略注释的支持(虽然我没有验证这一点)，所以上面的结果是针对实际的“代码”的。不出所料，XML行数减少了<em class="kk">非常大的幅度:<strong class="jq ht"> 76% </strong>。拜拜布局文件、样式、主题和许多其他XML文件。👋</em></p><p id="aebb" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">同样有趣的是，科特林的线路总数也下降了。我的工作理论是，我们现在在应用程序中有更少的样板文件，我们能够删除许多视图助手和实用程序代码。见<a class="ae kl" href="https://github.com/chrisbanes/tivi/pull/713" rel="noopener ugc nofollow" target="_blank">这个PR </a>去掉了我这些年写的近<strong class="jq ht">3000</strong>行:</p><div class="hg hh ez fb hi ly"><a href="https://github.com/chrisbanes/tivi/pull/713" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd ht fi z dy md ea eb me ed ef hr bi translated">通过chrisbanes pull request # 713 chrisbanes/tivi删除旧代码🗑️的负载</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">github.com</p></div></div><div class="mh l"><div class="pc l mj mk ml mh mm ho ly"/></div></div></a></div></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><h1 id="9573" class="km kn hs bd ko kp oo kr ks kt op kv kw iy oq iz ky jb or jc la je os jf lc ld bi translated">构建速度⏳</h1><p id="d11a" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">构建速度是开发人员非常关心的一个指标。在开始这个过程之前，我有一种感觉，去掉许多注释处理器将有助于提高构建速度，但我不确定提高多少。</p><h2 id="86cf" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">测试设置</h2><p id="1863" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">在我继续之前，知道我是如何测量下面的数字是很重要的。当Chris Horner 在不同的CPU上测量<a class="ae kl" href="https://chrishorner.codes/post/cpu-build-comparison/" rel="noopener ugc nofollow" target="_blank">构建时间时，我使用了与</a><a class="ae kl" href="https://twitter.com/chris_h_codes" rel="noopener ugc nofollow" target="_blank">类似的设置。</a></p><p id="fbc3" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我测试的机器是联想P920，内存为192GB，CPU为<em class="kk">非常快</em>的<a class="ae kl" href="https://www.intel.co.uk/content/www/uk/en/products/processors/xeon/scalable/gold-processors/gold-6154.html" rel="noopener ugc nofollow" target="_blank"> Xeon Gold 6154 </a>。不用说，这台机器不是典型的开发人员设置，所以为了使测试更加真实，我将CPU固定在它的最低时钟频率:</p><pre class="lo lp lq lr fd ot lm ou ov aw ow bi"><span id="eef4" class="nr kn hs lm b fi ox oy l oz pa"># Use performance governor to allow tweaking of max freq<br/>sudo cpupower frequency-set -g performance<br/># Set max frequency to CPU minimum: 1.2GHz<br/>sudo cpupower frequency-set -u 1.2GHz</span></pre><p id="64d0" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">为了启动所有的远程藏物缓存，我运行了<code class="du lj lk ll lm b">./gradlew assembleDebug</code>。</p><p id="3875" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">为了运行测试，我在一个循环中运行了以下命令5次:</p><pre class="lo lp lq lr fd ot lm ou ov aw ow bi"><span id="0324" class="nr kn hs lm b fi ox oy l oz pa"> <!-- -->./gradlew --profile \<br/>           --offline \<br/>           --rerun-tasks \<br/>           --max-workers=4 \<br/>           assembleDebug</span></pre><blockquote class="pd pe pf"><p id="5d02" class="jo jp kk jq b jr js it jt ju jv iw jw pg jy jz ka ph kc kd ke pi kg kh ki kj ha bi translated"><code class="du lj lk ll lm b">--max-workers</code>不是绝对必要的，但是默认情况下，Gradle将使用该CPU上所有的64个“内核”。限制为4个更类似于典型的笔记本电脑CPU。</p></blockquote><h2 id="14f1" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">结果</h2><p id="d05d" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">使用每个生成的配置文件报告的“总构建时间”值，您可以看到下面的测试结果。</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es pj"><img src="../Images/c9e8056e6a7fc31ea15d25c4e336a952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmfuV2Hqtj3K6JAq9Z4ChQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Chart showing median build time of Tivi</figcaption></figure><p id="79a1" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">这个结果让我很惊讶，因为“完全合成”的时间比“合成中的每个片段”快<strong class="jq ht"> 25秒</strong>。🤔</p><p id="f542" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">感谢伊万·加夫里洛维奇(Ivan gavrilovi)找出原因，这与作曲无关。“完全合成”是使用最新版本的匕首/剑柄，它使用了Android Gradle Plugin 7.0中的新ASM API。该应用程序的其他版本使用的是旧版本的剑柄，它使用了不同的机制，导致下载时间为<em class="kk">slow www。</em></p><p id="8649" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">退一步说，当你想到Kotlin编译器&amp;composite编译器插件现在为我们做的一切，比如位置记忆和细粒度重组，构建时间的<strong class="jq ht"> 29% </strong> <strong class="jq ht">减少</strong>是惊人的。更多信息请参见<a class="ae kl" rel="noopener" href="/@intelligibabble"> Leland </a>这篇文章:</p><div class="hg hh ez fb hi ly"><a rel="noopener follow" target="_blank" href="/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd ht fi z dy md ea eb me ed ef hr bi translated">了解Jetpack编写—第1部分，共2部分</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">使用合成构建更好的用户界面</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">medium.com</p></div></div><div class="mh l"><div class="pk l mj mk ml mh mm ho ly"/></div></div></a></div></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><h1 id="2c5f" class="km kn hs bd ko kp oo kr ks kt op kv kw iy oq iz ky jb or jc la je os jf lc ld bi translated">警告</h1><p id="8c11" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">以上所有结果都有一些警告:</p><h2 id="6747" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">特写作品</h2><p id="5638" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">虽然在过去的11个月里，我没有在Tivi上进行任何主要的新功能工作，但我也没有特别限制自己。我做了一些改变，这些改变并不关注迁移，而且可能会扭曲结果。</p><h2 id="720e" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">依赖性更新</h2><p id="2e5f" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">在11个月的迁移过程中，有许多依赖性更新。大多数依赖项更新是运行时库依赖项，因此很可能会影响APK大小指标。</p><p id="d0e3" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我还更新了<a class="ae kl" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank">grade le</a>(从<code class="du lj lk ll lm b">6.0.1</code>到<code class="du lj lk ll lm b">7.1.1</code>)、<a class="ae kl" href="https://developer.android.com/studio/releases/gradle-plugin" rel="noopener ugc nofollow" target="_blank">Android grade le插件</a> ( <code class="du lj lk ll lm b">3.6.0</code>到<code class="du lj lk ll lm b">7.1.0-alpha02</code>)和<a class="ae kl" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a> ( <code class="du lj lk ll lm b">1.3.61</code>到<code class="du lj lk ll lm b">1.5.10</code>)，这些都对构建速度有很大的影响。</p><h2 id="0d2d" class="nr kn hs bd ko ns nt nu ks nv nw nx kw jx ny nz ky kb oa ob la kf oc od lc oe bi translated">作曲在测试版</h2><p id="5c94" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">显而易见的一个。Compose目前处于测试阶段，因此所有结果都来自正在开发中的即时快照<strong class="jq ht"><em class="kk"/></strong>。一旦它在今年晚些时候达到1.0，重新运行这些测试并观察是否有任何差异将是很有趣的。</p></div><div class="ab cl jh ji go jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="ha hb hc hd he"><h1 id="fa5e" class="km kn hs bd ko kp oo kr ks kt op kv kw iy oq iz ky jb or jc la je os jf lc ld bi translated">摘要</h1><p id="9b14" class="pw-post-body-paragraph jo jp hs jq b jr le it jt ju lf iw jw jx lg jz ka kb lh kd ke kf li kh ki kj ha bi translated">如果我们看结果和警告，我们不应该做太多的判断，因为我们不是在比较苹果🍎敬苹果🍏；这更像是比较苹果🍎它们稍微甜一点的表亲，梨🍐。</p><p id="b726" class="pw-post-body-paragraph jo jp hs jq b jr js it jt ju jv iw jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">除了水果类比，我认为对我来说最大的收获是Compose将对大多数开发人员指标产生积极(或中性)的影响。考虑到这一点，加上Compose极大地提高了开发人员的工作效率，对我来说，Compose是Android UI开发的未来是显而易见的。</p></div></div>    
</body>
</html>