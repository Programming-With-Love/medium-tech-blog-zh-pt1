<html>
<head>
<title>Swift Generics and Associated Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift泛型和关联类型</h1>
<blockquote>原文：<a href="https://medium.com/globant/swift-generics-and-associated-types-73aa2b184c7a?source=collection_archive---------0-----------------------#2020-12-06">https://medium.com/globant/swift-generics-and-associated-types-73aa2b184c7a?source=collection_archive---------0-----------------------#2020-12-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/165835d03224a3a818fa108665cecec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDoftZemdLuBreDAPqpB_w.png"/></div></div></figure><h1 id="d5bb" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">简介</strong></h1><p id="13ec" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">泛型是Swift的一大特色，它允许实现支持多种类型的可重用和抽象代码。这避免了代码重复，使代码更易于维护。Swift标准库中的数组、字典和其他功能都是使用泛型实现的。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="c796" class="ip iq hh bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated"><strong class="ak">泛型语法和例子</strong></h1><p id="e9e8" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面是反转整数数组的实现:</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Reverse Int array</figcaption></figure><p id="f306" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">要实现类似的字符串数组，函数定义如下:</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Reverse String array</figcaption></figure><p id="3c8d" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">可以实现类似的数组方法来反转数组，而不管元素是Int、String类型还是任何使用泛型的类或结构。为占位符指定有意义的名称，而不是像“T”这样的随机名称。所以我们写了一个通用版本的函数来反转数组。每次调用通用函数时，确定用来代替<em class="lm">元素</em>的实际类型:</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Generic reverse function</figcaption></figure><p id="8780" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">例如，如果我们必须返回数组的反向，排除一些相同类型的值，我们可以添加类型约束，否则编译器将返回错误:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/83248483ddd41de6938cbfc9d09a187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsHiTauhJ7Z_m2dJLhBBxQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">Error when type constraint not added</figcaption></figure><p id="4359" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">现在我们将实现一个方法，该方法返回数组的逆矩阵，不包括数组中的某些值，即不等于某个值。<br/> Swift已经为此提供了等同的协议。符合等价协议的类型可以使用==比较相等性，或者使用“！= "运算符。<br/>我们知道类型必须符合Equatable，让我们看看指定它的语法:</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="d968" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">Equatable是一个协议，但是也可以在约束中指定类和结构类型。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="3771" class="ip iq hh bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated"><strong class="ak">通用类型</strong></h1><p id="e4a4" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Swift允许定义通用类型，如自定义类、结构和枚举。通过编写要存储为尖括号内的值的类型，可以创建ListNode的新实例。添加扩展时，不需要指定占位符类型“元素”。</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Creating generic types and extensions</figcaption></figure></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="dde9" class="ip iq hh bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated"><strong class="ak">通用where子句</strong></h1><p id="8de3" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">通用where子句允许向扩展添加新的需求。如果我们必须检查链表中是否存在列表节点，我们将必须检查两个列表节点对象是否相等。我们可以使用通用的where子句来指定。</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Generics where clauses to add additional requirements</figcaption></figure><p id="4987" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">在扩展中使用where子句，仅当<em class="lm">节点值</em>为<em class="lm"> CustomStringConvertible时才添加方法printDescription()。</em></p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="f018" class="ip iq hh bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated"><strong class="ak">关联类型</strong></h1><p id="7f6d" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">由于引入了面向协议的编程，我们通常首先通过添加协议来开始实现。泛型可以通过associatedtype在协议中使用。</p><p id="cead" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">我们可以指定Any/AnyObject来代替泛型类型，但这会影响性能，因为对象的类型将在运行时确定。因为任何类型的任何对象都可以作为参数传递，所以我们需要添加代码来将Any/AnyObject类型转换为所需的具体类型。</p><p id="628b" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">一个<em class="lm">关联的类型</em>为一个类型提供一个占位符名称，该类型被用作协议的一部分。在采用该协议之前，不会指定关联类型的实际类型。</p><p id="3be6" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">下面的代码示例包含与泛型where子句和泛型下标示例关联的类型。让我们讨论一下每个特性。在代码片段后有对每个提到的功能的描述:</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Associated types in Swift</figcaption></figure><p id="f787" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated"><strong class="jp hi"><em class="lm">type alias Element = Int</em></strong>的定义将元素的抽象类型转化为Int的具体类型，用于此实现。</p><p id="3508" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">即使我们没有提到typealias，由于Swift的类型推断，一切仍然有效，因为协议方法是用参数类型Int定义的。</p><p id="e746" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">我们仍然可以创建一个通用的链表类型结构，并通过添加typealias来确认“linked list”协议，如下所示:<br/><strong class="jp hi">type alias</strong>Node = list Node&lt;NodeType&gt;</p><p id="cb0b" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">我们还可以为协议中的关联类型指定类型约束和where子句，以要求确认类型满足这些约束。在这个例子中，<em class="lm">迭代器</em>上的通用where子句要求迭代器必须遍历链表中作为<em class="lm">节点的类型的元素。</em></p><p id="5624" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">我们还可以通过在下标后的“&lt;&gt;”中写入占位符类型名称来添加通用下标。泛型下标的语法包含在链表示例中，该示例返回特定索引处的列表节点。</p><p id="dfdd" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">Swift标准库广泛使用了泛型和相关类型。我在Swift中包含了协议的文档链接。</p><p id="4c88" class="pw-post-body-paragraph jn jo hh jp b jq lh js jt ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk ha bi translated">感谢阅读！</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="71e5" class="ip iq hh bd ir is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="8d5c" class="lo lp hh jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><a class="ae lx" href="https://swiftdoc.org" rel="noopener ugc nofollow" target="_blank">https://swiftdoc.org</a></li></ul></div></div>    
</body>
</html>