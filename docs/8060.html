<html>
<head>
<title>Why Reactive? Thread per Request vs. Reactive Programming Model (Eventloop)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么反应？每个请求的线程与反应式编程模型(Eventloop)</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/thread-per-request-vs-7bf1f22f590?source=collection_archive---------2-----------------------#2021-09-11">https://medium.com/walmartglobaltech/thread-per-request-vs-7bf1f22f590?source=collection_archive---------2-----------------------#2021-09-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e94f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要理解反应式编程解决的是什么问题，我们先来看看到底是什么问题。系好安全带，如果你是新来的，可能会有一些理解上的混乱，但我会尽最大努力安全着陆。</p><h2 id="8bb6" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">每个请求的线程</strong></h2><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/e1f240328dfd1619038b64c3f93842cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84q9xs5bYRS_aIJsNUiueA.jpeg"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Sync and Blocking</figcaption></figure><p id="a6e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在考虑上图中的例子，有两架飞机，只有一架飞机失控。因此，在第一架飞机P1安全着陆后，另一架飞机P2将尝试着陆。这意味着P2的飞机将被禁止降落，除非P1完成降落并为P2开放跑道。也就是说，单个线程正在为请求提供服务，其他请求在队列中，如果该线程进一步执行IO操作，它就只是等待，不会产生任何效果。一旦它完成了它的任务，它就为其他的请求服务。这就是同步和阻塞呼叫。</p><p id="6ad3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们来理解每个请求的线程模型，考虑一个传统的spring web应用程序，它带有部署在servlet容器上的spring mvc，比如Tomcat。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es kn"><img src="../Images/1dba768549e155ff86073509c989c5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*iSkqkhP4GENJ4uz44JH93g.jpeg"/></div><figcaption class="kj kk et er es kl km bd b be z dx">Traditional Thread Per Request Model</figcaption></figure><p id="8515" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您正在Tomcat上运行的应用程序中销售电子产品(如上所述)。您发现在正常情况下，应用程序的流量大约是每秒500个请求。假设您已经将Tomcat的线程池配置为200，应用程序的平均响应时间为200毫秒。我们粗略的计算表明，app每秒可以处理1k左右的请求，这足以每秒处理500个请求(我们的平均流量)。但天空并不总是蓝色的，你的应用程序在节日期间开始失去请求，因为它被巨大的用户请求淹没了。</p><p id="a6ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述场景中到底发生了什么？我们有一个专用的线程池来处理请求，其中一个线程将被分配给每个传入的请求，它将管理该请求的生命周期。所以我们的应用程序只能处理N个并发请求，其中N是线程池的大小。你可能会争论为什么我们不能产生更多的线程和增加并发性。这听起来也是正确的，事实上在上面的例子中有很多扩展的范围，这是一个单独的讨论话题。</p><p id="7ec4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一切都是有代价的，这就是上述方法的问题，产生更多的线程将导致更高的内存消耗，在某个时候我们的应用程序可能会因内存不足而崩溃。</p><p id="b699" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">怎么会？在JDK 8中，每次JVM创建一个线程时，操作系统都会分配一些本机内存来保存线程的堆栈，并保留一些默认的线程堆栈大小，该大小随JVM、操作系统和环境变量而变化，线程的创建会向进程提交更多内存，直到线程退出。线程堆栈一旦创建就被完全分配(即提交，而不仅仅是保留)。现在，如果应用程序产生大量线程，它会消耗大量内存，否则这些内存会被应用程序或操作系统使用，这可能会使系统耗尽内存。显然有一个优化的范围，比如通过使用<em class="ko"> -Xss </em>选项运行服务器来减少堆栈大小，但是确实存在更好的解决方案。</p><p id="1f1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们知道产生更多的线程不是一个好的解决方案，让我们回到我们的每请求线程模型。除了较高的内存消耗之外，还涉及到其他复杂性，如果处理特定请求的线程正在执行一些IO操作(如DB调用),那么它可能会进入阻塞和等待状态，这也是一种浪费。更高的响应时间，如果我们有额外的网络调用或IO操作层。还可能发生这样的情况，我们的服务A向服务B请求最近几个月的销售数据，结果数据非常大，服务B将这个巨大的数据返回给服务A，它可能会独占服务A</p><h2 id="d56f" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">我们还能做些什么来使上面的系统高效？</strong></h2><p id="69f1" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">Java提供了两种异步编程模型:</p><p id="d289" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">回调:</strong>不返回值但有回调参数(lambda或匿名类)的异步方法，当结果可用时(或者当阻塞调用完成时)调用该回调参数。回调很难编写、阅读和维护，这就是为什么它被称为<strong class="ig hi"> <em class="ko">回调地狱</em> </strong>。<br/>考虑一个例子:在UI上显示来自用户的前5个最喜欢的项目，或者如果没有最喜欢的项目，则给出建议。我们可以假设涉及三个服务:第一个提供favoriteIDs，第二个提供favorite细节，第三个提供建议。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="7b43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回调接口有两个异步方法，一个在成功时调用，另一个在出错时调用(第1行)。第一个服务使用favoriteID列表调用其回调(第2行)，如果列表为空，我们将转到建议服务(第4行)。建议服务将favoriteID列表提供给第二个回调(第5行)。由于涉及到UI，我们需要确保消费代码在UI线程中运行(第6行)。我们只需要top 5，所以我们将使用java流只处理top 5并显示在UI上(第7到9行)。如果出现错误，我们将显示一个弹出窗口(第14行)。</p><p id="375e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在假设<em class="ko"> getfavorite </em>服务返回了一个有效列表而不是空列表(回到第1行)。我们需要转到favorite服务来获得详细的对象(第18到20行)。我们只需要显示前5名，所以同样的设置与另一个回调。代码太多，很难理解。</p><p id="628b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看与回调示例等价的反应器代码:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="8e9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我认为代码是不言自明的，这就是美妙之处。获取favoriteID列表，获取每个ID的详细信息，如果列表为空，给出建议，取前5名并在UI线程上发布，要么该过程成功，要么将发生错误，无论是什么，都将调用相应的订阅者的方法。</p><p id="b1fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Futures: </strong>立即返回Future &lt; T &gt;的异步方法。值T将由异步进程计算，但Future对象包装对值T的访问。尽管该值不会立即可用，但可以轮询该对象，直到它可用。<br/>未来对象比回调更好，在Java 8中被<strong class="ig hi"> CompletableFuture </strong>进一步改进。但是未来也有一些问题:</p><ul class=""><li id="9a8a" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">如果您知道Future是如何工作的，那么您就会知道当调用Future对象的<em class="ko"> get() </em>方法时，很容易出现另一种阻塞情况。</li><li id="b54b" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">不支持惰性计算(直到需要它的值时才进行计算)</li><li id="2a36" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">缺乏对多值和高级错误处理的支持。</li></ul><p id="2b72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑一个例子，我们有一个tweet id的列表，我们想获取这些tweet的作者和该特定tweet的点赞数，以异步方式将它们两两组合。下面是使用CompletableFuture的代码</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="6f65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第1行，我们得到了拥有tweetIDs的列表的未来。然后，我们继续对第3行中的列表进行异步处理，对于列表中的每一项，异步获取该tweet的作者姓名和赞数。组合结果，现在我们有了代表所有组合任务的未来列表(第11行)，要执行这些任务，我们必须将列表转换为数组(第12行)。现在我们将数组交给<em class="ko">CompletableFuture . allOf()</em>，它输出当其中的所有任务完成时完成的未来(第14行)，<em class="ko"> allOf() </em>返回<em class="ko">CompletableFuture&lt;Void&gt;，</em>，因此我们使用<em class="ko"> join() </em>对期货收集结果列表进行一次迭代，这并不阻塞，因为我们已经有完成的期货。一旦整个管道被触发，我们等待它被处理并返回断言的结果列表。</p><p id="8223" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于reactor有更多的组合运算符，上述内容可以在反应式编程中简化，如下所示:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="9989" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">被Flux和Mono吓到了，不要担心，现在就假设他们是Future的高级版本，他们基本上是project reactor的两个发行商，Mono发射0或1个元素，Flux发射1到N个元素。我将在后面的帖子中详细介绍。我们来理解一下上面写的代码。</p><p id="0f74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从异步提供的tweetIDs序列开始，作为<em class="ko"> Flux &lt; String &gt; </em>(第1行)。剩余的过程保持不变，比如获取作者姓名和喜欢的数量，然后使用zipWith运算符异步组合。在实际的场景中，比如在生产中，我们会继续异步地使用Flux，通过进一步组合它和订阅它。大多数情况下，我们将结果返回为Mono，但是出于<strong class="ig hi">测试</strong>的目的，我们阻塞了(第14行)，因此一旦过程结束，我们将返回值的聚合列表。</p><p id="f75c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们看到了回调、Future和CompletableFuture如何带来更多的异步性，但是在某个时候它们可能会被阻塞，比如<em class="ko"> Future.get() </em>和<em class="ko">CompletableFuture&lt;List&lt;Result&gt;&gt;</em>将需要等待整个集合的构建并随时可用<strong class="ig hi"> <em class="ko">(异步和阻塞)</em> </strong>，而且CompletableFuture没有无限值的句柄。</p><p id="d894" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">流应用编程接口</strong>是在Java 9中引入的，但这更多的是一个反应流的契约，没有实现可以作为JRE的一部分。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lk"><img src="../Images/18ea79b559707dc0b94f878890d1f80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sP_cx7NuvZXpIU_N0_3w1Q.jpeg"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Event Loop Model</figcaption></figure><p id="dbb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是反应式编程的拯救之处，它通过以下方法解决了上面提到的所有问题:</p><ul class=""><li id="8675" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">不要使用每个请求一个线程的模型，而是用少量的线程来处理流量，即<strong class="ig hi"> Eventloops </strong>。</li><li id="6341" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">在等待IO操作完成时防止线程阻塞，即<strong class="ig hi">异步和非阻塞IO (NIO) </strong></li><li id="583a" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">让消费者(此处为应用程序)能够向生产者(此处为DB或BE)发出排放率过高的信号，即<strong class="ig hi">背压</strong>支持<strong class="ig hi">推拉</strong>混合数据流模型，这意味着应用程序可以请求数据(拉)或在无界模式下工作(发布者推送数据)。</li></ul><p id="7fb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pheww..我想那太多了。我们现在有了很好的基地，我希望登陆成功。</p><p id="f479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们已经清楚了基础，我将在下一篇文章中从反应流规范开始。此外，我将在以后的文章中更详细地介绍Eventloop模型的并发性。</p><h1 id="aaa0" class="ll jd hh bd je lm ln lo ji lp lq lr jm ls lt lu jp lv lw lx js ly lz ma jv mb bi translated">参考文献:</h1><ul class=""><li id="6109" class="kw kx hh ig b ih kp il kq ip mc it md ix me jb lb lc ld le bi translated"><a class="ae mf" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">https://projectreactor.io/</a></li><li id="ed37" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><a class="ae mf" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">https://www.reactivemanifesto.org/</a></li></ul></div></div>    
</body>
</html>