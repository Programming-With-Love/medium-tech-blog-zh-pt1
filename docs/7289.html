<html>
<head>
<title>Stop Using Servers to Handle Webhooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用服务器来处理网络钩子</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/stop-using-servers-to-handle-webhooks-675d5dc926c0?source=collection_archive---------2-----------------------#2018-02-05">https://medium.com/square-corner-blog/stop-using-servers-to-handle-webhooks-675d5dc926c0?source=collection_archive---------2-----------------------#2018-02-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="c402" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><figure class="ir is it iu iv iw er es paragraph-image"><div class="er es iq"><img src="../Images/b57641db5f7c7bec85dcf087172f1a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*ZUiWUZ-UqpHXU5B9GvmjFw.png"/></div></figure><p id="83d6" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">Webhooks正日益成为从不同服务获取实时数据的主要方法。<a class="ae ip" href="https://developer.github.com/webhooks/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ip" href="https://api.slack.com/custom-integrations/outgoing-webhooks" rel="noopener ugc nofollow" target="_blank"> Slack </a>、<a class="ae ip" href="https://sendgrid.com/docs/API_Reference/Webhooks/index.html" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>，甚至<a class="ae ip" href="https://docs.connect.squareup.com/api/connect/v1#webhooks-overview" rel="noopener ugc nofollow" target="_blank"> Square </a>都使用webhooks让你看到数据或者得到你账户上发生的事件的通知。Webhooks非常棒，因为它们非常容易处理，并且可以避免开发人员不得不构建一些陈旧的轮询系统，这些系统最终会在网络请求和检索到的实际有用数据之间造成相当大的浪费。</p><p id="51cc" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">当创建一个服务来处理webhooks时，您有几个选择:您可以扩展我们的应用程序来处理来自定义的URL的输入数据，您可以创建一个微服务，或者您可以创建一个函数作为服务(FaaS)函数来处理我们的webhooks。我们将简要介绍每个选项和可能的权衡，然后总结一个Square的FaaS webhook处理程序的示例实现。</p><h2 id="e400" class="jw jx hh bd jy jz ka kb kc kd ke kf kg jk kh ki kj jo kk kl km js kn ko kp kq bi translated">扩展您的应用</h2><figure class="ks kt ku kv fd iw er es paragraph-image"><div class="er es kr"><img src="../Images/81d5f9b39f012a10e477d12e458bd62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*zjx1zBv78bWs7GbrkTSn7g.gif"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Source: <a class="ae ip" href="https://giphy.com/gifs/fj-cctv-servers-128kpIwiArqvUk" rel="noopener ugc nofollow" target="_blank">Giphy (CCTV Servers)</a></figcaption></figure><p id="af07" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">扩展应用程序的好处是可以利用应用程序中已有的任何助手或其他库。您的助手(或其他应用程序工具)可以帮助处理这些传入的数据，并可能使其更容易管理。您的应用程序可能会一直运行，所以让它处理webhooks的传入数据是没有问题的。然而，这种方法可能是一个缺点，因为您可能会扩展您的应用程序来处理一些不是核心功能或者不应该与之耦合的东西。扩展如何工作实际上取决于您自己的应用程序是如何构建的，但是最好将webhooks的处理方式与应用程序之外的事情分开。</p><h2 id="d387" class="jw jx hh bd jy jz ka kb kc kd ke kf kg jk kh ki kj jo kk kl km js kn ko kp kq bi translated">微服务</h2><figure class="ks kt ku kv fd iw er es paragraph-image"><div class="er es la"><img src="../Images/38decebd397965aa7424b1a31d229f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*xGaCdZC3K2gGyivUHANzHQ.gif"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Source: <a class="ae ip" href="https://giphy.com/gifs/computer-ants-rthingsforants-I5xVaRw3WqYBG" rel="noopener ugc nofollow" target="_blank">Giphy (Computer Ants)</a></figcaption></figure><p id="ce5a" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">与此同时，微服务方法可能会帮助您远离应用程序，并允许它简单地通信或处理这些新数据，供应用程序稍后使用。不幸的是，我们仍然有可伸缩性和供应的缺点，因为我们仍然需要不断地监听发送到webhook处理程序的新数据。尽管完全有可能估计有多少数据可能会进入我们的webhook处理程序并相应地进行配置，但仍然很可能会有大量的停机时间，因为它只是在等待服务请求。</p><h2 id="e342" class="jw jx hh bd jy jz ka kb kc kd ke kf kg jk kh ki kj jo kk kl km js kn ko kp kq bi translated">作为服务发挥作用</h2><figure class="ks kt ku kv fd iw er es paragraph-image"><div class="er es lb"><img src="../Images/d0720d7a19ed5952e0fd91b33fc5e9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/1*0Y0hKll2Fu0_RB6i9Uf9lw.gif"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Source: <a class="ae ip" href="https://giphy.com/gifs/snl-ryan-gosling-3o7aD6igymCUmBOorm" rel="noopener ugc nofollow" target="_blank">Giphy (Saturday Night Live GIF)</a></figcaption></figure><p id="c831" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">在这一点上，我知道很明显，我将支持使用FaaS处理webhooks的所有好处，尽管我也承认有一些相当恼人的权衡。首先是好处。使用FaaS处理webhook数据的一个优点是，它允许几乎无限的可伸缩性，因此您不必担心供应过多或不足。您的函数只在新事件发生时运行，因此您不必为了处理webhook数据而连续运行服务器，从而节省了基础设施成本。另一方面，使用FaaS的缺点通常是可维护性、测试和冷启动。有一些<a class="ae ip" href="https://serverless.com/framework/" rel="noopener ugc nofollow" target="_blank">工具</a>帮助维护你的功能版本，部署功能，以及<a class="ae ip" href="https://serverless.com/blog/keep-your-lambdas-warm/" rel="noopener ugc nofollow" target="_blank">保持功能温暖</a>。由于webhooks不直接为用户服务，而且大多数webhooks提供者对所需的响应时间都相当宽容，所以FaaS非常适合处理web hooks，尽管存在冷启动问题。</p></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><h2 id="817f" class="jw jx hh bd jy jz ka kb kc kd ke kf kg jk kh ki kj jo kk kl km js kn ko kp kq bi translated">工作示例</h2><p id="b643" class="pw-post-body-paragraph iz ja hh jb b jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ln ju jv io ha bi translated">因此，这在理论上是好的，但最好展示一个我们如何在FaaS平台上实现webhook处理程序的例子。这个例子将在使用他们的<a class="ae ip" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank">谷歌云功能</a>的<a class="ae ip" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上，但是我们涉及的大部分内容将跨平台翻译，因为我们使用的是JavaScript。</p><p id="4150" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">首先，我们希望确保尽可能快地为webhook请求提供服务，因为我们不希望它超时。如果我们的webhook处理程序重复服务请求的时间太长，并且超时，许多webhook系统将停止服务我们的webhook URL，并认为它不再工作。我们的目标是在发送回我们的200响应之前最小化处理时间，以确保我们可以考虑到我们的函数可能存在的任何<a class="ae ip" href="https://dzone.com/articles/aws-lambda-performance-and-cold-starts" rel="noopener ugc nofollow" target="_blank">冷启动</a>滞后时间。</p><p id="7f79" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">为了使事情变得简单和工作更快，我们将把我们为webhook得到的JSON响应写入一个JSON文件，并上传到Google云存储中。这将允许我们的webhook处理程序快速响应请求，我们可以定期检查这个桶中的新事件，甚至编写另一个Google Cloud函数来处理新的JSON文件。</p><p id="47dd" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">如果你对FaaS完全陌生，一个简单的开始方法是使用<a class="ae ip" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器</a>。它是一个帮助云提供商创建和部署功能的工具。您可以使用他们的<a class="ae ip" href="https://serverless.com/framework/docs/providers/google/guide/quick-start/" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>来生成一个模板，他们也有关于为每个提供商设置凭据的指南。在这里，我们将为我们的webhook处理程序展示一个稍微填充的无服务器模板的样子:</p><figure class="ks kt ku kv fd iw"><div class="bz dy l di"><div class="lo lp l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">We’re omitting over a few things here, so don’t expect the above to work.</figcaption></figure><p id="f022" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我们的例子给出了最终webhook处理程序如何运行的简化版本。我们正在字符串化我们的JSON，使用<code class="du lq lr ls lt b">fs</code>模块将其写入<code class="du lq lr ls lt b">/tmp/</code>目录。然后，我们使用他们的NodeSDK将它发送到Google云存储中。最后，我们清理本地创建的临时JSON文件，并在发送我们的<code class="du lq lr ls lt b">200</code>响应之前记录我们的成功。</p><figure class="ks kt ku kv fd iw"><div class="bz dy l di"><div class="lo lp l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx">Now we have something that could be used to process our webhooks.</figcaption></figure><p id="4a9f" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">上面的webhook处理程序显示了如何处理来自我们的Square帐户的事件。我们添加了对<code class="du lq lr ls lt b">X-Square-Signature</code>报头的验证，以验证它是来自Square的有效载荷。确保webhook服务提供某种方法来验证正在发送的数据总是值得的，因为不良行为者有可能通过向您的webhook处理程序发送恶意数据来中断或操纵服务。</p><p id="90e1" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">在这里验证我们的头可以确保我们没有将任意的有效载荷存储到我们的Google云存储桶中。从这里，您可以选择创建另一个函数来处理新数据，因为新数据来自另一个Google Cloud函数，或者您可以简单地让您的应用程序定期检查这个存储桶来处理新事件。</p><p id="9ee6" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">例如，您可以让它检查退款是否超过某个限制，监控库存中是否有太低的商品，或者查看高价值商品何时售出。你可以使用Square的webhooks <a class="ae ip" href="https://docs.connect.squareup.com/api/connect/v1/#webhooks-overview" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多关于你可以跟踪的事件的信息。</p><p id="8001" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我强烈推荐尝试一下<a class="ae ip" href="https://serverless.com/framework/docs/" rel="noopener ugc nofollow" target="_blank">无服务器</a>，创建你自己的webhook处理程序，作为对你的Square账户中不同事件做出反应的一种方式。如果您还没有Square帐户，请务必在https://squareup.com/developers<a class="ae ip" href="https://squareup.com/developers" rel="noopener ugc nofollow" target="_blank">注册。请在评论中告诉我们你是如何使用FaaS或webhooks的，我们希望听到更多！</a></p><p id="02cb" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated"><em class="lu">想要更多？</em> <a class="ae ip" href="https://www.workwithsquare.com/developer-newsletter.html?channel=Online%20Social&amp;sqmethod=Blog" rel="noopener ugc nofollow" target="_blank"> <em class="lu">注册</em> </a> <em class="lu">获取我们每月的开发者简讯。</em></p></div></div>    
</body>
</html>