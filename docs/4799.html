<html>
<head>
<title>Programmer dictionary: Extension receiver vs Dispatch receiver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员词典:扩展接收器与调度接收器</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277?source=collection_archive---------0-----------------------#2017-12-07">https://blog.kotlin-academy.com/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277?source=collection_archive---------0-----------------------#2017-12-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9168" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/p/b085b1620890" rel="noopener">接收器的概念之前已经解释过了</a>，所以在进一步阅读之前，请确保您知道什么是接收器。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/1b2f13f30456c4051b2ba7bdc1a0208f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBntJ9Ivhd4ZW4K-qQSjPQ.jpeg"/></div></div></figure><p id="431c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">分机接收者</strong>是与科特林分机密切相关的接收者。Extension receiver表示我们为其定义扩展的对象。要定义扩展，我们必须在它前面加上<em class="kv">接收器类型</em>(通常是类或接口的名称)。扩展接收器是在其上调用扩展的对象的实例。再来看<em class="kv"> Ball.bounce </em>扩展函数:</p><pre class="kk kl km kn gt kw kx ky kz aw la bi"><span id="69e1" class="lb lc in kx b gy ld le l lf lg">fun String.firstChar(): Char = this.get(this.length — 1)</span><span id="ef1a" class="lb lc in kx b gy lh le l lf lg">fun String.lastCharacter() {<br/>   println(“Receiver type is ${this.javaClass}, Reciver object is ${this.name}”)<br/>}</span><span id="7fac" class="lb lc in kx b gy lh le l lf lg">val ball = Ball(“Golf ball”)<br/>ball.bounce() <br/>// prints: Receiver type is Ball, Receiver object is Golf ball</span></pre><p id="9076" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述<em class="kv"> Ball </em>类的实例可以作为<em class="kv">扩展接收器</em>在<em class="kv"> bounce </em>扩展体内访问。接收器类型指定接收器对象的类型(<em class="kv">球</em>)，而接收器对象是接收器类的实例(高尔夫球/网球)。请注意，在扩展的情况下，receiver对象的行为与任何其他对象一样，因此我们不能访问具有私有或受保护可见性的成员。</p><p id="a917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">调度接收者</strong>是一种特殊的接收者，当扩展被声明为成员时就存在。它表示在中声明扩展的类的实例。假设我们将为<em class="kv"> Person </em>类定义<em class="kv"> uploadToBackend </em>扩展。请注意，我们将在网络类内部定义此接收器:</p><pre class="kk kl km kn gt kw kx ky kz aw la bi"><span id="ac30" class="lb lc in kx b gy ld le l lf lg">class Person {<br/>   fun move() {}<br/>}</span><span id="7293" class="lb lc in kx b gy lh le l lf lg">class NetworkRepository {<br/>   fun loadData() {}</span><span id="edd0" class="lb lc in kx b gy lh le l lf lg">   fun Person.uploadToBackend() {<br/>      move() //method from extension receiver<br/>      loadData() //method from extension dispatch receiver<br/>   }<br/>}</span></pre><p id="fd7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个<em class="kv"> uploadToBackend </em>扩展方法的主体中，我们可以从<em class="kv"> Person </em>类和<em class="kv"> NetworkRepository </em>类中调用方法。这背后的原因是，我们的<em class="kv">uploadtobacnd</em>方法有两个接收器。第一个是扩展接收器，表示调用扩展的类的实例。第二个是dispatch receiver，表示声明扩展的类的实例。注意，在上面的例子中，两个接收者都是隐式接收者——我们在两个不同的对象上调用两个不同的方法，而没有指定接收者。</p><p id="2afb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了调用<em class="kv"> Person </em>类的扩展方法，我们需要<em class="kv">数据库</em>类型的扩展接收器。</p><pre class="kk kl km kn gt kw kx ky kz aw la bi"><span id="f365" class="lb lc in kx b gy ld le l lf lg">class Person {<br/>   fun move() {}<br/>}</span><span id="aebd" class="lb lc in kx b gy lh le l lf lg">class Database (al person:Person) {<br/>   fun loadData() {}</span><span id="0d54" class="lb lc in kx b gy lh le l lf lg">   fun doSomething() {<br/>      person.uploadToBackend(); // We can access extension here<br/>   }<br/> <br/>   fun Person.uploadToBackend() {<br/>      move()<br/>      loadData()<br/>   }<br/>}</span><span id="0a2d" class="lb lc in kx b gy lh le l lf lg">val person = Person()<br/>person.uploadToBackend() // Compilation error</span></pre><p id="5104" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在<em class="kv">数据库</em>类之外调用<em class="kv">uploadtobanekd</em>方法时，编译器将报告错误(在没有<em class="kv">数据库</em>类型的接收器的上下文中)。我们可以在<em class="kv">数据库</em>类中调用这个扩展，因为合适的接收器是可用的。</p><p id="e7df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果两种方法有相同的签名会发生什么呢？让我们将move方法添加到数据库类中。</p><pre class="kk kl km kn gt kw kx ky kz aw la bi"><span id="3d64" class="lb lc in kx b gy ld le l lf lg">class Person {<br/>   fun move() {}<br/>}</span><span id="7359" class="lb lc in kx b gy lh le l lf lg">class NetworkRepository (val person:Person) {<br/>   fun loadData() {}<br/>   fun move() {}</span><span id="32d1" class="lb lc in kx b gy lh le l lf lg">   fun doSomething() {<br/>      person.uploadToBackend();<br/>   }</span><span id="ab75" class="lb lc in kx b gy lh le l lf lg">   fun Person.uploadToBackend() {<br/>     // calls method defined in Person class<br/>     move()</span><span id="2a6b" class="lb lc in kx b gy lh le l lf lg">     // calls method defined in NetworkRepository class         <br/>     this@NetworkRepository.move()<br/> }<br/>}</span></pre><p id="29c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，在Person类中定义的move方法优先，但是如果我们想要访问<em class="kv">网络存储库</em>中的方法，我们需要使用显式接收器(<em class="kv"> this@NetworkRepository </em>)。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="f13c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本帖是<a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第九部分。要保持最新的新零件，只需遵循此介质。为了与我的文章保持联系，<a class="ae ki" href="https://twitter.com/igorwojda" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。这里提到我的关键是<a class="ae ki" href="https://twitter.com/igorwojda" rel="noopener ugc nofollow" target="_blank"> @IgorWojda </a>。</p><p id="43b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi lp"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="lq lr in jm b jn jo jr js jv ls jz lt kd lu kh lv lw lx ly bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="1953" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="2a4f" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="d41a" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性对字段</a></li><li id="84df" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类对类型对对象</a></li><li id="795a" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="6937" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收方类型与接收方对象</a></li><li id="79c0" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="4c3e" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="d4c1" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="1cbc" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs方差</a></li><li id="9a6e" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="c2b3" class="lq lr in jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组合</a></li></ul></div></div>    
</body>
</html>