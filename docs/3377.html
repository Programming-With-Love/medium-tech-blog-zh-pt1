<html>
<head>
<title>Say What? Develop own Mockito Library?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">说什么？开发自己的Mockito库？</h1>
<blockquote>原文：<a href="https://medium.com/globant/say-what-develop-own-mockito-library-661ece5f2add?source=collection_archive---------2-----------------------#2019-11-06">https://medium.com/globant/say-what-develop-own-mockito-library-661ece5f2add?source=collection_archive---------2-----------------------#2019-11-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d7df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以创建自己的Mockito库吗？还是想学习莫奇托图书馆的幕后？</p><p id="3947" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个有点固执己见的问题，因为有人会问你为什么要重新发明轮子？这是事实。但是如何才能深入了解Mockito或者其他任何嘲讽框架内部是如何工作的呢？引擎盖下是什么？因为开发和理解事物是截然不同的(感谢StackOverflow) ).</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/dcdfcce621f5c36f5c9ad3e8b8ced3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbSdQCzeNQfyIVmiGz96aQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Mockito</figcaption></figure><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="f122" class="jx jy hh jt b fi jz ka l kb kc"><em class="kd">whenever</em>(mockObject.methodYouWantedToMock())<br/>    .thenReturn(<em class="kd">resultYouWanted</em>)</span></pre><p id="b963" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我对你说这很容易？会激励你在嘲讽框架的引擎盖下学习吗？那我们开始吧…</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">@copyrights with <a class="ae kg" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">giphy</a></figcaption></figure><p id="845b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有两种类型的模仿框架，或者我们可以说有两种类型的模仿策略。</p><ol class=""><li id="e9d7" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb km kn ko kp bi translated"><strong class="ig hi">基于代理的框架</strong></li><li id="7781" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated"><strong class="ig hi">字节码操作框架</strong></li></ol><p id="c6c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最简单的框架是基于代理的框架，因为要转化字节码，你需要更好地理解字节码本身。</p><p id="49c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">两种框架的区别</strong>:</p><ol class=""><li id="0844" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb km kn ko kp bi translated">基于代理的框架更容易实现，但是有其自身的局限性。</li><li id="1a63" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated">字节码操纵就像成为复仇者，我不是开玩笑，是真的。因为它需要像黑客电影中显示的屏幕一样理解字节码的人。而基于代理的框架更容易理解。</li></ol><p id="3a1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前，在这个故事中，我们将坚持基于代理的框架。<br/>让我们先了解一下代理:<br/>代理只是一个对象，它将被用来代替原来的对象本身。如果一个方法被调用，那么代理对象将决定:<br/> 1。处理呼叫本身。<br/> 2。委托给原始类。</p><blockquote class="kv kw kx"><p id="2669" class="ie if kd ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">注意:传递给原始类的方法被称为刺探，因为我们正在记录或刺探它从原始方法获取/返回的数据。<br/>在测试框架之外还有另一个术语，叫做类委托。</p></blockquote><h2 id="83de" class="jx jy hh bd lb lc ld le lf lg lh li lj ip lk ll lm it ln lo lp ix lq lr ls lt bi translated">代理人的限制</h2><p id="589f" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">对代理有一些重要的限制。不可能:</p><ul class=""><li id="12fc" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lz kn ko kp bi translated">拦截静态方法调用</li><li id="436d" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lz kn ko kp bi translated">拦截私有方法调用</li><li id="663d" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lz kn ko kp bi translated">拦截最终方法调用</li><li id="dcd7" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lz kn ko kp bi translated">为最终类构建一个代理</li></ul><p id="c19d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了克服限制，我们需要进行字节码操作，这就是PowerMockito的用武之地，因为它使用字节码操作策略来克服代理的限制。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ma kf l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">@copyrights with <a class="ae kg" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">giphy</a></figcaption></figure><p id="3162" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，现在，我停止所有的理论，让我们继续代码</p><h1 id="9195" class="mb jy hh bd lb mc md me lf mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated"><strong class="ak">创建代理？怎么会？</strong></h1><p id="7091" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">java反射API提供了一个代理类。</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="0bd2" class="jx jy hh jt b fi jz ka l kb kc">Proxy.<em class="kd">newProxyInstance</em>(MockProxy.class.getClassLoader(), new Class[]{clazz}, invocationHandler);</span><span id="f345" class="jx jy hh jt b fi ms ka l kb kc">//Method parameters<br/>//public static Object newProxyInstance(ClassLoader loader,<br/>                                      Class&lt;?&gt;[] interfaces,<br/>                                      InvocationHandler h)</span></pre><p id="e33e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“newProxyInstance”方法采用类加载器、接口和调用处理程序。让我们一步一步来:</p><ol class=""><li id="968c" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb km kn ko kp bi translated">` Classloader `:它引用了代理类。我们的自定义代理类负责所有的处理，比如模仿和存储被模仿的方法和返回值的引用。</li><li id="80ae" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated">接口:我们要模仿的接口需要类引用。</li><li id="1d16" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated">Invocationhandler:它用于方法的调用，所以当我们想要模仿某个方法时，我们通常设置mock(obj.method())。那么Return(返回值)所以当我们写这个签名时由代理类调用的类是invocationHandler。为了标记方法，我们需要通过从invoke方法获取数据来发送这个返回值。</li></ol><blockquote class="kv kw kx"><p id="96ca" class="ie if kd ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">注意:newProxyInstance只接受接口，如果你想模仿类，我会发表另一篇文章继续讲述如何模仿类的基础知识。</p></blockquote><p id="3fdd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建MockProxy类</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="a201" class="jx jy hh jt b fi jz ka l kb kc">class MockProxy {<br/><br/>    companion object {<br/>        private var lastMockInvocationHandler: MockInvocationHandler? = null<br/><br/>        <em class="kd">/**<br/>         * Creates a mock based on a class.<br/>         *<br/>         * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">clazz the class of the mock<br/>         * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">&lt;T&gt;   the type of the mock<br/>         * </em><strong class="jt hi"><em class="kd">@return </em></strong><em class="kd">the mock object<br/>        &lt;/T&gt; */<br/>        </em>fun &lt;T&gt; <strong class="jt hi">mock</strong>(clazz: Class&lt;T&gt;): T {<br/>            val invocationHandler = MockInvocationHandler()<br/>            return Proxy.newProxyInstance(<br/>                MockProxy::class.<em class="kd">java</em>.<em class="kd">classLoader</em>,<br/>                <em class="kd">arrayOf</em>&lt;Class&lt;*&gt;&gt;(clazz),<br/>                invocationHandler<br/>            ) as T<br/>        }<br/><br/>        <em class="kd">/**<br/>         * This class is just needed to ERHALTEN the type information. So that we<br/>         * have the type information for the When::thenReturn method.<br/>         *<br/>         * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">obj the value which we doesn't need.<br/>         * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">&lt;T&gt; the type of the return value<br/>         * </em><strong class="jt hi"><em class="kd">@return </em></strong><em class="kd">an instance of When with the correct type information<br/>        &lt;/T&gt; */<br/>        </em>fun &lt;T&gt; `when`(obj: T?): When {<br/>            return When()<br/>        }<br/>    }<br/><br/>    class When{<br/><br/>        <em class="kd">/**<br/>         * Sets the return value for the last method call.<br/>         *<br/>         * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">retObj the return value<br/>         */<br/>        </em>fun thenReturn(retObj: Any) {<br/>            lastMockInvocationHandler!!.setRetObj(retObj)<br/>        }<br/>    }<br/>}</span></pre><p id="893a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在MockProxyClass内部，我们创建了一个静态方法mock(或者我可以用Kotlin语言说是companion method)。</p><p id="fb3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在mock <br/> 1中，我们需要做两种类型的签名。模拟界面<br/> 2。模拟方法</p><p id="c428" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了模拟接口，我们在MockProxy类中有一个模拟方法。它将一个类作为参数，并使用我们之前看到的“<strong class="ig hi"> newProxyInstance </strong>”方法给出一个模拟的代理对象。现在我们有了一个模拟对象，我们可以模拟这个方法了。</p><blockquote class="kv kw kx"><p id="1fd4" class="ie if kd ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">您可能会想，我们不能直接模拟方法吗？不，我们不能。<br/>为什么？<br/>因为我们之前检查过，模拟代理有他的局限性，代理不能模拟静态方法。</p></blockquote><p id="cd47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了模仿这个方法，我们创建了`<strong class="ig hi"> when </strong>`方法，就像Mockito一样。</p><p id="7073" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，现在我们需要理解调用如何发生背后的逻辑，以便可以解释when方法和其他调用类的下一个代码。</p><p id="d235" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以首先让我们看一个模仿接口的模仿方法。</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="de8f" class="jx jy hh jt b fi jz ka l kb kc">fun &lt;T&gt; <strong class="jt hi">mock</strong>(clazz: Class&lt;T&gt;): T {<br/><strong class="jt hi">    val invocationHandler = MockInvocationHandler()</strong><br/>    return Proxy.<strong class="jt hi">newProxyInstance</strong>(<br/>        MockProxy::class.<em class="kd">java</em>.<em class="kd">classLoader</em>,<br/>        <em class="kd">arrayOf</em>&lt;Class&lt;*&gt;&gt;(clazz),<br/>        <strong class="jt hi">invocationHandler</strong><br/>    ) as T<br/>}</span></pre><p id="d96c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将创建一个invocationHandler并将其传递给代理类以进行代理。</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="3a16" class="jx jy hh jt b fi jz ka l kb kc">MockProxy.`<strong class="jt hi">when</strong>`(fooInterfaceMock.foo()).<strong class="jt hi">thenReturn</strong>("Foo Fighters!")</span></pre><blockquote class="kv kw kx"><p id="1cde" class="ie if kd ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">注意，每当我们调用mockobject.method()时，每次都会调用MockInvocationHandler。<br/>为什么？<br/>因为我们已经创建了一个代理接口，它就像一个没有任何功能的空白类，所以一切都将由我们来做。<br/>为了可读性，我们使用了语法mock proxy . `<strong class="ig hi">when</strong>`(foointerfacemock . foo())<br/>如果我们查看when方法的签名，它只是返回When()类，而没有对参数做任何事情，我们只是在then return方法之前调用处理程序，以获得调用的方法和参数，以及需要返回的数据。</p></blockquote><p id="1e2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们要模拟这个方法时，这个调用处理程序对象将被调用，我们需要带走所有东西，如<strong class="ig hi">方法</strong>、<strong class="ig hi">方法参数、</strong>和<strong class="ig hi">返回对象</strong>，这样当我们试图调用时，我们就知道需要返回什么。</p><p id="a1d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们可以清楚地看到，这个方法是在“when()”之后被我们调用的，所以我们需要保存所有的引用。我们创建了一个类。</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="e604" class="jx jy hh jt b fi jz ka l kb kc">inner class DataHolder(<br/>    val method: Method?,<br/>    val args: Array&lt;Any&gt;?,<br/>    val retObj: Any?<br/>)</span></pre><p id="d698" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接受方法、方法参数和返回对象的数据容器类。</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="0cfd" class="jx jy hh jt b fi jz ka l kb kc">private class <strong class="jt hi">MockInvocationHandler : InvocationHandler</strong> {<br/><br/>    private var lastMethod: Method? = null<br/>    private var lastArgs: Array&lt;Any&gt;? = null<br/>    private val dataHolders = ArrayList&lt;DataHolder&gt;()<br/><br/>    <em class="kd">/**<br/>     * Intercepts the method call and decides what value will be returned.<br/>     */<br/>    </em>@Throws(Throwable::class)<br/>    <strong class="jt hi">override fun invoke(proxy: Any?, method: Method?, args: Array&lt;Any&gt;?): Any? </strong>{<br/>        lastMockInvocationHandler = this<br/>        lastMethod = method<br/>        lastArgs = args<br/><br/>        // checks if the method was already called with the given arguments<br/>        for (dataHolder in dataHolders) {<br/>            if (dataHolder.method == method &amp;&amp; Arrays.deepEquals(dataHolder.args, args)) {<br/>                // if so than return the stored value<br/>                return dataHolder.retObj<br/>            }<br/>        }<br/><br/>        // otherwise return null<br/>        return null<br/>    }<br/><br/>    <em class="kd">/**<br/>     * Adds the return value for the last called method with the last given arguments.<br/>     *<br/>     * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">retObj the return value<br/>     */<br/>    </em>fun setRetObj(retObj: Any?) {<br/>        dataHolders.add(DataHolder(lastMethod, lastArgs, retObj))<br/>    }<br/>}</span></pre><p id="a54e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，MockInvocationHandler实现了InvocationHandler，为什么？由于“Proxy.newProxyInstance”将“InvocationHandler”接口作为参数，我们需要一个逻辑来存储模拟的方法和参数。<br/>每当我们试图使用代理对象的方法时，就会调用“invoke”方法。我们将模拟方法和参数的值存储到“lastMethodInvocation”和lastMethodArguments变量中。<br/>又糊涂了？为什么我们需要将它存储在“lastVariable”中？因为直到现在我们都没有返回对象，所以如果我们没有返回对象，就没有必要向数组中添加数据。</p><p id="c675" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们调用thenReturn时，它将从“lastInvocationhandler”中调用“setRetObj”方法，我们只是将所有细节添加到数组列表中。</p><p id="b5bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>我们没有检查我们是否已经模仿了那个方法，所以如果你运行上面的代码，它将不会更新新的返回数据。更新一下，下面是代码:</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="8cc6" class="jx jy hh jt b fi jz ka l kb kc"><em class="kd">/**<br/> * Adds the return value for the last called method with the last given arguments.<br/> *<br/> * </em><strong class="jt hi"><em class="kd">@param </em></strong><em class="kd">retObj the return value<br/> */<br/></em>fun setRetObj(retObj: Any?) {<br/>    var isFound = false<br/>    for (dataHolder in dataHolders) {<br/>        if (dataHolder.method == lastMethod &amp;&amp; Arrays.deepEquals(<br/>                dataHolder.args,<br/>                lastArgs<br/>            )<br/>        ) {<br/>            dataHolder.retObj = retObj<br/>            isFound = true<br/>        }<br/>    }<br/>    if (!isFound)<br/>        dataHolders.add(DataHolder(lastMethod, lastArgs, retObj))<br/>}</span></pre><p id="b901" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将所有细节和模拟数据类添加到数组中，可以开始测试了。</p><p id="a2f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个接口和JUnit测试文件</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="ca01" class="jx jy hh jt b fi jz ka l kb kc">public interface FooInterface {<br/><br/>    public String foo();<br/><br/>    public String echo(String val);<br/><br/>}<br/>-------------------------------------------</span><span id="1939" class="jx jy hh jt b fi ms ka l kb kc">object MainTest {<br/><br/>    @JvmStatic<br/>    fun main(args: Array&lt;String&gt;) {<br/><br/>        // java.lang.reflect.Proxy<br/>        <em class="kd">println</em>("# MockProxy")<br/>        val fooInterfaceMock = MockProxy.mock(FooInterface::class.<em class="kd">java</em>)<br/>        MockProxy.`when`(fooInterfaceMock.foo()).thenReturn("Foo Fighters!")<br/>        MockProxy.`when`(fooInterfaceMock.foo()).thenReturn("Foo Fighters again changed!")<br/>        <em class="kd">println</em>(fooInterfaceMock.foo())<br/>        MockProxy.`when`(fooInterfaceMock.echo("echo")).thenReturn("echo")<br/>        <em class="kd">println</em>(fooInterfaceMock.echo("echo"))<br/>        MockProxy.`when`(fooInterfaceMock.echo("hello")).thenReturn("world")<br/>        <em class="kd">println</em>(fooInterfaceMock.echo("hello"))<br/>        <em class="kd">println</em>()<br/>    }<br/>}</span></pre><p id="f0d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出将是:</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="e0b7" class="jx jy hh jt b fi jz ka l kb kc"># MockProxy<br/>Foo Fighters again changed!<br/>echo<br/>world</span></pre><p id="4458" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们结束了我们的测试定制Mockito库。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt kf l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">@copyrights with <a class="ae kg" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">giphy</a></figcaption></figure><p id="9a72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> TL'DR </strong></p><p id="c657" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这种类型的自定义代理类，您可以尝试很多事情。我们已经检查了代理是如何生成的？，它是如何工作的？调用处理程序如何像黑魔法一样工作，为方法调用创建了一个小代理，并返回我们自己的数据。</p><p id="5202" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的要点链接，这个自定义Mockito，找到这个链接。-&gt; <a class="ae kg" href="https://gist.github.com/parthdave93/a3ee2241cd118fe0eb5990bbfb904301" rel="noopener ugc nofollow" target="_blank">链接</a></p></div></div>    
</body>
</html>