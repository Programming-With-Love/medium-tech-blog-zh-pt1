<html>
<head>
<title>Fetching data and binding it to the UI in the MAD skills series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获取数据并将其绑定到MAD技能系列中的UI</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/fetching-data-and-binding-it-to-the-ui-in-the-mad-skills-series-cea89868b3e1?source=collection_archive---------2-----------------------#2021-10-11">https://medium.com/androiddevelopers/fetching-data-and-binding-it-to-the-ui-in-the-mad-skills-series-cea89868b3e1?source=collection_archive---------2-----------------------#2021-10-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><div class=""><h2 id="b6fc" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">疯狂寻呼技巧系列的第二集</h2></div><p id="b77f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">欢迎回到寻呼3.0 MAD技能系列！在之前的<a class="ae kd" rel="noopener" href="/androiddevelopers/introduction-to-paging-3-0-in-the-mad-skills-series-648f77231121">文章</a>中，我们介绍了分页库，了解了它如何适应应用的架构，并将其集成到应用的数据层中。我们使用一个<code class="du ke kf kg kh b">PagingSource</code>来获取我们的数据，然后使用它和一个<code class="du ke kf kg kh b">PagingConfig</code>来创建一个为UI消费提供一个<code class="du ke kf kg kh b">Flow&lt;PagingData&gt;</code>的<code class="du ke kf kg kh b">Pager</code>对象。在这篇文章中，我将讲述如何在你的用户界面中使用<code class="du ke kf kg kh b">Flow&lt;PagingData&gt;</code>。</p><h1 id="a5ff" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">为用户界面准备分页数据</h1><p id="1a8c" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">该应用程序目前有一个<code class="du ke kf kg kh b">ViewModel</code>,它在<code class="du ke kf kg kh b">UiState</code>数据类中公开了呈现UI所需的信息，该数据类包含一个<code class="du ke kf kg kh b">searchResult</code>字段；内存中的缓存，用于保存配置更改后的结果搜索。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Initial UiState Definition</figcaption></figure><p id="c880" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在分页3.0中，我们从<code class="du ke kf kg kh b">UiState</code>中去掉了<code class="du ke kf kg kh b">searchResult</code> val，取而代之的是用<code class="du ke kf kg kh b">PagingData&lt;Repo&gt;</code>的<code class="du ke kf kg kh b">Flow</code>来代替，它与<code class="du ke kf kg kh b">UiState</code>分开暴露。这个新的<code class="du ke kf kg kh b">Flow</code>将与<code class="du ke kf kg kh b">searchResult</code>的目的相同:提供一个由UI呈现的项目列表。</p><p id="ecc0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在<code class="du ke kf kg kh b">ViewModel</code>中增加一个私有方法<code class="du ke kf kg kh b">searchRepo()</code>，调用<code class="du ke kf kg kh b">Repository</code>从<code class="du ke kf kg kh b">Pager</code>中提供一个<code class="du ke kf kg kh b">PagingData</code> <code class="du ke kf kg kh b">Flow</code>。然后，我们可以调用这个方法，根据用户输入的搜索词创建我们的<code class="du ke kf kg kh b">Flow&lt;PagingData&lt;Repo&gt;&gt;</code>。我们还在生成的<code class="du ke kf kg kh b">PagingData</code> <code class="du ke kf kg kh b">Flow</code>上使用了<code class="du ke kf kg kh b">cachedIn</code>操作符，该操作符使用<code class="du ke kf kg kh b">ViewModelScope</code>缓存它以便更快地重用。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">PagingData Flow integration from the repository</figcaption></figure><p id="9cb3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">重要的是要揭露</strong> <code class="du ke kf kg kh b"><strong class="jj ht">PagingData</strong></code> <strong class="jj ht"> </strong> <code class="du ke kf kg kh b"><strong class="jj ht">Flow</strong></code> <strong class="jj ht">独立于其他</strong> <code class="du ke kf kg kh b"><strong class="jj ht">Flows</strong></code> <strong class="jj ht">。</strong>这是因为<code class="du ke kf kg kh b">PagingData</code>本身是一个可变类型，它维护着自己的内部数据流，这些数据流会随着时间的推移而更新。</p><p id="bcd2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">完全定义了包含<code class="du ke kf kg kh b">UiState</code>字段的<code class="du ke kf kg kh b">Flows</code>后，我们可以将它们组合成<code class="du ke kf kg kh b">UiState</code>的<code class="du ke kf kg kh b">StateFlow</code>，然后可以与<code class="du ke kf kg kh b">PagingData</code>的<code class="du ke kf kg kh b">Flow</code>一起暴露给UI，并由UI使用。有了以上内容，我们现在可以开始在UI中使用我们的<code class="du ke kf kg kh b">Flows</code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Exposing the PagingData Flow to the UI. Note the use of the cachedIn operator</figcaption></figure><h1 id="a674" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">在用户界面中使用分页数据</h1><p id="5db7" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">我们做的第一件事是将<code class="du ke kf kg kh b">RecyclerView</code>和<code class="du ke kf kg kh b">Adapter</code>从<code class="du ke kf kg kh b">ListAdapter</code>切换到<code class="du ke kf kg kh b">PagingDataAdapter</code>。一个<code class="du ke kf kg kh b">PagingDataAdapter</code>是一个<code class="du ke kf kg kh b">RecyclerView</code> <code class="du ke kf kg kh b">Adapter</code>，优化用于区分和聚集来自<code class="du ke kf kg kh b">PagingData</code>的更新，以确保后台数据集中的更改尽可能高效地传播。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Switching from a ListAdapter to a PagingDataAdapter</figcaption></figure><p id="e704" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">接下来，我们开始从<code class="du ke kf kg kh b">PagingData</code> <code class="du ke kf kg kh b">Flow</code>收集，因此我们可以使用<code class="du ke kf kg kh b">submitData</code>暂停函数将其排放绑定到<code class="du ke kf kg kh b">PagingDataAdapter</code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Consuming PagingData with a PagingDataAdapter. Note the use of the collectLatest operator</figcaption></figure><p id="875b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此外，作为用户体验津贴，我们希望确保当用户搜索新事物时，他们被带到列表顶部的<strong class="jj ht">以显示第一个搜索结果。当我们确信<strong class="jj ht">已经完成加载并在UI </strong>中呈现数据时，我们希望这样做。我们通过利用由<code class="du ke kf kg kh b">PagingDataAdapter</code>暴露的<code class="du ke kf kg kh b">loadStateFlow</code>和<code class="du ke kf kg kh b">UiState</code>中的<code class="du ke kf kg kh b">hasNotScrolledForCurrentSearch</code>字段来实现这一点，如果用户自己手动滚动了列表，则用于跟踪。这两者的组合创建了一个标志，让我们知道是否可以触发自动滚动。</strong></p><p id="f50a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">由于<code class="du ke kf kg kh b">loadStateFlow</code>提供的负载状态与UI中显示的内容是同步的，所以一旦负载状态流通知我们没有为每个新查询加载，我们就可以放心地滚动到列表的顶部。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Implementing auto scroll to the top for new queries</figcaption></figure><h1 id="b711" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">添加页眉和页脚</h1><p id="1ca6" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">分页库的另一个优点是能够借助<code class="du ke kf kg kh b">LoadStateAdapter</code>在列表的顶部或底部显示进度指示器。当加载数据时，<code class="du ke kf kg kh b">RecyclerView.Adapter</code>的这个实现自动被通知<code class="du ke kf kg kh b">Pager</code>中的变化，这使它能够根据需要在列表的顶部或底部插入项目。</p><p id="8961" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最好的部分是你甚至不需要改变你现有的<code class="du ke kf kg kh b">PagingDataAdapter</code>。<code class="du ke kf kg kh b">withLoadStateHeaderAndFooter</code>扩展方便地用页眉和页脚包装您现有的<code class="du ke kf kg kh b">PagingDataAdapter</code>！</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Headers and Footers</figcaption></figure><p id="29e3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du ke kf kg kh b">withLoadStateHeaderAndFooter</code>函数的参数接受页眉和页脚的<code class="du ke kf kg kh b">LoadStateAdapters</code>定义。<code class="du ke kf kg kh b">LoadStateAdapter’s</code>又拥有自己的<code class="du ke kf kg kh b">ViewHolders</code>，它们与最新的加载状态绑定在一起，使得定义视图的行为变得容易。我们甚至可以传递参数，让我们在出现错误的情况下重试加载，这将在下一篇文章中详细介绍。</p><h1 id="2fd3" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">接下来</h1><p id="71da" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">这样我们就把分页数据绑定到UI上了！简单回顾一下，我们:</p><ul class=""><li id="e56f" class="lp lq hs jj b jk jl jn jo jq lr ju ls jy lt kc lu lv lw lx bi translated">使用PagingDataAdapter将分页集成到UI层中</li><li id="2f9f" class="lp lq hs jj b jk ly jn lz jq ma ju mb jy mc kc lu lv lw lx bi translated">使用PagingDataAdapter公开的LoadStateFlow来保证我们只在页面加载完成时自动滚动到列表的顶部</li><li id="d50c" class="lp lq hs jj b jk ly jn lz jq ma ju mb jy mc kc lu lv lw lx bi translated">提取数据时，使用withLoadStateHeaderAndFooter()向用户界面添加进度条</li></ul><p id="2869" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">感谢您的阅读！请继续关注，在下一篇文章中再见，我们将把来自数据库的分页视为一个真实的来源，并进一步研究<code class="du ke kf kg kh b">LoadStateFlow</code>！</p></div></div>    
</body>
</html>