# Kotlin 中初始化修饰符的实用解释

> 原文：<https://medium.com/google-developer-experts/a-practical-explanation-for-initialization-modifiers-in-kotlin-9f52096ff1ca?source=collection_archive---------2----------------------->

![](img/d51bc0a08f92e0ac70baa0613a51e0c6.png)

最近，我为一位客户举办了一场科特林研讨会。研讨会的中心思想是花几个小时展示语言本身，逐个介绍它的一些功能，然后开发一个完整的应用程序，能够连接到 API，获取数据，存储数据并在 RecyclerView 中显示数据。我发现这个工作坊的概念很适合科特林的读者小说，或者是刚刚开始的。大多数最初的概念都被探索或接触过，你有一个具有初始架构和方法的应用程序，它可以在以后被扩展并在其他专业项目中重用。

然而，在这次研讨会上，发生了一些我以前经历过的事情，它遇到了理论概念和实际应用之间的差距。这一次，它发生在 Kotlin 的初始化属性上。

(更有趣的是，当您从 Java 这样的语言跳到 Kotlin 这样的语言时，这种情况会增加。多年来，你已经养成了一种缺乏太多益处的习惯，以至于你的大脑处于一种持续的混乱状态。

作为一个日常开发者和偶尔的训练者，我遇到这种差距是有一定周期性的。它是这样工作的:

1.  有一个理论概念需要解释。
2.  我重温了这个理论。我解释了它的特性。我浏览了手册描述及其对应的属性。
3.  我确保观众理解理论概念。我问他们问题，我寻找答案。一切看起来都很好。
4.  然后我得到了问题:“是的，一切都很好，但我们什么时候使用这个？”

要真正理解一个概念，你需要能够在理论领域和实际应用中漫步。仅仅了解某样东西是如何工作的，了解它的内在规律，并熟记手册或教程是不够的。你需要找到一个点，在这个点上，你可以想到一个可能需要它的实际含义。这正是工程和实用科学:将理论知识应用到实际工作中。

在前面提到的研讨会上，我被问到这个问题:“是的，我们知道初始化属性是如何工作的。但你能告诉我们一个实际案例吗？”

这篇文章旨在回应我的提问者。

# Kotlin 中的初始化属性

让我们首先从 Kotlin 中所有可用的初始化属性开始。Java 中没有对等的机制，所以如果您来自这个领域，您可能会发现它首先是新奇的。

不出所料，初始化属性决定了变量将如何初始化。在 Java 中，当构造函数被调用时，变量被初始化。简单。和限制。科特林为我们提供了更多的选择:

# 懒惰的

惰性属性在第一次被访问时被初始化。请看下面的例子:

除非您访问 aVar，否则它的值永远不会被设置。这是两行解释，虽然一个懒惰的属性有更多的糖。该值仅在一个线程中计算，所有线程将看到相同的值。此外，第一次访问 Lazy 属性时，会进行初始化。第二次，这个值被记住并返回。例如，看一看:

该代码将实际打印以下内容:

```
I am computing this valueHolaHola
```

如引言所述，理论方面很容易掌握。我们稍后将回到懒惰修饰语。

# lateinit

修饰符 **lateinit** 允许我们延迟变量的初始化。让我们考虑下面这段代码:

如果您在编译器中尝试上面的代码部分，将不会抛出错误。尝试在没有 **lateinit** 的情况下完成，你将得到一个编译消息。

![](img/57d3e9d4934e8359b8c59ad469724eb9.png)

通过写 **lateinit** ，我们必须稍后(在它被访问之前)负责初始化变量。如果我们不这样做，将会抛出一个异常:

> 起因:科特林。uniinitializedpropertyaccessexception:late init 属性 myVar 尚未初始化

啊！更多细节在顶部: **lateinit** 不支持原始类型。你需要使用委托。

# 初始化修饰符的实际范围

我们已经领会了它的理论意义，并初步领会了它的含义。为了继续掌握这个修饰语，我们需要找到可以应用它们的用例。让我们检查其中的一些。

## 依赖注入

如果您使用 Dagger 或类似的依赖注入框架，您可能会习惯于编写类似下面这样的代码片段:

变量实际上并没有被初始化，而是在之后被注入。通过使用 **lateinit** ，我们允许初始化发生在稍后的瞬间。

**高密度计算或大对象**

想象一个需要大量计算才能创建的对象，或者它们占用了大量内存空间。位图总是一个很好的例子。你实例化对象，对象已经在内存中，然后你需要等待，直到你使用它。这是一个应该被声明为惰性对象的变量的简单例子。记住这个简单的动作会从一开始就优化你的代码。这同样适用于昂贵的操作，例如从磁盘系统打开文件等。

([朱哈妮·莱蒂姆基](/@lehtimaeki)实际上在一次谈话中向我指出了这是一个很好的使用案例)

**资源**

你需要访问一个资源(在 Android 中，这可能是 drawables，string，dimens…)。除非您处于这种状态(例如，在特定条件下发生错误)，否则您不需要加载它们。宾果，这又是一个适合后期初始化的场景。

进一步考虑: **by lazy** 只限于`val.` **lateinit** 只允许在可变属性`(var)`上使用。

总之，试着想象一个变量，它的实例化依赖于一个特定的状态。如果你能想到一个例子，你已经有一个懒惰或延迟初始化的候选。

我在我的 [Twitter 账户](https://twitter.com/eenriquelopez)中写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它确实帮助了你，请随意分享它，♥它和/或留下评论。这是给业余作家加油的货币。

感谢我的同事兼朋友 Marius Budin 对本文的反馈。