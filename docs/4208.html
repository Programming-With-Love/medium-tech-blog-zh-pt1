<html>
<head>
<title>Exploring the Android Fragment Scenario component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Android片段场景组件</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-the-android-fragment-scenario-component-e369ec587419?source=collection_archive---------2-----------------------#2018-11-12">https://medium.com/google-developer-experts/exploring-the-android-fragment-scenario-component-e369ec587419?source=collection_archive---------2-----------------------#2018-11-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ce4dc1ec0fec5b58c5d7a6a2ab20b468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JCCW2uqtUkkkpOH430bog.png"/></div></div></figure><p id="908c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我总是很好奇android下一步会有什么工具和功能——为了确保我不会错过这些，我喜欢关注android开发者网站上的发布说明。最近引起我注意的两个是<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/jetpack/androidx/androidx-rn#2018-nov-fragment" rel="noopener ugc nofollow" target="_blank">fragment-1.1.0-alpha01</a></code>和<code class="du jn jo jp jq b">fragment-testing-1.1.0-alpha01</code>的发布，在测试方面，我们看到一个新的片段场景组件，它为我们提供了一种简单的方法来测试我们的片段。在这篇文章中，我想对此做一个快速的探究，这样我们就可以将它集成到我们的应用程序测试中。</p><p id="ddc3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>这目前只在alpha版本中可用。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><figure class="ka kb kc kd fd ii er es paragraph-image"><a href="http://eepurl.com/dIKgiT"><div class="er es jz"><img src="../Images/e8dd46ab2c119165e7a212299a73013e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-QbIIAzOjpz4kfDKWkgGg.png"/></div></a></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="cd46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当谈到我们的android应用程序的自动化测试时，我们可能会使用espresso来满足这一要求。如果是这样，您可能已经使用espresso测试了应用程序中的活动——这可能涉及到启动活动、为活动意图提供额外内容以及检查某些UI组件状态。当谈到活动时，这总是好的，你是如何处理应用程序中的片段测试的？有可能是这样的事情:</p><ul class=""><li id="8446" class="ke kf hh ir b is it iw ix ja kg je kh ji ki jm kj kk kl km bi translated">启动您的应用程序的活动，该活动包含您想要测试的片段</li><li id="f32d" class="ke kf hh ir b is kn iw ko ja kp je kq ji kr jm kj kk kl km bi translated">创建一个定制的测试规则，允许您启动想要单独测试的片段</li></ul><p id="f2d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这两种方法都有效，但它们都有缺陷。首先，启动包含该片段的活动意味着您不是在孤立地测试该片段——您的测试应该只关心该片段本身，而不是它的父容器。例如，如果您在一个活动中使用底部导航视图，该活动还管理一些幕后状态(例如一个经过验证的用户),那么这些数据将需要在您的片段的测试中进行处理——您可能会遇到必须模拟许多不同的请求，而这些请求是片段根本不关心的。然后，如果住房活动发生变化，我们的片段测试会像活动测试一样失败吗？虽然这些只是简单的要点，但我希望它显示出像我们的应用程序代码一样，我们的测试应该关注它们的责任并保持轻量级。这将有助于确保我们的测试保持可维护性、可读性，并且在前进的过程中不太可能出错。</p><p id="9990" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">转到第二点——这一点无疑是对第一点的巨大改进。这允许我们孤立地启动我们的片段，并关注我们正在测试的东西。这要么需要使用外部依赖(比如https://github.com/novoda/espresso-support的<a class="ae jr" href="https://github.com/novoda/espresso-support" rel="noopener ugc nofollow" target="_blank">)要么编写自己的实现。然而，每当您想要设置隔离测试时，这些都需要向您的应用程序添加一个依赖项，或者向您的项目添加一点样板文件。没什么大不了的，但是值得记住这些事情。</a></p><p id="7703" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，随着<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/jetpack/androidx/androidx-rn#2018-nov-fragment" rel="noopener ugc nofollow" target="_blank">fragment-1.1.0-alpha01</a></code>和<code class="du jn jo jp jq b">fragment-testing-1.1.0-alpha01</code>的最新发布，我们看到了这个新的FragmentScenario组件，它让我们不再担心如何测试我们的片段。这个新组件为我们处理了所有这些责任，让我们看看如何使用这个组件编写一些片段测试。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="2877" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们可以设置这个新功能之前，我们需要继续将以下依赖项添加到我们的<strong class="ir hi"> build.gradle </strong>文件中:</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="c0c8" class="kw kx hh jq b fi ky kz l la lb">implementation 'androidx.fragment:fragment:1.1.0-alpha01'<br/>debugImplementation 'androidx.fragment:fragment-testing:1.1.0-alpha01'</span></pre><p id="3189" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经这样做了，我们可以继续改进我们的片段测试。让我们先快速浏览一下可用于启动所需片段的代码，然后检查其中是否显示了给定的视图:</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="273f" class="kw kx hh jq b fi ky kz l la lb">@Test<br/>fun tournamentsContainerIsDisplayed() {<br/>    launchFragmentInContainer&lt;TournamentsFragment&gt;()<br/>    <br/>    onView(withId(R.id.<em class="lc">recycler_tournaments</em>))<br/>            .check(matches(isDisplayed()))<br/>}</span></pre><p id="77a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的关键是我们调用的这个<strong class="ir hi">launchFragmentInContainer()</strong>函数——这是用来在一个隔离的环境中启动我们想要的片段的(本质上是一个容纳该片段的空活动)。您会注意到，这个函数将fragment类作为它的类型——这个类引用稍后用于执行启动。所有这些功能都是获取给定的片段并在内部<strong class="ir hi"> EmptyFragmentActivity </strong>类中启动它——将片段放在根视图容器<strong class="ir hi"> android中。R.id.content </strong>这很可能类似于如果您以一种隔离的方式测试片段，您以前在您的应用程序内部会有的样板代码。</p><p id="b609" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们的片段使用这个函数启动，我们就可以像在其他espresso测试中一样与之交互。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="b530" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对launchFragmentInContainer()的调用也可以通过添加两个参数来完成:</p><ul class=""><li id="f2a2" class="ke kf hh ir b is it iw ix ja kg je kh ji ki jm kj kk kl km bi translated"><strong class="ir hi">片段参数</strong> —提供可以传递给片段的附加参数，以配置其行为。很可能你的一些片段使用了片段参数，使用这个属性为你提供了一个简单的方法来测试这些条件值的行为</li></ul><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="675e" class="kw kx hh jq b fi ky kz l la lb">val args = Bundle().apply {<br/>            putString(ARG_FRAGMENT_MODE, "some_mode_key") <br/>}</span></pre><ul class=""><li id="c837" class="ke kf hh ir b is it iw ix ja kg je kh ji ki jm kj kk kl km bi translated"><strong class="ir hi">片段工厂</strong>—<strong class="ir hi">androidx . fragment 1 . 1 . 0-alpha 01</strong>版本现在允许使用带有FragmentManager实例的fragment factory来构建片段，这允许您提供一种方式来描述应该如何实例化片段。所以这个工厂的结果也可以被测试，这个工厂可以作为一个参数传入。</li></ul><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="e697" class="kw kx hh jq b fi ky kz l la lb">val factory = SomeFragmentFactory()</span></pre><p id="c622" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记住这些，我们就可以用我们已经提供的附加属性来启动我们的片段:</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="efda" class="kw kx hh jq b fi ky kz l la lb">launchFragmentInContainer&lt;TournamentsFragment&gt;(args, factory)</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="c094" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在某些情况下，您可能想要对您已经在测试中启动的片段执行触发器操作。当调用<strong class="ir hi">launchFragmentInContainer</strong>方法时，我们得到一个<strong class="ir hi"> FragmentScenario </strong>类的实例。</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="eb33" class="kw kx hh jq b fi ky kz l la lb">val scenario = launchFragmentInContainer&lt;TournamentsFragment&gt;()</span></pre><p id="3f71" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经访问了这个片段场景，我们可以做一些不同的事情来进一步操作和测试我们的片段。</p><h2 id="dd04" class="kw kx hh bd ld le lf lg lh li lj lk ll ja lm ln lo je lp lq lr ji ls lt lu lv bi translated">触发片段函数</h2><p id="30c1" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在某些情况下，您的片段可能包含外部类可能调用的公共函数——可能该函数刷新内容，或者可能它处理一些应用程序状态更改。无论哪种方式，这个新的API都允许我们轻松地与我们发布的片段进行交互:</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="dc70" class="kw kx hh jq b fi ky kz l la lb">val scenario = <em class="lc">launchFragmentInContainer</em>&lt;TournamentsFragment&gt;()<br/>scenario.onFragment <strong class="jq hi">{<br/>    it</strong>.onUserSignedOut()<br/><strong class="jq hi">}</strong></span></pre><p id="f3b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个<strong class="ir hi"> onFragment </strong>函数允许我们在片段上触发我们想要的动作。在这个调用中，API使用片段管理器来定位我们的片段，然后执行我们所请求的动作。这将有助于测试可以在我们的片段上触发的公共函数。</p><h2 id="75e6" class="kw kx hh bd ld le lf lg lh li lj lk ll ja lm ln lo je lp lq lr ji ls lt lu lv bi translated">碎片再创造</h2><p id="52a8" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">如果在某些情况下，我们可能需要重置片段的状态，那么我们可以通过使用<strong class="ir hi"> recreate() </strong>函数来实现:</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="cc2c" class="kw kx hh jq b fi ky kz l la lb">val scenario = <em class="lc">launchFragmentInContainer</em>&lt;TournamentsFragment&gt;()<br/>scenario.recreate()</span></pre><p id="0293" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当调用这个时，托管我们的片段的空活动被重新创建，这反过来将导致片段状态被重置为它所处的前一个状态。</p><h2 id="79eb" class="kw kx hh bd ld le lf lg lh li lj lk ll ja lm ln lo je lp lq lr ji ls lt lu lv bi translated">改变状态</h2><p id="57db" class="pw-post-body-paragraph ip iq hh ir b is lw iu iv iw lx iy iz ja ly jc jd je lz jg jh ji ma jk jl jm ha bi translated">在我们的一些片段中，我们可能会在它的生命周期中发生不同的事情——可能我们会在恢复期间触发一些特定的事件，而一旦片段开始，可能会发生不同的事件。在这些情况下，我们可以利用<strong class="ir hi"> moveToState() </strong>函数以编程方式触发状态变化</p><pre class="ka kb kc kd fd ks jq kt ku aw kv bi"><span id="fa79" class="kw kx hh jq b fi ky kz l la lb">val scenario = <em class="lc">launchFragmentInContainer</em>&lt;TournamentsFragment&gt;()<br/>scenario.moveToState(Lifecycle.State.RESUMED)</span></pre><p id="491f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当被调用时，这将检索我们当前的片段，并使用我们给定的参数强制设置状态。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="83b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们看了一下新的片段场景组件，以及我们如何使用它在一个隔离的环境中测试我们的片段。这个新增加的API将帮助我们改进我们的片段测试，并保持事情向前简化。如果您对片段场景有任何问题或意见，请联系我们！</p><div class="mb mc ez fb md me"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hi fi z dy mj ea eb mk ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead @Buffer。谷歌开发专家为@Android，@GooglePay &amp;…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">twitter.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms in me"/></div></div></a></div></div></div>    
</body>
</html>