<html>
<head>
<title>Building scalable near-real time indexing on HBase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在HBase上构建可扩展的近实时索引</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/building-scalable-near-real-time-indexing-on-hbase-7b5eeb411888?source=collection_archive---------3-----------------------#2021-07-20">https://medium.com/pinterest-engineering/building-scalable-near-real-time-indexing-on-hbase-7b5eeb411888?source=collection_archive---------3-----------------------#2021-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c5b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ankita Wagh |软件工程师，存储和缓存</p><p id="08aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HBase是Pinterest最重要的存储后端之一，为我们的许多在线流量存储服务提供支持，如Zen(图形数据库)和UMS(宽列数据存储)。虽然HBase有许多优势，如高容量请求中行级别的强一致性、灵活的模式、低延迟的数据访问和Hadoop集成，但它本身不支持高级索引和查询。二级索引是我们的客户最需要的特性之一，但是在HBase中直接支持它是相当具有挑战性的。就查询效率和代码复杂性而言，随着索引数量的增长而维护单独的索引表不是一个可伸缩的解决方案。这促使我们构建一个名为Ixia的存储解决方案，在HBase上提供近乎实时的二级索引。设计灵感主要来自于<a class="ae jc" href="https://ngdata.github.io/hbase-indexer/" rel="noopener ugc nofollow" target="_blank"> Lily HBase Indexer </a>。</p><p id="3479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ixia在HBase的基础上提供了一个通用的搜索接口，它扮演了事实来源数据库的角色。搜索引擎本身针对倒排索引查找进行了优化，存储索引。搜索引擎还提供丰富的搜索和聚合查询，并支持Pinterest的大多数索引和检索用例。</p><p id="5159" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将首先简要介绍系统的架构和设计选择。然后，我们将介绍我们如何维护Ixia的数据一致性SLA，我们如何解决灾难恢复问题，以及我们必须采取哪些措施来提高整体系统性能。最后，我们将提供一些关于未来工作和机会的指导方针。</p><h1 id="f346" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">体系结构</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/2a77110512ae8d2d7d8e28ff52a6305f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l44wlomCIjZNrZBY"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Figure 1: System architecture showing data flow</figcaption></figure><p id="ab27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在各小节中，我们将简要描述每个组件，最后解释整个流程。</p><h2 id="dfc3" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">HBase</h2><p id="6186" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">HBase是一个面向列的NoSQL数据库管理系统，运行在Hadoop分布式文件系统(HDFS)之上。它是仿照谷歌的大表，用Java编写的。它非常适合实时数据处理或对大量数据的随机读/写访问。我们使用HBase作为Ixia的真实数据库来源。</p><p id="6cc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">复制机制&amp;改变数据捕获(CDC)系统</strong></p><p id="8eb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HBase复制是一种将数据从一个HBase集群(主)复制到另一个集群(辅助)的机制。这是通过从活动集群向备用集群区域服务器重放预写日志(WAL)中的预写日志条目(WALEdits)来异步完成的。WALEdit是一个表示一个事务的对象，可以有多个变异操作。由于HBase支持单行级事务，一个WALEdit只能有一行的条目。</p><p id="b25c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们引入了定制的HBase复制接收器服务器，实现备用集群的复制接收器API。复制接收器服务提供了将WAL事件转换成消息的业务逻辑，并在不改变HBase代码的情况下将它们异步发布到Kafka。如果复制接收服务器能够将此事件发布到Kafka，它会向复制源(主)群集发送确认(ACK)。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es lk"><img src="../Images/b139da6fe0144a3bf152c4c343a1e05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6gnINwdUN64Fyz7nN2uhQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Figure 2: Code snippet showing API of Replication Sink Service</figcaption></figure><p id="81cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">名为Argus的内部通知框架接收Kafka事件，并基于这些事件触发业务逻辑。</p><p id="0b50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个系统与Kafka一起构成了我们基于HBase的CDC框架的主干，除了Ixia之外，它还被广泛用于多个用例。HBase复制接收器机制保证所有wal都发布到Kafka，Kafka的使用者为每个事件执行客户定义的业务逻辑。</p><h2 id="b79c" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">搜索引擎</h2><p id="92e7" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">我们有一个名为<a class="ae jc" rel="noopener" href="/pinterest-engineering/manas-realtime-enabling-changes-to-be-searchable-in-a-blink-of-an-eye-36acc3506843"> Muse </a>的内部搜索引擎，这是一个通用的信息检索平台。Muse针对在线服务进行了大量优化，并提供了丰富的搜索和聚合查询。Muse在Pinterest上用于不同的关键用例，如家庭订阅、广告、购物等。Ixia使用Muse作为搜索引擎，在非行键列中提供丰富的搜索功能。</p><p id="4f31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们评估了Solr或ElasticSearch作为搜索引擎的使用。两者都被业界广泛采用，并具有良好的查询和索引性能。Muse与Solr和Elasticsearch的功能相当，它完全集成在Pinterest堆栈中。我们决定选择Muse，以保持技术堆栈与Pinterest的其余部分保持一致。尽管如此，如果将来需要，我们在Ixia中的可插拔查询引擎接口使得切换到不同的搜索引擎更加容易。</p><h2 id="17e5" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">隐藏物</h2><p id="577e" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">Ixia使用Pinterest的<a class="ae jc" rel="noopener" href="/pinterest-engineering/scaling-cache-infrastructure-at-pinterest-422d6d294ece">分布式缓存基础设施</a>，由<a class="ae jc" href="https://github.com/memcached/memcached" rel="noopener ugc nofollow" target="_blank"> Memcached </a>和<a class="ae jc" href="https://github.com/facebook/mcrouter" rel="noopener ugc nofollow" target="_blank"> Mcrouter </a>提供支持。它使用后备缓存策略来优化读取性能并减少HBase上的负载。Ixia的请求模式的特点是非常高的读写比率(~15:1)，添加缓存节省了大量基础设施成本。每个缓存条目对应一个ixia文档，该文档又对应一个HBase行。读取请求首先在缓存中进行同步检查，并在可用时返回给客户端，缺失的条目从真实源存储中异步回填。所有写请求首先在缓存中删除，以维护Ixia的数据一致性契约。Ixia中的查询API提供了从文档中请求字段子集的灵活性。为了降低从缓存和HBase组装文档的实现复杂性，我们决定故意拒绝不包含所有请求字段的缓存条目，并将它们异步回填到缓存中。</p><p id="cbe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们试验了直写缓存策略，发现如果Ixia在写入时间写入缓存，命中率会非常低。由于较高的读/写比率，写流量非常低，以至于文档最终从HBase中读取，缓存不是很有用。在如上所述将策略改为后备之后，缓存命中率显著提高，一直在90%左右。</p><h2 id="157d" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">端到端请求流</h2><ol class=""><li id="5a34" class="ll lm hh ig b ih lf il lg ip ln it lo ix lp jb lq lr ls lt bi translated">当insert/upsert请求进来时，Ixia从缓存中删除这个键，并同步写入HBase(如图1所示)。WAL在被复制到复制接收器服务器之后被发布到Kafka。通知框架(Argus)使用更新事件并将请求发送给Ixia，请求中带有一个标志，指示服务只能通过Kafka更新Muse。删除/移除请求的流程类似。</li><li id="272c" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated">当一个查询请求进来时，Ixia将它发送给Muse进行倒排索引查找。然后，Ixia在HBase中对Muse返回的所有文档键执行正向数据查找，以确保这些文档存在于真理数据库的源中。</li><li id="e6f3" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated">当一个Get请求进来时，Ixia直接从数据库获得结果，并将其返回给客户机。这个RPC是一个相对较薄的包装器，用于KV对HBase的直接访问。</li></ol><h1 id="6f54" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据模型</h1><p id="f7a2" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">Ixia是一个文档存储库，由以下不同的逻辑组件组成</p><p id="cf4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">名称空间— Ixia的名称空间与HBase中的名称空间和Muse中的名称空间有1:1的映射。</p><p id="9b54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">文档键—这个键唯一地标识一个Ixia文档，并与HBase行键有1:1的映射。</p><p id="cf21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">表Ixia表映射到HBase表。</p><p id="fdf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">字段Ixia字段的结构为<namespace> : <table> : <hbase_column_family> : <hbase_column_name>，唯一标识一个HBase单元格和一个Muse索引字段。</hbase_column_name></hbase_column_family></table></namespace></p><h1 id="4709" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">模式管理和生存时间(TTL)支持</h1><p id="a9c9" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">Ixia支持在线模式更改。HBase是无模式的，但是Muse使用预先声明的类型化模式。目前，Ixia支持在不影响在线流量的情况下添加新的索引。这些索引需要部署在Muse配置和Ixia节俭层。新的索引以后可以由客户机为旧文档回填。</p><p id="0848" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ixia支持TTL，保证Hbase TTL +/- cache TTL。如果文档在HBase中缓存并过期，可能会出现不一致的情况。因此，我们为对到期准确性更敏感的用例设置较短的缓存TTL。</p><h1 id="257a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">一致性模型</h1><p id="cab8" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">Ixia类似于HBase，支持强一致性Get请求。只有在对数据库的写请求成功后，索引才会更新。这是CDC框架的自然结果，因为WAL事件肯定会发布到复制接收器服务，从而发布到kafka。通知框架使用这些消息，并通过Ixia向Muse发送索引请求。这种保证是使用CDC层进行索引的核心设计动机之一。查询API用于从搜索引擎中搜索文档。它提供了丰富的功能，如基于匹配、成员、范围等的过滤。，以及基于总和、平均值、最大值、最小值等的聚合结果，如图3所示。由于架构的异步索引，查询API最终是一致的。P99从编写文档到搜索文档之间的延迟大约是1秒。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es lz"><img src="../Images/9f8a49eefee4fadd7a9d921d1afeacea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duQ2lUbFucwAdxpnrSu9gw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx">Figure 3: An example of Ixia’s query request</figcaption></figure><h1 id="2e24" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">表演</h1><p id="ef6b" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">Ixia已经投入生产一年多了，为购物、广告、信任和安全等几个关键用例提供服务。由于组件的分布式本质，系统是可水平扩展的。API节俭层和Muse具有基于CPU警报的自动伸缩功能。我们实施了监控和警报，以确保在扩展需求开始影响其他组件的系统可用性和可靠性之前满足这些需求。我们能够根据客户的需求调整节俭层、缓存层、muse层和HBase层的配置。这些参数通常由QPS、延迟、吞吐量、查询模式要求等因素决定。我们根据使用情形、数据量等的关键程度部署了专用和共享集群。我们的一个生产集群正在以大约5毫秒的p99请求延迟为大约40k qps提供服务，响应大小为大约12KB，可用性SLA为99.99%。整个系统的最大吞吐量峰值约为250k qps。</p><h1 id="f304" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">灾难恢复</h1><p id="9acb" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">对于容错，Ixia由两个HBase集群提供支持。活动群集为在线流量提供服务，并不断复制到备用群集。如果活动集群出现问题，我们有适当的机制来实现零停机故障转移，并在不影响可用性的情况下激活备用集群。</p><p id="2073" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，还有一些系统可以定期拍摄HBase快照和连续的WAL备份。这两种机制共同为我们提供了真实数据来源的时间点恢复。</p><p id="5773" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有Map reduce作业，它可以基于HBase快照确定性地导出一个索引。只要真实数据的来源完好无损，这个离线Muse索引可以用于在任何时间点启动新的Muse集群。</p><p id="11ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果出现数据损坏，我们有能力恢复真实来源的数据以及索引。</p><h1 id="73ac" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">学习和未来工作</h1><h2 id="197a" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">系统复杂性</h2><p id="ed5a" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">在这样一个复杂的分布式系统上学习、贡献和装载客户机是一次很棒的经历。由于HBase本身缺乏对二级索引的支持，异步索引管道有多个组件增加了操作负载。</p><p id="45d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ixia thrift层的API表面积很大，这使得客户可以非常灵活地编写昂贵的查询。这使得我们有必要在各个层设置系统限制，以防止由于查询模式变化而导致的级联故障。诊断和调试这种复杂的错误会增加维护成本。</p><h2 id="c741" class="kr je hh bd jf ks kt ku jj kv kw kx jn ip ky kz jr it la lb jv ix lc ld jz le bi translated">最终一致性</h2><p id="85d2" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">当前架构无法支持当前模型中的强索引一致性。由于API层是通用的可插拔存储和搜索后端，我们正在探索其他与Ixia一起使用的NewSQL数据库，它们可以支持强大的一致性并降低异步索引管道的复杂性。</p><p id="da1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们目前支持p99延迟为几毫秒、SLA为99.5%的最终索引一致性。少量失败的索引更新被记录在磁盘上，并在稍后使用内部管道进行尝试，这些管道使用发布-订阅系统将数据从磁盘移动到数据湖。我们定期运行离线作业，从数据湖中读取这些失败的索引请求，并使用在线路径重试。</p><h1 id="140b" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">确认</h1><p id="c477" class="pw-post-body-paragraph ie if hh ig b ih lf ij ik il lg in io ip lh ir is it li iv iw ix lj iz ja jb ha bi translated">我们要感谢整个存储和缓存团队，特别是和徐。我们还要感谢我们的搜索基础团队，特别是谢海滨。最后，我们要感谢所有客户的支持和反馈。</p><p id="b641" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ma">要在Pinterest了解更多工程知识，请查看我们的</em> <a class="ae jc" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="ma">工程博客</em> </a> <em class="ma">，并访问我们的</em><a class="ae jc" href="https://labs.pinterest.com/?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=wagh-july-20-2021" rel="noopener ugc nofollow" target="_blank"><em class="ma">Pinterest Labs</em></a><em class="ma">网站。要查看和申请空缺职位，请访问我们的</em> <a class="ae jc" href="https://www.pinterestcareers.com/?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=wagh-july-20-2021" rel="noopener ugc nofollow" target="_blank"> <em class="ma">职业</em> </a> <em class="ma">页面。</em></p></div></div>    
</body>
</html>