# Python 性能管理的 5 点框架

> 原文：<https://medium.com/capital-one-tech/a-5-point-framework-for-python-performance-management-5af2be5739d9?source=collection_archive---------1----------------------->

## 性能测试——像帆船比赛一样——取决于赛道的条件

![](img/68dad775d9037a49b0659e81acf575d2.png)

我以前住在船上。出现的一个问题是*“它跑多快？”*这是一个足够令人愉快的问题，但答案却很微妙，听起来有些闪烁其词。这是一艘帆船，意味着速度在一定程度上随风而变。它也随着所使用的帆、天气和海况以及船和风之间的相对角度而变化。所以回答“看情况”总觉得别扭。

*这并不是我想回避，但是衡量业绩是很微妙的。对船来说，没有简单的“它跑得这么快”。用 Python 写软件的时候也没有。当我们将像 numpy 和 Dask 这样的库添加到组合中时，我们真正测量的是什么？我们应该测量什么样的***？**

*或许更重要的是，任何关于“速度”的问题都不一定是正确的问题。大型船上居住帆船的用例关注的是它能去哪里，而不是它到达那里的速度。甚至还有*“它能去哪里？”*这个问题比看起来要复杂得多。没有问对问题会让你陷入困境。字面上。当谈到帆船的性能时，有一些艰难的教训需要吸取。或者 Python 应用。*

*我想说的是，Python 的性能就像一艘船一样，与配置选择(如船帆)和特定用例(如风向)密切相关。此外，我想说的是，关于数据量和可伸缩性的问题也很重要，但有时会被忽视。此外，我们应该考虑询问简单性和可维护性。当看 Python 时，我们必须认识到 Python 是一个软件包交易:它以低门槛开始，通过一种易于使用的语言导航，并包含丰富的附加软件包库。将话题缩小到只讨论性能可能会错过 Python 这样的语言带来的额外好处。*

*在这篇文章中，我想概述管理性能测试的五个步骤。我认为这对于 Python 应用程序是有帮助的，在这些应用程序中，性能经常被提到，但是它的应用非常广泛。我们将从一些用例的定义开始这个过程，然后用 Gherkin 形式化它们，与利益相关者一起审查它们，用 Python 实现它们，最后，使整个事情成为我们部署过程的一个持续部分。为什么要使用小黄瓜语言？我认为描述测试的语言适用于许多测试种类，包括集成、系统、验收和性能测试。我想先看看性能测试的目标，以及为什么有时很难提出合适的问题。从那里，我们将能够进入测量 Python 应用程序性能的方法。*

# *性能测试目标*

*我们经常从一个安全的港湾开始我们的 Python 性能之旅。我们已经构建了一个应用程序，现在我们希望确保它在大规模运行时表现良好。这应该会引出一个非常明显的问题“我们在谈论什么规模？”*

*“尺度”这个问题有点模糊。这似乎比简单地测量速度更重要。这导致了几种可伸缩性测试的方法。这里有两个极端的立场:*

1.  *在不断增加的工作负载下运行应用程序、服务或平台，直到性能“恶化”我要把这个叫做*探索*。*
2.  *设置工作负载的级别和性能目标，以查看应用程序是否满足给定工作负载下的性能要求。我想称之为*测试*，以区别于较少约束的*探索*。*

*我曾经与不喜欢将性能或可伸缩性降低到几个通过/失败测试用例的人一起工作过。他们更喜欢探索性方法的数据收集和工程方面。我不想给探索贴上错误的标签，但是我想把开放式探索和有明确终点线的测试用例区分开来。*

*![](img/49990a31d7bc918db0d65227987606d4.png)*

*Photo by me*

*探索是为什么在皮划艇或站立式划桨板中闲逛是有趣的。你可以找到许多凉爽、僻静的地方，进行一些认真的观鸟活动。但是如果没有一个清晰、深、宽、有标记的航道，你就不会驾驶一艘 42 英尺的帆船进入任何地方。这些标准至关重要，通常由美国海岸警卫队等政府机构制定。测试案例包括“*航道是否在已发布的海图上？”*和*“标记是否修复良好？”*和*“绘制的深度是否足够？”*和*“有什么碍事的吗？”*如果这些测试案例失败，我们必须将船掉头驶向安全的深水区。*

*对于一艘大帆船来说，问题不是“多快？”更像是*“多远？”*这是一个不同的性能问题，与目的地有关，而不是速度。与部署应用软件一样，我们必须确保我们问的是正确的问题。*

*当我们稍微转移一下我们的焦点时，很明显“速度”是更具包容性的规模概念的一个方面。我们必须考虑工作负载、事务组合、网络开销和延迟，以及基于 web 的架构的常见混乱。*

*当开始一个新项目时，很难确定每件事都考虑到了。我想提供一个允许——并鼓励——积极成长和学习的框架。我们希望我们的测试用例反映出我们对问题、解决方案和用户体验的最佳理解。*

# *Python 性能测试*

*我想建议进行 Python 性能测试的五个步骤。*

1.  *定义用例以及性能目标。这就创造了一种我们的应用程序必须生活在其中的“盒子”。在某些情况下，盒子的比喻非常贴切，因为有一个速度与体积的权衡，使它们成为彼此的反义词。*
2.  *将绩效目标编成小黄瓜。这些通常是看起来相对简单的场景概要。在某些情况下，可能有多个与性能相关的功能。在其他情况下，性能是整个验收测试套件的一部分，并且只有一个特性。*
3.  *与产品负责人一起回顾，确保他们理解小黄瓜是如何描述用户体验的。这涉及到一个持续的努力，优先考虑和改变我们所知道的和我们将定义为可接受的。是的，这很像在比赛中移动终点线。在帆船比赛中，调整航向以反映不断变化的天气条件是很常见的。*
4.  *现在到了编程部分。行为工具([https://behave.readthedocs.io/en/latest/index.html](https://behave.readthedocs.io/en/latest/index.html))依靠 Python 函数来实现小黄瓜测试场景的文本。有了 Gherkin 步骤定义和一个环境模块，您可以运行 behave 工具，这将构建您的性能结果。*
5.  *使性能测试成为 CICD 管道的一部分。我认为持续集成需要持续的性能测试。否则，您如何在部署应用程序之前确定它是可接受的呢？*

*我们将分别采取这些步骤。*

# *步骤 1 —定义用例*

*对于软件性能，必须为数据量、用户数量、事务混合和其他特定属性定义具体的阈值。就像帆船比赛一样，需要有一个起跑线、一个航向和一个终点线。有些球场布局长或复杂，需要大量的机动，其他球场可能布局较短和简单，但需要选手多跑几圈。*

*我们的软件应用程序的测试阈值可能从一个单一的、简单的、崇高的目标开始，就像希望大多数事务处理 20 毫秒。当我们考虑应用程序所做的实际工作时，我们可能会调整这个目标，以允许峰值工作负载下的时间线滑至 500 毫秒。我们在场景细节中发现的潜在复杂因素越多，如数据库访问、网络延迟、缓存冲突，我们的时间阈值和工作负载就变得越微妙和复杂。*

*很难指定具体的阈值。*多慢才算慢？*虽然一些面向企业的分析工作应该在每天上午 9 点之前出现在决策者的收件箱中是件好事，但推迟一个小时也不会造成太多问题。*多晚才算晚？**

*这些问题可能很难回答，因此很难制定具体的衡量标准和阈值。设置阈值的工作可能非常困难，一些人宁愿放弃性能测试，而切换到“探索”模式，在这种模式下，他们摆弄软件，直到他们觉得它可能被称为“足够快”或“太慢”*

*我更喜欢定义一条终点线。然后移动它。*

*这似乎不公平，但是，我认为定义一个具体的测试用例更适合自动化 CICD。即使终点线需要移动，但有目标并不等于完全没有终点线。没有目标，工程努力可能会浪费在已经“足够快”的事情上*

*我们可能会以一个描述工作负载度量标准 *n* 和一个测试用例结果 s 的表格结束，以确保事情确实有效。我们可能会在这个表中添加更多内容，比如工作负载名称，或者时间目标。出于本文的目的，我们将从所有这些工作负载级别的单一时间阈值开始。*

```
*| n | s |
 | 89 | 44 |
 | 10_000 | 3_382 |
 | 100_000 | 60_696 |
 | 1_000_000 | 1_089_154 |*
```

*您的应用程序可能有更复杂的工作负载因素。你可以跳过“有用吗？”测试结果。对于每个案例，您可能有不同的时间。但是这个想法是定义一个应用程序必须适合的盒子。一旦定义了盒子，形状和大小可能会随着经验的积累而改变。*

# *第二步——用小黄瓜编码*

*每种活动都有自己的语言。航海与软件语言或测试语言没有什么不同。“Helm's a-lee”对于非水手来说意义不大。然而，对于水手来说，这是一个信号，表明船将要转向，横倾的方向将会改变，吊杆将会移动，船帆将会发出噪音，人们将会开始通过绞盘拉起床单。有很多技术细节，都是用水手和船的语言。*

*Gherkin 是描述测试用例设置和预期结果的优秀语言。描述的基本单位是一个场景，它有三种步骤。*

*   ***给出的**步骤描述了设置和先决条件。使用的语言(除了第一个词“给定”)应该是适合应用程序和问题领域的语言。它应该反映我们试图衡量的用户体验。在后面的小节中，我将向您展示这里使用的语言是如何映射到 Python 代码的。从自然语言到实现的映射是灵活的，所以重要的规则是“术语和用法要一致”*
*   *一个 **When** 步骤(通常只有一个)描述运行操作或事务或一组事务。同样，自然语言元素被映射到用 Python 编写的步骤定义。要精确，但也要尽量坚持以用户为中心的术语。*
*   ***然后**步骤描述预期结果。*

*下面是一个场景在实践中的样子:*

```
*Scenario Using the Data Model Filter 2:
**Given** An upper limit of 89
**And** The Data Model Filter 2 algorithm
**When** A request is made
**Then** The row count is 44
**And** Performance is under 500ms*
```

*场景的**给出的**步骤描述了两个先决条件:一个上限和一个特定的数据模型过滤算法。步骤时的**是一个含糊不清的“提出请求”；这依赖于上下文来提供细节。最后的**然后**步骤描述了两个预期结果，一个是正确答案，另一个是性能阈值。***

*场景有标题来提供所需的上下文信息。场景也被分组到特性中，这让我们可以提供额外的上下文。这个想法是让场景步骤小而灵活。*

*实际上，性能测试应该包括许多不同规模的场景。Gherkin 让我们编写一个场景大纲，我们可以使用占位符将大纲扩展成具体的场景。这使我们免于复制和粘贴表面上相似的场景。*

*这是一个只有一个场景轮廓的功能示例。这将填充示例表中场景的占位符。请注意，测试的阈值是 500 毫秒(我们将回到这一点)。*

```
*Feature: Data Filtering App  **Scenario Outline:** Using the Data Model Filter 2
**Given** An upper limit of <n>
**And** The Data Model Filter 2 algorithm
**When** A request is made
**Then** The row count is <s>
**And** Performance is under 500ms ** Examples:**
 | n | s |
 | 89 | 44 |
 | 10_000 | 3_382 |
 | 100_000 | 60_696 |
 | 1_000_000 | 1_089_154 |*
```

*您可以看到，给定的**步骤从表中取值`<n>`，然后**步骤从示例表中取值`<s>`。自然语言文本(如“发出请求”)将由后面的步骤定义来处理，基本规则是保持一致。*****

**(我省略了标点符号。有些人喜欢用逗号或分号结束从句。)**

*500 ms 的性能阈值被简单地写入一个**然后是**步骤，并应用于每一个场景。这样合适吗？如果我们需要移动终点线，我们可能需要扩展表，将阈值作为另一列包含进来。我们可以对缓慢复杂的事务和快速简单的事务使用两种不同的场景大纲。对于复杂应用程序的不同部分，我们可能希望有单独的特性文件，有不同种类的场景。*

*最重要的是将性能形式化的步骤，即创建特定的工作负载和特定的性能目标。这使得运行自动化测试套件并查看故障以了解我们还能学到什么变得明智起来。也许有一个 bug 需要修复。又或许，终点线离起跑线太远了，不符合我们用户的体验。*

*这将我们从定义测试场景带到与产品所有者和其他利益相关者一起审查它们。*

# *步骤 3 —与利益相关方一起审核*

*我认为产品负责人需要对阅读和评论小黄瓜感到舒服。他们应该也能写出来。这可以帮助他们改进和重写测试语言。这种想法通常是有帮助的，因为它可以更深入地了解应用程序如何解决用户的问题。*

*(如果我们改变小黄瓜，我们可能也必须改变 Python 中的步骤定义。我们将在下一节中讨论小黄瓜映射。)*

*通过具体的小黄瓜语言与产品所有者和用户的互动有助于形式化模糊的概念和澄清模糊的期望。它还有助于识别和组织特殊情况、例外和可移动的终点线。这些细微差别通常很重要，在特征文件中直观地跟踪它们会使它们变得可见和具体。*

*一艘帆船，不管它长什么样，都很少有绳索；绳子是在陆地上使用的东西。你在船上看到的每一根绳索一般都是某种线，大部分是床单或升降索。是的，水手们有专门的术语，这是因为每一行的工作都有很大的不同。释放帆有点烦人，因为帆会发出很大的噪音，船会变慢。放下升降索，你就让一堆 50 英尺高的涤纶落在所有东西上。语言很重要，重要的是要确保每个人都认同我们使用的词语的含义。*

*小黄瓜让我们将特性作为组织场景的一种方式。大多数工具，比如 behavior，使用小黄瓜语言特性文件的目录来执行测试，允许我们对特性和场景进行复杂的分级。behavior 工具还允许我们为特性和单独的场景提供标签，让我们对必须通过的测试和仍然是探索的一部分的测试有更多的控制，以及可能需要移动的终点线。*

*行为工具甚至允许我们定义多个环境。所有这些灵活性给了我们很多方法来描述(和测试)我们的应用软件。我认为这种灵活性是形式化的通过/失败测试和不太结构化的探索之间的桥梁。我们可以拥有未经测试的特性，但用于探索性能。*

*我非常喜欢使用表单标签`@rel_x`作为“Release_x”的简写，来设置特性和场景的优先级。所有的`@rel_2`特性都需要为下一个版本做好准备。`@rel_3` 功能测试可能不会马上全部通过。标签似乎有助于标记由于工作正在进行而无法通过的测试。*

# *步骤 4 —构建步骤定义和环境*

*一旦我们有了一些小黄瓜，我们需要实现它。行为工具将实现细节分为两部分:*

*   *步骤定义模块*
*   *环境模块*

*我喜欢这样的目录树:*

```
*the_app
 +-- benches
 | +-- features
 | | +-- important.feature
 | +-- steps
 | | +-- definitions.py
 | +-- environment.py
 +-- src
 | +-- my_app.py
 +-- tests
 | +-- test_my_app.py
 +-- pyproject.toml*
```

*我将性能测试放在`benches`中，就像在“基准测试”中一样`tests`目录有单元测试。“测试”这个名称似乎包含了很多内容，所以可能会有一点误导。我更喜欢将单元测试和性能测试分开，因为每次有变化时都需要运行单元测试，而性能基准测试可能会推迟到发布时进行。*

*通用配置的想法也适用于帆船的布局。在大多数船上，主升降索从主桅伸出，穿过转向滑轮和导缆器，然后到达驾驶舱内的绳索离合器和绞盘。在许多船上，甲板上的线条清晰可见，使布局更容易理解。我们希望我们的项目目录同样简单和通用。*

*基准测试似乎属于集成和验收测试。因为涉众的参与，这些测试的受众不同于单元测试。随着用户知识的增长和产品体验的增长，他们会受到一定程度的影响。这也表明它们应该与单元测试分开。*

*特征文件是小黄瓜，如上所示。`environment.py`文件可以为空。behave 工具需要有一个同名的文件，但是我们不需要在其中放入任何东西。类似地，`steps`目录也可以从空开始。行为工具可以为我们需要编写的步骤定义提供模板。*

*我们可以使用 behave 为步骤定义生成一个模板。每个在 steps 目录的模块中没有匹配定义的 Gherkin 步骤都会产生一个错误。它还将为步骤定义的外观提供建议。*

```
*benches % PYTHONPATH=../src behave Feature: Project Euler Problem #2 Command Line App # features/perf1.feature:1  Scenario Outline: Better Fibonacci Generator -- @1.1 # features/perf1.feature:12
 Given An upper limit of 89 # None
 And The Better Fibo Generator # None
 When Sum is computed # None
 Then Answer is 44 # None
 And Performance is under 500ms # None*
```

*这将显示所有场景。在场景的最后，有这样一个总结:*

```
*0 features passed, 1 failed, 0 skipped
 0 scenarios passed, 10 failed, 0 skipped
 0 steps passed, 0 failed, 0 skipped, 50 undefined
 Took 0m0.000s You can implement step definitions for undefined steps with these snippets: @given(u'An upper limit of 89')
 def step_impl(context):
 raise NotImplementedError(u'STEP: Given An upper limit of 89')*
```

*behave 输出中的最后一批行将是任何所需步骤定义的报告。该报告将详细说明每个尚未定义的小黄瓜步骤；它们作为一个函数提供，可以粘贴到 steps 目录中的模块中。第一次运行 behavior 时，可能会出现大量这样的小块；将它们复制并粘贴到一个模块中即可开始使用。*

*当我们看函数占位符时，在步骤定义中会有`@given`、`@when`和`@then`装饰器。在最初的小黄瓜中，我们使用‘And’来继承上一步的步骤类型。这使用`"Given this And that And the other"`创建了一个稍微更自然的流程。我们可以在小黄瓜中只使用`Given`,但是当我们这样做时，它看起来比正常情况下更不自然。小黄瓜`"Given this And that"`导致`@given(u'this')`和`@given(u'that')`步骤定义装饰。想法是从测试用例到 Python 中的实现有一个相对透明的映射。*

*(`u''`字符串使用前缀明确表示该字符串是 Unicode 的。这是默认的，所以显得多余。)*

*需要注意的是，behavior 在处理复杂的引号方面并不是很聪明。如果步骤的小黄瓜文本使用了引号，最好使用`"`来避免处理`'`带来的一点点复杂性。具体来说，第一次使用带有`'`的生成步骤时，您可能会在生成的代码中看到语法错误。修复生成的步骤定义并不难；它只需要做一次，因为它们永远不会再次生成。*

*还有，函数名都是`step_impl`。名字并不重要，也没有真正被使用。装饰用于将代码分离到不同的结构中，供 behave 使用。*

*一旦您定义了所有的步骤，您可以重新运行 behave 并看到您的所有步骤现在都失败了，因为它们没有被实现。这是一大进步。现在我们已经为下一段旅程做好了准备，那就是更全面地定义我们如何进行性能测试和收集基准信息。*

# *步骤 5 —构建测试细节*

*行为工具的工作方式是检查场景中的每个步骤，并定位与步骤文本相匹配的步骤定义。当我们有一个场景大纲时，示例表中的每一个唯一的替换都会导致大纲中步骤的唯一副本。*

*在我们的例子中，这种处理方法意味着给定变量将有四个单独的**，包括`@given(u'An upper limit of 89')`。behave 工具为我们提供了几个可选的匹配器，可以用来从步骤文本中提取有意义的值，避免了需要四个几乎相同的步骤。***

*默认的匹配器允许我们修改装饰器和函数，如下所示。*

```
*@given(u'An upper limit of {limit}')
 def step_impl(context, limit):
 context.cli_options.extend(["--limit", str(int(limit))])*
```

*`{limit}`提取定义步骤的文本部分。该文本与测试上下文一起提供给实现功能。我们进行了一次`int()`转换，以确保它是一个整数，然后将它转换回一个字符串，因为这是后面需要的。我们将该值保存到测试应用程序的 test `context`对象的`cli_options`属性中。*

*因为`context`参数值是一个普通的 Python 对象，所以我们可以随心所欲地给它添加属性。我们必须避免那些被 behave 使用的。*

*我们可以在 environment.py 模块中使用一个`before_scenario()`函数来创建一个空的`context.cli_options`列表。这不是步骤定义的一部分，这是单独的，是`environment.py`模块中仅有的两行代码。*

```
*def before_scenario(context, scenario):
 context.cli_options = []*
```

*在定义步骤时，有一些常见的模式可以遵循。通常，我们的**给定的**步骤将在上下文中保存设置信息。随着设置变得更加复杂，环境模块中相关的`before_scenario()`功能也可能变得更加复杂。*

*我们的 **When** 步骤将使用设置信息来运行我们正在测试的应用程序、服务或框架。在我们的例子中，它可能看起来像这样:*

```
*from my_app import main @when(u'Sum is computed')
 def step_impl(context):
 buffer = io.StringIO()
 with contextlib.redirect_stdout(buffer):
 start = time.perf_counter()
 main(context.cli_options)
 end = time.perf_counter()
 context.output_text = buffer.getvalue().splitlines()
 context.run_time = end-start*
```

*因为我们测试的应用程序有一个`main()`函数，我们可以利用它。有很多选择，这取决于测试的是哪种代码，以及你如何测试它。以下是几个备选方案:*

1.  *使用`subprocess`模块运行应用程序，就像从命令行运行一样。这对于非 Python 应用程序来说非常重要。*
2.  *使用`subprocess`模块运行 Docker 命令，启动运行应用程序的 Docker 容器。性能测量需要理解为反映在另一个主机上运行的 dockerized 容器。*
3.  *使用类似 Terraform 的工具来构建云资源、部署和启动应用程序。这种云原生测试需要时间来启动和停止，因此一个大型的性能测试套件可能需要很长时间来运行。这可能会导致为某些关键功能创建场景子集。*
4.  *如果我们使用 AWS，我们可能会使用`boto3`库为我们的测试构建云资源。*

*这还不是全部。这些只是众多可用技术中的几个。重要的是，我们将利用 Python 的能力来运行应用程序。Python 提供了许多库，我们最终可能会做一些相当聪明的事情。*

*一个好的实践是在 **When** 步骤中捕获输出，并将其填充到上下文中。然后**和**步骤可以检查这些结果，看看测试是否通过。*

*拥有一个测试套件是性能测试解决方案的一部分。使用测试套件也是必不可少的，我们接下来会谈到这一点。*

**披露声明:2021 首创一号。观点是作者个人的观点。除非本帖中另有说明，否则 Capital One 不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。**

**原载于*[*https://www.capitalone.com*](https://www.capitalone.com/tech/software-engineering/5-point-framework-for-python-performance-management/)*。**