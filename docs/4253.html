<html>
<head>
<title>About lists, snackbars, and why they don’t get along.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于清单，零食，以及为什么他们合不来。</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/about-lists-snackbars-and-why-they-dont-get-along-4c9ea11258f1?source=collection_archive---------2-----------------------#2019-07-23">https://medium.com/google-developer-experts/about-lists-snackbars-and-why-they-dont-get-along-4c9ea11258f1?source=collection_archive---------2-----------------------#2019-07-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7fc19668fc5ded5f5aaef6deaa7c01bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prb0pSFFwWcOSn0jFDHUKw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Image from <a class="ae hu" href="https://www.instagram.com/jplenio/" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> — <a class="hv hw ge" href="https://medium.com/u/a640208c527a?source=post_page-----4c9ea11258f1--------------------------------" rel="noopener" target="_blank">Pixabay</a></figcaption></figure><div class=""/><p id="448a" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">最近，我一直在开发核心的纽约时报阅读应用的一个新功能，我遇到了一个非常具有挑战性的问题:每当用户点击列表中的一项时，就会出现一个永久的<code class="du ju jv jw jx b">Snackbar</code>。因为<code class="du ju jv jw jx b">Snackbar</code>应该被锚定到<code class="du ju jv jw jx b">RecyclerView</code>的下端，所以列表的最后一个元素总是至少被部分覆盖，并且不可访问。</p><figure class="jz ka kb kc fd hj er es paragraph-image"><div class="er es jy"><img src="../Images/9bd0512c9d6c38946ada3a44a93a0fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*J4rarlupEDx4a2kB4D5nAA.gif"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">We can see the last item being always covered</figcaption></figure><p id="fa66" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">我们与团队的其他成员讨论了几种解决方案:我们试图使用<code class="du ju jv jw jx b">CoordinatorLayout</code>，但是由于<code class="du ju jv jw jx b"><a class="ae hu" href="https://developer.android.com/reference/android/support/design/widget/Snackbar.html?hl=en" rel="noopener ugc nofollow" target="_blank">Snackbar</a></code> <a class="ae hu" href="https://developer.android.com/reference/android/support/design/widget/Snackbar.html?hl=en" rel="noopener ugc nofollow" target="_blank">不是</a> <code class="du ju jv jw jx b"><a class="ae hu" href="https://developer.android.com/reference/android/support/design/widget/Snackbar.html?hl=en" rel="noopener ugc nofollow" target="_blank">View</a></code>，这种方法显得相当复杂；我们讨论过在列表末尾添加一个空的<code class="du ju jv jw jx b">View</code>，或者一些空格，但是我们没有被说服。</p><p id="ccc4" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">因此，在我的黑客日期间，我决定探索另一个解决方案:一般的想法是利用回调，这样当<code class="du ju jv jw jx b">Snackbar</code>可见时我可以得到警告。<code class="du ju jv jw jx b">BaseCallback&lt;T&gt;</code>提供了两个方法来覆盖，这两个方法将在<code class="du ju jv jw jx b">Snackbar</code>显示后被触发，并在is消失后被触发。</p><h2 id="face" class="kd ke hz bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated">代码</h2><p id="97f2" class="pw-post-body-paragraph iw ix hz iy b iz ky jb jc jd kz jf jg jh la jj jk jl lb jn jo jp lc jr js jt ha bi translated">主要思想是利用显示事件来提升内容——仅在需要时——并在<code class="du ju jv jw jx b">Snackbar</code>不再可见时降低内容。因为我们希望这尽可能平滑，所以我们在显示了<code class="du ju jv jw jx b">Snackbar</code>之后更新了间距，但是我们不会使用其他事件:这个方法将在<code class="du ju jv jw jx b">Snackbar</code>已经消失之后被触发，所以我们会看到一个小故障。</p><p id="3fc9" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">我们将使用<code class="du ju jv jw jx b">Snackbar</code>上的<code class="du ju jv jw jx b">Action</code>，这样我们就可以在动画开始之前重置间距，从而掩盖故障:</p><figure class="jz ka kb kc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="3c0f" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">推动利润波动的逻辑非常简单，但我花了几个小时才完全理解。我们要做的第一件事是检查适配器中的最后一项是什么。</p><p id="bc15" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">下一步将是<code class="du ju jv jw jx b">RecyclerView</code>的实际移动:我们创建一个新的<code class="du ju jv jw jx b">ConstraintSet</code>并从根<code class="du ju jv jw jx b">ConstraintLayout</code>克隆它，然后我们应用一个基于<code class="du ju jv jw jx b">Snackbar</code>高度或0的边距(当这样的条不再显示时)，然后我们将这个设置应用到根。</p><p id="1f07" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">此时，如果所选项目是最后一项，我们滚动列表，以便每个项目都可见:</p><figure class="jz ka kb kc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="e9ff" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">该代码基于几个特定于我们案例的假设:</p><ul class=""><li id="d2ef" class="lf lg hz iy b iz ja jd je jh lh jl li jp lj jt lk ll lm ln bi translated">我们的元素比<code class="du ju jv jw jx b">Snackbar</code>高，所以栏只能覆盖其中一个——这样我们只需要关心最后一项。</li><li id="6733" class="lf lg hz iy b iz lo jd lp jh lq jl lr jp ls jt lk ll lm ln bi translated">在我们的场景中，当我们按下<code class="du ju jv jw jx b">Snackbar</code>上的动作按钮时，我们被带到另一个屏幕，因此用户将看不到退出动画。</li><li id="432d" class="lf lg hz iy b iz lo jd lp jh lq jl lr jp ls jt lk ll lm ln bi translated">如果感兴趣的项目是最后一个，我们只想滚动—因为我们在底部添加了边距，用户仍然可以滚动并看到所有内容。</li></ul><p id="9eeb" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">我们还需要在每次迭代中创建一个新的<code class="du ju jv jw jx b">SmoothScroller</code>实例，否则我们的应用程序会开始抱怨它被重用:</p><pre class="jz ka kb kc fd lt jx lu lv aw lw bi"><span id="5939" class="kd ke hz jx b fi lx ly l lz ma">W/RecyclerView: An instance of SmoothScroller was started more than once. Each instance ofSmoothScroller is intended to only be used once. You should create a new instance for each use.</span></pre><p id="f2d9" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">需要使用一个<code class="du ju jv jw jx b">SmoothScroller</code>，它是<code class="du ju jv jw jx b">LinearSmoothScroller</code>的一个小扩展，这样我们可以定义一个滚动速度，这个速度在屏幕的其余部分看起来很好，但它可以很容易地进一步阐述:</p><figure class="jz ka kb kc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c901" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">最终结果看起来相当不错，即使我对列表的退出行为不是100%满意:</p><figure class="jz ka kb kc fd hj er es paragraph-image"><div class="er es jy"><img src="../Images/029941d821d5b86976ace526770b041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*UTxALxJ5JX8LNZWupBzxYw.gif"/></div></figure><h2 id="abec" class="kd ke hz bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated">结论</h2><p id="45f1" class="pw-post-body-paragraph iw ix hz iy b iz ky jb jc jd kz jf jg jh la jj jk jl lb jn jo jp lc jr js jt ha bi translated">这段代码实际上是根据我们所面临的问题而定制的，它可以很容易地根据可见项目的数量进行定制。</p><p id="3e67" class="pw-post-body-paragraph iw ix hz iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">如果你想检查代码并尝试一下——也许能找到更好的解决方案——你可以在<a class="ae hu" href="https://github.com/tiwiz/AndroidXSharedTest" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>