<html>
<head>
<title>Generic Docker Container Image for running and live reloading a Node application based on a GitHub Repo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于GitHub Repo运行和实时重新加载节点应用程序的通用Docker容器映像</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/generic-docker-container-image-for-running-and-live-reloading-a-node-application-based-on-a-github-66777bf6e7a8?source=collection_archive---------0-----------------------#2018-09-22">https://medium.com/oracledevs/generic-docker-container-image-for-running-and-live-reloading-a-node-application-based-on-a-github-66777bf6e7a8?source=collection_archive---------0-----------------------#2018-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d30f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的愿望是:找到一种使用通用Docker容器从Git(Hub)存储库中运行节点应用程序的方法，并且能够在repo中的源代码更新时动态刷新运行中的容器。在某些情况下，包括快速开发/测试周期和实时演示，为每个应用程序和应用程序的每次更改生成容器的过程过于繁琐和耗时。我正在寻找一种方便的方法，在任何可以运行Docker容器的地方运行节点应用程序，而不必构建和推送容器映像，并在几秒钟而不是几分钟内持续更新正在运行的应用程序。本文描述了我为满足这一需求而创建的内容。</p><p id="4a90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">故事中的关键成分:node mon——一个工具，它监视文件系统中node.js应用程序的任何更改，并在出现此类更改时自动重启服务器。我不得不把这些放在一起:</p><p id="c2f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于官方节点映像的通用Docker容器——内部有npm和git客户端</p><ul class=""><li id="dfa1" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">添加nodemon(监视应用程序源)</li><li id="b246" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">添加一个后台节点应用程序，该应用程序可以根据一个明确的请求、基于一个作业调度并由Git webhook触发，从Git存储库中刷新</li><li id="d375" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">为节点应用程序的源Git存储库的URL定义一个环境变量GITHUB_URL</li><li id="cf8b" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">添加一个启动脚本，该脚本在容器第一次运行时运行(从通过GITHUB_URL指定的Git repo克隆，并使用<em class="jq"> nodemon </em>运行应用程序)或重启时运行(仅使用<em class="jq"> nodemon </em>运行应用程序)</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/5396b9b1e3d14e3d858bc7c7866d0a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5R666VQkrr7mOeWM"/></div></div></figure><p id="5526" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我一直在努力学习Docker语法和操作(CMD vs RUN vs ENTRYPOINT)以及Linux bash shell脚本——我确信我的结果可以改进。</p><p id="30ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">构建包含所有通用元素的Docker容器的Docker文件如下所示:</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="92ca" class="ki kj hh ke b fi kk kl l km kn">FROM node:8 <br/>#copy the Node Reload server - exposed at port 4500 <br/>COPY package.json /tmp <br/>COPY server.js /tmp <br/>RUN cd tmp &amp;&amp; npm install <br/>EXPOSE 4500 <br/>RUN npm install -g nodemon <br/>COPY startUpScript.sh /tmp <br/>COPY gitRefresh.sh /tmp <br/>CMD ["chmod", "+x", "/tmp/startUpScript.sh"] <br/>CMD ["chmod", "+x", "/tmp/gitRefresh.sh"] <br/>ENTRYPOINT ["sh", "/tmp/startUpScript.sh"]</span></pre><p id="3b90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随意挑选任何其他节点基础映像—例如来自https://hub.docker.com/_/node/.<a class="ae ko" href="https://hub.docker.com/_/node/." rel="noopener ugc nofollow" target="_blank">的节点:10。</a></p><p id="f925" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每当启动容器时执行的startUpScript负责将节点应用程序从Git(Hub) URL初始克隆到目录/tmp/app，并使用nodemon运行该应用程序，如下所示。请注意这个技巧(受<a class="ae ko" href="https://stackoverflow.com/questions/37836764/run-command-in-docker-container-only-on-the-first-start" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的启发)只在容器第一次运行时运行脚本。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="2e56" class="ki kj hh ke b fi kk kl l km kn">#!/bin/sh CONTAINER_ALREADY_STARTED="CONTAINER_ALREADY_STARTED_PLACEHOLDER" <br/>if [ ! -e $CONTAINER_ALREADY_STARTED ]; <br/>then <br/>  touch $CONTAINER_ALREADY_STARTED <br/>  echo "-- First container startup --" <br/>  # YOUR_JUST_ONCE_LOGIC_HERE <br/>  cd /tmp <br/>  # prepare the actual Node app from GitHub <br/>  mkdir app <br/>  git clone $GITHUB_URL app <br/>  cd app <br/>  #install dependencies for the Node app <br/>  npm install <br/>  #start both the reload app and (using nodemon) the actual Node app  <br/>  cd .. <br/>  (echo "starting reload app") &amp; (echo "start reload";npm start; echo "reload app finished") &amp; <br/>  cd app; <br/>  echo "starting nodemon for app cloned from $GITHUB_URL"; <br/>  nodemon <br/>else <br/>  echo "-- Not first container startup --" <br/>  cd /tmp <br/>  (echo "starting reload app and nodemon") &amp; (echo "start reload";npm start; echo "reload app finished") &amp; <br/>  cd app; <br/>  echo "starting nodemon for app cloned from $GITHUB_URL"; <br/>  nodemon <br/>fi</span></pre><p id="c1ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">启动脚本在后台运行live reloader应用程序—使用(echo“start reload”；npm开始)&amp;。最后一个&amp;符号负责在后台运行命令。这个<em class="jq"> npm start </em>命令运行/tmp中的server.js文件。该服务器在端口4500监听请求。当在/reload收到请求时，应用程序将执行<em class="jq"> gitRefresh.sh </em> shell脚本，该脚本在/tmp/app目录中执行git pull，该目录是存储库的git克隆的目标。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="77e7" class="ki kj hh ke b fi kk kl l km kn">const RELOAD_PATH = '/reload' <br/>const GITHUB_WEBHOOK_PATH = '/github/push'</span><span id="d1ea" class="ki kj hh ke b fi kp kl l km kn">var http = require('http'); <br/>var server = http.createServer(function (request, response) { <br/>  console.log(`method ${request.method} and url ${request.url}`)</span><span id="eb0b" class="ki kj hh ke b fi kp kl l km kn">if (request.method === 'GET' &amp;&amp; request.url === RELOAD_PATH) {<br/>    console.log(`reload request starting at ${new Date().toISOString()}...`);<br/>    refreshAppFromGit();<br/>    response.write(`RELOADED!!${new Date().toISOString()}`);<br/>    response.end();<br/>    console.log('reload request handled...');<br/>  }<br/>    else if (request.method === 'POST' &amp;&amp; request.url === GITHUB_WEBHOOK_PATH) {<br/>    let body = [];<br/>    request.on('data', (chunk) =&gt; { body.push(chunk);})<br/>           .on('end', () =&gt; {<br/>              body = Buffer.concat(body).toString();<br/>              // at this point, `body` has the entire request body stored in it as a string<br/>              console.log(`GitHub WebHook event handling starting ${new Date().toISOString()}...`);<br/>              ... (see code in GitHub Repo <a class="ae ko" href="https://github.com/lucasjellema/docker-node-run-live-reload/blob/master/server.js" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/docker-node-run-live-reload/blob/master/server.js</a>              <br/>              console.log("This commit involves changes to the Node application, so let's perform a git pull ")<br/>              refreshAppFromGit();<br/>              response.write('handled');<br/>              response.end();<br/>              console.log(`GitHub WebHook event handling complete at ${new Date().toISOString()}`);<br/>            });<br/>         }</span><span id="fd90" class="ki kj hh ke b fi kp kl l km kn">else { // respond <br/>    response.write('Reload is live at path '+RELOAD_PATH);<br/>    response.end(); <br/>  } <br/>}); <br/>server.listen(4500); <br/>console.log('Server running and listening at Port 4500'); <br/>var shell = require('shelljs'); <br/>var pwd = shell.pwd() <br/>console.info(`current dir ${pwd}`) <br/>function refreshAppFromGit() { <br/>  if (shell.exec('./gitRefresh.sh').code !== 0) { <br/>    shell.echo('Error: Git Pull failed'); <br/>    shell.exit(1); <br/>  } <br/>  else { } <br/>}</span></pre><h1 id="d86f" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用节点-运行-实时-重新加载映像</h1><p id="84e5" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">既然你已经对图像的内部工作原理有了一些了解，让我来告诉你如何使用它(同样参见这里的说明:【https://github.com/lucasjellema/docker-node-run-live-reload】T4)。</p><p id="399c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要自己构建映像，克隆GitHub repo并运行</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="5270" class="ki kj hh ke b fi kk kl l km kn">docker build -t "node-run-live-reload:0.1" .</span></pre><p id="a08e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢，当然可以使用你自己的图像标签。我已经将图像推送到Docker Hub，作为lucasjellema/node-run-live-reload:0.1。你可以像这样使用这个图像:</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="aeac" class="ki kj hh ke b fi kk kl l km kn">docker run --name express -p 3011:3000 -p 4505:4500  -e GITHUB_URL=https://github.com/shapeshed/express_example -d lucasjellema/node-run-live-reload:0.1</span></pre><p id="7ae3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在终端窗口中——我们可以使用</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="73d0" class="ki kj hh ke b fi kk kl l km kn">docker logs express --follow</span></pre><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/fa8b2b642e226ff707b5a82f8889bc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3sKqae-aAgxvbxn2"/></div></div></figure><p id="7d0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从GitHub克隆应用程序后，npm安装了依赖项，nodemon启动了应用程序，我们可以在<host> :3011访问它(因为<em class="jq"> docker run </em>命令中的端口映射):</host></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ls"><img src="../Images/f7a2ca48837253e02481e44a4f1e7d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/0*EfUNutt_OOax5EaA"/></div></figure><p id="bc05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当GitHub存储库中的应用程序源被更新时，我们可以使用一个GET请求(来自CURL或浏览器)到<host> :4505，用最新的应用程序定义刷新容器:</host></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lt"><img src="../Images/1016fec3aa5aef1e61f175e62627bcb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*1h9HAtKtk11K5vif"/></div></figure><p id="396d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自容器的日志表明执行了git pull并且没有返回新的源:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/b0e84be2f071002e03569dd9a1b90c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iMvnH8q3QNK-xNgl"/></div></div></figure><p id="4c33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为没有已更改的文件，所以在这种情况下，<em class="jq"> nodemon </em>不会重启应用程序。</p><p id="7b32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此时这个通用容器工作的一个要求是节点应用程序在其根目录中有一个package.json和一个scripts.start条目；nodemon希望该条目作为如何运行应用程序的指令。这个package.json与<em class="jq"> npm install </em>一起使用，为节点应用程序安装所需的库。</p><h1 id="0853" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="3c54" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">下图给出了本文所介绍内容的概述。如果您想运行一个节点应用程序，它的源代码可以在GitHub存储库中找到，那么您只需要一个Docker主机，以下是您的步骤:</p><ol class=""><li id="12fa" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb lu ji jj jk bi translated">拉Docker镜像:Docker pull lucasjellema/Node-run-live-reload:0.1(此镜像目前包含Node 8运行时、npm、nodemon、一个git客户端和reloader应用程序)<br/>或者:自己构建并标记容器。</li><li id="852e" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">运行容器映像，传递包含节点应用程序的repo的GitHub URL为节点应用程序和重新加载程序指定所需的端口映射(端口4500):docker run–name express-p 3011:3000-p 4500:4500-e GITHUB _ URL =<git hub="" repo="" url="">-d lucasjellema/Node-run-live-reload:0.1</git></li><li id="c929" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">当容器启动时，它将从GitHub克隆节点应用程序</li><li id="befa" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">使用<em class="jq"> npm install </em>，安装应用程序的依赖项</li><li id="73fe" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">使用<em class="jq"> nodemon </em>启动应用程序(并监控源代码，以便在发生变化时重启应用程序)</li><li id="f2f5" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">现在，可以在运行Docker容器的主机上访问该应用程序，按照docker run命令映射端口</li><li id="e608" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">通过对/reload端点的HTTP请求，容器中的reloader应用程序被指示</li><li id="7981" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">git从GitHub存储库中提取源代码，并运行npm install来获取任何更改或添加的依赖项</li><li id="8dad" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">如果更改了任何源，nodemon现在将自动重启节点应用程序</li><li id="af03" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lu ji jj jk bi translated">可以访问升级的节点应用程序</li></ol><p id="5bae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:或者，可以配置WebHook触发器。这使得在提交GitHub repo时自动触发应用程序重新加载功能成为可能。就像常规的CD管道一样，这意味着正在运行的节点应用程序可以自动升级。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/a7da9dc195aca448fd20165c9566c435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P2jLvrfd-Uf9KfhN"/></div></div></figure><h1 id="5b69" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">后续步骤</h1><p id="140b" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">我正在考虑使用这个通用容器映像的一些后续步骤——我欢迎您的拉取请求——包括:</p><ul class=""><li id="378c" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">允许通过容器上的环境变量(和/或通过调用重新加载应用程序上的端点)配置自动定期应用程序刷新，指示重新加载程序每X秒进行一次git拉取。</li><li id="cfc2" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">使用https://www.npmjs.com/package/simple-git的<a class="ae ko" href="https://www.npmjs.com/package/simple-git" rel="noopener ugc nofollow" target="_blank">而不是shelljs加本地Git客户端(这可以允许使用更轻的基础映像——比如用node-slim代替node)</a></li><li id="b878" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">强制重启节点应用程序—即使它根本没有更改</li><li id="eaf8" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">除了在应用程序的根目录下运行package.json中的scripts.start条目之外，还允许其他应用程序启动场景</li></ul><h1 id="f4c1" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">资源</h1><p id="3aa1" class="pw-post-body-paragraph ie if hh ig b ih ln ij ik il lo in io ip lp ir is it lq iv iw ix lr iz ja jb ha bi translated">包含本文所需资源的GitHub资源库—包括构建容器的docker文件:<a class="ae ko" href="https://github.com/lucasjellema/docker-node-run-live-reload" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/docker-node-run-live-reload</a></p><p id="2ec1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于我之前尝试从GitHub创建用于运行节点应用程序的通用Docker容器的文章:<a class="ae ko" href="https://technology.amis.nl/2017/05/21/running-node-js-applications-from-github-in-generic-docker-container/" rel="noopener ugc nofollow" target="_blank">https://technology . amis . nl/2017/05/21/running-Node-js-applications-from-GitHub-in-generic-Docker-container/</a></p><p id="4591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于nodemon的文章和文档:<a class="ae ko" rel="noopener" href="/lucjuggery/docker-in-development-with-nodemon-d500366e74df">https://medium . com/lucjuggery/docker-in-development-with-nodemon-d 500366 e 74 df</a>和<a class="ae ko" href="https://github.com/remy/nodemon#nodemon" rel="noopener ugc nofollow" target="_blank">https://github.com/remy/nodemon#nodemon</a></p><p id="1dab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">允许从节点应用程序执行shell命令的NPM模块shelljs:<a class="ae ko" href="https://www.npmjs.com/package/shelljs" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/shelljs</a></p><p id="62e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jq">原载于2018年9月22日</em><a class="ae ko" href="https://technology.amis.nl/2018/09/22/generic-docker-container-image-for-running-and-live-reloading-a-node-application-based-on-a-github-repo/" rel="noopener ugc nofollow" target="_blank"><em class="jq">technology . amis . nl</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>