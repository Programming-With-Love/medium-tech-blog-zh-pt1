<html>
<head>
<title>Enabling CORS in ASP.NET Web API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP.NET Web API中启用CORS</h1>
<blockquote>原文：<a href="https://medium.easyread.co/enabling-cors-in-asp-net-web-api-4be930f97a5c?source=collection_archive---------0-----------------------#2021-08-11">https://medium.easyread.co/enabling-cors-in-asp-net-web-api-4be930f97a5c?source=collection_archive---------0-----------------------#2021-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dd17" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在ASP.NET Web API中启用CORS的指南</h2></div><h1 id="4ffa" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">简介:-</h1><p id="b3c8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">ASP。NET是一个开发web应用程序的框架，它扩展了。NET平台的工具和库。ASP.NET的WebAPI是一种流行的技术。</p><p id="4645" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">每个人都试图使用AJAX请求或服务器端来访问服务。由于浏览器安全策略中的安全限制，您的web浏览器无法向另一个域中的服务器发出AJAX请求。这通常被称为“同源方案”</p><p id="f6f9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">换句话说，内置的浏览器保护可以防止一个域的网页对另一个域进行AJAX调用。当一个WebAPI被托管，而另一个来自不同域的应用程序试图通过AJAX请求访问它时，问题就出现了。在这种情况下，在WebAPI中启用跨来源资源共享(<a class="ae lv" href="https://www.interviewbit.com/web-api-interview-questions/#cors-in-web-api" rel="noopener ugc nofollow" target="_blank"> CORS </a>)至关重要。</p><p id="dc65" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">CORS是一种W3C标准，允许您绕过浏览器的同源策略，该策略限制从一个域访问属于另一个域的资源。使用适当的Web API包，您可以为您的Web API启用CORS。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/babedd38cea520e036611436330317b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A3jbwjE2OwyU277O5_UePg.png"/></div></div></figure><p id="ff4d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">方案、主机和端口号构成了请求的来源。如果两个请求具有相同的方案、主机和端口号，则认为它们来自同一个来源。如果所有这些都不相同，那么这些请求就被称为跨来源，这意味着它们不是来自同一个来源。</p><p id="501b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">web API可以帮助你创建一个基于AJAX的ASP.NET程序。web API框架使得构建可以在各种实体上运行的服务变得简单。因此，web API使得开发人员可以更容易地创建几乎可以在任何浏览器和计算机上运行的ASP.NET应用程序。Web APIs让您可以访问HTTP的所有特性，比如URIs、请求/响应头、内容格式化、缓存等等。</p><p id="26bc" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">因此，通过Web APIs使用RESTful web服务构建ASP.NET Web应用程序要比使用WCF(Windows Communication Foundation)rest服务简单得多，后者需要为不同的设备指定额外的配置设置。</p><h1 id="389a" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated"><em class="mi">在Web API中启用CORS的方法:- </em></h1><h2 id="3077" class="mj kd in bd ke mk ml dn ki mm mn dp km ld mo mp ko lh mq mr kq ll ms mt ks mu bi translated"><strong class="ak">使用JSONP:- </strong></h2><p id="fb66" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">JSONP是带填充的JSON的缩写。它有助于通过浏览器的同源策略实现跨域请求。它将一个JSON响应封装在一个JavaScript函数中，也就是回调函数)并作为脚本发送回浏览器。这允许您绕过同源策略，将JSON从外部服务器加载到网页上的JavaScript中。<br/> <strong class="kw io">例如:- </strong> <br/>让我们假设我们有下面的JSON:-</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="2131" class="mj kd in mw b gy na nb l nc nd">//JSON<br/>{<br/> ‘rollNo’ : ‘1’,<br/> ‘name’ : ‘Vaibhav’,<br/> ‘Maths’ : ‘100’,<br/> ‘Physics’ : ‘66’,<br/> ‘Chemistry’ : ‘97’,<br/> ‘Biology’ : ‘88’<br/>}</span></pre><p id="ba41" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">当服务器收到JSONP中的“callback”参数时，它以不同的方式包装结果，并像这样返回:-</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="613e" class="mj kd in mw b gy na nb l nc nd">//JSONP<br/>newStudent({<br/> ‘rollNo’ : ‘1’,<br/> ‘name’ : ‘Vaibhav’,<br/> ‘Maths’ : ‘100’,<br/> ‘Physics’ : ‘66’,<br/> ‘Chemistry’ : ‘97’,<br/> ‘Biology’ : ‘88’<br/>});</span></pre><p id="22a3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我们必须首先在WebAPI中允许CORS，然后从另一个程序使用AJAX请求调用服务。要允许CORS，我们需要从NuGet下载并安装JSONP包。我们需要安装软件包<strong class="kw io"> WebApiContrib。Jsonp </strong>为ASP.NET Web API提供了一个JSONP MediaTypeFormatter实现。</p><p id="8ec9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">安装Jsonp包后，将以下代码添加到App_StartWebApiConfig.cs文件中:-</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="7751" class="mj kd in mw b gy na nb l nc nd">var FormatterJSONP = new JsonpMediaTypeFormatter(config.Formatters.JsonFormatter); <br/>config.Formatters.Add(FormatterJSONP);</span></pre><p id="c470" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">它创建一个JsonpMediaTypeFormatter实例，并将其添加到config formatters对象中。<br/>现在CORS已经在服务器中被激活，另一个应用程序必须发送AJAX请求到一个不属于我们的域。在下面的代码片段中，数据类型被设置为jsonp，这与跨域请求兼容。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="a41a" class="mj kd in mw b gy na nb l nc nd">&lt;script src=”<a class="ae lv" href="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js" rel="noopener ugc nofollow" target="_blank">http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js</a>"&gt;&lt;/script&gt; <br/>&lt;script&gt; <br/> $(document).ready(function () { <br/> $.ajax({ <br/> type: ‘POST’, <br/> url: ‘<a class="ae lv" href="http://localhost:3000/api/Recipes'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/Recipes’</a>, <br/> cache: ‘true’, <br/> dataType: ‘jsonp’, <br/> success: function (json) { <br/> var pageContent = “”; <br/> $.each(json, function (key, item) { <br/> pageContent = pageContent + “&lt;tr&gt;&lt;td&gt;” + item.Number + “&lt;/td&gt;&lt;td&gt;” + item.Name + “&lt;/td&gt;&lt;td&gt;” + item.Recipe + “&lt;/td&gt;&lt;/tr&gt;”; <br/> }); <br/> $(‘#Recipes’).append(pageContent); <br/> }, <br/> error: function (parsedJSON, Status, thrownError) { <br/> <br/> $(‘body’).append( <br/> “Status of parsedJson : “ + parsedJSON.status + ‘&lt;/br&gt;’ + <br/> “errorStatus: “ + Status + ‘&lt;/br&gt;’ + <br/> “thrownError: “ + thrownError); <br/> <br/> } <br/> }); <br/> }); <br/>&lt;/script&gt;</span></pre><p id="55f6" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">使用JSONP的缺点:- </strong></p><ul class=""><li id="2755" class="ne nf in kw b kx lq la lr ld ng lh nh ll ni lp nj nk nl nm bi translated">这涉及到很多安全问题，包括我们的cookies被盗。这是一个非常令人关注的问题。</li><li id="6595" class="ne nf in kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">旧浏览器不支持JSONP。因此，它并不兼容所有的浏览器。</li></ul><h2 id="5613" class="mj kd in bd ke mk ml dn ki mm mn dp km ld mo mp ko lh mq mr kq ll ms mt ks mu bi translated">使用微软。WebApi.Cors:-</h2><p id="a5e9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，我们需要安装微软。NuGet包中的AspNet.WebApi.Cors包。为此，进入工具菜单= &gt;库包管理器= &gt;包管理器控制台，运行下面的命令:-<br/><strong class="kw io">Install-Package Microsoft。之后，我们将使用EnableCorsAttribute类来注册/启用Cors，它有四个参数，其中最后一个是可选的。这四个参数如下</strong></p><ul class=""><li id="d2bb" class="ne nf in kw b kx lq la lr ld ng lh nh ll ni lp nj nk nl nm bi translated"><strong class="kw io">来源:- </strong> <br/>这里，我们必须指定接受请求的来源或域。如果您有几个域，可以用逗号分隔它们。此外，如果您希望批准任何域请求，请使用“*”作为通配符。</li><li id="83f4" class="ne nf in kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><strong class="kw io">请求头:- </strong> <br/>启用哪个请求头由请求头参数指定。将该值设置为“*”以启用任何标题。</li><li id="852b" class="ne nf in kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><strong class="kw io"> HTTP方法:-</strong><br/>Methods参数指定可以访问资源的HTTP方法。当使用多个HTTP方法时，如“get，put，post”，使用逗号分隔的值。使用通配符值“*”来启用所有HTTP方法。</li><li id="4dfb" class="ne nf in kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><strong class="kw io"> exposedHeaders:- </strong> <br/>默认情况下，浏览器不会向应用程序显示所有的响应头。Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma是默认情况下可访问的响应头。</li></ul><p id="ccea" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">您必须使用exposedHeaders在浏览器中显示其他标题。您可以使用下面的代码片段构建自定义标题:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="fe56" class="mj kd in mw b gy na nb l nc nd">[EnableCors(origins: “*”, headers: “*”, methods: “*”, exposedHeaders: “SampleHeader”)] <br/>public class SampleController : ApiController <br/>{ <br/>}</span></pre><p id="2fd8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">CORS对Web API的支持可配置为三个级别:-</p><p id="7b56" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">全局级别:- </strong> <br/>我们将允许全局级别的CORS，这意味着它将应用于所有的控制者及其操作。在App Start/WebApiConfig.cs文件中，添加以下代码片段。它使用传入的以下参数生成EnableCorsAttribute类的实例:-<br/><strong class="kw io">"</strong><a class="ae lv" href="http://localhost:3000/SampleApp/Form1.aspx" rel="noopener ugc nofollow" target="_blank"><strong class="kw io">http://localhost:3000/sample app/form 1 . aspx</strong></a><strong class="kw io">"</strong><br/>对于此域，服务器已启用CORS。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="9550" class="mj kd in mw b gy na nb l nc nd">public static void Register(HttpConfiguration config) <br/>{ <br/> EnableCorsAttribute cors = new EnableCorsAttribute(“<a class="ae lv" href="http://localhost:3000/SampleApp/Form1.aspx" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/SampleApp/Form1.aspx</a>", “*”, “GET,POST”); <br/> config.EnableCors(cors); <br/>}</span></pre><p id="5700" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">星号表示它支持所有请求头。<br/>“GET，POST”:这意味着它只确认GET和POST http动词。如果服务器收到除“GET，POST”之外的请求，它会抛出一个异常。</p><p id="786f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">控制器级别:- </strong> <br/>我们可以在控制器级别允许CORS，这意味着其中的所有操作都准备好为跨域请求服务。将EnableCors属性添加到控制器的顶部，并传递适当的参数(如上所述)。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="0541" class="mj kd in mw b gy na nb l nc nd"><br/>[EnableCors(origins: “<a class="ae lv" href="http://localhost:3000/SampleApp/Form1.aspx" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/SampleApp/Form1.aspx</a>", headers: “*”, methods: “*”)] <br/>public class SampleController : ApiController <br/>{ <br/> <br/>}</span></pre><p id="a2a3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">动作级别:- </strong> <br/>与控制器级别类似，我们可以在动作级别允许CORS，这意味着CORS为准备好服务跨域请求的特定动作而激活。我们必须将EnableCors属性添加到操作的顶部，并传递适当的参数(如上所述)。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="144c" class="mj kd in mw b gy na nb l nc nd">public class SampleController : ApiController <br/>{ <br/> [EnableCors(origins: “<a class="ae lv" href="http://localhost:3000/SampleApp/Form1.aspx" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/SampleApp/Form1.aspx</a>", headers: “*”, methods: “*”)] <br/> <br/> public IEnumerable&lt;string&gt; Get() <br/> { <br/> return new string[] { “string1”, “string2” }; <br/> } <br/>}</span></pre><p id="0e56" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">在WebAPI 1.0中启用CORS:-</strong><br/>如果您正在使用Web API 1.0，您需要修改Global.asax文件以包含以下代码。在本例中，我们使用应用程序BeginRequest()事件来允许CORS，它检查源名称，然后向响应对象添加头。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="5392" class="mj kd in mw b gy na nb l nc nd">protected void Application_BeginRequest() <br/>{ <br/> string[] origin_Allowed = new string[] { “<a class="ae lv" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank">http://localhost:3001</a>", “<a class="ae lv" href="http://localhost:3013" rel="noopener ugc nofollow" target="_blank">http://localhost:3013</a>" };<br/> var origin = HttpContext.Current.Request.Headers[“Origin”]; <br/> if (origin != null &amp;&amp; origin_Allowed.Contains(origin)) <br/> { <br/> HttpContext.Current.Response.AddHeader(“Access-Control-Allow-Origin”, origin); <br/> HttpContext.Current.Response.AddHeader(“Access-Control-Allow-Methods”, “GET,POST”); <br/> } <br/>}</span></pre><p id="5dac" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">从网络上启用CORS。项目的配置文件:- </p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="ef6d" class="mj kd in mw b gy na nb l nc nd">&lt;system.webServer&gt;<br/> &lt;handlers&gt;<br/> &lt;remove name=”ExtensionlessUrlHandler-Integrated-4.0" /&gt;<br/> &lt;remove name=”OPTIONSVerbHandler” /&gt;<br/> &lt;remove name=”TRACEVerbHandler” /&gt;<br/> &lt;add name=”ExtensionlessUrlHandler-Integrated-4.0" path=”*.” verb=”*” type=”System.Web.Handlers.TransferRequestHandler” preCondition=”integratedMode,runtimeVersionv4.0" /&gt;<br/> &lt;/handlers&gt;<br/>//Add this part of code in the file <br/> &lt;httpProtocol&gt;<br/> &lt;customHeaders&gt;<br/> &lt;add name=”Access-Control-Allow-Origin” value=”*” /&gt;<br/> &lt;add name=”Access-Control-Allow-Credentials” value=”true”/&gt;<br/> &lt;add name=”Access-Control-Allow-Headers” value=”Content-Type” /&gt;<br/> &lt;add name=”Access-Control-Allow-Methods” value=”GET, POST, PUT, DELETE, OPTIONS” /&gt;<br/> &lt;/customHeaders&gt;<br/> &lt;/httpProtocol&gt;<br/> &lt;! — End of new addition →<br/> &lt;/system.webServer&gt;</span></pre><p id="9ad0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这将同时为项目中的所有控制器启用CORS。</p><p id="433b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">在跨来源请求中传递凭据:- </strong></p><p id="c04f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在CORS请求中，凭据必须以不同的方式处理。当发出跨来源请求时，默认情况下，浏览器不会提交任何凭据。Cookies和HTTP认证系统就是凭证的例子。客户端必须将XMLHttpRequest.withCredentials设置为true，才能通过跨来源请求提交凭据。<br/>直接使用XMLHttpRequest:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="6261" class="mj kd in mw b gy na nb l nc nd">//C#<br/>var temp = new XMLHttpRequest();<br/>temp.open(‘get’, ‘<a class="ae lv" href="http://localhost:3001/api/sample'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/api/sample'</a>);<br/>temp.withCredentials = true;</span></pre></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><pre class="mv mw mx my aw mz bi"><span id="8777" class="mj kd in mw b gy nz oa ob oc od nb l nc nd">//jQUERY<br/>$.ajax({<br/> type: ‘get’,<br/> url: ‘<a class="ae lv" href="http://localhost:3001/api/sample'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/api/sample'</a>,<br/> xhrFields: {<br/> withCredentials: true<br/> }</span></pre><p id="9332" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">此外，凭据必须由服务器启用。将[EnableCors]特性的SupportsCredentials属性设置为true，以允许Web API中的跨来源凭据:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="9a88" class="mj kd in mw b gy na nb l nc nd">//C#<br/>[EnableCors(origins: “<a class="ae lv" href="http://localhost:3001/api/sample" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/api/sample</a>", headers: “*”, <br/> methods: “*”, SupportsCredentials = true)]</span></pre><p id="cc40" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果此属性有效，HTTP响应中将包含Access-Control-Allow-Credentials标头。该头通知浏览器服务器接受跨来源凭据。如果响应不包含有效的Access-Control-Allow-Credentials头，浏览器不会向应用程序公开响应，AJAX请求将失败。<br/>应避免将SupportsCredentials设置为true，因为这意味着不同域中的网站会在用户不知情的情况下代表他们将登录用户的凭据发送到您的Web API。根据CORS规范，如果SupportsCredentials为true，则将origins设置为“*”也是无效的。</p><p id="362d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">自定义CORS策略提供者:-</strong><br/>ICorsPolicyProvider接口由[EnableCors]标记实现。创建一个从属性派生并实现ICorsPolicyProvider的类，以拥有您自己的实现。<br/>比如:-<br/>【attribute usage(attribute targets。方法|属性目标。Class，AllowMultiple = false)]</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="4e7b" class="mj kd in mw b gy na nb l nc nd">//C#<br/>public class CustomCORSPolicy : Attribute, ICorsPolicyProvider <br/>{<br/> private CorsPolicy myPolicy;public CustomCORSPolicy()<br/> {<br/> // Creating a CORS policy.<br/> myPolicy = new CorsPolicy<br/> {<br/> AllowAnyMethod = true,<br/> AllowAnyHeader = true<br/> };<br/>// Adding allowed origins.<br/> myPolicy.Origins.Add(“<a class="ae lv" href="http://localhost:3001/" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/</a>");<br/> myPolicy.Origins.Add(“<a class="ae lv" href="http://localhost:3013/" rel="noopener ugc nofollow" target="_blank">http://localhost:3013/</a>");<br/> }<br/>public Task&lt;CorsPolicy&gt; GetCorsPolicyAsync(HttpRequestMessage request)<br/> {<br/> return Task.FromResult(myPolicy);<br/> }<br/>}</span></pre><p id="0e7d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，您可以在放置[EnableCors]的任何地方使用该属性。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="3275" class="mj kd in mw b gy na nb l nc nd">[CustomCORSPolicy]<br/>public class SampleController : ApiController<br/>{<br/> …</span></pre><p id="d199" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">您可以注册一个ICorsPolicyProviderFactory对象来创建ICorsPolicyProvider对象，而不是使用属性。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="7d4e" class="mj kd in mw b gy na nb l nc nd">//C#<br/>public class CustomCorsPolicyFactory : ICorsPolicyProviderFactory<br/>{<br/> ICorsPolicyProvider providerCORS = new MyCorsPolicyProvider();<br/>public ICorsPolicyProvider GETCorsPolicyProvider(HttpRequestMessage request)<br/> {<br/> return providerCORS;<br/> }<br/>}</span></pre><p id="ae3a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">启动时调用SetCorsPolicyProviderFactory扩展方法来设置ICorsPolicyProviderFactory:</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="07e8" class="mj kd in mw b gy na nb l nc nd">public static class WebApiConfig<br/>{<br/> public static void Register(HttpConfiguration configuration)<br/> {<br/> configuration.SetCorsPolicyProviderFactory(new CustomCorsPolicyFactory());<br/> configuration.EnableCors();</span><span id="cd4c" class="mj kd in mw b gy oe nb l nc nd">// …<br/> }<br/>}</span></pre><h2 id="7420" class="mj kd in bd ke mk ml dn ki mm mn dp km ld mo mp ko lh mq mr kq ll ms mt ks mu bi translated">飞行前请求:-</h2><p id="f3e7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">某些类型的请求，比如DELETE或PUT，必须更进一步，在继续之前从服务器获得许可。浏览器使用预检请求来请求权限。</p><p id="7e22" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">浏览器在实际请求之前发送一个微小的请求，称为预检请求。它包括诸如使用的HTTP方法以及是否存在任何自定义HTTP头之类的详细信息。预检允许服务器在发送之前看到实际请求的外观。然后，服务器将告诉浏览器是否提交请求，或者是否向客户端返回一个错误。</p><p id="2b09" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">创建预检概念是为了在不破坏依赖于浏览器同源策略的现有服务器的情况下进行跨源请求。如果预检到达启用CORS的服务器，服务器将识别请求并做出适当的反应。</p><p id="5219" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">然而，如果预检到达不知道或不关心CORS的服务器，服务器将不会提交适当的预检响应，并且实际的请求将永远不会被提交。不受怀疑的服务器受到保护，不会处理它们不喜欢的跨来源请求。</p><p id="f882" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">预检请求有三个特征:它使用HTTP选项方法，它包括原始请求报头，并且它包括访问控制请求方法报头。</p><h2 id="6043" class="mj kd in bd ke mk ml dn ki mm mn dp km ld mo mp ko lh mq mr kq ll ms mt ks mu bi translated"><strong class="ak">飞行前请求错误:- </strong></h2><p id="334d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">即使在Web API中正确配置了所有内容，当从脚本发出预检请求时，预检请求通常会返回HTTP错误代码405。这可以通过对web.config和Global.asax文件进行一些更改来解决。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="f215" class="mj kd in mw b gy na nb l nc nd">//Web.config file<br/>&lt;system.webServer&gt;<br/> &lt;handlers&gt;<br/> &lt;remove name=”ExtensionlessUrlHandler-Integrated-4.0" /&gt;<br/> &lt;remove name=”OPTIONSVerbHandler” /&gt;<br/> &lt;remove name=”TRACEVerbHandler” /&gt;<br/> &lt;add name=”ExtensionlessUrlHandler-Integrated-4.0" path=”*.” verb=”*” type=”System.Web.Handlers.TransferRequestHandler” preCondition=”integratedMode,runtimeVersionv4.0" /&gt;<br/> &lt;! — Add this line of code → <br/> &lt;add name=”OPTIONSVerbHandler” path=”*” verb=”OPTIONS” modules=”ProtocolSupportModule” requireAccess=”None” responseBufferLimit=”4194304" /&gt; <br/> &lt;! — End of new addition → <br/> &lt;/handlers&gt;<br/> &lt;httpProtocol&gt;<br/> &lt;customHeaders&gt;<br/> &lt;add name=”Access-Control-Allow-Origin” value=”*” /&gt;<br/> &lt;add name=”Access-Control-Allow-Credentials” value=”true”/&gt;<br/> &lt;add name=”Access-Control-Allow-Headers” value=”Content-Type” /&gt;<br/> &lt;add name=”Access-Control-Allow-Methods” value=”GET, POST, PUT, DELETE, OPTIONS” /&gt;<br/> &lt;/customHeaders&gt;<br/> &lt;/httpProtocol&gt;<br/> &lt;/system.webServer&gt;</span></pre></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><pre class="mv mw mx my aw mz bi"><span id="6697" class="mj kd in mw b gy nz oa ob oc od nb l nc nd">// Global.asax<br/>public class WebApiApplication : System.Web.HttpApplication<br/> {<br/> protected void Application_Start()<br/> {<br/> AreaRegistration.RegisterAllAreas();<br/> GlobalConfiguration.Configure(WebApiConfig.Register);<br/> FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);<br/> RouteConfig.RegisterRoutes(RouteTable.Routes);<br/> BundleConfig.RegisterBundles(BundleTable.Bundles);<br/> }<br/>&lt;! — Added code →<br/> protected void Application_BeginRequest(object Sender, EventArgs eventE)<br/> {<br/> if (HttpContext.Current.Request.HttpMethod == “OPTIONS”)<br/> {<br/> HttpContext.Current.Response.Flush();<br/> }<br/> }<br/> &lt;! — End of added code →<br/> }</span></pre><h2 id="014e" class="mj kd in bd ke mk ml dn ki mm mn dp km ld mo mp ko lh mq mr kq ll ms mt ks mu bi translated">禁用CORS:-</h2><p id="560f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果在全局层或控制器层启用了CORS，则所有活动都将启用CORS。但是，如果出于安全原因想要禁用CORS一些行为，disable CORS属性就很方便了。它禁用CORS，这意味着其他域将无法调用该操作。</p><pre class="lx ly lz ma gt mv mw mx my aw mz bi"><span id="916d" class="mj kd in mw b gy na nb l nc nd">[DisableCors()] <br/>public string Get(int id) <br/>{ <br/> return “string”; <br/>}</span></pre><p id="35ec" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">CORS是一个服务器端应用程序，与浏览器协同工作。因此，也需要浏览器支持CORS。</p><h1 id="763c" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">结论:-</h1><p id="dcf5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Web API是一个用于ASP.NET开发的可扩展平台，它从服务器为我们提供信息。它完全建立在HTTP协议之上，以RESTful方式描述、公开和使用都很简单。</p><p id="4ebe" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在the.NET框架上，它被认为是创建RESTful应用程序的理想论坛。CORS(跨源资源共享)是一种协议，允许用户在浏览器中从一个网站向另一个网站发出请求，这通常被另一种称为SOP(同源策略)的法规所禁止。</p><p id="cfb0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">它允许客户端或浏览器向服务器发送安全的跨源请求和数据。来自不同背景的请求被称为跨来源请求。对于JavaScript，CORS只是解决了同源约束。可以使用适当的web API工具包或OWIN中间件来允许web API的CORS。</p><p id="346f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在本文中，我们看到了支持CORS的不同方式。我们提出了两种允许CORS的方法:JSONP和Microsoft Cors kit。出于保护目的，微软Cors的浏览器不兼容性战胜了JSONP。</p></div></div>    
</body>
</html>