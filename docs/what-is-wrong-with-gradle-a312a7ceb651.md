# 格雷迪怎么了？

> 原文：<https://medium.com/google-developer-experts/what-is-wrong-with-gradle-a312a7ceb651?source=collection_archive---------1----------------------->

![](img/7f8096bf0fc4a07e74783f5a0223cba7.png)

Photo by [Ana Frantz](https://unsplash.com/@anafrantz?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

首先，不要误会。我爱格雷德尔，我爱科特林，我爱他们在一起。在我看来，Gradle 是有史以来最好的构建系统，我一直鼓励它不仅用于 Java 和 Kotlin，也用于其他语言。

尽管如此，这个系统现在已经足够大了，并开始受到设计决策的影响，而当时它要小得多。我要谈论的问题并不新鲜，但随着 gradle.kts 语法的出现，这个问题变得很明显。

# 插件是如何工作的？

Gradle 的主要特点是模块化。如果有合适的插件，你可以用 Gradle 做任何事情。人们可以很容易地从存储库中取出插件或者就地编写它。这其实很容易。

与 Make 等系统不同，Gradle 有一个项目模型——对项目、依赖项和一些元数据的声明性描述。Gradle 利用了约定优先于配置的原则，即如果没有配置，项目模型假定合理的默认值。此外，Gradle 有任务——基于项目模型执行的操作。每个任务也有许多类型化的参数。任务也可以依赖于其他任务(在当前项目和其他项目中)，从而产生任务图。必须注意到，到目前为止，该系统是完全声明性的。任务本身包含命令性代码(这也是 Gradle 的主要优势之一)，但整个配置是在配置阶段以正式模型编写的。

现在插件来了。

插件接口非常简单(让我们看看官方文档):

```
class GreetingPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        project.task("hello") {
            doLast {
                println("Hello from the GreetingPlugin")
            }
        }
    }
}

// Apply the plugin
apply<GreetingPlugin>()
```

作者显然受到了著名的[接吻原则](https://en.wikipedia.org/wiki/KISS_principle)的启发。该类只有一个方法，将更改应用到项目模型。然后你需要做的就是实例化插件类(Gradle 在幕后完成)并应用它。很简单。很漂亮。不是吗。有人发现问题了吗？

实际上是几个。

# 问题 1:不再是声明性的

任何从事数据系统工作的人都应该马上发现这个问题。有些东西会改变配置的状态，并且这种改变是有时间的。这很糟糕。以前，我们的系统中没有时间，所以没有变化的顺序。任务图不算，因为它是正式的，任务是在配置完成后处理的。插件就不是这样了。

应用插件的顺序会影响结果。而且一旦你引入了时间和状态，你就不能把它收回来了。其中一个插件可以依赖其他插件提供的统计数据。模块(在 Gradle 中它们被称为项目)使事情变得更加复杂，因为不同的插件被应用于不同的项目，并且一个插件可以影响不同项目中的任务。模块插件的解析顺序是一个灰色地带，没有很多人理解它。

另一个问题是，Gradle 模型中的所有参数在默认情况下都是渴望的。这意味着它们发生在你使用插件的时候，并且不能被订购。Gradle 团队正在引入[新 API](https://docs.gradle.org/current/userguide/lazy_configuration.html)以在最新版本中覆盖这一点，但它看起来很丑。像这样:

在这里，我们将外部 lambda 中的所有内容作为回调应用到具有适当 ID 的插件上。扩展是由插件创建的配置对象，所以它们“从一开始”就不存在。只有在应用了特定的插件后，这些问题才能得到解决。因此需要首先检查相应的插件是否被应用(或者通过延迟初始化对其应用作出反应)。

在上面的例子中，我使用了一个稍微复杂一点的方案。比起我自己应用的插件，我更喜欢已经应用的插件。这样做是为了提供一个定制版本的 Kotlin 插件，但是效果并不好。

这种惰性配置解决了插件应用程序顺序的一些问题，但不是所有问题。插件只是不能配置其他插件。每个插件都对项目模型进行了添加，很少对现有模型进行一些更改。但是它们没有相互通信的手段。典型案例就是 K *otlin* 和 *java* 插件的干扰。Kotlin 依赖于来自 java 插件的配置(例如源集)，但是一些插件对 Kotlin 一无所知，并试图使用默认的 Java 配置(例如默认的`main`源集)。在 Kotlin-multiplatform 中，甚至有一个特殊的`withJava()`标记，使得 build 以 java 插件喜欢的方式公开源代码集(仍然有一个问题)。

# 问题 2:禁止调谐

上面的插件接口没有任何参数。既不是插件类本身，也不是应用方法。事实上，Gradle 开发者认为配置可以通过任务参数来完成。插件是最基本的，以便能够通过反射使用反射进行类实例化。

插件可以在配置阶段创建一个用户可用的“扩展”对象。和任务可以依赖于这个扩展中的信息。但是扩展不能控制哪些任务被创建以及它们如何相互依赖。有一种广泛使用的方法，将项目模型作为参数传递给扩展，就像这里的[所做的那样](https://github.com/mipt-npm/gradle-tools/blob/820664a74b6f4053e98d6f84625f9684130c17a6/src/main/kotlin/ru/mipt/npm/gradle/KScienceExtension.kt#L46)。它允许从用户配置中动态地影响项目模型，但是它对属性变更的顺序造成了更多的混乱。

一方面，这似乎是一个合理的假设。另一方面，不，不起作用。(再次)以科特林为例。Kotlin 编译器嵌入在 Kotlin 插件中。所以如果你想使用不同版本的编译器，你需要一个不同版本的插件。但是很少发生，你需要修改编译器版本而不改变插件版本。例如，出于测试目的，您需要使用一个定制的编译器或者只是一个不同版本的编译器。现在，当编译器版本改变时，需要重写整个配置。

API 的另一个问题是一个插件不能依赖另一个插件。当然，我们可以这样做:

但是调优呢？两个不同的插件依赖于一个插件并对配置应用不同的更改会发生什么？

# 问题 3:我的类路径通向哪里？

需要记住的是，Gradle build 实际上是一个常规的 JVM 程序。这是最大的好处，同时也是最大的问题之一。每个 JVM 程序都有一个类路径。所有的类都应该加载在一个树状结构中，并且不可能(通过简单的方法)拥有同一个类的两个不同版本。JVM 允许在飞行中加载类，这对于面向插件的系统来说相当方便，但是一般情况下不可能“卸载”类(实际上你可以这样做，但这是一个很长的讨论)。同时加载两个版本是绝对不可能的(否则会带来很多混乱)。

现在，我们记住插件没有参数。所以实现插件不同行为的唯一方法是制作不同版本的插件。这里我们有一个关于类路径的问题。如果一个模块需要一个插件版本，而另一个模块需要另一个插件版本，我们不能把它们放在同一个项目中。

此外，构建系统类路径必须在正式配置阶段之前解决。这意味着我们有三个实际阶段:

*   构建脚本配置
*   项目配置
*   任务评估

因此有三个不同的类路径——一个用于插件，一个用于应用插件后的项目模型，一个用于实际构建。很难理解哪个版本去了哪里。例如，Gradle 有一个嵌入式 Kotlin 编译器，但它的版本通常与项目中使用的版本不同。您可以在插件应用程序块中显式设置版本，但这并不总是简单的，因为如果插件工件已经在构建类路径中(例如，另一个插件需要它)，它将会失败。所以我们有两个不同的插件依赖层——类路径依赖和应用依赖。

您可能注意到脚本的某些部分，如`buildscript`块或`plugins`似乎与构建脚本的其余部分不在同一个“空间”中。事实上，这些块在不同的“时间”被评估。

![](img/689c1f73ea1368c99ee7d8ad1fd3294b.png)

Plugin management block in Gradle source code

上面的代码片段显示该块甚至没有被求值。这些块被 Gradle 编译器捕获，并在其他代码建立类路径之前被解释。这就给我们带来了另一个问题。

# 问题 4:编译器黑客

上面列出了其中一个例子。另一个更明显的例子是主`build.gradle.kts`文件中的`plugin`块。它以同样的方式工作。它在构建脚本之前执行，所以它不能访问脚本的主体。

在这里，Kotlin 脚本发挥了它的作用。如果您不知道，Gradle 使用一种分阶段编译来提供 Kotlin 自动补全。它接受加载的插件，然后创建一组隐式导入到构建脚本中的合成扩展。一方面，它为 gradle.kts 用户提供了无缝的自动完成和静态访问体验(这真的很好。另一方面，为了让这个东西工作，你必须事先了解插件。如果你想在同一个文件中声明插件，你需要魔法。魔法本身并不坏，但在编程中，魔法通常会产生不一致。不一致是不好的。

例如，人们通常希望在`plugins`块和依赖块中都使用一个版本号。但这是不可能的。插件阻塞生活在自己的“时间泡”中，可以访问外部代码。因此，我们编写了非常合理的 Kotlin/Groovy 代码，但它并没有像预期的那样工作。

# 解决方案？

开始的时候，我说过，我很喜欢格雷尔。尽管有很多缺点。不过，这些问题必须得到解决，该工具才能继续发展。或者会被更一致的东西取代。

我认为应该做几件事来解决插件问题:

*   系统应该正式引入一个额外的零构建阶段——构建管理阶段(在配置和执行阶段之前)。这个阶段必须单独配置，不能放在`build.gradle.kts`里面。也许应该在`settings.gradle.kts`中完成，也许是另一种方式，但不是作为构建文件中的一个 hack。在科特林，这可以通过`@file:`注释来完成。但是也许有其他更好的方法。插件版本必须在构建文件之外声明。在 Gradle 中通过[版本目录](https://docs.gradle.org/current/userguide/platforms.html)有这样的努力，但是到目前为止让它工作还很棘手(见[这里](https://github.com/mipt-npm/visionforge/blob/dev/settings.gradle.kts)举例)主要是因为问题 3 和 4。还有额外的编译器技巧(现在在`settings.gradle.kts`中)和类路径加载任务。
*   应该会有一种新型的插件(超级插件？特色？)，它有一个参数化工厂，可以依赖于其他工厂。那些超级插件应该可以在没有应用的情况下(在应用之前)声明配置扩展。应用程序本身应该在副作用最小的情况下完成。这样做将允许为插件设置明确的插件依赖性和参数。此外，在插件依赖性解析期间检测参数冲突。
*   我认为应该有某种分层配置的机制(类似于在[https://github.com/mipt-npm/dataforge-core](https://github.com/mipt-npm/dataforge-core)中是如何完成的，参见[文章](https://www.researchgate.net/publication/342770054_Declarative_analysis_in_Troitsk_nu-mass_experiment)中的解释)。这将允许避免来自不同插件的冲突配置改变。

所有这些事情都不需要创建一个全新的系统，它们可以在现有项目模型的基础上在 Gradle 中完成。正在朝着这个方向采取一些步骤。但是大多数解决的是症状(配置顺序、版本目录等)，而不是问题本身——插件管理模型。所以我认为应该努力设计这个东西应该如何工作，然后尝试将它的一部分放入系统中，与现有的功能并行，而不是试图取代它们。设计这些变化并测试它们与现有系统的兼容性是一项巨大的工作。但是应该这样做。无论是在 Gradle 还是在它之后的新系统中。

我要感谢 [Vladimir Sitnikov](https://medium.com/u/eb977cc0e31?source=post_page-----a312a7ceb651--------------------------------) 阅读这篇文章并留下许多评论。我们都喜欢格雷德尔，但在某些情况下，我们的意见有很大的不同，所以我并不同意所有的言论。尽管如此，这些评论使文章更好。