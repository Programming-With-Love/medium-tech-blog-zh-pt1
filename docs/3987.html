<html>
<head>
<title>Facade Design Pattern In Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的外观设计模式</h1>
<blockquote>原文：<a href="https://medium.com/globant/facade-design-pattern-in-android-71ed37551087?source=collection_archive---------0-----------------------#2022-09-21">https://medium.com/globant/facade-design-pattern-in-android-71ed37551087?source=collection_archive---------0-----------------------#2022-09-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7207c4336667570cd206fe706f50e2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDuK9HJoCCZNq3_wIEyifA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image Credit <a class="ae it" href="https://unsplash.com/s/photos/waiter" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c7b8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你好，神奇而热情的程序员。</p><p id="01c0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在日常的编程生活中，您可能遇到过在项目级别同时使用多个库或多个组件，并试图让它们一起工作的情况。但是我们中的一些人可能在实现<strong class="iw hi">抽象</strong>的时候遇到了一些问题，这有助于<strong class="iw hi">降低复杂性。</strong>所以<strong class="iw hi">T5】为了避免<strong class="iw hi">复杂性</strong>或者<strong class="iw hi">复杂的逻辑我们可以使用facade设计模式。</strong></strong></p><p id="b17b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">立面设计模式</strong>是<strong class="iw hi">结构设计模式</strong>的一种。这种设计模式主要关注更容易地重新安排对象的结构。</p><p id="d58b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面我们试着对门面设计模式<strong class="iw hi">做一个简单的简要说明。</strong></p><p id="5058" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="js">什么是</em> </strong> <em class="js"> </em> <strong class="iw hi"> <em class="js">立面设计图案？</em>T25】</strong></p><ul class=""><li id="93fa" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">门面就是面具的意思。它隐藏了客户端类的任何对象的复杂实现。</li><li id="afe4" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">外观是为更复杂的逻辑或功能提供简化接口的对象。这意味着它提供了更高级别的接口，使得一组其他接口更容易使用。</li></ul><p id="0870" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"><em class="js"/></strong><em class="js"/><strong class="iw hi"><em class="js"/></strong><em class="js"/><strong class="iw hi"><em class="js">立面设计模式的用例是什么？</em> </strong></p><ul class=""><li id="ae5a" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">当有一个<strong class="iw hi">复杂系统</strong>需要更容易地暴露给客户时。</li><li id="6466" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">将应用程序代码与库代码分离。</li><li id="b4a1" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">在新的应用程序中重用遗留代码。</li></ul><p id="6dbf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="js">立面设计模式有什么优势？</em>T49】</strong></p><ul class=""><li id="2d43" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">这种模式避免或让用户远离子系统组件的复杂性。</li><li id="a9e4" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">我们可以实现子系统和它们的用户之间的松散耦合。</li></ul><p id="dfb9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="js">代码片段及示例</em> </strong></p><p id="e864" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们举一个餐馆的简单例子。顾客只是简单的点菜单上的菜，顾客并不想知道谁来接单，谁来做饭，谁来洗碗。顾客只是想点餐并用餐。因此，菜单作为一个门面，使顾客更容易避免来自厨房甚至来自服务员的复杂性。</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kh"><img src="../Images/f4b555dcaa4e75dd85bcffeb6f0999aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-KI3CejGcq3EQBAEhLe6w.png"/></div></div></figure><ol class=""><li id="c852" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr km jz ka kb bi translated">现在你已经知道外观是做什么的了，它将为复杂的子系统提供简单的接口逻辑。所以让我们有两个界面服务员和厨房。</li></ol><pre class="ki kj kk kl fd kn ko kp kq aw kr bi"><span id="0c61" class="ks kt hh ko b fi ku kv l kw kx">interface Waiter {     <br/>     fun takeOrder()     <br/>     fun sendOrderToKitchen()     <br/>     fun serveFood() <br/>}</span><span id="9603" class="ks kt hh ko b fi ky kv l kw kx">interface Kitchen {    <br/>    fun prepareFood()      <br/>    fun callWaiter()      <br/>    fun washesDishes()  <br/>}</span></pre><p id="3694" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.让我们为这两个接口创建一个实现类。</p><pre class="ki kj kk kl fd kn ko kp kq aw kr bi"><span id="be6f" class="ks kt hh ko b fi ku kv l kw kx">class WaiterImpl : Waiter {    <br/>     fun takeOrder() {       <br/>         Logger.d("Taking order from customer")    <br/>     }    <br/>     fun sendOrderToKitchen() {      <br/>         Logger.d("Sending order to kitchen")    <br/>     }    <br/>     fun serveFood() {       <br/>         Logger.d("Serving food to customer")    <br/>     }<br/>}</span><span id="9919" class="ks kt hh ko b fi ky kv l kw kx">class KitchenImpl : Kitchen {    <br/>     fun prepareFood() {         <br/>         Logger.d("Preparing food")     <br/>     }     <br/>     fun callWaiter() {         <br/>         Logger.d("Calling waiter")     <br/>     }<br/>     fun washesDishes() {        <br/>         Logger.d("Washing dishes")     <br/>     }<br/>}</span></pre><p id="f5e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.现在我们将创建一个类作为OrderFood，它将扮演菜单服务器的角色。</p><pre class="ki kj kk kl fd kn ko kp kq aw kr bi"><span id="064e" class="ks kt hh ko b fi ku kv l kw kx">class OrderFood {</span><span id="cd51" class="ks kt hh ko b fi ky kv l kw kx">   val waiter: Waiter = WaiterImpl()  <br/>   val kitchen: Kitchen  = KitchenImpl()  <br/> <br/>   fun orderFood(oderId: String) {       <br/>      waiter.takeOrder()     <br/>      waiter.sendOrderToKitchen()       <br/>      kitchen.prepareFood()       <br/>      kitchen.callWaiter()       <br/>      waiter.serveFood()       <br/>      kitchen.washesDishes()   <br/>   }  <br/>}</span></pre><p id="1313" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">4.<strong class="iw hi">最后，顾客类，顾客打算在这里订购食物。</strong></p><pre class="ki kj kk kl fd kn ko kp kq aw kr bi"><span id="6725" class="ks kt hh ko b fi ku kv l kw kx">class Customer {<br/>   private val orderFood = OrderFood()     </span><span id="30f7" class="ks kt hh ko b fi ky kv l kw kx">   fun main() {       <br/>     orderFood.orderFood("ORD123456789")<br/>   } <br/>}</span></pre><p id="3539" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="js">外卖</em> </strong></p><p id="6699" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在开发应用程序时，我们添加了一些第三方库，这些库在我们的项目中有一些类，并提供一些可重用的代码。在将库包含在项目中之后，开发人员可以直接将库中的这些类添加到应用程序中。</p><p id="6137" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是直接引用库并不是一个好的解决方案，因为应用程序代码与库紧密耦合，有时与库的特定版本紧密耦合。如果应用程序更加依赖这个库，那么用新版本的库替换这个库就更加困难。这是因为开发人员在用新的库替换旧库时需要更加小心。</p><p id="f100" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我们可以使用外观设计模式来解决这个问题。使用外观设计模式，我们可以将应用程序代码从库代码中分离出来。facade对象就像是库的包装器。当开发人员需要用新的库版本替换旧的库版本时，开发人员只需要专注于修改facade对象内部的代码。</p><p id="fdb7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在库代码上使用facade模式时，最好限制在应用程序中直接引用或直接使用库代码。幸运的是，这很容易通过以下步骤实现</p><ul class=""><li id="94c4" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">通过在应用程序中创建单独的项目并向其中添加facade对象。</li><li id="f0e2" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">将具有外观的项目中的引用添加到第三方库。</li><li id="48ac" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">仅使用facade从应用程序向项目添加引用。</li></ul><p id="823c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望这篇文章对你有所帮助。还要特别感谢 <a class="ae it" href="https://medium.com/u/c82347902bcd?source=post_page-----749339e32a7d--------------------------------" rel="noopener"> Rohit Chandekar </a>！帮我写这篇文章。</p><p id="a26f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">谢谢你👏🏽</p></div></div>    
</body>
</html>