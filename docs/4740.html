<html>
<head>
<title>The Forgotten History of OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被遗忘的OOP历史</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f?source=collection_archive---------1-----------------------#2018-11-01">https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f?source=collection_archive---------1-----------------------#2018-11-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="62a6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列的一部分<strong class="iz hi">s</strong><a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">T5】(现在一本书！) </a>从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">买书</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">索引</a>|<a class="ae jv" rel="noopener" href="/javascript-scene/javascript-monads-made-simple-7856be57bfe8">|&lt;上一张</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381">下一张&gt; </a></p></blockquote><p id="8197" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们今天使用的函数式和命令式编程范式最初是在20世纪30年代用lambda演算和图灵机进行数学探索的，它们是通用计算的替代公式(可以执行一般计算的形式化系统)。丘奇·图灵论文表明λ演算和图灵机在功能上是等价的——任何可以用图灵机计算的东西都可以用λ演算来计算，反之亦然。</p><blockquote class="it iu iv"><p id="aa57" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:有一种普遍的误解，认为图灵机可以计算任何可计算的东西。有几类问题(例如<a class="ae jv" href="https://en.wikipedia.org/wiki/Halting_problem" rel="noopener ugc nofollow" target="_blank">停机问题</a>)在某些情况下是可以计算的，但一般情况下，使用图灵机是无法计算所有情况的。当我在本文中使用“可计算”这个词时，我的意思是“可由图灵机计算”。</p></blockquote><p id="25d7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Lambda演算代表了一种自顶向下的函数应用计算方法，而图灵机的纸带/寄存器机器公式代表了一种自底向上的命令式(一步一步)计算方法。</p><p id="cfed" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">像机器代码和汇编这样的低级语言出现在20世纪40年代，到20世纪50年代末，第一批流行的高级语言出现了。Lisp方言今天还在通用，包括Clojure，Scheme，AutoLISP等。FORTRAN和COBOL都出现在20世纪50年代，是今天仍在使用的命令式高级语言的例子，尽管对于大多数应用程序来说，C族语言已经取代了COBOL和FORTRAN。</p><p id="77a2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">命令式编程和函数式编程都源于计算理论的数学，早于数字计算机。“面向对象编程”(OOP)是由Alan Kay大约在1966年或1967年在读研究生时创造的。</p><p id="c4f6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">伊凡·苏泽兰开创性的画板应用程序是OOP的早期灵感。它创作于1961年至1962年之间，并于1963年发表在他的<a class="ae jv" href="https://dspace.mit.edu/handle/1721.1/14979" rel="noopener ugc nofollow" target="_blank">画板论文</a>中。这些对象是表示显示在示波器屏幕上的图形图像的数据结构，并通过动态委托表现出继承性，伊凡·苏泽兰在他的论文中称之为“主人”。任何对象都可以成为“主对象”，对象的其他实例称为“事件”。Sketchpad的masters与JavaScript的原型继承有很多共同之处。</p><blockquote class="it iu iv"><p id="9bcd" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>麻省理工学院林肯实验室的TX-2是早期使用的图形计算机显示器之一，它使用光笔进行直接屏幕交互。EDSAC在1948-1958年间运行，可以在屏幕上显示图形。麻省理工学院的旋风在1949年有一个工作的示波器显示器。该项目的动机是创造一个通用的飞行模拟器，能够模拟多架飞机的仪表反馈。这导致了SAGE计算系统的开发。<a class="ae jv" href="http://www.computerhistory.org/revolution/real-time-computing/6/123" rel="noopener ugc nofollow" target="_blank">TX-2是SAGE </a>的测试电脑。</p></blockquote><p id="38c0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">第一种被广泛认为是“面向对象”的编程语言是Simula，于1965年指定。像画板一样，Simula以对象为特色，并最终引入了类、类继承、子类和虚方法。</p><blockquote class="it iu iv"><p id="1ada" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:<strong class="iz hi">虚拟方法</strong>是定义在一个类上的方法，它被设计成被子类覆盖。虚拟方法允许程序调用在编译代码时可能不存在的方法，通过使用动态分派来确定在运行时调用什么具体方法。JavaScript以动态类型为特色，并使用委托链来确定调用哪些方法，因此不需要向程序员公开虚方法的概念。换句话说，JavaScript中的所有方法都使用运行时方法分派，因此JavaScript中的方法不需要声明为“虚拟”来支持该特性。</p></blockquote><h1 id="6222" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">伟大的想法</h1><blockquote class="kx"><p id="fe0b" class="ky kz hh bd la lb lc ld le lf lg ju dx translated">“我创造了‘面向对象’这个术语，我可以告诉你我脑子里没有C++”~艾伦·凯，OOPSLA '97 </p></blockquote><p id="3310" class="pw-post-body-paragraph iw ix hh iz b ja li jc jd je lj jg jh jw lk jk jl jx ll jo jp jy lm js jt ju ha bi translated">Alan Kay于1966年或1967年在研究生院创造了“面向对象编程”这个术语。最重要的想法是在软件中使用封装的微型计算机，通过信息传递而不是直接的数据共享进行通信——以停止将程序分解成单独的“数据结构”和“过程”。</p><p id="2e7b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">"递归设计的基本原则是使各部分具有与整体相同的能力."~ Bob Barton，B5000的主要设计师，b 5000是一种为运行Algol-60而优化的大型机。</p><p id="edba" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Smalltalk是由艾伦·凯、丹·英格尔斯、阿黛尔·戈德堡和施乐PARC公司的其他人开发的。Smalltalk比Simula更面向对象——small talk中的一切都是对象，包括类、整数和块(闭包)。最初的Smalltalk-72没有子类化功能。这是丹·英格尔斯在Smalltalk-76中介绍的。</p><p id="d58f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">虽然Smalltalk支持类并最终支持子类化，但Smalltalk并不涉及类或子类化。这是一种受Lisp和Simula启发的函数式语言。Alan Kay认为业界对子类化的关注分散了对面向对象编程真正好处的关注。</p><blockquote class="it iu iv"><p id="3d18" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">很抱歉，我很久以前就为这个主题创造了“对象”这个术语，因为它让许多人关注次要的概念。最重要的想法是信息传递。”<br/> ~艾伦·凯</p></blockquote><p id="f1f4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在2003年的一次电子邮件交流中，艾伦·凯澄清了他称Smalltalk为“面向对象”的意思:</p><blockquote class="it iu iv"><p id="40c5" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“对我来说，OOP只意味着消息传递、本地保留、保护和隐藏状态流程，以及所有东西的极端后期绑定。”<br/> ~艾伦·凯</p></blockquote><p id="512b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">换句话说，根据Alan Kay的说法，OOP的基本成分是:</p><ul class=""><li id="b6c6" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">信息传递</li><li id="23fd" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">包装</li><li id="5ce9" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">动态绑定</li></ul><p id="1a70" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">值得注意的是，艾伦·凯并不认为继承和子类多态性是OOP的基本组成部分，他创造了这个术语并把OOP带给了大众。</p><h1 id="a0b6" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">面向对象的本质</h1><p id="a9a5" class="pw-post-body-paragraph iw ix hh iz b ja mb jc jd je mc jg jh jw md jk jl jx me jo jp jy mf js jt ju ha bi translated">消息传递和封装的结合有一些重要的目的:</p><ul class=""><li id="bebd" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">通过封装状态和将其他对象与本地状态变化隔离来避免共享的可变状态。影响另一个对象状态的唯一方法是通过发送消息来请求(而不是命令)该对象改变它。状态变化在本地、细胞水平上被控制，而不是暴露给共享访问。</li><li id="7faa" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated"><strong class="iz hi">将</strong>对象彼此解耦——消息发送者只是通过消息传递API松散地耦合到消息接收者。</li><li id="dccf" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated"><strong class="iz hi">通过后期绑定对运行时变化的适应性和弹性</strong>。运行时适应性提供了许多Alan Kay认为对OOP至关重要的好处。</li></ul><p id="60c6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些想法是通过Alan Kay的生物学背景和Arpanet(互联网的早期版本)的设计影响，从生物细胞和/或网络上的个人计算机中受到启发的。甚至在早期，艾伦·凯就设想了在一台巨大的分布式计算机(互联网)上运行的软件，其中各个计算机就像生物细胞一样，在它们自己孤立的状态下独立运行，并通过消息传递进行通信。</p><blockquote class="it iu iv"><p id="274e" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“我意识到细胞/整台计算机的比喻将摆脱数据[…]”<br/>~艾伦·凯</p></blockquote><p id="2a29" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">通过“摆脱数据”，Alan Kay肯定意识到了共享可变状态问题和由共享数据引起的紧密耦合——这是当今常见的主题。</p><p id="2af6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是在20世纪60年代后期，ARPA的程序员感到沮丧，因为他们需要在构建软件之前为他们的程序选择一个数据模型表示。与特定数据结构耦合过紧的过程无法适应变化。他们希望对数据进行更加同质的处理。</p><blockquote class="it iu iv"><p id="14f4" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“[……]OOP的全部意义在于不必担心对象内部的内容。在不同的机器上用不同的语言制造的物体应该能够互相交谈[…]”~艾伦·凯</p></blockquote><p id="e416" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对象可以抽象并隐藏数据结构实现。对象的内部实现可以改变，而不会破坏软件系统的其他部分。事实上，通过极端的后期绑定，一个完全不同的计算机系统可以接管一个对象的职责，而软件可以继续工作。同时，对象可以公开一个标准接口，该接口可以处理对象内部碰巧使用的任何数据结构。同一个接口可以处理链表、树、流等等。</p><p id="7c7a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">艾伦·凯也将对象视为代数结构，这为它们的行为提供了某些数学上可证明的保证:</p><blockquote class="it iu iv"><p id="cb32" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“我的数学背景让我意识到，每个对象都可能有几个与之相关的代数，可能有几个代数族，这些代数将非常非常有用。”<br/> ~艾伦·凯</p></blockquote><p id="46e0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这已被证明是正确的，并形成了承诺和透镜等物体的基础，这两者都是由范畴理论启发的。</p><p id="bd49" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Alan Kay对对象的设想的代数本质将允许对象提供形式验证、确定性行为和改进的可测试性，因为代数本质上是遵循方程形式的一些规则的运算。</p><p id="8244" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在程序员的行话中，代数就像是由函数(运算)组成的抽象，伴随着由那些函数必须通过的单元测试强制执行的特定法则(公理/方程)。</p><p id="019f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些想法在大多数C族面向对象语言中被遗忘了几十年，包括C++、Java、C#等。，但是它们开始在最广泛使用的OO语言的最新版本中找到自己的路。</p><p id="56d3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">你可能会说，编程世界正在重新发现面向对象语言环境中函数式编程和理性思维的好处。</p><p id="c712" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">和之前的JavaScript和Smalltalk一样，大多数现代OO语言越来越成为“多范式语言”。没有理由在函数式编程和OOP之间做出选择。当我们审视各自的历史本质时，它们不仅是兼容的，而且是互补的思想。</p><p id="1434" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">因为它们有如此多的共同点，我喜欢说JavaScript是Smalltalk对世界误解OOP的报复。Smalltalk和JavaScript都支持:</p><ul class=""><li id="b132" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">目标</li><li id="e8e4" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">一级函数和闭包</li><li id="bb4e" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">动态类型</li><li id="fbac" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">后期绑定(运行时函数/方法可变)</li><li id="fc38" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">无类继承的OOP</li></ul><p id="436a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">面向对象程序设计的本质是什么(根据艾伦·凯)？</p><ul class=""><li id="9a19" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">包装</li><li id="959f" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">信息传递</li><li id="c4c7" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">动态绑定(程序在运行时进化/适应的能力)</li></ul><p id="8cc9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">什么是非必要的？</p><ul class=""><li id="06d3" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">班级</li><li id="84e7" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">类继承</li><li id="3849" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">对象/功能/数据的特殊处理</li><li id="d224" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated"><code class="du mg mh mi mj b">new</code>关键字</li><li id="53cb" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">多态性</li><li id="0fe5" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">静态类型</li><li id="86db" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">将类识别为“类型”</li></ul><p id="a3c9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您的背景是Java或C#，您可能会认为静态类型和多态是必不可少的成分，但是Alan Kay更喜欢以代数形式处理一般行为。例如，来自Haskell的:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="b7de" class="ms ka hh mj b fi mt mu l mv mw">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="337f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这是仿函数映射签名，它一般作用于未指定的类型<code class="du mg mh mi mj b">a</code>和<code class="du mg mh mi mj b">b</code>，在<code class="du mg mh mi mj b">a</code>的仿函数的上下文中应用从<code class="du mg mh mi mj b">a</code>到<code class="du mg mh mi mj b">b</code>的函数来产生<code class="du mg mh mi mj b">b</code>的仿函数。Functor是数学术语，本质上意味着“支持映射操作”。如果你熟悉JavaScript中的<code class="du mg mh mi mj b">[].map()</code>，你应该已经知道这是什么意思了。</p><p id="8e19" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">以下是JavaScript中的两个例子:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="ee47" class="ms ka hh mj b fi mt mu l mv mw">// isEven = Number =&gt; Boolean<br/>const isEven = n =&gt; n % 2 === 0;</span><span id="386b" class="ms ka hh mj b fi mx mu l mv mw">const nums = [1, 2, 3, 4, 5, 6];</span><span id="041c" class="ms ka hh mj b fi mx mu l mv mw">// map takes a function `a =&gt; b` and an array of `a`s (via `this`)<br/>// and returns an array of `b`s.<br/>// in this case, `a` is `Number` and `b` is `Boolean`<br/>const results = nums.map(isEven);</span><span id="ec01" class="ms ka hh mj b fi mx mu l mv mw">console.log(results);<br/>// [false, true, false, true, false, true]</span></pre><p id="ea75" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du mg mh mi mj b">.map()</code>方法是通用的，因为<code class="du mg mh mi mj b">a</code>和<code class="du mg mh mi mj b">b</code>可以是任何类型，并且<code class="du mg mh mi mj b">.map()</code>处理得很好，因为数组是实现代数<code class="du mg mh mi mj b">functor</code>法则的数据结构。类型对<code class="du mg mh mi mj b">.map()</code>来说无关紧要，因为它并不试图直接操纵它们，而是应用一个函数来期望并返回应用程序的正确类型。</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="768e" class="ms ka hh mj b fi mt mu l mv mw">// matches = a =&gt; Boolean<br/>// here, `a` can be any comparable type<br/>const matches = control =&gt; input =&gt; input === control;</span><span id="a406" class="ms ka hh mj b fi mx mu l mv mw">const strings = ['foo', 'bar', 'baz'];</span><span id="09f9" class="ms ka hh mj b fi mx mu l mv mw">const results = strings.map(matches('bar'));</span><span id="049f" class="ms ka hh mj b fi mx mu l mv mw">console.log(results);<br/>// [false, true, false]</span></pre><p id="ba8e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在TypeScript这样的语言中，这种泛型类型关系很难正确和彻底地表达，但在Haskell的Hindley Milner类型中，通过对更高级类型(类型的类型)的支持，这种关系很容易表达。</p><p id="1ac5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">大多数类型系统限制太多，不允许自由表达动态和功能思想，如函数组合、自由对象组合、运行时对象扩展、组合子、透镜等。换句话说，静态类型经常使编写可组合软件变得更加困难。</p><p id="e5a9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你的类型系统限制太多(例如，TypeScript，Java)，你就不得不写更多复杂的代码来实现同样的目标。这并不意味着静态类型是个坏主意，也不意味着所有的静态类型实现都具有同等的限制性。我遇到的Haskell类型系统的问题要少得多。</p><p id="cff7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您是静态类型的粉丝，并且不介意这些限制，那么您将获得更多的权力，但是如果您发现本文中的一些建议很难，因为很难对组合函数和组合代数结构进行类型化，那么请责怪类型系统，而不是思想。人们喜欢他们的SUV的舒适，但没有人抱怨他们不让你飞。为此，你需要一辆自由度更高的车。</p><p id="054a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果限制让你的代码更简单，那太好了！但是如果限制迫使你写更复杂的代码，也许限制是错误的。</p><h1 id="339a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是对象？</h1><p id="e7b5" class="pw-post-body-paragraph iw ix hh iz b ja mb jc jd je mc jg jh jw md jk jl jx me jo jp jy mf js jt ju ha bi translated">这些年来，物品显然有了很多内涵。我们在JavaScript中称之为“对象”的只是复合数据类型，与基于类的编程或Alan Kay的消息传递没有任何关系。</p><p id="b616" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中，这些对象可以并且经常支持封装、消息传递、通过方法的行为共享，甚至子类多态性(尽管使用委托链而不是基于类型的分派)。您可以将任何功能分配给任何属性。您可以动态构建对象行为，并在运行时更改对象的含义。JavaScript还支持使用闭包来实现隐私的封装。但所有这些都是选择加入的行为。</p><p id="a332" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们目前对对象的概念仅仅是一个复合数据结构，不需要更多的东西就可以被认为是对象。但是，使用这些类型的对象进行编程并不会使您的代码“面向对象”，就像使用函数进行编程不会使您的代码“函数化”一样。</p><h2 id="561b" class="ms ka hh bd kb my mz na kf nb nc nd kj jw ne nf kn jx ng nh kr jy ni nj kv nk bi translated">面向对象不再是真正的面向对象</h2><p id="554f" class="pw-post-body-paragraph iw ix hh iz b ja mb jc jd je mc jg jh jw md jk jl jx me jo jp jy mf js jt ju ha bi translated">因为“对象”在现代编程语言中的意义远不如它对Alan Kay的意义，所以我用“组件”而不是“对象”来描述真正OOP的规则。很多<em class="iy">对象</em>被JavaScript中的其他代码直接拥有和操纵，但是<strong class="iz hi">组件</strong>要封装和控制自己的状态。</p><p id="4a23" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">真正的面向对象意味着:</p><ul class=""><li id="ae54" class="ln lo hh iz b ja jb je jf jw lp jx lq jy lr ju ls lt lu lv bi translated">用<strong class="iz hi">组件</strong>编程(艾伦·凯的“对象”)</li><li id="450a" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">组件状态必须被封装</li><li id="7af0" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">使用消息传递进行对象间通信</li><li id="321e" class="ln lo hh iz b ja lw je lx jw ly jx lz jy ma ju ls lt lu lv bi translated">可以在运行时添加/更改/替换组件</li></ul><p id="d186" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">大多数组件行为都可以用代数数据结构来描述。这里不需要继承。组件可以重用共享函数和模块化导入中的行为，而无需共享它们的数据。</p><p id="f5e7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中操作<em class="iy">对象</em>或使用<em class="iy">类继承</em>并不意味着你在“做OOP”。以这种方式使用组件<em class="iy">可以。</em>但是流行的用法是如何定义单词，所以也许我们应该放弃面向对象编程，称之为“面向消息编程(MOP)”而不是“面向对象编程(OOP)”。</p><p id="b798" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">拖把被用来收拾残局是巧合吗？</p><h1 id="ed05" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么样的拖把是好的</h1><p id="2f7f" class="pw-post-body-paragraph iw ix hh iz b ja mb jc jd je mc jg jh jw md jk jl jx me jo jp jy mf js jt ju ha bi translated">在大多数现代软件中，有一些UI负责管理用户交互，一些代码管理应用程序状态(用户数据)，还有一些代码管理系统或网络I/O。</p><p id="b782" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些系统中的每一个都可能需要长期存在的进程，比如事件侦听器、状态来跟踪诸如网络连接、ui元素状态和应用程序状态本身之类的事情。</p><p id="98f8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">好的MOP意味着系统通过消息调度与其他组件进行通信，而不是所有这些系统相互联系并直接操纵彼此的状态。当用户点击保存按钮时，可能会发送一条<code class="du mg mh mi mj b">"SAVE"</code>消息，应用程序状态组件可能会解释这条消息并将其传递给状态更新处理程序(比如一个纯粹的reducer函数)。也许在状态更新后，状态组件可能会向UI组件发送一条<code class="du mg mh mi mj b">"STATE_UPDATED"</code>消息，UI组件将依次解释状态，协调UI的哪些部分需要更新，并将更新后的状态传递给处理UI的这些部分的子组件。</p><p id="95ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">同时，网络连接组件可能正在监视用户与网络上另一台机器的连接，监听消息，并调度更新的状态表示以在远程机器上保存数据。它在内部跟踪网络心跳计时器，不管连接当前是在线还是离线，等等。</p><p id="0cae" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些系统不需要知道系统其他部分的细节。只关心他们个人的，模块化的问题。系统组件是可分解和可重组的。他们实现了标准化的接口，以便能够进行互操作。只要接口令人满意，您就可以用不同方式做相同事情的替代物，或者用相同的消息做完全不同的事情。您甚至可以在运行时这样做，一切都会正常工作。</p><p id="42bd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">同一软件系统的组件甚至不需要位于同一台机器上。该系统可以是分散的。网络存储可能会在像<a class="ae jv" href="https://en.wikipedia.org/wiki/InterPlanetary_File_System" rel="noopener ugc nofollow" target="_blank"> IPFS </a>这样的分散存储系统中共享数据，这样用户就不需要依赖任何特定机器的健康状况来确保他们的数据得到安全备份，并且不会被黑客窃取。</p><p id="4196" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">OOP部分受到Arpanet的启发，Arpanet的目标之一是建立一个分散的网络，可以抵御像原子弹这样的攻击。据阿帕网开发期间DARPA主任斯蒂芬·j·卢卡西克(<a class="ae jv" href="https://ieeexplore.ieee.org/document/5432117" rel="noopener ugc nofollow" target="_blank">“为什么要建阿帕网”</a>):</p><blockquote class="it iu iv"><p id="6036" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">目标是利用新的计算机技术来满足军事指挥和控制核威胁的需要，实现对美国核力量的生存控制，并改进军事战术和管理决策。</p></blockquote><p id="8265" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">注:</em></strong><em class="iy">Arpanet最初的推动力是便利而非核威胁，其明显的防御优势是后来才显现出来的。ARPA使用三台独立的计算机终端与三个独立的计算机研究项目进行通信。鲍勃·泰勒想要一个单一的计算机网络将每个项目与其他项目连接起来。</em></p><p id="5a3e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">一个好的MOP系统可能会在应用程序运行时使用可热插拔的组件来共享互联网的健壮性。如果用户使用手机，但由于进入隧道而离线，它仍可以继续工作。如果飓风破坏了服务器所在的一个数据中心的电源，它可以继续工作。</p><p id="93fc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">软件世界是时候放下失败的类继承实验，拥抱最初定义OOP精神的数学和科学原则了。</p><p id="22ce" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在是我们开始构建更灵活、更有弹性、更好组合的软件的时候了，让MOP和函数式编程和谐地工作。</p><blockquote class="it iu iv"><p id="04c3" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:首字母缩写词MOP已经被用来描述“面向监控的编程”,它不太可能出现的OOP将会悄然消失。</p><p id="89ca" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">如果MOP没有作为编程行话流行起来，不要沮丧。一定要把你的脏东西擦干净。</p></blockquote><h1 id="90b0" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">在EricElliottJS.com了解更多信息</h1><p id="d76c" class="pw-post-body-paragraph iw ix hh iz b ja mb jc jd je mc jg jh jw md jk jl jx me jo jp jy mf js jt ju ha bi translated">EricElliottJS.com的会员可以上函数式编程的视频课。如果你还不是会员，今天就注册吧。</p></div><div class="ab cl nl nm go nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy"> Eric Elliott </em> </strong> <em class="iy">是一位分布式系统专家，著有以下书籍:</em> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【排版软件】</em></a><em class="iy"/><a class="ae jv" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"><em class="iy">【编程JavaScript应用】</em> </a> <em class="iy">。作为</em><a class="ae jv" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="iz hi"> <em class="iy">、Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">、华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC、</em> </strong> <em class="iy">以及包括</em> <strong class="iz hi"> <em class="iy">亚瑟、弗兰克·奥申、金属乐队在内的顶级录音艺术家提供软件体验</em></strong></p><p id="98ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>