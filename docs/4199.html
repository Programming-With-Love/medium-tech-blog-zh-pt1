<html>
<head>
<title>Who’s afraid of Machine Learning? Part 6 : Running ML-Kit On Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁害怕机器学习？第6部分:在云上运行ML-Kit</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/whos-afraid-of-machine-learning-part-6-running-ml-kit-on-cloud-633343d80fd9?source=collection_archive---------9-----------------------#2018-10-05">https://medium.com/google-developer-experts/whos-afraid-of-machine-learning-part-6-running-ml-kit-on-cloud-633343d80fd9?source=collection_archive---------9-----------------------#2018-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="2c63" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">面向移动开发者的ML &amp; ML-Kit简介</h2></div><p id="9b71" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae js" rel="noopener" href="/@britt.barak/whos-afraid-of-machine-learning-part-5-running-ml-kit-on-device-394b6c19f00f">上一篇文章中，我们运行了本地(在设备上)模型</a>来对图像进行分类。现在，是时候尝试通过运行基于<strong class="iy hi">云</strong>的模型来提高标签的准确性(同时允许更多的延迟)。☁</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/ca1146d4efefb5698432933a177cd92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0xJNZY_wZnlGyX67SWVJg.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx"><a class="ae js" href="https://unsplash.com/@jeanbeller" rel="noopener ugc nofollow" target="_blank">Jéan Béller</a> on Unsplash</figcaption></figure><h2 id="12dc" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">开始之前:</h2><p id="861e" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">如果你已经完成了上一篇文章，你就可以跳到下一部分了！</p><p id="0137" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">否则，您应该确保克隆这个演示的代码，并将Firebase和MLKit添加到您的应用程序中。如需指导，请在开始前查看上一篇文章的 部分的<strong class="iy hi"> <em class="lj">。</em></strong></p><p id="f142" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如您所知，对于每个模型，我们有4个实施步骤:</p><p id="54b1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">0.设置(不是出轨:)真的不算一步…)</p><ol class=""><li id="2fb2" class="lk ll hh iy b iz ja jc jd jf lm jj ln jn lo jr lp lq lr ls bi translated">设置分类器</li><li id="5534" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr lp lq lr ls bi translated">处理输入</li><li id="6a2f" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr lp lq lr ls bi translated">运行模型</li><li id="f8a6" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr lp lq lr ls bi translated">处理输出</li></ol><p id="5e15" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们开始吧:</p><h1 id="3def" class="ly kk hh bd kl lz ma mb kp mc md me kt in mf io kw iq mg ir kz it mh iu lc mi bi translated">运行基于云的模型</h1><h2 id="227c" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">步骤0:设置</h2><p id="0333" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">基于云的模型属于<em class="lj">云视觉API </em>，您必须确保为您的项目启用该API:</p><ol class=""><li id="f275" class="lk ll hh iy b iz ja jc jd jf lm jj ln jn lo jr lp lq lr ls bi translated">使用基于云的模式需要支付超过一定额度的费用。出于演示和开发的目的，您不太可能接近那个配额。但是，你必须升级你的Firebase项目计划，这样理论上它可以在需要的时候充电。将免费的<em class="lj"> Spark </em>计划项目升级为<em class="lj"> Blaze </em>计划，这是一个现收现付的计划，使您能够使用Cloud Vision APIs。你可以在<a class="ae js" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>中完成。</li><li id="2c5f" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr lp lq lr ls bi translated">在<a class="ae js" href="https://console.cloud.google.com/apis/library/vision.googleapis.com/" rel="noopener ugc nofollow" target="_blank">云控制台API库</a>上启用<em class="lj">云视觉API </em>。在顶部菜单中，选择你的Firebase项目，如果还没有启用，点击<strong class="iy hi">启用</strong>。</li></ol><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mj"><img src="../Images/5a0aae59fc052af614873476aab441a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAZx2SprTWNBs7A3qGHejA.png"/></div></div></figure><ul class=""><li id="b8e8" class="lk ll hh iy b iz ja jc jd jf lm jj ln jn lo jr mk lq lr ls bi translated"><strong class="iy hi">注</strong>:开发用，这个配置就行。但是，在部署到生产环境之前，您应该采取一些额外的步骤来确保您的帐户没有进行未经授权的呼叫。在这种情况下，查看此处的说明<a class="ae js" href="https://firebase.google.com/docs/ml-kit/android/secure-api-key" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><h2 id="b9cc" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">步骤1:设置分类器</h2><p id="3d25" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">创建<strong class="iy hi"><em class="lj">cloud classifier</em></strong>类，保存<strong class="iy hi"> <em class="lj">探测器</em> </strong>对象:</p><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="9d43" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">public class </strong>CloudClassifier {<br/>    <strong class="mm hi">detector </strong>= FirebaseVision.<em class="lj">getInstance</em>().<strong class="mm hi">getVisionCloudLabelDetector</strong>();<br/>}</span></pre><p id="d602" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了<em class="lj">探测器的类型之外，它真的和上一篇文章的<code class="du mu mv mw mm b">LocalClassifier</code>几乎一样。</em></p><p id="4caf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以在检测器上设置一些额外的选项:</p><ul class=""><li id="daeb" class="lk ll hh iy b iz ja jc jd jf lm jj ln jn lo jr mk lq lr ls bi translated"><em class="lj"> setMaxResults() </em> —默认情况下将返回10个结果。如果你需要更多，你必须指定它。另一方面，在设计演示应用程序时，我决定只展示前3名的结果。我可以在这里定义它，让计算快一点。</li><li id="1138" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr mk lq lr ls bi translated"><em class="lj"> setModelType() — </em>可以是<code class="du mu mv mw mm b"><a class="ae js" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/cloud/FirebaseVisionCloudDetectorOptions.html#STABLE_MODEL" rel="noopener ugc nofollow" target="_blank">STABLE_MODEL</a></code>也可以是<code class="du mu mv mw mm b"><a class="ae js" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/cloud/FirebaseVisionCloudDetectorOptions.html#LATEST_MODEL" rel="noopener ugc nofollow" target="_blank">LATEST_MODEL</a></code>，默认为后者。</li></ul><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="8159" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">public class </strong>CloudClassifier {</span><span id="d46b" class="kj kk hh mm b fi mx mr l ms mt"><strong class="mm hi">options </strong>=<br/>        new<strong class="mm hi"> </strong>FirebaseVisionCloudDetectorOptions.Builder()<br/>             .setModelType(FirebaseVisionCloudDetectorOptions.<strong class="mm hi"><em class="lj">LATEST_MODEL</em></strong>)<br/>             .setMaxResults(ImageClassifier.<strong class="mm hi"><em class="lj">RESULTS_TO_SHOW</em></strong>)<br/>             .build();</span><span id="15cb" class="kj kk hh mm b fi mx mr l ms mt"><em class="lj">    </em><strong class="mm hi">detector </strong>=<br/>        FirebaseVision.<em class="lj">getInstance</em>().getVisionCloudLabelDetector(<strong class="mm hi">options</strong>);<br/>}</span></pre><h2 id="0e37" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">步骤2:处理输入</h2><p id="5ac7" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">与<code class="du mu mv mw mm b">LocalDetector</code>类似，<code class="du mu mv mw mm b"><em class="lj">FirebaseVisionCloudLabelDetector</em></code> <em class="lj"> </em>使用了一个<code class="du mu mv mw mm b"><em class="lj">FirebaseVisionImage</em></code>的输入，我们将从一个<code class="du mu mv mw mm b">Bitmap</code>中获取，以方便UI；</p><p id="cb14" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于<code class="du mu mv mw mm b">FirebaseVisionImage</code>的更多解释可以在之前的帖子中找到。</p><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="f4b5" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">public class </strong>CloudClassifier {<br/>    //...</span><span id="4907" class="kj kk hh mm b fi mx mr l ms mt">    FirebaseVisionImage <strong class="mm hi">image</strong>;<br/>    public void<strong class="mm hi"> execute</strong>(Bitmap bitmap) {<br/>        <br/><em class="lj">        </em><strong class="mm hi">image </strong>= FirebaseVisionImage.<em class="lj">fromBitmap</em>(bitmap);<br/>    }<br/>}</span></pre><h2 id="6271" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">步骤3:运行模型</h2><p id="6dfd" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">与前面的步骤一样，这一步与我们运行本地模型的步骤极其相似。</p><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="fc9a" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">public class </strong>CloudClassifier {</span><span id="486b" class="kj kk hh mm b fi mx mr l ms mt">public void<strong class="mm hi"> execute</strong>(Bitmap bitmap, <strong class="mm hi">OnSuccessListener</strong> successListener, <strong class="mm hi">OnFailureListener</strong> failureListener) {<br/>        <em class="lj">//...</em></span><span id="5fc4" class="kj kk hh mm b fi mx mr l ms mt"><strong class="mm hi">        detector</strong>.detectInImage(<strong class="mm hi">image</strong>)<br/>                .addOnSuccessListener(successListener)<br/>                .addOnFailureListener(failureListener);</span><span id="0e7f" class="kj kk hh mm b fi mx mr l ms mt">    }<br/>}</span></pre><h2 id="fded" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">步骤4:处理输出</h2><p id="a11e" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">由于本地模型与基于云的模型不同，它们的输出也不同，因此我们在<code class="du mu mv mw mm b">OnSuccessListener</code>上得到的响应的对象类型根据<em class="lj">检测器</em>是不同的。然而，这些对象是完全相同的工作。</p><p id="46e1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du mu mv mw mm b"><strong class="iy hi">ImageClassifier.java</strong></code>上<em class="lj"> : </em></p><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="9919" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">cloudClassifier </strong>= new<strong class="mm hi"> </strong>CloudClassifier();</span><span id="ba3a" class="kj kk hh mm b fi mx mr l ms mt">public void <strong class="mm hi">executeCloud</strong>(Bitmap bitmap, ClassifierCallback callback) {</span><span id="f400" class="kj kk hh mm b fi mx mr l ms mt">    <strong class="mm hi">successListener</strong> = new<strong class="mm hi"> </strong>OnSuccessListener&lt;List&lt;FirebaseVisionCloudLabel&gt;&gt;() {<br/>    <br/>        public void<strong class="mm hi"> onSuccess</strong>(List&lt;FirebaseVisionCloudLabel&gt; labels) {<br/>            <strong class="mm hi">processCloudResult</strong>(labels, callback, start);<br/>        }<br/>    };</span><span id="df55" class="kj kk hh mm b fi mx mr l ms mt">    <strong class="mm hi">cloudClassifier</strong>.execute(bitmap, successListener, failureListener);<br/>}</span></pre><p id="cd4e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，处理UI要呈现的结果取决于您对UI所呈现内容的决定。对于这个例子:</p><pre class="ju jv jw jx fd ml mm mn mo aw mp bi"><span id="8e1a" class="kj kk hh mm b fi mq mr l ms mt"><strong class="mm hi">processCloudResult</strong>(List&lt;FirebaseVisionCloudLabel&gt; labels, ClassifierCallback callback) {<br/>    labels.sort(cloudLabelComparator);    <br/>    <strong class="mm hi">resultLabels</strong>.clear();</span><span id="4f61" class="kj kk hh mm b fi mx mr l ms mt">    FirebaseVisionCloudLabel label;<br/>    for (int<strong class="mm hi"> </strong>i = 0; i &lt; Math.<em class="lj">min</em>(<strong class="mm hi"><em class="lj">RESULTS_TO_SHOW</em></strong>, labels.size()); ++i) {<br/>        label = labels.get(i);<br/>        <strong class="mm hi">resultLabels</strong>.add(label.getLabel() + <strong class="mm hi">":" </strong>+ label.getConfidence());<br/>    }<br/>    callback.onClassified(<strong class="mm hi">"Cloud Model"</strong>, <strong class="mm hi">resultLabels</strong>);</span><span id="8e44" class="kj kk hh mm b fi mx mr l ms mt">}</span></pre><p id="cc0a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如上所述，<code class="du mu mv mw mm b">FirebaseVisionCloudLabel</code>和用于本地模型的<code class="du mu mv mw mm b">FirebaseVisionLabel</code>是不同的对象。它们都基于<a class="ae js" href="https://developers.google.com/knowledge-graph/" rel="noopener ugc nofollow" target="_blank"> <em class="lj">谷歌知识图</em>、</a>，因此，它们的API是相同的:</p><ul class=""><li id="092f" class="lk ll hh iy b iz ja jc jd jf lm jj ln jn lo jr mk lq lr ls bi translated"><code class="du mu mv mw mm b"><strong class="iy hi">getLabel()</strong></code> —人类可理解的文本，表示在图像上发现的对象。它将永远是英文的。</li><li id="85dc" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr mk lq lr ls bi translated"><code class="du mu mv mw mm b"><strong class="iy hi">getConfidence()</strong></code>—0–1浮点，表示图像中检测到的物体确实符合建议标签的概率。</li><li id="fdc3" class="lk ll hh iy b iz lt jc lu jf lv jj lw jn lx jr mk lq lr ls bi translated"><code class="du mu mv mw mm b"><strong class="iy hi">getEntityId()</strong></code> —如果在<a class="ae js" href="https://developers.google.com/knowledge-graph/" rel="noopener ugc nofollow" target="_blank">谷歌知识图</a>上找到该标签，该字段将为其返回一个唯一的Id，该Id可以被<a class="ae js" href="https://developers.google.com/knowledge-graph/" rel="noopener ugc nofollow" target="_blank">知识图</a> API进一步查询，以获得对象的更广泛的上下文。</li></ul><h2 id="c004" class="kj kk hh bd kl km kn ko kp kq kr ks kt jf ku kv kw jj kx ky kz jn la lb lc ld bi translated">差不多就是这样！🎉</h2><p id="c84b" class="pw-post-body-paragraph iw ix hh iy b iz le ii jb jc lf il je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">就是这样！让我们来看看一些结果:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es my"><img src="../Images/80ca03ce90a1463789dd48a51e23d2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*fbfgnSaCdT7rBAsuY11mlQ.gif"/></div></figure><p id="12f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">太酷了！！</p><p id="e856" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如所料，模型返回结果的时间稍长。然而，现在它可以告诉我图像中是哪个具体的水果，而不仅仅是一个笼统的标题。此外，它对结果的信心超过90%,而本地模型的信心为70 %- 80%。</p><p id="a9d3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种权衡是我们作为应用开发者要考虑的。</p><p id="78ba" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个帖子的代码可以在回购上找到，分支<a class="ae js" href="https://github.com/brittBarak/MLKitDemo/tree/2.run_cloud_model" rel="noopener ugc nofollow" target="_blank"><strong class="iy hi">2 . run _ cloud _ model</strong></a></p><p id="517a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">希望你也能意识到使用Firebase MLKit是多么简单和有趣。使用其他模型:人脸检测、条形码扫描等..工程非常相似，我鼓励你尝试一下！</p></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><p id="ec0b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们能得到更好的结果吗？在接下来的文章中，让我们也使用一个自定义模型来探索这个问题。再见！！</p></div></div>    
</body>
</html>