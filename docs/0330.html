<html>
<head>
<title>Windows Insets + Fragment Transitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">窗口插入+片段过渡</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/windows-insets-fragment-transitions-9024b239a436?source=collection_archive---------2-----------------------#2018-03-01">https://medium.com/androiddevelopers/windows-insets-fragment-transitions-9024b239a436?source=collection_archive---------2-----------------------#2018-03-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="830e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">悲惨的故事</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/62891816e492ce0ddacbee5cff581786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUTUt9FU2cA9czR2ArOI8g.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://flic.kr/p/92WJtS" rel="noopener ugc nofollow" target="_blank">Cat Window</a></figcaption></figure><p id="e79d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这篇文章是我写的关于片段转换的系列文章的第二篇。下面是第一个，它设置了如何让片段过渡工作。</p><div class="kj kk ez fb kl km"><a rel="noopener follow" target="_blank" href="/google-developers/fragment-transitions-ea2726c3f36f"><div class="kn ab dw"><div class="ko ab kp cl cj kq"><h2 class="bd hi fi z dy kr ea eb ks ed ef hg bi translated">片段转换</h2><div class="kt l"><h3 class="bd b fi z dy kr ea eb ks ed ef dx translated">让他们工作</h3></div><div class="ku l"><p class="bd b fp z dy kr ea eb ks ed ef dx translated">medium.com</p></div></div><div class="kv l"><div class="kw l kx ky kz kv la jg km"/></div></div></a></div></div><div class="ab cl lb lc go ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ha hb hc hd he"><blockquote class="li"><p id="a9e2" class="lj lk hh bd ll lm ln lo lp lq lr ki dx translated">在我继续之前，我假设你知道什么是窗口插入，以及它们是如何被分派的。如果你不知道，我建议你看看这个演讲(是的，是我写的🙋)</p></blockquote><div class="ls lt lu lv lw km"><a href="https://chris.banes.me/talks/2017/becoming-a-master-window-fitter-lon/" rel="noopener  ugc nofollow" target="_blank"><div class="kn ab dw"><div class="ko ab kp cl cj kq"><h2 class="bd hi fi z dy kr ea eb ks ed ef hg bi translated">成为窗户装配工大师🔧</h2><div class="kt l"><h3 class="bd b fi z dy kr ea eb ks ed ef dx translated">窗口插入长期以来一直是开发人员困惑的来源，这是因为它们确实非常令人困惑…</h3></div><div class="ku l"><p class="bd b fp z dy kr ea eb ks ed ef dx translated">克里斯.贝恩斯.我</p></div></div><div class="kv l"><div class="lx l kx ky kz kv la jg km"/></div></div></a></div></div><div class="ab cl lb lc go ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ha hb hc hd he"><p id="68fb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我要坦白一件事。当我写这个系列的第一篇博文时，我在视频上做了一点手脚。我实际上遇到了一个窗口插入的问题，这意味着我实际上结束了如下:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ly"><img src="../Images/65d8c85ad5eb0fe14102af16e8010333.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*F5gd8B0lTil_dF7pwP9JbA.gif"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Transition breaks status bar handling</figcaption></figure><p id="c708" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Woops，不完全是我在第一个帖子里展示的🤐。我不想把第一篇文章写得太复杂，所以决定把它单独写出来。无论如何，你可以看到，当添加转换时，我们突然失去了所有的状态栏处理，视图被推到了状态栏的后面。</p><h2 id="ac72" class="lz ma hh bd mb mc md me mf mg mh mi mj jw mk ml mm ka mn mo mp ke mq mr ms mt bi translated">问题是</h2><p id="8122" class="pw-post-body-paragraph jn jo hh jp b jq mu ii js jt mv il jv jw mw jy jz ka mx kc kd ke my kg kh ki ha bi translated">这两个片段都大量使用窗口小图来绘制系统栏的后面。片段A使用一个<a class="ae jm" href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html" rel="noopener ugc nofollow" target="_blank"> CoordinatorLayout </a>和<a class="ae jm" href="https://developer.android.com/reference/android/support/design/widget/AppBarLayout.html" rel="noopener ugc nofollow" target="_blank"> AppBarLayout </a>，而片段B使用自定义窗口嵌入处理(通过applywindowsetslistener上的<a class="ae jm" href="https://developer.android.com/reference/android/support/v4/view/OnApplyWindowInsetsListener.html" rel="noopener ugc nofollow" target="_blank">)。不管实现如何，这种转换都会把两者都搞乱。</a></p><p id="eaed" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">那么，为什么会出现这种情况呢？当您使用片段转换时，退出(片段A)和进入(片段B)内容视图的实际情况如下:</p><ol class=""><li id="b784" class="mz na hh jp b jq jr jt ju jw nb ka nc ke nd ki ne nf ng nh bi translated">过渡已完成。</li><li id="d090" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">因为我们在片段A上使用了退出过渡，所以视图A保持不变，并且过渡在其上运行。</li><li id="4f14" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">视图B被添加到容器视图中，并立即设置为不可见。</li><li id="9188" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">开始片段B的进入和“共享元素进入”转换。</li><li id="43bb" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">视图B被设置为可见。</li><li id="7ca2" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">当片段A的退出转换完成时，视图A从容器视图中移除。</li></ol><p id="7787" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这听起来不错，但是为什么它会突然影响窗口插入的处理呢？这都是因为在转换过程中，两个片段的视图都出现在容器中。</p><p id="cc5c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这听起来很好，对吗？在我的场景中，两个片段的视图都想要处理和使用窗口插入，因为它们都希望看到屏幕上唯一的“主”视图。但是只有一个视图会收到窗口插入:第一个子视图。这是由于ViewGroup <a class="ae jm" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/view/ViewGroup.java#6928" rel="noopener ugc nofollow" target="_blank">分派窗口插入</a>的方式，即通过依次迭代其子元素，直到其中一个元素消耗了这些插入。如果第一个孩子(这里的片段A)消耗了insets，那么任何后续的孩子(这里的片段B)都得不到它们，我们就结束了这种情况。</p><p id="a300" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们再来一遍，但是这一次增加了调度窗口插入的时间:</p><ol class=""><li id="7bda" class="mz na hh jp b jq jr jt ju jw nb ka nc ke nd ki ne nf ng nh bi translated">交易已完成。</li><li id="f279" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">由于我们使用的是退出转换，视图A保持不变，转换在其上运行。</li><li id="450e" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">视图B被添加到容器视图中，并立即设置为不可见。</li><li id="8a90" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated"><strong class="jp hi">窗口小图被调度。我们希望视图B(子视图1)获得它们，但是视图A(子视图0)再次获得它们。</strong></li><li id="1566" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">开始片段B的进入和“共享元素进入”转换。</li><li id="98e1" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">视图B被设置为可见。</li><li id="016e" class="mz na hh jp b jq nm jt nn jw no ka np ke nq ki ne nf ng nh bi translated">当片段A的退出转换完成时，视图A被移除。</li></ol><h2 id="2ac9" class="lz ma hh bd mb mc md me mf mg mh mi mj jw mk ml mm ka mn mo mp ke mq mr ms mt bi translated">修复</h2><p id="70e9" class="pw-post-body-paragraph jn jo hh jp b jq mu ii js jt mv il jv jw mw jy jz ka mx kc kd ke my kg kh ki ha bi translated">修复实际上相对简单:我们只需要确保两个视图<br/>都接收到窗口插入。</p><p id="1d4f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我这样做的方法是在容器视图中添加一个<a class="ae jm" href="https://developer.android.com/reference/android/support/v4/view/OnApplyWindowInsetsListener.html" rel="noopener ugc nofollow" target="_blank">on applywindowsetslistener</a>(在本例中是在主机活动中),它手动将任何insets分派给它的所有子节点，而不仅仅是在一个节点使用insets之前。</p><pre class="ix iy iz ja fd nr nl ns nt aw nu bi"><span id="2454" class="lz ma hh nl b fi nv nw l nx ny">fragment_container.setOnApplyWindowInsetsListener { view, insets -&gt;<br/>  var consumed = false<br/><br/>  (view as ViewGroup).forEach { child -&gt;<br/>    <em class="nz">// Dispatch the insets to the child</em><br/>    val childResult = child.dispatchApplyWindowInsets(insets)<br/>    <em class="nz">// If the child consumed the insets, record it</em><br/>    if (childResult.isConsumed) {<br/>      consumed = true<br/>    }<br/>  }<br/><br/>  <em class="nz">// If any of the children consumed the insets, return<br/>  // an appropriate value</em><br/>  if (consumed) insets.consumeSystemWindowInsets() else insets<br/>}</span></pre><p id="a640" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们应用之后，两个片段都收到了窗口插入，我们得到了我在第一篇文章中实际显示的结果:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ly"><img src="../Images/6fd20be0fd63551f9ef5c169da38b98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*qIMJQmMCS_g9Yl4XfPEMQQ.gif"/></div></figure></div><div class="ab cl lb lc go ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ha hb hc hd he"><h2 id="d21e" class="lz ma hh bd mb mc md me mf mg mh mi mj jw mk ml mm ka mn mo mp ke mq mr ms mt bi translated">奖金部分💃:确保请求</h2><p id="681f" class="pw-post-body-paragraph jn jo hh jp b jq mu ii js jt mv il jv jw mw jy jz ka mx kc kd ke my kg kh ki ha bi translated">我差点忘了写一件相关的小事。如果你在片段中处理窗口插入，隐式地(通过使用AppBarLayout等)或显式地，你需要确保你请求一些插入。使用<a class="ae jm" href="https://developer.android.com/reference/android/support/v4/view/ViewCompat.html#requestApplyInsets(android.view.View)" rel="noopener ugc nofollow" target="_blank"> requestApplyInsets() </a>很容易做到这一点:</p><pre class="ix iy iz ja fd nr nl ns nt aw nu bi"><span id="c57c" class="lz ma hh nl b fi nv nw l nx ny">override fun<strong class="nl hi"> </strong>onViewCreated(view: View, icicle: Bundle) {<br/>  super.onViewCreated(view, savedInstanceState)<br/>  <em class="nz">// yadda, yadda</em></span><span id="df92" class="lz ma hh nl b fi oa nw l nx ny">  <strong class="nl hi">ViewCompat.requestApplyInsets(view)</strong><br/>}</span></pre><p id="3dec" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你必须这样做，因为只有当整个视图层次结构<strong class="jp hi">的聚合系统ui可见性值发生变化</strong>时，窗口才会自动向下发送insets。由于可能有两个片段提供完全相同的值的时候，聚集值不会改变，所以系统将忽略“改变”。</p></div></div>    
</body>
</html>