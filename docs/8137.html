<html>
<head>
<title>Schema governance approaches for GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL的模式治理方法</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/schema-governance-approaches-for-graphql-68eaf32a48c0?source=collection_archive---------5-----------------------#2022-08-11">https://medium.com/walmartglobaltech/schema-governance-approaches-for-graphql-68eaf32a48c0?source=collection_archive---------5-----------------------#2022-08-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9b97c7d66a7f9134590b401a56590ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_ZdyCP8rbwS8hGJzi0LjQ.png"/></div></div></figure><p id="b3e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章概述了我们在沃尔玛使用的一种方法，以确保无冲突、标准化的子图被装载到联邦网关上。使用我们内部的“GraphQL模式治理工具”，我们通过使用<a class="ae jn" href="https://www.npmjs.com/package/graphql-schema-linter" rel="noopener ugc nofollow" target="_blank"> graphql-schema-linter </a>和<a class="ae jn" href="https://www.npmjs.com/package/graphql-voyager" rel="noopener ugc nofollow" target="_blank"> GraphQL Voyager </a>包，提前消除了开发周期中和入职前的各种顾虑。</p><h1 id="596d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">GraphQL联盟</h1><p id="096e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在进入治理工具的细节之前，让我们回顾一下GraphQL联邦的基础。</p><p id="11ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">GraphQL federation在后端提供了一个带有多个服务的GraphQL API，允许不同的团队使用他们自己的服务处理他们自己的模式或子图。然后可以将这些模式集成在一起，形成一个超图。组合子图的任务由“网关”层完成，它不需要太多代码。</p><p id="2853" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在任何服务中存在修改的情况下，前端层仅查询联合网关，而不必基于服务对查询进行改变。</p><p id="77d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们分析了一些正在集成到我们的联邦网关中的子图，并观察了它们设计中的一些常见问题。这些启发了我们开发GraphQL模式治理工具。下面列出了其中的一些问题:</p><h2 id="27d6" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">不一致的模式</h2><p id="059e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">联邦面临的挑战之一是难以管理来自不同来源的子图。团队可能最终会创建与另一个团队相同的<em class="lf">类型</em>，这可能会在集成到联合网关中之后导致冲突。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/540edf05bba2b536be48882a40ff0651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk2C6zXxsUUNcAVxhCAekQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Team A and Team B create the same Type <em class="lp">Person</em> which leads to conflict</figcaption></figure><h2 id="d73d" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">非标准开发实践</h2><p id="41d4" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">不同团队在联合网关上持续集成子图增加了冲突的可能性。开发人员在注意到网关上的冲突(例如使用相同的<em class="lf">类型</em>)之前，会经历整个软件开发生命周期(SDLC)。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/707154558027c04d415ed2e9556cab29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZSIHgUx53i5xiYIu7Qijw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Different datatypes used for the same field</figcaption></figure><h2 id="c6c4" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">代码质量保证</h2><p id="d314" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">需要分析GraphQL模式以获得设计指南。这个过程可以通过使用一个可以解析模式并返回问题的工具来自动化。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/b5d4de16a2f05a67824ceaf565726d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FelJU735KWFkZBCC5iYEcw.png"/></div></div></figure><h2 id="3622" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">缺乏分析问题的可视化工具</h2><p id="ac04" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">随着模式大小的增加，识别<em class="lf">类型</em>之间的偶然循环依赖变得越来越困难。然而，使用GraphQL Voyager这样的可视化工具，检测循环依赖关系会更容易，耗时也更少。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/6dfaafcb3469e14d8eb6bd5a57c6fc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZydN7LkN_v5qfp817S92tw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Cyclic dependency between Type Person and Type Contact</figcaption></figure><h2 id="b57a" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">复杂图形</h2><p id="76ce" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从我们的分析中，我们发现扁平图形比非扁平图形具有更低的响应时间。为了避免网关级别的性能问题，可以在集成之前识别复杂的图。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/f56d2d399aebf7c6f628f166f8bad5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKARZwWXp5O5bnrlO7GFzw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Complex graph for Type Person</figcaption></figure><h1 id="f032" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">GraphQL模式治理工具</h1><p id="4ce3" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了解决上述挑战，我们通过利用graphql-schema-linter和GraphQL Voyager包开发了GraphQL模式治理工具。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/e1af29fba4f017a291d68d4f6c3d1a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm6nHiyCqmzP9cyg8oq8pw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">The architecture of the GraphQL Schema Governance Tool</figcaption></figure><h2 id="c9e5" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">图表SQL-模式-链接器</h2><p id="e413" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">graphql-schema-linter是一个npm包，用于根据某些规则验证模式定义语言(SDL)。该包提供了一个命令行实用程序，其中包含一组内置规则和几个用于验证的配置。该实用程序解析模式定义并生成一个可以配置成不同格式(text/compact/JSON)的报告。</p><p id="43a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了内置规则之外，该库还允许开发人员编写一组定制规则，以满足他们组织的需求。例如，我们使用以下规则来确保有效、一致的模式:</p><p id="70f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lf">[C]表示我们开发的自定义规则。</em></p><ul class=""><li id="6186" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><em class="lf">字段有描述<br/> </em>该规则将验证对象类型字段和接口类型字段有描述。</li><li id="de5d" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">字段是驼峰式大小写<br/> </em>该规则将验证对象类型字段，接口类型字段名称是驼峰式大小写。</li><li id="fcdf" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">模式深度检查器【C】<br/></em>该规则通过检查类型嵌套来检查模式的深度。如果深度大于某个阈值，就会抛出错误。</li><li id="e0e1" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">循环检测器【C】<br/></em>该规则将检查子图中的循环依赖关系。</li><li id="b50a" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">id应该是ID [C]类型<br/> </em>如果带有“ID”后缀的字段不是ID类型，此规则将引发验证错误。</li><li id="124d" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">冲突检查器[C]: <br/> </em>该规则将访问并获得超级图中可用类型的列表。如果子图中的任何类型出现在超图中，它将抛出一个错误。</li><li id="4a0c" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><em class="lf">稀疏数组检查器【C】<br/></em>对于下面的类型，里面的感叹号表示数组中的任何值都将是一个<em class="lf">字符串</em>。如果缺少此感叹号，数组可能包含空值/未定义的值。外面的感叹号表示数组将始终返回，但可能为空。</li></ul><p id="e9a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此规则验证对于不可为空的数组，数组内的字段类型也不可为空。</p><pre class="lh li lj lk fd mh mi mj mk aw ml bi"><span id="cd53" class="kr jp hh mi b fi mm mn l mo mp">type Person {</span><span id="b755" class="kr jp hh mi b fi mq mn l mo mp">contacts: [String!]!</span><span id="2235" class="kr jp hh mi b fi mq mn l mo mp">}</span></pre><p id="388f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">验证这些规则后，所有错误和警告的报告将发送给模式所有者。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/0c84f08f1052582d2aaac11a6b2de685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*-QtRwLfKJoF2m8wADGfW3A.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">The generated report</figcaption></figure><h2 id="2eb7" class="kr jp hh bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">GraphQL航海家号</h2><p id="c9a7" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">GraphQL Voyager是一个用于任何GraphQL API的交互式可视化的包。在设计或讨论数据模型时，这是一个很好的工具。它可以与GraphQL API集成，并具有以下特性:</p><ul class=""><li id="3ce6" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated">图表上的快速导航</li><li id="1c65" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">左侧面板提供了每种类型的更多详细信息</li><li id="4117" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">“跳过中继”选项，通过删除中继包装类来简化图形</li><li id="20d3" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">选择任何类型作为图的根的能力</li></ul><p id="20ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">知识图的可视化也被发送给模式所有者。这种可视化使开发人员能够更快地理解他们的模式的问题。</p><h1 id="6597" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="8d1d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从上面的挑战中，很明显模式治理工具对于复杂的超图是必要的。这有助于确保遵循联邦模式设计指南。此外，GraphQL模式治理工具有助于实现以下目标:</p><ul class=""><li id="d844" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated">深入了解标准模式设计实践</li><li id="1a80" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">在集成到联邦之前理解模式冲突</li><li id="1c39" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">在出现冲突的情况下，节省审查和重做开发工作的时间</li><li id="5597" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">通过在集成前检测复杂图形来防止性能问题</li></ul><p id="e532" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">非常感谢<a class="ms mt ge" href="https://medium.com/u/b7654bf06923?source=post_page-----68eaf32a48c0--------------------------------" rel="noopener" target="_blank"> Rohit Magazine </a>和<a class="ms mt ge" href="https://medium.com/u/9fb04e6e3e94?source=post_page-----68eaf32a48c0--------------------------------" rel="noopener" target="_blank"> Rupesh Patel </a>对本文的贡献！</p></div></div>    
</body>
</html>