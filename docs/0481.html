<html>
<head>
<title>Inline functions — under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌入式功能—在引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/inline-functions-under-the-hood-12ddcc0b3a56?source=collection_archive---------0-----------------------#2020-04-01">https://medium.com/androiddevelopers/inline-functions-under-the-hood-12ddcc0b3a56?source=collection_archive---------0-----------------------#2020-04-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7dbdff2f6243de6e06b0425e311eb83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QpP21pn8EmDouGf0jAK_Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="1f0b" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇</h2></div><p id="f312" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你知道你用各种各样的小函数创建的所有那些Util文件，你最终在你的应用程序中使用了很多？如果你的效用函数得到其他函数作为参数，你可以通过保存一些额外的对象分配来提高你的应用程序的性能，你可能甚至不知道你在做什么，用一个关键字:<code class="du kd ke kf kg b"><a class="ae kh" href="https://kotlinlang.org/docs/reference/inline-functions.html" rel="noopener ugc nofollow" target="_blank">inline</a></code>。让我们看看当您传递这些短函数时会发生什么，内联在幕后做什么，以及在使用内联函数时应该注意什么。</p><h1 id="53fd" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">函数调用—在引擎盖下</h1><p id="a875" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">假设您在应用程序中经常使用<code class="du kd ke kf kg b">SharedPreferences</code>，那么您创建这个实用函数来减少每次在您的<code class="du kd ke kf kg b">SharedPreferences</code>中写东西时的样板文件:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="d766" class="ln kj hs kg b fi lo lp l lq lr">fun SharedPreferences.edit(<br/>    commit: Boolean = false,<br/>    action: SharedPreferences.Editor.() -&gt; Unit<br/>) {<br/>    val editor = edit()<br/>    action(editor)<br/>    if (commit) {<br/>        editor.commit()<br/>    } else {<br/>        editor.apply()<br/>    }<br/>}</span></pre><p id="d0d0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，你可以用它来保存一个<code class="du kd ke kf kg b">String</code>令牌:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="f21f" class="ln kj hs kg b fi lo lp l lq lr">private const val KEY_TOKEN = “token”</span><span id="48c6" class="ln kj hs kg b fi ls lp l lq lr">class PreferencesManager(private val preferences: SharedPreferences){<br/>    fun saveToken(token: String) {<br/>        preferences.edit { putString(KEY_TOKEN, token) }<br/>    }<br/>}</span></pre><p id="c28d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在让我们看看当<code class="du kd ke kf kg b">preferences.edit</code>被调用时，在引擎盖下发生了什么。如果我们查看Kotlin字节码(Tools &gt; Kotlin &gt;将Kotlin反编译成Java ),我们会看到调用了一个<code class="du kd ke kf kg b">NEW</code>,因此创建了一个新对象，即使在我们的代码中我们没有调用任何对象构造函数:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="b37d" class="ln kj hs kg b fi lo lp l lq lr">NEW com/example/inlinefun/PreferencesManager$saveToken$1</span></pre><p id="4849" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们检查反编译的代码，使它更友好一些。我们的<code class="du kd ke kf kg b">saveToken</code>反编译函数如下(注释和格式化我的):</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lv lw lx"><p id="2640" class="jh ji ly jj b jk jl it jm jn jo iw jp lz jr js jt ma jv jw jx mb jz ka kb kc ha bi translated">我们创建的每个高阶函数都会导致一个<code class="du kd ke kf kg b">Function</code>对象的创建和内存分配，从而引入运行时开销。</p></blockquote><h1 id="c8f4" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">嵌入式功能—引擎盖下</h1><p id="a338" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">为了提高应用程序的性能，我们可以使用inline关键字来避免创建新的函数对象:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="418e" class="ln kj hs kg b fi lo lp l lq lr"><strong class="kg ht">inline</strong> fun SharedPreferences.edit(<br/>    commit: Boolean = false,<br/>    action: SharedPreferences.Editor.() -&gt; Unit<br/>) { … }</span></pre><p id="d10e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在Kotlin字节码不包含任何<code class="du kd ke kf kg b">NEW</code>调用，下面是我们的<code class="du kd ke kf kg b">saveToken</code>方法的反编译后的java代码(注释和格式化我的):</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="94ee" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为有了<code class="du kd ke kf kg b">inline</code>关键字，编译器将内联函数的内容复制到调用点，避免了创建新的<code class="du kd ke kf kg b">Function</code>对象。</p><h1 id="adf5" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">将什么标记为内嵌</h1><p id="2356" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">⚠️如果你试图将一个不接受另一个函数作为参数的函数标记为内联函数，你不会获得显著的性能优势，IDE甚至会告诉你，建议你删除它:</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/cffbcf08cac160ad4bd0b2a60a64fdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ikDfnUd8BdIh3y48"/></div></div></figure><p id="03b4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">⚠️因为内联可能会导致生成的代码增长，所以请确保您<strong class="jj ht">避免内联大型函数</strong>。例如，如果您查看Kotlin标准库，您会发现大多数内联函数只有1-3行。</p><blockquote class="md"><p id="0e23" class="me mf hs bd mg mh mi mj mk ml mm kc dx translated">⚠️ <strong class="ak">避免内联大型函数！</strong></p></blockquote><p id="b2cf" class="pw-post-body-paragraph jh ji hs jj b jk mn it jm jn mo iw jp jq mp js jt ju mq jw jx jy mr ka kb kc ha bi translated">⚠️当使用内联函数时，你不允许保留对作为参数传递的函数的引用，或者将它传递给不同的函数——你会得到一个编译器错误提示<code class="du kd ke kf kg b">Illegal usage of inline-parameter</code>。</p><p id="6e5d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">例如，让我们修改一下<code class="du kd ke kf kg b">edit</code>方法和<code class="du kd ke kf kg b">saveToken</code>方法。<code class="du kd ke kf kg b">edit</code>方法获取另一个参数，然后传递给不同的函数。<code class="du kd ke kf kg b">saveToken</code>使用在新函数中更新的虚拟变量:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="6681" class="ln kj hs kg b fi lo lp l lq lr">fun myFunction(importantAction: Int.() -&gt; Unit) {<br/>    importantAction(-1)<br/>}</span><span id="3bf6" class="ln kj hs kg b fi ls lp l lq lr">inline fun SharedPreferences.edit(<br/>    commit: Boolean = false,<br/>    <strong class="kg ht">importantAction: Int.() -&gt; Unit = { },</strong><br/>    action: SharedPreferences.Editor.() -&gt; Unit<br/>) {<br/>    <strong class="kg ht">myFunction(importantAction)<br/>    ...</strong><br/>}<br/>...<br/>fun saveToken(token: String) {<br/>    var dummy = 3<br/>    preferences.edit(<strong class="kg ht">importantAction = { dummy = this}</strong>) {<br/>         putString(KEY_TOKEN, token)<br/>    }<br/>}</span></pre><p id="84ce" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们可以看到<code class="du kd ke kf kg b">myFunction(importantAction)</code>产生了一个错误:</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ms"><img src="../Images/f331d56ba78000056828486e54145ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h0ABDsPPmx10ZeKS"/></div></div></figure><p id="7a68" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">下面是解决这个问题的方法，取决于您的函数看起来是什么样的:</p><p id="de48" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">情况1 </strong>:如果你有多个函数作为参数，而你只需要保留对其中一个的引用，那么你可以将其标记为<code class="du kd ke kf kg b"><a class="ae kh" href="https://kotlinlang.org/docs/reference/inline-functions.html#noinline" rel="noopener ugc nofollow" target="_blank">noinline</a></code>。</p><p id="1001" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过使用<code class="du kd ke kf kg b">noinline</code>，编译器将只为那个特定的函数创建一个新的<code class="du kd ke kf kg b">Function</code>对象，但是其余的将被内联。</p><p id="8b85" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们的<code class="du kd ke kf kg b">edit</code>功能现在将是:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="41d3" class="ln kj hs kg b fi lo lp l lq lr">inline fun SharedPreferences.edit(<br/>    commit: Boolean = false,<br/>    <strong class="kg ht">noinline</strong> importantAction: Int.() -&gt; Unit = { },<br/>    action: SharedPreferences.Editor.() -&gt; Unit<br/>) {<br/>    myFunction(importantAction)<br/>    ...<br/>}</span></pre><p id="27ba" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果我们检查字节码，我们会看到出现了一个<code class="du kd ke kf kg b">NEW</code>调用:</p><pre class="lf lg lh li fd lj kg lk ll aw lm bi"><span id="8fa2" class="ln kj hs kg b fi lo lp l lq lr">NEW com/example/inlinefun/PreferencesManager$saveToken$1</span></pre><p id="1f35" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在反编译的代码中，我们可以看到以下内容(我的评论):</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="ad4c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">情况二</strong>:如果你的函数只有一个函数作为参数，干脆不要用<code class="du kd ke kf kg b">inline</code>。如果您确实想使用内联，您必须用<code class="du kd ke kf kg b">noinline</code>标记您的参数，但是像这样，您将通过内联方法获得较低的性能收益。</p></div><div class="ab cl mt mu go mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ha hb hc hd he"><p id="2031" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要减少lambda表达式导致的内存分配，请使用<code class="du kd ke kf kg b">inline</code>关键字！确保您将它应用于将一个<strong class="jj ht">λ作为参数</strong>的<strong class="jj ht">小函数</strong>。如果你需要保存一个对lambda的引用或者将它作为参数传递给另一个函数，那么使用<code class="du kd ke kf kg b">noinline</code>关键字。开始内联开始保存！</p></div></div>    
</body>
</html>