<html>
<head>
<title>7 Steps To Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7步到房间</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/7-steps-to-room-27a5fe5f99b2?source=collection_archive---------2-----------------------#2017-07-07">https://medium.com/androiddevelopers/7-steps-to-room-27a5fe5f99b2?source=collection_archive---------2-----------------------#2017-07-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7e1c4c0c79789eb9ca3210aa5aee7fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhuoTzXc0jJ7mrTrDTj4xw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Take the 7 steps to Room (<a class="ae hu" href="https://unsplash.com/photos/bt-Sc22W-BE" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><div class=""/><p id="3856" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">如何将你的应用迁移到房间的逐步指南</em></p><p id="1b32" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room </a>是一个持久性库，是Android <a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>的一部分。这使得在应用程序中使用SQLiteDatabase对象更加容易，减少了样板代码的数量，并在编译时验证SQL查询。</p><p id="98e9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您是否已经有了一个使用SQLite进行数据持久化的Android项目？如果有，可以把它迁移到房间！让我们来看看如何通过7个简单的步骤，利用一个预先存在的项目并重构它来使用空间。</p><blockquote class="jt ju jv"><p id="259e" class="iu iv js iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated"><strong class="iw hy">TL；DR:更新你的gradle依赖项，创建你的实体、DAO和数据库，用DAO方法调用替换你的SQLiteDatabase调用，测试你创建或修改的所有东西，删除不用的类。就是这样！</strong></p></blockquote></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><p id="ab4b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的<a class="ae hu" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample" rel="noopener ugc nofollow" target="_blank">迁移示例应用程序</a>显示了一个可编辑的用户名，存储在数据库中，作为用户对象的一部分。我们使用产品风格来展示数据层的不同实现:</p><ol class=""><li id="28d6" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated"><strong class="iw hy"> sqlite </strong> —使用sqliteOpenHelper和传统的SQLite接口。</li><li id="9e65" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated"><strong class="iw hy">房间</strong> —用房间代替实施并提供迁移。</li></ol><p id="a607" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每种风格都使用相同的UI层，应用模型-视图-展示者设计模式并使用UserRepository类。</p><p id="b58a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在sqlite版本中，您会看到在<code class="du ku kv kw kx b">UsersDbHelper</code>和<code class="du ku kv kw kx b">LocalUserDataSource</code>类中查询数据库的每个方法中都有大量重复的代码。在ContentValues的帮助下构建查询，并逐列读取由<code class="du ku kv kw kx b">Cursor</code>对象返回的数据。所有这些代码很容易引入微妙的错误，比如忘记在查询中添加一列，或者从数据库数据中错误地构造模型对象。</p><p id="b9bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看Room如何改进我们的代码。最初，我们只是从<code class="du ku kv kw kx b">sqlite</code>版本中复制类，然后逐渐修改它们。</p><h1 id="55df" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤1-更新梯度相关性</h1><p id="da77" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Room的依赖项可以通过Google的新Maven资源库获得，只需将其添加到主build.gradle文件的资源库列表中:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="6149" class="mj kz hx kx b fi mk ml l mm mn">allprojects {<br/>    repositories {<br/>        google()<br/>        jcenter()<br/>    }<br/>}</span></pre><p id="6e94" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在同一文件中定义您的房间库版本。目前，它还处于alpha阶段，但是请关注我们的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/release-notes.html" rel="noopener ugc nofollow" target="_blank">开发者页面</a>获取版本更新。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="5252" class="mj kz hx kx b fi mk ml l mm mn">ext {<br/>   ... <br/>    roomVersion = '1.0.0-alpha4'<br/>}</span></pre><p id="2128" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您的<code class="du ku kv kw kx b">app/build.gradle</code>文件中，添加Room的依赖项。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="c19c" class="mj kz hx kx b fi mk ml l mm mn">dependencies{<br/> …</span><span id="a09a" class="mj kz hx kx b fi mo ml l mm mn">implementation        <br/>   “android.arch.persistence.room:runtime:$rootProject.roomVersion”</span><span id="252e" class="mj kz hx kx b fi mo ml l mm mn">annotationProcessor <br/>   “android.arch.persistence.room:compiler:$rootProject.roomVersion”</span><span id="0287" class="mj kz hx kx b fi mo ml l mm mn">androidTestImplementation <br/>   “android.arch.persistence.room:testing:$rootProject.roomVersion”</span><span id="ccba" class="mj kz hx kx b fi mo ml l mm mn">}</span></pre><p id="0340" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了迁移到Room，我们需要增加数据库版本，为了保存用户数据，我们需要实现一个<code class="du ku kv kw kx b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html" rel="noopener ugc nofollow" target="_blank">Migration</a></code>类。为了<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html#db-migration" rel="noopener ugc nofollow" target="_blank">测试迁移</a>，我们需要导出模式。为此，将以下内容添加到您的<code class="du ku kv kw kx b">app/build.gradle</code>文件中:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="ed48" class="mj kz hx kx b fi mk ml l mm mn">android {<br/>    defaultConfig {<br/>        ...<br/>       // used by Room, to test migrations<br/>        javaCompileOptions {<br/>            annotationProcessorOptions {<br/>                arguments = ["room.schemaLocation": <br/>                                 "$projectDir/schemas".toString()]<br/>            }<br/>        }<br/>    }<br/><br/>    // used by Room, to test migrations<br/>    sourceSets {<br/>        androidTest.assets.srcDirs += <br/>                           files("$projectDir/schemas".toString())<br/>    }<br/>...</span></pre><h1 id="5ee9" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤2-将模型类更新为实体</h1><p id="3720" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Room为每个标注了<code class="du ku kv kw kx b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Entity.html" rel="noopener ugc nofollow" target="_blank">@Entity</a></code>的类创建一个表；类中的字段对应于表中的列。因此，实体类往往是不包含任何逻辑的小型模型类。我们的<code class="du ku kv kw kx b">User</code>类表示数据库中数据的模型。所以让我们更新它，告诉Room它应该基于这个类创建一个表:</p><ul class=""><li id="34fe" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr mp km kn ko bi translated">用<code class="du ku kv kw kx b">@Entity</code>注释该类，并使用<code class="du ku kv kw kx b">tableName</code>属性设置表的名称。</li><li id="41a2" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr mp km kn ko bi translated">通过向正确的字段添加<code class="du ku kv kw kx b">@PrimaryKey</code>注释来设置主键——在我们的例子中，这是用户的ID。</li><li id="f675" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr mp km kn ko bi translated">使用<code class="du ku kv kw kx b">@ColumnInfo(name = “column_name”)</code>注释设置类字段的列名。如果您的字段已经有了正确的列名，请随意跳过这一步。</li><li id="c589" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr mp km kn ko bi translated">如果有多个合适的构造函数，添加<code class="du ku kv kw kx b">@Ignore</code>注释来告诉Room哪些应该使用，哪些不应该使用。</li></ul><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="458d" class="mj kz hx kx b fi mk ml l mm mn">@Entity(tableName = "users")<br/>public class User {<br/><br/>    @PrimaryKey<br/>    @ColumnInfo(name = "userid")<br/>    private String mId;<br/><br/>    @ColumnInfo(name = "username")<br/>    private String mUserName;<br/><br/>    @ColumnInfo(name = "last_update")<br/>    private Date mDate;<br/><br/>    @Ignore<br/>    public User(String userName) {<br/>        mId = UUID.<em class="js">randomUUID</em>().toString();<br/>        mUserName = userName;<br/>        mDate = new Date(System.<em class="js">currentTimeMillis</em>());<br/>    }<br/><br/>    public User(String id, String userName, Date date) {<br/>        this.mId = id;<br/>        this.mUserName = userName;<br/>        this.mDate = date;<br/>    }<br/>...<br/>}</span></pre><p id="468c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意:</strong>为了实现无缝迁移，请密切注意初始实现中的表和列名，并确保在<code class="du ku kv kw kx b">@Entity</code>和<code class="du ku kv kw kx b">@ColumnInfo</code>注释中正确设置它们。</p><h1 id="1170" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤3 —创建数据访问对象(Dao)</h1><p id="0ef9" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Dao负责定义访问数据库的方法。在我们项目的初始SQLite实现中，所有对数据库的查询都是在<code class="du ku kv kw kx b">LocalUserDataSource</code>文件中完成的，在这里我们使用的是<code class="du ku kv kw kx b">Cursor</code>对象。有了Room，我们不需要所有与<code class="du ku kv kw kx b">Cursor</code>相关的代码，可以简单地使用<code class="du ku kv kw kx b">UserDao</code>类中的注释定义我们的查询。</p><p id="bbdc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，当查询所有用户的数据库时，Room会做所有的“繁重”工作，我们只需要编写:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="b1c0" class="mj kz hx kx b fi mk ml l mm mn">@Query(“SELECT * FROM Users”)<br/>List&lt;User&gt; getUsers();</span></pre><h1 id="dc14" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤4 —创建数据库</h1><p id="3a33" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">到目前为止，我们已经定义了我们的<code class="du ku kv kw kx b">Users</code>表及其相应的查询，但是我们还没有创建将这些空间的其他部分集合在一起的数据库。为此，我们需要定义一个扩展<code class="du ku kv kw kx b">RoomDatabase</code>的抽象类。这个类用<code class="du ku kv kw kx b">@Database</code>进行了注释，列出了数据库中包含的实体，以及访问它们的Dao。数据库版本必须从初始值增加1，所以在我们的例子中，它将是2。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="7432" class="mj kz hx kx b fi mk ml l mm mn">@Database(entities = {User.class}, version = 2)<br/>@TypeConverters(DateConverter.class)<br/>public abstract class UsersDatabase extends RoomDatabase {<br/><br/>    private static UsersDatabase <em class="js">INSTANCE</em>;<br/><br/>    public abstract UserDao userDao();</span></pre><p id="fd18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们想要保存用户数据，所以我们需要实现一个<code class="du ku kv kw kx b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html" rel="noopener ugc nofollow" target="_blank">Migration</a></code>类，告诉Room从版本1迁移到版本2时应该做什么。在我们的例子中，因为数据库模式没有改变，所以我们将只提供一个空的实现:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="6399" class="mj kz hx kx b fi mk ml l mm mn">static final Migration <em class="js">MIGRATION_1_2 </em>= new Migration(1, 2) {<br/>    @Override<br/>    public void migrate(SupportSQLiteDatabase database) {<br/>// Since we didn't alter the table, there's nothing else to do here.<br/>    }<br/>};</span></pre><p id="de7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du ku kv kw kx b">UsersDatabase</code>类中创建数据库对象，定义数据库名称和迁移:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="246e" class="mj kz hx kx b fi mk ml l mm mn">database = Room.<em class="js">databaseBuilder</em>(context.getApplicationContext(),<br/>        UsersDatabase.class, "Sample.db")<br/>        .addMigrations(<em class="js">MIGRATION_1_2</em>)<br/>        .build();</span></pre><p id="17e9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解更多关于如何实现数据库迁移以及它们如何在幕后工作的信息，请查看这篇文章:</p><div class="hg hh ez fb hi mq"><a rel="noopener follow" target="_blank" href="/google-developers/understanding-migrations-with-room-f01e04b07929"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hy fi z dy mv ea eb mw ed ef hw bi translated">了解迁移与空间</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">用SQLite API执行数据库迁移总是让我感觉像是在拆除一颗炸弹——好像我就是一颗…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ho mq"/></div></div></a></div><h1 id="de44" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤5 —更新存储库以使用空间</h1><p id="1f59" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">我们已经创建了数据库、<code class="du ku kv kw kx b">Users</code>表和查询，现在是时候使用它们了！在这一步中，我们将更新<code class="du ku kv kw kx b">LocalUserDataSource</code>类来使用<code class="du ku kv kw kx b">UserDao</code>方法。为此，我们将首先通过移除<code class="du ku kv kw kx b">Context</code>并添加<code class="du ku kv kw kx b">UserDao</code>来更新构造函数。当然，任何实例化<code class="du ku kv kw kx b">LocalUserDataSource</code>的类也需要更新。</p><p id="8eb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其次，我们将通过调用<code class="du ku kv kw kx b">UserDao</code>方法来更新查询数据库的<code class="du ku kv kw kx b">LocalUserDataSource</code>方法。例如，获取所有用户的方法现在如下所示:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="8288" class="mj kz hx kx b fi mk ml l mm mn">public List&lt;User&gt; getUsers() {<br/>   return mUserDao.getUsers();<br/>}</span></pre><p id="39d4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在:运行时间！</p><p id="ef5e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Room最好的特性之一是，如果您在主线程上执行数据库操作，您的应用程序将会崩溃，并显示以下异常消息:</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="f90c" class="mj kz hx kx b fi mk ml l mm mn">java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.</span></pre><p id="ef1b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将I/O操作移出主线程的一个可靠方法是为每个数据库查询创建一个新的在单线程<code class="du ku kv kw kx b">Executor</code>上运行的<code class="du ku kv kw kx b">Runnable</code>。因为我们已经在<code class="du ku kv kw kx b">sqlite</code>风格中使用了这种方法，所以不需要任何改变。</p><h1 id="e023" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤6 —设备上测试</h1><p id="d1d3" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">我们创建了新的类— <code class="du ku kv kw kx b">UserDao</code>和<code class="du ku kv kw kx b">UsersDatabase</code>，并修改了我们的<code class="du ku kv kw kx b">LocalUserDataSource</code>来使用房间数据库。现在，我们需要测试他们！</p><h2 id="e479" class="mj kz hx bd la nf ng nh le ni nj nk li jf nl nm lm jj nn no lq jn np nq lu nr bi translated"><strong class="ak">测试</strong> <code class="du ku kv kw kx b"><strong class="ak">UserDao</strong></code></h2><p id="1f39" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">为了测试<code class="du ku kv kw kx b">UserDao</code>，我们需要创建一个<code class="du ku kv kw kx b">AndroidJUnit4</code>测试类。Room的一个令人惊叹的特性是它能够创建一个内存数据库。这避免了在每个测试用例之后清理的需要。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="6b7e" class="mj kz hx kx b fi mk ml l mm mn">@Before<br/>public void initDb() throws Exception {<br/>    mDatabase = Room.inMemoryDatabaseBuilder(<br/>                           InstrumentationRegistry.getContext(),<br/>                           UsersDatabase.class)<br/>                    .build();<br/>}</span></pre><p id="e35c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还需要确保在每次测试后关闭数据库连接。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="c498" class="mj kz hx kx b fi mk ml l mm mn">@After<br/>public void closeDb() throws Exception {<br/>    mDatabase.close();<br/>}</span></pre><p id="a433" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，为了测试一个<code class="du ku kv kw kx b">User</code>的插入，我们将插入用户，然后我们将检查我们确实可以从数据库中获得那个<code class="du ku kv kw kx b">User</code>。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="64ad" class="mj kz hx kx b fi mk ml l mm mn">@Test<br/>public void insertAndGetUser() {<br/>    // When inserting a new user in the data source<br/>    mDatabase.userDao().insertUser(<em class="js">USER</em>);<br/><br/>    //The user can be retrieved<br/>    List&lt;User&gt; users = mDatabase.userDao().getUsers();<br/>    <em class="js">assertThat</em>(users.size(), <em class="js">is</em>(1));<br/>    User dbUser = users.get(0);<br/>    <em class="js">assertEquals</em>(dbUser.getId(), <em class="js">USER</em>.getId());<br/>    <em class="js">assertEquals</em>(dbUser.getUserName(), <em class="js">USER</em>.getUserName());<br/>}</span></pre><h2 id="c917" class="mj kz hx bd la nf ng nh le ni nj nk li jf nl nm lm jj nn no lq jn np nq lu nr bi translated"><strong class="ak">测试LocalUserDataSource </strong>中 <code class="du ku kv kw kx b"><strong class="ak">UserDao</strong></code> <strong class="ak">的用法</strong></h2><p id="d3c0" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">确保<code class="du ku kv kw kx b">LocalUserDataSource</code>仍然正常工作是很容易的，因为我们已经测试了这个类的行为。我们需要做的就是创建一个内存数据库，从中获取一个<code class="du ku kv kw kx b">UserDao</code>对象，并将其用作<code class="du ku kv kw kx b">LocalUserDataSource</code>构造函数的参数。</p><pre class="mb mc md me fd mf kx mg mh aw mi bi"><span id="5dbd" class="mj kz hx kx b fi mk ml l mm mn">@Before<br/>public void initDb() throws Exception {<br/>    mDatabase = Room.inMemoryDatabaseBuilder(<br/>                           InstrumentationRegistry.getContext(),<br/>                           UsersDatabase.class)<br/>                    .build();<br/>    mDataSource = new LocalUserDataSource(mDatabase.userDao());<br/>}</span></pre><p id="c0c7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，我们需要确保在每次测试后都关闭数据库。</p><h2 id="f214" class="mj kz hx bd la nf ng nh le ni nj nk li jf nl nm lm jj nn no lq jn np nq lu nr bi translated"><strong class="ak">测试数据库迁移</strong></h2><p id="b174" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">在这篇博文中，我们详细讨论了如何实现数据库迁移测试，并解释了<code class="du ku kv kw kx b">MigrationTestHelper</code>的工作原理:</p><div class="hg hh ez fb hi mq"><a rel="noopener follow" target="_blank" href="/google-developers/testing-room-migrations-be93cdb0d975"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hy fi z dy mv ea eb mw ed ef hw bi translated">测试室迁移</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">在之前的一篇文章中，我解释了带房间的数据库迁移是如何工作的。我们看到一个不正确的…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="ns l nb nc nd mz ne ho mq"/></div></div></a></div><p id="248b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看来自<a class="ae hu" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample" rel="noopener ugc nofollow" target="_blank">迁移示例应用</a>的代码，获取更广泛的示例。</p><h1 id="e501" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第7步—清理</h1><p id="872c" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">删除任何未使用的类或代码行，这些类或代码行现在被房间功能所取代。在我们的项目中，我们只需删除<code class="du ku kv kw kx b">UsersDbHelper</code>类，这是对<code class="du ku kv kw kx b">SQLiteOpenHelper</code>类的扩展。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><p id="1edd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> I </strong>如果您有一个更大、更复杂的数据库，并且您想要增量迁移到Room，以下是方法:</p><div class="hg hh ez fb hi mq"><a rel="noopener follow" target="_blank" href="/google-developers/incrementally-migrate-from-sqlite-to-room-66c2f655b377"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hy fi z dy mv ea eb mw ed ef hw bi translated">从SQLite到Room的增量迁移</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">将您复杂的数据库迁移到具有可管理PRs的房间。</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="nt l nb nc nd mz ne ho mq"/></div></div></a></div></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><p id="de16" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">样板文件、易错代码的数量减少了，查询现在在编译时被检查，一切都是可测试的。通过7个简单的步骤，我们能够将现有应用迁移到Room。点击查看示例应用<a class="ae hu" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample" rel="noopener ugc nofollow" target="_blank">。请在下面的评论中告诉我们你的房间迁移进展如何。</a></p></div></div>    
</body>
</html>