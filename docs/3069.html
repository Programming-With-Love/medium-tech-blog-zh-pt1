<html>
<head>
<title>Fibonacci Series In C Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C程序设计中的斐波那契数列</h1>
<blockquote>原文：<a href="https://medium.com/edureka/fibonacci-series-in-c-3207f0f57eb6?source=collection_archive---------2-----------------------#2019-07-15">https://medium.com/edureka/fibonacci-series-in-c-3207f0f57eb6?source=collection_archive---------2-----------------------#2019-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/87276773d07af677dfe6aca5d741bf23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*hO8nWObZ4Z7xx3Z41AwzEg.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Fibonacci Series in C — Edureka</figcaption></figure><p id="27f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你作为一个程序员参加过面试，你会知道有很多C编程面试可能会问一个为斐波那契数列创建程序的问题。这个看似简单的棘手问题困扰着许多人。在本文中，我们将讨论如何在c中实现斐波那契数列。</p><ul class=""><li id="0986" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">斐波纳契级数</li><li id="d733" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">斐波那契数列，直到用户输入数字</li><li id="f5ed" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用递归的斐波那契数列</li></ul><p id="1643" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么让我们开始吧，</p><h1 id="1d3d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">C语言中的斐波那契数列</h1><p id="af26" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">斐波那契数列是数列中前面两个数相加形成的数列。前两项分别为0和1。这之后的项是通过简单地将前两项相加而生成的。</p><p id="3eb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有两种方法可以编写斐波那契数列程序:</p><ul class=""><li id="53bc" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">无递归的斐波那契数列</li><li id="61c2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用递归的斐波那契数列</li></ul><h1 id="fdd8" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">斐波那契怎么算？</h1><p id="3563" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">斐波纳契数列是一系列数字:0，1，1，2，3，5，8，13，21，34，…</p><p id="2bb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一个数字是通过将它前面的两个数字相加得到的:</p><ul class=""><li id="d553" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">2的计算方法是将它前面的两个数相加(1+1)，</li><li id="5a48" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">3是通过将它前面的两个数相加(1+2)来计算的，</li><li id="0e48" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">5是(2+3)，以此类推...</li></ul><p id="b2c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个斐波那契数列的例子:0，1，1，2，3，5，8，13等等。</p><p id="a312" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，0和1是数列的前两项。这两个术语是直接打印的。第三项是由前两项相加而成的。在这种情况下是0和1。所以，我们得到0+1=1。因此，1被打印为第三项。通过使用第二和第三项而不使用第一项来生成下一项。这样做，直到你想要的或用户要求的条款的数量。在上面的例子中，我们使用了八个术语。</p><p id="7e19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个c程序:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="31dc" class="ln kc hh lj b fi lo lp l lq lr">#include&lt;stdio.h&gt;<br/>int main()<br/>{<br/>int first=0, second=1, i, n, sum=0;<br/>printf("Enter the number of terms: ");<br/>scanf("%d",&amp;n); //accepting the terms<br/>printf("Fibonacci Series:");<br/>for(i=0 ; i&lt;n ; i++)<br/>{<br/>if(i &lt;= 1)<br/>{ sum=i;<br/>} //to print 0 and 1<br/>else<br/>{<br/>sum=first + second;<br/>first=second;<br/>second=sum;<br/>//to calculate the remaining terms.<br/>//value of first and second changes as new term is printed.<br/>}<br/>printf(" %d",sum)<br/>}<br/>return 0;<br/>}</span></pre><p id="2849" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">输出:</strong></p><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/7d7b439cf8bbaabf84e093478be8e84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/0*PPB1RhPddIw3QPF-.png"/></div></figure><p id="4f0d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的程序中，我们首先声明所有的变量。首先，我们设置第一个和第二个变量的值，这些变量将用于生成更多的项。接下来，我们声明n项，它将保存项数。我们有一个术语来表示两位数的和，叫做sum。最后一项是I，用于a循环中的迭代。</p><p id="cd09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们接受来自用户的术语数，并将其存储在n中。然后我们有一个for循环，从0一直运行到用户请求的术语数，即n。</p><p id="1d14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在for循环中，我们首先有一个if语句，条件是检查I的值是否小于1。如果是零，则打印一个，这取决于术语的数量。当有两个以上的术语时，它用于打印首字母0和1。</p><p id="6a6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果项数大于1，则执行循环的else部分。在这部分中，变量first和second的相加被赋给变量sum。下一项是和变量。例如，将值为0和1的第一个和第二个相加，得到的和值为1。</p><p id="d0d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下一部分中，我们将第二项的值赋给第一项，然后将和的值赋给第二项。这样做是因为对于下一个术语，随着新值的打印，前面的两个值被改变。这是总值。如果我们考虑将0和1分配给第一个和第二个，在这个步骤之后，第一个的值将是1，第二个的值也将是1，因为sum的值是1。</p><p id="160b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">退出else部分后，我们打印sum值。这一直执行到I的值等于n，循环中断，我们退出程序。</p><p id="db4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们继续阅读C #文章中的斐波那契数列，看看还能做些什么，</p><h1 id="0c8d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">斐波那契数列，直到用户输入数字</h1><p id="f2f8" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated"><strong class="ir hi">代码:</strong></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="5525" class="ln kc hh lj b fi lo lp l lq lr">#include &lt;stdio.h&gt;<br/>int main()<br/>{<br/>int first = 0, second = 1, sum = 0, n;<br/>printf("Enter the end term for the series: ");<br/>scanf("%d", &amp;n);<br/>printf("Fibonacci Series: %d, %d, ", first, second);<br/>sum = first + second;<br/>while(sum &lt;= n)<br/>{<br/>printf("%d, ",sum); <br/>irst = second;<br/>second = sum;<br/>sum = first + second;<br/>}<br/>return 0;<br/>}</span></pre><p id="68b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">输出:</strong></p><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/8a08459420e407ef2151202cbd40b777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*zA7xmiJwK5qaSntacRZU8w.png"/></div></figure><p id="dba9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个程序中，我们从用户那里得到最终术语。我们必须显示一个斐波纳契数列直到这个数字。这是通过使用while循环来完成的。我们接受用户的输入，这是最后一项。然后打印第一项和第二项。在此之后，将第一个和第二个相加，存储在sum中。然后，有一个while循环。它一直运行到总和的值小于用户输入的数字的值。在while循环中，首先打印出总和。</p><p id="ca58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下一部分中，我们将第二项的值赋给第一项，然后将sum的值赋给第二项。我们再次执行加法，将第一项和第二项相加，并将其赋值为总和。循环运行，直到总和值大于用户输入的数字。</p><h1 id="d8e8" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">10的斐波那契数列是多少？</h1><p id="e57c" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">斐波纳契数列是通过将前两个数字相加得到下一个数字来实现的，从0和1开始:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="4e67" class="ln kc hh lj b fi lo lp l lq lr">#include &lt;iostream&gt;<br/>using namespace std;<br/>int main ()<br/>{<br/>int a = 0, b = 1;<br/>cout &lt;&lt; a &lt;&lt; ", " &lt;&lt; b;<br/>for (int i = 0; i &lt; 8; i++)<br/>{<br/>cout &lt;&lt; ", " &lt;&lt; a + b;<br/>b = a + b; // b is the sum of the 2 numbers<br/>a= b - a; // a is the old y<br/>}<br/>}</span></pre><h1 id="0e2d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">0是斐波那契数吗？</h1><p id="7980" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">没错，斐波那契数列就是数列:<br/> 0，1，1，2，3，5，8，13，21，34，…</p><p id="79a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们继续讨论C语言文章中斐波纳契数列的最后一点。</p><h1 id="b15d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">斐波那契数列使用递归</strong></h1><p id="4a5c" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">另一种编程斐波那契数列生成的方法是使用递归。递归是以自相似的方式重复项目的过程。在编程语言中，如果一个程序允许你在同一个函数中调用一个函数，那么它就被称为该函数的递归调用。</p><p id="b31e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">代码:</strong></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="667b" class="ln kc hh lj b fi lo lp l lq lr">#include&lt;stdio.h&gt;<br/>int f(int);<br/>int main()<br/>{<br/>int n, m= 0, i;<br/>printf("Enter Total terms:n");<br/>scanf("%d", &amp;n);<br/>printf("Fibonacci series terms are:n");<br/>for(i = 1; i &lt;= n; i++)<br/>{<br/>printf("%dn", fibonacci(m));<br/>m++;<br/>}<br/>return 0;<br/>}<br/>int fibonacci(int n)<br/>{<br/>if(n == 0 || n == 1)<br/>return n;<br/>else<br/>return(fibonacci(n-1) + fibonacci(n-2));<br/>}</span></pre><p id="719d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">输出:</strong></p><figure class="le lf lg lh fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/3af6cda471fa1bbe6bb0dd2690581945.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*D9vI5Ij-p99Mu3HTmjfL5A.png"/></div></figure><p id="1eba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个程序中，我们使用递归来生成斐波那契数列。函数Fibonacci被递归调用，直到我们得到输出。在函数中，我们首先检查数字n是零还是一。如果是，我们返回n的值。如果不是，我们用值n-1和n-2递归调用Fibonacci。</p><p id="dc79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae lv" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=fibonacci-series-in-c" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><blockquote class="lw lx ly"><p id="a776" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">1.<a class="ae lv" rel="noopener" href="/edureka/basic-structure-of-c-program-ed3bf9c72632">C程序的基本结构</a></p><p id="df2b" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">2.<a class="ae lv" rel="noopener" href="/edureka/c-program-quadratic-equation-1483f6a182af"> C程序求一个二次方程的根</a></p><p id="d2d3" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">3.<a class="ae lv" rel="noopener" href="/edureka/compile-c-program-in-command-prompt-e6cd3ce11d8e">如何在命令提示符下编译C程序</a></p><p id="ec95" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">4.<a class="ae lv" rel="noopener" href="/edureka/c-programming-tutorial-36bc0380175f"> C编程教程</a></p></blockquote></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="78fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lz">原载于2019年7月15日</em><a class="ae lv" href="https://www.edureka.co/blog/fibonacci-series-in-c/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://www.edureka.co</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>