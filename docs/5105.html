<html>
<head>
<title>Unique Foreign Keys and Concurrency: Mendix and Me</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">唯一外键和并发性:Mendix和我</h1>
<blockquote>原文：<a href="https://medium.com/mendix/unique-foreign-keys-and-concurrency-mendix-and-me-3f30c10b7898?source=collection_archive---------1-----------------------#2021-03-31">https://medium.com/mendix/unique-foreign-keys-and-concurrency-mendix-and-me-3f30c10b7898?source=collection_archive---------1-----------------------#2021-03-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9fa677290871a74369cf3706ee9bbcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bY4qcX5WakV9hst4hyAcYA.png"/></div></div></figure><div class=""/><h1 id="8210" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">尽管Mendix通过域模型管理关系，并且您通常不会接触到键和外键，但很可能您会到达需要它们的时候。典型的例子是避免跨模块关联，或者避免从第三方系统接收数据并希望在本地缓存。</h1><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ka"><img src="../Images/e93329d05173648e16b3515ab7712bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAvrisdOx5qs_oQAx3f2vA.png"/></div></div></figure><p id="7ebe" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">在许多情况下，一个密钥只需要存在一次。例如，如果从外部系统同步记录，您希望避免多次存储同一记录。一种简单而有效的方法是使用CreateOrRetrieveIfExisting模式。</p><p id="4c30" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">让我们来看看下面的数据集:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/1789cc747d07ca604b39afa1610b8ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/0*pVMa1Zx5kZcjRCDp"/></div></figure><p id="b891" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">标识符属性是唯一键。如果需要具有某个键的记录，可以对现有记录使用CreateOrRetrieveIfExisting微流，或者，如果没有这样的记录，则创建一个新记录。这用于事件驱动系统，其中另一个系统中的事件创建或更改必须保持同步的记录。相应的微流现在看起来如下:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/6bd9b0a5c63fa3f6e3f8033fff108907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VSUOh1KuYcfeC6CV"/></div></div></figure><p id="02df" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">对于给定的标识符，系统现在从数据库中搜索数据记录，并在必要时创建它。这样，您可以确保总是获得一条记录，并且一条记录只存在一次。</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff le"><img src="../Images/6dce5a2e86ec59d3ed0aa6627062ee68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEVX4H5BL_VBX3sHpw_smw.png"/></div></div><figcaption class="lf lg fg fe ff lh li bd b be z ek"><a class="ae lj" href="https://bit.ly/MXW21" rel="noopener ugc nofollow" target="_blank">https://bit.ly/MXW21</a></figcaption></figure><h1 id="cb82" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">问题是:并发性</h1><p id="bc8c" class="pw-post-body-paragraph kf kg if bd b kh lk kj kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb hn dt translated">这种模式运行良好，但是有一个问题:它不能处理并发性。尤其是(但不仅仅是)使用事件驱动的架构，短时间内可能会有几个事件都引用同一个记录。如果记录已经存在，这不是问题。然而，如果它在这个时间点不存在，那么正在运行的几个进程对彼此一无所知。这些进程都无法在数据库中找到该对象，因为此时其他进程的事务尚未完成。如果流程运行时间很长，这尤其危险。结果是这些过程中的每一个都重新创建记录，结果是该记录在数据库中存在多次。</p><h1 id="878a" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">解决方案:数据库级验证和重试机制</h1><p id="2eb4" class="pw-post-body-paragraph kf kg if bd b kh lk kj kk kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb hn dt translated">首先，我们需要在数据库中创建一个惟一的约束。幸运的是，使用Mendix域模型可以很容易地做到这一点。为此，我们为标识符创建一个验证规则，如下所示:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/1448786716f2494dba67597fe5bf807d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V3cEaumHxM7qjzAK"/></div></div></figure><p id="f942" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">数据库现在不允许相同的值存在多次。如果您尝试提交一个已经使用了标识符的对象，就会引发异常。</p><p id="1afd" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">当然，我们不希望我们的进程因异常而终止。理想情况下，我们希望在产生问题时就已经知道了。为此，CreateOrRetrieveIfExisting微流可以被修改如下:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/9c032065b392507c89ae558da14b4bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lFMdzICYHQf-oFbv"/></div></div></figure><p id="a6ce" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">对象现在在创建时直接保存。这导致了一个事实，即存在一个数据库锁，如果有必要，其他进程必须等待第一个进程结束。如果结果是第一个进程已经创建了对象，那么create操作会抛出一个异常。</p><p id="e915" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">现在，我们一发现问题就知道有问题了。然而，如果我们的进程能够成功地继续，而不是因为一个异常而终止，那就更方便了。如果我们将错误处理与重试机制相结合来扩展微流，我们就可以实现这种舒适。</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ld"><img src="../Images/bd39a1412e19cf76c4484081a9426ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*psyyqL6ZHjGn2jJt"/></div></div></figure><p id="165a" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">IsRetry变量是一个布尔值，它用“false”初始化，并在出错时更改为“true”。这确保重试仅尝试一次。这个问题就更没必要了。</p><p id="a95f" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">如果第一个进程现在结束了它的事务，那么在其他进程的创建操作中就会抛出一个异常。这是通过从头开始再次启动微流来处理的。由于第一个流程的事务已经完成，现在可以在数据库中找到数据集，并且可以使用了。如果并行创建不同的数据集，并行性仍然存在。如果它涉及相同的数据记录，那么对于第一个创建进程(如果必要的话),等待第一个进程被锁定的事实。因此，这些查询被串行处理，而在进一步的过程中，并行性再次给出。</p><p id="4662" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">希望这篇文章有帮助。一如既往，我很高兴听到任何反馈。</p></div><div class="ab cl lp lq hb lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><p id="068a" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated"><em class="lw">2021年3月31日于</em><a class="ae lj" href="https://mendixandme.de/index.php/2021/03/31/eindeutige-fremdschluessel-und-parallelitaet/" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://mendixamme . de</em></a><em class="lw">原文为德文。</em></p></div><div class="ab cl lp lq hb lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hn ho hp hq hr"><p id="d40c" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated"><em class="lw">来自发布者- </em></p><p id="bb75" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated"><em class="lw">如果你喜欢这篇文章，你可以在我们的</em> <a class="ae lj" href="https://medium.com/mendix" rel="noopener"> <em class="lw">媒体页面</em> </a> <em class="lw">或我们自己的</em> <a class="ae lj" href="https://developers.mendix.com/community-blog/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">社区博客网站</em> </a> <em class="lw">找到更多类似的内容。</em></p><p id="a36f" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated"><em class="lw">希望入门的创客，可以注册一个</em> <a class="ae lj" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="lw">免费账号</em> </a> <em class="lw">，通过我们的</em> <a class="ae lj" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="lw">学苑</em> </a> <em class="lw">获得即时学习权限。</em></p><p id="2f10" class="pw-post-body-paragraph kf kg if bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">有兴趣加入我们的社区吗？你可以加入我们的 <a class="ae lj" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> Slack社区频道</em> </a> <em class="lw">或者想更多参与的人，看看加入我们的</em><a class="ae lj" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"><em class="lw">Meet ups</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>