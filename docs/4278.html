<html>
<head>
<title>Exploring Jetpack Compose: TopAppBar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Jetpack撰写:TopAppBar</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-jetpack-compose-topappbar-c8b79893be34?source=collection_archive---------0-----------------------#2020-02-19">https://medium.com/google-developer-experts/exploring-jetpack-compose-topappbar-c8b79893be34?source=collection_archive---------0-----------------------#2020-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/44a5111182d1efbc185c6513c47d2c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zswjo9-DxXdbWRbtnF1h6A.png"/></div></div></figure><blockquote class="ip iq ir"><p id="76cb" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这篇文章最初发布于<a class="ae jr" href="https://joebirch.co/" rel="noopener ugc nofollow" target="_blank">joebirch.co</a></p></blockquote><p id="7747" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们应用程序的许多屏幕中，我们很可能在Android应用程序中使用工具栏/应用程序栏。当使用Jetpack Compose构建应用程序时，我们将需要重新创建这个组件。在本文中，我们将看看<a class="ae jr" href="https://material.io/develop/android/components/app-bar-layout/" rel="noopener ugc nofollow" target="_blank">顶部应用程序栏</a>组件，它允许我们这样做。</p><p id="412f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果你想通过这个媒介了解顶级应用程序栏，这篇博文有一个支持视频:</p><figure class="jv jw jx jy fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="070e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">TopAppBar组件通常用作我们屏幕的标题——显示导航标题以及菜单组件或我们应用程序设计所需的任何其他装饰。在Jetpack Compose中，可以通过两个不同的函数创建该组件。第一个有三个参数:</p><ul class=""><li id="12bd" class="kb kc hh iv b iw ix ja jb js kd jt ke ju kf jq kg kh ki kj bi translated"><strong class="iv hi">标题</strong> —在应用程序栏中显示的标题。这是<strong class="iv hi">所要求的</strong></li><li id="adb5" class="kb kc hh iv b iw kk ja kl js km jt kn ju ko jq kg kh ki kj bi translated"><strong class="iv hi">颜色</strong> —用于工具栏背景的颜色。可选，如果没有提供，那么将使用主题原色。</li><li id="70df" class="kb kc hh iv b iw kk ja kl js km jt kn ju ko jq kg kh ki kj bi translated"><strong class="iv hi">导航图标</strong> —显示在应用程序栏开始处的图标</li></ul><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="8234" class="ku kv hh kq b fi kw kx l ky kz">@Composable<br/>fun TopAppBar(<br/>    title: @Composable() () -&gt; Unit,<br/>    color: Color = MaterialTheme.colors().primary,<br/>    navigationIcon: @Composable() (() -&gt; Unit)? = null<br/>)</span></pre><p id="168f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">让我们来看一下如何构建我们自己的TopAppBar——如上所述，我们必须至少提供一个标题来这样做:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="e302" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar(<br/>    title = { Text(text = "AppBar") }<br/>)</span></pre><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es la"><img src="../Images/9f2feb5bcb4d676832d5dd061d16107c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xB1uuMvAoxQ0wmwY"/></div></div></figure><p id="6121" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">您可能从上面注意到，这个标题使用了@Composable引用，这意味着我们不仅仅局限于文本组件。也许我们想在AppBar中显示某种形式的装饰或自定义组件。例如，我们可以显示由多个子组件组成的行。虽然您可能不需要做下面的事情，但这只是一个简单的例子:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="6163" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar(<br/>    title = { <br/>        Row(children = {<br/>            Text(text = "AppBar")<br/>            Text(text = " With another child")<br/>        })<br/>    }<br/>)</span></pre><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/8c4ee898eba90347f5ab71b4f144b98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*al0c-CREbk7xvxQI"/></div></div></figure></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="d0a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">虽然TopAppBar使用了我们主题的主要颜色，但是在某些情况下我们可能想要改变颜色。我们可以通过为颜色参数提供一个颜色参考来实现这一点:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="f3b0" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar(<br/>    title = { Text(text = "AppBar") },<br/>    color = Color.White<br/>)</span></pre><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/2e18de5bc8794e075cfa2906bfb2586f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DuXYC84SbZXCIinQ"/></div></div></figure><p id="e76a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">事实上，我们的顶部应用程序栏看起来很棒！然而，我们用来组成TopAppBar的函数也允许我们提供一个navigationIcon，显示在工具栏的开始，标题之前。这里我们可以传递一个AppBarIcon实例形式的导航图标。</p><p id="d4dc" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">AppBarIcon是一个可组合的组件，包含一个带有内置涟漪效果的可点击容器，托管我们提供的图像。除了图像之外，还提供了一个onClick处理程序，这样我们就可以对图标上的单击事件做出反应。我们不会在这里处理这个问题，因为它超出了本文的范围。</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="2fa1" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar(<br/>    title = { Text(text = "AppBar") },<br/>    color = Color.White,<br/>    navigationIcon = {<br/>        AppBarIcon(<br/>            icon = imageResource(<br/>                id = R.drawable.ic_menu_black_24dp)<br/>            ) {<br/>                // Open nav drawer<br/>            }<br/>    }<br/>)</span></pre><figure class="jv jw jx jy fd ii er es paragraph-image"><div class="er es lk"><img src="../Images/a12539ec094637709b292f33d9082a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/0*BxPs6yxN-oZNAlKi"/></div></figure><p id="d675" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这个AppBarIcon为我们处理图标的大小，使用应用程序栏图标的预定义直径。虽然我们可以自己完成这项工作，但这个方便的助手composable会从我们这里接手一些工作。</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="1312" class="ku kv hh kq b fi kw kx l ky kz">Container(width = ActionIconDiameter, height = ActionIconDiameter) {<br/>    Ripple(bounded = false) {<br/>        Clickable(onClick = onClick) {<br/>            SimpleImage(icon)<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="9f66" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">通过以上操作，我们已经能够创建一个简单的TopAppBar，它包含我们希望显示的标题，以及一个导航图标。然而，在某些情况下，我们会希望在我们的TopAppBar中显示操作——这就是TopAppBar的第二个可组合方法出现的地方:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="304d" class="ku kv hh kq b fi kw kx l ky kz">@Composable<br/>fun &lt;T&gt; TopAppBar(<br/>    title: @Composable() () -&gt; Unit,<br/>    actionData: List&lt;T&gt;,<br/>    color: Color = MaterialTheme.colors().primary,<br/>    navigationIcon: @Composable() (() -&gt; Unit)? = null,<br/>    action: @Composable() (T) -&gt; Unit<br/>        // TODO: support overflow menu <br/>        here with the remainder of the list<br/>)</span></pre><p id="72ae" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">从上面我们已经可以看到一些相似之处——我们仍然可以为TopAppBar设置标题、颜色和导航图标。但是在这里我们看到添加了另外两个属性——actionData和action，以及我们的函数<t>的通用声明。</t></p><p id="18c7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">以前，当谈到应用程序栏动作时，这些是在XML菜单文件中定义的，并作为屏幕菜单加载。这里我们提供了一个ID以及一些文本或图标引用。当涉及到TopAppBar时，事情的工作方式有点不同。我们可以提供一个为<strong class="iv hi"> &lt; T &gt; </strong>声明的类型集合，而不是提供一个菜单资源。这可能是字符串、整数资源或类的集合。让我们来看一个例子。</p><p id="c99d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对于我的类型T，我将定义一个名为MenuAction的新的密封类——当涉及到处理混合标签/图标、溢出菜单以及单击侦听器时，不使用原始数据类型将更容易处理事情。现在，我们将只定义一个名为Share的操作:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="a1e7" class="ku kv hh kq b fi kw kx l ky kz">sealed class MenuAction(<br/>    @StringRes val label: Int, <br/>    @DrawableRes val icon: Int) {<br/>    <br/>    object Share : MenuAction(R.string.share, R.drawable.ic_share)</span><span id="0de9" class="ku kv hh kq b fi ll kx l ky kz">}</span></pre><p id="91c0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">然后我可以继续添加它作为我的类型<t>:</t></p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="b124" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar&lt;MenuAction&gt;(<br/>    title = { Text(text = "AppBar") },<br/>    color = Color.White,<br/>    navigationIcon = {<br/>        AppBarIcon(icon = imageResource(<br/>            id = R.drawable.ic_menu_black_24dp)) {<br/>            // Open nav drawer<br/>        }<br/>    }<br/>)</span></pre><p id="9387" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">将它定义为TopAppBar操作的类型后，我们就不能继续添加actionData了——这实际上是我们希望在TopAppBar中显示的菜单项列表。现在，我们将只显示一个菜单项:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="d2fd" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar&lt;MenuAction&gt;(<br/>    title = { Text(text = "AppBar") },<br/>    color = Color.White,<br/>    navigationIcon = {<br/>        AppBarIcon(icon = imageResource(<br/>            id = R.drawable.ic_menu_black_24dp)) {<br/>            // Open nav drawer<br/>        }<br/>    },<br/>    actionData = listOf(MenuAction.Save)<br/>)</span></pre><p id="5b31" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在我们的TopAppBar知道了将要显示的菜单项，我们可以添加action参数了。该操作用于为正在使用的每个菜单项构建一个可组合的。因此，如果我们在actionData中返回了多个MenuAction项，那么将为其中的每个项调用此操作，从而在流程中构建一个可组合的。在这里，我们将使用前面的同一个AppBarIcon类，使用我们的MenuAction引用来构建一个可组合的:</p><pre class="jv jw jx jy fd kp kq kr ks aw kt bi"><span id="51f8" class="ku kv hh kq b fi kw kx l ky kz">TopAppBar&lt;MenuAction&gt;(<br/>    title = { Text(text = "AppBar") },<br/>    color = Color.White,<br/>    navigationIcon = {<br/>        AppBarIcon(icon = imageResource(<br/>            id = R.drawable.ic_menu_black_24dp)) {<br/>            // Open nav drawer<br/>        }<br/>    },<br/>    actionData = listOf(MenuAction.Save),<br/>    action = { menuAction -&gt;<br/>        AppBarIcon(icon = imageResource(<br/>            id = menuAction.icon)) {<br/>            // Handle action click<br/>        }<br/>    }<br/>)</span></pre><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/6722461bac596de09136a02cd5ac7b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uID1Bv0YuYS8dEP-"/></div></div></figure><p id="6f0e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">有了它，我们现在有了一个支持菜单项的TopAppBar。如上所述，我们可以支持多个菜单动作——目前对API中溢出菜单的支持还没有完成，所以这里的行为可能与预期不同。</p></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="b9ca" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在本文中，我们深入研究了Jetpack Compose中的TopAppBar组件，以及如何在我们的应用程序中使用它。虽然它是一个非常小的组件，但它提供了很大的灵活性，允许我们创建适合我们应用程序需求的应用程序栏。你对如何使用这个组件有什么问题吗，或者你已经使用过它了吗？请在这里或twitter上联系我们！</p><div class="ln lo ez fb lp lq"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hi fi z dy lv ea eb lw ed ef hg bi translated">乔·伯奇</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead @Buffer。他/他。GDE为@Android、@actionsongoogle…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">twitter.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me in lq"/></div></div></a></div></div></div>    
</body>
</html>