<html>
<head>
<title>Kotlin Native. Multithreading with Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林本地人。使用协程的多线程</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/kotlin-native-multithreading-with-coroutines-373663bf5a09?source=collection_archive---------0-----------------------#2021-09-24">https://medium.com/google-developer-experts/kotlin-native-multithreading-with-coroutines-373663bf5a09?source=collection_archive---------0-----------------------#2021-09-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/9982e95287268f37c04f2aa5884cbc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tUyPsjM8mctWV9pIrbZKkw.png"/></div></figure><p id="ff46" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Kotlin Multiplatform以及其他跨平台SDK的主要思想是通过编写一次代码并在不同平台之间共享来优化开发。然而，有一些细微的差别应该根据平台的具体情况来解决。一个这样的时刻是并发性。KMM SDK为每个本机平台版本的Kotlin使用特定的:Kotlin/JVM、Kotlin/JS或Kotlin/Native。Kotlin Native与Kotlin JVM确实不同，因为它取决于iOS平台的具体情况。大多数适用于JVM的默认解决方案根本不适合Kotlin Native。在这个故事中，我们将讨论在Kotlin多平台中处理iOS和Kotlin本地并发的基本方法。</p><p id="8ac9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Kotlin多平台提供了实现多线程的通用方法。它使用Kotlin，所以我们可以对所有目标使用<em class="jj">协程</em>:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="32d9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们需要设置协程的作用域和上下文，以便与主线程和后台线程一起工作:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="1457" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">由于平台特定的代码，我们需要使用预期/实际机制来为我们使用的每个平台设置正确的版本。<br/>对于Android和iOS，我们可以使用<em class="jj">默认</em>和<em class="jj">主</em>调度程序:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="e546" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">JVM和Android中不存在并发性问题，所以我们将只关注Kotlin Native。在那里，我们将面对一些细微的差别。<br/>如果我们使用默认调度程序，并在主线程和后台线程之间共享一些对象，我们可以得到<em class="jj"> FreezingException </em>:</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/6ede60c5ed1156f9676bd61d0ec343d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rirv7LQDjWM98T7yqhhCdg.png"/></div></div></figure><p id="a1f2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/freeze.html" rel="noopener ugc nofollow" target="_blank">在Kotlin Native中，我们只能在线程间共享不可变的对象</a>。<strong class="in hi">为了使一个对象或代码块不可变，我们应该使用freeze()命令</strong>。为了封装和隐藏所有冻结的工作，我们可以创建自己的<em class="jj">协程调度程序</em>:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="e970" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用MainDispatcher处理主队列是绝对正确的。但是<em class="jj">DISPATCH _ get _ Global _ QUEUE(DISPATCH _ QUEUE _ PRIORITY _ default . tolong()，0.toULong()) </em>不能用于<em class="jj">全局队列</em>，因为在Kotlin Native中它没有绑定到任何特定的线程。主线程和后台线程都可以使用<em class="jj"> MainDispatcher </em>:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="ccc2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">ThreadLocal注释用于使单例对象在线程间可共享。</p><p id="869b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用<em class="jj"> MainDispatcher </em>看起来真的很奇怪。但是当我们把它和像<em class="jj"> Ktor </em>这样的库一起使用时，这是可以的。因为Ktor 已经实现了一个异步机制。</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jw"><img src="../Images/71a6391dae7467524af88bb87a568ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*353z9J2cOItbe5WCUbymPQ.png"/></div></div></figure><p id="c54e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是如果我们不想使用<em class="jj"> Ktor </em>呢？在这种情况下，我们如何处理后台线程？<br/>我们可以尝试使用<em class="jj">全局范围</em>。但是不建议这样做，因为在此范围内启动的所有协程都存在潜在的泄漏和缺乏控制:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="df45" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以使用简单的变通方法来管理<em class="jj">全局范围</em>中的所有协程。但是仍然不安全。</p><p id="7ef9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以在其他范围内运行我们定制的调度程序:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="533d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它会成功的。我们还可以使用特殊的native-mt版本的协同程序库，它允许我们使用多线程协同程序，例如1.5.2-native-mt 。因为<code class="du jx jy jz ka b">kotlinx.coroutines</code>的主版本是单线程的，所以库几乎肯定会依赖这个版本。这种情况下我们可以面对<code class="du jx jy jz ka b">InvalidMutabilityException</code>。另一个问题是使用多线程协程时的内存泄漏。</p><p id="af62" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在Kotlin Native中使用协程似乎很棘手。如何在没有协程的情况下处理并发，我们将在<a class="ae jv" rel="noopener" href="/p/56599ea33620">讨论下一个故事</a>。</p><div class="kb kc ez fb kd ke"><a href="https://kotlinlang.org/docs/kmm-concurrency-and-coroutines.html" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hi fi z dy kj ea eb kk ed ef hg bi translated">并发和协同程序| Kotlin</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">协程是轻量级线程，允许您编写异步非阻塞代码。科特林提供了…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">kotlinlang.org</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks ij ke"/></div></div></a></div></div></div>    
</body>
</html>