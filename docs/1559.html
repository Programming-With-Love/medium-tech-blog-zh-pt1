<html>
<head>
<title>3 Best Practices for API Clients</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API客户端的3个最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/3-best-practices-for-api-clients-feef9ec97f1a?source=collection_archive---------0-----------------------#2018-05-07">https://medium.com/capital-one-tech/3-best-practices-for-api-clients-feef9ec97f1a?source=collection_archive---------0-----------------------#2018-05-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/543bab2d85ec93a3147dd9dd19207cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XisNpcbzbrkdApEGvD44uA.jpeg"/></div></div></figure><p id="4a37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有许多关于设计良好的REST APIs的最佳实践的博文/文章。本文试图为REST APIs的客户端做同样的事情。</p><p id="f24f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您选择了一个设计良好的API，它具有弹性、安全性和可伸缩性，能够满足您作为API客户端应用程序的需求。应该不会有下降的预期吧？事实是，大量行为不良的客户端(恶意的或编码不良的)甚至可以压倒最好的API或API网关。如果用API构建是API客户机和生产者之间的合作关系，那么客户机如何成为这种关系中的好管家呢？本文的重点是帮助API客户更好地集成他们的API，并且基于我作为<a class="ae jo" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank">Capital One deve exchange</a>的工程负责人的经验。</p><h1 id="d6ce" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">API客户端最佳实践</h1><h2 id="9229" class="kn jq hh bd jr ko kp kq jv kr ks kt jz ja ku kv kd je kw kx kh ji ky kz kl la bi translated">知道你的HTTP状态码</h2><p id="b72e" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">HTTP状态码已经存在很长时间了，并且非常<a class="ae jo" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank">有据可查</a>。然而，大量糟糕的客户端行为源于对HTTP状态代码的不正确处理。以下是HTTP状态代码要遵循的两个简单规则:</p><p id="4c63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.<strong class="ir hi"> <em class="jn"> HTTP 4XX状态码:</em> </strong>这意味着一件事——服务器(API或网关)因为出错而指责客户端。如果发生这种情况，不要按原样重试请求，在客户端可以重试请求之前，需要进行一些更改。通常，客户端需要做一些不同的事情，比如提供缺失的请求数据。或者在某些情况下，需要采取带外操作。例如，在客户端可以重试之前，在服务器上进行访问配置以避免HTTP 401。</p><p id="57f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例子</strong>:我最近遇到一个客户端，在收到一个HTTP 429(由于请求太多，网关限制了速率)后，不但没有减速，反而一直盲目重试。显然，这除了给网关基础设施带来不必要的负担之外，还加剧了他们自己的问题。</p><p id="5ed4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.<strong class="ir hi"> <em class="jn"> HTTP 5XX状态码:</em> </strong>这意味着一件事——服务器(API或网关)在说<em class="jn">‘我的错’</em>所以让他们休息一下吧。客户有权重试，但应谨慎行事。在HTTP 5XX上盲目重试可能会进一步破坏API的稳定性。那么，客户应该怎么做呢？</p><ul class=""><li id="a978" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated">在用户等待的情况下，客户端需要中止进程，因此用户可以选择是否重试。</li><li id="1156" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated">对于没有用户等待的后台调用或系统到系统的调用，客户端可以使用指数后退策略重试(更多信息见下文)。</li></ul><h2 id="6fc9" class="kn jq hh bd jr ko kp kq jv kr ks kt jz ja ku kv kd je kw kx kh ji ky kz kl la bi translated">了解你的OAuth令牌</h2><p id="102f" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">有很多方法可以保护API，包括基本认证和摘要认证。但是，如果您正在访问的API是使用<a class="ae jo" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 </a>保护的，那么作为一个API客户端，您将需要处理很多令牌——访问令牌、承载令牌、刷新令牌等。以下是一些关于如何处理这些令牌的提示:</p><ul class=""><li id="8993" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="jn">复用令牌:</em> </strong>通常情况下，访问令牌在到期前都是可复用的。重用令牌，不要为每个API调用请求新令牌。</li><li id="f503" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="jn">优雅地处理过期令牌:</em> </strong>不要硬编码令牌过期时间。一个设计良好的API应该返回一个<strong class="ir hi"> <em class="jn"> expires_in </em> </strong>字段(当请求新令牌时)和/或应该在使用过期令牌时返回HTTP 401。使用这些作为触发器来请求新的访问令牌(使用先前提供的刷新令牌)。</li><li id="2e9c" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="jn">不透明地对待记号:</em> </strong>不依赖于记号的结构、内容或大小，也不对其做任何假设。它们是服务器端的植入细节，依赖它们可能会在不经意间破坏客户端。</li></ul><h2 id="f7d2" class="kn jq hh bd jr ko kp kq jv kr ks kt jz ja ku kv kd je kw kx kh ji ky kz kl la bi translated"><strong class="ak">指数退避策略</strong></h2><p id="418a" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">在收到HTTP 5XX 状态代码后，客户端可以按原样重试请求，但应该在一段延迟后重试。进行这些重试的最佳方式之一是采用指数补偿算法。</p><p id="aa87" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简而言之，这将使客户端能够在重试之间的等待时间逐渐变长后重试。<strong class="ir hi"> </strong> <em class="jn">比如1秒后重试，2秒，4秒，8秒，16秒……等等。</em></p><p id="ace6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，这可以这样表达:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="5a00" class="kn jq hh lz b fi md me l mf mg"><em class="jn">Math.pow(2, retryCount)</em></span></pre><p id="6565" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种算法还应该实现最大重试间隔和最大重试次数，并使用最佳值。<strong class="ir hi"> </strong>例如，在<em class="jn"> 1秒、2秒、4秒、8秒、16秒后重试……最多300秒或最多10次重试。</em></p><p id="f30a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，如果客户端运行在大量设备上(比如在后台调用API的移动客户端)，客户端必须在指数后退算法中使用抖动(随机延迟)。如果不在等待时间中引入这种随机延迟，在错误场景中，数百万个客户端可能会在完全相同的时间(并发地)重试，从而进一步使API不堪重负。这是系统负载在有抖动和无抖动情况下的示例图。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/f12b89439e7e386106b7f36c7b3d1519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJl7cQbiYQUNrzIIK6nqzw.png"/></div></div></figure><p id="7634" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有关<a class="ae jo" href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="jn">指数回退和抖动</em> </strong> </a> <strong class="ir hi"> <em class="jn">的更多信息，请参考这篇AWS架构博客。</em> </strong></p><h2 id="aa2c" class="kn jq hh bd jr ko kp kq jv kr ks kt jz ja ku kv kd je kw kx kh ji ky kz kl la bi translated"><strong class="ak">结论</strong></h2><p id="4eb6" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">虽然恶意API客户端确实存在，但大多数API和API网关都被善意但编码糟糕的API客户端所淹没。一个编码糟糕的API客户端可以撤销为你的应用选择一个有弹性的、安全的、可伸缩的API的所有考虑。通过理解和实施这些简单的最佳实践来帮助防止这种情况。你的用户会感谢你的。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es mi"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="7fb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为Capital One 2018。</em></p></div></div>    
</body>
</html>