<html>
<head>
<title>Automatically Generate Elixir API Docs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动生成酏剂API文档</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/automatically-generate-elixir-api-docs-986ad60721e7?source=collection_archive---------0-----------------------#2018-02-03">https://medium.com/quick-code/automatically-generate-elixir-api-docs-986ad60721e7?source=collection_archive---------0-----------------------#2018-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="49c5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">官僚简介</h2></div><h2 id="dbad" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">首先,(非常)简要地介绍一下长生不老药</h2><p id="06b3" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated"><a class="ae kn" href="https://en.wikipedia.org/wiki/Elixir_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Elixir </a>是一种高效、可读、可扩展的语言；非常适合构建API。它被设计成容错的，使用单独的筒仓进程来防止孤立的错误引起应用程序范围的错误。在Elixir中构建应用程序最流行的框架是Phoenix，它的设计感觉就像Rails。Elixir编译为<a class="ae kn" href="https://en.wikipedia.org/wiki/Erlang_(programming_language)" rel="noopener ugc nofollow" target="_blank"> erlang </a>，这是一种(相对)古老的语言，根据维基百科，它最早出现在1986年。人们花了30年才发现它的价值，但现在凭借其新鲜的灵药包装和Ruby-ish语法，它已经成为各地大公司的基石。</p><p id="e3bc" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">我将把关于Elixir比Ruby更快/更有效的细节留给更有资格的专业人员，但是我想为没有背景知识的读者简单介绍一下这个主题。</p><h2 id="bc83" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">什么是官僚？</h2><p id="6dd1" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated"><a class="ae kn" href="https://github.com/api-hogs/bureaucrat" rel="noopener ugc nofollow" target="_blank">官僚</a>是一个你可以添加到你的Phoenix项目中的依赖项，它将使用你的测试(是的，你必须写测试…)来自动编译api文档。随着端点的添加或更改，这个方便的工具将重新生成markdown(或带有一些定制的HTML ),因此没有人需要完成确保文档是最新的这一令人羡慕的任务。</p><p id="d271" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">该软件包缺乏适当的文档，按照github上的自述文件将会不可避免地把你引入歧途。正是这种困惑激励我花点时间整理我的想法，希望它能帮助其他人避免一些相当恼人的缺点。</p><h2 id="494d" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">基本实现</h2><p id="243b" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated">官僚可以用简单的内置减价软件编写基本的减价程序。该配置看起来</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="a7d7" class="iw ix hh ky b fi lc ld l le lf"># in test/test_helper.exs</span><span id="a676" class="iw ix hh ky b fi lg ld l le lf">Bureaucrat.start(<br/> writer: Bureaucrat.MarkdownWriter,<br/> default_path: "docs/api-v1.md",<br/> paths: [],<br/> titles: [<br/>  {ApplicationCartController, "API /carts"},<br/>  {Canvaserver.V1.RouteController, "API /routes"},  <br/>  {Canvaserver.V1.WaypointController, "API /waypoints"},  <br/>  {Canvaserver.V1.ChargerController, "API /chargers"}],<br/>  env_var: "DOC"<br/>)</span><span id="7493" class="iw ix hh ky b fi lg ld l le lf"># titles add extra metadata to alias controllers</span><span id="0fa1" class="iw ix hh ky b fi lg ld l le lf"># add Bureaucrat formatter to ExUnit.start()</span><span id="47a7" class="iw ix hh ky b fi lg ld l le lf">ExUnit.start(formatters: [ExUnit.CLIFormatter, Bureaucrat.Formatter])</span></pre><figure class="kt ku kv kw fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lh"><img src="../Images/82197e1125f6993e1da95bdebe536bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nyDK6yIctlnd5FDXF7ETw.png"/></div></div></figure><p id="79d6" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">现在，我们所需要做的就是添加一个文档调用到我们想要被记录的端点测试，这样我们的基本文档就完成了！</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="070c" class="iw ix hh ky b fi lc ld l le lf">conn = conn<br/> |&gt; api_login(user) # helper method<br/> |&gt; get(v1_cart_path(conn, :index))<br/> |&gt; doc(description: "List all carts")</span><span id="e74d" class="iw ix hh ky b fi lg ld l le lf"># description is an extra option for basic metadata with the basic bureaucrat implementation</span><span id="4ece" class="iw ix hh ky b fi lg ld l le lf"># calling tests, include the DOC=1 flag to trigger bureaucrat<br/>DOC=1 mix test</span></pre><figure class="kt ku kv kw fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lp"><img src="../Images/615b944d5013716da1a156128e781a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xprsW8tkeKd9YZRKCBoWg.png"/></div></div></figure><p id="1f79" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">使用_intro保存在目标文件夹中的任何文件都会自动包含在输出文件的开头，因此您可以进行一些自定义。</p><p id="4cfe" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">这是markdown writer内置的官僚程序所能达到的最好效果。</p><h2 id="7379" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">神气活现的官僚</h2><p id="0c52" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated">官僚主义者提供了第二种选择，用SwaggerSlateMarkdown writer生成文档。这种方法的配置如下所示:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="56b7" class="iw ix hh ky b fi lc ld l le lf">Bureaucrat.start(<br/> writer: Bureaucrat.SwaggerSlateMarkdownWriter,<br/> default_path: "ext/doc/source/index.html.md",<br/> swagger: "swagger.json" |&gt; File.read!() |&gt; Poison.decode!()<br/>)</span><span id="349d" class="iw ix hh ky b fi lg ld l le lf"># default_path points to a cloned slate project<br/># swagger points to a generated swagger.json file</span><span id="ff31" class="iw ix hh ky b fi lg ld l le lf">ExUnit.start(formatters: [ExUnit.CLIFormatter, Bureaucrat.Formatter])</span></pre><p id="aa66" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">遵循开放API语法，或普遍接受的语言来记录API的目的和用途。<a class="ae kn" href="https://github.com/xerions/phoenix_swagger" rel="noopener ugc nofollow" target="_blank"> PhoenixSwagger </a>允许我们在控制器中填充这些元数据，并执行一个命令来生成swagger.json文件。安装步骤可以在上面的链接中找到，但这里有一个如何使用它的例子。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5bf9" class="iw ix hh ky b fi lc ld l le lf"># import PhoenixSwagger before using to gain access to swagger_path and swagger_definition methods</span><span id="6965" class="iw ix hh ky b fi lg ld l le lf">use PhoenixSwagger</span><span id="0675" class="iw ix hh ky b fi lg ld l le lf"># define basic get all carts method</span><span id="a3f5" class="iw ix hh ky b fi lg ld l le lf">swagger_path :index do<br/>  get "api/v1/carts"<br/>  summary "Query for carts"<br/>  description "Query returns all carts"<br/>  produces "application/json"<br/>  tag "Carts"<br/>  operation_id "list_carts" # used to link to test examples<br/>  parameters do<br/>    authorization :header, :string, "authorization token", required: true<br/>  end<br/>  # define expected parameters<br/>  response 200, "OK", <strong class="ky hi">Schema.ref(:CartsResponse)</strong><br/>  response 400, "Client Error"</span><span id="790c" class="iw ix hh ky b fi lg ld l le lf">  # define responses<br/>end</span></pre><p id="bbd6" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">我们还可以定义模式，所以我可以简单地告诉用户，如果他们感兴趣，我将返回一个购物车数组并链接到购物车的结构。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="34ca" class="iw ix hh ky b fi lc ld l le lf">def swagger_definitions do<br/> CartsResponse: swagger_schema do<br/>   title "Carts Response"<br/>   description "response template for carts"<br/>   properties do<br/>     success :boolean, "success boolean", required: true<br/>     data :array, "array of carts", items: Schema.ref(:Cart), required: true<br/>   end<br/> end<br/>end</span><span id="2589" class="iw ix hh ky b fi lg ld l le lf"># we would then have to define :Cart</span></pre><p id="7ccc" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">这些数据模型在输出中有很好的超链接。假设一切都已正确配置，您可以通过为您的项目调整这个脚本并运行。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="0a8f" class="iw ix hh ky b fi lc ld l le lf">mix phx.swagger.generate --router Application.Router --endpoint Application.Endpoint</span></pre><p id="a9b0" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">您的swagger.json文件现在应该填充了在<em class="lq"> swagger_definition </em>语句中定义的所有模型，在<em class="lq"> swagger_path </em>语句中定义的所有路径，以及您的测试中引用的所有示例。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="cc80" class="iw ix hh ky b fi lc ld l le lf"># ...in tests...</span><span id="177f" class="iw ix hh ky b fi lg ld l le lf">|&gt; doc(operation_id: "list_carts")</span><span id="48ad" class="iw ix hh ky b fi lg ld l le lf"># refers to operation_id in swagger_path</span></pre><p id="19a2" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">下一步是将json转换成一个漂亮的交互式文档。</p><h2 id="46d1" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">通过Swagger.json使用Slate</h2><p id="99b0" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated"><a class="ae kn" href="https://github.com/lord/slate" rel="noopener ugc nofollow" target="_blank">石板</a>要靠红宝石，邦德勒，中间人。对于某些人来说，这可能会导致部署过程中出现问题，但对于大多数人来说，这只是一次性的不便。</p><figure class="kt ku kv kw fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lr"><img src="../Images/c5e8e3df4ad5eae26e74161a715b9383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMCPwETJJL7-pIy4XCitYA.png"/></div></div></figure><p id="e798" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">输出是一个干净的交互式文档，任何开发人员都会乐于使用。</p><p id="35ef" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">现在，当我们再次在测试脚本中包含DOC=1时，官僚将为我们做两件事:</p><ul class=""><li id="928d" class="ls lt hh jw b jx ko ka kp jh lu jl lv jp lw km lx ly lz ma bi translated">用测试库中的例子更新swagger.json</li><li id="9d58" class="ls lt hh jw b jx mb ka mc jh md jl me jp mf km lx ly lz ma bi translated">用swagger.json的最终内容更新slate index.html.md文件</li></ul><p id="6f91" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">剩下要做的就是重建石板回购:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8151" class="iw ix hh ky b fi lc ld l le lf"># /doc/</span><span id="3ad3" class="iw ix hh ky b fi lg ld l le lf">bundle exec middleman build</span></pre><p id="d959" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">您可以在浏览器中打开index.html.md文件，并(希望)开始与您的文档进行交互。</p><h2 id="9214" class="iw ix hh bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">把所有的事情都联系起来</h2><p id="9805" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc jh kd ke kf jl kg kh ki jp kj kk kl km ha bi translated">这篇文章失去了控制，但是这里的总体思想是自动化文档。帮助未来的开发人员，尤其是您自己，避免更新文档的单调任务，确保这些文档保持最新。最新的文档确保顾客和客户能够尽他们最大的能力使用您的服务，而您的企业不必处理来自问题和议题的流失。</p><p id="ae5f" class="pw-post-body-paragraph ju jv hh jw b jx ko ii jz ka kp il kc jh kq ke kf jl kr kh ki jp ks kk kl km ha bi translated">一如既往，欢迎对这些帖子的反馈。如果你发现任何误导或困惑，请让我知道，这样我就可以更新这个帖子。</p></div></div>    
</body>
</html>