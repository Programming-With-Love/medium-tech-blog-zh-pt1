<html>
<head>
<title>Mocking is not rocket science: MockK features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘲笑不是火箭科学:嘲笑特征</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-features-e5d55d735a98?source=collection_archive---------0-----------------------#2018-01-23">https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-features-e5d55d735a98?source=collection_archive---------0-----------------------#2018-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="15b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用Kotlin，那么与其他嘲讽框架相比，MockK无疑是更好的选择。<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03">上一篇文章</a>展示了一些基础知识。现在是时候讨论诸如捕获的参数、轻松的模拟、间谍和注释等特性了。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2639ebe88a58339f71f9b1932f794908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CRvBn4axjKSKlUdcDM4dg.jpeg"/></div></div></figure><h2 id="a5ab" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">占领</h2><p id="f150" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">如果您需要在<code class="fe lt lu lv lw b">every</code>或<code class="fe lt lu lv lw b">verify</code>块中获取一个参数的值，参数捕获可以让您的生活更加轻松。假设我们有以下类:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="0816" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">class </strong>Divider {<br/>    <strong class="lw io">fun </strong>divide(a: Int, b: Int) = a / b<br/>}</span></pre><p id="5be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种方法可以捕获参数:使用<code class="fe lt lu lv lw b">CapturingSlot&lt;Int&gt;</code>和使用<code class="fe lt lu lv lw b">MutableList&lt;Int&gt;</code>。</p><p id="9f48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lt lu lv lw b">CapturingSlot</code>只允许捕捉一个值，所以使用起来更简单。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="c063" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">val </strong>slot = <em class="mf">slot</em>&lt;Int&gt;()<br/><strong class="lw io">val </strong>mock = <em class="mf">mockk</em>&lt;Divider&gt;()<br/><em class="mf">every </em><strong class="lw io">{ </strong>mock.divide(capture(slot), any()) <strong class="lw io">} </strong>returns 22</span></pre><p id="a998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这创建了一个slot和一个mock，并按照下面的方式设置预期的行为:如果调用了<code class="fe lt lu lv lw b">mock.divide</code>，那么第一个参数被捕获到<code class="fe lt lu lv lw b">slot</code>并返回<code class="fe lt lu lv lw b">22</code>。</p><p id="78b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在正在测试的代码:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="0a1d" class="kv kw in lw b gy mb mc l md me">mock.divide(5, 2) // 22 is a result</span></pre><p id="b692" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行后，<code class="fe lt lu lv lw b">slot.captured</code>值等于第一个参数，即<code class="fe lt lu lv lw b">5</code></p><p id="0412" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你可以做一些检查，比如断言:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="bd47" class="kv kw in lw b gy mb mc l md me">assertEquals(5, slot.captured)</span></pre><p id="df24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，你可以在一个<code class="fe lt lu lv lw b">answer</code> lambda中使用一个插槽:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="065f" class="kv kw in lw b gy mb mc l md me"><em class="mf">every </em><strong class="lw io">{ <br/>  </strong>mock.divide(capture(slot), any()) <br/><strong class="lw io">} </strong>answers <strong class="lw io">{<br/>  </strong>slot.captured * 11<br/><strong class="lw io">}</strong></span></pre><p id="5b03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以<code class="fe lt lu lv lw b">mock.divide(5, 2)</code>返回<code class="fe lt lu lv lw b">55</code>。</p><p id="c061" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上就是这样。与<code class="fe lt lu lv lw b">MutableList</code>的工作方式相同，只是应该使用<code class="fe lt lu lv lw b">MutableList</code>功能，而不是<code class="fe lt lu lv lw b">capture</code>中的<code class="fe lt lu lv lw b">slot</code>。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="a064" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">val </strong>list = <em class="mf">mutableList</em>&lt;Int&gt;()<br/><strong class="lw io">val </strong>mock = <em class="mf">mockk</em>&lt;Divider&gt;()<br/><em class="mf">every </em><strong class="lw io">{ </strong>mock.divide(capture(list), any()) <strong class="lw io">} </strong>returns 22</span></pre><p id="bb81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许在一行中从几个调用中捕获几个值。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/1541386c39f29638d2fb4fe56b8c65b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LT3av3zeWRd1KyMId3Viw.jpeg"/></div></div></figure><h2 id="cecd" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">轻松的嘲笑</h2><p id="2c91" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">默认情况下，模拟是严格的。在将mock传递给被测试的代码之前，你应该用<code class="fe lt lu lv lw b">every</code>块设置行为。如果您没有提供预期的行为，并且执行了调用，库将抛出一个异常。</p><p id="ed32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这和Mockito默认的做法是不一样的。Mockito允许您跳过指定预期行为，并使用类似于<code class="fe lt lu lv lw b">null</code>或<code class="fe lt lu lv lw b">0</code>的一些基本值进行回复。通过声明relaxed mock，您可以在mock中实现相同甚至更多的功能。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="4eca" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">val </strong>mock = <em class="mf">mockk</em>&lt;Divider&gt;(relaxed = <strong class="lw io">true</strong>)</span></pre><p id="3bec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后你可以马上使用它:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="39ae" class="kv kw in lw b gy mb mc l md me">mock.divide(5, 2) // returns 0</span></pre><p id="49dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，如果返回值是引用类型，库将尝试创建子mock并构建调用链。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="9f7f" class="kv kw in lw b gy mb mc l md me">mock.call1(1, 2, 3).call2(4, 5, 6)</span></pre><p id="7700" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe lt lu lv lw b">verify</code>块中，您可以检查调用是否被执行:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="6597" class="kv kw in lw b gy mb mc l md me"><em class="mf">verify </em><strong class="lw io">{ </strong>mock.divide(5, 2) <strong class="lw io">}</strong></span></pre><p id="58ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="f98e" class="kv kw in lw b gy mb mc l md me"><em class="mf">verify </em><strong class="lw io">{ </strong>mock.call1(1, 2, 3).call2(4, 5, 6) <strong class="lw io">}</strong></span></pre><p id="b01b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是请注意，由于自然语言的限制，不可能让调用链为泛型返回类型工作，因为这些信息已经被删除了。如果您需要这样的用例，请在<code class="fe lt lu lv lw b">every</code>块中显式设置预期行为。</p><h2 id="6dd3" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">间谍</h2><p id="53cb" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">Spies提供了设置预期行为和进行行为验证的可能性，同时仍然执行对象的原始方法。</p><p id="a86e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有下面的类:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="9c0a" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">class </strong>Adder {<br/>    <strong class="lw io">fun </strong>magnify(a: Int) = a<br/><br/>    <strong class="lw io">fun </strong>add(a: Int, b: Int) = a + magnify(b)<br/>}</span></pre><p id="04d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们想要测试<code class="fe lt lu lv lw b">add</code>函数的行为，同时模仿<code class="fe lt lu lv lw b">magnify</code>函数的行为。</p><p id="5ce3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们首先创建一个间谍:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="283f" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">val </strong>spy = <em class="mf">spyk</em>(Adder())</span></pre><p id="ec67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们创建了对象<code class="fe lt lu lv lw b">Adder()</code>，并在其上构建了一个间谍。构建一个spy实际上意味着创建一个特殊的同类型的空对象，并复制所有的字段。</p><p id="b984" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以使用它，就好像它是普通的<code class="fe lt lu lv lw b">Adder()</code>物体一样。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="8995" class="kv kw in lw b gy mb mc l md me"><em class="mf">assertEquals</em>(9, spy.add(4, 5))</span></pre><p id="d8df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将检查原始方法是否被调用。</p><p id="5ad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，我们可以通过将它放到<code class="fe lt lu lv lw b">every</code>块来定义间谍行为:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="2a6e" class="kv kw in lw b gy mb mc l md me"><em class="mf">every </em><strong class="lw io">{ </strong>spy.magnify(any()) <strong class="lw io">} </strong>answers <strong class="lw io">{ </strong>firstArg&lt;Int&gt;() * 2 <strong class="lw io">}</strong></span></pre><p id="57bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这为<code class="fe lt lu lv lw b">magnify</code>函数提供了一个预期的答案。</p><p id="3e1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此后，<code class="fe lt lu lv lw b">add</code>的行为发生了变化，因为它依赖于<code class="fe lt lu lv lw b">magnify</code>:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="f978" class="kv kw in lw b gy mb mc l md me"><em class="mf">assertEquals</em>(14, spy.add(4, 5))</span></pre><p id="d28c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们用间谍达到了目的。</p><p id="8353" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们可以验证调用，就像它是一个模拟:</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="35df" class="kv kw in lw b gy mb mc l md me"><em class="mf">verify </em><strong class="lw io">{ </strong>spy.add(4, 5) <strong class="lw io">}<br/></strong><em class="mf">verify </em><strong class="lw io">{ </strong>spy.magnify(5) <strong class="lw io">}</strong></span></pre><p id="6fc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种非常强大的测试技术。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/abcdf63749fcb8b4160ab0479d160c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMeBtiANNMnpWgk0gjPE6g.jpeg"/></div></div></figure><h2 id="d564" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">释文</h2><p id="34a8" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">该库支持注释<code class="fe lt lu lv lw b">@MockK</code>、<code class="fe lt lu lv lw b">@SpyK</code>和<code class="fe lt lu lv lw b">@RelxedMockK</code>，可以作为一种更简单的方式来创建相应的模拟、间谍和轻松模拟。</p><pre class="kk kl km kn gt lx lw ly lz aw ma bi"><span id="9522" class="kv kw in lw b gy mb mc l md me"><strong class="lw io">class </strong>Test {<br/>    @MockK<br/>    <strong class="lw io">lateinit var doc1</strong>: Dependency1<br/><br/>    @RelaxedMockK<br/>    <strong class="lw io">lateinit var doc2</strong>: Dependency2<br/><br/>    @SpyK<br/>    <strong class="lw io">val doc3 </strong>= Dependency3()<br/><br/>    @Before<br/>    <strong class="lw io">fun </strong>setUp() = MockKAnnotations.init(this)<br/><br/>    @Test<br/>    <strong class="lw io">fun </strong>calculateAddsValues1() {<br/>        <em class="mf">every </em><strong class="lw io">{ doc1</strong>.call().add(any()) <strong class="lw io">} </strong>returns 5<br/>        <em class="mf">every </em><strong class="lw io">{ doc2</strong>.<strong class="lw io">value2 } </strong>returns <strong class="lw io">"6"<br/>        </strong><em class="mf">every </em><strong class="lw io">{ doc3</strong>.sub(any()) <strong class="lw io">} </strong>returns 7<br/><br/>        <strong class="lw io">val </strong>sut = SystemUnderTest(<strong class="lw io">doc1</strong>)<br/><br/>        <em class="mf">assertEquals</em>(11, sut.calculate())<br/>    }<br/>}</span></pre><p id="0592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里重要的部分是在<code class="fe lt lu lv lw b">@Before</code>阶段执行的<code class="fe lt lu lv lw b">MockKAnnotations.init(this)</code>调用。当它被执行时，所有带注释的属性都被相应的对象所替代:模仿、间谍和放松的模仿。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/d27a417733ced087a022994fad0dc3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5WNn3aesvHa3U7iuy72Hg.jpeg"/></div></div></figure><p id="0378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一篇文章将描述链式调用、对象模拟、扩展函数和DSL。</p><p id="3b75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的关注！</p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="d3f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">拍手</strong>说“谢谢”并帮助他人找到这篇文章。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://kt.academy/article"><div class="gh gi mn"><img src="../Images/5cf9179effdb3e8ab1a9bf39598fdfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNxjFpvGWzjC5h4VRjLyCw.png"/></div></a></figure><p id="bec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于用MockK进行单元测试的下一篇文章将在下周发表。不要错过它—订阅出版物和作者频道。以下是上一篇文章:</p><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd io gy z fp mw fr fs mx fu fw im bi translated">嘲讽不是火箭科学:预期行为和行为验证</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在上一篇文章中，我描述了嘲讽的基础。现在让我来概述一下MockK的基本特性。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kt mr"/></div></div></a></div><p id="3e06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢<a class="ae ki" href="https://twitter.com/DBacinski" rel="noopener ugc nofollow" target="_blank"> Dariusz Baciński </a>的技术验证。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ng"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>