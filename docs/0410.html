<html>
<head>
<title>Threading models in Coroutines and Android SQLite API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和Android SQLite API中的线程模型</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/threading-models-in-coroutines-and-android-sqlite-api-6cab11f7eb90?source=collection_archive---------2-----------------------#2019-07-17">https://medium.com/androiddevelopers/threading-models-in-coroutines-and-android-sqlite-api-6cab11f7eb90?source=collection_archive---------2-----------------------#2019-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/577060d3b329729e4a004d51fb3ba724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSPG9auNmYfzUiWw1MhSHg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="a99c" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">在房间中实施暂停交易</h2></div><p id="d08c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Room 2.1现在允许您通过定义挂起的DAO函数来使用Kotlin协程。协程非常适合执行异步操作。它们允许您编写自然、有序的代码，这些代码可以在数据库等昂贵的资源上运行，而不必在线程之间显式地传递任务、结果和错误。Room的协程支持为您带来了数据库操作中的并发范围、生命周期和嵌套的好处。</p><p id="ec4d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在Room中开发协程支持时，我们最终在协程的线程模型和Android的SQL API之间遇到了一些不可预见的问题。请继续阅读，了解有关这些问题、我们的解决方案和实施的更多信息。</p><h1 id="dea1" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">无法预见的问题</h1><p id="7660" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">看一下下面的代码片段，它看起来很安全，但实际上是坏的😮：</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><blockquote class="ll"><p id="58f2" class="lm ln hx bd lo lp lq lr ls lt lu kh dx translated">Android的SQLite事务是线程受限的</p></blockquote><p id="6849" class="pw-post-body-paragraph jm jn hx jo b jp lv iy jr js lw jb ju jv lx jx jy jz ly kb kc kd lz kf kg kh ha bi translated">问题是Android的SQLite事务是线程受限的。当查询在当前线程上正在进行的事务中执行时，它被视为该事务的一部分，可以继续执行。如果查询是在不同的线程上执行的，那么它不会被视为该事务的一部分，并且会一直阻塞，直到另一个线程上的事务结束。这就是<code class="du ma mb mc md b">beginTransaction</code>和<code class="du ma mb mc md b">endTransaction</code> API允许原子性的方式。当数据库任务完全在一个线程上运行时，这是一个合理的API然而，这对于协程来说是个问题，因为它们没有绑定到任何特定的线程。不能保证挂起后继续协同程序的线程与挂起点之前执行的线程是同一线程。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/49e1e5e3ccfb6bf9324c41fb1ee2b98c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*STuz0AN0jlWq0z1T9Sp9qA.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Database transactions in coroutines can lead to deadlock.</figcaption></figure><h1 id="49df" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">一个简单的实现</h1><p id="8b51" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">为了解决Android的SQLite限制，我们需要一个类似于<code class="du ma mb mc md b">runInTransaction</code>的API来接受一个暂停块。这个API的简单实现可以简单到使用一个单线程调度程序:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="68be" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">上面的实现只是一个开始，但是当在挂起块中使用不同的调度程序时，它很快就崩溃了:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="1816" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">通过接受挂起块，有可能使用不同的调度程序启动子协同例程，这可能会在意外的不同线程中执行数据库操作。因此，一个合适的实现应该允许使用标准的协程构建器，比如<code class="du ma mb mc md b">async</code>、<code class="du ma mb mc md b">launch</code>和<code class="du ma mb mc md b">withContext</code>。实际上，只需要将数据库操作分派给单个事务线程。</p><h1 id="b1e1" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">withTransaction简介</h1><p id="eb82" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">为了实现这一点，我们构建了<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/room/package-summary.html#(androidx.room.RoomDatabase).withTransaction(kotlin.coroutines.SuspendFunction0)" rel="noopener ugc nofollow" target="_blank">withTransaction</a></code> API，它模仿了<code class="du ma mb mc md b">withContext</code> API，但是提供了一个专门为安全房间事务构建的协同程序上下文。这允许您编写代码，例如:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f6fb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当我们深入到Room的<code class="du ma mb mc md b">withTransaction</code> API的实现时，让我们回顾一下已经提到的一些协程概念。一个<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineContext</a></code>保存协程分派工作所需的信息。它携带当前的<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineDispatcher</a></code>、<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">Job</a></code>，可能还有一些附加数据；但是它也可以扩展为包含更多的元素。<code class="du ma mb mc md b">CoroutineContext</code>的一个重要特征是它们被同一协程范围内的子协程继承，例如<code class="du ma mb mc md b">withContext</code>块中的范围。这种机制允许子协程继续使用同一个调度程序，或者当父协程作业被取消时，它们被取消。实质上，Room的挂起事务API创建了一个专门的协同例程上下文，用于在事务范围内执行数据库操作。</p><p id="610d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在由<code class="du ma mb mc md b">withTransaction</code> API创建的上下文中有三个关键元素:</p><ul class=""><li id="8eea" class="mf mg hx jo b jp jq js jt jv mh jz mi kd mj kh mk ml mm mn bi translated">用于执行数据库操作的单线程调度程序。</li><li id="3a7b" class="mf mg hx jo b jp mo js mp jv mq jz mr kd ms kh mk ml mm mn bi translated">一个上下文元素，帮助DAO函数识别它们是否在事务中。</li><li id="da70" class="mf mg hx jo b jp mo js mp jv mq jz mr kd ms kh mk ml mm mn bi translated">一个<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/" rel="noopener ugc nofollow" target="_blank">ThreadContextElement</a></code>标记在事务协程期间使用的调度线程。</li></ul><h1 id="a730" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">事务调度程序</h1><p id="2510" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">一个<code class="du ma mb mc md b">CoroutineDispatcher</code>指示协程将在哪个线程中执行。例如，<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.IO</a></code>使用推荐用于卸载阻塞操作的共享线程池，而<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.Main</a></code>将在Android的主线程中执行协程。由Room创建的事务分派器能够分派到来自<a class="ae hu" href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder.html#setQueryExecutor(java.util.concurrent.Executor)" rel="noopener ugc nofollow" target="_blank"> Room的执行者</a>的单个线程——它没有使用任意的新线程。这一点很重要，因为执行器可由用户配置，并且可用于测试。在事务开始时，Room将获得executor中一个线程的所有权，直到事务完成。在事务期间执行的数据库操作将被分派到事务线程中，即使为子协同例程更改了分派程序。</p><p id="455d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">获取一个事务线程不是一个阻塞操作——不应该是，因为如果没有线程可用，我们应该挂起并让出调用者，以便其他协程可以继续。它还包括将runnable入队并等待它实际执行，这是一个线程变得可用的指示。函数<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>帮助我们在基于回调的API和协程之间架起一座桥梁。在这种情况下，当线程可用时，我们的回调是执行排队的runnable。一旦我们的runnable执行完毕，我们就使用<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" rel="noopener ugc nofollow" target="_blank">runBlocking</a></code>来启动一个事件循环，这个事件循环将获得线程的所有权。然后由<code class="du ma mb mc md b">runBlocking</code>创建的分派器被提取出来，用于将块分派到获取的线程中。此外，使用一个<code class="du ma mb mc md b">Job</code>来挂起和保持线程，直到事务完成。请注意，在协程被取消或无法获取线程时会采取预防措施。获取事务线程的代码片段如下:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="2b88" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">事务上下文元素</h1><p id="f01c" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">有了dispatcher，我们就可以创建一个事务元素，我们可以将它添加到我们的上下文中，并引用dispatcher。这使我们能够将DAO函数重新路由到正确的线程，如果它们是从事务范围内调用的话。我们的交易要素如下:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="b512" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du ma mb mc md b">TransactionElement</code>函数<code class="du ma mb mc md b">acquire</code>和<code class="du ma mb mc md b">release</code>用于跟踪嵌套事务。由于对应的方法<code class="du ma mb mc md b">beginTransaction</code>和<code class="du ma mb mc md b">endTransaction</code>允许嵌套调用，我们理想地希望允许相同的行为；但是我们只需要在最外层的事务完成时释放事务线程。这些功能的用法将在<code class="du ma mb mc md b">withTransaction</code>的实现中给出。</p><h1 id="4d0e" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">事务线程标记</h1><p id="261c" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">前面提到的创建事务上下文所需的最后一个关键元素是一个<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/" rel="noopener ugc nofollow" target="_blank">ThreadContextElement</a></code>。一个<code class="du ma mb mc md b">CoroutineContext</code>中的这个元素类似于一个<code class="du ma mb mc md b"><a class="ae hu" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" rel="noopener ugc nofollow" target="_blank">ThreadLocal</a></code>，它跟踪线程中是否有正在进行的事务。该元素由一个实际的<code class="du ma mb mc md b">ThreadLocal</code>支持；它的工作方式是为调度程序用来执行协程程序块的每个线程的<code class="du ma mb mc md b">ThreadLocal</code>设置一个值。一旦线程执行完该块，该值将被重置。对于我们的用例，这个值是没有意义的；在Room中，这只是一个值是否存在的问题。如果协程上下文可以访问平台中存在的<code class="du ma mb mc md b"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/database/sqlite/SQLiteDatabase.java#96" rel="noopener ugc nofollow" target="_blank">ThreadLocal&lt;SQLiteSession&gt;</a></code>,我们可以从协程所在的任何线程向它分派begin/ends。我们不能，只好阻塞线程，直到事务完成；但是我们仍然需要跟踪每个阻塞数据库方法应该在哪个事务上运行，从而跟踪哪个线程拥有平台事务。</p><p id="af70" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Room的<code class="du ma mb mc md b">withTransaction</code> API使用的<code class="du ma mb mc md b">ThreadContextElement</code>标识阻塞的数据库函数。Room中的阻塞函数，包括生成的Dao中的那些，现在在事务协程中被调用时有了特殊的处理，以确保它们不会在不同的调度程序上运行。这使得在一个<code class="du ma mb mc md b">withTransaction</code>块中混合和匹配阻塞函数和挂起函数成为可能，因为您的DAO仍然混合了这两种类型的函数。通过将<code class="du ma mb mc md b">ThreadContextElement</code>添加到协程上下文并从所有DAO函数中访问它，我们可以验证阻塞函数是否在正确的范围内。如果不是，那么<strong class="jo hy">我们抛出一个错误，而不是导致死锁</strong>。将来，我们计划将阻塞函数重新路由到事务线程中。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ae9b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这三个要素的结合创造了我们的交易环境:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="93a9" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">事务API实现</h1><p id="ce19" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">有了创建的事务上下文，我们现在终于可以为在协程中执行数据库事务提供一个安全的API了。剩下要做的是将这个上下文与通常的开始/结束事务模式结合起来:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure></div><div class="ab cl mt mu go mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ha hb hc hd he"><p id="d2e3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Android的SQLite线程限制是合理的，并且是在Kotlin不存在的时代设计的。同时，协程引入了一种新的范式，改变了传统Java并发的一些思维过程。解除Android的线程限制不是一个可行的解决方案，因为我们想提供一个向后兼容的解决方案。上面提到的东西的组合最终使我们在一个伴随着coroutines-fluent API的解决方案中具有创造性。</p></div></div>    
</body>
</html>