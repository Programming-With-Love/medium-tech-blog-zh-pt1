<html>
<head>
<title>Easier, Better, Faster JSON: 12 Things Developers Will Love About Oracle Database 12c Release 2 Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更简单、更好、更快JSON:开发人员会喜欢的关于Oracle Database 12c第2版第1部分的12件事</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/easier-better-faster-json-12-things-developers-will-love-about-oracle-database-12c-release-2-b478ebbd149f?source=collection_archive---------1-----------------------#2016-11-10">https://medium.com/oracledevs/easier-better-faster-json-12-things-developers-will-love-about-oracle-database-12c-release-2-b478ebbd149f?source=collection_archive---------1-----------------------#2016-11-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9991" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">12.1.0.2为Oracle数据库带来了JSON支持。这有助于您处理存储在clobs或varchar2s中的JSON文档。</p><p id="74e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些太棒了。但是存储原始JSON应该是例外，而不是常规。大多数时候，您应该将JSON文档分解到关系表中。</p><p id="78c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这给你留下了一个问题。以JSON格式获取数据！</p><p id="30d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尝试编写自己的JSON生成器很难。因此，在12.2中，我们提供了一整套选项来帮助您完成工作。</p><h1 id="3a84" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">来自SQL的JSON</h1><p id="2bc7" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">12.2提供了四个关键函数来帮助您编写以JSON格式返回数据的SQL:</p><ul class=""><li id="db16" class="kf kg hh ig b ih ii il im ip kh it ki ix kj jb kk kl km kn bi translated">JSON _对象</li><li id="284e" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">JSON_objectagg</li><li id="8509" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">JSON _数组</li><li id="6b2e" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">JSON_arrayagg</li></ul><p id="32ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用JSON_object*函数创建一系列键值对文档。即输出有花括号{}。JSON_array*函数接受一个值列表，并将其作为一个数组返回，即放在方括号[]中。</p><p id="93c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于输入中的每一行，这些函数的非agg版本都输出一行。agg版本将多行合并到一个文档或数组中。</p><p id="c479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好的。那么这些是如何工作的呢？</p><p id="44c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个例子。</p><p id="e314" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您正在使用经典的雇员和部门表。对于每个部门，您需要一个包含以下内容的JSON文档:</p><ul class=""><li id="34b6" class="kf kg hh ig b ih ii il im ip kh it ki ix kj jb kk kl km kn bi translated">部门名称</li><li id="3dbb" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">一批员工</li><li id="e1b3" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">这个数组的每个元素都应该是自己的文档，列出雇员的姓名和职务。</li></ul><p id="4e9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="fe4d" class="lc jd hh ky b fi ld le l lf lg">{ <br/>  "department": "Accounting", <br/>  "employees": [ { <br/>    "name": "Shelley,Higgins", <br/>    "job": "Accounting Manager" <br/>  }, { <br/>    "name": "William,Gietz", <br/>    "job": "Public Accountant" <br/>  } ] <br/>}</span></pre><p id="7e33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如何使用新函数来创建它呢？</p><p id="22f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从内向外努力:</p><ul class=""><li id="e563" class="kf kg hh ig b ih ii il im ip kh it ki ix kj jb kk kl km kn bi translated">首先，您需要为每个员工准备一份文档。这有两个属性，name和job。将这些传递给JSON_object调用。</li><li id="e8f5" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">然后你需要把这些变成一个数组。所以将JSON_object包装在一个JSON_arrayagg中。按部门分组，将每个部门的雇员划分到单独的数组中。</li><li id="316d" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">最后，每个部门都有一个文档。因此，您需要另一个带有部门和雇员属性的JSON_object。这些值是部门名称和上一步中JSON_arrayagg调用的结果。</li></ul><p id="e099" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将所有这些放在一起，您会得到:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9ede" class="lc jd hh ky b fi ld le l lf lg">select json_object (<br/>  'department' value d.department_name, <br/>  'employees' value json_arrayagg ( <br/>    json_object ( <br/>      'name' value first_name || ',' || last_name, <br/>      'job' value job_title <br/>    )<br/>  )<br/>) <br/>from  hr.departments d, hr.employees e, hr.jobs j <br/>where d.department_id = e.department_id <br/>and   e.job_id = j.job_id <br/>group by d.department_name;</span></pre><p id="40ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">瞧啊。你有你的JSON！</p><figure class="kt ku kv kw fd li er es paragraph-image"><div class="er es lh"><img src="../Images/76011dadf6df62fdfdff7c4194b22f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*z4oTgB5qdXijTL8U.png"/></div></figure><h1 id="144e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">PL/SQL中的JSON</h1><p id="a980" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在您有了JSON文档。但是如果要编辑呢？</p><p id="2314" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您想将名称改为大写。并添加一个标题元素。所以前面的文档变成了:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7793" class="lc jd hh ky b fi ld le l lf lg">{ <br/>  "department": "Accounting", <br/>  "employees": [ { <br/>    "name": "SHELLEY,HIGGINS", <br/>    "job": "Accounting Manager", "title": "" <br/>  }, {<br/>    "name": "WILLIAM,GIETZ", <br/>    "job": "Public Accountant", <br/>    "title": "" <br/>  } ] <br/>}</span></pre><p id="35ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您正在生成文档，最简单的方法就是将它们添加到SQL中！因此，这假设您想要从外部来源更改JSON文档。</p><p id="a8e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了帮助解决这个问题，有了新的PL/SQL对象。这些使您能够通过get/put调用访问、修改JSON文档并向其中添加元素。</p><p id="2438" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关键对象类型包括:</p><ul class=""><li id="b315" class="kf kg hh ig b ih ii il im ip kh it ki ix kj jb kk kl km kn bi translated">json_element_t —文档和数组的超类型</li><li id="2b73" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">json_object_t —用于处理json文档</li><li id="4f9c" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">json_array_t —用于使用json数组</li></ul><p id="536d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您需要做的第一件事是创建JSON对象。通过解析文档来实现:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4289" class="lc jd hh ky b fi ld le l lf lg">doc := json_object_t.parse(' {<br/>  "department": "Accounting", <br/>  "employees": [ { <br/>    "name": "Shelley,Higgins", <br/>    "job": "Accounting Manager" <br/>  }, { <br/>    "name": "William,Gietz", <br/>    "job": "Public Accountant" } ] <br/>  } '<br/>);</span></pre><p id="642b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，您可以使用get来访问employees数组:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4ff6" class="lc jd hh ky b fi ld le l lf lg">emps := treat(doc.get('employees') as json_array_t) ;</span></pre><p id="94ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">treat函数将元素转换为适当的类型(这里是JSON_array_t)。</p><p id="13b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦有了数组，就可以遍历雇员。如果不存在，Put会添加一个新键。否则，它会覆盖现有值。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7cc5" class="lc jd hh ky b fi ld le l lf lg">for i in 0 .. emps.get_size - 1 loop <br/>  emp := treat(emps.get(i) as json_object_t); <br/>  emp.put('title', ''); <br/>  emp.put('name', upper(emp.get_String('name'))); <br/>end loop;</span></pre><p id="66fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">get函数返回对原始对象的引用。所以如果你得到一些JSON并修改它，原始文档也会改变！</p><p id="c2bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果不希望这样，那么在得到元素时克隆它。例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="2dc2" class="lc jd hh ky b fi ld le l lf lg">emps := treat(doc.get('employees') as json_array_t).clone</span></pre><p id="43ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，转换JSON的完整PL/SQL块是:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b553" class="lc jd hh ky b fi ld le l lf lg">declare <br/>  doc json_object_t; <br/>  emps json_array_t; <br/>  emp json_object_t; <br/>begin <br/>  doc := json_object_t.parse('{ <br/>      "department": "Accounting", <br/>      "employees": [ { <br/>        "name": "Shelley,Higgins", <br/>        "job": "Accounting Manager" <br/>      }, { <br/>        "name": "William,Gietz", <br/>        "job": "Public Accountant" <br/>      } ] <br/>    }'<br/>  ); </span><span id="2018" class="lc jd hh ky b fi ll le l lf lg">  emps := treat(doc.get('employees') as json_array_t) ; </span><span id="7aa4" class="lc jd hh ky b fi ll le l lf lg">  for i in 0 .. emps.get_size - 1 loop <br/>    emp := treat(emps.get(i) as json_object_t); <br/>    emp.put('title', ''); <br/>    emp.put('name', upper(emp.get_String('name'))); <br/>  end loop;   </span><span id="cdec" class="lc jd hh ky b fi ll le l lf lg">  dbms_output.put_line(doc.to_String); <br/>end; <br/>/<br/>{ <br/>  "department": "Accounting", <br/>  "employees": [ { <br/>    "name": "SHELLEY,HIGGINS", <br/>    "job": "Accounting Manager", <br/>    "title": "" <br/>  }, { <br/>    "name": "WILLIAM,GIETZ", <br/>    "job": "Public Accountant", <br/>    "title": "" <br/>  } ] <br/>}</span></pre><p id="3857" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您可以从SQL生成JSON，并在PL/SQL中对其进行更改，您有强大的选项来处理它。</p><p id="ad97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在12.2版本中，JSON的功能还有很多其他的改进。其他增强功能包括:</p><ul class=""><li id="b7f2" class="kf kg hh ig b ih ii il im ip kh it ki ix kj jb kk kl km kn bi translated">JSON_exists函数</li><li id="c02a" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">支持内存、分区和物化视图</li><li id="e082" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">搜索索引</li><li id="c271" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">杰奥森</li><li id="11a7" class="kf kg hh ig b ih ko il kp ip kq it kr ix ks jb kk kl km kn bi translated">JSON数据指南</li></ul><p id="9241" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你非常想使用JSON，我推荐<a class="ae lm" href="https://docs.oracle.com/database/122/ADJSN/changes.htm#ADXDB6162" rel="noopener ugc nofollow" target="_blank">看看这些</a>。</p></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="541f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【blogs.oracle.com】全文原载于2016年11月10日<a class="ae lm" href="https://blogs.oracle.com/sql/12-things-developers-will-love-about-oracle-database-12c-release-2" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a><em class="lu">。</em></p></div></div>    
</body>
</html>