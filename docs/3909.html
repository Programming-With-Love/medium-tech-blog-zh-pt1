<html>
<head>
<title>From Patterns to Hexagons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从图案到六角形</h1>
<blockquote>原文：<a href="https://medium.com/globant/from-patterns-to-hexagons-ace6ce62351a?source=collection_archive---------1-----------------------#2022-07-05">https://medium.com/globant/from-patterns-to-hexagons-ace6ce62351a?source=collection_archive---------1-----------------------#2022-07-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c880" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">从基本原则出发导出软件架构</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/22dd322fa699761b1c1e1a5c28b15d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4_5ya5E-lfn5OX45"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@dotnny?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Donny Jiang</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6ad0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">保持更新总是至关重要的，尤其是在技术领域。对我来说，重要的是不仅要知道新的算法、结构、设计原则等等。而且要充分理解我们如何获得它们，不仅仅是能够使用一种新工具，而是真正了解我们为什么应该应用它。</p><p id="0940" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在本文中，我们将研究如何开发一个服务器。从像SOLID、设计模式和函数式编程这样的基本原则开始，我们将得到一个具有一些好的特性的软件架构，重新发现一个强大的系统设计方法；激动人心的结果！</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="3c03" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">从一个问题开始</h1><p id="24b8" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">先说一个简单的问题…下图怎么了？我们有一个运行在服务器上的基本服务。服务接收请求，与其他实体交互(右边:更多云服务、区块链、文件系统、电子邮件服务、数据库、消息队列、文件桶等。)，并最终构建一个响应，将它发送回来。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/0f09f6ae692dba11e1b5eae0f62a7f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewKmGtlqQyDShd4d-Le8sA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">A basic service receives requests, does some work, and sends back responses… what's wrong here?</figcaption></figure><p id="3020" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这是一种相当普遍的情况，那么“<em class="lo">这幅图有什么问题呢？</em>”问题有一个简单的答案:“<em class="lo">没什么！</em>”。然而，如果我们再深入一点(并沉溺于一点夸张……)我们可能会把答案变成“<em class="lo">一切！</em>“—怎么会呢？</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="1448" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">要问的三个问题</h1><p id="d050" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">毫无疑问，这项服务是有效的，类似的实现随处可见。但是，我想问三个问题:</p><ul class=""><li id="b2b3" class="lp lq hh jp b jq jr jt ju jw lr ka ls ke lt ki lu lv lw lx bi translated">第一:理解代码有多容易？代码可能难以理解，因为它将业务逻辑问题与外部问题的实现细节混在一起，例如如何调用服务、更新数据库或访问消息队列。</li><li id="e371" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">第二:改代码有多简单？有多少改变的理由？如果我们谈论商业逻辑，必须改变它总是一种可能性。但是，如果我们谈论改变，比如说，数据库使用Redis代替呢？或者，如果我们选择将元组添加到数据库中，而不是将消息发送到队列中？并非所有变更的原因都与服务的实际业务目标相关，这是相关的。</li><li id="2add" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">第三，我们主要关心的是:测试代码有多简单？变化可能会出现，也可能不会出现，但是我们确实必须测试我们的代码，那么我们该如何着手呢？</li></ul><p id="6b75" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后一个问题是最有趣的一个，我们会回答它——但还不是时候；我们先绕道进入函数式编程(FP)来获得一些见解！</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="3ab3" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">绕道进入FP</h1><p id="e746" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">在<a class="ae jm" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>中，有一个重要的概念:<em class="lo">纯函数</em>。纯函数在某些方面与数学函数非常相似。让我们阐明一些性质，然后看一些例子。</p><ul class=""><li id="2f2b" class="lp lq hh jp b jq jr jt ju jw lr ka ls ke lt ki lu lv lw lx bi translated">如果给定相同的参数，纯函数总是返回相同的结果。如果您的代码依赖于数据库查询返回的内容，那么函数的行为方式每次都不一样；即使查询仍然相同，结果也可能不同。一个纯函数不会返回不同的结果。</li><li id="1e3f" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">纯函数没有副作用。副作用可能是修改系统全局状态的任何事情:向控制台写入消息、更新数据库、更改全局变量的值等。，都是副作用。</li><li id="1dc3" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">由于前面的两个属性，纯函数非常适合测试…但是在实际工作中很少使用！如果一个函数不被允许访问文件、发送消息或改变任何东西，那它还有什么用呢？</li></ul><p id="8740" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们来看一个简单的纯函数和不纯函数的例子。下面我们有两个简单的函数。第一个函数接收两个参数并返回其和。如果您必须测试这个函数，那将是轻而易举的事情:用几个测试用例调用它，并验证结果是正确的。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="5d0a" class="mi kr hh me b fi mj mk l ml mm">const sum = (a, b) =&gt; { <br/>  return a+b;<br/>}</span><span id="86f6" class="mi kr hh me b fi mn mk l ml mm">const sum = (a, b) =&gt; {<br/><strong class="me hi">  console.log("Sum", a, b); // side effect!</strong><br/>  return a+b;<br/>}</span></pre><p id="388c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">另一方面，第二个函数有一个副作用:它记录了一些东西。每次用一对参数调用它时，它都会进一步修改系统的全局状态——也就是说，控制台上会出现更多的消息。(记住这是一个简单的例子；该函数可以很好地修改数据库或完成任何其他状态更改。)</p><p id="084e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">回到我们之前的问题:如何测试这个函数？现在事情没那么容易了。当然，您可以检查返回值，但是您如何验证某些东西被记录了呢？(对于更复杂的例子，如何确认数据库已经更新，远程服务已经调用，事件已经触发，等等。等。？)这是我们关心的问题。</p><p id="6e6a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们考虑测试一个不纯的函数，并尝试应用我们得到的任何答案来解决本文开始时测试服务的问题。我们如何测试一个不纯的功能——比如我们的服务？我想到了三种方法:</p><ul class=""><li id="7c7c" class="lp lq hh jp b jq jr jt ju jw lr ka ls ke lt ki lu lv lw lx bi translated">我们可以在完全不同的环境中工作。这要求每个开发人员拥有一个完整的环境(他自己版本的数据库、外部服务、队列、服务器等)。).在任何测试运行之后，他应该检查数据库是否被正确修改，消息是否被发送，等等。这当然是可能的，但是成本很高，很难设置，并且导致测试非常慢——在每次测试之前，您必须将环境重置为某个已知状态，并且在每次测试之后，您必须到处进行多次检查。</li><li id="80c7" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated"><strong class="jp hi">或者，我们可以与完全模拟的外部实体合作</strong>。诸如<a class="ae jm" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>或<a class="ae jm" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>之类的单元测试工具允许模仿实体，因此您可以建立一个模仿所需行为的模仿，而不是提供实际的数据库、外部服务或队列。这种方式效率更高——因为不需要更新实际的数据库，不需要调用服务，等等。—但是模拟行为仍然意味着大量的工作。</li><li id="f41a" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">或者，我们可以先降低函数的不纯度！这是我们想要采用的方法。如果我们有办法从要测试的函数中去除杂质(这可能吗？？)写测试会容易很多。</li></ul><p id="d076" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们回到我们的副作用产生函数。我们可以重写如下。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="4c75" class="mi kr hh me b fi mj mk l ml mm">const sum = (a, b, <strong class="me hi">logger=console.log</strong>) =&gt; {<br/>    <strong class="me hi">logger(a, b);</strong><br/>    return a+b;<br/>}</span></pre><p id="b10a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们给这个函数添加了一个参数，默认情况下是<code class="du mo mp mq me b">console.log</code>日志记录函数。如果我们像调用<code class="du mo mp mq me b">sum(22,9)</code>一样调用这个函数，它将记录22和9并返回31，就像之前一样。然而，有一个关键的区别:出于测试目的，我们可以提供一个不同的<code class="du mo mp mq me b">logger</code>模拟函数，这将简化一切！</p><p id="d589" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这种解决方案是众所周知的……但是我们是如何得到它的呢？答案需要谈论其他的原则:让我们再走一段弯路，讨论坚实的原则和设计模式。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="55e1" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">第二个弯路:实体和设计模式</h1><p id="0f9a" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">在OOP (Object Oriented Programming)中，<a class="ae jm" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> SOLID </a>是首字母缩写，代表五个原则:<a class="ae jm" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"><strong class="jp hi">S</strong>single-respons ibility</a>，<a class="ae jm" href="https://en.wikipedia.org/wiki/Open-closed_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> O </strong> pen-Closed </a>，<a class="ae jm" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> L </strong> iskov替换</a>，<a class="ae jm" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> I </strong>接口隔离</a>，以及<a class="ae jm" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> D </strong>依赖倒置</a>我们不想深入讨论所有五个，相反，我们将只关注其中两个:<strong class="jp hi"> O </strong>和<strong class="jp hi"> D </strong>。</p><ul class=""><li id="dd04" class="lp lq hh jp b jq jr jt ju jw lr ka ls ke lt ki lu lv lw lx bi translated"><strong class="jp hi"> O </strong>代表“开-闭”，表示实体(函数、方法等。)应该是“对扩展开放，但对修改关闭”，这意味着我们应该能够扩展它的行为，而不必修改它的代码。对于我们不纯的<code class="du mo mp mq me b">sum</code>函数来说，如果我们要改变一些东西被记录的方式，我们应该能够在不改变我们的原始函数的情况下实现它。</li><li id="5c91" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated"><strong class="jp hi"> D </strong>代表“依赖倒置”，要求较高层实体应该独立于较低层实体的实现细节。较高级别的实体不应该从较低级别的实体导入任何东西，而应该依赖抽象(接口)；具体的实现应该提供必要的细节来使事情运转起来。在我们的例子中，修改后的<code class="du mo mp mq me b">sum</code>函数只需要知道如何使用提供给它的任何<code class="du mo mp mq me b">logger</code>函数——也就是它的接口。具体的细节(比如，使用<code class="du mo mp mq me b">console.log</code>来记录一些东西)不应该涉及我们的原始功能。</li></ul><p id="3399" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们如何实现这些想法？一个<a class="ae jm" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>会有所帮助——这就是我们已经做的！<a class="ae jm" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank"> <em class="lo">依赖注入</em> </a>模式是一个实体如何接收它所依赖的任何其他实体。在我们的不纯函数的情况下，我们提供(“注入”)了一个日志记录实体，将这个问题从原始函数中分离出来。我们可以实现我们的<strong class="jp hi"> O </strong>和<strong class="jp hi"> D </strong>原则:我们可以改变或扩展函数的行为，而不必重写它，函数本身完全独立于日志记录是如何完成的；它只是要求注入的日志记录器对应于一个特定的接口。</p><p id="a80f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">依赖注入是如何实现的？基本上有三种方法:通过类的构造函数，通过类中的setter方法，或者通过向函数或方法传递参数——这正是我们所做的，但是让我们先回到我们最初的服务！</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="1ada" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">关于架构和节点服务的一些思考</h1><p id="f0bb" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">我们将通过应用我们在上一节中得到的解决方案来实现我们的服务。我们来看下图。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mr"><img src="../Images/3dfc1991c6404f5525dbf61e11573768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cixj1PCROm5lj0tgkF3jxQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">The "Ports and Adapters" -or "Hexagonal"- Architecture Pattern</figcaption></figure><p id="509d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们仍然将我们的服务放在中心(“核心”)，但是它将指定“端口”(接口)并接收“适配器”(接口实现)，通过它们它将连接到外部实体。有了这个“端口和适配器”架构，我们将能够插入不同的模块来做不同的事情，就像我们能够为不纯的<code class="du mo mp mq me b">sum</code>函数提供不同的<code class="du mo mp mq me b">logger</code>参数一样。</p><p id="546a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">对于正常工作，服务将被注入调用服务、与区块链交互、发送消息等功能。对于测试工作，服务将被注入模拟适配器，具有相同的端口规范，但只是一个简单的“什么都不做”的实现。</p><blockquote class="ms mt mu"><p id="cad2" class="jn jo lo jp b jq jr ii js jt ju il jv mv jx jy jz mw kb kc kd mx kf kg kh ki ha bi translated">“端口和适配器”架构更广为人知的名称是“<a class="ae jm" href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" rel="noopener ugc nofollow" target="_blank">六角形架构</a>”，一个更吸引人的名字！</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="d1a9" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">实现服务</h1><p id="7284" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">让我们考虑一个简单的服务，我们希望在一个<a class="ae jm" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a> + <a class="ae jm" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>服务器中实现它，一个常见的组合:</p><ul class=""><li id="09ac" class="lp lq hh jp b jq jr jt ju jw lr ka ls ke lt ki lu lv lw lx bi translated">端点响应<code class="du mo mp mq me b">GET /client/:id</code>请求</li><li id="b26b" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">该服务在数据库中搜索给定的客户端</li><li id="2c83" class="lp lq hh jp b jq ly jt lz jw ma ka mb ke mc ki lu lv lw lx bi translated">该服务向队列发送消息</li></ul><p id="74b9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">该服务需要两个端口和两个适配器；让我们用客户端数据库相关的一个，另一个将是类似的。节点项目的通常架构将会变成这样:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es my"><img src="../Images/80e2dcf0d8ba1d37e4f38fe9120a907c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYqxAIyyvgL_-OlAgtDb0Q.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">The basic structure of a Node project, with ports and adapters added in</figcaption></figure><p id="3ba2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">大多数目录已经为开发人员所熟知；我们只是添加了所有端口和适配器将驻留的<code class="du mo mp mq me b">adapters_and_ports</code>目录。<code class="du mo mp mq me b">services</code>目录将有服务的实现，这将和以前一样，除了它们将被编码为与端口和适配器一起工作。让我们看看这在实践中是如何实现的，使用TypeScript可以更清楚地了解所涉及的数据类型。</p><p id="5620" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">首先，要在数据库中找到一个客户机，我们必须定义它的接口。在我们的例子中，我们定义了<code class="du mo mp mq me b">FindClientPort</code>:一个接收数字<code class="du mo mp mq me b">id</code>作为参数的函数，并返回一个承诺，该承诺要么返回一个客户端(如果找到的话)，要么返回<code class="du mo mp mq me b">null</code>(否则)。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="7993" class="mi kr hh me b fi mj mk l ml mm">type FindClientPort = <br/>  (id:number) =&gt; Promise&lt;ClientType | null&gt;;</span><span id="a334" class="mi kr hh me b fi mn mk l ml mm">const findClientFromDBAdapter: FindClientPort =<br/>  async (id:number) =&gt; {<br/>  // return a promise to get the client from DB<br/>};</span></pre><p id="531e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们还可以看到一个特定的适配器:<code class="du mo mp mq me b">findClientFromDBAdapter</code>是<code class="du mo mp mq me b">FindClientPort</code>接口的具体实现，它恰好访问一个数据库。注意关于命名的一个重要细节:端口不<em class="lo">而</em>说客户机应该来自哪里，但是适配器说。不同的适配器可以在其他地方寻找客户端(文件系统？钥匙店？)，但是它们都会实现相同的接口。</p><p id="9429" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将如何编写服务？代码如下所示。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="7d6a" class="mi kr hh me b fi mj mk l ml mm">function getClientService(id, <br/>  <strong class="me hi">{ findClient, sendMsg }</strong> = <br/><strong class="me hi">  { findClient: findClientFromDBAdapter, <br/>    sendMsg: sendMsgAdapter }</strong>) { <br/>  … <br/>}</span></pre><p id="3016" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">工作方式类似于我们使<code class="du mo mp mq me b">sum</code>函数不那么不纯的时候，我们为所需的适配器添加了一个(可选的)参数。如果省略该参数，我们将使用两个默认适配器来访问数据库并发送消息。在Express中，我们将如下使用<code class="du mo mp mq me b">getClientService</code>。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="6ab1" class="mi kr hh me b fi mj mk l ml mm">app.get("/client/:id", <br/>  (req) =&gt; getClientService(req.params.id));</span></pre><p id="a97a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当我们收到对<code class="du mo mp mq me b">/client/:id</code>端点的请求时，我们调用我们的服务代码而不提供任何适配器——这意味着将使用标准适配器，并且服务将按预期运行。关键区别在于测试；让我们来看看实际测试的一部分。</p><pre class="ix iy iz ja fd md me mf mg aw mh bi"><span id="1e4f" class="mi kr hh me b fi mj mk l ml mm">findClientMock = jest.fn().mockResolvedValue(...);  // [1]<br/>sendMsgMock = jest.fn().mockReturnValue(...);</span><span id="f146" class="mi kr hh me b fi mn mk l ml mm">result = await getClientService(22,                 // [2]<br/>  { findClient: findClientMock, <br/>    sendMsg: sendMsgMock });</span><span id="1039" class="mi kr hh me b fi mn mk l ml mm">expect(findClientMock).toHaveBeenCalledWith(22);    // [3]<br/>expect(sendMsgMock).toHaveBeenCalledWith(...);<br/>expect(result).toMatchObject(...);</span></pre><p id="0d52" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们首先定义[1]一对模拟函数；<code class="du mo mp mq me b">findClientMock</code>将模拟它找到了某个客户端，而<code class="du mo mp mq me b">sendMsgMock</code>将返回成功的消息发送操作将返回的任何内容。然后我们可以[2]调用<code class="du mo mp mq me b">getClientService</code>，但是要提供我们的两个(模拟)适配器。最后[3],我们可以验证一个适配器被用来寻找正确的客户端，另一个适配器被调用以发送正确的消息，以及服务返回正确的答案。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="f7c2" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">摘要</h1><p id="7b3e" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">我们在这里取得了什么成就？我们从一个(不太)简单的服务开始，担心它的维护和测试。然后，我们走了一些弯路，进入了关于纯函数的函数式编程概念、关于实体之间关系的坚实原则以及依赖注入设计模式，从中我们导出了一种使函数“不那么不纯”的方法……这使我们重新发明了“端口和适配器”(或“六角形”)架构！</p><p id="a84d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可以阅读关于架构的书籍，学习如何设计和实现它，但不知何故，我发现如果我能完全理解设计的所有动机和原因，并设法自己推导出它，我会更满意；希望你同意！</p></div></div>    
</body>
</html>