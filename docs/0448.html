<html>
<head>
<title>Room 🔗 Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间🔗流动</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-flow-273acffe5b57?source=collection_archive---------0-----------------------#2019-12-17">https://medium.com/androiddevelopers/room-flow-273acffe5b57?source=collection_archive---------0-----------------------#2019-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1dd6e3d4207739f4dd0ea09488b1b739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AWxyQ-i-fQGmgLPsTn1PYA.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Flow support in Room</figcaption></figure><div class=""/><p id="97cc" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Room中的协程支持在每个版本中都有所增加:Room 2.1增加了对单次读/写操作的<a class="ae jr" rel="noopener" href="/androiddevelopers/room-coroutines-422b786dc4c5">协程支持</a>，而Room 2.2现在支持可观察的读操作，并通过<code class="du js jt ju jv b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener ugc nofollow" target="_blank">Flow</a></code>使您能够获得数据库中变化的通知。</p><figure class="jx jy jz ka fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jw"><img src="../Images/63e80c6f02905e56fa26fd2a1d965745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jEnmX0FZOBDdJIHK"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Room async queries support</figcaption></figure><h1 id="95da" class="kb kc hw bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">行动中的流动</h1><p id="f744" class="pw-post-body-paragraph it iu hw iv b iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ld jo jp jq ha bi translated">假设我们有一个狗的数据库，其中名字是主键，因此，我们不能在数据库中有2只同名的狗。</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="d003" class="li kc hw jv b fi lj lk l ll lm">@Entity<br/>data class Dog (<br/>    @PrimaryKey val name: String,<br/>    val cuteness: Int,<br/>    val barkingVolume: Int<br/>)</span></pre><p id="f00d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了显示狗的完整列表以及它们的所有信息，我们将在我们的<a class="ae jr" href="https://developer.android.com/training/data-storage/room/accessing-data" rel="noopener ugc nofollow" target="_blank"> DAO </a>中编写这样一个查询:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="2f3e" class="li kc hw jv b fi lj lk l ll lm">@Query("SELECT * FROM Dog")<br/>fun getAllDogs(): List&lt;Dog&gt;</span></pre><p id="65b4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因为狗的吠叫音量会随着时间的推移而变化，我们希望确保我们的UI是最新的，所以我们希望在Dogs表中发生的每一次变化都得到通知:添加新的狗、删除或更新狗。为此，我们更新查询以返回<code class="du js jt ju jv b">Flow</code>:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="bb35" class="li kc hw jv b fi lj lk l ll lm">@Query("SELECT * FROM Dog")<br/>fun getAllDogs(): <strong class="jv hx">Flow</strong>&lt;List&lt;Dog&gt;&gt;</span></pre><p id="1f94" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像这样，每当数据库中的狗被更新，那么狗的整个列表<strong class="iv hx">被再次发出。例如，假设我们在数据库中有以下数据:</strong></p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="4472" class="li kc hw jv b fi lj lk l ll lm">(Frida, 11, 3)</span><span id="7e96" class="li kc hw jv b fi ln lk l ll lm">(Bandit, 12, 5)</span></pre><p id="9e90" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我们第一次呼叫<code class="du js jt ju jv b">getAllDogs</code>时，我们的<code class="du js jt ju jv b">Flow</code>会发出:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="231e" class="li kc hw jv b fi lj lk l ll lm">[(Frida, 11, 3), (Bandit, 12, 5)]</span></pre><p id="b3b7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果班迪特变得兴奋，他的吠叫音量被更新为6: <code class="du js jt ju jv b">(Bandit, 12, 6)</code>，则<code class="du js jt ju jv b">Flow</code>将再次发出，狗表的全部内容都是最新值:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="fdd6" class="li kc hw jv b fi lj lk l ll lm">[(Frida, 11, 3), <strong class="jv hx">(Bandit, 12, 6)</strong>]</span></pre><p id="3a94" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在让我们说，我们可以在一个新的屏幕中打开一个狗的细节。因为我们也想确保我们总是拥有关于狗的最新数据并实时获得更新，所以我们返回一个<code class="du js jt ju jv b">Flow</code>:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="f245" class="li kc hw jv b fi lj lk l ll lm">@Query("SELECT * FROM Dog WHERE name = :name")<br/>fun getDog(name: String): Flow&lt;Dog&gt;</span></pre><p id="002c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，如果我们调用<code class="du js jt ju jv b">getDog("Frida")</code>，<code class="du js jt ju jv b">Flow</code>将返回一个对象:<code class="du js jt ju jv b">(Frida, 11, 3)</code>。</p><p id="24b4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">每当对表进行任何更改时，不管哪一行被更改，查询都将被重新触发，并且<code class="du js jt ju jv b">Flow</code>将再次发出。因此，如果弗里达得到更新，我们将收到最新的信息。</p><p id="0129" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，数据库的这种行为也意味着，如果我们更新一个不相关的行，比如Bandit，我们的<code class="du js jt ju jv b">Flow</code>将再次发出，结果是相同的:<code class="du js jt ju jv b">(Frida, 11, 3)</code>。因为SQLite数据库触发器只允许表级别的通知，而不允许行级别的通知，所以Room无法知道表数据中到底发生了什么变化，因此它重新触发DAO中定义的查询。在您的代码中，使用像<code class="du js jt ju jv b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html" rel="noopener ugc nofollow" target="_blank">distinctUntilChanged</a></code>这样的<code class="du js jt ju jv b">Flow</code>操作符，以确保您只在感兴趣的数据发生变化时得到通知:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="7aee" class="li kc hw jv b fi lj lk l ll lm">@Dao<br/>abstract class DoggosDao {</span><span id="209c" class="li kc hw jv b fi ln lk l ll lm">    @Query("SELECT * FROM Dog WHERE name = :name")<br/>    abstract fun getDog(name: String): Flow&lt;Dog&gt;</span><span id="15d0" class="li kc hw jv b fi ln lk l ll lm">    fun getDogDistinctUntilChanged(name:String) =   <br/>           getDog(name).distinctUntilChanged()<br/>}</span></pre></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="5b59" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过使用<code class="du js jt ju jv b">Flow</code>的可观察读取开始获得数据库变化的通知！加上Jetpack库中添加的其他协同程序支持，如<a class="ae jr" href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecycle-aware" rel="noopener ugc nofollow" target="_blank">生命周期感知协同程序作用域</a>、<a class="ae jr" href="https://developer.android.com/topic/libraries/architecture/coroutines#suspend" rel="noopener ugc nofollow" target="_blank">暂停生命周期感知协同程序</a>或<a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">从</a> <code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">Flow</a></code> <a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">到</a> <code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>的转换，您现在可以在整个应用程序中使用协同程序和流程。</p><p id="653b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要了解更多关于在您的应用程序中使用<code class="du js jt ju jv b">Flow</code>的信息，请查看<a class="ae jr" rel="noopener" href="/androiddevelopers/lessons-learnt-using-coroutines-flow-4a6b285c0d06">这篇文章</a>，了解在Android Dev Summit 2019应用程序中使用<code class="du js jt ju jv b">Flow</code>时学到的经验。</p></div></div>    
</body>
</html>