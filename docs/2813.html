<html>
<head>
<title>Object Detection Tutorial in TensorFlow- Perform Real-Time Object Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow中的对象检测教程-执行实时对象检测</h1>
<blockquote>原文：<a href="https://medium.com/edureka/tensorflow-object-detection-tutorial-8d6942e73adc?source=collection_archive---------0-----------------------#2018-08-20">https://medium.com/edureka/tensorflow-object-detection-tutorial-8d6942e73adc?source=collection_archive---------0-----------------------#2018-08-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a6de77e863eae91b3975a0255b7797ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*52Au-Wwxy50dEA-VIyJrfA.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Object Detection in TensorFlow — Edureka</figcaption></figure><p id="307e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建能够在单个图像中识别和定位多个对象的准确的机器学习模型仍然是计算机视觉中的核心挑战。但是，随着深度学习<strong class="ir hi">的最新进展，物体检测</strong>应用程序比以往任何时候都更容易开发。TensorFlow的对象检测API是一个基于TensorFlow构建的开源框架，可以轻松构建、训练和部署对象检测模型。伙计们，在这个物体检测教程中，我将涉及以下主题:</p><ul class=""><li id="9d66" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">什么是物体检测？</li><li id="c516" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">目标检测的不同应用</li><li id="3563" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">对象检测工作流程</li><li id="dc74" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">什么是张量流？</li><li id="74fd" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用Tensorflow进行物体检测(演示)</li><li id="8ba6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">实时/活动物体检测(演示)</li></ul><h1 id="c3ab" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是物体检测？</h1><p id="9eab" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">对象检测是在静止图像或视频中寻找真实世界对象实例的过程，如汽车、自行车、电视、花和人。它允许识别、定位和检测图像中的多个对象，这为我们提供了对图像整体的更好理解。它通常用于图像检索、安全、监控和高级驾驶辅助系统(ADAS)等应用。</p><p id="72d0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">物体检测可以通过多种方式完成:</p><ul class=""><li id="32d4" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">基于特征的目标检测</li><li id="1bd5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Viola Jones对象检测</li><li id="e7b9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">具有猪特征的SVM分类</li><li id="ba6a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">深度学习对象检测</li></ul><p id="4b25" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本对象检测教程中，我们将重点关注<strong class="ir hi">深度学习对象检测</strong>，因为Tensorflow使用深度学习进行计算。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es le"><img src="../Images/c1b26e90f5ec7f06c03d802134fd0c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ZNWMrxtmS9EU_X-QDOhKgg.png"/></div></figure><p id="c152" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们继续学习目标检测教程，了解它在行业中的各种应用。</p><h1 id="8824" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">物体检测的应用</h1><h2 id="6fa8" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">面部识别:</h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/a851161167a12599e2f2b451fe565d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*LpqpcgIG9Lt3c5DyjD_9rg.jpeg"/></div></figure><p id="4da6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个名为“<strong class="ir hi"> DeepFace </strong>的深度学习面部识别系统已经由脸书<strong class="ir hi">、</strong>的一组研究人员开发出来，它可以非常有效地识别数字图像中的人脸。<strong class="ir hi">谷歌</strong>在Google Photos中使用自己的面部识别系统，该系统会根据图像中的人自动隔离所有照片。面部识别涉及各种组件，如眼睛、鼻子、嘴和眉毛。</p><h2 id="4b8e" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">人数统计:</h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/7af0b0bf30c16dffd3f7ccad023235ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*VSU8c6e6SGbeO89JOocOJA.png"/></div></figure><p id="048c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">物体检测也可用于人数统计，用于分析商店业绩或节日期间的<strong class="ir hi">人群统计</strong>。随着人们快速移出画面，这些往往变得更加困难。</p><p id="ba94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个非常重要的应用程序，因为在人群聚集期间，该功能可以用于多种目的。</p><h2 id="a053" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">工业质量检查:</h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/9aec4f258028987443483a6311c73811.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*7ijtvXqK6TaVAmDFMYhOjw.png"/></div></figure><p id="c56f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对象检测也用于工业过程中识别产品。通过视觉检测找到特定的物体是一项基本任务，涉及分拣、库存管理、加工、质量管理、包装等多个工业过程。</p><p id="dd83" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">库存管理可能非常棘手，因为物品很难实时跟踪。自动物品计数和定位可提高库存准确性。</p><h2 id="2461" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">无人驾驶汽车:</h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/7e33a7a4133e1f67f725f5dc375f4480.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*T10jKYe4FWQm5X6VpzVVzA.png"/></div></figure><p id="27d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无人驾驶汽车是未来，这一点毋庸置疑。但其背后的工作非常棘手，因为它结合了多种技术来感知周围环境，包括雷达，激光，GPS，里程计和计算机视觉。</p><p id="efeb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">先进的控制系统解释传感信息，以识别适当的导航路径以及障碍，一旦图像传感器检测到路径上有任何生物的迹象，它就会自动停止。这种情况发生的速度非常快，是向无人驾驶汽车迈出的一大步。</p><h2 id="62c1" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">安全性:</h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/e278815f696d5822d759341841a1df49.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*Du7AKPGHteyhHDx11Nzg9A.png"/></div></figure><p id="df1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目标检测在安全中起着非常重要的作用。无论是苹果的face ID还是所有科幻电影中使用的视网膜扫描。</p><p id="c8a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">政府也用它来访问安全信号，并将其与现有的数据库进行匹配，以找到任何罪犯或检测劫匪的车辆。</p><p id="2ae9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用是无限的。</p><h1 id="365a" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">对象检测工作流程</h1><p id="5107" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">每个对象检测算法都有不同的工作方式，但它们都基于相同的原理。</p><p id="ab5c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">特征提取:</strong>他们从手头的输入图像中提取特征，并利用这些特征来确定图像的类别。无论是通过MatLab、Open CV、Viola Jones还是深度学习。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/912a2b77d128a04eadcdebc7a912474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tEC07i-wEflZOc6QUK_x3A.png"/></div></div></figure><p id="fc2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在你已经了解了物体检测的基本工作流程，让我们继续学习物体检测教程，了解Tensorflow是什么，它的组成部分是什么？</p><h1 id="a002" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是张量流？</h1><p id="f93c" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Tensorflow是谷歌的开源机器学习框架，用于跨一系列任务的数据流编程。图中的节点表示数学运算，而图边表示它们之间通信的多维数据数组(<strong class="ir hi">张量</strong>)。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/8bc27374da769a507891e9cbbd44887d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eAFGZI2VqKzLMCPvnB7aw.png"/></div></div></figure><p id="d718" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">张量只是多维数组，是二维表向更高维数据的扩展。Tensorflow有许多特性，这使它适合深度学习。因此，不浪费任何时间，让我们看看如何使用Tensorflow实现对象检测。</p><h1 id="1a2b" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">物体检测教程</h1><h2 id="4c92" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">获取先决条件</h2><ul class=""><li id="3cb8" class="jn jo hh ir b is kz iw la ja me je mf ji mg jm js jt ju jv bi translated">在开始演示之前，我们先来看看先决条件。我们将需要:</li></ul><ol class=""><li id="dfba" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mh jt ju jv bi translated">计算机编程语言</li><li id="a949" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mh jt ju jv bi translated">张量流</li><li id="f451" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mh jt ju jv bi translated">张量板</li><li id="6c09" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mh jt ju jv bi translated">Protobuf v3.4或更高版本</li></ol><h2 id="9d27" class="lj kc hh bd kd lk ll lm kh ln lo lp kl ja lq lr kp je ls lt kt ji lu lv kx lw bi translated">设置环境</h2><ul class=""><li id="813b" class="jn jo hh ir b is kz iw la ja me je mf ji mg jm js jt ju jv bi translated">现在，要下载TensorFlow和TensorFlow GPU，您可以使用pip或conda命令:</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="2cd2" class="lj kc hh mj b fi mn mo l mp mq"># For CPU<br/>pip install tensorflow<br/># For GPU<br/>pip install tensorflow-gpu</span></pre><ul class=""><li id="1e8c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">对于所有其他库，我们可以使用pip或conda来安装它们。代码如下所示:</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="376e" class="lj kc hh mj b fi mn mo l mp mq">pip install --user Cython<br/>pip install --user contextlib2<br/>pip install --user pillow<br/>pip install --user lxml<br/>pip install --user jupyter<br/>pip install --user matplotlib</span></pre><ul class=""><li id="b18d" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">接下来，我们有Protobuf: <strong class="ir hi">协议缓冲区</strong> (Protobuf)是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据，就像XML一样，但是更小、更快、更简单。你需要<a class="ae mr" href="https://github.com/google/protobuf/releases" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="ms">下载Protobuf</em></strong></a>3.4版或以上版本进行本演示并解压。</li><li id="6be5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">现在你需要从<a class="ae mr" href="https://github.com/tensorflow/models" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="ms">Github</em></strong></a>克隆或者下载TensorFlow的模型。一旦<em class="ms">下载了</em>并且<em class="ms">提取了</em>，就将“模型-主控”重命名为“<strong class="ir hi">模型</strong>”。</li><li id="f66f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">现在为了简单起见，我们将“模型”和“protobuf”放在一个文件夹“<strong class="ir hi"> Tensorflow </strong>”下。</li><li id="6b33" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">接下来，我们需要进入Tensorflow文件夹，然后进入research文件夹，从那里使用以下命令运行protobuf:</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="9c44" class="lj kc hh mj b fi mn mo l mp mq">"path_of_protobuf's bin"./bin/protoc object_detection/protos/</span></pre><ul class=""><li id="e1fa" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">要检查这是否有效，您可以转到models&gt;object _ detection&gt;protos中的<strong class="ir hi"> protos </strong>文件夹，在那里您可以看到为每个proto文件都创建了一个python文件。</li></ul><h1 id="234c" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">主代码</h1><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/2debff01b8ea617244343882a569c785.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*kDNjG80ly__g84k77bJobw.jpeg"/></div></figure><p id="eafd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置好环境后，您需要转到“<strong class="ir hi"> object_detection </strong>”目录，然后创建一个新的python文件。你可以使用<strong class="ir hi"> Spyder </strong>或<strong class="ir hi"> Jupyter </strong>来编写你的代码。</p><ul class=""><li id="43ba" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">首先，我们需要导入所有的库</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="1832" class="lj kc hh mj b fi mn mo l mp mq">import numpy as np<br/>import os<br/>import six.moves.urllib as urllib<br/>import sys<br/>import tarfile<br/>import tensorflow as tf<br/>import zipfile<br/> <br/>from collections import defaultdict<br/>from io import StringIO<br/>from matplotlib import pyplot as plt<br/>from PIL import Image<br/> <br/>sys.path.append("..")<br/>from object_detection.utils import ops as utils_ops<br/> <br/>from utils import label_map_util<br/> <br/>from utils import visualization_utils as vis_util</span></pre><p id="9cee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将下载在<a class="ae mr" href="http://cocodataset.org/#home" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="ms"> COCO数据集</em> </strong> </a>上训练好的模型。COCO代表<strong class="ir hi">上下文中的公共对象，</strong>该数据集包含大约330K个带标签的图像。现在，型号选择很重要，因为你需要在<strong class="ir hi">速度和精度</strong>之间做出重要的权衡。根据您的要求和系统内存，必须选择正确的型号。</p><p id="9202" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ms">模型&gt;研究&gt;对象_检测&gt; g3doc &gt;检测_模型_动物园</em>里面包含了所有不同速度和精度的模型(图)。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mu"><img src="../Images/bbbb9c00be9cb3e40487a3da4d4b009e.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*HmbuDIRfPpKl_LDU9onsaw.png"/></div></figure><ul class=""><li id="2189" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">接下来，我们提供所需的模型和Tensorflow生成的冻结推理图以供使用。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="f873" class="lj kc hh mj b fi mn mo l mp mq">MODEL_NAME = 'ssd_mobilenet_v1_coco_2017_11_17'<br/>MODEL_FILE = MODEL_NAME + '.tar.gz'<br/>DOWNLOAD_BASE = '<a class="ae mr" href="http://download.tensorflow.org/models/object_detection/'" rel="noopener ugc nofollow" target="_blank">http://download.tensorflow.org/models/object_detection/'</a><br/> <br/>PATH_TO_CKPT = MODEL_NAME + '/frozen_inference_graph.pb'<br/> <br/>PATH_TO_LABELS = os.path.join('data', 'mscoco_label_map.pbtxt')<br/> <br/>NUM_CLASSES = 90</span></pre><ul class=""><li id="9531" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">这段代码将从互联网上下载该模型，并提取该模型的冻结推理图。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="2605" class="lj kc hh mj b fi mn mo l mp mq">opener = urllib.request.URLopener()<br/>opener.retrieve(DOWNLOAD_BASE + MODEL_FILE, MODEL_FILE)<br/>tar_file = tarfile.open(MODEL_FILE)<br/>for file in tar_file.getmembers():<br/>  file_name = os.path.basename(file.name)<br/>  if 'frozen_inference_graph.pb' in file_name:<br/>    tar_file.extract(file, os.getcwd())<br/> <br/>detection_graph = tf.Graph()<br/>with detection_graph.as_default():<br/>  od_graph_def = tf.GraphDef()<br/>  with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:<br/>    serialized_graph = fid.read()<br/>    od_graph_def.ParseFromString(serialized_graph)<br/>    tf.import_graph_def(od_graph_def, name='')</span></pre><ul class=""><li id="c3e0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">接下来，我们将加载所有标签</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="b46b" class="lj kc hh mj b fi mn mo l mp mq">label_map = label_map_util.load_labelmap(PATH_TO_LABELS)<br/>categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)<br/>category_index = label_map_util.create_category_index(categories)</span></pre><ul class=""><li id="77c5" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">现在我们将把图像数据转换成一个numPy数组进行处理。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="306b" class="lj kc hh mj b fi mn mo l mp mq">def load_image_into_numpy_array(image):<br/>  (im_width, im_height) = image.size<br/>  return np.array(image.getdata()).reshape(<br/>      (im_height, im_width, 3)).astype(np.uint8)</span></pre><ul class=""><li id="db4f" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">这里定义了用于测试目的的图像路径。这里我们有一个命名约定“<strong class="ir hi">图像[i] </strong>”，用于i in (1到n+1)，n是提供的图像的数量。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="9297" class="lj kc hh mj b fi mn mo l mp mq">PATH_TO_TEST_IMAGES_DIR = 'test_images'<br/>TEST_IMAGE_PATHS = [ os.path.join(PATH_TO_TEST_IMAGES_DIR, 'image{}.jpg'.format(i)) for i in range(1, 8) ]</span></pre><ul class=""><li id="ebbb" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">这段代码对单个图像进行推理，检测对象，制作盒子，并提供该特定对象的类别和类别分数。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="3388" class="lj kc hh mj b fi mn mo l mp mq">def run_inference_for_single_image(image, graph):<br/>  with graph.as_default():<br/>    with tf.Session() as sess:<br/>    # Get handles to input and output tensors<br/>      ops = tf.get_default_graph().get_operations()<br/>      all_tensor_names = {output.name for op in ops for output in op.outputs}<br/>      tensor_dict = {}<br/>      for key in [<br/>          'num_detections', 'detection_boxes', 'detection_scores',<br/>          'detection_classes', 'detection_masks'<br/>     ]:<br/>        tensor_name = key + ':0'<br/>        if tensor_name in all_tensor_names:<br/>          tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(<br/>            tensor_name)<br/>      if 'detection_masks' in tensor_dict:<br/>        # The following processing is only for single image<br/>        detection_boxes = tf.squeeze(tensor_dict['detection_boxes'], [0])<br/>        detection_masks = tf.squeeze(tensor_dict['detection_masks'], [0])<br/>        # Reframe is required to translate mask from box coordinates to image coordinates and fit the image size.<br/>        real_num_detection = tf.cast(tensor_dict['num_detections'][0], tf.int32)<br/>        detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1])<br/>        detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1])<br/>        detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks(<br/>            detection_masks, detection_boxes, image.shape[0], image.shape[1])<br/>        detection_masks_reframed = tf.cast(<br/>            tf.greater(detection_masks_reframed, 0.5), tf.uint8)<br/>        # Follow the convention by adding back the batch dimension<br/>        tensor_dict['detection_masks'] = tf.expand_dims(<br/>            detection_masks_reframed, 0)<br/>        image_tensor = tf.get_default_graph().get_tensor_by_name('image_tensor:0')<br/> <br/>        # Run inference<br/>        output_dict = sess.run(tensor_dict,<br/>            feed_dict={image_tensor: np.expand_dims(image, 0)})<br/> <br/>        # all outputs are float32 numpy arrays, so convert types as appropriate<br/>        output_dict['num_detections'] = int(output_dict['num_detections'][0])<br/>        output_dict['detection_classes'] = output_dict[<br/>          'detection_classes'][0].astype(np.uint8)<br/>        output_dict['detection_boxes'] = output_dict['detection_boxes'][0]<br/>        output_dict['detection_scores'] = output_dict['detection_scores'][0]<br/>        if 'detection_masks' in output_dict:<br/>          output_dict['detection_masks'] = output_dict['detection_masks'][0]<br/>return output_dict</span></pre><ul class=""><li id="58cc" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">我们的最终循环将调用上面定义的所有函数，并对所有输入图像逐一进行推理，这将为我们提供图像输出，其中检测到带有标签的对象以及该对象与训练数据相似的百分比/分数。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="d7da" class="lj kc hh mj b fi mn mo l mp mq">for image_path in TEST_IMAGE_PATHS:<br/>  image = Image.open(image_path)<br/>  # the array based representation of the image will be used later in order to prepare the<br/>  # result image with boxes and labels on it.<br/>  image_np = load_image_into_numpy_array(image)<br/>  # Expand dimensions since the model expects images to have shape: [1, None, None, 3]<br/>  image_np_expanded = np.expand_dims(image_np, axis=0)<br/>  # Actual detection.<br/>  output_dict = run_inference_for_single_image(image_np, detection_graph)<br/>  # Visualization of the results of a detection.<br/>  vis_util.visualize_boxes_and_labels_on_image_array(<br/>      image_np,<br/>      output_dict['detection_boxes'],<br/>      output_dict['detection_classes'],<br/>      output_dict['detection_scores'],<br/>      category_index,<br/>      instance_masks=output_dict.get('detection_masks'),<br/>      use_normalized_coordinates=True,<br/>      line_thickness=8)<br/>plt.figure(figsize=IMAGE_SIZE)<br/>plt.imshow(image_np)</span></pre><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mv"><img src="../Images/2d37b94cd5b18d26171198384e990e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1omtrwXtDAVaRMx7Dejlgw.png"/></div></div></figure><p id="a424" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们继续学习对象检测教程，看看如何在实时视频中检测对象。</p><h1 id="5de6" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用张量流的活体对象检测</h1><p id="93f2" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">对于这个演示，我们将使用相同的代码，但是我们将做一些调整。这里我们将使用<strong class="ir hi"> <em class="ms"> OpenCV </em> </strong>和摄像头模块来使用网络摄像头的实时馈送来检测对象。</p><ul class=""><li id="75f1" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">添加OpenCV库和用于捕捉图像的相机。只需将下面几行添加到导入库部分。</li></ul><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="3835" class="lj kc hh mj b fi mn mo l mp mq">import cv2<br/>cap = cv2.VideoCapture(0)</span></pre><ul class=""><li id="df3c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">接下来，我们不需要从目录中加载图像并将其转换为numPy数组，因为OpenCV会为我们完成这项工作</li></ul><p id="b862" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">去掉这个</strong></p><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="765d" class="lj kc hh mj b fi mn mo l mp mq">for image_path in TEST_IMAGE_PATHS:<br/>image = Image.open(image_path)<br/># the array based representation of the image will be used later in order to prepare the<br/># result image with boxes and labels on it.<br/>image_np = load_image_into_numpy_array(image)</span></pre><p id="dd4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">同</strong></p><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="2a78" class="lj kc hh mj b fi mn mo l mp mq">while True:<br/>ret, image_np = cap.read()</span></pre><ul class=""><li id="47db" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">我们将不会使用matplotlib来显示最终的图像，我们也将使用OpenCV。现在，为了这个，</li></ul><p id="b165" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">移除此</strong></p><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="1236" class="lj kc hh mj b fi mn mo l mp mq">plt.figure(figsize=IMAGE_SIZE)<br/>plt.imshow(image_np)</span></pre><p id="0fab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">同</strong></p><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="0754" class="lj kc hh mj b fi mn mo l mp mq">cv2.imshow('object detection', cv2.resize(image_np, (800,600)))<br/>if cv2.waitKey(25) &amp; 0xFF == ord('q'):<br/>  cv2.destroyAllWindows()<br/>  break</span></pre><p id="9fce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该代码将使用OpenCV，OpenCV将依次使用前面初始化的camera对象来打开一个名为“<strong class="ir hi"> Object_Detection </strong>”的大小为“800×600”的新窗口。它将等待25毫秒让摄像机显示图像，否则，它将关闭窗口。</p><h1 id="36fc" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">包含所有更改的最终代码:</h1><pre class="lf lg lh li fd mi mj mk ml aw mm bi"><span id="bf94" class="lj kc hh mj b fi mn mo l mp mq">import numpy as np<br/>import os<br/>import six.moves.urllib as urllib<br/>import sys<br/>import tarfile<br/>import tensorflow as tf<br/>import zipfile<br/> <br/>from collections import defaultdict<br/>from io import StringIO<br/>from matplotlib import pyplot as plt<br/>from PIL import Image<br/> <br/>import cv2<br/>cap = cv2.VideoCapture(0)<br/> <br/>sys.path.append("..")<br/> <br/>from utils import label_map_util<br/> <br/>from utils import visualization_utils as vis_util<br/> <br/>MODEL_NAME = 'ssd_mobilenet_v1_coco_11_06_2017'<br/>MODEL_FILE = MODEL_NAME + '.tar.gz'<br/>DOWNLOAD_BASE = '<a class="ae mr" href="http://download.tensorflow.org/models/object_detection/'" rel="noopener ugc nofollow" target="_blank">http://download.tensorflow.org/models/object_detection/'</a><br/> <br/># Path to frozen detection graph. This is the actual model that is used for the object detection.<br/>PATH_TO_CKPT = MODEL_NAME + '/frozen_inference_graph.pb'<br/> <br/># List of the strings that is used to add correct label for each box.<br/>PATH_TO_LABELS = os.path.join('data', 'mscoco_label_map.pbtxt')<br/> <br/>NUM_CLASSES = 90<br/> <br/>opener = urllib.request.URLopener()<br/>opener.retrieve(DOWNLOAD_BASE + MODEL_FILE, MODEL_FILE)<br/>tar_file = tarfile.open(MODEL_FILE)<br/>for file in tar_file.getmembers():<br/>  file_name = os.path.basename(file.name)<br/>  if 'frozen_inference_graph.pb' in file_name:<br/>    tar_file.extract(file, os.getcwd())<br/> <br/>detection_graph = tf.Graph()<br/>with detection_graph.as_default():<br/>  od_graph_def = tf.GraphDef()<br/>  with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:<br/>    serialized_graph = fid.read()<br/>    od_graph_def.ParseFromString(serialized_graph)<br/>    tf.import_graph_def(od_graph_def, name='')<br/> <br/>label_map = label_map_util.load_labelmap(PATH_TO_LABELS)<br/>categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)<br/>category_index = label_map_util.create_category_index(categories)<br/> <br/>with detection_graph.as_default():<br/>  with tf.Session(graph=detection_graph) as sess:<br/>    while True:<br/>    ret, image_np = cap.read()<br/>    # Expand dimensions since the model expects images to have shape: [1, None, None, 3]<br/>    image_np_expanded = np.expand_dims(image_np, axis=0)<br/>    image_tensor = detection_graph.get_tensor_by_name('image_tensor:0')<br/>    # Each box represents a part of the image where a particular object was detected.<br/>    boxes = detection_graph.get_tensor_by_name('detection_boxes:0')<br/>    # Each score represent how level of confidence for each of the objects.<br/>    # Score is shown on the result image, together with the class label.<br/>    scores = detection_graph.get_tensor_by_name('detection_scores:0')<br/>    classes = detection_graph.get_tensor_by_name('detection_classes:0')<br/>    num_detections = detection_graph.get_tensor_by_name('num_detections:0')<br/>    # Actual detection.<br/>    (boxes, scores, classes, num_detections) = sess.run(<br/>      [boxes, scores, classes, num_detections],<br/>      feed_dict={image_tensor: image_np_expanded})<br/>    # Visualization of the results of a detection.<br/>    vis_util.visualize_boxes_and_labels_on_image_array(<br/>        image_np,<br/>        np.squeeze(boxes),<br/>        np.squeeze(classes).astype(np.int32),<br/>        np.squeeze(scores),<br/>        category_index,<br/>        use_normalized_coordinates=True,<br/>        line_thickness=8)<br/> <br/>    cv2.imshow('object detection', cv2.resize(image_np, (800,600)))<br/>    if cv2.waitKey(25) 0xFF == ord('q'):<br/>      cv2.destroyAllWindows()<br/>      break</span></pre><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mw"><img src="../Images/ed442f2d123cf8cc3f988da784675a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*YR10dGQBKXi6Qvm0CWbumA.png"/></div></figure><p id="22c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">至此，我们结束了这个物体检测教程。我希望你们喜欢这篇文章，并理解Tensorflow的力量，以及在图像和视频中检测对象是多么容易。所以，如果你读到这里，你就不再是物体检测和张量流的新手了。尝试这些例子，如果您在部署代码时遇到任何挑战，请告诉我。</p><p id="3c2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ms">这就把我们带到了“TensorFlow中的对象检测”这篇文章的结尾。我希望这篇文章对你有所帮助，并增加了你的知识价值。</em></p><p id="6864" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae mr" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=tensorflow-object-detection-tutorial" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释深度学习的各个其他方面。</p><blockquote class="mx my mz"><p id="33c4" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">1.<a class="ae mr" rel="noopener" href="/edureka/tensorflow-tutorial-ba142ae96bca"> TensorFlow教程</a></p><p id="3bf3" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">2.<a class="ae mr" rel="noopener" href="/edureka/pytorch-tutorial-9971d66f6893"> PyTorch教程</a></p><p id="0c46" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">3.<a class="ae mr" rel="noopener" href="/edureka/perceptron-learning-algorithm-d30e8b99b156">感知器学习算法</a></p><p id="a467" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">4.<a class="ae mr" rel="noopener" href="/edureka/neural-network-tutorial-2a46b22394c9">神经网络教程</a></p><p id="5c4e" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">5.<a class="ae mr" rel="noopener" href="/edureka/backpropagation-bd2cf8fdde81">什么是反向传播？</a></p><p id="6c4c" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">6.<a class="ae mr" rel="noopener" href="/edureka/convolutional-neural-network-3f2c5b9c4778">卷积神经网络</a></p><p id="ee87" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">7.<a class="ae mr" rel="noopener" href="/edureka/capsule-networks-d7acd437c9e">胶囊神经网络</a></p><p id="9a27" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">8.<a class="ae mr" rel="noopener" href="/edureka/recurrent-neural-networks-df945afd7441">递归神经网络</a></p><p id="4b50" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">9.<a class="ae mr" rel="noopener" href="/edureka/autoencoders-tutorial-cfdcebdefe37">自动编码器教程</a></p><p id="b91b" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">10.<a class="ae mr" rel="noopener" href="/edureka/restricted-boltzmann-machine-tutorial-991ae688c154">受限玻尔兹曼机教程</a></p><p id="b303" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">11.<a class="ae mr" rel="noopener" href="/edureka/pytorch-vs-tensorflow-252fc6675dd7"> PyTorch vs TensorFlow </a></p><p id="473f" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">12.<a class="ae mr" rel="noopener" href="/edureka/deep-learning-with-python-2adbf6e9437d">用Python进行深度学习</a></p><p id="74e0" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">13.<a class="ae mr" rel="noopener" href="/edureka/artificial-intelligence-tutorial-4257c66f5bb1">人工智能教程</a></p><p id="6ee5" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">14.<a class="ae mr" rel="noopener" href="/edureka/tensorflow-image-classification-19b63b7bfd95">张量流图像分类</a></p><p id="3c61" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">15.<a class="ae mr" rel="noopener" href="/edureka/artificial-intelligence-applications-7b93b91150e3">人工智能应用</a></p><p id="2659" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">16.<a class="ae mr" rel="noopener" href="/edureka/become-artificial-intelligence-engineer-5ac2ede99907">如何成为一名人工智能工程师？</a></p><p id="4c6d" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">17.<a class="ae mr" rel="noopener" href="/edureka/q-learning-592524c3ecfc">问学</a></p><p id="4a30" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">18.<a class="ae mr" rel="noopener" href="/edureka/apriori-algorithm-d7cc648d4f1e"> Apriori算法</a></p><p id="10b2" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">19.<a class="ae mr" rel="noopener" href="/edureka/introduction-to-markov-chains-c6cb4bcd5723">马尔可夫链与Python </a></p><p id="2335" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">20.<a class="ae mr" rel="noopener" href="/edureka/artificial-intelligence-algorithms-fad283a0d8e2">人工智能算法</a></p><p id="11dc" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">21.<a class="ae mr" rel="noopener" href="/edureka/best-laptop-for-machine-learning-a4a5f8ba5b">机器学习的最佳笔记本电脑</a></p><p id="9523" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">22.<a class="ae mr" rel="noopener" href="/edureka/top-artificial-intelligence-tools-36418e47bf2a">12大人工智能工具</a></p><p id="8f17" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">23.<a class="ae mr" rel="noopener" href="/edureka/artificial-intelligence-interview-questions-872d85387b19">人工智能(AI)面试问题</a></p><p id="bb3e" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">24.<a class="ae mr" rel="noopener" href="/edureka/theano-vs-tensorflow-15f30216b3bc"> Theano vs TensorFlow </a></p><p id="e50c" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">25.<a class="ae mr" rel="noopener" href="/edureka/what-is-a-neural-network-56ae7338b92d">什么是神经网络？</a></p><p id="a935" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">26.<a class="ae mr" rel="noopener" href="/edureka/pattern-recognition-5e2d30ab68b9">模式识别</a></p><p id="7d7d" class="ip iq ms ir b is it iu iv iw ix iy iz na jb jc jd nb jf jg jh nc jj jk jl jm ha bi translated">27.<a class="ae mr" rel="noopener" href="/edureka/alpha-beta-pruning-in-ai-b47ee5500f9a">人工智能中的阿尔法贝塔剪枝</a></p></blockquote></div><div class="ab cl nd ne go nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ha hb hc hd he"><p id="f018" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ms">原载于2018年8月20日</em><a class="ae mr" href="https://www.edureka.co/blog/tensorflow-object-detection-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="ms">【www.edureka.co</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>