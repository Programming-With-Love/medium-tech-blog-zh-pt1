<html>
<head>
<title>Demystifying Functional Programming (Part 2) — The need for immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开函数式编程的神秘面纱(第2部分)——对不变性的需求</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/demystifying-functional-programming-part-2-the-need-for-immutability-4f5c16ae2c9a?source=collection_archive---------0-----------------------#2020-01-03">https://medium.com/walmartglobaltech/demystifying-functional-programming-part-2-the-need-for-immutability-4f5c16ae2c9a?source=collection_archive---------0-----------------------#2020-01-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7bb7a31d4e36833118c11c08e587ec5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kFnCGCRn8zJk0IycJVr_w.png"/></div></div></figure><div class=""/><p id="dfe4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">欢迎回来，对于那些没有浏览过本系列前一篇博客的人，我建议浏览一下<a class="ae jn" rel="noopener" href="/walmartlabs/demystifying-functional-programming-part-1-eb4347d145d0"> Part 1 </a> (5分钟阅读)以便更好地理解！</p><h1 id="85cd" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是不变性和可变性？</h1><figure class="kn ko kp kq fd hj er es paragraph-image"><div class="er es km"><img src="../Images/a74201df1d11585ab8af4a018a2cd7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*PBvwhxbEZR_5V0RG"/></div></figure><p id="b58a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不可变对象是其状态在声明后不能改变的对象，而可变对象是变量，其状态可以在程序的整个执行过程中改变。</p><p id="9e48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在java中，你可以将final视为不可变的，而在scala中，所有声明为‘val’的字段都是不可变的，而‘var’是可变的！</p><blockquote class="kr ks kt"><p id="eba4" class="ip iq ku ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi translated">字符串在Java中也是不可变的</p></blockquote><p id="f149" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你们中的一些人可能认为我们可以在一段时间内改变字符串的值，或者对它执行“连接”操作。当然你可以这样做，但是当你这样做的时候，另一个string对象就被创建了，而不需要修改在堆内存中保存那个值的前一个对象。</p><p id="099a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里就不深究语言具体的东西了！</p><h1 id="68b6" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么是不变性？</h1><p id="695b" class="pw-post-body-paragraph ip iq hs ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ha bi translated">在一个简单的场景中，您希望利用多核CPU实现快速处理，您需要并行化您的代码，并以分布式方式运行它。拥有不可变字段意味着您不必担心并行线程之间的交互以及改变其他字段的状态。这使得并行毫不费力，而不用担心任何线程安全问题。</p><p id="9785" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编写可变的并行代码很难，而且很容易出错。不可变函数式编程几乎是我们所知道的唯一一种既安全又容易做到这一点的方法。</p><blockquote class="kr ks kt"><p id="ef49" class="ip iq ku ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi translated">让你的变量不可变，除非有一个很好的理由不这样做。</p></blockquote><p id="8254" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能会有很多疑问，不是在任何地方我们都可以使用不变性概念，比如在循环中，或者根据条件表达式给字段赋值。</p><p id="9541" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我会在某个时候回答这个问题，在我们知道函数式编程语言中的<em class="ku">“一切都‘评估’为一个值”</em>之前。这意味着，即使是if else语句也将向您返回一个对象！</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ld"><img src="../Images/a4bca6f13e489ffee63e6020de4b6d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZIBtIgf7TO-1NuS"/></div></div></figure><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es le"><img src="../Images/db0732d74ce684706c5b5d4f9b9f11f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XeMwzCloQ-DNh7On"/></div></div></figure><p id="ebdc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在第一张图中，我们使用了一个可变字段'<em class="ku"> flag </em>'，我们可以很容易地避免使用这个概念，即在函数式编程中，所有东西都计算一个值。因此，<em class="ku"> if else </em>条件返回一个<em class="ku">真/假</em>表达式，该表达式存储在第二幅图像的不可变字段“<em class="ku"> flag </em>中。</p><p id="eabb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi lf translated">在还不算太晚之前，我已经找到了你最喜欢的变量。另一个关于如何避免for循环的例子，如果你在java 8中使用流函数，你会理解下面的代码，无论如何我会试着解释一下！所以我们有一个列表，我们希望它的值增加2(每个值加2)</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/79d7419062e5b49c950cb131f71f355a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YM00PzbzKR-KyANT"/></div></div></figure><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/b7a3b8cfb627026c9c36f8d817c88583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QlbU7-DSEaV8GsdZ"/></div></div></figure><p id="9d3f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一张图是不言自明的，也是处理事情的基本方式，在第二段代码中，我们使用了一个<em class="ku">‘map’函数</em>，它不过是scala中的一个t <em class="ku">变换函数</em>。<em class="ku"> </em>将地图放在列表上可以让我们进入列表，访问每个值，这里用<em class="ku"> ' _ '(下划线)表示。</em>所以，下划线是我们的整数值，列表一次只有一个。为了解决我们的问题，我们只需要做一个<em class="ku"> ( _ + 2) </em>，它给出了创建一个新列表所需的输出！</p><p id="d87f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ku">你也可以在Java 8中使用‘map ’,但是你需要额外做一步将列表转换成流，所以Java中的不可变代码看起来像这样- </em></p><pre class="kn ko kp kq fd lq lr ls lt aw lu bi"><span id="d1f6" class="lv jp hs lr b fi lw lx l ly lz">final List newList= list.stream().map(value -&gt; value + 2).collect(Collectors.toList());</span></pre><p id="29a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后一个例子-从1到10的数字相加-</p><pre class="kn ko kp kq fd lq lr ls lt aw lu bi"><span id="5c6e" class="lv jp hs lr b fi lw lx l ly lz">val sum10 = (1 until 10).foldLeft(0){<br/>  case (sum,curr) =&gt; sum + curr<br/>}</span></pre><p id="2f2e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里(1到10)会给你一个范围。<em class="ku"> FoldLeft是一个可遍历函数，用于从左到右取值，默认参数为</em> 0，即此处的sum <em class="ku">。</em>从上面的代码片段中可以看出，我们省略了声明可变字段<em class="ku"> SUM </em>的使用。</p><h1 id="c6c0" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论:</h1><p id="16ac" class="pw-post-body-paragraph ip iq hs ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ha bi translated">如果您想要编写利用大部分处理能力的并行代码，并且想要一种线程安全的方式，那么不变性就是答案！</p><p id="bcc3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您对如何将可变场景转换成不可变场景有任何疑问，您可以通过我的LinkedIn句柄联系我！:)</p></div></div>    
</body>
</html>