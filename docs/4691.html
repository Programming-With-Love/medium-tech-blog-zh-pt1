<html>
<head>
<title>You Might Not Need TypeScript (or Static Types)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不需要类型脚本(或静态类型)</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b?source=collection_archive---------1-----------------------#2016-12-05">https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b?source=collection_archive---------1-----------------------#2016-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1e20e909f60c6f85124cfd4c1af87285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8k-Z4n84BkXPT17vfiV3w.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Krispy Kreme — Scott Ableman (CC BY-NC-ND 2.0)</figcaption></figure><p id="251c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">自从Angular 2项目决定采用TypeScript并以TypeScript编写所有文档示例以来，TypeScript已经变得非常流行，但是它真的值得投资吗？</p><p id="aae4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们开始之前，我先说我是静态类型支持的工具的粉丝，TypeScript是目前JavaScript社区中我最喜欢的静态类型系统。</p><p id="327c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我来自一个使用静态类型语言的背景，包括C/C++和Java。JavaScript的动态类型起初很难适应，但一旦我习惯了，就像从一个漫长黑暗的隧道中走出来，来到了光明中。静态类型有很多优点，但是动态类型也有很多优点。</p><p id="1d5a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我对技术栈和开发工具不感兴趣。我很实际。我做咨询，现在很多开发团队使用Angular 2和TypeScript。如果我要给他们建议，我最好知道我在说什么。</p><p id="2c1e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我强烈建议您对新的和不同的技术堆栈和工具采取类似的开放态度。相信我，在你的职业生涯中，你会学到更多。</p><p id="3a7c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">成为一名开发者意味着你选择了终生学习新事物。这是一个好主意，现在就和平解决这个问题。这并不意味着学习所有的新事物，但是如果你需要为你的工作学习新东西，或者仅仅是为了发现的快乐，要对新东西保持开放的态度。</p><blockquote class="js"><p id="9099" class="jt ju hh bd jv jw jx jy jz ka kb jq dx translated">发现的快乐是软件开发人员最大的乐趣之一。</p></blockquote><p id="eee2" class="pw-post-body-paragraph it iu hh iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">几个月前，我决定同时尝试Angular 2和TypeScript。我全职工作了几个月，为一个真正的开发团队开发一个真正的生产应用程序。</p><p id="1d1c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我的总体结论是这样的:</p><ol class=""><li id="2aa9" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq km kn ko kp bi translated">Angular 2有很多React中没有的东西，但所有这些额外的东西都没有让我更有效率，而且大多数好东西都可以在第三方模块中获得。</li><li id="23e6" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq km kn ko kp bi translated">TypeScript碍事多于帮忙。它没有减少错误，也没有提高我们的生产力。</li></ol><p id="2e9e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以在<a class="ae jr" rel="noopener" href="/javascript-scene/angular-2-vs-react-the-ultimate-dance-off-60e7dfbc379c">“Angular 2 vs React:终极舞会”</a>中读到更多关于那次冒险的内容。</p><p id="2138" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你已经是TypeScript的粉丝，你可能已经迫不及待地想对这篇文章发表评论了。在此之前，请阅读<a class="ae jr" rel="noopener" href="/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3">“关于静态类型的惊人秘密”</a>。</p><p id="f46d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要点:静态类型不会降低总体的错误密度，但是您可能仍然喜欢将它们用于开发工具。</p><p id="8018" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">每个人都在谈论静态类型的所有好处，但是相对来说很少有文章讨论它的缺点。让我们谈一谈这些。</p><h1 id="a56d" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">静态类型如何阻碍维护</strong></h1><p id="0a8e" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">类型注释显然会产生更多的语法噪音，这种语法使得代码更难阅读，更难维护。但是缺点更深一层。具体来说，静态类型会使所有这些事情变得更加困难(<em class="ly">不是不可能</em>，只是比它们需要的更复杂):</p><ul class=""><li id="ce9c" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq lz kn ko kp bi translated">通用函数和多态性</li><li id="1277" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq lz kn ko kp bi translated">高阶函数</li><li id="22c9" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq lz kn ko kp bi translated">对象组成</li></ul><p id="9b80" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这很麻烦，因为我经常使用这些东西<strong class="iv hi"/>，如果你是一个熟练的JavaScript程序员，你也很有可能经常使用它们。</p><p id="8d9d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我不想把这篇文章写成一本书，所以我们将集中讨论我最讨厌的静态类型:泛型函数。</p><p id="1a29" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一个<strong class="iv hi">通用函数</strong>是一个可以对多种类型的参数进行操作的函数。例如，计算总和的函数可能适用于数字，但也可能适用于提供返回数字的<code class="du ma mb mc md b">.valueOf()</code>方法的对象(注意，在JS中，数字有一个<code class="du ma mb mc md b">.valueOf()</code>方法，这使得使用相同的内部逻辑处理两种类型成为可能)。</p><p id="2548" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在像C++或Java这样的语言中，泛型函数需要类型构造函数或模板，它们接受类型参数以实现编译时函数多态性。</p><p id="d4b2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您需要解析的语法变成了多维的，因为单个函数实际上是两个函数:参数化的类型函数和实际执行行为的具体函数。</p><p id="ce1a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在动态类型语言中，不需要类型构造函数。解析类型对开发人员来说是抽象的。这种情况仍然会发生，但它发生在运行时的引擎盖下，开发人员不需要考虑它。</p><p id="893a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">效果是开发人员不会被类型构造函数或模板语法分心。相反，开发人员可以使用duck typing，<em class="ly">可选地</em>执行<strong class="iv hi">运行时类型检查</strong>。</p><h2 id="05ec" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">动态类型并不意味着没有类型检查</h2><p id="2bff" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">运行时类型检查是在程序运行时进行的类型检查，即在实际使用该类型的时候。动态类型检查内置在JavaScript中，但是它非常宽松，只有当你试图做一些超级疯狂的事情，比如调用<code class="du ma mb mc md b">undefined</code>作为函数时，才会抛出错误。</p><p id="bf8c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当这种情况发生时，你的软件可能会崩溃。可能会导致生产中的服务器停机。哎呀。</p><p id="76bc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了进行更严格的类型检查，可以定义参数类型，然后用类型检查函数包装函数。</p><p id="c496" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">例如，使用JavaScript + React，我们可以在开发模式下使用React的PropTypes进行自动动态类型检查，甚至可以为生产部署编译类型检查，因为一旦您验证了传递的类型是正确的，就不再需要它们了。</p><p id="d703" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，应用程序不需要通过降低性能来从运行时类型检查中获益。</p><p id="10aa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是一个简化的例子，说明如何在JavaScript中增强运行时类型检查:</p><figure class="ms mt mu mv fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="be38" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一个更聪明的版本可以解析函数签名的文本，并从默认参数值中提取类型需求。例如，如果您试图传递一个<code class="du ma mb mc md b">Date</code>对象而不是<code class="du ma mb mc md b">hireDate</code>的纪元时间，您可能会抛出一个类型错误。</p><p id="0209" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">React的PropTypes不是用这样的包装函数处理的。由于React是一个框架，它可以在组件生命周期中任意地、有条件地在任何地方插入类型检查。其他框架可以在开发和生产行为之间实现类似的区别:</p><figure class="ms mt mu mv fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="6d73" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您认为与静态类型相比，这听起来很麻烦，请考虑运行时类型检查的复杂性通常隐藏在框架或库中。上面这个应用程序的创建者只需要担心<code class="du ma mb mc md b">createEmployee()</code>函数和它的<code class="du ma mb mc md b">required</code>属性。换句话说，这比编写等价的静态类型注释要简单。</p><blockquote class="my mz na"><p id="a9d4" class="it iu ly iv b iw ix iy iz ja jb jc jd nb jf jg jh nc jj jk jl nd jn jo jp jq ha bi translated">注意:有一些开源库是为做我刚刚描述的事情而设计的。如果你想贡献一个实验性的，无论有没有React都可以在任何JS程序中轻松使用的工具，请查看<a class="ae jr" href="https://github.com/ericelliott/rfx" rel="noopener ugc nofollow" target="_blank"> rfx </a>。</p></blockquote><h2 id="b7c9" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">输入错误会使我的应用程序停止运行吗？</h2><blockquote class="js"><p id="dc5e" class="jt ju hh bd jv jw jx jy jz ka kb jq dx translated">类型正确性并不能保证程序的正确性。</p></blockquote><p id="8567" class="pw-post-body-paragraph it iu hh iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">类型错误不是bug的唯一来源，抛出异常也不是响应bug时可能发生的最糟糕的事情。</p><p id="3eed" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">希望你已经接受了我关于使用TDD的建议。静态类型很擅长捕捉类型错误，但是<a class="ae jr" rel="noopener" href="/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3">对总体错误密度</a>影响不大，TDD可以减少40% — 80%的产品错误密度。代码审查也是降低bug密度的一种非常有效的方法。花在代码审查上的每一个小时可以节省33个小时的维护时间[1]。</p><blockquote class="js"><p id="43ea" class="jt ju hh bd jv jw jx jy jz ka kb jq dx translated">如果你同时使用TDD和代码评审，很少有类型错误会进入生产环境。</p></blockquote><p id="7673" class="pw-post-body-paragraph it iu hh iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">将运行时类型检查添加到这个组合中，您就拥有了一个针对发布错误的三层防线。我见过这些策略被用来为服务于数千万用户的生产应用程序提供百万以上的LOC代码库，并且错误密度非常低。</p><p id="d848" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">任何告诉你需要静态类型来发布大型复杂应用程序的人都是在吹牛。高质量的连续交付方法对bug密度和项目成功的影响比静态类型的存在与否要大得多。</p><h2 id="6ce6" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">什么是鸭子打字？</h2><p id="d47d" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated"><strong class="iv hi"> Duck typing </strong>是一种类型检查的方法，它查看值的结构，而不是它的名称或类。这就像物体的特征检测。如果它像鸭子一样走路，像鸭子一样说话，我们就像对待鸭子一样对待它，即使它不是。</p><p id="db53" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像React在JS中的PropTypes这样的系统是结构类型检查器，这意味着类型是基于其形状(其属性的名称和类型)而不是给定类型的名称或身份来检查的。</p><p id="e48e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只有当所需的功能不存在时，才会引发类型错误。Duck typing是有益的，因为在设计时，您没有任何办法知道程序的所有未来需求。如果将来你需要一个橡胶鸭子无人机，它仍然可以像普通鸭子一样飞行和嘎嘎叫，那该怎么办？</p><p id="798e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于名义静态类型，您需要更改程序中处处使用duck的每个函数的类型签名——这个过程不容易通过自动化重构工具来辅助，因为需要更改的函数还不知道橡皮鸭无人机的存在。</p><p id="9cf4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有了鸭子类型和某些结构类型系统，你不需要改变签名来适应橡皮鸭无人机。</p><h1 id="da39" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">概述</h1><p id="c092" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">对于泛型函数，静态类型在两个方面阻碍了维护:</p><ol class=""><li id="36d9" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq km kn ko kp bi translated">模板和类型构造函数增加的复杂性使得在静态类型语言中设计和理解泛型函数变得更加困难。</li><li id="0959" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq km kn ko kp bi translated">名义静态类型的限制使得将来向程序添加功能变得更加困难。</li></ol><p id="a1ec" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">第二点不适用于结构化类型系统，如TypeScript，它也检查功能可用性，而不是检查名称或标识。它确实适用于名义类型系统，包括Java和C++。</p><h2 id="c8c1" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">TypeScript中的泛型函数</h2><p id="624b" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">对于泛型来说，TypeScript的复杂性增加了。看看标准JavaScript中的这个通用身份函数:</p><pre class="ms mt mu mv fd ne md nf ng aw nh bi"><span id="e0e8" class="me kw hh md b fi ni nj l nk nl">const identity = arg =&gt; arg;</span></pre><p id="30bb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">与TypeScript中更嘈杂的静态类型函数相比:</p><pre class="ms mt mu mv fd ne md nf ng aw nh bi"><span id="b22b" class="me kw hh md b fi ni nj l nk nl">function identity&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}</span></pre><p id="07bb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这两个函数实际上都不需要任何类型信息，因为值是在不使用任何参数特性的情况下传递的。</p><p id="2064" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像JavaScript内置的动态类型系统可以选择使用静态数据流分析来推断和跟踪通过函数的标准JavaScript版本的参数类型。这就是像<a class="ae jr" href="https://ternjs.net/" rel="noopener ugc nofollow" target="_blank"> Tern.js </a>和<a class="ae jr" href="https://flowtype.org/" rel="noopener ugc nofollow" target="_blank">脸书之流</a>这样的系统施展魔法的方式。(注意:Flow是一个静态类型系统，具有动态推理&amp;数据流分析功能…注释可选)。</p><p id="2ac9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">例如，Flow不需要类型构造函数来跟踪身份的类型。<strong class="iv hi"> <em class="ly">编辑:</em> </strong> <em class="ly"> TypeScript 2也加入了类似的功能。</em></p><pre class="ms mt mu mv fd ne md nf ng aw nh bi"><span id="b3fb" class="me kw hh md b fi ni nj l nk nl">const identity = arg =&gt; arg;<br/>const num:number = identity('NaN LOL');<br/>// "String. This type is incompatible with number"</span></pre><h2 id="116a" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">类型推理岩石</h2><p id="b77a" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">在ES6中，函数可以指定默认值，这些值可以由兼容的类型推理系统(如Tern.js、TypeScript和Flow)用于类型推理。例如:</p><pre class="ms mt mu mv fd ne md nf ng aw nh bi"><span id="0ea3" class="me kw hh md b fi ni nj l nk nl">const createEmployee = ({<br/>  name = 'Unnamed Employee',<br/>  hireDate = Date.now(),<br/>  title = 'Worker Drone'<br/>}) =&gt; ({<br/>  name,<br/>  hireDate,<br/>  title<br/>});</span></pre><p id="eb44" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是atom-ternjs显示的签名类型提示:</p><figure class="ms mt mu mv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/26b77e477f3da508b05a788af3aecf9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ0RJ-ALEmxb4CH6ch3ZsQ.png"/></div></div></figure><p id="1d2c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，只使用标准的动态类型JavaScript代码和支持推理的IDE工具，就可以获得静态类型系统99%的好处。</p><p id="4539" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">TypeScript的一个优点是，当推理功能不可避免地出现签名错误时(当一个函数包装另一个函数时，这种情况经常发生)，TypeScript允许您手动为某个对象分配一个接口，以便在编辑器中显示正确的类型提示。</p><p id="fa6d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我希望JavaScript中有一种可选的T2方式来实现这一点。</p><h2 id="5625" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">自动化重构呢？</h2><p id="580b" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">两点:</p><ol class=""><li id="9d06" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq km kn ko kp bi translated">任何可以搜索依赖树并具有类型推断和数据流分析的开发工具，都可以完成大多数与静态类型工具相同的自动化重构。例如Tern.js。</li><li id="ae60" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq km kn ko kp bi translated">在几十年的软件开发中，我可以用一只手来数清我花了几分钟以上的时间，用一种可以得到静态类型实质性帮助的方式来手动重构一些东西。</li></ol><h2 id="5ca2" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">自动完成呢？</h2><p id="e859" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">每个像样的编辑器都有很好的自动完成插件。在Tern.js、Flow等的帮助下，许多支持类型推理…下面是Atom的内置<code class="du ma mb mc md b">autocomplete-plus</code>功能:</p><figure class="ms mt mu mv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nn"><img src="../Images/3280ed09ae097987da2dbc94020b9f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EZx3q13xaTdLUO4CvcOJyA.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Atom’s autocomplete-plus</figcaption></figure><h2 id="253b" class="me kw hh bd kx mf mg mh lb mi mj mk lf je ml mm lj ji mn mo ln jm mp mq lr mr bi translated">标识符名称错别字怎么办？</h2><p id="b980" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">任何像样的过敏者都能发现这些错误。以下是ESLint的实际应用:</p><figure class="ms mt mu mv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es no"><img src="../Images/0702bddf09e0cfae8f4dbec9961ddcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcbh4jkSuy1xCMl2Gg8jQw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ESLint in action</figcaption></figure><h1 id="4c84" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="2bf4" class="pw-post-body-paragraph it iu hh iv b iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ha bi translated">在我看来，很多静态类型的拥护者并没有意识到现代动态类型工具的能力，比如运行时类型检查，以及带有数据流分析的类型推断。</p><p id="09ab" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您可以获得静态类型的99%的好处，而没有额外的语法噪音和类型注释的认知开销，静态类型真的会给您带来开发人员生产力的净收益吗？</p><blockquote class="js"><p id="59cf" class="jt ju hh bd jv jw jx jy jz ka kb jq dx translated">静态类型真的值得权衡吗？</p></blockquote><p id="f3d7" class="pw-post-body-paragraph it iu hh iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">根据我的经验，答案是肯定的，也是否定的。</p><p id="0a16" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">是的</strong>，因为TypeScript的开发者工具目前比Tern.js和Flow的工具更好(据我所知)。所谓更好，我的意思是用户界面更好。比较好用。类型错误看起来就像来自linter的语法错误，格式非常漂亮。超级有用。我有点爱上它了。你可能也会坠入爱河。</p><blockquote class="js"><p id="9d0e" class="jt ju hh bd jv jw jx jy jz ka kb jq dx translated">在我看来，TypeScript提供了当今JavaScript世界中最好的开发人员工具体验。</p></blockquote><p id="6a08" class="pw-post-body-paragraph it iu hh iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">如果TypeScript的工具默认为标准JS文件提供提示和类型推断，我会用它来代替Tern.js，并向所有人推荐这个设置。简单的选择。</p><blockquote class="my mz na"><p id="f6ad" class="it iu ly iv b iw ix iy iz ja jb jc jd nb jf jg jh nc jj jk jl nd jn jo jp jq ha bi translated">注意:Tern.js和Flow没有理由比不上TypeScript的开发人员工具UX。有人只需要在编辑器/IDE插件中投入一些TLC。</p></blockquote><p id="b068" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">没有</strong>，因为随着TypeScript今天的工作，你需要教育你的团队中的开发人员如何正确地使用TypeScript，以及如何使代码尽可能地不受语法干扰和注释的影响，同时仍然提供足够的类型线索和注释来使它值得。</p><p id="1829" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我见过一个生产TypeScript项目有超过1000个类型错误，到处都是<code class="du ma mb mc md b">any</code>注释(静态类型碍事时的逃生出口)。不管你听到多少，TypeScript使运行大项目变得更容易，大项目伴随着大团队，开发人员教育和接受是软件开发中最难的问题之一。</p><p id="c691" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">TypeScript是<em class="ly">绝对酷。</em>我真的很喜欢。但是它有很大的代价，忽视它是不明智的。在您决定使用TypeScript之前，仔细看看您的团队，非常认真和诚实地问自己:</p><ul class=""><li id="c662" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq lz kn ko kp bi translated">你的团队准备好学习曲线了吗？</li><li id="a3af" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq lz kn ko kp bi translated">你是否有纪律去投资培训和指导，让你的开发人员跟上TypeScript的速度？</li><li id="465c" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq lz kn ko kp bi translated">在未来的招聘中，你能一直保持同样的培训纪律吗？</li><li id="bdb4" class="kh ki hh iv b iw kq ja kr je ks ji kt jm ku jq lz kn ko kp bi translated">从ROI的角度来看，最重要的是:TypeScript提供的适度改进真的值得付出所有额外的努力吗？</li></ul><p id="f841" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">或者:</p><ul class=""><li id="fcf7" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq lz kn ko kp bi translated">你从标准JS+tern . JS+ESLint+autocomplete+TDD+代码评审中获得的99%的收益对你的团队来说够好了吗？</li></ul><blockquote class="my mz na"><p id="48f7" class="it iu ly iv b iw ix iy iz ja jb jc jd nb jf jg jh nc jj jk jl nd jn jo jp jq ha bi translated">提示:即使是静态类型，您仍然需要林挺、TDD和代码审查来大大降低产品bug密度。</p></blockquote><p id="a32e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一句话:毫无疑问，静态类型感觉很好。咬一口热腾腾的油炸圈饼感觉很好。但是真的对你有好处吗？</p></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><ol class=""><li id="cb11" class="kh ki hh iv b iw ix ja jb je kj ji kk jm kl jq km kn ko kp bi translated">Glen w . Russell，“超大规模开发中的检验经验”，<em class="ly"> IEEE软件</em>，第8卷第1期(1991年1月)，第25–31页。</li></ol></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><p id="6c41" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">想要加强你的JavaScript游戏吗？如果你不是会员，你就错过了。</p><figure class="ms mt mu mv fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es ie"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="ly">埃里克·艾略特</em> </strong> <em class="ly">著有</em> <a class="ae jr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="ly">【编程JavaScript应用】</em> </a> <em class="ly">(奥赖利)，以及</em> <a class="ae jr" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="ly">【跟埃里克·艾略特学JavaScript】</em></a><em class="ly">。他为Adobe Systems</em><strong class="iv hi"><em class="ly"/></strong><em class="ly"/><strong class="iv hi"><em class="ly">尊巴健身</em></strong><em class="ly"/><strong class="iv hi"><em class="ly">华尔街日报</em></strong><em class="ly"/><strong class="iv hi"><em class="ly">【ESPN</em></strong><em class="ly"/><strong class="iv hi"><em class="ly">BBC</em></strong><em class="ly">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>