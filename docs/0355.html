<html>
<head>
<title>What’s your text’s appearance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的文本是什么样子的？</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/whats-your-text-s-appearance-f3a1729192d?source=collection_archive---------1-----------------------#2018-08-02">https://medium.com/androiddevelopers/whats-your-text-s-appearance-f3a1729192d?source=collection_archive---------1-----------------------#2018-08-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/daeed0b79439368743105b677778ac9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0HSvySGMQMEXe9qIVLlow.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="dd22" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">了解如何在Android上以声明方式设计文本。</h2></div><p id="7689" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在Android应用中设计文本样式时，<code class="du ki kj kk kl b">TextView</code>提供了多种属性和不同的应用方式。您可以直接在布局中设置属性，可以将样式应用于视图，将主题应用于布局，或者设置文本外观。但是应该用哪个呢？如果把它们结合起来会怎么样？</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es km"><img src="../Images/4f5f340aa092d569a69e5c4bf32c6483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6rbzwBOcEOA4RePr3l_9w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kr">Which to use and when?</em></figcaption></figure><p id="0018" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">本文概述了声明式文本样式化的不同方法(例如，当您扩展XML布局时)，查看了它们的范围和优先级，以及何时应该使用每种技术。</p><h1 id="8c2c" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">TL；dr；</h1><p id="6f72" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">你<em class="lp">真的应该</em>阅读整篇文章，但这里有一个摘要。</p><p id="c391" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请注意不同样式技术的优先顺序—如果您正在尝试样式化某些文本，但没有看到预期的结果，则您的更改可能会被该层次结构中更高的内容覆盖:</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div class="er es lq"><img src="../Images/76ded798f2c76648bf71b9e18f0d925c.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*CzAFTpIAJhbKohiCnFi0AQ.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kr">The hierarchy of text styling techniques</em></figcaption></figure><p id="aaeb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我建议使用以下工作流程来设计文本样式:</p><ol class=""><li id="17ea" class="lr ls hx jo b jp jq js jt jv lt jz lu kd lv kh lw lx ly lz bi translated">在你的主题中设置任何应用程序的默认样式。</li><li id="a51f" class="lr ls hx jo b jp ma js mb jv mc jz md kd me kh lw lx ly lz bi translated">建立一个你的应用将要使用的<code class="du ki kj kk kl b">TextAppearance</code>的(小)选择(或者使用/扩展MaterialComponent的<a class="ae hu" href="https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/typography/res/values/styles.xml" rel="noopener ugc nofollow" target="_blank">样式</a>)并直接从你的视图中引用这些</li><li id="889a" class="lr ls hx jo b jp ma js mb jv mc jz md kd me kh lw lx ly lz bi translated">创建<code class="du ki kj kk kl b">styles</code>设置任何<code class="du ki kj kk kl b">TextAppearance</code>不支持的属性(它们自己指定你的一个<code class="du ki kj kk kl b">TextAppearances</code>)。</li><li id="e46b" class="lr ls hx jo b jp ma js mb jv mc jz md kd me kh lw lx ly lz bi translated">直接在布局中执行任何独特的样式。</li></ol><h1 id="1c58" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">展示一些风格</h1><p id="e4f5" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">虽然您可以在布局中直接设置<code class="du ki kj kk kl b">TextView</code>属性，但是这种方法可能会很繁琐并且容易出错。想象一下，尝试以这种方式更新应用程序中所有文本视图的颜色🙀。与所有视图一样，您可以(也应该！)而是使用样式来促进一致性、重用和易于更新。为此，我建议每当您想要将相同的样式应用于多个视图时，为文本创建样式。这非常简单，主要由Android view系统处理。</p><p id="a2b8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当你在一个视图上设置一个样式的时候，到底发生了什么？如果您曾经编写过自定义视图，您可能会看到对<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/content/Context.html#obtainStyledAttributes(android.util.AttributeSet,%20int[],%20int,%20int)" rel="noopener ugc nofollow" target="_blank">context.obtainStyledAttributes(AttributeSet, int[], int, int)</a></code>的调用。<em class="lp">这个</em>就是Android视图系统如何将布局中指定的属性传递给视图。<code class="du ki kj kk kl b">AttributeSet</code>参数本质上可以被认为是您在布局中指定的XML参数的映射。如果这个<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/util/AttributeSet" rel="noopener ugc nofollow" target="_blank">AttributeSet</a></code>指定了一个样式，那么<strong class="jo hy">样式首先被读取</strong>，然后在视图上直接指定的属性被应用到其上。这样，我们得到了第一个优先规则。</p><blockquote class="mf mg mh"><p id="e875" class="jm jn lp jo b jp jq iy jr js jt jb ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">视图&gt;样式</p></blockquote><p id="bf8d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">直接在视图上定义的属性总是“有效”的，并且会覆盖那些在样式中指定的属性。注意，样式和视图属性的组合<strong class="jo hy">被应用；在一个视图上定义一个也出现在样式<strong class="jo hy">中的属性并不会</strong>放弃整个样式。有趣的是，在你看来没有真正的方法来确定的风格来自哪里；这个问题由view系统在这个简单的调用中为您解决。你不能两者兼得。</strong></p><p id="c951" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">虽然风格非常有用，但它们也有局限性。其中之一是你只能对一个视图应用一种样式(不像web上的CSS那样可以应用多个类)。然而，<code class="du ki kj kk kl b">TextView</code>自有妙计，它提供了一个<code class="du ki kj kk kl b">TextAppearance</code>属性，该属性的功能<em class="lp">类似于</em>到<code class="du ki kj kk kl b">style</code>。如果您通过一个<code class="du ki kj kk kl b">TextAppearance</code>提供文本样式，让<code class="du ki kj kk kl b">style</code>属性自由用于其他样式，这听起来很有用。让我们仔细看看<code class="du ki kj kk kl b">TextAppearance</code>是什么，它是如何工作的。</p><h1 id="62d1" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">文本外观</h1><p id="df52" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated"><code class="du ki kj kk kl b">TextAppearance</code>没什么神奇的(比如一个<em class="lp">秘密</em>模式去应用安卓不想让你知道的多种风格！！！1!)，<code class="du ki kj kk kl b">TextView</code>为你做一些非常有用的跑腿工作。让我们看看<code class="du ki kj kk kl b">TextView</code>的一些构造函数，看看发生了什么。</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="1158" class="mp kt hx kl b fi mq mr l ms mt">TypedArray a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes);<br/>TypedArray appearance = null;<br/>int ap = a.getResourceId(com.android.internal.R.styleable.TextViewAppearance_textAppearance, -1);<br/>a.recycle();</span><span id="3fda" class="mp kt hx kl b fi mu mr l ms mt">if (ap != -1) {<br/>  appearance = theme.obtainStyledAttributes(ap, com.android.internal.R.styleable.TextAppearance);<br/>}</span><span id="2604" class="mp kt hx kl b fi mu mr l ms mt">if (appearance != null) {<br/>  readTextAppearance(context, appearance, attributes, false);<br/>  appearance.recycle();<br/>}</span><span id="1285" class="mp kt hx kl b fi mu mr l ms mt">// a little later<br/>a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes);<br/>readTextAppearance(context, a, attributes, true);</span></pre><p id="0419" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里发生了什么？实际上，<code class="du ki kj kk kl b">TextView</code>首先查看您是否提供了<code class="du ki kj kk kl b">android:textAppearance</code>，如果是，它将加载该样式并应用它指定的任何属性。稍后，它加载视图的所有属性(记住，包括样式)并应用它们。因此，我们得出第二个优先规则:</p><blockquote class="mf mg mh"><p id="8347" class="jm jn lp jo b jp jq iy jr js jt jb ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">视图&gt;样式&gt;文本外观</p></blockquote><p id="6cae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为首先检查文本外观，所以直接在视图或样式中定义的任何属性都将覆盖文本外观。</p><p id="d089" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">关于<code class="du ki kj kk kl b">TextAppearance</code>还有一个需要注意的地方，那就是它支持<code class="du ki kj kk kl b">TextView</code>提供的<strong class="jo hy">样式属性子集</strong>。为了理解这一点，让我们回到这一行:</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="fbe0" class="mp kt hx kl b fi mq mr l ms mt">obtainStyledAttributes(ap, android.R.styleable.TextAppearance);</span></pre><p id="9e4b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们已经看过了<code class="du ki kj kk kl b">obtainStyledAttributes</code>的4 arg版本，这个2 arg版本略有不同。相反，它会查看给定的样式(由第一个<code class="du ki kj kk kl b">id</code>参数标识),并将其过滤为出现在第二个<code class="du ki kj kk kl b">attrs</code>数组参数中的该样式的属性。同样，可样式化的<code class="du ki kj kk kl b">android.R.styleable.TextAppearance</code>定义了<code class="du ki kj kk kl b">TextAppearance</code>理解的<strong class="jo hy">范围</strong>。查看这个的定义我们可以看到<code class="du ki kj kk kl b"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml#4414" rel="noopener ugc nofollow" target="_blank">TextAppearance</a></code> <a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml#4414" rel="noopener ugc nofollow" target="_blank">支持</a>许多<strong class="jo hy">但不是<code class="du ki kj kk kl b"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml#4472" rel="noopener ugc nofollow" target="_blank">TextView</a></code> <a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml#4472" rel="noopener ugc nofollow" target="_blank">支持</a>的所有</strong>属性。</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="c4a0" class="mp kt hx kl b fi mq mr l ms mt">&lt;attr name=<!-- -->"<!-- -->textColor<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textSize<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textStyle<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->typeface<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->fontFamily<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textColorHighlight<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textColorHint<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textColorLink<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->textAllCaps<!-- -->"<!-- --> format=<!-- -->"<!-- -->boolean<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->shadowColor<!-- -->"<!-- --> format=<!-- -->"<!-- -->color<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->shadowDx<!-- -->"<!-- --> format=<!-- -->"<!-- -->float<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->shadowDy<!-- -->"<!-- --> format=<!-- -->"<!-- -->float<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->shadowRadius<!-- -->"<!-- --> format=<!-- -->"<!-- -->float<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->elegantTextHeight<!-- -->"<!-- --> format=<!-- -->"<!-- -->boolean<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->letterSpacing<!-- -->"<!-- --> format=<!-- -->"<!-- -->float<!-- -->"<!-- --> /&gt;<br/>&lt;attr name=<!-- -->"<!-- -->fontFeatureSettings<!-- -->"<!-- --> format=<!-- -->"<!-- -->string<!-- -->"<!-- --> /&gt;</span></pre><p id="5731" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><em class="lp">支持</em> <code class="du ki kj kk kl b"><em class="lp">TextAppearance</em></code> <em class="lp"> s </em>的造型属性</p><p id="b7bc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不包括的一些常见的<code class="du ki kj kk kl b">TextView</code>属性有<code class="du ki kj kk kl b">lineHeight[Multiplier|Extra]</code>、<code class="du ki kj kk kl b">lines</code>、<code class="du ki kj kk kl b">breakStrategy</code>、&amp;、<code class="du ki kj kk kl b">hyphenationFrequency</code>。<code class="du ki kj kk kl b">TextAppearance</code>作用于字符级，而非段落级，因此不支持影响整个布局的属性。</p><p id="f702" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所以<code class="du ki kj kk kl b">TextAppearance</code>非常有用，它让我们定义一个专注于文本样式属性的样式，并把视图的<code class="du ki kj kk kl b">style</code>留给其他用途。然而，它的范围有限，并且位于优先链的底部，所以要注意它的局限性。</p><h1 id="cf3a" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">合理的违约</h1><p id="dd95" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">当我们看了一下Android view系统如何解析属性(<code class="du ki kj kk kl b">context.obtainStyledAttributes</code>)时，我们实际上把事情简化了一点。这将调用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/content/res/Resources.Theme.html#obtainStyledAttributes(android.util.AttributeSet,%20int[],%20int,%20int)" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">theme</strong>.obtainStyledAttributes</a></code>(使用<code class="du ki kj kk kl b">Context</code>的当前<code class="du ki kj kk kl b">Theme</code>)。检查<a class="ae hu" href="https://developer.android.com/reference/android/content/res/Resources.Theme.html#obtainStyledAttributes(android.util.AttributeSet,%20int[],%20int,%20int)" rel="noopener ugc nofollow" target="_blank">引用</a>这显示了我们之前看到的优先顺序，并指定了另外两个解析属性的地方:视图的默认样式和主题。</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mv"><img src="../Images/8cfa8a057f75c388fc96164b03b22991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8P3YgnVgL8RljQpQ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kr">The styling precedence order from </em><a class="ae hu" href="https://developer.android.com/reference/android/content/res/Resources.Theme#obtainStyledAttributes(android.util.AttributeSet,%20int[],%20int,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="kr">Theme documentation</em></a></figcaption></figure><p id="6277" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们将回到主题，但让我们看看默认的风格。默认风格到底是什么？要回答这个问题，我认为从<code class="du ki kj kk kl b">TextView</code>快速绕过去，看看不起眼的<code class="du ki kj kk kl b">Button</code>是很说明问题的。当你把一个<code class="du ki kj kk kl b">&lt;Button&gt;</code>放到你的布局中时，它看起来像这样。</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div class="er es mw"><img src="../Images/c5c60090ccda832b4011ae8c6f944503.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*FU_7oWc7ZLOhBPBSifCHgA.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kr">A standard Button</em></figcaption></figure><p id="ab40" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为什么？如果你看一下<code class="du ki kj kk kl b">Button</code>的源代码，它相当稀疏:</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="d68a" class="mp kt hx kl b fi mq mr l ms mt">public class Button extends TextView {</span><span id="67a7" class="mp kt hx kl b fi mu mr l ms mt">  public Button(Context context) {<br/>    this(context, null);<br/>  }</span><span id="b38f" class="mp kt hx kl b fi mu mr l ms mt">  public Button(Context context, AttributeSet attrs) {<br/>    this(context, attrs, com.android.internal.R.attr.buttonStyle);<br/>  }</span><span id="cad5" class="mp kt hx kl b fi mu mr l ms mt">  public Button(Context context, AttributeSet attrs, int defStyleAttr) {<br/>    this(context, attrs, defStyleAttr, 0);<br/>  }</span><span id="4c5f" class="mp kt hx kl b fi mu mr l ms mt">  public Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {<br/>    super(context, attrs, defStyleAttr, defStyleRes);<br/>  }</span><span id="7af4" class="mp kt hx kl b fi mu mr l ms mt">  @Override public CharSequence getAccessibilityClassName() {<br/>    return Button.class.getName();<br/>  }</span><span id="1e9c" class="mp kt hx kl b fi mu mr l ms mt">  @Override public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex) {<br/>    if (getPointerIcon() == null &amp;&amp; isClickable() &amp;&amp; isEnabled()) {<br/>      return PointerIcon.getSystemIcon(getContext(), PointerIcon.TYPE_HAND);<br/>    }<br/>    return super.onResolvePointerIcon(event, pointerIndex);<br/>  }<br/>}</span></pre><p id="69f8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">就是这样！全班(少评论)。你可以在这里查看<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/Button.java" rel="noopener ugc nofollow" target="_blank"/>。我会等的。那么背景、大写的文字、波纹等等都是从哪里来的呢？你可能已经错过了，但这都在2 arg构造函数中；从XML展开布局时调用的函数。最后一个参数指定了<code class="du ki kj kk kl b">com.android.internal.R.attr.buttonStyle</code>的一个<code class="du ki kj kk kl b">defaultStyleAttr</code>。这是默认样式，本质上是一个间接点，允许你指定一个默认使用的样式。它并不直接指向一个样式，而是让<strong class="jo hy">你</strong>指向你的主题中的一个样式，它将在解析属性时检查这个样式。这正是你通常继承的所有主题所做的，为常见的小部件提供默认的外观和感觉。以Material主题为例，它定义了<code class="du ki kj kk kl b">&lt;item name="buttonStyle"&gt;@style/Widget.Material.Light.Button&lt;/item&gt;</code>，而<strong class="jo hy">这个</strong>样式提供了所有的属性，如果你不指定任何其他属性的话<code class="du ki kj kk kl b">theme.obtainStyledAttributes</code>就会提供这些属性。</p><p id="2c62" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">回到<code class="du ki kj kk kl b">TextView</code>，它还提供了一个默认的风格:<code class="du ki kj kk kl b">textViewStyle</code>。如果你想在你的应用程序中的每一个<code class="du ki kj kk kl b">TextView</code>应用一些样式，这会非常方便。假设您想设置默认的行距倍数为1.2。你可以通过<code class="du ki kj kk kl b">style</code> s/ <code class="du ki kj kk kl b">TextAppearance</code> s来做到这一点，并尝试通过代码审查(或者甚至是一个奇特的定制Lint规则)来强制执行这一点，但是你必须保持警惕，确保加入新的团队成员，并小心重构等。</p><p id="5876" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一个更好的方法可能是为应用程序中的所有<code class="du ki kj kk kl b">TextView</code>指定你自己的默认样式，编码期望的行为。您可以通过为<code class="du ki kj kk kl b">textViewStyle</code>设置您自己的样式来做到这一点，该样式从platform或material components/app compat default扩展而来。</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="e88e" class="mp kt hx kl b fi mq mr l ms mt">&lt;style name="Theme.MyApp"<br/>  parent="@style/Theme.MaterialComponents.Light"&gt;<br/>  ...<br/>  &lt;item name="android:textViewStyle"&gt;@style/Widget.MyApp.TextView&lt;/item&gt;&lt;/style&gt;</span><span id="0811" class="mp kt hx kl b fi mu mr l ms mt">&lt;style name="Widget.MyApp.TextView"<br/>  parent="@android:style/Widget.Material.TextView"&gt;<br/>  &lt;item name="android:textAppearance"&gt;@style/TextAppearance.MyApp.Body&lt;/item&gt;<br/>  &lt;item name="android:lineSpacingMultiplier"&gt;@dimen/text_line_spacing&lt;/item&gt;<br/>&lt;/style&gt;</span></pre><p id="552c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，考虑到这一点，我们的优先规则变成:</p><blockquote class="mf mg mh"><p id="b590" class="jm jn lp jo b jp jq iy jr js jt jb ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">视图&gt;样式&gt;默认样式&gt;文本外观</p></blockquote><p id="657c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">作为视图系统属性解析的一部分，这将插入到后样式中(因此默认样式中的任何内容都将被应用的样式或视图属性覆盖)，但仍将覆盖文本外观。默认样式非常方便。如果您曾经编写过自己的定制视图，那么它们可能是实现默认行为的一种强大方式，同时允许轻松定制。</p><p id="b67f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你正在创建一个小部件的子类，而<strong class="jo hy">没有</strong>指定你自己的默认样式，那么一定要在你的构造函数中使用父类的默认样式(不要只传递0)。例如，如果你正在扩展<code class="du ki kj kk kl b">AppCompatTextView</code>并编写你自己的2 arg构造函数，一定要将<code class="du ki kj kk kl b">android.R.attr.textViewStyle</code>作为<code class="du ki kj kk kl b">defaultStyleAttr</code> ( <a class="ae hu" href="https://github.com/nickbutcher/plaid/blob/master/core/src/main/java/io/plaidapp/core/ui/widget/BaselineGridTextView.java#L58" rel="noopener ugc nofollow" target="_blank">就像这个</a>)传递，否则你会丢失父类的行为。</p><h1 id="c317" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">主题</h1><p id="03f8" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">如前所述，有一种(最后，我保证)方法可以提供样式信息。另一个地方<code class="du ki kj kk kl b">theme.obtainStyledAttributes</code>看起来是直接在主题本身。也就是说，如果你在你的主题中提供了一个类似<code class="du ki kj kk kl b">android:textColor</code>的样式属性，视图系统会把它作为最后的手段。一般来说，混合主题属性和样式属性不是一个好主意，也就是说，你直接应用到视图的东西通常不应该在主题上设置(反之亦然)，但是也有一些罕见的例外。</p><p id="c1f9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一个例子可能是，如果你试图改变整个应用程序的字体。你可以使用上面的技术之一，但是手动设置样式/文本外观会重复且容易出错，默认样式只在窗口小部件级别有效；子类可能会覆盖这种行为，例如按钮定义它们自己的<code class="du ki kj kk kl b">android:buttonStyle</code>，它不会选择你的自定义<code class="du ki kj kk kl b">android:textViewStyle</code>。相反，您可以在主题中指定字体:</p><pre class="kn ko kp kq fd ml kl mm mn aw mo bi"><span id="0ad2" class="mp kt hx kl b fi mq mr l ms mt">&lt;style name="Theme.MyApp"<br/>  parent="@style/Theme.MaterialComponents.Light"&gt;<br/>  ...<br/>  &lt;item name="android:fontFamily"&gt;@font/space_mono&lt;/item&gt;<br/>&lt;/style&gt;</span></pre><p id="5b59" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在，任何支持该属性的视图都会选择它，除非被优先级更高的内容覆盖:</p><blockquote class="mf mg mh"><p id="ffc7" class="jm jn lp jo b jp jq iy jr js jt jb ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">视图&gt;样式&gt;默认样式&gt;主题&gt;文本外观</p></blockquote><p id="ada7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">同样，由于这是视图样式系统的一部分，它将覆盖文本外观中提供的任何内容，但会被任何更具体的属性覆盖。</p><p id="d630" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请记住这个优先顺序。在我们的应用程序宽字体示例中，您可能希望<code class="du ki kj kk kl b">Toolbar</code> s选择这种字体，因为它们包含一个标题<code class="du ki kj kk kl b">TextView</code>。然而，Toolbar类本身定义了一个默认样式，包含一个本身指定了<code class="du ki kj kk kl b">android:fontFamily</code>的<code class="du ki kj kk kl b">titleTextAppearance</code>，并直接在标题<code class="du ki kj kk kl b">TextView</code>上设置它，覆盖了主题级别值。主题级别的样式很有用，但是很容易被覆盖，所以一定要检查它是否按预期应用。</p><h1 id="2772" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">额外收获:拓展事务</h1><p id="d593" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">整篇文章都讨论了声明性视图级别的样式，即如何在膨胀时对整个<code class="du ki kj kk kl b">TextView</code>进行样式化。膨胀后应用的任何样式(例如<code class="du ki kj kk kl b"> textView.setTextColor(…)</code>)将覆盖声明性样式。<code class="du ki kj kk kl b">TextView</code>还通过<code class="du ki kj kk kl b">Span</code> s支持更精细的样式。我不会深入这个主题，因为它已经在<a class="mx my ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----f3a1729192d--------------------------------" rel="noopener" target="_blank">弗洛里纳·芒特内斯库</a>的这些文章中彻底讨论过了</p><div class="hg hh ez fb hi mz"><a rel="noopener follow" target="_blank" href="/google-developers/spantastic-text-styling-with-spans-17b0c16b4568"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hy fi z dy ne ea eb nf ed ef hw bi translated">带跨度的文本样式</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">要在Android中样式化文本，使用spans！改变一些字符的颜色，使它们可以点击，缩放…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ho mz"/></div></div></a></div><div class="hg hh ez fb hi mz"><a rel="noopener follow" target="_blank" href="/google-developers/underspanding-spans-1b91008b97e4"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hy fi z dy ne ea eb nf ed ef hw bi translated">下跨跨度</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">跨度是强大的概念，通过提供对组件的访问，允许在字符或段落级别对文本进行样式化…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn ho mz"/></div></div></a></div><p id="527a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我提到它是为了完整地记住编程风格和跨度将位于我们优先顺序的顶端:</p><blockquote class="mf mg mh"><p id="0867" class="jm jn lp jo b jp jq iy jr js jt jb ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">Span &gt;设置&gt;视图&gt;样式&gt;默认样式&gt;主题&gt;文本外观</p></blockquote><h1 id="2a78" class="ks kt hx bd ku kv kw kx ky kz la lb lc jd ld je le jg lf jh lg jj lh jk li lj bi translated">选择你的风格</h1><p id="7cbf" class="pw-post-body-paragraph jm jn hx jo b jp lk iy jr js ll jb ju jv lm jx jy jz ln kb kc kd lo kf kg kh ha bi translated">虽然有多种样式化文本的方式，但是了解这些技术之间的差异及其局限性有助于您为手头的工作找到合适的工具，或者理解为什么一种技术优先于另一种技术。</p><p id="16f9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">快乐的文字造型！</p></div></div>    
</body>
</html>