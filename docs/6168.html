<html>
<head>
<title>Keeping Related Pins fresh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持相关pin码新鲜</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/keeping-related-pins-fresh-6b0e2876d7e?source=collection_archive---------0-----------------------#2018-02-09">https://medium.com/pinterest-engineering/keeping-related-pins-fresh-6b0e2876d7e?source=collection_archive---------0-----------------------#2018-02-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8ec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">刘文秀|软件工程师，探索</p><p id="971f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你曾经听到有人提到“Pinterest兔子洞”，他们可能指的是相关的大头针，你在你点击的大头针下面看到的想法。相关大头针是与特写大头针相关的内容，占Pinterest参与度的40%。在如此高的使用率下，这些建议必须尽可能的个性化、相关和有用。我们进一步挖掘，找到了一个机会，使相关的pin尽可能新鲜，并确保新的pin——七天或更短——在相关时显示得更突出。</p><h1 id="3b89" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">冷启动问题</h1><p id="a5cc" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在推荐领域，寻找高质量、吸引人的新鲜内容被称为难以捉摸的“冷启动”问题。当内容是新的时，它通常很少有或没有信号可供推荐引擎使用，因此通常的候选生成和排序方法可能不会那么有效。</p><p id="766e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于相关引脚，冷启动问题同样令人望而生畏。大多数是通过遍历<a class="ae kf" rel="noopener" href="/@Pinterest_Engineering/introducing-pixie-an-advanced-graph-based-recommendation-system-e7b4229b664b"> Pixie </a>生成的，这是我们基于图表的个性化推荐系统，随后是<a class="ae kf" href="https://labs.pinterest.com/user/themes/pinlabs/assets/paper/p2p-www17.pdf" rel="noopener ugc nofollow" target="_blank">排名阶段</a>。在Pixie阶段，我们从特写大头针的节点开始，在图中进行随机遍历。在此过程中访问的Pin节点被记录并按访问计数排序。鉴于较旧的内容有时间在系统中被发现并保存到更多的板上，较旧的引脚在图中连接得更好。因此，在随机遍历中，遍历陈旧(较旧)管脚的机会更大。</p><p id="094e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在排名阶段，我们使用参与度数据作为积极信号来训练我们的模型。这就形成了一个反馈回路，其中较老的、但却是常青树的pin(包括大部分馈送)继续收集最积极的信号，而较新的pin收集较少的参与度数据。在训练过程中，我们的模型不能确定什么样的质量好，新鲜的针看起来像。在过去的一年里，我们一直致力于解决这些问题。</p><h2 id="b8c8" class="kg jd hh bd je kh ki kj ji kk kl km jm ip kn ko jq it kp kq ju ix kr ks jy kt bi translated"><strong class="ak">生成相关的新鲜pin码</strong></h2><p id="e317" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们解决的第一个挑战是生成与特写Pin(也称为查询Pin)相关的新Pin。我们通过使用Pixie来获取相关的电路板而不是引脚来做到这一点。在随机漫步中，我们跟踪哪些电路板被访问过，并根据访问次数对它们进行分类。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ku"><img src="../Images/01c8268f5ded5e863a9839416ad436fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/0*s7IFVxfTssyA8QoN."/></div><figcaption class="lc ld et er es le lf bd b be z dx">Fetching related boards with the Pixie graph</figcaption></figure><p id="df1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们收集了每块板上的新引脚，并将它们用作新的候选集。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lg"><img src="../Images/41f160d527807fd58bc80c1e2e8322bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*O7IM56OwBhJpO9j0."/></div><figcaption class="lc ld et er es le lf bd b be z dx">Gathering new pins from related boards</figcaption></figure><p id="2b98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然这种方法给了我们一些新的pin，但我们希望进一步提高覆盖率。</p><p id="148a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们尝试的下一个方法是用新的最近邻来扩充现有的Pixie图。我们构建了一个每日作业，首先获取过去七天添加到系统中的所有pin。然后，我们使用视觉和文本搜索来查找和映射每个新Pin的相关建议。这个映射然后被反转并上传到我们的Pixie服务器。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/eaafea714607df9f8d5b996b99958b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h7PcgsNuEqQvqV6x."/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Generating new neighbors</figcaption></figure><p id="3fa4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于每个像素结果引脚，我们查看新邻居的映射。我们保存了一份这些新邻居的名单，并根据他们出现的次数进行排序。这个最终列表被修整并作为第二组新的候选项返回。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lm"><img src="../Images/15e706bb14de7bd6330fa87475660c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXB9JAGXze6ZG4yN."/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Using the map of new neighbors to create a fresh candidate set</figcaption></figure><h2 id="cec2" class="kg jd hh bd je kh ki kj ji kk kl km jm ip kn ko jq it kp kq ju ix kr ks jy kt bi translated"><strong class="ak">将新鲜的大头针融入生态系统</strong></h2><p id="a0ba" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在我们有了新的候选集，我们必须将它们与更广泛的结果结合起来。我们的模型没有在最新的pin上训练(没有必要的元数据用于排名)，所以我们从简单的比率混合开始。我们每N个插槽插入一个新的Pin，以保证结果的新鲜度。这在我们的结果集中均匀地分布了新的pin，因此Pinners更有可能看到并参与其中。这是一个简单的初始解决方案，有助于收集更多关于新内容的信号。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ln"><img src="../Images/da01bd577c3134876f2cad29fed0dad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLBVKKix2swfH1R5."/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Blending fresh candidates by ratio</figcaption></figure><p id="ee29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是让我们的模型能够对新的pin进行排序。我们通过用从看过我们新候选人的用户那里收集的数据训练一个新模型来做到这一点。我们还为新pin创建了一种简化形式的元数据，可以在几秒钟内(而不是几天)生成。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lo"><img src="../Images/210338a1235b71f37d0acacf17a1776d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xJSW5O9V_Oiii8bl."/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Ranking fresh candidates</figcaption></figure><p id="c28e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这些新的变化，我们能够从简单的比例混合迁移到地板混合。使用floor blending，我们首先通过我们的排名程序运行新的候选人pin，然后根据分数将它们与其余的候选人合并。为了保证至少是最近的，我们设置了一个新鲜度阈值。如果新的候选人在结果集中排名较低，我们会将他们向上移动以满足阈值(如果新的候选人在结果中排名较好，我们可能不需要进行更改)。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lp"><img src="../Images/7ebc63dd829b9033aa48216eb886387c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m6TBWLnvCDLfDjpF."/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Floor blending fresh candidates</figcaption></figure><h2 id="5407" class="kg jd hh bd je kh ki kj ji kk kl km jm ip kn ko jq it kp kq ju ix kr ks jy kt bi translated"><strong class="ak">结果</strong></h2><p id="ddfd" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">通过生成相关的新鲜候选人，使我们的模型能够进行排名并在结果集中智能地混合它们，我们将相关pin的新鲜度提高了1，400%，同时保持其他参与度指标不变。这一举措将有助于我们的推荐随着时间的推移而改进，向Pinners展示他们最喜爱的领域中最相关和最有吸引力的内容，如时尚、烹饪、美容等。</p></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="585f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">鸣谢:这项技术是与斯蒂芬妮·罗杰斯、刘中达、庞·埃克松巴奇、康奈尔·多纳吉、任潮和李馨巧合作开发的。</em></p></div></div>    
</body>
</html>