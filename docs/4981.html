<html>
<head>
<title>Most Common Android Problems — Android Pitfalls 🐭 🧀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最常见的Android问题——Android陷阱🐭 🧀</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/most-common-android-problems-android-pitfalls-d7f3e11dabff?source=collection_archive---------0-----------------------#2022-04-11">https://blog.kotlin-academy.com/most-common-android-problems-android-pitfalls-d7f3e11dabff?source=collection_archive---------0-----------------------#2022-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ad626b439c0460feb6d47bb35136f7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVR7tiN1Hil8RMGYkdOLbw.png"/></div></div></figure><p id="fb2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大家好，希望一切顺利！</p><p id="aa27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将解释Android的常见问题以及我们应该如何解决它们。我将在三个标题下讨论这些问题；<strong class="jx io">核心，UI，网络</strong>。</p><p id="6a94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们开始吧！🏁</p><h1 id="6daa" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">核心⚡️</h1><h2 id="d6eb" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">屏幕旋转🤸🏼‍♀</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/1e67e50e50674140afc2397b33f68652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ePB8kSa15Wt7BLCi"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Photo by <a class="ae mm" href="https://unsplash.com/@laurenmancke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lauren Mancke</a> on <a class="ae mm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ef0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mn">旋转屏幕会发生什么？在我们考虑这个问题之前，让我们试着理解Android是如何处理这个问题的。</em></strong></p><p id="7a59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户旋转他们的手机<strong class="jx io">时，活动的配置会改变，因此android操作系统会破坏该活动并再次创建它</strong>。</p><p id="b31e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幕后；当设备方向改变时，首先当调用<code class="fe mo mp mq mr b"><strong class="jx io">onPause</strong></code> <strong class="jx io">、</strong> <code class="fe mo mp mq mr b"><strong class="jx io">onStop</strong></code> <strong class="jx io">和</strong> <code class="fe mo mp mq mr b"><strong class="jx io">onDestroy</strong></code>方法时，活动将消失一毫秒。几毫秒后，活动将重新启动，并调用<code class="fe mo mp mq mr b"><strong class="jx io">onCreate</strong></code>、<code class="fe mo mp mq mr b"><strong class="jx io">onStart</strong></code>和<code class="fe mo mp mq mr b"><strong class="jx io">onResume</strong></code>方法。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/fd05a0d23d839deb43d7df3e9e1c5736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*0XO2QQyYmWjPggw6UXHq4A.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Photo from <a class="ae mm" href="https://stackoverflow.com/questions/28954134" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/28954134</a></figcaption></figure><p id="644b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上图所示，随着屏幕的旋转，再次调用<code class="fe mo mp mq mr b">onCreate</code>方法，暗示我们的旧数据丢失了。这是我们在设计Android应用时面临的常见场景。没有进一步的犹豫，有两种流行的方法来处理这个问题！</p><ul class=""><li id="f470" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">使用视图模型:</strong> ViewModel <strong class="jx io"> </strong>类被设计用来保存和管理<strong class="jx io"> UI相关的数据</strong>也保留配置变化中的数据，比如屏幕旋转。这就是为什么当我们使用它们来保持我们的状态时，我们不需要担心电话轮换。</li></ul><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/55f1ac8f9b46e83608839ddd97a5efcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZt_W3SjaDsNaWhgZX_DlQ.png"/></div></div></figure><ul class=""><li id="688e" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">通过使用</strong> <code class="fe mo mp mq mr b">onSaveInstanceState()</code> <strong class="jx io"> : </strong>我们可以将数据存储在一个包中，并使用<code class="fe mo mp mq mr b">onRestoreInstanceState</code>方法进行检索。</li></ul><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="944a" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">您的清单&gt;活动标签添加</strong> <code class="fe mo mp mq mr b">android:configChanges="orientation|keyboardHidden|screenSize"</code> <strong class="jx io"> : </strong>这可以防止您的活动在旋转或改变方向时被重新创建，从而不会丢失任何数据(将保留您以前的值)</li></ul><h2 id="cce8" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">片段空校验</h2><p id="0e13" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">下一个主题是在使用片段管理器添加片段之前检查是否创建了活动。</p><p id="976c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mn">为什么在添加新片段之前，需要在onCreate时检查</em> </strong> <code class="fe mo mp mq mr b">savedInstanceState</code> <strong class="jx io"> <em class="mn">参数是否为空？</em> </strong> —答案在这里👉🏻当您的活动被重新创建时，例如在屏幕旋转或其他<a class="ae mm" href="http://developer.android.com/guide/topics/resources/runtime-changes.html" rel="noopener ugc nofollow" target="_blank">配置更改</a>之后，片段会被自动重新附加。通过在<code class="fe mo mp mq mr b">onCreate</code>检查<code class="fe mo mp mq mr b">savedInstanceState == null</code>，你确保你没有重新添加已经为你添加的片段。</p><p id="f0da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以使用<code class="fe mo mp mq mr b">findFragmentByTag</code>或<code class="fe mo mp mq mr b">findFragmentById</code>函数来获得一个片段。如果提到的方法返回null，那么该片段不存在。如果一个片段存在，你不必创建一个新的，你应该使用现有的！</p><pre class="me mf mg mh gt nk mr nl nm aw nn bi"><span id="b643" class="lr ku in mr b gy no np l nq nr">Fragment fragmentA = fragmentManager.findFragmentByTag("frag1");<br/>if (fragmentA == null) {<br/>  // not exist<br/>} else {<br/>  // fragment exist<br/>}</span></pre><p id="c825" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一下，你不需要声明引用Fragment实例的变量。相反，通过标签保存你的片段，然后获取它。像那样；</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="ebda" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">与碎片交流</h2><ul class=""><li id="8296" class="mt mu in jx b jy nf kc ng kg ns kk nt ko nu ks my mz na nb bi translated"><strong class="jx io">通过定义接口在片段之间传递数据:</strong>在片段之间传递数据的最常见的方式是通过使用由容器活动实现的方法来定义接口。你可以认为我们有一个项目的清单和项目的细节片段。列表片段调用由活动实现的方法，并将数据(项目id)传递给它。活动中的方法找到项目细节片段，并通过调用细节片段中定义的setter方法来设置从项目片段接收的数据。</li></ul><p id="d6e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如何做到这一点！</p><p id="7c32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我创建了一个名为Communicator的接口，这里有一个方法<code class="fe mo mp mq mr b">sendSelectedItemId</code>,我们从ListItem片段中发送选中项目的id。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a0ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过用<strong class="jx io"> MainActivity </strong>中的<strong class="jx io"> DetailFragment </strong>替换<strong class="jx io"> ListItemFragment </strong>来显示新片段，就像这样；</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d9b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们发送了来自<strong class="jx io">列表项</strong> <strong class="jx io">片段</strong>的值之后，就该从我们的<strong class="jx io">细节片段</strong>中检索它并将其显示在屏幕上了。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="a8ee" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">使用ViewModel在片段之间传递数据:</strong>使用ViewModel和LiveData在活动的两个片段之间传递数据的最佳解决方案之一。</li></ul><p id="1731" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来看例子。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f7f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户点击一个按钮时，FragmentA将更新ViewModel中的实时数据。代码如下所示:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ff01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正在观察SharedViewModel的选定实时数据的任何人现在都可以对实时数据中的变化做出反应。如果FragmentB想要注意到变化，它将看起来像这样:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d2e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">活动也观察变化；</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="4658" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated"><strong class="jx io">片段结果监听器:</strong>你可以通过使用Fragment Result Listener找到如何在片段间传递结果的最佳解释，请阅读此<a class="ae mm" href="https://developer.android.com/guide/fragments/communicate#fragment-result" rel="noopener ugc nofollow" target="_blank">文档</a>！</li></ul><h1 id="760f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用户界面🔮</h1><p id="e972" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">让我们想象一下，你已经开始开发应用程序，你要在你的用户界面上显示数据。我们会面临什么样的情况？🧐</p><p id="89ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看第一种情况！</p><h2 id="0cac" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">没有互联网连接</h2><p id="d325" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">你完成了任务，获取了数据，并在你的应用程序上显示出来，一切都很好，但如果互联网<strong class="jx io">瘫痪</strong>，用户会怎么办？</p><p id="1b01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个场景中，将自己<strong class="jx io"> <em class="mn">视为用户</em> </strong>。<strong class="jx io"> <em class="mn">你想在屏幕上看到什么？</em> </strong> <strong class="jx io"> <em class="mn">什么都没有？以前的数据？相关信息？..</em> </strong></p><p id="2663" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想没有人想在屏幕上看到任何东西。我们可能会显示相关的消息，我认为这比在这个场景中什么都不显示要好，但是我的方法是“显示<strong class="jx io">以前的</strong> <strong class="jx io">数据</strong>！”我们来看看怎么做吧！</p><blockquote class="nv nw nx"><p id="dcca" class="jv jw mn jx b jy jz ka kb kc kd ke kf ny kh ki kj nz kl km kn oa kp kq kr ks ig bi translated">首先，为了做到这一点，用户必须在连接互联网时至少使用一次应用程序<strong class="jx io"/><strong class="jx io"/>；否则，我们无法这样做，因为我们需要获取数据以便保存它！</p></blockquote><p id="2de9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户第一次启动应用程序时，所有数据都保存在数据库中(例如SQLite、房间等)。如果用户有互联网连接，以前存储在数据库中的数据将被删除，然后新数据(更新)将被一次又一次地保存到数据库中…</p><p id="4572" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这太好了，因为我们希望保留最新的数据。<strong class="jx io"> </strong>当用户没有互联网连接时，我们可以显示存储在我们app上的数据。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ac68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是请密切注意那里，因为我们需要小心我们显示的数据！例如，您可能有服装数据(图片、详细信息、价格、尺寸等)<strong class="jx io"> <em class="mn">您希望显示哪个字段？</em> </strong>我更喜欢<strong class="jx io">而不是</strong>显示服装价格，因为它们可能会在没有互联网连接的情况下发生变化。我只会分享衣服的图片，细节和尺寸，这些都是静态的信息。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="31e8" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">如果您的数据为空，该怎么办？</h2><p id="6372" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">让我们回顾一下这个场景。您已经获取了数据并将它们列在UI上，一切看起来都是有序的，但是如果一些数据是空的呢？！ <strong class="jx io"> <em class="mn">作为用户，你期望在屏幕上看到什么？</em>T41】</strong></p><p id="9859" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，作为一个用户，我更喜欢看到一些东西，而不是什么都没有的！<br/>作为开发人员，如果图像数据为空，我会显示信息图像，对于文本数据，我会显示类似<strong class="jx io"><em class="mn">‘对不起，我们找不到尺寸信息’或‘不适用’</em></strong>的信息文本</p><blockquote class="nv nw nx"><p id="356b" class="jv jw mn jx b jy jz ka kb kc kd ke kf ny kh ki kj nz kl km kn oa kp kq kr ks ig bi translated">请记住，我们不管理服务数据，但我们可以更清楚地显示它。</p></blockquote><p id="7e1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在这段代码中看到我是如何处理它的👇🏻</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="5161" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">用户界面状态(加载、成功、错误)</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/97b5ed38dc406c1f62dbc9ff753c5b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t7JeU-oTMm9Otpl_9-vPA.png"/></div></div></figure><p id="c4cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们向服务发出了请求，正在等待响应；因此，<strong class="jx io"> <em class="mn">在这种情况下，您的方法是什么(直到您收到服务的响应)？</em> </strong> <strong class="jx io"> <em class="mn">您会简单地等待响应还是通知用户这种情况？</em>T15】</strong></p><p id="83bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我是一个<strong class="jx io">用户</strong>，如果我在得到服务的响应之前没有在屏幕上看到变化，我会认为这个应用程序被冻结了，无法工作，我会退出它。</p><p id="7bbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一个<strong class="jx io">开发者</strong>，在这样的情况下我会采取以下做法:首先，不管服务的响应(成功，错误)，我们都必须提供用户应该等待的消息，即加载消息。如果结果是一个错误，我们必须向用户显示相同的错误消息。如果我们的服务结果是成功的，我们必须展示我们的数据。</p><p id="0903" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的例子中，我使用了MVVM架构，因此我在ProductViewModel类中更新了我的UI状态。当UI状态被触发时，我还调用了<code class="fe mo mp mq mr b">bindApiStatus</code>函数。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，另一个问题是<strong class="jx io">装载</strong>的状态。我们向服务发出请求，从那时起的过程，直到我们得到响应，就是我们的加载状态生命周期。</p><p id="4640" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们想象一下这样一个场景，我们有产品并列出它们，当用户点击其中一个时，它会把他们带到产品的详细页面。<strong class="jx io"> <em class="mn">这种情况下装载状态应该放在哪里？</em> </strong> 🧐请在评论中分享你的想法！</p><h1 id="2b4c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">⛓网络</h1><h2 id="72f9" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">SSL固定</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/72344f396f7a71b08d7649e584a51925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhgRJUCTBohX_u2hdLw9cQ.jpeg"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Reference from techuz.com</figcaption></figure><p id="e5c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mn">什么是SSL？— </em> </strong> SSL Pinning代表<strong class="jx io">安全套接字层</strong>。SSL是在<strong class="jx io">客户端</strong>和<strong class="jx io">服务器</strong>之间建立加密链接的标准安全技术。SSL证书有一个密钥对，即一个<strong class="jx io">公钥</strong>和一个<strong class="jx io">私钥</strong>。</p><p id="6a66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mn">为什么需要SSL证书钉住？</em> </strong> — SSL pinning允许应用程序只信任有效的或预定义的<strong class="jx io">证书</strong>或<strong class="jx io">公钥。</strong>应用程序开发人员使用<strong class="jx io"> SSL pinning </strong>技术作为应用程序流量的附加安全层。通常，应用程序信任自定义的<strong class="jx io">证书</strong>，并允许应用程序拦截流量。</p><p id="662d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">锁定可信证书集可以防止攻击者分析服务器通信。</p><p id="5575" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在<strong class="jx io">参考文献</strong>部分添加了一些关于SSL固定的文章，强烈推荐您阅读。你可以在这里了解更多！</p><h2 id="2d2b" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">ProGuard-Android</h2><p id="54aa" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">ProGuard是一个可以帮助你<strong class="jx io">缩小</strong>、<strong class="jx io">混淆</strong>和<strong class="jx io">优化</strong>你的代码的程序。这对于减少你的Android应用程序的整体大小以及删除那些导致Android应用程序固有的64k 方法限制的不使用的类和方法是非常有效的。因此，ProGuard经常被建议用于开发和生产，特别是对于<strong class="jx io">更大的</strong>项目。</p><p id="0d3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过指定<strong class="jx io"> minifyEnabled </strong>参数，可为任何建筑类型激活ProGuard。强烈建议，如果您打算将它用于<strong class="jx io">生产</strong>，也在您的<strong class="jx io">开发</strong>中启用它。如果您没有在您的开发版本上彻底测试ProGuard，您可能会遇到意外的崩溃或应用程序无法按预期执行的情况。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="292d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Android SDK包括ProGuard和默认设置文件，名为<strong class="jx io"> proguard-android.txt </strong>。包含这个文件是非常重要的，因为它包含了显式的配置设置，比如明确指定所有的视图getter和setter方法都不应该被移除。您将用来配置的文件是proguard-rules.pro。</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="23d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读。我希望它对你有帮助😌请随时在<a class="ae mm" href="https://github.com/BegumYazici" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae mm" href="https://www.linkedin.com/in/begumyazici/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。回头见！</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><h1 id="387b" class="kt ku in bd kv kw ok ky kz la ol lc ld le om lg lh li on lk ll lm oo lo lp lq bi translated">参考🔍</h1><div class="op oq gp gr or os"><a href="https://stackoverflow.com/questions/31277979/why-is-it-necessary-to-check-savedinstancestate-inside-of-oncreate/31278014#31278014" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">为什么需要在OnCreate内部检查savedInstanceState？</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">onCreate()方法中if块的用途是什么？为什么需要检查savedInstanceState是否…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">stackoverflow.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jt os"/></div></div></a></div><p id="4015" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mm" href="https://developer.android.com/guide/fragments/communicate" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/guide/fragments/communicate</a></p><div class="op oq gp gr or os"><a href="https://medium.com/@anuj.rai2489/ssl-pinning-254fa8ca2109" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">SSL固定</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">SSL pinning代表安全套接字层。SSL证书通过建立一个安全的…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg jt os"/></div></div></a></div><p id="0279" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mm" href="https://mailapurvpandey.medium.com/ssl-pinning-in-android-90dddfa3e051#:~:text=SSL%20pinning%20is%20a%20process,'pinned'%20to%20the%20host" rel="noopener">https://mailapurvpandey . medium . com/SSL-pinning-in-Android-90 dddfa 3 e 051 #:~:text = SSL % 20 pinning % 20 is % 20a % 20 process，' pinned ' % 20 to % 20% 20 host</a>。</p><p id="7772" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mm" href="https://developer.android.com/guide/fragments/communicate#fragment-result" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/guide/fragments/communicate # fragment-result</a></p><figure class="me mf mg mh gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi pi"><img src="../Images/7cc3e53c80b722128adb3c22f527646e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PRlebsP2nkBq-WA8pLJew.png"/></div></a></figure></div></div>    
</body>
</html>