<html>
<head>
<title>How to Build REST API with Node.js from Scratch?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js从零开始构建REST API？</h1>
<blockquote>原文：<a href="https://medium.com/edureka/rest-api-with-node-js-b245e345f7a5?source=collection_archive---------0-----------------------#2019-05-07">https://medium.com/edureka/rest-api-with-node-js-b245e345f7a5?source=collection_archive---------0-----------------------#2019-05-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/8aa5e542408167d6de2efa63dbca4bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3EkVGOncIe9--WNjcyTkRw.png"/></div><figcaption class="il im et er es in io bd b be z dx">Build REST API With Node.js — Edureka</figcaption></figure><p id="3bc3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从WWW发明以来，各种web技术如RPC或SOAP被用来创建和实现web服务。但是这些技术在处理任何通信任务时都使用了严格的定义。因此，REST被开发出来，它有助于降低复杂性，并为设计基于网络的应用程序提供了一种架构风格。因为Node.js技术为前端开发人员带来了服务器的革命，所以在本文中，我将展示用Node.js从头开始构建REST API的过程。</p><p id="0988" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是我将在本文中涉及的主题:</p><ul class=""><li id="227f" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">什么是REST API？</li><li id="891c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">休息原则</li><li id="025e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">实践演示:用Node.js构建REST API</li></ul><h1 id="4e15" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是REST API？</h1><p id="bcb6" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">REST或<strong class="ir hi"> REST </strong> ful代表<strong class="ir hi"><em class="le">RE</em></strong><em class="le">presental</em><strong class="ir hi"><em class="le">S</em></strong><em class="le">tate</em><strong class="ir hi"><em class="le">T</em></strong><em class="le">transfer。它是一种架构风格，也是一种用于通信目的的方法，经常用于各种web服务开发。简单地说，它是一个应用程序接口(API ),利用HTTP请求在WWW上获取、上传、发布和删除数据。</em></p><p id="c4ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">REST架构风格有助于利用较少的带宽，这使得应用程序更适合互联网。它通常被认为是互联网的“<strong class="ir hi"><em class="le"/></strong>”语言。它完全基于资源，其中每个组件都被视为一个组件，单个资源可以通过使用标准HTTP方法的公共接口进行访问。</p><p id="7744" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了更好地理解，让我们深入一点，看看REST API到底是如何工作的。基本上，REST API分解一个事务，以便创建小模块。现在，这些模块中的每一个都用于处理交易的特定部分。这种方法提供了更多的灵活性，但是需要从头开始进行大量的工作。</p><p id="4bb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="le">任何基于REST的架构中使用的主要函数有:</em> </strong></p><ul class=""><li id="8d04" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">提供对资源的只读访问。</li><li id="0b37" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">PUT</strong>—创建新资源。</li><li id="b5ec" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">删除</strong>—删除资源。</li><li id="8213" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">发布</strong>—更新现有资源或创建新资源。</li></ul><p id="8934" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但凡是声称的都不能称为RESTful API。为了被视为RESTful API，您的应用程序必须满足某些约束或原则。在本文的下一部分，我将详细讨论这些原则。</p><h1 id="b4c9" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">休息原则</h1><p id="69e4" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">菲尔丁博士提出了六条基本原则，他是2000年定义REST API设计的人。以下是休息的六个指导原则:</p><h2 id="2244" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">无状态</strong></h2><p id="0aed" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">从客户端发送到服务器的请求包含完全理解它所需的所有必要信息。它可以是URI、查询字符串参数、正文甚至标头的一部分。URI用于唯一标识资源，主体保存请求资源的状态。一旦服务器完成处理，一个适当的响应将通过头、状态或响应体发送回客户端。</p><h2 id="63a9" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">客户端-服务器</strong></h2><p id="4a11" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">它有一个统一的接口，将客户机和服务器分开。分离关注点有助于提高跨多个平台的用户界面的可移植性，并增强服务器组件的可伸缩性。</p><h2 id="9ee5" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">统一接口</strong></h2><p id="5364" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">为了获得整个应用程序的一致性，REST定义了四个接口约束，它们是:</p><ul class=""><li id="a403" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">资源标识</li><li id="20c8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用表示的资源操作</li><li id="7502" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">自我描述的消息</li><li id="4ca1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">作为应用程序状态引擎的超媒体</li></ul><h2 id="eeaf" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">可缓存</strong></h2><p id="3582" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">为了提供更好的性能，应用程序通常是可缓存的。这是通过隐式或显式地将来自服务器的响应标记为可缓存或不可缓存来实现的。如果响应被定义为可缓存的，那么客户机缓存可以在将来为等效的响应重用响应数据。它还有助于防止过时数据的重复使用。</p><h2 id="88ff" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">分层系统</strong></h2><p id="c311" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">分层系统架构通过限制组件行为使应用程序更加稳定。这种体系结构支持负载平衡，并提供共享缓存来提高可伸缩性。分层架构还有助于增强应用程序的安全性，因为每一层中的组件都不能与其所在的下一层之外的组件进行交互。</p><h2 id="afb3" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak">按需编码</strong></h2><p id="5e10" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">按需编码是一个可选的约束，使用最少。它允许通过接口下载和扩展客户代码或小应用程序，以便在应用程序中使用。本质上，它通过创建一个不依赖于自身代码结构的智能应用程序来简化客户端。</p><p id="9b7a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在您已经知道了什么是REST API，以及为了交付高效的应用程序您需要注意什么，让我们更深入地了解使用Node.js构建REST API的过程。</p><h1 id="9984" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">实践演示:使用Node.js构建REST API</h1><p id="9729" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">这里，我们将使用<a class="ae lt" href="https://www.edureka.co/blog/nodejs-tutorial?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=rest-api-with-node-js" rel="noopener ugc nofollow" target="_blank"> Node.js和Express.js </a>为库管理创建一个简单的CRUD REST应用程序。要构建此应用程序，您需要安装以下软件:</p><ol class=""><li id="4cf3" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lu jt ju jv bi translated">节点. js</li><li id="60a1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lu jt ju jv bi translated">快递. js</li><li id="f93c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lu jt ju jv bi translated">约伊</li><li id="ecd5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lu jt ju jv bi translated">节点监控器</li></ol><p id="59a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个例子中，我将使用WebStorm IDE来编写和执行代码。您可以根据自己的选择使用任何IDE或代码编辑器。那么，我们开始吧。</p><p id="d8c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，您需要创建您的项目目录。接下来，打开命令提示符并导航到您的项目目录。在那里，您需要使用下面的命令调用npm:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6036" class="lf kc hh ma b fi me mf l mg mh">npm init</span></pre><p id="c252" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您点击enter时，Node.js会要求您输入一些细节来构建。json文件，例如:</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/865b804b7fd0076b4e5b6d7b8f181fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*R7fUiwOq4GIq9sfuX4fUGA.png"/></div></div></figure><p id="57e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，您可以定义您的入口点以及其他一些信息。对于这个演示，我将使用<strong class="ir hi"> script.js </strong>作为切入点。接下来，我们将使用以下命令安装Express.js:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6ed7" class="lf kc hh ma b fi me mf l mg mh">npm i express</span></pre><p id="f2d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我将安装一个名为<strong class="ir hi"> nodemon的节点监控包。</strong>它监视该文件夹中任何扩展名的所有文件。此外，有了观察器上的nodemon，您不必在每次进行任何更改时都重新启动Node.js服务器。nodemon将隐式地检测这些更改，并为您重新启动服务器。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3f7b" class="lf kc hh ma b fi me mf l mg mh">npm i -g nodemon</span></pre><h2 id="53d7" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak"> package.json </strong></h2><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="9a68" class="lf kc hh ma b fi me mf l mg mh">{<br/>"name": "samplerestapi",<br/>"version": "1.0.0",<br/>"description": "Edureka REST API with Node.js",<br/>"main": "script.js",<br/>"scripts": {<br/>"test": "echo "Error: no test specified" &amp;amp;&amp;amp; exit 1"<br/>},<br/>"author": "Edureka",<br/>"license": "ISC",<br/>"dependencies": {<br/>"express": "^4.16.4",<br/>"joi": "^13.1.0"<br/>}<br/>}</span></pre><h2 id="711c" class="lf kc hh bd kd lg lh li kh lj lk ll kl ja lm ln kp je lo lp kt ji lq lr kx ls bi translated"><strong class="ak"> script.js </strong></h2><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="d90d" class="lf kc hh ma b fi me mf l mg mh">const express = require('express');<br/>const Joi = require('joi'); //used for validation<br/>const app = express();<br/>app.use(express.json());<br/> <br/>const books = [<br/>{title: 'Harry Potter', id: 1},<br/>{title: 'Twilight', id: 2},<br/>{title: 'Lorien Legacies', id: 3}<br/>]<br/> <br/>//READ Request Handlers<br/>app.get('/', (req, res) =&gt; {<br/>res.send('Welcome to Edurekas REST API with Node.js Tutorial!!');<br/>});<br/> <br/>app.get('/api/books', (req,res)=&gt; {<br/>res.send(books);<br/>});<br/> <br/>app.get('/api/books/:id', (req, res) =&gt; {<br/>const book = books.find(c =&gt; c.id === parseInt(req.params.id));<br/> <br/>if (!book) res.status(404).send('&lt;h2 style="font-family: Malgun Gothic; color: darkred;"&gt;Ooops... Cant find what you are looking for!&lt;/h2&gt;');<br/>res.send(book);<br/>});<br/> <br/>//CREATE Request Handler<br/>app.post('/api/books', (req, res)=&gt; {<br/> <br/>const { error } = validateBook(req.body);<br/>if (error){<br/>res.status(400).send(error.details[0].message)<br/>return;<br/>}<br/>const book = {<br/>id: books.length + 1,<br/>title: req.body.title<br/>};<br/>books.push(book);<br/>res.send(book);<br/>});<br/> <br/>//UPDATE Request Handler<br/>app.put('/api/books/:id', (req, res) =&gt; {<br/>const book = books.find(c=&gt; c.id === parseInt(req.params.id));<br/>if (!book) res.status(404).send('&lt;h2 style="font-family: Malgun Gothic; color: darkred;"&gt;Not Found!! &lt;/h2&gt;');<br/> <br/>const { error } = validateBook(req.body);<br/>if (error){<br/>res.status(400).send(error.details[0].message);<br/>return;<br/>}<br/> <br/>book.title = req.body.title;<br/>res.send(book);<br/>});<br/> <br/>//DELETE Request Handler<br/>app.delete('/api/books/:id', (req, res) =&gt; {<br/> <br/>const book = books.find( c=&gt; c.id === parseInt(req.params.id));<br/>if(!book) res.status(404).send('&lt;h2 style="font-family: Malgun Gothic; color: darkred;"&gt; Not Found!! &lt;/h2&gt;');<br/> <br/>const index = books.indexOf(book);<br/>books.splice(index,1);<br/> <br/>res.send(book);<br/>});<br/> <br/>function validateBook(book) {<br/>const schema = {<br/>title: Joi.string().min(3).required()<br/>};<br/>return Joi.validate(book, schema);<br/> <br/>}<br/> <br/>//PORT ENVIRONMENT VARIABLE<br/>const port = process.env.PORT || 8080;<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}..`));</span></pre><p id="018a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，下一步是检查处理程序是否正常工作。为此，我们将使用名为Postman的Chrome扩展。要安装Postman，你可以访问这里的<a class="ae lt" href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a><strong class="ir hi"/>，点击“添加到Chrome”。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mn"><img src="../Images/839c699e1596fa71898a09603beed268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D936oVkEnSqE7fhg1cXElA.png"/></div></div></figure><p id="726d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">成功安装Postman后，打开它并开始测试您的应用程序。所以，让我们从测试GET方法开始。现在，为了做到这一点，您需要从下拉列表中选择GET，键入定义的URI并点击send。如果您的代码运行良好，那么您将会看到我们在代码中手动添加的所有书籍的列表。在下面的图片中，你可以看到我的结果。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mo"><img src="../Images/be1fe19981e7def5feb74a068a3d03f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hobGeUNAroLPLnjoU7xSzg.png"/></div></div></figure><p id="3bdb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们尝试将一本新书添加到我们的目录列表中。为此，从下拉列表中选择“POST ”,并输入为POST方法定义的URI。现在，单击“Body ”,选择“raw ”,然后从下拉列表中选择“JSON ”,如下图所示。现在，在文本区，键入你的书名，如图所示，然后点击发送。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mp"><img src="../Images/72c5fb1437f134dc634fd46918c444c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pRAGi1dDrfCE97dh46xXg.png"/></div></div></figure><p id="4cda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的POST方法运行良好，您的响应正文将包含书名和图书id。现在，让我们尝试更新书名。目前，我的书名是“天使与魔鬼”，我将更新为“天使与魔鬼”。因此，要更新数据，您需要首先从下拉列表中选择“PUT ”,并输入PUT请求的URI以及您希望更新的图书id。接下来在“正文”中，输入新书标题，然后按回车键。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mp"><img src="../Images/1bce9c0a788619e85403a1aca2d7466c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u43Kiad8sFL7dqfzKfuSdw.png"/></div></div></figure><p id="b40a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将给你一个带有图书id和更新的书名的响应。</p><p id="88ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，让我们发送一个“删除”请求来删除一个现有的记录。从下拉列表中选择DELETE，并键入删除请求处理程序的URI以及您想要删除的书的详细信息，然后按enter键。如果您的交易成功，您将在回复正文中看到已删除条目的完整详细信息。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mq"><img src="../Images/18ca1477315c2536e6a0aa1591b8061a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MX9UYqNDzxJ1-aZaOM6kug.png"/></div></div></figure><p id="2fd9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们发送一个GET请求来获取我们的最终图书列表。</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mr"><img src="../Images/9b70e1e130fb338387627b67fc3ff6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZK3HSMf-ewrcObZHtL6lA.png"/></div></div></figure><p id="638f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的截图中可以看到，响应正文总共包含三本书，其中缺少图书id 3，因为我们已经删除了该条目。</p><p id="f366" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">至此，我们结束了这篇关于用Node.js构建REST API的文章。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Node.js的各个方面</p><blockquote class="ms mt mu"><p id="7c19" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">1.<a class="ae lt" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> NodeJS教程</a></p><p id="823e" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">2.<a class="ae lt" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762">使用Node.js和MySQL构建一个CRUD应用程序</a></p><p id="b4e1" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">3.<a class="ae lt" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c">使用节点构建CRUD应用程序。JS和MongoDB </a></p><p id="df2f" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">4.<a class="ae lt" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="ea4d" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">5.<a class="ae lt" rel="noopener" href="/edureka/node-js-docker-tutorial-72e7542d69d8">如何对Node.js App进行Dockerize？</a></p><p id="caf6" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">6.<a class="ae lt" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">用Node.js构建REST API</a></p><p id="865e" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">7.<a class="ae lt" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="4de2" class="ip iq le ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">8.<a class="ae lt" rel="noopener" href="/edureka/learn-node-js-b3a9c6fb632c"> Express.js基础</a></p></blockquote></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="2a45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="le">原载于2019年5月7日https://www.edureka.co</em><em class="le">T21</em><a class="ae lt" href="https://www.edureka.co/blog/rest-api-with-node-js/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>