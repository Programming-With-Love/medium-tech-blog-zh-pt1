# 如何用 Python 编码:用 Python 编码的好与坏的实践

> 原文：<https://medium.com/quick-code/how-to-code-in-python-good-and-bad-practices-of-coding-in-python-e320bd581a3a?source=collection_archive---------0----------------------->

![](img/a4f2c6c96876fa2a2a79e3a3d541b377.png)

[Duomly — Programming Online Courses](https://www.duomly.com)

本文最初发表于:[https://www . blog . duomly . com/good-and-bad-practices-of-coding-in-python/](https://www.blog.duomly.com/good-and-bad-practices-of-coding-in-python/)

Python 是一种强调可读性的高级多范式编程语言。它是按照被称为**Python 之禅**或 **PEP 20** 的规则开发、维护和经常使用的。

本文展示了几个您可能经常遇到的用 Python 编码的好的和坏的实践的例子。

# 使用解包编写简洁的代码

打包和解包是强大的 Python 特性。您可以使用解包来为变量赋值:

```
**>>> a, b = 2, 'my-string'
>>> a
2
>>> b
'my-string'**
```

您可以利用这种行为来实现整个计算机编程世界中最简洁、最优雅的变量交换:

```
**>>> a, b = b, a**
**>>> a**
**'my-string'**
**>>> b**
**2**
```

太棒了。
在更复杂的情况下，解包可用于多个变量的赋值。例如，您可以这样赋值:

```
**>>> x = (1, 2, 4, 8, 16)
>>> a = x[0]
>>> b = x[1]
>>> c = x[2]
>>> d = x[3]
>>> e = x[4]
>>> a, b, c, d, e
(1, 2, 4, 8, 16)**
```

但是，您可以使用一种更简洁、更具可读性的方法:

```
**>>> a, b, c, d, e = x**
**>>> a, b, c, d, e**
**(1, 2, 4, 8, 16)**
```

很酷，对吧？但它甚至可以更酷:

```
**>>> a, *y, e = x**
**>>> a, e, y**
**(1, 16, [2, 4, 8])**
```

重点是带*的变量收集了没有赋给别人的值。

# 使用链接编写简洁的代码

Python 允许您链接比较操作。因此，您不必使用 and 来检查两个或多个比较是否为真:

```
**>>> x = 4**
**>>> x >= 2 and x <= 8**
**True**
```

相反，你可以像数学家一样，用更简洁的形式来写:

```
**>>> 2 <= x <= 8**
**True**
**>>> 2 <= x <= 3**
**False**
```

Python 也支持链式赋值。所以，如果你想给多个变量赋予相同的值，你可以用一种简单的方法:

```
**>>> x = 2**
**>>> y = 2**
**>>> z = 2**
```

一种更优雅的方式是使用解包:

```
**>>> x, y, z = 2, 2, 2**
```

然而，使用链式分配，事情会变得更好:

```
**>>> x = y = z = 2**
**>>> x, y, z**
**(2, 2, 2)**
```

当你的值可变时要小心！所有变量都引用同一个实例。

# 检查无

在 Python 中，None 是一个特殊且唯一的对象。它有一个类似的目的，就像类 C 语言中的 null。

可以用比较运算符==和来检查变量是否引用了它！=:

```
**>>> x, y = 2, None**
**>>> x == None**
**False**
**>>> y == None**
**True**
**>>> x != None**
**True**
**>>> y != None**
**False**
```

然而，一种更巧妙、更可取的方法是使用 is 和 not:

```
**>>> x is None**
**False**
**>>> y is None**
**True**
**>>> x is not None**
**True**
**>>> y is not None**
**False**
```

此外，您应该更喜欢使用 is not 结构 x not None，而不是可读性较差的替代结构 not (x is None)。

# 迭代序列和映射

您可以通过几种方式在 Python 中实现迭代和 for 循环。Python 提供了一些内置的类来促进它。

几乎在所有情况下，您都可以使用该范围来获得产生整数的迭代器:

```
**>>> x = [1, 2, 4, 8, 16]**
**>>> for i in range(len(x)):**
**...     print(x[i])**
**...** 
**1**
**2**
**4**
**8**
**16**
```

然而，有一种更好的方法来迭代序列:

```
**>>> for item in x:**
**...     print(item)**
**...** 
**1**
**2**
**4**
**8**
**16**
```

但是如果你想以相反的顺序迭代呢？当然，范围也是一个选项:

```
**>>> for i in range(len(x)-1, -1, -1):**
**...     print(x[i])**
**...** 
**16**
**8**
**4**
**2**
**1**
```

颠倒顺序是一种更优雅的方式:

```
**>>> for item in x[::-1]:**
**...     print(item)**
**...** 
**16**
**8**
**4**
**2**
**1**
```

Pythonic 式的方法是使用 reversed 来获得一个迭代器，该迭代器以相反的顺序产生序列中的各项:

```
**>>> for item in reversed(x):**
**...     print(item)**
**...** 
**16**
**8**
**4**
**2**
**1**
```

有时，您需要序列中的项目和相应的索引:

```
**>>> for i in range(len(x)):**
**...     print(i, x[i])**
**...** 
**0 1**
**1 2**
**2 4**
**3 8**
**4 16**
```

最好使用 enumerate 获得另一个迭代器，该迭代器产生带有索引和条目的元组:

```
**>>> for i, item in enumerate(x):**
**...     print(i, item)**
**...** 
**0 1**
**1 2**
**2 4**
**3 8**
**4 16**
```

太酷了。但是如果你想迭代两个或更多的序列呢？当然，您可以再次使用该范围:

```
**>>> y = 'abcde'**
**>>> for i in range(len(x)):**
**...     print(x[i], y[i])**
**...** 
**1 a**
**2 b**
**4 c**
**8 d**
**16 e**
```

在这种情况下，Python 也提供了更好的解决方案。您可以应用 zip 并获取相应项目的元组:

```
**>>> for item in zip(x, y):**
**...     print(item)**
**...** 
**(1, 'a')**
**(2, 'b')**
**(4, 'c')**
**(8, 'd')**
**(16, 'e')**
```

您可以将它与拆包结合起来:

```
**>>> for x_item, y_item in zip(x, y):**
**...     print(x_item, y_item)**
**...** 
**1 a**
**2 b**
**4 c**
**8 d**
**16 e**
```

请记住，范围是非常有用的。然而，在某些情况下(如上图所示),有更方便的选择。迭代一个字典产生它的键:

```
**>>> z = {'a': 0, 'b': 1}**
**>>> for k in z:**
**... print(k, z[k])**
**...** 
**a 0**
**b 1**
```

但是，您可以应用方法。items()并获取带有键和相应值的元组:

```
**>>> for k, v in z.items():**
**...     print(k, v)**
**...** 
**a 0**
**b 1**
```

您也可以使用这些方法。按键()和。values()来分别迭代键和值。

# 与零比较

当您有数字数据，并且您需要检查数字是否等于零时，您可以但不是必须使用比较运算符==和！=:

```
**>>> x = (1, 2, 0, 3, 0, 4)**
**>>> for item in x:**
**...     if item != 0:**
**...         print(item)**
**...** 
**1**
**2**
**3**
**4**
```

Pythonic 式的方法是利用这样一个事实:在布尔上下文中，零被解释为假，而所有其他数字都被认为是真:

```
**>>> bool(0)**
**False**
**>>> bool(-1), bool(1), bool(20), bool(28.4)**
**(True, True, True, True)**
```

记住这一点，你可以只使用如果项目，而不是如果项目！= 0:

```
**>>> for item in x:**
**...     if item:**
**...         print(item)**
**...** 
**1**
**2**
**3**
**4**
```

您可以遵循相同的逻辑，使用 if not item 代替 if item == 0。

# 避免可变的可选参数

Python 有一个非常灵活的为函数和方法提供参数的系统。可选参数是该选项的一部分。但是要小心:你通常不想使用可变的可选参数。考虑下面的例子:

```
**>>> def f(value, seq=[]):**
**...     seq.append(value)**
**...     return seq**
```

乍一看是这样的，如果不提供 seq，f()会在一个空列表中追加一个值，并返回类似于[value]的内容:

```
**>>> f(value=2)**
**[2]**
```

看起来不错，对吧？不要！考虑下面的例子:

```
**>>> f(value=4)**
**[2, 4]**
**>>> f(value=8)**
**[2, 4, 8]**
**>>> f(value=16)**
**[2, 4, 8, 16]**
```

惊讶吗？迷茫？如果你是，你不是唯一一个。
似乎每次调用函数时，可选参数(本例中为 list)的实例都是相同的。也许有时你会想要上面的代码做什么。然而，更有可能的是，您需要避免这种情况。你可以用一些额外的逻辑来避免这种情况。其中一个方法是这样的:

```
**>>> def f(value, seq=None):**
**...     if seq is None:**
**...         seq = []**
**...     seq.append(value)**
**...     return seq**
```

更简短的版本是:

```
**>>> def f(value, seq=None):**
**...     if not seq:**
**...         seq = []**
**...     seq.append(value)**
**...     return seq**
```

现在，你会得到不同的行为:

```
**>>> f(value=2)**
**[2]**
**>>> f(value=4)**
**[4]**
**>>> f(value=8)**
**[8]**
**>>> f(value=16)**
**[16]**
```

在大多数情况下，这是一个人想要的。

# 避免传统的 Getters 和 Setters

Python 允许像 C++和 Java 一样定义 getter 和 setter 方法:

```
**>>> class C:**
**...     def get_x(self):**
**...         return self.__x**
**...     def set_x(self, value):**
**...         self.__x = value**
```

这就是如何使用它们来获取和设置对象的状态:

```
**>>> c = C()**
**>>> c.set_x(2)**
**>>> c.get_x()**
**2**
```

在某些情况下，这是完成工作的最佳方式。然而，定义和使用属性通常更优雅，尤其是在简单的情况下:

```
**>>> class C:**
**...     @property**
**...     def x(self):**
**...         return self.__x**
**...     @x.setter**
**...     def x(self, value):**
**...         self.__x = value**
```

属性被认为比传统的 getters 和 setters 更具 Pythonic 风格。您可以像在 C#中一样使用它们，也就是说，与普通数据属性一样:

```
**>>> c = C()**
**>>> c.x = 2**
**>>> c.x**
**2**
```

所以，一般来说，尽可能使用属性，在必要时使用类似 C++的 getters 和 setters 是一个好习惯。

# 避免访问受保护的类成员

Python 没有真正的私有类成员。然而，有一个约定是，你不应该在成员实例之外访问或修改以下划线(_)开头的成员。它们不能保证保留现有的行为。

例如，考虑代码:

```
**>>> class C:**
**...     def __init__(self, *args):**
**...         self.x, self._y, self.__z = args**
**...** 
**>>> c = C(1, 2, 4)**
```

C 类的实例有三个数据成员:。x，。_y，还有。_C__z。如果一个成员的名字以双下划线(dunder)开头，它会被修改。这就是为什么你有？_C__z 而不是。__z.
现在访问或者修改都挺 OK 的。直接 x:

```
**>>> c.x  # OK**
**1**
```

您还可以访问或修改。_y，但这被认为是一种不好的做法:

```
**>>> c._y  # Possible, but a bad practice!**
**2**
```

你不能进入。__z，因为它已经损坏，但您可以访问或修改。_C__z:

```
**>>> c.__z # Error!**
**Traceback (most recent call last):**
**File "", line 1, in** 
**AttributeError: 'C' object has no attribute '__z'**
**>>> c._C__z # Possible, but even worse!**
**4**
**>>>**
```

你应该避免这样做。该类的作者可能会以下划线开头来告诉您“不要使用它”。

# 使用上下文管理器释放资源

有时需要编写代码来正确管理资源。在处理文件、数据库连接或其他具有非托管资源的实体时，经常会出现这种情况。例如，您可以打开并处理一个文件:

```
**>>> my_file = open('filename.csv', 'w')**
**>>> # do something with `my_file`**
```

要正确管理内存，您需要在完成作业后关闭该文件:

```
**>>> my_file = open('filename.csv', 'w')
>>> # do something with `my_file and`
>>> my_file.close()**
```

这样做总比不做好。但是，如果在处理您的文件时出现异常，该怎么办呢？那么 my_file.close()永远不会执行。您可以使用异常处理语法或上下文管理器来处理这个问题。第二种方法是将代码放在带有块的中:

```
**>>> with open('filename.csv', 'w') as my_file:**
**...     # do something with `my_file`**
```

使用 with 块意味着特殊方法。__ 输入 _ _()和。__exit__()被调用，即使在异常情况下也是如此。这些方法应该照顾到资源。通过结合上下文管理器和异常处理，您可以实现特别健壮的结构。

# 风格建议

Python 代码应该优雅、简洁、易读。应该很美。

关于如何编写漂亮的 Python 代码的终极资源是 Python 代码的**风格指南**或 **PEP 8** 。如果你想用 Python 编码，你绝对应该读一读。

# 结论

本文就如何编写更高效、更易读、更简洁的代码给出了几个建议。简而言之，它展示了如何编写 Pythonic 代码。另外，PEP 8 提供了 Python 代码的风格指南，PEP 20 代表了 Python 语言的原理。

享受编写 Pythonic 式的、有用的、漂亮的代码吧！

![](img/2bebe9fe48fb99c5d1c4456e97533030.png)

[Duomly — Programming Online Courses](https://www.duomly.com)

感谢您的阅读。

这篇文章是我们的队友米尔科准备的。