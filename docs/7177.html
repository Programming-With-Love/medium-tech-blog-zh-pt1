<html>
<head>
<title>Android leak pattern: subscriptions in views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android泄漏模式:视图中的订阅</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/android-leak-pattern-subscriptions-in-views-18f0860aa74c?source=collection_archive---------0-----------------------#2016-09-20">https://medium.com/square-corner-blog/android-leak-pattern-subscriptions-in-views-18f0860aa74c?source=collection_archive---------0-----------------------#2016-09-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="2957" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="eac3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">在Square Register Android中，我们依靠自定义视图来构建我们的应用程序。有时一个视图会监听一个比该视图寿命更长的对象的变化。</p><p id="6163" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">例如，HeaderView可能想要侦听来自验证者单例的用户名更改:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="0514" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">onFinishInflate()是一个很好的地方，可以让一个膨胀的定制视图找到它的子视图，所以我们这样做，然后我们订阅用户名更改。</p><p id="60bf" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">上面的代码有一个<strong class="is hi">重大bug </strong>:我们<strong class="is hi">从来不退订</strong>。当视图消失时，Action1保持订阅状态。因为Action1是一个匿名类，所以它保留了对外部类HeaderView的引用。<strong class="is hi">整个视图层次现在正在泄漏</strong>，并且不能被垃圾收集。</p><p id="47a7" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">为了修复这个bug，让我们在视图<strong class="is hi">与窗口</strong>分离时取消订阅</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="7605" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">问题解决了吗？不完全是。我最近在看一份LeakCanary报告，它是由一段非常相似的代码引起的:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/aef9b5bd0d1c6c7d01a57c7560491ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TCdPuf8E7LyQinhT."/></div></div></figure><p id="5a5b" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">让我们再看一下代码:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="2d97" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">不知何故<strong class="is hi"> View.onDetachedFromWindow()没有被调用</strong>，这导致了泄漏。</p><p id="1664" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在调试的时候，我发现<strong class="is hi"> View.onAttachedToWindow()也没有被调用</strong>。如果一个视图从未被附加，显然它不会被分离。所以，<strong class="is hi">调用View.onFinishInflate()，而不是View.onAttachedToWindow() </strong>。</p><p id="a8f8" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">让我们进一步了解View.onAttachedToWindow():</p><ul class=""><li id="ad3b" class="kg kh hh is b it jn ix jo jb ki jf kj jj kk io kl km kn ko bi translated">当一个视图被添加到一个带有窗口的<strong class="is hi">父视图中时，onAttachedToWindow()被<strong class="is hi">立即从addView()中调用</strong>。</strong></li><li id="9ab4" class="kg kh hh is b it kp ix kq jb kr jf ks jj kt io kl km kn ko bi translated">当一个视图被添加到一个没有窗口的<strong class="is hi">父视图时，onAttachedToWindow()将被调用，当那个父视图被附加到一个窗口</strong>时。</li></ul><p id="3bee" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">我们正在以典型的Android方式扩大视图层次:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="faa5" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">此时，<strong class="is hi">视图层次结构中的每个视图都收到了View.onFinishInflate()回调</strong>，但没有收到View.onAttachedToWindow()回调。原因如下:</p><blockquote class="ie"><p id="a43a" class="if ig hh bd ih ii ku kv kw kx ky io dx translated"><strong class="ak"> View.onAttachedToWindow()在第一次视图遍历时被调用，在Activity.onStart()之后的某个时间</strong></p></blockquote><p id="89c9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated"><a class="ae ip" href="https://github.com/android/platform_frameworks_base/blob/76fdbb7/core/java/android/view/ViewRootImpl.java#L1516" rel="noopener ugc nofollow" target="_blank"> ViewRootImpl </a>是onAttachedToWindow()调用被调度的地方:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="f75f" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">很酷，所以我们不会依赖onCreate()，但是onStart()之后呢？那不总是在onCreate()之后调用吗？</p><p id="6d26" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">不总是！<a class="ae ip" href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">activity . oncreate()</a>javadoc给了我们答案:</p><blockquote class="kz la lb"><p id="7612" class="iq ir lc is b it jn iv iw ix jo iz ja ld jp jd je le jq jh ji lf jr jl jm io ha bi translated"><em class="hh">您可以从这个函数中调用finish()，在这种情况下，onDestroy()将立即被调用</em> <strong class="is hi"> <em class="hh">，而不会执行任何剩余的活动生命周期</em> </strong> <em class="hh"> (onStart()、onResume()、onPause()等)。</em></p></blockquote><p id="2f78" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">找到了。</p><p id="3cb5" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">我们在onCreate()中验证活动意图，如果该意图的内容无效，则立即调用finish()并返回错误结果:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="32e7" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">视图层次是膨胀的，但从未附加到窗口，因此从未分离。</p><p id="5f9c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这是旧活动生命周期图的更新版本:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lg"><img src="../Images/24d011d6f54a2f703f6e0ff315701208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*B3c61EWVLnfb3ryd."/></div></figure><p id="bb96" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">有了这些知识，我们现在可以将订阅代码移动到onAttachedToWindow():</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="693e" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">无论如何，这是更好的:对称是好的，不像最初的实现，我们可以添加和删除视图任意次。</p></div></div>    
</body>
</html>