<html>
<head>
<title>Making a JS request with the Fetch API in Symfony 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Symfony 3中的Fetch API发出JS请求</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/making-a-js-request-with-the-fetch-api-in-symfony-3-21122a525f52?source=collection_archive---------3-----------------------#2017-11-27">https://medium.com/quick-code/making-a-js-request-with-the-fetch-api-in-symfony-3-21122a525f52?source=collection_archive---------3-----------------------#2017-11-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a1cdaf55c53f4d368a22de3482c60e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWkL4QRmHnvLiIoXPoU2qA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/OqtafYT5kTw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ilya Pavlov</a> on <a class="ae it" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8f58" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我正在做的一个学校项目中，我必须使用JavaScript的Fetch API在Symfony 3应用程序后端提供的一个文件中做一些AJAX请求。这不容易，但我赢了！</p><h1 id="8646" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">该项目</h1><p id="f503" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">首先，一点点的背景。在我受教育期间，我必须在两年内与6名学生(包括我)一起从零开始创建一个项目。我们可以自由选择主题，但必须在选定的陪审团面前通过一系列陈述来验证，以检查该项目是否有潜力导致创业。</p><p id="61c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的项目叫做<strong class="iw hi"> Playficient </strong>。多亏了统计数据，我们发现<strong class="iw hi">平均损失了40%的工作时间</strong>。其中一个主要原因是从一种工具切换到另一种工具。为了<strong class="iw hi">减少</strong>工作中使用的工具数量，做了很多软件和工具(用API同步，用“脸书登录”，用IFTTT，或者在Slack或者Github上创建WebHoks)。</p><p id="acfd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们想为小公司和非常小的公司创造一个类似的工具，这些公司与计算机有很强的联系。但是我们想更进一步，用游戏化的原则来激励员工，同时用人工智能的聪明建议让用户在日常工作过程中变得更好。为了让这个变得更复杂一点，我们希望这个项目是可定制的，有一个模块化的系统，就像Wordpress或Firefox中的插件一样(潜意识文本:去Firefox 57！)</p><p id="2e78" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">(链接到一个展示网站，如果你想看一看，不要犹豫，给我们一些反馈，这将是令人敬畏的，如此亲切！=D)</p><h1 id="fa6b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">嘿，你不是说了一篇技术文章吗？</h1><p id="123e" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">的确，的确，是我谈论它的时候了。为了轻松管理模块化系统，我们在PHP中使用了一个名为<a class="ae it" href="http://symfony.com" rel="noopener ugc nofollow" target="_blank"> Symfony 3 </a>的服务器端框架，它与<strong class="iw hi"> Bundles </strong>一起工作，目前有2个人在这个后端工作。前端部分由Symfony通过<strong class="iw hi">模板</strong>和<strong class="iw hi">资产</strong>进行管理:</p><ul class=""><li id="fa2f" class="kv kw hh iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">一个<strong class="iw hi">模板</strong>是一个带有<a class="ae it" href="https://twig.symfony.com/" rel="noopener ugc nofollow" target="_blank">分支</a>语法的HTML页面，它是可重用的，并且可以通过变量替换和一些其他特性如循环和条件来定制。</li><li id="bcff" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">一个<strong class="iw hi">资产</strong>是一个为模板提供内容的文件，比如JavaScript代码、图像、CSS等等。</li></ul><p id="e80e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我们使用一个模板来创建<strong class="iw hi">可重用的</strong>页面，或者创建一个<strong class="iw hi">特定的</strong>页面到一个<a class="ae it" href="https://symfony.com/doc/current/routing.html" rel="noopener ugc nofollow" target="_blank">路由</a>。但是除了<strong class="iw hi"> HTML代码</strong>和<strong class="iw hi"> Twig </strong>标签，我们在模板中找不到任何东西(如果你写了难看的代码，也找不到其他代码)。所以我们如果想写JavaScript代码，其实并不在乎模板。</p><p id="f957" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一方面，资产要有趣得多，因为多亏了它们，我们才能够为客户端提供JavaScript文件。但是这里我们有一个问题:我们<strong class="iw hi">没有</strong>从模板中分支语法来使用<strong class="iw hi"> JavaScript </strong>中的服务器端变量。</p><p id="092d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们需要获取一个<strong class="iw hi">路径的URL </strong>时，这就成问题了。</p><h1 id="9a5d" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">FOSJSBundle来救我们了</h1><p id="c786" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">如我所说，Symfony使用捆绑包，就像JavaScript中的npm包或Ruby中的Gems一样。这些包被用作一个项目的依赖项，由于巨大的Symfony社区，我们可以找到数百个已经存在的包。</p><p id="a713" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">FOSJSBundle 是一个包，它给了我们一个JavaScript库，叫做<code class="du lj lk ll lm b">Routing</code>来获取一条路线的URL。</p><p id="c26d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是它的使用方法:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="2486" class="lv jt hh lm b fi lw lx l ly lz">const url = Routing.generate('route_name', {your parameters}, absoluteUrlBool);</span></pre><p id="9f01" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个函数返回<strong class="iw hi">对应于第一个参数中给出的路径的URL </strong>，这正是我们所需要的！</p><p id="a9c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们需要创建所谓的AJAX请求。让我们看一个用例(随机地，我今天正在做的)。我们是用户X，<strong class="iw hi">连接</strong>到Playficient并拥有<strong class="iw hi">任务管理器</strong>模块。在这里我们有一个盒子列表，每个盒子都是一个<strong class="iw hi">任务</strong>，可以包含任意数量的<strong class="iw hi">子任务</strong>。我们想做一些子任务的“拖放”来改变它所属的盒子。我们这样做，我们需要告诉服务器，我们希望<strong class="iw hi">将</strong>任务从其先前的位置移除，而<strong class="iw hi">将</strong>任务添加到其新的位置。</p><p id="22b0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，我们使用som JavaScript并创建一个<strong class="iw hi"> AJAX </strong>请求。有多种方法可以解决这个问题，最新的方法是使用<a class="ae it" href="https://developer.mozilla.org/fr/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">获取API </a>。Fetch API使用两个对象和一个方法:</p><ul class=""><li id="da77" class="kv kw hh iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated"><a class="ae it" href="https://developer.mozilla.org/fr/docs/Web/API/Request" rel="noopener ugc nofollow" target="_blank">请求</a>:是定义请求的对象(简单吧？).我们在其中定义了URL、参数、方法等。</li><li id="850a" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><a class="ae it" href="https://developer.mozilla.org/fr/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">响应</a>:这个对象定义了服务器的响应。当一个获取承诺被解决时，我们得到这个对象。</li><li id="6f65" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><a class="ae it" href="https://developer.mozilla.org/fr/docs/Web/API/GlobalFetch/fetch" rel="noopener ugc nofollow" target="_blank"> fetch() </a>:该方法将请求作为第一个参数。这个方法返回一个解析响应对象的<a class="ae it" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>。</li></ul><p id="454b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在您对它有了更多的了解，让我们来看一下与从原来的盒子中删除子任务的请求相对应的代码:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="3952" class="lv jt hh lm b fi lw lx l ly lz">const url = Routing.generate('rask_remove', {<br/>  taskId: 1,<br/>  parentId: 2,`<br/>});<br/>const request = new Request(url, { method: 'GET' });</span><span id="4516" class="lv jt hh lm b fi ma lx l ly lz">fetch(request)<br/>  .then(reponse =&gt; {<br/>    console.log('We removed this task!');<br/>  })<br/>  .catch(error =&gt; {<br/>    console.error(`Error when removing: ${error}`);<br/>  });</span></pre><p id="0fd1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好了，东西都齐了吗？让我们运行服务器并进行操作…下面是Firefox的控制台给我们提供的内容:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="daf4" class="lv jt hh lm b fi lw lx l ly lz">GET   http://localhost/task/2/1/remove        302 Found<br/>GET   http://localhost/login                  200 Ok<br/>'We removed this taks!'</span></pre><p id="8b82" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们重新加载页面时……任务<strong class="iw hi">仍然在这里！</strong></p><p id="ef69" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很快，我们可以看到有两个请求<strong class="iw hi">完成了:一个是删除任务，另一个是登录页面…这很奇怪。我不会再让悬念持续下去了，也不会解释为什么会这样。</strong></p><p id="0e02" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们仍然是用户X(不是教授),并且已经连接，服务器需要在<strong class="iw hi">中知道我们正在做这个请求的</strong>的名字。这就是为什么在Symfony中使用<a class="ae it" href="https://en.wikipedia.org/wiki/HTTP_cookie" rel="noopener ugc nofollow" target="_blank"> cookies </a>的原因。从一个页面到另一个页面，用户带着这个cookies<strong class="iw hi">到处走，这个cookies </strong>允许他/她保持连接，直到他/她点击“注销”。</p><p id="b017" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们在请求中需要做的是<strong class="iw hi">获取这个cookie </strong>并发送它，但是如何做呢？事实上，这对于Fetch API和Symfony来说非常简单，因为这是一个简单的参数<strong class="iw hi">放入Fetch方法</strong>，以发送“凭证”:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="8d5a" class="lv jt hh lm b fi lw lx l ly lz">fetch(request, { credentials: 'same-origin' })</span></pre><p id="9497" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们再次运行我们的代码:</p><pre class="ln lo lp lq fd lr lm ls lt aw lu bi"><span id="5cb0" class="lv jt hh lm b fi lw lx l ly lz">GET   http://localhost/task/2/1/remove      200 OK<br/>'We removed this task!'</span></pre><p id="15a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的要求来了！</p><p id="6a3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用JavaScript和Symfony的Fetch API，做所有这些事情是相当容易的，但前提是我们知道如何做。(我花了3天时间寻找如何从Symfony获得JavaScript中的路线，并理解这个凭证错误，尽管它实际上很简单！)</p><p id="4ff8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你愿意，这篇文章也有法语版本。我打算利用我在魁北克的逗留时间和我的毕业设计写更多关于技术学生的文章。顺便说一下，我正在开发一个来自<a class="ae it" href="https://coralproject.net/" rel="noopener ugc nofollow" target="_blank"> CoralProject </a>的<a class="ae it" href="https://coralproject.net/products/talk.html" rel="noopener ugc nofollow" target="_blank"> Talk </a>插件，当这个插件完成时，我可能会写一些关于它的东西；)</p><p id="62a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在那之前，祝大家愉快！</p><p id="e826" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mb">本文首发于</em><a class="ae it" href="https://ilphrin.com" rel="noopener ugc nofollow" target="_blank"><em class="mb">【https://ilphrin.com】</em></a><em class="mb"><br/>如果你喜欢，请拍手告诉我你是否喜欢那种文章；)</em></p></div></div>    
</body>
</html>