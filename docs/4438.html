<html>
<head>
<title>KSP for Code-Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码生成的KSP</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/ksp-for-code-generation-dfd2073a6635?source=collection_archive---------0-----------------------#2022-08-22">https://medium.com/google-developer-experts/ksp-for-code-generation-dfd2073a6635?source=collection_archive---------0-----------------------#2022-08-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fb5e4284b362c2026fbdfe9c01e0cb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmbJXSVFug8vwdpopXgtDw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@birminghammuseumstrust?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Birmingham Museums Trust</a> on <a class="ae it" href="https://unsplash.com/s/photos/assembly-line?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="141d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为一名开发人员，我们每天所做的就是编写代码。不仅仅是无意识地写，我们都希望我们能写出没有缺陷的代码。为此，有很多工具可以帮助我们提高质量，比如单元测试和静态分析。但是，没有人能保证他们的代码没有任何错误。</p><p id="f8ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">人为错误似乎是不可避免的，这就是为什么我们可能希望利用代码生成工具来帮助我们编写更少的代码。这不仅会减少我们花费的时间，还会提高代码质量。如果您熟悉Java，您可能以前听说过注释处理，如果您是Kotlin开发人员，现在您已经有了KSP。</p><h1 id="38c0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">KSP</h1><p id="657f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">KSP代表科特林符号处理。顾名思义，它不仅仅是一个代码生成工具，还是一个编译器插件API，可以帮助你在编译时获得完整的源代码信息。你可以做任何事情，比如生成更多的代码，分析结构，甚至抛出一个额外的错误来中断构建，代码生成无疑是一个非常强大的用例，我们今天将主要关注这个主题。</p><h2 id="4a1b" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">代码生成</h2><p id="e261" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">通常，我们将创建一个单独的处理器模块，其中包含一些在编译时会被触发的处理器。每个处理器可以读取主应用程序源代码信息以生成代码，生成的代码将与您的源代码一起编译以形成最终输出。</p><p id="b93b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用预定义的注释是一种常见的技巧。处理器模块和您的应用程序模块都依赖于同一个注释模块，处理器模块可以很容易地通过这些注释过滤来自应用程序模块的信息，但这完全取决于您的偏好。</p><p id="532d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一节中，我将结合详细的分步介绍和一个简单的用例来展示KSP可以为我们做些什么。</p><h1 id="9b99" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">例子</h1><p id="ef98" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">比方说，我们喜欢构建一些工厂模式，如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bafa" class="kv jt hh lo b fi ls lt l lu lv">public enum class AnimalType {<br/>    CAT,<br/>    DOG,<br/>}<br/><br/>public fun AnimalFactory(key: AnimalType): Animal = when (key) {<br/>    AnimalType.CAT -&gt; Cat()<br/>    AnimalType.DOG -&gt; Dog()<br/>}</span><span id="4fd3" class="kv jt hh lo b fi lw lt l lu lv">interface Animal</span><span id="8870" class="kv jt hh lo b fi lw lt l lu lv">class Dog : Animal</span><span id="bb15" class="kv jt hh lo b fi lw lt l lu lv">class Cat : Animal</span></pre><p id="cb3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们调用<code class="du lx ly lz lo b">AnimalFactory(AnimalType.CAT)</code>时，我们希望得到一个<code class="du lx ly lz lo b">Cat</code>实例——而不是担心如何创建它。这种模式很漂亮，但是不可扩展，正如你所看到的，每当我们想要添加一个新的类型，我们需要一次又一次地修改同一个函数。我们能做些什么来使它变得更好？</p><p id="06c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最重要的部分是定义那些动物类和接口，其余的似乎只是遵循一些规则。让我们致力于通过KSP自动构建<code class="du lx ly lz lo b">AnimalType</code>和<code class="du lx ly lz lo b">AnimalFactory</code>，这样我们就不用再写样板代码了。</p><h2 id="8176" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">更新项目级配置</h2><p id="14e1" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">首先，更新你的根目录<code class="du lx ly lz lo b">build.gradle</code>来启用KSP特性，如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="da3f" class="kv jt hh lo b fi ls lt l lu lv">plugins {<br/>    id 'org.jetbrains.kotlin.jvm' version '1.7.10' apply false <br/>    id 'com.google.devtools.ksp' version '1.7.10-1.0.6' apply false<br/>}  </span><span id="98ec" class="kv jt hh lo b fi lw lt l lu lv">buildscript {<br/>    dependencies {<br/>        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.10'     <br/>    } <br/>}</span></pre><blockquote class="ma mb mc"><p id="db4a" class="iu iv md iw b ix iy iz ja jb jc jd je me jg jh ji mf jk jl jm mg jo jp jq jr ha bi translated">这里可以找到KSP版本:<a class="ae it" href="https://github.com/google/ksp/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/google/ksp/releases</a></p></blockquote><h2 id="fe59" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">注释模块</h2><p id="e854" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们将首先在一个新模块中为应用程序和处理器模块定义注释，以便在它们之间传递元数据。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="eced" class="kv jt hh lo b fi ls lt l lu lv">@Target(AnnotationTarget.CLASS)<br/>@Retention(AnnotationRetention.SOURCE)<br/>annotation class AutoElement</span><span id="e646" class="kv jt hh lo b fi lw lt l lu lv">@Target(AnnotationTarget.CLASS)<br/>@Retention(AnnotationRetention.SOURCE)<br/>annotation class AutoFactory</span></pre><p id="cd61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们假设<code class="du lx ly lz lo b">AutoElement</code>将添加到具体类中，而<code class="du lx ly lz lo b">AutoFactory</code>用于声明返回类型。稍后，我们将依靠这个契约来过滤构建图表所需的信息。</p><blockquote class="ma mb mc"><p id="e491" class="iu iv md iw b ix iy iz ja jb jc jd je me jg jh ji mf jk jl jm mg jo jp jq jr ha bi translated">这里您可以看到注释类本身也有两个合格的注释。<code class="du lx ly lz lo b">@Target</code>用来限制它可以使用的地方。假设我们只想在类或接口上标记它，我们选择<code class="du lx ly lz lo b">CLASS</code>。<code class="du lx ly lz lo b">@Retention</code>用于声明注释的生命周期，对于KSP用例，我们在编译后不再需要它，所以我们将其设置为<code class="du lx ly lz lo b">SOURCE</code>。</p></blockquote><h2 id="ec9b" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">处理器组件</h2><p id="c2d8" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">这是所有奇迹发生的地方！我们将很快创建处理器来自动生成代码。在此之前，我们需要像下面这样声明KSP依赖关系<code class="du lx ly lz lo b">build.gradle</code>:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8ac0" class="kv jt hh lo b fi ls lt l lu lv">plugins {<br/>    id 'org.jetbrains.kotlin.jvm'<br/>}<br/><br/>dependencies {<br/>    implementation project(":annotation")<br/>    implementation 'com.google.devtools.ksp:symbol-processing-api:1.7.10-1.0.6'<br/>}</span></pre><p id="bcb2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个处理器模块可能有几个处理器，这里是所有处理器都应该实现的基本<code class="du lx ly lz lo b">SymbolProcessor</code>接口。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1e79" class="kv jt hh lo b fi ls lt l lu lv">interface SymbolProcessor {<br/>     fun process(resolver: Resolver): List&lt;KSAnnotated&gt; //main logic<br/>     fun finish() {}<br/>     fun onError() {} <br/>}</span></pre><p id="9184" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">process函数是解析代码的入口点，而<code class="du lx ly lz lo b">Resolver</code>是帮助我们获取代码符号的对象。我们可以构建一个如下所示的助手函数:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8c0f" class="kv jt hh lo b fi ls lt l lu lv">fun Resolver.<em class="md">getSymbols</em>(cls: KClass&lt;*&gt;) =<br/>    this.getSymbolsWithAnnotation(cls.qualifiedName.<em class="md">orEmpty</em>())<br/>        .<em class="md">filterIsInstance</em>&lt;KSClassDeclaration&gt;()<br/>        .<em class="md">filter</em>(KSNode::validate)</span></pre><p id="7546" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lx ly lz lo b">KSClassDeclaration</code>在源代码中表示为一个类或接口符号，<code class="du lx ly lz lo b">Resolver.getSymbolsWithAnnotation</code>是一个函数，它返回每一个具有目标注释的符号。</p><p id="3787" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们简化这个问题，假设我们只需要生成一个工厂。我们可以用我们的注释得到所有的符号，如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5393" class="kv jt hh lo b fi ls lt l lu lv">val factory = resolver.<em class="md">getSymbols</em>(AutoFactory::class).firstOrNull()<br/>val elements = resolver.<em class="md">getSymbols</em>(AutoElement::class).<em class="md">toList</em>()</span></pre><blockquote class="ma mb mc"><p id="3614" class="iu iv md iw b ix iy iz ja jb jc jd je me jg jh ji mf jk jl jm mg jo jp jq jr ha bi translated">如果您对完整的实现感兴趣，请随意查看这里的<a class="ae it" href="https://github.com/Jintin/KFactory" rel="noopener ugc nofollow" target="_blank"/>！</p></blockquote><h2 id="2563" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">科特林诗人</h2><p id="d754" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在是时候将图形写入文件了。我们可以利用Square开发的一个很棒的工具——kotlin poet。科特林诗人也与KSP有很大的融合。只需首先添加依赖关系:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ef91" class="kv jt hh lo b fi ls lt l lu lv">dependencies {<strong class="lo hi"><br/></strong>    implementation 'com.squareup:kotlinpoet:1.11.0'<br/>    implementation 'com.squareup:kotlinpoet-ksp:1.12.0'<br/>}</span></pre><p id="ad1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后创建一个函数来生成文件，如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7845" class="kv jt hh lo b fi ls lt l lu lv">private fun genFile(key: ClassName, list: List&lt;ClassName&gt;): FileSpec {<br/>    val packageName = key.packageName<br/>    val funcName = key.simpleName + "Factory"<br/>    val enumName = key.simpleName + "Type"<br/><br/>    return FileSpec.builder(packageName, funcName)<br/>        .addType(TypeSpec.enumBuilder(enumName)<br/>            .<em class="md">apply </em>{<br/>                list.<em class="md">forEach </em>{<br/>                    addEnumConstant(it.simpleName.<em class="md">uppercase</em>())<br/>                }<br/>            }<br/>            .build())<br/>        .addFunction(FunSpec.builder(funcName)<br/>            .addParameter("key", ClassName(packageName, enumName))<br/>            .returns(key)<br/>            .beginControlFlow("return when (key)")<br/>            .<em class="md">apply </em>{<br/>                list.<em class="md">forEach </em>{<br/>                    addStatement("${enumName}.${it.simpleName.<em class="md">uppercase</em>()} -&gt; %T()", it)<br/>                }<br/>            }<br/>            .endControlFlow()<br/>            .build())<br/>        .build()<br/>}</span></pre><p id="0732" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它有点长，但相当具有声明性，你可以看出KotlinPoet提供了一种比<code class="du lx ly lz lo b">StringBuilder</code>或其他手工作品更系统的方式来生成Kotlin代码。</p><p id="1c25" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">生成<code class="du lx ly lz lo b">FileSpec</code>后，我们可以完成<code class="du lx ly lz lo b">process</code>函数中的整个流程，如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a08d" class="kv jt hh lo b fi ls lt l lu lv">override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {<br/>    val factory = ...<br/>    if (factory != null) {<br/>        val elements = ...<br/>        genFile(<br/>            factory.<em class="md">toClassName</em>(),<br/>            elements.<em class="md">map</em>(KSClassDeclaration::toClassName)<br/>        ).<em class="md">writeTo</em>(codeGenerator, Dependencies(true))<br/>    }<br/>    return <em class="md">emptyList</em>()<br/>}</span></pre></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><p id="7eac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">似乎很棒，但是编译器怎么知道处理器在哪里呢？处理器是由提供商创建的，下面是定义</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8f95" class="kv jt hh lo b fi ls lt l lu lv">fun interface SymbolProcessorProvider {<em class="md"><br/>    </em>fun create(env: SymbolProcessorEnvironment): SymbolProcessor<br/>}</span></pre><p id="cf1d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们可以在如下所示的提供程序中创建我们的处理器:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="89d1" class="kv jt hh lo b fi ls lt l lu lv">fun create(environment: SymbolProcessorEnvironment) =<br/>    BuilderProcessor(<br/>        environment.codeGenerator,<br/>        environment.logger<br/>    )</span></pre><p id="9d61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但仅此而已吗？编译器仍然不知道提供者在哪里。我们需要在一个名为<code class="du lx ly lz lo b">resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider</code>的文件中注册我们的提供者的全名，包括包名，以便编译器链接。</p><h2 id="abe4" class="kv jt hh bd ju kw kx ky jy kz la lb kc jf lc ld kg jj le lf kk jn lg lh ko li bi translated">应用模块</h2><p id="11cf" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们已经接近我们想要的了，现在我们可以在应用程序模块中使用处理器了。应用程序模块中的<code class="du lx ly lz lo b">build.gradle</code>文件如下所示:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="dca2" class="kv jt hh lo b fi ls lt l lu lv">plugins {<br/>    id 'com.google.devtools.ksp'<br/>}<br/><br/>sourceSets {<br/>    main {<br/>        java {<br/>            srcDir "${buildDir.absolutePath}/generated/ksp/"<br/>        }<br/>    }<br/>}</span><span id="9d42" class="kv jt hh lo b fi lw lt l lu lv">dependencies {<br/>    implementation project(":annotation")<br/>    ksp project(":processor")<br/>}</span></pre><p id="f640" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，应用KSP插件。并将注释和处理器模块声明为依赖关系。注意，对于处理器模块，我们需要使用<code class="du lx ly lz lo b">ksp</code>关键字。由于KSP目前对IDE来说相对较新，如果自动生成的文件已经创建，但是IDE不知道如何找到它们，就像<code class="du lx ly lz lo b">sourceSets</code>部分那样手动添加它。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2eaa" class="kv jt hh lo b fi ls lt l lu lv">@AutoFactory<br/>interface Animal</span><span id="1e90" class="kv jt hh lo b fi lw lt l lu lv">@AutoElement<br/>class Dog : Animal</span><span id="3bbd" class="kv jt hh lo b fi lw lt l lu lv">@AutoElement<br/>class Cat : Animal</span></pre><p id="e0d2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，将注释添加到目标类中，然后重新构建项目，等待KSP为您生成文件，就这样！！</p><h1 id="862b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">参考</h1><p id="57d2" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">【https://kotlinlang.org/docs/ksp-overview.html T4】</p><p id="0bdc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" rel="noopener" href="/@jintin/annotation-processing-in-java-3621cb05343a">https://medium . com/@ jintin/annotation-processing-in-Java-3621 CB 05343 a</a></p><div class="mo mp ez fb mq mr"><a href="https://github.com/Jintin/KFactory" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hi fi z dy mw ea eb mx ed ef hg bi translated">GitHub-Jintin/KFactory:KFactory是一个构建简单工厂模式的库，很容易利用…</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">KFactory是一个通过ksp(Kotlin符号处理)自动生成简单工厂类的库…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf in mr"/></div></div></a></div></div></div>    
</body>
</html>