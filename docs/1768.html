<html>
<head>
<title>Guardrails for AWS Event-Driven Serverless Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS事件驱动的无服务器架构的护栏</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/guardrails-for-aws-event-driven-serverless-architectures-f9bc12ad689f?source=collection_archive---------1-----------------------#2020-11-18">https://medium.com/capital-one-tech/guardrails-for-aws-event-driven-serverless-architectures-f9bc12ad689f?source=collection_archive---------1-----------------------#2020-11-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c736" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak"> 9种高效处理的最佳实践&amp;通过AWS SNS、SQS、EventBridge、&amp; Lambdas </strong>实现成本优化</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/eb62fff6e9e1e789573b9ce93eb85dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*feZoGC1JaZ4QanXo.png"/></div></div></figure><p id="ae5c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">事件驱动架构是一种强大的架构风格，它促进了系统之间的解耦、更好的故障隔离、独立伸缩以及独立开发和发布。无服务器体系结构是一种体系结构风格，其优点是不必担心服务器供应或维护，并且具有自动扩展、高容错性和按使用付费。AWS将这两种架构风格与无服务器计算<a class="ae ke" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank">λ</a>和消息解决方案<em class="kf"> AWS简单队列服务(</em> <a class="ae ke" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> SQS </em> </a> <em class="kf">)、AWS简单通知服务(</em><a class="ae ke" href="https://aws.amazon.com/sns/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc" rel="noopener ugc nofollow" target="_blank"><em class="kf">SNS</em></a><em class="kf">)以及AWS</em><a class="ae ke" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank"><em class="kf">event bridge</em></a><em class="kf">结合在一起。</em></p><p id="34e5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在本文中，我们将探讨工程师在大规模使用事件驱动的无服务器架构时面临的一些挑战，以及如何使用上述AWS服务的一些最佳实践来应对这些挑战。让我们直接进入那些最佳实践。</p><h1 id="9237" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">1.减轻事件消费者及其依赖关系的压力</h1><p id="5047" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">在事件驱动的无服务器架构风格中，其中一个防护就是确保消费者能够顺利处理事件，同时保持成本在可控范围内。</p><h2 id="1f37" class="ld kh hh bd ki le lf lg km lh li lj kq jr lk ll ks jv lm ln ku jz lo lp kw lq bi translated"><strong class="ak">消费者处理每个事件所需时间的因素</strong></h2><p id="6f1b" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">假设您有一个Lambda函数，它是SNS主题的订阅者，并且Lambda函数需要相当长的时间来处理每个事件。<strong class="jk hi"> <em class="kf">例如:</em> </strong> <em class="kf">它需要进行一个外部API调用，这个调用对请求的响应速度慢得要命。</em></p><p id="6e45" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，如果您使用SNS向Lambda广播消息，并且有大量消息，这可能会导致同时运行多个Lambda函数。这将降低成本效率，并可能达到最大并发Lambda调用的限制。此外，由于这些限制是在帐户级别，这可能会导致同一帐户上的其他应用程序出现容量问题。</p><p id="010b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里合适的方法是预先限制流量。您可以使用SQS作为SNS的目的地，其中SQS队列可用于保存消息，直到消费者准备好处理它们，如下图所示。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lr"><img src="../Images/051c3d1841232a7261613bd5b10e1513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/0*rIl9GN8SDk9PPlVI"/></div><figcaption class="ls lt et er es lu lv bd b be z dx"><a class="ae ke" href="https://event-driven-architecture.workshop.aws/4-sns/2-filtering/message-filtering.html" rel="noopener ugc nofollow" target="_blank">SNS distributes events to SQS</a></figcaption></figure><h2 id="e763" class="ld kh hh bd ki le lf lg km lh li lj kq jr lk ll ks jv lm ln ku jz lo lp kw lq bi translated">考虑事件消费者的伸缩限制及其依赖性</h2><p id="b92b" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">这与上面的场景略有不同。假设您有一个Lambda函数，它将使用来自SNS主题的消息，并在一个<a class="ae ke" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> AWS RDS </a>数据库上执行一些操作，或者调用一个扩展性不好的API。如果SNS主题有突发消息，即使Lambda可以扩展到并发限制集，下游依赖项也可能无法处理它。<strong class="jk hi"> <em class="kf">例如:</em> </strong> <em class="kf">可能会达到RDS最大连接数限制，否则无法很好扩展的下游API可能会崩溃。通过Lambda重试，它可能会自我修复，或者我们可能会使它变得更糟，从而导致消息发送到DLQ(也就是说，如果您已经为您的Lambda配置了DLQ)。</em></p><p id="d740" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与上面类似，利用SQS作为SNS的目的地，然后让Lambda函数在它准备好的时候使用它。</p><h1 id="00ef" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">2.使用社交网络消息过滤功能</h1><p id="6556" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">可以利用这种事件驱动的无服务器最佳实践，在噪音到达事件消费者之前预先过滤噪音，从而节省成本。</p><p id="91ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当订阅SNS主题时，消费者可以在他们的订阅<a class="ae ke" href="https://docs.aws.amazon.com/sns/latest/dg/sns-subscription-filter-policies.html" rel="noopener ugc nofollow" target="_blank">过滤策略</a>中指定额外的过滤标准，即“仅向我发送符合特定标准的消息”过滤策略是一个包含过滤条件的JSON对象。发布到SNS主题的消息由一个消息属性元素组成，该元素可以托管关于消息的附加元数据。发布者可以填充该元素，SNS负责根据订阅过滤策略过滤消息，只将符合正确标准的消息发送给消费者。这样，消费者就不需要被每一条信息所困扰，从而节省了成本和处理过程。</p><p id="bb9d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，在上图中，消息被发布到Orders SNS主题，订阅该主题的每个SQS队列都列出了一个过滤策略。SNS使用这个过滤策略来过滤匹配的消息，并将其路由到各自的SQS队列。<strong class="jk hi"> <em class="kf">注:</em> </strong> <em class="kf">这在上图中用不同的颜色编码表示。红色消息被发送到订单队列，绿色消息被发送到订单-EU队列。</em></p><p id="4c70" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以下是过滤策略的一个示例:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/c97fa787b9e982a6e3d2ac4afe66af3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f_J9p_YwW5b68Rxp"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx"><a class="ae ke" href="https://event-driven-architecture.workshop.aws/4-sns/3-advanced-filtering/adv-message-filtering.html" rel="noopener ugc nofollow" target="_blank">Filter Policy</a></figcaption></figure><p id="b76e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">仅在符合逻辑的情况下使用过滤策略，即订户对相似类型的事件感兴趣，并且对该主题具有相似的访问权限要求。不要用它把不相关的事件推到一个单一的话题上，那样会使事情复杂化。</p><h1 id="98d4" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">3.考虑限制消耗事件的Lambda函数</h1><p id="24a2" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">这种技术符合成本优化和保护事件消费者的最佳实践，在有多个无服务器组件的企业环境中非常有用，这些组件可能由同一个AWS帐户下的不同团队拥有。</p><p id="a0ee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Lambda并发限制是在帐户级别，这意味着它由该AWS帐户下的所有Lambda函数共享。但是，您也可以预先配置一个函数级并发限制，称为<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a>。它可以确保其他功能不会占用您的预留配额。当您的函数订阅处理突发消息时，它还可以抑制Lambda函数调用。请记住，您的函数的并发调用不会超过这个设置，即使在未提供服务的并发中有空间。</p><p id="55c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这有助于减少下游依赖项(如数据库或其他API)的负载，并有助于控制成本。超出指定限制的对函数的额外请求将因节流错误而失败。关于不同类型错误的重试，请参考下面的第9点。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lx"><img src="../Images/00c3f33b981fc67f146a292d900fd981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4570nMUYOBTgqJ6W"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx"><a class="ae ke" href="https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/" rel="noopener ugc nofollow" target="_blank">Reserved Concurrency</a></figcaption></figure><h1 id="1803" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">4.考虑使用SQS的长轮询功能</h1><p id="d785" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">有了SQS，消费者可以使用<a class="ae ke" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html" rel="noopener ugc nofollow" target="_blank">短轮询或长轮询</a>从队列中接收消息。当消费者使用短轮询时，SQS立即从分发消息的服务器子集返回消息。这可能导致空响应或消息的子集没有返回给消费者。消费者被迫进行更多的扫描，以获取SQS上的完整信息。在下面的示例中，来自服务器的SQS消息A、C、D和B显示为灰色，并且没有返回消息e</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/11f3fcc941464d3b90cbb9865bc58a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dcetmjLkpXo8COqX"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx"><a class="ae ke" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html" rel="noopener ugc nofollow" target="_blank">Short Polling SQS</a></figcaption></figure><p id="4237" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">AWS定价随着队列中轮询的数量而增加。长轮询是一种在更长时间内(最长20秒)保持与队列连接的机制，当消息到达时，立即开始处理。这可以降低您的成本，因为它将减少轮询次数，从而减少空读取并从所有服务器获得完整的消息集。您可以对每个队列进行配置，它被称为<em class="kf">接收消息等待时间。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lx"><img src="../Images/13104df7dbfc3eec055fd1bae18a638e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-OwnXonPlo4eT7g9"/></div></div></figure><p id="cdf2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在AWS Lambda使用SQS触发器的情况下，Lambda轮询队列(使用长轮询)并与包含消息的事件同步调用函数。</p><h1 id="e33a" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">5.考虑将批量大小与λ和SQS一起使用</h1><p id="1e89" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">假设你有SQS作为Lambda的事件源——也就是说，你为你的Lambda函数配置了一个SQS触发器。在这种情况下，Lambda从SQS队列中读取消息，并同步调用您的函数。</p><p id="6a79" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你的Lambda函数代码做了一些普通的初始化工作——比如为它处理的每条消息丰富数据，或者它没有下游依赖的缓慢处理问题，等等。—一次批量提取消息可能更好。这有助于节省一些处理时间和成本。当您将SQS触发器设置为Lambda的事件源时，可以配置batchSize(最多10个)。您的函数超时应该考虑处理所有消息所花费的时间。</p><p id="99e4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当您的函数成功处理一个批处理时，Lambda会从队列中删除那些消息。但是，这里要注意错误处理。如果您在批处理中提取的消息之一无法处理，SQS队列中的整批消息将对其他使用者可见。在这里，您可以选择再次重新处理同一个批处理，或者在代码中安全地处理该异常，并将成功返回给从SQS拉取的Lambda服务(然后，您可以利用DLQs，在那里显式地发送失败的消息，或者在您的函数代码中自己负责显式地删除消息)。</p><p id="1570" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，对SQS FIFO队列使用<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html" rel="noopener ugc nofollow" target="_blank">批处理</a>操作会比不使用批处理提供更多的<a class="ae ke" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html" rel="noopener ugc nofollow" target="_blank">吞吐量</a>，因此每秒可以读取更多的消息。</p><h1 id="283d" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">6.在SQS设置正确的能见度超时</h1><p id="7738" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">SQS队列的可见性超时定义了一个时间段，在该时间段内，消息一旦被一个使用者获取，就保持对其他使用者隐藏。在可见性超时过期之前，获取该消息的使用者需要将其从队列中显式删除，这样其他使用者就看不到它了。</p><p id="5eb3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">定义一个可见性超时(如上图所示),该超时比应用程序处理队列中的消息所需的最大处理时间稍长。与您的应用程序处理时间相比，将这个<em class="kf">设置得太低</em>会导致其他消费者再次收到相同的消息，即使您的应用程序成功地处理了该消息。将这个<em class="kf">设置得太高</em>会导致其他消费者不能及时得到失败的消息。</p><h1 id="e2c7" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">7.当Lambdas是SQS的消费者时，设置正确的重试次数</h1><p id="a135" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">当Lambda从SQS队列中读取一批消息时，整批消息都是隐藏的，直到队列的可见性超时。当消息出现在SQS队列中时，Lambda最初会打开五个并行的长轮询连接来执行读取。如果队列中仍有可用的消息，它将<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-queueconfig" rel="noopener ugc nofollow" target="_blank">将读取消息的进程数量增加</a>到每分钟多60个实例，最多1000个批处理，可以并行处理。</p><p id="e0b6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所有同步读取批处理的Lambda进程都将尝试调用Lambda函数。但是，如果Lambda函数调用被抑制，会发生什么呢？因此，在可见性超时后，无法处理的消息将变得可用。</p><p id="8a13" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">AWS <a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html" rel="noopener ugc nofollow" target="_blank">建议</a>在队列的重新驱动策略中将maxReceiveCount至少设置为5，这样消息在发送到DLQ之前可以重试。此外，AWS建议将源队列的可见性超时设置为函数超时的至少六倍，以考虑到由于节流、Lambda冷启动时间等原因导致的重试。</p><h1 id="db33" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">8.了解Lambda的错误处理&amp;在哪里附加死信队列来捕获所有错误</h1><p id="1e49" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">Lambdas同步处理SQS消息，异步处理SNS消息。如果您有一个SNS主题的DLQ，并且Lambda是该主题的订阅者，则该DLQ将只包含在所有重试之后无法传递到Lambda服务的消息(由于权限或服务不可用)。它将不会包含成功传递到Lambda、被您的函数拾取、但由于一些其他代码或运行时问题而未成功处理的消息。它也不会包含导致Lambda函数无法调用的节流错误。</p><p id="fc6f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Lambda服务使用其内部队列来处理此类场景的重试。您可以配置重试次数、事件的最长时间以及向SQS、SNS、EventBridge、Lambda等发送失败消息的位置。</p><p id="c1c0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里看一下Lambda的<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html" rel="noopener ugc nofollow" target="_blank">的异步调用</a>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lz"><img src="../Images/4f71c3817754da232ad696ee0ef0abae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*08FREZpmV5UXd2t_"/></div><figcaption class="ls lt et er es lu lv bd b be z dx"><a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html" rel="noopener ugc nofollow" target="_blank">Lambda Asynchronous: Send failed messages to a new destination</a></figcaption></figure><p id="9c41" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">了解Lambda的不同类型的<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-retries.html" rel="noopener ugc nofollow" target="_blank">错误</a>。</p><h1 id="496b" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">9.知道何时使用AWS EventBridge</h1><p id="13ff" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">到目前为止，我们一直在谈论使用SQS和社交网络的最佳实践。然而，有些情况下它们并不是这项工作的最佳工具。最近，AWS推出了<a class="ae ke" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank"> Amazon EventBridge </a>作为另一个事件总线，具有区别于SQS或SNS的独特功能。EventBridge以前叫CloudWatch Events，主要是作为AWS资源状态变化事件<em class="kf">(例如:EC2实例终止)</em>或者预定事件<em class="kf">(例如:使用cron表达式触发一个Lambda) </em>的事件总线。</p><p id="038a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与SNS相比，AWS EventBridge支持更多的客户端作为事件源和目的地。它可以将事件传递给其他AWS帐户，这在一个组织中是一个非常有用的功能，在这个组织中，每个拥有不同帐户的不同团队可能希望订阅其他帐户中的事件。它提供的一个更棒的功能是，它可以从第三方SaaS应用程序接收事件并触发其目的地。<strong class="jk hi"> <em class="kf">示例:</em> </strong> <em class="kf">您可以配置EventBridge，将在PagerDuty中创建或更新的事件传递给Lambda函数，该函数可以创建事件日志。</em></p><p id="1811" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">EventBridge提供了许多更有用的功能，例如使用规则的事件路由，您可以根据事件的内容过滤消息(不像SNS，您必须依赖MessageAttributes，但有一些限制)。此外，您可以在将事件发送到目标之前对其进行转换。</p><p id="c6b4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，与SNS相比，目前在每个规则的目标数量、允许的吞吐量和延迟方面存在<a class="ae ke" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/cloudwatch-limits-eventbridge.html" rel="noopener ugc nofollow" target="_blank">限制</a>。这可能会在未来几年发生变化，因为这仍然是一项相当新的AWS服务。</p><p id="46e7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> *** </strong></p><p id="b490" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这篇文章中，我们介绍了使用AWS解决方案SNS、SQS、EventBridge和Lambdas的事件驱动无服务器架构的最佳实践。我希望这能给你一些在事件驱动的无服务器架构上使用AWS解决方案时优化成本、提高处理效率和减少错误的机会。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="63fb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>