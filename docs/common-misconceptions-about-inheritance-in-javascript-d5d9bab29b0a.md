# JavaScript 中关于继承的常见误解

> 原文：<https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a?source=collection_archive---------0----------------------->

> ***窟？[*** *窟* ***] —*** 感叹词:程序员在某件事违反了最小惊奇原则，用反直觉的行为使其吃惊时发出的声音。

```
> .1 + .2
0.30000000000000004
> WAT? OMG! STFU! STUPID JAVASCRIPT!!!
…
```

还有，瓦特？这是我与许多经验丰富的 JavaScript 开发人员交谈时发出的声音，他们忽略了学习原型继承的基本机制:这是 cs 历史上最重要的创新之一，也是 JavaScript 的两大支柱之一。

对我来说，这就像一个专业摄影师还没有学会曝光三角——控制照片大部分视觉风格的基本公式。简而言之:

> 如果你不懂原型，
> 你就不懂 JavaScript。

# 古典继承和原型继承真的不是一回事吗，只是一种文体偏好？

> **号**

经典继承和原型继承在根本上和语义上是不同的。

经典遗传和原型遗传之间有一些**定义特征**。为了使本文有意义，您必须记住以下几点:

在**类继承中，实例从蓝图**(类)继承，**创建子类关系**。换句话说，你不能像使用实例一样使用类。你不能调用类定义本身的实例方法。您必须首先创建一个实例，然后调用该实例上的方法。

在原型继承中，**实例从其他实例继承。**使用**委托原型**(将一个实例的原型设置为引用一个**示例对象**)，它实际上是**对象链接到其他对象**，或者如凯尔·辛普森所说的 **OLOO** 。使用**串联继承**，您只需**将属性**从**样本对象**复制到一个新实例。

理解这些差异真的很重要。类继承凭借其机制**创建类层次，作为子类创建的副作用。**那些层次导致**关节炎代码**(难以更改)和**脆性**(当您修改基类时，由于波动的副作用而容易损坏)。

原型继承不一定会创建相似的层次结构。我建议你保持原型链尽可能的浅。很容易将许多原型拼合在一起，形成一个**单一委托原型。**

TL；博士:

*   一个**级**就是一个**蓝图**。
*   一个**原型**是一个**对象**实例。

# 类难道不是 JavaScript 中创建对象的正确方式吗？

> **号**

在 JavaScript 中创建对象有几种正确的方法。第一个也是最常见的是对象文字。看起来是这样的(在 ES6 中):

当然，对象文字比 ES6 早得多，但是它们缺少上面看到的方法快捷方式，你必须使用 *`var`* 而不是 *`let`* 。哦，还有， *`.describe()`* 方法中的模板字符串也不能在 ES5 中工作。

你可以用 *`Object.create()`* (一个 ES5 特性)附加委托原型:

让我们把这个分解一下。 *`animal`* 是**的代表原型**。 *`mouse`* 就是一个实例。当您试图访问 *`mouse`* 上不存在的属性时，JavaScript 运行时将查找 *`animal`* (委托)上的属性。

***` object . assign()`***是 Rick Waldron 倡导的一项新的 ES6 特性，此前已在几十个库中实现。你可能知道它是 *`$。从 jQuery 或 *`_ 中扩展()`*。从下划线扩展()`*。Lodash 有一个版本叫做 *`assign()`。*你传入一个目标对象，以及尽可能多的源对象，用逗号分隔。它将通过*赋值*将所有**可枚举的自身属性**从源对象复制到目标对象，其中**优先级最后。**如果有任何属性名冲突，则来自最后一个传入对象的版本会胜出。

***` object . create()`***是道格拉斯·克洛克福特倡导的一个 ES5 特性，这样我们就可以在不使用构造函数和 *`new`* 关键字的情况下附加委托原型。

我跳过构造函数的例子，因为我不能推荐它们。我见过他们被虐的很多，也见过他们造成[很多麻烦](/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf)。值得注意的是，很多聪明人不同意我的观点。聪明人会为所欲为。

聪明人会**采纳道格拉斯·克洛克福特的建议:**

> 如果某项功能有时很危险，并且有更好的选项，那么请始终使用更好的选项

# 不需要一个构造函数来指定对象实例化行为，处理对象初始化吗？

> **号**

任何函数都可以创建和返回对象。当它不是构造函数时，它被称为**工厂函数。**

## 更好的选择

我通常不把我的工厂命名为“工厂”——这只是为了举例说明。通常我会叫它 *`mouse()`。*

# JavaScript 中隐私不需要构造函数吗？

> **号**

在 JavaScript 中，每当您导出一个函数时，该函数都可以访问外部函数的变量。当您使用它们时，JS 引擎会创建一个**闭包**。闭包是 JavaScript 中的一种常见模式，通常用于保护数据隐私。

闭包并不是构造函数所独有的。任何功能都可以为数据隐私创建一个封闭:

![](img/c3f2be93b6633d6b6ec3478284d5512b.png)

# “新”是否意味着代码正在使用经典继承？

> **号**

` *new`* 关键字用于调用构造函数。它实际上做的是:

*   创建新实例
*   将` *this`* 绑定到新实例
*   将新对象的委托[[Prototype]]引用到由构造函数的 *`prototype`* 属性引用的对象。
*   将新对象的`.constructor`属性引用到被调用的构造函数。
*   以构造函数命名对象类型，这在调试控制台中最常见。你会看到` *[Object Foo]`，比如*，而不是` *[Object object]`。*
*   允许` *instanceof`* 检查对象的原型引用是否与*引用的对象相同。构造函数的原型*属性。

## 谎言

让我们在这里暂停一下，重新考虑一下 *`instanceof`* 的值。你可能会改变对它的有用性的看法。

**重要提示:** ` *instanceof`* 不会像在强类型语言中那样进行类型检查。相反，它对原型对象进行身份检查，这很容易被愚弄。例如，它不能跨执行上下文工作(错误、挫折和不必要限制的常见来源)。作为参考，一个[野外的例子，来自 bacon.js](https://github.com/baconjs/bacon.js/issues/296) 。

它也很容易被其他来源的假阳性(更常见的是假阴性)欺骗。因为这是针对目标对象的` *.prototype`* 属性的身份检查，所以会导致奇怪的事情:

```
> function foo() {}
> var bar = { a: ‘a’};
> foo.prototype = bar; // Object {a: “a”}
> baz = Object.create(bar); // Object {a: “a”}
> baz instanceof foo // true. oops.
```

最后一个结果完全符合 JavaScript 规范。没有什么是坏的——只是 *`instanceof`* 不能保证类型安全。**很容易欺骗**报告**误报**，和**漏报**。

除此之外，试图让你的 JS 代码表现得像强类型代码一样，会阻止你的函数被提升到泛型，泛型可重用性更高，也更有用。

**` *instanceof* `限制了你的代码的可重用性，并可能给使用你的代码的程序带来错误。**

> 谎言的实例。
> 
> 改为 Ducktype。

## “新”很奇怪

**窟？** ` *new* `也做一些*古怪的事情*来返回值。如果你试图返回一个原语，那是行不通的。如果你返回任何其他任意对象，那个 ***做*** 工作，但是 *`this`* 被丢弃，破坏对它的所有引用(包括`*)。调用()`*和`*。apply()`* )，并断开与构造函数的 *`.prototype`* 引用的链接。

# 经典继承和原型继承的性能差别大吗？

> **号**

你可能听说过**隐藏类，**，并且认为构造函数明显优于用 *`Object.create()`* 实例化的对象。这些性能差异被大大夸大了。

您的应用程序的一小部分时间花在运行 JavaScript 上，其中很少一部分时间花在访问对象的属性上。事实上，今天生产的最慢的笔记本电脑每秒可以访问数百万个属性。

**那不是你 app 的瓶颈**。帮你自己一个忙，[剖析你的应用](http://www.paulirish.com/2015/advanced-performance-audits-with-devtools/)来**发现你真正的性能瓶颈**。我敢肯定，在你再花时间考虑微优化之前，有无数的事情需要解决。

**不服气？**为了让一个微优化对你的应用产生任何可感知的影响，你必须循环运行**成百上千次**，微优化中你应该关心的唯一差异是那些**数量级的差异**。

**经验法则:**剖析你的应用，尽可能多地消除加载、网络、文件 I/O 和渲染瓶颈。**那时，也只有那时，你才应该开始考虑微优化。**

你能说出 *.0000000001* 秒和 *.000000001* 秒的区别吗？我也不能，但我肯定能区分加载 10 个小图标和加载一个网络字体的区别。

如果你用**剖析你的应用**并且发现对象创建确实是一个瓶颈，最快的方法不是使用 *`new`* 和传统的 OO。**最快的方法是使用对象文字**。您可以在循环中这样做，并将对象添加到对象池中，以避免来自垃圾收集器的冲击。如果相对于 perf 而言，放弃原型 OO 是值得的，那么抛弃原型链和继承来产生对象文字也是值得的。

> 但是谷歌说上课快…

**窟？**谷歌正在打造一个 JavaScript 引擎。您正在构建一个应用程序。显然他们关心的和你关心的应该是**非常不同的事情**。让谷歌来处理微优化。你担心你的应用程序的真正瓶颈。我保证，关注其他任何事情，你都会获得更好的投资回报。

# 经典和原型的内存消耗差别大吗？

> **号**

两者都可以使用委托原型在许多对象实例之间共享方法。两者都可以使用或避免将一堆状态包装到闭包中。

事实上，如果您从工厂函数开始，切换到对象池会更容易，这样您可以更仔细地管理内存，避免被垃圾收集器周期性地阻塞。关于为什么构造函数会如此尴尬的更多信息，请看。注意*下的“‘新’是否意味着代码正在使用经典继承？”*

换句话说，如果您想要内存管理的最大灵活性，请使用工厂函数而不是构造函数和经典继承。

> “…如果您想要最灵活的内存管理，
> 使用工厂函数…”

# 本机 API 使用构造函数。他们不是比工厂更地道吗？

> **号**

**工厂在 JavaScript 中极其常见。**例如，有史以来最流行的 JavaScript 库 **jQuery** 向用户公开了一个工厂。John Resig 写过关于选择使用工厂和原型扩展而不是类的文章。基本上，这可以归结为一个事实，即他不希望呼叫者每次做出选择时都必须键入 *`new`* 。那会是什么样子呢？

还有什么曝光工厂的？

*   **React***` React . create class()`*是工厂。
*   **Angular** 使用类&工厂，但是用依赖注入容器中的工厂包装它们。所有的提供者都是使用 *`.provider()`* 工厂的糖。甚至还有一个`。 *factory()`* provider，甚至还有 *`.service()`* provider 包装普通构造函数并公开……你猜对了:一个 **factory** 给 DI 消费者。
*   **Ember**` Ember . application . create()；`是生产 app 的工厂。与其创建构造函数来调用*` new`*,*`. extend()`*方法，不如扩充应用程序。
*   **节点**核心服务像 *`http.createServer()`* 和 *`net.createServer()`* 都是工厂函数。
*   **快递**是创建快递 app 的工厂。

如您所见，几乎所有最流行的 JavaScript 库和框架都大量使用了工厂函数。JS 中唯一比工厂更常见的对象实例化模式是对象文字。

JavaScript 内置开始使用构造函数，因为 Brendan Eich 被告知要使它看起来像 Java。JavaScript 继续使用构造函数来实现自我一致性。现在试图把一切都改成工厂而贬低构造函数是很尴尬的。

> 这并不意味着**你的 API**必须很烂。

# 经典继承不是比原型继承更惯用吗？

> **号**

每次我听到这种误解，我都会忍不住说，“你会写 JavaScript 吗？”继续前进…但我会忍住冲动，澄清事实。

如果这也是你的问题，不要难过。这不是你的错。 [JavaScript 培训烂透了！](/javascript-scene/javascript-training-sucks-284b53666245)

这个问题的答案是一个巨大的

# 不…(但是)

原型是 JS 惯用的继承范式， *`class`* 是掠夺性的入侵物种。

## 流行 JavaScript 库简史:

一开始，每个人都写自己的库，开放共享并不是什么大事。然后**原型**出现了。(名字在这里是一个很大的暗示)。Prototype 通过使用**串联继承**扩展内置**委托原型**发挥了它的魔力。

后来我们都意识到，当本地替代和冲突库破坏了互联网时，修改内置原型是一种反模式。但那是另一回事了。

JS lib 人气过山车上的下一个是 **jQuery** 。jQuery 最出名的是 **jQuery 插件**。他们通过使用**串联继承扩展 jQuery 的**委托原型**来工作。**

> 你开始感觉到一种模式了吗？

jQuery 仍然是有史以来最受欢迎的 JavaScript 库。以巨大的优势。巨大的。

这就是事情变得混乱的地方，类扩展开始潜入语言中…John Resig(jQuery 的作者)在 JavaScript 中写了关于*简单类继承的文章，人们开始*实际使用它，*即使 John Resig 自己并不认为它属于 jQuery(因为 **prototypal OO 更好地完成了同样的工作**)。*

像 ExtJS 这样的半流行的 Java 风格的框架出现了，带来了类在 JavaScript 中的第一次有点儿，有点儿，不是真正主流的使用。这是 2007 年。在一个有点流行的 lib 开始向 JS 用户展示经典继承之前，JavaScript 已经有 12 年的历史了。

三年后，Backbone **爆发了**并有了一个 *`.extend()`* 方法，它模仿了类继承，包括所有最糟糕的特性，比如脆弱的对象层次。就在那时，天下大乱了。

> ~100kloc app 开始使用 Backbone。几个月后，我调试了一个 6 级层次结构，试图找到一个 bug。逐句通过“超级”链上的每一行构造函数代码。发现并修复了顶级基类中的错误。然后必须修复许多子类，因为它们依赖于基类的错误行为。**几个小时的挫败**使得**本应是 5 分钟的修复**。

***这不是 JavaScript。*** 我突然又活在了*爪哇地狱*里。在那个孤独、黑暗、可怕的地方，任何快速的移动都可能导致整个等级制度在紧密结合的抽搐中颤抖和崩溃。

这些是重写本的组成部分。

但是，在主干文件中隐藏着一缕金色的阳光:

我们的老朋友，**串联传承**力挽狂澜*` backbone . events `***mixin**。

事实证明，如果你足够仔细地观察**任何非平凡的 JavaScript 库**，**你会发现串联和委托的例子**。JavaScript 开发人员做这些事情是如此普遍和自动，以至于**他们甚至不认为这是继承**，即使它**完成了相同的目标。**

> JS 中的继承是如此简单
> 以至于让那些认为需要努力的人感到困惑。
> 
> 为了使它变得更难，我们加上了“类”。

我们是如何添加类的？当然，我们使用**委托原型**和**对象连接**在原型继承的基础上构建了它！

这就像开着你的特斯拉 Model S 去汽车经销店，换一辆生锈的 1983 年福特 Pinto。

# 经典继承和原型继承之间的选择不是取决于用例吗？

> **号**

原型 OO 更简单、更灵活，并且不容易出错。多年来，我一直在提出这一主张，并鼓励人们想出一个令人信服的类用例*。成千上万的人听到了这个号召。我收到的几个答案取决于本文中提到的一个或多个误解。*

我曾经是古典传承迷。我完全相信了。我到处构建对象层次结构。我构建了 visual OO 快速应用程序开发工具来帮助软件架构师设计有意义的对象层次和关系。使用传统的继承分类法，需要一个可视化工具来真实地映射和图形化企业应用程序中的对象关系。

在我从 C++和 Java 过渡到 JavaScript 后不久，我就停止了所有这些工作。不是因为我在构建不太复杂的应用程序(事实正好相反)，而是因为 JavaScript 简单多了，我不再需要那些 OO 设计工具了。

我以前做应用程序设计咨询，经常推荐全面重写。为什么？因为**对于新的用例来说，所有的对象层次最终都是错误的。**

我不是一个人。在那些日子里，对于新的软件版本来说，完全重写是非常普遍的。这些重写中的大部分都是由因循守旧、脆弱的阶级阶层造成的。整本书都是关于面向对象设计错误以及如何避免它们或者从它们中重构出来。似乎每个开发人员的办公桌上都有一本[“设计模式”](http://www.amazon.com/gp/product/0201633612?ie=UTF8&camp=213733&creative=393185&creativeASIN=0201633612&linkCode=shr&tag=eejs-20&linkId=QYF6ABRMZ4O6KML2)。

在这一点上，我建议你们采纳 T21、“四人帮”的建议:

> "优先选择对象组合而不是类继承."

在 Java 中，这比类继承更难，因为你实际上必须使用类来实现它。

在 JavaScript 中，我们没有这样的借口。实际上，在 JavaScript 中，通过将各种**原型**组装在一起，简单地创建您需要的对象**要比管理对象层次结构容易得多。**

**窟？**认真。想要一个可以将任何日期输入转换成 *`megaCalendarWidget`* 的 jQuery 对象吗？不用 *`extend`* 一个 *`class`* 。JavaScript 有动态对象扩展，jQuery 公开了自己的原型，所以您可以直接扩展它——不需要 extend 关键字！**窟？:**

下次调用 jQuery 工厂时，您将获得一个实例，它可以让您的数据输入变得非常棒。

同样，您可以使用 *`Object.assign()`* 将任意数量的对象与后进优先级组合在一起:

不，真的— **任意数量的对象:**

这种技术被称为**串联继承**，你继承的原型有时被称为**范例原型**，它不同于委托原型，因为你**从它们那里复制**，而不是委托给它们。

# ES6 有“class”关键字。这难道不意味着我们都应该使用它吗？

> **号**

有很多令人信服的理由让到[避免使用 ES6 *`class`* 关键字](/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf)，尤其是因为它不适合 JavaScript。

在 JavaScript 中，我们已经有了一个**非常强大且富有表现力的对象系统**。如今在 JS 中实现的类的概念更具限制性(以一种糟糕的方式，而不是以一种酷的类型正确性的方式)，并且掩盖了很久以前内置到语言中的非常酷的原型 OO 系统。

你知道什么对 JavaScript 真正有好处吗？从熟悉原型 OO 的程序员的角度来看，更好的糖和抽象建立在原型之上。

那可能是真的很酷。

> 我正在用 JavaScript 在
> 原型 OO 上创建一个完整的在线类。
> 
> [现在就预订](https://ericelliottjs.com/product/lifetime-access-pass/)
> 终身访问所有
> 我的 JavaScript 课程。

***埃里克·艾略特*** *著有* [*【编程 JavaScript 应用】*](http://pjabook.com) *(奥赖利)&纪录片制作主持人，* ***【编程素养】*** *。他为 Adobe Systems******尊巴健身*******华尔街日报*******【ESPN*******BBC****等顶级录音师贡献了软件经验******

**他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。**