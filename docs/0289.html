<html>
<head>
<title>ViewModels : A Simple Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图模型:简单的例子</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e?source=collection_archive---------0-----------------------#2017-06-28">https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e?source=collection_archive---------0-----------------------#2017-06-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="2311" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="b3ed" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">两年多前，我正在为初学者开发Android。带领学生从零编程到第一个Android应用的课程。作为课程的一部分，学生们开发了一个非常简单的叫做<a class="ae ka" href="https://github.com/udacity/Court-Counter" rel="noopener ugc nofollow" target="_blank">法庭计数器</a>的单屏应用。</p><p id="75d8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">Court-Counter是一个<em class="kg">非常</em>简单的应用程序，带有修改篮球比分的按钮。尽管完成的应用程序有一个缺陷；如果你旋转手机，你现在的分数会莫名其妙地消失。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/59dfc78131b754f6696f70e17dbcafc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kZ5CiWnpSC0-aQeModzpNA.gif"/></div></div></figure><p id="28cc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这是怎么回事？旋转设备是应用程序在其生命周期中可以经历的少数<a class="ae ka" href="https://developer.android.com/guide/topics/manifest/activity-element.html#config" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi">配置更改</strong> </a>之一，包括键盘可用性和更改设备语言。所有这些配置更改都会导致活动被拆除并重新创建。</p><p id="08eb" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这种行为允许我们在设备侧向旋转时使用横向特定布局。不幸的是，对于新的(有时不那么新的)工程师来说，这可能是一件令人头痛的事情。</p><p id="3486" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在Google I/O 2017上，Android框架团队推出了一组新的<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>，其中一个组件处理的就是这个确切的旋转问题。</p><p id="b231" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi"> ViewModel </strong> </a>类旨在以生命周期意识的方式保存和管理UI相关数据。这使得数据能够在屏幕旋转等配置更改后继续存在。</p><p id="6b6b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这篇文章是探索ViewModel的来龙去脉的系列文章的第一篇。在这篇文章中，我将:</p><ul class=""><li id="c85e" class="kt ku hh je b jf kb jj kc jn kv jr kw jv kx jz ky kz la lb bi translated">解释视图模型满足的基本需求</li><li id="c256" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">通过将法庭计数器代码更改为使用ViewModel来解决旋转问题</li><li id="b58b" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">仔细看看ViewModel和UI组件的关联</li></ul><h1 id="757f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">潜在的问题</h1><p id="00ce" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">潜在的挑战是<a class="ae ka" href="https://developer.android.com/guide/components/activities/activity-lifecycle.html" rel="noopener ugc nofollow" target="_blank"> Android活动生命周期</a>有许多状态，并且由于配置更改，单个活动可能会在这些不同的状态中循环多次。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lh"><img src="../Images/47ef390767e1f70dcf7e7c7f1c0f333d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*CGGROXWhl8dTko1GdDeFsA.png"/></div></figure><p id="a911" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当一个活动经历所有这些状态时，您可能还需要将瞬态UI数据保存在内存中。我将把<strong class="je hi">瞬态UI数据</strong>定义为UI所需的数据。示例包括用户输入的数据、运行时生成的数据或从数据库加载的数据。这些数据可以是位图图像、RecyclerView所需的对象列表，或者是篮球比分。</p><p id="4f90" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">以前，您可能在配置更改期间使用<code class="du li lj lk ll b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onRetainNonConfigurationInstance()" rel="noopener ugc nofollow" target="_blank">onRetainNonConfigurationInstance</a></code>保存这些数据，并在另一端解包。但是，如果您的数据不需要知道或管理活动的生命周期状态，这不是很好吗？如果数据存储在活动之外的某个地方，而不是在活动中有一个像<code class="du li lj lk ll b">scoreTeamA </code>这样的变量，并因此与活动生命周期的所有突发事件联系在一起，那会怎么样呢？这就是ViewModel类的用途。</p><p id="2d5a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在下图中，您可以看到一个活动的生命周期，它经历了一个循环，然后最终完成。视图模型的生命周期显示在相关活动生命周期的旁边。注意，ViewModels可以很容易地用于片段和活动，我称之为<strong class="je hi"> UI控制器</strong>。这个例子着重于活动。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lm"><img src="../Images/f474166c18e6ef30cce099cf3494de16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*3Kr2-5HE0TLZ4eqq8UQCkQ.png"/></div></figure><p id="d5e1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">ViewModel从您第一次请求ViewModel(通常在<code class="du li lj lk ll b">onCreate</code>活动中)开始存在，直到活动完成并销毁。<code class="du li lj lk ll b">onCreate</code>在一个活动的生命周期中可能被调用多次，例如当应用程序被轮换时，但是ViewModel始终存在。</p><h1 id="2be7" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">一个非常简单的例子</h1><p id="37d0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">设置和使用视图模型有三个步骤:</p><ol class=""><li id="d784" class="kt ku hh je b jf kb jj kc jn kv jr kw jv kx jz ln kz la lb bi translated">通过创建一个扩展<a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"> ViewModel </a>的类，将数据从UI控制器中分离出来</li><li id="5920" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ln kz la lb bi translated">设置视图模型和UI控制器之间的通信</li><li id="4c17" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ln kz la lb bi translated">在UI控制器中使用视图模型</li></ol><h2 id="b339" class="lo if hh bd ig lp lq lr ik ls lt lu io jn lv lw is jr lx ly iw jv lz ma ja mb bi translated">步骤1:创建一个视图模型类</h2><p id="f269" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi">注意</strong>:要创建ViewModel，您首先需要添加正确的生命周期依赖。这里的<a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#declaring_dependencies" rel="noopener ugc nofollow" target="_blank">怎么看</a>。</p><p id="c2d5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">通常，您将为应用程序中的每个屏幕创建一个ViewModel类。这个ViewModel类将保存与屏幕相关的所有数据，并为存储的数据设置getters和setters。这将显示UI的代码(在活动和片段中实现)与数据(现在位于ViewModel中)分离开来。因此，让我们为Court-Counter中的一个屏幕创建一个ViewModel类:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="480f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">为了简洁起见，我选择将数据作为公共成员存储在我的<code class="du li lj lk ll b">ScoreViewModel.java</code>中，但是创建getter和setter来更好地封装数据是一个好主意。</p><h2 id="1d45" class="lo if hh bd ig lp lq lr ik ls lt lu io jn lv lw is jr lx ly iw jv lz ma ja mb bi translated">步骤2:关联UI控制器和视图模型</h2><p id="5d98" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">您的UI控制器(也称为活动或片段)需要了解您的视图模型。这是为了当UI交互发生时，您的UI控制器可以显示数据并更新数据，比如按一个按钮来增加球队在球场上的得分。</p><p id="87a8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">然而，ViewModels不应该持有对活动、</strong> <a class="ae ka" href="https://developer.android.com/reference/android/content/Context.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi">上下文、</strong> </a> <strong class="je hi"> s </strong>的引用。<strong class="je hi"> ** </strong>此外，视图模型不应该包含包含对UI控制器的引用的元素，例如视图，因为这将创建对上下文的间接引用。</p><p id="dd75" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">您不应该存储这些对象的原因是，视图模型比您的特定UI控制器实例寿命长—如果您旋转一个活动三次，您就创建了三个不同的活动实例，但您只有一个视图模型。</p><p id="f465" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">记住这一点，让我们创建这个UI控制器/ViewModel关联。您需要在UI控制器中为您的ViewModel创建一个成员变量。然后在<code class="du li lj lk ll b">onCreate</code>中，你应该调用:</p><pre class="ki kj kk kl fd me ll mf mg aw mh bi"><span id="49b4" class="lo if hh ll b fi mi mj l mk ml">ViewModelProviders.of(<strong class="ll hi">&lt;Your UI controller&gt;</strong>).get(<strong class="ll hi">&lt;Your ViewModel&gt;.class</strong>)</span></pre><p id="6c9a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在Court-Counter的情况下，这看起来像:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="4a9f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">* *注意:</strong>“视图模型中没有上下文”规则有一个例外。有时候你可能需要一个<a class="ae ka" href="https://developer.android.com/reference/android/content/Context.html#getApplicationContext()" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi">应用上下文</strong> </a> <strong class="je hi"> </strong>(与活动上下文相对)来使用系统服务之类的东西。将应用程序上下文存储在ViewModel中是可以的，因为应用程序上下文与应用程序生命周期紧密相关。这与活动上下文不同，后者与活动生命周期相关联。事实上，如果您需要一个应用程序上下文，您应该扩展<a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html" rel="noopener ugc nofollow" target="_blank"><strong class="je hi">AndroidViewModel</strong></a>，它只是一个包含应用程序引用的视图模型。</p><h2 id="4fd6" class="lo if hh bd ig lp lq lr ik ls lt lu io jn lv lw is jr lx ly iw jv lz ma ja mb bi translated">步骤3:在UI控制器中使用ViewModel</h2><p id="623a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">要访问或更改UI数据，您现在可以使用ViewModel中的数据。这里有一个新的<code class="du li lj lk ll b">onCreate</code>方法和一个通过给A队加一分来更新分数的方法的例子:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="18ed" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> Pro提示:</strong> ViewModel还可以很好地与另一个架构组件<a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>配合使用，我不会在本系列中深入探讨这个组件。使用LiveData的额外好处是它是可见的:当数据改变时，它可以触发UI更新。你可以在这里了解更多关于LiveData <a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="c802" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">仔细看看<code class="du li lj lk ll b">ViewModelsProviders.of</code></h1><p id="c27c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">MainActivity第一次调用<code class="du li lj lk ll b"><a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of(android.support.v4.app.Fragment)" rel="noopener ugc nofollow" target="_blank">ViewModelProviders.of</a></code>方法时，它会创建一个新的ViewModel实例。当这个方法再次被调用时(每当调用<code class="du li lj lk ll b">onCreate</code>时都会发生)，它将返回与特定法院计数器MainActivity关联的预先存在的ViewModel。这是保存数据的方法。</p><p id="855b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这只有在您将正确的UI控制器作为第一个参数传入时才有效。虽然您应该<strong class="je hi">永远不要</strong>将UI控制器存储在ViewModel中，但是ViewModel类确实在幕后跟踪ViewModel和UI控制器实例之间的关联，使用您作为第一个参数传入的UI控制器。</p><pre class="ki kj kk kl fd me ll mf mg aw mh bi"><span id="0f52" class="lo if hh ll b fi mi mj l mk ml">ViewModelProviders.<em class="kg">of</em>(<strong class="ll hi">&lt;THIS ARGUMENT&gt;</strong>).get(ScoreViewModel.<strong class="ll hi">class</strong>);</span></pre><p id="bb28" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这允许您拥有一个打开相同活动或片段的许多不同实例的应用程序，但是具有不同的视图模型信息。让我们想象一下，如果我们扩展我们的法庭柜台的例子，有多个篮球比赛的分数。游戏以列表的形式呈现，然后点击列表中的一个游戏会打开一个看起来像我们当前的MainActivity的屏幕，但我会将其命名为GameScoreActivity。</p><p id="27a1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">对于您打开的每个不同的游戏屏幕，如果您在<code class="du li lj lk ll b">onCreate</code>中将ViewModel和<code class="du li lj lk ll b">GameScoreActivity</code>相关联，它将创建一个不同的ViewModel实例。如果您旋转这些屏幕中的一个，与<strong class="je hi">相同的</strong>视图模型的连接将保持不变。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mm"><img src="../Images/0f627088ad40a2a6a5aa456db010c40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQ6XDm4Ga14SJWlCb27rkg.png"/></div></div></figure><p id="aa4a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">所有这些逻辑都是通过调用<code class="du li lj lk ll b">ViewModelProviders.of(&lt;Your UI controller&gt;).get(&lt;Your ViewModel&gt;.class)</code>来完成的。因此，只要你传入一个UI控制器的正确实例，它就能工作。</p><p id="5490" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">最后一个想法</strong>:视图模型非常适合将用户界面控制器代码与填充用户界面的数据分离开来。也就是说，它们不是数据持久性和保存应用程序状态的灵丹妙药。在下一篇文章中，我将探索活动生命周期与视图模型的微妙交互，以及视图模型与<code class="du li lj lk ll b">onSaveInstanceState</code>的比较。</p><h1 id="b54a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论和进一步学习</h1><p id="a2af" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在这篇文章中，我探索了新的ViewModel类的基础。关键要点是:</p><ul class=""><li id="159f" class="kt ku hh je b jf kb jj kc jn kv jr kw jv kx jz ky kz la lb bi translated"><a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"> ViewModel </a>类旨在以生命周期意识的方式保存和管理UI相关数据。这使得数据能够在屏幕旋转等配置更改后继续存在。</li><li id="2ef8" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">视图模型将UI实现与应用程序的数据分离开来。</li><li id="63e9" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">一般来说，如果应用程序中的一个屏幕有瞬态数据，你应该为这个屏幕的数据创建一个单独的视图模型。</li><li id="86ac" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">ViewModel的生命周期从关联的UI控制器第一次被创建时开始，直到它被完全销毁。</li><li id="dbd3" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">不要在视图模型中直接或间接存储UI控制器或上下文。这包括在视图模型中存储一个视图。对UI控制器的直接或间接引用违背了将UI与数据分离的目的，并可能导致内存泄漏。</li><li id="bb3d" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">ViewModel对象会经常存储LiveData对象，你可以在这里了解更多<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></li><li id="5cae" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated"><a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of(android.support.v4.app.Fragment)" rel="noopener ugc nofollow" target="_blank"> ViewModelProviders.of </a>方法通过作为参数传入的UI控制器跟踪ViewModel与哪个UI控制器相关联。</li></ul><p id="336e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">想要更好的视角吗？检查:</p><ul class=""><li id="12ef" class="kt ku hh je b jf kb jj kc jn kv jr kw jv kx jz ky kz la lb bi translated"><a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/adding-components.html" rel="noopener ugc nofollow" target="_blank">添加梯度依赖关系的说明</a></li><li id="0b12" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated"><a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank">视图模型</a>文档</li><li id="2ea7" class="kt ku hh je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb bi translated">在有景观的<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view/" rel="noopener ugc nofollow" target="_blank">房间进行引导视图模型练习</a>和<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" rel="noopener ugc nofollow" target="_blank">生命周期代码实验室</a></li></ul><p id="6d2c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">架构组件是根据您的反馈创建的。如果您对ViewModel或任何架构组件有任何问题或意见，请查看我们的<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/feedback.html" rel="noopener ugc nofollow" target="_blank">反馈页面</a>。对这个系列有什么问题或建议吗？留言评论！</p></div></div>    
</body>
</html>