<html>
<head>
<title>Gesture Navigation: handling visual overlaps (II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手势导航:处理视觉重叠(二)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c?source=collection_archive---------0-----------------------#2019-08-07">https://medium.com/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c?source=collection_archive---------0-----------------------#2019-08-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/36988ac0698938a0e39ca9b2582a1d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA3ZtpNRcwzxvVjSKtfEtQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Cover image by <a class="ae hu" rel="noopener" href="/@VPoltrack">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="195b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们手势导航系列的第二篇文章。如果你想跳到另一篇文章，你可以在下面找到它们:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-going-edge-to-edge-812f62e4e83e"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:从边缘到边缘(一)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">Android Q增加了一个新的系统导航模式，允许用户导航回主屏幕…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-handling-gesture-conflicts-8ee9c2665c69"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:处理手势冲突(三)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">这是我们博客系列的第三篇文章，我们讨论了如何在更新应用程序后处理视觉重叠…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-immersive-modes-43f2d37a925d"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:沉浸式模式(四)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">在这个关于手势导航的博客系列的第三篇文章中，我们讨论了如何处理手势冲突…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="5e45" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列的第1部分中，我们探讨了如何让你的应用程序“边到边”。不幸的是，这会导致您的一些视图被绘制在系统栏的后面，使用户看不到它们。这篇文章探索了我们如何<em class="ko">嵌入</em>那些视图，将它们从系统栏中移走。</p><p id="b191" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章的剩余部分，我将会提到一个叫做“系统用户界面”的东西。这就是我们所说的任何系统在屏幕上提供的UI，比如导航栏和状态栏。它还包括通知面板之类的东西。</p><h1 id="6bf5" class="kp kq hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">插入物</h1><p id="8aa5" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">术语<em class="ko"> insets </em>往往会让Android开发人员感到恐惧，通常来自他们在Android Lollipop时代试图隐藏状态栏的经历。比如这个很老的<a class="ae hu" href="https://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st" rel="noopener ugc nofollow" target="_blank"> StackOverflow题</a>上的题目就有<strong class="iw hy"> <em class="ko"> lot </em> </strong>的观点😲。</p><p id="acb9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Insets告诉你屏幕的哪些部分与系统UI相交，比如导航条或状态栏。交叉可能意味着简单地显示在你的内容上面，但它也可以告诉你系统手势。我们可以使用insets来尝试和消除任何冲突，例如通过从边缘移动一个视图。</p><p id="8712" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，insets由<code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets.html" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>类表示，在AndroidX中由<code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html" rel="noopener ugc nofollow" target="_blank">WindowInsetsCompat</a></code>表示。有了Android Q，我们在设计你的应用时有5种类型的插件需要考虑。你使用哪种插入类型取决于你所处的情况，所以让我们来看看每种类型，看看…</p><h2 id="fa9d" class="lw kq hx bd kr lx ly lz kv ma mb mc kz jf md me ld jj mf mg lh jn mh mi ll mj bi translated">系统窗口插入</h2><p id="8df1" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated"><strong class="iw hy">方法:</strong> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getSystemWindowInsets()" rel="noopener ugc nofollow" target="_blank">getSystemWindowInsets()</a></code></p><p id="7195" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统窗口插入是目前最常用的插入类型。从API 1开始，它们就以各种形式出现，每当系统UI显示在应用程序上方(z轴)时，它们就被分派到视图层次结构中。常见的例子有状态栏和导航栏，但也包括屏幕键盘(IME)。</p><p id="ad5d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个使用系统窗口插入的例子。这里我们有一个<code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/com/google/android/material/floatingactionbutton/FloatingActionButton.html" rel="noopener ugc nofollow" target="_blank">FloatingActionButton</a></code> (FAB)，放在屏幕的底角，有一个<code class="du ls lt lu lv b">16dp</code>的余量(根据<a class="ae hu" href="https://material.io/design/components/buttons-floating-action-button.html#specs" rel="noopener ugc nofollow" target="_blank">指南</a>)。</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mq"><img src="../Images/fbc7d72b1a72be725b7f57434a541ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CfzjfLjOba2KRet1"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">FAB in the Google I/O app before it was converted to go edge-to-edge</figcaption></figure><p id="0830" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们完成了<a class="ae hu" rel="noopener" href="/androiddevelopers/gesture-navigation-going-edge-to-edge-812f62e4e83e">上一篇文章</a>中的第1步和第2步，我们的视图现在被展开到导航栏后面:</p><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mq"><img src="../Images/7435f6bfeaa88bbf17ef0c7adcb6bfbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UKTD7TVinGEHCYFg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">FAB in the Google I/O app after requesting fullscreen layout</figcaption></figure><p id="d311" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以看到我们的会议日程列表现在延伸到导航栏后面，这就是我们想要创造一个更加身临其境的✔️.体验<em class="ko">我们将在以后的文章中更详细地介绍如何处理列表/网格。</em></p><p id="6213" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">回到示例，您还可以看到FAB现在被遮挡，这意味着用户可能无法与视图交互/单击视图。这种视觉冲突是我们想要避免的🚫。当设备被设置为使用按钮导航模式(如图)时，这个例子更明显，因为栏更高。在具有动态颜色适应的手势导航中，它确实有点工作，但请记住，系统可以随时切换到半透明的稀松布，这可能会破坏任何交互。</p><blockquote class="mr"><p id="399b" class="ms mt hx bd mu mv mw mx my mz na jr dx translated">这是指出你应该在所有导航模式下测试你的应用的好时机。</p></blockquote><p id="d335" class="pw-post-body-paragraph iu iv hx iw b ix nb iz ja jb nc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr ha bi translated">那么我们如何处理视觉冲突呢？这就是<strong class="iw hy">系统窗口插入</strong>发挥作用的地方。它们告诉您系统栏在视图层次结构上的位置，因此我们可以使用这些值将视图从系统栏移开。</p><p id="e518" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，工厂布置在底部和右侧边缘附近，因此我们可以使用<code class="du ls lt lu lv b">systemWindowInsets.bottom</code>和<code class="du ls lt lu lv b">systemWindowInsets.right</code>值来增加视图在每个维度上的边距，将其从导航栏上移开。</p><p id="f034" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们这样做了，我们反而得到以下内容:</p><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mq"><img src="../Images/1b28bce5cb15981257bef4a7a59fc628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*86T1NdOX84j-9Xzn"/></div></div></figure><p id="fff9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ko">在这篇文章的后面，我们将详细讨论如何实现这一点。</em></p><p id="d62f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ko">TL；DR: </em>系统窗口插件最适用于移动/填充视图，这些视图是<strong class="iw hy">可点击的</strong>，并且不应该被系统栏遮挡。</p><h2 id="8342" class="lw kq hx bd kr lx ly lz kv ma mb mc kz jf md me ld jj mf mg lh jn mh mi ll mj bi translated">可点击元素插入</h2><p id="0594" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated"><strong class="iw hy">方法:</strong> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getTappableElementInsets()" rel="noopener ugc nofollow" target="_blank">getTappableElementInsets()</a></code></p><p id="570a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来是Android Q中新增的可点击元素插件。这些插件与上面的系统窗口插件非常相似，但对导航栏的不同可见性做出了响应。</p><p id="a314" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">TL；DR</strong>for ' tap table element insets ':忽略它们，使用' system window insets '代替。你可以跳到下面的“手势插图”,或者继续阅读了解更多。🕵️</p></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="6558" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可点击元素插入定义应用于可点击(可点击)视图的最小<strong class="iw hy">插入。这种情况下的最小值意味着<em class="ko">的值</em>仍然会导致<em class="ko"> </em>中的<em class="ko"> </em>与系统条冲突。这与系统窗口插图不同，后者提供的值总是避免与系统栏冲突。</strong></p><p id="1be1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们用<a class="ae hu" href="https://developer.android.com/reference/com/google/android/material/floatingactionbutton/FloatingActionButton" rel="noopener ugc nofollow" target="_blank"> FloatingActionButton </a>的例子来展示值的不同:</p><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mq"><img src="../Images/0e8618c3fa5b048ffb45b4e88d46bb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DwH78_x1JI_-BSOR"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Pink = navigation bar bounds. Green = FAB bounds with the specific inset as a bottom margin</figcaption></figure><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ng"><img src="../Images/34aed9339ebdde6f08cb7b9cbd4a67c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*at_w4W9H0_w2W7NBCg4sCw.png"/></div></div></figure><blockquote class="nh ni nj"><p id="eba7" class="iu iv ko iw b ix iy iz ja jb jc jd je nk jg jh ji nl jk jl jm nm jo jp jq jr ha bi translated"><em class="hx">记住，</em> <strong class="iw hy"> <em class="hx">千万不要</em> </strong> <em class="hx">硬编码上表中的值，因为导航栏可以改变大小——使用insets。</em></p></blockquote><p id="13aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以看到，当设备设置为按钮导航时,“可点击元素插入”和“系统手势插入”的作用是相同的。关键区别在于设备何时设置为手势导航<em class="ko">和</em>启用颜色适应。在这种情况下，导航栏是透明的，这意味着理论上可以在其中放置可点击的视图，这就是它包含底部值0的原因。</p><p id="f3c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是Insets不知道视图应该放在哪里，所以当使用tappable元素insets时，理论上可以得到这样的结果:</p><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mq"><img src="../Images/1266923eeb2a56ba644f4f334e78230d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*riBy2AfHqNUNK0UO"/></div></div></figure><p id="cc5d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这并不理想，因为视图离导航条太近，让用户感到困惑。</p><p id="bc95" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">实际上，几乎所有可点击元素插入的用法都由“系统窗口插入”来代替。</strong></p><h2 id="9660" class="lw kq hx bd kr lx ly lz kv ma mb mc kz jf md me ld jj mf mg lh jn mh mi ll mj bi translated">手势插图</h2><p id="0b07" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated"><strong class="iw hy">方法:</strong> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getSystemGestureInsets()" rel="noopener ugc nofollow" target="_blank">getSystemGestureInsets()</a></code> &amp; <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getMandatorySystemGestureInsets()" rel="noopener ugc nofollow" target="_blank">getMandatorySystemGestureInsets()</a></code></p><p id="64f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将讨论的下一种插件是新的系统手势插件，添加到Android Q的平台中。概括地说，Android Q带来了一种新的手势导航模式，允许用户通过两种触摸手势来导航他们的设备:</p><ol class=""><li id="ee4f" class="nn no hx iw b ix iy jb jc jf np jj nq jn nr jr ns nt nu nv bi translated">从显示器的一个边缘水平推送。这触发了后退功能。</li><li id="d401" class="nn no hx iw b ix nw jb nx jf ny jj nz jn oa jr ns nt nu nv bi translated">从显示屏底部边缘向上滑动。这允许用户去他们的主屏幕或最近的应用程序。</li></ol><figure class="mk ml mm mn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ob"><img src="../Images/d6b835324184d1c3469d55cc5f5b0615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JGyqAoNDAtkMzv-V"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demo showing gesture navigation on Android Q</figcaption></figure><p id="cd82" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统手势插入表示系统手势优先于应用程序触摸手势的窗口区域。您可能已经注意到，我在上面列出了两种方法。这是因为实际上有两种类型的系统手势插入:一种包含所有手势区域的<strong class="iw hy">和<strong class="iw hy">子集</strong>，包含<em class="ko">强制</em>系统手势插入。</strong></p><p id="9ced" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">系统手势插图</strong> <br/>首先我们有了系统手势插图。这些插图包含屏幕上所有系统手势优先于应用手势的区域。在Android Q上，这意味着插图看起来有点像这样，包含一个home手势的底部插图，以及一个back手势的左右插图:</p><pre class="mk ml mm mn fd oc lv od oe aw of bi"><span id="9168" class="lw kq hx lv b fi og oh l oi oj">           0<br/>    +--------------+<br/>    |              |<br/>    |   <strong class="lv hy">System</strong>     |<br/> 40 |   <strong class="lv hy">Gesture</strong>    |  40<br/>    |   <strong class="lv hy">Insets</strong>     |<br/>    |              |<br/>    +--------------+<br/>           60</span></pre><p id="7417" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你什么时候会使用系统手势插入？这些插图告诉你系统手势在哪里优先，所以你可以使用它们来主动移动任何需要滑动手势来操作的视图。</p><p id="e82e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">常见的例子包括<a class="ae hu" href="https://material.io/design/components/sheets-bottom.html" rel="noopener ugc nofollow" target="_blank">底层</a>，刷卡游戏互动，旋转木马(ala <a class="ae hu" href="https://developer.android.com/reference/androidx/viewpager2/widget/ViewPager2.html" rel="noopener ugc nofollow" target="_blank"> ViewPager </a>)。一般来说，你应该使用这些插入来移动/填充<strong class="iw hy">可旋转的</strong>视图远离边缘。</p><p id="7779" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">强制系统手势插件<br/> </strong>强制系统手势是系统手势插件的子集，只包含应用程序不能排除的区域(因此得名)。我们已经跳过了下一篇博文，在那里我们将讨论手势冲突的处理，但是为了这篇博文的目的，只需要知道应用程序有能力在屏幕的某些部分排除系统手势。</p><p id="7192" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">强制系统手势插入告诉你系统手势<strong class="iw hy">总是</strong>优先的屏幕区域，并且是强制的。在Android Q上，目前唯一强制的区域是屏幕底部的home手势区域。这是为了让用户能够<em class="ko">总是</em>退出应用程序。</p><p id="19e7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们来看一个Android Q设备的手势插入示例，您可能会得到类似这样的结果:</p><pre class="mk ml mm mn fd oc lv od oe aw of bi"><span id="15d0" class="lw kq hx lv b fi og oh l oi oj">           0                              0  <br/>    +--------------+               +--------------+<br/>    |              |               |   <strong class="lv hy">Mandatory</strong>  |<br/>    |   <strong class="lv hy">System</strong>     |               |   <strong class="lv hy">System</strong>     |<br/> 40 |   <strong class="lv hy">Gesture</strong>    | 40          0 |   <strong class="lv hy">Gesture</strong>    | 0<br/>    |   <strong class="lv hy">Insets</strong>     |               |   <strong class="lv hy">Insets</strong>     |<br/>    |              |               |              |<br/>    +--------------+               +--------------+<br/>           60                             60</span></pre><p id="fa9b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以看到系统手势插入包含左、右和底部，而强制手势只包含home手势的底部插入。我们将在下一篇博文中更多地讨论如何排除手势区域。</p><h2 id="2401" class="lw kq hx bd kr lx ly lz kv ma mb mc kz jf md me ld jj mf mg lh jn mh mi ll mj bi translated">稳定插入</h2><p id="af97" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated"><strong class="iw hy">方法:</strong> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getStableInsets()" rel="noopener ugc nofollow" target="_blank">getStableInsets()</a></code></p><p id="8348" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稳定的嵌入是Android上可用的最后一种嵌入。它们与手势导航并不特别相关，但是我想为了完整起见，我们会很快介绍它们。</p><p id="33e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稳定插入与系统窗口插入相关，但它们表示系统UI <em class="ko">可能</em>在你的应用程序上显示的位置，而不是系统UI <em class="ko">显示的位置</em>。稳定插入主要用于系统UI设置为可见性可切换的模式时，例如使用<a class="ae hu" href="https://developer.android.com/training/system-ui/immersive#leanback" rel="noopener ugc nofollow" target="_blank">向后倾斜</a>或<a class="ae hu" href="https://developer.android.com/training/system-ui/immersive#immersive" rel="noopener ugc nofollow" target="_blank">沉浸式</a>模式时(常见示例:游戏、照片查看器、视频播放器)。</p><h1 id="46d0" class="kp kq hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">处理插图</h1><p id="a792" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">希望你现在对不同类型的insets有了更好的理解，所以现在让我们看看你是如何在你的应用中使用它们的。</p><p id="c1c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">访问<code class="du ls lt lu lv b">WindowInsets</code>的主要方法是通过<code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/ViewCompat.html#setOnApplyWindowInsetsListener(android.view.View,%2520androidx.core.view.OnApplyWindowInsetsListener)" rel="noopener ugc nofollow" target="_blank">setOnApplyWindowInsetsListener</a></code>方法。让我们看一个视图的例子，我们想要添加填充，这样它就不会显示在导航栏后面:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="b794" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我们只是将视图的底部填充设置为系统窗口底部插入值。</p><blockquote class="nh ni nj"><p id="cd55" class="iu iv ko iw b ix iy iz ja jb jc jd je nk jg jh ji nl jk jl jm nm jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="hx">注意:</em> </strong> <em class="hx">如果你在一个</em> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/android/view/ViewGroup.html" rel="noopener ugc nofollow" target="_blank"><em class="hx">ViewGroup</em></a></code> <em class="hx">上做这个，你可能想在它上面设置</em> <code class="du ls lt lu lv b"><em class="hx">android:clipToPadding="false"</em></code> <em class="hx">。这是因为默认情况下，所有视图都在填充内裁剪绘图。这个属性通常与</em> <code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html" rel="noopener ugc nofollow" target="_blank"><em class="hx">RecyclerView</em></a></code> <em class="hx">一起使用，我们将在后面的帖子中详细介绍。</em></p></blockquote><p id="41be" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不过要确保你的监听器函数是幂等的。如果用相同的insets多次调用侦听器，那么每次的结果应该是相同的。下面是一个不幂等的例子:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="7a6f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">🙅你不应该在每次调用监听器的时候增加视图的填充。在视图层次结构的生命周期中，窗口插入传递可以在任何时间发生，也可以发生多次。</p><h2 id="2841" class="lw kq hx bd kr lx ly lz kv ma mb mc kz jf md me ld jj mf mg lh jn mh mi ll mj bi translated">喷气背包</h2><p id="b512" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">对于insets有一点要注意，我建议<em class="ko">总是</em>使用<a class="ae hu" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Jetpack </a>的<code class="du ls lt lu lv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html" rel="noopener ugc nofollow" target="_blank">WindowInsetsCompat</a></code>类，不管你的SDK最低版本是什么。多年来，WindowInsets API得到了改进和扩展，compat版本提供了跨所有API级别的一致API和行为。</p><p id="e62a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在Android Q中提供了新的insets类型，compat方法提供了一组值，这些值在所有API级别上都适用于主机设备。要访问<a class="ae hu" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank"> AndroidX </a>中的新API，请确保更新到<code class="du ls lt lu lv b">androidx.core:core:<strong class="iw hy">1.2.0</strong>-xxx</code>(目前在alpha中)或更高版本。最新版本见此处。</p><h1 id="712b" class="kp kq hx bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">更进一步</h1><p id="d4be" class="pw-post-body-paragraph iu iv hx iw b ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ha bi translated">我上面提到的技术是使用<code class="du ls lt lu lv b">WindowInsets[Compat]</code>API的最简单的方法，但是它们会使您的代码非常冗长和重复。今年早些时候，我写了一篇博文，详细介绍了一些使用绑定适配器显著提高处理窗口插件的人体工程学的技术。您可以在此阅读更多信息:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">WindowInsets —布局的监听器</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">将我们处理插入的地方移到我们的视图所在的地方，布局文件</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="ok l kd ke kf kb kg ho js"/></div></div></a></div></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="3988" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列的下一篇博文中，我们将探讨如何处理你的应用程序与系统手势之间的冲突:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-handling-gesture-conflicts-8ee9c2665c69"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:处理手势冲突(三)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">这是我们博客系列的第三篇文章，我们讨论了如何在更新应用程序后处理视觉重叠…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div></div></div>    
</body>
</html>