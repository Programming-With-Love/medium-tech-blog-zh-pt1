<html>
<head>
<title>Prefetch Text Layout in RecyclerView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RecyclerView中的预取文本布局</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/prefetch-text-layout-in-recyclerview-4acf9103f438?source=collection_archive---------1-----------------------#2018-07-12">https://medium.com/androiddevelopers/prefetch-text-layout-in-recyclerview-4acf9103f438?source=collection_archive---------1-----------------------#2018-07-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/5e6e83678063be099cbc589c2777115c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhQOYPUYLfMg8MlExzXZsw.png"/></div></div></figure><div class=""/><p id="e9f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了在Android上布局文本，系统做了大量的工作。每个字形都被解析——取决于字体、地区、大小、字体特征(比如<strong class="ir ht">粗体</strong>或<em class="jn">斜体</em>)。然后，系统将解析它们在形成单词时如何排列、组合或合并的规则。在所有这些之后，单词终于可以被包装到可用的空间中。</p><p id="7616" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于这些原因，对文本进行布局可能会很昂贵是有道理的。Android使用每个单词的缓存来避免重新计算这些数据，但这只能有所帮助——屏幕上显示的新单词，甚至只是新的字体和文本大小都限制了这种优化。</p><p id="a966" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">recycle view对布局性能特别敏感。当新项目出现在屏幕上时，它们必须作为显示它们的第一帧的一部分进行布局。因此，如果RecyclerView项目中一段复杂的文本需要12毫秒来测量，几乎肯定会导致抖动和丢帧。</strong></p><p id="4fc7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将讨论如何使用新的PrecomputedText APIs在UI线程需要它之前计算文本布局。我们还将介绍Jetpack中专门为在RecyclerView中显示大量文本而设计的新文本预取API，以及它们如何<strong class="ir ht">将UI线程文本测量成本降低95%！</strong></p><h1 id="9e02" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">复杂文本布局</h1><p id="dd56" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">下图显示了一个简单的RecyclerView，它显示了大块的文本。在Pixel2(运行Android P，CPU为1GHz)上，测量80个单词(~520个字符)需要TextView <strong class="ir ht"> 15.6ms </strong>。这是一个巨大的时间量！每一帧的截止时间是16.67毫秒，所以如果UI线程必须测量哪怕一个如此复杂的TextView，它就会超过截止时间。</p><p id="d0eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你的文本视图中可能没有那么多文本，但如果你在低端手机上运行，显示比罗马字符更复杂的内容，或者使用各种字体和样式，这样的时候可能会很现实。</p><p id="00d8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<a class="ae kr" href="https://developer.android.com/studio/profile/inspect-gpu-rendering" rel="noopener ugc nofollow" target="_blank">开发者选项&gt;监控&gt; Profile GPU渲染</a>，可以直观的看到这个问题。绿色的水平条显示了16.67毫秒的理想值，帧根据它们花费的时间垂直堆叠。使用左边的常规文本视图，会有许多丢失的帧——当新项目出现在屏幕上时，图形中会出现大尖峰。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/993a38e7c63d053a3b2467232920b8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eu1ggDz3bK182JPpwEHzZQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Regular TextView measurement on the left, with PrecomputedText on the right.</figcaption></figure><p id="3eab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">右边的截图显示了同一个应用程序，但是使用了PrecomputedText来避免UI线程上昂贵的测量工作。剩下的测量工作还在，造成小尖峰，但不再造成jank。<code class="du lb lc ld le b">TextView.onMeasure</code>缩短为<strong class="ir ht">0.9毫秒</strong> —比<strong class="ir ht">快了16倍多！</strong></p><h1 id="e27d" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">预计算文本</h1><p id="c2a2" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">今年I/O上宣布的<a class="ae kr" href="https://developer.android.com/reference/android/text/PrecomputedText" rel="noopener ugc nofollow" target="_blank"> PrecomputedText </a>是Android P 中的<a class="ae kr" href="https://android-developers.googleblog.com/2018/07/whats-new-for-text-in-android-p.html" rel="noopener ugc nofollow" target="_blank">新API，Jetpack </a>中的<a class="ae kr" href="https://developer.android.com/reference/androidx/core/text/PrecomputedTextCompat" rel="noopener ugc nofollow" target="_blank"> compat版本降低了文本的UI线程成本。它允许您在后台线程上预计算绝大多数测量/布局工作。</a></p><p id="df97" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在UI线程中，从TextView确定布局参数:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="942b" class="lj jp hs le b fi lk ll l lm ln">val params : PrecomputedTextCompat.Params =<br/>        TextViewCompat.getTextMetricsParams(myTextView)</span></pre><p id="2686" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在后台线程上计算一段开销很大的文本:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="81de" class="lj jp hs le b fi lk ll l lm ln">val precomputedText : Spannable =<br/>        PrecomputedTextCompat.create(expensiveText, params)</span></pre><p id="59b0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在文本视图中使用生成的预计算文本:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="574d" class="lj jp hs le b fi lk ll l lm ln">TextViewCompat.setPrecomputedText(myTextView, precomputedText)</span></pre><p id="825a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将超过90%的工作从UI线程中移走——一个巨大的性能胜利！AndroidX实现<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/androidx/core/text/PrecomputedTextCompat" rel="noopener ugc nofollow" target="_blank">PrecomputedTextCompat</a></code>在L (API 21)和更高版本上工作，因此性能提升适用于大约85%的活动设备(<a class="ae kr" href="https://developer.android.com/about/dashboards/" rel="noopener ugc nofollow" target="_blank">截至今年5月</a>)。</p><p id="62dd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个很大的改进，但是上面的异步模式对于显示文本来说不是很好。例如，在RecyclerView中，项目中的文本应该立即可见，而不是在滚动到屏幕一半时才可见。为了实现这一点，我们需要尽早知道文本参数，并在显示TextView之前做后台线程工作。</p><p id="e1ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们如何尽早开始这个预计算文本的工作，这样我们就不需要推迟文本的显示了？</p><h1 id="07b0" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第一种方法—预计算布局</h1><p id="345d" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">当您已经在异步加载文本数据时，使用后台线程来预处理文本非常有用。例如，从网络上加载数据并反序列化它是很常见的，可能在发送到UI线程之前用spans对它进行样式化。</p><p id="04a2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就在反序列化之后，在这里使用PrecomputedText是非常诱人的。我们希望在将文本发送到UI之前对其进行充分的预处理，以最大限度地减少UI线程工作:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="ceb2" class="lj jp hs le b fi lk ll l lm ln">/* Worker Thread */</span><span id="4e3b" class="lj jp hs le b fi lo ll l lm ln">// resolve spans on worker thread to reduce load on UI thread<br/>val expensiveSpanned = resolveIntoSpans(networkData.item.textData)<br/>    <br/>// pre-compute measurement work to reduce load on UI thread<br/>val textParams: PrecomputedTextCompat.Params = <strong class="le ht">// we’ll get to this<br/></strong>val precomputedText: PrecomputedTextCompat = <br/>    PrecomputedTextCompat.create(expensiveSpanned, params)</span></pre><p id="7d5f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，您可以在UI中显示从加载线程发送的预计算文本:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="017a" class="lj jp hs le b fi lk ll l lm ln">/* UI Thread */</span><span id="8f24" class="lj jp hs le b fi lo ll l lm ln">myTextView.setTextMetricParams(precomputedText.getParams())<br/>myTextView.setPrecomputedText(precomputedText)</span></pre><p id="d2e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，我们跳过了如何获得<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/androidx/core/text/PrecomputedTextCompat.Params" rel="noopener ugc nofollow" target="_blank">PrecomputedTextCompat.Params</a></code>，这是棘手的部分。</p><h2 id="03b2" class="lj jp hs bd jq lp lq lr ju ls lt lu jy ja lv lw kc je lx ly kg ji lz ma kk mb bi translated">尺寸问题</h2><p id="7d3b" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">预计算文本需要知道字形大小来进行测量。这意味着它需要知道尺寸，不是以<strong class="ir ht"> sp </strong>(通常在XML中指定)，而是以<strong class="ir ht">像素</strong>为单位，根据文本密度进行调整。将<strong class="ir ht"> sp </strong>转换为<strong class="ir ht">像素</strong>使用<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/android/util/DisplayMetrics.html#scaledDensity" rel="noopener ugc nofollow" target="_blank">DisplayMetrics.scaledDensity</a></code>，这不容易简单地传递给后台线程。</p><p id="d3d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">平台在运行时改变<code class="du lb lc ld le b">scaledDensity</code>以支持用户定义的文本缩放。如果您只查询DisplayMetrics一次，并将它们传递给一个后台线程，您的用户可能会从更改系统范围的字体大小返回到一个只有一半TextViews大小正确的应用程序——这不是一个很好的体验。</p><p id="920d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正确处理这一点是可能的，但是您需要非常小心——任何时候重新创建活动时，一定要查询<code class="du lb lc ld le b">scaledDensity</code>,如果它发生了变化，删除并重新构建任何缓存的PrecomputedText。</p><h1 id="af5a" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第二种方法—未来预取&lt;&gt;</h1><p id="cebc" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在不改变太多代码的情况下获得PrecomputedText的好处，或者不必担心跨线程反弹文本大小信息，这将是一件好事。让我们来看看一些典型的RecyclerView绑定代码，它设置了一个TextView:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="1d26" class="lj jp hs le b fi lk ll l lm ln">override fun onBindViewHolder(vh: ViewHolder, position: Int) {<br/>    val itemData = getData(position)</span><span id="6a6c" class="lj jp hs le b fi lo ll l lm ln">    vh.textView.textSize = if (item.isImportant) 14 else 10<br/>    vh.textView.text = itemData.text<br/>}</span></pre><p id="740b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">理想情况下，这种代码很容易适应使用PrecomputedText。</p><p id="c48d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让预计算文本变得困难的是，Android TextViews几乎在调用<code class="du lb lc ld le b">setText()</code>之后立即执行布局，而文本样式直到那之前才完成(注意动态<code class="du lb lc ld le b">textSize</code>属性)。这意味着我们没有足够的时间来放置背景文本布局。</p><p id="1f84" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，有一个重要的特性打破了这种预期— <a class="ae kr" rel="noopener" href="/google-developers/recyclerview-prefetch-c2f269075710">回收视图预取</a>。因为预取，RecyclerView实际上比item layout早几帧调用<code class="du lb lc ld le b">onBindViewHolder()</code>。这样做是为了避免在最后一刻，也就是内容将要显示的时候，做昂贵的工作。</p><p id="ff72" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，对于PrecomputedText来说，这有一个很好的副作用，即在绑定和布局之间留出几十毫秒的时间，这是在后台线程上预计算文本的理想间隔！</p><p id="2ccc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在最近的Jetpack测试版中，我们添加了额外的功能来支持这种使用情况。现在可以产生一个<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/androidx/core/text/PrecomputedTextCompat#getTextFuture(java.lang.CharSequence,%20androidx.core.text.PrecomputedTextCompat.Params,%20java.util.concurrent.Executor)" rel="noopener ugc nofollow" target="_blank">Future&lt;PrecomputedTextCompat&gt;</a></code>，<a class="ae kr" href="https://developer.android.com/reference/androidx/appcompat/widget/AppCompatTextView#setTextFuture(java.util.concurrent.Future%3Candroidx.core.text.PrecomputedTextCompat%3E)" rel="noopener ugc nofollow" target="_blank">通知AppCompatTextView在下一个measure()过程中阻塞未来的</a>。</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="a90c" class="lj jp hs le b fi lk ll l lm ln">override fun onBindViewHolder(vh: ViewHolder, position: Int) {<br/>    val itemData = getData(position)</span><span id="5cb5" class="lj jp hs le b fi lo ll l lm ln">    // first, modify item-dependent properties<br/>    vh.textView.textSize = if (item.isImportant) 14 else 10</span><span id="1b56" class="lj jp hs le b fi lo ll l lm ln">    // Pass text computation future to AppCompatTextView,<br/>    // which awaits result before measuring.<br/>    textView.<strong class="le ht">setTextFuture</strong>(PrecomputedTextCompat.<strong class="le ht">getTextFuture</strong>(<br/>            item.text,<br/>            TextViewCompat.getTextMetricsParams(textView),<br/>            /*optional custom executor*/ null))<br/>}</span></pre><p id="5011" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过创造未来，应用程序启动了后台线程预计算文本工作。我们告诉TextView等待，而不是等待绑定代码中的工作，并且只在测量结果之前阻塞结果。当RecyclerView滚动时，项目会提前膨胀/绑定，PrecomputedText利用这一点来隐藏文本的开销。</p><p id="e016" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">只需几行代码，我们就添加了文本预取，将TextView测量时间减少了95%！</p><h1 id="3d2f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">警告</h1><p id="7156" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">注意，您正在查询<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/androidx/core/widget/TextViewCompat.html#getTextMetricsParams(android.widget.TextView)" rel="noopener ugc nofollow" target="_blank">TextViewCompat.getTextMetricsParams()</a></code>并将其传递给一个后台线程。因此，在<code class="du lb lc ld le b">setTextFuture()</code>之后不要改变TextView属性是很重要的，(除非你正在重新绑定，并在之后立即调用<code class="du lb lc ld le b">setTextFuture()</code>)。修改属性会导致PrecomputedText与TextView不兼容，在这种情况下，测量过程中将会引发异常。</p><p id="773b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">PrecomputedTextCompat依赖于Android的word布局缓存，这在Lollipop发布(API 21)之前并不存在。因此，PrecomputedTextCompat不会在Lollipop之前的平台版本上进行预计算。</p><p id="c263" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您禁用了<a class="ae kr" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager#setitemprefetchenabled" rel="noopener ugc nofollow" target="_blank">预取</a>，或者如果您正在使用一个不明确支持预取的自定义布局管理器，这种方法将没有帮助。如果您使用自定义LayoutManager，请确保它实现了<code class="du lb lc ld le b"><a class="ae kr" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager#collectAdjacentPrefetchPositions%28int,%20int,%20android.support.v7.widget.RecyclerView.State,%20android.support.v7.widget.RecyclerView.LayoutManager.LayoutPrefetchRegistry%29" rel="noopener ugc nofollow" target="_blank">collectAdjacentPrefetchPositions()</a></code>，以便RecyclerView知道要预取哪些项目。还要注意，预取只适用于在屏幕上滚动的视图，但幸运的是，这是性能最重要的时候。</p><h1 id="2622" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">数据绑定</h1><p id="17a6" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果你是Android数据绑定的用户，你可以通过定制的<a class="ae kr" href="https://developer.android.com/reference/android/databinding/BindingAdapter" rel="noopener ugc nofollow" target="_blank">绑定适配器</a>获得预计算文本未来的同样好处。首先，我们将像在XML中一样使用数据绑定，但是使用“asyncText”属性:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="534b" class="lj jp hs le b fi lk ll l lm ln">&lt;layout<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>    &lt;data&gt;<br/>        &lt;variable name="item" type="com.example.ItemData"/&gt;<br/>    &lt;/data&gt;<br/>    &lt;TextView<br/>        android:id="@+id/item_text"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:textSize="@{item.isImportant ? 14 : 10}"<br/>        <strong class="le ht">app:asyncText</strong>="@{item.text}"/&gt;<br/>&lt;/layout&gt;</span></pre><p id="2f04" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在我们的BindingAdapter中，我们可以定义<code class="du lb lc ld le b">asyncText</code>属性，并实现它以使用预先计算的文本和<code class="du lb lc ld le b">setTextFuture</code>:</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="7a04" class="lj jp hs le b fi lk ll l lm ln"><a class="ae kr" href="http://twitter.com/BindingAdapter" rel="noopener ugc nofollow" target="_blank">@BindingAdapter</a>(<br/>        "app:asyncText",<br/>        "android:textSize",<br/>        requireAll = false)<br/>fun asyncText(view: TextView, text: CharSequence, textSize: Int?) {<br/>    // first, set all measurement affecting properties of the text<br/>    // (size, locale, typeface, direction, etc)<br/>    if (textSize != null) {<br/>        // interpret the text size as SP<br/>        view.textSize = textSize.toFloat()<br/>    }<br/>    val params = TextViewCompat.getTextMetricsParams(view)<br/>   (view as AppCompatTextView).setTextFuture(<br/>           PrecomputedTextCompat.getTextFuture(text, params, null)<br/>}</span></pre><p id="e7da" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，我们小心地在BindingAdapter中使用所有与文本布局相关的属性，以避免其他binding adapter处理它们。我们需要保证对getTextMetricsParams的调用在TextView绑定了所有其他属性之后运行，并且数据绑定不保证何时调用哪个适配器。为了安全起见，我们采用任何可能由数据绑定控制的TextView属性，并在适配器的开头应用所有这些属性。</p><pre class="kt ku kv kw fd lf le lg lh aw li bi"><span id="9a57" class="lj jp hs le b fi lk ll l lm ln">override fun onBindViewHolder(holder: Holder, position: Int) {<br/>    holder.binding.item = getItem(position)<br/>    holder.binding.executePendingBindings()<br/>}</span></pre><p id="a6cb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们将调用<code class="du lb lc ld le b">executePendingBindings()</code>，以便更新列表项，而无需等待下一个布局阶段。在RecyclerView中使用数据绑定时，这是必需的，即使您没有使用PrecomputedText。</p><h1 id="247a" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="1c2a" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">PrecomputedText解决了RecyclerView中的文本布局性能，这是滚动性能中最主要的性能问题之一。只需几行代码，和最新的Jetpack，就可以降低95%的文本测量成本！</p><p id="8360" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前，我们建议使用通常显示200个或更多字符的列表项文本视图来尝试PrecomputedText。我们希望了解您的使用体验，以及它在您的应用程序中的哪些地方最有帮助。这是Jetpack测试版的一部分，所以请尝试一下，并<a class="ae kr" href="https://issuetracker.google.com/issues/new?component=192731&amp;template=842428" rel="noopener ugc nofollow" target="_blank">让我们知道你的想法</a>！</p><h1 id="dbf5" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">笔记</h1><p id="43d3" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">性能测量在Pixel 2，Android P上完成，锁定到1GHz以获得测量稳定性。应用程序运行时可调试=假，因此艺术运行时具有真实(发布)性能。</p><p id="7441" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Nexus 5，Android M，1.2GHz上运行相同的应用程序，同样的80个单词输入的前/后时间分别为20.3毫秒和1.2毫秒，这是一个非常相似的约94%的成本降低。</p><p id="7085" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从AndroidX <code class="du lb lc ld le b">1.0.0-beta01</code>(或者如果您还没有迁移到AndroidX)开始，上面的API是可用的。*套餐，<code class="du lb lc ld le b">28.0.0-beta01</code>)。</p></div></div>    
</body>
</html>