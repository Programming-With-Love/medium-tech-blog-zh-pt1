<html>
<head>
<title>How to Extract and Parse Query Params in Akka HTTP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提取和解析Akka HTTP中的查询参数</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-extract-and-parse-query-params-in-akka-http-51145ab5b33f?source=collection_archive---------0-----------------------#2019-06-23">https://medium.com/quick-code/how-to-extract-and-parse-query-params-in-akka-http-51145ab5b33f?source=collection_archive---------0-----------------------#2019-06-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/77e5223d9247f96c7b26212275804288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuKG2MoFUP86tlB4RvS3CQ.png"/></div></div></figure><p id="9d06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们免费的<a class="ae jn" href="http://link.codemunity.io/website-akka-http-quickstart" rel="noopener ugc nofollow" target="_blank"> Scala和Akka HTTP课程</a>中，我们为Todo应用程序构建了一个API。原来我知道…</p><p id="fa63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本教程中，我们将通过添加一个允许我们搜索todos的端点来扩展API的功能。</p><p id="0829" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">端点将接受两个查询参数，我们将提取、解析它们并返回适当的todo列表。</p><p id="01cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">克隆<a class="ae jn" href="https://github.com/Codemunity/akkahttp-quickstart" rel="noopener ugc nofollow" target="_blank">过程报告</a>并检查分支<code class="du jo jp jq jr b">8.3-test-update-route</code>。</p><p id="d179" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随意四处看看，当你准备好了，我们就开始编码！</p><h1 id="1048" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在存储库中实现搜索</h1><p id="4fac" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们的第一步是在存储库中实现搜索功能。</p><p id="e31c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你看看我们的模型，我们已经为每个端点接收的数据创建了一个模型。</p><p id="8a03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们为我们的搜索添加一个，我们希望通过文本或完成字段进行搜索，如果指定了文本，我们将检查标题和描述。</p><p id="30db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望这两个值都是可选的，以保持搜索的灵活性。</p><p id="23c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该模型看起来像:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="187d" class="ld jt hh jr b fi le lf l lg lh">case class SearchTodo(text: Option[String], done: Option[Boolean])</span></pre><p id="5e55" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，打开<code class="du jo jp jq jr b">TodoRepository</code>文件，向trait添加以下方法:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="ac23" class="ld jt hh jr b fi le lf l lg lh">def search(searchTodo: SearchTodo): Future[Seq[Todo]]</span></pre><p id="40a4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它期待我们刚刚创建的模型，它将返回一系列的todos。</p><p id="4be0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该项目现在不会编译，因为我们必须在几个地方实现这个新方法。先说最简单的。</p><p id="8e8c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要更新测试文件夹中的<code class="du jo jp jq jr b">FailingRepository</code>，它存在于<code class="du jo jp jq jr b">TodoMocks</code>特征中。向其添加以下方法:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="c6b5" class="ld jt hh jr b fi le lf l lg lh">override def search(searchTodo: SearchTodo): Future[Seq[Todo]] = Future.failed(new Exception("Mocked exception"))</span></pre><p id="a356" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">整个文件现在看起来像这样:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="8977" class="ld jt hh jr b fi le lf l lg lh">import scala.concurrent.Future<br/><br/>trait TodoMocks {<br/><br/>  class FailingRepository extends TodoRepository {<br/>    override def all(): Future[Seq[Todo]] = Future.failed(new Exception("Mocked exception"))<br/><br/>    override def done(): Future[Seq[Todo]] = Future.failed(new Exception("Mocked exception"))<br/><br/>    override def pending(): Future[Seq[Todo]] = Future.failed(new Exception("Mocked exception"))<br/><br/>    override def save(createTodo: CreateTodo): Future[Todo] = Future.failed(new Exception("Mocked exception"))<br/><br/>    override def update(id: String, updateTodo: UpdateTodo): Future[Todo] = Future.failed(new Exception("Mocked exception"))<br/><br/>    override def search(searchTodo: SearchTodo): Future[Seq[Todo]] = Future.failed(new Exception("Mocked exception"))<br/>  }<br/><br/>}</span></pre><p id="cf99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们可以在<code class="du jo jp jq jr b">InMemoryTodoRepository</code>类中实现实际的搜索登录。为了简单起见，我们将一步一步地过滤待办事项列表。这毕竟是一个虚拟的内存实现。</p><p id="da9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">覆盖新方法:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="6245" class="ld jt hh jr b fi le lf l lg lh">override def search(searchTodo: SearchTodo): Future[Seq[Todo]] = Future.successful {<br/>}</span></pre><p id="e6ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们知道我们需要返回一个<code class="du jo jp jq jr b">Future</code>，所以我们将继续使用整个类中使用的模式和<code class="du jo jp jq jr b">Future.successful</code>。现在让我们来实现这个函数。</p><p id="d59f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们将折叠文本字段，如果它是空的，这意味着我们不必用它来过滤待办事项列表，所以我们将返回待办事项列表。如果它不为空，我们将检查标题或描述是否包含文本:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="1105" class="ld jt hh jr b fi le lf l lg lh">val textTodos = searchTodo.text.fold(todos)(text =&gt; todos.filter { todo =&gt;<br/>  todo.title.contains(text) || todo.description.contains(text)<br/>})</span></pre><p id="c60d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其次，我们将在<code class="du jo jp jq jr b">done</code>字段上做同样的事情，但是这次我们过滤了<code class="du jo jp jq jr b">textTodos</code>:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="4ebc" class="ld jt hh jr b fi le lf l lg lh">searchTodo.done.fold(textTodos)(done =&gt; textTodos.filter(_.done == done))</span></pre><p id="bd67" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的整个函数看起来像:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="ef97" class="ld jt hh jr b fi le lf l lg lh">override def search(searchTodo: SearchTodo): Future[Seq[Todo]] = Future.successful {<br/>  val textTodos = searchTodo.text.fold(todos)(text =&gt; todos.filter { todo =&gt;<br/>    todo.title.contains(text) || todo.description.contains(text)<br/>  })<br/>  searchTodo.done.fold(textTodos)(done =&gt; textTodos.filter(_.done == done))<br/>}</span></pre><h1 id="1518" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">添加搜索路线</h1><p id="c0a0" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">有了我们的搜索功能，是时候通过添加新路线来展示它了。</p><p id="f400" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望响应对<code class="du jo jp jq jr b">/todos/search</code>路由的GET请求，我们将接受前面提到的两个查询参数，<code class="du jo jp jq jr b">done</code>和<code class="du jo jp jq jr b">text</code>。</p><p id="fd57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们转到<code class="du jo jp jq jr b">Router</code>文件，并在里面看一看<code class="du jo jp jq jr b">TodoRouter</code>类。要监听所需的路由，我们需要将它添加到<em class="li">“pending”</em>端点的旁边:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="53b8" class="ld jt hh jr b fi le lf l lg lh">... ~ path("pending") {<br/>    get {<br/>      handleWithGeneric(todoRepository.pending()) { todos =&gt;<br/>        complete(todos)<br/>      }<br/>    }<br/>  } ~ path("search") {<br/>    get {<br/>    }<br/>  }</span></pre><p id="9130" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样我们就可以监听路径<code class="du jo jp jq jr b">/todos/search</code>下的GET请求，现在我们需要处理参数。</p><p id="d946" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们可以使用<code class="du jo jp jq jr b">parameters</code>指令。我们可以查看官方文档来获得一些指导。</p><p id="ce29" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它接受我们想要接受的参数列表，按照文档中的第一个示例，用法如下:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="c54f" class="ld jt hh jr b fi le lf l lg lh">parameters('text, 'done) { (text: String, done: String) =&gt;<br/>  // search!<br/>}</span></pre><p id="b1a7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但这意味着我们得到的<code class="du jo jp jq jr b">text</code>和<code class="du jo jp jq jr b">done</code>值都是字符串，这不是我们想要的。</p><p id="0ec5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望<code class="du jo jp jq jr b">text</code>值是一个<code class="du jo jp jq jr b">Option[String]</code>，而<code class="du jo jp jq jr b">done</code>是一个<code class="du jo jp jq jr b">Option[Boolean]</code>。我们总是可以手动进行解析/对话，但是让我们看看Akka HTTP是否提供了我们需要的东西。</p><p id="c42f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据文档，我们可以使用<code class="du jo jp jq jr b">?</code>函数获得一个<code class="du jo jp jq jr b">Option[String]</code>:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="23e1" class="ld jt hh jr b fi le lf l lg lh">parameters('text.?, 'done) { (text: Option[String], done: String) =&gt;<br/>  // the text is now Option[String]<br/>}</span></pre><p id="89d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是<code class="du jo jp jq jr b">done</code>呢？</p><p id="d1ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从使它成为一个布尔值开始，文档显示了如何通过使用<code class="du jo jp jq jr b">as</code>方法将<code class="du jo jp jq jr b">color</code>转换为<code class="du jo jp jq jr b">Int</code>，让我们看看是否可以用它来转换为<code class="du jo jp jq jr b">Boolean</code>:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="94e9" class="ld jt hh jr b fi le lf l lg lh">parameters('text.?, 'done.as[Boolean]) { (text: Option[String], done: Boolean) =&gt;<br/>  // done is a Boolean now!<br/>}</span></pre><p id="a1f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们如何使<code class="du jo jp jq jr b">Boolean</code>成为可选值？文档中没有提到这个具体的用例，但是我们可以看到，在像使用<code class="du jo jp jq jr b">"distance".as[Int].*</code>一样使用<code class="du jo jp jq jr b">as</code>之后，我们可以使用<code class="du jo jp jq jr b">*</code>方法。让我们看看是否可以使用<code class="du jo jp jq jr b">?</code>方法来完成我们所需要的:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="ad35" class="ld jt hh jr b fi le lf l lg lh">parameters('text.?, 'done.as[Boolean]) { (text: Option[String], done: Option[Boolean]) =&gt;<br/>  // finally, we got Option[Boolean]<br/>}</span></pre><p id="879a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们可以创建我们的<code class="du jo jp jq jr b">SearchTodo</code>模型的一个实例。我们可以手动操作，但不能自动操作吗？</p><p id="fe48" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">原来<a class="ae jn" href="https://doc.akka.io/docs/akka-http/current/routing-dsl/case-class-extraction.html" rel="noopener ugc nofollow" target="_blank">我们可以</a>通过使用<code class="du jo jp jq jr b">as</code>函数和模型的应用方法:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="aa72" class="ld jt hh jr b fi le lf l lg lh">parameters('text.?, 'done.as[Boolean].?).as(SearchTodo) { searchTodo: SearchTodo =&gt;<br/>  // we've got our model now!<br/>}</span></pre><p id="b4e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们完成路线的实施。在得到模型之后，我们可以按照通常的模式用泛型指令处理错误，然后调用我们在存储库中早期实现的<code class="du jo jp jq jr b">search</code>方法:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="ee88" class="ld jt hh jr b fi le lf l lg lh">... ~ path("search") {<br/>      get {<br/>        parameters('text.?, 'done.as[Boolean].?).as(SearchTodo) { searchTodo =&gt;<br/>          handleWithGeneric(todoRepository.search(searchTodo)) { todos =&gt;<br/>            complete(todos)<br/>          }<br/>        }<br/>      }<br/>    }</span></pre><p id="4e18" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们获得了搜索的todos，如果有的话，我们将与他们一起响应请求。</p><p id="4625" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jo jp jq jr b">Main</code>对象中，我们用几个todos启动我们的应用程序，让我们运行它并向我们的API发送一些搜索请求。</p><p id="37f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我使用的是<a class="ae jn" href="https://httpie.org/" rel="noopener ugc nofollow" target="_blank"> HTTPie </a>，但也可以随意使用<code class="du jo jp jq jr b">curl</code>或您选择的客户端。</p><p id="4255" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">http localhost:9000/todos/search?done=true</code>:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/e245d87d1dc3fd6a491df7a6b95e7c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1phtmWRZKuqXu9H_.gif"/></div></div></figure><p id="778f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">http localhost:9000/todos/search?done=false</code>:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/46c439f0915156c26b87fdcc44e6fa63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*97tQoqPF3fnIUTxL.gif"/></div></div></figure><p id="52dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">http localhost:9000/todos/search?text=Buy</code>:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/96f75fbf3542def9164de52482167d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tqWggxxNyG6CB0mc.gif"/></div></div></figure><p id="eb2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以随意使用它，并思考我们尚未涉及的任何边缘案例。</p><h1 id="f2da" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试新路线</h1><p id="7914" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">手动测试在开始时很有趣，你可以亲眼看到你构建的东西在工作，但是随着你的应用程序的发展，它变得不再实际，或者不可行。</p><p id="4020" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以让我们为我们的搜索路线添加一些测试。如果你不熟悉如何测试Akka HTTP，不要担心，这很简单，已经有一些测试了，看看<code class="du jo jp jq jr b">main</code>文件夹旁边的<code class="du jo jp jq jr b">test</code>文件夹。</p><p id="c6ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望确保某些场景按预期工作:</p><ul class=""><li id="a1ab" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">按完成搜索</li><li id="e326" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">按文本搜索</li><li id="6f37" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">按两者搜索</li></ul><p id="6410" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们开始吧。</p><p id="29a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jo jp jq jr b">test/scala</code>下创建一个名为<code class="du jo jp jq jr b">TodoRouterSearchSpec</code>的新文件:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="e9c1" class="ld jt hh jr b fi le lf l lg lh">import akka.http.scaladsl.model.StatusCodes<br/>import akka.http.scaladsl.server.ValidationRejection<br/>import akka.http.scaladsl.testkit.ScalatestRouteTest<br/>import org.scalatest.{Matchers, WordSpec}</span><span id="d940" class="ld jt hh jr b fi ly lf l lg lh">class TodoRouterSearchSpec  extends WordSpec with Matchers with ScalatestRouteTest {<br/>  import de.heikoseeberger.akkahttpcirce.FailFastCirceSupport._<br/>  import io.circe.generic.auto._</span><span id="2a8b" class="ld jt hh jr b fi ly lf l lg lh">}</span></pre><p id="75c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们完成测试时，我们已经有了我们需要的导入，我们将使用ScalaTest的<code class="du jo jp jq jr b">WordSpec</code>样式，我们导入喀尔刻来编码和解码我们与JSON之间的模型。</p><p id="8620" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于测试目的，我们将实例化几个todos，就像我们的<code class="du jo jp jq jr b">Main</code>一样:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="5366" class="ld jt hh jr b fi le lf l lg lh">private val doneTodo =<br/>  Todo("2", "Buy milk", "The cat is thirsty!", done=true)<br/>private val pendingTodo =<br/>  Todo("1", "Buy eggs", "Ran out of eggs, buy a dozen", done=false)</span><span id="5140" class="ld jt hh jr b fi ly lf l lg lh">private val todos = Seq(doneTodo, pendingTodo)</span></pre><p id="7401" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从第一个测试开始:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="2645" class="ld jt hh jr b fi le lf l lg lh">"A TodoRouter" should {</span><span id="2975" class="ld jt hh jr b fi ly lf l lg lh">  "search todos by done field" in {<br/>    // what goes here?!</span><span id="8a50" class="ld jt hh jr b fi ly lf l lg lh">  }<br/>}</span></pre><p id="a0b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将遵循其他测试中使用的模式，首先我们将实例化一个内存存储库和一个路由器:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="23b5" class="ld jt hh jr b fi le lf l lg lh">val repository = new InMemoryTodoRepository(todos)<br/>val router = new TodoRouter(repository)</span></pre><p id="d36b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们将发出两个请求，一个搜索已完成的待办事项，另一个搜索未完成的待办事项。我们将断言我们获得了正确的状态代码和响应:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="cce4" class="ld jt hh jr b fi le lf l lg lh">Get("/todos/search?done=true") ~&gt; router.route ~&gt; check {<br/>  status shouldBe StatusCodes.OK<br/>  val respTodos = responseAs[Seq[Todo]]<br/>  respTodos shouldBe Seq(doneTodo)<br/>}<br/><br/>Get("/todos/search?done=false") ~&gt; router.route ~&gt; check {<br/>  status shouldBe StatusCodes.OK<br/>  val respTodos = responseAs[Seq[Todo]]<br/>  respTodos shouldBe Seq(pendingTodo)<br/>}</span></pre><p id="c1b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试用例看起来像:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="1150" class="ld jt hh jr b fi le lf l lg lh">"search todos by done field" in {<br/>  val repository = new InMemoryTodoRepository(todos)<br/>  val router = new TodoRouter(repository)</span><span id="f9a7" class="ld jt hh jr b fi ly lf l lg lh">  Get("/todos/search?done=true") ~&gt; router.route ~&gt; check {<br/>    status shouldBe StatusCodes.OK<br/>    val respTodos = responseAs[Seq[Todo]]<br/>    respTodos shouldBe Seq(doneTodo)<br/>  }</span><span id="1d20" class="ld jt hh jr b fi ly lf l lg lh">  Get("/todos/search?done=false") ~&gt; router.route ~&gt; check {<br/>    status shouldBe StatusCodes.OK<br/>    val respTodos = responseAs[Seq[Todo]]<br/>    respTodos shouldBe Seq(pendingTodo)<br/>  }<br/>}</span></pre><p id="74da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们的下一个测试，我们也将执行两个请求，一个请求标题，另一个请求描述:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="f25e" class="ld jt hh jr b fi le lf l lg lh">"search todos by text" in {<br/>  val repository = new InMemoryTodoRepository(todos)<br/>  val router = new TodoRouter(repository)<br/><br/>  Get("/todos/search?text=dozen") ~&gt; router.route ~&gt; check {<br/>    status shouldBe StatusCodes.OK<br/>    val respTodos = responseAs[Seq[Todo]]<br/>    respTodos shouldBe Seq(pendingTodo)<br/>  }<br/><br/>  Get("/todos/search?text=Buy") ~&gt; router.route ~&gt; check {<br/>    status shouldBe StatusCodes.OK<br/>    val respTodos = responseAs[Seq[Todo]]<br/>    respTodos shouldBe todos<br/>  }<br/>}</span></pre><p id="de4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与第一个非常相似，但是这次我们发送的是<code class="du jo jp jq jr b">text</code>查询参数。</p><p id="5a1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将为我们的快乐之路增加一个测试，在这里我们将搜索两者:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="cfc9" class="ld jt hh jr b fi le lf l lg lh">"search todos by both" in {<br/>  val repository = new InMemoryTodoRepository(todos)<br/>  val router = new TodoRouter(repository)<br/><br/>  Get("/todos/search?done=true&amp;text=egg") ~&gt; router.route ~&gt; check {<br/>    status shouldBe StatusCodes.OK<br/>    val respTodos = responseAs[Seq[Todo]]<br/>    respTodos shouldBe Seq.empty<br/>  }<br/>}</span></pre><p id="875d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随意添加更多的测试用例，并对它们进行试验。</p><h1 id="64c0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">验证参数</h1><p id="4cd8" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">您可能想知道:“如果我们得到无效数据怎么办？”。你的担心是对的，我们不能相信用户会给我们发送有效的数据。</p><p id="acff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是如果Akka HTTP正在为我们创建模型，我们如何验证它呢？</p><p id="dbe2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们总是可以在创建后验证它，但是如果Akka HTTP可以处理它，并且一旦我们得到模型，我们就可以直接使用它，这不是很好吗？</p><p id="b69b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，当然有可能…不然我也不会这么说！😉</p><p id="cfa5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">玩笑归玩笑，有多种方法可以做到这一点，我们将在本教程中使用一个简单的方法。</p><p id="5bc5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将利用Scala的<a class="ae jn" href="https://www.scala-lang.org/api/current/scala/Predef%24.html" rel="noopener ugc nofollow" target="_blank"> require </a>(如果检查链接，在搜索<code class="du jo jp jq jr b">require</code>时查找最后出现的内容)方法。</p><p id="d988" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果没有满足这些约束，Akka HTTP将使用这些约束来拒绝请求。</p><p id="22b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将讨论两种情况:</p><ul class=""><li id="b3f1" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">如果指定了字符串，则它不能为空，例如应该拒绝<code class="du jo jp jq jr b">/todos/search?text=</code></li><li id="b4a0" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">至少应该指定一个参数</li></ul><p id="7a79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">必须更新模型以包含这些验证，接下来我们来做:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="61c2" class="ld jt hh jr b fi le lf l lg lh">case class SearchTodo(text: Option[String], done: Option[Boolean]) {<br/>  require(text.fold(true)(_.nonEmpty), "If specified, the text can't be empty")<br/>  require(text.nonEmpty || done.nonEmpty, "At least one parameter has to be specified")<br/>}</span></pre><p id="22ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们甚至可以写自己的错误信息，酷！</p><p id="4f3e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们编写一个测试来验证第一种情况:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="6427" class="ld jt hh jr b fi le lf l lg lh">"not search with empty text" in {<br/>  val repository = new InMemoryTodoRepository(todos)<br/>  val router = new TodoRouter(repository)</span><span id="80e7" class="ld jt hh jr b fi ly lf l lg lh">  Get("/todos/search?text=") ~&gt; router.route ~&gt; check {<br/>    rejection shouldBe a[ValidationRejection]<br/>  }<br/>}</span></pre><p id="e8e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的新内容是我们如何断言请求应该被拒绝。Akka HTTP的testkit用<code class="du jo jp jq jr b">rejection</code>方法让我们知道。</p><p id="2922" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们断言<code class="du jo jp jq jr b">rejection</code>方法返回的值应该有一个<code class="du jo jp jq jr b">ValidationRejection</code>类型，这就是Akka HTTP将返回的类型。</p><p id="e204" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行测试并确保它通过。</p><p id="a91f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，当实际提出请求时，这种拒绝会是什么样的呢？让我们运行<code class="du jo jp jq jr b">Main</code>对象，自己看看:</p><p id="2ecb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">http localhost:9000/todos/search?text=</code>:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/9c06e8d7fef1686118bc2a3e8fbd9f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x4YFnsTvI9g3XQdh.gif"/></div></div></figure><p id="03fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到了我们所期望的<code class="du jo jp jq jr b">400 Bad Request</code>，但是请注意，我们也得到我们的错误消息<code class="du jo jp jq jr b">requirement failed: If specified, the text can't be empty</code>。太好了！</p><p id="1f2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的最后一个测试将确保我们的搜索端点不会被用来搜索所有的todos，因为我们有一个不同的端点。(没有具体原因😁)</p><p id="5068" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与前一个非常相似，但是这一次我们没有指定参数。让我们用HTTP客户端测试一下:</p><p id="d848" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">http localhost:9000/todos/search</code>:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/e3fd1af50d8629cb491beea6a94c89d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o9xyDQnSX51LdieR.gif"/></div></div></figure><h1 id="c6f1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="0c23" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们学习了如何在我们的API中提取、解析甚至验证查询参数！</p><p id="1d2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Akka HTTP提供了许多实用程序，涵盖了大多数用例，如果没有，您可以选择自己用强大的原语来扩展这个库。</p><p id="b55b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望你喜欢这个教程，我们会很快见到你！</p></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="bb01" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="http://link.codemunity.io/md-query-params" rel="noopener ugc nofollow" target="_blank">想通过免费的分步课程学习如何构建基础项目？你当然知道！</a>😁</p></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="20c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="li">原载于</em><a class="ae jn" href="https://www.codemunity.io/tutorials/akka-http-query-params/" rel="noopener ugc nofollow" target="_blank"><em class="li">https://www . code unity . io</em></a><em class="li">。</em></p></div></div>    
</body>
</html>