<html>
<head>
<title>Improving efficiency and reducing runtime using S3 read optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用S3读取优化提高效率并减少运行时间</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/improving-efficiency-and-reducing-runtime-using-s3-read-optimization-b31da4b60fa0?source=collection_archive---------1-----------------------#2021-08-12">https://medium.com/pinterest-engineering/improving-efficiency-and-reducing-runtime-using-s3-read-optimization-b31da4b60fa0?source=collection_archive---------1-----------------------#2021-08-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="732d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Bhalchandra Pandit |软件工程师</p><h1 id="a15c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">概观</h1><p id="6866" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们描述了一种我们用来提高S3读取吞吐量的新方法，以及我们如何使用它来提高生产作业的效率。结果非常令人鼓舞。一项独立的基准测试显示，S3读取吞吐量提高了12倍(从21 MB/s提高到269 MB/s)。生产量的增加使我们的生产工作能够更快完成。结果，我们看到vcore-hours减少了22%,内存-hours减少了23%,典型生产作业的运行时间也有类似的减少。尽管我们对结果很满意，但我们仍在探索未来更多的改进。在本博客的结尾对它们进行了简要描述。</p><h1 id="81a1" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">动机</h1><p id="047c" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们每天都要处理存储在亚马逊S3上的数Pb的数据。如果我们检查MapReduce/Cascading/burning作业的相关指标，有一点很突出:比预期的mapper速度慢。在大多数情况下，观察到的映射器速度约为5–7mb/秒。与观察到的aws s3 cp等命令的吞吐量相比，这个速度慢了几个数量级，在AWS S3 CP等命令中，大约200+MB/秒的速度是常见的(在EC2中的c5.4xlarge实例上观察到)。如果我们能够提高作业读取数据的速度，我们的作业将会更快完成，并在此过程中为我们节省大量的时间和金钱。考虑到加工成本很高，这些节省的成本很快就会增加到一个相当大的数目。</p><h1 id="1bcd" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">S3读取优化</h1><h2 id="65e6" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">问题:S3A中的吞吐量瓶颈</h2><p id="3a55" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如果我们检查S3AInputStream的实现，很容易注意到以下潜在的改进领域:</p><ol class=""><li id="8ea3" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated"><strong class="ig hi">单线程读取</strong>:在单线程上同步读取数据，这导致作业花费大部分时间等待通过网络读取数据。</li><li id="90f3" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi">多次不必要的重新打开</strong>:S3输入流不可查找。每次执行寻道或遇到读取错误时，都必须重复关闭和重新打开剥离。分裂越大，它发生的几率就越大。每次这样的重新打开都进一步降低了总吞吐量。</li></ol><h2 id="37cf" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">解决方案:提高读取吞吐量</h2><p id="ae44" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated"><strong class="ig hi">建筑</strong></p><figure class="li lj lk ll fd lm er es paragraph-image"><div class="er es lh"><img src="../Images/8b1f868b735f7f01304066912bd04d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*nTk_zYQXtoNWLf_Z"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 1: Components of a prefetching+caching S3 reader</figcaption></figure><p id="cf2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们解决上述缺点的方法包括以下内容:</p><ol class=""><li id="e6ff" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">我们将拆分视为由固定大小的数据块组成。大小默认为8 MB，但可以配置。</li><li id="1962" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">每个块在被调用者访问之前都被异步读入内存。预取缓存的大小(根据块数)是可配置的。</li><li id="856e" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">调用者只能访问已经被预取到内存中的块。这使客户端与网络碎片脱离，并允许我们有一个额外的重试层来提高整体弹性。</li><li id="8e75" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">每当我们遇到当前块之外的寻道，我们就在本地文件系统中缓存预取的块。</li></ol><p id="6df0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们进一步增强了实现，使其成为一个基本上无锁的生产者-消费者交互。这一增强将读取吞吐量从20mb/秒提高到了269 MB/秒，这是由一个独立的基准测试测得的(请参见下面图2中的详细信息)。</p><p id="db71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">顺序读取</strong></p><p id="0136" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何顺序处理数据的数据消费者(例如映射器)都会从这种方法中受益匪浅。当映射器正在处理当前检索的数据时，将异步预取序列中的下一个数据。大多数情况下，当映射器准备好处理下一个数据块时，数据已经被预取。这导致映射器花费更多时间做有用的工作，而等待数据的时间更少，从而有效地提高了CPU利用率。</p><p id="7060" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">更高效的拼花地板读数</strong></p><p id="95ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拼花文件要求非顺序访问，这是由其磁盘格式决定的。我们最初的实现没有使用本地缓存。每次在当前块之外进行寻道时，我们都必须丢弃任何预取的数据。当从Parquet文件中读取时，这导致了比股票阅读器更差的性能。</p><p id="3ba4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们观察到，引入预取数据的本地缓存后，Parquet文件的读取吞吐量有了显著提高。目前，与库存阅读器相比，我们的实现将Parquet文件读取吞吐量提高了5倍。</p><h2 id="876a" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">生产岗位的改善</h2><p id="f32e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">读取吞吐量的提高带来了生产作业的多项效率提升。</p><p id="0912" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">减少作业运行时间</strong></p><p id="33de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业的总体运行时间减少了，因为制图者等待数据的时间减少了，而且完成得更快。</p><p id="f433" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">潜在减少的映射器数量</strong></p><p id="22ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果映射器花费足够少的时间来完成，我们可以通过增加分割大小来减少映射器的数量。映射器数量的这种减少导致与每个映射器的固定开销相关联的CPU浪费的减少。更重要的是，它可以在不增加作业运行时间的情况下完成。</p><p id="bfd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">提高了CPU利用率</strong></p><p id="2a9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于映射器在更少的时间内完成相同的工作，整体CPU利用率增加了。</p><h1 id="8108" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结果</h1><p id="3906" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">目前，我们的实现(S3E)在一个单独的git存储库中，以允许对增强进行更快的迭代。我们最终会通过将它合并回S3A来回馈社区。</p><h2 id="66d3" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">独立基准测试</h2><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/90e2a0fca9fa3cdb70985a76044737aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AicyX2ybEfFOtqLo"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 2: Throughput of S3A vs S3E</figcaption></figure><p id="872b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每种情况下，我们按顺序读取一个3.5 GB的S3文件，并将其本地写入一个临时文件。后一部分用于模拟映射器操作期间发生的IO重叠。基准测试是在EC2中的一个c5.9xlarge实例上运行的。我们测量了读取文件所需的总时间，并计算了每种方法的有效吞吐量。</p><h2 id="6b26" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">生产运行</h2><p id="e9ed" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们用S3E实现测试了许多大型生产作业。这些作业通常每次运行使用数万个vcores。在图3中，我们给出了启用和未启用S3E时获得的指标之间的对比总结。</p><p id="ff73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">衡量资源节约</strong></p><p id="5191" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用下面的方法来计算这种优化带来的资源节省。</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ly"><img src="../Images/e64f9ec4604862aaef94ff05e357bd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcJmy0uce-FGfXow8-y1-Q.png"/></div></div></figure><p id="5445" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察到的结果</strong></p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lz"><img src="../Images/11eb08a0038a7f31ad485e8830e8fd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GRwj68W4lrt7Ry-h"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 3: Comparison of MapReduce job resource consumption</figcaption></figure><p id="65f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑到不同生产作业的工作负载特征的差异，我们发现在30个最昂贵的作业中，vcore降低了6%到45%。vcore天数平均减少了16%。</p><p id="3bb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的方法吸引人的一点是，它可以在不需要对作业代码进行任何更改的情况下为作业启用。</p><h1 id="ca3a" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">未来方向</h1><p id="04ce" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">目前，我们已经将增强的实现添加到一个单独的git存储库中。将来，我们可能会更新现有的S3A实现，并回馈社区。</p><p id="c208" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们正在多个集群中推广这种优化。我们将在未来的博客中公布结果。</p><p id="6b33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鉴于S3E输入流的核心实现不依赖于任何Hadoop代码，我们可以在任何其他访问大量S3数据的系统中使用它。目前，我们正在使用这一优化目标MapReduce，级联，烫印工作。然而，在我们的初步评估中，我们也看到了Spark和Spark SQL非常令人鼓舞的结果。</p><p id="3728" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当前的实现可以使用进一步的调整来提高其效率。同样值得探索的是，我们是否可以使用过去的执行数据来自动调整每个作业使用的块大小和预取缓存大小。</p><p id="0486" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ma">要在Pinterest了解更多关于工程的知识，请查看我们的</em> <a class="ae mb" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="ma">工程博客</em> </a> <em class="ma">，并访问我们的</em><a class="ae mb" href="https://www.pinterestlabs.com/?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=pandit-august-2-2021" rel="noopener ugc nofollow" target="_blank"><em class="ma">Pinterest Labs</em></a><em class="ma">网站。要查看和申请开放的机会，请访问我们的</em> <a class="ae mb" href="https://www.pinterestcareers.com/?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=pandit-august-2-2021" rel="noopener ugc nofollow" target="_blank"> <em class="ma">职业</em> </a> <em class="ma">页面。</em></p></div></div>    
</body>
</html>