<html>
<head>
<title>Build Widgets in Mendix with React Part 2 — Timer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React在Mendix中构建小部件第2部分—计时器</h1>
<blockquote>原文：<a href="https://medium.com/mendix/build-widgets-in-mendix-with-react-part-2-timer-b65c720b34e3?source=collection_archive---------1-----------------------#2022-07-19">https://medium.com/mendix/build-widgets-in-mendix-with-react-part-2-timer-b65c720b34e3?source=collection_archive---------1-----------------------#2022-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/27477902e49ff9c597c75f26b7a3de2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LvQku6jNBZlA0RtCyMECQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Build Widgets in Mendix with React Part 2 — Timer</figcaption></figure><h1 id="6185" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">Mendix平台使开发人员能够通过可插拔小部件框架，使用React扩展他们的应用程序。该框架允许开发人员利用强大的库，并通过构建可以在Mendix Studio Pro中使用的React组件来扩展UI。</h1><p id="0fde" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">在这篇博客中，我们将<strong class="bd lb">了解Typescript </strong>，我将向你展示如何<strong class="bd lb">在你的小部件</strong>中使用来自你的Mendix模型的属性，如何<strong class="bd lb">利用浏览器API </strong>，我们甚至将触及React 中的<strong class="bd lb">条件渲染。</strong></p><p id="db74" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">这是一个多部分系列的第二篇博客，博客1可以在这里找到:</p><div class="lh li fm fo lj lk"><a rel="noopener follow" target="_blank" href="/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">使用React在Mendix中构建小部件—第1部分—颜色计数器</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">Mendix是一个低代码平台，让制造商更快地交付价值，轻松地构建应用程序。和门迪克斯一起…</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly ja lk"/></div></div></a></div><h1 id="dccf" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">何时使用可插拔部件</h1><p id="fba5" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">在决定是否创建一个新的可插拔小部件时，我使用了一些检验标准:</p><ul class=""><li id="d509" class="lz ma hu bd b kg lc kk ld ko mb ks mc kw md la me mf mg mh dt translated">它需要UI组件吗？—如果您需要使用Javascript，但是没有UI组件，那么一个<a class="ae mi" href="https://docs.mendix.com/howto/extensibility/write-javascript-actions" rel="noopener ugc nofollow" target="_blank"> JS动作</a>可能更适合您的用例</li><li id="a75f" class="lz ma hu bd b kg mj kk mk ko ml ks mm kw mn la me mf mg mh dt translated">在<a class="ae mi" href="https://marketplace.mendix.com" rel="noopener ugc nofollow" target="_blank"> Mendix市场</a>有吗？</li><li id="dc8a" class="lz ma hu bd b kg mj kk mk ko ml ks mm kw mn la me mf mg mh dt translated">它使用浏览器API还是NPM软件包？</li></ul><h1 id="7533" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">我们正在建造的东西</h1><p id="fbeb" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">这一次我们将构建一个计时器，用于以固定的时间间隔刷新页面。"为什么我不用JavaScript就能做到呢？"我听到你问了。这是因为我们还将有一个可视化组件，<strong class="bd lb">会告诉您距离下一次刷新还有多长时间</strong>。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/1bd04459e0bec546e21b0774828ae56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*pweD_bj34Aze0x3H.jpg"/></div></figure><p id="d1d7" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">这是基于一个真实的用例，其中一个仪表板显示在车间里，需要每30秒更新一次。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/d3201ee5b175e93af1e1e6649211f911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xVPpMt1iVgIlgegQeh1d2A.gif"/></div></div></figure><h1 id="e7dd" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">入门指南</h1><p id="0681" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">对于这个小部件，我们将使用<a class="ae mi" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lb"> Typescript </strong> </a>，Javascript的强类型包装器，虽然它最初会使代码编写起来稍微困难一些，但是<strong class="bd lb">内置的林挺</strong>和<strong class="bd lb">丰富的文档</strong>在创建可插拔小部件时非常有用。Typescript的这些元素也使得在大型团队中协作更加容易，并且与复杂的API集成更加容易。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/ffea5537d29c6a6a849b1175818bce50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1we3_zYN7rxJ6j-uozuCGQ.png"/></div></figure><p id="60e8" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们从搭建我们的小部件开始，就像在<a class="ae mi" rel="noopener" href="/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff"> Blog 1 </a>中一样，但是这次选择Typescript作为我们的编程语言。</p><blockquote class="mv mw mx"><p id="1d1a" class="ke kf my bd b kg lc ki kj kk ld km kn mz le kq kr na lf ku kv nb lg ky kz la hn dt translated"><strong class="bd lb">React</strong>中功能组件与类组件的快速说明</p><p id="333c" class="ke kf my bd b kg lc ki kj kk ld km kn mz le kq kr na lf ku kv nb lg ky kz la hn dt translated"><strong class="bd lb">在这些博客中，我们将使用功能组件</strong>，然而，你也可能会遇到<strong class="bd lb">使用类组件</strong>编写的React。这是因为，<strong class="bd lb">直到</strong> <a class="ae mi" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lb">释放钩子</strong> </a> <strong class="bd lb">在React 16.8 </strong>，<strong class="bd lb">类组件是管理状态</strong>的唯一方式，功能组件主要是前端的表示层。现在，React社区正朝着使用功能组件的方向发展，因为它们在语法上更加简单，更加轻量级(T21)。</p></blockquote><div class="lh li fm fo lj lk"><a rel="noopener follow" target="_blank" href="/geekculture/is-there-any-reason-to-still-use-react-class-components-9b6a1e6aa9ef"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">还有理由继续使用React类组件吗？</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">用React钩子看函数组件和类组件</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">medium.com</p></div></div><div class="lt l"><div class="nc l lv lw lx lt ly ja lk"/></div></div></a></div><h1 id="ee0e" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">开发时间</h1><p id="eeab" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated"><em class="my">关于插件文件夹结构以及如何设置开发环境的解释，请参见我的</em> <a class="ae mi" rel="noopener" href="/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff"> <em class="my">上一篇博客</em> </a> <em class="my">。</em></p><p id="d9df" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><strong class="bd lb">先说一件事</strong></p><p id="85b2" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">为了加快开发过程，我们将删除我们的编辑器预览文件。这个文件在Studio Pro或Studio的设计模式下为我们的小部件创建预览，我们在本指南中并不担心这个问题。这只是又一个需要更新的东西。因此，让我们继续删除文件:<strong class="bd lb">timer . editor preview . tsx .</strong></p><h2 id="f5b7" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">简述</strong></h2><p id="bf8f" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">我们可以将我们的小部件想要实现的目标分成3个主要部分:</p><ul class=""><li id="3263" class="lz ma hu bd b kg lc kk ld ko mb ks mc kw md la me mf mg mh dt translated"><strong class="bd lb">步骤1: </strong>将定时器设置为Mendix中定义的初始值</li><li id="5509" class="lz ma hu bd b kg mj kk mk ko ml ks mm kw mn la me mf mg mh dt translated"><strong class="bd lb">步骤2: </strong>以1秒为间隔减少计时器</li><li id="5660" class="lz ma hu bd b kg mj kk mk ko ml ks mm kw mn la me mf mg mh dt translated"><strong class="bd lb">第三步:</strong>执行一个动作</li></ul><h1 id="ee6e" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated"><strong class="ak">第一步</strong></h1><h2 id="bbea" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">将定时器设置为Mendix </strong>中定义的初始值</h2><p id="018d" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">让我们从创建Mendix模型和小部件之间的接口开始。我们可以使用一个简单的整数，但是通过使用一个属性，我们可以更灵活地在运行时动态改变定时器值。</p><p id="06fa" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们更新Timer.xml以包含:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="cbfb" class="nd jh hu ns b fv nw nx l ny nz">&lt;property key="timeAtt" type="attribute" required="true<br/>    &lt;caption&gt;Time attribute&lt;/caption&gt;<br/>    &lt;description&gt;The number of seconds on refresh&lt;/description&gt;<br/>    &lt;attributeTypes&gt;<br/>         &lt;attributeType name="Integer"/&gt;<br/>    &lt;/attributeTypes&gt;<br/>&lt;/property&gt;</span></pre><p id="e129" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">同时，我们还应该将子组件重命名为TimeText，将接口重命名为TimeTextProps。当我们保存文件并运行命令:<code class="eh oa ob oc ns b">npm run build</code>时，我们会看到错误，这很好！</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff od"><img src="../Images/8ea5c4df4fc5b47db0fe994c17a203f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gf8OXusIcYEz6eDU.jpg"/></div></div></figure><p id="08f5" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">它显示sampleText属性已被timeAtt替换。让我们用timeAtt代替默认的sampleText来更新我们的计时器文件。</p><p id="b366" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">如果我们在Timer.tsx文件中突出显示timeAtt，我们可以看到它的类型是<code class="eh oa ob oc ns b">EditableValue&lt;Big&gt;</code>。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/bc956be9788b1ab858d94ca7b8f0982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FEnLSWKOawB3xHWc.jpg"/></div></div></figure><p id="30c2" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><a class="ae mi" href="https://docs.mendix.com/apidocs-mxsdk/apidocs/pluggable-widgets-client-apis/#editable-value" rel="noopener ugc nofollow" target="_blank"> EditableValue </a>是Mendix用来表示所有属性的<a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型类型</a>，它允许我们在Mendix模型中读写值。</p><p id="d65c" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><strong class="bd lb">&lt;&gt;</strong>部分，由属性类型决定。对于整数或小数属性，我们使用Big.js库。这是为了确保应用程序中使用的数字不受默认JavaScript数字限制的约束。</p><h2 id="5112" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">使用状态</strong></h2><p id="105d" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">到目前为止，我们已经通过容器组件的道具在Mendix和小部件之间创建了一个链接。现在我们需要将一个易读的值传递给TimeText组件，以显示在页面上。为此，我们将处理我们的<code class="eh oa ob oc ns b">EditableValue&lt;Big&gt;</code>，并在容器组件的<strong class="bd lb">状态</strong>中存储一个简单的整数。</p><p id="2b80" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们在这里使用<strong class="bd lb">状态</strong>而不是<strong class="bd lb">道具</strong>，因为我们将随时间改变我们的计时器值，并且<a class="ae mi" href="https://www.freecodecamp.org/news/how-to-update-a-components-prop-in-react-js-oh-yes-it-s-possible-f9d26f1c4c6d" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lb">道具永远不应该被直接改变</strong> </a>:</p><p id="fe78" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">让我们从从“React”导入<strong class="bd lb">使用状态</strong>开始，并用下面的代码初始化一个名为<strong class="bd lb">时间</strong>的<strong class="bd lb">状态</strong>:</p><p id="2bd2" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><code class="eh oa ob oc ns b">const [time, setTime] = useState&lt;number&gt;();</code></p><p id="8afc" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">这给了我们一个状态变量(<strong class="bd lb"> time </strong>)和一个setState函数来改变该状态(像props一样，状态决不能被直接改变，而是可以通过这个函数来改变)。</p><h2 id="0b00" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">使用使用效果</strong></h2><p id="2456" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">接下来，我们需要<strong class="bd lb">将我们的属性值传递给我们的状态</strong>。最简单的方法是将一个值传递给我们的useState:</p><p id="559b" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><code class="eh oa ob oc ns b">const [time, setTime] = useState&lt;number&gt;(timeAtt.value.toNumber());</code></p><p id="ffbc" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">但是因为我们的值可能是空的，所以我们不会这样做。相反，我们将使用React的另一个核心概念“useEffect”。</p><blockquote class="mv mw mx"><p id="fd01" class="ke kf my bd b kg lc ki kj kk ld km kn mz le kq kr na lf ku kv nb lg ky kz la hn dt translated">那么什么是useEffect呢？本质上，它在每次渲染后执行一个函数。我们可以用它来设定我们的时间，就像这样:</p></blockquote><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="9ef7" class="nd jh hu ns b fv nw nx l ny nz">export function Timer({timeAtt}: TimerContainerProps):ReactElement {<br/>const [time, setTime] = useState&lt;number&gt;();</span><span id="8dc6" class="nd jh hu ns b fv of nx l ny nz">    useEffect(() =&gt; {<br/>         if (timeAtt.value) {<br/>             setTime(timeAtt.value.toNumber());<br/>         }<br/>     }, []);<br/>    <br/>    return &lt;TimeText sampleText={sampleText ? sampleText:"World"}/&gt;;<br/>}</span></pre><p id="23de" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">然后，我们可以通过更新props来接受新的时间状态，从而将它传递给子组件TimeText:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="d32f" class="nd jh hu ns b fv nw nx l ny nz">return &lt;TimeText value={time}/&gt;;</span></pre><p id="f64e" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">这就是我们更新的计时器组件！</p><p id="a06d" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">现在我们只需要对我们的TimeText组件做一些小的改动，让<strong class="bd lb">接受新的道具</strong>。因为我们使用的是Typescript，所以我们的组件有一个<strong class="bd lb">接口</strong>。这定义了使用该组件的任何代码如何与之交互。因此，让我们将显示组件更新为:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="6af3" class="nd jh hu ns b fv nw nx l ny nz">export interface TimeTextProps {<br/>    value: number | undefined;<br/>}</span><span id="cf2f" class="nd jh hu ns b fv of nx l ny nz">export function TimeText({ value }: TimeTextProps): ReactElement {<br/>    return &lt;div&gt;{value} seconds&lt;/div&gt;;<br/>}</span></pre><blockquote class="mv mw mx"><p id="9c72" class="ke kf my bd b kg lc ki kj kk ld km kn mz le kq kr na lf ku kv nb lg ky kz la hn dt translated"><em class="hu">接口在这里似乎是不必要的，对于像这样的小部件来说，它们可能是必要的，但是对于</em> <strong class="bd lb"> <em class="hu">当项目变大时，它们是非常有用的</em> </strong> <em class="hu">。</em></p></blockquote><p id="b864" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">为了测试，我们可以打开Mendix Studio Pro并按下F4来同步更新或小部件。然后，我们需要设置页面，以便可以将数字属性传递给计时器小部件。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff og"><img src="../Images/739dbb3c3e9998b259cecf39c9e8f368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vhvDbOjDHxTsirp3.jpg"/></div></div></figure><p id="c331" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们<strong class="bd lb">点击运行</strong>并…我们的页面上只写着“秒”。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oh"><img src="../Images/39debd9f5ecfe988d315f41ea7fd1dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g5zkxs3DZFZkgIDz"/></div></div></figure><p id="3388" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">不要担心<strong class="bd lb">由于Mendix加载属性的方式</strong>，这是意料之中的。<strong class="bd lb">属性值是异步加载的</strong>，这使得Mendix前端如此之快，但这意味着我们需要额外的几行代码来让我们的小部件工作。</p><h2 id="c783" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">使用useEffect，但正确地</strong></h2><p id="06b3" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">我们让useEffect的第二个参数为空，<strong class="bd lb">这意味着useEffect函数在组件第一次挂载</strong>时运行一次，此时<strong class="bd lb">我们的属性值还没有准备好</strong>。</p><p id="dcb8" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><em class="my">如果您想检查这一点，请在If语句上方放置一个</em> <code class="eh oa ob oc ns b"><em class="my">console.log(`Render ${timeAtt.value}`)</em></code> <em class="my">并检查浏览器控制台(从浏览器中选择“Ctrl + Shift + i”)。</em></p><p id="4a12" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">因此，我们希望useEffect函数在timeAtt更新时运行，为此，我们只需将timeAtt添加到useEffect的第二个参数中。</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="4e62" class="nd jh hu ns b fv nw nx l ny nz">export function Timer({timeAtt}: TimerContainerProps):ReactElement {<br/>const [time, setTime] = useState&lt;number&gt;();</span><span id="cc5d" class="nd jh hu ns b fv of nx l ny nz">useEffect(() =&gt; {<br/>         if (timeAtt.value) {<br/>             setTime(timeAtt.value.toNumber());<br/>         }<br/>     }, [timeAtt]);<br/>    <br/>    return &lt;TimeText value={time}/&gt;;<br/>}</span></pre><p id="2ff9" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">如果您从Mendix重新运行应用程序，您将看到您的计时器值出现，如果您检查控制台日志，您将看到小部件呈现两次，一次是值未定义时，一次是数字。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/2c3f460d2fc26b02fe6135d9adf25d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*H5FhnWUL2QLN-AycdlYh0g.png"/></div></figure><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/a3119b9258291cf666ad2ecec21f9036.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*l60wNyYxrxQ_tTb2KYDXpA.png"/></div></figure><p id="daf3" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">成功！第1部分完成了！</p><h1 id="369e" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated"><strong class="ak">第二步</strong></h1><h2 id="31ca" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">以1秒为间隔减少计时器</strong></h2><p id="2ba5" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">酷毙了。所以我们在屏幕上显示了一个数字，但这并没有多大用处，<strong class="bd lb">我们希望我们的计时器倒计时</strong>。为此，我们将<strong class="bd lb">使用浏览器Javascript API，</strong>特别是<code class="eh oa ob oc ns b"><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" rel="noopener ugc nofollow" target="_blank">window.setTimeout()</a></code>，它会在固定时间后<strong class="bd lb">执行一项功能</strong>。</p><p id="663b" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">通过结合我们的老朋友useEffect，我们可以创建一个倒计时。如果我们让我们的useEffect函数依赖于我们的时间状态，并等待1秒钟来将我们的<strong class="bd lb">时间</strong>状态改变1秒钟，我们实际上创建了一个循环。</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="168d" class="nd jh hu ns b fv nw nx l ny nz">export function Timer({timeAtt}: TimerContainerProps):ReactElement {<br/>const [time, setTime] = useState&lt;number&gt;();</span><span id="1ca4" class="nd jh hu ns b fv of nx l ny nz">useEffect(() =&gt; {<br/>         if (timeAtt.value) {<br/>             setTime(timeAtt.value.toNumber());<br/>         }<br/>     }, [timeAtt]);</span><span id="4a0a" class="nd jh hu ns b fv of nx l ny nz">useEffect(() =&gt; {<br/>        if (time !== undefined) {<br/>             window.setTimeout(() =&gt; setTime(time - 1), 1000);<br/>        }<br/>    }, [time]);<br/>    <br/>    return &lt;TimeText value={time}/&gt;;<br/>}</span></pre><p id="bcab" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">但是这个计数会一直持续下去，所以我们需要再添加一个条件让它停止。</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="97bd" class="nd jh hu ns b fv nw nx l ny nz">useEffect(() =&gt; {<br/>        if (time !== undefined) {<br/>            if (time &gt; 0) {<br/>                window.setTimeout(() =&gt; setTime(time - 1), 1000);<br/>            }<br/>        }<br/>    }, [time]);</span></pre><p id="9744" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">如果我们重新加载我们的小部件，我们可以看到我们有倒计时。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/88ca9f969246270056901d2412e61832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2gucJEs6lOfX5JGm.gif"/></div></div></figure><blockquote class="mv mw mx"><p id="6e17" class="ke kf my bd b kg lc ki kj kk ld km kn mz le kq kr na lf ku kv nb lg ky kz la hn dt translated"><em class="hu">提醒您，如果您正在使用</em> <code class="eh oa ob oc ns b"><em class="hu">npm run start</em></code> <em class="hu">并观察您的小部件</em> <strong class="bd lb"> <em class="hu">上的变化，您需要清除缓存并刷新</em> </strong> <em class="hu">(在Chrome打开浏览器工具并右击刷新按钮)</em></p></blockquote><h1 id="261b" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated"><strong class="ak">第三步</strong></h1><h2 id="7a62" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">执行一个动作</strong></h2><p id="4e93" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">我们现在需要在倒计时到0的时候发生点什么！</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ok"><img src="../Images/d01a88c2ca318fc85cc44832122243e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tH_WI7UTPXR9QTGp.gif"/></div></div></figure><p id="84fb" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">幸运的是，Mendix提供了一个非常易用的API来与模型集成并执行一个动作。首先，我们更新Timer.xml以包含:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="1c38" class="nd jh hu ns b fv nw nx l ny nz">&lt;property key="action" type="action" required="true"&gt;<br/> &lt;caption&gt;Action&lt;/caption&gt;<br/>      &lt;description&gt;Action to trigger when the time elapses&lt;/description&gt;<br/>&lt;/property&gt;</span></pre><p id="d562" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">然后，我们可以添加一个函数来执行Timer.tsx上的操作，并更新useEffect函数来执行0处的操作。</p><p id="9210" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们最终的Timer.tsx应该是这样的:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="ac18" class="nd jh hu ns b fv nw nx l ny nz">export function Timer({ timeAtt, action }: TimerContainerProps): ReactElement {<br/>    const [time, setTime] = useState&lt;number&gt;();</span><span id="d8a8" class="nd jh hu ns b fv of nx l ny nz">useEffect(() =&gt; {<br/>        if (time !== undefined) {<br/>            if (time &gt; 0) {<br/>                window.setTimeout(() =&gt; setTime(time - 1), 1000);<br/>            } else {<br/>                execAction();<br/>            }<br/>        }<br/>    }, [time]);</span><span id="ba9d" class="nd jh hu ns b fv of nx l ny nz">useEffect(() =&gt; {<br/>        if (timeAtt.value) {<br/>            setTime(timeAtt.value.toNumber());<br/>        }<br/>    }, [timeAtt]);</span><span id="892e" class="nd jh hu ns b fv of nx l ny nz">const execAction = () =&gt; {<br/>        if (action &amp;&amp; action.canExecute) {<br/>            action.execute();<br/>        }<br/>    };</span><span id="3e95" class="nd jh hu ns b fv of nx l ny nz">return &lt;TimeText value={time} /&gt;;<br/>}</span></pre><p id="9af7" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们可以在我们的Mendix应用程序中测试这个新代码，方法是按下F4并选择要执行的操作。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ol"><img src="../Images/6d6f84bc54a65d61dabfed37857eb8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCQySl6B2RIzNb7Y8qpxYQ.png"/></div></div></figure><p id="fda7" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">通过选择调用刷新页面的微流，我们得到了重复计时器。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div class="fe ff om"><img src="../Images/d89edd03d73e6c9b0939fd9360c07c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*zPnWZ38CmHFMDsTT.jpeg"/></div></figure><h2 id="38e4" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated"><strong class="ak">最后一件事</strong></h2><p id="e865" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">当我们的组件首次加载时，有一小段时间传递给TimeText组件的时间值是未定义的。这不是一个大问题，因为它只是导致小部件呈现“秒”,但是给出一些值正在加载的指示是最佳实践。</p><p id="c72f" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">为此，我们将在React中使用一个通用模式进行条件呈现。</p><p id="234b" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">我们可以使用if语句来检查值是否尚未定义，并像这样显示loading:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="b3ee" class="nd jh hu ns b fv nw nx l ny nz">export function TimeText({ value }: TimeTextProps): ReactElement {<br/> if (value === undefined) {<br/>  return &lt;div&gt;Loading&lt;/div&gt;;<br/> } else {<br/>  return &lt;div&gt;{value}&lt;/div&gt;;<br/> }<br/>}</span></pre><p id="61a2" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">但是这个很啰嗦。<strong class="bd lb">我们可以用</strong> <a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lb">的三元运算符从ES6 </strong> </a>中将其简化为:</p><pre class="mp mq mr ms fq nr ns nt nu aw nv dt"><span id="15e9" class="nd jh hu ns b fv nw nx l ny nz">export function TimeText({ value }: TimeTextProps): ReactElement {<br/>    return value ? &lt;div&gt;{value} seconds&lt;/div&gt; : &lt;div&gt;Loading&lt;/div&gt;;}</span></pre><p id="7809" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">瞧啊。</p><figure class="mp mq mr ms fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/d3201ee5b175e93af1e1e6649211f911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xVPpMt1iVgIlgegQeh1d2A.gif"/></div></div></figure><h1 id="45de" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated"><strong class="ak">总结</strong></h1><p id="3835" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">恭喜，您构建了一个可插拔的小部件！</p><p id="1ffc" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">在这个版本中，我们介绍了可插拔小部件API，如何从Mendix模型中获取数据并更改它；讲述了如何使用Typescript来更好地理解如何与我们的Mendix应用程序集成，重温了关键的React概念，并学习了如何在小部件中执行来自Mendix模型的操作。</p><p id="0724" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">此小部件的最终状态可在此处找到:</p><div class="lh li fm fo lj lk"><a href="https://github.com/joe-robertson-mx/timer" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">GitHub -乔-罗伯逊-MX/定时器</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">我的widget描述][功能亮点][逐步说明][沙盒链接GitHub问题链接]…</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">github.com</p></div></div><div class="lt l"><div class="on l lv lw lx lt ly ja lk"/></div></div></a></div><p id="8edc" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">接下来，我们将使用Mendix和可插拔小部件构建看板，以了解如何组合小部件来创建流畅的最终用户体验，以及如何在您的Mendix数据库中进行持久的更改。</p><p id="2d72" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">如果你有任何自己开发的很酷的小部件想要分享，你在开发中遇到的挑战，或者你想在这个系列中看到的东西，请<strong class="bd lb">在</strong>下面留言！</p><h2 id="7483" class="nd jh hu bd ji ne nf ng jm nh ni nj jq ko nk nl ju ks nm nn jy kw no np kc nq dt translated">阅读更多</h2><div class="lh li fm fo lj lk"><a href="https://docs.mendix.com/apidocs-mxsdk/apidocs/pluggable-widgets/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">可插拔小部件API</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">理解插件的指南。</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lh li fm fo lj lk"><a href="https://docs.mendix.com/apidocs-mxsdk/apidocs/pluggable-widgets/#widget-definition" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">可插拔小部件API</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">理解插件的指南。</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lh li fm fo lj lk"><a href="https://docs.mendix.com/apidocs-mxsdk/apidocs/pluggable-widgets-property-types/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">可插入小部件属性类型</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">理解可插拔部件属性类型的指南。</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lh li fm fo lj lk"><a href="https://docs.mendix.com/apidocs-mxsdk/apidocs/pluggable-widgets-client-apis/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab ej"><div class="lm ab ln cl cj lo"><h2 class="bd hv fv z el lp eo ep lq er et ht dt translated">可插拔小部件可用的客户端API</h2><div class="lr l"><h3 class="bd b fv z el lp eo ep lq er et ek translated">理解可插拔小部件可用的客户端API的指南。</h3></div><div class="ls l"><p class="bd b gc z el lp eo ep lq er et ek translated">docs.mendix.com</p></div></div></div></a></div></div><div class="ab cl oo op hb oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="hn ho hp hq hr"><p id="523c" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><em class="my">来自发布者- </em></p><p id="dcd4" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><em class="my">如果你喜欢这篇文章，你可以在我们的</em> <a class="ae mi" href="https://medium.com/mendix" rel="noopener"> <em class="my">中页</em> </a> <em class="my">找到更多喜欢的。对于精彩的视频和直播会话，您可以前往</em><a class="ae mi" href="https://www.mendix.com/live/" rel="noopener ugc nofollow" target="_blank"><em class="my">MxLive</em></a><em class="my">或我们的社区</em><a class="ae mi" href="https://www.youtube.com/c/MendixCommunity/community" rel="noopener ugc nofollow" target="_blank"><em class="my">Youtube PAG</em></a><em class="my">e .</em></p><p id="f60c" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated"><em class="my">希望入门的创客，可以注册一个</em> <a class="ae mi" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="my">免费账号</em> </a> <em class="my">，通过我们的</em> <a class="ae mi" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="my">学苑</em> </a> <em class="my">获得即时学习。</em></p><p id="3a28" class="pw-post-body-paragraph ke kf hu bd b kg lc ki kj kk ld km kn ko le kq kr ks lf ku kv kw lg ky kz la hn dt translated">有兴趣加入我们的社区吗？加入我们的 <a class="ae mi" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="my">松弛社区频道</em> </a> <em class="my">。</em></p></div></div>    
</body>
</html>