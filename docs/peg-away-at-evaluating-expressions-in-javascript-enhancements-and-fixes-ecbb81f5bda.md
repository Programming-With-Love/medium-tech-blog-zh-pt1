# 专注于评估 JavaScript 中的表达式——增强和修复

> 原文：<https://medium.com/globant/peg-away-at-evaluating-expressions-in-javascript-enhancements-and-fixes-ecbb81f5bda?source=collection_archive---------0----------------------->

关于使用解析表达式语法评估 JavaScript 中表达式的进一步思考和经验

![](img/d2e47ec7dd9bcfeaee11e4178086a633.png)

Photo by [Joshua Sortino](https://unsplash.com/@sortino?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

不久前，正如我在 JavaScript 中的文章 [*PEG away 中所描述的，我们使用解析表达式语法(PEG)来验证和评估涉及数字、变量和函数的数学公式。*](/globant/peg-away-at-evaluating-expressions-in-javascript-15159511fa97)

[](/globant/peg-away-at-evaluating-expressions-in-javascript-15159511fa97) [## 专注于计算 JavaScript 中的表达式

### 通过使用解析表达式语法，以简单而强大的方式安全地评估 JavaScript 中的表达式

medium.com](/globant/peg-away-at-evaluating-expressions-in-javascript-15159511fa97) 

在将代码付诸实践后，一些增强的想法出现了，并且(喘息！)几个 bug！我们甚至发现，Excel 的规则有时与正常的算术规则不同，因此我们必须添加一些更改，以获得错误的(但在 Excel 的“眼中”是正确的)结果。

在本文中，我们将看到我们如何进一步修改我们的 PEG，以包括简化和修正，并展示我们增强的公式评估代码；我们开始吧！

# 修复:变量名

我们添加的第一个补丁很简单。我们最初对变量名的定义(见下文)实际上允许像`220960`这样的名字——这在大多数(all？)语言。此外，大写字符没有包含在定义中，所以像`returnOnInvestment`这样的变量不会被识别。

修复很简单:我们定义第一个字符(`char1`，如下)必须是一个下划线或字母(小写或大写),其后可以是更多的下划线、字母或数字。

这种改变既简单又快速，添加更多允许的字符将是微不足道的。让我们继续，以避免一些不必要的转换，我们已经包括在几个地方。

# 简化:数字处理

我们做的下一个改变与数字处理有关。在我们的第一个版本中，我们在很多地方加入了`Number()`转换，来处理字符串到数字的转换。

在与用户讨论这个问题后，他们同意不应该对字符串进行数学运算，也不需要，如果需要的话，那么应该实现 Excel 的 [VALUE()函数](https://support.microsoft.com/en-us/office/value-function-257d0108-07dc-437d-ae1c-bc2d3953d8c2)。变化本身就是简单。

坦白说:在检查`Number()`的用法时，我们发现它的用法并不一致，有些地方我们漏掉了……*现在*没事了！

接下来，我们决定尝试获得更清晰的语法。

# 增强:使用令牌名称

我们做的下一个改变是一个简单的重构:我们没有在所有的语法规则中混合标记和字符串，而是决定在任何地方都使用标记。第一步是为单个字符(如`CARET`和`COMMA`)、集合(如`DIGIT`和`LETTER`)以及特定字符串(如`LOG10`和`TRUE`)定义令牌。

下一步很简单；我们只是修改了所有现有的规则来使用这些令牌。例如，我们从

到下面的代码；变化基本上是微不足道的，只是一个“查找和替换”的问题。

这本身并没有给语言或函数的计算带来任何变化，但是让代码变得更加清晰。然而，仍然有一些我们不喜欢的东西…那些到处显示空白的下划线使得规则有点太长，所以我们决定继续努力。

# 简化:空白空间处理

至于空位，我们的规则很简单；基本上大多数标记的前面或后面都可以有空格。我们没有添加这么多作品，而是决定每个标记或符号将“吞噬”它后面的任何空白空间。当然，有些符号(比如数字中的句号)不允许有空格；我们考虑到了这一点。我们通过在名称中添加下划线来重命名允许空格的标记。让我们看看这里的一些变化。

更新后的规则(如上所示)如下所示。

不错！规则变得更短更清晰，所以我们认为这是一个胜利。然而，就在这个时候，一件不太好的事情突然出现了；一些公式产生了错误的结果！

# 修正:数学左联想

让我们看看社交网络中经常出现的一个谜题:24/4/2 是什么？做 24/4=6，再做 6/2=3，就找到了正确答案；另一种说法是除法运算符是*左关联*。(乘法运算符也是左关联的，但是如果将 24 乘以 4 乘以 2 计算为(24 乘以 4)乘以 2，或者计算为 24 乘以(4 乘以 2)，结果是相同的。)然而，我们的联系汇率有一个问题；我们来复习一下。

中间的规则是 24/4/2 应该被解释为 24 除以另一个表达式(4/2 ),所以我们得到的不是 3 而是 12。我不想输入太多的细节，但是使用[上下文无关语法](https://en.wikipedia.org/wiki/Context-free_grammar)我们可以通过左递归定义来解决这个问题，或者通过应用[左递归去除算法](https://en.wikipedia.org/wiki/Left_recursion)来使语法变得更复杂。然而，PEG 提供了一种更简单的方法，如下所示。

这个语法规则说一个`EXP_PD`以一个`EXP_X`开始，后面是零对或多对乘法或除法记号和另一个`EXP_X`。使用 JavaScript 的`.reduce()`方法让我们从左到右计算表达式，正如所料。

对了，我们还用同样的方法固定了减法:6–3–2 应该解释为(6 减 3)减 2，而不是 6 减(3 减 2)。

这两个错误只是在特定的测试之后才浮出水面。幸运的是，用户没有编写过有这些问题的公式，所以我们躲过了一劫——但是修复后的代码肯定消除了 bug，并且展示了其他强大的 PEG 特性。

# 增强:逻辑常数

下一次增强是因为用户对 Excel 的熟悉；他说你不必写`TRUE()`,因为括号是可选的；`TRUE`也是一样。在检查了文档之后，我们知道我们必须修复它，但幸运的是这很容易。我们只需重写之前的`TRUE()`和`FALSE()`规则，如下所示:

在新规则中，我们做了一个小小的语法改变，使括号成为可选的。

这里，括号对是可选的；他们可能都在场，也可能都不在场。我们以为我们已经对公式有了一个很好的最终定位，但是一个新的问题出现了:Excel 不能像预期的那样进行数学运算！

# 修复:Excel/算术差异

用我们的评估器和 Excel 做实验显示了一些问题。第一，[根据数学规则](https://en.wikipedia.org/wiki/Order_of_operations#Serial_exponentiation)，2^3^2 应该被评价为 2^(3^2)，或者 2⁹，所以 512。但是，Excel 是从左到右计算的，所以结果应该是(2^3)^2，或 64。这个问题的解决方案类似于我们对除法和减法所做的。

我们最初的定义是右结合的；通过使用与前面相同的风格，我们从左到右做幂运算。有了这个`EXP_X`的替代定义，现在结果与 Excel 的一致。但是我们发现了另一个不同点！

-2^2 是什么？这按照通常的规则应该理解为-4 [，但是 Excel 评估如果是(-2)^2，所以结果是 4。在这种情况下，我们的公式评估员给出了正确的(Excel)结果，但在我们看来是错误的！如果我们修复它(如下所示),结果将与 Excel 的不匹配，但我们也希望有一个完全符合算术规则的评估器；一个语法可以表现为两种不同的方式。](https://en.wikipedia.org/wiki/Order_of_operations#Unary_minus_sign)

我们使用的 [peg.js 库](https://pegjs.org/)允许我们拥有它，通过使用[一种特殊的检查](https://pegjs.org/documentation#grammar-syntax-and-semantics)。首先，我们在文件的顶部添加了一个常量。

如果`EXCEL_STYLE`为真，我们的评估者将以 Excel 的方式行事；如果我们将其设置为 false，它将遵循正常的算术规则。然后我们重写了`VALUE`和`EXP_X`规则以依赖`EXCEL_STYLE`。

只有当`EXCEL_STYLE`为真时，才会考虑以`& { return EXCEL_STYLE; }`开头的行；相反，只有当`EXCEL_STYLE`为假时，才会考虑以`! { return EXCEL_STYLE; }`开头的行。你也可以用另一种方式重写规则。

有了这最后的改变，我们有了一个可以双向工作的公式计算器:根据 Excel 的规则，或者根据标准的算术规则。我们发现，如果需要进行标准评估，我们已经有了所需的解决方案，实现起来并不难。

# 代码的最终版本

经过这么多的修改，代码长度是以前的两倍(149 行而不是 77 行),但是我们认为它更清晰了(希望如此！！)无 bug。

我们还开发了许多单元测试(这里没有显示),以便验证我们的更改没有破坏任何东西，现在我们对最终结果有了更多的信心——但是如果您发现任何问题，请让我们知道；记住，测试只能证明你是错的，永远不能证明你是对的！

# 摘要

在“完成”我们的算术表达式求值器之后，我们提出了一些改进，也提出了一些对特定问题的修复。我们的最终结果越来越清晰(或者说我们是这样认为的！)和灵活性(允许我们容易地表示公式求值的两种可选方式)。我们应用了 PEG 库的新特性，我们觉得这些变化并不难实现或理解。现在我们只需要等待用户的意见和新的要求！