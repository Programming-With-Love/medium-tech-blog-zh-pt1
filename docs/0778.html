<html>
<head>
<title>RenderNode for Bigger, Better Blurs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渲染节点获得更大、更好的模糊效果</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/rendernode-for-bigger-better-blurs-ced9f108c7e2?source=collection_archive---------5-----------------------#2022-11-23">https://medium.com/androiddevelopers/rendernode-for-bigger-better-blurs-ced9f108c7e2?source=collection_archive---------5-----------------------#2022-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="107d" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">RenderEffects #3:使用RenderNode实现更快、更好的模糊效果</h2></div><p id="f59f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">前两篇文章(更详细，用更多的话)涵盖了我在视频<a class="ae js" href="https://youtu.be/qlBxrvhk3tg" rel="noopener ugc nofollow" target="_blank">中快速谈论的内容，该视频是我与Sumir Kataria为最近的</a><a class="ae js" href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc92MGTd1CgUtXZfhA74nUpb" rel="noopener ugc nofollow" target="_blank"> Android开发者峰会</a>活动制作的。这篇文章超出了这一内容，尽管我在最近伦敦Droidcon的一次会议结束时确实提到了它。因此，如果你想要这个(和以前的)内容的视频版本，在这里你去:</p><div class="jt ju ez fb jv jw"><a href="https://www.droidcon.com/2022/11/15/android-graphics-blurring-the-lines/" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hi fi z dy kb ea eb kc ed ef hg bi translated">安卓图形:模糊界限</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">本次会议将介绍Android上支持更丰富应用的最新图形API和功能。模糊…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">www.droidcon.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk kl jw"/></div></div></a></div><p id="9a79" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae js" rel="noopener" href="/androiddevelopers/agsl-made-in-the-shade-r-7d06d14fe02a">的上一篇文章</a>中，我展示了如何创建一个磨砂玻璃效果，它模糊并照亮了一个<code class="du km kn ko kp b">ImageView</code>的一个子部分，使图片标题更具可读性。以下是放大的字幕图像出现在模糊的背景图像库中的结果:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/d219e466e0ce48ffd8608da517ca48ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXU2Nm9K0SqlPGNjn_Rrlw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">The caption is drawn with a shader which both blurs and frosts that area</figcaption></figure><p id="fb1f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是标题区域中使用的模糊虽然有效且可用，但既不像我们通过使用平台的内置<code class="du km kn ko kp b">RenderEffect</code>模糊所能获得的那样好(因为它不是那么模糊)也不像我们通过使用平台的内置<code class="du km kn ko kp b">RenderEffect</code>模糊所能获得的那样快(正如本系列的第一篇文章中所解释的，它已经被用于上面图片库的背景模糊)。如果能有一个更快、更模糊的版本当然更好，这样有助于突出文字所在的区域，就像我们在上面看到的单词“Ceiling”的末尾，黑色文字位于图片中其他深色硬边对象的顶部。</p><p id="c00f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我没有使用“最佳”模糊方法的原因是…如何做到这一点并不直观，我正在优化清晰的代码和技术。但是现在这些都已经解决了(在上一篇文章中)，我还想展示如何使用内置的更好的模糊效果来实现同样的效果。</p><h1 id="1a45" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">问题</h1><p id="fc4b" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">模糊+冰霜效果不直接的原因归结于一个事实，我只想给放大的图片出现的<code class="du km kn ko kp b">ImageView</code>部分加阴影。也就是说，我只想模糊/磨砂底部的标签区域，而不是整个视图。然而<code class="du km kn ko kp b">RenderEffect</code>适用于<em class="mc">整个</em>视图；没有办法只将效果裁剪到视图的一部分。因此，当我对持有放大图片的<code class="du km kn ko kp b">ImageView</code>应用<code class="du km kn ko kp b">RenderEffect</code>模糊和磨砂玻璃着色器时，代码如下:</p><pre class="kr ks kt ku fd md kp me mf aw mg bi"><span id="9432" class="mh lg hh kp b fi mi mj l mk ml"><strong class="kp hi">val </strong>blur = RenderEffect.createBlurEffect(<br/>        30f, 30f, Shader.TileMode.<em class="mc">CLAMP</em>)<br/><strong class="kp hi">val </strong>shader = RenderEffect.createRuntimeShaderEffect(<br/>        <strong class="kp hi">FROSTED_GLASS_SHADER</strong>, <strong class="kp hi">"inputShader"</strong>)<br/><strong class="kp hi">val </strong>chain = RenderEffect.createChainEffect(blur, shader)<br/>setRenderEffect(chain)</span></pre><p id="25d1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我得到这样的结果:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mm"><img src="../Images/c9b5944b152f6a14f55a7abce08115d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnc32sjFs39V8aCA2xiJQw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">Applying a RenderEffect blur to a view blurs the entire view, which is… not what I wanted</figcaption></figure><p id="0366" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种更明显的模糊对于更好地突出说明文字来说是很好的，但是对于其他的东西来说……就很糟糕了。用户可能希望看到图片细节，而超级模糊没有帮助。但是只有一部分视图变得模糊和模糊，这对我们当前的API来说是不明显的。</p><h2 id="a9dd" class="mh lg hh bd lh mn mo mp ll mq mr ms lp jf mt mu lr jj mv mw lt jn mx my lv mz bi translated">好吧，用一个单独的视图怎么样？</h2><p id="6d66" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">你可能有理由怀疑(就像我第一次开发这个应用时一样)为什么我不能简单地依靠视图层次来帮助解决问题。也就是说，我可以使用一个大小适合标题边界的单独视图，位于<code class="du km kn ko kp b">ImageView</code>的底部，就像现有的保存标题的<code class="du km kn ko kp b">TextView</code>一样，而不是在更大的<code class="du km kn ko kp b">ImageView</code>对象中给标签区域加阴影。</p><p id="fd55" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，我可以直接使用<code class="du km kn ko kp b">TextView</code>本身。然后我可以模糊/冻结那个视图，而不是<code class="du km kn ko kp b">ImageView.</code>嗯…是的。不。我的意思是，我肯定<em class="mc">可以</em>遮蔽<code class="du km kn ko kp b">TextView</code>并得到类似的效果。差不多吧。但这也将效果应用于文本；着色器是在<code class="du km kn ko kp b">View</code>将其所有内容渲染到视图中之后运行的——包括这里的文本——所以我最终得到了这样的结果:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es na"><img src="../Images/82f914e6610fbed03b217679664dc424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjaiFldNuRuELgyN0dCf7A.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">The caption effect is now being done directly in the TextView. (But it’s not being done well).</figcaption></figure><p id="f626" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您仔细观察标签区域，与我们对底层ImageView的一部分进行阴影处理所获得的效果相比，会有一些问题。提醒一下，下面是<em class="mc">应该是</em>的样子:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nb"><img src="../Images/301ef10d5ac8a5a6a98d92cfc3eaad64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Evbo-jTzEGmyJ7xlb7LoQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">The caption effect as it should be (shader applied to underlying ImageView)</figcaption></figure><p id="d7b4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最明显的问题是标题文本。在上面的第一张图片中，字母被洗掉了。这来自于效果应用于整个<em class="mc">文本视图的问题，包括文本字符。这种给<code class="du km kn ko kp b">TextView</code>加阴影的方法直接导致了模糊的、磨砂的文本，这并不是我们真正想要的。</em></p><p id="9ab2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一个问题稍微微妙一点，但是如果你观察标题区域右边的三角形网格窗口，你会发现它非常明显。在图像的正确版本中，该区域明显(如果只是轻微)模糊，而当我们在<code class="du km kn ko kp b">TextView</code>上使用着色器时，它一点也不模糊。发生这种情况是因为着色器效果仅在应用它的视图的像素上运行，而不是在显示器上那些像素下出现的任何东西上运行。因此，虽然从你的视角来看<em class="mc">看起来</em>像是应该遮蔽那些图像像素，但那是因为它们在显示器上被渲染成一个在另一个之上。但是在渲染器级别，每个视图的内容是独立创建的，仅基于该视图，而不考虑绘制时它们将位于什么之上。</p><p id="153a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，当我们将着色器应用于透明背景<code class="du km kn ko kp b">TextView</code>时，实际上唯一模糊的是文本。该视图中的透明像素只是…保持透明。这种效果的全部原因是为了让文本<em class="mc">更具可读性，所以这种方法显然是把事情引向了错误的方向。</em></p><p id="34f1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我上面提到的另一个想法，在底层的<code class="du km kn ko kp b">ImageView</code>和最顶层的<code class="du km kn ko kp b">TextView</code>之间插入一个新视图，也会因为类似的原因而失败。虽然这种技术可以避免在对<code class="du km kn ko kp b">TextView</code>进行着色时出现模糊的文本伪影，但它仍然没有正确的图像数据来应用模糊(因为中间视图不包含图像数据)，因此不会出现可见的模糊。着色器将应用于占位符视图中的任何颜色(大概是透明像素，就像上面的<code class="du km kn ko kp b">TextView</code>示例中的情况)。</p><p id="8b62" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于中间视图，我们还可以做另外一件事，我们在其中绘制放大图像的裁剪副本，从而给着色器一些东西来正确地进行模糊和磨砂。这是可行的，原因和在ImageView中一样。我们不需要原始着色器的裁剪逻辑，因为我们正在对该视图中的所有像素进行着色。但是手动裁剪照片，然后将复制的副本重绘到另一个视图中，以获得这种效果，这似乎是一种黑客行为。</p><p id="22a6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也许有更好的方法…</p><h1 id="6894" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">更好的方法…使用<code class="du km kn ko kp b">RenderNode</code></h1><p id="436e" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">我真正想做的(也是我第一次写演示应用时尝试过但失败了的)是将效果链接在一起。也就是说，我想要一个使用系统模糊的<code class="du km kn ko kp b">RenderEffect</code>，通过<code class="du km kn ko kp b">RenderEffect.createBlurEffect()</code>，和我在底层图库容器中使用的一样。然后我想要第二个效果来应用一个磨砂玻璃着色器(没有应用我当前着色器中的框模糊)，用<code class="du km kn ko kp b">RenderEffect.createRuntimeShaderEffect()</code>创建。然后我可以使用<code class="du km kn ko kp b">RenderEffect.createChainedEffect()</code>合成这些效果，告诉系统一起应用这两种效果，一个接一个。</p><p id="a5c8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个<em class="mc">几乎</em>起作用…但是没有办法指定标签的裁剪区域，所以它只是给整个放大的图像一个模糊/磨砂的外观。再说一次，那不是我想要的表情。</p><p id="a813" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我不能使用连锁效应。但是我可以通过使用两个<code class="du km kn ko kp b">RenderNode</code>对象手动应用效果来做类似的事情。</p><p id="da5b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，我们已经对整个<code class="du km kn ko kp b">View</code>应用了我们的着色器。这是很强大的，但是有上面解释的限制，效果应用于整个视图。因此，如果我想要一个效果(如模糊)只应用选择性，或有条件的，这是不可能的。或者说，这是可能的，但只有在使用像我在当前模糊+霜冻着色器中使用的着色器逻辑时，它才会检查当前像素的位置，并适当地运行或跳过效果。但是这种逐像素的逻辑方法对于其他的<code class="du km kn ko kp b">RenderEffect</code>是不可能的(模糊、链等)。</p><p id="2f81" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，相反，我可以将效果应用到<code class="du km kn ko kp b">RenderNode</code>对象而不是<code class="du km kn ko kp b">View</code>对象，并使用那些<code class="du km kn ko kp b">RenderNode</code>对象有选择地绘制到视图中，从而达到对<code class="du km kn ko kp b">View</code>的子集进行着色的目的。<code class="du km kn ko kp b">RenderNode</code>和<code class="du km kn ko kp b">View</code>有相同的<code class="du km kn ko kp b">setEffect()</code> API，所以这种方法的设置非常相似。</p><p id="2298" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是等等——什么是<code class="du km kn ko kp b">RenderNode</code>？</p><h1 id="5bed" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">RenderNode:视图如何绘制它们的内容</h1><p id="a2d7" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">引用<code class="du km kn ko kp b">RenderNode</code>上的参考文件:</p><blockquote class="nc"><p id="4175" class="nd ne hh bd nf ng nh ni nj nk nl jr dx translated">默认情况下，RenderNodes在内部用于所有视图，通常不会直接使用。</p></blockquote><p id="239b" class="pw-post-body-paragraph iw ix hh iy b iz nm ii jb jc nn il je jf no jh ji jj np jl jm jn nq jp jq jr ha bi translated">哦，不，等等——这不是我要粘贴的内容(我们肯定会直接使用它)。这里，这样更好:</p><blockquote class="nc"><p id="10b8" class="nd ne hh bd nf ng nh ni nj nk nl jr dx translated">RenderNode用于构建硬件加速渲染层次。</p></blockquote><p id="cf86" class="pw-post-body-paragraph iw ix hh iy b iz nm ii jb jc nn il je jf no jh ji jj np jl jm jn nq jp jq jr ha bi translated">每个<code class="du km kn ko kp b">View</code>对象在其内容出现在屏幕上之前的某个时间点，记录绘制其内容的操作和属性，以交付给低级渲染器(Skia)。它通过<code class="du km kn ko kp b">RenderNode</code>实现这一点，从API级别29开始，它被公开为您可以直接使用的公共API。也就是说，您可以在一个<code class="du km kn ko kp b">RenderNode</code>中缓存命令，然后手动绘制该节点，通常是到一个<code class="du km kn ko kp b">View</code>。</p><p id="9b9c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你通常可以通过将你的绘图命令记录到一个<code class="du km kn ko kp b">RecordingCanvas</code>中来做到这一点，你可以通过<code class="du km kn ko kp b">RenderNode.recordingCanvas()</code>得到这个命令。然后你可以像绘制一个典型的<code class="du km kn ko kp b">Canvas</code>对象一样绘制到那个<code class="du km kn ko kp b">Canvas</code>，只是现在你的绘制命令存储在<code class="du km kn ko kp b">RenderNode</code>中。然后，您可以通过调用<code class="du km kn ko kp b">Canvas.drawRenderNode()</code>将该节点(包含您存储的那些命令)呈现到一个<code class="du km kn ko kp b">View</code>中。</p><p id="6f32" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，回到我们的模糊+着色器示例:想法是使用两个不同的<code class="du km kn ko kp b">RenderNode</code>对象，一个渲染底层图像内容，一个保存模糊该内容的<code class="du km kn ko kp b">RenderEffect</code>。每一个都将被分别绘制到<code class="du km kn ko kp b">View</code>中，并且可以被定位到我们想要的位置来绘制效果，这将给我们带来我们想要的<code class="du km kn ko kp b">RenderEffect</code>的裁剪/定位能力。</p><p id="d108" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看这是如何工作的。</p><h1 id="0735" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">使用多个RenderNodes绘制</h1><p id="225e" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">首先，我们创建并缓存两个<code class="du km kn ko kp b">RenderNode</code>对象，每当视图本身被绘制时，它们将被重用(重绘):</p><pre class="kr ks kt ku fd md kp me mf aw mg bi"><span id="a13e" class="mh lg hh kp b fi mi mj l mk ml"><strong class="kp hi">val contentNode </strong>= RenderNode(<strong class="kp hi">"image"</strong>)<br/><strong class="kp hi">val blurNode </strong>= RenderNode(<strong class="kp hi">"blur"</strong>)</span></pre><p id="f6eb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mc">(注:</em><code class="du km kn ko kp b"><em class="mc">“image”</em></code><em class="mc"/><code class="du km kn ko kp b"><em class="mc">“blur”</em></code><em class="mc">无意义或再次提及；它们被记录为用于调试目的，大概是在内部，因为在它们被传入之后，没有办法从对象中访问那些属性。)</em></p><p id="da4d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们需要在将出现这些内容的<code class="du km kn ko kp b">ImageView</code>中覆盖<code class="du km kn ko kp b">onDraw()</code>方法。覆盖<code class="du km kn ko kp b">onDraw()</code>的目的是在我们绘制视图内容的时候注入<code class="du km kn ko kp b">RenderNode</code>代码。通常在<code class="du km kn ko kp b">onDraw()</code>中，我们可能首先调用超类的<code class="du km kn ko kp b">onDraw()</code>方法来绘制<code class="du km kn ko kp b">View</code>中的标准内容。但是在这种情况下，我们想要创建一个<code class="du km kn ko kp b">RenderNode</code>来保存该内容，所以我们将在那里绘制它，然后使用它作为从到<code class="du km kn ko kp b">View</code>的源:</p><pre class="kr ks kt ku fd md kp me mf aw mg bi"><span id="70b7" class="mh lg hh kp b fi mi mj l mk ml"><strong class="kp hi">override fun </strong>onDraw(canvas: Canvas?) {<br/><br/>    <strong class="kp hi">contentNode</strong>.setPosition(0, 0, <em class="mc">width</em>, <em class="mc">height</em>)<br/><em class="mc">    </em><strong class="kp hi">val </strong>rnCanvas = <strong class="kp hi">contentNode</strong>.beginRecording()<br/>    <strong class="kp hi">super</strong>.onDraw(rnCanvas)<br/>    <strong class="kp hi">contentNode</strong>.endRecording()<br/><br/>    canvas?.drawRenderNode(<strong class="kp hi">contentNode</strong>)<br/>    <br/>    // ... rest of code below<br/>}</span></pre><p id="6070" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面有几件事需要注意:首先，我们创建了一个<code class="du km kn ko kp b">RecordingCanvas</code>，然后要求超类(<code class="du km kn ko kp b">ImageView</code>)在画布中进行绘制。然后我们通过调用<code class="du km kn ko kp b">drawRenderNode()</code>将内容复制到视图画布中。这避免了多次调用超类<code class="du km kn ko kp b">onDraw()</code>方法，这是一个很好的实践，以防该方法中有额外的开销，这可以通过使用<code class="du km kn ko kp b">RenderNode</code>对象中命令的缓存版本来避免。</p><p id="eb32" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其次，请注意，如果我经常从那个节点重绘，出于速度和效率的目的，我可以在<code class="du km kn ko kp b">RenderNode</code>上调用<code class="du km kn ko kp b">setUseCompositingLayer()</code>。合成层将绘图缓存为位图(作为GPU中的纹理)，未来的绘图操作将是简单的位图(纹理)副本，速度非常快。代价是该纹理消耗了额外的内存。在这种情况下，我只画了两次<code class="du km kn ko kp b">RenderNode</code>;一次是对视图本身(在上面的代码中)，第二次是对另一个模糊的视图<code class="du km kn ko kp b">RenderNode</code>(在下面的代码中)。仅仅为了一个额外的绘制操作而缓存节点是不值得的。但是对于你自己的<code class="du km kn ko kp b">RenderNode</code>对象来说，这是值得考虑的，这取决于你如何处理它们的内容。</p><p id="0192" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们执行模糊。我们通过从主节点<code class="du km kn ko kp b">RenderNode</code>绘制到模糊节点，并进行适当的转换来实现这一点。这个模糊的节点上设置了一个模糊<code class="du km kn ko kp b">RenderEffect</code>，其位置和大小正好是我们想要模糊的标签区域。</p><pre class="kr ks kt ku fd md kp me mf aw mg bi"><span id="e435" class="mh lg hh kp b fi mi mj l mk ml"><strong class="kp hi">    </strong>// ... rest of code above</span><span id="6017" class="mh lg hh kp b fi nr mj l mk ml"><strong class="kp hi">    blurNode</strong>.setRenderEffect(RenderEffect.createBlurEffect(30f, 30f,<br/>        Shader.TileMode.<em class="mc">CLAMP</em>))<br/>    <strong class="kp hi">blurNode</strong>.setPosition(0, 0, <em class="mc">width</em>, 100)<br/>    <strong class="kp hi">blurNode</strong>.<em class="mc">translationY </em>= <em class="mc">height </em>- 100f<br/><br/>    <strong class="kp hi">val </strong>blurCanvas = <strong class="kp hi">blurNode</strong>.beginRecording()<br/>    blurCanvas.translate(0f, -(<em class="mc">height </em>- 100f))<br/>    blurCanvas.drawRenderNode(<strong class="kp hi">contentNode</strong>)<br/>    <strong class="kp hi">blurNode</strong>.endRecording()<br/><br/>    canvas?.drawRenderNode(<strong class="kp hi">blurNode</strong>)<br/>}</span></pre><p id="012b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这段代码设置了模糊<code class="du km kn ko kp b">RenderEffect</code>，在x和y方向的模糊半径为30(比我早期的着色器方法中微不足道的5x5框模糊要好得多)。请注意，<code class="du km kn ko kp b">setPosition</code>创建了一个比前面的<code class="du km kn ko kp b">contentNode</code>小得多的尺寸，因为我们只需要这个更小的区域来放置标题。还要注意的是，<code class="du km kn ko kp b">translationY</code>操作将渲染移动到整个视图的底部，这是模糊字幕所在的位置。</p><p id="f4ae" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们再次从这个节点获得一个<code class="du km kn ko kp b">RecordingCanvas</code>。在我们绘制之前(使用<code class="du km kn ko kp b">contentNode</code>，我们从标题位置反向翻译到图像的顶部；这确保了在较小的/翻译后的标题区域下，内容对于较大的图像是正确定位的。最后，一旦<code class="du km kn ko kp b">blurNode</code>绘制完成，我们再调用一次<code class="du km kn ko kp b">drawRenderNode()</code>，将结果渲染到视图的画布中(在来自<code class="du km kn ko kp b">contentNode</code>的现有内容之上),我们就完成了。</p><p id="aa97" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是最终结果。它非常接近我们最初的样子，但是你可以看到标签区域的模糊更加明显，这有助于标题文本的可读性。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ns"><img src="../Images/1c77c894003a7ce530828e85de9ba470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uknfb1wN9bC-ANGSvsNJGQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">Better blur in the label by combining a RenderEffect blur in addition to frosted-glass shader, with two RenderNodes.</figcaption></figure><h1 id="de0e" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">…就是这样！</h1><p id="1629" class="pw-post-body-paragraph iw ix hh iy b iz lx ii jb jc ly il je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">这是当前系列的结尾(尽管我保留在未来写更多着色器和<code class="du km kn ko kp b">RenderEffect</code>文章的选择。不承诺)。我们设法用系统模糊来获得一个模糊背后的效果，帮助从背景中弹出一个图像。然后，我们添加了AGSL着色器逻辑来增强图像标题的视觉效果。最后，我们使用了<code class="du km kn ko kp b">RenderNode</code>来利用系统模糊来获得更好(更快！)效果，并简化AGSL着色器逻辑以简单地提供磨砂玻璃效果。</p><p id="e4cb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想了解这方面的更多信息，有很多资源可供参考。以下是一些开始:</p><ul class=""><li id="888d" class="nt nu hh iy b iz ja jc jd jf nv jj nw jn nx jr ny nz oa ob bi translated"><code class="du km kn ko kp b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RenderEffect" rel="noopener ugc nofollow" target="_blank">RenderEffect</a></code>:用于创建模糊、位图、链等效果的类。这些效果设置在<code class="du km kn ko kp b">Views</code>或<code class="du km kn ko kp b">RenderNodes</code>上，以改变这些对象的绘制方式。</li><li id="f863" class="nt nu hh iy b iz oc jc od jf oe jj of jn og jr ny nz oa ob bi translated"><code class="du km kn ko kp b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RenderNode" rel="noopener ugc nofollow" target="_blank">RenderNode</a></code>:保存用于绘制视图的底层操作的对象，但也可以直接用于记录和存储自定义绘制操作。</li><li id="3a3c" class="nt nu hh iy b iz oc jc od jf oe jj of jn og jr ny nz oa ob bi translated"><code class="du km kn ko kp b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RuntimeShader" rel="noopener ugc nofollow" target="_blank">RuntimeShader</a></code>:保存AGSL着色器代码的对象。</li><li id="29fd" class="nt nu hh iy b iz oc jc od jf oe jj of jn og jr ny nz oa ob bi translated"><a class="ae js" href="https://developer.android.com/develop/ui/views/graphics/agsl" rel="noopener ugc nofollow" target="_blank"> AGSL </a>:安卓图形着色语言。像SkSL，但是针对安卓。它提供了一种创建非常定制的每像素绘制效果的机制。</li><li id="d2f5" class="nt nu hh iy b iz oc jc od jf oe jj of jn og jr ny nz oa ob bi translated"><a class="ae js" href="https://skia.org/docs/user/sksl/" rel="noopener ugc nofollow" target="_blank">SkSL</a>:Skia的着色语言。这就像GLSL，但Skia渲染管道。</li><li id="4ace" class="nt nu hh iy b iz oc jc od jf oe jj of jn og jr ny nz oa ob bi translated"><a class="ae js" href="https://www.khronos.org/files/opengles_shading_language.pdf" rel="noopener ugc nofollow" target="_blank"> GLSL </a>着色器:使用OpenGL时片段着色器的语言。</li></ul><p id="1912" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到处玩！创造整洁的效果！制作更好更直观的用户界面！享受图形带来的乐趣！这就是它存在的目的！</p><p id="5827" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mc">感谢</em><a class="ae js" href="https://twitter.com/nadewad" rel="noopener ugc nofollow" target="_blank"><em class="mc">Nader Jawad</em></a><em class="mc">对他理解和实现上述双重</em> <code class="du km kn ko kp b"><em class="mc">RenderNode</em></code> <em class="mc">手法的帮助。</em></p></div></div>    
</body>
</html>