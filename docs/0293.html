<html>
<head>
<title>ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ViewModels: Persistence，onSaveInstanceState()，恢复UI状态和加载器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090?source=collection_archive---------1-----------------------#2017-07-17">https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090?source=collection_archive---------1-----------------------#2017-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="0fda" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="9c6c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在<a class="ae ka" rel="noopener" href="/google-developers/viewmodels-a-simple-example-ed5ac416317e">上一篇博文</a>中，我探索了一个简单的用例，使用新的<a class="ae ka" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank"> ViewModel </a>类在配置更改期间保存篮球比分数据。视图模型旨在以生命周期意识的方式保存和管理与UI相关的数据。视图模型允许数据在屏幕旋转等配置变化后仍然存在。</p><p id="2b5c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">此时，您可能会对视图模型的作用范围有一些疑问。在这篇文章中，我将回答:</p><ul class=""><li id="c461" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated"><strong class="je hi">视图模型会保存我的数据吗？</strong>TL；【T6号】博士照常坚持！</li><li id="1289" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">【ViewModels是否是<a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank"><strong class="je hi">onSaveInstanceState</strong></a><strong class="je hi">的替代品？</strong>TL；不，但它们是相关的，所以继续读下去。</li><li id="2bca" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><strong class="je hi">2019年5月15日更新:如何使用ViewModels高效保存和恢复UI状态？</strong>t̶l̶；̶d̶r̶̶y̶o̶u̶̶u̶s̶e̶̶a̶̶c̶o̶m̶b̶i̶n̶a̶t̶i̶o̶n̶̶o̶f̶̶v̶i̶e̶w̶m̶o̶d̶e̶l̶s̶,̶̶o̶n̶s̶a̶v̶e̶i̶n̶s̶t̶a̶n̶c̶e̶s̶t̶a̶t̶e̶(̶)̶̶a̶n̶d̶̶l̶o̶c̶a̶l̶̶p̶e̶r̶s̶i̶s̶t̶e̶n̶c̶e̶.̶TL；你使用视图模型和<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank">视图模型保存状态模块</a>以及本地持久性。</li><li id="5b5c" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">ViewModels是装载机的替代品吗？TL；是的，与其他几个类结合使用的视图模型可以代替加载器。</li></ul><p id="e5e9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">2019年5月15日更新了新的ViewModel保存状态模块。请注意“我如何使用视图模型来有效地保存和恢复用户界面状态？”在顶部有一个当前在alpha中的<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank">视图模型保存状态模块</a>的更新。</strong></p><h1 id="ca25" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">视图模型会保存我的数据吗？</h1><p id="4e4d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi">TL；【T27号博士】照常坚持！</strong></p><p id="53ca" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">视图模型保存在UI中使用的瞬态数据，但是它们不保存数据。一旦相关联的UI控制器(片段/活动)被销毁或者进程被停止，ViewModel和所有包含的数据就被标记为垃圾收集。</p><p id="56fc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">应用程序多次运行时使用的数据应该像平常一样保存在<a class="ae ka" href="https://developer.android.com/guide/topics/data/data-storage.html" rel="noopener ugc nofollow" target="_blank">本地数据库、共享首选项和/或云中</a>。如果你希望用户能够将应用程序放入后台，然后在三个小时后回到完全相同的状态，你也应该持久化数据。这是因为一旦你的活动进入后台，如果设备内存不足，你的应用程序进程就会停止。在activity类文档中有一个<a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle" rel="noopener ugc nofollow" target="_blank">方便的表格，它描述了在哪些活动生命周期状态下您的应用程序是可停止的:</a></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/b42bf977893a309062226a6f97ca47b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlXDJ7WENwiFBgOeKWjH7g.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle" rel="noopener ugc nofollow" target="_blank">Activity lifecycle documentation</a></figcaption></figure><p id="830f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">提醒一下，当一个应用程序进程由于资源限制而停止时，它的停止是没有仪式的，并且<strong class="je hi">不会调用额外的生命周期回调。</strong>这意味着你不能依赖<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onDestroy()" rel="noopener ugc nofollow" target="_blank">onDestroy</a></code>被调用。在进程关闭时，您<strong class="je hi">没有</strong>机会保存数据。因此，如果你想最大程度地确保你不会丢失数据，那么一旦用户输入了数据，就把它持久化。这意味着，即使您的应用程序进程由于资源限制而关闭，或者如果设备电池电量耗尽，数据也将被保存。如果您愿意承认在设备突然关闭的情况下丢失数据，您可以将数据保存在<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onStop()" rel="noopener ugc nofollow" target="_blank">onStop()</a></code> <strong class="je hi"> </strong>回调<strong class="je hi">、</strong>中，这正好在活动进入后台时发生。</p><h1 id="1f54" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">ViewModels是onSaveInstanceState的替代吗？</h1><p id="7ee6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi">TL；不，博士，但是他们是相关的，所以继续读下去。</strong></p><p id="4b75" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">为了理解这种差异的微妙之处，理解<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle, android.os.PersistableBundle)" rel="noopener ugc nofollow" target="_blank">onSaveInstanceState()</a></code>和<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Fragment.html#setRetainInstance(boolean)" rel="noopener ugc nofollow" target="_blank">Fragment.setRetainInstance(true)</a></code>之间的差异是有帮助的</p><p id="c266" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> onSaveInstanceState(): </strong>这个回调意味着在两种情况下保留少量的与UI相关的数据:</p><ul class=""><li id="0d32" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">由于内存限制，应用程序的进程在后台时会停止。</li><li id="1e96" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">配置更改。</li></ul><p id="9fb4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du lk ll lm ln b">onSaveInstanceState()</code>被系统在<a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onStop()" rel="noopener ugc nofollow" target="_blank">停止</a>但<a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#finish()" rel="noopener ugc nofollow" target="_blank">未完成</a>的情况下调用。当用户显式关闭活动或在其他情况下调用<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#finish()" rel="noopener ugc nofollow" target="_blank">finish()</a></code>时，不会调用<strong class="je hi">而不是</strong>。</p><p id="0261" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">请注意，许多UI数据是自动保存和恢复的:</p><blockquote class="lp lq lr"><p id="00e3" class="jc jd lo je b jf kb jh ji jj kc jl jm ls kd jp jq lt ke jt ju lu kf jx jy jz ha bi translated">此方法的默认实现保存有关活动视图层次结构状态的临时信息，如<a class="ae ka" href="https://developer.android.com/reference/android/widget/EditText.html" rel="noopener ugc nofollow" target="_blank"> EditText </a>小部件中的文本或<a class="ae ka" href="https://developer.android.com/reference/android/widget/ListView.html" rel="noopener ugc nofollow" target="_blank"> ListView </a>小部件的滚动位置— <a class="ae ka" href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras" rel="noopener ugc nofollow" target="_blank">保存和恢复实例状态文档</a></p></blockquote><p id="7e6e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这些也是应该存储在<code class="du lk ll lm ln b">onSaveInstanceState()</code>中的数据类型的好例子。<code class="du lk ll lm ln b">onSaveInstanceState()</code> <a class="ae ka" href="https://developer.android.com/guide/topics/resources/runtime-changes.html#RetainingAnObject" rel="noopener ugc nofollow" target="_blank">不是为了</a>存储大量数据而设计的，比如位图。<code class="du lk ll lm ln b">onSaveInstanceState()</code>旨在存储较小的数据，与用户界面相关，序列化或反序列化并不复杂。如果被序列化的对象很复杂，序列化会消耗大量内存。因为在配置更改期间，这个过程发生在主线程上，所以它需要很快，这样您就不会丢帧并导致视觉上的停顿。</p><p id="f981" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">fragment . setretaininstance(true)</strong>:<a class="ae ka" href="https://developer.android.com/guide/topics/resources/runtime-changes.html#RetainingAnObject" rel="noopener ugc nofollow" target="_blank">处理配置更改文档</a>描述了在配置更改期间使用保留的片段存储数据的过程。这个<em class="lo">听起来</em>不如<code class="du lk ll lm ln b">onSaveInstanceState()</code>有用，因为<code class="du lk ll lm ln b">onSaveInstanceState()</code>涵盖了配置更改和流程关闭。创建保留片段的用处在于，它意味着保留大型数据集(如图像)或保留复杂对象(如网络连接)。</p><p id="c4d7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">视图模型仅在与配置更改相关的破坏中存活；它们无法在停止的过程中存活。</strong>这使得视图模型取代了使用带有<code class="du lk ll lm ln b">setRetainInstance(true)</code>的片段(事实上，视图模型在后台使用带有<a class="ae ka" href="https://developer.android.com/reference/android/app/Fragment.html#setRetainInstance(boolean)" rel="noopener ugc nofollow" target="_blank"> setRetainInstance </a>设置为true的片段)。</p><h2 id="0ea1" class="lv if hh bd ig lw lx ly ik lz ma mb io jn mc md is jr me mf iw jv mg mh ja mi bi translated">ViewModel的其他优势</h2><p id="e0a6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">视图模型和<code class="du lk ll lm ln b">onSaveInstanceState()</code>以非常不同的方式处理UI数据。<code class="du lk ll lm ln b">onSaveInstanceState()</code>是一个生命周期回调，而视图模型从根本上改变了用户界面数据在应用中的管理方式。除了<code class="du lk ll lm ln b">onSaveInstanceState()</code>之外，这里还有一些关于使用ViewModel的好处的想法:</p><ul class=""><li id="8cff" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">视图模型鼓励好的架构设计。您的数据与您的UI代码分离，这使得代码更加模块化并简化了测试。</li><li id="d585" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><code class="du lk ll lm ln b">onSaveInstanceState()</code>旨在保存少量的瞬态数据，而不是复杂的对象列表或媒体数据。<strong class="je hi">ViewModel可以委托复杂数据的加载，并且在数据加载后充当临时存储</strong>。</li><li id="2de5" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><code class="du lk ll lm ln b">onSaveInstanceState()</code>在配置更改期间以及活动进入后台时调用；在这两种情况下，如果你把数据保存在视图模型中，你实际上不需要<strong class="je hi">重新加载或处理数据。</strong></li></ul><h1 id="81a0" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">如何使用视图模型高效地保存和恢复UI状态？</h1></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="3318" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">更新于2019年5月15日</strong></p><p id="e421" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">t̶l̶；̶d̶r̶̶</strong>y̶o̶u̶̶u̶s̶e̶̶a̶̶c̶o̶m̶b̶i̶n̶a̶t̶i̶o̶n̶̶o̶f̶̶v̶i̶e̶w̶m̶o̶d̶e̶l̶s̶,̶̶o̶n̶s̶a̶v̶e̶i̶n̶s̶t̶a̶n̶c̶e̶s̶t̶a̶t̶e̶(̶)̶̶a̶n̶d̶̶l̶o̶c̶a̶l̶̶p̶e̶r̶s̶i̶s̶t̶e̶n̶c̶e̶.̶</p><p id="6818" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">TL；</strong>博士你使用<code class="du lk ll lm ln b">ViewModel</code> s和<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank"> ViewModel保存状态模块</a>以及本地持久性。</p><p id="5b60" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">目前在alpha 中有一个新的ViewModel保存状态模块<a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#viewmodel-savedstate-1.0.0-alpha01" rel="noopener ugc nofollow" target="_blank">，你应该知道。这个模块的目的是替换onSaveInstanceState回调中的代码，并将其移动到ViewModel中。当它变得稳定时，这将是使用ViewModel保存UI状态的推荐方式。本节中的所有内容都是用ViewModel处理保存状态的“当前的、即将过时的”方式。</a></p><p id="0994" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">了解更多信息</strong></p><p id="df1a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要添加的依赖项是:</p><pre class="kv kw kx ky fd mq ln mr ms aw mt bi"><span id="092f" class="lv if hh ln b fi mu mv l mw mx">androidx.lifecycle:lifecycle-viewmodel-savedstate:1.0.0-alpha01</span></pre><p id="90e7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">有关如何使用新模块的说明，请查阅<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank">文档</a>。在<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#6" rel="noopener ugc nofollow" target="_blank">生命周期代码实验室</a>中也有一个分步示例。来自codelab的解决方案代码有一个运行中的模块的简短示例；你可以在这里看一下<a class="ae ka" href="https://github.com/googlecodelabs/android-lifecycles/tree/master/app/src/main/java/com/example/android/lifecycles/step6_solution" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f5ca" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">最后，在<a class="ae ka" href="https://youtu.be/Qxj2eBmXLHg" rel="noopener ugc nofollow" target="_blank">架构组件中的新特性(Google I/O' 19) </a>演示中，Sergey展示了一个处理ViewModel和onSaveInstanceState的旧方法的示例，以及使用ViewModel保存状态的新方法。可以从<a class="ae ka" href="https://youtu.be/Qxj2eBmXLHg?t=926" rel="noopener ugc nofollow" target="_blank"> 15:27 </a>开始看代码示例。对于整个保存状态/视图模型难题的解释，从<a class="ae ka" href="https://youtu.be/Qxj2eBmXLHg?t=687" rel="noopener ugc nofollow" target="_blank"> 11:26 </a>开始观看。</p><p id="f964" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">有什么变化</strong></p><p id="061a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">以下是不同之处的概述:</p><ul class=""><li id="51a1" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">不需要在活动的<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">onCreate</a></code>方法中覆盖<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">onSaveInstanceState</a></code> / <code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/android/app/Activity.html#onRestoreInstanceState(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">onRestoreInstanceState</a></code>或对savedInstanceState bundle做任何事情。</li><li id="b09c" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">现在，ViewModel中有了一个<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle.html" rel="noopener ugc nofollow" target="_blank">SavedStateHandle</a></code>，而不是将状态保存到活动的包中。现在，ViewModel可以真正处理自己的所有数据了。它不再需要向活动发送状态和从活动接收状态。</li><li id="1e26" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle.html" rel="noopener ugc nofollow" target="_blank">SavedStateHandle</a></code>与bundle非常相似——它是一个键值映射，在内存约束相关的进程死亡后仍然存在。出于上面给出的相同原因，您应该只在<code class="du lk ll lm ln b">SavedStateHandle</code>中存储<strong class="je hi">少量的</strong>数据。基本上，<code class="du lk ll lm ln b">SavedStateHandle</code>代替了捆绑包。</li><li id="2189" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><code class="du lk ll lm ln b">SavedStateHandle</code>具有返回<code class="du lk ll lm ln b"><a class="ae ka" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle.html#getLiveData(java.lang.String)" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>的额外能力。</li></ul><p id="9ba4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">下面是我第一次发表这篇博文时出现的“老办法”。这个建议仍然适用，只是在活动中提到使用<code class="du lk ll lm ln b">onSaveInstanceState</code>时，应该在视图模型中用<code class="du lk ll lm ln b">SavedStateHandle</code>替换。记住这一点，继续读下去。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="d764" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">重要的是，您的活动保持用户期望的状态，即使它被轮换、被系统关闭或被用户重启。正如我刚才提到的，不要让复杂的对象阻塞<code class="du lk ll lm ln b">onSaveInstanceState</code>也很重要。您也不希望在不需要的时候从数据库中重新加载数据。让我们来看一个允许您搜索歌曲库的活动示例:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es my"><img src="../Images/81a617a10c560f16a645f56c2f47a990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjsvodQeJCZwSWiwtPET2g.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Example of the clean state of the activity and the state after a search</figcaption></figure><p id="bc32" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">有两种用户可以离开活动的一般方式，以及用户将期望的两种不同结果:</p><ul class=""><li id="5815" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">第一个是用户<strong class="je hi">是否完全关闭</strong>活动。如果用户将某个活动从<a class="ae ka" href="https://developer.android.com/guide/components/activities/recents.html" rel="noopener ugc nofollow" target="_blank">最近屏幕</a>上划掉，或者如果用户<a class="ae ka" href="https://developer.android.com/training/design-navigation/ancestral-temporal.html" rel="noopener ugc nofollow" target="_blank">向上或向后</a>导航出某个活动，则用户可以完全关闭该活动。在这些情况下的假设是<strong class="je hi">用户已经永久地离开了该活动，如果他们再次打开该活动，他们将期望从一个干净的状态开始</strong>。对于我们的歌曲应用程序，如果用户完全关闭歌曲搜索活动，然后重新打开该活动，歌曲搜索框将被清除，搜索结果也将被清除。</li><li id="4021" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">另一方面，如果用户旋转电话或将活动放在背景中，然后再回来，用户期望他们搜索的搜索结果和歌曲就在那里，和以前完全一样。有几种方法可以让用户将活动放在后台。他们可以按下home键或导航到应用程序的其他地方。或者他们可能在查看搜索结果的过程中收到电话或通知。但是最终，用户希望当他们回到活动时，状态和他们离开时一样。</li></ul><p id="14cd" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">为了在这两种情况下实现这种行为，您将一起使用本地持久性、视图模型和<code class="du lk ll lm ln b">onSaveInstanceState()</code>。每个都将存储活动使用的不同数据:</p><ul class=""><li id="0c8f" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated"><strong class="je hi">本地持久化</strong>用于存储您不想在打开和关闭活动时丢失的所有数据。<br/> <strong class="je hi">示例:</strong>所有歌曲对象的集合，可能包括音频文件和元数据</li><li id="a4d4" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><strong class="je hi">视图模型</strong>用于存储显示相关UI控制器所需的所有数据。<br/> <strong class="je hi">例如:</strong>最近搜索的结果，最近搜索查询</li><li id="1047" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><strong class="je hi"> onSaveInstanceState </strong>用于存储当UI控制器被系统停止并重新创建时，轻松重新加载活动状态所需的少量数据。不在这里存储复杂对象，而是在本地存储中持久化复杂对象，并在<code class="du lk ll lm ln b">onSaveInstanceState()</code>中存储这些对象的唯一ID。<br/> <strong class="je hi">例如:</strong>最近的搜索查询</li></ul><p id="c759" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在歌曲搜索示例中，不同的事件应该如何处理:</p><p id="ef25" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">当用户添加一首歌曲时—</strong>ViewModel将立即委托在本地保存该数据。如果新添加的歌曲应该显示在UI中，那么您还应该更新ViewModel中的数据以反映歌曲的添加。记住在主线程之外执行所有的数据库插入。</p><p id="c12f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">当用户搜索歌曲时— </strong>无论您从数据库中为UI控制器加载什么样的复杂歌曲数据，都应该立即存储在ViewModel中。您还应该在ViewModel中保存搜索查询本身。</p><p id="5ae9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">当活动进入后台，活动被系统停止— </strong>当活动进入后台，会调用<code class="du lk ll lm ln b">onSaveInstanceState()</code>。您应该将搜索查询保存在<code class="du lk ll lm ln b">onSaveInstanceState()</code>包中。这种少量的数据很容易保存。这也是让活动回到当前状态所需的所有信息。</p><p id="b961" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">创建活动时</strong> —有三种不同的方式:</p><ul class=""><li id="abb7" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated"><strong class="je hi">第一次创建活动</strong>:在这种情况下，<code class="du lk ll lm ln b">onSaveInstanceState()</code>包中没有数据，只有一个空的视图模型。创建ViewModel时，您将传递一个空查询，ViewModel将知道还没有要加载的数据。该活动将以干净的空状态开始。</li><li id="372f" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><strong class="je hi">活动在被系统</strong>停止后创建:活动会将查询保存在<code class="du lk ll lm ln b">onSaveInstanceState()</code> bundle中。活动应该将查询传递给ViewModel。ViewModel将看到它没有缓存搜索结果，并将使用给定的搜索查询委托加载搜索结果。</li><li id="35b5" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><strong class="je hi">活动是在配置更改</strong>之后创建的:活动将查询保存在<code class="du lk ll lm ln b">onSaveInstanceState()</code>包中，视图模型已经缓存了搜索结果。您将查询从<code class="du lk ll lm ln b">onSaveInstanceState()</code>包传递到ViewModel，ViewModel将确定它已经加载了必要的数据，并且<strong class="je hi">不</strong>需要重新查询数据库。</li></ul><p id="e8a1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这是处理保存和恢复活动状态的一种合理方式。根据您的活动实现，您可能根本不需要使用<code class="du lk ll lm ln b">onSaveInstanceState()</code>。例如，一些活动在用户关闭后不会以干净的状态打开。目前，当我在Android上关闭并重新打开Chrome时，它会带我回到关闭之前我正在查看的网页。如果您的活动以这种方式运行，那么您可以放弃<code class="du lk ll lm ln b">onSaveInstanceState()</code>,转而在本地持久化所有内容。在歌曲搜索示例中，这意味着持续最近的查询，例如在<a class="ae ka" href="https://developer.android.com/reference/android/content/SharedPreferences.html" rel="noopener ugc nofollow" target="_blank">共享偏好</a>中。</p><p id="735f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">此外，当您从意向中打开一个活动时，在配置更改和系统恢复一个活动时，会向您提供附加包。如果搜索查询作为一个额外的意图被传递，您可以使用extras包而不是<code class="du lk ll lm ln b">onSaveInstanceState()</code>包。</p><p id="ff23" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">不过，在这两种场景中，您仍然可以使用ViewModel来避免在配置更改期间浪费从数据库重新加载数据的周期！</p><h1 id="b963" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">视图模型是装载机的替代品吗？</h1><p id="02ba" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi">TL；是的，与其他一些类结合使用的视图模型可以代替加载器。</strong></p><p id="161b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><a class="ae ka" href="https://developer.android.com/guide/components/loaders.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi">加载器</strong> </a>用于为UI控制器加载数据。此外，如果您在装载过程中旋转设备，装载器可以承受配置变化。这听起来很熟悉！</p><p id="5dc4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">加载器，尤其是<a class="ae ka" href="https://developer.android.com/reference/android/content/CursorLoader.html" rel="noopener ugc nofollow" target="_blank">光标加载器</a>的一个常见用例是让加载器观察数据库的内容，并保持UI显示的数据同步。使用CursorLoader，如果数据库中的值发生变化，加载器将自动触发数据的重新加载并更新UI。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mz"><img src="../Images/a3895df34c72dfa067a3ba2b517d5cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuZeqCSgKlrfD7CGQq1laA.png"/></div></div></figure><p id="32a7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">与其他架构组件<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>和<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room </a>一起使用的视图模型可以替代加载器。ViewModel确保数据可以在配置更改后继续存在。LiveData确保您的UI可以在数据更新时更新。Room确保当您的数据库更新时，您的LiveData会得到通知。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es na"><img src="../Images/845e69ab7a226a5f4a4b0fdd9d316894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc2mtVLw7y10MFZq4za7EA.png"/></div></div></figure><p id="902d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">加载器是作为UI控制器中的回调实现的，所以视图模型的一个额外好处是它们将UI控制器和数据加载分开。这使得类之间的强引用更少。</p><p id="a4cc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">使用视图模型和LiveData加载数据有几种方法:</p><ul class=""><li id="8798" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">在<a class="ae ka" rel="noopener" href="/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4">的这篇博客文章</a>，<a class="nb nc ge" href="https://medium.com/u/51a4f24f5367?source=post_page-----fc7cc4a6c090--------------------------------" rel="noopener" target="_blank">中，Ian Lake </a>概述了如何使用ViewModel和LiveData来替换<a class="ae ka" href="https://developer.android.com/reference/android/content/AsyncTaskLoader.html" rel="noopener ugc nofollow" target="_blank"> AsyncTaskLoader </a>。</li><li id="7ec6" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">随着代码变得越来越复杂，您可以考虑在单独的类中进行实际的数据加载。ViewModel类的目的是包含UI控制器的数据，以便该数据在配置更改后仍然存在。加载、持久化和管理数据是复杂的功能，超出了传统视图模型的范围。Android应用架构指南<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/guide.html#fetching_data" rel="noopener ugc nofollow" target="_blank">建议构建一个<strong class="je hi">知识库</strong>类。</a></li></ul><blockquote class="lp lq lr"><p id="0630" class="jc jd lo je b jf kb jh ji jj kc jl jm ls kd jp jq lt ke jt ju lu kf jx jy jz ha bi translated">储存库模块负责处理数据操作。它们为应用程序的其余部分提供了一个干净的API。他们知道从哪里获取数据，以及在数据更新时进行什么API调用。您可以将它们视为不同数据源(持久模型、web服务、缓存等)之间的中介。)."— <a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/guide.html#fetching_data" rel="noopener ugc nofollow" target="_blank">应用架构指南</a></p></blockquote><h1 id="c941" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论和进一步学习</h1><p id="90ed" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在这篇文章中，我回答了一些关于ViewModel类是什么和不是什么的问题。关键要点是:</p><ul class=""><li id="0e08" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">视图模型不能替代持久性——当数据发生变化时，可以像平常一样持久化数据。</li><li id="b8ca" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">视图模型不是<code class="du lk ll lm ln b">onSaveInstanceState()</code>的替代品，因为它们只能在与配置更改相关的破坏中存活；它们不会在操作系统停止应用程序的过程中存活。</li><li id="a5b3" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><code class="du lk ll lm ln b">onSaveInstanceState()</code>不是指需要冗长的序列化/反序列化的复杂数据。</li><li id="89f9" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">为了有效地保存和恢复用户界面状态，使用持久化、<code class="du lk ll lm ln b">onSaveInstanceState()</code>和视图模型的组合。复杂数据保存在本地持久存储中，而<code class="du lk ll lm ln b">onSaveInstanceState()</code>用于存储复杂数据的唯一标识符。视图模型在加载后将复杂数据存储在内存中。</li><li id="eead" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">在这种场景中，当活动旋转或进入后台时，视图模型仍然保留数据，这是纯粹使用<code class="du lk ll lm ln b">onSaveInstanceState()</code>不容易做到的。</li><li id="8f88" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">ViewModels和LiveData结合使用，可以替代加载器。您可以使用Room来替换CursorLoader功能。</li><li id="c2fe" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">创建存储库类是为了支持加载、缓存和同步数据的可扩展架构。</li></ul><p id="8bb7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">想要更好的视角吗？检查:</p><ul class=""><li id="377a" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated"><a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/adding-components.html" rel="noopener ugc nofollow" target="_blank">添加梯度依赖关系的说明</a></li><li id="aa5d" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank"> ViewModel </a>文档</li><li id="90fd" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">在带景观的<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view/" rel="noopener ugc nofollow" target="_blank">房间进行引导视图模型练习</a>和<a class="ae ka" href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" rel="noopener ugc nofollow" target="_blank">生命周期代码实验室</a></li><li id="2bb2" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">包含ViewModel [ <a class="ae ka" href="https://github.com/googlesamples/android-architecture-components" rel="noopener ugc nofollow" target="_blank">架构组件</a> ] [ <a class="ae ka" href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvvm-live/" rel="noopener ugc nofollow" target="_blank">使用生命周期组件的架构蓝图</a> ]的有用示例</li><li id="4ed1" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated"><a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/guide.html" rel="noopener ugc nofollow" target="_blank">应用架构指南</a></li></ul><p id="921b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">架构组件是根据您的反馈创建的。如果您对ViewModel或任何架构组件有任何问题或意见，请查看我们的<a class="ae ka" href="https://developer.android.com/topic/libraries/architecture/feedback.html" rel="noopener ugc nofollow" target="_blank">反馈页面</a>。关于这个系列的问题？留言评论！</p></div></div>    
</body>
</html>