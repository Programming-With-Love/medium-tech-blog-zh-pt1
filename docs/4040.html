<html>
<head>
<title>API Test Automation with REST Assured</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">放心的API测试自动化</h1>
<blockquote>原文：<a href="https://medium.com/globant/api-test-automation-with-rest-assured-and-json-server-9b429e7934ce?source=collection_archive---------0-----------------------#2022-12-05">https://medium.com/globant/api-test-automation-with-rest-assured-and-json-server-9b429e7934ce?source=collection_archive---------0-----------------------#2022-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fd9c1ffc50e90194459f3148e46b88b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Io13pIXrlVT9dN6p"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@jonathanborba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonathan Borba</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4190" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对API测试需求的增加导致了<a class="ae it" href="https://rest-assured.io/" rel="noopener ugc nofollow" target="_blank">放心库</a>的流行，它已经在全球的测试自动化框架中被广泛采用。在本文中，我们将指出API自动化的一些好处，并讨论一些使用该库创建RESTful web服务自动化测试的实例。</p><h1 id="f121" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么选择API自动化？</h1><p id="26f4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">API自动化对于确保您的API按预期运行并满足客户的需求至关重要。API的自动化测试可以减少手动测试所需的时间，并减少相关的工作量，从而确保更顺利的实现。以下是API自动化的一些好处:</p><ul class=""><li id="85e1" class="kv kw hh iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">早期缺陷检测:早期检测导致更快的缺陷解决和交付。</li><li id="6154" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">关注功能:业务逻辑与外观和感觉的分离。</li><li id="80e9" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">业务层的可靠性:拥有稳定的API接口增加了自动化的稳定性。</li><li id="33ab" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">降低成本:使用自动化节省的测试时间降低了成本。</li><li id="51aa" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><a class="ae it" href="https://www.lambdatest.com/blog/shift-left-testing-approach/" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> Shift-Left </em> </a>:通过遵循Shift-Left测试方法，API自动化帮助验证功能，即使UI仍然需要准备好。测试与开发并行，而不是在开发之后。</li><li id="3f11" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">合同验证:由于测试已经自动化，合同中的变更可以很容易地被识别。</li><li id="5f00" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">软件行为和客户体验的改进减少了响应时间，并促进了与其他应用程序的交互。</li></ul><h2 id="a1b1" class="lk jt hh bd ju ll lm ln jy lo lp lq kc jf lr ls kg jj lt lu kk jn lv lw ko lx bi translated">测试自动化金字塔</h2><p id="bbde" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">测试自动化金字塔是一个概念，它建议自动化测试应该被组织成三层:单元测试、服务测试和UI测试。UI测试用于测试用户界面，单元测试用于验证单个功能或代码单元的功能，而服务测试用于测试应用程序的API层。应该经常编写和运行服务测试，以提供快速反馈，并确保API更改不会破坏现有功能。</p><figure class="lz ma mb mc fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/6275717b7bf8c4b2b4171a4b08cfc78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*9skw8tSuimBoaWrONOlWbg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">The Test Automation Pyramid</figcaption></figure><p id="d2af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">放心用于创建服务测试；它不适用于单元测试或UI测试。</p><h1 id="e43c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">REST API自动化流程</h1><p id="cd30" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">基本的API自动化流程包括自动化向API发送HTTP请求和验证来自API的响应的过程。这不仅可以通过放心来实现，还可以通过其他各种工具和框架来实现，比如<a class="ae it" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>、<a class="ae it" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> JMeter </a>和<a class="ae it" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。</p><figure class="lz ma mb mc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/f1796a85b972ba17945b936fa0b17a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fCFbIPUKJspqy6Bj"/></div></div></figure><h1 id="047d" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">放心</h1><p id="86d3" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">放心的主要目的是简化REST APIs的测试和验证。它提供了一种领域特定语言(DSL)来简单直接地编写测试和断言。这有助于确保API按预期运行，并允许开发人员在问题变成问题之前快速识别问题。</p><p id="fdaa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它使用<a class="ae it" href="https://cucumber.io/docs/gherkin/" rel="noopener ugc nofollow" target="_blank"> Gherkin </a>语法(Given，When，Then)来支持使用HTTP方法(如GET、POST、PUT、PATCH和DELETE)创建请求。这将使你的测试更具可读性，更容易理解。</p><p id="566b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它还提供了内置的状态代码验证，并使用<a class="ae it" href="http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html" rel="noopener ugc nofollow" target="_blank"> Hamcrest匹配器<em class="lj"> </em> </a>和<a class="ae it" href="https://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>语法，使用<a class="ae it" href="https://www.javadoc.io/doc/io.rest-assured/json-path/latest/io/restassured/path/json/JsonPath.html" rel="noopener ugc nofollow" target="_blank"> JsonPath </a>或<a class="ae it" href="https://www.javadoc.io/doc/io.rest-assured/xml-path/latest/io/restassured/path/xml/XmlPath.html" rel="noopener ugc nofollow" target="_blank"> XmlPath </a>来检查响应正文内容。此外，它还可以处理不同的认证机制，如<a class="ae it" href="https://www.ibm.com/docs/en/cics-ts/5.4?topic=concepts-http-basic-authentication" rel="noopener ugc nofollow" target="_blank">基础</a>、<a class="ae it" href="https://oauth.net/1/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>、<a class="ae it" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>和<a class="ae it" href="https://www.yubico.com/resources/glossary/what-is-certificate-based-authentication/" rel="noopener ugc nofollow" target="_blank">证书</a>。</p><h1 id="a6bc" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建项目</h1><p id="7405" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">对于示例项目，我们将从<code class="du me mf mg mh b"><a class="ae it" href="http://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank">jsonplaceholder.typicode.com</a></code>中提取数据。首先，我们发送一个简单的GET请求并验证响应状态代码。之后，我们将执行一些使用请求参数查询数据的例子。</p><p id="36c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们<a class="ae it" href="https://maven.apache.org/guides/getting-started/" rel="noopener ugc nofollow" target="_blank">创建一个简单的Maven项目</a>。为此，在文件系统中的任意位置创建一个新目录，在其中启动一个shell并运行以下Maven goal命令:</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="9272" class="mm jt hh mh b be mn mo l mp mq">mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</span></pre><p id="2d8f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，您可以从最近创建的项目中替换<code class="du me mf mg mh b">pom.xml</code>文件的原始内容，如下所示:</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="4da4" class="mm jt hh mh b be mn mo l mp mq">&lt;project  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>     <br/>  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;<br/>  &lt;artifactId&gt;my-app&lt;/artifactId&gt;<br/>  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/>     <br/>  &lt;properties&gt;<br/>    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;<br/>    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br/>    &lt;junit.jupiter.api&gt;5.6.0&lt;/junit.jupiter.api&gt;<br/>    &lt;rest.assured&gt;5.3.0&lt;/rest.assured&gt;<br/>  &lt;/properties&gt;<br/>     <br/>  &lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>     &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br/>      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;<br/>     &lt;version&gt;${junit.jupiter.api}&lt;/version&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>      &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;<br/>      &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;<br/>      &lt;version&gt;${rest.assured}&lt;/version&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>  &lt;/dependencies&gt;<br/>&lt;/project&gt;</span></pre><p id="2553" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建的项目必须在目录<code class="du me mf mg mh b">/src/test/java</code>中有一个名为<code class="du me mf mg mh b">AppTest.java</code>的文件；如果不存在，请创建它。</p><h1 id="8b05" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代码重用</h1><p id="99f9" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">您可以利用<code class="du me mf mg mh b">@BeforeAll</code> <em class="lj"> </em>注释以及放心的全局变量来放置公共代码，这些代码将在以后编写的每个测试中执行。</p><p id="d47a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将使用<a class="ae it" href="https://www.dezlearn.com/rest-assured-request-and-response-specifications/" rel="noopener ugc nofollow" target="_blank">放心请求和响应规范</a>来避免可重用配置的代码重复。</p><p id="62b9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lj">构建器类</em> <code class="du me mf mg mh b">RequestSpecBuilder</code> <a class="ae it" href="https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/builder/RequestSpecBuilder.html" rel="noopener ugc nofollow" target="_blank"> </a>和<code class="du me mf mg mh b">ResponseSpecBuilder</code>分别用于实现<code class="du me mf mg mh b">RequestSpecification</code>和<code class="du me mf mg mh b">ResponseSpecification</code>接口。<code class="du me mf mg mh b">RequestSpecification</code>允许您指定请求的外观，而<code class="du me mf mg mh b">ResponseSpecification</code>对响应也是如此。</p><p id="821e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的例子中，我们为请求设置了<code class="du me mf mg mh b">Base URI</code>、<code class="du me mf mg mh b">Port</code>和<code class="du me mf mg mh b">Content Type </code>，为响应设置了<code class="du me mf mg mh b">Response Time</code>和<code class="du me mf mg mh b">Content Type</code>的期望值。</p><p id="a839" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下面代码片段的最后两行，我们使用了<code class="du me mf mg mh b">RestAssured.requestSpecification</code> <em class="lj"> </em>和<code class="du me mf mg mh b">RestAssured.responseSpecification</code> <em class="lj"> </em>来使之前的配置全局化，这样我们就不需要在之后的每个请求中指定它们。</p><p id="15e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，<code class="du me mf mg mh b">AppTest.java</code>的配置将如下所示:</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="213c" class="mm jt hh mh b be mn mo l mp mq">public class AppTest {<br/>    RequestSpecification requestSpec;<br/>    ResponseSpecification responseSpec;<br/><br/>    @BeforeAll<br/>    public static void setup() {<br/><br/>        requestSpec = new RequestSpecBuilder()<br/>                .setBaseUri("https://jsonplaceholder.typicode.com")<br/>                .setContentType(ContentType.JSON)<br/>                .build();<br/><br/>        responseSpec = new ResponseSpecBuilder()<br/>                .expectResponseTime(Matchers.lessThan(5L), TimeUnit.SECONDS)<br/>                .expectContentType(ContentType.JSON)<br/>                .build();<br/><br/>        RestAssured.requestSpecification = requestSpec;<br/>        RestAssured.responseSpecification = responseSpec;<br/>    }<br/>}</span></pre><h1 id="c7da" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建第一个测试用例</h1><p id="f165" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">下面的代码片段展示了使用放心的API的一个最基本的测试。它只是对我们的端点执行一个GET请求，并检查它是否以状态代码200响应，这意味着请求已经成功。</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="631b" class="mm jt hh mh b be mn mo l mp mq">@Test<br/>public void testGetPosts() {<br/><br/>    RestAssured<br/>        .given()<br/>        .when()<br/>            .get("/posts")<br/>        .then()<br/>            .assertThat()<br/>            .statusCode(HttpStatus.SC_OK);<br/>}</span></pre><p id="5edb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们已经在设置方法中定义了我们的<code class="du me mf mg mh b">BaseUri</code>，这里我们调用<code class="du me mf mg mh b">get()</code>方法，将<code class="du me mf mg mh b">/posts</code>端点作为参数传递。</p><h1 id="cead" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">参数化GET请求</h1><p id="540b" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">GET请求中可以使用两种类型的参数。</p><h2 id="92eb" class="lk jt hh bd ju ll lm ln jy lo lp lq kc jf lr ls kg jj lt lu kk jn lv lw ko lx bi translated">a)路径参数</h2><p id="12ea" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在这种情况下，参数值是请求的URL的一部分。路径参数是端点本身的一部分，不是可选的。下面的代码在<code class="du me mf mg mh b">https://jsonplaceholder.typicode.com/posts/1</code>端点上执行一个GET请求。</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="afe7" class="mm jt hh mh b be mn mo l mp mq">@Test<br/>public void testGetPostByIdUsingPathParam() {<br/><br/>    int pathParam = 1;<br/>    String partialExpectedTitle = "provident";<br/><br/>    RestAssured<br/>        .given()<br/>            .pathParam("id", pathParam)<br/>        .when()<br/>            .get("posts/{id}")<br/>        .then()<br/>            .assertThat()<br/>            .statusCode(HttpStatus.SC_OK)<br/>            .body("title", Matchers.contains(partialExpectedTitle));<br/>}</span></pre><h2 id="6a7d" class="lk jt hh bd ju ll lm ln jy lo lp lq kc jf lr ls kg jj lt lu kk jn lv lw ko lx bi translated">b)查询字符串参数</h2><p id="d41b" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">查询字符串参数出现在问号(？)在端点中。参数及其值后面的问号称为查询字符串。其中，每个参数都列在另一个参数的后面，用&amp;符号分隔。查询字符串参数的顺序无关紧要。</p><p id="21fe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们的例子，我们将使它变得简单，传递一个参数:<code class="du me mf mg mh b">https://jsonplaceholder.typicode.com/comments?email=Veronica_Goodwin@timmothy.net</code>。</p><pre class="lz ma mb mc fd mi mh mj bn mk ml bi"><span id="8303" class="mm jt hh mh b be mn mo l mp mq">@Test<br/>public void testGetPostByIdUsingQueryParam() {<br/><br/>    int queryParam = "Veronica_Goodwin@timmothy.net";<br/>    String expectedTitle = "fugit labore quia mollitia quas deserunt nostrum sunt";<br/><br/>    RestAssured<br/>        .given()<br/>            .queryParam("email", queryParam)<br/>        .when()<br/>            .get("/comments")<br/>        .then()<br/>            .assertThat()<br/>            .statusCode(HttpStatus.SC_OK)<br/>            .body("name", Matchers.equalTo(expectedTitle));<br/>}</span></pre><h1 id="472a" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">总结</h1><p id="4fd9" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在本文中，您简要介绍了什么是放心，以及它如何在API测试环境中为您提供帮助。</p><p id="aac6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我认为它是web服务测试的强大工具。它的语法简单易懂，文档非常优秀，许多在线资源可以帮助您入门。</p><p id="5495" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">暂时就这样了。在下面的文章中，我们将讨论一个更详细的例子，使用放心测试不同的HTTP请求方法。</p></div></div>    
</body>
</html>