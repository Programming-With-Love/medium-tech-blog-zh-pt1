<html>
<head>
<title>First steps with Docker Checkpoint — to create and restore snapshots of running containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker检查点的第一步——创建和恢复正在运行的容器的快照</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/first-steps-with-docker-checkpoint-to-create-and-restore-snapshots-of-running-containers-f85395d1b69f?source=collection_archive---------0-----------------------#2018-04-08">https://medium.com/oracledevs/first-steps-with-docker-checkpoint-to-create-and-restore-snapshots-of-running-containers-f85395d1b69f?source=collection_archive---------0-----------------------#2018-04-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="61dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker容器可以停止和重新启动。在运行的容器中对文件系统所做的更改将在这种有意的停止和启动循环中继续存在。内存中的数据和正在运行的进程显然不会。崩溃的容器不能只是重新启动，如果可以重新启动，它将使文件系统处于不确定状态。当您在一个容器停止后启动它时，它将经历它的完整启动例程。如果需要启动负载较重的进程，比如数据库服务器进程，那么这个启动时间可能会很长，可能会有几秒或几十秒。</p><p id="e79b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Linux在用户空间中有一种称为CRIU或检查点/恢复的机制。使用该工具，您可以冻结正在运行的应用程序(或其一部分),并将其作为磁盘上的文件集合进行检查点检查。然后，您可以使用这些文件来恢复应用程序，并完全按照冻结时的状态运行它。详见<a class="ae jc" href="https://criu.org/Main_Page" rel="noopener ugc nofollow" target="_blank">https://criu.org/Main_Page</a>。Docker CE对CRIU有(实验性的)支持。这意味着使用简单的docker命令，我们可以拍摄一个正在运行的容器的快照(docker check point create&lt;container name&gt;&lt;check point name&gt;)。稍后，我们可以作为同一个容器(docker start–check point&lt;check point name&gt;&lt;container name&gt;)或不同的容器启动该快照。</p><p id="eac8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从检查点启动的容器与创建检查点时的容器处于相同的状态(内存和进程)。此外，容器从快照的启动时间非常短(亚秒)；对于启动时间相当长的容器，这种快速启动是一个巨大的好处。</p><p id="d085" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将讲述我与CRIU和Docker的最初步骤。我让它工作了。我确实在Docker CE的最近版本(17.12和18.x)中遇到了<a class="ae jc" href="https://github.com/moby/moby/issues/35691" rel="noopener ugc nofollow" target="_blank">问题</a>，所以我求助于Docker CE的17.04。我还在旧版本的CRIU上遇到了<a class="ae jc" href="https://github.com/checkpoint-restore/criu/commit/fb4f28f00af0f2d8c6fafdbafc74951f0caea925" rel="noopener ugc nofollow" target="_blank">问题</a>，所以我构建了当前最新版本的CRIU (3.8.1)而不是Ubuntu Xenial 64发行版中的版本(2.6)。</p><p id="9cd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将演示如何启动一个克隆GitHub存储库的容器，并启动一个简单的REST API作为节点应用程序；这需要10秒或更长时间。这个应用程序计算它处理的GET请求的数量(通过保存一些内存状态)。在处理了许多请求之后，我为这个容器创建了一个检查点。接下来，我又提出了几个请求，同时观察计数器的增加。然后，我停止集装箱，并从检查点开始一个新的集装箱。容器运行速度极快，不到700毫秒，因此它明显利用了创建快照时的容器状态。它在创建快照时继续计算请求数，显然是继承了它的内存状态。正如所期望的那样。</p><p id="180a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:检查点不会捕获容器中文件系统的更改。只有内存状态是快照的一部分。</p><p id="d27f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意2: Kubernetes还不支持检查点。这意味着pod不能从检查点启动容器。</p><p id="9249" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在以后的文章中，我将描述这些快照的一个用例——在自动化测试场景和复杂数据集中。</p><p id="51cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我所经历的步骤(在我的Windows 10笔记本电脑上，使用了vagger 2 . 0 . 3和VirtualBox 5.2.8):</p><ul class=""><li id="8348" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">使用vagger创建一个带有Docker CE 18.x的Ubuntu 16.04 LTS (Xenial)虚拟机箱虚拟机</li><li id="af5b" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">将Docker从18.x降级到17.04</li><li id="55d1" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">为实验选项配置Docker</li><li id="df74" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">安装CRIU软件包</li><li id="df69" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">尝试使用Docker检查点的简单场景</li><li id="0eb6" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">构建CRIU最新版本</li><li id="a21c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用Docker检查点尝试更复杂的场景(在旧的CRIU版本中失败了)</li></ul><h1 id="3c1d" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用Docker CE 18.x创建Ubuntu 16.04 LTS (Xenial)虚拟机箱虚拟机</h1><p id="4c75" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我的Windows 10笔记本电脑已经有了流浪者2.0.3和虚拟盒子5.2.8。我使用下面的浮动文件创建了一个VM，它是我在这个实验中的Docker主机:</p><p id="a3e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建(并启动)虚拟机后</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="dd2f" class="ld js hh kz b fi le lf l lg lh">vagrant up</span></pre><p id="ac27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用以下命令连接到虚拟机</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4519" class="ld js hh kz b fi le lf l lg lh">vagrant ssh</span></pre><p id="f054" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在命令提示符下结束，准备行动。</p><p id="a1ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了确保我们是最新的，我跑了</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="464a" class="ld js hh kz b fi le lf l lg lh">sudo apt-get upgrade</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es li"><img src="../Images/19d334d71a5d74d38e6449118ff7dc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*cwEAySjm1ZFPGkaF."/></div></figure><h1 id="64a8" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">将Docker CE降级到版本17.04</h1><p id="e3f6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在撰写本文时，最近的Docker版本(至少为17.09及更高版本——见<a class="ae jc" href="https://github.com/moby/moby/issues/35691" rel="noopener ugc nofollow" target="_blank">https://github.com/moby/moby/issues/35691</a>)存在问题，因此我降级到17.04版本(如下所述:<a class="ae jc" href="https://forums.docker.com/t/how-to-downgrade-docker-to-a-specific-version/29523/4" rel="noopener ugc nofollow" target="_blank">https://forums . Docker . com/t/how-to-downgrade-Docker-to-a-specific-version/29523/4</a>)。</p><p id="a446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先删除由流浪者提供者安装的Docker版本:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="dbc3" class="ld js hh kz b fi le lf l lg lh">sudo apt-get autoremove -y docker-ce \ &amp;&amp; sudo apt-get purge docker-ce -y \ &amp;&amp; sudo rm -rf /etc/docker/ \ &amp;&amp; sudo rm -f /etc/systemd/system/multi-user.target.wants/docker.service \ &amp;&amp; sudo rm -rf /var/lib/docker \ &amp;&amp; sudo systemctl daemon-reload</span></pre><p id="ea36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后安装所需的版本:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c6de" class="ld js hh kz b fi le lf l lg lh">sudo apt-cache policy docker-ce sudo apt-get install -y docker-ce=17.04.0~ce-0~ubuntu-xenial</span></pre><h1 id="f0eb" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为实验选项配置Docker</h1><p id="c6f1" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">利用CRIU支持检查点是Docker中的一个实验性特性。为了利用它，必须启用实验选项。这已经完成(如https://stack overflow . com/questions/44346322/how-to-run-docker-with-experimental-functions-on-Ubuntu-16-04中所述)</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b046" class="ld js hh kz b fi le lf l lg lh">sudo nano /etc/docker/daemon.json</span></pre><p id="0d67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">增加</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b363" class="ld js hh kz b fi le lf l lg lh">{ "experimental": true }</span></pre><p id="659a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按CTRL+X，选择Y并按Enter保存新文件。</p><p id="a45c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重新启动docker服务:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2f22" class="ld js hh kz b fi le lf l lg lh">sudo service docker restart</span></pre><p id="302d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8a60" class="ld js hh kz b fi le lf l lg lh">docker version</span></pre><p id="1bcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果实验真的启用了。</p><h1 id="97e3" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">安装CRIU软件包</h1><p id="c5aa" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">CRIU的简单方法——它应该如何工作——就是简单地安装CRIU软件包:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bba7" class="ld js hh kz b fi le lf l lg lh">sudo apt-get install criu</span></pre><p id="4ac9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(例如参见<a class="ae jc" href="https://yipee.io/2017/06/saving-and-restoring-container-state-with-criu/" rel="noopener ugc nofollow" target="_blank">https://yipee . io/2017/06/saving-and-restore-container-state-with-criu/</a>)</p><p id="1a34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个安装为我带来了CRIU软件包的2.6版本。对一些行动来说，这证明是足够的，而对另一些行动来说，这证明是不够的。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lm"><img src="../Images/96bad1e1a2f5d8ce8d12168543990177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/0*D5HlsBEtDq0pyiLp."/></div></figure><h1 id="33ac" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用CRIU码头检查站尝试简单场景</h1><p id="42dc" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">目前我们有Docker 17.04，Ubuntu 16.04和CRIU 2.6。这种组合可以让我们对Docker检查点机制有一个初步的了解。</p><p id="0c27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行一个简单的容器，该容器每秒向控制台写入一次计数器值(然后增加计数器)</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b748" class="ld js hh kz b fi le lf l lg lh">docker run --security-opt=seccomp:unconfined --name cr -d busybox /bin/sh -c 'i=0; while true; do echo $i; i=$(expr $i + 1); sleep 1; done'</span></pre><p id="148f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查写入控制台的值:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c67e" class="ld js hh kz b fi le lf l lg lh">docker logs cr</span></pre><p id="8ae9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在为容器创建一个Docker检查点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ae7c" class="ld js hh kz b fi le lf l lg lh">docker checkpoint create  --leave-running=true cr checkpoint0</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/d9b1e4e29c074c3e0cd5dc346273320c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*BsLWelm-207k05wv."/></div></div></figure><p id="b2c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让容器运行一段时间，然后再次检查日志</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="92cd" class="ld js hh kz b fi le lf l lg lh">docker logs cr</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/cce88c192e40bc9937287b34fdfc2034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j_NjXmbbw_tp-BRd."/></div></div></figure><p id="7b9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在停止容器:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="27b5" class="ld js hh kz b fi le lf l lg lh">docker stop cr</span></pre><p id="db54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并重新启动/重新创建容器—不是从头开始，而是从检查点开始:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7f17" class="ld js hh kz b fi le lf l lg lh">docker start --checkpoint checkpoint0 cr</span></pre><p id="0b88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查日志:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="20b5" class="ld js hh kz b fi le lf l lg lh">docker logs cr</span></pre><p id="d758" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会发现日志在创建检查点的值(19)处恢复:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lt"><img src="../Images/9011417c88f2de5cd532ad26ff616bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/0*n8qxMnKaCUG_qq67."/></div></figure><h1 id="4821" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">构建CRIU最新版本</h1><p id="427d" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">当我尝试一个更复杂的场景时(见下一节)，我遇到了这个<a class="ae jc" href="https://github.com/checkpoint-restore/criu/commit/fb4f28f00af0f2d8c6fafdbafc74951f0caea925" rel="noopener ugc nofollow" target="_blank">问题</a>。我可以通过在我的Ubuntu Docker主机上构建最新版本的CRIU来解决这个问题。以下是我按照这些指示完成的步骤:<a class="ae jc" href="https://criu.org/Installation" rel="noopener ugc nofollow" target="_blank">https://criu.org/Installation</a>。</p><p id="f7f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，删除当前安装的CRIU软件包:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e325" class="ld js hh kz b fi le lf l lg lh">sudo apt-get autoremove -y criu \ <br/>&amp;&amp; sudo apt-get purge criu -y \</span></pre><p id="35fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，准备构建环境:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6f92" class="ld js hh kz b fi le lf l lg lh">sudo apt-get install build-essential \ <br/>&amp;&amp; sudo apt-get install gcc   \ <br/>&amp;&amp; sudo apt-get install libprotobuf-dev libprotobuf-c0-dev protobuf-c-compiler protobuf-compiler python-protobuf \ <br/>&amp;&amp; sudo apt-get install pkg-config python-ipaddr iproute2 libcap-dev  libnl-3-dev libnet-dev --no-install-recommends</span></pre><p id="05d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，克隆CRIU的GitHub存储库:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="962c" class="ld js hh kz b fi le lf l lg lh">git clone https://github.com/checkpoint-restore/criu</span></pre><p id="8c2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">导航到包含代码库的criu目录</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="fcc8" class="ld js hh kz b fi le lf l lg lh">cd criu</span></pre><p id="b480" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并构建criu包:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3751" class="ld js hh kz b fi le lf l lg lh">make</span></pre><p id="d22b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当make完成后，我可以运行CRIU:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="de3d" class="ld js hh kz b fi le lf l lg lh">sudo ./criu/criu check</span></pre><p id="0b92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看安装是否成功。最终输出的消息应该是:看起来不错(尽管可能有一个或多个警告)。</p><p id="27f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b874" class="ld js hh kz b fi le lf l lg lh">sudo ./criu/criu –V</span></pre><p id="3884" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">了解当前安装的CRIU版本。</p><p id="664e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:CRIU说明描述了在系统范围内安装criu的以下步骤。为了让docker从Docker检查点命令中利用CRIU，似乎不需要这样做。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7b62" class="ld js hh kz b fi le lf l lg lh">sudo apt-get install asciidoc  xmlto <br/>sudo make install criu check</span></pre><p id="ce2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们已经准备好接受更复杂的场景，这种场景之前在旧的CRIU版本中由于一个问题而失败了。</p><h1 id="a2c5" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">具有Docker检查点的更复杂的场景</h1><p id="54a3" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这种情况在旧的CRIU版本中失败了——可能是因为这个<a class="ae jc" href="https://github.com/checkpoint-restore/criu/commit/fb4f28f00af0f2d8c6fafdbafc74951f0caea925" rel="noopener ugc nofollow" target="_blank">问题</a>。我可以通过在我的Ubuntu Docker主机上构建最新版本的CRIU来解决这个问题。</p><p id="2f12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本例中，我运行了一个基于Docker容器映像的容器，用于运行从GitHub存储库中下载的任何节点应用程序。容器将下载并运行的节点应用程序处理简单的HTTP GET请求:它对请求进行计数，并返回计数器的值作为对请求的响应。这个容器映像和这个应用程序在之前的文章中介绍过:<a class="ae jc" href="https://technology.amis.nl/2017/05/21/running-node-js-applications-from-github-in-generic-docker-container/" rel="noopener ugc nofollow" target="_blank">https://technology . amis . nl/2017/05/21/running-node-js-applications-from-github-in-generic-docker-container/</a></p><p id="1340" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里您可以看到运行容器的命令—将被称为<em class="lu"> reqctr2 </em>:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5696" class="ld js hh kz b fi le lf l lg lh">docker run --name reqctr2 -e "GIT_URL=https://github.com/lucasjellema/microservices-choreography-kubernetes-workshop-june2017" -e "APP_PORT=8080" -p 8005:8080 -e "APP_HOME=part1" -e "APP_STARTUP=requestCounter.js" lucasjellema/node-app-runner</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/c24e1c4bce1e3556a38f9c7626aa3502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0poFN762iIKmq-RE."/></div></div></figure><p id="03b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序启动和处理请求大约需要15秒钟。</p><p id="0e33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦容器开始运行，就可以从VM外部发送请求——例如从我的笔记本电脑上运行的浏览器——由容器处理，http://192.168.188.106:8005/。</p><p id="1cc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一次或多次请求后，计数器显示在21:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lv"><img src="../Images/5b5332d997e0c80b535d1088f44ea173.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*MnwMLWWl4rzUUCks."/></div></figure><p id="268e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此时，我为容器创建了一个检查点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a976" class="ld js hh kz b fi le lf l lg lh">docker checkpoint create --leave-running=true reqctr2 checkpoint1</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/73d61b54df01fc549cbbf618f0ca3b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GXEdfy5rCQHmLvpQ."/></div></div></figure><p id="f39a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我在浏览器中发出几个额外的请求，使计数器达到更高的值:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lw"><img src="../Images/486b999079e95932daafbf3de87ec39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*FP3cERtHH2J8awlm."/></div></figure><p id="da20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此时，我停止了容器—随后从检查点再次启动它<strong class="ig hi">:</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c586" class="ld js hh kz b fi le lf l lg lh">docker stop reqctr2 docker start --checkpoint checkpoint1 reqctr2</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/68b339c317f194fddd273b98911a3a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uUdsGQS4rjFzQTmA."/></div></div></figure><p id="1bb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">容器继续运行不到一秒钟。</p><p id="49ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我发出一个新请求时，我得到的值既不是1(新容器的结果)，也不是43(如果前一个容器仍在运行，我将得到的结果)。相反，我得到了</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lx"><img src="../Images/d6812a787b47575a373fe7968a119f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*fWWRFFjis9gf8fDe."/></div></figure><p id="4ca8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是从快照中捕获的容器状态开始的下一个值。注意:因为我从浏览器发出GET请求，并且浏览器也试图检索favicon，所以我在浏览器中每按一次refresh，计数器就增加2。</p><p id="52c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:我可以获得为容器创建的所有检查点的列表。显然，我应该在这些检查点的命名约定上投入更多的精力:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1e38" class="ld js hh kz b fi le lf l lg lh">docker checkpoint ls reqctr2</span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es ly"><img src="../Images/f29d76d7bd4afdcece8fda529d7dd37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/0*JyhhfJ0SKinq0YeM."/></div></figure><p id="2756" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在这个场景中经历的流程可以想象成这样:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/3e2755392146c74df8e6c70cee12b51e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s3aw-5B8KXZH528N."/></div></div></figure><p id="1f73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起点:Windows笔记本电脑与流浪汉和虚拟框。一个VM已经被里面有Docker的流浪者创建了。Docker和CRIU软件包的正确版本已经设置。</p><p id="bfc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后运行这些步骤:</p><ol class=""><li id="f32c" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lz jj jk jl bi translated">使用节点JS运行时基于映像启动Docker容器</li><li id="a5cc" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">克隆包含节点JS应用程序的GitHub存储库</li><li id="0ef6" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">运行Node JS应用程序—为HTTP请求做好准备</li><li id="5b91" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">处理来自Windows主机上的浏览器的HTTP请求</li><li id="9e2c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">为容器创建Docker检查点—容器状态的快照</li><li id="0f7f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">检查点保存在Docker主机上，以备后用</li><li id="189c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">从检查点启动容器。这个容器瞬间启动，不需要GitHub克隆和应用启动；它从创建检查点时的状态恢复</li><li id="2d5e" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lz jj jk jl bi translated">容器处理HTTP请求——就像它的检查点前身一样</li></ol><h1 id="993b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">资源</h1><p id="baaa" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">来源于这个GitHub repo:<a class="ae jc" href="https://github.com/lucasjellema/docker-checkpoint-first-steps" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/docker-check point-first-steps</a></p><p id="2fa8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于CRIU的文章:<a class="ae jc" href="http://www.admin-magazine.com/Archive/2014/22/Save-and-Restore-Linux-Processes-with-CRIU" rel="noopener ugc nofollow" target="_blank">http://www . admin-magazine . com/Archive/2014/22/Save-and-Restore-Linux-Processes-with-CRIU</a></p><p id="98ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有:关于CRIU和Docker:<a class="ae jc" href="https://yipee.io/2017/06/saving-and-restoring-container-state-with-criu/" rel="noopener ugc nofollow" target="_blank">https://yipee . io/2017/06/saving-and-restoring-container-state-with-criu/。</a></p><p id="0e30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker中关于检查点和恢复的文档:<a class="ae jc" href="https://github.com/docker/cli/blob/master/experimental/checkpoint-restore.md" rel="noopener ugc nofollow" target="_blank">https://github . com/Docker/CLI/blob/master/experimental/check point-Restore . MD</a></p><p id="9e97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker支持页面:<a class="ae jc" href="https://criu.org/Docker;" rel="noopener ugc nofollow" target="_blank">https://criu.org/Docker;</a>在Ubuntu上安装CRIU包:<a class="ae jc" href="https://criu.org/Packages#Ubuntu" rel="noopener ugc nofollow" target="_blank">https://criu.org/Packages#Ubuntu</a></p><p id="2f0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">安装并构建https://criu.org/Installation来源:<a class="ae jc" href="https://criu.org/Installation" rel="noopener ugc nofollow" target="_blank">CRIU</a></p><p id="25e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于流浪乞讨人员救助的文件:<a class="ae jc" href="https://www.vagrantup.com/docs/provisioning/docker.html" rel="noopener ugc nofollow" target="_blank">https://www.vagrantup.com/docs/provisioning/docker.html</a></p><p id="1b1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于降级Docker的文章:<a class="ae jc" href="https://forums.docker.com/t/how-to-downgrade-docker-to-a-specific-version/29523/4" rel="noopener ugc nofollow" target="_blank">https://forums . Docker . com/t/how-to-降级-Docker-to-a-specific-version/29523/4</a></p><p id="d0f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为实验选项配置Docker:<a class="ae jc" href="https://stackoverflow.com/questions/44346322/how-to-run-docker-with-experimental-functions-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/44346322/how-to-run-Docker-with-experimental-functions-on-Ubuntu-16-04</a></p><p id="0982" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">码头和检查站问题(至少在17.09–18.03中):【https://github.com/moby/moby/issues/35691 T2】</p><p id="eca6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lu">原载于2018年4月8日</em><a class="ae jc" href="https://technology.amis.nl/2018/04/08/first-steps-with-docker-checkpoint-to-create-and-restore-snapshots-of-running-containers/" rel="noopener ugc nofollow" target="_blank"><em class="lu">technology . amis . nl</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>