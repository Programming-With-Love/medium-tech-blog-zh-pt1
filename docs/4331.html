<html>
<head>
<title>Advanced FP for the Enterprise Bee: Kleisli</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业蜂的高级FP:Kleisli</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-kleisli-1d0de0fa82d9?source=collection_archive---------5-----------------------#2021-01-29">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-kleisli-1d0de0fa82d9?source=collection_archive---------5-----------------------#2021-01-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/4f44c45fa352474084f48a0a84373d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*ALuwNIY0UvXaBzk_zaBXTA.png"/></div><figcaption class="il im et er es in io bd b be z dx">An (Non-Kleisli) Arrow Pointing to Honey</figcaption></figure><h1 id="ce60" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="5a72" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是本系列的第四篇文章，为注重实践的Kotlin开发人员探索高级FP概念。到目前为止，我们已经看了<a class="ae kl" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4">遍历</a>、<a class="ae kl" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c">应用</a>和<a class="ae kl" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527">高级类型</a>。这次我们调查的是Kleisli型。</p><p id="d496" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我非常不愿意接近这个概念，主要是因为这个术语是从范畴理论借用来的。所以我以为会很曲折。幸运的是，Kleisli比我们已经讨论过的许多概念都要简单。</p><h1 id="5281" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">简单的问题</h1><p id="39e9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">让我们从重温第一篇文章中唯一的朋友开始。这个函数试图读取一个JVM属性，在一个<em class="kr">或者</em>中返回结果。</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="e5b2" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">假设我们需要浏览一系列的财产价值:</p><ul class=""><li id="ee9a" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">我们得到了一个JVM属性的键<strong class="jp hi"> A </strong></li><li id="4d59" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">属性<strong class="jp hi"> A </strong>的值将成为键<strong class="jp hi"> B </strong></li><li id="43d5" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">属性<strong class="jp hi"> B </strong>的值将成为键<strong class="jp hi"> C </strong></li><li id="653d" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">这个过程必须重复N次</li></ul><p id="6899" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们创建两个助手方法，一个创建这样的链，另一个打印出所有的JVM属性:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="ef0a" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">作为样本数据，让我们使用沙丘书中阿崔迪斯家族的血统:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="3098" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">当我们运行以上代码时，输出包含以下信息:</p><pre class="ks kt ku kv fd lm ln lo lp aw lq bi"><span id="8b88" class="lr iq hh ln b fi ls lt l lu lv">            Vladimir | Jessica<br/>             Jessica | Paul<br/>                Paul | Ghanima<br/>             Ghanima | Moneo<br/>               Moneo | Siona</span></pre><p id="b44d" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们的任务是通过FP和Arrow导航这个关联链。</p><h1 id="b0b6" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">程序性解决方案</h1><p id="3a7f" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是如何以程序方式解决问题的:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="c971" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">运行此代码会产生正确的输出:</p><pre class="ks kt ku kv fd lm ln lo lp aw lq bi"><span id="34d2" class="lr iq hh ln b fi ls lt l lu lv">Right(Siona)</span></pre><p id="f782" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">程序方法有三个问题:</p><ul class=""><li id="50bc" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">我们不得不将propertyViaJVM封装在一个新的函数中，这个函数要么接受T21，要么接受T22</li><li id="d011" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">为了实现这个功能，我们需要注意<em class="kr">或</em>的规则</li><li id="f955" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">应用该函数需要嵌套和/或临时变量</li></ul><h1 id="ff3d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">克莱斯利溶液</h1><p id="39dd" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面是使用Kleisli类型编写的解决方案。我们仍然包装了<em class="kr"> propertyViaJVM </em>函数，但是有一些重要的区别:</p><ul class=""><li id="bc82" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">通过<code class="du lw lx ly ln b">Kleisli { … }</code>为我们进行包装</li><li id="181d" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">包装的函数接受一个常规字符串作为输入</li><li id="c58b" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><em class="kr">或者</em>的实现是从我们这里抽象出来的</li></ul><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8fa7" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">然后，我们使用<em class="kr">将所有需要的调用链接在一起。</em>这将调用组合成一个单一的序列，当我们调用<em class="kr"> run </em>时执行该序列。需要调用<em class="kr"> fix </em>来执行向下转换，原因<a class="ae kl" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527">在前一篇文章</a>中讨论过。</p><p id="d3cf" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果你熟悉Java线程库中的<em class="kr"> CompletableFuture </em>类型，这是一个非常相似的设计。让我们看看它如何处理正确和错误的数据:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="5705" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">它给了我们想要的东西:</p><pre class="ks kt ku kv fd lm ln lo lp aw lq bi"><span id="e08d" class="lr iq hh ln b fi ls lt l lu lv">Right(Siona)<br/>Left(No JVM property: Alia)</span></pre><p id="6a07" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">因为我们只包装了一个函数，所以可以通过用方法引用替换lambda来简化代码:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="0e95" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Kleisli中的附加功能</h1><p id="dbd1" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">到目前为止，我们已经看到Kleisli类型简化了函数的组成，其中函数返回但不接受像<em class="kr">这样的一元类型，或者</em>或者<em class="kr">验证过的</em>。还有一些有用的实用方法。让我们稍微修改一下输入数据:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="b66f" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">除了现有要求，我们现在还想:</p><ul class=""><li id="75cc" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">将“Harkonnen”追加到客户端给定的初始值。该功能由<em class="kr">本地</em>功能提供。</li><li id="4b54" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">向调用<em class="kr"> run </em>产生的最终值追加‘at reides’。正如您所料，这种能力是由<em class="kr"> map </em>函数提供的。</li></ul><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="46e4" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这又一次给了我们想要的输出:</p><pre class="ks kt ku kv fd lm ln lo lp aw lq bi"><span id="3c38" class="lr iq hh ln b fi ls lt l lu lv">Right(Siona Atreides)<br/>Left(No JVM property: Alia)</span></pre><h1 id="b2b4" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么不用单子？</h1><p id="07e9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当我遇到克莱斯利时，我的第一个问题是“为什么不直接用一元合成？”。事实证明，我们总是可以的——事实上，这就是Kleisli的实现方式。</p><p id="62e6" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">你可能已经注意到了，我们把任一单子传递给了<em class="kr">和</em>。结果是，如果你已经实现了一元类型，那么你就可以免费得到Kelisli。因此，您可以选择最适合的方法。</p><p id="4662" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">下面是直接使用一元合成解决的问题:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="91a1" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这给出了我们想要的结果。但是与Kleisli解决方案相比，有更多的“管道”。我们必须记住:</p><ul class=""><li id="3b08" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">暂停我们的功能</li><li id="6ff7" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">使用bang运算符(或等效运算符)</li><li id="fedc" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">为中间结果声明变量</li></ul><h1 id="74f2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是克莱斯利箭？</h1><p id="ba7c" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在纯函数式编程和范畴理论中，函数的组合都是通过绘制(或编码)箭头来表示的。这是菲利普·瓦德勒的精彩演讲，充满了箭头图。Kleisli箭头表示一元上下文中的功能组合。在我们的例子中，单子是<em class="kr">或者</em>，但是它也可以是<em class="kr">有效的</em>、<em class="kr">写者</em>、<em class="kr">状态</em>等等...</p><p id="98a6" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这就是为什么在语言允许的情况下，函数库通常提供一个箭头符号来替代<em class="kr">和</em>方法。这是我们用Scala和<a class="ae kl" href="https://github.com/scalaz/scalaz" rel="noopener ugc nofollow" target="_blank"> Scalaz </a>库重写的例子。</p><p id="b274" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">请注意，在第31行，我们使用了<em class="kr"> &gt; = &gt; </em>操作符来组合函数:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="2d91" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="b33e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">尽管Kleisli这个术语来源于范畴论，但它既不复杂也不不实用。无论何时，克莱斯利都是一元作曲的绝佳替代品:</p><ul class=""><li id="6231" class="ky kz hh jp b jq km ju kn jy la kc lb kg lc kk ld le lf lg bi translated">一个或多个函数返回一个容器(又名。Monad)但采用常规参数。</li><li id="981a" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">要求将这些功能链接在一起以获得最终结果。</li></ul><h1 id="0f2f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">运行示例代码</h1><p id="4d00" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">像往常一样，列出的所有代码都可以在这个位存储桶repo 中找到<a class="ae kl" href="https://bitbucket.org/instilco/advanced-fp-gde/src/master/" rel="noopener ugc nofollow" target="_blank">。然而，所使用的Kleisli类型仍处于试验阶段，因此可以在</a><a class="ae kl" href="https://github.com/arrow-kt/arrow-incubator" rel="noopener ugc nofollow" target="_blank">Arrow孵化器项目</a>中找到。要运行我的‘UsingKleisli’项目，你必须首先克隆并构建<em class="kr"> arrow-incubator </em>，然后将<em class="kr"> arrow-mtl </em>和<em class="kr"> arrow-mtl-data </em>库复制到<em class="kr"> libs </em>文件夹中。</p><h1 id="cfaa" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">谢谢</h1><p id="2572" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">感谢<a class="ae kl" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kl" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。所有的错误当然是我自己的。</p></div></div>    
</body>
</html>