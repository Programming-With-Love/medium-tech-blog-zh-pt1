<html>
<head>
<title>Experimenting With SQLite in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中试验SQLite</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/experimenting-with-sqlite-in-ios-ae9dec92dbaf?source=collection_archive---------3-----------------------#2020-05-27">https://medium.com/capital-one-tech/experimenting-with-sqlite-in-ios-ae9dec92dbaf?source=collection_archive---------3-----------------------#2020-05-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8587" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我们能从脸书的光速项目中学到什么</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f3b7f3d824bcbe41f1d96f5270082330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gykAusjdyx9jUYB0"/></div></div></figure><blockquote class="ji"><p id="761e" class="jj jk hh bd jl jm jn jo jp jq jr js dx translated">在科学界听到的最激动人心的短语，预示着新发现的短语，不是“尤里卡”，而是“真有趣……”<em class="jt">——</em><a class="ae ju" href="https://www.brainyquote.com/quotes/isaac_asimov_109758" rel="noopener ugc nofollow" target="_blank"><em class="jt">【艾萨克·阿西莫夫(1920–1992)</em></a></p></blockquote><p id="6fc5" class="pw-post-body-paragraph jv jw hh jx b jy jz ii ka kb kc il kd ke kf kg kh ki kj kk kl km kn ko kp js ha bi translated">脸书工程公司最近发表了一篇关于他们的信使重写项目光速的文章，这表明他们找到了依靠SQLite的好理由。他们报告说，与之前的iOS版本相比，重写后的代码减少了84%，从170万行减少到36万行，导致应用程序大小减少了75%，启动时间减少了50%。</p><p id="9092" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">最有趣的是，在关于光速项目的讨论中缺席的是<a class="ae ju" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React Native </a>和<a class="ae ju" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，这是两个用于移动开发的大型突出的脸书项目。脸书(重新)发现了SQLite的什么，使他们更喜欢传统的关系数据库管理系统(RDMS ),而不是其他模式和技术？</p><p id="0b5d" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">那个问题让我疑惑地停顿了一下，<em class="kv">“真有意思。那不可能那么有效也不简单。可以吗？”</em>但是如果，原谅我的双关语，我们以<em class="kv">面</em>取这个值呢？</p><p id="fde9" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">这里事关重大。从工程角度来看，快速、高效的开发和应用性能是脸书的关键驱动因素。因此，如果脸书工程公司说SQLite是这种变化的关键组成部分，那么我们应该好奇，看看。</p><p id="d662" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">我非常熟悉RDMSs和在许多环境中使用的各种对象关系管理器/映射器(ORM ),从使用Java的<a class="ae ju" href="https://en.wikipedia.org/wiki/Hibernate_(framework)" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>、<a class="ae ju" href="https://en.wikipedia.org/wiki/Enterprise_Objects_Framework" rel="noopener ugc nofollow" target="_blank"> NeXT的企业对象框架</a>到<a class="ae ju" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html" rel="noopener ugc nofollow" target="_blank">苹果的核心数据</a>。我也对SQLite做了相当多的修改。尽管它是安装最广泛的SQL数据库，并且可能是这个星球上第二个使用最广泛的软件，但它在我们的操作系统和应用程序中一直扮演着一个安静的、常常不被注意的角色。尽管我有经验，但我经常避开RDBM/SQLite解决方案，认为它是一把大锤，而我只需要一个球头。但我认为一只好的“老狗”应该在看到新把戏时就能认出来。是时候再次看看可以从SQLite中学到什么新东西了。</p><h1 id="14b6" class="kw kx hh bd ky kz la lb lc ld le lf lg in lh io li iq lj ir lk it ll iu lm ln bi translated">实验</h1><p id="c7f5" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">简而言之，这是脸书文章的前后图表和评论，说明了我想要回答的基本问题。<em class="kv">“就复杂性和编码模式而言，移除中间控制器层意味着什么？它的性能如何？”</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lt"><img src="../Images/8357ec6a239e0fb765f4f4eefe01c566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*V7v_oR2SBItb3vHvYnE1Bw.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Figure 1a: Before Lightspeed Configuration</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ly"><img src="../Images/e433278fae94f581720ae8345bd726ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*Z1j5Z08M5_SosVvH_nmdYg.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Figure 1b: Lightspeed Configuration</figcaption></figure><p id="9793" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">我的(不太生动的)解释强调了脸书提出的前(图1a)和后(图1b)架构。</p><p id="5a4d" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated"><strong class="jx hi">所以我决定做一个实验</strong>到<strong class="jx hi"> </strong>测试SQLite在驱动一个简单应用的UI时的性能。特别感兴趣的是用户体验的视觉响应性以及对开发人员生产力的影响；是不是更快更简单？</p><h2 id="d137" class="lz kx hh bd ky ma mb mc lc md me mf lg ke mg mh li ki mi mj lk km mk ml lm mm bi translated">应用程序</h2><p id="fde8" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">我们希望我们的测试应用程序简单，但是它应该在处理大量记录(至少几千条)方面锻炼数据库。由于典型的移动应用程序不进行大量的数据I/O，并且表单填充是一种低带宽操作，所以一个大部分是只读的应用程序对于我们的测试来说应该绰绰有余。我们还希望我们的领域模式能够代表真实世界的应用程序。除了我们对SQLite库的Swift API，我们将编写一些SQL以及少量的网络和绑定“胶水”,以与iOS的MVC架构集成。为了将这些部分连接在一起，我们将使用一个众所周知且广泛采用的模式，即模型-视图-视图模型(<a class="ae ju" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>)，并实现一个视图模型和SQL驱动的绑定框架，以尽可能薄的单板封装我们的数据库。更少的域类或类型，没有通知，没有主题观察者，没有键值观察。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mn"><img src="../Images/2caadb62797ee99e710be7d2f4bbcdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*D7UOm79GJdcPU8qq"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><em class="jt">Figure 2: Our Design inserts a ViewModel and SQL Bindings (in green) into the traditional iOS MVC pattern with SQLite backing the Model.</em></figcaption></figure><p id="c224" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">重要的是——服务API领域的核心是JSON——嵌套对象和数组——它们不容易与RDBMS的表和行对齐，这通常会成为采用的障碍。开发人员生活在面向对象的世界中，从对象图到RDMS模式的映射不是一件有趣、容易或高效的任务。这就是为什么许多noSQL、graphQL和各种各样的ORM@解决方案如此受欢迎。但是知名的数据库，包括<a class="ae ju" href="https://www.oracle.com/database/technologies/appdev/json.html" rel="noopener ugc nofollow" target="_blank"> Oracle </a>、<a class="ae ju" href="https://dev.mysql.com/doc/refman/8.0/en/json.html" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae ju" href="https://www.devplaybook.com/intermediate-sql-tutorials/working-with-json-in-an-rdbms-part-1-ms-sql-server/" rel="noopener ugc nofollow" target="_blank"> MSSQL </a>和<a class="ae ju" href="https://www.devplaybook.com/intermediate-sql-tutorials/working-with-json-in-an-rdbms-part-2-postgresql/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>，都包含了扩展，不仅可以存储JSON文档，还可以就地读取和编辑JSON的对象图。当然，SQLite还包括一个健壮的实现(<a class="ae ju" href="https://www.sqlite.org/json1.html" rel="noopener ugc nofollow" target="_blank"> JSON1 </a>)来缓解我们的ORM问题。我们一会儿会看看这方面的一些细节。</p><p id="9bb6" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">为了对数据库进行压力测试，我们给它更多的记录来操作，并深入到任何嵌套结构中。在UI方面，这意味着我们希望以不同的方式显示大型列表。对于我们的应用程序，我们将使用UITableViews和MKMapViews。此外，我们将添加搜索/过滤功能，鉴于这是数据库的核心功能，我们希望这应该是一个简单易行的功能，可以集成到我们的应用程序中。</p><h2 id="e49e" class="lz kx hh bd ky ma mb mc lc md me mf lg ke mg mh li ki mi mj lk km mk ml lm mm bi translated">假设</h2><p id="6fe8" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">通过移除绝大部分的控制器中介逻辑，我们应该看到用户体验肯定不会比传统解决方案差，并且在理想情况下甚至会更具响应性和性能。我们还希望使用SQLite，尽可能使用数据库。例如，根据需要直接从数据库获取值；避免对特定领域类型的需求。同样，在数据库之外缓存也被认为是不好的形式。</p><p id="2a43" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">最重要的是，我们希望看到开发人员的体验在以下方面得到改善。</p><ul class=""><li id="709a" class="mo mp hh jx b jy kq kb kr ke mq ki mr km ms js mt mu mv mw bi translated"><strong class="jx hi">更简单、更不复杂</strong> —通过更少的交互组件、更少的代码、更少的文件以及组件之间更清晰的契约和更窄的API，减少了认知过载。</li><li id="5bb6" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">更高效</strong>——“简单”且近在咫尺意味着在大量文件之间切换更少。应该更容易辨别实现的意图，在解决问题时更容易看到哪里。</li><li id="84fd" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">低“</strong> <a class="ae ju" href="https://en.wikiversity.org/wiki/Software_Design/Change_amplification" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hi">变化放大</strong></a><strong class="jx hi">”</strong>—数据模式或布局的变化对要求较少的其他组件的影响较小，如果有任何代码变化的话。更好的设计减少了受每个设计决策影响的代码量。</li><li id="85e4" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">减少错误</strong> —声明式表单更容易理解和验证。更简单的模块化设计应该更容易测试。</li></ul><p id="b3d8" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">我们将在讨论过程中触及这些问题，并在结论中对其进行回顾。因此，带着这些想法，让我们跳进去，看看这是如何进行的。</p><h2 id="324a" class="lz kx hh bd ky ma mb mc lc md me mf lg ke mg mh li ki mi mj lk km mk ml lm mm bi translated">设置</h2><p id="ad40" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">我们将要使用的数据来自Capital One的黑客马拉松模拟APINessie。如果你参加过Capital One黑客马拉松，你可能在你的项目中使用过这个模拟API。Nessie提供了对一些真实的面向公众的数据的访问，如Capital One ATM和银行分行位置，以及一些模拟的客户帐户数据，并被设计用于类似这样的实验。这将为我们的实验提供足够多的数据选择。</p><p id="bfde" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">作为一个参考和讨论点，应用程序是使用<a class="ae ju" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>模式实现的。选择它是因为它的简单性和与<a class="ae ju" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" rel="noopener ugc nofollow" target="_blank"> Cocoa的MVC </a>框架的紧密结合，这也是随着SwiftUI的引入<a class="ae ju" href="https://insights.dice.com/2019/06/17/swiftui-swift-mvvm-mvc/" rel="noopener ugc nofollow" target="_blank">向MVVM设计的演进。</a></p><ul class=""><li id="5be6" class="mo mp hh jx b jy kq kb kr ke mq ki mr km ms js mt mu mv mw bi translated"><strong class="jx hi">模型</strong>——在我们的例子中，模型是我们到较低级别的SQLite C API的快速桥梁。重要的是，它没有覆盖任何形式的orm或者将数据库记录映射到和/或映射出传统对象数据结构的需求。我选择了一个<a class="ae ju" href="https://github.com/wildthink/SQift" rel="noopener ugc nofollow" target="_blank"> SQift fork </a>(一个Nike开源框架)，因为它占用空间小(3，754 loc)并且可以无障碍地访问SQL。有趣的是，由于我们去掉了ORM和繁重的控制器调解，我们实际上不需要任何Swift类或结构来保存任何域数据。</li><li id="cdce" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">视图</strong> —视图指定布局；模型中值的位置、大小和呈现。例如，我们配置了一个UITextField，指定了它的大小、字体、颜色、边框等等，但是实际的内容(比如用户的名字)来自数据库中的某个表和列。</li><li id="6882" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">使用SQL进行绑定</strong> —大多数绑定实现都将实例化对象的值关联起来，这导致了更严格的和“固定的”组件相互依赖关系。但在它的核心，绑定只是一个数据结构或表达式，它将模型中的特定值与特定的UI呈现组件关联起来。在SQL方面，想象一下sometextfield . text = SELECT first _ name FROM users其中id = 1。这是通过“名称”而不是通过“引用”的绑定。如果没有这个绑定变体，将需要一个新的UIViewController子类来保存对UI的引用以及将模型值映射到每个视图的逻辑。每个ViewController都依赖于模型值的类型/类和视图的组成。使用“名称”允许我们消除对每个重现的新的不同类的需要，将视图的引用作为常量，以及期望的模型数据类型和至少其模式的一部分。</li><li id="dc35" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">视图模型</strong> —视图模型位于模型和视图之间。它执行最简单、最普通的任务:1)在数据库中查找一个值并将其提供给视图，2)将用户和系统输入事件分派给改变数据库和/或从应用程序输出数据的函数。值得注意的是，视图是状态的函数，因此在这个意义上不被认为是“输出”。</li></ul><h1 id="ab7b" class="kw kx hh bd ky kz la lb lc ld le lf lg in lh io li iq lj ir lk it ll iu lm ln bi translated">使用SQL，而不是对象</h1><p id="5a28" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">移动开发人员对SQL的使用并不陌生，但我们在日常工作中也不会欣然接受或利用它。通常，在我们面向对象编程的世界中，SQL或关系数据库的任何使用都是抽象的。</p><p id="2058" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">但是在我们的调查中，我们对数据库实际上在做什么非常感兴趣，所以我们不会回避在我们的例子中直接使用SQL。我们可以在以后的实际实现中添加方便的方法，这些方法将抽象出文本的构造和错误处理等。</p><p id="d800" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">代码中特定数据结构(对象)的具体化反过来要求显式内存管理、对象引用(内存指针)的传递以及遵守基于类型和/或Swift协议的特殊处理(在Java中也称为“接口”)。</p><p id="217e" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">遵循领域模型及其对象的设计语义，每种类型通常携带比单个组件所需更多的信息。例如，UI中的特定文本标签将只显示一个人的姓名。人的地址虽然是人的定义的一部分，但在代码中被实例化，但在某些视图中根本不显示。从这个意义上说，在某些情况下，一个物体可能比需要的要“重”。</p><p id="212c" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">相比之下，数据库记录使用主键(标识符)来代替指针，SQL使我们能够直接、明确地访问数据结构的各个属性(例如数据库列)。为了显示人名，SQL请求是“从id = <id>的人中选择姓名”。在这种情况下，组件对人的结构的其余部分一无所知，因此不会受到模型中的变化的影响，除非它特别影响人的“name”属性。</id></p><h2 id="8230" class="lz kx hh bd ky ma mb mc lc md me mf lg ke mg mh li ki mi mj lk km mk ml lm mm bi translated">应用程序</h2><p id="1907" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">我们的应用程序将简单明了(因为我不是UI设计师)。界面布局将是一个简单的选项卡式视图——一个用于表格视图，另一个用于地图。每一个都将以不同的方式处理它们的集合，从而帮助我们检查不同的数据操作和检索策略。表格视图是一个可滚动的列表，是演示大量记录交互处理的好地方(不应该影响快速滚动)。我们还将引入一个关键字搜索特性，以挑战数据库和UI在不断重建和重新呈现大量记录时的响应能力。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/e051a79438472f59b59473250e956d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*3C36yX6OwZar0pRWDHmLJg.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><em class="jt">Figure 3: Two ways to display an array of “locations” in our Demo.</em></figcaption></figure><p id="62fd" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">界面实际上很简单，但是首先我们需要显示数据。让我们先来看看从Nessie mock API获得的原始JSON，以及它如何与其他模块(即数据库和MapViewController)中所需的数据相关联。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nd"><img src="../Images/f23ffb5bb6c43ff7c17bf37494b4edd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cnZ_B8j3RuzlqAX4v6fvg.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx"><em class="jt">Figure 4: Illustrating the schemas as specified in each layer; RESTful, Database/Model and View.</em></figcaption></figure><p id="4aa6" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">注意，SQLite让我们将入站JSON的数组和嵌套子结构address和geocode打包到一个数据库列中。我们将需要使用<a class="ae ju" href="https://www.sqlite.org/json1.html" rel="noopener ugc nofollow" target="_blank"> JSON扩展</a>语法来检索嵌套的值，但是这样我们就不必在离开大门之前描绘出每一个细节。这就是“数据库视图”发挥作用的地方。观察力敏锐的读者可能已经注意到了表名上的前缀“_”。这是我用来表示“原始”底层数据表的惯例。上面的数据库视图提供了_branches列的子集，作为“locations”中重命名的列。注意，我们利用SQLite JSON扩展来提取地址和地理编码的选定属性。</p><p id="5664" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">既然我们已经看到了数据库是如何建立的，领域模式是如何定义的，那么是时候转到UI了。我们的每个主视图(表和地图)都显示了一个位置集合，每个位置记录都有单独的单元格(小视图)。这是表格视图中的一行，以及地图视图中的图钉标注。每个文本标签和字段都用一个“模型键”绑定进行编程注释(按照我们的MVVM设计)。在我们的例子中，每个单元格都有分支的“标题”和“副标题”标签。此绑定是视图的字符串属性，指定要显示的类型/表和属性/列值。它可以通过编程方式设置，也可以在Xcode的界面生成器中设置。对于要显示的每个值，每个绑定都转换为一个SQL“SELECT<property>FROM<table>WHERE id =<id>”。</id></table></property></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/aad2fe3617b00a20cf5c14a7a8de0163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*ejv7q26IQFHQdu6ST6xFxA.png"/></div></figure><p id="83b2" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">编写完应用程序后，我发现把东西放在一起变得出奇的容易。我敢说在某些方面“令人愉快”吗？以至于我决定尝试视频演示。从项目创建到构建和运行的时间是以小时计算的，而不是以天或周计算的。</p><p id="8b98" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">这个视频是创建示例应用程序的一个快速(不到2分钟)轻松的分步指南。只有78行Swift，68行SQL和1个故事板。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><a class="ae ju" href="https://youtu.be/FegFCJ-MKN8" rel="noopener ugc nofollow" target="_blank">Video</a> Illustrating the steps in creating “Fred’s Bank”</figcaption></figure><h1 id="ae6f" class="kw kx hh bd ky kz la lb lc ld le lf lg in lh io li iq lj ir lk it ll iu lm ln bi translated">结论——发现、观察和意见</h1><p id="34a1" class="pw-post-body-paragraph jv jw hh jx b jy lo ii ka kb lp il kd ke lq kg kh ki lr kk kl km ls ko kp js ha bi translated">看起来怎么样？我发现的大量价值在于我能够移除的，而不是我需要添加的。除了实际的应用程序性能之外，使用SQL快速、直观地将数据结构从JSON映射到UI的能力显著提高了设计-&gt;代码-&gt;构建周期的速度。</p><p id="2e95" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">为了便于讨论，下图展示了应用MVC/MVVM模式时的典型组件配置。这将有助于突出我们的设计与更常见的实现之间的差异。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nh"><img src="../Images/02561540aade076bbb89ed31c74cc224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s21sdG9DOf8gb_LyN7xGvg.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">Figure 6: Typical MVVM Configuration</figcaption></figure><p id="b00f" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">上面要注意的要点是每个组件都是“位置”特定的。换句话说，每一个都依赖于“位置”数据结构和模型(例如类型)的结构和任何相关联的方法。从设计上来说，位置类型的任何变化都意味着在这个相互作用的组件系统中所需的变化的潜在级联。需要额外变化的程度定义了这种“<a class="ae ju" href="https://en.wikiversity.org/wiki/Software_Design/Change_amplification" rel="noopener ugc nofollow" target="_blank">变化放大</a>的幅度。</p><p id="e693" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">如果我们遵循相同的模式，我们将会创建(并维护)这样的样板结构。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ni"><img src="../Images/4608c5df3aa08888c47a86599b687454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AMiz42BOnVm9vc26"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx"><em class="jt">Figure 7: Note the significant number of hard-wired, baked-in dependencies that would be required for our application with even a small model using the traditional MVC pattern</em>.</figcaption></figure><p id="6665" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">相反，我们得到了一个更简单，更数据驱动的设计，因此，更可重用的框架如下图所示。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nj"><img src="../Images/8212c29ba3a50c9a41c3e9b3d0bd9f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*k4De5NkoZVqNdvch"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><em class="jt">Figure 8: Note the direct relationship between the Database schema and the SQL Binding annotations (indicated in red) for each View in our Demo.</em></figcaption></figure><ul class=""><li id="32a8" class="mo mp hh jx b jy kq kb kr ke mq ki mr km ms js mt mu mv mw bi translated"><strong class="jx hi">更简单，不太复杂</strong> —我们的视图模型只需要很少的代码。注意，实际的应用程序代码是唯一包含领域知识的地方。唯一的依赖项是SQift和SQiftViewModel框架。两者都是通用的(并且是开源的),但是它们的代码度量被包括进来以供比较。</li></ul><pre class="ix iy iz ja fd nk nl nm nn aw no bi"><span id="c03e" class="lz kx hh nl b fi np nq l nr ns">Module            Language     files      code<br/>--------------------------------------------------------------------<br/>Fred's Bank       Swift        3          108<br/>                  SQL          1          68<br/>--------------------------------------------------------------------<br/>ViewModel         Swift        6          695<br/>Framework<br/>--------------------------------------------------------------------<br/>SQift             Swift        27         2,814</span></pre><p id="c034" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated"><em class="kv">图9:模块或我们的演示应用程序的文件数量和代码行数。</em></p><p id="072f" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">应用程序中极少量的代码减少了认知负荷。不需要为ViewModel框架中提供的TableViewController和MapViewController创建子类。由于能够使用SQL来重新映射和计算列，因此不需要中间的域类。简洁而不混乱。</p><blockquote class="ji"><p id="7f06" class="jj jk hh bd jl jm nt nu nv nw nx js dx translated">对单个绑定的更改彼此完全独立，不需要对中介控制器进行任何更改。</p></blockquote><ul class=""><li id="94bf" class="mo mp hh jx b jy jz kb kc ke ny ki nz km oa js mt mu mv mw bi translated">更高效的——对开发人员来说，关注点是明确分离的；模式、绑定和布局是独立指定或实现。所有模式操作(映射、提取、过滤等)都是用SQL处理的。在视图层次结构的叶子上使用基于SQL的绑定使得辨别所显示数据的来源变得很简单。中介对象只处理标识符，不处理对对象的引用；只有视图的呈现才承担验证类型和值的责任。开发人员可以更容易地定位相关文件和代码(SQL、Swift和注释)并辨别其意图。</li><li id="e256" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">低</strong> <a class="ae ju" href="https://en.wikiversity.org/wiki/Software_Design/Change_amplification" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hi">变化放大</strong> </a> —一个好的设计减少了受每个设计决策影响的代码量。来自服务器的入站JSON的变化会产生重大影响(如图8所示)，几乎总是可以用数据库中的SQL直接解决(如图9所示)。对单个绑定的更改彼此完全独立，不需要对中介控制器进行任何更改。</li><li id="8a74" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated"><strong class="jx hi">错误减少</strong>—SQL绑定的声明形式使得意图清晰且易于验证。例如，查看表格单元格中的UILabel，绑定“location/title”是“SELECT title FROM location WHERE id =&lt;id&gt;”的语法糖。有了“id ”,就可以检索到准确的值。通常，开发人员必须研究(也称为“阅读和理解代码”)对象的“监管链”，并在它从一个组件传递到另一个组件时确定其值。处理对象的中间组件越多，这个过程就变得越复杂，越容易出错。SQL表和列的这种搭配和简洁的声明形式使得理解和验证域数据结构之间的关系更加容易。</li></ul><p id="2b71" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">除了用户和开发人员体验的改进之外，我还想指出通过这种实现实现的一些额外优势。</p><ul class=""><li id="e2ca" class="mo mp hh jx b jy kq kb kr ke mq ki mr km ms js mt mu mv mw bi translated">依靠数据库作为域和应用程序状态的真实来源，使得分析和调试变得非常容易。</li><li id="c9fa" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated">SQLite + JSON很容易满足UI的需求，通过正则表达式搜索和读取JSON结构来处理数千条记录。</li><li id="9f29" class="mo mp hh jx b jy mx kb my ke mz ki na km nb js mt mu mv mw bi translated">数据库视图是组合不同数据类型进行展示的一种非常简单有效的方式。它们在转换数据结构以履行其他模块的“契约”方面也非常有用。</li></ul><p id="2305" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">我发现这个实验很有启发性。虽然更详细和全面的基准测试肯定是值得的，但我有理由相信SQLite是许多用例的最佳选择。当SQLite在您的环境中是一个给定的东西时，我鼓励读者跳出框框思考，思考许多可能性。</p><p id="3218" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated">如果你觉得这很有趣，我很想听听你的经历。</p></div><div class="ab cl ob oc go od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ha hb hc hd he"><p id="4e3a" class="pw-post-body-paragraph jv jw hh jx b jy kq ii ka kb kr il kd ke ks kg kh ki kt kk kl km ku ko kp js ha bi translated"><em class="kv">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>