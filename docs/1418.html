<html>
<head>
<title>RxJava 2: Android MVVM Lifecycle App Structure with Retrofit 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJava 2: Android MVVM生命周期应用程序结构与改进2</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e?source=collection_archive---------0-----------------------#2016-11-12">https://medium.com/capital-one-tech/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e?source=collection_archive---------0-----------------------#2016-11-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/152aa07fc169797511e36cbdac47b6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rm4OvgoHzCgva_qU__Pfmw.png"/></div></div></figure><p id="ddcc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我写这篇关于<a class="ae jn" rel="noopener" href="/@manuelvicnt/rxjava-android-mvvm-app-structure-with-retrofit-a5605fa32c00#.ltpf9ie2c"> MVVM、RxJava和翻新</a>的帖子已经两年多了。现在对我来说似乎有点过时了。一年能学到这么多，真让人吃惊！你回头看看，你可能会为自己的代码感到尴尬。不仅仅是代码本身，还有你到达那里的过程。<strong class="ir hi">所有这些对我来说都是遗留代码</strong>。</p><p id="9f6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将尝试用新的场景和库来改进我的第一篇文章。让我们继续同一个例子(点击了解更多信息)。这一次，我将在一个真实的例子中使用RxJava 2，这个例子是在一个使用改型的<strong class="ir hi"> MVVM结构</strong>中。我们还将讨论如何通过响应视图生命周期的网络请求来<strong class="ir hi">提高应用</strong>的性能。</p><h2 id="25e7" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">迎头赶上</h2><figure class="kk kl km kn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kj"><img src="../Images/3e55458fd349d29e4c100ec9320d36f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhDDuqzBSV4BQyLwp-PDeQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">App structure</figcaption></figure><p id="c98c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们快速浏览不同的层…</p><ul class=""><li id="7884" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated">改造层:它实际上提出了网络请求。</li><li id="60e5" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">APIService层:它负责发出网络请求，解析响应，并在需要时进行处理。</li><li id="7831" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">RequestManager层:准备要发送的数据并链接不同的网络请求。</li><li id="7ae6" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">视图模型层:处理视图所需的逻辑。</li><li id="3101" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">视图层:视图是虚拟的。只处理用户输入。</li></ul><h1 id="3b70" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated">把手放在某物或者某人身上</h1><p id="6c98" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">在这篇文章中，我将提到和谈论很多关于一个宠物项目，在这个项目中你可以看到所有的东西是如何实现的。</p><div class="mc md ez fb me mf"><a href="https://github.com/manuelvicnt/RxJava2-MVVM-Android-Structure" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">manuel vicnt/rx Java 2-MVVM-Android-结构</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在GitHub上创建一个帐户，为RxJava2-MVVM-Android-Structure开发做贡献。</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt in mf"/></div></div></a></div><h1 id="26a8" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated">生命周期导致视图和视图模型之间的问题？</h1><p id="8db8" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">在使用RxJava 1的上一篇文章中，我们在视图模型中有主题，这些主题将信息回复给使用订阅者的视图。你还记得我说我在两年内学到了很多吗？这是一个例子。</p><p id="c159" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们都遇到过同样的问题:如果<strong class="ir hi"> app到后台</strong>我不想取消网络请求或者多做一个。</p><p id="4213" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在这里面临的一个问题是，订阅者/观察者onNext()或onComplete()方法被调用，而视图不在屏幕上。如果订阅者试图与视图通信(通过BusManager或回调)，并且在该方法中我们试图更新任何UI小部件，<strong class="ir hi">应用程序可能会崩溃</strong>。主题在掌握信息时很有帮助，直到视图似乎明白了。</p><p id="cced" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您看一下新的repo，视图和视图模型之间的通信是通过一个名为Contract的接口(回调)进行的。<strong class="ir hi">这给了你在ViewModel </strong>上即插即用任何视图的灵活性。想象一下，你有不同的视图，这取决于它是智能手机、平板电脑还是智能手表……所有这些都可能共享同一个视图模型，但不一定相反。</p><h2 id="0e8f" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">如何解决生命周期问题？</h2><p id="b814" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">界面被定义为交流每时每刻发生的事情。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="c7a2" class="jo jp hh mw b fi na nb l nc nd">public interface Lifecycle {<br/><br/>    interface View {<br/><br/>    }<br/><br/>    interface ViewModel {<br/><br/>        void onViewResumed();<br/>        void onViewAttached(@NonNull Lifecycle.View viewCallback);<br/>        void onViewDetached();<br/>    }<br/>}</span></pre><p id="d115" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该视图将调用生命周期。ViewModel#onViewResumed()在其onResume()方法中。生命周期。ViewModel#onViewAttached(this)在onStart() one和生命周期中。onDestroy()中的ViewModel#onViewDetached()。</p><p id="176f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，<strong class="ir hi">ViewModel就知道生命周期</strong>，并且决定何时显示或不显示某个内容的逻辑会转到ViewModel(就像它应该做的那样),因此它可以相应地采取行动，并在获得信息时通知视图。</p><h2 id="f0cf" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">视图和视图模型之间的契约</h2><p id="6872" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">契约定义了视图需要从视图模型中得到什么，反之亦然。虽然您也可以按功能定义合同，但通常您是按屏幕定义合同的。</p><p id="e277" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的例子中，我们有主屏幕，它能够刷新用户数据。我们可以将合同定义为:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="a387" class="jo jp hh mw b fi na nb l nc nd">public interface HomeContract {<br/><br/>    interface View extends Lifecycle.View {<br/><br/>        void showSuccessfulMessage(String message);<br/>    }<br/><br/>    interface ViewModel <strong class="mw hi">extends Lifecycle.ViewModel</strong> {<br/><br/>        void getUserData();<br/>    }<br/>}</span></pre><p id="371e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个契约是从生命周期契约扩展而来的，所以视图模型也将是生命周期感知的。</p><h1 id="0f4d" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated">RxJava 2反应流类型</h1><p id="9c25" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">在RxJava 2中，引入了一些概念，并重命名了其他一些概念。<a class="ae jn" href="https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0" rel="noopener ugc nofollow" target="_blank">查看文档了解更多信息</a>。</p><p id="7a62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它们之间的主要区别是背压处理。基本上，在RxJava2中，一个<strong class="ir hi">可流动的</strong>是一个处理背压的观察器。同样的关系将一个<strong class="ir hi">流处理器</strong>链接到一个主题，将一个<strong class="ir hi">订户</strong>链接到一个观察者，等等。</p><p id="7e41" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="mu">记住一个</em> <strong class="ir hi"> <em class="mu">可完成的</em></strong><em class="mu"/><strong class="ir hi"><em class="mu">单个的</em></strong><em class="mu"/><strong class="ir hi"><em class="mu">也许</em> </strong> <em class="mu">不处理反压。</em></p><p id="ac45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于学习的目的，我们将使Retrofit返回一个可观察的对象。如果我们想处理反压力呢？如果我们知道我们期望的结果，并且想要优化我们的代码来指定我们想要得到的流，那该怎么办呢？我们会谈到这一点。</p><h2 id="8522" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">使用Completable</h2><p id="5889" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">让我们以注册呼叫为例。因为RegistrationAPIService正在处理信息，所以我们不希望返回流，因为RequestManager层不使用响应。<strong class="ir hi">我们只关心通话是否成功</strong>。为此，我们返回一个Completable对象，忽略从可观察对象中获得的元素。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="9eb2" class="jo jp hh mw b fi na nb l nc nd">public <strong class="mw hi">Completable</strong> register(RegistrationRequest request) {<br/><br/>    return registrationAPI.register(request)<br/>            .doOnSubscribe(disposable -&gt; isRequestingRegistration = true)<br/>            .doOnTerminate(() -&gt; isRequestingRegistration = false)<br/>            .subscribeOn(Schedulers.<em class="mu">io</em>())<br/>            .observeOn(AndroidSchedulers.<em class="mu">mainThread</em>())<br/>            .onErrorResumeNext(this::handleRegistrationError)<br/>            .doOnNext(registrationResponse -&gt; processRegistrationResponse(request, registrationResponse))<br/><strong class="mw hi">            .ignoreElements();<br/></strong>}</span></pre><h2 id="aa38" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">使用可能</h2><p id="d0a3" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果我们想要将响应传递回RequestManager层，但是因为它是一个网络请求<strong class="ir hi">，我们知道我们将只接收一个对象</strong>，我们可以使用Maybe(可能主体是空的，所以我们使用Maybe来避免空对象时的异常)。</p><p id="e30d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记住使用<strong class="ir hi"> singleElement() </strong>操作符，而不是firstElement()操作符。如果您使用第二个元素，但什么也没有得到，它将抛出一个异常，因为它总是试图访问第一个元素，即使它不在那里。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="4a5c" class="jo jp hh mw b fi na nb l nc nd">public <strong class="mw hi">Maybe&lt;LoginResponse&gt;</strong> login(LoginRequest request) {<br/><br/>    return loginAPI.login(request.getNickname(), request.getPassword())<br/>            .doOnSubscribe(disposable -&gt; isRequestingLogin = true)<br/>            .doOnTerminate(() -&gt; isRequestingLogin = false)<br/>            .subscribeOn(Schedulers.<em class="mu">io</em>())<br/>            .observeOn(AndroidSchedulers.<em class="mu">mainThread</em>())<br/>            .onErrorResumeNext(this::handleLoginError)<br/>            .doOnNext(this::processLoginResponse)<br/><strong class="mw hi">            .singleElement();<br/></strong>}</span></pre><h2 id="2ae2" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">使用可流动</h2><p id="ceed" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">正如我们之前所说的，可流动的物体将具有与可观察物体相同的行为，但是将处理背压。为此，<strong class="ir hi">当将一个可观察对象转换为一个可流动对象时，我们必须指定我们想要使用的策略</strong>。</p><p id="c25f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些是不同的策略:</p><ul class=""><li id="9542" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated">BUFFER:缓冲所有onNext值，直到下游使用它。</li><li id="a9fc" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">DROP:如果下游跟不上，则丢弃最近的onNext值。</li><li id="7d46" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">错误:发出MissingBackpressureException信号以防下游跟不上。(这与可观察到的行为相同。)</li><li id="e66b" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">LATEST:仅保留最新的onNext值，如果下游跟不上，则覆盖任何以前的值。</li><li id="9eb8" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">MISSING:写入onNext事件时没有任何缓冲或丢弃。</li></ul><p id="89ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的游戏示例中，我们将使用<strong class="ir hi">缓冲策略</strong>，因为我们不想在下游跟不上的情况下丢失任何游戏。可能会慢一些，但他们都会在那里。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="6e00" class="jo jp hh mw b fi na nb l nc nd">public <strong class="mw hi">Flowable&lt;GamesResponse&gt;</strong> getGames(GamesRequest request) {<br/><br/>    return gamesAPI.getGamesInformation(request.getNickname())<br/>            .doOnSubscribe(disposable -&gt; isRequestingGames = true)<br/>            .doOnTerminate(() -&gt; isRequestingGames = false)<br/>            .subscribeOn(Schedulers.<em class="mu">io</em>())<br/>            .observeOn(AndroidSchedulers.<em class="mu">mainThread</em>())<br/>            .doOnError(this::handleAccountError)<br/><strong class="mw hi">            .toFlowable(BackpressureStrategy.<em class="mu">BUFFER</em>);<br/></strong>}</span></pre><h2 id="63c9" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">使用Zip运算符同时发出不同的网络请求</h2><p id="8b7c" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果您想同时发出不同的网络请求，并且只在所有请求都成功时得到通知，那么您应该使用Zip操作符。它真的很强大，是我的最爱之一！</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="ff72" class="jo jp hh mw b fi na nb l nc nd">#UserDataRequestManager.java</span><span id="5409" class="jo jp hh mw b fi ne nb l nc nd">public Flowable&lt;Object&gt; getUserData() {<br/><br/>    return <strong class="mw hi">Flowable.<em class="mu">zip</em></strong>(<br/>                getAccount(),<br/>                getGames(),<br/>                this::processUserDataResult);<br/>}</span><span id="1104" class="jo jp hh mw b fi ne nb l nc nd">private Flowable&lt;AccountResponse&gt; getAccount() {<br/><br/>    return accountAPIService.getAccount(createAccountRequest());<br/>}<br/><br/>private Flowable&lt;GamesResponse&gt; getGames() {<br/><br/>    return gamesAPIService.getGames(createGamesRequest());<br/>}</span></pre><h2 id="fc27" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">连接不同的网络请求</h2><p id="f228" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">我们可以看到每个网络请求如何返回不同类型的流。让我们看看怎样才能把它们锁起来。这个想法是让注册请求、登录和用户数据一次完成。</p><p id="0f91" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">UserData返回一个可流动的，但是，登录请求返回一个可能，所以我们必须匹配它们:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="12e2" class="jo jp hh mw b fi na nb l nc nd">#AuthenticationRequestManager.java</span><span id="4891" class="jo jp hh mw b fi ne nb l nc nd">private MaybeSource&lt;Object&gt; <strong class="mw hi">makeGetUserDataRequest</strong>(LoginResponse loginResponse) {<br/><br/>    return userDataRequestManager.getUserData().singleElement();<br/>}</span></pre><p id="3854" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果响应成功，登录请求将获得用户数据。由于我们准备了getUserDataRequestMethod来返回一个Maybe，我们可以用一个<strong class="ir hi"> flatMap()操作符</strong>将它们连接起来:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="8b3c" class="jo jp hh mw b fi na nb l nc nd">#AuthenticationRequestManager.java</span><span id="a2f3" class="jo jp hh mw b fi ne nb l nc nd">public MaybeSource&lt;Object&gt; <strong class="mw hi">login()</strong> {<br/><br/>    return loginAPIService.login(createLoginRequest())<br/>            .<strong class="mw hi">flatMap</strong>(this::makeGetUserDataRequest);<br/>}</span></pre><p id="fb2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果我们想发出注册调用，然后发出登录请求，我们只需在Completable完成后调用它。我们用<strong class="ir hi">和Then()操作符</strong>来做这件事。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="481f" class="jo jp hh mw b fi na nb l nc nd">#AuthenticationRequestManager.java</span><span id="0cb8" class="jo jp hh mw b fi ne nb l nc nd">public MaybeSource&lt;Object&gt; <strong class="mw hi">register()</strong> {<br/><br/>    return registrationAPIService.register(createBodyForRegistration())<br/>            .<strong class="mw hi">andThen</strong>(makeLoginRequest());<br/>}</span><span id="fe8b" class="jo jp hh mw b fi ne nb l nc nd">private MaybeSource&lt;Object&gt; makeLoginRequest() {<br/><br/>    return login();<br/>}</span></pre><h1 id="df9c" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated">观察源</h1><p id="a365" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果我们看一下文档，我们可以看到<strong class="ir hi">观察者</strong>(对于可观察的)和<strong class="ir hi">订户</strong>(对于可流动的)如何在他们的接口中公开一个新方法:<strong class="ir hi"> onSubscribe() </strong>。</p><p id="67b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个观察者用一个<strong class="ir hi"> Disposable，</strong>来订阅，这让它可以处理/取消订阅。一个<strong class="ir hi">订阅者</strong>订阅了一个订阅，除了取消它之外，它还可以请求项目(我们可以在这里看到背压功能)。</p><p id="71c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数情况下，我们不希望在观察者或订阅者中覆盖onSubscribe方法(就像我们以前在RxJava 1中做的那样)。为此，我们只需通过<strong class="ir hi"> DisposableObserver </strong>或<strong class="ir hi"> DisposableSubscriber </strong>订阅流。</p><p id="e0f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你观察一个流时，如果你想获得Subscription/Disposable你必须使用方法<strong class="ir hi"> subscribeWith() </strong>而不是subscribe()。</p><p id="1ebb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您不打算取消订阅，可以使用subscribe():</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="5db1" class="jo jp hh mw b fi na nb l nc nd">public void getUserData() {<br/><br/>    userDataRequestManager.getUserData()<br/>            .<strong class="mw hi">subscribe</strong>(new HomeSubscriber());<br/>}</span></pre><p id="5956" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想退订/处理:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="23ab" class="jo jp hh mw b fi na nb l nc nd">public void getUserData() {<br/><br/>    <strong class="mw hi">Disposable</strong> userDataSubscription = userDataRequestManager.getUserData()<br/>            .<strong class="mw hi">subscribeWith</strong>(new HomeSubscriber());<br/><br/>    userDataSubscription.dispose();<br/>}</span></pre><h1 id="0c44" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated"><strong class="ak">后台处理和生命周期</strong></h1><p id="2b05" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">为了避免在视图不在屏幕上时通知视图，我们希望保留信息直到视图变得可见(准备好做应该做的事情)，然后发送信息。在我们的用例中，当应用程序在后台或视图不在那里时，我们只想发出一个网络请求，而不是多个请求。</p><p id="a8b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">选项1:使用生命周期合同方法</strong></p><p id="748f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用生命周期方法，我们创建了一个抽象类，它将为我们处理请求状态。我们可以保存状态和在那里发生的最后一个错误。</p><p id="0b6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还必须根据流的类型创建不同的观察器。例如，登录请求由一个MaybeObserver处理。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="1f3e" class="jo jp hh mw b fi na nb l nc nd">protected class MaybeNetworkObserver&lt;T&gt; extends DisposableMaybeObserver&lt;T&gt; {<br/><br/>    @Override<br/>    public void onSuccess(T value) {<br/><br/>        requestState = <em class="mu">REQUEST_SUCCEEDED</em>;<br/>    }<br/><br/>    @Override<br/>    public void onError(Throwable e) {<br/><br/>        lastError = e;<br/>        requestState = <em class="mu">REQUEST_FAILED</em>;<br/>    }<br/><br/>    @Override<br/>    public void onComplete() {<br/><br/>    }<br/>}</span></pre><p id="cc70" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如您所看到的，onSuccess(T)是在这种情况下将requestState设置为SUCCEEDED的方法，因为它是一个DisposableMaybeObserver(如果它是一个DisposableObserver，那么它应该在onComplete()方法中)。当发出网络请求时，登录视图模型将使用这个观察器。如果我们看一下这个类，这些方法被定义为:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="29c6" class="jo jp hh mw b fi na nb l nc nd">public class LoginViewModel extends <strong class="mw hi">NetworkViewModel</strong> implements <strong class="mw hi">LoginContract.ViewModel</strong> {</span><span id="a4a4" class="jo jp hh mw b fi ne nb l nc nd">   public void login() {<br/><br/>       authenticationRequestManager.login()<br/>            .<strong class="mw hi">subscribe</strong>(new LoginObserver());<br/>   }</span><span id="b644" class="jo jp hh mw b fi ne nb l nc nd">}</span><span id="7ffa" class="jo jp hh mw b fi ne nb l nc nd">private class LoginObserver extends MaybeNetworkObserver&lt;Object&gt; {<br/><br/>    @Override<br/>    public void onSuccess(Object value) {<br/><br/>        onLoginCompleted();<br/>    }<br/><br/>    @Override<br/>    public void onError(Throwable e) {<br/><br/>        onLoginError(e);<br/>    }<br/><br/>    @Override<br/>    public void onComplete() {<br/><br/>    }<br/>}</span></pre><p id="cf0c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">onLoginError()和onLoginCompleted()是类中定义的方法，用于处理快乐和悲伤的场景。如你所见，在这种情况下，我们可以在authenticationRequestManager Maybe流上调用subscribe()，因为<strong class="ir hi">我们不会取消订阅它</strong>。</p><p id="39eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">app到后台</strong>我们怎么处理这个？我们使用onViewResumed()方法:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="285b" class="jo jp hh mw b fi na nb l nc nd">@Override<br/>public void onViewResumed() {<br/><br/>    @RequestState int requestState = getRequestState();<br/>    if (requestState == <strong class="mw hi"><em class="mu">REQUEST_SUCCEEDED</em></strong>) {<br/>        onLoginCompleted();<br/>    } else if (requestState == <strong class="mw hi"><em class="mu">REQUEST_FAILED</em></strong>) {<br/>        onLoginError(getLastError());<br/>    }<br/>}</span></pre><p id="a286" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当视图恢复时，如果我们的状态是REQUEST_SUCCEEDED，那么我们通知视图。如果失败，我们会通知错误。您可能已经注意到，当响应到来时，LoginObserver类中的代码已经被调用。如果它在那里，我们会通知它的，对吗？我们需要一个空检查来避免调用不存在的视图。请参见下面的代码:</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="ebcd" class="jo jp hh mw b fi na nb l nc nd">private void onLoginCompleted() {<br/><br/>    if (<strong class="mw hi">viewCallback != null</strong>) {<br/><br/>        viewCallback.hideProgressDialog();<br/>        viewCallback.launchHomeActivity();<br/>    }<br/>}</span></pre><h2 id="9a42" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated"><strong class="ak">选项2:使用处理器(有反压支持的对象)</strong></h2><p id="abec" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">当我们在HomeActivity上拉刷新时，HomeViewModel将获取UserData。我们将使用一个<strong class="ir hi">处理器</strong>，而不是使用普通用户。</p><p id="6814" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该解决方案的设计考虑到了的<strong class="ir hi">拉取刷新行为。我们总是想提出那个网络请求；如果您不想发出多个网络请求，而只想得到最后一个响应，那么实现会略有不同。</strong></p><p id="fb0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这个例子，我们将使用一个<strong class="ir hi"> AsyncProcessor </strong>，因为我们只想要源发出的尚未使用的最后信息，而不是所有的元素。</p><p id="536f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们拉刷新时，我们总是发出getUserData()网络请求。然而，当视图从视图模型中分离时，<strong class="ir hi">我们不取消网络请求，而是在视图恢复时处理信息</strong>。</p><p id="1154" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关键是异步处理器。这个对象将订阅用户数据流，并且<strong class="ir hi">它将保存该信息，直到订阅者请求它</strong>。</p><p id="897b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们总是想发出网络请求，所以我们每次都创建一个新的AsyncProcessor。然后，我们向AsyncProcessor订阅我们希望获得响应的对象，并将它保存在一个本地字段中(这样我们就可以在分离视图时释放它)。最后，我们使用AsyncProcessor作为订阅者发出网络请求。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="6f21" class="jo jp hh mw b fi na nb l nc nd"># HomeViewModel.java<br/>private <strong class="mw hi">AsyncProcessor&lt;Object&gt; userDataProcessor</strong>;<br/>private <strong class="mw hi">Disposable userDataDisposable</strong>;</span><span id="1dcd" class="jo jp hh mw b fi ne nb l nc nd">public void getUserData() {<br/><br/>    userDataProcessor = AsyncProcessor.<strong class="mw hi"><em class="mu">create</em></strong>();<br/>    userDataDisposable = userDataProcessor.subscribeWith(new HomeSubscriber());<br/><br/>        userDataRequestManager.getUserData().subscribe(userDataProcessor);<br/>}</span></pre><p id="81cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">视图分离后会发生什么</strong>？我们取消了现有的一次性用品。请注意，网络请求没有被取消，因为它已经被AsyncProcessor订阅了。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="dd52" class="jo jp hh mw b fi na nb l nc nd">@Override<br/>public void onViewDetached() {<br/><br/>    this.viewCallback = null;<br/><br/>    if (isNetworkRequestMade()) {<br/>        userDataDisposable.dispose();<br/>    }<br/>}</span><span id="5a62" class="jo jp hh mw b fi ne nb l nc nd">private boolean isNetworkRequestMade() {<br/>    <br/>    return userDataDisposable != null;<br/>}</span></pre><p id="9112" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当视图恢复时，我们检查是否发出了网络请求。如果是，我们将订户重新连接到异步处理器。如果网络请求正在路上，我们会在它到达时得到通知。如果它已经来了，我们会马上得到通知。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="daa0" class="jo jp hh mw b fi na nb l nc nd">@Override<br/>public void onViewResumed() {<br/><br/>    if (isNetworkRequestMade()) {<br/>        <br/>        userDataProcessor.subscribe(new HomeSubscriber());<br/>    }<br/>}</span></pre><p id="d751" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">这种解决方案的特点是用户的代码永远不会在后台执行。</strong>因此，我们不必检查视图的可空性，因为viewCallback对象永远不会为空。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="953f" class="jo jp hh mw b fi na nb l nc nd">private class HomeSubscriber extends DisposableSubscriber&lt;Object&gt; {<br/><br/>    @Override<br/>    public void onNext(Object o) {<br/><br/>    }<br/><br/>    @Override<br/>    public void onError(Throwable t) {<br/><br/>        viewCallback.showSuccessfulMessage("Refreshed");<br/>    }<br/><br/>    @Override<br/>    public void onComplete() {<br/><br/>        viewCallback.showSuccessfulMessage("Refreshed");<br/>        viewCallback.hideLoading();<br/>    }<br/>}</span></pre><h1 id="1bb7" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated">模仿改造网络的要求</h1><p id="94f2" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果你看一下这个项目，我正在模拟客户端的网络请求，并添加了一个延迟，这样我就可以在应用程序进入后台时测试它。</p><p id="6cbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用改装生成器上的<strong class="ir hi">RxJava 2 calladapterfactory</strong>启用改装的rx Java 2功能。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="c025" class="jo jp hh mw b fi na nb l nc nd">public static Retrofit getAdapter() {<br/><br/>    OkHttpClient okHttpClient = new OkHttpClient.Builder()<br/>            .<strong class="mw hi">addInterceptor(new MockInterceptor())</strong><br/>            .build();<br/><br/>    return new Retrofit.Builder()<br/>            .baseUrl("http://www.mock.com/")<br/>            .client(okHttpClient)<br/>            .addConverterFactory(GsonConverterFactory.<em class="mu">create</em>())<br/>            .addCallAdapterFactory(RxJava2CallAdapterFactory.<em class="mu">create</em>())<br/>            .build();<br/>}</span></pre><p id="ec2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">拦截器总是在两秒钟后返回成功的响应。它可以改进，检查发出了哪个请求，然后将正确的JSON响应作为主体的一部分返回。</p><pre class="kk kl km kn fd mv mw mx my aw mz bi"><span id="8b1a" class="jo jp hh mw b fi na nb l nc nd">public class MockInterceptor implements Interceptor {<br/><br/>    @Override<br/>    public Response intercept(Chain chain) throws IOException {<br/><br/><strong class="mw hi">        addDelay();<br/></strong><br/>        return new Response.Builder()<br/>                .code(200)<br/>                .message("OK")<br/>                .request(chain.request())<br/>                .protocol(Protocol.<em class="mu">HTTP_1_0</em>)<br/>                .body(ResponseBody.<em class="mu">create</em>(MediaType.<em class="mu">parse</em>("application/json"), "{}"))<br/>                .build();<br/>    }<br/><br/>    private void addDelay() {<br/>        try {<br/>            Thread.<em class="mu">sleep</em>(2000);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><h1 id="dc86" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated"><strong class="ak">其他考虑事项</strong></h1><p id="7ff1" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果你看一看回购，<strong class="ir hi">代码的某些部分相当差</strong>。你注意到单件的使用了吗？(例如，UserDataRequestManager)它伤害了我的眼睛，但我没有时间让它变得更好。</p><p id="1958" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能会想…有什么问题？嗯，<strong class="ir hi">单元测试单件是可怕的</strong>，因为它们在单元测试之间保持它们的状态。</p><p id="c73c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你会如何解决这个问题？<strong class="ir hi">依赖注入！你可以手动完成，四处传递对象(这并不理想)，或者你可以集成Dagger 2(这比Dagger 1好得多，因为这都是在编译时)。我会避免手动操作，因为你最终会在顶层架构类(主要在视图中)中使用大量的方法，这些方法会创建和传递只在底层架构中使用的对象(**叹气* *)。想象一下，一个片段必须创建一个APIService并通过所有层传递它！恐怖！</strong></p><h1 id="00e9" class="lg jp hh bd jq lh li lj ju lk ll lm jy ln lo lp kb lq lr ls ke lt lu lv kh lw bi translated"><strong class="ak">结论</strong></h1><p id="c180" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">确保当您将代码迁移到RxJava2时，您使用了您想要的流和观察器。</p><p id="e3aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个很好的总结，关于如何使用MVVM构建你的应用，并以一种有效的方式处理视图生命周期。</p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><h1 id="e9d6" class="lg jp hh bd jq lh nm lj ju lk nn lm jy ln no lp kb lq np ls ke lt nq lv kh lw bi translated"><strong class="ak">其他文章</strong></h1><p id="e15b" class="pw-post-body-paragraph ip iq hh ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">让所有这些在配置更改后继续存在怎么样？看看我写的另一篇文章。</p><div class="mc md ez fb me mf"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/surviving-configuration-changes-using-dagger-b08042f67092"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">使用Dagger幸存的配置更改</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">自己动手！</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">medium.com</p></div></div><div class="mo l"><div class="nr l mq mr ms mo mt in mf"/></div></div></a></div><p id="b045" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="mu">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em></p></div></div>    
</body>
</html>