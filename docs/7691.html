<html>
<head>
<title>Hacking Node Core HTTP Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑客节点核心HTTP模块</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/hacking-node-core-http-module-f2a10ea3028e?source=collection_archive---------3-----------------------#2017-10-25">https://medium.com/walmartglobaltech/hacking-node-core-http-module-f2a10ea3028e?source=collection_archive---------3-----------------------#2017-10-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4bdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di"> O </span>我在<a class="jl jm ge" href="https://medium.com/u/c884135151a4?source=post_page-----f2a10ea3028e--------------------------------" rel="noopener" target="_blank"> @WalmartLabs </a>写的支持NodeJS的一个模块是我出于需要不得不做的。它对NodeJS核心中的<code class="du jn jo jp jq b">http</code>模块进行了黑客攻击和猴子修补。在这篇博客中，我将回顾一下为什么和如何做到这一点。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h2 id="d242" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">大写和小写HTTP头</h2><p id="96a9" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我们有一个用Java实现的SOA微服务架构。它支持注册和自动发现、客户端验证和服务代理。该实现添加了一些自定义的HTTP头。</p><p id="f7da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的NodeJS应用程序平台需要提供的一个东西是连接到我们内部微服务的标准方式。我很快遇到了一个问题；我测试的服务都返回了HTTP 500错误，表明我的请求缺少自定义头。</p><p id="11a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">经过一些健全性检查和手工制作cURL请求的尝试后，我意识到Java SOA库只允许定制的大写HTTP头。不幸的是，Node core自动将所有的HTTP头转换成小写，这很好，因为根据RFC 2616,<a class="ae ky" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html" rel="noopener ugc nofollow" target="_blank">HTTP头不区分大小写。</a></p><p id="4180" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我尝试的第一件事是为拥有SOA的团队寻找联系人。一段时间后，很明显，修复并不简单，因为:</p><ol class=""><li id="dc9d" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">SOA v1.0版被部署到所有服务中，更新所有服务需要一些时间。</li><li id="1cf2" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">SOA团队正在开发2.0版，没有可用的周期来修复这个问题。</li></ol><p id="38a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这让我处于非常困难的境地。我们的努力受阻了吗？</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h2 id="bbd2" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">猴子补丁来拯救</h2><p id="ab24" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">JavaScript的动态特性导致了一种被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank">猴子补丁</a>的现象。它允许您替换或更改不打算公开的代码。一般来说，这是不好的，但有时，这是通过关键拦截的唯一方式。</p><p id="aa68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鉴于HTTP头的小写是在节点核心中硬编码的，很明显monkey patch是我唯一的选择。所以我开始研究核心的<code class="du jn jo jp jq b">http</code>模块。</p><p id="da2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当时，NodeJS正准备发布4.2.4。没有太多的装饰，我很容易地找到了位置<a class="ae ky" href="https://github.com/nodejs/node/blob/d3a40c51c5770b4def9a6033df0fa46c6f9f0cc7/lib/_http_outgoing.js#L369" rel="noopener ugc nofollow" target="_blank">传出的HTTP头被转换成小写字母的位置</a>。</p><p id="22e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Monkey修补代码也很简单。我只是复制了<code class="du jn jo jp jq b">setHeader</code>的方法，打了补丁，替换了原来的版本:</p><pre class="ln lo lp lq fd lr jq ls lt aw lu bi"><span id="792d" class="jy jz hh jq b fi lv lw l lx ly">var http = require("http");</span><span id="73a3" class="jy jz hh jq b fi lz lw l lx ly">http.OutgoingMessage.prototype.setHeader = function(name, value) {<br/>  // original code etc</span><span id="e86b" class="jy jz hh jq b fi lz lw l lx ly">  var key;<br/>  if (!name.startsWith("FOO_")) {<br/>    key = name.toLowerCase();<br/>  } else {<br/>    key = name;<br/>  }</span><span id="0d22" class="jy jz hh jq b fi lz lw l lx ly">  // original code that updates this._headers<br/>};</span></pre><p id="9294" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就成功了。NodeJS中任何以<code class="du jn jo jp jq b">FOO_</code>开头的HTTP头的大写字母。当然，我们实际的内部头使用另一个前缀签名。</p><h2 id="d75b" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">测试</h2><p id="3774" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">单元测试这有点棘手。节点核心还将所有传入的HTTP头转换为小写。因此，测试用类似的猴子补丁<code class="du jn jo jp jq b">http</code> <code class="du jn jo jp jq b">IncomingMessage</code>来捕获和验证原始形式的HTTP报头。</p><p id="5864" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实际的测试使用<a class="ae ky" href="https://www.npmjs.com/package/mitm" rel="noopener ugc nofollow" target="_blank"> mitm </a>来伪造一个HTTP服务器，然后向它发出一个请求，请求中使用了一些大写的自定义HTTP头。然后，服务器的请求处理程序验证它们没有小写。</p><h2 id="a918" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">节点8.3.0</h2><p id="5a02" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">NodeJS 8.3.0的发布带来了全新的v8发动机涡轮风扇，优化效果更好。我立即测试了我们应用的React <code class="du jn jo jp jq b">renderToString</code>性能。结果是我们的一个生产应用的渲染时间持续减少了60%。这是一个巨大的收获。所以我们立即着手用Node 8.3.0运行回归。</p><p id="d725" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，Node 8对<code class="du jn jo jp jq b">http</code>模块有一些重大改变。其中之一是<code class="du jn jo jp jq b">OutgoingMessage</code>对象现在隐藏了<code class="du jn jo jp jq b">_headers</code>字段。不是<code class="du jn jo jp jq b">this._headers</code>，而是<code class="du jn jo jp jq b">this[outHeadersKey]</code>，其中<code class="du jn jo jp jq b">outHeadersKey</code>是这里创建的一个<code class="du jn jo jp jq b">Symbol</code> <a class="ae ky" href="https://github.com/nodejs/node/blob/05a7fc5b5d5c703d77f01bf77809fb404d249c71/lib/internal/http.js#L24" rel="noopener ugc nofollow" target="_blank">。更重要的是，这是一个用户代码无法访问的内部模块。因为一个</a><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">符号总是唯一的</a>并且我没有办法获得对内部<code class="du jn jo jp jq b">outHeadersKey</code>符号的引用，所以我不能再用monkey补丁修改输出头了。</p><p id="c037" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我花了一些时间查看做出这些更改的<a class="ae ky" href="https://github.com/nodejs/node/pull/10941" rel="noopener ugc nofollow" target="_blank">拉请求</a>，以理解它们背后的基本原理。我还查看了官方为用户代码访问HTTP头添加的方法。对于改变硬编码的小写行为，我似乎无能为力。</p><p id="a29a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">意识到这一点后，我举了一下手。我的猴子补丁就这样结束了吗？我们的SOA v2.0已经发布，但我不确定它的采用情况。这是否意味着使用节点8在一段时间内是不可行的？如果我们不能利用所有的性能提升，那将是一个巨大的失败。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h2 id="04d2" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">符号API</h2><p id="324c" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">在没有明确选择的情况下，我开始研究新的<code class="du jn jo jp jq b">Symbol</code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank"> API文档。</a></p><p id="2ac6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最初除了<code class="du jn jo jp jq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for" rel="noopener ugc nofollow" target="_blank">Symbol.for</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for" rel="noopener ugc nofollow" target="_blank">方法</a>之外，没有什么突出的东西。我认为这是我获得核心的<code class="du jn jo jp jq b">outHeadersKey</code>符号参考的关键，所以我甚至没有阅读文档，并立即尝试它。嗯，5分钟后没有运气，我回去真的读了文件。我找到了原因:</p><blockquote class="ma mb mc"><p id="bf7d" class="ie if md ig b ih ii ij ik il im in io me iq ir is mf iu iv iw mg iy iz ja jb ha bi translated">与<code class="du jn jo jp jq b">Symbol()</code>相反，<code class="du jn jo jp jq b">Symbol.for()</code>函数创建一个在全局符号注册表中可用的符号。</p></blockquote><p id="f054" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">啊，是<em class="md">全局符号注册表列表</em>，对！此时我以为游戏结束了，但我继续浏览<code class="du jn jo jp jq b">Symbol</code>上的文档。</p><p id="ea0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我注意到了<code class="du jn jo jp jq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" rel="noopener ugc nofollow" target="_blank">Object.getOwnPropertySymbols</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" rel="noopener ugc nofollow" target="_blank"> API </a>。不确定这是否可行，我去试了一下。</p><p id="54f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">长话短说，它成功了，下面是我如何设法进入内部的<code class="du jn jo jp jq b">outHeadersKey</code>符号。</p><pre class="ln lo lp lq fd lr jq ls lt aw lu bi"><span id="0ab4" class="jy jz hh jq b fi lv lw l lx ly">const http = require("http");<br/>const assert = require("assert");</span><span id="b1d5" class="jy jz hh jq b fi lz lw l lx ly">function hackFinity() {<br/>  const x = new http.OutgoingMessage();<br/>  const s = Object.getOwnPropertySymbols(x);<br/>  assert(typeof s[0] === "symbol" &amp;&amp;<br/>    s[0].toString() === "Symbol(outHeadersKey)");</span><span id="ed15" class="jy jz hh jq b fi lz lw l lx ly">  return s[0];<br/>}</span><span id="51d2" class="jy jz hh jq b fi lz lw l lx ly">const outHeadersKey = hackFinity();</span></pre><p id="d892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">咻，monkey修补了业务，NodeJS中出现了大写的HTTP头。</p><h2 id="f6c3" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">mitm</h2><p id="2466" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">因为mitm在核心层攻击Node，所以它在Node 8中停止工作。毫不奇怪，单元测试停止工作也是因为它们依赖于mitm。所以我不得不修改测试，在本地主机上启动一个真正的HTTP服务器，监听一个随机端口，然后向它发送带有自定义HTTP头的请求以进行验证。</p><h2 id="1e7d" class="jy jz hh bd ka kb kc kd ke kf kg kh ki ip kj kk kl it km kn ko ix kp kq kr ks bi translated">结论</h2><p id="d519" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">Monkey patch不是一个好主意，但它是我发现的使用JS的好处之一，它让我在一些情况下摆脱了困境。只有在绝对必要时，才应尽量少用。Node 8的小小恐慌为我敲响了警钟，我意识到我应该与SOA团队一起跟进，以确保有修复该问题的计划。就目前而言，我们仍然在用猴子补丁来传递这个拦截器。到目前为止，我还没有注意到任何负面影响，但这是一件需要进一步研究的事情。</p></div></div>    
</body>
</html>