<html>
<head>
<title>Exposing Container Services to a Bridge Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向桥接网络公开容器服务</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/exposing-container-services-to-a-bridge-network-aa5fe17a9332?source=collection_archive---------5-----------------------#2017-11-06">https://medium.com/capital-one-tech/exposing-container-services-to-a-bridge-network-aa5fe17a9332?source=collection_archive---------5-----------------------#2017-11-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8938" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在未链接的容器之间共享信息</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/571b79c6da6bc6abbb276ed9e141a1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IL2zqIIm3lEwk0_tfOMj2w.png"/></div></div></figure><p id="037d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">容器被设计为独立运行，并与共享操作系统的其余部分隔离，但是在某些情况下，信息需要在容器之间共享。在分布式环境中使用容器时尤其如此，比如分布式缓存或分布式k/v存储。一种常见的方法是在主机模式下运行所有容器，这将容器置于主机网络中。这种方法的一个缺点是，由于网络不是集装箱化的，并且可以直接访问集装箱的每个端口，所以集装箱现在不是真正隔离的。此外，容器将无法在主机模式下公开相同的端口，因此默认情况下，拥有多个公开端口80的容器将不起作用。尽管为了隔离容器并避免使用端口映射，以桥接模式运行容器可能更好，但如果容器必须在彼此之间共享信息，这确实会增加复杂性。然而，这不应该成为在主机模式下运行容器的理由，因为我们将展示一个简单的解决方案来在桥模式下共享容器上的服务。</p><p id="1cf9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在本演练中介绍的是一种替代方法，可以与运行在同一虚拟机上的其他容器共享容器化的服务，而任何容器都不必共享主机网络的命名空间。我们将通过几个简单的步骤演示如何使用docker的端口转发标志、iptables规则和extrahosts在桥接网络上的容器之间公开服务信息。如果您不熟悉iptables，请随意查看附加资源部分，因为iptables是我们解决方案的重要组成部分。如果您已经对iptables有了很好的理解，可以跳过这一节，直接进入我们的工作示例，在这个示例中，我们展示了在桥接网络上，运行Consul的容器如何通过运行带有consul-template的HAProxy的容器来访问。</p><h1 id="4e3f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">使用Consul和iptables的示例</h1><p id="6842" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">您的容器主机是否包含大量运行共享服务的Docker容器？这些容器需要相互之间以及其他人的容器可以访问。为了在不链接或不使用主机的网络名称空间的情况下实现这一点，我们设置了iptables规则来转发往来于一个众所周知的链路本地地址的流量。让我们看一个简单的例子，运行领事的容器如何被运行带有领事模板的HAProxy的容器访问。</p><p id="37a9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae lb" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> Consul </a>是一个用于服务发现的分布式高可用工具，而<a class="ae lb" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>是一个高可用负载平衡器，它利用consul-template在Consul发现新服务时动态创建其配置文件。正如你所看到的，为了让这个设置工作，在HAProxy容器中运行的consul-template需要监听来自consul的新事件。虽然我们可以简单地在主机模式下运行两个容器，而consul-template可以在端口8500上监听，但是我们将描述一个两个容器都在桥模式下运行的替代方案。</p><p id="28bc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，在端口8500上运行带有端口转发的Consul容器:</p><ol class=""><li id="88c5" class="lc ld hh jk b jl jm jo jp jr le jv lf jz lg kd lh li lj lk bi translated">码头运行–p 8500:8500领事</li></ol><p id="bd2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将在网桥网络上运行Consul容器，同时允许其端口8500在主机网络上可见。Docker实际上是在幕后使用iptables来实现这一点的，它创建了一个规则，将数据包从主机网络的端口8500转发到容器的端口。如果在您的主机上运行下面的命令，您可以看到这一点。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ll"><img src="../Images/aa93484e2fe31876dc7505fe5c731044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBVfXHrv8unAnATKrRV9Gg.png"/></div></div></figure><p id="e971" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您将看到一个名为Docker的链，它具有上面提到的规则。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lm"><img src="../Images/e06086d55972d56e552f7769f9fb39d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0NcBd8kIFIhPEuQwU_YMQ.png"/></div></div></figure><p id="cefb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，在CIDR块169.254.0.0/16中选择一个链路本地地址，该地址会将流量转发到localhost:8500，这是Consul正在侦听的地址。我们使用链路本地地址，因为这些地址是本地保留的，不能从主机网络外部直接路由到。在本例中，我们使用地址169.254.32.1。</p><p id="db53" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后在iptables中定义以下两条规则:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/6151bf2269a96683b9d2a885f4fd23b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoPKA1YbnUsbA-M970MhIw.png"/></div></div></figure><p id="16b1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第一条规则将在169.242.32.1:80收到的TCP请求路由到主机网络。然而，由于Consul监听端口8500，我们在输出链中创建第二个规则，从端口80重定向到端口8500。</p><p id="2d2d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面你可以看到<strong class="jk hi"><em class="lo">GET/v1/agent/members</em></strong>现在在localhost:8500和链接本地地址169.254.32.1:80上都能工作了:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/32b3fb30d2b5f0090e24c3f1099bc80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BE8F_JpBJlUPkalutpGJ-A.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/6b4722d745b3d6d83e29ee87317000d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QixI3lBHrVKTHoMZek7n3g.png"/></div></div></figure><p id="6b12" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这种设置的一个问题是链路本地地址不太可读。为了解决这个问题，在每个应用程序容器上的<strong class="jk hi"> <em class="lo"> /etc/hosts </em> </strong>中添加一个条目，将地址consul.local指向196.254.32.1。您可以手动完成此操作，或者在docker run命令中添加–add-host标志。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/6b244c2dc5ac901c22abd88aafb0796f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfH-pX9AbkvYIFncfJwfsQ.png"/></div></div></figure><p id="c61d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，容器中的应用程序可以通过地址consul.local访问Consul。</p><p id="8087" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面的截图显示了我们设置的iptables规则</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lr"><img src="../Images/c618c1d0f2f2f7b7233767bb437803a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QL28YMAWCku3S5P25gVUg.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx"><strong class="bd kg">ECS Cluster Configuration</strong></figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/f28d34861e268044e74d49a32d37b197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIMjDoyDi6yoH2tdlwyljQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx"><strong class="bd kg">iptable rules we created along with the extrahost mapping</strong></figcaption></figure><h1 id="6545" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated"><strong class="ak">结论</strong></h1><p id="1868" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">总之，在本演练中，我演示了如何在桥接网络上运行Consul，然后使用Docker的端口转发标志来创建iptable规则，以使其端口在主机网络上可见。接下来，我选择了一个链接本地地址，并创建了两个iptable规则，将在该地址收到的TCP请求路由到特定端口的主机。最后，我展示了如何使用extrahosts，这样就可以使用可读性更好的地址，比如consul.local，而不是实际的链接本地地址。现在，您可以从HAProxy容器向consul.local发送请求，并与consul容器连接，而不需要任何一个容器位于主机网络上。</p><p id="db5c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望本演练对您有所帮助，并且您现在已经知道了主机和桥模式之间的区别，以及如何在每种模式下的服务之间共享信息。</p><h1 id="d2a5" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated"><strong class="ak">附加信息:</strong></h1><p id="de38" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">http://www.iptables.info/en/iptables-contents.html<a class="ae lb" href="http://www.iptables.info/en/iptables-contents.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="cba5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">【https://wiki.archlinux.org/index.php/Iptables T4】</p><p id="e661" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lo">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2017首都一。</em></p></div></div>    
</body>
</html>