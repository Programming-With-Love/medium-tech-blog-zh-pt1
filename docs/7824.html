<html>
<head>
<title>A Glimpse into the World of Embedded Database Feat. RocksDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌入式数据库领域的一瞥。RocksDB</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/https-medium-com-kharekartik-rocksdb-and-embedded-databases-1a0f8e6ea74f?source=collection_archive---------2-----------------------#2019-11-20">https://medium.com/walmartglobaltech/https-medium-com-kharekartik-rocksdb-and-embedded-databases-1a0f8e6ea74f?source=collection_archive---------2-----------------------#2019-11-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3831438648bad92563c787ed3182d22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_wfmng_uhRF09Gw"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@jankolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jan Kolar / VUI Designer</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d03f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RocksDB 是脸书创建的一个数据库。它不支持SQL，不提供ACID保证，并且不能以分布式方式运行。尽管如此，它仍然是开发者生态系统中最受欢迎的数据库之一。它被用在诸如Apache Flink和<a class="ae it" href="https://www.cockroachlabs.com/blog/cockroachdb-on-rocksd/" rel="noopener ugc nofollow" target="_blank">cocroach db</a>这样的高规模框架中。</p><p id="dc38" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么，是什么让RocksDB成为超越竞争对手的令人信服的选择呢？</p><p id="d7db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了理解它的用例，首先，我们需要了解一下嵌入式数据库的世界。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/65dc77b1916c79af7a2a73c43a38ee5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUmIZFPuTR32EcCCpUya6g.png"/></div></div></figure><h1 id="b15b" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">嵌入式数据库</h1><p id="9dae" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">顾名思义，开发人员将嵌入式数据库放在使用它的服务/应用程序中。这意味着如果您的应用程序运行在容器/服务器A中，数据库也将出现在相同的位置。网络呼叫会导致显著的延迟。通过避免它们，您可以将数据库访问时间减少几个数量级。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Latency Numbers Every Programmer Should Know by <a class="ae it" href="https://github.com/jboner" rel="noopener ugc nofollow" target="_blank">Jonas Bonér</a></figcaption></figure><p id="527e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，这种设计选择的明显限制是，您既不能保证数据库的可用性，也不能存储超出当前机器容量的数据。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/43a5804fd76c75256986e27c3b1c5431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsmM_ixjG7v5V4GnmFK8Lw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Embedded Database Architecture</figcaption></figure><h2 id="c837" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">什么时候应该使用嵌入式数据库？</h2><p id="f443" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">如果需要存储大量数据，但是这些数据可以快速地重新创建，并且不是关键数据，那么应该使用嵌入式数据库。将这样的数据存储在应用程序的内存中是不可靠的，而以某种简单的格式存储在磁盘上将导致很高的延迟。</p><p id="ada5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个领域中最流行的数据库之一是SQLite。Android应用程序广泛使用它来存储详细信息，例如用户是否已经登录，以及用户id、出生日期、地址等。从服务器获取所有数据的成本很高，而一旦关闭应用程序，内存中的数据就会消失。</p><h1 id="c9d4" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">RocksDB</h1><p id="9979" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">虽然SQLite在大多数情况下都很好，但是它有一个严重的局限性。SQLite是一个单线程数据库，不支持并发访问。这种无法多线程化的特性使得它在高吞吐量的情况下执行速度非常慢。</p><p id="9c05" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于这个限制，Google创建了支持多线程的LevelDB。脸书以LevelDB为基础创建了RocksDB。另一个流行的嵌入式数据库是T4 LMDB T5。LMDB拥有与LevelDB完全不同的体系结构，在特定场景中表现出色。然而，为了保持内容简短，我将在本文中重点讨论RocksDB。</p><p id="56e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们来看看LevelDB和RocksDB共有的一些概念，这些概念使它们比它们的前辈强大得多。</p><h2 id="31de" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">表</h2><p id="c692" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">Google创建了BigTable，它使用下面的<a class="ae it" href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/" rel="noopener ugc nofollow" target="_blank"> SSTable </a>来存储数据。RocksDB中使用了相同的表。表以键值的方式存储数据。数据也根据关键字进行排序。排序允许快速访问数据，因为在排序的关键字范围内搜索很容易。</p><p id="57b3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">表本质上也是不可变的。这意味着您可以从SSTable中读取数据，而不用担心它在mid中被修改(如果有一个SSTable的话)。</p><p id="ba55" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">LevelDB和RocksDB共享相同的<a class="ae it" href="https://github.com/google/leveldb/blob/master/doc/table_format.md" rel="noopener ugc nofollow" target="_blank">表格式</a>，只是RocksDB包含更多类型的元数据块。元数据块包含文件属性，如用于填充压缩库的字典或压缩过程中使用的过滤器。您可以在下面找到一般的表格格式:</p><pre class="jt ju jv jw fd lr ls lt lu aw lv bi"><span id="6a57" class="ld jy hh ls b fi lw lx l ly lz">&lt;beginning_of_file&gt;<br/>[data block 1]<br/>[data block 2]<br/>...<br/>[data block N]<br/>[meta block 1]<br/>...<br/>[meta block K]<br/>[metaindex block]<br/>[index block]<br/>[Footer]        (fixed size; starts at file_size - sizeof(Footer))<br/>&lt;end_of_file&gt;</span></pre><p id="ccea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该文件包含内部指针。每个这样的指针称为块句柄，包含以下信息:</p><pre class="jt ju jv jw fd lr ls lt lu aw lv bi"><span id="7585" class="ld jy hh ls b fi lw lx l ly lz">offset:   varint64<br/>size:     varint64</span></pre><h2 id="b5fb" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">日志结构合并树</h2><p id="d844" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">如果只将数据存储在一个表中，它会变得很大，从而减少访问时间。此外，你不能简单地创建多个固定大小的表，因为随着文件数量的增加，这将导致同样的问题。</p><p id="89f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree" rel="noopener ugc nofollow" target="_blank"> LSM树</a>就是为了解决上述问题而产生的。当固定大小的表超过一个数时，它们被合并成一个更大的表。这一步称为压缩，在后台进行。例如，如果10MB的s表文件的数量超过10个，则它们被合并以创建单个100MB的s表文件。对于新数据，将创建最小大小的新表，例如1MB。</p><p id="73c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最新的数据总是在最小的文件中找到，而最旧的数据驻留在较大的文件中。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/16dff382000472e766f0dc42f1156198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aiOk96pp4sR9QgTxB9ibQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Log-Structured Merged Format</figcaption></figure><h2 id="17dc" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">内存表</h2><p id="0e5b" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">DB首先将数据插入到一个简单排序的内存结构(称为Memtable)和一个磁盘文件(称为提交日志)中。这使得访问最近的数据非常快，因为它已经存在于内存中。</p><p id="c93d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为Memtable已经被排序，所以它被转储到磁盘中以创建一个SSTable。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/0ca9a9bda3e7e97259b04afde8987d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wsd1-D8jGFI19qe3XVVS9w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Memtable, Commit Log and SSTables organization in RocksDB</figcaption></figure><h1 id="6739" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么为什么不仅仅使用LevelDB呢？</h1><p id="eda6" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">RocksDB几乎在每个方面都改进了level DB，这使得它与Google的产品相比是一个有吸引力的选择。</p><p id="8d7d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看RocksDB为改进其前身所采取的措施。</p><h2 id="56b3" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">不要读不存在的东西</h2><p id="8087" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">BloomFilters允许用户快速知道数据库中是否存在某个键。它们有助于防止对数据库的不必要的读取，并使查询响应更快。</p><p id="4659" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RocksDB将bloom filter方法带到了下一步。它为整个数据库之外的每个Memtable和SSTable实现了一个bloom filter。</p><h2 id="0bee" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">更新您的密钥，无忧无虑</h2><p id="2c06" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated"><a class="ae it" href="https://github.com/facebook/rocksdb/wiki/Column-Families" rel="noopener ugc nofollow" target="_blank">列族</a>是一种帮助用户在单个数据库中对数据进行逻辑分区的机制。用户可以跨列族对多个键进行安全的原子写入。</p><p id="4b74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">列族共享预写日志，不共享memtables和表文件。通过共享预写日志，您可以获得原子写入的好处。通过分离memtables和表文件，可以独立配置列族并快速删除它们。例如，将元数据存储在一个列族中，将实际数据存储在另一个列族中。然后，您可以对元数据和数据应用不同类型的压缩和压缩策略。如果需要，可以在保留数据的同时删除元数据列族。</p><h2 id="259d" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">拍快照</h2><p id="f9ab" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">因为RocksDB不提供ACID保证，所以您读取的数据可能会在多个请求之间发生变化，例如，由于压缩用一个值替换另一个值。</p><p id="f0f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，如果您的应用程序需要一致的数据视图，您可以在RocksDB中创建一致的快照。局限性在于，它不会包含创建快照后插入的任何数据。</p><h2 id="f38c" class="ld jy hh bd jz le lf lg kd lh li lj kh jf lk ll kl jj lm ln kp jn lo lp kt lq bi translated">避免部分更新</h2><p id="e388" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">RocksDB支持悲观和乐观并发控制的事务。</p><p id="345a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在悲观流中，DB锁定用户正在修改的所有密钥，这使它安全但缓慢。乐观流不进行任何锁定，并在提交时解决任何可能的冲突。</p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="5bf9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了前面提到的主要变化，RocksDB还提供了一些附加功能:</p><ul class=""><li id="52c4" class="mj mk hh iw b ix iy jb jc jf ml jj mm jn mn jr mo mp mq mr bi translated">开箱即用的速率限制器，用于控制数据库的吞吐量</li><li id="76db" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">多线程压缩使它们更快</li><li id="67ae" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">多种压缩算法，如LZ4，GZIP，SNAPPY等。</li></ul><p id="937f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解更多详情，您可以参考下面提到的文章:</p><ol class=""><li id="84fa" class="mj mk hh iw b ix iy jb jc jf ml jj mm jn mn jr mx mp mq mr bi translated"><a class="ae it" href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/" rel="noopener ugc nofollow" target="_blank">表和日志结构化存储:LevelDB </a></li><li id="d88e" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mx mp mq mr bi translated"><a class="ae it" href="http://rocksdb.blogspot.com/2013/11/the-history-of-rocksdb.html" rel="noopener ugc nofollow" target="_blank">RocksDB的历史</a></li><li id="9799" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mx mp mq mr bi translated"><a class="ae it" href="https://www.slideshare.net/mobile/HiveData/tech-talk-rocksdb-slides-by-dhruba-borthakur-haobo-xu-of-facebook" rel="noopener ugc nofollow" target="_blank"> RocksDB技术讲座</a></li></ol></div></div>    
</body>
</html>