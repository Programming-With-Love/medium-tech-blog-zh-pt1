<html>
<head>
<title>The Z Garbage Collector algorithm (JDK 15 version)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Z垃圾收集器算法(JDK 15版本)</h1>
<blockquote>原文：<a href="https://medium.com/globant/the-z-garbage-collector-algorithm-jdk-15-version-ca6da00b5281?source=collection_archive---------0-----------------------#2020-12-09">https://medium.com/globant/the-z-garbage-collector-algorithm-jdk-15-version-ca6da00b5281?source=collection_archive---------0-----------------------#2020-12-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="c96e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="d837" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">9月25日，JDK 11号发射升空。在其他特性中，<a class="ae kj" href="https://openjdk.java.net/jeps/333" rel="noopener ugc nofollow" target="_blank"> Z垃圾收集器</a>算法，也称为ZGC，是作为一个实验特性引入的。几周前的9月15日，JDK 15发布了，最新版本的ZGC现在<a class="ae kj" href="https://openjdk.java.net/jeps/377" rel="noopener ugc nofollow" target="_blank">准备生产</a>。</p><p id="8b9c" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">简而言之，ZGC是一个可扩展的低延迟垃圾收集器，最大GC暂停时间为10毫秒，能够处理从几兆字节到几兆字节的堆，最大吞吐量减少15%。</p><h2 id="076a" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">JVM垃圾收集器</h2><p id="ca8b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">到目前为止，JVM已经介绍了一个有趣的垃圾收集器算法列表，让我们通过下面介绍的最重要的算法列表和简要描述来记住它们。</p><ul class=""><li id="7786" class="ld le hh je b jf kk jj kl jn lf jr lg jv lh jz li lj lk ll bi translated"><strong class="je hi">串行(低内存占用):</strong>它使用单线程来完成工作。它适用于单处理器机器，并针对低内存占用量(通常是嵌入式系统)进行了优化。</li><li id="69ca" class="ld le hh je b jf lm jj ln jn lo jr lp jv lq jz li lj lk ll bi translated"><strong class="je hi"> Parallel(吞吐量收集器):</strong>它并行进行少量收集，以减少垃圾收集开销。它是为运行在多处理器硬件上的中型到大型数据集应用程序而构建的。</li><li id="d3f6" class="ld le hh je b jf lm jj ln jn lo jr lp jv lq jz li lj lk ll bi translated"><strong class="je hi"> CMS(并发标记-清除收集器):</strong>它旨在缩短垃圾收集器暂停时间。专门为具有大量长寿命对象或大量有期限一代的应用程序而设计。CMS收集器是分代的。</li><li id="3e42" class="ld le hh je b jf lm jj ln jn lo jr lp jv lq jz li lj lk ll bi translated"><strong class="je hi"> G1(吞吐量/延迟平衡):</strong>垃圾优先(Garbage-First)是一个服务器风格的垃圾收集器，为具有大内存的多处理器机器而设计。它是一个压缩收集器(它压缩到足以避免使用细粒度空闲列表进行分配)。</li><li id="9873" class="ld le hh je b jf lm jj ln jn lo jr lp jv lq jz li lj lk ll bi translated"><strong class="je hi"> ZGC(低延迟)</strong></li></ul><blockquote class="lr ls lt"><p id="656f" class="jc jd lu je b jf kk jh ji jj kl jl jm lv km jp jq lw kn jt ju lx ko jx jy jz ha bi translated">串行和并行被称为“世界停止”算法。CMS在JDK 9中被弃用，G1取而代之。</p></blockquote><p id="395b" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">比较它们很有意思。并强调ZGC同时执行所有繁重的运算，这是其他算法所不具备的(更多细节见下文)。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h1 id="0f85" class="ie if hh bd ig ih mf ij ik il mg in io ip mh ir is it mi iv iw ix mj iz ja jb bi translated">深入Z垃圾收集器</h1><p id="4d08" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated"><span class="l kb kc kd bm ke kf kg kh ki di"> Z </span> GC是一个并发的低延迟算法，除了线程堆栈扫描之外，它执行所有并发的操作(标记、压缩、引用处理、重定位集选择、字符串表清理、JNI WeakRef清理、JNI GlobalRefs扫描和类卸载)。这使得该算法非常适合低延迟。</p><p id="eba6" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">值得一提的重要一点是，目前，暂停时间<em class="lu">不会随着堆或活动大小</em>而增加，然而，暂停时间<em class="lu">会随着根集大小(您的应用程序正在使用的java线程的数量)而增加。</em></p><p id="ed79" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">从算法的角度来看，它是一个并发收集器，当java线程继续执行时，它完成所有繁重的工作。它是一个基于区域的收集器，这意味着堆被划分为更小的区域，压缩工作将集中在这些区域的子集上，即垃圾最多的区域。它是NUMA感知的，由于CPU的本地内存，它减少了延迟。它使用彩色指针和负载屏障，这些将在下面的章节中详细介绍。而且是单代收藏家，没有老少之分，<em class="lu">还没有</em>。</p><h2 id="6431" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated"><strong class="ak">ZGC阶段</strong></h2><p id="b4dd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">ZGC的GC循环分为三个暂停。</p><p id="cb9e" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">在第一阶段，暂停标记开始，ZGC遍历对象图来标记对象是活的还是垃圾。此阶段还包括实时数据的重新映射。</p><p id="b7db" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">第二个阶段，暂停标记结束，是引用预处理完成的地方。类卸载和重定位集选择也在这个阶段完成。</p><p id="0363" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">暂停重定位开始，最后一个阶段，是压缩堆的繁重工作发生的地方。</p><h2 id="e780" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated"><strong class="ak">彩色指针</strong></h2><p id="e1d9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">它们是ZGC的核心设计理念。该算法使用64位对象指针中一些未使用的位来存储一些元数据，这允许查找、标记、定位和重新映射对象。下图显示了64位对象指针和每个位的含义。</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mk"><img src="../Images/0a7a1aeb2ce079bc0daacd96b8481c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CG5uYLyByTLQn7_YzZLLgw.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">Colored pointers diagram.</figcaption></figure><h2 id="40d3" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated"><strong class="ak">负载屏障</strong></h2><p id="993b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">它是JIT在一些战略位置注入的代码。目标是检查加载的对象引用是否有错误的颜色。当线程从堆中加载对象引用时，加载屏障代码将运行。</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es na"><img src="../Images/feb920c4c6f1f5aac7cdc21d482bd5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRP-uuark_PGZcincFh9Bg.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">Load Barrier example</figcaption></figure></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h1 id="2fcc" class="ie if hh bd ig ih mf ij ik il mg in io ip mh ir is it mi iv iw ix mj iz ja jb bi translated"><strong class="ak">调谐选项</strong></h1><p id="3909" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">让我描述一下如何使用ZGC和一些有趣的参数进行调优。从JDK 11版到JDK 15版，如果您想使用ZGC算法，您必须解锁实验选项:</p><p id="9a2a" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu">-XX:+unlockeexperimentalvmoptions-XX:+use zgc</em></p><p id="51e7" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">从JDK 15版开始，您可以通过指定以下内容来使用它:</p><p id="7170" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC </em></p><p id="3b0b" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">ZGC被设计成易于调音。以下是具体的ZGC选项列表:</p><figure class="ml mm mn mo fd mp er es paragraph-image"><div class="er es nb"><img src="../Images/8db5c9c489565f1f035d57588a53cb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*EoA3uGFcAOlXnFz2DddfJg.png"/></div></figure><p id="7d08" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">为了了解所用的时间并查看有关算法行为的一些数字，最好打印垃圾收集器日志，只需在选择ZGC时添加以下命令来查看简单的日志:</p><p id="2090" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;尺寸&gt; -Xlog:gc </em></p><p id="c283" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">或者，如果您想打印垃圾收集器日志以获得更多详细信息，请执行以下操作:</p><p id="2da6" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;尺寸&gt; -Xlog:gc* </em></p><p id="4321" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">现在，让我们开始看看最有趣的调优选项。</p><h2 id="0fcd" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">设置堆大小</h2><p id="9959" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在ZGC中要调优的一个最重要的选项是设置最大堆大小(<em class="lu"> -Xmx &lt; size &gt; </em>)。我们必须为我们的应用程序找到正确的值，因为我们不想失去内存，我们希望在GC运行时，我们的应用程序有足够的空间来容纳活动对象和分配。下面是一个使用示例:</p><p id="7d90" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;尺寸&gt;T3】</em></p><h2 id="5444" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">设置并发GC线程</h2><p id="e84a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">尽管ZGC有自动设置这个数字的启发式方法，但有时，根据我们的应用程序，指定并发GC线程的数量可能会很有趣。这个选项决定了你的GC将占用多少CPU，所以你必须小心你想要给的容量。</p><p id="c021" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;尺寸&gt;-XX:congcthreads =&lt;数量&gt; </em></p><h2 id="29a6" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">将未使用的内存返回给操作系统</h2><p id="5285" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">与其他GC算法不同，ZGC取消了未使用内存的提交，将其交还给操作系统。对于内存占用可能成为问题的应用程序，这可能是必要的。如果要禁用这个选项，可以使用-XX:-ZUncommit。</p><p id="3845" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;大小&gt; -XX:-ZUncommit </em></p><h2 id="3721" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">在Linux上启用大页面</h2><p id="f898" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这是一个带来性能改进的选项，没有缺点或副作用。唯一的问题是它需要root权限，这就是为什么不是默认选项，并且可能无法为您的应用程序启用它。请查看文档以正确设置该选项。这需要准备一些东西，选项如下:</p><p id="5853" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu">-XX:+use zgc-Xms16G-Xmx16G-XX:+use large pages</em></p><h2 id="0dfd" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">在Linux上启用透明的大页面</h2><p id="eb5c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于对延迟敏感的应用程序，不建议使用Huges页面，尽管它可以很好地替代前面的调优选项。</p><p id="4a6c" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu">-XX:+UseZGC-…-XX:+use large pages-XX:+UseTransparentHugePages</em></p><p id="d0d1" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">在这种情况下，我强烈建议您在您的应用程序中进行试验，并注意峰值，如果出现峰值，这可能不适合您的情况。</p><h2 id="194e" class="kp if hh bd ig kq kr ks ik kt ku kv io jn kw kx is jr ky kz iw jv la lb ja lc bi translated">启用NUMA支持</h2><p id="7654" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如我前面说过的，ZGC是NUMA感知的，这意味着这个选项是默认启用的。这将把Java堆分配定向到NUMA本地内存。JVM可以自动禁用它，如果您需要显式覆盖该行为，您可以使用选项-XX:+UseNUMA或-XX:-UseNUMA。</p><p id="24a9" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;大小&gt; -XX:+UseNUMA </em></p><p id="46bd" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu">或</em></p><p id="4cdc" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><em class="lu"> -XX:+UseZGC -Xmx &lt;大小&gt; -XX:-UseNUMA </em></p><p id="6237" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">算法的维基页面上有更多信息。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h1 id="40f5" class="ie if hh bd ig ih mf ij ik il mg in io ip mh ir is it mi iv iw ix mj iz ja jb bi translated">接下来会发生什么？</h1><p id="cb95" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">ZGC团队的路线图中有两件事引起了我的注意。</p><p id="6e38" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">首先，该团队正在努力将最大暂停时间减少到1毫秒。线程堆栈扫描将同时进行，这也意味着暂停时间不会随着根集大小(<a class="ae kj" href="https://openjdk.java.net/jeps/376" rel="noopener ugc nofollow" target="_blank"> JEP 376 </a>)而增加。</p><p id="c010" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">第二，他们将使ZGC分代，因为大多数对象是短命的，这将是另一个很好的改进。</p><h1 id="cded" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">参考</h1><p id="971a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">【https://openjdk.java.net/jeps/333 T2】号</p><p id="9d7e" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated">【https://openjdk.java.net/jeps/377 T4】</p><p id="5316" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><a class="ae kj" href="http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zGlobals_linux_x86.hpp#l39" rel="noopener ugc nofollow" target="_blank">http://Hg . open JDK . Java . net/zgc/zgc/file/59 c 07 AEF 65 AC/src/hotspot/OS _ CPU/Linux _ x86/zGlobals _ Linux _ x86 . HPP # l39</a></p><p id="5f62" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><a class="ae kj" href="https://wiki.openjdk.java.net/display/zgc/Main" rel="noopener ugc nofollow" target="_blank">https://wiki.openjdk.java.net/display/zgc/Main</a></p><p id="0217" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><a class="ae kj" href="https://www.youtube.com/watch?v=88E86quLmQA" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=88E86quLmQA</a></p><p id="bc22" class="pw-post-body-paragraph jc jd hh je b jf kk jh ji jj kl jl jm jn km jp jq jr kn jt ju jv ko jx jy jz ha bi translated"><a class="ae kj" href="http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf" rel="noopener ugc nofollow" target="_blank">http://Cr . open JDK . Java . net/~ pliden/slides/ZGC-福斯德姆-2018.pdf </a></p></div></div>    
</body>
</html>