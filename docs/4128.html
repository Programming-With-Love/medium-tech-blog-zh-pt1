<html>
<head>
<title>Functional Reactive Programming para Desenvolvedores Android — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于 Android 开发人员的函数式响应式编程 — 第 3 部分</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/functional-reactive-programming-para-desenvolvedores-android-part-3-461c2f558565?source=collection_archive---------2-----------------------#2017-03-21">https://medium.com/google-developer-experts/functional-reactive-programming-para-desenvolvedores-android-part-3-461c2f558565?source=collection_archive---------2-----------------------#2017-03-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8e3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您好,首先祝贺您观看本系列的前两篇文章,我首先介绍了在<a class="ae jc" rel="noopener" href="/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-i-53788a4fbc9f#.ds3wsaxim">首篇文章</a>中响应式编程背后的概念和理论,然后是第二篇文章更具技术性的文章,重点是配置RxJava库和创建简单的Observable以发送数据流和观察者(订阅者),该观察者将监听并响应接收数据的步骤。</p><p id="7d5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中,我将谈论:</p><ul class=""><li id="5093" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">RxJava中的函数或运算符以及可以用它们做什么。</li></ul><h1 id="cd67" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">函数或操作员</h1><p id="bd00" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">正如我在第一个post-reactive programming中解释的那样,它就像是Observer Pattern的升级,而不是只有一个组件发出数据流,另一个组件接收和响应数据流,有一组函数(运算符),允许您根据您希望数据流在接收观察者时的形式以各种方式操纵数据流。</p><p id="2d38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了从事件、数据流和应用于此流的函数的角度来理解它是什么以及实际发生的事情,我将使用一个称为<em class="kp">大理石图(T5)的表示来解释。</em></p><h2 id="ef88" class="kq jn hh bd jo kr ks kt js ku kv kw jw ip kx ky ka it kz la ke ix lb lc ki ld bi translated">大理石图(Marble Diagram,T7)</h2><p id="2566" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">简单来说,大理石图表允许您表示异步数据流。</p><p id="3e8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如下图所示,水平线上的两条线代表<strong class="ig hi">时间。</strong>在此期间,数据流从左向右输出,垂直于时间线(有时为“x”)的最右侧的小线表示数据流的结束。</p><p id="d6a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">两条线之间的矩形表示一个函数,该函数将应用于数据流中要发出的每个元素。</p><p id="7b22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要解读大理石图,需要:</p><ul class=""><li id="3094" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">查看函数之前的第一个时间线;</li><li id="1b38" class="jd je hh ig b ih le il lf ip lg it lh ix li jb ji jj jk jl bi translated">抓住正在发出一次一个元素;</li><li id="e2b2" class="jd je hh ig b ih le il lf ip lg it lh ix li jb ji jj jk jl bi translated">应用矩形中表示的函数</li><li id="7371" class="jd je hh ig b ih le il lf ip lg it lh ix li jb ji jj jk jl bi translated">最后,将转换后的元素放入函数中,与该函数在输出时间轴中通过该函数的时刻相同。</li></ul><p id="1dec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此,取下图中的第2号元素:</p><p id="8d6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该元素由源发出,并通过一个函数(在本例中将其值乘以 map 函数中的 10) <strong class="ig hi"> </strong> 将其转换为值为 20 的新数字。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/eee37f6e3970ad91619c693e4700987e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZlxqnkNN29XS8waRt9yoQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Marble Diagram, Map Function from <a class="ae jc" href="http://rxmarbles.com/#map" rel="noopener ugc nofollow" target="_blank">http://rxmarbles.com/#map</a></figcaption></figure><p id="b6c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kp">提示:</em><strong class="ig hi"><em class="kp"/></strong><em class="kp"> 大理石图是一种非常实用的</em>方式<em class="kp">来理解操作员的工作方式,只要它的实现或文档不是很清楚。<br/> Reactive Streams的官方网站和</em> <a class="ae jc" href="http://rxmarbles.com/#map" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> RxMarbles </em> </a> <em class="kp">包含了很多很好的表示形式,可以帮助您在通过操作员后查看输出流。(T16)</em></p><h1 id="d400" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">有趣的运算符(在我看来很重要)</strong></h1><p id="9820" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">在 <a class="ae jc" href="http://reactivex.io/documentation/operators.html" rel="noopener ugc nofollow" target="_blank"> ReactiveX </a> 网站上有大量的运算符和最佳实践。</p><p id="9066" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中,我将只关注那些我认为很重要的,并且在Android应用程序开发中反复使用的内容。</p><p id="d3a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">map — </strong> 如上所示,map 运算符是最简单的运算符之一,因为它的工作是接收数据流中发出的每个项目,并根据定义的函数将其转换为另一个项目(相同类型或不同类型)。<br/>如下面的例子所示,Observable发出一个名称,但使用函数<strong class="ig hi">map,</strong>字符串“Dario”被转换为“Hello I am Dario”,并发给订阅者。<em class="kp">超级简单= </em></p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="319c" class="kq jn hh ma b fi me mf l mg mh">Observable.<em class="kp">just</em>(<strong class="ma hi">"Dario"</strong>).map(<strong class="ma hi">new </strong>Func1&lt;String, String&gt;() {<br/>    @Override<br/>    <strong class="ma hi">public </strong>String call(String name) {<br/>        <strong class="ma hi">return </strong>String.<em class="kp">format</em>(<strong class="ma hi">"Hello I am %s"</strong>, name);<br/>    }<br/>});</span></pre><p id="29a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> flatMap — </strong> 平面映射运算符的工作方式类似于映射运算符,它将每个输出的项目转换为数据流,只不过返回一个新的可观察的数据流而不是一个项目。</p><p id="41de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然有一个运算符可以帮助对数据流中的项目进行排序,如下面的代码所示,但我使用了flatMap运算符将电影列表转换为按字母顺序排列的电影列表,只需在flatMap中执行排序操作并发出一个新的observable,该命令将电影列表按标题排序。</p><p id="c356" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">flatMap的一个有趣的用例可以在需要对一个API进行两次调用时找到,其中一个依赖于另一个来启动。</p><p id="5e1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如,如果您需要加载喜爱的电影列表,然后获取每部电影的详细信息,则可以创建一个 Observable(调用 API 加载喜爱的电影的 id),该 API 将发送由电影的 id 组成的数据流,并在每个流元素上使用 flatMap 运算符返回另一个 Observable(调用 ID 加载电影的数据),以构成仅能播放电影和详细信息的单个流。</p><p id="320c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要实现这一目标,需要编写大量代码,使用回调在第一个调用返回电影id后立即启动第二个调用。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="9e2b" class="kq jn hh ma b fi me mf l mg mh"><strong class="ma hi">public </strong>Observable&lt;List&lt;Movie&gt;&gt; loadMovies() {<br/>    <strong class="ma hi">return service</strong>.loadMovies().flatMap(<strong class="ma hi">new </strong>Func1&lt;List&lt;Movie&gt;, Observable&lt;List&lt;Movie&gt;&gt;&gt;() {<br/>        @Override<br/>        <strong class="ma hi">public </strong>Observable&lt;List&lt;Movie&gt;&gt; call(List&lt;Movie&gt; movies) {<br/>            MovieUtils.<em class="kp">sortByTitleAsc</em>(movies);<br/>            <strong class="ma hi">return </strong>Observable.<em class="kp">just</em>(movies);<br/>        }<br/>    });<br/>}</span></pre><h2 id="1f02" class="kq jn hh bd jo kr ks kt js ku kv kw jw ip kx ky ka it kz la ke ix lb lc ki ld bi translated">订阅VS ObserveOn</h2><p id="d70e" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">这两个运算符是反应式编程的宝石,因为它们在并发编程中非常容易,其中多个线程用于并行执行不同的任务。</p><p id="6a3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回到Android开发的基础,一个启动的应用程序在主线程(UI Thread)上运行,它负责执行诸如管理图形界面,监听用户事件等任务,以确保应用程序始终响应用户。<br/>执行无限期结束的任务,例如在互联网上调用API或从本地数据库加载数据等,会阻止主线程继续执行其工作,从而导致应用程序崩溃并向用户返回错误。</p><p id="850f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从Android的早期,像AsyncTasks,Loaders这样的框架解决方案允许创建一个新的线程来执行这些任务,并最终将响应发送回主线程。</p><p id="5c5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最大的问题是,像依赖于 Activity 的 AsyncTask 这样的解决方案不是很灵活,特别是如果您考虑编写易于维护和测试的代码(任何使用过 AsyncTasks 和 Loaders 的人都知道代码有多复杂)。</p><h2 id="b072" class="kq jn hh bd jo kr ks kt js ku kv kw jw ip kx ky ka it kz la ke ix lb lc ki ld bi translated"><strong class="ak">subscribeOn </strong></h2><p id="3c22" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">查看本系列文章中编写的所有示例,所有创建的 Observable 都会在主线程中发出数据流,其中订阅者调用了 [<strong class="ig hi"> subscribe </strong> 方法给 Observable。</p><p id="3660" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此,如果数据流的任何生产者执行具有无限终止时间的操作(API调用),他们肯定会遇到与阻止线程(如Android的主线程)相关的问题。</p><p id="9748" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用 subscribeOn 运算符,您可以指定生产者将使用哪个线程来发送数据流。<br/>此运算符接收一个 Scheduler 作为参数,该 Scheduler 负责创建和管理线程,如下面的代码所示,调用 API 以加载显示的电影将在由<strong class="ig hi"> Schedulers.newThread 创建的新线程上执行。</strong></p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="019e" class="kq jn hh ma b fi me mf l mg mh"><strong class="ma hi">public </strong>Observable&lt;List&lt;Movie&gt;&gt; getShowingMovies(){<br/>    <strong class="ma hi">return </strong>Observable.<em class="kp">just</em>(loadShowingMovies())<br/>            .subscribeOn(Schedulers.<em class="kp">newThread</em>());<br/>}<br/><br/><strong class="ma hi">public </strong>List&lt;Movie&gt; loadShowingMovies(){<br/>    List&lt;Movie&gt; showingMovies = <strong class="ma hi">new </strong>ArrayList&lt;&gt;();<br/>    <em class="kp">//load from network and return list<br/>    </em><strong class="ma hi">return  </strong>showingMovies;<br/>}</span></pre><h2 id="a0b0" class="kq jn hh bd jo kr ks kt js ku kv kw jw ip kx ky ka it kz la ke ix lb lc ki ld bi translated">(T8) ObserveOn (T9)</h2><p id="d8cf" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">使用 subscribeOn 操作符创建另一个线程来加载显示的电影后,您可能需要指定订阅者将接收数据流的线程。对于上面的例子,您很可能希望订阅者在应用程序的主线程中接收数据流,但如果需要,您可以使用observeOn操作符定义另一个线程。</p><p id="13ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与 subscribeOn 操作符类似,observeOn 接收一个 Scheduler 作为参数,该 Scheduler 将定义和管理订阅者将接收数据流的线程。</p><p id="23ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要设置订阅者接收 Android 主线程中的数据流,需要传递调度器 <strong class="ig hi"> AndroidSchedulers.MainThread </strong> 作为参数,该参数是 <a class="ae jc" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank"> RxAndroid </a> 库的一部分(RxJava 库扩展指定的 Android),如下面的代码所示:</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="1d6e" class="kq jn hh ma b fi me mf l mg mh"><strong class="ma hi">public </strong>Observable&lt;List&lt;Movie&gt;&gt; getShowingMovies(){<br/>    <strong class="ma hi">return </strong>Observable.<em class="kp">just</em>(loadShowingMovies())<br/>            .subscribeOn(Schedulers.<em class="kp">newThread</em>())<br/>            .//outros operadores flatMap, map, etc<br/>            .observeOn(AndroidSchedulers.mainThread());<br/>}<br/><br/><strong class="ma hi">public </strong>List&lt;Movie&gt; loadShowingMovies(){<br/>    List&lt;Movie&gt; showingMovies = <strong class="ma hi">new </strong>ArrayList&lt;&gt;();<br/>    <em class="kp">//load from network and return list<br/>    </em><strong class="ma hi">return  </strong>showingMovies;<br/>}</span></pre><h2 id="63c0" class="kq jn hh bd jo kr ks kt js ku kv kw jw ip kx ky ka it kz la ke ix lb lc ki ld bi translated">需要考虑的几件事</h2><ul class=""><li id="2688" class="jd je hh ig b ih kk il kl ip mi it mj ix mk jb ji jj jk jl bi translated">subscribeOn 运算符只能对每个 observable 使用一次,所有在 observable 中定义的运算符,取消 observeOn,将在定义的线程上执行它们的工作。</li><li id="632e" class="jd je hh ig b ih le il lf ip lg it lh ix li jb ji jj jk jl bi translated">如果多次定义 onSusbscribeOn 运算符,则仅使用第一个定义(最接近流源的定义)。</li><li id="06d5" class="jd je hh ig b ih le il lf ip lg it lh ix li jb ji jj jk jl bi translated">可以多次使用 observeOn 运算符,并且在使用它后立即定义的所有运算符将在它指定的线程上执行其功能。(不建议这样做,因为有可能需要处理<strong class="ig hi"><em class="kp">backpressure</em></strong>的情况下,一个线程上的observable发送数据的速度比另一个线程上的observable可以处理的更快)</li></ul><p id="619a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望你现在已经了解了反应式编程的力量,以及这种模式如何帮助你在开发高质量的应用程序时变得更好。</p><p id="9603" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您有任何疑问,请不要犹豫,添加评论,以便我们可以进行对话:)</p><p id="431d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kp">如果您发现这篇文章很有趣,请点击下面的心脏点击并与朋友分享!(T9 )</em></p><p id="077e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">吃下一个,</p><p id="95ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">dm=)</p></div></div>    
</body>
</html>