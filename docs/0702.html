<html>
<head>
<title>DataStore and testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据存储和测试</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/datastore-and-testing-edf7ae8df3d8?source=collection_archive---------2-----------------------#2022-02-16">https://medium.com/androiddevelopers/datastore-and-testing-edf7ae8df3d8?source=collection_archive---------2-----------------------#2022-02-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1fea125b5da043ce725eedc85b702dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_yt1M6_QEMN0OgGU8VaZw.png"/></div></div></figure><div class=""/><p id="8aec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"> <strong class="ir ht"> Jetpack数据存储系列</strong> </a>的最后一篇文章中，我们将讲述如何<strong class="ir ht">成功测试您的数据存储。</strong></p><h1 id="2f99" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">测试数据存储</h1><p id="39ed" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">每一个好故事都需要好的检验！为了总结我们的系列，我们将回顾如何使用<strong class="ir ht">测试您的数据存储库</strong>。同样，我们将参考<a class="ae jn" href="https://developer.android.com/codelabs/android-preferences-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">首选项codelab </strong> </a>作为起点。但是，请记住，您可以使用此材料来设置<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore#0" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto DataStore</strong></a>测试，因为它与Preferences非常相似。</p><p id="d1c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要全面测试数据存储，首先需要完成<a class="ae jn" href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">仪器测试</strong> </a>的设置。这将使我们能够验证<strong class="ir ht">实际更新</strong>正在根据我们的预期对我们的存储进行，因为我们将从<strong class="ir ht">实际文件</strong>中写入和读取。</p><p id="e06c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也有可能在单元测试时仅仅<strong class="ir ht">模仿你的数据存储实例</strong>并将其作为依赖注入到另一个类，但是你不能在数据存储本身上运行<strong class="ir ht">任何真正的验证检查</strong>。</p><h2 id="27d1" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">首选项数据存储测试</h2><p id="fa82" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在我们的codelab中，负责向我们的数据存储库读写数据的类是<code class="du lf lg lh li b">UserPreferencesRepository</code>，所以我们想要验证这个类，以及它与数据存储库交互的<strong class="ir ht">函数，是否按预期工作。</strong></p><p id="04a1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们创建一个<code class="du lf lg lh li b">UserPreferencesRepositoryTest</code>类:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="47e1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经有了测试的框架，让我们开始创建我们的测试主题，<code class="du lf lg lh li b">UserPreferencesRepository</code>，并以我们的方式向后工作！</p><p id="f3a2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得<code class="du lf lg lh li b">UserPreferencesRepository</code>的实例，我们需要传递一个数据存储实例:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="09ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将构建一个快速的<code class="du lf lg lh li b">testDataStore</code>实例，它将创建一个单独的测试文件，我们可以进一步使用它来设置和验证虚拟数据:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c32d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用<code class="du lf lg lh li b">PreferenceDataStoreFactory</code>创建一个首选项数据存储实例，并传递:</p><ul class=""><li id="46e8" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated"><code class="du lf lg lh li b">testCoroutineScope</code> —我们的测试操作将在其中执行的协程作用域</li><li id="99f3" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du lf lg lh li b">produceFile</code> —使用来自<code class="du lf lg lh li b">ApplicationProvider</code>的<code class="du lf lg lh li b">testContext</code>，构建一个我们将用于写入和读取测试数据的测试文件:</li></ul><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="466d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于数据存储基于Kotlin协程，我们需要确保我们的测试有正确的协程设置。为此，我们需要添加:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="27ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个执行协程的<code class="du lf lg lh li b">CoroutineDispatcher</code>，默认情况下，它是立即执行的。这意味着任何计划运行的任务都会立即执行。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c00a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个为测试提供对协程执行的详细控制的范围。添加的<code class="du lf lg lh li b">Job</code>允许我们在每次测试后，作为常规清理的一部分，轻松地取消协程。</p><p id="d5d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置完成后，我们的测试类应该如下所示:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="6894" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的第一个测试将只是在创建<code class="du lf lg lh li b">testDataStore</code>时验证我们数据的状态。我们将在没有 <strong class="ir ht">订阅流</strong>的情况下获取数据<strong class="ir ht">的快照，并根据我们的预期结果进行快速检查。在我们的<code class="du lf lg lh li b">UserPreferencesRepository</code>中，这是我们想要测试的第一个函数:</strong></p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0c08" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当第一次创建存储库时，它检查数据存储是否为空，并在这种情况下设置我们的数据的默认实例:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="fa29" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们考虑这个测试用例的必要步骤，我们需要:</p><ol class=""><li id="dc91" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm md lv lw lx bi translated">创建一个保存了默认值的<code class="du lf lg lh li b">testDataStore</code>——完成✅</li><li id="902b" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">创建测试主题<code class="du lf lg lh li b">UserPreferencesRepository</code> —完成✅</li><li id="da8b" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">设置代表我们期望在<code class="du lf lg lh li b">testDataStore</code>中发现什么的<code class="du lf lg lh li b">expectedUserPreferences</code>——还没有完成！</li><li id="e59a" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">呼叫<code class="du lf lg lh li b">repository.fetchInitialPreferences()</code> —还没完成！</li><li id="cdb1" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">验证返回值是否与我们预期的结果相匹配——还没有完成！</li></ol><p id="9222" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">按照这些步骤，我们的测试应该如下所示:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><blockquote class="me mf mg"><p id="3e52" class="ip iq mh ir b is it iu iv iw ix iy iz mi jb jc jd mj jf jg jh mk jj jk jl jm ha bi translated"><em class="hs">💡你可能会注意到Android Studio抱怨“</em>挂起函数‘fetchInitialPreferences’应该只能从协程或另一个挂起函数<em class="hs">中调用”。</em></p><p id="5f59" class="ip iq mh ir b is it iu iv iw ix iy iz mi jb jc jd mj jf jg jh mk jj jk jl jm ha bi translated"><em class="hs">事实上，我们的</em> <code class="du lf lg lh li b"><em class="hs">fetchInitialPreferences()</em></code> <em class="hs">是一个暂停函数，但是因为我们是从测试中调用它，所以我们需要确保避免任何实时延迟。</em> <code class="du lf lg lh li b"><em class="hs">kotlinx.coroutines.test</em></code> <em class="hs">用一个非常简单的测试解决方案再次挽救了局面——用</em> <code class="du lf lg lh li b"><em class="hs">testCoroutineScope.runBlockingTest{}</em></code> <em class="hs">将它包围起来(注意，如果你使用的是Kotlin 1.6，你可以用</em> <code class="du lf lg lh li b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html" rel="noopener ugc nofollow" target="_blank"><em class="hs">runTest{}</em></a></code> <em class="hs"> ) </em></p></blockquote><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="73d1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个搞定了，还有一个。我们的下一个测试用例通过启用或禁用存储的<code class="du lf lg lh li b">SortOrder</code>值来验证我们的存储库是否对数据存储库进行了正确的更改:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="99ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们遵循类似的模式:</p><ol class=""><li id="8f0d" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm md lv lw lx bi translated">创建一个保存默认值的<code class="du lf lg lh li b">testDataStore</code>—完成✅</li><li id="dc71" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">创建测试主题<code class="du lf lg lh li b">UserPreferencesRepository</code> —完成✅</li><li id="510c" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">用新值调用<code class="du lf lg lh li b">repository.enableSortByDeadline()</code>——还没完成！</li><li id="92d3" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm md lv lw lx bi translated">验证来自<code class="du lf lg lh li b">repository.userPreferencesFlow</code>的<code class="du lf lg lh li b">testDataStore</code>值与我们的预期结果相匹配——尚未完成！</li></ol><p id="69be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">添加最后两个测试步骤将如下所示:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8677" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这涵盖了我们的基本测试用例。您可以遵循相同的步骤来增加这个存储库类的测试覆盖率。</p><p id="faa0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在剩下要做的就是维护和清理一个健康的测试环境。最后，让我们看一下现在已经完成的整个测试类:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="3ecd" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">就这样结束了！🎬</h1><p id="8b9e" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在我们关于<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"><strong class="ir ht">Jetpack DataStore</strong></a>的整个系列中，我们涵盖了许多不同的主题，所有这些主题对于深入理解DataStore 并在<strong class="ir ht">生产环境</strong>中正确使用它都是至关重要的<strong class="ir ht">。</strong></p><p id="3996" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们已经了解了<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">数据存储是如何工作的，</a>它给<code class="du lf lg lh li b">SharedPreferences</code>带来了什么好处，以及它的<a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">偏好</a>和<a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">原型</a>实现。我们也看到了使用哪种<a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c">序列化方法，</a>如何用刀柄注入<a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">以及最后如何测试。现在就看你自己去尝试了！您还可以从我们的</a><a class="ae jn" href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc8to3Ere-ePuco69yBUmQ9C" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> MAD Skills视频系列</strong> </a>中了解数据存储，并参加我们即将举行的现场Q &amp; A，我们将回答您可能有的所有问题。</p><p id="e485" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在这里找到我们的Jetpack数据存储系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack数据存储简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">数据存储和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c">数据存储和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c">数据存储和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa">数据存储和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8">数据存储和测试</a></p></div></div>    
</body>
</html>