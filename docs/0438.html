<html>
<head>
<title>Learn Kotlin through unit tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过单元测试学习Kotlin</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/learn-kotlin-through-unit-tests-914106d2d8c5?source=collection_archive---------3-----------------------#2019-11-07">https://medium.com/androiddevelopers/learn-kotlin-through-unit-tests-914106d2d8c5?source=collection_archive---------3-----------------------#2019-11-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/094e17b2de29db977ffd6d8a98125ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OY_827HKirfNCSuWyvEnw.png"/></div></div></figure><p id="6c32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在2019年的I/O大会上，我们<a class="ae jn" href="https://android-developers.googleblog.com/2019/05/google-io-2019-empowering-developers-to-build-experiences-on-Android-Play.html" rel="noopener ugc nofollow" target="_blank">宣布【Android将以Kotlin为先。然而，一些开发者提到他们仍然不确定如何进行。开始编写Kotlin代码是令人害怕的第一步，尤其是如果团队中没有人熟悉它的话。</a></p><p id="cebb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们这些Android Studio profilers团队的成员是渐进的。第一步是要求我们所有的单元测试都用Kotlin编写。因为这些类是从产品代码中分离出来的，所以我们最初犯的任何错误都会被包含在内。</p><p id="c133" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在此期间，我通过收集我们团队在几次代码评审中观察到的常见问题，整理出了以下指南。我在下面复制它，希望它能帮助更广泛的Android社区中的其他人。</p><p id="59b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">注意:这篇文章是针对科特林初学者的。如果你和你的团队已经在有效地编写Kotlin代码，这篇文章可能不会为你提供太多新的信息。然而，如果你读了它，并认为你会包括一些我没有的东西，考虑留下评论吧！</em></p></div><div class="ab cl jp jq go jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="ha hb hc hd he"><h1 id="30df" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">IDE操作:将Java文件转换为Kotlin文件</h1><p id="25da" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">如果你正在使用Android Studio，开始学习Kotlin最简单的方法是用Java编写你的测试类，然后通过从菜单栏中选择<code class="du kz la lb lc b">Code → Convert Java File to Kotlin File</code>将其转换成Kotlin。</p><p id="2b5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此操作可能会询问您<em class="jo">"在执行此转换后，项目剩余部分中的一些代码可能需要更正。是否也要找到这样的代码并纠正它？”我建议选择“<em class="jo">否</em>”，这样你就可以一次只关注一个文件。</em></p><p id="28f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这个动作会生成Kotlin代码，但是产生的代码通常还有改进的空间。接下来的部分强调了我们从几十个自动生成代码的代码评审中收集到的常见技巧。当然，Kotlin语言远不止下面讨论的内容，但是为了不离题，本指南只关注我们观察到的重复出现的问题。</p><h1 id="c65c" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">高级语言比较</h1><p id="071f" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Java和Kotlin在高层次上看起来非常相似。下面是一个先用Java，再用Kotlin编写的框架测试类。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="b14a" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><strong class="lc hi">public</strong> class ExampleTest {<br/>  @Test<br/>  <strong class="lc hi">public</strong> <strong class="lc hi">void</strong> testMethod1() <strong class="lc hi">throws Exception</strong> {}</span><span id="a4b2" class="lq jx hh lc b fi lv ls l lt lu">  @Test<br/>  <strong class="lc hi">public</strong> <strong class="lc hi">void</strong> testMethod2() <strong class="lc hi">throws Exception</strong> {}<br/>}</span><span id="5430" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>class ExampleTest {<br/>  @Test<br/>  fun testMethod1() {}</span><span id="8fcc" class="lq jx hh lc b fi lv ls l lt lu">  @Test<br/>  fun testMethod2() {}<br/>}</span></pre><p id="576d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">值得注意的是Kotlin中的精简内容:</p><ul class=""><li id="fe3d" class="lw lx hh ir b is it iw ix ja ly je lz ji ma jm mb mc md me bi translated">默认情况下，方法和类是公共的。</li><li id="6865" class="lw lx hh ir b is mf iw mg ja mh je mi ji mj jm mb mc md me bi translated"><code class="du kz la lb lc b">void</code>返回类型不需要显式声明。</li><li id="fbea" class="lw lx hh ir b is mf iw mg ja mh je mi ji mj jm mb mc md me bi translated">没有已检查的异常。</li></ul><h1 id="2107" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">分号是可选的</h1><p id="b15c" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">这是一开始可能会感觉很不舒服的变化之一。实际操作中，不需要太担心。只需编写您的代码，如果您出于习惯使用分号，代码仍会编译，IDE会指出它们。提交前全部删除即可。</p><p id="868f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不管你喜不喜欢这个选择，Java已经在某些地方去掉了分号，如果你对比C++(更多地方需要分号)，你会注意到这一点。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="fcd6" class="lq jx hh lc b fi lr ls l lt lu">/// C++<br/>std::thread([this] { this-&gt;DoThreadWork()<strong class="lc hi">;</strong> })<strong class="lc hi">;</strong></span><span id="19ca" class="lq jx hh lc b fi lv ls l lt lu">/// Java<br/>new Thread(() -&gt; doThreadWork())<strong class="lc hi">;</strong></span><span id="1f04" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>Thread { doThreadWork() }</span></pre><h1 id="f636" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">类型在末尾声明</h1><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="794a" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><strong class="lc hi">int</strong> value = 10;<br/><strong class="lc hi">Entry</strong> add(<strong class="lc hi">String</strong> name, <strong class="lc hi">String</strong> description)</span><span id="0d90" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>var value: <strong class="lc hi">Int</strong> = 10<br/>fun add(name: <strong class="lc hi">String</strong>, description: <strong class="lc hi">String</strong>): <strong class="lc hi">Entry</strong></span></pre><p id="fcc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就像可选的分号一样，如果您不习惯，这种变化可能会很难接受。这与许多人在编程生涯中根深蒂固的顺序完全相反。</p><p id="2aa2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，这种语法的优点是，当可以推断类型时，可以更容易地省略它们。这将在后面的章节<em class="jo">省略变量类型</em>中进一步讨论。</p><p id="d6cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种语法也更强调变量本身，而不是它的类型。我发现大声谈论代码时，这个顺序听起来更自然:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="c7ff" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>int result;     <strong class="lc hi">// An integer that is a variable called "result".</strong></span><span id="eb30" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>var result: Int <strong class="lc hi">// A variable called "result" that is an integer.</strong></span></pre><p id="e28f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于这种语法，我要说的最后一点是，尽管开始使用起来很别扭，但随着时间的推移，你会习惯它的。</p><h1 id="0c32" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">不带“new”的构造函数</h1><p id="9d60" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Kotlin在构造函数调用之前不需要<em class="jo"> new </em>关键字。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="4070" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>... = <strong class="lc hi">new</strong> SomeClass();</span><span id="b519" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>... = SomeClass()</span></pre><p id="54e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乍一看，这可能感觉像是丢失了重要的信息，但实际上不是Java中的许多函数在幕后分配内存，而您从来不在乎。许多库甚至有静态创建方法，如下所示:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="9704" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>Lists.newArrayList();</span></pre><p id="8f83" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，真的，科特林只是让这更一致。任何函数都可能分配内存，也可能不分配内存。</p><p id="d39a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这也清理了你分配一个临时类只是为了调用它的一个函数而没有把它分配给任何东西的模式。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="6d47" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><strong class="lc hi">new</strong> Thread(...).start(); // Awkward but valid</span><span id="ccde" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>Thread(...).start()</span></pre><h1 id="4b33" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">可变性和不变性</h1><p id="eadd" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">默认情况下，Java中的变量是可变的，需要使用<code class="du kz la lb lc b">final</code>关键字使它们不可变。相比之下，Kotlin没有<code class="du kz la lb lc b">final</code>关键字。相反，您需要用<code class="du kz la lb lc b">val</code>来标记属性，以指示一个<em class="jo">值</em>(不可变的)或<code class="du kz la lb lc b">var</code>来指示一个<em class="jo">变量</em>(可变的)。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="f91a" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>private <strong class="lc hi">final</strong> Project project; // Cannot reassign after init<br/>private Module activeModule;   // Can reassign after init</span><span id="bcbf" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>private <strong class="lc hi">val</strong> project: Project     // Cannot reassign after init<br/>private <strong class="lc hi">var</strong> activeModule: Module // Can reassign after init</span></pre><p id="bb59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常在Java中，你会遇到许多本可以是<code class="du kz la lb lc b">final</code>的字段，但是这个关键字被省略了(可能是偶然的，因为它很容易被忘记)。在Kotlin中，您必须在您声明的每个字段中明确说明这个决定。如果你不确定它应该是什么，就默认标记为<code class="du kz la lb lc b">val</code>，以后如果需求发生变化，就改为<code class="du kz la lb lc b">var</code>。</p><p id="0889" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">顺便说一下，在Java中，函数参数总是可变的，并且像字段一样，可以通过使用<code class="du kz la lb lc b">final</code>使其不可变。在Kotlin中，函数参数总是不可变的——也就是说，它们被隐式标记为<code class="du kz la lb lc b">val</code>。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="9ece" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>public void log(<strong class="lc hi">final</strong> String message) { … }</span><span id="e8a2" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>fun log(message: String) { … } // "message" is immutable</span></pre><h1 id="3edd" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">可空性</h1><p id="5361" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Kotlin废弃了<code class="du kz la lb lc b">@NotNull</code>和<code class="du kz la lb lc b">@Nullable</code>注释。如果一个值可以是null，你只需要用一个问号来声明它的类型。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="1748" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><a class="ae jn" href="http://twitter.com/Nullable" rel="noopener ugc nofollow" target="_blank"><strong class="lc hi">@Nullable</strong></a><strong class="lc hi"> Project</strong> project;<br/><a class="ae jn" href="http://twitter.com/NotNull" rel="noopener ugc nofollow" target="_blank"><strong class="lc hi">@NotNull</strong></a><strong class="lc hi"> String</strong> title;</span><span id="aa5e" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>val project: <strong class="lc hi">Project?</strong><br/>val title: <strong class="lc hi">String</strong></span></pre><p id="716e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在某些情况下，如果你确定一个<em class="jo">可空的</em>值将总是<em class="jo">非空的</em>，你可以使用<code class="du kz la lb lc b">!!</code>操作符来断言。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="8222" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/>// 'parse' could return null, but this test case always works<br/>val result = parse("123")<strong class="lc hi">!!<br/></strong>// The following line is not necessary. !! already asserts.<br/>❌ assertThat(result).isNotNull()</span></pre><p id="5a4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果不正确地应用<code class="du kz la lb lc b">!!</code>，会导致代码抛出一个<code class="du kz la lb lc b">NullPointerException</code>。在单元测试中，这只会导致测试失败，但是在产品代码中使用时应该格外小心。事实上，许多人认为生产代码中的<code class="du kz la lb lc b">!!</code>是一种潜在的代码味道(尽管这里有足够的细微差别，这一点可能需要自己的博客文章)。</p><p id="c098" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在单元测试中，使用<code class="du kz la lb lc b">!!</code>操作符来断言一个特定的案例是有效的更容易被接受，因为如果这个假设不再成立，测试就会失败，而你可以修复它。</p><p id="f087" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您确定使用<code class="du kz la lb lc b">!!</code>操作符是有意义的，那么您应该尽快应用它。例如，执行以下操作:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="4081" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/><strong class="lc hi">val result = parse("...")!!</strong><br/>result.doSomething()<br/>result.doSomethingElse()</span></pre><p id="8967" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是<em class="jo">不要</em>这样做:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="45b5" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin (auto-generated)<br/>val result = parse("...")<br/>❌ result<strong class="lc hi">!!</strong>.doSomething()<br/>❌ result<strong class="lc hi">!!</strong>.doSomethingElse()</span></pre><h1 id="7dda" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">省略变量类型</h1><p id="ea1e" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">在Java中，你会看到很多这样的代码:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="ff5d" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><strong class="lc hi">SomeClass</strong> instance1 = new <strong class="lc hi">SomeClass</strong>();<br/><strong class="lc hi">SomeGeneric&lt;List&lt;String&gt;&gt;</strong> instance2 = new <strong class="lc hi">SomeGeneric&lt;&gt;</strong>();</span></pre><p id="dc99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中，这些类型声明被认为是多余的，不需要写两次:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="d41f" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/>val instance1 = <strong class="lc hi">SomeClass</strong>()<br/>val instance2 = <strong class="lc hi">SomeGeneric&lt;List&lt;String&gt;&gt;</strong>()</span></pre><p id="42c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“但是等等！”你大声说，“有时我打算声明那些类型！”例如:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="8e6f" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/><strong class="lc hi">BaseClass</strong> instance = new <strong class="lc hi">ChildClass</strong>(); // e.g. List = new ArrayList</span></pre><p id="d032" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这可以在Kotlin中使用以下语法来完成:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="835d" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/>val instance: <strong class="lc hi">BaseClass</strong> = <strong class="lc hi">ChildClass</strong>()</span></pre><h1 id="d018" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">没有已检查的异常</h1><p id="e47b" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">与Java不同，Kotlin不要求它的方法声明它们抛出什么异常。<em class="jo">检查的</em>异常和<em class="jo">运行时</em>异常之间不再有区别。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="fca7" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>public void readFile() <strong class="lc hi">throws IOException</strong> { … }</span><span id="7f11" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>fun readFile() { … }</span></pre><p id="dbba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，为了让Java能够调用Kotlin代码，Kotlin支持使用<code class="du kz la lb lc b"><a class="ae jn" href="http://twitter.com/Throws" rel="noopener ugc nofollow" target="_blank">@Throws</a></code>注释间接声明异常。<code class="du kz la lb lc b">Java → Kotlin</code>动作为了安全起见，总是包含这个信息。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="933e" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin (auto-converted from Java)<br/><a class="ae jn" href="http://twitter.com/Throws" rel="noopener ugc nofollow" target="_blank"><strong class="lc hi">@Throws</strong></a><strong class="lc hi">(Exception::class)</strong><br/>fun testSomethingImportant() { … }</span></pre><p id="b513" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是你永远不必担心你的单元测试被Java类调用。因此，您可以保存一些行，并安全地删除这些有干扰的异常声明:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="85b8" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/>fun testSomethingImportant() { … }</span></pre><h1 id="5dfa" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">在lambda调用中省略括号</h1><p id="03f0" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">在Kotlin中，如果你想给一个变量分配一个闭包，你需要显式声明它的类型:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="3003" class="lq jx hh lc b fi lr ls l lt lu">val sumFunc: (Int, Int) -&gt; Int = <strong class="lc hi">{ x, y -&gt; x + y }</strong></span></pre><p id="f250" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，如果一切都可以推断，这可以缩短为只是</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="2b96" class="lq jx hh lc b fi lr ls l lt lu"><strong class="lc hi">{ x, y -&gt; x + y }</strong></span></pre><p id="c642" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举个例子，</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="a3eb" class="lq jx hh lc b fi lr ls l lt lu">val intList = listOf(1, 2, 3, 4, 5, 6)<br/>val sum = intList.fold(0, <strong class="lc hi">{ x, y -&gt; x + y }</strong>)</span></pre><p id="b49a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，在Kotlin中，如果函数的最后一个参数是lambda调用，那么可以在括号外写闭包。上述内容与以下内容相同:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="eb47" class="lq jx hh lc b fi lr ls l lt lu">val sum = intList.fold(0) <strong class="lc hi">{ x, y -&gt; x + y }</strong></span></pre><p id="f9a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，仅仅因为你能，并不意味着你应该。有人可能会说上面的盖牌听起来很奇怪。其他时候，这种语法可以减少一些视觉干扰，特别是当方法的唯一参数是闭包时。假设我们想计数偶数。比较以下内容:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="8303" class="lq jx hh lc b fi lr ls l lt lu">intList.filter({ x -&gt; x % 2 == 0 }).count()</span></pre><p id="1088" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="c9f3" class="lq jx hh lc b fi lr ls l lt lu">intList.filter { x -&gt; x % 2 == 0 }.count()</span></pre><p id="888a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者比较:</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="a8fb" class="lq jx hh lc b fi lr ls l lt lu">Thread({ doThreadWork() })</span></pre><p id="eac1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="a62d" class="lq jx hh lc b fi lr ls l lt lu">Thread { doThreadWork() }</span></pre><p id="2598" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不管你认为什么是最好的方法，你都会在Kotlin代码中看到这种语法，它可以由<code class="du kz la lb lc b">Java → Kotlin</code>动作自动生成，所以你应该确保在看到它的时候明白是怎么回事。</p><h1 id="0db7" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">等于、==、和===</h1><p id="23f6" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Kotlin在相等测试上偏离了Java。</p><p id="adfa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，double-equals ( <code class="du kz la lb lc b">==</code>)用于实例比较，这与<code class="du kz la lb lc b">equals</code>方法不同。虽然这在理论上听起来不错，但在实践中，开发人员很容易在打算使用<code class="du kz la lb lc b">equals</code>的时候不小心使用了<code class="du kz la lb lc b">==</code>。这可能会引入微妙的错误，并需要几个小时来发现或调试。</p><p id="c4be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中，<code class="du kz la lb lc b">==</code>本质上和equals是一样的——唯一的区别是它也正确地处理了null情况。例如，<code class="du kz la lb lc b">null == x</code>计算正确，而<code class="du kz la lb lc b">null.equals(x)</code>抛出NPE。</p><p id="bd6e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果需要在Kotlin中进行实例比较，可以使用triple-equals ( <code class="du kz la lb lc b">===</code>)来代替。这种语法更难被误用，也更容易被发现。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="434a" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>Color first = new Color(255, 0, 255);<br/>Color second = new Color(255, 0, 255);<br/>assertThat(<strong class="lc hi">first.equals(second)</strong>).<strong class="lc hi">isTrue</strong>();<br/>assertThat(<strong class="lc hi">first == second)</strong>.<strong class="lc hi">isFalse();</strong></span><span id="6396" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>val first = Color(255, 0, 255)<br/>val second = Color(255, 0, 255)<br/>assertThat(<strong class="lc hi">first.equals(second)</strong>).<strong class="lc hi">isTrue</strong>()<br/>assertThat(<strong class="lc hi">first == second</strong>).<strong class="lc hi">isTrue</strong>()<br/>assertThat(<strong class="lc hi">first === second</strong>).<strong class="lc hi">isFalse</strong>()</span></pre><p id="82f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数时候你写Kotlin代码，你会想要使用<code class="du kz la lb lc b">==</code>，因为对<code class="du kz la lb lc b">===</code>的需求相对较少。作为预防措施，Java到Kotlin的转换器总是将<code class="du kz la lb lc b">==</code>转换为<code class="du kz la lb lc b">===</code>。出于可读性和意图，您应该考虑尽可能恢复到<code class="du kz la lb lc b">==</code>。例如，这在枚举比较中很常见。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="1bb7" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>if (day == DayOfWeek.MONDAY) { … }</span><span id="c9f6" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin (auto-converted from Java)<br/>❌ if (day === DayOfWeek.MONDAY) { … }</span><span id="0faa" class="lq jx hh lc b fi lv ls l lt lu">/// Kotlin<br/>if (day == DayOfWeek.MONDAY) { … }</span></pre><h1 id="1b4a" class="jw jx hh bd jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp lh kr ks kt bi translated">删除字段前缀</h1><p id="581e" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">在Java中，私有字段与公共getter和setter配对是很常见的，许多代码库在字段上附加了前缀，这是匈牙利符号<a class="ae jn" href="https://en.wikipedia.org/wiki/Hungarian_notation" rel="noopener ugc nofollow" target="_blank">的遗迹</a>。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="e118" class="lq jx hh lc b fi lr ls l lt lu">/// Java<br/>private String <strong class="lc hi">myName</strong>;<br/>// or private String <strong class="lc hi">mName</strong>;<br/>// or private String <strong class="lc hi">_name</strong>;<br/>public String getName() { … }<br/>public void setName(String name) { … }</span></pre><p id="e13d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个前缀是一个有用的标记，只对类的实现可见，使得区分类的局部字段和传递给函数的参数变得更加容易。</p><p id="714f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中，字段和getter/setter合并成一个概念。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="198a" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin<br/>class User {<br/>  <strong class="lc hi">val id</strong>: String   // represents field and getter<br/>  <strong class="lc hi">var name</strong>: String // represents field, getter, and setter<br/>}</span></pre><p id="94a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，当您自动转换代码时，Java前缀有时会被带走，曾经隐藏在类内部的细节可能会泄漏到它的公共接口中。</p><pre class="li lj lk ll fd lm lc ln lo aw lp bi"><span id="3bb0" class="lq jx hh lc b fi lr ls l lt lu">/// Kotlin (auto-converted from Java)<br/>class User {<br/>❌ val <strong class="lc hi">myId</strong>: String<br/>❌ var <strong class="lc hi">myName</strong>: String<br/>}</span></pre><p id="4f32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了防止前缀泄露，建议养成去掉前缀以保持一致性的习惯。</p><p id="dcb5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">没有前缀的字段可能会使偶尔使用web工具进行的代码审查变得有点难以阅读(例如，在一个太大的类中的一个太长的函数中)。然而，当您阅读ide中的代码时，通过语法突出显示，可以清楚地看出哪些值是字段，哪些是参数。移除前缀也可能鼓励围绕编写更集中的方法和类的更好的编码习惯。</p></div><div class="ab cl jp jq go jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="ha hb hc hd he"><h1 id="92ba" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结束语</h1><p id="a609" class="pw-post-body-paragraph ip iq hh ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">希望这篇指南能帮助你开始学习Kotlin。首先，您将从编写Java并将其转换为Kotlin开始，然后您将编写类似Java的Kotlin，最后，用不了多久，您将像专业人员一样编写地道的Kotlin代码！</p><p id="bbae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章只是触及了Kotlin的皮毛。它的目标是为那些没有很多时间，只需要快速启动和运行他们的第一个Kotlin测试的人提供一个最小的笔记集，同时仍然向他们介绍相当数量的语言基础。</p><p id="988b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，它可能不会涵盖你需要的一切。为此，请考虑官方文档:</p><p id="88ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语言参考:</strong><a class="ae jn" href="https://kotlinlang.org/docs/reference/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">【https://kotlinlang.org/docs/reference/】</strong></a><strong class="ir hi"><br/>互动教程:</strong><a class="ae jn" href="https://try.kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">https://try.kotlinlang.org/</strong></a></p><p id="260f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语言参考非常有用。它涵盖了Kotlin中的所有主题，但没有深入到让人不知所措的程度。</p><p id="3722" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">教程会给你一个练习使用语言的机会，它们还包括koans(一系列简短的练习)来帮助确认你新获得的知识。</p><p id="8102" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，请查看我们的官方代码实验室，了解对Kotlin的重构。它涵盖了这篇博文中介绍的主题，以及更多更多的内容。</p></div></div>    
</body>
</html>