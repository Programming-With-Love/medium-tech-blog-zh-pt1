<html>
<head>
<title>iOS linting at Pinterest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pinterest上的iOS林挺</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/ios-linting-at-pinterest-3108d8764390?source=collection_archive---------1-----------------------#2017-06-23">https://medium.com/pinterest-engineering/ios-linting-at-pinterest-3108d8764390?source=collection_archive---------1-----------------------#2017-06-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7780" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">迈克尔·施耐德| Pinterest工程师，iOS核心体验</em></p><p id="a8b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于一个每天都有大量开发人员工作、每周都有新工程师加入的代码库来说，编码一致性和指导方针至关重要。为了控制代码质量和实施最佳实践，我们最近在基础设施中添加了林挺，以帮助开发人员编写更好的代码。林挺是运行程序来分析代码中潜在错误的过程。</p><p id="65ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与此同时，我们正在将我们当前的构建基础架构迁移到巴泽尔，因此这是考虑哪些林挺选项将与新构建很好地配合的好时机。该计划的主要目标是尽早推进林挺过程，以便在编译时，如果代码不符合我们的指导方针或最佳实践，开发人员可以立即做出响应。在本帖中，我们将介绍我们如何实施林挺以及在此过程中学到的最佳实践。</p><h2 id="8869" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">叮当工具</h2><p id="aee6" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们评估了现有的解决方案，但是没有一个足够灵活或者能够容易地集成到我们的构建系统中。然后我们研究了LLVM能提供什么，尤其是围绕Clang的工具。</p><p id="91a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Clang提供了编写工具的基础结构，这些工具需要一个叫做Clang Tools的程序的语法和语义信息。Clang为开发人员提供了不同的接口来连接Clang的编译过程。可用的接口有<a class="ae kd" href="http://clang.llvm.org/doxygen/group__CINDEX.html" rel="noopener ugc nofollow" target="_blank"> LibClang </a>、<a class="ae kd" href="https://clang.llvm.org/docs/ClangPlugins.html" rel="noopener ugc nofollow" target="_blank"> Clang插件</a>和<a class="ae kd" href="https://clang.llvm.org/docs/LibTooling.html" rel="noopener ugc nofollow" target="_blank"> LibTooling </a>。页面<a class="ae kd" href="https://clang.llvm.org/docs/Tooling.html" rel="noopener ugc nofollow" target="_blank">“为您的应用选择正确的接口”</a>对于决定哪些Clang工具接口最适合我们的需求特别有帮助。我们在一个小例子中测试了每个接口，发现LibClang不能提供对AST的完全控制，LibTooling不能运行由依赖关系变化触发的部分构建。最终我们决定使用Clang插件。</p><p id="2858" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值得注意的一点是，由于Clang是用C++编写的，工具扩展点本身是作为C++接口公开的。此外，所有文档大部分都是从带注释的C++源代码中自动生成的doxygen输出。所以在用Clang工作时，有以前的C++经验是非常有帮助的。</p><h2 id="5aa6" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">Clang插件</h2><p id="0ceb" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Clang插件使我们能够在Clang AST ( <a class="ae kd" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>)上运行额外的操作，作为编译的一部分。Clang的AST不同于其他编译器生成的AST，因为它非常类似于编写的C++代码和C++标准。例如，在AST中，圆括号表达式和编译时间常数以未简化的形式提供。这使得Clang的AST非常适合重构工具。(更多信息请参见<a class="ae kd" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" rel="noopener ugc nofollow" target="_blank">叮当声介绍</a>。<a class="ae kd" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" rel="noopener ugc nofollow" target="_blank"> ) </a></p><p id="8e64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">插件是由编译器在运行时加载的动态库，允许我们向编译器发出特殊的lint风格的警告和错误，这些警告和错误将在Xcode左侧的警告标签部分或直接在源代码中显示为众所周知的警告或错误。我们称我们的Clang插件为PINLinter。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/49364eacf867eb4b4aa7d5758ddafe54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4fj-Ss0o1om-Wz_v."/></div></div></figure><h1 id="0f45" class="kq je hh bd jf kr ks kt jj ku kv kw jn kx ky kz jq la lb lc jt ld le lf jw lg bi translated">体系结构</h1><p id="6aca" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">和所有Clang插件一样，PINLinter由一个在编译时加载的动态库(dylib)来表示。一旦加载了PINLinter插件，Clang就会使用一个JSON格式的配置文件，其中包含一个应该加载的所有规则的列表，以及一个惟一的名称，并加载每个列出的Linter规则。这允许我们只为所有规则使用一个Clang插件，而不是为每个规则都使用一个，并且我们可以为不同的规则配置启用或禁用某些规则，比如开发与构建机器。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lh"><img src="../Images/5725da3763746523220c7925666c3e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vcd1yY5CDq77UnTq."/></div></div></figure><h2 id="71a3" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">PINLinterASTAction</h2><p id="ecb6" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">主Clang插件类的名字叫<code class="du li lj lk ll b">PINLinterASTAction</code>，是一个<a class="ae kd" href="http://clang.llvm.org/docs/ClangPlugins.html" rel="noopener ugc nofollow" target="_blank">前端动作</a>。<code class="du li lj lk ll b">FrontendAction</code>是一个接口，允许执行用户特定的动作作为编译的一部分。为了在AST上运行工具，Clang提供了方便的接口<code class="du li lj lk ll b">PluginASTAction</code>，它通过实现为每个翻译单元返回一个<code class="du li lj lk ll b">ASTConsumer</code>的<code class="du li lj lk ll b">CreateASTConsumer</code>方法来执行动作。</p><p id="dc96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编译器在运行时从动态库中加载插件。为了在库中注册PINLinter插件，我们使用了<code class="du li lj lk ll b">FrontendPluginRegistry::Add&lt;&gt;</code>方法:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="d6f6" class="jd je hh ll b fi lq lr l ls lt">static clang::FrontendPluginRegistry::Add&lt;PINLinterASTAction&gt;</span><span id="1d8f" class="jd je hh ll b fi lu lr l ls lt">  X("PINLinter", "LLVM Pinterest Linter Plugin");</span><span id="b03f" class="jd je hh ll b fi lu lr l ls lt">}</span></pre><p id="13d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在PINLinter的<code class="du li lj lk ll b">CreateConsumer</code>实现中，将解析一个配置文件以获得应该加载的规则列表。配置文件非常简单，如下所示。</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="1f27" class="jd je hh ll b fi lq lr l ls lt">{</span><span id="6e30" class="jd je hh ll b fi lu lr l ls lt">  // ...</span><span id="1adc" class="jd je hh ll b fi lu lr l ls lt">  linters: [</span><span id="7bb4" class="jd je hh ll b fi lu lr l ls lt">    "PINPreventAssignPointersRule",</span><span id="2526" class="jd je hh ll b fi lu lr l ls lt">    "PINCallViewInInitRule",</span><span id="d91b" class="jd je hh ll b fi lu lr l ls lt">    // ...</span><span id="ae2d" class="jd je hh ll b fi lu lr l ls lt">  ]</span><span id="9383" class="jd je hh ll b fi lu lr l ls lt">  // ...<br/>}</span></pre><p id="f9b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于配置文件中列出的每个规则，将通过<code class="du li lj lk ll b">CreateRulesForConfiguration</code>创建一个具体的对象。然后，规则对象的向量被传递给<code class="du li lj lk ll b">PINLinterASTConsumer</code>类的初始化器。</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="d0f1" class="jd je hh ll b fi lq lr l ls lt">// Central place where the linters plugin is registered</span><span id="00ff" class="jd je hh ll b fi lu lr l ls lt">class PINLinterASTAction : public PluginASTAction {</span><span id="1ace" class="jd je hh ll b fi lu lr l ls lt">// ...</span><span id="a132" class="jd je hh ll b fi lu lr l ls lt">protected:</span><span id="f079" class="jd je hh ll b fi lu lr l ls lt">   virtual std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef InFile) {</span><span id="ff84" class="jd je hh ll b fi lu lr l ls lt">     // Try read linters path from environment variables</span><span id="b3a2" class="jd je hh ll b fi lu lr l ls lt">     Optional&lt;std::string&gt; env =</span><span id="0a74" class="jd je hh ll b fi lu lr l ls lt">       sys::Process::GetEnv("PINLINTERS_CONFIGURATION");</span><span id="8579" class="jd je hh ll b fi lu lr l ls lt">     if (env.hasValue()) {</span><span id="aaff" class="jd je hh ll b fi lu lr l ls lt">       CreateRulesForConfiguration(env.getValue());</span><span id="9ef1" class="jd je hh ll b fi lu lr l ls lt">     }</span><span id="9276" class="jd je hh ll b fi lu lr l ls lt">     return make_unique&lt;PINLinterASTConsumer&gt;(std::move(m_rules));</span><span id="2a7a" class="jd je hh ll b fi lu lr l ls lt">   }</span><span id="0805" class="jd je hh ll b fi lu lr l ls lt">   // ...<br/>}</span></pre><h2 id="50d5" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">PINLinterASTConsumer</h2><p id="6e55" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">一个<code class="du li lj lk ll b">ASTConsumer</code>是一个客户端对象，当AST被构建并“消费”它时，它从Clang接收回调。<code class="du li lj lk ll b">PINLinterASTConsumer</code>本身就是<code class="du li lj lk ll b">PINLinterASTAction</code>和所有<code class="du li lj lk ll b">PINLinter::Rule</code>对象之间的粘合剂。它的主要工作是将被覆盖的<code class="du li lj lk ll b">Initialize</code>和<code class="du li lj lk ll b">HandleTranslationUnit</code>方法的调用转发给它知道的所有加载的规则。</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="497b" class="jd je hh ll b fi lq lr l ls lt">class PINLinterASTConsumer : public ASTConsumer {</span><span id="1543" class="jd je hh ll b fi lu lr l ls lt">  // ...<br/>  virtual void Initialize(ASTContext &amp;Context) override {</span><span id="07d6" class="jd je hh ll b fi lu lr l ls lt">    // Initialize all loaded linters</span><span id="4dae" class="jd je hh ll b fi lu lr l ls lt">    for (auto &amp;linter : m_linter) {</span><span id="d186" class="jd je hh ll b fi lu lr l ls lt">      linter-&gt;Initialize(Context);</span><span id="32d2" class="jd je hh ll b fi lu lr l ls lt">    }</span><span id="d930" class="jd je hh ll b fi lu lr l ls lt">  }<br/></span><span id="9303" class="jd je hh ll b fi lu lr l ls lt">  virtual void HandleTranslationUnit(ASTContext &amp;context) override {</span><span id="e9b6" class="jd je hh ll b fi lu lr l ls lt">    // Pass through call to all registered linter</span><span id="ccd7" class="jd je hh ll b fi lu lr l ls lt">    for (auto &amp;linter : m_linter) {</span><span id="b071" class="jd je hh ll b fi lu lr l ls lt">      linter-&gt;HandleTranslationUnit(context);</span><span id="78c5" class="jd je hh ll b fi lu lr l ls lt">    }</span><span id="65ed" class="jd je hh ll b fi lu lr l ls lt">  }</span><span id="9fb5" class="jd je hh ll b fi lu lr l ls lt">  // ...</span><span id="1094" class="jd je hh ll b fi lu lr l ls lt">};</span></pre><h2 id="71cc" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">PINLinter::规则</h2><p id="7ee1" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">每个linter规则都是<code class="du li lj lk ll b">PINLinter::Rule</code>类的子类。<code class="du li lj lk ll b">PINLinter::Rule</code>子类有两个主要用途。第一种是通过重写initialize来初始化自己，以创建一个顶级<code class="du li lj lk ll b">RecursiveASTVisitor</code>并将<code class="du li lj lk ll b">HandleTranslationUnit</code>中的高级翻译单元分派给上述根AST访问者对象。具体规则子类的示例实现如下所示:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="376b" class="jd je hh ll b fi lq lr l ls lt">class PINPreventAssignPointersRule : public PINLinter::Rule {</span><span id="880e" class="jd je hh ll b fi lu lr l ls lt">   // ...</span><span id="b021" class="jd je hh ll b fi lu lr l ls lt">  virtual void Initialize(ASTContext &amp;Context) override {</span><span id="9d50" class="jd je hh ll b fi lu lr l ls lt">    PINLinter::Rule::Initialize(Context);</span><span id="a8ef" class="jd je hh ll b fi lu lr l ls lt">    _Visitor = make_unique&lt;PINPreventAssignPointersLinterVisitor&gt;(Context);</span><span id="9f25" class="jd je hh ll b fi lu lr l ls lt">  }<br/></span><span id="9af3" class="jd je hh ll b fi lu lr l ls lt">  virtual void HandleTranslationUnit(ASTContext &amp;Context) override {</span><span id="1e7b" class="jd je hh ll b fi lu lr l ls lt">    PINLinter::Rule::HandleTranslationUnit(Context);</span><span id="8cc1" class="jd je hh ll b fi lu lr l ls lt">    _Visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl());</span><span id="8dec" class="jd je hh ll b fi lu lr l ls lt">  }</span><span id="eb83" class="jd je hh ll b fi lu lr l ls lt">  // ...<br/>};</span></pre><p id="e06e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，<code class="du li lj lk ll b">PINLinterASTAction</code>负责基于本地配置文件创建和初始化具体的规则对象。查找可用的linter规则类的能力提供了一个名为<code class="du li lj lk ll b">PINLinter::registry::RuleRegistry</code>的中央注册表对象，其中每个规则类都可以用一个惟一的名称注册自己。为了简化注册过程，我们创建了一个名为<code class="du li lj lk ll b">RULE_REGISTER</code>的宏来简化注册。例如，这里我们注册了一个名为<code class="du li lj lk ll b">PINPreventAssignPointersRule</code>的规则类用于使用:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="3f53" class="jd je hh ll b fi lq lr l ls lt">RULE_REGISTER(PINPreventAssignPointersRule, "PINPreventAssignPointersRule")</span></pre><h2 id="ba07" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">RecursiveASTVisitor</h2><p id="96a2" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><code class="du li lj lk ll b">RecursiveASTVisitor</code>对象，即<code class="du li lj lk ll b">PINLinter::Rule</code>类在它们的<code class="du li lj lk ll b">Initialize</code>方法中创建的对象，在整个Clang AST上完成前序或后序深度优先遍历，并访问每个节点。在我们的例子中，它通过用根级翻译单元声明调用<code class="du li lj lk ll b">TraverseDecl</code>来启动这个过程。默认情况下，这个访问者预订单遍历AST。如果需要后序遍历，需要覆盖<code class="du li lj lk ll b">shouldTraversePostOrder</code>方法以返回true。</p><p id="6657" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du li lj lk ll b">RecursiveASTVisitor</code>类执行三个不同的任务:</p><ol class=""><li id="f295" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated">遍历AST(即转到每个节点)。</li><li id="6c8c" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">在给定的节点，从节点的动态类型开始沿着类层次向上走，直到到达最顶层的类(例如Stmt、Decl或type)。</li><li id="1104" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">给定一个(节点，类)组合，其中“类”是“节点”的动态类型的某个基类，调用一个用户可重写的函数来实际访问该节点。</li></ol><p id="e835" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些任务分别由三组方法完成:</p><ol class=""><li id="b8c9" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated"><code class="du li lj lk ll b">TraverseDecl(Decl *x)</code>执行任务#1。它是遍历一个以x为根的AST的入口点，这个方法简单地调度(即转发)到<code class="du li lj lk ll b">TraverseFoo(Foo *x)</code>其中<code class="du li lj lk ll b">Foo</code>是<code class="du li lj lk ll b">*x</code>的动态类型，它调用<code class="du li lj lk ll b">WalkUpFromFoo(x)</code>，然后递归访问<code class="du li lj lk ll b">x</code>的子节点。<code class="du li lj lk ll b">TraverseStmt(Stmt *x)</code>和<code class="du li lj lk ll b">TraverseType(QualType x)</code>工作原理类似。</li><li id="62b3" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><code class="du li lj lk ll b">WalkUpFromFoo(Foo *x)</code>执行任务2。它不会尝试访问<code class="du li lj lk ll b">x</code>的任何子节点。而是先调用<code class="du li lj lk ll b">WalkUpFromBar(x)</code>其中Bar是<code class="du li lj lk ll b">Foo</code>的直接父类(除非<code class="du li lj lk ll b">Foo</code>没有父类)，再调用<code class="du li lj lk ll b">VisitFoo(x)</code>(见下一个列表项)。</li><li id="dc7e" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><code class="du li lj lk ll b">VisitFoo(Foo *x)</code>执行任务3。</li></ol><p id="14ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于我们的目的，我们只对上面的第三个任务感兴趣。为了挂钩到解析过程，我们必须子类化<code class="du li lj lk ll b">RecursiveASTVisitor</code>类(提供我们自己作为模板参数，使用<a class="ae kd" href="https://sourcemaking.com/design_patterns/template_method" rel="noopener ugc nofollow" target="_blank">模板模式</a>)并为声明、类型、语句、表达式或访问者应该定制行为的其他AST节点重写任何<code class="du li lj lk ll b">Visit*</code>方法。</p><p id="14ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果我们想要根据Objective-C方法声明检查某些情况，我们必须实现<code class="du li lj lk ll b">bool VisitObjCMethodDecl(ObjCMethodDecl *D)</code>并使用作为参数传入的<code class="du li lj lk ll b">ObjCMethodDecl</code>对象来做进一步的检查，并根据发现发出警告或错误。</p><h2 id="995b" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">实施规则的示例</h2><p id="c5bc" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">为了展示具体的<code class="du li lj lk ll b">PINLinter::Rule</code>实现在实践中是怎样的，让我们看一下我们目前在代码库中运行的两个例子。</p><p id="dbb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">防止为Objective-C指针分配属性</strong></p><p id="5421" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们实现的一个linter规则阻止了Objective-C类型的赋值属性。在以下情况下，一旦开发人员在Xcode中点击compile，就会对其进行检查:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="a482" class="jd je hh ll b fi lq lr l ls lt">// Error using pointer for a scalar type</span><span id="eff1" class="jd je hh ll b fi lu lr l ls lt">@property (nonatomic, assign) CGFloat *foo;</span><span id="6105" class="jd je hh ll b fi lu lr l ls lt">// Error using assign for an objc pointer type</span><span id="8103" class="jd je hh ll b fi lu lr l ls lt">@property (nonatomic, assign) NSNumber *bar;</span></pre><p id="c124" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了检查特定的Objective-C属性声明，我们在<code class="du li lj lk ll b">RecursiveASTVisitor</code>子类中覆盖了<code class="du li lj lk ll b">VisitObjCPropertyDecl</code>方法。每个Objective-C属性声明都会调用这个方法。具体实现如下所示:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="015d" class="jd je hh ll b fi lq lr l ls lt">class PINPreventAssignPointersLinterVisitor</span><span id="685e" class="jd je hh ll b fi lu lr l ls lt">     : public RecursiveASTVisitor&lt;PINPreventAssignPointersLinterVisitor&gt; {</span><span id="7e63" class="jd je hh ll b fi lu lr l ls lt">  // …</span><span id="f67a" class="jd je hh ll b fi lu lr l ls lt">  bool VisitObjCPropertyDecl(ObjCPropertyDecl *P) {</span><span id="84bf" class="jd je hh ll b fi lu lr l ls lt">    // …</span><span id="4809" class="jd je hh ll b fi lu lr l ls lt">    // Check for pointer type</span><span id="5497" class="jd je hh ll b fi lu lr l ls lt">    QualType Type = P-&gt;getType();</span><span id="1da7" class="jd je hh ll b fi lu lr l ls lt">    // We are interested in any pointer type, but for now don’t bother for void</span><span id="d5a5" class="jd je hh ll b fi lu lr l ls lt">    // pointers as well as pointer to pointers</span><span id="5abd" class="jd je hh ll b fi lu lr l ls lt">    if (Type-&gt;isAnyPointerType() &amp;&amp; !Type-&gt;isVoidPointerType() &amp;&amp;</span><span id="97be" class="jd je hh ll b fi lu lr l ls lt">        !isPointerToPointerType(Type)) {</span><span id="f94b" class="jd je hh ll b fi lu lr l ls lt">        // Check if the written properties contains the one we are interested</span><span id="5d58" class="jd je hh ll b fi lu lr l ls lt">        const auto PropertyAttributes = P-&gt;getPropertyAttributes();</span><span id="9bd2" class="jd je hh ll b fi lu lr l ls lt">        const auto IsAssignPointer =</span><span id="d4ce" class="jd je hh ll b fi lu lr l ls lt">          (PropertyAttributes &amp;</span><span id="d164" class="jd je hh ll b fi lu lr l ls lt">          (ObjCPropertyDecl::PropertyAttributeKind::OBJC_PR_assign |</span><span id="9a79" class="jd je hh ll b fi lu lr l ls lt">           ObjCPropertyDecl::PropertyAttributeKind::</span><span id="3a65" class="jd je hh ll b fi lu lr l ls lt">               OBJC_PR_unsafe_unretained));</span><span id="428c" class="jd je hh ll b fi lu lr l ls lt">        if (IsAssignPointer) {</span><span id="9a9b" class="jd je hh ll b fi lu lr l ls lt">          std::string WarningString = ([Type]() {</span><span id="9593" class="jd je hh ll b fi lu lr l ls lt">            if (Type-&gt;isObjCObjectPointerType()) {</span><span id="bbd8" class="jd je hh ll b fi lu lr l ls lt">              return “Using assign for an ObjC pointer type is not valid. Either “</span><span id="e9f9" class="jd je hh ll b fi lu lr l ls lt">                   “use strong or weak for a zeroing reference in this case.”;</span><span id="b563" class="jd je hh ll b fi lu lr l ls lt">            } else {</span><span id="63dd" class="jd je hh ll b fi lu lr l ls lt">              return “Using a pointer for a scalar type is invalid.”;</span><span id="501a" class="jd je hh ll b fi lu lr l ls lt">            }</span><span id="6c0d" class="jd je hh ll b fi lu lr l ls lt">          }());</span><span id="0124" class="jd je hh ll b fi lu lr l ls lt">          // Emit warning / error</span><span id="a9c0" class="jd je hh ll b fi lu lr l ls lt">          auto &amp;DiagnosticEngine = _Context.getDiagnostics();</span><span id="5fad" class="jd je hh ll b fi lu lr l ls lt">          unsigned DiagnosticID = DiagnosticEngine.getCustomDiagID(DiagnosticsEngine::Warning, “%0”);</span><span id="cdbb" class="jd je hh ll b fi lu lr l ls lt">          DiagnosticEngine.Report(P-&gt;getLocStart(), DiagnosticID) &lt;&lt; WarningString;</span><span id="9650" class="jd je hh ll b fi lu lr l ls lt">        }</span><span id="2f26" class="jd je hh ll b fi lu lr l ls lt">    }</span><span id="d84d" class="jd je hh ll b fi lu lr l ls lt">    // …</span><span id="1ef1" class="jd je hh ll b fi lu lr l ls lt">  }</span><span id="fa8f" class="jd je hh ll b fi lu lr l ls lt">  //…<br/>};</span></pre><p id="4edd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开发人员在引入新代码后第一次尝试编译时，Xcode会立即显示一条警告，并提示如何修复该问题:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es mj"><img src="../Images/7ebdb3bd5ded1e5d48465338d260eb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVzdCfaUSkkXmLrg."/></div></div></figure><h2 id="0a6e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">纹理:在init方法中访问视图属性</strong></h2><p id="1c89" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Pinterest的iOS应用几乎全部是用<a class="ae kd" href="https://github.com/texturegroup/texture" rel="noopener ugc nofollow" target="_blank">纹理</a>(原AsyncDisplayKit)编写的。有一些常见的模式会降低Texture提高性能的能力，因为我们拥有linter基础设施，所以我们创建了专门针对这些反模式的规则。</p><p id="08e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，其中一种模式是在任何类型的init方法中访问<code class="du li lj lk ll b">ASDisplayNode</code>的视图属性。访问<code class="du li lj lk ll b">ASDisplayNode</code>的视图将加载其支持视图或层。然而，init方法可以被任何线程调用，所以这样做不是线程安全的，因为加载过程会导致访问后台<code class="du li lj lk ll b">UIView</code>或<code class="du li lj lk ll b">CALayer</code>对象的属性。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es mk"><img src="../Images/2d3440ea0ee87b361d9af571872f4cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qUyqMTD14PyHNf91."/></div></div></figure><p id="068a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">定制的林挺基础设施允许我们灵活地快速对新的需求做出改变，而不需要依赖其他的linter基础设施来为我们的需求添加规则。</p><h2 id="ff3e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">安全舱口</h2><p id="760e" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在某些情况下，有必要跳过林挺。PINLinter提供了一个逃生出口。我们拥有对AST的完全访问权限，并且可以查找自定义的属性，通过添加可以附加到函数、方法或属性的自定义属性来完全跳过linter规则:</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="e70c" class="jd je hh ll b fi lq lr l ls lt">// functions</span><span id="31d3" class="jd je hh ll b fi lu lr l ls lt">__attribute__((annotate(“pi_nolint”)))</span><span id="40c2" class="jd je hh ll b fi lu lr l ls lt">static int divide(int denominator, int numerator) { /* … */ }<br/></span><span id="0619" class="jd je hh ll b fi lu lr l ls lt">// methods</span><span id="5358" class="jd je hh ll b fi lu lr l ls lt">- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath __attribute__((annotate(“pi_nolint”))) { /*… */ }<br/></span><span id="5e0f" class="jd je hh ll b fi lu lr l ls lt">// properties</span><span id="8c40" class="jd je hh ll b fi lu lr l ls lt">__attribute__((annotate(“pi_nolint”)))</span><span id="9684" class="jd je hh ll b fi lu lr l ls lt">@property (assign) CGFloat *iKnowWhatImDoint;</span></pre><p id="e2d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果这个属性附加到一个声明中，linter规则将跳过它，并且不会显示警告。该选项仅在特殊情况下使用。我们在代码评审基础设施中添加了一个特定的规则，如果使用了<code class="du li lj lk ll b">pi_nolint</code>属性，它会自动将特定的一组人添加到评审的差异中。</p><h2 id="d732" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">警告</h2><p id="64a1" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><strong class="ig hi">自定义Clang版本</strong></p><p id="bd15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用<a class="ae kd" href="https://clang.llvm.org/docs/ClangPlugins.html" rel="noopener ugc nofollow" target="_blank"> Clang </a>，必须从源代码构建Clang，或者使用来自<a class="ae kd" href="http://releases.llvm.org/download.html" rel="noopener ugc nofollow" target="_blank"> LLVM网站</a>的预构建版本。通过Xcode发布的Clang版本不支持现成的Clang插件，所以我们在安装期间为每个开发人员下载了一个预构建的Clang二进制文件，并指示Xcode在编译过程中使用这个版本的Clang。这可以通过将CC和CXX构建变量设置为自定义Clang二进制文件所在的路径来实现。接下来的每个编译过程都将使用这个Clang二进制文件，而不是Xcode二进制文件。</p><p id="7c8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">未知属性no scape</strong></p><p id="2f2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们遇到的另一个问题是预编译的Clang二进制文件不理解no escape属性，我们第一次编译Pinterest的iOS应用程序时就看到了编译错误。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/0ec2b0a3fc8bff2475a2f8557aca325b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w6RxjhwA6Ks5BJzK."/></div></div></figure><p id="7352" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我们创建了一个宏，如果编译器支持<code class="du li lj lk ll b">no_escape</code>它就会扩展，并用它替换了所有的<code class="du li lj lk ll b">__attribute__((noescape))</code>外观。</p><pre class="kf kg kh ki fd lm ll ln lo aw lp bi"><span id="098b" class="jd je hh ll b fi lq lr l ls lt">#if __has_attribute(noescape)</span><span id="7dd8" class="jd je hh ll b fi lu lr l ls lt">  #define PI_NOESCAPE __attribute__((noescape))</span><span id="0c7e" class="jd je hh ll b fi lu lr l ls lt">#else</span><span id="8595" class="jd je hh ll b fi lu lr l ls lt">  #define PI_NOESCAPE</span><span id="c3fa" class="jd je hh ll b fi lu lr l ls lt">#endif</span></pre><h2 id="215e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">摘要</h2><p id="4231" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">总的来说，我们看到了这种基础设施协同工作的主要收益，以及代码质量和开发人员满意度的显著提高。</p><p id="e28b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">鸣谢:感谢我们所有的iOS开发者使用和提供反馈，特别是我的队友Garrett Moon、Jon Parise、Brandon Kase、Rahul Malik和Levi McCallum对本文的反馈。</em></p></div></div>    
</body>
</html>