<html>
<head>
<title>How Capital One is Using Angular Elements to Upgrade from AngularJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Capital One如何使用角度元素从AngularJS升级</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/capital-one-is-using-angular-elements-to-upgrade-from-angularjs-to-angular-42f38ef7f5fd?source=collection_archive---------0-----------------------#2019-01-22">https://medium.com/capital-one-tech/capital-one-is-using-angular-elements-to-upgrade-from-angularjs-to-angular-42f38ef7f5fd?source=collection_archive---------0-----------------------#2019-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b82f346008c99d8ab7c8d79b20efe001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0Oss9jyhWpm_X7I7wQD7g.png"/></div></div></figure><p id="c331" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Capital One，我们的主要服务平台的很大一部分是用AngularJS构建的，我们每天都在不断地向我们的平台添加新功能。2018年7月，AngularJS的积极功能开发进入尾声，并进入长期支持(LTS)。由于这种转变，我们将从AngularJS迁移到Angular的计划变得更加紧迫。为了成功完成这一迁移，我们正在开发一个流程，以模块化的方式升级和构建新功能，同时不妨碍我们平台的持续开发。为了实现这一点，我们使用角元素作为偏移工具。</p><p id="b059" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">在我们潜进去之前，本文假设你已经对</em></strong><a class="ae jo" href="https://angularjs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="jn">AngularJS</em></strong></a><strong class="ir hi"><em class="jn"/></strong><a class="ae jo" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="jn">Angular</em></strong></a><strong class="ir hi"><em class="jn">，以及</em> </strong> <a class="ae jo" href="https://github.com/angular/ngMigration-Forum/wiki/Migration-Paths-Overview" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="jn">各种升级策略</em> </strong> </a> <strong class="ir hi"> <em class="jn">。</em> </strong></p><p id="2f2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有些人可能会问，<em class="jn">“等等，为什么是角元素？你为什么不用ngUpgrade方法来代替呢？！？!"。这些都是完全正确的问题。</em></p><h1 id="ae14" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><code class="du kn ko kp kq b">NgUpgrade</code>太脆</h1><p id="9bf3" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated"><a class="ae jo" href="https://angular.io/api/upgrade/static/UpgradeModule" rel="noopener ugc nofollow" target="_blank"> UpgradeModule </a>库不允许多个开发团队在同时升级的同时对同一个库做出贡献。更具体地说，从ngUpgrade方法的技术角度来看，在页面上同时升级两个AngularJS组件是不可能的。这将会妨碍我们的开发工作在有许多贡献者的大平台上的可伸缩性和独立性。</p><p id="9a06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">UpgradeModule使用AngularJS <code class="du kn ko kp kq b">$injector</code>记录角度分量。这允许两个框架在升级/降级过程中相互通信。然而，<em class="jn">因为</em>我们有多个团队升级他们自己的特性——用复杂的依赖图——这就产生了风险。团队需要在<code class="du kn ko kp kq b">$injector</code>中竞争名称空间，协调升级时间表几乎是不可能的。</p><p id="3a4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，UpgradeModule将两个框架紧密耦合在一起，当调用任一框架的生命周期挂钩时，都会导致性能影响。例如，如果AngularJS <code class="du kn ko kp kq b">$digest</code>周期由<code class="du kn ko kp kq b">ng-click</code>事件触发，Angular将经历一个完整的变化检测周期。同样，如果角度变化检测周期由<code class="du kn ko kp kq b">(click)</code>事件触发，AngularJS将经历一个完整的<code class="du kn ko kp kq b">$digest</code>周期。</p><p id="c168" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于这些原因，我们认为ngUpgrade对于我们的用例来说不是一个可行的升级策略。相反，我们需要一些灵活、可靠、与现有应用程序分离的东西，这样它们就不会影响我们的其他开发团队。</p><p id="744b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但那可能是什么呢？</p><h1 id="effc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">输入:角度元素</h1><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/dbb32d358a69544bab3508c344c724ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wN6wwpD3xvSAo_3h"/></div></div></figure><p id="36ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">早在Angular v6发布的时候，<a class="lb lc ge" href="https://medium.com/u/d265c7f819df?source=post_page-----42f38ef7f5fd--------------------------------" rel="noopener" target="_blank"> Rob Wormald </a>在NgConf 2018上发表了一个<a class="ae jo" href="https://www.youtube.com/watch?v=Z1gLFPLVJjY" rel="noopener ugc nofollow" target="_blank">激动人心的演讲</a>，谈到了web组件(一组包含自定义元素的DOM APIs)的进步，并列举了Angular如何让开发人员能够创建高度可移植的、与web框架无关的小部件的许多原因。这种方法的优点是:</p><ul class=""><li id="0240" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm li lj lk ll bi translated"><strong class="ir hi">随处使用— </strong>角度元素可以在浏览器中的任何地方使用，与框架无关。</li><li id="9189" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">通过依赖注入使用状态管理— </strong>我们可以利用Angular提供的依赖注入系统将页面上的任何元素链接到您选择的任何状态管理存储。这是通过在倾斜启动时暴露窗口对象上的注入器来实现的。(我们稍后将对此进行更深入的讨论。)</li><li id="8694" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">内容投影管用— </strong>只要第一次用页面渲染内容投影，一切都管用。另外，<code class="du kn ko kp kq b">ContentChild</code>和<code class="du kn ko kp kq b">QueryList</code>(及其复数形式)是为静态消费设计的；这些功能还不能适应动态的世界。Angular团队计划在不久的将来解决这个问题。</li><li id="63e1" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">样式的作用域是元素— </strong> <code class="du kn ko kp kq b">ViewEncapsulation</code>本质上是使用阴影DOM。元素应该使用<code class="du kn ko kp kq b">Native</code>模式，这样样式就不会漏过整个页面。<em class="jn">(注意</em>:我们选择在实现中使用<code class="du kn ko kp kq b">None</code>，因为我们有意重用我们为元素和遗留代码设计的样式。)</li><li id="7766" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">支持大多数主流浏览器— </strong>支持Angular的地方都支持Elements。确保包含通常所需的相同聚合填充。它甚至可以在IE9之前的IE浏览器中运行。</li><li id="bac9" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">所有的东西都在沙盒里— </strong>元素完全独立运作。这意味着在<code class="du kn ko kp kq b">$digest</code>周期和<code class="du kn ko kp kq b">ngZone</code>之间没有紧密耦合来检测变化。这直接转化为零性能影响！</li></ul><p id="6223" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">凭借元素的多功能性、依赖注入系统的可用性和自治性，元素解决了ngUpgrade可能会引入的许多问题。现在我们有了一种方法，可以让多个开发团队在迁移特性时按照他们自己的步调独立工作。</p><h1 id="0d60" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">这很好，但接下来呢？</h1><p id="24f2" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">既然我们已经有了将功能转换为元素的方法，我们需要为开发人员找到一种将元素转换为纯角度页面的方法。一些开发人员强调了两种转换特征的常用方法:垂直转换(例如通过路线)或水平转换(例如通过特征)。有了元素，我们就有了同时使用这两种方法的机会，这种机会将我们带到了完全迁移的三个基本阶段:</p><ol class=""><li id="2ef7" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm lr lj lk ll bi translated">从现有AngularJS应用程序中选择一个简单特征。</li><li id="e3c8" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">将整个页面的功能转换为元素。</li><li id="b45f" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">将所有新元素转换为有角度的路线，使它们成为纯有角度的。</li></ol><p id="7e8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">阶段2是最灵活的，因为它可以同时垂直和水平实施。以下是这一阶段的两种通用方法:</p><ol class=""><li id="3caa" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm lr lj lk ll bi translated">指定承载转换后的要素的单个元素。一旦所有东西都在元素中，就可以将其转换为角度路线:</li></ol><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/06835a2b5c87bc7777f6673ab2b26cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9rs6G79kunhdmg70"/></div></div></figure><p id="db3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.指定一个单独的元素来承载每个功能:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/8bb57685d59d69bd341e1698217939f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qfnbx96AzPQZPuAD"/></div></div></figure><p id="0ec6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管这三个阶段倾向于更垂直的迁移模式，但这并不是必须的。</p><p id="d1f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">避免在另一个元素中消耗一个元素，以及在根角度应用程序中消耗一个元素，这一点很重要。虽然这种形式的元素消耗是可能的，但它引入了将元素束加载到应用程序的额外技术复杂性。构建过程必须适应嵌套元素以及它们对最终构建包的引用。这种单一的复杂性会迅速增加认知负荷，导致糟糕的开发体验。将一个元素嵌入到另一个元素中的另一种方法可能很简单，只需构建彼此交互的规则角度特征组件，然后将所有这些组件包装到上面第一种方法中所示的单个元素中。</p><p id="b03a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在迁移时，有许多方法可以使用元素。我们发现这两种方法最直接，也最适合我们的情况。一定要选择最简单的适合你的选择。</p><p id="0a39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们超越自我之前，有几个设计决策是为了促进这种方法。</p><h1 id="47af" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">应用程序结构</h1><p id="4bde" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">为了将元素转换成纯角度的路线，我们需要做一些建筑管道来让事情移动:</p><ul class=""><li id="35eb" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm li lj lk ll bi translated"><strong class="ir hi">两个框架，两个陌生人— </strong>两个框架共存于页面上，但彼此不认识。</li><li id="3154" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi"> Angular首先引导— </strong>我们首先在页面顶部引导一个独立的根Angular应用程序，然后引导我们现有的AngularJS应用程序。这要尽快完成，以便在初始化任何元素之前，公开Angular的注入器来连接任何必要的状态管理工具。</li><li id="71b4" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">在同一个地方呈现UI—</strong>Angular js<code class="du kn ko kp kq b">&lt;ui-view&gt;</code>和Angular <code class="du kn ko kp kq b">&lt;router-outlet&gt;</code>标签在主内容区域中作为兄弟存在。这将AngularJS页眉和页脚强制作为包装器；随后，这些将是最后迁移的功能。</li><li id="3d31" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">保持关注点分离— </strong>在AngularJS处理的路线上，<code class="du kn ko kp kq b">&lt;ui-view&gt;</code>负责渲染任何可能包含元素特征的模板，而Angular route什么也不渲染。相反，当角度路线被激活时，AngularJS不显示任何内容，并且<code class="du kn ko kp kq b">&lt;router-outlet&gt;</code>接管渲染内容。</li></ul><p id="f6df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在顶层，我们让AngularJS和Angular frameworks并行运行。每个框架都有各自相邻的路由器标签。当我们将特征转换为元素，然后将元素转换为角度路线时，我们需要确保AngularJS不会为角度路线渲染任何内容，反之亦然。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/fa86d48c189aeeec00d44d80a8fdde2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oo9HYKBxN8mqo6_r"/></div></div></figure><p id="e695" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在左边,<code class="du kn ko kp kq b">/hero</code>路径由AngularJS处理，并呈现所有的蓝色内容区域。在浏览器的这种状态下，角度侧没有为其定义的管线，因此它默认使用空白模板渲染零部件:</p><pre class="kx ky kz la fd lu kq lv lw aw lx bi"><span id="942a" class="ly jq hh kq b fi lz ma l mb mc">/app.module.ts<br/>--------------------------------------------------------------------</span><span id="6fae" class="ly jq hh kq b fi md ma l mb mc">@Component({<br/>   template: ‘’<br/>})<br/>export class EmptyComponent {}</span><span id="00e7" class="ly jq hh kq b fi md ma l mb mc">. . .</span><span id="a23e" class="ly jq hh kq b fi md ma l mb mc">RouterModule.forRoot([<br/>  {<br/>     path: 'details',<br/>     component: HeroDetailsComponent<br/>  },<br/>  {<br/>     path: ‘**’,<br/>     component: EmptyComponent<br/>  }<br/>])</span></pre><p id="38e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当route在<code class="du kn ko kp kq b">/details</code>时，Angular router接管并渲染红色内容区域的所有内容。同时，AngularJS没有为<code class="du kn ko kp kq b">/details</code>定义路线，所以它将默认不渲染任何东西:</p><pre class="kx ky kz la fd lu kq lv lw aw lx bi"><span id="0a62" class="ly jq hh kq b fi lz ma l mb mc">/app.js<br/>--------------------------------------------------------------------</span><span id="328d" class="ly jq hh kq b fi md ma l mb mc">const heroState = {<br/>   name: 'hero',<br/>   url: '/hero',<br/>   templateUrl: './hero.html'<br/>};</span><span id="95b9" class="ly jq hh kq b fi md ma l mb mc">const emptyState = {<br/>   name: ‘empty-state’,<br/>   url: ‘/*path’,<br/>   template: ‘’<br/>};</span><span id="14bd" class="ly jq hh kq b fi md ma l mb mc">$stateProvider.state(heroState);<br/>$stateProvider.state(emptyState);</span></pre><h1 id="f9a8" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建角度元素</h1><p id="bae6" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">现在，我们已经建立了将特征转换为角度的过程，让我们来谈谈如何实际创建一个元素。如果您曾经经历过创建自己的元素的过程，这个过程可能会是一个巨大的痛点，尤其是当您需要创建多个元素时。创建和使用元素的一般过程如下:</p><ol class=""><li id="c1c6" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm lr lj lk ll bi translated">创建一个新的<code class="du kn ko kp kq b">NgModule</code>，它将作为<a class="ae jo" href="https://developers.google.com/web/fundamentals/web-components/customelements" rel="noopener ugc nofollow" target="_blank">定制元素</a>的宿主。</li><li id="3a35" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">在新的<code class="du kn ko kp kq b">NgModule</code>主机中定义一个组件作为<code class="du kn ko kp kq b">entryComponent</code>。</li><li id="fbc7" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">在注入器上连接任何状态管理。</li><li id="7a87" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">获取组件的一个引用，并将其定义为一个<code class="du kn ko kp kq b">customElement</code>。</li><li id="d30b" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">使用CLI和/或自定义生成器生成元素。</li><li id="459a" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">将新的包包含到根应用程序的<code class="du kn ko kp kq b">index.html</code>中。</li><li id="50b4" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm lr lj lk ll bi translated">在任何地方使用新的定制元素。</li></ol><p id="57ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是我们的用例<em class="jn">的一般过程。但是，根据具体情况，可能会添加或删除一些步骤。经历这一过程可能非常耗时且容易出错。因此，让我们使用一个更新的功能来帮助自动化这个过程，以消除尽可能多的人为错误！</em></p><h1 id="32fe" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">救援的角度示意图</h1><p id="b49b" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">随着Angular v6的发布，还引入了<a class="ae jo" href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" rel="noopener ugc nofollow" target="_blank">原理图</a>,使开发人员能够利用为Angular CLI提供动力的“秘方”,但用于他们自己的个人用例。Angular schematics本质上是一组API，使开发人员能够创建用于操作文件系统的指令集。</p><p id="a7da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于创建自定义元素非常复杂，我们求助于schematics作为搭建新元素的完美解决方案，然后一旦我们准备好将工作转换为角度路线，就“解开”它们。该解决方案将上面列出的七个步骤简化为一个命令！这不仅简化了过程，而且创建了开发人员可以遵循的标准的、可重复的过程。现在，他们可以专注于构建新的角度代码，而不是错综复杂地连接新元素。</p><p id="dd94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Schematics非常灵活，可以适应我们已经确定的各种用例。编写我们自己的定制原理图有助于消除迁移过程中创建和展开元素的手动过程中的棘手问题。</p><p id="1d8d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是现在你可能想知道，"<em class="jn">如果我想迁移的特性依赖于AngularJS资源(例如工厂、服务、提供者、常量等等)怎么办？)那还没换算呢？”很高兴你问了！</em></p><h1 id="22ae" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">输入:$injector</h1><p id="c924" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">为了在Angular上下文中重用AngularJS资源，我们需要获取对该资源的引用。前面提到过，UpgradeModule利用<code class="du kn ko kp kq b">$injector</code>来挂钩AngularJS，因此我们可以做同样的事情:</p><pre class="kx ky kz la fd lu kq lv lw aw lx bi"><span id="7634" class="ly jq hh kq b fi lz ma l mb mc">const $injector = (window as   any).angular.element(document.body).injector();</span></pre><p id="1818" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">获取对<code class="du kn ko kp kq b">$injector</code>的引用使我们能够访问APIs更具体地说，让我们可以访问<code class="du kn ko kp kq b">get()</code>和<code class="du kn ko kp kq b">has()</code>方法。通过这些方法，我们可以创建一个顶级的Angular service，它获取对AngularJS资源的引用，并将其注入到我们的任何元素中。</p><pre class="kx ky kz la fd lu kq lv lw aw lx bi"><span id="ce16" class="ly jq hh kq b fi lz ma l mb mc">/angularJSResource.service.ts<br/>--------------------------------------------------------------------</span><span id="f829" class="ly jq hh kq b fi md ma l mb mc">@Injectable({<br/> ...<br/>})<br/>export class AngularJSResourceService {</span><span id="3114" class="ly jq hh kq b fi md ma l mb mc">const $injector = (window as any).angular.element(document.body).injector();</span><span id="b542" class="ly jq hh kq b fi md ma l mb mc">getResource(name: string): any | null {<br/>  return this.$injector.has(name) ? this.$injector.get(name) : null;<br/>}</span><span id="6441" class="ly jq hh kq b fi md ma l mb mc">}</span><span id="869e" class="ly jq hh kq b fi md ma l mb mc">/my-element.component.ts<br/>--------------------------------------------------------------------</span><span id="5f66" class="ly jq hh kq b fi md ma l mb mc">@Component({<br/>  ...<br/>})<br/>export class MyElementComponent {</span><span id="f33b" class="ly jq hh kq b fi md ma l mb mc">// Grab reference to an AngularJS service<br/>const weatherProvider = this.ngService.getResource(‘weatherService’);</span><span id="79c1" class="ly jq hh kq b fi md ma l mb mc">constructor(private ngService: AngularJSResourceService) {}</span><span id="481f" class="ly jq hh kq b fi md ma l mb mc">}</span></pre><p id="e232" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在AngularJS中，我们将依赖项注册为字符串，因此我们可以按照我们定义它们的方式来引用它们。现在我们可以自由使用<code class="du kn ko kp kq b">factories</code>、<code class="du kn ko kp kq b">service</code>、<code class="du kn ko kp kq b">providers</code>、<code class="du kn ko kp kq b">constants</code>等资源。而不必先将依赖关系转换为角度。</p><p id="6354" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是要注意，即使我们使用<code class="du kn ko kp kq b">$injector</code>来获取资源的引用，我们也没有挂钩到任何AngularJS digest循环钩子。<code class="du kn ko kp kq b">$injector</code>的这种用法对性能没有任何影响。</p><h1 id="8369" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">升级的状态</h1><p id="d29f" class="pw-post-body-paragraph ip iq hh ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">截至2018年12月，我们已经迁移并推出了第一个迁移功能，作为生产的角度元素，并取得了巨大成功。为了衡量我们实施的影响，我们正在通过A/B测试评估可用性，这将有助于进一步确定我们的成功水平，确认与客户的零功能差异，并规避任何不可预见的风险。万一我们发现由该元素引起的生产问题，我们可以安全地关闭测试，继续使用已经存在的生产代码。</p><p id="dbc5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Capital One的服务平台将在未来几个月进行重大变革。我们预计将会有许多成功和经验教训。当我们继续以创新的方式学习、成长和利用Angular元素时，请务必跟随我们的旅程。</p><p id="bd63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">我想对</strong><a class="lb lc ge" href="https://medium.com/u/1f82434592fb?source=post_page-----42f38ef7f5fd--------------------------------" rel="noopener" target="_blank"><strong class="ir hi">Peter Shao</strong></a><strong class="ir hi">帮忙整理这篇博文表示感谢。</strong></p><h2 id="0ab0" class="ly jq hh bd jr me mf mg jv mh mi mj jz ja mk ml kd je mm mn kh ji mo mp kl mq bi translated">相关:</h2><ul class=""><li id="1eea" class="ld le hh ir b is kr iw ks ja mr je ms ji mt jm li lj lk ll bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/the-people-aspect-of-decommissioning-an-app-395c1ec3b722">您在迁移过程中会遇到的4个用户</a></li><li id="f067" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/a-b-testing-big-change-not-big-bang-c20e547400c"> A/B测试，大变化不是大爆炸</a></li></ul></div><div class="ab cl mu mv go mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ha hb hc hd he"><p id="3bf5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2018首都一。</em></p></div></div>    
</body>
</html>