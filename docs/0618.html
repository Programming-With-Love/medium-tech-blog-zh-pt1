<html>
<head>
<title>All About PendingIntents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于未决事件的一切</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/all-about-pendingintents-748c8eb8619?source=collection_archive---------1-----------------------#2021-03-23">https://medium.com/androiddevelopers/all-about-pendingintents-748c8eb8619?source=collection_archive---------1-----------------------#2021-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/74154bd75aa48609f3a8dd8281cc2d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csWzYUmYq_1HQsqBWk3OTA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration by <a class="ae it" href="https://dribbble.com/Molly_Hensley" rel="noopener ugc nofollow" target="_blank">Molly Hensley</a></figcaption></figure><p id="4ffd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">是Android框架的重要组成部分，但大多数可用的开发人员资源都专注于它们的实现细节，即“对系统维护的令牌的引用”，而不是它们的用法。</p><p id="b80f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于Android 12包括对待定意图的重要改变，包括需要明确决定何时可变或不可变的改变，我认为更多地讨论待定意图做什么，系统如何使用它们，以及为什么你可能偶尔想要可变的T2会有所帮助。</p><h1 id="f21f" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是未决事件？</h1><p id="caf8" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">一个<code class="du js jt ju jv b">PendingIntent</code>对象包装了一个<code class="du js jt ju jv b">Intent</code>对象的功能，同时允许你的应用程序代表你的应用程序指定另一个应用程序应该做的事情，以响应未来的动作。例如，当警报响起时，或者当用户点击通知时，可以调用包装的意图。</p><p id="3679" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">待定意向的一个关键方面是另一个应用程序代表你的应用程序调用意向<em class="kz">。也就是说，其他应用程序在调用意图时使用您的应用程序的身份。</em></p><p id="d036" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使<code class="du js jt ju jv b">PendingIntent</code>具有与普通<code class="du js jt ju jv b">Intent</code>相同的行为，系统使用与创建时相同的身份触发<code class="du js jt ju jv b">PendingIntent</code>。在大多数情况下，如警报和通知，这是应用程序本身的身份。</p><p id="dd64" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看我们的应用程序与<code class="du js jt ju jv b">PendingIntent</code>配合使用的不同方式，以及我们为什么要以这些方式使用它们。</p><h1 id="67f6" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">共同格</h1><p id="bbf9" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">使用<code class="du js jt ju jv b">PendingIntent</code>最常见也是最基本的方式是作为与通知相关联的动作:</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="5a55" class="li jx hh jv b fi lj lk l ll lm">val intent = Intent(applicationContext, MainActivity::class.java).apply {<br/>    action = NOTIFICATION_ACTION<br/>    data = deepLink<br/>}<br/><strong class="jv hi">val pendingIntent = PendingIntent.getActivity(<br/>    applicationContext,<br/>    NOTIFICATION_REQUEST_CODE,<br/>    intent,<br/>    PendingIntent.FLAG_IMMUTABLE<br/>)<br/></strong>val notification = NotificationCompat.Builder(<br/>        applicationContext,<br/>        NOTIFICATION_CHANNEL<br/>    ).apply {<br/>        // ...<br/>        setContentIntent(pendingIntent)<br/>        // ...<br/>    }.build()<br/>notificationManager.notify(<br/>    NOTIFICATION_TAG,<br/>    NOTIFICATION_ID,<br/>    notification<br/>)</span></pre><p id="5715" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到，我们正在构建一个标准类型的<code class="du js jt ju jv b">Intent</code>来打开我们的应用程序，然后简单地将其包装在一个<code class="du js jt ju jv b">PendingIntent</code>中，然后将其添加到我们的通知中。</p><p id="3d1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，因为我们有一个确切的动作，我们知道我们想要执行，我们构造了一个<code class="du js jt ju jv b">PendingIntent</code>，它不能被我们通过使用一个名为<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#FLAG_IMMUTABLE:kotlin.Int" rel="noopener ugc nofollow" target="_blank">FLAG_IMMUTABLE</a></code>的标志传递给它的应用程序修改。</p><p id="52d0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们调用<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/androidx/core/app/NotificationManagerCompat#notify(java.lang.String,%20int,%20android.app.Notification)" rel="noopener ugc nofollow" target="_blank">NotificationManagerCompat.notify()</a></code>之后，我们就完成了。系统将显示通知，当用户点击它时，在我们的<code class="du js jt ju jv b">PendingIntent</code>上调用<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#send" rel="noopener ugc nofollow" target="_blank">PendingIntent.send()</a></code>，启动我们的应用程序。</p><h1 id="5d7a" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">更新不可变的挂起内容</h1><p id="4a73" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">你可能认为如果一个应用程序需要更新一个<code class="du js jt ju jv b">PendingIntent</code>，它应该是可变的，但事实并非总是如此！创建<code class="du js jt ju jv b">PendingIntent</code>的应用程序总是可以通过传递标志<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#flag_update_current" rel="noopener ugc nofollow" target="_blank">FLAG_UPDATE_CURRENT</a></code>来更新它:</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="a321" class="li jx hh jv b fi lj lk l ll lm">val updatedIntent = Intent(applicationContext, MainActivity::class.java).apply {<br/>   action = NOTIFICATION_ACTION<br/>   data = differentDeepLink<br/>}<br/>// Because we're passing `FLAG_UPDATE_CURRENT`, this updates<br/>// the existing PendingIntent with the changes we made above.<br/>val updatedPendingIntent = PendingIntent.getActivity(<br/>   applicationContext,<br/>   NOTIFICATION_REQUEST_CODE,<br/>   updatedIntent,<br/><strong class="jv hi">   PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT</strong><br/>)<br/>// The PendingIntent has been updated.</span></pre><p id="f1c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们一会儿将讨论为什么一个人可能想要使<code class="du js jt ju jv b">PendingIntent</code>成为可变的。</p><h1 id="63fd" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">应用程序间API</h1><p id="8708" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">常见的情况不仅仅在与系统交互时有用。虽然最常见的是在执行一个动作后使用<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int,%20android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">startActivityForResult()</a></code>和<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent)" rel="noopener ugc nofollow" target="_blank">onActivityResult()</a></code>来<a class="ae it" href="https://developer.android.com/training/basics/intents/result" rel="noopener ugc nofollow" target="_blank">接收一个回调</a>，但这不是唯一的方法。</p><p id="e814" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">想象一下，一个在线订购应用程序提供了一个API，允许应用程序与之集成。它可能接受一个<code class="du js jt ju jv b">PendingIntent</code>作为它自己的<code class="du js jt ju jv b">extra</code>来启动点餐过程。订单应用程序仅在订单交付后启动<code class="du js jt ju jv b">PendingIntent</code>。</p><p id="938a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，订购应用程序使用一个<code class="du js jt ju jv b">PendingIntent</code>而不是发送一个活动结果，因为交付订单可能需要很长时间，而且强迫用户等待是没有意义的。</p><p id="5790" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们想要创建一个不可变的<code class="du js jt ju jv b">PendingIntent</code>，因为我们不希望在线订购应用程序改变我们的<code class="du js jt ju jv b">Intent</code>的任何东西。我们只是想让他们在订单到达时原样发送。</p><h1 id="a8dc" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">可变挂起内容</h1><p id="bfd0" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">但是，如果我们是订购应用程序的开发人员，我们希望添加一个功能，允许用户键入一条消息，该消息将被发送回调用它的应用程序，那该怎么办呢？也许是为了让调用应用程序显示类似“该吃披萨了！”</p><p id="9f19" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个问题的答案是使用可变的<code class="du js jt ju jv b">PendingIntent</code>。</p><p id="2125" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于一个<code class="du js jt ju jv b">PendingIntent</code>本质上是一个<code class="du js jt ju jv b">Intent</code>的包装器，人们可能会认为会有一个叫做<code class="du js jt ju jv b">PendingIntent.getIntent()</code>的方法，人们可以调用它来获取和更新被包装的<code class="du js jt ju jv b">Intent</code>，但事实并非如此。那么它是如何工作的呢？</p><p id="6447" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了<code class="du js jt ju jv b">PendingIntent</code>上的<code class="du js jt ju jv b">send()</code>方法不接受任何参数之外，还有一些其他版本，包括<a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#send(android.content.Context,%20kotlin.Int,%20android.content.Intent)" rel="noopener ugc nofollow" target="_blank">这个版本</a>，它接受一个<code class="du js jt ju jv b">Intent</code>:</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="9e5e" class="li jx hh jv b fi lj lk l ll lm">fun PendingIntent.send(<br/>    context: Context!, <br/>    code: Int, <br/>    intent: Intent?<br/>)</span></pre><p id="ebf6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个<code class="du js jt ju jv b">intent</code>参数不会替换包含在<code class="du js jt ju jv b">PendingIntent</code>中的<code class="du js jt ju jv b">Intent</code>，而是用来填充在<code class="du js jt ju jv b">PendingIntent</code>创建时没有提供的包装<code class="du js jt ju jv b">Intent</code>中的参数。</p><p id="9bb3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子。</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="03c9" class="li jx hh jv b fi lj lk l ll lm">val orderDeliveredIntent = Intent(applicationContext, OrderDeliveredActivity::class.java).apply {<br/>   action = ACTION_ORDER_DELIVERED<br/>}<br/>val mutablePendingIntent = PendingIntent.getActivity(<br/>   applicationContext,<br/>   NOTIFICATION_REQUEST_CODE,<br/>   orderDeliveredIntent,<br/>   PendingIntent.FLAG_MUTABLE<br/>)</span></pre><p id="5abe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个<code class="du js jt ju jv b">PendingIntent</code>可以交给我们的在线订单app。交付完成后，订单应用程序可以获取一个<code class="du js jt ju jv b">customerMessage</code>并将其作为额外的意图发送回去，如下所示:</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="49f6" class="li jx hh jv b fi lj lk l ll lm">val intentWithExtrasToFill = Intent().apply {<br/>   putExtra(EXTRA_CUSTOMER_MESSAGE, customerMessage)<br/>}<br/>mutablePendingIntent.send(<br/>   applicationContext,<br/>   PENDING_INTENT_CODE,<br/>   intentWithExtrasToFill<br/>)</span></pre><p id="cc5e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，调用应用程序将在其<code class="du js jt ju jv b">Intent</code>中看到额外的<code class="du js jt ju jv b">EXTRA_CUSTOMER_MESSAGE</code>，并能够显示该消息。</p><h1 id="113a" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">声明挂起意图可变性时的重要考虑事项</h1><p id="aff7" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">⚠️在创建一个可变的<code class="du js jt ju jv b">PendingIntent</code> <strong class="iw hi">时总是</strong>显式地设置将要在<code class="du js jt ju jv b">Intent</code>中启动的组件。这可以用我们上面的方法来完成，通过显式设置接收它的类，但是也可以通过调用<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/content/Intent.html#setComponent(android.content.ComponentName)" rel="noopener ugc nofollow" target="_blank">Intent.setComponent()</a></code>来完成。</p><p id="c509" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您的应用程序可能会有一个似乎更容易调用<code class="du js jt ju jv b">Intent.setPackage()</code>的用例。如果你这样做，要非常小心<strong class="iw hi">匹配多个组件</strong>的可能性。如果可能的话，最好指定一个特定的组件来接收<code class="du js jt ju jv b">Intent</code>。</p><p id="a83c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">⚠️:如果你试图覆盖用<code class="du js jt ju jv b">FLAG_IMMUTABLE</code>创建的<code class="du js jt ju jv b">PendingIntent</code>中的值，那么<strong class="iw hi">将会无声地</strong>失败，不加修改地交付原始包装的<code class="du js jt ju jv b">Intent</code>。</p><p id="05dd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，一个应用程序总是可以更新它自己的<code class="du js jt ju jv b">PendingIntent</code>，即使它们是不可变的。使<code class="du js jt ju jv b">PendingIntent</code>可变的唯一原因是另一个应用程序必须能够以某种方式更新包装的<code class="du js jt ju jv b">Intent</code>。</p><h1 id="cd8c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">关于标志的详细信息</h1><p id="aedd" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">我们已经讨论了一些在创建<code class="du js jt ju jv b">PendingIntent</code>时可以使用的标志，但是还有一些其他的标志需要讨论。</p><p id="dbff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#FLAG_IMMUTABLE:kotlin.Int" rel="noopener ugc nofollow" target="_blank">FLAG_IMMUTABLE</a></code>:表示<code class="du js jt ju jv b">PendingIntent</code>内部的意图不能被其他传递了<code class="du js jt ju jv b">Intent</code>到<code class="du js jt ju jv b">PendingIntent.send()</code>的应用修改。一个应用程序总是可以使用<code class="du js jt ju jv b">FLAG_UPDATE_CURRENT</code>来修改它自己的挂起内容</p><p id="2808" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android 12之前，没有这个标志的<code class="du js jt ju jv b">PendingIntent</code>在默认情况下是可变的。</p><p id="f56d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android 6 (API 23)之前的Android版本上的⚠️，<code class="du js jt ju jv b">PendingIntent</code> s总是可变的。</p><p id="3be2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">🆕<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#FLAG_MUTABLE:kotlin.Int" rel="noopener ugc nofollow" target="_blank">FLAG_MUTABLE</a></code>:表示<code class="du js jt ju jv b">PendingIntent</code>内部的意图应该允许通过合并<code class="du js jt ju jv b">PendingIntent.send()</code>的意图参数的值来更新其内容。</p><p id="f275" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">⚠️ <strong class="iw hi">总是</strong>填充任何可变<code class="du js jt ju jv b">PendingIntent</code>的包装<code class="du js jt ju jv b">Intent</code>的<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/android/content/ComponentName" rel="noopener ugc nofollow" target="_blank">ComponentName</a></code>。否则会导致安全漏洞！</p><p id="62eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个标志是在<a class="ae it" href="https://developer.android.com/reference/android/app/PendingIntent#FLAG_MUTABLE" rel="noopener ugc nofollow" target="_blank"> Android 12 </a>中添加的。在Android 12之前，任何没有<code class="du js jt ju jv b">FLAG_IMMUTABLE</code>标志的<code class="du js jt ju jv b">PendingIntent</code>都是隐式可变的。</p><p id="a818" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#flag_update_current" rel="noopener ugc nofollow" target="_blank">FLAG_UPDATE_CURRENT</a></code>:请求系统用新的额外数据更新现有的<code class="du js jt ju jv b">PendingIntent</code>，而不是存储新的<code class="du js jt ju jv b">PendingIntent</code>。如果<code class="du js jt ju jv b">PendingIntent</code>没有被注册，那么这个就会被注册。</p><p id="64a9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#flag_one_shot" rel="noopener ugc nofollow" target="_blank">FLAG_ONE_SHOT</a></code>:只允许发送一次PendingIntent(通过<code class="du js jt ju jv b">PendingIntent.send()</code>)。当将一个<code class="du js jt ju jv b">PendingIntent</code>传递给另一个应用程序时，如果其中的<code class="du js jt ju jv b">Intent</code>只能被发送一次，这可能很重要。这可能和方便有关，也可能是为了防止app多次执行某个动作。</p><p id="f64d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">🔐利用<code class="du js jt ju jv b">FLAG_ONE_SHOT</code>防止诸如<a class="ae it" href="https://en.wikipedia.org/wiki/Replay_attack" rel="noopener ugc nofollow" target="_blank">【重放攻击】</a>之类的问题。</p><p id="0ecb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent#flag_cancel_current" rel="noopener ugc nofollow" target="_blank">FLAG_CANCEL_CURRENT</a></code>:在注册新的<code class="du js jt ju jv b">PendingIntent</code>之前，取消现有的<code class="du js jt ju jv b">PendingIntent</code>(如果存在的话)。如果一个特定的<code class="du js jt ju jv b">PendingIntent</code>被发送到一个应用程序，而你想把它发送到不同的应用程序，可能会更新数据，这可能很重要。通过使用<code class="du js jt ju jv b">FLAG_CANCEL_CURRENT</code>，第一个应用程序将不再能够调用send，但是第二个应用程序可以。</p><h1 id="989c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">接收待处理内容</h1><p id="eb44" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">有时系统或其他框架会提供一个<code class="du js jt ju jv b">PendingIntent</code>作为API调用的返回。Android 11中加入的方法<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/android/provider/MediaStore#createWriteRequest(android.content.ContentResolver,%20java.util.Collection%3Candroid.net.Uri%3E)" rel="noopener ugc nofollow" target="_blank">MediaStore.createWriteRequest()</a></code>就是一个例子。</p><pre class="la lb lc ld fd le jv lf lg aw lh bi"><span id="ff61" class="li jx hh jv b fi lj lk l ll lm">static fun MediaStore.createWriteRequest(<br/>    resolver: ContentResolver, <br/>    uris: MutableCollection&lt;Uri&gt;<br/>): PendingIntent</span></pre><p id="5b59" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们的应用程序创建的<code class="du js jt ju jv b">PendingIntent</code>用我们的应用程序的身份运行，系统创建的<code class="du js jt ju jv b">PendingIntent</code>用系统的身份运行。在这个API的例子中，这允许我们的应用程序启动一个<code class="du js jt ju jv b">Activity</code>,它可以向我们的应用程序授予对一组<code class="du js jt ju jv b">Uri</code>的写权限。</p><h1 id="a52d" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">摘要</h1><p id="e348" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">我们已经讨论过如何将一个<code class="du js jt ju jv b">PendingIntent</code>看作是一个<code class="du js jt ju jv b">Intent</code>的包装器，它允许系统或另一个应用程序在未来的某个时间启动一个应用程序创建的<code class="du js jt ju jv b">Intent</code>。</p><p id="2037" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还讨论了一个<code class="du js jt ju jv b">PendingIntent</code>通常应该是不可变的，这样做不会阻止应用程序更新它自己的<code class="du js jt ju jv b">PendingIntent</code>对象。除了使用<code class="du js jt ju jv b">FLAG_IMMUTABLE</code>之外，还可以使用<code class="du js jt ju jv b">FLAG_UPDATE_CURRENT</code>标志。</p><p id="9bb9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还讨论了我们应该采取的预防措施——确保填充被包装的<code class="du js jt ju jv b">Intent</code>的<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/reference/kotlin/android/content/ComponentName" rel="noopener ugc nofollow" target="_blank">ComponentName</a></code>——如果<code class="du js jt ju jv b">PendingIntent</code>必须是可变的。</p><p id="a2d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们讨论了有时系统或框架如何向我们的应用程序提供<code class="du js jt ju jv b">PendingIntent</code> s，以便我们可以决定如何以及何时运行它们。</p><p id="fe0a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对<code class="du js jt ju jv b">PendingIntent</code>的更新只是Android 12中旨在提高应用安全性的功能之一。点击在预览中阅读所有的<a class="ae it" href="https://android-developers.googleblog.com/2021/02/android-12-dp1.html" rel="noopener ugc nofollow" target="_blank">变化。</a></p><p id="7874" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">想做更多吗？我们鼓励您在操作系统的<a class="ae it" href="https://developer.android.com/about/versions/12/get" rel="noopener ugc nofollow" target="_blank">新开发者预览版上测试您的应用，并且</a><a class="ae it" href="https://developer.android.com/about/versions/12/feedback" rel="noopener ugc nofollow" target="_blank">向我们提供您的体验反馈</a>！</p></div></div>    
</body>
</html>