<html>
<head>
<title>Data consistency among microservices: is it possible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务之间的数据一致性:可能吗？</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/data-consistency-among-microservices-is-it-possible-fe48938235d1?source=collection_archive---------0-----------------------#2018-12-14">https://medium.com/oracledevs/data-consistency-among-microservices-is-it-possible-fe48938235d1?source=collection_archive---------0-----------------------#2018-12-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="1e74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">微服务是一种趋势，很好看，很酷……甚至很牛逼！但是，如果您正在考虑使用它或者已经转向这种方法，您是否已经考虑过如何正确地处理数据？你觉得你应该考虑一下吗？</p><h1 id="683c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">第一:为什么是微服务？</h1><p id="a101" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">您为什么要在项目中考虑微服务呢？为什么开发人员应该关心它？</p><p id="2340" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">答案可以通过康威定律找到:</p><blockquote class="kf kg kh"><p id="bb53" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">“设计系统的组织……不得不生产这些组织的通信结构的复制品。”</p></blockquote><p id="0c42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，你和/或你的公司交付的软件是以你们内部相互交流的方式构建的。</p><p id="95eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在马丁·福勒的一篇著名文章(URL 1)中，有一些康威定律的好例子。</p><p id="9d86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，他展示了“孤立的职能团队”如何构建他们的应用程序:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es km"><img src="../Images/43a212d6941eca4364532e4d262b0a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*s1z_Ue7LPO0S6xW3S1-iog.png"/></div></figure><p id="8886" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么“跨职能团队”是如何做到的:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/0870700a5e948038d31ba21f98e4482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqxQdYlj4SxN9mtKoVne4A.png"/></div></div></figure><p id="1d56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">什么给我们带来了一个重要的概念:微服务打算先规模化人，而不是软件。</p><p id="deb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，不管你把你的整体分成几十个、几百个甚至几千个服务。如果在分解的过程之前没有对你的团队的组织方式进行分解，你的项目结果可能是一场灾难。</p><p id="1690" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个与组织你的团队的方式有关的定律也是众所周知的:“两个披萨定律”。它指出，组织中的任何团队和/或会议都不应该太大，以至于不能只用两个披萨来满足。通过这样做，公司保持了所有团队的小规模、独立性，如果一切顺利，还保持了敏捷。</p><p id="3c95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过加入两个定律(康威和2个比萨饼)，你明白你会分解你的团队，并保持小规模，以帮助你扩大规模。甚至在考虑扩展软件之前。</p><p id="5604" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果团队有自主权，他们可以选择服务中使用的技术。他们可以定义服务API。当然，他们可以选择服务的数据库。</p><h1 id="9cdd" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">数据库和微服务</h1><p id="4c7f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">因为我们这里的观点是专门用微服务处理数据，所以Fowler的文章也讨论了这个问题。根据康威定律,“孤立”和“跨职能”团队的自然数据库输出如下:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/83db6db803fcf27e0382b2b4faea740c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGvTQcRp-fLVDfgu1rEx2Q.png"/></div></div></figure><p id="4ea4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在左侧，我们有整体数据库:整个应用程序只有一个数据库。</p><p id="4145" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在右侧，每个应用程序一个数据库，也称为“每个服务模式一个数据库”。</p><p id="2fc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想更好地知道如何从左边来，到右边去，看看我的朋友Edson Yanaga的这本书(URL 2)。</p><p id="4861" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个服务一个数据库的模式有助于处理微服务开发的许多方面，但是也产生了一个问题:一致性。</p><h1 id="2762" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">数据一致性</h1><p id="9579" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在一张图片中，你会怎么说“一致性”？我会这样做:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es la"><img src="../Images/6b4d23eb68af81ebd0816b8d656951f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SR4mLxU9hYNoXrkCqszrzw.png"/></div></div></figure><p id="d5de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当谈到微服务数据一致性时，它关系到我们应该做些什么来避免猫中的猫头鹰…</p><p id="e379" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于monolith数据库，使用ACID事务来保证一致性是很容易和自然的。ACID缩写的意思是:</p><ul class=""><li id="8ac8" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">原子性:不管一个事务有一个、两个还是一百个步骤；所有这些都必须成功完成。否则，事务将被回滚；</li><li id="0f2e" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">一致性:在事务结束时，数据库中的所有数据必须一致。与完整性引用、业务逻辑引用等保持一致；</li><li id="4e15" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">隔离:一个事务不能接触其他事务同时接触的数据；</li><li id="283d" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">持久性:与持久性有关。在事务结束时，数据必须持久保存在数据库中。</li></ul><p id="c6df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好吧，但是…当数据库彼此分离时，你会怎么做呢？你甚至不能保证它们使用相同的技术。你如何在它们之间进行交易？</p><p id="780b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它们可以在不同的网络、云供应商、服务器、框架下……请看下图:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lp"><img src="../Images/9065b457b8e9f0e75534c3057d94aaa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NK-84f3dCk9riFHcACSjRQ.png"/></div></div></figure><p id="62df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我希望您确信您不能在微服务架构中的数据库之间进行事务处理，因此您不能使用事务来保证一致性。但是您仍然需要ACID事务能够为您的应用程序带来的结果，对吗？</p><h1 id="5a60" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">拯救传奇</h1><p id="93ab" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了帮助我们应对这一挑战，有一个很棒的设计模式叫做Sagas。作为一个快速的背景介绍，它在1987年由埃克托·加西亚-莫利纳和肯尼斯·塞勒姆写的一篇论文中首次被提及，该论文由普林斯顿大学出版。</p><p id="6987" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇论文很棒，你可以在URL 3这里读到它的副本。</p><p id="55df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文中最重要的一点是一个叫做“补偿交易”的概念。</p><p id="704b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，对于事务的每一步，都有一个在失败时调用的辅助步骤。重要提示:补偿事务不会回滚所做的事情，但会…嗯…补偿它。你可以在下图中看到:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lq"><img src="../Images/f331a6a86a3798bacb68f07bd6c013fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVPG8yAQe4_As0mLmLXS4A.png"/></div></div></figure><p id="3fa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设你用信用卡购物100美元。但是产品有问题，你决定马上退货。信用卡公司不会回滚或删除交易:他们会创建另一个交易来恢复交易。来补偿它。</p><p id="26e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在你的信用卡账单上，你将会有100美元以上和100美元以下的交易。</p><p id="e3f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，当您调用了一系列服务，其中一个失败时，您可以调用前一个服务的补偿事务，以便将数据状态返回到起点。</p><h1 id="d73b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">如何管理补偿电话</h1><p id="156b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">好的，很好。补偿交易无处不在，一切都会起作用。问题解决了！</p><p id="2018" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">良好的..</p><p id="fcb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">调用补偿有两种方式:</p><ul class=""><li id="da39" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">自我管理:如果出现问题，服务知道应该做什么。它知道必须调用哪个补偿；</li><li id="c325" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">编排:有一个服务用于编排调用链。它知道调用服务的顺序，以及当任何一个服务失败时必须做什么。</li></ul><p id="2a3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一种在服务之间产生耦合。也增加了服务的复杂性。并且降低了它的可用性。所以，要避免。</p><p id="7a9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个是松耦合的，复杂性转移到了orchestrator服务，服务保持了它们的可重用性。更喜欢。</p><p id="41aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想象一下，信用交易可以用在不同的场景中。一个用于购物，另一个用于退货，另一个用于在线服务……每一个都有不同的补偿要做。因此，每个场景可以有一个orchestrator，让它管理所有棘手的部分。</p><p id="33e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">太好了！现在，您已经有了一个模式和实现该模式的方法，以便在与不一致性的斗争中取得成功。但是，您是否注意到应用程序的复杂性正在增加？你如何保持它的可管理性，同时还能获得最好的佐贺外卖？</p><h1 id="1611" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">来自Fn流的手</h1><p id="693d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">有一个很棒的开源项目叫做Fn。我不会在这里说太多的细节，但是你可以在URL 4得到更多的信息。</p><p id="90a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Fn是一个无服务器的平台，在这里你可以像函数一样运行你的应用。为了帮助你管理你的函数执行，Fn有一个很棒的工具叫做Fn Flow。</p><p id="985e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Fn Flow不仅可以管理、监控和记录所有函数的执行(如果你用它来调用它们的话)，还可以给你一个编排你的传奇故事的方法。</p><p id="4229" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码可以在URL 5的Fn教程中找到。</p><p id="858c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它模拟了一个旅行社，您可以在其中预订和取消不同的旅游服务:酒店、汽车租赁和航班。在请求结束时，您应该会收到一封确认电子邮件。</p><p id="9abb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">服务编排器代码将如下所示:</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="94f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要理解代码:</p><ul class=""><li id="24ed" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">首先从"<em class="ki">"中获得一个Fn流的实例。current flow()</em>"；</li><li id="d0a7" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">通过这个实例，您可以从“<em class="ki"> invokeFunction(…) </em>”创建每个服务端点的调用；</li><li id="eeff" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">这些调用是未来的实例，因此您可以享受异步调用的所有好处；</li><li id="8823" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">做<em class="ki">然后作曲</em>的时候，可以管理调用的顺序，以及任何一个失败的时候应该调用什么；</li><li id="39fe" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">对于每个“<em class="ki"> excepcionallyCompose </em>”，它被称为“取消”方法，指向一个端点。</li></ul><p id="22b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“<em class="ki">取消</em>的方法代码是这样的:</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b5bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些呼叫由Fn Flow跟踪，并可通过其仪表板进行监控。查看以下示例:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lt"><img src="../Images/4947ccc557d594e9c10d13d46f656060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCmic5FPU-9_93y8knXSzw.png"/></div></div></figure><p id="8649" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">厉害！但是我们并不仍然“在那里”…我们“几乎在那里”…</p><p id="4254" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法通过调用另一个服务(“取消”服务)来解决处理每个服务失败的问题。但是如果“取消”服务也失败了呢？</p><p id="fcd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你不能写长篇大论，因为出错的可能性是无穷无尽的，这样的代码会非常糟糕。那么，你应该怎么做呢？</p><h1 id="79dc" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">商业方面</h1><p id="e8c5" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在补偿失败的情况下应该做什么的决定更多地与业务方面相关。</p><p id="2ead" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个例子，选择是创建一个重试它的逻辑。因此，它没有调用“取消”方法，而是创建了一个“重试取消”方法:</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4203" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Retry类后面的代码在这里没有太大的区别，知道它将针对失败的端点安排一些重试就足够了。</p><p id="8835" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，关于失败补偿的决定与商业方法密切相关。可能是:</p><ul class=""><li id="05f0" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">打开求助服务台的票证</li><li id="bff6" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">改变应用程序行为，直到问题得到解决</li><li id="eea5" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">给某人/某处发电子邮件</li><li id="ccad" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">你说出其他人的名字…</li></ul><h1 id="e211" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="2b33" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">微服务是解决许多情况的好方法，但前提是以正确的方式和正确的理由使用它。否则，它只会制造你的项目和团队中没有的复杂情况。</p><p id="e3cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">轮到你了！如果你尝试这些方法，分享你的想法和结果。</p><h1 id="fecf" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><p id="356c" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">网址1:<a class="ae lu" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/microservices.html</a></p><p id="e4d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">网址2:<a class="ae lu" href="https://www.oreilly.com/programming/free/migrating-to-microservice-databases.csp" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/programming/free/migrating-to-microservice-databases . CSP</a></p><p id="149c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">网址3:<a class="ae lu" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . Cornell . edu/andru/cs 711/2002 fa/reading/sagas . pdf</a></p><p id="fad2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">网址4:<a class="ae lu" href="http://fnproject.io/" rel="noopener ugc nofollow" target="_blank">http://fnproject.io/</a></p><p id="2820" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">URL 5:<a class="ae lu" href="https://github.com/delabassee/tutorials/tree/master/FlowSaga" rel="noopener ugc nofollow" target="_blank">https://github . com/delabassee/tutorials/tree/master/flow saga</a></p></div></div>    
</body>
</html>