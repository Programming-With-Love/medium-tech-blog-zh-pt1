<html>
<head>
<title>Spec to Gherkin to Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">规范到小黄瓜到代码</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa?source=collection_archive---------0-----------------------#2018-02-01">https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa?source=collection_archive---------0-----------------------#2018-02-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="381c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">基于Swagger和OAS的接力赛</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/780056b3c3a7015947489cba5d2bb903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2Xvf5a2GQc0w16Zn-cM0w.jpeg"/></div></div></figure><p id="0b76" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">短语<em class="ke">“Spec to Gherkin to Code”</em>听起来几乎就像体育广播员在喊棒球双杀，从游击手到二垒手再到一垒手。良好同步的团队合作的理想是我们如何从写在<a class="ae kf" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a> (OAS，以前的Swagger)中的API描述转移到基于<a class="ae kf" href="https://cucumber.io/docs/reference" rel="noopener ugc nofollow" target="_blank">小黄瓜</a>的验收测试，再到实际的工作代码。我感兴趣的是移交的细节，以及在过程的每个阶段信息是如何保存的。</p><p id="9ac4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这似乎与通过平衡优势和劣势来建立团队的本质相类似。一项运动的规则导致需要建立专门的技能。组建一支棒球队需要九个人；构建一个有效的应用程序需要多种工具和语言。当所有球员都需要的时候，把一个球员提升为“最有价值”是错误的。</p><p id="3591" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">记住目的很重要:<em class="ke">工作代码。</em>但是单独运行应用程序代码<em class="ke"/>——是不够的。除了代码，我们还需要一些基础来证明代码真的有效。如果你是一个棒球迷，并且支持一场出色的防守，你会很高兴看到裁判判跑垒员出局。有一个裁判为刚刚发生的事情提供正式的见证是很重要的。在软件领域，裁判的判断被自动化测试所取代。当我们查看各种测试工具时，我想起了三位棒球裁判，他们努力做到公平:</p><p id="67b3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">裁判# 1:</strong>“<em class="ke">有球就有好球，我就叫它们本来的样子。”</em></p><p id="393a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">裁判#2:  <em class="ke">“我只是一个普通人，我所能做的最好的事情就是按照我所看到的来称呼他们。”</em></p><p id="f741" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">裁判#3:  <em class="ke">“你们两个都错了:在你叫他们之前，他们什么都不是。”</em></p><p id="a062" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">裁判#3的观点与自动化测试和验收测试驱动开发(ATDD)相似。我们的代码没有工作，直到我们有自动化测试来确认我们对正确行为的主观印象。没有测试结果，就没有可用的代码。</p><p id="4709" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我认为这有助于澄清OpenAPI规范和小黄瓜的作用。最终的工作代码只是解决方案的一部分。测试用例至少和代码一样重要，在某些情况下，测试用例可能是唯一更重要的工件，因为它们可能是正确行为的唯一有意义的定义。</p><p id="09b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，试图管理Gherkin、OpenAPI和代码，并让它们成功地合作可能会有问题。我们的玩家有不同的语言，但他们应该都在玩一个游戏。我们可以创建一个小的Python工具来确保语言匹配。</p><h2 id="360e" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">RESTful API和OpenAPI规范</h2><p id="3197" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">我将从OpenAPI规范开始，因为我偏向于编写RESTful API，而编写到OpenAPI规范中的API描述提供了大量的细节，这些细节很容易转换成小黄瓜<em class="ke">。</em> <strong class="jk hi"> <em class="ke">注意——在这篇文章中，我将重点介绍OAS版本2，而不是OAS版本3。</em> </strong></p><p id="cdcc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然OpenAPI规范在技术上是一个简单的JavaScript对象符号(JSON)文档，但是读取和编写JSON可能很困难。因此，很多人更喜欢使用YAML(另一种标记语言)符号来编写OpenAPI规范的API描述。如果你去<a class="ae kf" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank">https://swagger.io/</a>打开在线编辑器，它可以用YAML符号工作。</p><p id="1e23" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">OpenAPI规范受到底层HTTP规则的约束。规范中没有详细说明这些规则。形式上，它们是在RFC中定义的，RFC定义了规范部分的语义。虽然规范中没有说明行为细节，但是在为验收测试创建小黄瓜时需要说明。</p><p id="38d2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">写入OpenAPI规范的API描述定义了服务器处理的URL路径。每条路径中都有操作。这些是应用于由路径定义的资源的动词。HTTP对可用的动词施加了一些限制，这要求在适当地选择操作时需要一些技巧。Gherkin没有OpenAPI规范那样狭隘的关注点。</p><p id="8138" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个符合我们介绍中棒球主题的具体例子:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="c242" class="kg kh hh lh b fi ll lm l ln lo">swagger: ‘2.0’<br/>info:<br/> title: A Quick Demo<br/> version: ‘1.0’</span><span id="8a97" class="kg kh hh lh b fi lp lm l ln lo">paths:<br/> <br/> /umpires:<br/>   get:<br/>    summary: The umpires<br/>    responses:<br/>     200:<br/>       description: The umpire list<br/>       schema:<br/>         type: object<br/>         properties:<br/>            status:<br/>              type: string<br/>              example: “OK”<br/>            data:<br/>              type: array<br/>              items:<br/>                type: string<br/>              example: [“Tinker”, “Evers”, “Chance”]<br/>     403:<br/>       description: Error</span></pre><p id="4472" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们已经定义了一个RESTful API，其中有一个资源/umpires，并且只有一个针对该资源的操作GET。名称/umpires是复数，以强调它是资源的分类，而不是资源的单个实例。</p><p id="59eb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">schema部分提供了响应文档的定义。模式定义的细节可能很难可视化。一个例子会有所帮助:下面是示例文档</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="fc19" class="kg kh hh lh b fi ll lm l ln lo">{<br/>    “status”: “OK”,<br/>    “data”: [<br/>       “Tinker”,<br/>       “Evers”,<br/>       “Chance”<br/>    ]<br/> }</span></pre><p id="ce24" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">本文档是根据OpenAPI规范中提供的示例构建的。示例值是从规范到代码的核心。</p><h2 id="f04f" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">验收测试和小黄瓜</h2><p id="98a4" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">一个非常流行的验收测试工具是黄瓜，这个工具使用小黄瓜语言规范和基于Ruby的步骤定义。我更熟悉<a class="ae kf" href="http://pythonhosted.org/behave/" rel="noopener ugc nofollow" target="_blank">行为</a>，因为它是Cucumber的一个很好的Python实现。阅读更多关于<a class="ae kf" rel="noopener" href="/@mvwi/story-writing-with-gherkin-and-cucumber-1878124c284c">用小黄瓜和黄瓜</a>写更好的用户故事。</p><p id="d88a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与OpenAPI规范一样，Gherkin本质上倾向于声明性的。规范本身不是工作代码，它们是对代码预期行为的描述。Gherkin语句是被动编写的，允许用命令式代码灵活实现。</p><p id="b316" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个小黄瓜场景规范的例子:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="8c1f" class="kg kh hh lh b fi ll lm l ln lo">Scenario: Get the list of umpires<br/> Given a test microservice<br/> And umpires [‘Tinker’, ‘Evers’, ‘Chance’]<br/> When request is “/umpires”<br/> Then response body includes [‘Tinker’, ‘Evers’, ‘Chance’]</span></pre><p id="b560" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是一个正式的结构，包含三个步骤定义:</p><ul class=""><li id="f299" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">给定—指定上下文。</li><li id="a6ad" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">When —这将指定一个RESTful API请求。</li><li id="d722" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">那么——这描述了预期的响应。</li></ul><p id="a026" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Gherkin结构是一种在任何粒度级别指定行为的优雅方式。可应用于函数、类定义、模块、包、微服务、框架、数据库等。一切有行为的地方。</p><p id="1c99" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果小黄瓜特征文件不是代码，它们是如何变成测试的？T9】</p><p id="a468" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们需要编写步骤定义，在用问题领域术语编写的特性和在解决方案领域工作的测试用例之间架起一座桥梁。使用Behave时，我们可能会有一个steps/prejure . py文件，其中包含以下几种定义:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="828d" class="kg kh hh lh b fi ll lm l ln lo">from behave import *<br/> <br/> @given(‘Given a test microservice’)<br/> def create_client(context):<br/> # Some test client setup goes here.<br/> pass<br/> <br/> @given(“umpires [‘Tinker’, ‘Evers’, ‘Chance’]”)<br/> def set_database(context):<br/> # Some database setup goes here.<br/> pass<br/> <br/> @when(‘request is “/umpires”’)<br/> def make_get_umpires_request(context):<br/> # The RESTful API request goes here.<br/> pass<br/> <br/> @then(“response body includes [‘Tinker’, ‘Evers’, ‘Chance’]”)<br/> def assert_response(context):<br/> # Check the response goes here.<br/> pass</span></pre><p id="b090" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里显示的代码有基于小黄瓜场景的占位符。pass语句必须替换为工作测试代码。我加入了一些注释来帮助说明需要编写什么样的代码。</p><p id="e8d1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，如果服务器是在<a class="ae kf" href="http://flask.pocoo.org/," rel="noopener ugc nofollow" target="_blank">http://flask.pocoo.org/,</a>中实现的，那么create_client()函数将需要构建应用程序并为应用程序创建一个Flask测试客户端。</p><p id="9cac" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">运行测试时，behavior将使用特征文件和步骤规范来执行测试并确认结果。输出将包括一个日志以及一个JSON文档，其中包含官方结果，以显示软件的行为是可以接受的。</p><blockquote class="me"><p id="0c53" class="mf mg hh bd mh mi mj mk ml mm mn kd dx translated"><em class="mo">运行Behave或pytest-bdd创建的JSON输出是正式裁判发出的“安全”或“出界”信号的体现。这就是导致粉丝爆发出喜悦或悲伤的原因。</em></p></blockquote><p id="6293" class="pw-post-body-paragraph ji jj hh jk b jl mp ii jn jo mq il jq jr mr jt ju jv ms jx jy jz mt kb kc kd ha bi translated">小黄瓜经常被吹捧为让非技术人员投入软件正确行为的好方法。小黄瓜的潜在成本是用另一种语言工作的额外复杂性。正如我们上面提到的，我们用三种不同的语言表达共同的想法。</p><ul class=""><li id="12c7" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">OpenAPI规范——虽然API描述的语法可能是YAML或JSON，但它是一种形式化行为的声明性语言。</li><li id="c304" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">小黄瓜——行为的另一种形式化。它没有OpenAPI规范严格。</li><li id="7690" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">代码——这仍然是期望行为的另一种形式化。对我来说，这是用Python写的。当然，它可以涉及其他语言，如HTML、CSS、SQL、Jinja模板语言等。</li></ul><h2 id="6fd6" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">开发过程</h2><p id="65bd" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">一旦我们让</em> </strong>将我们的API描述写成OpenAPI规范，<strong class="jk hi"> <em class="ke">我们就可以开始编码了。</em> </strong></p><p id="c091" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦我们有了小黄瓜特性定义，我们就可以开始测试了。T11】</p><p id="03c3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦我们有了棒球和球棒，我们就可以打球了。T15】</p><p id="02e4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大部分工作是编写和重构代码，直到测试通过，代码看起来足够好可以发布。理想情况下，我们使用Behave(或pytest-bdd)来确认软件工作。配置存储库很方便，这样每次提交都会正常运行，并确认代码有效。在某些情况下，使用Git pull请求来触发运行Behave可能更简单。这确认了要合并的代码将满足其所需的行为。</p><p id="4e83" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们看到从规范到小黄瓜到代码的过程时，缩小超级灵活的小黄瓜描述的范围是很有帮助的，这样它们就能准确地匹配API描述。</p><p id="43c7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是我的偏好。</p><ol class=""><li id="a822" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd mu lw lx ly bi translated">将API描述写入OpenAPI规范。我喜欢从这里开始，因为它有助于我专注于RESTful API的限制和约束。</li><li id="c552" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd mu lw lx ly bi translated">将API描述转换成小黄瓜。我将在下面概述一个工具。一般来说，这是一个困难的问题，但是您可以很容易地用Python开发一个支持必要的定制和调整的工具。</li><li id="afa4" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd mu lw lx ly bi translated">提供步骤定义，这样小黄瓜就可以用于运行测试。前几次，这涉及到一些学习。好的步骤定义可以足够通用，具有高度的可重用性。</li><li id="2620" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd mu lw lx ly bi translated">编写有效的代码。重构代码，直到它是好的。</li></ol><h2 id="a1c8" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">将开放API规范转换为小黄瓜</h2><p id="136f" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">从编写到OpenAPI规范的API描述转移到Gherkin是将OAS API描述(或简称为规范)细节重新组织成不同的符号。在转换过程中避免损失和混乱是很重要的。</p><p id="76e7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">OpenAPI规范的嵌套结构可以总结如下:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="6886" class="kg kh hh lh b fi ll lm l ln lo">path:<br/>    operation:<br/>       … (request details)<br/>       responses:<br/> code: … (response details)</span></pre><p id="a130" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个规范通常有许多路径。对于每个路径项，都有一个或多个操作。每个操作都有一个或多个响应。</p><p id="29f4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个小黄瓜文档——基于写在OpenAPI规范中的API描述——将有一个(或多个)特性描述。(标签可用于区分复杂应用程序的功能。)每个特性将包括多个场景。每个场景描述了对(路径、操作)组合的一种响应。</p><p id="ecae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">场景的小黄瓜模板可以是这样的:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="92c0" class="kg kh hh lh b fi ll lm l ln lo">scenario: {operation summary} leading to {response description}<br/> Given {context}<br/> And some context tied to the response<br/> When {operation} on {path}<br/> And some reason for the response<br/> Then validate expected {response}</span></pre><p id="c41c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的大多数{占位符}直接来自OAS描述。例外情况是“与回应相关的背景”和“回应的原因”。</p><p id="0510" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这些“一些上下文”和“一些原因”短语是细节的例子，这些细节在规范中是隐含的，而不是陈述的。发生这种情况是因为OpenAPI规范是特定于RESTful API的，并且所提供的例子关注于成功响应的“快乐之路”。401未授权或404未找到的任何“不愉快”响应通常会在响应的描述属性中进行总结。这就是为什么我认为导致不愉快反应的条件是隐含的。</p><p id="ec4b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个具体的例子。我们将使用OpenAPI规范为我们编写的API描述添加一个路径，以便为仲裁人获取详细信息。这意味着一个未知裁判的失误。</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="54ac" class="kg kh hh lh b fi ll lm l ln lo">/umpires/{umpire}:<br/>  get:<br/>    summary: An umpire<br/>    parameters:<br/>      — name: umpire<br/>        in: path<br/>        description: the umpire’s name<br/>        type: string<br/>        required: true<br/>    responses:<br/>      200:<br/>        description: An umpire’s details<br/>        schema:<br/>          type: object<br/>          properties:<br/>            name:<br/>              type: string<br/>              example: “Tinker”<br/>      404:<br/>        description: Unknown umpire</span></pre><p id="e7a6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这描述了当裁判未知时情况的响应状态代码404。理解RESTful API(和OpenAPI规范)的开发人员知道这意味着什么。当使用Gherkin步骤定义时，我们需要明确这一点，以确保我们能够区分这两种场景。</p><p id="b5ff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们有几种方法来揭示这种错误的原因的细节:</p><ul class=""><li id="07e6" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">尝试使用风格化的自然语言来扩展规范描述条目。添加错误的例子来定义这些额外的小黄瓜场景会使规范变得混乱。</li><li id="afc7" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">在规范中以“x-given”和“x-when”的形式添加扩展属性。扩展属性必须被不能使用它们的工具悄悄忽略，所以添加它们是安全的。</li></ul><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="e961" class="kg kh hh lh b fi ll lm l ln lo">404:<br/>  description: Unknown umpire<br/>  x-given: Umpires are [“Tinker”]<br/>  x-when: request is for “Evers”</span></pre><p id="f96b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这些扩展值提供了构建小黄瓜错误场景所需的具体示例。这个想法可以扩展到提供许多错误场景。</p><p id="9821" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然添加错误细节可以更容易地将编写到OpenAPI规范中的API描述转换为有意义的小黄瓜，但它们会使事情变得混乱。对快乐的路径使用OpenAPI规范似乎更好，并且只用小黄瓜描述不快乐的路径。</p><p id="6dc6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">技术黄瓜</p><p id="8601" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要完成从规范到小黄瓜再到代码的重要传递，还需要一个更重要的主题。我们必须稍微改变我们的关注点。小黄瓜——当被企业主使用时——就像棒球击球手挥棒击球。<em class="ke">这是战略性的一击:这将是一个全垒打。</em></p><p id="4735" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">小黄瓜可以缩小到有一个技术重点。这里有一个例子。</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="1b47" class="kg kh hh lh b fi ll lm l ln lo">Scenario: Get list of Umpires<br/>Given a test app and client<br/> And a valid Authorization token is ‘dizzy’<br/> And a test database<br/> And umpire names of [“Tinker”, “Evers”, “Chance”]<br/>When headers include {“x-Auth-Token”: “dizzy”, “Accept”: “application/json”}<br/> And request operation is ‘Get’<br/> And request path is ‘/umpires’<br/>Then response status is 200<br/> And response body is {“status”: “OK”, “data”: [“Tinker”, “Evers”,     “Chance”]}</span></pre><p id="5733" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">小黄瓜场景的一般形状具有给定的时间结构。然而，细节已经从产品所有者的抽象观点变成了描述RESTful API实现的具体技术细节。</p><p id="2a0d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这些步骤已经使用一些样板文本“headers include ”(后跟参数值)进行了参数化。其思想是基于行为工具解析步骤字符串的能力来创建步骤定义。一个通用的Python步骤实现可以处理各种参数值。</p><p id="d34c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以下是使用Behave符号的参数化步骤定义:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="89bd" class="kg kh hh lh b fi ll lm l ln lo">@when(‘Response status is {status:int}’)<br/>def check_status(context, status):<br/>    assert context[‘status’] == status</span></pre><p id="5d06" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个@when定义可以被所有从我们为OpenAPI规范编写的API描述中生成的小黄瓜场景重用。拥有一个可重用的步骤定义库意味着对规范的更改将会改变基于小黄瓜的处理。这对于执行变更后的测试场景有直接的好处。</p><p id="9518" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">小黄瓜脚本的OpenAPI规范</p><p id="5341" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然这看起来非常清楚和直接，但有许多复杂的因素。</p><ul class=""><li id="cd7e" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">命名。我们为OpenAPI规范编写的API描述允许对操作和每个响应进行总结和描述。如何使用这些字段的细节可能有所不同，每个组织将建立不同的命名约定。OpenAPI-to-Gherkin工具必须反映组织的命名约定。</li><li id="fd56" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">可选功能。操作的规范可以定义许多可选参数。描述文本可能包括一些关于参数含义和省略参数时的默认行为的指导。枚举场景可能很难自动化，可能需要手动干预来提供显示参数如何交互的详细测试用例。</li><li id="3063" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">当地标准。在每个OpenAPI API文档中，一个已建立的微服务家族可能会假定而不是定义一些标准特性。虽然可以将描述复制到每个OpenAPI API文档中，但是可能很难找出所有需要测试的以小黄瓜为中心的变体。在OpenAPI规范之外处理这些情况可能更好。</li><li id="4354" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">外部依赖性。当使用简单的微服务时，数据库的状态可以用x-given扩展来描述。试图通过简单的x-given扩展来描述具有多个复杂外部依赖的错误和问题可能会变得非常复杂。在这些情况下，一些手动创建的步骤定义可能比制定OAS扩展更容易。</li><li id="a120" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">不愉快的路径场景。与其用错误处理细节来混淆我们的API描述，不如用OpenAPI-to-Gherkin工具来注入错误处理场景。</li></ul><p id="f547" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个简单而通用的OpenAPI-to-Gherkin应用程序似乎是不必要的困难。大多数实际应用都涉及扩展和可选功能。相反，建立一个定制的两步转换管道似乎更好。</p><ol class=""><li id="5016" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd mu lw lx ly bi translated">中的<strong class="jk hi"> OpenAPI。这将从我们写给OpenAPI规范的API描述中构建场景定义。在获取源时，可以根据需要处理定制和扩展。</strong></li><li id="562a" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd mu lw lx ly bi translated"><strong class="jk hi">小黄瓜出来了。</strong>这将从场景定义中写入小黄瓜特征文件。这涉及到步骤定义和小黄瓜文本之间的特性的精心编排。定制和扩展可以在这里注入。</li></ol><p id="7105" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这两者之间是作为一系列场景的特性的内部表示。每个场景都是从OpenAPI文档中提取的值的集合，并重新组装到一个Python字典中，其关键字如下:</p><ul class=""><li id="2cbc" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated"><strong class="jk hi">路径- </strong>进入When步骤的路径。</li><li id="8d08" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><strong class="jk hi">操作- </strong>进入When步骤的操作。</li><li id="76e8" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><strong class="jk hi">请求- </strong>请求的细节和参数。其中一部分填充了场景名称。其中的一部分将填充When步骤，以发出请求。在有可选参数的情况下，每个组合可能导致一个单独的场景。注意这里的组合爆炸:a <em class="ke"> n </em>可选参数的幂集的大小是2 <em class="ke"> n </em>。</li><li id="569a" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><strong class="jk hi">状态- </strong>这是该场景的总体最终状态。</li><li id="3e0a" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><strong class="jk hi">响应- </strong>这是预期的响应示例文档。</li></ul><p id="3236" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个例子:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="de5b" class="kg kh hh lh b fi ll lm l ln lo">{‘path’: ‘/credentials’,<br/> ‘operation’: ‘post’,<br/> ‘request’: {<br/>     ‘parameters’: [<br/>         {‘in’: ‘body’,<br/>          ‘name’: ‘User Credentials’,<br/>          ‘schema’: {<br/>              ‘description’: ‘input’,<br/>              ‘properties’: {‘username’: {‘type’: ‘string’}}</span><span id="4c56" class="kg kh hh lh b fi lp lm l ln lo">          }<br/>         } <br/>        ],<br/>       ‘summary’: ‘Post new user credentials’,<br/>},<br/>‘status’: ‘200’,<br/>‘response’: {‘description’: ‘it worked’}}</span></pre><p id="8101" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">是的，你是对的，这个参数没有任何例子细节。这只是一个模式。填写这些细节是初始质量检查的一部分。如果一个简单的工具不能生成合适的小黄瓜测试，那么规范就需要扩展。</p><p id="e08b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">创建它的基本Python编程具有以下类型的顶级函数:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="327d" class="kg kh hh lh b fi ll lm l ln lo">def make_gherkin(oaspec: Dict, file: OptFile=sys.stdout):</span><span id="0790" class="kg kh hh lh b fi lp lm l ln lo">    common = get_common_features(oaspec)<br/>    emit_feature_header(oaspec, file)<br/>        for scenario in scenario_iter(oaspec):<br/>            emit_scenario(make_scenario(common, scenario), file)</span></pre><p id="b34c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">输出由两个函数创建。</p><ul class=""><li id="8353" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">emit_feature_header()在文件的顶部写入“feature:”部分。编写特性头的模板很简单。</li><li id="6aed" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">emit_scenario()为给定的场景编写小黄瓜步骤。这个也比较简单。这就是用“给定”、“何时”、“然后”和“和”这样的词来注释各个步骤的问题。</li></ul><p id="b857" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">数据收集由三个功能完成:</p><ul class=""><li id="743d" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">get_common_features()从OpenAPI文档中提取公共细节。这包括安全信息、MIME类型和安全定义。这将从OpenAPI文档中提取像basePath这样的字段。</li><li id="f0b5" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">make_scenario()从OpenAPI中提取细节，并将这些细节重新打包到各个小黄瓜步骤中。这是处理过程中最复杂的部分。</li><li id="4d72" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">scenario_iter()是一个生成器函数，它基于路径、操作和可选参数的各种组合生成一系列场景。</li></ul><p id="50c4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">scenario_iter()函数如下所示:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="e8ba" class="kg kh hh lh b fi ll lm l ln lo">def scenario_iter(oaspec: Dict) -&gt; Iterable[Dict]:<br/>  for path in oaspec[‘paths’]:<br/>    for operation in oaspec[‘paths’][path]:<br/>        request = oaspec[‘paths’][path][operation].copy()<br/>        # Optional: compute the powerset of the optional  parameters<br/>        responses = request.pop(‘responses’)<br/>        for response_status in responses:<br/>            response = responses[response_status].copy()<br/>            yield {<br/>                ‘path’: path,<br/>                ‘operation’: operation,<br/>                ‘request’: request,<br/>                ‘status’: response_status,<br/>                ‘response’: response}</span></pre><p id="87ec" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个函数遍历路径、操作和响应。它将每个独特的组合生成一个独特的场景。细节可以用来以小黄瓜符号的形式显示细节。</p><p id="1197" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个例子没有计算可选参数的幂集。itertools文档展示了如何使用chain.from_iterable()函数构建powerset()迭代器。当使用复杂的OpenAPI规范时，这可以为备选场景增加一个有用的复杂级别。</p><p id="2b58" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">make_scenario()函数是大部分转换发生的地方。这个函数的目标是发出一个遵循Gherkin场景整体结构的字典。这是我们编写的API描述的隐式细节被扩展成显式小黄瓜文本的地方。</p><p id="08d8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">make_scenario()的结尾将如下所示:</p><pre class="ix iy iz ja fd lg lh li lj aw lk bi"><span id="3a7c" class="kg kh hh lh b fi ll lm l ln lo">scenario = {<br/>    ‘scenario’: [summary, description],<br/>    ‘given’: [],<br/>    ‘when’: [],<br/>    ‘then’: []<br/>}<br/>scenario[‘given’].append(‘test app and client’)<br/>scenario[‘given’].extend( [f”{sec_key} security” for sec_key in security_keys] )<br/> <br/>if req_header:<br/>    req_header_json = json.dumps(req_header)<br/>    scenario[‘when’].append(f”headers are {req_header_json}”)<br/>if req_query:<br/>    req_query_json = json.dumps(req_query)<br/>    scenario[‘when’].append(f”query is {req_query_json}”)<br/>if req_body:<br/>    req_body_json = json.dumps(req_body)<br/>scenario[‘when’].append(f”body is {req_body_json}”)<br/>scenario[‘when’].append(f”request operation is {operation}”)<br/>scenario[‘when’].append(f”request path is {basePath}{path}”)<br/> <br/>scenario[‘then’].append(f”status is {status} {response[‘description’]}”)<br/>if set(response.keys()) &gt; {‘description’}:<br/>    response_json = json.dumps(example_response)<br/>    scenario[‘then’].append(f”response is {response_json}”)</span></pre><p id="ad12" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">三个小黄瓜步骤中的每一步都是一个子句列表。每个子句都是一个格式化的字符串，对人们来说有意义，对behavior或pytest-bdd的步骤匹配规则也有用。字符串的良好选择反映了技术细节和有意义的术语之间的平衡。</p><p id="6306" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">请注意，这些子句中的每一个都与阶梯夹具直接平行。例如，向when子句追加头是{…}"。“标题是”文本必须与步骤定义相匹配。我们可以使用像@ when(" header是{…} ")这样非常详细的东西。如果我们使用@when(parsers.re(r "头是(？P <header>。*)")，因此通用步骤定义可以在多个场景中重用。</header></p><p id="f8ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们已经完成了从规范到小黄瓜的第一个接力，我们准备好了下一个从规范到小黄瓜再到代码的接力。像Behave和pytest这样的工具是裁判，做出这出戏成功的最终决定。</p><h2 id="665f" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">规范到小黄瓜到代码</h2><p id="169b" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">我们通常称项目大纲为“推销”让我们不要把这个类比推得太远，但是防守团队——教练、投手和捕手正在整理球场。当它被打到内场时，有很多防守会出错，让跑垒员绕垒前进。</p><p id="26da" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">按照OpenAPI规范编写API描述是设计API的第一步。这种描述是基于音高的，它可以驱动API设计和实现<em class="ke">。</em></p><p id="9004" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然有许多针对编写到OpenAPI规范中的API描述的测试工具，但它们都有一个局限性:OpenAPI示例只涵盖了快乐路径，而没有指定所有“其他”路径。如果我们编写自己的工具来从扩展的OpenAPI规范中创建测试，我们可以很容易地包含非快乐路径的例子。</p><p id="88c4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">像behavior这样基于小黄瓜的工具产生正式的文档，显示一套验收测试全部通过。如果我们没有通过所有测试的正式通知，我们就在没有任何官员的情况下进行运动。很好玩，但是纠纷不可避免。公正地评价临近的比赛真的很有帮助。</p><p id="32e5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">将球从规范扔向小黄瓜再扔向代码，可以很容易地确保这个剧本被正确调用。</p><p id="b8a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">相关:</strong></p><ul class=""><li id="ffc7" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-developers/bashing-the-bash-replacing-shell-scripts-with-python-d8d201bc0989">痛击——用Python替换Shell脚本</a></li><li id="0728" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-developers/nosql-database-doesnt-mean-no-schema-a824d591034e"> NoSQL数据库并不意味着没有模式</a></li><li id="b201" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-developers/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792">自动化NoSQL数据库构建</a></li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es mv"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a></figure><p id="4e5c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>