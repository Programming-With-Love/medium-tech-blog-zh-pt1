<html>
<head>
<title>Useful tools: Headless Chrome &amp; puppeteer for browser automation &amp; testing.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的工具:用于浏览器自动化和测试的无头Chrome和木偶师。</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/useful-tools-headless-chrome-puppeteer-for-browser-automation-testing-1ac7707bad40?source=collection_archive---------1-----------------------#2018-10-11">https://medium.com/square-corner-blog/useful-tools-headless-chrome-puppeteer-for-browser-automation-testing-1ac7707bad40?source=collection_archive---------1-----------------------#2018-10-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="22de" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">了解一些新工具，这些工具可以使端到端测试更容易&amp;更准确，以及自动化您在web浏览器中可以做的任何事情！</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/54b03b3933c8c695ca12ac524dbc89b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uKfNbPMHQDYExSCL6oGUOQ.gif"/></div></div></figure><blockquote class="ji jj jk"><p id="9643" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ki" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="8b4c" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">网站变得比以往更加复杂。现代网站通常由多个组件文件组成，这些文件打包在一起，然后进行优化，而不是单一的html页面。当一个网站加载这些文件时，它会发出几十个不同的异步请求，以完成包含更多信息的页面，此外还会加载和运行所有的广告和分析脚本。我们希望所有这些不同的活动部件都能为我们的用户带来无缝的、令人愉快的新鲜出炉的体验，但情况并非总是如此。有时候，直到你完成烘焙，你才知道一种配料已经变质。端到端(E2E)测试工具旨在确保您在设置模板之前发现任何错误。如果你已经接受了从头到尾测试的需求，那么你需要了解无头浏览器。</p><h1 id="9fee" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated"><strong class="ak">无头镀铬</strong></h1><p id="b46c" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">最新最棒的端到端测试工具之一是Headless Chrome。在你开始考虑幽灵骑士之前，要知道Headless Chrome是你所知道的同一个网络浏览器，除了你可以关闭所有的UI，从命令行运行它，并做一些<em class="jn">spooooooooky</em>编程控制。</p><p id="2b46" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">关于Headless Chrome，你需要知道的第一件事是，你不是从你的桌面或dock启动它。相反，您将从命令行执行所有操作。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lj"><img src="../Images/25c534a8bc479689c622bb1d22c7fb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/1*GBu9TjWE81sShCZO6XCaRA.gif"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Running Headless Chrome from the command line.</figcaption></figure><p id="0dc0" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">首先，您需要为Chrome可执行文件创建一个别名，这样您就可以更容易地从命令行运行它。对我来说(在Mac上)，这看起来就像深入挖掘谷歌Chrome应用程序以找到其下面的可执行文件:</p><pre class="ix iy iz ja fd lo lp lq lr aw ls bi"><span id="12bc" class="lt kn hh lp b fi lu lv l lw lx">$ alias chrome="/Applications/Goo...Chrome"</span></pre><p id="c8c8" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我已经把它添加到我的<code class="du ly lz ma lp b">bash_profile</code>中，这样每当我打开一个新的终端窗口时，这个别名就会出现。在无头模式下运行Chrome就像一个命令行标志<code class="du ly lz ma lp b">--headless</code>一样简单。您需要提供的唯一其他参数是您想要访问的网站的URL。有了这两个标志，Headless Chrome将发出请求并得到响应，然后出色地完成任务并退出。乍一看，这似乎更像是一个更糟糕的<code class="du ly lz ma lp b">cURL</code>请求，但是有一些命令行标志可以让它更有用一些。</p><h2 id="92f9" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">远程调试</strong></h2><p id="1fe2" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">请求一个页面并退出并不令人兴奋，但是可以与<code class="du ly lz ma lp b">--headless</code>结合使用的一个简洁的命令行标志是<code class="du ly lz ma lp b">--remote-debugging-port</code>。这个标志打开了一个端口，用于通过<a class="ae ki" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>控制Chrome实例并与之交互。你需要指定一个端口号(比如<code class="du ly lz ma lp b">--remote-debugging-port=9222</code>，你甚至可以在Chrome中尝试远程调试。只需打开一个新的(非无头)标签，并前往<code class="du ly lz ma lp b">localhost:9222</code>。你将能够看到所有运行的Chrome实例，浏览渲染过的网站，使用它们的javascript控制台，甚至点击、键入或以其他方式与页面交互(尽管如果你想浏览网页，使用DevTools从另一个Chrome浏览器控制一个无头Chrome实例可能不是最好的方法😄).当您开始运行完全无头的复杂操作，然后需要一种方法来查看发生了什么时，这个标志将非常有用。</p><h2 id="21fe" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">截图&amp;pdf</strong></h2><p id="e186" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">命令行Headless Chrome的一个真正有用且易于使用的功能是截图或创建网站的pdf文件。这两个标志的工作方式类似，但会产生非常不同的结果。标志<code class="du ly lz ma lp b">--print-to-pdf=site.pdf</code>将具有与浏览打印对话框并保存为pdf名称<code class="du ly lz ma lp b">site.pdf</code>相同的效果。因为它使用了打印对话框，所以它创建了打印媒体css的pdf，这取决于你的站点期望打印多少，可能有点不可靠。通常你更喜欢截图而不是pdf，而且还有一个标志！<code class="du ly lz ma lp b">--screenshot=file.png</code>将提取渲染的像素并保存到一个名为<code class="du ly lz ma lp b">file.png</code>的图像文件中。将它与其他标志如<code class="du ly lz ma lp b">--window-size=1200,1600</code>结合起来，你可以创建大量不同尺寸的网站截图，以查看你的页面在任何你想要的设备上的外观。</p><p id="a7d3" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">仅仅从命令行使用Headless Chrome有着巨大的价值:很容易对从分支代码构建的网站进行截屏，以自动包含到拉取请求中，或者对本地环境进行截屏，并使用类似<code class="du ly lz ma lp b"><a class="ae ki" href="https://github.com/mapbox/pixelmatch" rel="noopener ugc nofollow" target="_blank">pixelmatch</a></code>的图像区分工具将它们与生产站点的实时图像进行比较。</p><p id="7a5a" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">但是，如果您尝试对网页进行一些更复杂的测试或交互，这些命令行标志不会对您有所帮助。为此，我们需要更强大的东西。</p><h2 id="b867" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated">操纵木偶的人</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mo"><img src="../Images/78751027f722b4a713bfe79a784d9bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*kk8ovQKB-45FsZ8TZM-vjg.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Puppeteer is ©Google and licensed under Apache 2.0</figcaption></figure><p id="44c6" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">Puppeteer是一个基于NodeJS的库，它使用相同的Headless Chrome和DevTools协议与Headless Chrome进行交互，但是在JavaScript中具有更强大和可扩展的接口。从NPM安装<code class="du ly lz ma lp b">puppeteer</code>之后，它通常看起来是这样的:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="17dd" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">你可能会注意到我们大量使用了<code class="du ly lz ma lp b">async</code>和<code class="du ly lz ma lp b">await</code>。如果你不熟悉async/await，一定要花点时间阅读一下 <code class="du ly lz ma lp b"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">async</a></code> <a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> &amp; </a> <code class="du ly lz ma lp b"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">await</a></code>的<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">文档。通过上面的代码，我们创建了一个新的Chrome浏览器，加载了一个新页面，然后在页面转到一个网站时运行几个异步函数，执行一个操作，最后关闭浏览器。Puppeteer中几乎所有与网站交互的东西都是异步的，当你想以可预测的线性方式使用网站时，这不是很好。我们将对大多数命令使用<code class="du ly lz ma lp b">await</code>来保持执行流程更加同步，而不是无休止地<code class="du ly lz ma lp b">then</code>调用或使用回调。让我们更深入地了解一下你可以用NodeJS和Puppeteer进行交互的一些方式:</a></p><h2 id="a1a3" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">浏览器</strong></h2><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="62e6" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">浏览器是你首先要创建的对象之一，当你启动浏览器时，你有很多选择。我使用的最常见的配置选项之一是<code class="du ly lz ma lp b">headless</code>，它是一个布尔值，让你可以通过UI运行Chrome，这样你就可以看到你的木偶脚本在做什么。<code class="du ly lz ma lp b">slowMo</code>也非常有用，因为它将为几乎所有的事情增加一个人为的毫秒数延迟。这可以使人类看不到的事件变得更加明显，并且可以在与具有许多异步添加的事件处理程序的网页交互时帮助润滑轮子。</p><p id="d17e" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">就你可以用浏览器做什么而言，你最常做的事情是创建一个<code class="du ly lz ma lp b">newPage</code>，但是你也可以创建新的匿名标签，以及对关闭页面、检查浏览器版本和用户代理的基本控制。你可以在布偶师<a class="ae ki" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-browser" rel="noopener ugc nofollow" target="_blank"> GitHub文档</a>上阅读更多关于<code class="du ly lz ma lp b">browser</code>对象的信息。</p><h2 id="b5a3" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">页面</strong></h2><p id="af48" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">Headless Chrome的页面对象类似于你可能习惯的Chrome版本中的标签。page对象有很多功能和函数来控制网站如何被请求、加载和使用。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="776f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">您通常只是创建新页面并与内容进行交互，但是页面对象也是您可以更改一些有用设置的地方。通过<code class="du ly lz ma lp b">setViewport</code>、<code class="du ly lz ma lp b">setUserAgent</code>、&amp;、<code class="du ly lz ma lp b">emulate</code>，你可以像移动设备或平板电脑一样加载网页，让你知道(并测试)你的网站<em class="jn">如何响应</em>响应环境。</p><p id="bfa7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">还有大量的事件处理程序可以用于页面。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="6c8a" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">您可以创建在页面输出到其javascript控制台时运行的函数，或者当它创建对图像和其他资源的附加请求时运行的函数，以及当这些请求的响应返回时运行的函数。</p><h2 id="ee07" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">鼠标</strong></h2><p id="064e" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">与内容交互相比，加载网站并不那么有用，鼠标是一个很好的方式。木偶戏给了你一个有用的功能，<code class="du ly lz ma lp b">page.click()</code>，它允许你在指定的选择器上创建一个点击，并可以选择指定点击的类型和你按住按钮的时间。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="42c4" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">您还可以使用<code class="du ly lz ma lp b">page.mouse()</code>对鼠标进行更精细的控制，这是一个让您可以控制移动鼠标的对象，并打开更复杂的序列，如拖动。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="d921" class="lt kn hh bd ko mb mc md ks me mf mg kw kj mh mi ky kk mj mk la kl ml mm lc mn bi translated"><strong class="ak">键盘</strong></h2><p id="8af6" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">键盘是另一个很好的交互来源，就像鼠标一样，puppeteer为您提供了一个助手功能，让您选择选择器和您想要键入的内容，以及用于精确按键控制的低级命令，选择单个键，并决定它们被按住的时间。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="db6e" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">实践中的无头浏览器</h1><p id="4dea" class="pw-post-body-paragraph jl jm hh jo b jp le ii jr js lf il ju kj lg jx jy kk lh kb kc kl li kf kg kh ha bi translated">Headless Chrome和Puppeteer提供的所有不同的工具可以组合在一起，创造出测试和网站自动化的交响乐。最简单的用例之一可能是创建一个测试，寻找站点的本地分支和产品版本之间的视觉差异。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="f32f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这个脚本使用Headless Chrome的命令行标志来创建您的本地代码截图(<code class="du ly lz ma lp b">localhost:8080</code>)，并使用<a class="ae ki" href="https://github.com/mapbox/pixelmatch" rel="noopener ugc nofollow" target="_blank"> pixelmatch </a>(一个图像区分工具)将其与您的生产站点截图(<code class="du ly lz ma lp b">example.com</code>)进行比较。</p><p id="f64e" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们也可以用木偶师做同样的例子，做一些更复杂的互动。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="8529" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">使用这段代码，我们可以加载一个页面，等待特定的选择器出现在页面上，然后使用NodeJS库的完整生态系统来处理和操作结果图像。</p><p id="2066" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">还可以运行跨多个页面和交互的非常复杂的网站交互。下面是一个注册页面的端到端测试示例:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="f3de" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">进入页面后，鼠标事件用于点击按钮，导航到一个新页面，然后在页面上的iframe中键入内容以填写注册细节。需要注意的一点是这一节:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="1d72" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">当使用点击事件在页面间导航时，这实际上是一个最佳实践。<code class="du ly lz ma lp b">page.click()</code>返回一个承诺，但是当点击事件完成时，这个承诺就失效了。这并没有足够的时间来看到下一页的导语，如果你只是像往常一样做<code class="du ly lz ma lp b">await</code>，那么你的下一行代码很可能会失望。幸运的是，有<code class="du ly lz ma lp b">page.waitForNavigation()</code>返回一个承诺，直到浏览器导航到一个新的页面才会解决。通过将它们都包装在一个<code class="du ly lz ma lp b">Promise.all()</code>中，你可以确保在链接被点击<em class="jn">和</em>到下一页之前不会继续执行。</p><p id="a420" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这种复杂的页面交互是Headless Chrome在端到端测试和网站自动化方面的超级能力。这篇文章仅仅向你展示了使用Headless Chrome可以改进你的测试工作流程的冰山一角。如果您想更深入地了解这些工具，请查看以下资源:</p><ul class=""><li id="058f" class="mr ms hh jo b jp jq js jt kj mt kk mu kl mv kh mw mx my mz bi translated"><a class="ae ki" href="https://developers.google.com/web/updates/2017/04/headless-chrome" rel="noopener ugc nofollow" target="_blank">无头Chrome入门</a> &amp; <a class="ae ki" href="https://developers.google.com/web/updates/2017/06/headless-karma-mocha-chai" rel="noopener ugc nofollow" target="_blank">无头Chrome自动化测试</a>均由<a class="na nb ge" href="https://medium.com/u/443b43fab64?source=post_page-----1ac7707bad40--------------------------------" rel="noopener" target="_blank"> Eric Bidelman </a>在Google web developers网站上发布</li><li id="28d4" class="mr ms hh jo b jp nc js nd kj ne kk nf kl ng kh mw mx my mz bi translated"><a class="ae ki" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">Google chrome/puppeter</a>和GitHub 上的<a class="ae ki" href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" rel="noopener ugc nofollow" target="_blank">puppeter API文档——阅读所有方法的绝佳资源。</a></li><li id="4036" class="mr ms hh jo b jp nc js nd kj ne kk nf kl ng kh mw mx my mz bi translated"><a class="ae ki" href="https://github.com/GoogleChrome/lighthouse/blob/master/docs/readme.md#using-programmatically" rel="noopener ugc nofollow" target="_blank">Chrome/light house</a>——以Chrome扩展、NodeJS包和CLI工具的形式提供，这是一种快速测试网站重要领域的好方法，包括可访问性、速度&amp; SEO。</li></ul><p id="7422" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">希望你喜欢这篇文章，看看你可以用无头浏览器做些什么。如果您想了解我们的最新内容，请务必关注这个<a class="ae ki" href="https://medium.com/square-corner-blog" rel="noopener">博客</a> &amp;我们的<a class="ae ki" href="https://twitter.com/SquareDev" rel="noopener ugc nofollow" target="_blank"> Twitter </a>账户，并注册我们的<a class="ae ki" href="https://www.workwithsquare.com/developer-newsletter.html?channel=Online%20Social&amp;sqmethod=Blog" rel="noopener ugc nofollow" target="_blank">开发者简讯</a>！</p></div></div>    
</body>
</html>