<html>
<head>
<title>Re-animation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新制作动画</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/re-animation-7869722af206?source=collection_archive---------4-----------------------#2017-06-09">https://medium.com/androiddevelopers/re-animation-7869722af206?source=collection_archive---------4-----------------------#2017-06-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="468d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一篇文章中，我描述了一种在Android上创建矢量动画的技术:</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/google-developers/animation-jump-through-861f4f5b3de4"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">动画:跳转</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">最近，一个求助的电话引起了我的注意；询问如何在Android上实现一个奇特的“获取位置”动画:</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><p id="7e4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在撰写本文时，这种技术的一部分(路径变形)只在Lollipop和更新版本的操作系统上受支持。然而，Android支持库的版本25.4 将这一功能一直支持到冰激凌三明治(即令人印象深刻的<a class="ae jv" href="https://developer.android.com/about/dashboards/index.html#Platform" rel="noopener ugc nofollow" target="_blank"> 99%的设备</a>)。查看这个Google I/O会话，它涵盖了支持库中的这一变化和其他令人惊叹的变化:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="7795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想通过更新我的示例来尝试这些新功能，以便在旧设备上工作，并分享我的发现。</p><h2 id="83a9" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">14是新的21</h2><p id="aafd" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">第一步就是把我的<code class="du ld le lf lg b">minSdkVersion</code>从21岁改成14岁。打开完全相同的<code class="du ld le lf lg b">AnimatedVectorDrawable,</code>Lint工具指出了几个错误。具体来说，我使用了一些标准的材质插值器，这些插值器只在API 21中引入，所以不会在旧平台上使用。由于支持库也支持<code class="du ld le lf lg b">PathInterpolators</code>,我简单地将它们的实现从平台复制到我的项目中，并引用它们。</p><p id="f00b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还将我的<code class="du ld le lf lg b">build.gradle</code>文件中的<code class="du ld le lf lg b">vectorDrawables.useSupportLibrary = true</code>设置为<a class="ae jv" rel="noopener" href="/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88">告诉构建工具链</a>不要剥离旧设备上的矢量资源。</p><h2 id="8bc1" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">建设中</h2><p id="d5f9" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">要播放动画，您需要在代码中获得对它的引用并调用<code class="du ld le lf lg b">start()</code>。有多种方法可以实际创建动画drawable:</p><ol class=""><li id="d8c2" class="lh li hh ig b ih ii il im ip lj it lk ix ll jb lm ln lo lp bi translated">在你的布局(<code class="du ld le lf lg b">app:srcCompat="@drawable/avd_foo"</code>)中引用它，然后从<code class="du ld le lf lg b">ImageView</code>中检索drawable。</li><li id="b24d" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">使用<code class="du ld le lf lg b"><a class="ae jv" href="https://developer.android.com/reference/android/support/v7/content/res/AppCompatResources.html#getDrawable(android.content.Context, int)" rel="noopener ugc nofollow" target="_blank">AppCompatResources#getDrawable</a></code></li><li id="68b9" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">使用<code class="du ld le lf lg b"><a class="ae jv" href="https://developer.android.com/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html#create(android.content.Context, int)" rel="noopener ugc nofollow" target="_blank">AnimatedVectorDrawableCompat#create</a></code></li></ol><p id="547b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我发现方法1 &amp; 2可以返回不同的具体类；一个<code class="du ld le lf lg b">AnimatedVectorDrawable</code>或者一个<code class="du ld le lf lg b">AnimatedVectorDrawable<strong class="ig hi">Compat</strong></code>,这取决于你使用哪种API。</p><blockquote class="lv lw lx"><p id="5a46" class="ie if ly ig b ih ii ij ik il im in io lz iq ir is ma iu iv iw mb iy iz ja jb ha bi translated">有趣的是，支持库<a class="ae jv" href="https://android.googlesource.com/platform/frameworks/support/+/master/v7/appcompat/src/android/support/v7/widget/AppCompatDrawableManager.java#92" rel="noopener ugc nofollow" target="_blank">目前使用API 24+上的本地版本</a>和之前的compat版本，尽管该类是在API 21中引入的。这使它能够为API 21–23提供错误修复。</p></blockquote><p id="c365" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果/当你需要铸造<code class="du ld le lf lg b">drawable</code>的时候，这可能会有问题。</p><blockquote class="lv lw lx"><p id="ea77" class="ie if ly ig b ih ii ij ik il im in io lz iq ir is ma iu iv iw mb iy iz ja jb ha bi translated">注意，两个类都实现了<code class="du ld le lf lg b"><a class="ae jv" href="https://developer.android.com/reference/android/graphics/drawable/Animatable.html" rel="noopener ugc nofollow" target="_blank">Animatable</a></code>，所以如果你需要的只是启动/停止它，那么你就可以安全地抛弃它了。此外，<code class="du ld le lf lg b">AnimatedVectorDrawableCompat</code>提供了一个方便的静态方法来<a class="ae jv" href="https://developer.android.com/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html#registerAnimationCallback(android.graphics.drawable.Drawable, android.support.graphics.drawable.Animatable2Compat.AnimationCallback)" rel="noopener ugc nofollow" target="_blank">注册回调</a>，它将检查我们正在处理的类型，并适当地委托回调。</p></blockquote><p id="5c6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，我选择了3号门；总是使用compat类。这可能会增加一点点开销(因为在较新的平台上<code class="du ld le lf lg b">AVDC</code>只是将所有事情委托给本地类),但这使我的消费代码更简单。</p><h2 id="4fec" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">给我回电话</h2><p id="6dba" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我发现的一个小问题是我用来制作动画循环的技术。不幸的是<code class="du ld le lf lg b">AnimatorSet</code>不支持重复，所以我添加了一个<code class="du ld le lf lg b">AnimationCallback</code>来监听动画的结尾并再次调用<code class="du ld le lf lg b">start</code>来解决这个问题。这在老的平台上不起作用，但是我可以通过在一个处理程序上发布<code class="du ld le lf lg b">start</code>调用来解决这个问题，这个调用将在结束回调之后执行:</p><pre class="jw jx jy jz fd mc lg md me aw mf bi"><span id="b44f" class="kd ke hh lg b fi mg mh l mi mj">avd?.registerAnimationCallback(<br/>        object : Animatable2Compat.AnimationCallback() {<br/>    override fun onAnimationEnd(drawable: Drawable?) {<br/>        imageView.<strong class="lg hi">post</strong> {<strong class="lg hi"> </strong>avd.start() }<br/>    }<br/>})</span></pre><h2 id="a9dd" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">陈旧状态</h2><p id="4a2f" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">动画的某些部分只在循环中的某些点上运行；例如，当这些点进入/退出场景时，它们会淡入/淡出。在旧设备上，我发现它们的“状态”在每次循环中都没有被重置(重置为在<code class="du ld le lf lg b">VectorDrawable</code>中定义的状态)。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mk"><img src="../Images/25aa66e535d994ad55edcb36dc0f1e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*SYFNYDLLY8Y0Jcs_tGl1WA.gif"/></div></figure><p id="4671" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意当灰点从右边进入时是如何(不正确地)可见的，然后短暂消失，<em class="ly">然后</em>淡入。为了解决这个问题，我添加了一个零长度动画，以便在每个循环开始时将属性设置为它们的期望值，这样它们就可以进行动画制作了，例如:</p><pre class="jw jx jy jz fd mc lg md me aw mf bi"><span id="7bd8" class="kd ke hh lg b fi mg mh l mi mj">&lt;!-- Fade dot 5 in as it enters the scene --&gt;<br/>&lt;set&gt;<br/>    &lt;objectAnimator<br/>        android:propertyName="fillAlpha"<br/>        android:valueFrom="0"<br/>        android:<strong class="lg hi">valueTo="0"</strong><br/>        android:<strong class="lg hi">duration="0"</strong> /&gt;<br/>    &lt;objectAnimator<br/>        android:propertyName="fillAlpha"<br/>        android:valueFrom="0"<br/>        android:valueTo="1"<br/>        android:startOffset="1900"<br/>        android:duration="60"<br/>        android:interpolator="@android:interpolator/linear" /&gt;<br/>&lt;/set&gt;</span></pre><h2 id="43b6" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">排成一队</h2><p id="e226" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我遇到的最后一个问题是<em class="ly">顺序</em>有序<code class="du ld le lf lg b">AnimatorSet</code>的问题。主要的引脚跳转动画是一系列路径变形动画，从一个关键帧到另一个关键帧。我的动画假设这个序列将运行所有单个动画师的持续时间总和。然而，在旧平台上，一个错误导致每个动画师在开始之前等待下一帧边界。这些小的延迟加在一起，使得动画花费的时间<em class="ly">比持续时间的总和还要长</em>，因此作品的其他部分会被错误地定时。我可以通过切换到<code class="du ld le lf lg b">ordering="together"</code>来解决这个问题，并在每个单独的动画师身上使用<code class="du ld le lf lg b">startOffset</code>在正确的时间启动他们。</p><h2 id="ad7d" class="kd ke hh bd kf kg kh ki kj kk kl km kn ip ko kp kq it kr ks kt ix ku kv kw kx bi translated">令人印象深刻的平庸</h2><p id="17b1" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">最终的结果是非常令人印象深刻的。也就是说，动画看起来和以前完全一样，但是现在可以在更多的设备上运行。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mm"><img src="../Images/411bc045dada9e3c1160929047082da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/1*S4m8qfUcavdD3qUBMgC1Jg.gif"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">Animation running on API 16. #holoyolo.</figcaption></figure><p id="30d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管我确实遇到了一些在旧设备上运行的问题，但这些问题都很容易解决，我认为在如此多的API级别上运行的能力使得努力<em class="ly">非常</em>值得。</p><p id="5c3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我对许多工作感到满意，包括允许你在一个文件中指定<code class="du ld le lf lg b">VectorDrawable</code>和动画的XML bundle格式。Lint工具也有助于指出一些问题。你可以在Github 上找到我的后向移植动画<a class="ae jv" href="https://gist.github.com/nickbutcher/b1806905c6bc0ef29f545fd580935bd3" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="395b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您因为缺乏API支持而推迟向您的应用程序添加精彩的动画，那么就不要再推迟了。如果你正在研究路径变形动画，那么一定要看看<a class="mr ms ge" href="https://medium.com/u/f61fb1c467cd?source=post_page-----7869722af206--------------------------------" rel="noopener" target="_blank">亚历克斯·洛克伍德</a>的神奇的<a class="ae jv" href="https://shapeshifter.design/" rel="noopener ugc nofollow" target="_blank">变形器</a>工具，它将帮助你创建可变形的形状。如果这启发了你去创造一些东西，那么<a class="ae jv" href="http://twitter.com/crafty" rel="noopener ugc nofollow" target="_blank">让我知道</a>！</p></div></div>    
</body>
</html>