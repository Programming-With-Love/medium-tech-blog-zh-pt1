<html>
<head>
<title>Thinking functionally in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的功能思维</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/thinking-functionally-in-kotlin-1928c9995643?source=collection_archive---------0-----------------------#2021-09-09">https://blog.kotlin-academy.com/thinking-functionally-in-kotlin-1928c9995643?source=collection_archive---------0-----------------------#2021-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/272d4b9723131ffe1ee8cd9eb24eb05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAo0Xa06viJVPYhDzPP7tA.png"/></div></div></figure><p id="e14c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于大多数应用程序开发人员来说，函数式编程很难理解。固执己见的框架告诉程序员如何构建应用程序，减少了实验的欲望。我经常听到人们说构建应用程序的正确方法是“这个”。推动变革的修补性质被抛在了后面。</p><p id="dbf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">移动应用程序开发人员就属于这种情况。iOS和Android SDK是以某种方式构建的。开发人员通常认为这是构建应用程序的唯一方法。在本文中，我们将与科特林一起工作。任何使用Java的地方都可以使用Kotlin。随着Android团队采用Kotlin，许多Android开发人员使用它构建应用程序。这导致了用Kotlin进行Java编程的方式。</p><h1 id="85bb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">函数式编程</h1><p id="d54a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">简而言之，函数式编程就是将参数应用于函数。函数是程序的基本构件。每个都接受参数并返回一个值。函数被组合在一起以构建程序。没有共享状态，因为给定一个输入，每个函数产生相同的输出。</p><p id="8b17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Android开发人员认为使用类作为构建块来构建应用程序。类维护状态，函数操纵和使用状态。这会产生副作用，导致不可预测的输出。加上线程，你就有了一个灾难的配方。</p><p id="cb83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Android应用程序需要在系统的边界内工作。这需要国家。Kotlin支持面向对象(OO)和函数式(FP)风格。Android开发者应该利用这一点。Android应用程序中不涉及使用系统类的部分应该以功能性的方式构建。用Kotlin写得好的函数式程序是模块化的、可测试的和可预测的。</p><h1 id="a819" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">科特林的功能思维</h1><p id="b176" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">功能性思维很难。它要求开发者将程序分解成小功能。然后组合这些函数来解决手头的问题。</p><p id="a9a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解释这一点的最好方法是使用海军水面武器中心(NSWC)1993年的问题声明。美国高级研究计划局(ARPA)与NSWC合作进行了这项实验。给出了一个问题陈述，并要求参与者提交不同语言的原型。这个问题，一个几何区域服务器是一个更大的系统——宙斯盾武器系统(AWS)的组成部分。</p><h1 id="651c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题陈述</h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/4376f67e86c469826b411494394cecea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q9LR_r3cu1iGOw5a.png"/></div></div></figure><p id="ca2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题陈述最好用上图描述(想想战舰)。</p><ul class=""><li id="9b43" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">三角形:这些代表友好的船只。</li><li id="2097" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">最小距离</strong>:超过这个距离射击不会造成自残。</li><li id="7253" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">射程</strong>:目标在射程内的距离。</li></ul><p id="7d2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题归结为计算出一个点是否在射击范围内，并且不靠近友军船只。</p><h1 id="1373" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">必要的解决方案</h1><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="5954" class="mu ku in mq b gy mv mw l mx my">data class Point (val xPosition: Double, val yPosition: Double)  // 1</span><span id="404e" class="mu ku in mq b gy mz mw l mx my">typealias Position = Point  // 2</span><span id="e640" class="mu ku in mq b gy mz mw l mx my">class Ship (val position: Position, val minDistance: Double, val range: Double) {  // 3<br/>    <br/>    fun inRange(target: Position, friendly: Position):Boolean { // 4<br/>        return false<br/>    }<br/>}</span></pre><ol class=""><li id="04a3" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks na mh mi mj bi translated">名为<code class="fe nb nc nd mq b">Point</code> <strong class="jx io"> </strong>的数据类，用于存储x和y坐标。</li><li id="81b3" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks na mh mi mj bi translated">可读性的一个<code class="fe nb nc nd mq b">typealias</code>。</li><li id="c580" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks na mh mi mj bi translated">代表战舰的类。</li><li id="35bc" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks na mh mi mj bi translated">确定<code class="fe nb nc nd mq b">Position</code>是否在射程内的功能。</li></ol><p id="8eb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们修改<code class="fe nb nc nd mq b">InRange</code> <strong class="jx io"> </strong>函数，以满足问题陈述中的条件。</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="98ee" class="mu ku in mq b gy mv mw l mx my">fun inRange(target: Position, friendly: Position):Boolean {<br/> val dx = position.xPosition - target.xPosition<br/> val dy = position.yPosition - target.yPosition<br/>        <br/> val friendlyDx = friendly.xPosition - target.xPosition<br/> val friendlyDy = friendly.yPosition - target.yPosition<br/>        <br/> val targetDistance = sqrt(dx * dx - dy * dy) // 1<br/> val friendlyDistance <br/>  = sqrt(friendlyDx * friendlyDx - friendlyDy * friendlyDy) //2<br/>            <br/> return targetDistance &lt; range <br/>   &amp;&amp; targetDistance &gt; minDistance <br/>      &amp;&amp; friendlyDistance &gt; minDistance //3<br/>}</span></pre><ol class=""><li id="d8e0" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks na mh mi mj bi translated"><code class="fe nb nc nd mq b">targetDistance</code>是船和目标之间的距离。</li><li id="8973" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks na mh mi mj bi translated"><code class="fe nb nc nd mq b">friendlyDistance</code> <strong class="jx io"> </strong>是友船与目标之间的距离。</li><li id="5699" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks na mh mi mj bi translated">这种情况检查目标是否在射程之内，并且没有靠近友方船只。</li></ol><p id="f09c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看上面的代码，随着更多条件的加入，复杂性也增加了。很难阅读、维护和测试。</p><h1 id="9a29" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">功能解决方案</h1><p id="9e03" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在它的核心，我们正在寻找一个<code class="fe nb nc nd mq b">Position</code>是否在射程之内。</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="3207" class="mu ku in mq b gy mv mw l mx my">typealias inRange = (Position) -&gt; Boolean</span></pre><p id="d1d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面是一个lambda，它获取一个位置并返回一个布尔值。这个lambda将是我们的基本构建模块。</p><p id="32cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设船在原点，让我们写一个函数来检查一个点是否在范围内。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/9f900945549898662539833b7b219858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fb3k2y9geMH4Cpjl.png"/></div></div></figure><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="cf94" class="mu ku in mq b gy mv mw l mx my">fun circle(radius: Double): inRange {<br/>    return { position -&gt;<br/>        sqrt(position.xPosition * position.xPosition <br/>             - position.yPosition * position.yPosition) <br/>         &lt; radius<br/>    }<br/>}</span></pre><p id="bc1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数将半径作为参数，并返回一个lambda。给定一个点，如果它在半径范围内，lambda将返回true/false。这个函数假设船总是在原点。要改变这一点，我们可以修改这个函数，或者创建另一个函数来完成转换。</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="9431" class="mu ku in mq b gy mv mw l mx my">fun shift(offset: Position, range: inRange): inRange {<br/>    return { position -&gt; <br/>     val dx = position.xPosition - offset.xPosition<br/>        val dy = position.yPosition - offset.yPosition<br/>        range(Position(dx, dy))<br/>    }<br/>}</span></pre><p id="6cb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是众所周知的变压器功能。它根据偏移量转换位置，并允许调用者对其应用任何<code class="fe nb nc nd mq b">InRange</code> <strong class="jx io"> </strong>函数。我们可以使用之前定义的<code class="fe nb nc nd mq b">circle</code>函数。这是函数式编程的基本构件之一。位于位置10，10且圆半径为20的船将被描述为:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="faad" class="mu ku in mq b gy mv mw l mx my">shift(Position(10, 10), circle(10))</span></pre><p id="5082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以定义更多的转换函数。以下是一些例子:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="54e6" class="mu ku in mq b gy mv mw l mx my">fun invert(circle: inRange): inRange {<br/>    // not in circle<br/>    return { position -&gt;<br/>        !circle(position)<br/>    }<br/>}</span><span id="1772" class="mu ku in mq b gy mz mw l mx my">fun intersection(circle1: inRange, circle2: inRange): inRange {<br/>    // in both circle1 and circle 2<br/>    return { position -&gt;<br/>        circle1(position) &amp;&amp; circle2(position)<br/>    }<br/>}</span><span id="676a" class="mu ku in mq b gy mz mw l mx my">fun union(circle1: inRange, circle2: inRange): inRange {<br/>    // either in circle1 or circle2<br/>    return { position -&gt;<br/>        circle1(position) || circle2(position)<br/>    }<br/>}</span><span id="266f" class="mu ku in mq b gy mz mw l mx my">fun difference(circle1: inRange, circle2: inRange): inRange {<br/> // points in the first but not in the second<br/> return { position -&gt;<br/>        intersection(circle1, invert(circle2))<br/>    }<br/>}</span></pre><p id="0dcf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到我们最初的问题陈述，我们现在可以构建如下所示的解决方案:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="a3c5" class="mu ku in mq b gy mv mw l mx my">fun inRange1(ownPosition: Position, <br/>             targetPosition: Position,<br/>             friendlyPosition: Position,<br/>             minDistance: Double,<br/>             range: Double):Bool {<br/>    val firingRange = difference(circle(minDistance), circle(range)) // 1<br/>    val shiftedFiringRange = shift(ownPosition, firingRange) // 2<br/>    val friendlyRange = shift(friendlyPosition, circle(minDistance)) // 3<br/>    <br/>    val safeFiringRange = difference(shifterFiringrange, friendlyRange) // 4<br/>    return safeFiringRange(targetPosition)<br/>}</span></pre><p id="40f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码计算了船的射击范围和友船的最小安全范围。然后，它会找到两者之间的差异区域，并检查该区域中的点。这是编写相同解决方案的更具声明性的方法。一种使用函数而不使用状态的方法。你可能会说第一种方法更容易理解，但是当你在构建android应用程序时开始使用这些原则，测试的好处超过了任何争论。</p><h1 id="a3f9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从这里去哪里？</h1><p id="0b70" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在本文中，我们提到了一些函数式编程的概念。我们采用问题陈述并在Kotlin中构建解决方案。</p><p id="c436" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅仅使用函数式编程来构建Android应用是不可能的。应用程序必须与系统中需要状态的不同组件进行交互。然而，应用程序中涉及业务逻辑的部分可以使用这些原则来构建。这允许您使用组合，避免副作用，并编写易于测试的代码。</p><p id="f0b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:这个问题陈述的原始解决方案是由<a class="ae ne" href="https://www.cse.iitk.ac.in/users/karkare/oldcourses/2010/cs653/Papers/hudak_haskell_sw_prototype.pdf" rel="noopener ugc nofollow" target="_blank"> Paul Hudak和Mark Jones </a>用Haskell编写的。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="77f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本博客最初发布于<a class="ae ne" href="https://wednesday.is/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">https://Wednesday . is</strong></a>了解更多关于周三工作的感受关注我们的insta gram<strong class="jx io"><em class="nm">|</em></strong><a class="ae ne" href="https://twitter.com/wednesdaysol" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nm">推特</em></strong></a><strong class="jx io"><em class="nm">|</em></strong><a class="ae ne" href="https://www.linkedin.com/company/wednesday-solutions/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nm">LinkedIn</em></strong></a></p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h1 id="eab5" class="kt ku in bd kv kw nn ky kz la no lc ld le np lg lh li nq lk ll lm nr lo lp lq bi translated">点击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="21b9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ne" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ne" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>关注我们Medium。</p><p id="6286" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae ne" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi ns"><img src="../Images/0f75035864c8777980691ea01b2909c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9G3D67yqAvCKwAlxLkvDQ.png"/></div></a></figure></div></div>    
</body>
</html>