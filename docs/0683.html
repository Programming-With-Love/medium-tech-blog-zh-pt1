<html>
<head>
<title>Convert YUV To RGB for CameraX ImageAnalysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将YUV转换为RGB用于CameraX图像分析</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/convert-yuv-to-rgb-for-camerax-imageanalysis-6c627f3a0292?source=collection_archive---------2-----------------------#2021-11-19">https://medium.com/androiddevelopers/convert-yuv-to-rgb-for-camerax-imageanalysis-6c627f3a0292?source=collection_archive---------2-----------------------#2021-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0692123aba710df1face488836c8b08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuOorbZgMbRvkSSGuDGccw.png"/></div></div></figure><div class=""/><p id="ee3c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CameraX 是一个Jetpack支持库，旨在帮助简化相机应用程序的开发。它支持图像捕获、预览和图像分析等不同用例，可以与<a class="ae jn" href="https://developers.google.com/ml-kit" rel="noopener ugc nofollow" target="_blank"> ML套件</a>或<a class="ae jn" href="https://www.tensorflow.org/lite" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite </a>无缝结合。这为创建文本识别、图像标记等应用程序，甚至使用您自己训练的TensorFlow Lite模型检测和识别对象提供了许多可能性。然而，CameraX和这些库之间的图像格式转换并不简单，有时非常耗时。在这篇博客中，我们将讨论我们最近为支持CameraX ImageAnalysis的YUV到RGB转换而构建的一个新功能，包括我们为什么要构建它以及如何只用少量代码来使用它。</p><h1 id="202f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">背景</strong></h1><p id="1aee" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">CameraX使用<a class="ae jn" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV420_888 </a>生成图像，每个通道具有8位亮度(Y)、色度(U，V)和填充(P)。YUV是一种通用而灵活的格式，它允许不同设备上的OEM变体，涵盖了许多图像分析用例。然而，许多应用程序仍然依赖于RGB格式。在我们的开发人员社区中，YUV到RGB的转换是最受欢迎的功能之一，因为RGB格式很受欢迎，易于使用，有时也是必需的，例如TensorFlow Lite模型)。我们先来看看YUV和RGB格式。</p><h1 id="982f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">YUV_420_888格式</h1><p id="c11a" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">YUV格式也可以称为“YCbCr”。它包括平面(如I420)、半平面(如NV21/NV12)和封装格式(如UYVY)。YUV_420_888是一种通用YCbCr格式，能够描述任何4:2:0色度二次采样平面或半平面缓冲器(但不是完全交错的)，每个颜色样本8位。Y平面保证不会与U/V平面交错(特别是，像素跨度始终为1)。U/V平面保证具有相同的行间距和像素间距。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kr"><img src="../Images/b8de0d6b326d033da11f45b786e878df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E4HVc2Bcr3IOKfQR"/></div></div></figure><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kr"><img src="../Images/ac3ea106f290f53c3ce22d8b320843d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ilWBSyFmQ77Jp58f"/></div></div></figure><h1 id="e5e0" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">RGBA_8888格式</h1><p id="4b64" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/RGBA_color_model" rel="noopener ugc nofollow" target="_blank"> RGBA_8888 </a>是标准的RGB格式，有红色、绿色、蓝色和alpha通道，每个通道有8位。转换的主要目标是RGB色彩空间。RGB更简单，变化更少。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kr"><img src="../Images/514013841167d81729fbcc521e269322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b30u8Rdwn1zDq43q"/></div></div></figure><h1 id="481f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> API实现</strong></h1><p id="99bb" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们已经评估了3种YUV到RGB转换的方法</p><ol class=""><li id="150a" class="kw kx hs ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">Java/Kotlin</li><li id="b5ee" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">渲染脚本</li><li id="1189" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">本机(C/C++和NDK)</li></ol><p id="952d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">图像处理的Java/Kotlin实现伴随着长的计算时间和垃圾收集压力。Renderscript 是计算密集型任务的候选，例如YUV到RGB。不过从Android 12开始就已经<a class="ae jn" href="https://developer.android.com/guide/topics/renderscript/migrate#scripts" rel="noopener ugc nofollow" target="_blank">弃用</a>了。</p><p id="0162" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑到未来的可扩展性和兼容性，我们决定使用原生方式(libyuv + NDK)。<a class="ae jn" href="https://chromium.googlesource.com/libyuv/libyuv/" rel="noopener ugc nofollow" target="_blank"> Libyuv </a>是一个开源项目，包括yuv缩放、转换和旋转功能。考虑到所有因素，CameraX色彩转换管道可以在较高层次上进行查看，如下所示:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/32a8e5a5617a29d8be876d24f32419ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tAzCwvQdkhcPEXJu"/></div></div></figure><p id="207c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的管道仍然产生<a class="ae jn" href="https://developer.android.com/reference/androidx/camera/core/ImageProxy" rel="noopener ugc nofollow" target="_blank"> ImageProxy </a>作为向后兼容的输出。ImageProxy是媒体的包装类。Image，是Android框架产生的图像缓冲区。为了生成转换后的图像，Java/Kotlin层可以通过<a class="ae jn" href="https://developer.android.com/reference/android/media/ImageWriter#dequeueInputImage()" rel="noopener ugc nofollow" target="_blank"> dequeueInputImage() </a>从<a class="ae jn" href="https://developer.android.com/reference/android/view/Surface" rel="noopener ugc nofollow" target="_blank">表面</a>获取输入图像，然后使用<a class="ae jn" href="https://developer.android.com/reference/android/media/ImageReaderhttps://developer.android.com/reference/android/media/ImageReader" rel="noopener ugc nofollow" target="_blank"> ImageReader </a>和<a class="ae jn" href="https://developer.android.com/reference/android/media/ImageWriter" rel="noopener ugc nofollow" target="_blank"> ImageWriter </a>将图像数据写入其中。由于ImageWriter是在API 23中添加的，我们使用<a class="ae jn" href="https://developer.android.com/ndk/reference/group/a-native-window?hl=en" rel="noopener ugc nofollow" target="_blank"> ANativeWindow </a>及其缓冲区来生成RGBA格式的输出图像，以支持更多的API级别。</p><p id="bd24" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于输入，我们支持YUV_420_888格式的不同变体(I420、NV12、NV21等。)在CameraX内部。对于输出，我们现在支持RGBA格式，但将来可能会扩展到其他RGB格式的支持。</p><p id="aaa9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于我们使用<a class="ae jn" href="https://chromium.googlesource.com/libyuv/libyuv/" rel="noopener ugc nofollow" target="_blank"> libyuv </a>作为新的依赖项，我们库的大小增加了大约<strong class="ir ht"> 50 KB </strong>。</p><h1 id="c787" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> API用法</strong></h1><p id="3b52" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从<a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/camera#1.1.0-alpha08https://developer.android.com/jetpack/androidx/releases/camera#1.1.0-alpha08" rel="noopener ugc nofollow" target="_blank"> CameraX 1.1.0-alpha08 </a>开始，应用程序可以通过在ImageAnalysis配置中使用setOutputImageFormat来选择YUV_420_888或RGBA_8888格式的输出图像。</p><p id="ac41" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦选择了RGBA_8888，输出图像格式将是<a class="ae jn" href="https://developer.android.com/reference/android/graphics/PixelFormat#RGBA_8888" rel="noopener ugc nofollow" target="_blank">像素格式。RGBA_8888 </a>，它只有一个带有填充的图像平面(R，G，B，一个像素接一个像素)。传统上，Android框架支持带有PixelFormat和ImageFormat子集的图像缓冲格式。</p><p id="9c3f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相比之下，如果选择YUV_420_888，输出图像将是<a class="ae jn" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> ImageFormat。YUV_420_888 </a>，它有3个独立的图像平面(Y，U，V)。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/e7104613de164ef6fb03547962761b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABu3PZc0sNAGNyX7bhooEg.png"/></div></div></figure><h1 id="d930" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">性能</strong></h1><p id="9b85" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们测量了速度，并将结果与不同Android版本和设备上的<a class="ae jn" href="https://github.com/android/camera-samples/blob/master/CameraUtils/lib/src/main/java/com/example/android/camera/utils/YuvToRgbConverter.kt" rel="noopener ugc nofollow" target="_blank"> Renderscript </a>进行了比较。总体而言，我们的libyuv管道在不同分辨率和Android操作系统版本的不同设备上优于我们的参考Renderscript实现。</p><div class="ks kt ku kv fd ab cb"><figure class="lm hj ln lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><img src="../Images/48edba0c6c7fc003fc03ebe3cc96dc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*ap19cZA6PcLcHDBg"/></div></figure><figure class="lm hj ls lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><img src="../Images/833ef0ef22584e90145743fb37e3a5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*BzR4acDtffdDHwGF"/></div></figure></div><div class="ab cb"><figure class="lm hj lt lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><img src="../Images/0999cc705a5334863373ff5bc5c8b70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*yxuPgtuAhwlEjtwc"/></div></figure><figure class="lm hj lt lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><img src="../Images/25345657ab0414be7064af8110815940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*rOIJsc1I2UkG8k7R"/></div></figure></div><h1 id="1e5c" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">总结</strong></h1><p id="e7ce" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们支持CameraX ImageAnalysis管道中的YUV到RGB转换。用户现在只需为ImageAnalysis用例选择输出格式(YUV_420_888或RGBA_8888)即可与其他库连接。这是一个激动人心的旅程的开始，我们正在考虑在我们的CameraX ImageAnalysis管道中添加更多的图像处理功能，并将其扩展到其他用户案例(图像捕捉或预览等)。).如果您有任何功能需求，请告诉我们。</p><p id="02b8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">YUV到RGB转换的示例代码可从GitHub 上的<a class="ae jn" href="https://github.com/android/camera-samples/blob/main/CameraXTfLite/app/src/main/java/com/example/android/camerax/tflite/CameraActivity.kt#L170" rel="noopener ugc nofollow" target="_blank">获得。要了解更多关于CameraX的信息，请参考</a><a class="ae jn" href="https://developer.android.com/training/camerax" rel="noopener ugc nofollow" target="_blank">官方文档</a>。为了跟上CameraX的最新发展，加入<a class="ae jn" href="https://groups.google.com/a/android.com/g/camerax-developers" rel="noopener ugc nofollow" target="_blank"> CameraX讨论组</a>。反馈是非常有价值和受欢迎的:请随意在这里留下您的回复，在<a class="ae jn" href="https://groups.google.com/a/android.com/g/camerax-developers" rel="noopener ugc nofollow" target="_blank">CameraX讨论组</a>与我们交流，或者通过<a class="ae jn" href="https://issuetracker.google.com/issues/new?component=618491&amp;template=1257717" rel="noopener ugc nofollow" target="_blank">官方问题跟踪器</a>创建CameraX问题。</p><p id="32f8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">敬请期待！</p><h1 id="02a3" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">其他参考文献</strong></h1><ul class=""><li id="5667" class="kw kx hs ir b is km iw kn ja lu je lv ji lw jm lx lc ld le bi translated"><a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/camera" rel="noopener ugc nofollow" target="_blank"> CameraX发布说明</a></li><li id="0040" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lx lc ld le bi translated"><a class="ae jn" href="https://developer.android.com/codelabs/camerax-getting-started#0" rel="noopener ugc nofollow" target="_blank">CameraX入门</a></li><li id="dd7d" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lx lc ld le bi translated"><a class="ae jn" href="https://github.com/android/camera-samples" rel="noopener ugc nofollow" target="_blank"> CameraX Github样本</a></li><li id="04de" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lx lc ld le bi translated"><a class="ae jn" href="https://wiki.videolan.org/YUV" rel="noopener ugc nofollow" target="_blank"> YUV格式维基</a></li></ul></div></div>    
</body>
</html>