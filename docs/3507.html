<html>
<head>
<title>C# 8 — New features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 8 —新功能</h1>
<blockquote>原文：<a href="https://medium.com/globant/c-8-new-features-17bdf09658d3?source=collection_archive---------0-----------------------#2020-09-28">https://medium.com/globant/c-8-new-features-17bdf09658d3?source=collection_archive---------0-----------------------#2020-09-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cfbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">C#的新特性和增强功能概述</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d78366434eeed9e0a477b240d22f3a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kZQWPZiPXi3Us1EK"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4463" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在使用c# 20年后，自第一个版本以来，已经发生了很多变化，C# 8在2019年9月发布最新稳定版本后，正在积极进入创新世界。因为这个策略，微软让很多开发者处于一种迷茫的状态。目前，开发人员对C# 8的一些新特性有非常有争议的看法。</p><p id="10c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，您可以对C# 8的新特性有一个简要的概述；我会分别描述重要的特性并用一个例子来演示，我也会简单处理不太重要的特性。我还将写下每个即将到来的重要特性的优缺点。我希望在读完这篇文章后，你会对C# 8的特性有一个清晰的认识。</p><h1 id="22bf" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">C# 8的新特性</h1><p id="9647" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这些是我们将要讨论的C#的新特性。</p><ul class=""><li id="5d38" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">默认接口方法</li><li id="2921" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">可为空的引用类型</li><li id="7aaf" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">模式匹配增强</li><li id="bf55" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">异步流/异步一次性</li><li id="51a0" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">使用声明</li><li id="9397" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">插值逐字字符串的增强</li><li id="c0aa" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">零合并赋值</li><li id="2929" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">静态局部函数</li><li id="5be0" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">指数和范围</li><li id="2e12" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">非托管构造类型</li><li id="751d" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">只读成员</li><li id="cc6d" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">一次性引用结构</li></ul></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="79d5" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">默认接口方法</h1><p id="2db9" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#default-interface-methods" rel="noopener ugc nofollow" target="_blank">默认接口方法</a>允许你添加新的功能到你的库的接口，并确保向后兼容为那些接口的老版本编写的代码。请参见下面的示例。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="c481" class="mb ju hh lx b fi mc md l me mf">interface IWriteLine  <br/>{  <br/>   public void WriteLine()  <br/>   {  <br/>     Console.WriteLine("Wow C# 8!");  <br/>   }  <br/>}</span></pre><p id="8b36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个很有争议的特性，它在。网络社区。这里没有什么新东西。这个概念已经在许多语言中得到应用，并且是从Java中克隆出来的。它基于<a class="ae js" href="https://en.wikipedia.org/wiki/Trait_(computer_programming)#:~:text=In%20computer%20programming%2C%20a%20trait,the%20functionality%20of%20a%20class." rel="noopener ugc nofollow" target="_blank">特征技术</a>，特征是面向对象编程中一种经过验证的强大技术。作为一名专业人士，我认为你可以在不破坏旧版本界面兼容性的情况下给界面添加新功能，但应该小心使用。否则，很容易导致违反单一责任原则。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="eaa7" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">可空引用类型</h1><p id="435f" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如果一个不能为空的变量被赋值为空，一个<a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#nullable-reference-types" rel="noopener ugc nofollow" target="_blank">可为空的引用类型</a>会发出一个编译器警告或错误。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="7654" class="mb ju hh lx b fi mc md l me mf">string? nullableString = null;  <br/>Console.WriteLine(nullableString.Length); // WARNING: may be null! Take care!</span></pre><p id="a7e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般来说，这个特性在。网络社区。这是一项经过验证的技术，也是微软的一项很好的创新。它帮助您消除NullReferenceException。此外，它还能帮助你解决代码中的问题，就像末日金字塔一样。然而，在复杂的场景中，这个特性可能会在引用类型和使用“？”方面带来一些混乱更多信息，请阅读来自<a class="ae js" href="https://codeblog.jonskeet.uk/2019/02/10/nullableattribute-and-c-8/" rel="noopener ugc nofollow" target="_blank">乔恩·斯基特博客</a>的这篇文章。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="68fa" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">高级模式匹配</h1><p id="382c" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#more-patterns-in-more-places" rel="noopener ugc nofollow" target="_blank">高级模式匹配</a>提供了解构匹配对象的能力，让你可以访问它们的部分数据结构。C#提供了一组丰富的模式，可用于匹配。请参见下面的示例。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="78d4" class="mb ju hh lx b fi mc md l me mf">var point = new 3DPoint(1, 2, 3); //x=1, y=2, z=3  <br/>if (point is 3DPoint(1, var myY, _))  <br/>{  <br/>  // Code here will be executed only if <br/>  // the point .X == 1, myY is a new variable  <br/>  // that can be used in this scope.  <br/>}</span></pre><p id="446a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使这里没有什么新鲜的东西，它也很受欢迎。网络社区。递归模式匹配帮助您以一种非常方便、简洁的语法来分解和导航数据结构。而模式匹配在概念上类似于一系列(if，then)语句，所以它将帮助您以函数式风格编写代码。但是对于复杂的表达式，语法可能会很复杂，很难理解。<a class="ae js" href="https://docs.scala-lang.org/tour/pattern-matching.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>是一项经过验证的已知技术，已经使用了很多年，尤其是在函数式编程中。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="864b" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">异步流</h1><p id="bf32" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">允许使用“async”迭代集合。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="2320" class="mb ju hh lx b fi mc md l me mf">await foreach (var x in enumerable)  <br/>{  <br/>  Console.WriteLine(x);  <br/>}</span></pre><p id="7760" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#asynchronous-streams" rel="noopener ugc nofollow" target="_blank">异步流</a>提供了一种极好的方式来表示可由消费者控制的异步数据源。例如，当从web下载数据时，我们希望创建一个异步集合，在数据可用时以块的形式返回数据。这是一个广为接受的功能，但这里没有什么新的东西！这种技术已经在许多其他语言(AKA)流中使用。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="f504" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">范围</h1><p id="786a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#indices-and-ranges" rel="noopener ugc nofollow" target="_blank"> Ranges </a>在访问数据序列或从集合中获取切片时是一个非常强大的构造。该特征由两部分组成，</p><p id="8e2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一部分索引</strong></p><p id="80ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可用于从开头或结尾获取集合，如下例所示。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="16cf" class="mb ju hh lx b fi mc md l me mf">Index i1 = 3; // number 3 from beginning  <br/>Index i2 = ^4; // number 4 from end</span><span id="4c66" class="mb ju hh lx b fi mg md l me mf">int[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  <br/>Console.WriteLine($"{a[i1]}, {a[i2]}"); // "3, 6"</span></pre><p id="7647" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二部分范围</strong></p><p id="8617" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从集合中访问子集合(切片),如下例所示。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="490e" class="mb ju hh lx b fi mc md l me mf">var slice = a[i1..i2]; // { 3, 4, 5 }</span></pre><p id="6bff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">提供了一个很好的语法来访问集合中的数据序列。这是广为接受的，但一次又一次，没有什么是新的。很多类似的技术已经在其他语言中使用，比如<a class="ae js" href="https://www.geeksforgeeks.org/python-range-function/" rel="noopener ugc nofollow" target="_blank"> Python </a>。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="51ca" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">零合并赋值</h1><p id="607d" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#null-coalescing-assignment" rel="noopener ugc nofollow" target="_blank">零合并赋值</a>简化了一个常见的编码模式，如果一个变量为空，就给它赋值。</p><p id="ba0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">常见的代码形式有:</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="f617" class="mb ju hh lx b fi mc md l me mf"><strong class="lx hi">if</strong> (variable == <strong class="lx hi">null</strong>)  <br/>{  <br/>  variable = expression; // C# 1..7  <br/>}</span><span id="705f" class="mb ju hh lx b fi mg md l me mf">variable ??= expression; // C# 8</span></pre><p id="3a46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它提供了一个很好的语法，但只会为您节省几行代码，没什么特别的。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="7adb" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">替代内插逐字字符串</h1><p id="d13f" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#enhancement-of-interpolated-verbatim-strings" rel="noopener ugc nofollow" target="_blank">与$@"hello "(当前内插逐字字符串)相比，备选内插逐字字符串</a>将扩展对象初始化器以允许@$"hello "作为逐字内插字符串。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="3e4a" class="mb ju hh lx b fi mc md l me mf">var file = $@"c:\temp\{filename}"; // C# 7  <br/>var file = @$"c:\temp\{filename}"; // C# 8</span></pre><p id="bf7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我会认为这是一个固定的错误，而不是一个新的功能，这就是为什么我不会进一步讨论它。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="31e0" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">使用声明</h1><p id="8907" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#using-declarations" rel="noopener ugc nofollow" target="_blank">使用声明</a>增强了‘Using’操作符对模式的使用，使其更加自然。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="559e" class="mb ju hh lx b fi mc md l me mf">// C# Old Style  <br/>using (var repository = new Repository())    <br/>{    <br/>} // repository is disposed here!<br/>       <br/>// vs.C# 8       <br/>using var repository = new Repository();    <br/>Console.WriteLine(repository.First());    <br/>// repository is disposed here!</span></pre><p id="f555" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您需要小心使用这个特性，否则当您仍然需要它时，您的对象将被处理掉。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="90f5" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">一次性引用结构</h1><p id="4539" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#disposable-ref-structs" rel="noopener ugc nofollow" target="_blank">可处理的引用结构</a>允许你使用带有‘using’模式的引用结构/只读引用结构。</p><p id="5b1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对ref结构使用基于模式的</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="5e30" class="mb ju hh lx b fi mc md l me mf">ref struct Test {  <br/>   public void Dispose() { ... }  <br/>}  <br/>using var local = new Test();  <br/>// local is disposed here!</span></pre></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="6451" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">静态局部函数</h1><p id="ee5a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#static-local-functions" rel="noopener ugc nofollow" target="_blank">静态局部函数</a>允许你给局部函数添加“静态”修饰符。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="f200" class="mb ju hh lx b fi mc md l me mf">int AddFiveAndSeven()  <br/>{  <br/>  int y = 5; <br/>  int x = 7;  <br/>  return Add(x, y);</span><span id="51fb" class="mb ju hh lx b fi mg md l me mf">  static int Add(int left, int right) =&gt; left + right;  <br/>}</span></pre><p id="5d88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此功能将帮助您修复警告，使其不会从封闭范围中捕获对任何变量的引用。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="e896" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">非托管构造类型</h1><p id="c04d" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在C# 7.3和更早版本中，构造类型(至少包含一种参数类型的类型)不能是非托管类型。从C# 8.0开始，如果构造值类型只包含非托管类型的字段，则该类型是非托管的。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="0a6f" class="mb ju hh lx b fi mc md l me mf">Public <strong class="lx hi">struct</strong> Foo&lt;T&gt;   <br/>{   <br/><strong class="lx hi">  public</strong> T Var1;   <br/><strong class="lx hi">  public</strong> T Var2;   <br/>}</span></pre><p id="ea03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Bar <int>类型在C# 8.0中是一个非托管类型。与任何非托管类型一样，您可以创建一个指向该类型变量的指针，或者在堆栈上为该类型的实例分配一块内存:</int></p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="1ba9" class="mb ju hh lx b fi mc md l me mf">// Pointer</span><span id="8579" class="mb ju hh lx b fi mg md l me mf">var foo = <strong class="lx hi">new</strong> Foo &lt;<strong class="lx hi">int</strong>&gt; { Var1 = 0, Var2 = 0 }, <br/>var bar = &amp;foo; // C# 8 </span><span id="b910" class="mb ju hh lx b fi mg md l me mf">// Block of memory <br/>Span&lt; Foo&lt;<strong class="lx hi">int</strong>&gt;&gt; bars = <strong class="lx hi">stackalloc</strong>[] <br/>{ <br/> <strong class="lx hi">new</strong> Foo &lt;<strong class="lx hi">int</strong>&gt; { Var1 = 0, Var2 = 0 }, <br/> <strong class="lx hi">new</strong> Foo &lt;<strong class="lx hi">int</strong>&gt; { Var1 = 0, Var2 = 0 } <br/>};</span></pre><p id="738a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该功能是一种性能增强。如果构造值类型只包含非托管类型的字段，则它们现在是非托管的。这个特性意味着你可以在堆栈上分配实例。阅读下面的<a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#unmanaged-constructed-types" rel="noopener ugc nofollow" target="_blank">链接</a>。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="dc90" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">只读成员</h1><p id="c8ff" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">新的<a class="ae js" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#readonly-members" rel="noopener ugc nofollow" target="_blank">只读成员</a>允许你将只读修饰符应用于结构的任何成员。它表示该成员不修改状态。</p><pre class="jd je jf jg fd lw lx ly lz aw ma bi"><span id="09d0" class="mb ju hh lx b fi mc md l me mf"><strong class="lx hi">public</strong> <strong class="lx hi">struct</strong> XValue <br/>{ <br/> <strong class="lx hi">private</strong> <strong class="lx hi">int</strong> X { <strong class="lx hi">get</strong>; <strong class="lx hi">set</strong>; } </span><span id="155c" class="mb ju hh lx b fi mg md l me mf"> <strong class="lx hi">public</strong> <strong class="lx hi">readonly</strong> <strong class="lx hi">int</strong> IncreaseX() <br/> { <br/> // This will not compile: C# 8 <br/> // X = X + 1; <br/> var newX = X + 1; // OK <br/> <strong class="lx hi">return</strong> newX; <br/> } <br/>}</span></pre><p id="9f13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此功能允许您指定您的设计意图，以便编译器可以实施它，并基于该意图进行优化。</p></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><h1 id="150d" class="jt ju hh bd jv jw lr jy jz ka ls kc kd ke lt kg kh ki lu kk kl km lv ko kp kq bi translated">摘要</h1><p id="f622" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">C# 8有许多有用的新特性，在社区中被广泛接受。不幸的是，创新仍然很低，没有达到许多开发人员的期望，就像在C#中一劳永逸地融入特征，只是在这里和那里有一些小的变化，没有创造出真正大的功能。我们已经看到了C# 8提出的特性及其优缺点的概述，我希望这将有助于您在未来更好地使用它们。</p></div></div>    
</body>
</html>