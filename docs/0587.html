<html>
<head>
<title>Testing App Startup Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试应用启动性能</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/testing-app-startup-performance-36169c27ee55?source=collection_archive---------2-----------------------#2020-11-25">https://medium.com/androiddevelopers/testing-app-startup-performance-36169c27ee55?source=collection_archive---------2-----------------------#2020-11-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/92a2a5d5cb2312146371d206ec4d74ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvOu8q-aj-bS7l-Iu-9f2A.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="ca78" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">测试发射性能可能很棘手，但也不一定如此</h2></div><h1 id="540c" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">用于测试启动的Shell命令</h1><p id="df0f" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">我写这篇文章是为了解释更多关于性能、启动测试以及我用来测试启动的部分背后的原因。但是，如果你只是想要一些快速的东西，这就是:</p><ol class=""><li id="8615" class="la lb hx kg b kh lc kk ld kn le kr lf kv lg kz lh li lj lk bi translated">如果可能的话，锁定时钟(见下文)</li><li id="872e" class="la lb hx kg b kh ll kk lm kn ln kr lo kv lp kz lh li lj lk bi translated">在命令行上运行(当您的设备连接时):</li></ol><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ddbd" class="lz jn hx lv b fi ma mb l mc md">$ for i in `seq 1 100`<br/>&gt; do <br/>&gt;   adb shell am force-stop com.android.samples.mytest<br/>&gt;   sleep 1<br/>&gt;   adb shell am start-activity -W -n com.android.samples.mytest/.MainActivity | grep "TotalTime" | cut -d ' ' -f 2<br/>&gt; done</span></pre><p id="e6e3" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">上面的命令循环100次，启动一个应用程序，输出启动持续时间，并终止进程以准备再次执行所有操作。</p><h1 id="dbcc" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">测试启动性能…不明显</h1><p id="3394" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">最近，我需要测试一个应用程序的启动性能(同时摆弄启动库，看看它是如何影响事情的——在以后的文章中会有更多的介绍)。我发现，就像我之前在<a class="ae hu" href="http://graphics-geek.blogspot.com/" rel="noopener ugc nofollow" target="_blank">沿着这条路散步一样</a>，测试启动性能……并不明显。</p><p id="083c" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">如果你正在测试一段运行时代码，有各种各样的方法去做它，从琐碎的“写一个紧密的循环并在<code class="du mh mi mj lv b">System.currentTimeMillis()</code>中计算增量”到更复杂和有用的东西，比如由<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/benchmark" rel="noopener ugc nofollow" target="_blank"> AndroidX基准</a>库提供的设施。</p><p id="77bf" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">但是根据定义，应用程序启动的大部分过程发生在系统开始调用您的代码之前。那么你如何计算出到达那里需要多长时间呢？</p><p id="3a00" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">我在logcat中四处闲逛，查看了一些底层API，并询问了平台团队中的一些工程师，发现了一些有帮助的东西。更好的是，我能够使用<code class="du mh mi mj lv b">adb shell</code>工具中的工具来完全自动化我的测试和输出信息，这种方式使得将结果弹出到电子表格中并分析它们变得容易。</p><p id="8108" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">我将描述我在上面的命令中使用的部分，给你1-2个简单的步骤，如果<em class="mk">你</em>需要测试启动性能的话。</p><h1 id="343f" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">ActivityTaskManager启动日志</h1><p id="3a79" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">正如我之前在更早的(不幸的是，已经过时和不正确的)<a class="ae hu" href="http://graphics-geek.blogspot.com/" rel="noopener ugc nofollow" target="_blank">博客</a>中所写的，自从KitKat发布以来，系统已经发布了一个方便的日志。每当活动开始时，您都会在logcat输出中看到类似这样的内容:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2712" class="lz jn hx lv b fi ma mb l mc md">ActivityTaskManager: Displayed com.android.samples.mytest/.MainActivity: +1s380ms</span></pre><p id="4075" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">此持续时间(本例中为1，380毫秒)表示从启动应用程序到系统认为它“已启动”所花费的时间，包括绘制第一帧(因此“已显示”)。</p><p id="181b" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">这个<code class="du mh mi mj lv b">Displayed</code>持续时间并不一定包括你的应用在准备好之前需要做的所有事情。只要你的应用程序确定已经完全完成加载和初始化，你就可以通过调用<code class="du mh mi mj lv b"><a class="ae hu" href="https://developer.android.com/reference/android/app/Activity#reportFullyDrawn()" rel="noopener ugc nofollow" target="_blank">Activity.reportFullyDrawn(</a>)</code>向系统提供额外的信息。如果/当您调用该可选方法时，系统会发出另一个具有该时间戳和持续时间的日志:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="377f" class="lz jn hx lv b fi ma mb l mc md">2020-11-18 15:44:02.171 1279-1336/system_process I/ActivityTaskManager: Fully drawn com.android.samples.mytest/.MainActivity: +2s384ms</span></pre><p id="a1c9" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">我只想要显示的持续时间，所以内置日志对于我的目的来说已经足够好了。</p><h1 id="b77b" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">自动化启动</h1><p id="9591" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">性能测试应该总是包括多次运行测试，以减少结果中固有的可变性；你跑得越多，你对平均成绩就越有信心。我试着至少运行十次测试，但是做得更多会更好。根据您的情况下结果的可变性以及时间的长短(因为可变性对较短的持续时间有较大的影响)，可能需要进行更多的运行。</p><blockquote class="ml"><p id="4e54" class="mm mn hx bd mo mp mq mr ms mt mu kz dx translated">疯狂是一遍又一遍地做同样的事情，却期待不同的结果。<br/>——阿尔伯特·爱因斯坦</p></blockquote><p id="e70d" class="pw-post-body-paragraph ke kf hx kg b kh mv iy kj kk mw jb km kn mx kp kq kr my kt ku kv mz kx ky kz ha bi translated">性能测试推论:</p><blockquote class="ml"><p id="d208" class="mm mn hx bd mo mp mq mr ms mt mu kz dx translated"><strong class="ak"> <em class="na">精神错乱</em> </strong> <em class="na">做同一件事只做一次，并期待结果是确定的。</em></p><p id="a350" class="mm mn hx bd mo mp mq mr ms mt mu kz dx translated">-不是阿尔伯特·爱因斯坦</p></blockquote><p id="8e50" class="pw-post-body-paragraph ke kf hx kg b kh mv iy kj kk mw jb km kn mx kp kq kr my kt ku kv mz kx ky kz ha bi translated">连续多次点击应用程序图标来启动它是…相当乏味的。以可预测和一致的方式做到这一点(以避免引入可变性，就像你碰巧错误地启动了另一个应用程序，或者让系统做额外的工作来丢弃计时结果)可能是一个问题。</p><p id="e49f" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">所以我真正想要的是某种从命令行启动应用程序的方式。然后，我可以运行那个命令来一遍又一遍地做同样的事情，避免手动启动应用程序的可变性(和乏味)。</p><p id="7cad" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated"><code class="du mh mi mj lv b"><a class="ae hu" href="https://developer.android.com/studio/command-line/adb" rel="noopener ugc nofollow" target="_blank">adb</a></code> (Android Debug Bridge，一个读到这里的人可能都很熟悉的工具)提供了我需要的东西。更具体地说，<code class="du mh mi mj lv b">adb shell</code>提供了一个命令行界面来启动一个应用:<code class="du mh mi mj lv b">adb shell am start-activity</code>。该命令也应该阻塞，直到应用程序完成启动，所以我们也将使用<code class="du mh mi mj lv b">-W</code>参数(这对于下一步是必要的，在下一步中，我们将添加一个后续命令来在启动后终止应用程序)。以下是完整的启动命令:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="3289" class="lz jn hx lv b fi ma mb l mc md">$ adb shell am start-activity -W -n com.android.samples.mytest/.MainActivity</span></pre><p id="44d9" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">最后一个参数是应用程序的包+组件信息。您可以看到它们与上一节中的<code class="du mh mi mj lv b">ActivityTaskManager</code>日志输出相同。</p><p id="dff6" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">运行此命令会启动应用程序(除非应用程序已经在前台，这不是您想要的；我们将在接下来处理它)，然后输出以下信息:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ddc5" class="lz jn hx lv b fi ma mb l mc md">Starting: Intent { cmp=com.android.samples.mytest/.MainActivity }<br/>Status: ok<br/>LaunchState: COLD<br/>Activity: com.android.samples.mytest/.MainActivity<br/>TotalTime: 1380<br/>WaitTime: 1381<br/>Complete</span></pre><p id="7cc1" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">查看<code class="du mh mi mj lv b">TotalTime</code>结果:这与我们在日志中看到的信息完全相同:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="4388" class="lz jn hx lv b fi ma mb l mc md">ActivityTaskManager: Displayed com.android.samples.mytest/.MainActivity: +1s380ms</span></pre><p id="4298" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">这意味着我们不必通过logcat来获取这些信息。相反，我们可以从运行launch命令的控制台直接获得它。更好的是，我们可以去掉无关的文本，只留下启动结果，这样更容易提取这些数据供其他地方使用。</p><p id="efa7" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">为了将上面的输出转换为启动持续时间，我通过<code class="du mh mi mj lv b">grep</code>和<code class="du mh mi mj lv b">cut</code> shell命令传输输出(有多种方法可以做到这一点，我只是随机选择了一种):</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="e11f" class="lz jn hx lv b fi ma mb l mc md">adb shell am start-activity -W -n com.android.samples.mytest/.MainActivity | grep "TotalTime" | cut -d ' ' -f 2</span></pre><p id="8d83" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">现在，当我运行这个命令时，我得到了一个期望的数字:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="46b8" class="lz jn hx lv b fi ma mb l mc md">$ [start-activity command as above...]<br/>1380</span></pre><h1 id="ba4c" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">创业是一道最好的冷盘</h1><p id="5fd7" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">在检查启动性能时，最好理解“冷启动”和“热启动”之间的区别</p><p id="1165" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated"><em class="mk">冷启动</em>发生在您的应用程序在安装、重启后第一次启动时，或者当它不在后台时。</p><p id="8b8e" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated"><em class="mk">另一方面，热启动</em>是当应用程序已经启动并在后台运行(但已暂停)时得到的结果。</p><p id="7fc1" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">这两种场景都可以测试和理解。但是一般来说，在<strong class="kg hy">冷启动</strong>场景中测试你的启动性能是一个更好的开始，有两个主要原因:</p><ul class=""><li id="f602" class="la lb hx kg b kh lc kk ld kn le kr lf kv lg kz nb li lj lk bi translated"><strong class="kg hy">一致性</strong>:冷启动确保你的app每次启动都在经历相同的一组操作。如果你的应用是在热启动场景下启动的，那么哪些步骤被执行，哪些步骤被跳过就不那么明显了，所以不清楚你实际上在计时什么(以及你是否在重复运行之间持续测试)。</li><li id="7c9f" class="la lb hx kg b kh ll kk lm kn ln kr lo kv lp kz nb li lj lk bi translated"><strong class="kg hy">最坏情况</strong>:根据定义，冷启动是最坏情况；这是您的用户将看到的最长的启动持续时间。您需要将注意力放在最差的统计数据上，而不是最好的热启动情况。如果你忽视这些大问题，你就无法解决它们。</li></ul><p id="bc4f" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">为了在每次运行时强制冷启动，您需要在运行之间关闭应用程序。同样，在屏幕上这样做(比如说，从launcher的概览列表中划掉它)会很乏味而且容易出错。<code class="du mh mi mj lv b">adb shell</code>再次前来救援。</p><p id="52fd" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">有几个不同的shell命令可以用来终止活动。最明显的是<code class="du mh mi mj lv b">adb shell am kill</code> …但它实际上并不奏效。在你启动你的应用程序后，它在前台，并且<code class="du mh mi mj lv b">kill</code>不会关闭前台应用程序。相反，你需要<code class="du mh mi mj lv b">force-quit</code>命令:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="eed0" class="lz jn hx lv b fi ma mb l mc md">adb shell am force-stop com.android.samples.mytest</span></pre><p id="87ab" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">在这里你使用你的应用程序的包名来告诉它停止哪个应用程序。</p><h1 id="6ab4" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">我喜欢循环，循环</h1><p id="d3f6" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">现在，您可以一起运行命令来启动应用程序，输出启动持续时间数据，并退出应用程序，使其准备好再次启动。你可以在控制台中一遍又一遍地输入这个，但是，嘿，我们在一个shell中；让我们把它放在一个循环中，只用一个命令重复运行它。</p><p id="8ec9" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">在这样做的时候，你要避免在应用程序被终止后过早地运行它，以防出现与应用程序被拆除相关的副作用(比如当应用程序被拆除时，系统将启动器拉到前台)。为此，我添加了第二个<code class="du mh mi mj lv b">sleep</code>来在操作之间插入一个小缓冲区。</p><p id="ea13" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">这是我使用的最后一个命令，包括关闭应用程序，等待一秒钟，然后启动它。我循环了100次迭代，这为我的情况提供了一个合理的样本大小:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="65f0" class="lz jn hx lv b fi ma mb l mc md">$ for i in `seq 1 100`<br/>&gt; do <br/>&gt;   adb shell am force-stop com.android.samples.mytest<br/>&gt;   sleep 1<br/>&gt;   adb shell am start-activity -W -n com.android.samples.mytest/.MainActivity | grep "TotalTime" | cut -d ' ' -f 2<br/>&gt; done</span></pre><p id="1ca3" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">当我运行这个程序时，每次启动完成时，控制台都会输出启动持续时间，这正是我想要跟踪和分析的。</p><p id="6dc5" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">注意:使用<code class="du mh mi mj lv b">-S</code>(首先强制停止活动)和<code class="du mh mi mj lv b">-R COUNT</code>(运行<code class="du mh mi mj lv b">start-activity</code>命令<code class="du mh mi mj lv b">COUNT</code>次)循环start-activity实际上有一种简单得多的方法，所以我可以用这个来代替:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="22b5" class="lz jn hx lv b fi ma mb l mc md">$ adb shell am start-activity -S -W -R 100-n com.android.samples.mytest/.MainActivity | grep "TotalTime" | cut -d ' ' -f 2</span></pre><p id="a177" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">但是为了确保在拆卸和启动之间有一个不活动的缓冲，我需要那个<code class="du mh mi mj lv b">sleep 1</code>命令，所以我使用了更冗长的循环方法。况且shell脚本代码<em class="mk"> sooooo </em>优雅吧？</p><h1 id="16bb" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">可能的话，锁定你的时钟</h1><p id="dd47" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">影响移动设备性能的因素之一是CPU架构，尤其是CPU频率。具体来说，移动设备保持电池寿命并避免过热的主要问题的主要方法之一是通过抑制CPU速度。</p><p id="e23f" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">CPU节流对电池寿命有好处，但对性能测试来说就不那么好了，因为在性能测试中，一致的结果是至关重要的。</p><p id="426a" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">理想情况下，在运行性能测试时，您应该能够控制CPU频率。不幸的是，您能否做到这一点取决于您所拥有的设备；您需要以root用户身份访问设备来控制CPU调控器，CPU调控器控制频率，不同的设备可能有不同的方式来改变这种行为。</p><p id="d42e" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">以下信息仅适用于您，前提是您碰巧可以访问允许它的设备，并且您可以获得root访问权限。在设备方面，我知道Pixel设备允许这种访问；其他设备我不敢说。</p><p id="dec2" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">无论如何，<em class="mk">如果</em>你可以锁定你的时钟，我建议你这样做。对于您的特定测试情况，这可能并不重要(事实上，系统通常以高频率运行时钟，特别是在启动应用程序时，因此这可能已经提供了您需要的一致性)。但是至少消除CPU频率这个可变性因素是有好处的。</p><p id="8baf" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">不幸的是，手动锁定CPU频率可能很棘手。幸运的是，<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/benchmark" rel="noopener ugc nofollow" target="_blank"> AndroidX基准测试</a>库使它变得简单。事实上，您甚至不需要为基准API编写代码；您可以使用这个库来获得它提供的便利的<code class="du mh mi mj lv b">lockClocks</code>和<code class="du mh mi mj lv b">unlockClocks</code>实用程序。</p><p id="9bc3" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">首先，将基准库作为依赖项添加到项目级build.gradle文件中:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="e929" class="lz jn hx lv b fi ma mb l mc md">classpath "androidx.benchmark:benchmark-gradle-plugin:1.0.0"</span></pre><p id="b290" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">接下来，通过将基准插件添加到您的应用程序级build.gradle文件来应用它:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="eeeb" class="lz jn hx lv b fi ma mb l mc md">apply plugin: androidx.benchmark</span></pre><p id="1a9d" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">现在你可以同步你的项目了(Android Studio可能已经在催促你这么做了)，之后锁定任务就可以从<code class="du mh mi mj lv b">gradlew</code>使用了。</p><p id="e425" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">现在，您可以通过在命令行上运行它来锁定您的时钟(我在Android Studio的终端工具中运行了它，但是您也可以在ide之外运行它):</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="e6a3" class="lz jn hx lv b fi ma mb l mc md">$ ./gradlew lockClocks</span></pre><p id="be59" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">当我这样做时，我在控制台中看到了以下输出:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="283f" class="lz jn hx lv b fi ma mb l mc md">Locked CPUs 4,5,6,7 to 1267200 / 2457600 KHz<br/>Disabled CPUs 0,1,2,3</span></pre><p id="2e8a" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">这个输出很好地表明它在我的Pixel 2上工作。一个更好的迹象是，我的启动测试现在比以前花费了更多的时间。但是等等，为什么锁定的时钟<em class="mk">比</em>慢？</p><p id="f21f" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">基准测试工具将时钟锁定在一个容易维持的水平，而不是一个高性能的水平。如果时钟尽可能地高速运行，您可能会获得更好的性能，但是:</p><ul class=""><li id="bba5" class="la lb hx kg b kh lc kk ld kn le kr lf kv lg kz nb li lj lk bi translated">您希望测试结果具有真实的甚至很差的性能，就像您的许多用户在现场看到的那样。您不希望只看到最佳情况下的性能，这不是人们在现实中通常会看到的。</li><li id="90d3" class="la lb hx kg b kh ll kk lm kn ln kr lo kv lp kz nb li lj lk bi translated">时钟以高频率运行太久会使它们过热。我不知道系统对此会有什么反应(希望它能在出现严重问题之前自动关闭系统)，但我真的不想知道。</li></ul><p id="2799" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">请注意，当您完成测试后，您将需要<em class="mk">解锁</em>时钟。设备将在重新启动时解锁它们，但您也可以通过运行相反的梯度任务解锁它们:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="03af" class="lz jn hx lv b fi ma mb l mc md">$ ./gradlew unlockClocks</span></pre><p id="cfcf" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">…只需重启设备即可执行重置。</p><p id="1710" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">(如果你想了解更多关于benchmark锁定工具的信息，请查看<a class="ae hu" href="https://developer.android.com/studio/profile/benchmark#clock-stability" rel="noopener ugc nofollow" target="_blank">用户指南</a>)。</p><h1 id="a49e" class="jm jn hx bd jo jp jq jr js jt ju jv jw jd jx je jy jg jz jh ka jj kb jk kc kd bi translated">就这样…完成了！</h1><p id="938d" class="pw-post-body-paragraph ke kf hx kg b kh ki iy kj kk kl jb km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">在锁定时钟之后，我已经准备好了一切:一个可以可靠一致地再现我的启动情况的系统，以及一个我可以执行并返回结果流的简单命令行。我能够复制结果，将它们粘贴到电子表格中，并分析它们(通过将我的启动平均值与我想要试验的各种之前/之后的情况进行比较)。</p><p id="d879" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">理想情况下，我不需要一篇文章来解释如何做到这一切。老实说，你不需要上面所有的解释。(但是知道事物是如何工作的以及为什么工作总是更有趣，不是吗？)您真正需要的是单个<code class="du mh mi mj lv b">for()</code> loop shell命令，以及可选的锁定时钟的方法。</p><ol class=""><li id="f236" class="la lb hx kg b kh lc kk ld kn le kr lf kv lg kz lh li lj lk bi translated">如果可能的话，锁定时钟(见下文)</li><li id="b61a" class="la lb hx kg b kh ll kk lm kn ln kr lo kv lp kz lh li lj lk bi translated">在命令行上运行(当您的设备连接时):</li></ol><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="e7da" class="lz jn hx lv b fi ma mb l mc md">$ for i in `seq 1 100`<br/>&gt; do <br/>&gt;   adb shell am force-stop com.android.samples.mytest<br/>&gt;   sleep 1<br/>&gt;   adb shell am start-activity -W -n com.android.samples.mytest/.MainActivity | grep "TotalTime" | cut -d ' ' -f 2<br/>&gt; done</span></pre><p id="76a5" class="pw-post-body-paragraph ke kf hx kg b kh lc iy kj kk ld jb km kn me kp kq kr mf kt ku kv mg kx ky kz ha bi translated">为了更简单的性能测试和分析，以及更好的应用程序性能，该团队正在研究简化这一过程的方法。当我们有什么要分享的时候，请继续关注。但同时，我希望上面的命令和信息对您的启动测试需求有所帮助。</p></div></div>    
</body>
</html>