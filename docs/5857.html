<html>
<head>
<title>Analyze Bank Transaction Data using Graph (Part 1/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图表分析银行交易数据(第1/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-1-3-2088c6024f81?source=collection_archive---------1-----------------------#2021-12-21">https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-1-3-2088c6024f81?source=collection_archive---------1-----------------------#2021-12-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fb7a63d219b1fadcb7e7d0ec2bd7e46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKIZPuXOqfuFkeylwZmVzA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@eduschadesoares?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Eduardo Soares</a> on <a class="ae it" href="https://unsplash.com/s/photos/atm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (edited)</figcaption></figure><p id="6eb5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，作为使用Oracle Graph的第一步，我们将了解如何以图表的形式管理银行交易数据，以及可以进行何种分析。金融机构中的欺诈检测是图形数据库的主要用例之一。图形也有望用于反洗钱，因此这种用例应该继续扩展。</p><p id="a71b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我将讨论为什么把诸如银行转帐这样的交易看作图表是有帮助的。例如，假设我们有一个由客户表、帐户表和交易表组成的银行交易数据集。我们想回答以下(可能很常见)两个问题:</p><ul class=""><li id="1a78" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">鲍勃和查理之间有资金往来吗？即使没有直接交易，你也可以说有通过其他账户的间接资金流动。</li><li id="1cdb" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">是否存在事务集群？也就是说，是否存在一些账户之间频繁交易而这些账户与其他账户之间不太频繁交易的模式？</li></ul><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kg"><img src="../Images/edad0dcd3dd6667d954788af97cf03c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYgxA7wYzv6dZJF4J1fZBA.png"/></div></div></figure><p id="f11e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们使用RDBMS，回答第一个问题自然需要表到表的连接和自连接。找到关系的跳数越多，需要的连接就越多。第二个问题更难回答，可能需要过程代码(比如Oracle的PL/SQL)来构建图结构和确定集群。</p><p id="4871" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们考虑把它当作一个图的情况。</p><p id="a0f2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图有两种结构:节点和边。因此，如果我们希望将表中的信息表示为图形，我们可以将帐户建模为节点，将交易建模为边。这种表示很直观，如下图所示，我们可以简单地沿着从账户a1到a3、a5、a4的边，来回答第一个问题。理想情况下，这样的数据库系统应该提供一种有效的方法来找到a1和a4之间的路径。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/2d8f6655b7aa7b48f269173b1db38c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3unMXwVVnGl_vOgAIo_WA.png"/></div></div></figure><p id="ec39" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了回答第二个问题，我们需要实现或使用一个现有的<strong class="iw hi">图算法</strong>来基于事务的网络结构找到集群。许多这样的算法已经被提出并用于社会网络分析中的社区检测。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es km"><img src="../Images/641a20a1e869d9ef1d7c867254d98d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFBrmyXt88opI0cdAMu3Ew.png"/></div></div></figure><p id="76a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文的第1部分中，我们将在Oracle Graph的两层部署中尝试数据输入和输出。这种配置不需要中间层的图形服务器组件。我们将假设Oracle数据库中已经启用了Oracle Graph，并且PGQL插件已经添加到SQLcl client中。如果你还没有一个环境，请参见<a class="ae it" rel="noopener" href="/oracledevs/build-oracle-graph-on-docker-part-1-2-5fcacaca430e">这篇文章</a>中的设置说明。我们会用<strong class="iw hi"> PGQL </strong>(属性图查询语言)编码，和SQL很像，直观易用。</p><p id="06fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用SQL登录数据库，切换到PGQL模式。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="71f3" class="ks kt hh ko b be ku kv l kw kx">PGQL AUTO ON</span></pre><p id="09f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建一个新图表。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="96f2" class="ks kt hh ko b be ku kv l ky kx">CREATE PROPERTY GRAPH graph1;</span></pre><p id="26e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用INSERT VERTEX语句添加两种类型的节点:customers和accounts。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="5507" class="ks kt hh ko b be ku kv l ky kx">INSERT INTO graph1 VERTEX v LABELS (customer) PROPERTIES (v.cst_id = 'c1', v.first_name = 'Alice');<br/>INSERT INTO graph1 VERTEX v LABELS (customer) PROPERTIES (v.cst_id = 'c2', v.first_name = 'Bob');<br/>INSERT INTO graph1 VERTEX v LABELS (customer) PROPERTIES (v.cst_id = 'c3', v.first_name = 'Charlie');<br/>INSERT INTO graph1 VERTEX v LABELS (customer) PROPERTIES (v.cst_id = 'c4', v.first_name = 'Dave');<br/><br/>INSERT INTO graph1 VERTEX v LABELS (account) PROPERTIES (v.acc_id = 'a1');<br/>INSERT INTO graph1 VERTEX v LABELS (account) PROPERTIES (v.acc_id = 'a2');<br/>INSERT INTO graph1 VERTEX v LABELS (account) PROPERTIES (v.acc_id = 'a3');<br/>INSERT INTO graph1 VERTEX v LABELS (account) PROPERTIES (v.acc_id = 'a4');<br/>INSERT INTO graph1 VERTEX v LABELS (account) PROPERTIES (v.acc_id = 'a5');<br/><br/>COMMIT;</span></pre><p id="eda8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们使用INSERT EDGE语句添加两种类型的边:帐户所有权(OWNS)和帐户间转帐(TRANSFERRED_TO)。在此过程中，您可以看到我们正在寻找作为每条边的起点和终点的节点，然后在它们之间添加一条边。为了获得更好的性能，有一种在单个INSERT语句中添加节点和边的方法，但是这里我们将只为每个节点和边发出一个INSERT语句。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="ff8a" class="ks kt hh ko b be ku kv l ky kx">INSERT INTO graph1 EDGE e BETWEEN src AND dst LABELS (OWNS)<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.cst_id = 'c1' AND dst.acc_id = 'a2';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst LABELS (OWNS)<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.cst_id = 'c1' AND dst.acc_id = 'a5';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst LABELS (OWNS)<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.cst_id = 'c2' AND dst.acc_id = 'a1';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst LABELS (OWNS)<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.cst_id = 'c3' AND dst.acc_id = 'a4';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst LABELS (OWNS)<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.cst_id = 'c4' AND dst.acc_id = 'a3';<br/><br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst<br/>  LABELS (transferred_to) PROPERTIES (e.amount = '20000')<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.acc_id = 'a1' AND dst.acc_id = 'a3';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst<br/>  LABELS (transferred_to) PROPERTIES (e.amount = '20000')<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.acc_id = 'a3' AND dst.acc_id = 'a5';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst<br/>  LABELS (transferred_to) PROPERTIES (e.amount = '30000')<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.acc_id = 'a5' AND dst.acc_id = 'a4';<br/>INSERT INTO graph1 EDGE e BETWEEN src AND dst<br/>  LABELS (transferred_to) PROPERTIES (e.amount = '10000')<br/>  FROM MATCH ((src), (dst)) ON graph1<br/>  WHERE src.acc_id = 'a4' AND dst.acc_id = 'a2';<br/><br/>COMMIT;</span></pre><p id="82f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们在这个图上运行一个PGQL SELECT查询。首先，我们会找到鲍勃拥有的银行账户。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="2af0" class="ks kt hh ko b be ku kv l ky kx">SELECT c.first_name, a.acc_id<br/>FROM MATCH (c:customer)-[:owns]-&gt;(a:account) ON graph1<br/>WHERE c.first_name = 'Bob';<br/><br/>FIRST_NAME    ACC_ID <br/>_____________ _________ <br/>Bob           a1</span></pre><p id="0742" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们将从上面Bob的帐户中找到要将钱转移到的帐户。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="c562" class="ks kt hh ko b be ku kv l ky kx">SELECT c.first_name, a.acc_id AS a1, t.amount, a2.acc_id AS a2<br/>FROM MATCH (c:customer)-[:owns]-&gt;(a:account)-[t:transferred_to]-&gt;(a2:account) ON graph1<br/>WHERE c.first_name = 'Bob';<br/><br/>FIRST_NAME    A1    AMOUNT    A2 <br/>_____________ _____ _________ _____ <br/>Bob           a1    20000     a3</span></pre><p id="ea49" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类似地，我们可以扩展模式来获取帐户的所有者。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="517f" class="ks kt hh ko b be ku kv l ky kx">SELECT<br/>  c.first_name AS c1<br/>, a.acc_id AS a1<br/>, t.amount<br/>, a2.acc_id AS a2<br/>, c2.first_name AS c2<br/>FROM MATCH (c:customer)-[:owns]-&gt;(a:account)-[t:transferred_to]-&gt;(a2:account)&lt;-[:owns]-(c2:customer) ON graph1<br/>WHERE c.first_name = 'Bob';<br/><br/>C1    A1    AMOUNT    A2      C2 <br/>______ _____ _________ _____ _______ <br/>Bob    a1    20000     a3    Dave</span></pre><p id="f929" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，使用一个<a class="ae it" href="https://pgql-lang.org/spec/1.4/#reachability" rel="noopener ugc nofollow" target="_blank">可达性测试</a>查询语法，我们可以将货币转移路径的最小和最大长度指定为1跳和3跳。然后我们可以看到Bob的帐户通过3跳连接到Charlie的帐户。</p><pre class="kh ki kj kk fd kn ko kp bn kq kr bi"><span id="d281" class="ks kt hh ko b be ku kv l ky kx">SELECT c.first_name AS c1, a.acc_id AS a1, a2.acc_id AS a2, c2.first_name AS c2<br/>FROM MATCH (c:customer)-[:owns]-&gt;(a:account)-/:transferred_to{1,3}/-&gt;(a2:account)&lt;-[:owns]-(c2:customer) ON graph1<br/>WHERE c.first_name = 'Bob';<br/><br/>C1    A1    A2         C2 <br/>______ _____ _____ __________ <br/>Bob    a1    a5    Alice      <br/>Bob    a1    a3    Dave       <br/>Bob    a1    a4    Charlie</span></pre><p id="39cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，我希望您已经掌握了数据库如何通过PGQL API将事务性数据集“视为图形”的基本思想。</p><p id="eb5e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个阶段，你可能会有一些疑问。要使用这个新的API，我们必须开始创建或重新创建图形形式的数据集吗？此外，一旦我们有了这样的图，我们如何实现基于图的操作，如搜索路径或检测社区？</p><p id="a393" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将在<a class="ae it" href="https://ryotayamanaka.medium.com/analyze-bank-transaction-data-using-graph-part-2-3-155516bb6349" rel="noopener">第二部分</a>和<a class="ae it" href="https://ryotayamanaka.medium.com/analyze-bank-transaction-data-using-graph-part-3-3-ab8ae1f68bd2" rel="noopener">第三部分</a>中讨论这些问题。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="5987" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请从以下网址了解有关<strong class="iw hi"> Oracle Graph </strong>的更多信息:</p><ul class=""><li id="11a9" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><a class="ae it" rel="noopener" href="/tag/oracle-graph">中</a> (=所有带有Oracle Graph标签的文章)</li><li id="773c" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae it" href="https://stackoverflow.com/questions/tagged/oracle-graph" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a> (=带有oracle-graph标记的问题)</li><li id="d2d5" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae it" href="https://join.slack.com/t/andouc/shared_invite/zt-1a2hmiz6f-vLlblcQyv0t9FMraMMP5uQ" rel="noopener ugc nofollow" target="_blank"> Slack AnDOUC </a> (=邀请链接，请访问#graph)</li><li id="dca1" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae it" href="https://join.slack.com/t/oracledevrel/shared_invite/zt-uffjmwh3-ksmv2ii9YxSkc6IpbokL1g" rel="noopener ugc nofollow" target="_blank"> Slack OracleDevRel </a> (=邀请链接，请访问#oracle-db-graph)</li></ul></div></div>    
</body>
</html>