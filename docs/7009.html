<html>
<head>
<title>Build Testing Rules for Your Design System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的设计系统建立测试规则</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/build-testing-rules-for-your-design-system-e83500b25?source=collection_archive---------0-----------------------#2022-03-16">https://medium.com/quick-code/build-testing-rules-for-your-design-system-e83500b25?source=collection_archive---------0-----------------------#2022-03-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e7e1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解如何使用ESLint构建高级测试规则，以确保符合设计系统最佳实践</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/90c143c852b7457de998f723f9e73fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aZmQBt3xJhHdPnqD.jpg"/></div></div></figure><p id="5654" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">欢迎来到三部分<em class="ke">“用ESLint设计系统最佳实践”的第二部分。</em></p><p id="106a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">本系列旨在帮助您鼓励那些使用您的设计系统的人遵循您的最佳实践。</p><p id="d944" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在第1部分中涉及了很多理论(<a class="ae kf" rel="noopener" href="/quick-code/use-eslint-to-enforce-design-system-eaffbb1cd4e7"> <em class="ke">使用ESLint强制设计系统</em> </a>，如果你还没有读过，你应该从它开始)，比如ESLint是如何在引擎盖下工作的。我们用ESLint建立了一些简单的规则。</p><p id="d0a3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在第2部分中，我们将讨论如何构建更复杂的ESLint规则。</p><h1 id="8d55" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">快速回顾第1部分</h1><p id="18b6" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">在第一篇文章中，我们讨论了如何创建两条规则:</p><ul class=""><li id="dc52" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">避免元素中的内联样式</li><li id="1b28" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">确保工具提示不包含交互式内容。</li></ul><p id="9131" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们花点时间来谈谈为什么我们选择了这些规则。</p><p id="606f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，它们都是很好的规则，可以作为编写规则的入门。虽然我们在这些文章中讨论的实现可能还没有准备好投入生产，但是它们将有助于巩固您到目前为止所学到的知识。</p><p id="0884" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">除了作为教学辅助，这两条规则还有实际应用。</p><p id="1d04" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于我们的第一条规则，您可能希望鼓励您的最终用户与他们的样式实现保持一致，这可能有助于可读性和维护。CSS偏好因人而异，因库而异，所以您可能会发现这个特定的规则不适用于您的库。但是，针对特定属性非常有用。例如，您可能不希望在非交互元素上使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex#accessibility_concerns" rel="noopener ugc nofollow" target="_blank">标签索引，或者您可能希望鼓励对某个元素使用属性，比如对<code class="du lr ls lt lu b">button</code>组件使用<code class="du lr ls lt lu b">type</code>属性。</a></p><p id="bfca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们选择了第二条规则，因为我们将使用一个现有的设计系统作为例子，即使用Lion web组件编写的<a class="ae kf" href="https://backlight.dev/edit/5vtJtbY04aoD1dGKcsu1/introduction/doc/index.md" rel="noopener ugc nofollow" target="_blank"> Simba设计系统</a>。</p><p id="5f2d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在<a class="ae kf" href="https://backlight.dev/edit/5vtJtbY04aoD1dGKcsu1/tooltip/doc/index.md" rel="noopener ugc nofollow" target="_blank">工具提示元素</a>的Simba设计系统文档中，开头描述如下:</p><p id="5519" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">交互式内容不应放在工具提示内容槽中。工具提示只是为了显示附加信息。</p><p id="8ffe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这可能足以防止一些最终用户不使用<code class="du lr ls lt lu b">tooltip,</code>中的交互内容，但一些开发人员可能不会阅读(或记住)文档中的所有规则。有一个ESLint规则来执行这些规则，会让人们更容易记住并遵守你的框架的规则。</p><h1 id="593a" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">设置我们的项目</h1><p id="0414" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">让我们从克隆starter repo开始。回购涵盖了许多繁琐的设置，例如:</p><ul class=""><li id="0f26" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">安装软件包</li><li id="c2bb" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">ESLint样板文件</li><li id="7ba2" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">设置测试套件</li></ul><p id="fd86" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要开始回购，请遵循以下步骤:</p><ul class=""><li id="f7f1" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">使用<code class="du lr ls lt lu b">git clone <a class="ae kf" href="https://github.com/andrico1234/custom-eslint-tutorial/tree/0-begin-first-rule" rel="noopener ugc nofollow" target="_blank">https://github.com/andrico1234/custom-eslint-tutorial/tree/0-begin-first-rule</a></code>克隆回购</li><li id="761e" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">导航到项目目录</li><li id="ce09" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">用<code class="du lr ls lt lu b">npm i</code>安装你的依赖项</li><li id="3621" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">在代码编辑器中打开repo</li></ul><blockquote class="lv lw lx"><p id="077f" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">使用<a class="ae kf" href="https://eslint.org/docs/developer-guide/working-with-rules" rel="noopener ugc nofollow" target="_blank"> ESLint </a>指南设置演示回购。</p></blockquote><p id="7efa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以下是启动回购的简要概述:</p><h2 id="e3b8" class="mb kh hh bd ki mc md me km mf mg mh kq jr mi mj ks jv mk ml ku jz mm mn kw mo bi translated">库/规则</h2><p id="d61a" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated"><code class="du lr ls lt lu b">lib/rules</code>包含我们的规则。我们已经通过编写样板文件为您准备了第一个。根据<a class="ae kf" href="https://eslint.org/docs/developer-guide/working-with-rules" rel="noopener ugc nofollow" target="_blank"> <em class="ke">使用规则</em> ' </a>的建议，我们已经向文件添加了一些JSDoc注释。这将为您编写lint逻辑提供一些非常好的智能感知。</p><h2 id="d4eb" class="mb kh hh bd ki mc md me km mf mg mh kq jr mi mj ks jv mk ml ku jz mm mn kw mo bi translated">测试/库/规则</h2><p id="c3b6" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated"><code class="du lr ls lt lu b">tests/lib/rules</code>包含我们将为我们的规则编写的测试。我们为<code class="du lr ls lt lu b">no-inline-styles</code>增加了一些，但如果你喜欢，欢迎你添加更多。我们使用ESLint的内置<a class="ae kf" href="https://eslint.org/docs/developer-guide/nodejs-api#ruletester" rel="noopener ugc nofollow" target="_blank"> RuleTester </a>来测试我们的规则。我们已经创建了一个<code class="du lr ls lt lu b">RuleTester</code>的实例，并用几个有效和无效的案例来调用<code class="du lr ls lt lu b">run</code>。</p><p id="e69e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lr ls lt lu b">valid</code>是一个不应该报告林挺错误的字符串化JavaScript数组。</p><p id="b3fc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lr ls lt lu b">invalid</code>是包含两个属性的对象数组:<code class="du lr ls lt lu b">code</code>和<code class="du lr ls lt lu b">errors</code>。<code class="du lr ls lt lu b">code</code>是报告林挺错误的字符串化JavaScript。<code class="du lr ls lt lu b">errors</code>属性是一个对象数组。这些对象可以保存不同类型的断言，因此我们不仅可以检查代码片段是否不符合lint规则，还可以检查我们得到的错误消息以及错误在IDE中的位置，这就是VSCode如何确定在哪里放置曲线。</p><p id="8bd7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦您熟悉了repo，您就可以通过运行<code class="du lr ls lt lu b">npm test</code>来启动测试运行程序。每当您对规则文件进行更改时，测试运行程序将会运行，这将在出现问题时提供即时反馈，或者更有希望是正确的</p><h1 id="0938" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">创建简单的ESLint规则</h1><p id="c504" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">如果<code class="du lr ls lt lu b">lit</code>元素包含内联样式，我们将编写的第一条规则将显示一条错误消息。</p><h2 id="0f31" class="mb kh hh bd ki mc md me km mf mg mh kq jr mi mj ks jv mk ml ku jz mm mn kw mo bi translated">创建我们的访问者函数</h2><p id="4b20" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">让我们从跳转到<code class="du lr ls lt lu b">lib/rules/no-inline-styles.js</code>文件开始。</p><p id="6e99" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您还记得第一篇文章，当我们的JavaScript被解析时，<code class="du lr ls lt lu b">html</code>函数被表示为AST中的<code class="du lr ls lt lu b">TaggedTemplateExpression</code>节点。我们可以通过在规则的<code class="du lr ls lt lu b">create</code>函数中定义一个<code class="du lr ls lt lu b">TaggedTemplateExpression</code>来请求ESLint在到达这个节点时访问它。</p><p id="ce69" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不要忘记，并不是所有的<code class="du lr ls lt lu b">TaggedTemplateExpressions</code>都是我们想要运行lint规则的<code class="du lr ls lt lu b">html</code>表达式。我们要检查函数的名称，看看它是否是“html”。</p><p id="6a35" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">试着用上面的逻辑填充<code class="du lr ls lt lu b">create</code>函数，或者你可以偷看下面我们的答案。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="d51e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下一步是获取<code class="du lr ls lt lu b">node</code>并将其解析成有效的HTML AST。</p><h1 id="d325" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">解析我们的HTML</h1><p id="caa6" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">由于解析我们的<code class="du lr ls lt lu b">node</code>的逻辑不是我们规则的<em class="ke">业务逻辑</em>的一部分，我们在一个单独的实用程序目录中创建了一个类存根。所以跳到<code class="du lr ls lt lu b">utils/index.js</code>文件。</p><p id="bbdb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们需要做两件事:</p><ul class=""><li id="5daa" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">将我们的模板表达式转换成HTML字符串</li><li id="d6fa" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">将我们的字符串解析成HTML AST，并将其存储为实例变量</li></ul><p id="1dbb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于第一个任务，让我们采取简单的方法，就像我们的Lit表达式不包含动态内容一样。</p><p id="661d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">换句话说，我们只需要担心:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="feab" class="mb kh hh lu b fi mv mw l mx my">html`&lt;div style="display:none;"&gt;&lt;/div&gt;`;</span></pre><p id="b40b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">而不是:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="65a3" class="mb kh hh lu b fi mv mw l mx my">html`&lt;div style="${val}"&gt;&lt;/div&gt;`;</span></pre><p id="1fe0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将在下面提供解决方案，但是尝试使用我们在本文中介绍的工具来自己解决这个问题。</p><p id="4b85" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可以自己尝试一下，或者查看下面的解决方案:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><blockquote class="lv lw lx"><p id="eb7f" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">技巧1:不要忘记使用<a class="ae kf" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST浏览器</a>来理解如何从模板表达式中获取HTML字符串</p><p id="d00f" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">技巧2:要将字符串解析成HTML，使用parse5的<code class="du lr ls lt lu b"><a class="ae kf" href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md#parsefragment" rel="noopener ugc nofollow" target="_blank"><em class="hh">parseFragment</em></a></code>函数。</p></blockquote><h1 id="798c" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">templateExpressionToHtml是怎么回事？</h1><p id="a9fc" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">上面的代码忽略了更复杂的用例，只提取了<code class="du lr ls lt lu b">quasis</code>数组中的第一项。</p><p id="722f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这意味着对于下面的<code class="du lr ls lt lu b">lit</code>表达式，这些测试将运行良好:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="2efc" class="mb kh hh lu b fi mv mw l mx my">html`&lt;div style=""&gt;&lt;/div&gt;`;<br/>html`&lt;div style="display:none;"&gt;&lt;/div&gt;`;</span></pre><p id="6a4b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是因为这些<code class="du lr ls lt lu b">lit</code>表达式在模板文本中不包含任何JavaScript表达式。</p><p id="e123" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这意味着<code class="du lr ls lt lu b">node.quasi</code>物体看起来会像这样:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="1bff" class="mb kh hh lu b fi mv mw l mx my">{<br/>  quasi: {<br/>    quasis: ['&lt;div style="display:none;"&gt;&lt;/div&gt;'],<br/>		expressions: [],<br/>  }<br/>}</span></pre><p id="1069" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，这意味着下面的<code class="du lr ls lt lu b">lit</code>表达式的测试将会失败:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="d574" class="mb kh hh lu b fi mv mw l mx my">html`&lt;div style="${val}"&gt;&lt;/div&gt;`;</span></pre><p id="00f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为这个<code class="du lr ls lt lu b">lit</code>表达式在模板文本中包含了一个JavaScript表达式，所以<code class="du lr ls lt lu b">node.quasi</code>对象看起来会像这样:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="c3ee" class="mb kh hh lu b fi mv mw l mx my">{<br/>  quasi: {<br/>    quasis: ['&lt;div style="', '"&gt;&lt;/div&gt;'],<br/>		expressions: ['val'],<br/>  }<br/>}</span></pre><p id="3ddd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第三个测试用例将会失败，直到我们完全实现了<code class="du lr ls lt lu b">templateExpressionToHtml</code>函数。</p><p id="8416" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您已经运行了测试，所有有效的案例应该仍然是通过的，所有无效的案例应该是失败的。这是一个很好的指标，可以看出我们的TemplateAnalyzer的构造函数中是否存在任何基本的解析问题。</p><blockquote class="lv lw lx"><p id="5845" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">上面的代码片段是一个非常简化的例子，与ESLint将JavaScript解析成的AST结构不匹配。</p></blockquote><h1 id="7a47" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">创建我们的访问者函数</h1><p id="c21c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">下一步是为我们的分析器创建一个遍历函数。这将进入每个HTML节点，就像ESLint对JavaScript所做的那样，它将调用一个访问者函数，我们将使用该函数来进行断言。</p><p id="6743" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它会把我们的访问者函数作为一个输入，然后访问每个节点，调用我们的访问者。</p><p id="c709" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了简单起见，我们需要检查节点是否是一个元素，然后调用正确的访问者。不要担心其他节点类型，比如注释节点或文本节点。</p><blockquote class="lv lw lx"><p id="2eb1" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">如果您不确定如何实现visitor。你可以从第一篇文章回到<a class="ae kf" href="https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>。</p></blockquote><p id="6650" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的遍历函数将:</p><ul class=""><li id="1879" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">取一个名为<code class="du lr ls lt lu b">visitors</code>的对象，它包含了我们的访问者函数</li><li id="3d81" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">访问<code class="du lr ls lt lu b">this.ast</code>的每个子节点</li><li id="e951" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">为每个元素节点调用<code class="du lr ls lt lu b">element</code>访问者函数</li></ul><p id="321a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦实现，<code class="du lr ls lt lu b">traverse</code>函数将看起来像这样:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="8d33" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是该函数正在做的事情:</p><ul class=""><li id="a331" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">声明了处理核心逻辑的函数<code class="du lr ls lt lu b">visit</code>。</li><li id="638a" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">如果没有<code class="du lr ls lt lu b">node</code>出现，<code class="du lr ls lt lu b">visit</code>会提前返回</li><li id="b5f9" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><code class="du lr ls lt lu b">visit</code>检查我们的节点是否是一个HTML元素</li><li id="3fea" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">如果是，<code class="du lr ls lt lu b">visit</code>调用我们的访客函数</li><li id="9b18" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><code class="du lr ls lt lu b">visit</code>用子节点递归调用。</li></ul><p id="9551" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">剩下的唯一要实现的功能是<code class="du lr ls lt lu b">isElement</code>助手。这个助手将把一个<code class="du lr ls lt lu b">node</code>作为参数，并检查<code class="du lr ls lt lu b">node.tagName</code>值是否正确。</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="3432" class="mb kh hh lu b fi mv mw l mx my">isElement(node) {<br/>    return !!node.tagName;<br/>}</span></pre><h1 id="6ac6" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">撰写我们的断言</h1><p id="0ad5" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">现在我们可以开始写断言了，让我们重温一下ESLint规则。让我们使用新的visitor函数来访问每个元素。</p><blockquote class="lv lw lx"><p id="198c" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">这个简单的助手是受T21的启发。</p></blockquote><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="d17d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们现在可以通过修复失败的测试来继续TDD方式。第一个失败的测试针对以下情况:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="5f8b" class="mb kh hh lu b fi mv mw l mx my">html`&lt;div style=""&gt;&lt;/div&gt;`;</span></pre><p id="689e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个例子失败了，因为存在<code class="du lr ls lt lu b">style</code>属性。如果属性存在，我们应该报告一个ESLint错误。在继续之前，花几分钟时间尝试并实现属性检查。如果您不确定节点的形状，不要忘记使用AST explorer。</p><p id="0cbe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下一步是报告错误，我们将使用ESLint提供的<code class="du lr ls lt lu b"><a class="ae kf" href="http://context.report" rel="noopener ugc nofollow" target="_blank">context.report</a></code>函数来完成。<code class="du lr ls lt lu b">report</code>函数接受一个对象，我们将使用它来提供值:</p><ol class=""><li id="57d3" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd mz lj lk ll bi translated"><code class="du lr ls lt lu b">message</code>，也就是<code class="du lr ls lt lu b">no-inline-styles</code></li><li id="0958" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd mz lj lk ll bi translated"><code class="du lr ls lt lu b">node</code>，这将是我们的ESLint节点。</li></ol><p id="5a7f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">花些时间浏览一下AST，并亲自尝试一下。如果除了一个测试之外，所有的测试都通过了，那么您就知道您已经实现了一个通过的解决方案</p><p id="f5af" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">解决方案如下:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="5d41" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">返回模板表达式Html</h1><p id="49b0" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">我们需要做的最后一件事是修复最终失败的测试。这意味着我们需要对我们的<code class="du lr ls lt lu b">templateExpressionToHtml</code>函数进行修改。</p><p id="de3e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为我们节点的<code class="du lr ls lt lu b">quasi</code>值如下所示:</p><pre class="ix iy iz ja fd mr lu ms mt aw mu bi"><span id="cf36" class="mb kh hh lu b fi mv mw l mx my">{<br/>  quasi: {<br/>    quasis: ['&lt;div style="', '"&gt;&lt;/div&gt;'],<br/>		expressions: ['val'],<br/>  }<br/>}</span></pre><p id="9cdb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们需要做的就是按照下面的模式来调和它们:准[0] →表达式[0] →准[1] →等等。</p><p id="4d6b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这听起来像是一个简单循环的工作！</p><p id="1916" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为我们不关心表达式的值，所以我们可以应用一个占位符来帮助区分它和HTML字符串的其余部分。这有助于我们稍后在HTML遍历器中运行检查。</p><p id="3885" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将复制<a class="ae kf" href="https://github.com/43081j/eslint-plugin-lit#readme" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-lit </a>用于自己占位符的占位符模板:<code class="du lr ls lt lu b">{{__Q:${i}__}}</code>。</p><p id="4a0c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">试着写一个循环，一旦最终测试通过，你就会知道你成功了。下面是<code class="du lr ls lt lu b">templateExpressionToHtml</code>函数完成后的样子:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><blockquote class="lv lw lx"><p id="030c" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">这个语法没有什么特别的。它足够具体，因此不会与我们的任何JavaScript代码冲突。表达式的唯一标识符就是表达式在数组中的位置。</p></blockquote><p id="fc0b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们一步步来:</p><ul class=""><li id="58cd" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated"><code class="du lr ls lt lu b">value</code>用一个空字符串初始化，用来构建HTML</li><li id="b897" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">我们计算<code class="du lr ls lt lu b">quasis</code>数组的长度，这将用于通知我们的循环的迭代计数。</li><li id="c8b0" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">我们开始我们的循环，我们:<br/>–通过当前索引<br/>访问quasi–通过当前索引<br/>访问表达式–将当前quasi追加到我们的<code class="du lr ls lt lu b">value</code>字符串<br/>–如果<code class="du lr ls lt lu b">expression</code>存在，我们也将它追加到<code class="du lr ls lt lu b">value</code>。</li><li id="dbf1" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">我们返回<code class="du lr ls lt lu b">value</code>，现在我们可以用它来解析成HTML AST。</li></ul><p id="4b4c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了真正切中要害，让我们运行以下代码片段的循环:</p><p id="d1f9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">提醒一下，我们将得到的节点如下所示:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><ul class=""><li id="e3bf" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">我们将使用<code class="du lr ls lt lu b">value</code>来构建HTML</li><li id="ba67" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">我们将查看<code class="du lr ls lt lu b">node.quasi.quasis</code>的长度来确定循环的迭代次数。在这种情况下，数组中有两个元素。一个用于<code class="du lr ls lt lu b">&lt;div style="</code>，另一个用于<code class="du lr ls lt lu b">"&gt;&lt;/div&gt;</code>。</li><li id="0bcd" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">循环1:<br/>–获取第一个quasi，<code class="du lr ls lt lu b">&lt;div style="</code>，并将其添加到我们的<code class="du lr ls lt lu b">value</code>字符串中。<br/>——因为一个元素存在于<code class="du lr ls lt lu b">expressions</code>数组的第一个索引中，我们将为<code class="du lr ls lt lu b">val<br/></code>创建一个占位符——在第一次循环迭代结束时，我们的<code class="du lr ls lt lu b">value</code>看起来像<code class="du lr ls lt lu b">&lt;div style="{{__Q:i__}}</code></li><li id="20cc" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">循环2:<br/>–获取第二个quasi，<code class="du lr ls lt lu b">"&gt;&lt;/div&gt;</code>，并将其添加到我们的<code class="du lr ls lt lu b">value</code>字符串中。<br/>——因为在<code class="du lr ls lt lu b">expressions</code>数组的第二个索引中不存在元素，我们跳过这一步<br/>——在第二次循环迭代结束时，我们的<code class="du lr ls lt lu b">value</code>看起来像<code class="du lr ls lt lu b">&lt;div style="{{__Q:i__}}"&gt;&lt;/div&gt;</code></li><li id="882c" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">我们返回完全格式化的<code class="du lr ls lt lu b">value</code>字符串，它准备好被解析成HTML AST。</li></ul><p id="6bc6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在实现了<code class="du lr ls lt lu b">templateExpressionToHtml</code>函数之后，整个测试套件都通过了，希望你的也能通过！</p><blockquote class="lv lw lx"><p id="584d" class="ji jj ke jk b jl jm ii jn jo jp il jq ly js jt ju lz jw jx jy ma ka kb kc kd ha bi translated">这一系列的解释可能会让人觉得矫枉过正。关于拟和表达式的概念可能会令人困惑，所以我们想在它们上面多花一点时间。</p></blockquote><h1 id="5fb4" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">ESLint的局限性</h1><p id="82fc" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">根据定义，我们使用像ESLint这样的静态分析工具，在不运行代码的情况下检查代码。我们可以使用ESLint来标记代码中的代码风格问题，就像我们在本文中所做的那样。</p><p id="b747" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">ESLint不能做的是运行我们的代码，并在输出中报告错误。因此，ESLint无法报告以下代码片段的问题:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="a8ed" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是因为我们作为值传递的表达式不会被ESLint计算。</p><h1 id="ed56" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">更进一步</h1><p id="e180" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">我们已经介绍并学习了如何构建更高级的ESLINT规则来实施设计系统最佳实践。</p><p id="32be" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我们的下一篇也是最后一篇文章中，我们将更进一步。我们将编写一个更复杂的规则以及一些单元测试。我们将为现有设计系统的<code class="du lr ls lt lu b">Tooltip</code>组件实现实现一个ESLint规则。这个规则将特别有用，因为它将确保组件以其预期的方式使用，并且它将避免棘手的可访问性问题，这些问题可能会排除所有人使用该组件</p></div><div class="ab cl na nb go nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ha hb hc hd he"><p id="9fba" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">原载于</em><a class="ae kf" href="https://backlight.dev/blog/best-practices-w-eslint-part-2" rel="noopener ugc nofollow" target="_blank"><em class="ke">https://back light . dev</em></a><em class="ke">作者:</em><a class="ae kf" href="https://twitter.com/AndricoKaroulla" rel="noopener ugc nofollow" target="_blank">@ AndricoKaroulla</a><em class="ke">2022年1月14日。</em></p></div><div class="ab cl na nb go nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ha hb hc hd he"><p id="5806" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">沙箱:</p><p id="197a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae kf" href="https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js </a></p><p id="b785" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">资源:</p><ul class=""><li id="1694" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated"><a class="ae kf" href="https://backlight.dev/edit/5vtJtbY04aoD1dGKcsu1/introduction/doc/index.md" rel="noopener ugc nofollow" target="_blank">辛巴设计系统</a></li><li id="d6d0" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><a class="ae kf" href="https://github.com/andrico1234/custom-eslint-tutorial/tree/0-begin-first-rule" rel="noopener ugc nofollow" target="_blank"> Github回购克隆</a></li><li id="ba5d" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><a class="ae kf" href="https://eslint.org/docs/developer-guide/working-with-rules" rel="noopener ugc nofollow" target="_blank"> ESLint 指南 (T1)</a></li><li id="2e16" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">(T2) RuleTester (T3)</li><li id="a9a0" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">◎片 名 AST Explorer (T5)</li><li id="6d34" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><a class="ae kf" href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md#parsefragment" rel="noopener ugc nofollow" target="_blank"> parseFragment </a></li><li id="922f" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><a class="ae kf" href="https://github.com/43081j/eslint-plugin-lit#readme" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-lit (T9)</a></li></ul></div></div>    
</body>
</html>