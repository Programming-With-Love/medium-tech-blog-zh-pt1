<html>
<head>
<title>Himeji: A Scalable Centralized System for Authorization at Airbnb</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">姬路一个可扩展的Airbnb授权中心系统</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/himeji-a-scalable-centralized-system-for-authorization-at-airbnb-341664924574?source=collection_archive---------1-----------------------#2021-04-20">https://medium.com/airbnb-engineering/himeji-a-scalable-centralized-system-for-authorization-at-airbnb-341664924574?source=collection_archive---------1-----------------------#2021-04-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="01db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由<a class="ae jc" href="https://www.linkedin.com/in/alanyao" rel="noopener ugc nofollow" target="_blank">阿兰·姚</a>、<a class="ae jc" href="https://www.linkedin.com/in/pawardipak/" rel="noopener ugc nofollow" target="_blank">迪帕克·帕瓦尔</a>、<a class="ae jc" href="https://www.linkedin.com/in/yujia-wu/" rel="noopener ugc nofollow" target="_blank">布莱尔·吴</a>和<a class="ae jc" href="https://www.linkedin.com/in/abhishek-parmar-924b529a/" rel="noopener ugc nofollow" target="_blank">阿布舍克·帕尔马</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6dc7592466af156a062135cd4aa3d78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cMsnNUL3oXNj33QB"/></div></div></figure><h1 id="e1d4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问题是</h1><p id="8d83" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在过去的几年里，Airbnb工程从单一的Ruby on Rails架构转向了面向服务的架构。在我们的Rails架构中，每个资源都有一个API来访问底层数据。这些API有授权检查来保护敏感数据。因为只有一种方法可以访问资源的数据，所以管理这些检查很容易。在向SOA过渡的过程中，我们转向了分层架构，其中有包装数据库的数据服务和来自多个数据服务的表示服务。将许可检查从monolith转移到SOA的最初方法是将这些检查转移到表示服务。然而，这导致了几个问题:</p><ol class=""><li id="a7ff" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated"><strong class="ig hi">重复且难以管理的授权检查:</strong>提供对相同底层数据的访问的多个表示服务通常具有重复的授权检查代码。在某些情况下，这些检查变得不同步并且难以管理。</li><li id="a830" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated"><strong class="ig hi">扇出到多个服务:</strong>大多数授权检查都需要调用其他服务。这很慢，负载难以维持，并且影响了整体性能和可靠性。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/a3a63b014ad6753f2d60a3b5865141df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A2kdtTr_8sMQB3Mx"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Early authorization checks</figcaption></figure><h1 id="6088" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决方案</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ll"><img src="../Images/3620241dc4fa528ddd607c701505b9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/0*vLMmJuKbeDge1N5T"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Himeji-based authorization checks</figcaption></figure><p id="33a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这些问题，我们做了两项改变:</p><ol class=""><li id="4e12" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">我们将授权检查转移到了数据服务，而不是只在表示服务中执行授权检查。这帮助我们减少了重复和不一致的检查问题。</li><li id="1236" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">我们创建了<strong class="ig hi">姬路</strong>，一个基于<a class="ae jc" href="https://research.google/pubs/pub48190/" rel="noopener ugc nofollow" target="_blank">桑给巴尔</a>的集中授权系统，从数据层调用。它存储许可数据，并作为事实的中心来源执行检查。我们不是在读取时散开，而是在资源发生变化时写入所有权限数据。考虑到我们繁重的读取工作负载，我们在写入而不是读取时扇出。</li></ol><h1 id="7fc9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">应用程序接口</h1><p id="7b33" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">姬路为数据服务公开了一个检查API来执行授权检查。API签名如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="70cd" class="lr jq hh ln b fi ls lt l lu lv">// Can the principal do relation on entity?<br/>boolean check(entity, relation, principal)</span></pre><p id="dfcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">权限检查如下所示，即“用户123可以写清单10的描述吗？":</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="5d21" class="lr jq hh ln b fi ls lt l lu lv">check(entity: “LISTING : 10 : DESCRIPTION”, <br/>      relation: WRITE, <br/>      principal: User(123))</span></pre><p id="b3fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">姬路将此解释为“用户123是可以写入清单10的描述的用户集合中的一员吗？".</p><h1 id="7368" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">储存；储备</h1><p id="1cc7" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">与桑给巴尔岛相似，姬米吉岛的基本存储单位是形式为<code class="du lw lx ly ln b">entity # relation @ principal</code>的<strong class="ig hi">元组</strong>。</p><ul class=""><li id="ef08" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb lz ky kz la bi translated">一个<strong class="ig hi">实体</strong>就是三重<code class="du lw lx ly ln b">(entity type : entity id : entity part)</code>；这来自于自然语言的方法:<code class="du lw lx ly ln b">LISTING : 10 : DESCRIPTION</code> →列表10的描述。</li><li id="199b" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">实体id </strong>是真理数据源中的对应id。</li><li id="3a4a" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">实体类型</strong>定义应用的数据权限。示例:<code class="du lw lx ly ln b">LISTING</code>、<code class="du lw lx ly ln b">RESERVATION</code>、<code class="du lw lx ly ln b">USER</code></li><li id="77d8" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">实体零件</strong>是可选组件。示例:<code class="du lw lx ly ln b">DESCRIPTION</code>、<code class="du lw lx ly ln b">PRICING</code>、<code class="du lw lx ly ln b">WIFI_INFO</code></li><li id="65d8" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">关系</strong>描述关系，像<code class="du lw lx ly ln b">OWNER</code>、<code class="du lw lx ly ln b">READ</code>或<code class="du lw lx ly ln b">WRITE</code>一样，但可以是特定于用例的；一些示例包括用于保留主机的<code class="du lw lx ly ln b">HOST</code>和用于拒绝访问列表的<code class="du lw lx ly ln b">DENY_VIEW</code>。</li><li id="309d" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">主体</strong>或者是类似<code class="du lw lx ly ln b">User(123)</code>的认证用户身份，或者是类似<code class="du lw lx ly ln b">Reference(LISTING:15)</code>的另一个实体。</li></ul><h1 id="4371" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">配置</h1><p id="10a5" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">如果我们必须为所检查的每个确切权限编写一个元组，那么数据量和反规范化将呈指数级增长。例如，我们必须同时写<code class="du lw lx ly ln b">LISTING : 10 # WRITE @ User(123)</code>和<code class="du lw lx ly ln b">LISTING : 10 # READ @ User(123)</code>以便列表所有者能够读写。</p><p id="3a10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于桑给巴尔配置，我们使用基于YAML的配置语言，该语言允许通过集合代数解析权限检查，允许开发人员将检查映射到集合操作:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="9758" class="lr jq hh ln b fi ls lt l lu lv">LISTING:<br/>  '#WRITE':<br/>    union:<br/>      - '#WRITE'<br/>      - '#OWNER'<br/>  '#READ':<br/>    union:<br/>      - '#READ'<br/>      - '#WRITE'</span></pre><p id="d114" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设用户123是清单10的所有者。那么数据库将会有元组<code class="du lw lx ly ln b">LISTING : 10 # OWNER @ User(123)</code>。</p><p id="e0b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们请求<code class="du lw lx ly ln b">check(entity: "LISTING : 10", relation: WRITE, userId: 123)</code>时，姬路解译为<code class="du lw lx ly ln b">LISTING # READ</code>为<code class="du lw lx ly ln b">READ</code> &amp; <code class="du lw lx ly ln b">WRITE</code>的并集，而传递性的<code class="du lw lx ly ln b">LISTING # WRITE</code>为<code class="du lw lx ly ln b">WRITE</code> &amp; <code class="du lw lx ly ln b">OWNER</code>的并集。因此，它将从其数据库中获取以下内容，以及属于<code class="du lw lx ly ln b">LISTING # WRITE</code>集合的任何匹配:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="76f7" class="lr jq hh ln b fi ls lt l lu lv">Query LISTING : 10 # WRITE @ User(123) =&gt; Empty<br/>Query LISTING : 10 # OWNER @ User(123) =&gt; Match User(123)</span></pre><p id="993d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，例如，用户123只需要让<code class="du lw lx ly ln b">LISTING : 10 # OWNER @ User(123)</code>在<code class="du lw lx ly ln b">LISTING : 10 # WRITE</code>集合中。</p><h1 id="39dd" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><p id="b185" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们观察到，Airbnb上的实体由于它们的存在而频繁地向其他实体授予访问权限。例如，预订的客人可以访问列表的位置，以及列表的其他信息。我们用元组来表示这个用例，其中主体是对实体的引用，即<code class="du lw lx ly ln b">LISTING : $id # RESERVATION @ Reference(RESERVATION : $reservationId)</code>。这允许我们表达这样的概念，即在列表的“预订”集合中的预订的“客人”集合中的用户在<code class="du lw lx ly ln b">LISTING : LOCATION # READ</code>集合中，从而最小化需要存储的数据量:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="8886" class="lr jq hh ln b fi ls lt l lu lv">LISTING:<br/>  LOCATION:<br/>    '#READ':<br/>      union:<br/>        - #OWNER<br/>        - LISTING : $id # RESERVATION @ <br/>          Reference(RESERVATION : $reservationId # GUEST)</span></pre><p id="5f5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法与Zanzibar的不同之处在于，这种元组在主体中不包含关系(即<code class="du lw lx ly ln b">Reference(RESERVATION:$id # GUEST)</code>)。被引用实体后面的关系是静态的，从配置中检索。以清单示例为例，然后对照其他用例进行检查，我们发现通常会在多个关系后面跟随一个引用。在我们的产品中，两个实体类型之间使用的关系集没有变化；集合中的变更意味着产品变更，适用于所有实体类型。如果两个实体类型(即<code class="du lw lx ly ln b">Reference(RESERVATION:$id # GUEST)</code>、<code class="du lw lx ly ln b">Reference(RESERVATION:$id # COTRAVELLER)</code>、<code class="du lw lx ly ln b"> Reference(RESERVATION:$id # BOOKER)</code>、…)之间的关系集具有大小<code class="du lw lx ly ln b">M</code>，则为这些实体类型中的每一个写一个元组会导致<code class="du lw lx ly ln b">N*M</code>个元组。通过将关系拉入配置，我们将存储数据的大小减少到<code class="du lw lx ly ln b">N</code>。</p><p id="f6e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在读取执行时，假设数据库中存储了以下元组:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="3c9f" class="lr jq hh ln b fi ls lt l lu lv">LISTING : 10 # OWNER @ User(123)<br/>LISTING : 10 # RESERVATION @ Reference(RESERVATION : 500)<br/>RESERVATION : 500 # GUEST @ User(456)</span></pre><p id="5346" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果一个客户发送这样的请求:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="85ce" class="lr jq hh ln b fi ls lt l lu lv">check(LISTING : 10 : LOCATION # READ, User(456))</span></pre><p id="b349" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，根据配置，姬路基于来自请求的信息和上述配置发出第一次数据库提取:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="de6f" class="lr jq hh ln b fi ls lt l lu lv">Query LISTING : 10 # RESERVATION =&gt; Match Reference(RESERVATION:500)<br/>Query LISTING : 10 # OWNER @ User(456) =&gt; Empty</span></pre><p id="6873" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">姬路随后将发出第二个DB获取，替换为找到的预订的id，其中匹配指示用户456在允许读取清单10的位置的用户集合中。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e4f2" class="lr jq hh ln b fi ls lt l lu lv">Query RESERVATION : 500 # GUEST @ User(456) =&gt; Match User(456)</span></pre><h1 id="4ced" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">架构和性能</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/1da7bd1f5e39ef80abef6b4117ed878c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mu6CzNQKbugA7iZu"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Himeji Architecture</figcaption></figure><p id="8196" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">姬路分三层:</p><ul class=""><li id="14b4" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb lz ky kz la bi translated"><strong class="ig hi">编排层</strong>接收来自客户端的请求，负责根据配置逻辑发布数据获取，并解析结果。编排层通过一致的哈希路由到缓存层。</li><li id="6bbb" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated">被分片和复制的<strong class="ig hi">缓存层</strong>(每个AZ每个分片一个实例)，负责在未命中时过滤内存和删除数据库中的负载。通过一致的散列法，每个碎片被分配一组数据。我们的目标是缓存命中率达到98%左右。</li><li id="a918" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">数据层</strong>，由逻辑上分片的数据库组成。</li></ul><p id="d577" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相对于桑给巴尔岛的设置，我们对姬路所做的最重要的改变是:</p><ol class=""><li id="8951" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">将请求编排层与缓存层分开，这样就可以更容易地更新编排层，而无需重新启动缓存。</li><li id="f0c5" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">基于<a class="ae jc" rel="noopener" href="/airbnb-engineering/capturing-data-evolution-in-a-service-oriented-architecture-72f7c643ee6f">发布的来自数据库</a>的突变，使缓存碎片无效。</li><li id="98a9" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">使用Amazon <a class="ae jc" href="https://aws.amazon.com/rds/aurora/?aurora-whats-new.sort-by=item.additionalFields.postDateTime&amp;aurora-whats-new.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> Aurora </a>进行数据库存储，作为我们<a class="ae jc" rel="noopener" href="/airbnb-engineering/our-journey-towards-cloud-efficiency-9c02ba04ade8">云之旅</a>的一部分，这与桑给巴尔岛使用Spanner不同。</li></ol><p id="953a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在可用性方面实施了与桑给巴尔相同的可靠性(对冲、分层缓存)和减载功能。</p><p id="27ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">姬路已在生产中提供检查服务约一年，其吞吐量已从2020年3月的0增长到2021年3月的<strong class="ig hi"> 85万</strong> <strong class="ig hi">实体/秒</strong>，同时保持了去年的可用性和延迟目标:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="f1a9" class="lr jq hh ln b fi ls lt l lu lv">Availability  99.9990%<br/>P50 Latency   1.8 ms<br/>P95 Latency   7   ms<br/>P99 Latency   12  ms</span></pre><h1 id="437c" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">工具作业</h1><p id="31c2" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">为了缩短集成时间并推动开发人员采用，我们构建了一些工具，例如:</p><ul class=""><li id="b122" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb lz ky kz la bi translated"><strong class="ig hi">基于配置的回填:</strong>将现有权限检查迁移到姬路需要我们回填现有实体的权限元组。我们构建了一个基于Apache Airflow和Apache Spark的通用解决方案，而不是每个数据服务所有者构建自己的回填流程。服务所有者只需提供一个小的配置，该配置指示他们的元组应该如何从他们的数据库导出中形成。</li><li id="b603" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">自动代码生成:</strong>为了让入职更容易，我们提供了脚本来自动生成Java和Scala代码。</li><li id="e03b" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">胖客户端:</strong>我们提供了一个胖http客户端，具有日志记录、指标和迁移展示控件。</li><li id="f82c" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb lz ky kz la bi translated"><strong class="ig hi">用于调试和一次性任务的UI工具:</strong>调查一次性权限问题可能会变得繁琐，并且需要检查系统中写入的权限数据，因此我们构建了一个UI来分析数据并修复权限问题。</li></ul><h1 id="5311" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="278a" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">基于<a class="ae jc" href="https://www.usenix.org/system/files/atc19-pang.pdf" rel="noopener ugc nofollow" target="_blank">桑给巴尔</a>的姬路授权系统，统一了Airbnb的授权数据和逻辑。在引入它之前，跨不相交的逻辑片段维护一致性和性能是困难的。姬路用具有灵活逻辑配置的简单数据模型来集中所有产品和数据授权。姬路扩展了桑给巴尔的可扩展性和性能属性，并通过其高命中率分层分布式缓存降低了延迟。所有这些共同导致姬路一秒钟存储数百亿个关系和服务近百万个实体授权，同时保持低延迟和高可用性。</p><h1 id="4ab7" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">承认</h1><p id="c56d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">姬路之所以成为可能，得益于Airbnb团队许多成员的贡献。我们感谢该团队的前任和现任成员——Max、Alex Rosenblatt、Jefferson Lee、Divya Gupta、Clare Liu、Li、Leelakrishna Nukala、Karen Kim、Gary Leung、Ryan Flood、Tony Tran和Gurer Kiratli。此外，还要感谢我们现任和前任管理层对这项工作的大力支持——Anish Das Sarma、Vijaya Kaza、Jason Sobel、Bipin Suresh、Marc Blanchou、Raymie Stata和Aristotle Balogh。</p><p id="765a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这项工作以及许多令人兴奋的事情总是在Airbnb发生。如果你想加入我们，请查看我们的Airbnb招聘页面。</p><h1 id="747b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">商标属性</h1><p id="dede" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">“Rails”和“Ruby on Rails”是David Heinemeier Hansson的注册商标。</p><p id="e10b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Apache Kafka、Apache Airflow、Apache Spark和Apache是Apache Software Foundation在美国和/或其他国家的注册商标或商标。</p><p id="6a46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AWS和Amazon Aurora是Amazon.com公司或其附属公司在美国和/或其他国家的商标。</p><p id="7a33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java是Oracle和/或其附属公司的注册商标。</p><p id="324a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有商标都是其各自所有者的财产。这些的任何使用仅用于识别目的，并不意味着赞助或认可。</p></div></div>    
</body>
</html>