<html>
<head>
<title>Adding a domain layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">添加域层</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/adding-a-domain-layer-bc5a708a96da?source=collection_archive---------0-----------------------#2022-12-13">https://medium.com/androiddevelopers/adding-a-domain-layer-bc5a708a96da?source=collection_archive---------0-----------------------#2022-12-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3858c91fbdaae1899fbad7843fa8f8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2TKwNfb65qVbd99E4QoKQ.png"/></div></div></figure><div class=""/><p id="7c70" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将解释我们如何在Android应用程序的<a class="ae jn" href="https://github.com/android/nowinandroid" rel="noopener ugc nofollow" target="_blank">中添加</a><a class="ae jn" href="https://developer.android.com/topic/architecture/domain-layer" rel="noopener ugc nofollow" target="_blank">域层</a>，以提高可读性、可伸缩性和可移植性。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jo"><img src="../Images/495e0b792ecb5a8525a6a6b104843053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qsUtntTd3E_Rr3mhYfBeg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">The domain layer sits between the UI and data layers</figcaption></figure><p id="1c28" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android应用程序架构中，领域层包含业务逻辑，即规定应用程序如何工作的规则。在本文的剩余部分，我将使用术语“逻辑”来指代“业务逻辑”，而不是“UI逻辑”或任何其他形式的逻辑。</p><p id="a98d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着应用程序变得越来越复杂，引入域层是很常见的，并使用它来封装复杂的逻辑或被许多屏幕级状态持有者重用的逻辑，如视图模型。</p><p id="05f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文所基于的拉取请求在这里是<a class="ae jn" href="https://github.com/android/nowinandroid/pull/342" rel="noopener ugc nofollow" target="_blank"/>。我简化并重新命名了一些类名，以关注核心概念。</p><h1 id="13fc" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">用例</h1><p id="5a33" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">领域层是通过将逻辑(通常来自UI层)移动到<em class="la">用例</em>中来创建的。用例是包含逻辑的函数(或具有单一公共方法的类)。他们执行单一的操作，该操作通常组合或转换来自存储库或其他用例的数据。</p><p id="d7a9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文中用例的<a class="ae jn" href="https://en.wikipedia.org/wiki/Naming_convention_(programming)" rel="noopener ugc nofollow" target="_blank">命名约定</a>(以及Android应用中的Now)遵循官方指南<a class="ae jn" href="https://developer.android.com/topic/architecture/domain-layer#conventions" rel="noopener ugc nofollow" target="_blank">:</a></p><ul class=""><li id="c5b7" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated"><em class="la">现在时态的动词</em>例如<code class="du lk ll lm ln b">Get</code></li><li id="27f3" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">名词/什么例如:T1</li><li id="80e9" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated"><code class="du lk ll lm ln b">UseCase</code>T20】后缀。</li></ul><p id="3614" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:<code class="du lk ll lm ln b"><a class="ae jn" href="https://github.com/android/nowinandroid/blob/56b3c1d0b950ed27051424ca6718743d7a3c6b97/core/domain/src/main/java/com/google/samples/apps/nowinandroid/core/domain/GetFollowableTopicsUseCase.kt" rel="noopener ugc nofollow" target="_blank">GetFollowableTopicUseCase</a></code></p><h1 id="6b55" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">过程</h1><p id="d4de" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">以下是我们所用流程的概述:</p><ul class=""><li id="8a35" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">识别视图模型中重复和复杂的逻辑</li><li id="50cf" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">创建适当命名的用例</li><li id="d6f5" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">将逻辑移到用例中</li><li id="ef6d" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">重构视图模型以依赖用例而不是存储库</li><li id="4396" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">为用例添加测试</li></ul><h1 id="f34c" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">识别重复的逻辑并创建用例</h1><p id="d737" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">下图显示了每个视图模型观察到的数据。“观察”列中的每个框代表逻辑，通常组合来自多个流的数据。每个方框代表一个用例的候选，相同颜色的方框表示重复的逻辑。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/bd4c801c758a1fb74b5f9ac2f81595a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWx3t4Po25x692oA0ROZ6w.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Diagram showing the logic contained by each ViewModel and use case candidates for that logic</figcaption></figure><p id="bcba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了可读性，图中省略了“用例”后缀。</p><h1 id="b8fc" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">将逻辑移到用例中</h1><p id="93a8" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">既然“命名事物”的困难部分已经完成，我们只需要将逻辑从每个视图模型移动到相关的<code class="du lk ll lm ln b">UseCase</code>中。让我们看一个例子。</p><p id="2bc8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">观察新闻文章的逻辑在三种不同的视图模型中使用。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/137262eae4bcc7a6a0f2a88d31afd84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoxqOIQLC72KjrzjISqTeQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Diagram showing duplicate logic in three ViewModels being moved into a single use case</figcaption></figure><p id="a65d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们来看看<code class="du lk ll lm ln b">BookmarksViewModel</code>里面的这个逻辑:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="d39a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事情是这样的:</p><ol class=""><li id="4541" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lx lh li lj bi translated">书签从<code class="du lk ll lm ln b">UserDataRepository</code>获得</li><li id="949c" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lx lh li lj bi translated">新闻资源(又名文章)从<code class="du lk ll lm ln b">NewsRepository</code>获得</li><li id="a4e1" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lx lh li lj bi translated">这两者结合起来创建一个书签新闻资源列表</li><li id="5d97" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lx lh li lj bi translated">该列表经过过滤，只显示书签新闻资源</li></ol><p id="038d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">步骤1–3的逻辑对于所有其他视图模型都是通用的，因此可以移到名为<code class="du lk ll lm ln b">GetSaveableNewsResourcesUseCase</code>的新用例中。代码如下:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h1 id="c466" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">领域层模块和模型</h1><p id="28ef" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">用例存在于领域层，为了清楚地将这一层与我们代码库的其余部分分开，我们创建了一个<code class="du lk ll lm ln b">:domain</code>模块。由用例创建的类，通常是由于组合了来自多个存储库的数据模型，也被移到了<code class="du lk ll lm ln b">:domain</code>模块中。</p><p id="f40c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个很好的例子是<code class="du lk ll lm ln b">SaveableNewsResource</code>数据类，它是由<code class="du lk ll lm ln b">NewsRepository</code>提供的<code class="du lk ll lm ln b">NewsResource</code>和使用来自<code class="du lk ll lm ln b">UserDataRepository</code>的书签列表计算的<code class="du lk ll lm ln b">isSaved</code>属性组合而成的。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/62a1af80c074121c8804555ea4081d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_c6DYKw31-dSWY-WRjH8gg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Diagram showing data layer classes (NewsResource and UserData) being combined into a domain layer class (SaveableNewsResource).</figcaption></figure><h1 id="0d9c" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">根据用例更新视图模型</h1><p id="56cb" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">现在我们已经创建了<code class="du lk ll lm ln b">GetSaveableNewsResourcesUseCase</code>，我们可以重构<code class="du lk ll lm ln b">BookmarksViewModel</code>来调用它。</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="e7de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ViewModel现在更简单，更容易阅读。从构造函数中可以清楚地看到这个类在做什么——获取可保存的新闻资源，并且不需要中间的<code class="du lk ll lm ln b">bookmarks</code>变量来存储来自用户数据存储库的数据。</p><p id="b04c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仍然有一些逻辑来过滤掉未加书签的新闻文章。我们可以将这个过滤逻辑转移到另一个用例(可能命名为<code class="du lk ll lm ln b">Get<strong class="ir ht">Saved</strong>NewsResourcesUseCase</code>)中，但是为一个对<code class="du lk ll lm ln b">filter</code>的调用创建一个全新的类可能不值得增加一个额外用例的复杂性。最终，由您决定将多少逻辑移入您的用例。</p><p id="9666" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其他视图模型现在可以根据我们的用例进行重构。添加任何常见的逻辑，如返回给定主题或作者的新闻资源的能力。</p><h1 id="7e1f" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">摘要</h1><p id="1715" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">我们对重复逻辑的每个区域重复了这个过程:</p><ul class=""><li id="bbda" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">选择视图模型</li><li id="31e4" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">将逻辑转移到用例中</li><li id="0cbf" class="lb lc hs ir b is lo iw lp ja lq je lr ji ls jm lg lh li lj bi translated">重构其他视图模型以使用用例</li></ul><p id="153e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，我们还<a class="ae jn" href="https://github.com/search?l=&amp;q=repo%3Aandroid%2Fnowinandroid+filename%3A%2AUseCaseTest.kt&amp;type=code" rel="noopener ugc nofollow" target="_blank">为每次使用cas添加了测试</a>，因为用例是简单的函数，所以非常容易测试！最终，通过添加领域层，我们的代码库更容易维护和扩展。</p><p id="2a7a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在<a class="ae jn" href="https://github.com/android/nowinandroid/blob/main/docs/ArchitectureLearningJourney.md" rel="noopener ugc nofollow" target="_blank">架构学习之旅</a>中阅读更多关于Android中领域层的内容，在官方Android开发者网站上阅读更多<a class="ae jn" href="https://developer.android.com/topic/architecture/domain-layer" rel="noopener ugc nofollow" target="_blank">的深度指导。</a></p></div></div>    
</body>
</html>