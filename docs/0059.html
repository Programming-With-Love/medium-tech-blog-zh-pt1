<html>
<head>
<title>Getting to Swift 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进入Swift 3</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/getting-to-swift-3-at-airbnb-79a257d2b656?source=collection_archive---------2-----------------------#2017-02-07">https://medium.com/airbnb-engineering/getting-to-swift-3-at-airbnb-79a257d2b656?source=collection_archive---------2-----------------------#2017-02-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3670" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">由</em> <a class="ae jd" href="https://twitter.com/chengyinliu" rel="noopener ugc nofollow" target="_blank"> <em class="jc">【刘】</em></a><em class="jc"/><a class="ae jd" href="https://github.com/kompfner" rel="noopener ugc nofollow" target="_blank"><em class="jc">【保罗】</em></a><em class="jc"/><a class="ae jd" href="https://twitter.com/michaelbachand" rel="noopener ugc nofollow" target="_blank"><em class="jc">迈克尔</em> </a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b77d09ba86420f4daa0d8d0ac413b734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRyt_nc-U0j7xGW0bMADOg.png"/></div></div></figure><p id="e25e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自Swift语言诞生以来，Airbnb就一直在使用它。我们已经看到了使用这种现代、安全、社区驱动的语言的诸多好处。</p><p id="b062" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">直到最近，我们代码库的很大一部分都在Swift 2中。我们刚刚完成了向Swift 3的迁移，正好赶上了支持Swift 2的Xcode的发布。</p><p id="40b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们希望与社区分享我们的迁移方法、Swift 3对我们应用的影响以及我们在此过程中获得的一些技术见解。</p><h1 id="a8c6" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">“不中断开发”的方法</h1><p id="0e70" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们有几十个模块和几个用Swift编写的第三方库，包括几千个文件和几十万行代码。好像这个Swift代码库的规模还不足以成为一个挑战，Swift 2和Swift 3模块不能相互导入的事实进一步复杂化了迁移过程。甚至导入Swift 2库的正确的Swift 3代码也不会编译。这种不兼容性使得并行代码转换变得困难。</p><p id="8403" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了确保我们能够逐步转换和验证我们的代码，我们首先创建了一个依赖图，对我们的36个Swift模块进行了拓扑排序。我们的升级计划如下:</p><ol class=""><li id="62d0" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">将CocoaPods升级到1.1.0(以支持必要的pod升级)</li><li id="d9be" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">将第三方pod升级到Swift 3版本</li><li id="c5f6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">按照拓扑顺序转换我们自己的模块</li></ol><p id="cafb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过与其他已经完成迁移的公司交谈，我们了解到冻结开发是一种常见的策略。如果可能的话，我们希望避免代码冻结，即使这意味着对那些进行移植的人来说增加了一些困难。由于转换工作不容易并行化，所有人都参与进来的方法将是低效的。此外，由于很难估计转换需要多长时间，我们希望确保我们可以在迁移期间继续发布新版本。</p><p id="215b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有三个人负责迁移。两个人专注于代码转换，第三个人专注于协调、与团队沟通和基准测试。</p><p id="48e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，包括准备工作，我们实际的项目时间表如下所示:</p><ul class=""><li id="48a3" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lh kz la lb bi translated">1周:调查和准备(一人)</li><li id="6075" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lh kz la lb bi translated">2.5周:转化(两人)，分析转化的影响，与更大的团队沟通(一人)</li><li id="5c9e" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lh kz la lb bi translated">2周:QA和bug修复(QA团队+各种iOS功能所有者)</li></ul><h1 id="3ee2" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Swift 3的影响</h1><p id="de7e" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">虽然我们对Swift 3的新语言功能感到兴奋，但我们也想了解该更新将如何影响我们的最终用户和整体开发者体验。我们密切关注Swift 3对发布IPA大小和调试构建时间的影响，因为这是迄今为止我们最大的两个Swift痛点。不幸的是，在尝试了不同的优化设置后，Swift 3在这两项指标上的得分仍然略有下降。</p><h2 id="0ae3" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">发布IPA大小</h2><p id="d077" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在迁移到Swift 3之后，我们看到我们发布的IPA增加了2.2MB。稍微挖掘一下就会发现，这几乎完全是由于Swift库的大小增加了(我们自己的二进制文件的大小几乎没有变化)。以下是我们发现的未压缩二进制文件大小增加的几个例子:</p><ul class=""><li id="0602" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lh kz la lb bi translated">libswiftFoundation.dylib:涨幅233.40% (3.8 MB)</li><li id="a607" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lh kz la lb bi translated">libswiftCore.dylib:增长11.76% (1.5兆字节)</li><li id="0322" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lh kz la lb bi translated">libswiftDispatch.dylib:上涨344.61% (0.8 MB)</li></ul><p id="5d3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鉴于Swift 3的库(如Foundation)的增强，这种变化是可以理解的。尽管如此，当备受期待的稳定的Swift ABI登陆时，应用程序应该不再需要遭受大小增加以从这些增强中受益。</p><h2 id="1b2e" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">调试构建时间</h2><p id="c408" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">迁移后，我们的调试构建时间慢了4.6%，比之前的6分钟多了16秒。</p><p id="4759" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们试图在Swift 2和Swift 3之间比较每个函数的编译时间，但是无法得出具体的结论，因为配置文件如此不同。然而，我们确实发现了一个函数，由于迁移，它的编译时间增加到了12秒。幸运的是，我们能够将它按摩回来，但它向我们展示了检查转换后的代码是否有像这样的异常值的重要性。像Xcode的<a class="ae jd" href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" rel="noopener ugc nofollow" target="_blank">Build Time Analyzer</a>这样的工具会有所帮助，或者你可以只<a class="ae jd" href="http://irace.me/swift-profiling" rel="noopener ugc nofollow" target="_blank">设置适当的Swift编译器标志并解析生成的构建日志</a>。</p><h2 id="8a65" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">运行时问题</h2><p id="4bd2" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">不幸的是，即使您的代码在Swift 3中编译后，移植工作也没有完成。Xcode代码转换工具不能保证相同的运行时行为。此外，正如我们将在后面讨论的，代码转换仍然涉及手工工作，并且存在一些问题。不幸的是，这可能意味着倒退。由于我们的单元测试覆盖率没有给我们足够的信心，我们不得不在新移植的应用上花费额外的QA周期。</p><p id="3edd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对新迁移的应用程序的第一次QA检查发现了几十个相当明显的问题。负责迁移的3人团队迅速解决了绝大多数问题(在几个小时内)，主要是通过应用本文档稍后讨论的一些技术。在初步排除了低悬的、高度可见的回归之后，iOS团队总体上剩下15个潜在的回归——其中3个是崩溃——需要在下一个应用版本发布之前进行调查。</p><h1 id="9443" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">代码转换过程</h1><p id="9afb" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们从从<code class="du lw lx ly lz b">master</code>创建一个新的<code class="du lw lx ly lz b">swift-3</code>分支开始。如前所述，我们逐个模块地处理代码转换，从叶模块开始，沿着依赖树向上。只要有可能，我们就并行转换不同的模块。当我们不能时，我们坐在一起，大声说出我们正在做什么，以避免碰撞。</p><p id="4101" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于每个模块，流程大致如下:</p><ol class=""><li id="f1ff" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">从<code class="du lw lx ly lz b">swift-3</code>分支创建一个新分支</li><li id="e4f9" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在模块上运行Xcode代码转换工具</li><li id="6cb2" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">提交和推送更改</li><li id="91cd" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">建设</li><li id="5234" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">手动修复大量构建错误</li><li id="198e" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">提交和推送更改</li><li id="a7b6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">重建</li><li id="a619" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">重复前面的3个步骤，直到完成</li></ol><p id="6ffa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当手动更新代码时，我们坚持“进行最直接的代码转换”的原则这意味着我们的目标不是在转换过程中提高代码的安全性。我们这样做有两个原因。首先，由于团队正在Swift 2中积极开发，这个过程是一场与时间的赛跑。其次，我们希望将引入回归的风险降至最低。</p><p id="d9a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，我们在一段时间内承担了这个项目，因为假期，工作比较慢。这意味着我们可以安全地走几天，而不用将<code class="du lw lx ly lz b">swift-3</code>重置为<code class="du lw lx ly lz b">master</code>，也不会落后太多。无论何时我们做了rebase，我们都使用<code class="du lw lx ly lz b">git rebase -Xours master</code>来尽可能多地保留<code class="du lw lx ly lz b">swift-3</code>，同时默认使用<code class="du lw lx ly lz b">master</code>中的代码来解决冲突。</p><p id="23bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦<code class="du lw lx ly lz b">swift-3</code>赶上了<code class="du lw lx ly lz b">master</code>，我们知道我们需要大约一天的时间来解决一些问题，然后才能舒服地合并它。不过，对于我们这样规模的iOS团队来说，<code class="du lw lx ly lz b">master</code>是一个移动的目标。因此，为了完成Swift 3迁移，我们强烈鼓励整个团队(不包括进行迁移的团队)在周六真正休假😄。</p><h1 id="32e0" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">值得一提的问题</h1><h2 id="2458" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">Objective-C中的块参数</h2><p id="7c53" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们遇到的一个最常见的问题是，Xcode没有自动给出修复建议，这与Objective-C和Swift之间的桥接块参数有关。考虑Objective-C头文件中的方法声明:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="9e5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Swift 2.3中，生成的接口是:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="eb82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Swift 3中，生成的接口是:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="d694" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很多事情都变了，但最重要的是<code class="du lw lx ly lz b">completionBlock</code>中的参数从隐式展开的可选参数变成了可选参数。这可能会破坏它在块内的使用。</p><p id="3734" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们决定，Swift 3最“字面”的翻译(不涉及Objective-C代码)是在程序块的顶部声明一个变量，该变量与参数同名，但被隐式展开:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="997e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样做，而不是在使用参数时实际解开参数，是最不可能破坏块中其他地方的语义的。在上面的例子中，像<code class="du lw lx ly lz b">if let someReview = review { /* … */ } </code>和<code class="du lw lx ly lz b">review ?? anotherReview</code>这样的后续语句将继续按预期工作。</p><h2 id="771c" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">隐式展开选项赋值中的类型推断</h2><p id="089a" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">另一个常见的(相关的)问题与Swift 3如何推断一个隐式展开的可选变量的类型有关。请考虑以下情况:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="b2b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Swift 2.3中，<code class="du lw lx ly lz b">result</code>被推断为<code class="du lw lx ly lz b">Int!</code>类型。在Swift 3中，它的类型是<code class="du lw lx ly lz b">Int?</code>。</p><p id="7c09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于block参数中列出的原因，最直接的解决方案是将变量声明为隐式取消包装的可选类型:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="88b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题出现得比预期的更频繁，因为桥接的Objective-C初始化器隐式返回未包装的选项。</p><h2 id="3342" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">单个函数的编译时爆炸</h2><p id="6702" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">偶尔，在我们的代码转换工作中，编译器会停止几分钟。</p><p id="9d92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的项目包含了一些需要大量复杂类型推理的函数。在正常情况下，编译这些代码只需要很少的时间。但是当它们包含编译错误时，它会使编译器陷入混乱。</p><p id="0e0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们的进度被这种类型的问题阻碍时，我们使用Xcode 的<a class="ae jd" href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" rel="noopener ugc nofollow" target="_blank">构建时分析器来帮助我们发现瓶颈在哪里。然后，我们可以将精力集中在这个功能上，打开转换代码、重新构建和转换更多代码的快乐循环。</a></p><h2 id="98ce" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">可选协议方法实现中的“未遂事件”</h2><p id="de99" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在Swift 3转换期间，可选协议方法很容易意外丢失。</p><p id="660d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du lw lx ly lz b">UICollectionViewDataSource</code>上考虑这种方法:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="9989" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您的类实现了<code class="du lw lx ly lz b">UICollectionViewDataSource</code>并声明了下面的方法:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="0b9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你能看出不同之处吗？很艰难。但是他们在那里。你的类不用更新定义的签名就可以很好地编译，因为它是一个可选的协议方法。</p><p id="c763" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，在某些情况下，编译器警告可以帮助您，但不是所有情况。重要的是，要用可选的方法检查实现协议的任何类型——像大多数UIKit委托和数据源协议——并验证它们的正确性。搜索像“<code class="du lw lx ly lz b">func collectionView(collectionView:</code>”这样的文本(注意第一个参数标签，这是Swift 2延期的可靠标志)可以帮助您在代码库中找到违规者。</p><h2 id="9870" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">具有默认方法实现的协议</h2><p id="03df" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">协议可能具有通过协议扩展提供的默认方法实现。如果一个协议的方法签名在Swift 2和Swift 3之间发生了变化，验证它是否在任何地方都发生了变化是很重要的。如果<em class="jc">或者</em>协议扩展的实现<em class="jc">或者</em>你的类型的实现是正确的，编译器会很高兴地编译，但是成功的编译不能保证<em class="jc">和</em>的实现都是正确的。</p><h2 id="6fc8" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">具有字符串原始值的枚举</h2><p id="7078" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在Swift 3中，命名约定规定enum用例为<code class="du lw lx ly lz b">lowerCamelCase</code>。Xcode代码转换工具会自动对任何现有的枚举进行适当的更改。然而，它跳过了原始值类型为<code class="du lw lx ly lz b">String</code>的枚举。这样做有一个很好的理由——可以用与枚举用例名称匹配的<code class="du lw lx ly lz b">String</code>来初始化这些枚举之一。如果更改枚举事例名，就有可能破坏初始化。您可能想自己通过小写一些enum用例来“完成这项工作”，但是只有在您确信它不会破坏某处基于<code class="du lw lx ly lz b">String</code>的初始化时才这样做。</p><h2 id="1f6e" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">第三方库API变化</h2><p id="4213" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">像大多数应用程序一样，我们对第三方库有一些依赖。迁移需要更新任何用Swift编写的库。这应该是显而易见的，但值得一提的是:请仔细阅读发行说明，尤其是当您的依赖项经历了重大版本变更时(这很可能是在更改语言版本时)。它帮助我们发现了一些非显而易见的API变化，这是编译器无法帮助我们的。</p><h1 id="7bba" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">后续步骤</h1><p id="2d62" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">咻！我们的<code class="du lw lx ly lz b">master</code>分支在Swift 3中，Swift 2中没有新的开发。所有与迁移相关的工作都完成了，对吗？</p><p id="5bf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不完全是。如前所述，在代码转换过程中，我们只在Swift 2和Swift 3代码之间进行最“字面”的转换。这意味着我们并不总是利用Swift 3增加的安全性或其新的约定。</p><p id="a724" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在持续的基础上，我们将寻找一些潜在的改进。</p><h2 id="f880" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">更细粒度的访问控制</h2><p id="3e11" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">默认情况下，Xcode代码转换工具将<code class="du lw lx ly lz b">private</code>访问控制修饰符转换为<code class="du lw lx ly lz b">fileprivate</code>，将<code class="du lw lx ly lz b">public</code>访问控制修饰符转换为<code class="du lw lx ly lz b">open</code>。这代表一种“文字”转换，保证代码将继续像以前一样工作。然而，这也让开发者错过了一个机会，去考虑新的<code class="du lw lx ly lz b">private</code>和<code class="du lw lx ly lz b">public</code>行为是否真的是更好的<em class="jc">工具。下一步是重新访问文字访问控制转换的实例，并检查我们是否可以利用Swift 3增强的表达能力来提供更细粒度的控制。</em></p><h2 id="778b" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">Swift 3方法命名</h2><p id="63cb" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">当手动转换代码时(当Xcode转换工具不够用时，或者当我们改变基础时)，我们经常采取“字面”的方法来改变方法名，以便调用点继续正确。以下面的Swift 2.3方法签名为例:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="ff7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了做出最小、最快的改变，使我们的代码在Swift 3中再次编译，我们将把它转换成:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="36eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，更“迅捷3”的写法应该是:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="882c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是找到采用命名快捷方式的实例，并更新方法签名以更好地遵循Swift 3惯例。</p><h2 id="31e9" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">隐式展开选项的安全使用</h2><p id="9c80" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如前所述，我们处理新的可选(在Swift 3中)Objective-C块参数的方法是，立即将它们分配给隐式展开的可选变量，这消除了更新块内大部分代码的需要。然而，我们<em class="jc">应该</em>在我们的块中做的是适当地处理参数成为<code class="du lw lx ly lz b">nil</code>的可能性。</p><h2 id="81a9" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">修复警告</h2><p id="1636" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">为了快速结束代码转换过程，我们最终忽略了相当数量的编译器警告，这些警告并没有让我们觉得特别紧急。展望未来，我们必须意识到要降低我们的警告次数。</p><h1 id="f3ad" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="e9ee" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">由于Airbnb是Swift的早期热心采用者，我们积累了大量Swift代码。起初，迁移到Swift 3的前景似乎令人生畏，不清楚我们将如何进行，也不清楚它将如何影响我们的应用程序。如果您还没有决定将您的代码转换到Swift 3，我们希望我们的经验有助于揭开这个过程的神秘面纱。</p><p id="8434" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，如果你有兴趣使用Swift 3等最新的移动技术来帮助任何地方的人们，<a class="ae jd" href="https://www.airbnb.com/careers/departments/engineering" rel="noopener ugc nofollow" target="_blank">我们正在招聘！</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mc"><img src="../Images/3913f6470a7657e02386189e67b4eb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:108/format:webp/1*YsUOrWx3mRxZZljtc9xZyw.png"/></div></figure><h2 id="888d" class="li jr hh bd js lj lk ll jw lm ln lo ka ip lp lq ke it lr ls ki ix lt lu km lv bi translated">在<a class="ae jd" href="http://airbnb.io" rel="noopener ugc nofollow" target="_blank"> airbnb.io </a>查看我们所有的开源项目，并在Twitter上关注我们:<a class="ae jd" href="https://twitter.com/AirbnbEng" rel="noopener ugc nofollow" target="_blank">@ Airbnb eng</a>+<a class="ae jd" href="https://twitter.com/AirbnbData" rel="noopener ugc nofollow" target="_blank">@ Airbnb data</a></h2></div></div>    
</body>
</html>