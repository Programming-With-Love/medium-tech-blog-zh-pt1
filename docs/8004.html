<html>
<head>
<title>Garbage Collector In Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">垃圾收集器在工作</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/garbage-collector-in-action-7b6d03b100a1?source=collection_archive---------0-----------------------#2021-04-22">https://medium.com/walmartglobaltech/garbage-collector-in-action-7b6d03b100a1?source=collection_archive---------0-----------------------#2021-04-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3e3100d43efa449c0fe4f9e18ee08d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gb8yT9pzrUeuZPSzcYhjA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae it" href="https://unsplash.com/s/photos/garbage-bin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f8d0" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">你遇到过OutOfMemoryError吗？？</h1><p id="6fc9" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在我做程序员的早期，我经常在java应用程序中遇到内存错误。为了解决这个问题，我曾经增加JVM堆的大小。在遇到很多次之后，我意识到从资源利用的角度来看，在不知道根本原因的情况下增加堆的大小并不是一个好主意。我们在这里讨论一下为什么会遇到这个问题。</p><p id="656d" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">内存泄露？？</strong>符合垃圾收集(GC)条件并且确实存在于我们的程序中的对象是内存泄漏。</p><p id="91b9" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">是的，像C，C++一样，我们在java中也有内存泄漏。Java垃圾收集器是Java中的一个进程，它代表开发人员处理内存泄漏。Java开发人员也会遇到“java.lang.OutOfMemoryError”异常。这种异常是由什么造成的？这是内存泄漏。<br/>它向我们指出了一个事实，即检测和处理内存泄漏是至关重要的。有工具可用于此目的。JProfiler就是这样一个工具。JProfiler可以与不同的集成开发环境(ide)相结合。在博客的其余部分，我将使用一个名为IntelliJ的IDE。</p><p id="1f61" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">让我们举一个简单的例子，假设Java垃圾收集器会处理内存泄漏，那么向map添加Employee对象会消耗大量堆。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="12c6" class="le iv hh la b fi lf lg l lh li">public class Sample {<br/><br/>    public static void main(String[] args) throws InterruptedException {<br/>        Map&lt;Employee, Integer&gt; map = new HashMap&lt;&gt;();<br/><br/>        while (true) {<br/>            for (int i = 0; i &lt; 1000000; i++) {<br/>                map.put(new Employee("Kara"), 1);<br/>            }<br/>            Thread.<em class="lj">sleep</em>(100);<br/>        }<br/>    }<br/>}<br/><br/>class Employee {<br/>    public String name;<br/><br/>    public Employee(String name) {<br/>        this.name = name;<br/>    }<br/>}</span></pre><p id="b113" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在运行应用程序一段时间后，我们会发现自己处于OutOfMemoryError异常中，因为在一种特定的情况下，java堆中没有剩余空间来分配Employee的对象。这是一个内存泄漏，因为对象正在被创建，但没有被GC收集。增加堆大小是一个补丁，但不是解决方案。因此，我们应该通过某种方法或其他方式使映射对GC可用。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/fcca959d84999669061ee2ec6bc9d9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UnhkC_RNJLGeu09yvI2Lg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">code</figcaption></figure><p id="76da" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">现在这只是一个类应用程序，但它也可能是一个有100个类的应用程序。要确定内存泄漏发生的确切位置，可以使用JProfiler。它告诉消耗最高内存并可能导致内存泄漏的类。堆遍历器是告诉我们内存泄漏的部分。我们可以看到Heap Walker(JProfiler snip)显示(红色标记)消耗大量内存的是HashMap和Employee类。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ll"><img src="../Images/77076a700186ceb48ced5a7743d0c44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFndQSmF6PlG7hh6k61sVQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">JProfiler</figcaption></figure><p id="1445" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">避免这种情况是程序员的责任。为了做到这一点，你必须知道Java垃圾收集器是如何工作的。人们还应该知道一个对象如何成为垃圾收集的合格对象。</p><p id="4ab1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">本文主要关注开发人员编写代码时利用GC的实用方法。</p><p id="cb95" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">要进一步了解，请参考本文末尾列出的链接。</p><h1 id="58de" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> Java垃圾收集器</strong></h1><p id="fe59" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Java垃圾收集器是一个守护线程，它总是在后台运行。它位于Java虚拟机内部，负责销毁未使用的对象。垃圾收集器基本上执行三个任务，即</p><ol class=""><li id="42d6" class="lm ln hh ju b jv kq jz kr kd lo kh lp kl lq kp lr ls lt lu bi translated">标记要清理的对象</li><li id="8b50" class="lm ln hh ju b jv lv jz lw kd lx kh ly kl lz kp lr ls lt lu bi translated">做实际的清理工作</li><li id="d954" class="lm ln hh ju b jv lv jz lw kd lx kh ly kl lz kp lr ls lt lu bi translated">压缩内存空间以实现连续内存分配。</li></ol><p id="8616" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">有许多GC算法，如串行GC，并行GC，并发标记，清扫(CMS)，G1和大多数JVM遵循标记和清扫算法。为了提高性能，堆被进一步分解成更小的部分或称代，如年轻、年老和永久代。次要和主要的GC由GC不时地在堆上执行。所有次要和主要的垃圾收集都是“停止世界”事件，不是本质上的，而是一般意义上的。</p><h1 id="7960" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">使对象可用于垃圾收集的方法</strong></h1><ol class=""><li id="9923" class="lm ln hh ju b jv jw jz ka kd ma kh mb kl mc kp lr ls lt lu bi translated"><strong class="ju hi">取消参考变量</strong></li></ol><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ba0c" class="le iv hh la b fi lf lg l lh li">Object redShirt = new Object();<br/>redShirt = null; //now redShirt is eligible for garbage collector</span></pre><p id="84b0" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi"> 2。重新分配参考变量</strong></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="0246" class="le iv hh la b fi lf lg l lh li">Object redShirt = new Object();<br/>Object blueShirt = new Object();<br/>redShirt = blueShirt;</span></pre><p id="32c1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi"> 3。在方法内创建的对象</strong></p><p id="b652" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">例1 </strong></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="bf19" class="le iv hh la b fi lf lg l lh li">public class StudentOperation {<br/>    public static void main(String[] args) {<br/>        Student s = <em class="lj">createStudent</em>(); <br/>    }<br/>    public static Student createStudent() {<em class="lj"><br/>        </em>Student s1 = new Student();<br/>        Student s2 = new Student();<br/>        return s1;<br/>    }<br/>}<br/>class Student {<br/>}</span></pre><p id="9287" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><em class="lj"> s1将被移除，但在此之前，它将在main方法中传递对s的引用。所以这个对象没有资格进行GC。一旦createStudent()方法完成，s2指向的对象将有资格进行GC。</em> <code class="du md me mf la b">s = <em class="lj">createStudent</em>()</code>持有对象，因为我们有一个占位符s。如果学生<code class="du md me mf la b">s = <em class="lj">createStudent</em>() </code>被替换为<code class="du md me mf la b"><em class="lj">createStudent</em>()</code>，那么s1和s2对象都有资格进行GC。因此，如果对象不是在全局级别处理，我们应该将对象的范围限制在一个方法中。</p><p id="4cef" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">例2 </strong></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8631" class="le iv hh la b fi lf lg l lh li">public class StudentOperation {<br/>    static Student <em class="lj">s1</em>;<br/>    public static void main(String[] args) {<br/>        <em class="lj">createStudent</em>();<br/>    }<br/>    public static void createStudent() {<br/>        <em class="lj">s1 </em>= new Student();<br/>        Student s2 = new Student();<br/>    } <br/>} <br/>class Student {<br/>}</span></pre><p id="e1f7" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">因为s1是静态变量，所以它的生存期贯穿于整个程序，甚至在调用createStudent()之后。所以这里只有s2有资格做GC。</p><p id="b48f" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi"> 4。孤岛</strong></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="dc43" class="le iv hh la b fi lf lg l lh li">class Student {<br/>    Student t;<br/>    public static void main() {<br/>        Student t1 = new Student();<br/>        Student t2 = new Student();<br/>        Student t3 = new Student();<br/>        t1.t = t2;<br/>        t2.t = t3;<br/>        t3.t = t1;<br/>        t1 = null;<br/>        t2 = null;<br/>        t3 = null;<br/>    }<br/>}</span></pre><p id="07f1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">直到行<code class="du md me mf la b">t2 = null; </code>没有对象适合GC。在第<code class="du md me mf la b">t3 = null;</code>行，所有三个对象都有资格进行GC，因为所有对象都与堆外的任何外部引用相隔离。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/1aafda27bed455971714f0bbbe5c4b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*D2rGj_JRK7M-e57eq8kSqA.png"/></div></figure><p id="6534" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">即使对象有一个引用变量，它有时也可能适合GC(如果所有引用都是内部引用)</p><h1 id="ec85" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">请求JVM运行GC的各种方法</h1><p id="a505" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated"><strong class="ju hi">功能</strong>:每当我们让一个对象符合垃圾收集器的条件时，这是否意味着这个对象会立即被JVM销毁？</p><p id="bcfd" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">不要！！我们不知道JVM什么时候会运行它的垃圾收集器。我们可以请求JVM运行它的垃圾收集器，gc()方法就是一种方法。同样，不能保证我们的请求是否被接受，但是大多数情况下，如果有空间不足，JVM会接受我们的请求。</p><ol class=""><li id="1ac0" class="lm ln hh ju b jv kq jz kr kd lo kh lp kl lq kp lr ls lt lu bi translated"><strong class="ju hi">系统类</strong>:包含一个静态方法gc()</li></ol><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6471" class="le iv hh la b fi lf lg l lh li">System.gc();</span></pre><p id="d869" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">2.<strong class="ju hi">运行时类</strong>:运行时类的对象使java能够与JVM通信。存在于java.lang包中，它是一个单例类，提供静态工厂方法来创建对象，然后调用实例gc()方法。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="805a" class="le iv hh la b fi lf lg l lh li">Runtime runtime = Runtime.<em class="lj">getRuntime</em>().gc();</span></pre><p id="2e10" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">如果我们谈论性能，<code class="du md me mf la b">Runtime.<em class="lj">getRuntime</em>().gc()</code>比<code class="du md me mf la b">System.gc()</code>好，因为<code class="du md me mf la b">System.gc()</code>只在内部调用运行时的类gc()方法。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="23dd" class="le iv hh la b fi lf lg l lh li">public final class System {<br/>    public static void gc() {<br/>        Runtime.<em class="lj">getRuntime</em>().gc();<br/>    }<br/>}</span></pre><p id="b84c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">例子</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="5c17" class="le iv hh la b fi lf lg l lh li">class GCDemo {<br/>    public static void main(String[] args) {<br/>        Runtime runtime = Runtime.<em class="lj">getRuntime</em>();<br/>        System.<em class="lj">out</em>.println("Total memory "+ runtime.totalMemory());<br/>        System.<em class="lj">out</em>.println("Free memory before running counter " + runtime.freeMemory());<br/>        for (int counter = 0; counter &lt; 100000; counter++) {<br/>            Date date = new Date();<br/>            date = null;<br/>        }<br/>        System.<em class="lj">out</em>.println("Free memory after running counter " + runtime.freeMemory());<br/>        System.<em class="lj">gc</em>();<br/>        System.<em class="lj">out</em>.println("Free memory after running gc " + runtime.freeMemory());<br/>    }<br/>}</span></pre><p id="8062" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">输出</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ca97" class="le iv hh la b fi lf lg l lh li">Total memory 257425408<br/>Free memory before running counter 25<strong class="la hi">4741016</strong><br/>Free memory after running counter 25<strong class="la hi">1575920</strong><br/>Free memory after running gc 25<strong class="la hi">5567128</strong></span></pre><h1 id="9a04" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">定稿</h1><ul class=""><li id="d756" class="lm ln hh ju b jv jw jz ka kd ma kh mb kl mc kp mh ls lt lu bi translated">就在销毁对象之前，垃圾收集器调用对象类finalize()方法来执行资源释放活动。对象上的finalize()仅作为gc()进程的一部分被调用。可以根据需要在自己的类中重写该方法。显式调用finalize()方法有什么不同吗？不，它将被视为一个常规的用户定义的方法调用。每当JVM运行垃圾收集器时，这个方法将在gc()方法调用发生之前被自动调用。</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="90a0" class="le iv hh la b fi lf lg l lh li">class GCFinalizeDemo {<br/>    public static void main(String[] args) {<br/>        GCFinalizeDemo gcFinalizeDemo = new GCFinalizeDemo();<br/>        gcFinalizeDemo.finalize();<br/>        gcFinalizeDemo.finalize();<br/>        gcFinalizeDemo = null;<br/>        System.<em class="lj">gc</em>();<br/>        System.<em class="lj">out</em>.println("GCFinalizeDemo work finished");<br/>    }<br/><br/>    public void finalize() {<br/>        System.<em class="lj">out</em>.println("GCFinalizeDemo class's finalize method is called");<br/>    }<br/>}</span></pre><p id="1c4b" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">输出</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c994" class="le iv hh la b fi lf lg l lh li">GCFinalizeDemo class's finalize method is called<br/>GCFinalizeDemo class's finalize method is called<br/>GCFinalizeDemo work finished<br/>GCFinalizeDemo class's finalize method is called</span></pre><ul class=""><li id="4b62" class="lm ln hh ju b jv kq jz kr kd lo kh lp kl lq kp mh ls lt lu bi translated">这里将调用属于特定类的对象(GC eligible)的finalize()方法。例如，在第<code class="du md me mf la b">anotherObject = null;</code>行，String类的对象符合GC条件，因此将调用String类的finalize()方法，而不是GCFinalizeDemo的finalize()方法。</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9385" class="le iv hh la b fi lf lg l lh li">class GCFinalizeDemo {<br/>    public static void main(String[] args) {<br/>        String anotherObject = "eligibleforGC";<br/>        anotherObject = null;<br/>        System.<em class="lj">gc</em>();<br/>        System.<em class="lj">out</em>.println("GCFinalizeDemo work finished");<br/>    }<br/><br/>    public void finalize() {<br/>        System.<em class="lj">out</em>.println("GCFinalizeDemo class's finalize method is called");<br/>    }<br/>}</span></pre><p id="9bfb" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">输出</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="21be" class="le iv hh la b fi lf lg l lh li">GCFinalizeDemo work finished</span></pre><ul class=""><li id="f686" class="lm ln hh ju b jv kq jz kr kd lo kh lp kl lq kp mh ls lt lu bi translated"><strong class="ju hi">当一个开发者调用finalize()方法时，JVM变成了局部的。</strong>在显式finalize()调用执行期间，如果出现未捕获的异常，程序将会突然终止。当JVM内部进行这样的调用时，它忽略异常并正常运行程序。</li><li id="0c04" class="lm ln hh ju b jv lv jz lw kd lx kh ly kl lz kp mh ls lt lu bi translated">垃圾收集器对任何对象只调用finalize()一次，即使它可以多次进行GC，如下例所示。</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="0af9" class="le iv hh la b fi lf lg l lh li">public class FinalizeWorld {<br/>    static FinalizeWorld <em class="lj">world1</em>;<br/><br/>    public static void main(String[] args) throws InterruptedException {<br/>        FinalizeWorld world2 = new FinalizeWorld();<br/>        System.<em class="lj">out</em>.println(world2.hashCode());<br/>        world2 = null;<br/>        System.<em class="lj">gc</em>();<br/>        Thread.<em class="lj">sleep</em>(5000);<br/>        System.<em class="lj">out</em>.println(<em class="lj">world1</em>.hashCode());<br/>        <em class="lj">world1 </em>= null;<br/>        System.<em class="lj">gc</em>();<br/>        Thread.<em class="lj">sleep</em>(5000);<br/>        System.<em class="lj">out</em>.println("End of main method");<br/>    }<br/><br/>    public void finalize() {<br/>        System.<em class="lj">out</em>.println("Finalize method called");<br/>    }<br/>}</span></pre><p id="1c9a" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">输出</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7378" class="le iv hh la b fi lf lg l lh li">621009875<br/>Finalize method called<br/>621009875<br/>End of main method</span></pre><h1 id="dbea" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">JVM行为</h1><p id="66c3" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">这是随机的，因为我们无法预测垃圾收集器如何识别要销毁的对象，垃圾收集器销毁对象的顺序，是否销毁所有符合条件的对象，以及垃圾收集器运行的确切时间。在下面的例子中，如果我们做<code class="du md me mf la b">counter &lt; 100000</code>可能JVM运行GC，但是有多少对象将被破坏是不可预测的。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="36ae" class="le iv hh la b fi lf lg l lh li">class GCDemo {<br/>    static int <em class="lj">count </em>= 0;<br/><br/>    public static void main(String[] args) {<br/>        for (int counter = 0; counter &lt; 10; counter++) {<br/>            GCDemo gcDemo = new GCDemo();<br/>            gcDemo = null;<br/>        }<br/>    }<br/>    public void finalize() {<br/>        <em class="lj">count</em>++;<br/>        System.<em class="lj">out</em>.println("finalize method called:" + <em class="lj">count</em>);<br/>    }<br/>}</span></pre><h1 id="8bc2" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">这里有一些有趣的链接，可以找到更多关于GC的信息</h1><div class="mi mj ez fb mk ml"><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hi fi z dy mq ea eb mr ed ef hg bi translated">Java垃圾收集基础知识</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">本OBE涵盖了Java虚拟机(JVM)垃圾收集(GC)的基础知识。在出窍的第一部分…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">www.oracle.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz in ml"/></div></div></a></div><div class="mi mj ez fb mk ml"><a href="https://ieeexplore.ieee.org/document/8400277" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hi fi z dy mq ea eb mr ed ef hg bi translated">Java编程语言中垃圾收集器的比较- IEEE会议出版物</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">IEEE Xplore，提供世界上最高质量的工程和…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">ieeexplore.ieee.org</p></div></div></div></a></div></div></div>    
</body>
</html>