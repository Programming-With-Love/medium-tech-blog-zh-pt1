<html>
<head>
<title>Compile time exception handling in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的编译时异常处理</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/compile-time-exception-handling-in-kotlin-1126c55387ce?source=collection_archive---------1-----------------------#2022-09-20">https://blog.kotlin-academy.com/compile-time-exception-handling-in-kotlin-1126c55387ce?source=collection_archive---------1-----------------------#2022-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1071a0593eb884c986aef19ae98fbd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXyU6ziL93ZAaisYfNkLdg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/es/@dav420?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">David Pupaza</a> on <a class="ae jz" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Kotlin中，没有类似Java的检查异常的概念。我们要么处理异常，要么让它在运行时崩溃。</p><p id="e9e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我一直在做一个Kotlin项目，他们用<strong class="kc io">函数式风格</strong>写代码。由于我来自C++背景，适应这种风格相当棘手。一开始，我违反了规则，使用了大量的<strong class="kc io"> var </strong>而不是<strong class="kc io"> val </strong>，并且到处使用<strong class="kc io">可变集合</strong>，但是过了一段时间，我开始适应了。</p><p id="02c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要多花一点时间来适应的一件事是函数式编程中的错误处理。在FP风格中，没有异常，错误被视为值。每个函数返回<strong class="kc io">成功</strong>或<strong class="kc io">错误</strong>。但问题是，Kotlin并不是像Haskell那样的纯函数式语言。大多数标准库函数都会抛出异常。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="063a" class="lh li in ld b gy lj lk l ll lm">fun main() {<br/>    <em class="ln">emptyList</em>&lt;Int&gt;().<em class="ln">first</em>()<br/>}</span></pre><p id="2f57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码将在运行时抛出<code class="fe lo lp lq ld b">NoSuchElementException</code>。函数代码中不允许出现这种运行时意外😜当然，也可以把上面的代码毫无例外地写成如下。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b2c4" class="lh li in ld b gy lj lk l ll lm">fun main() {<br/>    <em class="ln">emptyList</em>&lt;Int&gt;().<em class="ln">firstOrNull</em>()?.<em class="ln">let </em><strong class="ld io">{ </strong>first <strong class="ld io">-&gt;<br/>        </strong><em class="ln">println</em>("only execute if the list is not empty. First element = $first")<br/>    <strong class="ld io">}<br/></strong>}</span></pre><p id="2edb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者可以使用下面的箭头库来编写没有null的代码。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5d75" class="lh li in ld b gy lj lk l ll lm">import arrow.core.firstOrNone<br/>fun main() {<br/>    <em class="ln">emptyList</em>&lt;Int&gt;().<em class="ln">firstOrNone</em>().tap <strong class="ld io">{ </strong>first <strong class="ld io">-&gt;<br/>        </strong><em class="ln">println</em>("only execute if the list is not empty. First element = $first")<br/>    <strong class="ld io">}<br/></strong>}</span></pre><p id="7805" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们有一些抛出异常的标准库函数的替代函数。</p><p id="2e1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那还有什么问题呢？问题在于开发者😄是的，在处理大型函数式项目时，我们有时会忽略并使用标准的库函数，它会抛出异常。甚至有几次我也陷入了这个陷阱，陷入了代码审查。</p><p id="ee7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我在寻找一些linter，它可以在编译时警告我未处理的异常。不幸的是，有两个问题(<a class="ae jz" href="https://youtrack.jetbrains.com/issue/KT-18276" rel="noopener ugc nofollow" target="_blank"> KT-18276 </a>、<a class="ae jz" href="https://youtrack.jetbrains.com/issue/KTIJ-10948" rel="noopener ugc nofollow" target="_blank"> KTIJ-10948 </a>)已经存在于IntelliJ YouTrack中，并且在过去的3年中没有得到解决😐</p><h2 id="c365" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">箭头分析</h2><p id="5d5c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这篇文章基本上是为了表扬这个插件的开发者👍它在编译时分析代码，并试图捕捉潜在的未处理异常。例如，如果在Gradle构建中应用了箭头分析插件，下面的代码将无法编译。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2f01" class="lh li in ld b gy lj lk l ll lm">fun main() {<br/>    <em class="ln">emptyList</em>&lt;Int&gt;().<em class="ln">first</em>()<br/>}</span></pre><p id="36eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">箭头分析插件的编译时错误。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1ab5" class="lh li in ld b gy lj lk l ll lm">pre-condition `not empty` is not satisfied in `first()`<br/>  -&gt; unsatisfiable constraint: `(emptyList&lt;Int&gt;().size) &gt;= 1`</span></pre><p id="1872" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它仍然不能满足我的要求，因为它只捕获运行时可能崩溃的异常。例如，下面的代码可以顺利编译。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="afd7" class="lh li in ld b gy lj lk l ll lm">fun main() {<br/>    <em class="ln">listOf</em>(1,2).<em class="ln">first</em>()<br/>}</span></pre><p id="bd42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，该插件向类似于Kotlin <code class="fe lo lp lq ld b"><a class="ae jz" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" rel="noopener ugc nofollow" target="_blank">require</a></code>的函数添加了一组前置和后置条件，但它们是在编译时验证的。</p><p id="1212" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使您的项目已经用Kotlin <code class="fe lo lp lq ld b">require</code>编写，使用这个插件仍然有好处。它在编译时而不是运行时检查那些<code class="fe lo lp lq ld b">require</code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="50ff" class="lh li in ld b gy lj lk l ll lm">fun getIndices(count: Int): List&lt;Int&gt; {<br/>    <em class="ln">require</em>(count &gt;= 0) <strong class="ld io">{ </strong>"Count must be non-negative, was $count" <strong class="ld io">}<br/>    </strong>return <em class="ln">List</em>(count) <strong class="ld io">{ it </strong>+ 1 <strong class="ld io">}<br/></strong>}<br/><br/>fun main() {<br/>    <em class="ln">getIndices</em>(-1)<br/>}</span></pre><p id="ee7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">箭头分析插件的编译时错误。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a18e" class="lh li in ld b gy lj lk l ll lm">pre-condition `Count must be non-negative, was $count` is not satisfied in `getIndices(-1)`<br/>  -&gt; unsatisfiable constraint: `-1 &gt;= 0`</span></pre><h2 id="822e" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">向Gradle项目添加箭头分析</h2><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3e35" class="lh li in ld b gy lj lk l ll lm">buildscript {<br/>  dependencies {<br/>    classpath("io.arrow-kt.analysis.kotlin:io.arrow-kt.analysis.kotlin.gradle.plugin:2.0")<br/>  }<br/>}<br/>apply(plugin = "io.arrow-kt.analysis.kotlin")</span></pre><p id="a2fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">延伸阅读:<a class="ae jz" href="https://arrow-kt.io/docs/meta/analysis/#%CE%BBrrow-analysis-beyond-the-compiler" rel="noopener ugc nofollow" target="_blank">λrrow分析。超越编译器</a></p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="f69d" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">资源</h2><div class="mu mv gp gr mw mx"><a href="https://arrow-kt.io/docs/meta/analysis/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">rrow元</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">rrow分析在您的编译管道中引入了新的检查，它会警告常见的错误，如越界…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">arrow-kt.io</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jt mx"/></div></div></a></div><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi no"><img src="../Images/68557afd7e8ae2a75dec26b78d8ec016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxZ6inD12UP7rnbt-2PJZw.png"/></div></a></figure></div></div>    
</body>
</html>