<html>
<head>
<title>The TypeScript Tax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字税</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b?source=collection_archive---------0-----------------------#2019-01-23">https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b?source=collection_archive---------0-----------------------#2019-01-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9d6b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">成本与收益分析</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/63f2bcda41767f980298c397f951188d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwvkEcaGGVihZ8PBj_Y4hA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo: LendingMemo (CC BY 2.0)</figcaption></figure><p id="e71b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">TypeScript在2017年和2019年之间增长了很多，而且在许多方面都有很好的理由。TypeScript有很多可爱之处。在2018年JavaScript调查中，<a class="ae ki" href="https://2018.stateofjs.com/javascript-flavors/overview/" rel="noopener ugc nofollow" target="_blank">几乎一半的受访者</a>表示他们已经尝试过TypeScript，并将再次使用它。但是你应该把它用于你的大规模应用程序开发项目吗？</p><p id="d97c" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">本文采用一种更关键的、数据驱动的方法来分析使用TypeScript构建大规模应用程序的ROI。</p><h1 id="6f0d" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">打字稿增长</h1><p id="d86a" class="pw-post-body-paragraph jm jn hh jo b jp lb ii jr js lc il ju jv ld jx jy jz le kb kc kd lf kf kg kh ha bi translated">TypeScript是发展最快的语言之一，也是目前领先的编译到JavaScript语言。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/8d4ad466c05e23f995ffa986d22fc8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DLxM43Ih40MVQzpRupUUg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Google Trends 2014–2019 TypeScript Topic Growth</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lh"><img src="../Images/616288718e918eebf01dedc45f266cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIFVBWlTInmFBK29DRS7TQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">GitHub Fastest Growing Languages by Contributor Numbers [<a class="ae ki" href="https://blog.github.com/2018-11-15-state-of-the-octoverse-top-programming-languages/" rel="noopener ugc nofollow" target="_blank">Source</a>]</figcaption></figure><p id="24b6" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是非常令人印象深刻的牵引力，不应该被忽视，但它仍然远远没有主宰整个JavaScript生态系统。你可能会说这是一个更大的海洋中的一个大浪。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/ebfa6ac11580869bfe69011da1825e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFY5uChmah9_Hm_e3TWUCQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Google Search Trends 2014–2018 JavaScript (Red) vs TypeScript (blue) Topic Interest</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/fac17eb4ac73fa370155025152f3eb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plUmjDAw4PinUhx0j61clA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">GitHub Top Languages by Repositories Created: TypeScript is Not in the Top 5. [<a class="ae ki" href="https://blog.github.com/2018-11-15-state-of-the-octoverse-top-programming-languages/" rel="noopener ugc nofollow" target="_blank">Source</a>]</figcaption></figure><p id="ae8b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">也就是说，TypeScript在2018年达到了一个拐点，在2019年，将会有大量的制作项目使用它。作为一名JavaScript开发人员，您可能别无选择。TypeScript的决定会为您做出，您不应该害怕学习和使用它。</p><p id="6edd" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是如果你处于决定是否使用它的位置，你应该对收益和成本有一个现实的理解。会有正面影响还是负面影响？</p><p id="4973" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">以我的经验来看，两者都有，但是没有正的投资回报率。许多开发人员喜欢使用它，我也非常喜欢TypeScript开发人员体验的许多方面。但是所有这些都是有代价的。</p><h1 id="6068" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">背景</h1><p id="327c" class="pw-post-body-paragraph jm jn hh jo b jp lb ii jr js lc il ju jv ld jx jy jz le kb kc kd lf kf kg kh ha bi translated">我来自一个使用静态类型语言的背景，包括C/C++和Java。JavaScript的动态类型起初很难适应，但一旦我习惯了，就像从一个漫长黑暗的隧道中走出来，来到了光明中。静态类型有很多优点，但是动态类型也有很多优点。</p><p id="80f3" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在过去的几年里，我断断续续地全身心投入到打字稿上，积累了一年多的日常实践经验。接着，我领导了多个使用TypeScript作为主要语言的大型制作团队，了解了TypeScript对多项目的高级影响，并将其与类似的大型原生JavaScript版本进行了比较。</p><p id="5367" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">2018年，<a class="ae ki" rel="noopener" href="/the-challenge/blockchain-platforms-tech-to-watch-in-2019-f2bfefc5c23">去中心化应用起飞</a>，大部分使用智能合约和开源软件。当你处理价值互联网时，漏洞会让用户损失金钱。编写可靠的代码比以往任何时候都重要，因为这些项目通常都是开源的，所以我认为我们用TypeScript开发代码很好，这样其他TypeScript团队可以更容易地集成，同时保持与使用JavaScript的项目的兼容性。</p><p id="1d5a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我对TypeScript的理解，包括它的好处、成本和缺点，已经大大加深了。我很难过地说，它不像我希望的那样成功。除非它有很大的改进，否则我不会为另一个大型项目选择TypeScript。</p><h2 id="370f" class="lk kk hh bd kl ll lm ln kp lo lp lq kt jv lr ls kv jz lt lu kx kd lv lw kz lx bi translated">我喜欢打字稿的地方</h2><p id="56a7" class="pw-post-body-paragraph jm jn hh jo b jp lb ii jr js lc il ju jv ld jx jy jz le kb kc kd lf kf kg kh ha bi translated">我还是长期看好TypeScript的。<strong class="jo hi">我喜欢打字稿，</strong> <em class="ly"> </em>我仍然喜欢它的许多部分。我希望TypeScript的开发者和支持者会把这看作是一个建设性的批评，而不是一个充满敌意的反驳。TypeScript开发人员<em class="ly">可以修复一些问题，</em>如果他们这么做了，我可能会重复ROI分析并得出不同的结果。</p><p id="fc04" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">静态类型对于帮助<strong class="jo hi">记录功能、阐明用法和减少认知开销非常有用。</strong>例如，我<em class="ly">通常</em>发现Haskell的类型是有帮助的、低成本的、无痛苦的、不引人注目的，但是有时甚至Haskell灵活的更高级的类型系统也会碍事。尝试在Haskell(或TypeScript)中键入一个转换器。这并不容易，可能比非类型化的等价函数还要差一点。</p><p id="07b4" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我喜欢TypeScript中的<strong class="jo hi">类型注释在碍事时可以是可选的</strong>，我也喜欢TypeScript使用结构化类型，并对类型推断提供了一些支持(尽管推断还有很大的改进空间)。</p><p id="164d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi"> TypeScript支持接口，</strong>接口是可重用的(与内联相反)类型，您可以用各种方式应用它们来注释API和函数签名。一个接口可以有许多实现。接口是TypeScript最好的特性之一，我希望这个特性能够内置到JavaScript中。</p><p id="48ef" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">最好的消息:在我看来，如果你使用一个得到很好支持的编辑器(比如Atom或Visual Studio Code)，TypeScript的编辑器插件仍然可以为<strong class="jo hi">提供JavaScript生态系统中最好的ide开发者体验</strong>。其他插件开发者应该尝试一下，并记下他们如何改进。</p><h1 id="1d1c" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">在数字中键入ROI</h1><p id="62a8" class="pw-post-body-paragraph jm jn hh jo b jp lb ii jr js lc il ju jv ld jx jy jz le kb kc kd lf kf kg kh ha bi translated">我将从几个方面对TypeScript进行评分，给你一个更好的感觉，TypeScript是否适合大规模应用程序。</p><p id="593b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">大于0表示积极影响。小于0表示负面影响。3-5分代表相对较强的影响。2分代表中度影响。1分代表影响相对较低。</p><p id="0068" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这些数字很难精确测量，而且有些主观，但是我已经尽我所能估计出反映我们在真实项目中看到的实际成本和回报。</p><p id="5a57" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所有被判定有影响的项目都超过5万LOC，有几个合作者工作了几个月。一个项目是Angular 2 + TypeScript，而另一个类似的项目是用Angular 1和标准JavaScript编写的。所有其他项目都是用React和Node构建的，并与用标准JavaScript编写的React/Node项目进行比较。主观的bug密度、主观的相对速度和开发人员的反馈被估计，但是没有精确的测量。所有团队都混合了有经验的和新的TypeScript开发人员。所有成员都可以接触到更有经验的导师，以协助TypeScript入职。</p><p id="315e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在项目的小样本中，客观数据噪音太大，无法以可靠的误差范围做出任何明确的客观判断。在一个项目中，原生JavaScript显示出比TypeScript低41%的公开错误密度。在另一个项目中，TypeScript项目显示出比可比较的本地JavaScript版本低4%的错误密度。显然，其他质量度量的实现(或缺乏)比TypeScript有更强的影响，TypeScript使数字超出了可用性。</p><p id="9a03" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">由于误差如此之大，我放弃了客观量化，转而关注特性交付速度和对我们花费时间的观察。您将在投资回报逐点细分中看到更多这些细节。</p><p id="f4ef" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为涉及到很多主观性，你应该考虑到解释中的误差幅度(如图所示)，但是总的投资回报平衡应该给你一个好主意。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/6800a45edde3ef20320a67d53cb63fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvajSWEQ70_qz2gfqHin9g.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">TypeScript Cost vs Benefit Analysis: Likely Negative ROI</figcaption></figure><p id="b668" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我已经可以听到花生画廊对小收益分数的反对意见，我并不完全不同意这些论点。TypeScript确实提供了一些非常有用、强大的功能。这是毫无疑问的。</p><p id="79b2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了理解相对较小的收益分数，您必须很好地理解我将TypeScript与什么进行比较:不仅仅是JavaScript，还有与为原生JavaScript构建的工具配对的JavaScript <em class="ly">。</em></p><p id="a2e4" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们更详细地看一下每一点。</p><p id="8f2b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">开发人员工具:</strong>我最喜欢的TypeScript特性，也可以说是使用TypeScript最大的实际好处是，它能够通过提供接口类型提示和在编程时实时捕捉潜在错误来减轻开发人员的认知负担。如果这些在带有一些好插件的原生JavaScript中都不可能，我会给TypeScript更多的好处，但是0分是使用JavaScript已经可以得到的，基线已经很好了。</p><p id="c285" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">大多数TypeScript的拥护者似乎并没有很好地理解TypeScript在与什么竞争。开发工具的选择不是TypeScript vs native JavaScript，也没有工具。它介于TypeScript和<em class="ly">之间，JavaScript开发工具的整个丰富生态系统</em>。<em class="ly"> </em>当你使用<a class="ae ki" href="https://github.com/atom/autocomplete-plus" rel="noopener ugc nofollow" target="_blank">自动完成</a>、<a class="ae ki" href="https://atom.io/packages/atom-ternjs" rel="noopener ugc nofollow" target="_blank">类型推断</a>和<a class="ae ki" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> lint工具</a>时，原生JavaScript自动完成和错误检测让你获得80% — 90%的类型脚本的好处。当您运行类型推断时，并且<a class="ae ki" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1">您使用ES6默认参数</a>，您会得到类型提示，就像使用带类型注释的类型脚本代码一样。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/2d5a2e2ae16ae3a730ed2940cda3973b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13Zp1TW6jcnqsHCPl59_og.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Example of Native JavaScript Autocomplete with Type Inference</figcaption></figure><p id="a4d9" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">公平地说，如果您使用默认参数来提供类型提示，您也不需要为TypeScript代码提供注释，这是减少类型语法开销(使用TypeScript的开销之一)的一个很好的技巧。</p><p id="eb86" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">TypeScript为这些事情提供的工具可以说稍微好一点，更加一体化——但这还不足以证明其成本的合理性。</p><p id="289e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi"> API文档:</strong>TypeScript的另一个好处是更好的API文档，它总是与您的源代码保持同步。您甚至可以从您的TypeScript代码中生成API文档。这也会得到更高的分数，除了您可以在JavaScript中使用<a class="ae ki" href="http://usejsdoc.org/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>和<a class="ae ki" href="http://ternjs.net/" rel="noopener ugc nofollow" target="_blank"> Tern.js </a>获得相同的好处，并且文档生成器非常丰富。就我个人而言，我不是JSDoc的忠实粉丝，所以TypeScript确实有一些优点。</p><p id="bab4" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">即使有世界上最好的内联文档，您仍然需要真正的文档，因此TypeScript增强了而不是取代了现有的文档选项。</p><p id="4f3d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">重构。</strong>在大多数情况下，如果你能在重构中从TypeScript中获得显著的好处，那通常是一种代码味道，表明你的代码过于紧密耦合。我已经写了一整本书，讲述如何编写更加可组合、更加松散耦合的代码，书名叫做<a class="ae ki" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">“编写软件”</a>。如果TypeScript为您节省了许多重构的痛苦，那么紧耦合很可能仍然会给您带来许多其他可以避免的问题。我强烈建议阅读这本书，尤其是章节<a class="ae ki" rel="noopener" href="/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">“嘲讽是一种代码味道”</a>，它提供了大量关于紧密耦合的原因的信息，以及一些可以帮助您避免它们的最佳实践。</p><p id="1cc4" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">另一方面，一些公司运行着共享相同代码库的连接项目的非常大的生态系统(例如，<a class="ae ki" href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" rel="noopener ugc nofollow" target="_blank">谷歌著名的monorepo </a>)。使用TypeScript使他们能够升级API设计选择，以考虑更好的设计和新的用例。负责这些升级的开发人员还负责确保他们的库更改不会破坏monorepo中依赖于这些库的任何软件。TypeScript可以为这个非常有限的TypeScript用户子集节省大量时间。</p><p id="fbb1" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我说非常有限的子集，因为巨大的、封闭的monorepo生态系统是例外，而不是规律。这个过程可能会扩展到整个Google，但是不能扩展到库作者不知道的库。对更广泛的生态系统所使用的库API进行突破性的更改可能会破坏您甚至不知道存在的代码。</p><p id="b6ad" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在传统的、更加分散的库生态系统中，人们避免对API进行突破性的更改，而是遵循开放/封闭原则来创建新功能(API对扩展开放，对突破性的更改关闭)。除了少数例外，这就是网络平台本身的演变方式。这就是为什么React仍然支持自React 0.14以来被更好的选项所取代的特性。React发展并增加了新的特性，从根本上改善了开发者的体验<em class="ly">而没有破坏旧的功能。</em>例如，<code class="du lz ma mb mc b">class</code>React仍然支持组件，即使在改进很多的React Hooks API成熟之后。</p><p id="8181" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这使得整个生态系统的变化是可选的，而不是必须的。团队可以根据需要逐步升级他们的软件，而不是将整个生态系统的代码变更项目堆在库团队上。</p><p id="b383" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">即使在需要改变整个生态系统代码的情况下，类型推断和<a class="ae ki" href="https://github.com/reactjs/react-codemod" rel="noopener ugc nofollow" target="_blank">自动化代码模块</a>也能有所帮助——不需要类型脚本。</p><p id="94e2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我最初在心里给重构打了零分，并把它从列表中删除了，因为我非常喜欢开放/封闭的方法、推理和codemods。然而，在有限的情况下，一些团队从中获得了真正的好处。</p><p id="b301" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用原生JavaScript很有可能在其他方面为您提供更好的服务。</p><p id="3784" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">类型安全似乎没有太大的区别。</strong> TypeScript的支持者经常谈论类型安全的好处，但是<a class="ae ki" rel="noopener" href="/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3">几乎没有证据表明类型安全对生产bug密度有多大影响</a>(真的，<a class="ae ki" href="http://janvitek.org/pubs/toplas19.pdf" rel="noopener ugc nofollow" target="_blank">静态类型似乎对生产bug密度几乎没有影响</a>)。(2022年的一项研究甚至有更多证据表明，TypeScript对减少bug没有太大影响)。这是很重要的，因为代码审查和TDD有很大的不同(对于单独的TDD，<a class="ae ki" href="https://www.computer.org/csdl/mags/so/2007/03/s3024-abs.html" rel="noopener ugc nofollow" target="_blank">40%—80%</a>)。将TDD与设计评审、规范评审和代码评审结合起来，您会看到bug密度减少了90%以上。这些进程中的许多(特别是TDD)能够捕获TypeScript捕获的所有同类错误，以及TypeScript永远无法捕获的许多错误。</p><p id="b5d6" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">根据伦敦大学学院的高正和厄尔·t·巴尔以及微软研究院的克里斯蒂安·伯德的说法，TypeScript只能解决大约20%的“公共错误”，其中“公共”意味着这些错误在实现阶段后仍然存在，并被提交给公共存储库。</p><p id="4d4f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这项研究的作者认为他们低估了TypeScript的影响，因为他们假设已经应用了所有其他质量度量，但他们没有努力判断其他错误预防措施的质量。他们承认这一变量，但却将其完全排除在计算之外。</p><p id="be6c" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在我的经验中，绝大多数团队都部分应用了一些措施，但很少很好地应用所有重要的bug预防措施。在我的团队中，我们使用设计评审、规范评审、TDD、代码评审、lint、模式验证和公司赞助的指导，这些都对bug密度产生了巨大的影响，将类型错误减少到几乎为零。</p><p id="4ea2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">根据我的经验，除了林挺之外，其他类型对代码质量的影响都比静态类型大。换句话说，我从一个比论文作者更严格的零的定义出发。</p><p id="dedb" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你没有正确地实现那些其他的bug预防措施，<em class="ly">我毫不怀疑你会看到仅使用TypeScript就能减少15% — 18%的bug密度，</em>但是你也会完全错过80%的bug，直到它们进入生产并开始引起真正的问题。</p><p id="761b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有些人会争辩说，TypeScript提供了实时的错误反馈，因此您可以更早地捕捉到错误，但是类型推断、lint和TDD也是如此(我设置了一个监视脚本来运行文件保存上的单元测试，因此我得到了非常即时、丰富的反馈)。你可能会说这些其他的措施是有成本的，但是因为TypeScript总是会遗漏80%的bug，所以你不能安全地跳过它们，所以它们的成本适用于ROI数学的两个方面，并且已经被计算在内了。</p><p id="f176" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该研究着眼于预先已知的错误，包括为修复有问题的错误而更改的确切行，其中问题和潜在的解决方案是在引入类型化之前已知的。这意味着，即使事先知道漏洞存在，TypeScript】也无法检测到85%的公共漏洞——只能捕获15%。</p><blockquote class="mf mg mh"><p id="94b5" class="jm jn ly jo b jp jq ii jr js jt il ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated"><strong class="jo hi">更新:</strong>我们将假定TypeScript是无辜的，并在我们的计算中使用20%，以证明收益呈指数递减的观点。</p></blockquote><p id="507f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为什么这么多bug是TypeScript检测不到的？首先，<a class="ae ki" href="http://earlbarr.com/publications/typestudy.pdf" rel="noopener ugc nofollow" target="_blank">规范错误导致了GitHub上78%的公开分类错误</a>。未能正确地指定行为或正确地实现规范是最常见的错误类型，这种情况会自动导致绝大多数错误无法被TypeScript检测或阻止。在“键入或不键入”中，研究作者识别并分类了一系列“ts不可检测”的错误。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/e73c39f0d78b7c3990d4092da6978bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjmeLd5YV-Fy4YzTtDta6Q.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Histogram of ts-undetectable bugs. Source: <a class="ae ki" href="http://earlbarr.com/publications/typestudy.pdf" rel="noopener ugc nofollow" target="_blank">“To Type or Not to Type”</a></figcaption></figure><p id="51de" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">上面的“StringError”是错误的分类，其中字符串是正确的类型，但包含错误的值(如不正确的URL)。分支错误和谓词错误是导致使用错误代码路径的逻辑错误。如您所见，还有各种其他类型的错误是TypeScript无法触及的。TypeScript检测超过20%的错误的可能性微乎其微。</p><p id="a1bf" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是20%听起来太多了！为什么TypeScript没有获得高得多的bug预防分？</p><p id="942c" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为有太多的bug是静态类型检测不到的，所以跳过其他的质量控制措施，比如设计评审、规范评审、代码评审和TDD，是不负责任的。因此，假设TypeScript将是您用来防止bug的唯一工具是不公平的。为了真正获得ROI的感觉，我们必须在扣除由研究作者没有充分考虑的其他措施捕获的错误后，应用错误减少数学<em class="ly">。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/3fe5d8dbc3488f9040ba03c2f149ec86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*cJJern4t9JDeH4jrXzdVtg.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">It’s unsafe to skip other measures: Spec errors: 80% — Type errors: 20%</figcaption></figure><p id="79f8" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">假设您的项目包含1000个没有预防措施的bug。在应用了其他质量度量之后，潜在的产品缺陷数量减少到了100个。<strong class="jo hi">现在</strong>我们可以看看TypeScript可以阻止多少额外的错误，从而更真实地了解我们在TypeScript投资上的错误捕获回报。近80%的bug不能被TypeScript检测到，所有TypeScript可检测到的bug都有可能被其他方法捕获，比如TDD。</p><ul class=""><li id="285f" class="mn mo hh jo b jp jq js jt jv mp jz mq kd mr kh ms mt mu mv bi translated">没有措施:1000个错误</li><li id="a7d7" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated">采取其他措施后:仍有100个bug—<em class="ly">捕获900个bug</em></li><li id="fff3" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated">在将TypeScript添加到其他度量之后:还剩下80个bug—<em class="ly">又捕获了20个bug</em></li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/58fcd9b9c805c213c518a5380d3bef6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Ny1fCRVagi5bBWOAGFc9DA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Bar graph of bugs remaining after applying reduction measures: TypeScript provides little added benefit.</figcaption></figure><p id="7882" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有些人认为，如果你有静态类型，你不需要担心写这么多测试。那些人在进行愚蠢的争论。真的没有比赛。即使你打算使用TypeScript，<em class="ly">你仍然需要其他的方法。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/dff466c2195393fd1428712f66811147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gZT5dOdGG3vRW8JlMZr81w.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Chart: Adding TypeScript after reviews, TDD catches a tiny fraction of the total bug count.</figcaption></figure><p id="47f7" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这个场景中，reviews和TDD可以在没有TypeScript的情况下捕获900/1000的bug。如果你跳过评论和TDD，TypeScript可以捕获200/1000个bug。很明显，您不必选择其中的一个，但是在应用其他度量之后添加TypeScript会导致非常小的改进，因为回报呈指数递减。</p></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><p id="a7bf" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">更新时间:2019-02-11:</strong></p><p id="9a60" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Airbnb最近报告称，通过在开发过程中添加TypeScript，bug减少了38%。怎么可能呢？根据这篇文章，那应该是不可能的吧？数学不是这样的。我们处理的是百分比、平均值和收益递减，而不是具体的数值。</p><p id="8e7b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这篇文章所依赖的研究代表了<em class="ly">平均值、</em>，其他质量度量的存在与否影响了打字稿<em class="ly">可以</em>解决的剩余bug的百分比。</p><p id="a48b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">其他措施解决的<em class="ly">ts-detected</em>bug越多，TypeScript <em class="ly">可以</em>解决的剩余bug的百分比就越高，但是这些其他措施也减少了TypeScript要解决的剩余bug的总数。因此百分比可能会上升，但是捕获的错误总数可能只会有一点点变化。</p><p id="1cfc" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">此外，仔细的代码审查在捕捉和减少bug方面做得很好，没有比彻底检查整个代码库，仔细检查和分析每一行代码更仔细的代码审查了。不管是哪种类型，我预计仅从这一行为就能减少30%的错误(即使他们把它留在JavaScript中)。</p><p id="7a21" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在撰写本文时，他们还没有发布他们的方法或报告他们正在采用的其他bug减少措施，但我猜测他们正在采用某种形式的设计/规范审查过程，以减少最初出现在代码中的规范bug。</p><p id="8116" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">换句话说，当您消除了大量TypeScript无法解决的bug时，TypeScript可以为剩余的<em class="ly">bug提供更高百分比的bug减少。</em></p><p id="d991" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个结果并没有改变只有<em class="ly"> 20%的公共bug可以被TypeScript解决的事实，也没有否定收益指数递减的观点。</em></p><p id="491f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">相反，这意味着<em class="ly"> Airbnb可能有高于平均水平的设计或规格审查</em>(或者两者都有)，加上低于平均水平的自动化代码覆盖率<em class="ly">——可能缺少单元测试覆盖率、功能测试覆盖率，或者两者都有。适当的单元测试覆盖率可以捕获静态类型可以捕获的接近100%的错误，以及大量TypeScript不能捕获的错误。</em></p><p id="2acb" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">大多数团队很少或没有实施设计/规格审查过程。甚至在将模型交给开发人员实现之前，让工程师用批判的眼光来看待它们，也比一般情况要好。许多团队根本没有任何正式的设计评审过程。</p><p id="2409" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下面是他们的TypeScript优势图表:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/7575ac6acbe6092ee109e7a02cfc1bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*xhbFC5YxsectNOQETWHnTA.png"/></div></figure><p id="3ee3" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">TypeScript仍然只捕获了1000个潜在bug中的38个，但是由于大多数潜在bug是通过管道中的前几个步骤捕获的(就像人们在去开发人员那里实现之前检查模型一样)，TypeScript可以解决更大份额的剩余bug。在这种情况下，比团队遗漏Airbnb的额外代码质量度量多18个bug。</p><p id="f43b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">只有当TypeScript能够捕获更大份额的错误时，收益递减数学才能完全失效:接近75%+，因为在那个阶段，替换质量控制过程中其他昂贵的部分可能是可行的，如代码审查或TDD。</p><p id="d950" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">了解Airbnb在转换到TypeScript的过程中到底捕获了多少bug，了解TypeScript无法预防的bug的分类，了解bug密度(以及他们是如何计算的)，以及了解他们已经采用的其他质量控制措施，这将是一件有趣的事情。</p><blockquote class="mf mg mh"><p id="c95e" class="jm jn ly jo b jp jq ii jr js jt il ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">请记住:我并不反对使用TypeScript。我主张人们考虑成本和收益，做出对你和你的团队都是正确的理性、明智的决定。一些产品需要更严格的质量控制，为了消除1000个bug中的18个，额外的花费可能是值得的。例如，如果你的代码为特斯拉的自动驾驶系统的关键部分提供动力，我希望你使用静态类型和所有其他质量度量，因为错误的成本要高得多。每个团队都应该进行他们自己的ROI分析，并做出适合他们的决策。</p></blockquote></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><p id="d28b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我已经在大规模、数百万美元的开发项目中实施了质量控制系统，我可以告诉你，我对高成本系统实施的有效性的预期是30% — 80%的减少。您可以从以下任何一个地方获得这些数字:</p><ul class=""><li id="c220" class="mn mo hh jo b jp jq js jt jv mp jz mq kd mr kh ms mt mu mv bi translated"><strong class="jo hi">设计和规格审查</strong> ( <a class="ae ki" href="http://earlbarr.com/publications/typestudy.pdf" rel="noopener ugc nofollow" target="_blank">高达80%的降低</a>)</li><li id="a38d" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated"><strong class="jo hi"> TDD </strong> ( <a class="ae ki" href="https://www.computer.org/csdl/mags/so/2007/03/s3024-abs.html" rel="noopener ugc nofollow" target="_blank">剩余bug减少40%—80%</a>)</li><li id="1758" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated"><strong class="jo hi">代码评审</strong> ( <a class="ae ki" href="http://www.ifsq.org/finding-ia-2.html" rel="noopener ugc nofollow" target="_blank">一个小时的代码评审节省了33个小时的维护</a>)</li></ul><p id="ea18" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">事实证明，类型错误只是所有可能的错误中的一小部分<em class="ly">,还有其他方法可以捕捉类型错误。</em>数据在，结果很清楚:<strong class="jo hi"> TypeScript不会把你从bug中拯救出来。</strong>在最好的情况下，你会得到一个非常适度的减少，你仍然需要你所有的其他质量措施。</p><blockquote class="ni"><p id="f7af" class="nj nk hh bd nl nm nn no np nq nr kh dx translated">类型正确性并不能保证程序的正确性。</p></blockquote><p id="16a6" class="pw-post-body-paragraph jm jn hh jo b jp ns ii jr js nt il ju jv nu jx jy jz nv kb kc kd nw kf kg kh ha bi translated">看起来这些好处并没有达到打字稿宣传的效果。但这些并不是唯一的好处，对吗？</p><p id="4e4a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">新的JavaScript特性和编译为跨浏览器JavaScript: </strong> Babel为原生JavaScript做了这两项。</p><p id="2697" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们已经到了收益的终点，我不知道你怎么样，但我感觉有点索然无味。如果我们可以使用其他工具为原生JavaScript获得类型提示、自动完成和极大的bug减少，那么剩下的唯一问题是，类型脚本的差异是否值得使用它所需的投资？</p><p id="229b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了弄清楚这一点，我们需要仔细看看TypeScript的成本。</p><p id="7a56" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">招聘:</strong>虽然有将近一半的JavaScript受访者已经使用过TypeScript并且会再次使用，还有33.7%的人希望学习，5.4%的人已经使用过TypeScript并且<strong class="jo hi">不会再次使用</strong>，还有13.7%的<strong class="jo hi">对学习TypeScript不感兴趣。</strong>这使得招聘人数减少了近20%,对于需要大量招聘的团队来说，这可能是一笔巨大的成本。招聘是一个昂贵的过程，可能会拖上几个月，并占用其他开发人员的生产时间(他们通常是最有资格评估新候选人技能的人)。</p><p id="e442" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">另一方面，如果你只需要雇佣一两个开发人员，使用TypeScript可能会让你的开场白对几乎一半的候选人更有吸引力。对于小项目来说，可能是一洗，甚至是略正。对于数百或数千人的团队来说，这将会变成ROI误差的负值。</p><p id="b021" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">设置、初始培训:</strong>因为这些是一次性成本，所以相对较低。已经熟悉JavaScript的团队倾向于在2-3个月内提高TypeScript的工作效率，并在6-8个月内变得相当流利。肯定比招聘成本高，但如果这是唯一的成本，肯定值得努力。</p><p id="c5f1" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">缺少特性—Hof、组合、具有更高级别类型的泛型等。:</strong> <em class="ly"> TypeScript与惯用的JavaScript不完全共表达。</em>这是我在使用TypeScript时面临的最大挑战之一(也是最大的花费),因为熟练的JavaScript开发人员会经常遇到很难或不可能打字的情况，但是有责任心的开发人员会对把事情做好感兴趣。他们会花上几个小时搜索例子，试图学习如何输入TypeScript无法正确输入的内容。</p><p id="7d12" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">TypeScript可以通过提供更好的文档和发现TypeScript当前的限制来改善这种成本，这样开发人员就可以少花时间来尝试让它在更高阶的函数、声明性函数组合、转换器等方面表现良好。在许多情况下，良好的、可读的、可维护的TypeScript类型根本不会发生。开发人员需要能够很快发现这一点，这样他们就可以把时间花在更有成效的事情上。</p><p id="5d15" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">持续指导:</strong>虽然人们使用TypeScript很快就变得有效率，但确实需要相当长的时间才能变得自信。我仍然觉得还有很多东西要学。在TypeScript中，有不同的方法来键入相同的内容，并找出每种方法的优缺点，找出最佳实践，等等。比最初的学习曲线要长得多。</p><p id="e849" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">例如，新的TypeScript开发人员倾向于过度使用注释和内联类型，而更有经验的TypeScript开发人员已经学会了重用接口和创建单独的类型来减少内联注释的语法混乱。更有经验的开发人员也将发现在编译时收紧类型以产生更好的错误的方法。</p><p id="e6e7" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这种对打字的额外关注是一种持续的成本，你每次加入新的开发人员时都会看到，而且当你有经验的TypeScript开发人员学习并与团队的其他成员分享新技巧时也会看到。这种持续的指导只是合作的正常副作用，从长远来看，当应用于其他事情时，这是一种健康的习惯，可以节省金钱，但这是有代价的，TypeScript大大增加了这一点。</p><p id="d0dc" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi">打字开销:</strong>在打字开销的成本中，我包括了所有花费在打字、测试、调试和维护类型注释上的额外时间。调试类型是一项经常被忽略的成本。类型注释有自己的一类错误。打字太严格，太宽松，或只是错误的。</p><p id="7938" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">自从我第一次探索它以来，这个成本中心已经下降了，因为许多第三方库现在都包含了类型，所以你不必做那么多工作去寻找它们或者自己创建它们。然而，除了最流行的OSS包之外，这些类型化中的许多仍然是坏的和过时的，所以你仍然会最终为你想要类型提示的第三方库回填类型化。通常，开发人员试图将这些类型添加到上游，结果大相径庭。</p><p id="d33f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您可能还会注意到语法噪音大大增加了。在像Haskell这样的语言中，类型通常是在被定义的函数上面列出的简短的一行代码。在TypeScript中，特别是对于泛型函数，它们通常是侵入式的，默认情况下是内联定义的。</p><p id="5e23" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">类型脚本的类型化不仅没有增加函数签名的可读性，反而常常会使它们更难阅读和理解。这是有经验的TypeScript开发人员倾向于使用更多可重用的类型和接口，并从函数实现中单独声明类型的一个原因。大型TypeScript项目倾向于开发自己的可重用类型库，这些类型库可以在项目中的任何地方导入和使用，维护这些库可能会成为一项额外但值得做的工作。</p><p id="9dda" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">语法噪音是有问题的，原因有几个。你想让你的代码保持整洁的原因和你想让你的房子保持整洁的原因是一样的:</p><ul class=""><li id="bf57" class="mn mo hh jo b jp jq js jt jv mp jz mq kd mr kh ms mt mu mv bi translated">更多的混乱=更多的臭虫藏身的地方=更多的臭虫。</li><li id="b89f" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated">更多的杂乱会使你更难找到你想要的信息。</li></ul><p id="f511" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">杂波就像调谐不良的收音机里的静电噪声——噪声多于信号。当你消除噪音时，你能更好地听到信号。减少语法噪音就像把收音机调到合适的频率:意思更容易理解。</p><p id="6599" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">语法噪音是TypeScript的一个较大的代价，它可以通过几种方式得到改善:</p><ul class=""><li id="752c" class="mn mo hh jo b jp jq js jt jv mp jz mq kd mr kh ms mt mu mv bi translated">更好地支持使用高级类型的泛型，这可以消除一些模板语法噪音。(参考Haskell的类型系统)。</li><li id="0275" class="mn mo hh jo b jp mw js mx jv my jz mz kd na kh ms mt mu mv bi translated">鼓励单独打字，而不是行内打字，默认<em class="ly">。</em>如果避免内联类型化成为一种最佳实践，类型化语法将从函数实现中分离出来，这将更容易阅读类型签名和实现，因为它们不会相互竞争。这可以作为一个文档检查来实现，并伴随着一些关于堆栈溢出的布道。</li></ul><h1 id="bd15" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">结论</h1><p id="b4f3" class="pw-post-body-paragraph jm jn hh jo b jp lb ii jr js lc il ju jv ld jx jy jz le kb kc kd lf kf kg kh ha bi translated">我仍然喜欢TypeScript的许多方面，我仍然希望它能有所改进。这些成本问题中的一部分可能会在未来通过添加新功能和改进文档来充分解决。</p><p id="da9e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">然而，我们不应该掩盖这些问题，开发人员夸大TypeScript的好处而不考虑成本是不负责任的。</p><p id="5c9a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">TypeScript可以而且应该在类型推断、高阶函数和泛型方面做得更好。TypeScript团队也有巨大的机会来改进文档，包括教程、视频、最佳实践和易于找到的TypeScript局限性概述，这将帮助TypeScript开发人员节省大量时间，并显著降低使用TypeScript的成本。</p><p id="0b50" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我希望随着TypeScript的继续发展，更多的用户将度过蜜月期，并意识到它的成本和当前的局限性。随着用户越来越多，越来越多的优秀人才可以专注于解决方案。</p><p id="0e8a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">就TypeScript而言，我肯定会在小型开源库中再次使用它，主要是为了让其他TypeScript用户的生活更轻松。但是我不会在我的下一个大型应用程序中使用当前版本的TypeScript，因为项目越大，使用TypeScript compound的成本就越高。</p><p id="3ab2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个结论很讽刺，因为TypeScript的标语是“可伸缩的JavaScript”。一个更诚实的标语可能会加上一个词:“笨拙伸缩的JavaScript。”</p><blockquote class="mf mg mh"><p id="985f" class="jm jn ly jo b jp jq ii jr js jt il ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated"><strong class="jo hi">更新:2023–0310—</strong>添加了一个链接，链接指向2022年的一项研究，该研究分析了600多个GitHub存储库，发现TypeScript似乎并没有对bug产生显著影响。删除了一些关于“TypeScript理论上的最大好处”的令人困惑的措辞，取而代之的是强调GitHub上只有大约20%的公共bug可以通过TypeScript解决。</p><p id="e174" class="jm jn ly jo b jp jq ii jr js jt il ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated"><strong class="jo hi">更新时间:2019–02–11</strong>—澄清Airbnb如何在添加TypeScript后报告bug减少38%，而不使本文中的任何主张无效。TL；DR——高于平均水平的设计/规格评审+低于平均水平的测试覆盖率可能导致高于平均水平的剩余缺陷的ts可寻址百分比，而不会实质性地改变所有措施所防止的缺陷的总百分比。<br/> <strong class="jo hi">更新时间:2019年1月26日</strong> —增加了“重构”的好处。<br/> <strong class="jo hi">更新日期:2019年1月26日</strong> —澄清了减少bug的数学方法，将减少bug的好处从剩余bug的8%增加到20%，以使TypeScript获得最大的好处，并证明它仍然不会对ROI产生重大影响。</p></blockquote></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><p id="1c70" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi"><em class="ly">Eric Elliott</em></strong><em class="ly">是一位分布式系统专家，著有《编写软件》</em><a class="ae ki" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"><em class="ly"/></a><em class="ly"/><a class="ae ki" href="https://ericelliottjs.com/product/programming-javascript-applications-ebook/" rel="noopener ugc nofollow" target="_blank"><em class="ly">【编程JavaScript应用】</em> </a> <em class="ly">等书籍。作为</em><a class="ae ki" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="ly">devanywhere . io</em></a><em class="ly">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，并为Adobe Systems、</em><strong class="jo hi"><em class="ly">【Zumba Fitness、</em> </strong> <em class="ly"> </em> <strong class="jo hi"> <em class="ly">【华尔街日报、</em></strong><em class="ly"/><strong class="jo hi"><em class="ly">【ESPN、</em></strong><em class="ly"/><strong class="jo hi"><em class="ly">BBC、</em> </strong> <em class="ly">以及包括</em> <strong class="jo hi"> <em class="ly"> Usher、弗兰克·奥申、金属乐队在内的</em></strong></p><p id="0b51" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>