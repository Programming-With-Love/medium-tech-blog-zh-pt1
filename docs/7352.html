<html>
<head>
<title>Reliable Webhooks Using Serverless Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器架构的可靠Webhooks</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/reliable-webhooks-using-serverless-architecture-e009a2096732?source=collection_archive---------0-----------------------#2018-11-27">https://medium.com/square-corner-blog/reliable-webhooks-using-serverless-architecture-e009a2096732?source=collection_archive---------0-----------------------#2018-11-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="35d6" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我们如何使用SQS和拉姆达让我们的网络钩子更可靠</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/9195fd317e08de01a127556c2ab4c7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMkxLJBX6-K-8Y5phs9dnQ.jpeg"/></div></div></figure><blockquote class="ji jj jk"><p id="a46f" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ki" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="b5ff" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">对于那些已经是<a class="ae ki" href="https://squareup.com/developers" rel="noopener ugc nofollow" target="_blank"> Square开发者</a>的人来说，你可能已经听说了我们关于webhooks更加可靠的声明。如果你还没有:10月，我们发布了更加健壮和可靠的webhooks，以便更好地为开发者的应用程序提供事件服务。今天，我们将分享我们是如何做到这一点的。</p><p id="4b96" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">在大多数情况下，webhook事件将在相关事件发生后的30秒内到达，并且失败的交付将在最多72小时内重试。如果你对我们的Webhooks API如何工作感兴趣，一定要看看我们的<a class="ae ki" href="https://docs.connect.squareup.com/webhooks" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="8e31" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们能够通过将我们的webhooks基础设施的一部分转移到<a class="ae ki" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊Web服务(AWS) </a>并利用他们的SQS和Lambda服务来改进我们的webhooks。让我们简单了解一下我们的架构，以及我们是如何实现这一转变的。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><p id="b912" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">在我们开始之前，这里有一个对理解这篇文章有用的术语列表:</p><ul class=""><li id="f9e7" class="kt ku hh jo b jp jq js jt kj kv kk kw kl kx kh ky kz la lb bi translated">Webhook(也称为web回调或推送API)是由特定事件触发的HTTP调用或代码片段。对于典型的API，您必须定期调用以检测数据的变化。Webhooks用即时、实时的通知取代了常规的API调用。</li><li id="13ac" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated"><strong class="jo hi">无服务器架构</strong> —一种基于使用可配置的第三方后端服务而不是内部服务器的设计模式。一个很好的总结可以在<a class="ae ki" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="49d2" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated"><strong class="jo hi">亚马逊网络服务(AWS) </strong> —亚马逊的云计算平台，基于每次使用提供无数的通用服务。</li><li id="f2c3" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated"><strong class="jo hi"> Lambda </strong> —运行代码以响应事件并自动管理代码所需的计算资源的AWS服务。</li><li id="9a15" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated"><strong class="jo hi"> SQS </strong> —提供分布式消息队列的AWS服务。</li></ul></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><h2 id="f72c" class="lh li hh bd lj lk ll lm ln lo lp lq lr kj ls lt lu kk lv lw lx kl ly lz ma mb bi translated">我们的网钩简史</h2><p id="cd27" class="pw-post-body-paragraph jl jm hh jo b jp mc ii jr js md il ju kj me jx jy kk mf kb kc kl mg kf kg kh ha bi translated">从高层次来看，我们的webhooks架构遵循<a class="ae ki" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅模式</a>:有一组生产者、一条消息总线和一组消费者。一个典型的webhook事件将由生产者推入发布提要，由消息总线通过查看webhook订阅数据进行处理，然后转发给适当的消费者提要。消费者馈送将继续向订阅的端点发出POST通知，并处理可能发生的任何错误。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mh"><img src="../Images/9e305a378b7552479dd66f0b7aaaa968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_vC7TQGTOGGNXhJlWAHmw.png"/></div></div></figure><p id="198f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">通过这种模式，成千上万的用户每天可以获得数百万的网页链接。以前的系统是在Square内部实现的，超出了最初的设计处理能力。随着不为人知的错误浮出水面，代码复杂性持续增加，这一点变得越来越明显。毫不奇怪，构建一个定制的分布式消息传递系统并不容易。结果是订阅webhooks的开发人员不得不忍受不太理想的可靠性和有限的特性集。</p><p id="d108" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">考虑到这一点，我们重新开始，并确定了我们的目标:</p><ul class=""><li id="8e94" class="kt ku hh jo b jp jq js jt kj kv kk kw kl kx kh ky kz la lb bi translated">加快我们向客户提供功能的速度。</li><li id="4116" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">降低系统复杂性和操作负担。</li><li id="c9ca" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">通过使用记录完善、常用且经过验证的基础设施来提高可靠性。</li><li id="b2d7" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">支持全面的监控和分析。</li></ul><p id="31f7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">为了实现这些目标，该团队得出结论，生产者部分可以保持原样，因为它建立在Square其余部分使用的技术之上，但为webhooks定制的消费者部分将受益于重建。考虑到我们的目标，在云中重新实现它是最有意义的；开发速度会更快，最终产品会比另一个内部迭代更可靠。</p><h1 id="840a" class="mi li hh bd lj mj mk ml ln mm mn mo lr in mp io lu iq mq ir lx it mr iu ma ms bi translated">向云迁移</h1><p id="322f" class="pw-post-body-paragraph jl jm hh jo b jp mc ii jr js md il ju kj me jx jy kk mf kb kc kl mg kf kg kh ha bi translated">在主要云服务上进行原型开发后，我们决定使用AWS，因为它提供了最简单和最优雅的解决方案，这要归功于一个<a class="ae ki" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html" rel="noopener ugc nofollow" target="_blank">新功能</a>，它允许我们配置Lambdas自动从SQS拉取。另一个好处是我们对AWS的熟悉，以及它对Go的支持，这是我们首选的编程语言之一。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/a5b5fb299b8ecfaceeddf3d361bd959b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXhm36lcxEfRxN1LHdDBTA.png"/></div></div></figure><p id="1f42" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">架构图显示了我们的最终设计:对于每个应用程序，我们提供一个由Lambdas轮询的SQS队列，由一个共享的<a class="ae ki" href="https://en.wikipedia.org/wiki/Dead_letter_queue" rel="noopener ugc nofollow" target="_blank">死信队列</a>和度量队列支持。这为我们提供了管理每个应用程序的灵活性，例如动态更新和删除消息，以及通过设置并发Lambda执行的最大数量来限制吞吐量。死信队列(DLQ)是一个<a class="ae ki" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank"> AWS特性</a>，用于处理由于任何原因无法处理的消息，这些消息将被存放在这个单独的队列中进行诊断。共享指标队列保存信息性指标，如状态代码、时间戳和交付结果。</p><p id="4c53" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">在这个新系统中，交通流量简单明了。一旦消息总线计算出事件和订户，它就将信息转发给AWS，并在那里将其放入SQS队列中。运行我们的定制逻辑的Lambda自动从队列中取出，并试图将事件发送给指定的订阅者。如果发送成功，消息将被标记为完成，并从系统中删除。如果发送失败，消息将重新排队进入SQS，并配置设置适当的重试回退时间。</p><p id="c824" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这个系统的优点在于它的简单。缩放、速率限制、错误处理和基本监控都是通过使用Amazon提供的现有工具进行配置来完成的。对于额外的数据点，我们实现了额外的<a class="ae ki" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html" rel="noopener ugc nofollow" target="_blank">自定义指标</a>，这些指标在Lambdas中创建，并转发到指标队列，以定期进行监控、警报和分析。</p><h1 id="2463" class="mi li hh bd lj mj mk ml ln mm mn mo lr in mp io lu iq mq ir lx it mr iu ma ms bi translated">部署Lambdas</h1><p id="9374" class="pw-post-body-paragraph jl jm hh jo b jp mc ii jr js md il ju kj me jx jy kk mf kb kc kl mg kf kg kh ha bi translated">我们认为部署应该遵循我们现有工作流程设定的最佳实践。这意味着新代码首先被提交到一个阶段化环境中，并且构建通过自动化的(适当的话，手动的)验收测试被彻底验证为生产就绪。访问权限通过内部系统和AWS的<a class="ae ki" href="https://aws.amazon.com/iam/" rel="noopener ugc nofollow" target="_blank"> IAM </a>角色来实施。</p><p id="bb0f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们在AWS SDK的基础上构建了一套强大的工具来帮助本地开发、故障排除、推广和补救。例如，更新Lambda需要将代码上传到<a class="ae ki" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> AWS S3 </a>，调用ListLambda API获取所有的Lambda，然后更新Lambda API。</p><p id="4131" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这些工具支持以下典型工作流:</p><ul class=""><li id="324e" class="kt ku hh jo b jp jq js jt kj kv kk kw kl kx kh ky kz la lb bi translated">独立测试新的AWS依赖项。</li><li id="dd40" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">在本地创建新的特征变化。</li><li id="beb4" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">在AWS中提供一个子系统，以手动验证端到端场景。</li><li id="b4f0" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">编写测试。</li><li id="d618" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">打开一个PR，一旦批准，提交变更。</li><li id="3c4b" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">将更改部署到临时环境中。验收测试必须是绿色的，部署才能完成。</li><li id="e7ae" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated">将更改部署到生产环境中。</li></ul><h1 id="3bab" class="mi li hh bd lj mj mk ml ln mm mn mo lr in mp io lu iq mq ir lx it mr iu ma ms bi translated">监控和测试</h1><p id="e397" class="pw-post-body-paragraph jl jm hh jo b jp mc ii jr js md il ju kj me jx jy kk mf kb kc kl mg kf kg kh ha bi translated">监控是确保生产服务成功的核心要素之一。我们收集可量化的匿名数据，以确保我们的服务是最佳的和可操作的。</p><p id="ca63" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们有以下监测手段:</p><ul class=""><li id="ff7e" class="kt ku hh jo b jp jq js jt kj kv kk kw kl kx kh ky kz la lb bi translated"><strong class="jo hi"> CloudWatch日志</strong>。CloudWatch是一项提供主动监控的AWS服务。日志记录语句由系统和Lambda逻辑打印。出于调试目的，我们通常打印信息性和错误消息。</li><li id="3070" class="kt ku hh jo b jp lc js ld kj le kk lf kl lg kh ky kz la lb bi translated"><strong class="jo hi">信号FX</strong>T4】仪表盘和警报。Square使用总部位于SaaS的监测和分析平台SignalFx。对于内部监控，它是全面的-所有对AWS的API调用都受到监控，AWS中的所有流量都通过SignalFx与CloudWatch的直接集成或我们从指标队列中提取的数据进行监控。所有仪表板都有警报支持，一旦满足特定条件，就会触发警报。</li></ul><p id="41f8" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">单元测试是为单个功能或一小组功能编写的。它们位于遵循<a class="ae ki" href="https://www.golang-book.com/books/intro/12" rel="noopener ugc nofollow" target="_blank"> Go测试惯例</a>的产品代码旁边。它们必须在代码被推入主模块之前通过。</p><p id="7f6b" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">集成和CI测试类似于单元测试，只是范围扩大了。他们测试多个系统或者端到端的系统，并且是进入阶段的构建的把关者。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><p id="b596" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这只是开始！有兴趣加入我们吗？点击查看我们的招聘职位<a class="ae ki" href="https://square.jobs" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a5d2" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">要使用Square进行构建，请在<a class="ae ki" href="https://squareup.com/developer" rel="noopener ugc nofollow" target="_blank">https://squareup.com/developer</a>注册一个帐户，加入我们的<a class="ae ki" href="https://squ.re/slack" rel="noopener ugc nofollow" target="_blank"> Slack社区</a>，和/或注册我们的<a class="ae ki" href="https://www.workwithsquare.com/developer-newsletter.html?channel=Online%20Social&amp;sqmethod=Blog" rel="noopener ugc nofollow" target="_blank">时事通讯</a>。</p></div></div>    
</body>
</html>