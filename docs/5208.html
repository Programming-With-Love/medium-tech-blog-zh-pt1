<html>
<head>
<title>In Mendix how long is a String?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Mendix中，一个字符串有多长？</h1>
<blockquote>原文：<a href="https://medium.com/mendix/in-mendix-how-long-is-a-string-846b04d96770?source=collection_archive---------2-----------------------#2022-10-13">https://medium.com/mendix/in-mendix-how-long-is-a-string-846b04d96770?source=collection_archive---------2-----------------------#2022-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="70a6" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">这是我关于Mendix应用效率系列博客的第二篇。在这个系列的第一部分中(Mendix 中的<a class="ae jj" rel="noopener" href="/p/86a02a4c70a3">健康和效率)，我强调了一些可以提高低代码效率的简单方法。现在我将尝试解决一些更棘手的问题。</a></h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/fb173d6f5e8d781a44b1cd8af8116eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfyVmHwQiq5qtNBVDyXcwA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">In Mendix how long is a String?</figcaption></figure><p id="59c1" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在过去的五年中，我不得不两次处理这样的需求:浏览所有的数据并从中构建一个文本文件。</p><p id="80e5" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">第一个是在Mendix应用程序中生成一个表示一组数据的制表符分隔的文本文件。第二个要求从应用程序中内置的一组数据创建一个Typescript文件。这两个<strong class="bd kv">都需要支持创建非常长的文本文件</strong>，因为数据集可能非常大。</p><p id="fc0c" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在市场上有很棒的模块(例如<a class="ae jj" href="https://marketplace.mendix.com/link/component/108605" rel="noopener ugc nofollow" target="_blank"> CSV </a>模块)可以帮助CSV/TSV文件的制作，但是更多的任意文本输出需要一个替代的解决方案。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff kw"><img src="../Images/35b66a36ece792b0d891a4efc90604cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BavX6fUbzNGWaYcF9567BA.jpeg"/></div></div></figure><h1 id="1b15" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">测试练习</h1><p id="2829" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated"><em class="lu">为了收集统计数据进行比较，我使用了一个在</em><strong class="bd kv"><em class="lu">Mendix 9 . 15 . 1</em></strong><em class="lu">中创建的应用程序，部署在一个</em> <strong class="bd kv"> <em class="lu">中型</em> </strong> <em class="lu">环境(</em> <strong class="bd kv"> <em class="lu">最多2个CPU，最大2GB内存，Postgres数据库</em> </strong> <em class="lu">)中，运行在一个</em> <strong class="bd kv"> <em class="lu"> AWS EKS私有Mendix云上</em></strong></p><p id="1bb1" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">每次练习都是</em> <strong class="bd kv"> <em class="lu">运行五次</em> </strong> <em class="lu">。在每组五个练习运行t </em> <strong class="bd kv"> <em class="lu">之前，他停止并启动app</em></strong><em class="lu">以尽量减少可能的</em> <strong class="bd kv"> <em class="lu">缓存</em> </strong> <em class="lu">对结果的影响。</em> <strong class="bd kv"> <em class="lu">最好和最差的结果被丢弃</em> </strong> <em class="lu">和</em> <strong class="bd kv"> <em class="lu">其他三个结果被平均</em> </strong> <em class="lu">。这些练习不一定要按照这里给出的顺序进行。</em></p><p id="0d6e" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">使用的app在GitHub </em> <a class="ae jj" href="https://github.com/Adrian-Preston/HowLongIsAString" rel="noopener ugc nofollow" target="_blank"> <em class="lu">这里</em> </a></p><div class="lv lw fm fo lx ly"><a href="https://github.com/Adrian-Preston/HowLongIsAString" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">GitHub-Adrian-Preston/howlongisatring:Mendix app支持博文一个字符串有多长…</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ju ly"/></div></div></a></div><h1 id="ab4c" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">起点</h1><p id="7a56" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">我们有一个Mendix对象的列表，我们有一个微流，它将从这些对象中的一个生成我们想要的文本。为了简单起见，我将只处理一个数据实体，尽管在实际场景中可能会涉及到大量的对象树。<strong class="bd kv"> OutputDocument是FileDocument专门化，它接收字符串生成过程</strong>的结果。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/5e2ee060906dc7b64cf2356bf1acaa8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*i8147Stt2g96uZr-p1RX_w.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The Business Entity and Output Document in the domain model</figcaption></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mo"><img src="../Images/ff9b43012ca53971048f3e719825920d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*y661xOoQEbgPHawmadQaig.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The GetEntityToString microflow that generates the text for an instance of BusinessEntity</figcaption></figure><p id="947d" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了生成输出文件，我们以2，500条记录为一批提取数据记录，传递对象列表，并将为每个对象生成的文本附加到一个不断增长的集合字符串中。当列表用完时，我们累积的字符串被写入OutputDocument。创建的OutputDocument还记录了使用的算法、处理的记录数量、运行测试花费的时间以及生成文件的散列。生成并保存散列，以便我们可以确认用于生成相同输出的所有方法都来自相同的源数据。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mp"><img src="../Images/7a937835cad8011d2fee9215e6859828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dF1gTQ3-nkoHkpvMiQdPQ.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">TheStartingPointBuildString microflow</figcaption></figure><h1 id="cce2" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">让我们运行这个。</h1><p id="7057" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">我用<strong class="bd kv">的25，000条记录</strong>和<strong class="bd kv">的各500个字符的“随机”文本串</strong>和随机整数值填充数据库，然后运行上面的微流。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mq"><img src="../Images/96a3d9ca1f2e72efad5cbd00b8b0a68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44ZgFfrd4qSHbws4no0nkg.png"/></div></div></figure><p id="0fa3" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这给了我们平均78.81秒的时间来构建字符串并将其保存到FileDocument中。现在让<strong class="bd kv">将数据</strong>的大小加倍到<strong class="bd kv"> 50，000个</strong>记录，并重新运行微流。我想我们可能期望它在200秒内完成。我们至少应该假设，尽管我们在键上有一个索引，但是随着记录量的增加，批量检索会变慢。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mq"><img src="../Images/aa3713a439856ee0da5a2626dfebd375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmZDFxps5SDmiDAiQICzhw.png"/></div></div></figure><p id="18fd" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">哦哇！所以平均时间是334.05秒。我不会尝试一个非常大的数据集，除非我有一两部电影可以看…</p><p id="1e03" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么，为什么数据量翻倍会导致运行时间增加四倍呢？</p><p id="6b64" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">嗯，如果不使用分析工具，我们无法完全确定，但是我们可以对主要原因做出明智的猜测。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mr"><img src="../Images/8221afc3ab8bb163b1f559b75306a6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoMzmMQZxgRmpC908t1VpQ.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">TheStartingPointBuildString excerpt</figcaption></figure><p id="5022" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Change Variable操作将从GetEntityToString子微流返回的字符串附加到已经存储在输出变量中的先前结果。只不过它并不完全是这样。<strong class="bd kv">在Mendix中，一个字符串是不可变的</strong>，因此为了创建输出变量的新值，<strong class="bd kv"> Mendix必须创建一个新的字符串</strong>，该字符串由附加了EntityOutput副本的原始输出的副本<strong class="bd kv">组成，并且保存该新字符串来代替先前的输出值，先前的输出值被丢弃。</strong></p><blockquote class="ms"><p id="0d78" class="mt mu hu bd mv mw mx my mz na nb ku ek translated">随着输出中的值变得越来越长，文本复制的数量增加，这个过程变得越来越耗费时间和资源。</p></blockquote><p id="dcf1" class="pw-post-body-paragraph ka kb hu bd b kc nc iv ke kf nd iy kh ki ne kk kl km nf ko kp kq ng ks kt ku hn dt translated">因此，让我们尝试使用一些Java代码进行一点重新设计<strong class="bd kv">,看看我们是否可以避免长字符串的重复复制，并降低执行时间。</strong></p><h1 id="e941" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">存储缓冲器</h1><p id="3037" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">我们不是在Mendix变量字符串中构建长字符串，而是在一个缓冲区中构建字符串，该缓冲区存储在当前用户操作的上下文中，然后在最终存储区缓冲到FileDocument中。上下文只能从Java操作中访问，所以我们必须用Java来构建它。</p><p id="2291" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们使用的微流与原始微流非常相似，但它调用一个Java动作将下一个字符串追加到存储在上下文内存中的缓冲区，并调用另一个Java动作将完成的内容移入最后的FileDocument。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nh"><img src="../Images/e413b42cd07566681d74a0ff0c72c12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdySJmtZG9ptBi2wVHwwaA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">MemoryBufferBuildString microflow</figcaption></figure><p id="3e7e" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这两个Java动作看起来像这样。我们使用ByteArrayOutputStream来存储数据，然后将数据转换为ByteArrayInputStream，将结果移动到FileDocument中。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ni"><img src="../Images/1d0022063a399dd620d8df13e001cc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ej2sB1oXpVn2YS4Hs4Vfw.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">AppendStringToMemoryBuffer Java action</figcaption></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nj"><img src="../Images/bd1abae024ece82370ca6d2c56b97dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHgBXPhOMctgMiYAB3l-MQ.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">MoveMemoryBufferToDocument Java action</figcaption></figure><h2 id="2586" class="nk ky hu bd kz nl nm nn ld no np nq lh ki nr ns lj km nt nu ll kq nv nw ln nx dt translated"><strong class="ak">那么当我们运行这个函数时，我们得到了什么？</strong></h2><p id="79de" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">对于<strong class="bd kv">的25，000条记录</strong>，我们得到的平均值为<strong class="bd kv"> 1.90秒</strong>。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mq"><img src="../Images/3a18b10343c62c5011de5a867f0b937c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVUBmPaN6xbM8S-16pwjng.png"/></div></div></figure><p id="ad67" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">对于<strong class="bd kv">的50，000条记录</strong>，我们得到的平均值为<strong class="bd kv"> 2.94秒</strong>。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mq"><img src="../Images/cb75cac9d702c0bd1ff680680ebb9773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mtUwCMBnszwO36N63-F1A.png"/></div></div></figure><p id="434e" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我想你会同意这是对原始算法的显著改进(334秒对3秒)。这似乎表明我们的方向是正确的。</p><p id="e68d" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是我们能进一步改进吗？虽然速度大大提高了，但我们在应用程序的内存缓冲区中存储了大量文本，最终可能会给Mendix运行时内存带来压力。</p><h1 id="4d39" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">文件缓冲区</h1><p id="ac1e" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">另一种方法可能会减轻潜在的内存使用问题，并且仍然比原来的方法执行得更好。这个版本的流程将生成的文本写入一个临时文件，这样我们就不必将它保存在Mendix运行时内存中。</p><p id="2f72" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这个选项更复杂，需要使用两个微流和两个Java动作。第一微流调用第一Java动作，第一Java动作调用第二微流，第二微流调用第二Java动作。其原因将在后面解释。</p><p id="22b5" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">要启动FileBufferBuildString微流，需要进行一些设置，然后调用BuildStringInFileBuffer Java操作，最后将补充结果(散列、记录计数和时间)保存在文档中。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ny"><img src="../Images/3567d962892946ee99647d5e51ba6d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-rhH0-wBpiDwcw2l6E_7Q.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">FileBufferBuildString microflow</figcaption></figure><p id="a247" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">BuildStringDocumentInFileBuffer Java操作接受FileDocument和一个微流指针(该微流的可选参数)，在Java临时文件位置创建临时文件，将打开的文件详细信息存储在上下文内存中，然后调用指针中给出的微流。当微流返回时，它将临时文件的内容读入FileDocument并进行清理，删除文件和上下文对象。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff nz"><img src="../Images/eca94170a4060d595a60b1f3a0cab2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuNzp9GtnNtqufIiZjj49g.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">BuildStringDocumentInFileBuffer Java Action</figcaption></figure><p id="5370" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">SUB_FileBufferBuildString微流由BuildStringDocumentInFileBuffer Java操作调用。它运行读取记录批的循环，为每个记录生成字符串，然后调用AppendStringToFileBuffer Java操作来保存它们。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff oa"><img src="../Images/2bfd8cc50536560fc757041b359bf108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JykxJnV8EvysjaRzoGYDA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">SUB_FileBufferBuildString microflow</figcaption></figure><p id="a44c" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">AppendStringtoFileBuffer Java操作从上下文中提取临时文件信息(由BuildStringDocumentInFileBuffer保存在那里),并将单个记录的字符串写入临时文件的末尾。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ob"><img src="../Images/5bb00b1d38a09466544abd1aa088e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luyBNfskarRcUvAlf2Jk2A.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">AppendStringToFileBuffer Java action</figcaption></figure><p id="39a5" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好的，所以这种安排(<strong class="bd kv">微流调用-java调用-微流调用-java </strong>)有点复杂，可以被认为是晦涩的，并且违背了我在之前的博客文章中所说的(可读性与可维护性)，<strong class="bd kv">，所以应该为后来的开发人员做好记录</strong>。</p><p id="2a00" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这种方法有一个很好的理由——它是安全的。如果在这个过程中出现任何问题，第一个Java动作可以在返回到第一个微流之前清除临时文件和打开的文件描述符，因此应用程序作为一个整体受到损害的可能性较小。这篇博客附带的应用程序中还有一个替代方案(称为TempStorage)——参见<a class="ae jj" href="https://github.com/Adrian-Preston/HowLongIsAString" rel="noopener ugc nofollow" target="_blank">GitHub上的一个字符串有多长</a><em class="lu">——</em>，它不使用微流和Java动作的嵌套，但确实要求调用者在出错时更加小心地清理。</p><p id="7a95" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么结果如何呢？对于<strong class="bd kv">25000条记录</strong>花费了<strong class="bd kv"> 1.23 </strong>秒，对于<strong class="bd kv">50000条记录</strong>花费了<strong class="bd kv"> 2.75秒</strong>。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff oc"><img src="../Images/5b88b7b467a23d288b21d31d69a39f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13-zQ6dAfPP5BzgS_EbyDQ.png"/></div></div></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff oc"><img src="../Images/9e0279fd9364c1e76dd90230d6ed7790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLYakuvtp83MeiJvbv08pA.png"/></div></div></figure><p id="0cfa" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">内存缓冲区</em>和<em class="lu">文件缓冲区</em>在性能上非常接近，但是我们现在可以看到，最初的<em class="lu">起点</em>算法是三个算法中性能最差的，在本练习中，我们不再需要使用它。我们能在另外两个中选择吗？</p><h1 id="7eec" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">比赛结束了</h1><p id="7f0d" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">在比较这些解决方案时，我提到内存使用是另一个因素，所以我也应该得到一些统计数据。为了提高清晰度，让我们使用更大的测试数据样本— <strong class="bd kv"> 500，000条记录</strong>。</p><p id="c964" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">设置填充，然后重启应用程序，运行一次<em class="lu">内存缓冲</em>进程。在这个私有云上设置了<strong class="bd kv"> Grafana </strong>之后，我们可以获得一些关于资源使用情况的信息:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/6fec4d80e180ecac9a368ca8141223e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vS_h6VgbONwawPZ5_Hc1Uw.png"/></div></div></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/56d7de251ccbdfd96dfbe4168515942f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4INZsVjdr8oe-IE93czGfg.png"/></div></div></figure><p id="1f38" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">哎哟！<strong class="bd kv"> <em class="lu">内存缓冲区</em> </strong> <em class="lu"> </em> <strong class="bd kv">不够强大</strong>无法处理这种大小的作业，应用程序在AppendStringToMemoryBuffer中填充缓冲区时耗尽了内存。<em class="lu">文件缓冲</em>会做得更好吗？重新启动app，运行<strong class="bd kv"> <em class="lu">文件缓冲</em> </strong>:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/d31bee390ac1f61b91d6013b9a9fbba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_Efz3BiqYhEoKZmElEwJA.png"/></div></div></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/f4106d318f5fff3302102a7d0cd252a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTkzsfGhyFpn-Us9K_QRyw.png"/></div></div></figure><p id="c73a" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">等等！因此<em class="lu">文件缓冲区</em>也失败了，但是在成功创建并填充FileDocument之后，在将生成的整个文件读取到一个字符串(CommunityCommons StringFromFile)以计算数据的哈希值的过程中，该缓冲区因内存不足而终止。文件太大，无法执行该操作。所以我禁用了读取字符串并调用散列操作(使用常数)的代码，重新运行这个过程，它工作了。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/9a62c6d2a034f7f2071718b910aab0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1zfGfVar0s9T7QVe2KU_A.png"/></div></div></figure><p id="ff61" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以，是的，它完成了，我们似乎有一个赢家！</p><p id="ceb2" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了更好的测量，我建立了一个<strong class="bd kv"> 1，000，000记录</strong>数据集，并再次运行<em class="lu">文件缓冲区</em>，这也完成了。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/9692b4dce91e434691b2779ad3c40019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4eSrkJ0qxzdK_AjCygtAw.png"/></div></div></figure><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff oe"><img src="../Images/b4172947f9467f39dfe09267b8dc1eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uS2y4i7izONUPtw01A6TLQ.png"/></div></div></figure><h1 id="4448" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">您的里程可能会有所不同</h1><p id="fa53" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">当然，所有这些在现实世界中的表现取决于本文范围之外的许多因素，但我希望这有助于展示在特殊情况下，如何提高字符串生成的弹性和性能，以及一般情况下如何使用Java来提高性能。</p><p id="681c" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我的下一篇效率文章中，我计划展示如何利用内置的Mendix任务队列功能来改进一些冗长的操作。</p><h1 id="7f95" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">感谢</h1><p id="591c" class="pw-post-body-paragraph ka kb hu bd b kc lp iv ke kf lq iy kh ki lr kk kl km ls ko kp kq lt ks kt ku hn dt translated">我感谢阿扬·维斯的宝贵建议，感谢阿扬·兰默斯在这篇文章的顶部提到的很酷的CSV模块，我毫不羞耻地从那里借鉴了一些想法。</p><h2 id="ce4a" class="nk ky hu bd kz nl nm nn ld no np nq lh ki nr ns lj km nt nu ll kq nv nw ln nx dt translated">阅读更多</h2><div class="lv lw fm fo lx ly"><a href="https://grafana.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">Grafana:开放观察平台</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">Grafana是适用于所有数据库的开源分析和监控解决方案。</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">grafana.com</p></div></div><div class="mh l"><div class="of l mj mk ml mh mm ju ly"/></div></div></a></div><div class="lv lw fm fo lx ly"><a href="https://docs.mendix.com/refguide/java-actions/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">Java操作</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">描述如何使用Java操作来扩展Mendix应用程序的功能。</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lv lw fm fo lx ly"><a href="https://docs.mendix.com/howto/monitoring-troubleshooting/detect-and-resolve-performance-issues/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">检测并解决性能问题</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">描述可能的性能问题及其根本原因和解决方法。</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">docs.mendix.com</p></div></div></div></a></div></div><div class="ab cl og oh hb oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="hn ho hp hq hr"><p id="a9a0" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">来自发布者- </em></p><p id="c6f9" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你喜欢这篇文章，你可以在我们的 <a class="ae jj" href="https://medium.com/mendix" rel="noopener"> <em class="lu">中页</em> </a> <em class="lu">找到更多喜欢的。对于精彩的视频和直播会话，可以去</em><a class="ae jj" href="https://www.mendix.com/live/" rel="noopener ugc nofollow" target="_blank"><em class="lu">MxLive</em></a><em class="lu">或者我们的社区</em><a class="ae jj" href="https://www.youtube.com/c/MendixCommunity/community" rel="noopener ugc nofollow" target="_blank"><em class="lu">Youtube PAG</em></a><em class="lu">e .</em></p><p id="eaf5" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">对于希望入门的创客，您可以注册一个</em> <a class="ae jj" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="lu">免费账户</em> </a> <em class="lu">，并通过我们的</em> <a class="ae jj" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="lu">学院</em> </a> <em class="lu">获得即时学习。</em></p><p id="81ed" class="pw-post-body-paragraph ka kb hu bd b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="lu">有兴趣加入我们的社区吗？加入我们的</em> <a class="ae jj" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="lu">松弛社区频道</em> </a> <em class="lu">。</em></p></div></div>    
</body>
</html>