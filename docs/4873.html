<html>
<head>
<title>The Perils of Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继承的危险</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/the-perils-of-inheritance-698b777fa773?source=collection_archive---------1-----------------------#2018-12-12">https://blog.kotlin-academy.com/the-perils-of-inheritance-698b777fa773?source=collection_archive---------1-----------------------#2018-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3181607cd68ad0c2d4595afb1de5b87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FRh8-w0-heOF2k0l"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Helloquence</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="53d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文将展示类继承的危险。本文将说明类继承的替代方法——组合。看完这篇文章，你就会明白为什么Kotlin默认所有类都是final了。这篇文章将解释为什么除非有充分的理由，否则不应该创建Kotlin类。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="4c7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有以下接口:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 1: Insertable interface</figcaption></figure><p id="a069" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，<code class="fe ky kz la lb b">BaseInsert</code>是<code class="fe ky kz la lb b">Insertable&lt;Number&gt;</code>接口的一个实现。<code class="fe ky kz la lb b">BaseInsert</code>是<code class="fe ky kz la lb b">open</code>。所以，我们可以延长<code class="fe ky kz la lb b">BaseInsert</code>。</p><p id="389c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望<code class="fe ky kz la lb b">CountingInsert</code>扩展<code class="fe ky kz la lb b">BaseInsert</code>。每次代码插入一个<code class="fe ky kz la lb b">Number</code>，代码必须将变量<code class="fe ky kz la lb b">count</code>加1。所以，我们有:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 2: count algorithm implemented through inheritance</figcaption></figure><p id="2f88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种实现应该是可行的。第8行增加一个<code class="fe ky kz la lb b">count</code>；第13行是变量参数的个数。</p><p id="4c38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码没有按预期工作。参见下面图3的第7行。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig 3. CountingInsert() produces wrong result</figcaption></figure><p id="4ee0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题出现在下面图4的第10行:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 4: Implementation of BaseInsert</figcaption></figure><p id="d6cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">BaseInsert.insertAll</code>功能是一种便利功能。<code class="fe ky kz la lb b">insertAll</code>函数为<code class="fe ky kz la lb b">vararg</code>列表中的每一项调用<code class="fe ky kz la lb b">insert</code>。<code class="fe ky kz la lb b">CountingInsert</code>类重复计算了整数3和4的插入。<code class="fe ky kz la lb b">CountingInsert.insertAll</code>执行语句<code class="fe ky kz la lb b">count++</code>两次；语句<code class="fe ky kz la lb b">count += items.size</code>一次。<code class="fe ky kz la lb b">CountingInsert.insertAll</code>功能将<code class="fe ky kz la lb b">count</code>增加了四个而不是两个。</p><p id="4698" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有其他选择吗？是的。我们可以修改代码，也可以使用合成。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="7259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更改代码似乎是一个显而易见的解决方案。假设我们被允许改变基类。我们可以将<code class="fe ky kz la lb b">BaseInsert.insertAll</code>的实现改为:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 5 Updated implementation of BaseInsert.insertAll</figcaption></figure><p id="0e7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个实现避免了调用<code class="fe ky kz la lb b">BaseInsert.insert()</code>，这是我们麻烦的来源。</p><p id="ddec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们没有访问<code class="fe ky kz la lb b">BaseInsert</code>类的权限。然后我们可以移除对<code class="fe ky kz la lb b">insertAll()</code>的覆盖。参见图6:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig 6. CountingInsert class with the override to insertAll removed</figcaption></figure><p id="2f62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过修改代码来解决问题是脆弱的。<code class="fe ky kz la lb b">CountingInsert</code>类依赖于<code class="fe ky kz la lb b">BaseInsert</code>的实现细节。有更好的方法吗？对，就用构图吧。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="0f0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图7是通过组合的实现:</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 7: Implementation by Composition</figcaption></figure><p id="52c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设<code class="fe ky kz la lb b">BaseInsert</code>类使用图4的实现。当我们测试<code class="fe ky kz la lb b">InsertDelegation</code>类时，结果是正确的。参见下面图8的第15行。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig 8.: Test results for CompositionInsert</figcaption></figure><p id="a8bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比较图2和图7，<code class="fe ky kz la lb b">insert</code>和<code class="fe ky kz la lb b">insertAll</code>的实现是相似的。参见图9。下面。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 9: comparison of Inheritance vs composition</figcaption></figure><p id="ea56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了一个例外，可比较的方法是相同的。继承用途<code class="fe ky kz la lb b">super</code>；构图用途<code class="fe ky kz la lb b">insertable</code>。比较第3行和第12行；和7相对于图8的16。委托模式将插入任务留给了<code class="fe ky kz la lb b">insertable</code>。<code class="fe ky kz la lb b">CompositionInsert</code>类递增<code class="fe ky kz la lb b">count</code>变量。相比之下，继承打破了<code class="fe ky kz la lb b">BaseInsert</code>类的封装。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="41e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题的根本原因是什么？假设<code class="fe ky kz la lb b">BaseInsert</code>不是<code class="fe ky kz la lb b">open</code>。参见图4的第1行。如果<code class="fe ky kz la lb b">BaseInsert</code>是<code class="fe ky kz la lb b">final</code>，那么Kotlin编译器会将图2和图5中的代码标记为错误。只有图7中的解决方案是可行的。当我们制作<code class="fe ky kz la lb b">BaseInsert</code>类<code class="fe ky kz la lb b">final</code>时，<code class="fe ky kz la lb b">BaseInsert</code>的封装并没有被打破。</p><p id="179b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">科特林明白遗传的危险。Kotlin禁止继承，除非开发者将类标记为<code class="fe ky kz la lb b">open</code>。结论:一般来说，Kotlin类应该是<code class="fe ky kz la lb b">final</code>类，除非有很好的理由让它成为<code class="fe ky kz la lb b">open</code>类。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="5746" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你需要Kotlin工作室吗？访问我们的网站，看看我们能为你做些什么。</p><p id="4d6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae jz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae jz" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi lp"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>