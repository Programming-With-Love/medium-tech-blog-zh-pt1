# 从利用的角度理解程序存储器

> 原文：<https://medium.com/walmartglobaltech/understanding-program-memories-from-exploitation-point-of-view-822a1496dc26?source=collection_archive---------4----------------------->

![](img/db6ca1c8d35d3891e5ffb2bb8017d5a9.png)

Photo by [Hope House Press](https://unsplash.com/@hopehousepress?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

从内存中二进制文件的组织和这些二进制文件的汇编代码开始。我们需要理解 ELF 的概念。所以我将首先提到小精灵，然后我将移动到集合。

# 极低频

> *在计算中，可执行和可链接格式(ELF，以前称为可扩展链接格式)，是可执行文件、目标代码、共享库和核心转储的通用标准文件格式。*

你没想到吗？别担心。我来简化一下。

ELF 基本上是一种指定代码(可执行或可链接的二进制代码)如何进入内存的格式。ELF 头包含了很多关于 ELF 文件内容的信息。

可以使用下面的命令来查看编译上述代码生成的 ELF 文件的头文件。
`readelf -h ./function_call`

```
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048310
  Start of program headers:          52 (bytes into file)
  Start of section headers:          6860 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         36
  Section header string table index: 33
```

现在请注意两件事，它们对开发也很重要:

1.  **类型:** EXEC，意思是这个特殊的二进制文件是可执行的，而不是可链接的。
2.  **Data:** 2 的补码， **little endian** ，意思是这个文件是为使用 little endian 表示法的机器编译的。[它们是什么？](https://en.wikipedia.org/wiki/Endianness)

# ELF 文件如何在内存中查找？

```
 +---------------+ Highest Address 0xffffffff
                        | cmd line args |
                        | env Variable  |
                        +---------------+
                        |     STACK     |
                        +--+------------+
                        |  |            |
                        |  |            |
                        |  v         ^  |
                        |            |  |
                        |            |  |
                        +------------+--+
                        |     HEAP      |
                        +---------------+
                        | Uninitialized |
                        |   Data(BSS)   |
                        +---------------+
                        |  Initialized  |
                        |     Data      |
                        +---------------+
                        |   Read Only   |
                        |     data      |
                        |       +       |
                        |     code      |
                        +---------------+ Lowest Address 0X00000000
```

上图显示了任何 32 位二进制文件的 4GB 虚拟地址空间在加载到内存中时的样子。为了便于理解，我按照自上而下的顺序绘制了堆栈，即最高地址在顶部，最低地址在底部。让我们了解不同的部分(从上往下):

1.  第一部分存储命令行参数和在程序执行期间传递给程序的环境变量。
2.  **堆栈**:存储函数内部创建的动态变量。**不要把自己和*alloc 函数族生成的动态变量搞混了。**程序中的每个变量都是动态的，也就是说，每个变量只在运行时被分配内存。函数中通常声明的变量被存储到堆栈中。这是以相反的顺序生长的。从最高地址到最低地址。
3.  **堆**:由 ***alloc** 函数族创建的动态变量。
4.  **BSS** :这个部分存储未初始化的**(全局+静态)**变量。它们被自动初始化为 **0** 。
5.  下一部分存储变量(**全局+静态**)，它们被初始化为某个值。
6.  最后一段用二进制语言存储程序的所有**只读**变量和**代码。**

# 函数调用期间堆栈的组织。

在函数调用过程中使用堆栈来保存调用函数的状态，这样当它从被调用函数返回时就可以继续正常执行。这是函数调用后堆栈的样子。

```
 +   Previous function  |
                        |     Stack frame      |
                        |                      |
                        +----------------------+ <--- previous stack
                        |Space for return value|
                        +----------------------+
                        |Arguments for function|
                        +----------------------+
                        |    return address    |
                        +----------------------+
                        |     saved $ebp       |
                        +----------------------+
                        |                      | <---  padding 
                        +----------------------+
                        |    local variables   |
                        |                      |
                        |                      |
                        |                      |
                        |                      |
                        +----------------------+
                        |                      |
                        |                      |
                        |     unused space     |
                        +                      + 
```

# 堆栈如何增长:

现在让我们试着理解一下`$ebp`和`$esp`的用途。以及函数调用如何在堆栈中增长。

1.  **esp** :如图所示，堆栈指针或 **esp** 会在每次堆栈推送操作后不断变化。它用于保持堆栈顶部的指针(顶部向下移动)。
2.  **ebp** :在运行时，变量没有名字。它们被存储为对堆栈帧底部的引用。这个基数由 ebp 寄存器指向。这就是为什么当函数调用另一个函数时， **ebp** 寄存器的值被保存到堆栈中，并且 **ebp** 寄存器可用于存储新的堆栈帧。

# 函数调用的汇编代码

**汇编语言**可以想象就在机器语言之上。像 C 这样的高级语言首先被编译成汇编语言，然后用汇编程序翻译成机器语言。

让我们看一个函数调用代码的例子。您可以使用下面的命令来查看上面编译的 C 程序的汇编代码。
`objdump -d ./function_call`

```
0804840b <foo>:
 804840b:	55                   	push   %ebp
 804840c:	89 e5                	mov    %esp,%ebp
 804840e:	83 ec 08             	sub    $0x8,%esp
 8048411:	83 ec 0c             	sub    $0xc,%esp
 8048414:	68 d0 84 04 08       	push   $0x80484d0
 8048419:	e8 c2 fe ff ff       	call   80482e0 <printf@plt>
 804841e:	83 c4 10             	add    $0x10,%esp
 8048421:	90                   	nop
 8048422:	c9                   	leave  
 8048423:	c3                   	ret 08048424 <main>:
 8048424:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048428:	83 e4 f0             	and    $0xfffffff0,%esp
 804842b:	ff 71 fc             	pushl  -0x4(%ecx)
 804842e:	55                   	push   %ebp
 804842f:	89 e5                	mov    %esp,%ebp
 8048431:	51                   	push   %ecx
 8048432:	83 ec 04             	sub    $0x4,%esp
 8048435:	e8 d1 ff ff ff       	call   804840b <foo>
 804843a:	b8 00 00 00 00       	mov    $0x0,%eax
 804843f:	83 c4 04             	add    $0x4,%esp
 8048442:	59                   	pop    %ecx
 8048443:	5d                   	pop    %ebp
 8048444:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048447:	c3                   	ret    
 8048448:	66 90                	xchg   %ax,%ax
 804844a:	66 90                	xchg   %ax,%ax
 804844c:	66 90                	xchg   %ax,%ax
 804844e:	66 90                	xchg   %ax,%ax
```

这里我只复制了 main 和 foo 函数的代码。观察 main 对 foo 函数的调用。

1.  Main 似乎在函数调用前什么都不推。这意味着 foo 不接受任何参数。
2.  Call 指令会要求 CPU 将返回地址(指令指针旁边的地址)保存到堆栈中。这是由**调用**指令完成的，所以在代码中是不可见的。
3.  **foo** 的第一条指令是将 **$ebp** 推入堆栈。
4.  直接指令将是指向 **$ebp** 以指向 **$esp** 。
    这些指令可以分为三个部分，在下面的流程中解释。

# 缓冲器的汇编代码

在前面的**汇编语言**小节代码中，我提到了简单函数调用的代码是什么样子的。在本节中，我们将展示缓冲区在 **asm** 代码中的样子。

装配中相应的 **foo** 功能。

```
0804840b <foo>:
 804840b:	55                   	push   %ebp
 804840c:	89 e5                	mov    %esp,%ebp
 804840e:	83 ec 18             	sub    $0x18,%esp
 8048411:	83 ec 0c             	sub    $0xc,%esp
 8048414:	68 d0 84 04 08       	push   $0x80484d0
 8048419:	e8 c2 fe ff ff       	call   80482e0 <printf@plt>
 804841e:	83 c4 10             	add    $0x10,%esp
 8048421:	90                   	nop
 8048422:	c9                   	leave  
 8048423:	c3                   	ret
```

注意，两个**子**调用。

```
804840e:	83 ec 18             	sub    $0x18,%esp
8048411:	83 ec 0c             	sub    $0xc,%esp
```

现在我们可以忽略第一个 **sub** 调用，但是**第二个**调用是重要的。来自 esp 的第二个子调用实际上更新了堆栈，为 **ch** 缓冲区分配空间。注意，正如我提到的，名称在 **asm** 中什么都不是。它们只是来自$ **esp** 或$ **ebp** 的引用。