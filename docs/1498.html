<html>
<head>
<title>Learning to Use Go Reflection — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用Go反射—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/learning-to-use-go-reflection-part-2-c91657395066?source=collection_archive---------1-----------------------#2018-01-03">https://medium.com/capital-one-tech/learning-to-use-go-reflection-part-2-c91657395066?source=collection_archive---------1-----------------------#2018-01-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="02d4" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><a class="ae iw" rel="noopener" href="/@jon_43067">在Go上连续贴6张</a></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dfd31d78696875f52fac861e50605748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWuO5VhegCnn58H9nbr7kw.jpeg"/></div></div></figure><p id="72ff" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在<a class="ae iw" rel="noopener" href="/capital-one-developers/learning-to-use-go-reflection-822a0aed74b7">我的上一篇博客文章</a>中，我们查看了Go的反射包，并快速演示了它的一些特性。不清楚的是这些功能何时会有用。我们用反射做的所有事情都可以在没有它的情况下实现——而且会更高效，更简洁。但是我们也知道，Go团队不喜欢为了特性而包含特性。那么，反射能实现什么呢？</p><h1 id="49b3" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">寻找我的倒影</h1><p id="e68e" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">好的，我们可以用反射做所有这些巧妙的技巧，但是我如何在日常程序中使用它们呢？</p><p id="0dc0" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">很大程度上，你不会。反射是一种在幕后使用的工具，它让通常不可能的事情成为可能。它隐藏在一些(如果不是大多数)库和工具的实现中。</p><p id="ba58" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如何判断一个库是否在使用反射？最大的提示是检查参数的类型。如果你调用一个带有类型interface{}参数的函数，它很可能会使用反射来检查或改变参数的值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://twitter.com/CapitalOneDevEx"><div class="er es lc"><img src="../Images/a94559d31aeb80a7fd55aff68f92d34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGp3B7rAWWoCgY2i_nC6TA.png"/></div></a></figure><h1 id="00dd" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">处理JSON</h1><p id="7a7b" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">反射最常见的用途是从文件或网络中封送和解封送数据。每当您为JSON或数据库映射指定struct标记时，您都依赖于反射。您正在调用填充struct实例的库，使用反射来分析struct标记和设置struct字段上的值。</p><p id="a3cc" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们通过查看实现JSON解组的Go标准库内部的代码来看看这是如何实现的。</p><p id="0211" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了将json字符串中的值放入变量中，我们调用JSON。解组功能。它接受两个参数。</p><ul class=""><li id="97a3" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">包含JSON文本的类型是[]byte。</li><li id="c1dd" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">我们要填充的变量的类型是interface{}。</li></ul><p id="fa35" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这是我们的暗示，反射将要发生。</p><p id="9cbb" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果您深入研究代码，您会得到一个名为unmarshal的包私有方法。相关部分如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4ebe" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">它使用反射来验证v是一种正确的变量，一个指针。如果是，则v的反射版本(称为rv)被传递给value方法。</p><p id="3b73" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在跳过一些函数和方法之后，我们使用反射以不同的方式填充rv，这取决于JSON是表示数组、对象还是文字。例如，在解析JSON对象时，标准库以多种方式使用反射。</p><p id="e7dd" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">反射用于测试它是否填充到nil接口{}:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="201b" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">或者如果它被填充到地图中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9b92" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">并且在填充结构中的字段时使用反射:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="5ca4" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这只是用于解码JSON的反射代码的一小部分。如果你想自己浏览这段代码，可以在围棋标准库中找到:<a class="ae iw" href="https://golang.org/src/encoding/json/decode.go" rel="noopener ugc nofollow" target="_blank">https://golang.org/src/encoding/json/decode.go</a></p><h1 id="e733" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">记忆和短期记忆</h1><p id="057e" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">填充数据结构是反射的一个用例。但是其他人呢？让我们尝试构建我们自己的库，它使用反射来实现一个使用<em class="lt">记忆化</em>的短期缓存。</p><p id="5374" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果您不熟悉这个术语，记忆化是函数式编程领域的一种技术。函数式编程语言倾向于强加某些规则。比如参数和变量往往是<em class="lt">不可变的</em>；它们在构造后不能更改。函数式编程语言也试图限制<em class="lt">副作用</em>。这是函数所做的事情的名称，但是这些事情在函数返回的值中是不可见的。</p><p id="4de6" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">没有副作用是不可能有一个有用的程序的——因为它们包括像打印到屏幕上或写入文件或将数据放入数据库中这样的事情——但是一些副作用，如修改全局变量，会产生难以理解的程序。函数式编程的目标之一是让程序中的数据流变得更容易，这反过来也让理解程序实际上在做什么变得更容易。</p><p id="fd3d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这种编程风格还有其他一些好处。当您有一个输入参数和返回值都是不可变的函数并且该函数没有副作用时，您可以看到，使用相同的值对该函数的每次调用都将做完全相同的工作并返回完全相同的结果。如果你保存这些结果，就没有必要重复做这些工作。</p><p id="4d73" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这就把我们带到了记忆化。这很像函数级的缓存。记忆化是创建一个函数的过程，该函数包装了这些不变函数中的一个，缓存输入和输出值以避免做不必要的工作。当一个函数被记忆时，每组输入值只做一次。如果第二次传递相同的输入值，则从缓存中提取返回值，而不是重新计算。对于执行复杂或缓慢任务的函数，性能节省是巨大的。</p><p id="d5db" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在，Go可能不是一种函数式语言，但我们仍然可以应用其中的一些思想。这种编程风格有点限制性，但是避免修改输入和输出参数并最小化副作用会使您的程序更容易理解和维护。</p><p id="0de6" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">与其永远缓存，不如让我们看一下短时间的缓存。这是微服务架构中非常常见的模式。以下是它有用的情况:</p><blockquote class="lu lv lw"><p id="cde9" class="jj jk lt jl b jm jn ii jo jp jq il jr lx jt ju jv ly jx jy jz lz kb kc kd ke ha bi translated">你有一个提供价值的服务，另一个使用这个价值。因为有一个网络调用来获取值，所以需要一些时间。这确实会降低整个系统的性能。当值不经常改变时，即使值过期几秒钟也没关系，临时缓存该值可以显著提高系统性能。如果我们能够避免额外的网络调用，并且在不对API进行大量修改的情况下实现缓存，那就太好了。</p></blockquote><p id="5b45" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">那么我们如何在Go中实现基于记忆的缓存呢？我们将使用反射做三件事:</p><ul class=""><li id="ec50" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">确保输入类型是至少有一个输入参数和一个输出参数的函数。</li><li id="8091" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">创建一个全新的结构，它的字段类型与传入函数的输入参数类型相同。</li><li id="84df" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">制作一个输入参数和输出参数与传入函数匹配的全新函数。</li></ul><p id="02af" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们还将引入另一个限制:输入参数必须都是<em class="lt">可比的</em>。在围棋中，可比较的类型是可以用==比较的类型。我们将使用一个映射来关联我们的输入值和输出值，Go中的一个规则是映射的键必须是可比较的。这是有道理的。为了判断我们以前是否见过输入参数，我们需要能够检查它们是否相等。</p><p id="f819" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">幸运的是，在围棋中，只有四样东西没有可比性:</p><ul class=""><li id="e2a1" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">部分</li><li id="0dc9" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">地图</li><li id="57cb" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">功能</li><li id="2d49" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">包含切片、映射或函数类型字段的结构</li></ul><p id="5917" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们从缓存器函数的定义开始。看起来是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="573c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这做得不多，但至少我们知道我们要构建什么。让我们从填充反射检查开始，以确保我们有一个传递给我们的函数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="669f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在，我们需要构建用于保存输入参数的结构。在构建这个结构时，我们还将确保至少有一个输入参数、一个输出参数，并且所有的输入参数都是可比较的。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="bdca" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">只剩下一步了，声明我们将用来保存输入和输出值的缓存的映射，并使用反射来生成我们的缓存函数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="c99a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">就是这样！</p><p id="994e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们浏览一下这段代码。我们首先定义一个outExp类型来保存输出值和缓存值到期的时间。</p><p id="6dac" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">然后我们声明一个映射m，其中键是interface{}，值是outExp。选择这些类型是出于实际原因。正如我们在前面使用反射构建结构的例子中看到的，我们没有可以用来表示反射生成的结构的类型名。为了存储它的实例，我们必须使用interface{}类型的变量。至于返回类型，当您使用反射调用函数时，返回类型是[]reflect.Value。这也是从传递到reflect.MakeFunc的闭包返回的值。为了避免复制值，我们只保留[]reflect。我们从反射函数调用中获取的值，并将其存储在我们的映射中。</p><p id="9a7f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在我们的闭包中，我们使用反射来构造自定义类型的新实例，并用运行时传递给函数的值填充它的字段。然后，我们检查m中是否已经有与该实例相等的内容。如果没有，或者如果有，但已经过期，我们调用包装的函数，将响应和过期时间存储在ov中，并将它存储在m中，并将自定义结构的实例作为键。然后，我们返回ov.out中存储的输入值。</p><p id="1c7a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">就这样，我们编写了一个缓存器工厂函数，它将Go中的几乎所有函数包装在一个有时间限制的缓存中。</p><p id="68e0" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">那么，我们如何使用这些代码呢？这里有一个简单的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a2d8" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">虽然真实的例子会进行数据库查找或web服务调用，但我们的示例函数只是休眠100ms，然后将两个数字相加。由于Go没有泛型，我们需要将缓存的函数转换回正确的类型。因为我们还要检查错误，所以这需要几行代码将错误和缓存函数的接口{}表示放入变量中，然后将缓存实例转换为正确的类型。</p><p id="1c36" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果我们运行这段代码，我们会看到如下数字:</p><pre class="iy iz ja jb fd ma mb mc md aw me bi"><span id="ddca" class="mf kg hh mb b fi mg mh l mi mj">$ go run cacher.go<br/>got result 3 in 100.079405ms<br/>got result 3 in 3.873µs<br/>got result 3 in 561ns<br/>got result 3 in 462ns<br/>got result 3 in 398ns<br/>got result 3 in 100.054602ms</span></pre><p id="50a2" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们第一次运行它需要100毫秒(加上一些开销)，在同一个2秒窗口内的后续调用需要几百纳秒。在3秒钟的停顿后，最后一次呼叫再次进行100毫秒。</p><p id="30fa" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">你可以在https://play.golang.org/p/GNXG4CpG-E的围棋运动场看这段代码</p><h1 id="136a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">你的新秘密武器</h1><p id="e1e6" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">还有最后一件事需要注意。使用反射确实会对性能产生影响。如果您正在进行非常密集的数学计算或通过网络与外部服务对话，添加一层使用反射的代码不会产生显著的影响。然而，大多数代码都非常快。很有可能你代码中的大多数方法运行起来都不到几百纳秒。在这些情况下，当您使用反射和生成的函数增强代码时，您需要小心。这将会造成性能损失，您必须决定是否值得增加的功能带来更慢的性能和更复杂的代码。</p><p id="d815" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这应该会让您体验到在Go中可以通过反射解决的各种问题。这不是一个你可以一直使用的解决方案，但是当你遇到一个看起来不可能的问题时，因为类型之间没有共性，或者因为数据是动态的，反射是你的秘密武器。</p><p id="8f15" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi"> <em class="lt">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权是其各自所有者的所有权。本文为2017首都一。</em>T3】</strong></p><h1 id="245f" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">附加链接</h1><p id="75e1" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/in-the-not-too-distant-future-e2d0ad28e91">在不久的将来… </a></p><p id="305c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/buffered-channels-in-go-what-are-they-good-for-43703871828">缓冲通道——它们有什么用？</a></p><p id="d209" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5">闭包是Go的泛型</a></p><p id="a784" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd">在Go中构建无界通道</a></p></div></div>    
</body>
</html>