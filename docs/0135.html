<html>
<head>
<title>Better Android Testing at Airbnb — Part 5: Test Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb更好的Android测试——第5部分:测试架构</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b?source=collection_archive---------3-----------------------#2019-12-23">https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b?source=collection_archive---------3-----------------------#2019-12-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4fcb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们Airbnb Android测试系列的第五部分，我们仔细看看我们的集成测试框架的架构。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b95103e169151c369915a766b4a3ee16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS7H3FnyoSev8zyIiprObg.jpeg"/></div></div></figure><p id="68a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列的<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8">前几期</a>中，我们展示了我们的状态模拟系统，以及我们如何在其上构建UI集成测试。在本文中，我们将深入探讨系统是如何构建的，如何进行空闲检测，以及如何优雅地处理错误。</p><p id="fd83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这包括相当数量的实现深度，目标是提供足够的细节，以便其他人可以重新创建一个类似的系统，同时避免我们遇到的许多麻烦。</p><h1 id="6a7d" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试框架的架构</h1><p id="64cc" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们的集成测试是用Espresso运行的，但是在上面构建了一个相当复杂的测试工具。这是因为我们需要能够轻松地设置片段，操纵它们的视图，并拆除它们，这很难通过直接的Espresso API来完成。我们在测试中也没有使用普通的JUnit或Espresso断言，而是截取屏幕截图，以编程方式点击视图层次结构，并上传报告文件。</p><h1 id="9cc9" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">利用基础活动</h1><p id="1aa8" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们使用一个自定义活动(名为<strong class="ig hi"><em class="jc">IntegrationTestActivity</em></strong>)来运行测试，它位于我们应用程序的库模块中。这使得它可以在测试过程中直接操作片段。该模块作为一个测试依赖项包含在内，所以它不会交付到生产环境中。</p><p id="5955" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在JUnit端，一个单独的测试启动了<strong class="ig hi"><em class="jc">IntegrationTestActivity</em></strong>，其中一个片段名作为额外的字符串。活动使用片段名称来反射性地访问为该片段声明的模拟。然后，该活动运行所有的模拟，设置每个模拟，对其应用一些动作(比如截屏)，然后拆除它并继续下一个。处理完所有模拟后，活动会清理自己，并将其IdlingResource标记为空闲。</p><p id="e87e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="jc">IntegrationTestActivity</em></strong>是一个抽象类，负责管理模拟。它还覆盖了所有的活动函数，以防止它们被测试中的片段调用(正如在<a class="ae jp" rel="noopener" href="/p/1d1e91e489b4">上一篇关于交互测试的文章</a>中提到的)。子类简单地实现一个函数来在mock上运行验证，比如截图或者执行交互测试。</p><p id="b87a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，我们获取每个片段模拟截图的活动就是下面的代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="f93b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似地，我们的交互测试活动是另一个简单的子类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="1578" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，它们如何利用模拟框架来消费处于模拟状态的每个片段，而不必担心设置片段、等待视图稳定、拆除UI或集成测试中通常固有的任何其他繁琐工作。</p><p id="6763" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们可以非常容易地创建新的子类来处理这些模拟以及我们可能想要进行的任何其他检查。</p><h1 id="6851" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">运行测试活动</h1><p id="5fed" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">当其中一个活动运行时，JUnit测试等待并监听活动何时完成，以便JUnit可以完成测试。这是通过在IntegrationTestActivity的模块中声明的自定义Espresso IdlingResource实现的。JUnit测试和活动就是通过这个空闲来进行通信的。</p><p id="869a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Idler在定制的JUnit TestRule中注册了Espresso，我们利用Espresso来等待它。通常这是通过调用视图断言来完成的，但是因为我们不使用Espresso断言，所以我们通过调用<strong class="ig hi"><em class="jc">Espresso . onidle()</em></strong>来明确地告诉Espresso等待空闲者。</p><p id="6c8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在JUnit端，我们的测试大致如下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="c90b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意每个片段的测试声明是如何成为一行的。稍后您将看到我们如何为每个片段自动生成这个。</p><p id="ee0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回顾一下，这种单一活动托管方法的优势在于:</p><ul class=""><li id="6f6c" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">直接操作截图和交互测试的片段和视图</li><li id="9f33" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">阻塞对活动的函数调用，比如<strong class="ig hi"> <em class="jc">结束</em> </strong>，这样被测试的片段就不会无意中影响测试框架</li><li id="8632" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">通过一个通用基类提供模拟的片段，该基类可以根据特定的测试需求而被子类化</li></ul><p id="999c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，这种方法也存在一些挑战，需要一些复杂性来解决。</p><h1 id="43d5" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">空闲检测</h1><p id="9a05" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">通常情况下，Espresso会自动处理空闲检测。例如，Espresso ViewAssertion调用会等到UI空闲时再进行断言。在我们的自定义测试活动中，我们没有通过Espresso进行断言，也没有访问Espresso的底层API来获得idle上的回调。</p><p id="445b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，<strong class="ig hi"><em class="jc">IntegrationTestActivity</em></strong>需要显示一个片段，并可靠地知道它何时被完全布局，以便我们的测试可以在其上运行。这意味着我们需要构建自己的空闲检测实现。这很棘手，原因如下:</p><ul class=""><li id="8b63" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">考虑异步运行代码的所有来源就像玩打地鼠游戏，如果一个特性运行测试工具不知道的定制异步代码，这甚至是不可能的</li><li id="4702" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">不考虑所有的异步代码会导致测试不完整</li><li id="5988" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">过度防御，等待太久，会不必要地延长测试时间，甚至让测试超时</li></ul><p id="2bdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，我们的任务被简化了，因为我们的片段数据被完全模拟出来了。我们不需要担心等待网络请求或数据库查询。我们只需要确保等待任何可能影响UI的事情。</p><p id="d56e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最重要的一点是等待主线程空闲，因为这是处理UI更新的过程。方便的是，Handler公开了一个API来允许我们这样做！</p><p id="5fd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="jc">Handler()looper . queue . isidle</em>T3】</strong></p><p id="de14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以简单地轮询这个函数，直到队列空闲。然而，这种方法有一个问题。当最后一个Runnable仍在运行时，处理程序的队列可能会报告空闲。也就是说，一个runnable被出队然后运行，所以我们可以知道队列什么时候是空的，但是不知道最后一个Runnable是否已经完成运行。</p><p id="8124" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，我们将自己的Runnable发送给处理程序，当它运行时，我们检查队列是否为空。这让我们可以在检查队列状态之前刷新队列。一个基本的方法是这样的:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="e833" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这传达了基本的想法，但是应该添加一些东西来使它为生产做好准备:</p><ul class=""><li id="bd9b" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">HandlerIdleDetector内部的post循环必须在完成后取消，以避免它无限期地继续下去</li><li id="c17c" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">当我们等待空闲时，可以使用回调系统和协程来优雅地休眠，而不是轮询</li><li id="d101" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">如果活套从不空闲，可以添加超时系统以提供更可靠的错误消息</li><li id="a455" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">这不能在一个循环中包含的线程上运行，因为它们会在同一线程上竞争运行</li><li id="682f" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">通常，仅仅等到所有线程都空闲是不够的。值得注意的是，一些视图更新，如动画，被提交到下一个动画帧。确保所有活套至少空闲一帧时间(约16毫秒)。</li></ul><p id="1355" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还在UI中广泛使用Epoxy，它在后台线程上做一些处理。事实上，recycle view设置使用异步线程来处理不同的recycle view更改是很常见的，因此这将是许多人的常见用例。我们构建了我们的空闲检测来获取一个要监视的循环列表，并在它们都空闲时返回。这使得向列表中添加新线程变得容易。</p><p id="61b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对这种方法的一个警告是，任何通过<strong class="ig hi"><em class="jc"/></strong>发送到稍后时间的<strong class="ig hi"><em class="jc"/></strong>都不被考虑(Espresso也不能考虑这些)。为了防止这些碎片，我们不允许这些调用出现在我们的片段中。如果一个片段需要延迟一个Runnable(主要是为了动画的目的),那么我们有一个实用函数来包装这个调用，在测试构建中强制延迟为零。</p><h1 id="f340" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">错误处理</h1><p id="ddee" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如果一个测试抛出了一个异常，我们的目标(作为测试框架的创建者)是尽可能简单明了地向最终开发人员展示这个异常。开发人员不应该去挖掘日志，理解测试框架中的代码，或者在理解崩溃的根本原因时处理任何开销。我们已经做了一些事情来让他们更容易。</p><p id="0294" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，如果主线程发生崩溃，比如在某个异步任务中，那么测试运行程序通常会报告一条通用消息:</p><blockquote class="lj lk ll"><p id="70cf" class="ie if jc ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">测试未能运行完成。原因:“由于进程崩溃，检测运行失败。”。有关详细信息，请查看设备日志</p></blockquote><p id="771f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是没有帮助的，并且强迫开发者做额外的工作。相反，我们使用一个测试规则为所有线程注册一个默认的异常处理程序，包括RxJava和协程。该处理程序将异常传递给主线程，以便Espresso能够处理它，并正确地将错误显示为测试失败消息。</p><p id="e54c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使提供了正确的错误消息，如果没有抛出时发生了什么的上下文，工程师可能很难调试它。一个测试可以覆盖许多模拟，所以很难判断哪个模拟正在被测试。人们可以深入研究测试日志，但是我们想让这变得更容易。例如，我们可以提供关于片段上设置了哪个mock的信息，哪个视图被点击了，或者任何其他关于测试框架在抛出异常时正在做什么的相关信息。</p><p id="30e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现这一点，我们维护了一个表示“测试上下文”的字符串堆栈。框架可以将任何字符串压入堆栈，并在该阶段结束时弹出。例如，堆栈可能有以下两个字符串:</p><ul class=""><li id="7de8" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">为BookingFragment加载了“失败状态”</li><li id="86c8" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">点击“book_button”视图</li></ul><p id="159a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，由于我们已经有了一个捕捉抛出异常的系统，我们可以包装这些异常以向开发人员提供我们的上下文。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="4c99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些技术使得开发人员更容易解决代码中的错误，并且更加独立。作为测试框架的维护者，这对于减少我直接收到消息帮助某人调试测试失败的次数是很重要的。</p><p id="0293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的错误处理方法的最后一部分涉及到失败是如何出现在Github的PR上的。这将在后面关于CI的文章中详细讨论。</p><h1 id="2d46" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接下来:持续嘲笑的障碍</h1><p id="340f" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">本文详细介绍了我们的测试框架的实现、我们遇到的问题，以及我们为使系统健壮和可伸缩而做出的设计决策。</p><p id="4948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下一篇文章中，我们将看看测试框架可能不可靠的常见原因，以及我们如何从根本上解决它们。</p><h2 id="9786" class="lp jr hh bd js lq lr ls jw lt lu lv ka ip lw lx ke it ly lz ki ix ma mb km mc bi translated">系列索引</h2><p id="18cd" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这是关于Airbnb测试的七篇系列文章。</p><p id="c733" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第1部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a">测试理念和模拟系统</a></p><p id="22e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第2部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab">使用MvRx和Happo进行截图测试</a></p><p id="bd08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第3部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4">自动化交互测试</a></p><p id="f90f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第4部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8">单元测试框架视图模型</a></p><p id="39ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第5部分(本文)</strong> — <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">我们的自动化测试框架的架构</a></p><p id="7128" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第6部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f">持续嘲讽的障碍</a></p><p id="461f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第7部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f">测试生成和CI配置</a></p><h2 id="1e01" class="lp jr hh bd js lq lr ls jw lt lu lv ka ip lw lx ke it ly lz ki ix ma mb km mc bi translated">我们在招人！</h2><p id="e896" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">想和我们一起在这些和其他大规模的Android项目上合作吗？Airbnb正在全公司招聘几个Android工程师职位！有关当前空缺，请参见<a class="ae jp" href="https://careers.airbnb.com/" rel="noopener ugc nofollow" target="_blank">https://careers.airbnb.com</a>。</p></div></div>    
</body>
</html>