# Python starter pack 中的并行性

> 原文：<https://medium.com/globant/parallelism-in-python-starter-pack-84cd6a3d5e6c?source=collection_archive---------1----------------------->

![](img/fdbc3fdaf8a9bd11cde82c062366f998.png)

# 介绍

同时做许多事情被认为是非常高效的，至少当我们谈论计算的时候。如果您是一名软件工程师，您会希望利用这一点，以便您构建的应用程序可以运行得更快。

当您在终端窗口中运行 Hello World 文件时，它会在计算机 CPU 上的单个操作系统进程中运行。您使用的计算机很可能有多个 CPU，因此您编写的程序将在其中一个 CPU 上运行。

假设我们没有一个程序可以完成打印 Hello World 这样简单的任务。相反，我们的程序要复杂得多，比如向外部请求数据、向磁盘写入大文件，或者进行昂贵的数学计算，比如机器学习。在那里，我们有更高的概率碰到被称为*阻塞*的东西。当它停止我们逻辑中的一切，直到我们等待某事发生时，就会发生这种情况，就像我之前告诉你的等待时间。我们可以用这些时间来做其他事情，减少总的执行时间，最大限度地减少[](https://en.grenoble-em.com/news-digital-sobriety-using-digital-technology-sensibly-what-roles-do-companies-have-play)*(程序运行的时间越短，用的电就越少，我们留下的碳足迹也就越少)。*

*我们都听说过*并行*、*多任务*这几个字。尽管人们可能认为它们指的是同一件事，但事实远非如此。在开始编码之前，我们将逐一解释。*

*并行性，也叫做*多重处理*，就像*打开一个新的终端窗口来再次运行你的程序。也许用不同的参数来得到不同的输出。发生的情况是，每个程序同时在同一台机器的不同 CPU 上的不同进程中独立运行。我们可以通过编程实现这一点。**

*并发性或*多任务*，也称为*多线程*，是指程序将负责同时运行不同的事情(在不同的线程中)，通过廉价的上下文切换在单个进程上提供并行性的感知。一些编程语言实现比如*CPython*(Python 最流行的实现)不允许多线程，因为[全局锁解释器](https://wiki.python.org/moin/GlobalInterpreterLock)。*

*通过在单个进程中使用单个线程，也有可能产生并发的错觉。这可以通过实现一种叫做*事件循环*的机制来实现。是的，JavaScript 的核心设计和使 Node.js 在后端应用程序中如此出名的原因。因为这是一种设计模式，所以它可以在任何编程语言中实现。*

# *让我们编码*

*既然我们已经介绍了每种异步编程的基础知识，我们就可以看一些示例实现了。虽然示例是用 Python 编写的，但是逻辑可以用任何支持指定特性的编程语言来实现。如果你想深入研究这些话题，有大量的文献。*

*首先，我们将实现我们想要并行化的主要逻辑。一个简单的函数，通过使用流行的[请求](https://requests.readthedocs.io/en/latest/)库，请求公共 GitHub API 获取给定用户名的存储库列表。*

# *多线程操作*

*在上面的例子中，我们使用[线程](https://docs.python.org/3/library/threading.html)包来创建多个线程，这些线程将“同时”执行我们的函数来打印存储库。让我们记住，因为有了 *GIL* ，我们每个进程只能运行一个线程(除非你决定使用另一个 Python 实现，比如 *Jython* 或*pypypy*)。`join`功能用于阻塞程序流程，直到所有任务完成。*

# *多重处理*

*用法非常类似于多线程。相反，我们使用[多重处理](https://docs.python.org/3/library/multiprocessing.html)包。在这里，您可以以编程方式启动在不同 CPU 上运行该函数的多个进程。请考虑您拥有的 CPU 数量，您不希望使用 8 核处理器同时运行 1000 个进程。如果是这种情况，您可能想查看一下[池](https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers)类。*

# *异步输入输出*

*在单个进程中实现并发的真正方法是使用 [asyncio](https://docs.python.org/3/library/asyncio.html) 包(从 Python 3.4 开始提供)。AsyncIO 将给你一个 *Eventloop* 的能力，通过使用`async` / `await`关键字以一种非常直接的方式执行多个任务。值得一提的是，我们应该使用另一个支持异步请求的 HTTP 库，所以`get_repos`函数不能满足这个目的。对此，可以推荐 [aiohttp](https://docs.aiohttp.org/en/stable/) 。让我们看看如何用 aiohttp 实现`get_repos_async`函数:*

# *任务排队*

*这是一个特别的问题，我们不想在这篇文章中遗漏。任务队列是允许通过专用的*工作器*在不同的进程甚至不同的机器中分配任务(或作业)的实现。它们使用集中式非关系键值内存数据库服务来管理队列，充当消息代理。最受欢迎的是 [Redis](https://redis.io/) 。有很多任务队列，你可以找到一个适合你的需求。如果你想要一些开始测试的建议，你可以看看[芹菜](https://docs.celeryq.dev/en/stable/getting-started/introduction.html)。*

# *结论*

*我们探讨了实现并行性和并发性的各种方法。它们不会解决应用程序通常存在的任何性能问题。然而，了解这些概念以及何时应用它们是很重要的。甚至所有上述解决方案都会带来一个或多个缺点。您应该考虑的最重要的事情是避免出现竞争情况，在这种情况下，多个任务试图同时对单个资源执行操作，从而导致不一致或意外的变化。如果您处理了所有这些边缘情况，那么您就可以享受拥有高性能解决方案的好处。*