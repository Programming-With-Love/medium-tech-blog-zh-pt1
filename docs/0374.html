<html>
<head>
<title>Draw a Path: Rendering Android VectorDrawables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绘制路径:渲染Android VectorDrawables</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf?source=collection_archive---------1-----------------------#2018-12-04">https://medium.com/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf?source=collection_archive---------1-----------------------#2018-12-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3009e7874cb39475927b80627f0a1e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4yigvVn3kGRHnTu0yAlqQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="cdfe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上一篇文章中，我们研究了Android的<code class="du js jt ju jv b">VectorDrawable</code>格式，探讨了它的优势和功能。</p><div class="hg hh ez fb hi jw"><a rel="noopener follow" target="_blank" href="/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hy fi z dy kb ea eb kc ed ef hw bi translated">理解Android的矢量图像格式:VectorDrawable</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">Android设备有各种尺寸、形状和屏幕密度。这就是为什么我非常喜欢使用分辨率…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk ho jw"/></div></div></a></div><p id="75ee" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们讨论了如何定义组成资源中形状的路径。<code class="du js jt ju jv b">VectorDrawable</code>支持许多实际绘制这些形状的方法，我们可以用它们来创建丰富、灵活、可主题化和<em class="kl">交互式的</em>资产。在这篇文章中，我将深入探讨这些技术:使用颜色资源、主题颜色、颜色状态列表和渐变。</p><h1 id="5307" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">简单的颜色</h1><p id="62cd" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">绘制路径最简单的方法是指定硬编码的填充/描边颜色。</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="3352" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以定义这些属性中的一个或两个，并且每个路径只能应用一个填充/描边(与某些图形包不同)。首先绘制填充，然后应用任何描边。描边总是居中(也不像某些图形应用程序允许内部或外部描边)，需要指定一个<code class="du js jt ju jv b">strokeWidth</code>，并可以选择定义<code class="du js jt ju jv b">strokeLineCap</code>、<code class="du js jt ju jv b">strokeLineJoin</code>属性，这些属性控制描边线条的结束/连接的形状(对于<code class="du js jt ju jv b">miter</code>线条连接也是<code class="du js jt ju jv b">strokeMiterLimit</code>)。不支持虚线。</p><p id="bbdd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">填充和描边都提供了单独的alpha属性:<code class="du js jt ju jv b">fillAlpha</code>和<code class="du js jt ju jv b">strokeAlpha</code>[0–1]，它们都默认为1，即完全不透明。如果你指定了一个带有alpha成分的<code class="du js jt ju jv b">fillColor</code>或<code class="du js jt ju jv b">strokeColor</code>，那么这两个值就是<em class="kl">的组合</em>。例如，如果您指定50%透明红色<code class="du js jt ju jv b">fillColor</code> ( <code class="du js jt ju jv b">#80ff0000</code>)和<code class="du js jt ju jv b">0.5</code> <code class="du js jt ju jv b">fillAlpha</code>，那么结果将是25%透明红色。单独的alpha属性使设置路径不透明度的动画变得更加容易。</p><h1 id="2a08" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">色彩资源</h1><p id="20f0" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">向量支持填充和描边颜色的<code class="du js jt ju jv b">@color</code>资源语法:</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1040" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这使你可以更容易地维护颜色，并帮助你限制你的应用程序使用一致的调色板。</p><p id="90f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它<em class="kl">也</em>使你能够使用Android的<a class="ae hu" href="https://developer.android.com/guide/topics/resources/providing-resources#AlternativeResources" rel="noopener ugc nofollow" target="_blank">资源限定符</a>在不同的配置中提供不同的颜色值。例如，您可以在夜间模式(<code class="du js jt ju jv b">res/colors-night/colors.xml</code>)或<a class="ae hu" rel="noopener" href="/google-design/android-color-management-what-developers-and-designers-need-to-know-4fdd8054557e">设备支持宽色域</a> ( <code class="du js jt ju jv b">res/colors-widecg/colors.xml</code>)时提供替代颜色值。</p><h1 id="0a52" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">主题颜色</h1><p id="87ab" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">所有版本的vectors(从API14到AndroidX)都支持使用主题属性(例如<code class="du js jt ju jv b">?attr/colorPrimary</code>)来指定颜色。这些是由主题提供的颜色，对于创建您可以在应用程序的不同位置使用的灵活资源非常有用。</p><p id="ab51" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用主题颜色有两种主要方式。</p><h2 id="0651" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">主题填充/描边</h2><p id="3742" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">您可以直接引用主题颜色来填充或描边路径:</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="a95e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想要基于主题区分资产中的元素，这将非常有用。例如，一个体育应用程序可能会为一个占位符图像设置主题，以显示球队的颜色；使用单一可拉伸:</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/b67efbb2f29f0eb3b24a8413bb4aa05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bC0qT04NmBsM5wQdiDYPgw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Filling a path with a theme color</figcaption></figure><h2 id="c20e" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">染色</h2><p id="f77e" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">根<code class="du js jt ju jv b">&lt;vector&gt;</code>元素提供了<code class="du js jt ju jv b">tint</code> &amp; <code class="du js jt ju jv b">tintMode</code>属性:</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="fef8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然您可以使用它来应用静态色调，但它在与主题属性结合使用时更有用。这允许你根据膨胀的主题改变整个资源的颜色。例如，你可以使用<code class="du js jt ju jv b">?attr/colorControlNormal</code>来给图标上色，它定义了图标的标准颜色，并且随着主题的深浅而变化。这样，您可以在不同主题的屏幕上使用同一个图标:</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/b5ea0da455f21296d09efcbd7551e792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1z2s8mJ6giKx5_Ixx0DQQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Tinting an icon so that it is appropriately colored on light/dark screens</figcaption></figure><p id="9e65" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用淡色的一个好处是，您不需要依赖源作品来获得正确的颜色。对图标应用像<code class="du js jt ju jv b">?attr/colorControlNormal</code>这样的标准色调既能让你主题化，又能保证资产是完全相同的、正确的颜色。</p><p id="bb52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">tintMode</code>属性可以让您改变用于给绘图着色的混合模式，它支持:<code class="du js jt ju jv b">add</code>、<code class="du js jt ju jv b">multiply</code>、<code class="du js jt ju jv b">screen</code>、<code class="du js jt ju jv b">src_atop</code>、<code class="du js jt ju jv b">src_over</code>或<code class="du js jt ju jv b">src_in</code>；对应等效的<a class="ae hu" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode" rel="noopener ugc nofollow" target="_blank"> PorterDuff。模式</a>。默认的<code class="du js jt ju jv b">src_in</code>通常是您想要的，它将图像视为alpha蒙版，将单一色调应用于整个图标，忽略各个路径中的任何颜色信息(尽管alpha通道保持不变)。因此，如果你打算给图标上色，那么最好使用完全不透明的填充/描边颜色(惯例是使用<code class="du js jt ju jv b">#fff</code>)。</p><p id="6853" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可能想知道什么时候给资源着色，什么时候在单独的路径上使用主题颜色，因为两者可以获得相似的结果。如果你想在一些路径上使用主题颜色，那么你必须直接使用它们。另一个需要考虑的问题是，您的资源是否有任何重叠的渲染。如果是这样的话，那么用半透明的主题颜色填充可能不会产生你想要的效果，但是用浅色填充可能会。</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/8659fc79c4512635f871436e6c151d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hsEvZy71AHHAPAz-f9AHw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Assets with overlapping paths &amp; semi-opaque theme colors: comparing tint vs fills</figcaption></figure><p id="7a4d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，您可以在<code class="du js jt ju jv b">Activity</code> / <code class="du js jt ju jv b">View</code>级别通过设置<code class="du js jt ju jv b">android:theme</code>属性来改变用于膨胀drawable的主题，或者在代码中使用具有特定主题的<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/view/ContextThemeWrapper.html" rel="noopener ugc nofollow" target="_blank">ContextThemeWrapper</a></code>来<a class="ae hu" href="https://developer.android.com/reference/android/support/v7/content/res/AppCompatResources.html#getDrawable(android.content.Context,%20int)" rel="noopener ugc nofollow" target="_blank">膨胀</a>向量。</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Overlaying the theme `baz`</figcaption></figure><h1 id="150d" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">有色人种学者</h1><p id="aa2b" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated"><code class="du js jt ju jv b">VectorDrawable</code>支持参照<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/content/res/ColorStateList.html" rel="noopener ugc nofollow" target="_blank">ColorStateLists</a></code>进行填充/描边。这样，你可以创建一个单一的drawable，其中路径根据视图/drawable的状态(如按下、选择、激活等)改变颜色。</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/dbe94cd96b9b00566b8d9e0b5d235003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6ZTTJcAjPO6cUU5yk3tahQ.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Examples of vectors responding to pressed and selected states</figcaption></figure><p id="8cff" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是在API24中引入的，但最近添加到了AndroidX中，从版本1.0.0将支持带回API14。这也使用了<a class="ae hu" href="https://developer.android.com/reference/android/support/v7/content/res/AppCompatResources.html#getColorStateList(android.content.Context,%20int)" rel="noopener ugc nofollow" target="_blank">AndroidX ColorStateList inflater</a>，这意味着你也可以在<code class="du js jt ju jv b">ColorStateList</code>本身中使用主题属性和alpha(它们本身只是在API23中添加到平台中的)。</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="40f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然在一个<code class="du js jt ju jv b">StateListDrawable</code>中使用多个drawables可以获得相似的结果，但是如果不同状态之间的渲染差别很小，这可以减少重复，并且更容易维护。</p><p id="8203" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我也非常喜欢为自定义视图创建自己的状态，这可以与这种支持相结合，以控制资产中的元素，例如，除非设置了特定的状态，否则使路径透明。</p><h1 id="b3c0" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">梯度</h1><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/1b23fa299467dbad3ffd9eb86e7b4d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9DUfuae-a0oX12Dw88pmw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The 3 types of gradients supported</figcaption></figure><p id="5426" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">VectorDrawable</code>支持填充和描边的线性、径向和扫描(也称为角度)渐变。这也通过AndroidX支持回到API14。在<code class="du js jt ju jv b">res/colors/</code>中，渐变是在它们自己的文件中声明的，但是我们可以使用<a class="ae hu" href="https://developer.android.com/guide/topics/resources/complex-xml-resources" rel="noopener ugc nofollow" target="_blank">内联资源技术</a>来代替在一个矢量中声明渐变——这样会更方便:</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="59c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在构建时，渐变被提取到它自己的资源中，并且对它的引用被插入到<em class="kl">父</em>元素中。如果你要多次使用同一个渐变，最好声明一次并引用它，因为内联版本每次都会创建一个新的资源。</p><p id="7c7a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">指定渐变时，任何坐标都在根矢量元素的视口空间中。让我们来看看每种类型的梯度，以及如何使用它们。</p><h2 id="7c50" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">线性的</h2><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="0c13" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">线性渐变必须指定开始/结束X/Y坐标和<code class="du js jt ju jv b">type="linear"</code>。</p><h2 id="6324" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">放射状的；辐射状的</h2><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="c12f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">径向渐变必须指定中心X/Y和半径(同样在视口坐标中)以及<code class="du js jt ju jv b">type="radial"</code>。</p><h2 id="b03f" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated"><strong class="ak">扫一扫</strong></h2><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="c79c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">扫描梯度必须指定一个中心X/Y和<code class="du js jt ju jv b">type="sweep"</code>。</p><h2 id="f94d" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">颜色停止</h2><p id="e180" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">为了方便起见，渐变让你直接在渐变中指定一个<code class="du js jt ju jv b">startColor</code>、<code class="du js jt ju jv b">centerColor</code>和<code class="du js jt ju jv b">endColor</code>。如果你需要更精细的控制或者更多的颜色停止，你也可以通过添加指定一个<code class="du js jt ju jv b">color</code>和一个【0–1】<code class="du js jt ju jv b">offset</code>的子<code class="du js jt ju jv b">item</code>元素来实现(把它想象成渐变过程中的一个百分比)。</p><figure class="lp lq lr ls fd hj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h2 id="8dd2" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">平铺模式</h2><p id="453d" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">线性和径向(但不是扫描)渐变提供了平铺的概念，即如果渐变没有覆盖它填充/描边的整个路径，该怎么办。默认为<code class="du js jt ju jv b">clamp</code>，只是延续开始/结束颜色。或者，您可以指定<code class="du js jt ju jv b">repeat</code>或<code class="du js jt ju jv b">mirror</code>平铺模式……顾名思义！在下面的例子中，径向渐变被定义在中间的蓝色→紫色圆圈上，但是填充了较大的正方形路径。</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/670acb3d77734c41546e9c93fef50168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ngJx7igxFyEc48mjrN4xA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Gradient tile modes</figcaption></figure><h2 id="d160" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">模式</h2><p id="dd20" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">我们可以结合使用颜色停止和平铺模式来实现矢量中的基本模式支持。例如，如果您指定一致的颜色停止，您可以实现突然的颜色变化。结合这种重复平铺模式，我们可以创建条纹图案。<a class="ae hu" href="https://gist.github.com/nickbutcher/1e6c2309ee075ac62d2f8a6c285f0ce8" rel="noopener ugc nofollow" target="_blank">例如</a>这是一个由单一图案填充形状制成的装载指示器。通过在持有该模式的组上设置<code class="du js jt ju jv b">translateX</code>属性的动画，我们可以实现这样的效果:</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div class="er es ml"><img src="../Images/747b78a394ecd2a8f1439a8a3a5a21fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/1*uXCjERVWWepz-1AyHIy2Ow.gif"/></div></figure><p id="05a5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，这种技术离完全的<a class="ae hu" href="https://www.w3.org/TR/SVG/pservers.html#Patterns" rel="noopener ugc nofollow" target="_blank"> SVG模式</a>支持还差得很远，但是它是有用的。</p><h2 id="b044" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">插图</h2><figure class="lp lq lr ls fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/9e40fa6e7aaa658d54efe65335353cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk-FXON4_Y5RqsD_koB-ow.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Another lovely illustration by the very talented <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><p id="a9c1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">渐变在较大的矢量作品中非常常见，如插图。向量可以很好地适合插图，但是在放大时要注意内存的权衡。我们将在后面的系列文章中再次讨论这个问题。</p><h2 id="194d" class="lv kn hx bd ko lw lx ly ks lz ma mb kw jf mc md la jj me mf le jn mg mh li mi bi translated">阴影</h2><p id="50f3" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated"><code class="du js jt ju jv b">VectorDrawable</code> s不支持投影效果；然而，简单的阴影可以使用梯度<em class="kl">近似</em>。例如，该应用程序图标使用径向渐变来近似白色圆圈的投影，并使用线性渐变来近似三角形下方的阴影:</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div class="er es mm"><img src="../Images/00e78d35134134ba4054d1a353a4a0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LtNVL0GpyFlFei434XS-0Q.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Approximating shadows using gradients</figcaption></figure><p id="897a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，这离完全阴影支持还有很长的路要走，因为只能绘制线性/径向/扫描梯度，而不是沿着任意路径。可以近似一些形状；特别是通过将变换应用到渐变元素，例如<a class="ae hu" href="https://gist.github.com/nickbutcher/b9c726e956d25b354ee1d19dcb105a88" rel="noopener ugc nofollow" target="_blank">示例</a>使用<code class="du js jt ju jv b">scaleY</code>属性将一个具有径向渐变的圆变换为椭圆形以创建阴影:</p><figure class="lp lq lr ls fd hj er es paragraph-image"><div class="er es mn"><img src="../Images/e9c7c6898185f0040efef613084e8416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*CPo9LovW1xgD5jCkWRu0Ow.gif"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Transforming a path containing a gradient</figcaption></figure><h1 id="b49d" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">用数字着色</h1><p id="b5ca" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">希望这篇文章已经展示了<code class="du js jt ju jv b">VectorDrawable</code>支持许多高级特性，你可以使用这些特性在你的应用中渲染更复杂的资源，甚至用一个文件替换多个资源，帮助你构建更精简的应用。</p><p id="a35a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我建议所有的应用程序都应该为图标使用主题颜色。并且梯度支持更适合，但是如果你需要，知道向量支持那些用例是很好的。</p><p id="5f9d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">vectors的兼容性很好，所以这些特性现在可以在大多数应用程序中使用(下一期将详细介绍)。</p><p id="ac0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">加入我们在向量世界的下一段冒险:</p><div class="hg hh ez fb hi jw"><a rel="noopener follow" target="_blank" href="/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hy fi z dy kb ea eb kc ed ef hw bi translated">在Android应用中使用矢量资源</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">在之前的帖子中，我们已经了解了Android的VectorDrawable图像格式及其功能:</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="mo l kh ki kj kf kk ho jw"/></div></div></a></div><p id="3883" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kl">即将推出:为Android创建矢量资产<br/>即将推出:剖析Android </em> <code class="du js jt ju jv b"><em class="kl">VectorDrawable</em></code> <em class="kl"> s </em></p></div></div>    
</body>
</html>