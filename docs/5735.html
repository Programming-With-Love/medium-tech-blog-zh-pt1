<html>
<head>
<title>Oracle Entity Framework Core Performance Considerations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle实体框架核心性能注意事项</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracle-entity-framework-core-performance-considerations-7c601542e7dc?source=collection_archive---------1-----------------------#2020-09-24">https://medium.com/oracledevs/oracle-entity-framework-core-performance-considerations-7c601542e7dc?source=collection_archive---------1-----------------------#2020-09-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cc55e9eb0372f37d871eeb534c5518bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dytNZdrf1-N-YC-2zfVSA.jpeg"/></div></div></figure><p id="dba4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一些开发人员报告了从2.x升级到Oracle EF Core 3.1后运行时性能下降的情况。NET字符串实体属性绑定数据类型的Unicode支持与数据库列数据类型的不匹配。</p><p id="1a0f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当映射设置正确时，应用程序将字符串实体属性值绑定为数据库<code class="du jn jo jp jq b">NVARCHAR2</code>列的<code class="du jn jo jp jq b">NVARCHAR2</code>，或者绑定为数据库<code class="du jn jo jp jq b">VARCHAR2</code>列的<code class="du jn jo jp jq b">VARCHAR2</code>。如果类型不匹配，服务器端会在运行时进行额外的处理来执行数据类型转换，从而降低性能。当有大量值需要转换时，性能会显著下降。这种不匹配会导致数据库的执行计划更改为完全扫描。</p><p id="a180" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要避免这种数据类型不匹配的性能问题，请执行下列操作之一:</p><ul class=""><li id="d3e9" class="jr js hh ir b is it iw ix ja jt je ju ji jv jm jw jx jy jz bi translated">如果数据库表已经存在，使用脚手架来生成对应于关系数据库表的实体类。这样做可以为每个表列生成正确的fluent API。</li><li id="3497" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">如果实体类存在，但没有相应的数据库表，则使用迁移为字符串实体属性生成相应的数据库列，这将遵循调用的IsUnicode()或has columntype()fluent API。</li><li id="a099" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">如果手动创建对应于数据库表的实体类，使用适当的IsUnicode()或HasColumnType() fluent API将每个字符串实体属性正确映射到<code class="du jn jo jp jq b">NVARCHAR2</code>或<code class="du jn jo jp jq b">VARCHAR2</code>列类型，以避免不匹配。</li></ul><p id="867d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简单来说，让EF Core自动生成表(迁移)或类(脚手架)，那么你就不会碰到这个问题。如果手动修改数据类型映射，请注意映射要精确。如果您看到明显的性能问题，请再次检查您的映射。</p><p id="22e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">映射Oracle EF核心数据类型时需要注意的其他要点:</p><ul class=""><li id="d299" class="jr js hh ir b is it iw ix ja jt je ju ji jv jm jw jx jy jz bi translated">如果同时使用IsUnicode()和HasColumnType() fluent API，则has columntype()fluent API优先。</li><li id="6d26" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">对于迁移。默认情况下，NET String实体属性映射到<code class="du jn jo jp jq b">NVARCHAR2</code>。对于脚手架，<code class="du jn jo jp jq b">VARCHAR2</code>和<code class="du jn jo jp jq b">NVARCHAR2</code>列都映射到。网串。</li><li id="b442" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">如果数据库列类型是<code class="du jn jo jp jq b">VARCHAR2</code>，那么应该使用IsUnicode(false)或has columntype(" varchar 2(&lt;length&gt;))")fluent API将字符串实体属性正确映射到<code class="du jn jo jp jq b">VARCHAR2</code>列。这避免了性能下降的问题。</li><li id="ba6a" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">如果一个字符串实体属性与一个<code class="du jn jo jp jq b">NVARCHAR2</code>列相关联，那么既不需要调用IsUnicode()也不需要调用has columntype()fluent API。或者，可以调用IsUncode(true)或has columntype(" nvarchar 2(&lt;length&gt;)")fluent API将数据绑定为<code class="du jn jo jp jq b">NVARCHAR2</code>。</li><li id="2b3c" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">在甲骨文。EntityFrameworkCore 2.19.70及更早版本中，在执行LINQ查询时，字符串实体属性值总是被绑定为<code class="du jn jo jp jq b">VARCHAR2</code>。从Oracle EF Core 2.19.80开始，这种行为发生了变化。字符串实体属性值现在基于为实体字符串属性指定的映射进行绑定。在Oracle EF Core 2.19.70下性能最佳的应用程序在升级到更高版本的Oracle EF Core时性能可能会下降。</li><li id="ee22" class="jr js hh ir b is ka iw kb ja kc je kd ji ke jm jw jx jy jz bi translated">如果在Oracle EF核心升级后遇到新的性能问题，请验证与<code class="du jn jo jp jq b">VARCHAR2</code>列相关联的字符串实体属性既没有设置IsUnicode(false)，也没有设置has columntype(" varchar 2(&lt;length&gt;))")流畅API，也没有设置等效的数据注释。如果是这样，添加这些fluent API之一，以便使用正确的类型绑定基于字符的数据。</li></ul><p id="ced0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这个技巧，您可以避免Oracle EF核心应用程序遇到这种性能障碍。</p></div></div>    
</body>
</html>