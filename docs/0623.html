<html>
<head>
<title>Using DataStore With Kotlin Serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Kotlin序列化使用数据存储</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-datastore-with-kotlin-serialization-6552502c5345?source=collection_archive---------2-----------------------#2021-04-12">https://medium.com/androiddevelopers/using-datastore-with-kotlin-serialization-6552502c5345?source=collection_archive---------2-----------------------#2021-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/09501006a753581e9bc2c13ec2344f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7eVQ1Fe7-O6vZWvEt7kHg.png"/></div></div></figure><div class=""/><p id="3964" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，我们<a class="ae jn" href="https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html" rel="noopener ugc nofollow" target="_blank">已经分享了</a>如何使用<a class="ae jn" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank"> Protos </a>或<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/preferences/core/package-summary" rel="noopener ugc nofollow" target="_blank"> Preferences </a>的数据存储。在幕后，两个数据存储版本都使用Protos来序列化数据。您还可以通过使用<a class="ae jn" href="https://kotlinlang.org/docs/reference/serialization.html" rel="noopener ugc nofollow" target="_blank"> Kotlin序列化</a>来使用带有自定义数据类的数据存储。这有助于减少样板代码，而不必学习或依赖Protobuf库，同时仍然为您的数据提供模式。</p><p id="f428" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你需要做几件事:</p><ul class=""><li id="cbbc" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">定义数据类</li><li id="0d2e" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir ht">确保你的数据类是不可变的</strong></li><li id="43ac" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">使用Kotlin序列化实现数据存储序列化程序</li><li id="37df" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">开始使用它</li></ul><h1 id="d57c" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">定义数据类</h1><p id="3b4b" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Kotlin <a class="ae jn" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">数据类</a>非常适合用于数据存储，因为它们可以与Kotlin序列化无缝协作。数据存储依赖于为数据类自动生成的<code class="du lf lg lh li b">equals</code>和<code class="du lf lg lh li b">hashCode </code>。数据类还生成对调试和更新数据有用的<code class="du lf lg lh li b">toString</code>和<code class="du lf lg lh li b">copy</code>函数</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="3d06" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">确保你的数据类是不可变的</h1><p id="290a" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">确保你的类是不可变的非常重要，因为<strong class="ir ht">数据存储与可变类型</strong>不兼容。对DataStore使用可变类型将导致难以捕捉的错误和竞争情况。数据类不一定是不可变的。</p><p id="bad5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">变量是可变的，所以应该使用变量:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c860" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数组是可变的，所以你不应该暴露它们。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2ee9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使我们使用只读列表作为数据类的成员，它仍然是可变的。相反，你应该考虑使用<a class="ae jn" href="https://github.com/Kotlin/kotlinx.collections.immutable" rel="noopener ugc nofollow" target="_blank">不可变/持久集合</a>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="95ab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用可变类型作为数据类的成员使其可变。相反，您应该确保所有成员都是不可变类型。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="2bd1" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">实现您的数据存储序列化程序</h1><p id="878b" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Kotlin序列化<a class="ae jn" href="https://kotlinlang.org/docs/reference/serialization.html#formats" rel="noopener ugc nofollow" target="_blank">支持多种格式</a>包括JSON和协议缓冲区。我将在这里使用JSON，因为它非常常见，易于使用，并且以明文形式存储，便于调试。Protobuf也是一个不错的选择，因为它更小，更快，并且兼容<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore" rel="noopener ugc nofollow" target="_blank"> protobuf-lite。</a></p><p id="63ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使用Kotlin序列化来读写JSON中的数据类，需要用<code class="du lf lg lh li b">@Serializable</code>注释数据类，并使用<code class="du lf lg lh li b">Json.decodeFromString&lt;YourType&gt;(string)</code>和<code class="du lf lg lh li b">Json.encodeToString(data)</code>。这里有一个关于<code class="du lf lg lh li b">UserPreferences</code>的例子:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9809" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">⚠️ Parcelables与DataStore一起使用不安全，因为不同Android版本之间的数据格式可能会有所不同。</p><h1 id="3cde" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用序列化程序</h1><p id="d1e0" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在构建数据存储时，将您创建的序列化程序传递到数据存储中:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9caf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">读取数据看起来与使用protos一样:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="260f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用生成的<code class="du lf lg lh li b">.copy()</code>函数来更新数据:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="61e4" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="66ee" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">使用带有Kotlin序列化和数据类的DataStore可以减少boiler plate并有助于简化您的代码，但是，您必须小心不要通过可变性引入错误。您需要做的就是定义您的数据类并实现序列化程序。你自己试试吧！</p><p id="f8fb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多关于数据存储的信息，请查看我们的<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore" rel="noopener ugc nofollow" target="_blank">文档</a>，并获得一些关于我们的<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore#0" rel="noopener ugc nofollow" target="_blank">原型数据存储</a>和<a class="ae jn" href="https://developer.android.com/codelabs/android-preferences-datastore#0" rel="noopener ugc nofollow" target="_blank">首选项数据存储</a> codelabs的实践经验。</p></div></div>    
</body>
</html>