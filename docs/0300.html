<html>
<head>
<title>What’s new in Leanback: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leanback的新特性:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/whats-new-in-leanback-part-2-bcb0dece359b?source=collection_archive---------4-----------------------#2017-08-22">https://medium.com/androiddevelopers/whats-new-in-leanback-part-2-bcb0dece359b?source=collection_archive---------4-----------------------#2017-08-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f740" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">自定义搜索栏缩略图</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f894e425ba6d77f386fe02103ee03c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPnXgdTXUwwtNZwchAQvfQ.png"/></div></div></figure><p id="824b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">安卓电视新手？好奇26.0.0支持库的新变化？在这一系列文章中，我们将研究不同的组件。在阅读这篇文章之前，你不必阅读关于<a class="ae ke" href="https://developer.android.com/reference/android/support/v17/leanback/media/PlayerAdapter.html" rel="noopener ugc nofollow" target="_blank">播放器适配器</a>的<a class="ae ke" rel="noopener" href="/@benbaxter/whats-new-in-leanback-part-1-a895683c1567">第一部分</a>。</p><div class="kf kg ez fb kh ki"><a rel="noopener follow" target="_blank" href="/@benbaxter/whats-new-in-leanback-part-1-a895683c1567"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hi fi z dy kn ea eb ko ed ef hg bi translated">Leanback的新特性:第1部分</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">Android TV player adapter简介</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jg ki"/></div></div></a></div><p id="0dd7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这第二篇文章中，我们将探索新组件如何帮助增强搜索体验。</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="90d3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">目前，当不同的应用程序选择不同的方式在流中搜索时，用户的播放控制体验可能不一致。在<a class="ae ke" href="https://developer.android.com/topic/libraries/support-library/revisions.html#26-0-0-beta1" rel="noopener ugc nofollow" target="_blank"> 26.0.0-beta1 </a>中，我们引入了一种简单的方法来以一致且简单的方式增强搜索。有一个新组件叫做<a class="ae ke" href="https://developer.android.com/reference/android/support/v17/leanback/widget/PlaybackSeekDataProvider.html" rel="noopener ugc nofollow" target="_blank"> PlaybackSeekDataProvider </a>。这个类与<a class="ae ke" href="https://developer.android.com/reference/android/support/v17/leanback/media/PlaybackTransportControlGlue.html" rel="noopener ugc nofollow" target="_blank">PlaybackTransportControlGlue</a>无缝协作。</p><p id="6029" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当用户搜索时，缩略图的覆盖出现在搜索栏上方，给出了用户搜索后将在视频中的位置的视觉线索。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es le"><img src="../Images/a4f89af280dfafd5cbf7d7de5eb46b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*dtGGBNKg6fQ6ov3UPld01A.gif"/></div></figure><h1 id="2a49" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">设置</h1><p id="c84e" class="pw-post-body-paragraph ji jj hh jk b jl lx ii jn jo ly il jq jr lz jt ju jv ma jx jy jz mb kb kc kd ha bi translated">启用这个特性非常简单；只需在您的传输控制胶上设置提供程序。</p><pre class="ix iy iz ja fd mc md me mf aw mg bi"><span id="1457" class="mh lg hh md b fi mi mj l mk ml">mGlue.setSeekProvider(<strong class="md hi">new </strong>MyPlaybackSeekDataProvider(<strong class="md hi">...</strong>));</span></pre><p id="c74a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">真正的工作发生在seek数据提供程序的实现中。</p><h1 id="bb80" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">应用程序接口</h1><p id="b0b1" class="pw-post-body-paragraph ji jj hh jk b jl lx ii jn jo ly il jq jr lz jt ju jv ma jx jy jz mb kb kc kd ha bi translated">这个API非常简单明了。您需要扩展<a class="ae ke" href="https://developer.android.com/reference/android/support/v17/leanback/widget/PlaybackSeekDataProvider.html" rel="noopener ugc nofollow" target="_blank">PlaybackSeekDataProvider</a>并实现三个方法:</p><ul class=""><li id="c367" class="mm mn hh jk b jl jm jo jp jr mo jv mp jz mq kd mr ms mt mu bi translated">getSeekPositions()</li><li id="fbb9" class="mm mn hh jk b jl mv jo mw jr mx jv my jz mz kd mr ms mt mu bi translated">getThumbnail(int index，PlaybackSeekDataProvider。ResultCallback回调)</li><li id="4abf" class="mm mn hh jk b jl mv jo mw jr mx jv my jz mz kd mr ms mt mu bi translated">重置()</li></ul><p id="59b8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于PlaybackSeekDataProvider是一个空的实现，如果这三个方法对您的用例没有意义，您不需要重写它们。那么每个方法的职责是什么呢？</p><p id="2c91" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> getSeekPositions() </strong> —是可以显示缩略图的位置列表。可以将此想象为离散时刻的时间轴，其中缩略图可以捕捉视频中的当前场景。类似于DVD场景选择的概念，但是更加精细。</p><p id="6670" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> getThumbnail(int，ResultCallback) </strong> —这个方法包含了你检索那些时刻的神奇秘方。我们稍后将深入探讨细节。</p><p id="867f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> reset() </strong> —这是一个挂钩，通知您释放资源、清除缓存或执行您的实现所需的任何其他清理。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es na"><img src="../Images/1f277f4be57ea255aed83f7650c246f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DPt8Na6VzPwrZT1h."/></div></div></figure><h1 id="75a3" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">履行</h1><p id="e5f5" class="pw-post-body-paragraph ji jj hh jk b jl lx ii jn jo ly il jq jr lz jt ju jv ma jx jy jz mb kb kc kd ha bi translated">谈论一个API很容易，但是一旦你看到一个例子，理解如何创建你的实现就更有意义了。</p><p id="6b2a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用<a class="ae ke" href="https://developer.android.com/reference/android/media/MediaMetadataRetriever.html" rel="noopener ugc nofollow" target="_blank"> MediaMetadataRetriever </a>来帮助我们提取缩略图，实现变得几乎微不足道。请注意，这要求您的视频流中嵌入更多元数据。您不必使用MediaMetadataRetriever，有许多方法可以获得位图。我只是为了这个例子而使用它。</p><p id="744f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们要做的第一件事是计算我们的搜索位置。有一个确定的区间使这成为一个简单的数学问题。如果您在元数据中跟踪时间轴，那么就不需要这种额外的数学计算，只需沿着时间轴传递查找位置即可。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="5b25" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们已经计算了我们的查找位置，我们要实现的第一个方法变成了一个简单的getter方法:</p><pre class="ix iy iz ja fd mc md me mf aw mg bi"><span id="f46f" class="mh lg hh md b fi mi mj l mk ml">@Override<br/><strong class="md hi">public long</strong>[] getSeekPositions() {<br/>    <strong class="md hi">return mSeekPositions</strong>;<br/>}</span></pre><p id="5a81" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大部分神奇的事情发生在<em class="nd"> getThumbnail() </em>方法中。我们收到一个索引，它对应于我们的查找位置数组中的a位置。目的是leanback给我们一个索引作为参考标记。我们可以将参考标记与我们搜索位置相结合来获得缩略图的时间。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="ceea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为什么我们没有从<em class="nd"> getThumbnail() </em>返回任何东西，为什么我们被传递了一个回调？这种模式暗示了一种异步架构。</p><p id="f944" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">getThumbnail() 在UI线程上被调用，所以最好将大部分工作卸载到后台。在这个例子中，我使用了一个AsyncTask。<strong class="jk hi">注意</strong>注意<em class="nd">retriever . getframeattime()</em>真的很慢。在现实世界的应用程序中，视频缩略图通常在云中进行预处理，并在播放时下载。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="4578" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们现在需要适当地管理AsyncTask的生命周期。</p><p id="ac00" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们实现了<em class="nd"> reset() </em>方法，我们可以用它来释放正在运行的线程。首先，我们需要在启动异步任务时捕获它们；将它们存储在一个稀疏数组、列表或某个集合中。因为每个索引的图像都是相同的，所以每个索引只需要一个任务。因此，给定的索引映射到一个查找位置、一个缩略图和一个AsyncTask。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="2fa7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后在我们的<em class="nd"> reset() </em>方法中，我们应该取消并释放任务。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="f158" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在其他优化中，我们可以应用这种模式，用一个<a class="ae ke" href="https://developer.android.com/reference/android/util/LruCache.html" rel="noopener ugc nofollow" target="_blank"> LruCache </a>缓存缩略图。</p><p id="5bd2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">综上所述，我们有三种方法可以做任何我们需要的事情。只要我们明白每个人的目的，一切都会水到渠成。</p><p id="46f9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">getSeekPositions() —控制我们的索引范围</p><p id="a6fa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">getThumbnail() —奇迹发生了</p><p id="ef60" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">reset() —释放资源</p><h1 id="d4e2" class="lf lg hh bd lh li lj lk ll lm ln lo lp in lq io lr iq ls ir lt it lu iu lv lw bi translated">继续学习</h1><p id="436b" class="pw-post-body-paragraph ji jj hh jk b jl lx ii jn jo ly il jq jr lz jt ju jv ma jx jy jz mb kb kc kd ha bi translated">我推荐阅读<a class="ae ke" href="https://github.com/googlesamples/leanback-showcase/blob/master/app/src/main/java/android/support/v17/leanback/supportleanbackshowcase/app/media/PlaybackSeekAsyncDataProvider.java" rel="noopener ugc nofollow" target="_blank">PlaybackSeekAsyncDataProvider</a>的源代码，它演示了缓存和预取；以及<a class="ae ke" href="https://github.com/googlesamples/leanback-showcase/blob/master/app/src/main/java/android/support/v17/leanback/supportleanbackshowcase/app/media/PlaybackSeekDiskDataProvider.java" rel="noopener ugc nofollow" target="_blank">PlaybackSeekDiskDataProvider</a>。</p><p id="05e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您想加入讨论，请在<a class="ae ke" href="https://twitter.com/benjamintravels" rel="noopener ugc nofollow" target="_blank"> twitter </a>上留下您的回复或与我交谈。</p></div></div>    
</body>
</html>