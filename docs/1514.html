<html>
<head>
<title>Super-Powering Your Enterprise Jenkins CI Pipeline with Docker-Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Docker-Compose为您的企业Jenkins CI渠道提供超强动力</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/super-powering-your-enterprise-jenkins-ci-pipeline-with-docker-compose-a4f508598375?source=collection_archive---------0-----------------------#2018-02-15">https://medium.com/capital-one-tech/super-powering-your-enterprise-jenkins-ci-pipeline-with-docker-compose-a4f508598375?source=collection_archive---------0-----------------------#2018-02-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8cf04f30965790a6692722e8a4b43341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kj1ZLeCx4DnpuuIDpGapdQ.png"/></div></div></figure><p id="da62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而Jenkins可以灵活地添加几乎无限的插件和功能；它是在容器出现之前被创造出来的。最初，它主要通过UI进行交互，直到2016年才使代码优先管道成为规范；此举恰逢管道<em class="jn">(之前的工作流)</em> <a class="ae jo" href="https://www.cloudbees.com/blog/beta-release-github-support-pipeline-code" rel="noopener ugc nofollow" target="_blank">插件推出测试版</a>和<a class="ae jo" href="https://www.cloudbees.com/" rel="noopener ugc nofollow" target="_blank"> CloudBees </a>开源他们的<a class="ae jo" href="https://wiki.jenkins.io/display/JENKINS/Pipeline+Stage+View+Plugin" rel="noopener ugc nofollow" target="_blank">管道可视化插件</a>。</p><p id="03de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但在2018年，集装箱是常态。为了帮助我在Capital One的团队，我想在Jenkins环境的每个构建步骤中使用容器。下面是一个具体的修复方法，可以使Jenkinsfile更具可读性，并使使用Docker映像进行构建的步骤更简单。</p><h1 id="5385" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">image.inside()有问题</h1><p id="6dfd" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">“image.inside()”函数为在Docker容器中运行命令提供了很好的便利。使用它看起来像这样:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="43bc" class="lb jq hh kx b fi lc ld l le lf">node {</span><span id="6851" class="lb jq hh kx b fi lg ld l le lf">  checkout scm</span><span id="850b" class="lb jq hh kx b fi lg ld l le lf">  docker.withRegistry('https://registry.example.com') {</span><span id="2608" class="lb jq hh kx b fi lg ld l le lf">    docker.image('my-custom-image').inside {</span><span id="16c1" class="lb jq hh kx b fi lg ld l le lf">      sh 'make test'</span><span id="f95b" class="lb jq hh kx b fi lg ld l le lf">    }</span><span id="629b" class="lb jq hh kx b fi lg ld l le lf">  }</span><span id="87a9" class="lb jq hh kx b fi lg ld l le lf">}</span></pre><p id="38e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，对于您的项目，您可能不希望以root身份运行Jenkins构建代理，而是以另一个用户的身份运行。对于某些安全情况来说，将它们分开可能是有意义的，但是Docker Jenkins插件仍然期望某种形式的特权访问。正如我们所发现的，以这种方式运行Jenkins构建代理会导致<strong class="ir hi"><em class="jn">“image . inside()”函数不工作并抛出异常。</em>T11】</strong></p><p id="49e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然有一个变通办法，但它使代码更难阅读。在下面的语法正确但不起作用的<em class="jn">(这实际上不是我们的代码)</em> groovy代码示例中，在没有“img.inside()”函数工作的情况下，当在容器中运行bash中的命令时，我们必须将它们连接起来。不是可读性最强的代码；以及可能很快失控的解决方案。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fe1e" class="lb jq hh kx b fi lc ld l le lf">node{</span><span id="06bb" class="lb jq hh kx b fi lg ld l le lf">  docker.withRegistry(‘https://registry.example.com/', ‘svc-acct’) {</span><span id="7fb5" class="lb jq hh kx b fi lg ld l le lf">    def img = docker.image(‘org/go-builder-base-image:master’)</span><span id="b8ab" class="lb jq hh kx b fi lg ld l le lf">    img.pull()</span><span id="e713" class="lb jq hh kx b fi lg ld l le lf">    checkout scm</span><span id="a8a1" class="lb jq hh kx b fi lg ld l le lf">    stage(‘Build’) {</span><span id="b27f" class="lb jq hh kx b fi lg ld l le lf">      sh ‘docker run — privileged -t -v $(pwd):/go/src/git.example.com/group/registrysync -w /go/src/git.example.com/group/registrysync group/go-builder-base-image:master bash -c “go get &amp;&amp; go build”’</span><span id="59ff" class="lb jq hh kx b fi lg ld l le lf">    }</span><span id="4f39" class="lb jq hh kx b fi lg ld l le lf">    stage(‘Test’) {</span><span id="65bb" class="lb jq hh kx b fi lg ld l le lf">      sh ‘docker run — privileged -t -v $(pwd):/go/src/git.example.com/group/registrysync -w /go/src/git.example.com/group/registrysync group/go-builder-base-image:master bash -c “go test”’</span><span id="7541" class="lb jq hh kx b fi lg ld l le lf">    }</span><span id="76a7" class="lb jq hh kx b fi lg ld l le lf">  }</span><span id="32af" class="lb jq hh kx b fi lg ld l le lf">}</span></pre><p id="a7d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您将这段代码与过去五年发布的CI系统进行比较时，您可以为每个步骤指定一个Docker映像，这需要开发人员做更多的工作。</p><p id="dfcc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">输入Docker作曲。</em> </strong></p><h1 id="221e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">隔离各处的构建步骤</h1><p id="d882" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated"><a class="ae jo" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>是一个工具，用于在比仅使用docker run更高的级别上编排一个或多个容器、网络和卷。它在我们的每一个Jenkins节点上都可用，在你安装Docker的任何地方都可用。如果你没有在Jenkins上安装Docker插件，我强烈推荐。事实上，它是<a class="ae jo" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker的编排系统Swarm </a>的一部分，但它不一定要以那种方式使用。</p><p id="c48b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker Compose提供了一种更结构化、更简洁的方式来将变量和值传递给Docker命令。与docker文件不同，您可以访问环境变量并将它们传递给docker命令。Docker团队在这里对Docker Compose <a class="ae jo" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank">有一个很好的概述。</a></p><p id="4be9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们回到当前的需求— <em class="jn">让Jenkinsfile更具可读性，让Docker映像的构建步骤更简单。</em></p><p id="7163" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用的基本模式是在Docker编写文件中为每个构建步骤定义一个服务，并为每个步骤定义一个相关的Docker文件。</p><p id="6c36" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个例子中，我们有一个要编译的Go项目。创建一个docker文件来完成这项工作非常简单。我们将使用一个安装了Go环境的基础映像，我们可以在其中调用“go build”。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5c18" class="lb jq hh kx b fi lc ld l le lf">FROM registry.example.com/group/go-builder-base-image:master</span><span id="0dc3" class="lb jq hh kx b fi lg ld l le lf">ARG PROJECT_PATH<br/>VOLUME $PROJECT_PATH<br/>WORKDIR $PROJECT_PATH</span><span id="2958" class="lb jq hh kx b fi lg ld l le lf">CMD CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags ‘-s’ -x .</span></pre><p id="7b45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以看到，我们指定了一个PROJECT_PATH参数，然后用它来指定卷并设置工作目录。<em class="jn">记住——环境变量在docker文件中不可用。</em></p><p id="19b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以使用这个Docker文件作为构建步骤，在Docker-Compose文件中编译我们的Go项目。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6490" class="lb jq hh kx b fi lc ld l le lf">version: '3'<br/>  services:<br/>    compile:<br/>      build:<br/>        context: .<br/>        dockerfile: compile.dockerfile<br/>      args:<br/>        - PROJECT_PATH=$PROJECT_PATH<br/>      volumes:<br/>        - .:$PROJECT_PATH</span></pre><p id="c8c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Docker Compose文件中，您<strong class="ir hi">可以</strong>使用环境变量，这正是我们对$PROJECT_PATH所做的。正如您可能已经猜到的那样，在Jenkins构建环境中定义了当前项目的路径。我们在附加卷时使用它来确保我们的项目位于容器中的特定位置。</p><p id="b24d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了管道，让我们看看如何使用它。</p><p id="867b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">" docker-compose-f pipeline-compose . yml run-RM compile "</p><p id="156d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个命令将告诉docker-compose使用pipeline-compose.yml文件，并运行编译“服务”和删除任何创建的图像。这比我们最初使用的变通方法更容易阅读。这是为了唤起你的记忆:</p><p id="f9f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">" docker run-privileged-t-v $(pwd):/go/src/git . example . com/group/registry sync-w/go/src/git . example . com/group/registry sync group/go-builder-base-image:master go build "</p><p id="cee2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们将新的docker-compose步骤放到jenkinsfile中。这是一种方法，但凭借詹金斯的灵活性，还有其他方法。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="bd81" class="lb jq hh kx b fi lc ld l le lf">node{</span><span id="ef83" class="lb jq hh kx b fi lg ld l le lf">  docker.withRegistry(‘https://registry.example.com/', ‘svc-acct’) {<br/>  <br/>    checkout scm<br/>    stage(‘Build’) {</span><span id="173b" class="lb jq hh kx b fi lg ld l le lf">      sh ‘docker-compose –f build-compose.yml run –rm compile’<br/>    <br/>    }</span><span id="a776" class="lb jq hh kx b fi lg ld l le lf">  }</span><span id="6985" class="lb jq hh kx b fi lg ld l le lf">}</span></pre><p id="8699" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们对测试步骤做同样的事情，我们会得到如下结果:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b89c" class="lb jq hh kx b fi lc ld l le lf">node{</span><span id="62ed" class="lb jq hh kx b fi lg ld l le lf">  docker.withRegistry(‘https://registry.example.com/', ‘svc-acct’) {</span><span id="6d14" class="lb jq hh kx b fi lg ld l le lf">    checkout scm</span><span id="0046" class="lb jq hh kx b fi lg ld l le lf">    stage(‘Build’) {</span><span id="67ed" class="lb jq hh kx b fi lg ld l le lf">      sh ‘docker-compose –f build-compose.yml run –rm compile’</span><span id="b857" class="lb jq hh kx b fi lg ld l le lf">    }</span><span id="d7ea" class="lb jq hh kx b fi lg ld l le lf">    stage(‘Test) {</span><span id="b97b" class="lb jq hh kx b fi lg ld l le lf">      sh ‘docker-compose –f build-compose.yml run –rm test’</span><span id="4c2f" class="lb jq hh kx b fi lg ld l le lf">    }</span><span id="9649" class="lb jq hh kx b fi lg ld l le lf">  }</span><span id="a70a" class="lb jq hh kx b fi lg ld l le lf">}</span></pre><p id="2026" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个例子很简单，但是它很好地分享了这个概念。</p><p id="5066" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以这种方式使用Docker Compose有几个好处:</p><p id="550b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)您可以为步骤的依赖关系编排其他容器；例如模拟API或DB。(你已经在做了，对吗？对吗？)</p><p id="24b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)您可以在本地机器上执行每一步，而不依赖于正在安装的Docker。</p><p id="6817" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个好处真的很好，不是每个人都想到的。这让团队有信心知道，当他们提交时，他们在本地运行的步骤也将在CI环境中工作。</p><h1 id="7a07" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="de7e" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">并不是每个公司或项目在他们的Jenkins环境中都有相同的约束，所以并不是每个人都会在使用“image.inside()”函数时遇到相同的问题。我希望，即使您没有遇到我们遇到的同样的挑战，您仍然会考虑在您的Jenkins环境中使用Docker Compose，因为它对您的管道的好处远远超出了这个特定的解决方法。</p><p id="5070" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>