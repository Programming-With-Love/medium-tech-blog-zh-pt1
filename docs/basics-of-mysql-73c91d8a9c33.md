# MySQL 基础——面向初学者

> 原文：<https://medium.com/quick-code/basics-of-mysql-73c91d8a9c33?source=collection_archive---------1----------------------->

![](img/190af608f72543a3750ba6164b2707de.png)

在本文中，我们将讨论一些在使用 MySql 以获得更好性能时应该记住的事情。

# 设计模式时要记住的事项:

MySql 支持多种数据类型，但是你应该总是选择更适合你的需求的类型，而不是仅仅对每个域 xP 使用 **VARCHAR** 或 **TEXT**

**整数:**存储整数值有多种类型，每种类型都有自己的取值范围，可以存储在 int 中。

*   TINYINT:8 位
*   SMALLINT:16 位
*   中等:24 位
*   INT:32 位
*   BIGINT:64 位

每种类型都可以存储从 **-2^(n-1 到 2^(n-1) -1** 的值，所以最好明智地选择，因为每种类型都需要不同的空间来存储值。

如果你对没有负值很有信心，那么你实际上可以使用 UNSIGNED 来增加两倍的范围，从 0 到 2 * (2^n-1) 。

> **有趣的事实** : MySql 也允许我们定义小于 8 位的 int 的大小，就像这个 **int(1)** 但是在内部它仍然把空间当作普通的 int 而不是 **1 位，**这是 MySql 客户端级检查。

**实数(FLOAT vs DECIMAL):** 你应该尽可能使用 FLOAT 来存储小数值，直到你真的需要精确的小数值，因为 FLOAT 占用 32 位空间，DECIMAL 占用 64 位空间。

当你真正关心精确的分数时，你应该使用小数。

字符串:MySql 中主要有两种数据类型，它们看起来非常相似，但是有很多不同之处

*   **VARCHAR:** 就空间而言，VARCHAR 比固定长度类型更有效，因为它只在需要的时候使用空间，就像如果你定义了 **VARCHAR(20)** 这并不意味着它总是为每行占用 20 个字节，它根据行中存储的值使用空间，就像如果你存储一个长度为 10 的字符串，那么它将占用 10 个字节的空间，所以很明显，20 是一个字符串可以拥有的最大长度。

VARCHAR 实际上提高了空间方面的性能，因为空间是可变的，但是当我们更新的值比先前存储的值长时，有时会导致碎片问题，所以 MySQL 必须将空间重新分配给那一行，这可能会导致碎片。

*   CHAR: 只有当你对存储在其中的值有足够的把握时，你才应该使用 CHAR，它有固定的长度或几乎相似的长度，因为 CHAR 总是占用固定的空间，不像 VARCHAR。

比如，如果你定义了 CHAR(20 ),那么不管你要存储的字符串有多长，每行都要占用 20 字节的空间。

> **有趣的事实:** VARCHAR 实际上需要几个额外的字节来存储字符串的长度，而不是模式创建时定义的大小，就像如果你定义了 VARCHAR(100 ),那么它将需要 1 个额外的字节，VARCHAR(1000)需要 2 个字节来存储字符串的长度，而 CHAR 总是需要精确的空间量，就像 CHAR(100)需要精确的 100 字节没有额外的空间。

**BINARY vs VARBINARY:** 当你存储二进制字符串时，你应该使用 BINARY 或 VARBINARY，而不是 VARCHAR，因为所有东西都在内存中，所以二进制比较比字符比较快。

**BLOB vs TEXT:** 只有当你真的必须分别存储大量的二进制字符串或字符串时，才应该使用它们。

**日期时间 vs 时间戳:**你应该尽可能多地使用时间戳，因为时间戳占用 4 个字节，而日期时间占用 8 个字节的空间。DATETIME 可以保存从 1001 年到 9999 年的值，而 TIMESTAMP 可以保存从 1970 年到 2038 年的值。

> **有趣的事实:**
> 
> 如果在插入时没有指定时间戳列的值，它将自动设置为当前时间戳。
> 
> 如果将 0 存储到定义为时间戳的列中，存储的值将类似于 1969–12–31 19:00:00

# MySql 索引

索引用于改进 MySQL 查询的查找，以便尽可能快地从大量数据中找到数据，MySQL 有各种类型的索引，每种索引都有自己的属性，决定何时使用哪种索引。

***B 树索引* :** B 树索引是 MySql 中最常见的索引，B 树实际上是按照顺序存储信息的，这就是为什么在创建 B 树索引时必须仔细选择列的顺序。因为信息是按顺序存储的，这使得搜索非常快，而大多数查询都是按同样的顺序获取数据的。

你可以这样理解，就像我们有下表一样:

```
**CREATE TABLE People ( name varchar(50) not null, dob date not null, gender enum(‘m’, ‘f’)not null, key(name));**
```

所以现在所有的记录者都按照姓名列排序，所以搜索姓名以亚历克斯开始的人非常快。

**何时使用:**

*   **前缀匹配:**因为记录是按顺序存储的，所以搜索前缀是很有效的，就像所有人的**名字**都是以给定的前缀开头一样。
*   **范围值:**当你要搜索范围内的记录时，比如从 **Alex** 到 **Kim 的所有人。**
*   **Order By:** 当您的查询主要使用 **ORDER BY** 时，索引会使它更有效，因为记录已经按顺序存储了。

**创作时要记住的事情:**

*   **列顺序:**列顺序对于 B 树索引非常重要，因为数据是按顺序存储的，所以让 support 用**键(名字，姓氏)**创建了一个索引，如果您搜索所有**姓氏**以**约翰**开头的人，该索引将不会帮助您，因为您跳过了**名字**列，所以只有当您以与索引相同的顺序搜索信息时，才会使用该索引。

****何时使用:****

*   ****精确匹配:**散列索引只有在您有精确查找查询时才有帮助。**

****要记住的事情:****

*   **哈希索引对范围查询没有帮助。**
*   **哈希索引不适用于部分键匹配。**

> ****有趣的事实:****
> 
> **如果在查询的 WHERE 子句中有一个表达式，那么它不会使用 index，所以请确保不要在 WHERE 子句中使用表达式。**
> 
> **SELECT * FROM id+1 = 3 的用户；**
> 
> **当你需要创建一个包含很长字符串的索引时，你可以在创建索引时使用字符串的前缀而不是整个字符串，以使你的索引在空间和时间上更有效。**

# ****查询优化:****

*   **始终确保只检索您需要的行，并在选择列时尽可能避免 ***** 。**
*   **不要运行一个大规模的查询，而是运行一些短的查询，这样就不会长时间锁定这么多行。**
*   **尽可能使用中的**而不是 **JOIN** ，因为**中的**比 **JOIN 更高效。******
*   **尽可能使用索引。**

> ****有趣的事实:****
> 
> **在 InnoDB 引擎中，在子句的**中搜索需要 log(n)。****
> 
> **MySql 客户端和数据库之间的连接是半双工的。因此，当一方发送数据时，另一方在响应之前必须接收整个消息。**