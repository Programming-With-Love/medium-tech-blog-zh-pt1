<html>
<head>
<title>Ramda your JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/compendium/ramda-your-javascript-e72bfaef01d5?source=collection_archive---------0-----------------------#2020-08-10">https://medium.com/compendium/ramda-your-javascript-e72bfaef01d5?source=collection_archive---------0-----------------------#2020-08-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5596a6cdd256468524630773d2aef17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fq-o56NAWwCeRVtLKwoPXA.png"/></div></div></figure><p id="a60e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如今，在开发人员的世界里，总会有一些令人兴奋的东西等待你去发现:新的框架、库、代码风格、鼓舞人心的设计、方法论等等。最近几个月，我对JavaScript中的<em class="jn">函数式编程</em>最感兴趣。</p><h2 id="de1c" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">介绍</h2><p id="cce3" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">函数式编程范式对我来说是全新的，但它让我不再像传统那样思考编写代码。我相信以一种<em class="jn">功能</em>的方式编写【和思考】会让你的代码更具可读性；你最终会在团队中的开发人员之间有一个更加一致的语言。稍后调试和重构您的代码会更容易。你也可能会写更少的代码，做出更多有用的东西。做函数式编程是不一样的，但是当你习惯了之后，也会有很多乐趣。</p><p id="a303" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我想向你展示RamdaJs可以做的一些很酷的事情——为了简单和懒惰，我现在称之为<em class="jn"> Ramda </em>。首先，值得一提的是，Ramda是一个JavaScript库，可以帮助你编写功能性的、简洁的、可重用的代码。Ramda是声明性的(而不是命令性的，这是目前最常见的方法)。因此，为了更好地理解为什么Ramda是有用的，我们应该有一个函数式编程原则的基本知识，然后是一些关于Ramda的例子。</p><p id="d2db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">我们将进入以下主题:</strong></p><ul class=""><li id="cf17" class="ko kp hh ir b is it iw ix ja kq je kr ji ks jm kt ku kv kw bi translated">Currying</li><li id="1910" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">纯函数</li><li id="5848" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">作文</li><li id="b560" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">不变</li><li id="2ca6" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">示例:注释列表</li></ul><h1 id="0075" class="lc jp hh bd jq ld le lf ju lg lh li jy lj lk ll kb lm ln lo ke lp lq lr kh ls bi translated">Currying</h1><p id="6549" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">Currying是一种技术，在这种技术中，我们可以“考虑”将一个接受许多参数的函数转换为一个接受较少参数的更具体的函数。在currying的帮助下，我们可以将一个大的嵌套函数拆分成更小的函数。然后我们去除复杂性，使一个函数简洁且可重用。</p><h2 id="539d" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">简化的功能</h2><p id="4753" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">curried函数在收到所有需要的参数之前不会做任何事情。它将一次处理一个参数<em class="jn">。</em></p><p id="7cb8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们有一个带三个参数的函数，这个函数的一个简化版本将带一个参数并返回一个带下一个参数的函数，然后返回一个带第三个参数的函数。</p><p id="4b15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个有三个参数的函数，将每个函数的数目相加，可以写成:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c35d" class="jo jp hh ly b fi mc md l me mf">// add = a =&gt; b =&gt; c =&gt; Number<br/>const add = a =&gt; b =&gt; c =&gt; a + b + c;</span></pre><p id="4775" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了让这个函数充分发挥作用，我们需要应用它的所有参数。我们可以用几种方法做到这一点，下面所有的例子都是允许的:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="fd12" class="jo jp hh ly b fi mc md l me mf">add(1, 2, 3) // 6<br/>add(4)(1, 10) // 15<br/>add(2, 3)(2) // 7<br/>add(3)(2)(1) // 6</span><span id="7624" class="jo jp hh ly b fi mg md l me mf">add(2)(3) // partially applied</span></pre><p id="559d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Ramda之所以伟大，是因为它们的函数是自动生成的，这允许我们快速构建一系列简单明了的小函数或我们已经创建的旧函数。</p><h1 id="6f11" class="lc jp hh bd jq ld le lf ju lg lh li jy lj lk ll kb lm ln lo ke lp lq lr kh ls bi translated">纯函数</h1><p id="eba8" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">一个<em class="jn">纯函数</em>是函数式编程中的一个基本概念。所谓的<em class="jn">纯粹的</em>，我们的意思是一个函数应该没有所谓的“副作用”</p><p id="d19a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">纯函数的一些基本规则是:</p><ul class=""><li id="eb96" class="ko kp hh ir b is it iw ix ja kq je kr ji ks jm kt ku kv kw bi translated">它不会给未完成的变量赋值，即在自己的作用域之外，在<strong class="ir hi"> { </strong>和<strong class="ir hi"> } </strong>之间。</li><li id="f508" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">它不读写数据库，也不执行API调用。</li><li id="d7e5" class="ko kp hh ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">它不会改变传入的参数。(这是一个严格的规则，在我们的函数中并不总是能够避免使用副作用。但是在大多数情况下，所有的函数都应该尽可能的干净。)</li></ul><p id="6821" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有时，您甚至可能希望将函数嵌套在使用父函数作用域中的变量的其他函数中。在这种情况下，您应该考虑将函数拆分成更小的函数，而不是通过它们传递值。</p><h1 id="1e99" class="lc jp hh bd jq ld le lf ju lg lh li jy lj lk ll kb lm ln lo ke lp lq lr kh ls bi translated">作文</h1><p id="0911" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated"><em class="jn">组合</em>是指我们采用一个<em class="jn">返回</em>函数，并将其作为参数传递给另一个函数。看看下面的代码:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c729" class="jo jp hh ly b fi mc md l me mf">const flip = x =&gt; x.split('').reverse().join('')<br/>const exclaim = x =&gt; `${x}!`</span><span id="e923" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const flipAndShout = x =&gt; exclaim(flip(x))</strong></span><span id="38c2" class="jo jp hh ly b fi mg md l me mf">flipAndShout('dlroW olleH') // "Hello, World!"</span></pre><p id="2d63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们调用两个函数，它们都对值<em class="jn"> x </em>做了一些事情。这段代码很难读懂。如果我们给<strong class="ir hi"> flipAndShout </strong>变量添加更多的函数，那就更有挑战性了。</p><p id="0406" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一个例子是一个合成函数:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="bb88" class="jo jp hh ly b fi mc md l me mf">const compose = (f, g) =&gt; {<br/>  return x =&gt; f(g(x))<br/>}</span></pre><p id="42cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">参数<code class="du mh mi mj ly b">f</code>和<code class="du mh mi mj ly b">g</code>是函数，<code class="du mh mi mj ly b">x</code>是贯穿它们的值。在这里，函数<code class="du mh mi mj ly b">g</code>将首先运行，然后是函数<code class="du mh mi mj ly b">f</code>，这将使调用从右向左流动。为了了解如何实现这一点，我们可以重构前一个示例中的代码，并使用我们的<code class="du mh mi mj ly b">compose</code>函数:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4429" class="jo jp hh ly b fi mc md l me mf">const flip = x =&gt; x.split('').reverse().join('')<br/>const exclaim = x =&gt; `${x}!`</span><span id="d78e" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const flipAndShout = compose(exclaim, flip)</strong></span><span id="4238" class="jo jp hh ly b fi mg md l me mf">flipAndShout('dlroW olleH') // "Hello, World!"</span></pre><p id="8029" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这比一堆函数调用更容易阅读。我们只需快速浏览一下，就能看到<strong class="ir hi"> flipAndShout </strong>函数将返回什么。稍后我们将看一些Ramda的复合函数的例子。</p><h1 id="1206" class="lc jp hh bd jq ld le lf ju lg lh li jy lj lk ll kb lm ln lo ke lp lq lr kh ls bi translated">不变</h1><p id="c2a2" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">不变性和不可变数据的概念在函数式编程中也很重要。</p><p id="9018" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不变性意味着现有数据不应改变。我们用某个值(字符串，数组，数字)初始化一个变量；它不应该<em class="jn">改变</em>数据类型(或被转换为),也不应该被覆盖——甚至是对象属性或数组中的元素。如果现有数据被更改，我们可能会在调试时遇到一些大问题，如果有人在某个时候需要重构代码，代码可能不那么可读。</p></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><h1 id="eb31" class="lc jp hh bd jq ld mr lf ju lg ms li jy lj mt ll kb lm mu lo ke lp mv lr kh ls bi translated">我们现在可以跳Ramda了吗…？</h1><p id="0133" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">没错。</p><p id="50da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Ramda是一个优秀的库，可以帮助你开始用JavaScript进行功能性思考。Ramda提供了一个很棒的工具箱，里面有很多有用的功能和体面的文档。如果你想在我们进行的过程中尝试它的功能，可以看看拉姆达的<a class="ae mw" href="https://ramdajs.com/repl/" rel="noopener ugc nofollow" target="_blank"> REPL </a>。</p><h2 id="3f9c" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">装置</h2><p id="7d28" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">Ramda可以通过几种方式安装，通过Yarn或者NPM(但是他们也在他们的网站上提供一些CDN ):</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="b0e6" class="jo jp hh ly b fi mc md l me mf">yarn add ramda</span><span id="53a6" class="jo jp hh ly b fi mg md l me mf">// or </span><span id="7b67" class="jo jp hh ly b fi mg md l me mf">npm install ramda</span></pre><h2 id="06cb" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">使用</h2><p id="7c27" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated"><code class="du mh mi mj ly b">require</code>或<code class="du mh mi mj ly b">import</code>它进入你的项目:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="85f1" class="jo jp hh ly b fi mc md l me mf">const R = require('ramda')</span><span id="5b8d" class="jo jp hh ly b fi mg md l me mf">// or</span><span id="ec17" class="jo jp hh ly b fi mg md l me mf">import R from 'ramda'</span></pre><p id="5c68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者，如果更适合您，您可以导入每个函数。然后，您不需要为每个使用的函数预先添加<code class="du mh mi mj ly b">R.</code>:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="17dc" class="jo jp hh ly b fi mc md l me mf">import { map, filter, <!-- -->prop <!-- -->} from 'ramda'</span></pre><p id="0513" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你使用的是<a class="ae mw" href="https://ramdajs.com/repl/" rel="noopener ugc nofollow" target="_blank"> REPL </a>，没有必要导入任何东西。您可以编写函数(或者直接从这里复制/粘贴),就像它们已经现成可用一样。</p><h1 id="3cbb" class="lc jp hh bd jq ld le lf ju lg lh li jy lj lk ll kb lm ln lo ke lp lq lr kh ls bi translated">示例:注释列表</h1><p id="b989" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">总有一天，所有开发人员都会创建一个笔记列表。我们将笔记添加到我们的<em class="jn">列表</em>，当我们完成一个笔记时，我们将它存档。</p><p id="e5d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要一个数据集，既包含常规笔记，又包含这样一个笔记列表的提醒。在我们的例子中，我们将使用下面的notesList数组。具有有效(非空)“到期日期”属性的对象是提醒，而没有的对象是常规注释:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="8d74" class="jo jp hh ly b fi mc md l me mf">const notesList = [<br/>  {<br/>    title: "Buy milk and bread",<br/>    createdAt: '2020-04-04',<br/>    dueDate: null,<br/>    archived: false,<br/>  },<br/>  {<br/>    title: "Pick up a package at the post office",<br/>    createdAt: '2020-04-04',<br/>    dueDate: null,<br/>    archived: false,<br/>  },<br/>  {<br/>    title: "Take a walk with Yoda",<br/>    createdAt: '2020-04-04',<br/>    dueDate: null,<br/>    archived: true,<br/>  },<br/>  {<br/>    title: "Read 15 minutes",<br/>    createdAt: '2020-03-07',<br/>    dueDate: '2020-03-08',<br/>    archived: false,<br/>  },<br/>  {<br/>    title: "Do 30 minutes workout",<br/>    createdAt: '2020-03-01',<br/>    dueDate: '2020-03-04',<br/>    archived: false,<br/>  },<br/>]</span></pre><h2 id="6889" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">过滤</h2><p id="4f61" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">对这个列表的一个典型操作是过滤掉我们已经完成的内容(在这个例子中是“存档”)。通过使用内置数组方法，我们可以实现我们想要的:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="d514" class="jo jp hh ly b fi mc md l me mf">const filterNotes = notesList.filter(note =&gt; !note.archived);</span></pre><p id="9969" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">借助Ramda，我们可以做到以下几点:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="9097" class="jo jp hh ly b fi mc md l me mf">const filterNotes = R.filter(R.propEq('archived', false));</span></pre><p id="6d0d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，这里发生了什么？我们没有向使用Ramda语法的<code class="du mh mi mj ly b">filterNotes</code>函数传递任何参数。这是因为该功能属于<em class="jn">自由点类型。</em></p><p id="ae44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> Pointfree-style也是一种函数式编程风格，其中函数定义(函数体)不引用函数的参数。我们可以通过调用返回函数的函数，比如curried函数，得到一个无点样式。让我们提醒自己这个帖子前面的例子:</em></p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="af45" class="jo jp hh ly b fi mc md l me mf">// add = a =&gt; b =&gt; c =&gt; Number<br/>const add = a =&gt; b =&gt; c =&gt; a + b + c;</span></pre><p id="8083" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们不需要为函数定义分配参数。或者换句话说，我们不需要“告诉”Ramda函数它需要什么数据。</p><p id="3fdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们仍然需要调用带有参数的<code class="du mh mi mj ly b">filterNotes</code>函数来使其工作，参数必须是对象列表，并且对象必须至少包含一个<code class="du mh mi mj ly b">archived</code>属性。</p><h2 id="d615" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">按属性排序</h2><p id="b453" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">现在我们已经过滤掉了所有不是<code class="du mh mi mj ly b">archived</code>的音符。现在让我们按照创建日期对笔记进行分类。为此，我们可以使用Ramda的<code class="du mh mi mj ly b">sortBy</code>和<code class="du mh mi mj ly b">prop</code>函数:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="df81" class="jo jp hh ly b fi mc md l me mf">const filterNotes = filter(propEq('archived', false));</span><span id="4a29" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const sortByCreatedAt = sortBy(prop(‘createdAt’));<br/>const filteredNotes = filterNotes(notesList);</strong></span><span id="9043" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">sortByCreated(filteredNotes);</strong></span></pre><h2 id="6273" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">功能组成</h2><p id="5200" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">上面的代码可读性不是很好，但是我们怎样才能让它变得更好呢？前面我们讲了作文。通过函数组合，我们可以构建其他小函数的函数管道。Ramda提供了几个函数来进行函数组合，这些函数被称为<code class="du mh mi mj ly b">pipe</code>和<code class="du mh mi mj ly b">compose</code>。</p><p id="af3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这两个函数都接受一个或多个参数并返回一个函数。<code class="du mh mi mj ly b">pipe</code>※<em class="jn">由左向右</em>构图。它接受第一个参数，将结果传递给下一个参数，并像这样继续下去，直到最后一个参数。<code class="du mh mi mj ly b">compose</code>略有不同，从右向左应用参数<em class="jn">。</em></p><p id="3e52" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你用哪一个都没关系，但是要选择最适合你的。我更喜欢在例子中使用<code class="du mh mi mj ly b">compose</code>，因为这是我的眼睛处理得最好的。</p><p id="b7fc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在<strong class="ir hi"> <em class="jn">过滤器上使用<code class="du mh mi mj ly b">compose</code>注释</em> </strong>和<strong class="ir hi"><em class="jn">sortByCreatedAt</em></strong>:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="bcf8" class="jo jp hh ly b fi mc md l me mf">const filterNotes = filter(propEq('archived', false));</span><span id="f51d" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const sortByCreatedAt = sortBy(prop('createdAt'));</strong><br/><strong class="ly hi">const sortNotes = compose(sortByCreatedAt, filterNotes);</strong></span><span id="4ab8" class="jo jp hh ly b fi mg md l me mf">sortNotes(notesList);</span></pre><p id="8b45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们想对笔记进行降序排序，同时重用我们已经编写的代码。我们如何实现这一目标？Ramda的<code class="du mh mi mj ly b">reverse</code>函数在这里就派上用场了。<code class="du mh mi mj ly b">reverse</code>获取一个列表并以相反的顺序返回它:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="255a" class="jo jp hh ly b fi mc md l me mf">const filterNotes = filter(propEq('archived', false));</span><span id="3c6a" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const sortByCreatedAt = sortBy(prop('createdAt'));</strong><br/><strong class="ly hi">const sortByCreatedAtDescending = compose(reverse, sortByCreated);</strong></span><span id="52fb" class="jo jp hh ly b fi mg md l me mf">const sortNotes = compose(<strong class="ly hi">sortByCreatedAtDescending</strong>, filteredNotes);</span><span id="0178" class="jo jp hh ly b fi mg md l me mf">sortNotes(notesList);</span></pre><h2 id="9cdb" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">按类别分组</h2><p id="b39c" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">Ramda有一个名为<em class="jn"> groupBy </em>的函数，它将一个列表分割成子列表，然后将结果存储在一个对象中。</p><p id="9ab1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们的示例，我们可以传递一个函数，该函数为每个对象中的“dueDate”属性创建一个条件语句，然后返回一个笔记应该分组到哪个“key”中。</p><p id="d621" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的函数可以这样写:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="a551" class="jo jp hh ly b fi mc md l me mf">const groupByType = groupBy(n =&gt; n.duedate ? 'reminders' : 'notes')</span></pre><p id="fbb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并用剩下的代码实现它:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="f837" class="jo jp hh ly b fi mc md l me mf">const filterNotes = filter(propEq('archived', false));<br/>const sortByCreatedAt = sortBy(prop('createdAt'));</span><span id="7afb" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const groupByType = groupBy(n =&gt; n.dueDate ? 'reminders' : 'notes')</strong></span><span id="9706" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const filterByType = compose(groupByType, sortByCreatedAt);</strong><br/>const sortedNotes = compose(<br/>      <strong class="ly hi">filterByType</strong>,<br/>      filterNotes<br/>    );</span><span id="dddd" class="jo jp hh ly b fi mg md l me mf">sortedNotes(notesList)</span></pre><p id="d578" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的代码看起来很棒。现在我们将所有的笔记和提醒分组(每种类型作为对象键)，我们得到这样的结果:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="3889" class="jo jp hh ly b fi mc md l me mf">{<br/>    notes: [<br/>        {<br/>            archived: false,<br/>            createdAt: "2020-04-04",<br/>            dueDate: null,<br/>            title: "Buy milk and bread"<br/>        },<br/>        {<br/>            archived: false,<br/>            createdAt: "2020-04-04",<br/>            dueDate: null,<br/>            title: "Pick up a package at the post office"<br/>        }<br/>    ],<br/>    reminders: [<br/>        {<br/>            archived: false,<br/>            createdAt: "2020-03-01",<br/>            dueDate: "2020-03-04",<br/>            title: "Do 30 minutes workout"<br/>        },<br/>        {<br/>            archived: false,<br/>            createdAt: "2020-03-07",<br/>            dueDate: "2020-03-08",<br/>            title: "Read 15 minutes"<br/>        }<br/>    ]<br/>}</span></pre><p id="a62f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae mw" href="https://ramdajs.com/repl/?v=0.27.0#?const%20notesList%20%3D%20%5B%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Buy%20milk%20and%20bread%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Pick%20up%20package%20at%20mail%20office%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Take%20a%20walk%20with%20Yoda%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20true%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Read%2015%20minutes%22%2C%0A%20%20%20%20createdAt%3A%20%272020-03-07%27%2C%0A%20%20%20%20dueDate%3A%20%272020-03-08%27%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Do%2030%20minutes%20workout%22%2C%0A%20%20%20%20createdAt%3A%20%272020-03-01%27%2C%0A%20%20%20%20dueDate%3A%20%272020-03-04%27%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%5D%0A%0Aconst%20filterNotes%20%3D%20filter%28whereEq%28%7B%20archived%3A%20false%20%7D%29%29%3B%0Aconst%20sortByCreatedAt%20%3D%20sortBy%28prop%28%27createdAt%27%29%29%3B%0Aconst%20groupByType%20%3D%20groupBy%28n%20%3D%3E%20n.dueDate%20%3F%20%27reminders%27%20%3A%20%27notes%27%29%0Aconst%20filterByType%20%3D%20compose%28groupByType%2C%20sortByCreatedAt%29%3B%0Aconst%20sortedNotes%20%3D%20compose%28%0A%20%20%20%20%20%20filterByType%2C%0A%20%20%20%20%20%20filterNotes%0A%20%20%20%20%29%3B%0AsortedNotes%28notesList%29" rel="noopener ugc nofollow" target="_blank">查看拉姆达REPL的结果</a></p><h2 id="8eef" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">收尾工作</h2><p id="85be" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">现在，我们的<code class="du mh mi mj ly b">notesList</code>中的一些对象属性可能并不总是必需的。</p><p id="af42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以有一个用户界面，其中我们只需要一些属性来直观地显示它们(其余的不用)。这些性质我们可以认为是<em class="jn">重要的</em>信息。<code class="du mh mi mj ly b"><a class="ae mw" href="https://ramdajs.com/docs/#project" rel="noopener ugc nofollow" target="_blank">project</a></code>是一个类似于SQL <code class="du mh mi mj ly b">select</code>的Ramda函数，可以从每个对象中选择我们想要的(重要)属性(它也是Ramda <code class="du mh mi mj ly b">pick</code>和<code class="du mh mi mj ly b">map</code>的组合):</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="7656" class="jo jp hh ly b fi mc md l me mf">const importantFields = project(['title', 'createdAt'<strong class="ly hi">, </strong>'dueDate']);</span></pre><p id="f2a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用剩下的代码来实现它:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4c2a" class="jo jp hh ly b fi mc md l me mf">const filterNotes = filter(propEq('archived', false));<br/>const sortByCreatedAt = sortBy(prop('createdAt'));<br/>const sortByCreatedAtDescending = compose(reverse, sortByCreatedAt);<br/>const groupByType = groupBy(n =&gt; n.dueDate ? 'reminders' : 'notes')</span><span id="f033" class="jo jp hh ly b fi mg md l me mf"><strong class="ly hi">const importantFields = project(['title', 'createdAt', 'dueDate']);</strong></span><span id="0044" class="jo jp hh ly b fi mg md l me mf">const filterByType = compose(groupByType, sortByCreatedAt)<br/>const sortedNotes = compose(<br/>      <strong class="ly hi">importantFields</strong>,<br/>      filterByType,<br/>      filterNotes<br/>    )<br/>sortedNotes(notesList)</span></pre><p id="ad81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae mw" href="https://ramdajs.com/repl/?v=0.27.0#?const%20notesList%20%3D%20%5B%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Buy%20milk%20and%20bread%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Pick%20up%20package%20at%20mail%20office%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Take%20a%20walk%20with%20Yoda%22%2C%0A%20%20%20%20createdAt%3A%20%272020-04-04%27%2C%0A%20%20%20%20dueDate%3A%20null%2C%0A%20%20%20%20archived%3A%20true%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Read%2015%20minutes%22%2C%0A%20%20%20%20createdAt%3A%20%272020-03-07%27%2C%0A%20%20%20%20dueDate%3A%20%272020-03-08%27%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20title%3A%20%22Do%2030%20minutes%20workout%22%2C%0A%20%20%20%20createdAt%3A%20%272020-03-01%27%2C%0A%20%20%20%20dueDate%3A%20%272020-03-04%27%2C%0A%20%20%20%20archived%3A%20false%2C%0A%20%20%7D%2C%0A%5D%0A%0Aconst%20filterNotes%20%3D%20filter%28R.whereEq%28%7B%20archived%3A%20false%20%7D%29%29%3B%0Aconst%20sortByCreatedAt%20%3D%20sortBy%28prop%28%27createdAt%27%29%29%3B%0Aconst%20sortByCreatedAtDescending%20%3D%20compose%28reverse%2C%20sortByCreatedAt%29%3B%0Aconst%20groupByType%20%3D%20groupBy%28n%20%3D%3E%20n.dueDate%20%3F%20%27reminders%27%20%3A%20%27notes%27%29%0Aconst%20importantFields%20%3D%20project%28%5B%27title%27%2C%20%27createdAt%27%2C%20%27dueDate%27%5D%29%3B%0Aconst%20filterByType%20%3D%20compose%28groupByType%2C%20sortByCreatedAt%29%0Aconst%20sortedNotes%20%3D%20compose%28%0A%20%20%20%20%20%20map%28importantFields%29%2C%0A%20%20%20%20%20%20filterByType%2C%0A%20%20%20%20%20%20filterNotes%0A%20%20%20%20%29%0AsortedNotes%28notesList%29" rel="noopener ugc nofollow" target="_blank">在REPL看最终结果</a></p><p id="f8d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了一个包含两个数组的对象，按创建日期和活动状态排序；多棒啊，不是吗？作为我们的最终结果，看看它有多干净，我们得到了我们需要的数据:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="ebdb" class="jo jp hh ly b fi mc md l me mf">{<br/>    notes: [<br/>        {<br/>            createdAt: "2020-04-04",<br/>            dueDate: null,<br/>            title: "Buy milk and bread"<br/>        },<br/>        {<br/>            createdAt: "2020-04-04",<br/>            dueDate: null,<br/>            title: "Pick up package at mail office"<br/>        }<br/>    ],<br/>    reminders: [<br/>        {<br/>            createdAt: "2020-03-01",<br/>            dueDate: "2020-03-04",<br/>            title: "Do 30 minutes workout"<br/>        },<br/>        {<br/>            createdAt: "2020-03-07",<br/>            dueDate: "2020-03-08",<br/>            title: "Read 15 minutes"<br/>        }<br/>    ]<br/>}</span></pre><p id="41a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢阅读！</p><p id="aaeb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">代号foh shizzle </em></p></div></div>    
</body>
</html>