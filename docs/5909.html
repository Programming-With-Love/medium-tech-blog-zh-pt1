<html>
<head>
<title>Working with Data in TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TensorFlow中使用数据</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/working-with-data-in-tensorflow-a0656f616f4f?source=collection_archive---------1-----------------------#2022-05-16">https://medium.com/oracledevs/working-with-data-in-tensorflow-a0656f616f4f?source=collection_archive---------1-----------------------#2022-05-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5c10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">欢迎阅读本文章系列的第三篇文章！在本文中，我们将深入使用TensorFlow设置一个简单的项目，这与我们在文章系列中一直在做的事情(使用PyTorch)相反。希望我们能看到两个库中的开发相对来说有多容易。</p><p id="f2ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为一个提醒，让我们有一些关于TensorFlow的初始信息。TensorFlow是一个开源平台，由谷歌在2015年创建。从这个原始平台开始，开发了多个库，允许在各种编程语言中使用TensorFlow平台，如Python、JavaScript，甚至移动设备。它为希望将机器学习的最新技术变为现实的开发人员和研究人员提供了一个全面的工具生态系统。</p><h1 id="a8f0" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">建立OCI</h1><p id="89c8" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了在OCI建立TensorFlow，我们将在OCI创建一个<a class="ae kf" href="https://www.oracle.com/data-science/service/" rel="noopener ugc nofollow" target="_blank">数据科学</a>笔记本，我们将能够从云中访问它，从而省去我们在本地建立项目的麻烦。我们将遵循的过程与我们在系列文章的第一篇文章<a class="ae kf" href="https://github.com/jasperan/pytorch-tensorflow/blob/main/1_getting_started_with_pytorch_on_oci.md" rel="noopener ugc nofollow" target="_blank">中遵循的步骤非常相似。如果你在OCI建立数据科学笔记本时遇到了麻烦，一定要看看那篇文章。</a></p><p id="f40e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们设置一个OCI数据科学环境，并通过前往OCI控制台并导航到<strong class="ig hi"> OCI数据科学</strong>来实例化数据科学服务:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/734e0d2e2e89bcc610648444ba945fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OWHSbHg8bg9lv8cB"/></div></div></figure><p id="9608" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们到目前为止创建的唯一项目中，我们可以有几个笔记本会话；并且这些会话每个都有各自的存储。在我们的项目中，我们将创建一个新的笔记本会话，并在其中安装TensorFlow环境。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ks"><img src="../Images/354c07cf64af711158284fd15fd08b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qh_v8O9l4IyP7y3l"/></div></div></figure><p id="49c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">访问笔记本，我们从官方环境浏览器安装TensorFlow环境:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kt"><img src="../Images/0b43ec0807f3fb781496b8ee82c4ee97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I_DcsCShhMgWllrN"/></div></div></figure><p id="9457" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了安装它，我们在终端中使用相应的预构建标识符运行命令。在撰写本文时，TensorFlow 2.7是CPU可用的最新版本；以及面向GPU的TensorFlow 2.6。</p><h1 id="5ce3" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">TensorFlow基础知识—使用Keras加载数据</h1><p id="b4ca" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">值得注意的是，<a class="ae kf" href="https://github.com/jasperan/pytorch-tensorflow/blob/main/1_getting_started_with_pytorch_on_oci.md" rel="noopener ugc nofollow" target="_blank">在本系列的第一篇文章</a>中，我们加载了一个初始数据集(众所周知的虹膜数据集)，并从头开始创建了一个神经网络，以便准确预测虹膜的类型(setosa、versicolor或virginica)。我们通过PyTorch库实现了这一点，该库包括一个定制的数据集加载器。</p><p id="5cac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像PyTorch一样，TensorFlow也“喜欢”将其数据集加载到tensors中；然而，<a class="ae kf" href="https://www.tensorflow.org/tutorials" rel="noopener ugc nofollow" target="_blank">官方文档</a>指向使用<strong class="ig hi"> keras </strong>作为数据加载库。发现Keras和TensorFlow互换使用是很常见的，因为Keras简化了TensorFlow的使用。</p><p id="f151" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能会问自己:为什么要改变我们加载数据的机制？Keras和TensorFlow都是机器学习NN技术/库。然而，Keras <strong class="ig hi">封装了</strong>张量流。它是TensorFlow库的包装器，旨在使神经网络的开发更加容易。然而，这是有代价的，那就是速度。如果您决定使用Keras而不是TensorFlow，请考虑在标准TensorFlow库之上构建的任何东西都将导致模型吞吐量/机器预测吞吐量方面的不准确性，因为在访问TensorFlow本身之前，所有东西都将通过Keras进行过滤。</p><p id="9160" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记住这一点，您可以使用任何可用的数据加载库自由地加载数据。</p><p id="0999" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我选择只使用Keras作为数据加载库，而不是我们以前用于开发的库(包括iris NN)。</p><p id="7284" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，这里有一个使用Keras库加载数据是多么容易的例子。对于本例，我们将使用MNIST数字分类数据集。这是60000幅灰度图像的数据集，尺寸为28x28像素，其中每幅图片代表数字0到9的图像，测试集大小为10.000幅图像。<strong class="ig hi"> load_data </strong>函数自动将mnist数据集划分为以下训练/测试规模:</p><pre class="kh ki kj kk fd ku kv kw kx aw ky bi"><span id="85df" class="kz jd hh kv b fi la lb l lc ld">import tensorflow as tf<br/>mnist_dataset = tf.keras.datasets.mnist</span><span id="764c" class="kz jd hh kv b fi le lb l lc ld"># we split into train and tests using the load_data function <br/>(x_train, y_train), (x_test, y_test) = mnist_dataset.load_data()<br/>x_train, x_test = x_train / 255.0, x_test / 255.0</span><span id="a9d6" class="kz jd hh kv b fi le lb l lc ld">&gt;&gt;&gt; Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/mnist.npz<br/>&gt;&gt;&gt; 11493376/11490434 [==============================] - 0s 0us/step<br/>&gt;&gt;&gt; 11501568/11490434 [==============================] - 0s 0us/step</span></pre><p id="6790" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可能会问为什么我们要把数据除以255.0。这样做是为了将每个像素值(在数据集中的范围是从0到255)归一化为从0到1的值(基本上我们是在应用归一化)。公平地说，这是不必要的，因为神经网络最终会自己学习如何规范化数据。然而，为了建立良好的软件实践并自己处理输入数据，我们在处理数据之前应用这个非常基本的规范化。</p><p id="1d90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们打印现有的当前数据，我们将得到一个28x28的数组作为输入数据(我们的特性)和一个整数作为标签(像素实际代表的数量):</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lf"><img src="../Images/b81ef731d77f87b752ae0ba567a83ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*_TK0VXVcPdXtGYjW"/></div></figure><h1 id="c7f3" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">训练模型</h1><p id="6545" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在，我们将专注于训练模型。我们说过，每一行数据代表一幅图像。这张图片的尺寸是28x28像素，等于784。因此，我们将创建一个具有784个输入的张量流模型，并将这些输入连接到一个密集层(隐藏层)，这意味着我们正在创建一个递归神经网络。因此，自动微分和复杂梯度计算将在内部自动执行。隐藏层将具有128个节点并重新激活，然后将连接到10个节点的输出层(另一个密集层)。</p><p id="b270" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">选择初始参数是一门复杂的艺术。例如，当我开始学习AI和ML时，我总是想知道人们是如何得出初始参数的，我认为这是一项具有挑战性的任务。在与非常广泛地使用神经网络的人交谈时，我被告知，这个初始数字通常是半随机地执行的(脑子里有一些想法)，没有给予它太多的思考。如果神经网络能够利用这些初始参数进行学习，我们不需要执行任何其他操作，如果神经网络在学习指定数量的时期时遇到困难，可以尝试一些故障排除策略(可以考虑在机器学习中执行超参数化):</p><ul class=""><li id="1e44" class="lg lh hh ig b ih ii il im ip li it lj ix lk jb ll lm ln lo bi translated">更改输入参数，如组成隐藏层的节点数，并尝试不同的值</li><li id="993d" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">改变深层神经网络的架构(提醒:深层神经网络只是一个具有多个隐藏层的神经网络)</li><li id="4ebd" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">改变损失函数</li><li id="d83b" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">更改优化器</li><li id="cbe8" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">更改激活功能</li></ul><p id="9d1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最佳地执行这些事情需要大量的实践和尝试/错误，所以不要在开始时气馁，即使你不知道在开始时输入哪些值。</p><pre class="kh ki kj kk fd ku kv kw kx aw ky bi"><span id="ee69" class="kz jd hh kv b fi la lb l lc ld">model = tf.keras.models.Sequential([<br/>        # 1st layer: flatten the input. From a 28x28 array, we get a vector of 784 elements<br/>        tf.keras.layers.Flatten(input_shape=(28, 28)),<br/>        # 2nd layer: we create a dense layer with 128 nodes and ReLU activation<br/>        tf.keras.layers.Dense(128, activation='relu'),<br/>        # 3rd layer: we regularize the model (more about this below*)<br/>        tf.keras.layers.Dropout(0.2),<br/>        # 4th layer: we finish with another dense layer with 10 nodes.<br/>        tf.keras.layers.Dense(10)<br/>])</span><span id="e970" class="kz jd hh kv b fi le lb l lc ld">loss_fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)</span><span id="7376" class="kz jd hh kv b fi le lb l lc ld">model.compile(optimizer='adam',<br/>              loss=loss_fn,<br/>              metrics=['accuracy'])</span><span id="5e2a" class="kz jd hh kv b fi le lb l lc ld">model.fit(x_train, y_train, epochs=10, batch_size=1024)</span></pre><p id="80eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这为我们的模型训练了10个时期。如果损失没有显著减少，我们可以尝试增加时期的数量。请记住，对于每个时期，我们将使神经网络的参数由前一次迭代更新并更新，以便向神经网络提供反馈并随着时间的推移而改进。我个人见过在几周内运行了几十万个时期的模型，所以不要害怕添加时期。从理论上讲，包含的时代越多，数据集的精度就越高(一般来说)。</p><pre class="kh ki kj kk fd ku kv kw kx aw ky bi"><span id="c4f7" class="kz jd hh kv b fi la lb l lc ld">&gt;&gt;&gt; Epoch 1/10<br/>59/59 [==============================] - 1s 5ms/step - loss: 2.9121 - accuracy: 0.3993<br/>&gt;&gt;&gt; Epoch 2/10<br/>59/59 [==============================] - 0s 6ms/step - loss: 1.1435 - accuracy: 0.8094<br/>&gt;&gt;&gt; Epoch 3/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.7380 - accuracy: 0.8539<br/>&gt;&gt;&gt; Epoch 4/10<br/>59/59 [==============================] - 0s 6ms/step - loss: 0.5890 - accuracy: 0.8713<br/>&gt;&gt;&gt; Epoch 5/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.5113 - accuracy: 0.8818<br/>&gt;&gt;&gt; Epoch 6/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.4630 - accuracy: 0.8894<br/>&gt;&gt;&gt; Epoch 7/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.4298 - accuracy: 0.8949<br/>&gt;&gt;&gt; Epoch 8/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.4052 - accuracy: 0.8989<br/>&gt;&gt;&gt; Epoch 9/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.3864 - accuracy: 0.9025<br/>&gt;&gt;&gt; Epoch 10/10<br/>59/59 [==============================] - 0s 5ms/step - loss: 0.3712 - accuracy: 0.9053</span></pre><p id="8eca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面介绍的漏失层是深度神经网络中常用来防止过拟合的层，它基于一种称为随机正则化的正则化技术。主要思想是寻找试图学习噪声模式的NN的某些参数。这是通过随机丢弃一部分输入神经元来实现的，通常是大约20–50%的神经元(这取决于层中存在的神经元数量)。这试图检测哪些神经元增加了噪声，哪些神经元实际上增加了预测值。</p><h1 id="97f7" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">导出模型</h1><p id="9c87" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了导出和重用模型，我们可以制作一个名为<strong class="ig hi"> SaveModel </strong>的函数，该函数被认为是TensorFlow 2.x的标准，它被TensorFlow开发团队正式推荐为共享预训练模型的“格式”。</p><p id="fb33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，Keras隐藏了TensorFlow的许多复杂性(<a class="ae kf" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank">在TensorFlow中执行要比在Keras </a>中复杂一点)，并允许我们非常容易地做到这一点:</p><pre class="kh ki kj kk fd ku kv kw kx aw ky bi"><span id="a5fd" class="kz jd hh kv b fi la lb l lc ld">my_first_model_path = './firstmodel/'<br/>tf.saved_model.save(model, my_first_model_path)<br/># or: model.save(my_first_model_path)</span></pre><p id="0d5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们可以在保存模型后将其重新导入到另一个对象中:</p><pre class="kh ki kj kk fd ku kv kw kx aw ky bi"><span id="e6cc" class="kz jd hh kv b fi la lb l lc ld">new_model = tf.saved_model.load(my_first_model_path)</span><span id="af1e" class="kz jd hh kv b fi le lb l lc ld">&gt;&gt;&gt; &lt;tensorflow.python.saved_model.load.Loader._recreate_base_user_object.&lt;locals&gt;._UserObject at 0x7f917c4ab7d0&gt;</span></pre><p id="9b16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所见，使用TensorFlow并不太难。在我个人看来，TensorFlow在加载/导出数据方面似乎更容易使用，训练模型也更容易(这要归功于联合使用Keras和TensorFlow生态系统)。</p><p id="a533" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，现在是你开始的时候了。</p><p id="c2f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">前往OCI，创建一个免费帐户开始吧！如果你想不花一分钱就开始，在OCI的计算机上安装本地笔记本服务器，然后安装TensorFlow！如果你遇到了麻烦，你可以随时给我发信息(我总是很感激信息和问题)，我会尽我所能帮助你。</p><p id="9115" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列的后续文章中，我们将测量两个库的性能，并在分析数据集时关注两个库的性能/吞吐量分析！会很有见地的，我保证。</p><p id="2fa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">敬请期待！</p><h1 id="224b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">我如何开始学习OCI？</h1><p id="cc9f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">请记住，你可以随时免费注册OCI！您的Oracle Cloud帐户提供多项始终免费的服务和300美元免费积分的免费试用，可用于所有符合条件的OCI服务，最长30天。这些永远免费的服务在<strong class="ig hi">无限期</strong>内有效。免费试用服务可能会一直使用到您的300美元免费点数用完或30天到期，以先到者为准。你可以<a class="ae kf" href="https://signup.cloud.oracle.com/?language=en&amp;sourceType=:ow:de:te::::&amp;intcmp=:ow:de:te::::" rel="noopener ugc nofollow" target="_blank">在这里免费注册</a>。</p><h1 id="ec5b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">加入对话！</h1><p id="41e1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如果你对Oracle开发人员在他们的自然环境中发生的事情感到好奇，请加入我们的公共休闲频道！我们不介意成为你的鱼缸🐠</p><h1 id="f896" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">许可证</h1><p id="0f87" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">由<a class="ae kf" href="https://www.linkedin.com/in/ignacio-g-martinez/" rel="noopener ugc nofollow" target="_blank">伊格纳西奥·吉尔勒莫·马丁内兹</a><a class="ae kf" href="https://github.com/jasperan" rel="noopener ugc nofollow" target="_blank">@贾斯珀兰</a>撰写，由<a class="ae kf" href="https://www.linkedin.com/in/dawsontech/" rel="noopener ugc nofollow" target="_blank">艾琳·道森</a>编辑</p><p id="30b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">版权所有2021 Oracle和/或其附属公司。</p><p id="315f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据通用许可许可证(UPL)1.0版进行许可。</p><p id="689d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">详见<a class="ae kf" href="https://github.com/oracle-devrel/leagueoflegends-optimizer/blob/main/LICENSE" rel="noopener ugc nofollow" target="_blank">许可证</a>。</p></div></div>    
</body>
</html>