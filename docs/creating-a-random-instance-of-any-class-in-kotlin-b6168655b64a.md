# 在 Kotlin 中创建任意类的随机实例

> 原文：<https://blog.kotlin-academy.com/creating-a-random-instance-of-any-class-in-kotlin-b6168655b64a?source=collection_archive---------1----------------------->

![](img/8e545e98243e64473148c319e5799a2d.png)

在我们上一次[kot Lin 出现的时候，](/advent-of-kotlin-week-4-mocking-cde699ec9963)有一个特别棘手的时刻，我们必须为测试目的创建任何类的实例。这不是一项容易的任务。不同的类以不同的方式创建。它们可能有需要其他对象的构造函数。让我们看看如何创建一个随机类——一个使用 random 构造函数创建的实例，我们向它传递随机数据。

我们将以 TDD 的方式(测试驱动开发)一步一步来做。

在我们开始之前，本文需要一些关于 Kotlin 的经验。如果你是这个世界的新成员，这可能会很难。如果你想学习科特林，你可以加入我们的[工作坊](https://kt.academy)。

[![](img/d6ba3dcb5a3de1b3ff65f2512976b60b.png)](https://www.kt.academy/workshop/refactoringToCleanCode)

## 步骤 1:具有空构造函数的类

具有空构造函数的类是最简单的情况，因为我们需要做的就是使用这个构造函数。我们期望的是，当一个类的构造函数中没有任何参数时，我们可以使用我们的函数来创建它:

如你所见，`makeRandomInstance`需要知道`A`的类型。为了不删除它，我们需要具体化这个[类型参数](/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929):

然后我们可以使用`T::**class**`引用类。在 JVM 中，从空构造函数创建实例很容易。我们可以只使用`newInstance`:

这种方法有效，但是只在 JVM 上有效。为了实现通用，我们需要使用 Kotlin 反射:

这段代码中发生的事情是，我们首先引用类(`T::class`)，然后获取包含该类提供的所有构造函数的`constructors`属性。从这些构造函数中，我们取一个没有参数的。最后，我们调用这个构造函数，这样我们就创建了一个`T`的实例。

## 第二步:更多参数

当我们拥有更多参数时，一切都会变得更具挑战性:

此外，如果没有构造函数，我们将抛出一个错误。

要解决它，我们先从找到一个参数个数最少的构造函数并使用它开始。然后，为了创建每个参数，我们将循环使用`makeRandomInstance`。尽管要使用它，我们需要传递参数类型。为了找到它，我们可以检查在这个构造函数中声明为参数的内容。我们接受一个参数，询问它的类型，然后接受它的分类器。如果这不是一个泛型类型，那么它将是我们可以递归使用的`KClass`的一个实例，因为它与`T::class`相同。我们将在后面讨论处理泛型类型。现在，我们需要提取一个单独的函数，并向其传递一个类型:

这对我们有用，但是如果某个构造函数不能用，而另一个可以用呢？

最简单的答案是，我们应该迭代地寻找一个我们可以使用的构造函数:

最后，我们不在乎使用哪一个，因为我们需要一个随机的实例。稍后，我们还将随机化我们尝试构造函数的顺序。

[![](img/3860f92ecd05def9ec2568695cfc2895.png)](https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4)

## 第三步:原语

![](img/09c791664c291feb5b7dedb1f710b8d2.png)

有些类型不是通过构造函数创建的，也不受函数支持。原始人！为了简化，我只包括了最重要的:

我们需要单独的方法来创建它们。我们可以使用`Random`创建随机实例:

它也适用于通过构造函数传递原语的类:

# 停止

这是我想阻止你们大多数人的一点。我们的实现已经支持大多数类型，这应该会让您有所了解。在这之后，我们需要进入泛型的世界，事情变得更加糟糕。我们需要开始使用黑客和特定于平台的反射。这是因为泛型在 JVM 中是有问题的。它们是在 Java 5 (J2SE 5.0)中引入的，并不真正存在于 JVM 字节码中。所以 Java 中的泛型类型在编译时会被删除。有一些小技巧可以参考，但并不美，也不完美。这就是为什么我鼓励你在理解了随机类创建背后的逻辑之后，停止在这个令人满意的解决方案上。如果你愿意留下来，让我们深入泛型。

# 步骤 4:标准接口

有许多我们操作的接口，甚至不知道在引擎盖下是什么类。比如说`List`或者`Map`。我们使用`listOf`或`mapOf`创建它们，我们不需要知道它真正返回什么，只要它是`List`或`Map`的实例。因为它们经常被使用，所以我们也需要支持这些接口:

我们还应该支持需要这些集合作为构造函数参数的类:

如果你想知道为什么`B`在类外被声明，那是因为[这个错误](https://youtrack.jetbrains.net/issue/KT-29029)。

假设我们不想要空集合。我们希望他们有一些价值观。有一个问题。标准集合是泛型类型。为了填充它们，我们需要生成关联到它们的[类型参数](https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929)的实例。为此，我们需要知道那些[类型的参数](https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929)！但是类型在 JVM 中被删除了。诀窍是采用类型引用。它本身不受支持，但 Alexander Udalov 实现了一个解决方案。以下是`getKType`功能的链接:

> [链接到 getKType 实现](https://gist.github.com/udalov/bb6f398c2e643ee69586356fdd67e9b1)

有了这些，我们就可以引用类型，然后用它来获取类型或参数。

限制是这个函数不支持可空类型，所以我们根本不会产生空值。

当然，这种类型现在只用于集合。这就是我们如何添加对创建大小从 0 到 10 的随机集合的支持:

注意，当我们创建列表或映射时，我们使用`KType`来获取泛型类型，然后递归地创建实例。

[![](img/3146970f03e44cb07afe660b0d43e045.png)](https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&id=d2ba84960a)

## 步骤 5:泛型类型

让我们也开始支持泛型类型:

问题在于，当构造函数参数是泛型类型时，它不是具体的类，而是类型参数:

```
class A<T>(t: T)
```

这就是为什么当我们取它的分类器时，它不是一个`KClass`，而是一个`KTypeParameter`。因此，在前面的实现中，我们将在以下方面出错:

```
paramType.**classifier as** KClass<*>
```

相反，我们需要添加对`KTypeParameter`的支持。类型参数没有任何关于传递的类型参数的信息。它试图告诉我们传递给`A`的是什么类型，只知道`A`是如何定义的。在哪里可以找到这些信息？一般类型的！问题是在类类型中，你知道例如`A<String>`中的类型参数是`String`，但是我们不知道与这个类型参数关联的类型参数的名称是什么。这就是为什么我们也需要一个通用的类引用。使用这 3 个，我们可以使用类型参数引用来获得一个名称，使用这个名称和类引用来告诉我们要从哪个位置获取类型实参，最后使用这个位置获取具体的类型实参，并使用这个实参类型:

## 步骤 6:随机化、配置和抛光

让我们努力使这些实例更加随机。尽管这意味着什么？是否意味着一个随机列表应该有一个从 0 到`Int.**MAX_VALUE**`的随机长度？我们生产的绳子的长度应该是多少？这些问题没有明确的答案。让我们让用户通过配置一些属性来决定。我们将让用户配置应该使用的长度和对象(如果需要的话):

测试:

我们还应该让用户设置具体的`Random`。多亏了它，我们才能做这样的测试:

为了不将这个随机和配置作为参数传递，我决定将所有助手函数包装到一个类中。这是最终的实现和测试:

它可能支持更原始的类型或集合。它可能支持数组。更多的东西可以配置。虽然这些都是细节。此时，您应该完全知道如何添加所有这些元素。您还应该对 Kotlin 反射有更多的了解。它既不容易也不高效，但是正如你所看到的，最终，我们可以用它做几乎任何事情。

# 关于研讨会的思考

在 [Kt。学院](http://kt.academy/)我们在全球范围内举办 Kotlin 研讨会。反射的基础知识包含在关于 pure Kotlin 的标准研讨会或后端开发人员的 [Kotlin 中。如果你已经在你的公司使用了反射，请告诉我，我们可以在 Kotlin 反射中讨论逻辑和类。](http://kt.academy/Kotlin_in_Backend.html)

## 单击👏说“谢谢！”并帮助他人找到这篇文章。

了解卡帕头最新的重大新闻。学院，[订阅时事通讯](https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&id=d2ba84960a)，[观察推特](https://twitter.com/ktdotacademy)并在媒体上关注我们。