<html>
<head>
<title>LiveData with Coroutines and Flow — Part I: Reactive UIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有协程和流的LiveData第一部分:反应式用户界面</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-i-reactive-uis-b20f676d25d7?source=collection_archive---------2-----------------------#2020-07-13">https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-i-reactive-uis-b20f676d25d7?source=collection_archive---------2-----------------------#2020-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/948170b74bfd574483cc861a75a26f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhMDChty1gzkEUQxhc4hWw.jpeg"/></div></div></figure><div class=""/><p id="44cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是我在2019年Android Dev峰会上与Yigit Boyar的谈话摘要。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">LiveData with Coroutines and Flow (ADS 2019)</figcaption></figure><p id="d307" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一部分:反应式用户界面</p><p id="3132" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/337909f37ae7">第二部分:使用架构组件启动协程</a></p><p id="c6ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/592485a4a85a">第三部分:LiveData和协程模式</a></p></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><h1 id="56b0" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第一部分:反应式用户界面</h1><p id="f69a" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">自Android早期以来，我们很快就了解到<a class="ae jx" rel="noopener" href="/androiddevelopers/the-android-lifecycle-cheat-sheet-part-i-single-activities-e49fd3d202ab"> Android生命周期</a>很难理解，充满了边缘案例，保持理智的最佳方式是尽可能避免它们。</p><p id="a606" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们<a class="ae jx" href="https://developer.android.com/jetpack/docs/guide#recommended-app-arch" rel="noopener ugc nofollow" target="_blank">推荐</a>一个分层架构，这样我们就可以编写独立于UI的代码，而不用过多考虑生命周期。例如，我们可以添加一个包含业务逻辑(你的应用程序实际上做什么)的域层和一个数据层。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es li"><img src="../Images/79a262875b85b67ce871713f03dfe79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w4jqeDpraxI8q8jf"/></div></div></figure><p id="e616" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，我们了解到表示层可以划分为不同的组件，承担不同的职责:</p><ul class=""><li id="7aba" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated"><strong class="ir ht">视图</strong> —处理生命周期回调、用户事件和导航的活动或片段，以及</li><li id="b7fe" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">一个<strong class="ir ht">展示者</strong>或一个<strong class="ir ht">视图模型</strong>——向视图提供数据，而<em class="lx">大部分</em>不知道视图中正在进行的生命周期聚会。这意味着在重新创建视图时没有中断，也不需要清理。</li></ul><p id="e059" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">抛开命名不谈，有两种机制可以将数据从ViewModel/Presenter发送到视图:</p><ul class=""><li id="3964" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">引用视图并直接调用它。通常与主持人的工作方式有关。</li><li id="ccbd" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">向观察者展示可观察的数据。通常与视图模型的工作方式有关。</li></ul><p id="e15e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个在Android社区中建立得相当好的惯例，但是你会发现不同意的文章。有数百篇博客文章以不同的方式定义了演讲者、视图模型、MVP和MVVM。我建议你关注你的表示层的特性，并且使用<a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank"> Android架构组件视图模型</a>，它:</p><ul class=""><li id="c2a6" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">经受住配置变化，如旋转、区域设置变化、窗口大小调整、黑暗模式切换等。</li><li id="09f3" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">具有非常简单的生命周期。它有一个生命周期回调函数，<a class="ae jx" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel#onCleared()" rel="noopener ugc nofollow" target="_blank"> onCleared </a>，一旦它的生命周期所有者结束，这个函数就会被调用。</li></ul><p id="f1d4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ViewModel旨在使用观察者模式:</p><ul class=""><li id="5dd1" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">它不应该有对视图的引用。</li><li id="c167" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">它将数据暴露给观察者，而不知道这些观察者是什么。你可以用<a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">的LiveData </a>来做这个。</li></ul><p id="5525" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个视图(一个活动、片段或任何生命周期所有者)被创建时，视图模型被获取，并开始通过一个或多个视图订阅的LiveDatas公开数据。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/9499131642cf3c5a3dcc8d93372a2ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxOCm9Upaw8G2shQ"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">ViewModel exposing data through LiveData, observed by the View.</figcaption></figure><p id="6837" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该订阅可以通过<a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/livedata#observe_livedata_objects" rel="noopener ugc nofollow" target="_blank"> LiveData.observe </a>设置，也可以通过<a class="ae jx" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">数据绑定库</a>自动设置。</p><p id="9962" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果旋转设备，视图将被销毁(#1)，并创建一个新实例(#2):</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/98027f75adf019ff7467ed48637ba015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6-EsV9bFNWKcdqFk"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx"><em class="lz">View #1 is destroyed, so it stops observing automatically. View #2 starts observing.</em></figcaption></figure><p id="42d0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们在ViewModel中有一个对活动的引用，我们需要确保:</p><ul class=""><li id="0f5a" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">当视图被破坏时清除它</li><li id="a37a" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">如果视图处于过渡状态，请避免访问。</li></ul><p id="3edc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是有了ViewModel+LiveData，我们就再也不用处理这个问题了。这就是为什么我们在<a class="ae jx" href="https://developer.android.com/jetpack/docs/guide" rel="noopener ugc nofollow" target="_blank">应用架构指南</a>中推荐这种方法。</p><h1 id="c22d" class="kf kg hs bd kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky me la lb lc bi translated">领域</h1><p id="7791" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">由于活动和片段的生命周期等于或短于视图模型，我们可以开始讨论<strong class="ir ht">操作范围</strong>。</p><p id="c618" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<em class="lx">操作</em>是你需要在你的应用中做的任何事情，比如从网络上获取数据，过滤结果或者计算一些文本的排列。</p><p id="dba2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于您创建的任何操作，您都需要考虑它的范围:从启动到取消之间的时间长度。让我们看两个例子:</p><ul class=""><li id="bb94" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">您在活动的<code class="du mf mg mh mi b">onStart</code>中开始一项操作，并在<code class="du mf mg mh mi b">onStop</code>中停止它。</li><li id="6cc3" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">你在视图模型的<code class="du mf mg mh mi b">init</code>块中开始一个操作，然后在<code class="du mf mg mh mi b">onCleared()</code>中停止它。</li></ul><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/da36e03c52ec9a5d6b88c01648362dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qx1RqGEImofWqU0X2tr8A.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Activity lifecycle on rotation and finish vs ViewModel lifecycle</figcaption></figure><p id="1073" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看图表，我们可以找到每个操作有意义的地方。</p><ul class=""><li id="fc46" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated"><strong class="ir ht">在活动范围内的操作中获取数据</strong>将迫使我们在轮换后再次获取数据，因此应该改为在视图模型范围内获取数据。</li><li id="2d07" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated"><strong class="ir ht">排列文本</strong>在ViewModel范围内的操作中没有意义，因为在旋转之后，你的文本容器可能已经改变了形状。</li></ul><p id="edae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">显然，真实世界的应用程序可以有比这些更多的范围。例如，在Android Dev Summit应用中，我们可以使用:</p><ul class=""><li id="10cf" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">片段范围，每个屏幕多个</li><li id="e801" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">片段视图模型范围，每个屏幕一个</li><li id="9260" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">主要活动范围</li><li id="173f" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">主活动视图模型范围</li><li id="888a" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">适用范围</li></ul><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/9edf60913b1a0c80d5614f1943a348b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IVAP6OfXdapFmzPf1s3Yg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Schedule screen, Info screen, MainActivity</figcaption></figure><p id="0d0b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这会产生十几个不同的作用域，因此管理所有的作用域会变得非常困难。我们需要一种方法来构建这种并发性！</p><p id="84ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个非常方便的解决方案是<strong class="ir ht"> Kotlin协程</strong>。</p><p id="c51a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们喜欢在Android中使用协程有很多原因。其中一些是:</p><ul class=""><li id="4d35" class="lj lk hs ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated"><strong class="ir ht">很容易脱离主线</strong>。Android应用程序不断地在线程间切换以实现平滑的UX，协程让这变得超级简单。</li><li id="0bd7" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated"><strong class="ir ht">有最少的样板文件</strong>。协程被嵌入到语言中，所以使用像挂起函数这样的东西是轻而易举的。</li><li id="255e" class="lj lk hs ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated"><strong class="ir ht">结构化并发</strong>。这意味着您被迫定义您的操作的范围，并且您可以享受一些去除大量样板文件的保证，例如清理代码。把结构化并发想象成“自动取消”。</li></ul><p id="d17f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想了解协程，可以查看Android的<a class="ae jx" href="https://developer.android.com/kotlin/coroutines" rel="noopener ugc nofollow" target="_blank">介绍</a>和Kotlin的<a class="ae jx" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><p id="85eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续<a class="ae jx" rel="noopener" href="/p/337909f37ae7">第二部分:使用架构组件启动协程</a></p></div></div>    
</body>
</html>