<html>
<head>
<title>Room auto-migrations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间自动迁移</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-auto-migrations-d5370b0ca6eb?source=collection_archive---------0-----------------------#2021-04-21">https://medium.com/androiddevelopers/room-auto-migrations-d5370b0ca6eb?source=collection_archive---------0-----------------------#2021-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/bf10264d38ec2d8074c31f1abd230fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tGVzCBFAiGJ1gv_NLia_Q.png"/></div></div></figure><div class=""/><p id="3d05" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">轻松在房间间移动桌子</em></p><p id="0327" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在版本<code class="du jo jp jq jr b">2.4.0-alpha01</code>中引入的自动迁移的帮助下，使用Room实现数据库迁移变得更加容易。到目前为止，每当您的数据库模式发生变化时，您都必须实现一个<code class="du jo jp jq jr b">Migration</code>类，并告诉Room到底发生了什么变化。在大多数情况下，这涉及到编写和执行复杂的SQL查询。</p><p id="78b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在有了自动迁移功能，您可以指定要从哪个版本迁移到哪个版本。Room可以自动生成简单情况下的迁移，如添加、删除列或新表。对于更模糊的场景，Room将需要一些帮助。您将能够提供具体的规范—比如重命名或删除的列或表—基于此，Room将为您生成并运行迁移。让我们来看看一些例子，看看这是什么样子！</p><h1 id="d0d9" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">将自动设备置于自动迁移模式</h1><p id="718f" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">假设我们正在向一个表中添加一个新列，从数据库的版本1升级到版本2。我们必须通过增加版本号并添加从版本1到版本2的自动迁移来更新@Database注释:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="fad8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当您的数据库版本再次更改时，只需更新自动迁移列表，添加新的版本:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="d439" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于在<code class="du jo jp jq jr b">@Database</code>中声明的实体，模式更改(如添加新的列或表、更新主键、外键或索引或更改列的默认值等)由Room自动检测，不需要任何其他输入。</p><p id="7b61" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">⚠️Note:在引擎盖下，房间自动迁移依赖于生成的数据库模式，所以确保在使用<code class="du jo jp jq jr b">autoMigrations</code>时<code class="du jo jp jq jr b">@Database</code>中的<code class="du jo jp jq jr b">exportSchema</code>选项是<code class="du jo jp jq jr b">true</code>。否则导致错误:<code class="du jo jp jq jr b">Cannot create auto-migrations when export schema is OFF</code>。</p><h1 id="a5fb" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">当自动迁移需要一些帮助时</h1><p id="88f3" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">房间自动迁移不能检测数据库上执行的所有可能的更改，所以有时他们需要一些帮助。一个常见的例子是，Room不能检测表或列是否被重命名或删除。当这种情况发生时，Room将抛出一个编译时错误，要求您实现AutoMigrationSpec。这个类允许你指定你所做的改变的类型。实现AutoMigrationSpec，并用以下一项或多项对其进行注释:</p><ul class=""><li id="91aa" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated"><code class="du jo jp jq jr b">@DeleteTable(tableName)</code></li><li id="2c6c" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><code class="du jo jp jq jr b">@RenameTable(fromTableName, toTableName)</code></li><li id="0592" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><code class="du jo jp jq jr b">@DeleteColumn(tableName, columnName)</code></li><li id="59bd" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><code class="du jo jp jq jr b">@RenameColumn(tableName, fromColumnName, toColumnName)</code></li></ul><p id="010f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，假设我们将表<code class="du jo jp jq jr b">Doggos</code>重命名为<code class="du jo jp jq jr b">GoodDoggos</code>。Room无法检测这是否是一个全新的表并且我们删除了<code class="du jo jp jq jr b">Doggos</code>表，或者该表被重命名并且所有的值都需要保留。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="8e19" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">迁移与自动迁移</h1><h2 id="7514" class="lp jt hs bd ju lq lr ls jy lt lu lv kc ja lw lx kg je ly lz kk ji ma mb ko mc bi translated">何时使用迁移</h2><p id="b9f5" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">为了<a class="ae md" href="https://developer.android.com/training/data-storage/room/migrating-db-versions" rel="noopener ugc nofollow" target="_blank">手动处理迁移</a>，从版本1.0开始，Room提供了<code class="du jo jp jq jr b"><a class="ae md" href="https://developer.android.com/reference/kotlin/androidx/room/migration/Migration" rel="noopener ugc nofollow" target="_blank">Migration</a></code>类。每当您要进行复杂的数据库模式更改时，就必须使用这个类。例如，假设我们决定将一个表拆分成两个不同的表。Room无法检测这种拆分是如何执行的，也无法自动检测要移动哪些数据。所以这就是你必须实现一个<code class="du jo jp jq jr b">Migration</code>类并通过<code class="du jo jp jq jr b">addMigrations()</code>方法将其添加到<code class="du jo jp jq jr b">databaseBuilder()</code>的时候:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="ebf0" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结合迁移和自动迁移</h1><p id="7455" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">Room允许将迁移与自动迁移结合起来。例如，可以使用<code class="du jo jp jq jr b">Migration</code>从版本1迁移到版本2，使用自动迁移等从版本2迁移到版本3。如果您为同一个版本定义了一个<code class="du jo jp jq jr b">Migration</code>和一个自动迁移，那么<code class="du jo jp jq jr b">Migration</code>将会运行。</p><p id="2d2b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在幕后，自动迁移构造了一个<code class="du jo jp jq jr b">Migration</code>类，所以在这里详细描述的相同迁移逻辑仍然适用。TL；DR:当第一次访问数据库时，Room检查当前数据库版本是否与<code class="du jo jp jq jr b">@Database</code>中的版本不同。如果是，则Room寻找从一个到另一个的迁移路径。然后，迁移会连续运行。</p><h1 id="721f" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试自动迁移</h1><p id="4688" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">为了测试自动迁移，您可以使用<code class="du jo jp jq jr b">MigrationTestHelper</code>测试规则并调用<code class="du jo jp jq jr b">helper.runMigrationsAndValidate()</code>，就像使用迁移类一样。在我们的<a class="ae md" href="https://developer.android.com/training/data-storage/room/migrating-db-versions#single-migration-test" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多关于测试迁移的信息。</p><h1 id="aba5" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="05c7" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">自动迁移特性允许您通过使用<code class="du jo jp jq jr b">@Database</code>中的<code class="du jo jp jq jr b">autoMigration</code>参数来轻松处理数据库模式变更。虽然许多基本情况可以由Room处理，但是对于表/列的删除或重命名，您必须实现一个<code class="du jo jp jq jr b">AutoMigrationSpec</code>。对于所有其他情况，继续使用<code class="du jo jp jq jr b">Migrations</code>。</p><p id="ece0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个功能目前在<strong class="ir ht"> alpha </strong>中。通过对我们的<a class="ae md" href="https://issuetracker.google.com/issues/new?component=413107&amp;template=1096568" rel="noopener ugc nofollow" target="_blank">问题跟踪</a>提供反馈，帮助我们做得更好。</p></div></div>    
</body>
</html>