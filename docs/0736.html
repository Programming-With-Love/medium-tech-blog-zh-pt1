<html>
<head>
<title>Brushing up on Compose Text coloring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">温习撰写文本颜色</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/brushing-up-on-compose-text-coloring-84d7d70dd8fa?source=collection_archive---------3-----------------------#2022-07-25">https://medium.com/androiddevelopers/brushing-up-on-compose-text-coloring-84d7d70dd8fa?source=collection_archive---------3-----------------------#2022-07-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/436f9185c86215040a233f0ae0e15a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZK1BRIYM22iLQhexPGT1Q.png"/></div></div></figure><div class=""/><p id="bd53" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您的设计师要求您实现下面的草图:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es jn"><img src="../Images/332f49b43a671071fbd11157cfdf4dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Ckj00-vVWVbSRPcD0U-5BA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Screen design with a main <code class="du jw jx jy jz b">Text</code> and a <code class="du jw jx jy jz b">Button</code></figcaption></figure><p id="cff3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Jetpack Compose中构建这个屏幕应该很简单，除了<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#Text(kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Function1,androidx.compose.ui.text.TextStyle)" rel="noopener ugc nofollow" target="_blank">Text</a></code>的渐变颜色。</p><p id="3c6f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们探索一下在<a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/compose-ui#version_12_2" rel="noopener ugc nofollow" target="_blank">版本1.2.0 </a>之前，您可以用来在Compose中实现渐变的一些通用策略。</p><p id="4fd0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一种方法是使用Compose的<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#Canvas(android.graphics.Canvas)" rel="noopener ugc nofollow" target="_blank">Canvas</a></code>，直接在原生的<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/android/graphics/Canvas" rel="noopener ugc nofollow" target="_blank">android.graphics.Canvas</a></code>上绘图:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="58a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个更符合写作习惯的方法是在文本上使用<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier).drawWithCache(kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">drawWithCache</a></code>修饰符，以及一个<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">Brush</a></code>:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es kd"><img src="../Images/79e99b51c2b6811113727277c09959c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*kvm984G9xNQjChOx"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="ke">Text with gradient painted using Compose modifiers</em></figcaption></figure><p id="d5c6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的策略是在文本上绘制一个带有渐变颜色的矩形，然后使用<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/BlendMode#SrcAtop()" rel="noopener ugc nofollow" target="_blank">SrcAtop</a></code>混合它，以确保只有文本可见，矩形的其余部分被剪切。然而，这种方法利用了表情符号(如上所示)和<a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/InlineTextContent" rel="noopener ugc nofollow" target="_blank">内嵌内容</a>。</p><p id="ac10" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这两种解决方案都需要对绘图API、<code class="du jw jx jy jz b">Canvas</code>和<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/android/graphics/Paint" rel="noopener ugc nofollow" target="_blank">Paint</a></code>有更深入的了解。从<a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/compose-ui#version_12_2" rel="noopener ugc nofollow" target="_blank"> Compose 1.2.0 </a>开始，我们有了一个更好的解决方案！</p><h1 id="fd5c" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">画笔API</h1><p id="2e72" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated"><a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/compose-ui#version_12_2" rel="noopener ugc nofollow" target="_blank"> Compose 1.2.0 </a>在<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/TextStyle" rel="noopener ugc nofollow" target="_blank">TextStyle</a></code>和<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/SpanStyle" rel="noopener ugc nofollow" target="_blank">SpanStyle</a></code>中增加了<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">Brush</a></code> API，提供了一种使用复杂颜色绘制文本的方式，渐变只是开始。</p><blockquote class="li lj lk"><p id="f47e" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">在<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/TextStyle" rel="noopener ugc nofollow" target="_blank">TextStyle</a></code>中<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">Brush</a></code>的所有用法都是实验性的，所以确保在必要的地方添加了<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/ExperimentalTextApi" rel="noopener ugc nofollow" target="_blank">ExperimentalTextApi</a></code>注释。</p></blockquote><p id="e193" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您将使用两个主要组件:</p><ul class=""><li id="424d" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Brush</strong></a></code>:提供对默认画笔的访问，其中大部分是<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/ShaderBrush" rel="noopener ugc nofollow" target="_blank">ShaderBrush</a></code>的实现(如<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/LinearGradient" rel="noopener ugc nofollow" target="_blank">LinearGradient</a></code>、<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/RadialGradient" rel="noopener ugc nofollow" target="_blank">RadialGradient</a></code>等)。</li><li id="0305" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/ShaderBrush" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">ShaderBrush</strong></a></code>:当默认画笔不够用时，你可以扩展这个类来实现你自己的自定义画笔。</li></ul><p id="9891" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了实现上面的设计，我们定义了渐变颜色列表，并在<code class="du jw jx jy jz b">TextStyle</code>上使用了<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush#linearGradient(kotlin.Array,androidx.compose.ui.geometry.Offset,androidx.compose.ui.geometry.Offset,androidx.compose.ui.graphics.TileMode)" rel="noopener ugc nofollow" target="_blank">linearGradient</a></code>笔刷。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es md"><img src="../Images/e4efe63df969286e0f9e5599abc4f728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*crXB18BB3Zb2i0OwOy9dvg.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="ke">Brush.linearGradient</em></figcaption></figure><p id="07df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！真的就这么简单。值得注意的是，使用这个解决方案，画笔不会绘制表情符号，因为它们被底层着色器跳过。</p><h1 id="81b3" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">默认画笔</h1><p id="a39a" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated"><code class="du jw jx jy jz b">Brush</code>在其API中提供了各种预定义的笔刷样式。我们已经使用了<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush#linearGradient(kotlin.Array,androidx.compose.ui.geometry.Offset,androidx.compose.ui.geometry.Offset,androidx.compose.ui.graphics.TileMode)" rel="noopener ugc nofollow" target="_blank">linearGradient</a></code>，并且您还有以下内容:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/8064e86923da57a6d2e2408cfc713cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xm14EjWKtu1vRLil"/></div></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mf"><img src="../Images/ecda0ce5c39fcaccc8def62d1cb9aca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OqWGAj--3jkyDoUV"/></div></div></figure><p id="3afd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另外<code class="du jw jx jy jz b">SolidColor</code>用单一给定颜色刷油漆:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es mg"><img src="../Images/9475941337edb6026cfa497c00e2438b.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*98nRONzOFKejf_Fp_kZN1A.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="ke">SolidColor(Cyan)</em></figcaption></figure><p id="4650" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看<code class="du jw jx jy jz b">Brush</code> <a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">文档</a>获取完整的API描述。</p><h1 id="e215" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">自定义画笔</h1><p id="5dc7" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">在某些情况下，你可能需要确切地知道画笔的大小或绘制区域，并使用它来执行一些计算——比如减小画笔的大小以实现特定的平铺效果。下面，看看我们如何使用自定义笔刷来实现这一点。</p><h2 id="5b9c" class="mh kg hs bd kh mi mj mk kl ml mm mn kp ja mo mp kt je mq mr kx ji ms mt lb mu bi translated">重复颜色模式</h2><p id="835b" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">想象一下，我们想要实现某种颜色模式重复三次。一个简单的方法是将笔刷大小减少到绘图区域的三分之一，然后重复这个过程。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es mv"><img src="../Images/c8a54bff3a4c2d07b4588c5bfa4ab5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*wSIJiaB-bo_O-lIqhgkd4g.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Design we want to implement with a repeated pattern</figcaption></figure><p id="75dc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要访问画笔大小，你可以通过扩展抽象类<code class="du jw jx jy jz b">ShaderBrush</code>和覆盖<code class="du jw jx jy jz b">createShader()</code>方法来创建自己的<code class="du jw jx jy jz b">Brush</code>。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="d281" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode" rel="noopener ugc nofollow" target="_blank">tileMode</a></code>参数给出的策略重复梯度模式。</p><p id="c242" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jw jx jy jz b">tileMode</code>参数决定着色器如何填充其边界之外的区域的行为。由于重复的计算方式，在以下情况下可以更清楚地看到效果:</p><ul class=""><li id="be81" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated">你的画笔被迫小于文本布局(就像这样)。</li><li id="afce" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">您的绘图坐标小于可用的绘图区域。</li><li id="0964" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">使用径向渐变画笔。</li></ul><p id="6634" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用以下平铺模式:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mw"><img src="../Images/e9e91feeff96d5fd039ce5c160b1d1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jMhlE8hNitVhbX44"/></div></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mx"><img src="../Images/583d1e609b68c6e764c1c2c7214c35f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BD6CziIX4pFiy6Si"/></div></div></figure><ul class=""><li id="c4c9" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Repeated()" rel="noopener ugc nofollow" target="_blank">repeated</a></code>(刚刚在上面使用)在边缘重新开始颜色，重复该序列。</li><li id="1cc2" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Mirror()" rel="noopener ugc nofollow" target="_blank">mirror</a></code>从最后到第一个镜像图案边缘的颜色。</li><li id="d211" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Clamp()" rel="noopener ugc nofollow" target="_blank">clamp</a></code>将通过绘制渐变边缘的颜色来完成绘图区域:</li><li id="9051" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Decal()" rel="noopener ugc nofollow" target="_blank">decal</a></code>启动Android S (API 31)及以上版本支持，它绘制笔刷大小给定的图案，并用黑色完成其余的绘制区域。你可以通过使用<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#(androidx.compose.ui.graphics.TileMode).isSupported()" rel="noopener ugc nofollow" target="_blank">isSupported</a></code>方法来检查这个<code class="du jw jx jy jz b">tileMode</code>是否被支持。如果不是，它将退回到<code class="du jw jx jy jz b">tileMode</code> <code class="du jw jx jy jz b">clamp</code>。</li></ul><h2 id="266f" class="mh kg hs bd kh mi mj mk kl ml mm mn kp ja mo mp kt je mq mr kx ji ms mt lb mu bi translated">作为文本颜色的图像模式</h2><p id="186e" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">假设我们需要使用图像的颜色作为文本颜色。例如，使用Jetpack Compose徽标，我们希望得到以下结果:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es my"><img src="../Images/ad4f456f2a945e679a694b5b410ecb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*2XKbCkkNUbAXWtLPc4N3rA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Text with colors defined by a Bitmap</figcaption></figure><p id="48cf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了实现这一点，我们使用一个方法来创建一个<code class="du jw jx jy jz b">ShaderBrush</code>，传入一个本机<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/android/graphics/BitmapShader" rel="noopener ugc nofollow" target="_blank">BitmapShader</a></code>并设置我们想要使用的<code class="du jw jx jy jz b">Bitmap</code>。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="e28e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用remember函数来跨重新组合保存<code class="du jw jx jy jz b">ShaderBrush</code>,因为创建一个着色器可能会很昂贵，并且每次调用ShaderBrush都会导致BitmapShader的新分配。</p><h1 id="dc77" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">笔刷集成</h1><p id="38cc" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">刷子可与接受造型组件<code class="du jw jx jy jz b">TextStyle</code>和<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString" rel="noopener ugc nofollow" target="_blank">AnnotatedString</a></code>的所有元件一起使用。</p><p id="795d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，您可以为您的<code class="du jw jx jy jz b"><a class="ae ka" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors)" rel="noopener ugc nofollow" target="_blank">TextField</a></code>配置一个<code class="du jw jx jy jz b">Brush</code>样式:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es mz"><img src="../Images/227ee502fc70b7cefbc91fb7902369d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*zS1PHAdhe0kL-b12"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="ke">TextField value styled with Brush</em></figcaption></figure><p id="1b1f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当每个新输入的字符的状态发生变化时，确保使用<code class="du jw jx jy jz b">remember</code>函数在重新组合中保持画笔。</p><p id="9bd6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，一些性能优化是在幕后完成的。例如，将笔刷转换为着色器可能是一个昂贵的操作，但<code class="du jw jx jy jz b"><a class="ae ka" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui-text/src/androidMain/kotlin/androidx/compose/ui/text/platform/AndroidTextPaint.android.kt?q=AndroidTextPaint%20" rel="noopener ugc nofollow" target="_blank">AndroidTextPaint</a></code>优化了这一过程，使笔刷在合成之间不会改变(就像在这种情况下)。</p><p id="0eea" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要仅在文本或段落的选定部分添加渐变，您可以构建一个<code class="du jw jx jy jz b">AnnotatedString</code>并将<code class="du jw jx jy jz b">Brush</code>样式仅设置到文本的特定范围，如下所示:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es na"><img src="../Images/779d4659a81499a2b3f8947ac772c08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1f8Z37yB8NPjevqP"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx">Text with gradient built with brush in SpanStyle</figcaption></figure><h2 id="4458" class="mh kg hs bd kh mi mj mk kl ml mm mn kp ja mo mp kt je mq mr kx ji ms mt lb mu bi translated">使用画笔的不透明度</h2><p id="c290" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated"><a class="ae ka" href="https://developer.android.com/jetpack/androidx/releases/compose-ui#1.3.0-alpha01" rel="noopener ugc nofollow" target="_blank"> Compose版本1.3.0-alpha01 </a>为<code class="du jw jx jy jz b">TextStyle</code> / <code class="du jw jx jy jz b">SpanStyle</code>引入了一个alpha可选参数，它允许您在使用颜色渐变实现类似这样的东西时修改整个文本的不透明度:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es nb"><img src="../Images/72c2010b43c81b02a8263d22334ee660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*pAc7CcYPUrLQdsNi"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="ke">“Text in” has 0.5f alpha</em></figcaption></figure><p id="daf5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了实现这一点，我们将对文本的两个部分使用相同的笔刷，并且我们将改变文本在相应范围内的alpha。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="21b9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更多画笔和<code class="du jw jx jy jz b">TextStyle</code> / <code class="du jw jx jy jz b">SpanStyle</code>的例子，看一下AOSP的<code class="du jw jx jy jz b"><a class="ae ka" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/integration-tests/foundation-demos/src/main/java/androidx/compose/foundation/demos/text/BrushDemo.kt" rel="noopener ugc nofollow" target="_blank">BrushDemo</a></code>例子。</p><blockquote class="li lj lk"><p id="fb54" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">如果你想知道更多关于用画笔在Compose中可以实现什么的灵感，请查看由<a class="ae ka" href="http://twitter.com/halilozercan" rel="noopener ugc nofollow" target="_blank">Halil</a><a class="ae ka" href="http://twitter.com/halilozercan" rel="noopener ugc nofollow" target="_blank"/><a class="ae ka" href="http://twitter.com/halilozercan" rel="noopener ugc nofollow" target="_blank">zer can</a>制作的<a class="ae ka" href="https://twitter.com/halilozercan/status/1546563464025481216?t=Z26RiyXPvBE94xFRpUMU4g&amp;s=19" rel="noopener ugc nofollow" target="_blank">这个</a>演示(你可以在这里找到代码<a class="ae ka" href="https://github.com/halilozercan/madewithcompose/tree/main/app/src/main/java/com/halilibo/madewithcompose/brush" rel="noopener ugc nofollow" target="_blank">)。</a></p></blockquote><h1 id="6d72" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">概述</h1><p id="6885" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我们希望，通过拥有新的令人兴奋的、与您已经熟悉的API无缝集成的组合惯用API，将帮助您为您最有创意的用例创建漂亮的视觉效果。</p><p id="3a68" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您在使用<code class="du jw jx jy jz b">Brush</code> API时发现任何错误，请通过在<a class="ae ka" href="https://issuetracker.google.com/issues/new?component=779818&amp;template=1371638" rel="noopener ugc nofollow" target="_blank">我们的问题跟踪器</a>上提交错误来让我们知道。要了解更多关于Compose中的<code class="du jw jx jy jz b">Canvas</code>，你可以查看我们关于Compose 中的<a class="ae ka" href="https://developer.android.com/jetpack/compose/graphics" rel="noopener ugc nofollow" target="_blank">图形的文档。</a></p><p id="d276" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们迫不及待地想看看你和<code class="du jw jx jy jz b">Brush</code>一起建造了什么。在推特上给我加标签，这样我就可以看到你美丽的作品了！</p><p id="e440" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后但同样重要的是，如果你想学习如何用笔刷🖌️绘制颜色动画，请阅读这篇博文的第二部分。</p><p id="b45c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快乐作曲！👋</p><p id="8fc1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ll">这篇文章是与Jetpack撰写文本团队的</em><a class="ae ka" href="http://twitter.com/halilozercan" rel="noopener ugc nofollow" target="_blank"><em class="ll">Halil zercan</em></a><em class="ll">合作撰写的。感谢DevRel团队的</em> <a class="ae ka" href="https://twitter.com/riggaroo" rel="noopener ugc nofollow" target="_blank"> <em class="ll">丽贝卡·弗兰克斯</em></a><a class="ae ka" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"><em class="ll">弗洛里纳·芒特内斯库</em> </a> <em class="ll">和</em> <a class="ae ka" href="https://twitter.com/crafty" rel="noopener ugc nofollow" target="_blank"> <em class="ll">尼克·布彻</em> </a> <em class="ll">对他们的透彻点评。</em></p></div></div>    
</body>
</html>