<html>
<head>
<title>Connecting F1 2021 Telemetry with Oracle JET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将F1 2021遥测技术与Oracle JET连接</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/connecting-f1-2021-telemetry-with-oracle-jet-a73714768c34?source=collection_archive---------0-----------------------#2022-03-24">https://medium.com/oracledevs/connecting-f1-2021-telemetry-with-oracle-jet-a73714768c34?source=collection_archive---------0-----------------------#2022-03-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fb77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将讨论如何使用Codemasters开发的视频游戏F1 2021的遥测数据，并使用<a class="ae jc" href="https://oracle.com/jet" rel="noopener ugc nofollow" target="_blank"> Oracle JET </a>实时显示这些数据。</p><h1 id="9ce1" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">介绍</h1><p id="6937" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated"><a class="ae jc" href="https://oracle.com/jet" rel="noopener ugc nofollow" target="_blank">Oracle JET</a>(JavaScript Extension Toolkit)是由Oracle开发的一项技术，它作为命令的扩展，用于轻松开发移动应用程序和基于浏览器的用户界面。它面向从事客户端应用程序的JavaScript开发人员。通过将几个开源的JavaScript库与Oracle JavaScript库打包在一起，使得构建应用非常简单高效；此外，我们还拥有与其他Oracle产品和服务(尤其是Oracle云基础设施服务)更轻松交互的优势。</p><p id="f770" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从视频游戏中，我们能够使用游戏中的遥测功能提取遥测数据。这包括以下类型的数据包:</p><ul class=""><li id="0fb3" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">运动数据</li><li id="4ba6" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">会话数据</li><li id="f458" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">单圈数据</li><li id="af0c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">事件数据</li><li id="4bc7" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">参与者数据</li><li id="8794" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">汽车设置数据</li><li id="a8da" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">汽车遥测数据</li><li id="3a4f" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">汽车状态数据</li><li id="e83a" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">最终分类数据</li><li id="5118" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">大厅信息数据</li><li id="6b80" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">汽车损坏数据</li><li id="546a" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">会话历史数据</li></ul><p id="fa70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，我们能够获得这种信息:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="82ec" class="ld je hh kz b fi le lf l lg lh">class CarTelemetryData(Packet):<br/>    _fields_ = [<br/>        ("speed", ctypes.c_uint16),  # Speed of car in kilometres per hour<br/>        ("throttle", ctypes.c_float),  # Amount of throttle applied (0.0 to 1.0)<br/>        ("steer", ctypes.c_float),<br/>        # Steering (-1.0 (full lock left) to 1.0 (full lock right))<br/>        ("brake", ctypes.c_float),  # Amount of brake applied (0.0 to 1.0)<br/>        ("clutch", ctypes.c_uint8),  # Amount of clutch applied (0 to 100)<br/>        ("gear", ctypes.c_int8),  # Gear selected (1-8, N=0, R=-1)<br/>        ("engine_rpm", ctypes.c_uint16),  # Engine RPM<br/>        ("drs", ctypes.c_uint8),  # 0 = off, 1 = on<br/>        ("rev_lights_percent", ctypes.c_uint8),  # Rev lights indicator (percentage)<br/>        ("rev_lights_bit_value", ctypes.c_uint16),<br/>        # Rev lights (bit 0 = leftmost LED, bit 14 = rightmost LED)<br/>        ("brakes_temperature", ctypes.c_uint16 * 4),  # Brakes temperature (celsius)<br/>        ("tyre_surface_temperature", ctypes.c_uint8 * 4),<br/>        # tyre surface temperature (celsius)<br/>        ("tyre_inner_temperature", ctypes.c_uint8 * 4),<br/>        # tyre inner temperature (celsius)<br/>        ("engine_temperature", ctypes.c_uint16),  # Engine temperature (celsius)<br/>        ("tyre_pressure", ctypes.c_float * 4),  # tyre pressure (PSI)<br/>        ("surface_type", ctypes.c_uint8 * 4),  # Driving surface, see appendices<br/>    ]</span></pre><p id="33f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有数据包类型和定义以及所有变量定义都可以在<a class="ae jc" href="https://github.com/jasperan/f1-telemetry-oracle/blob/main/telemetry_f1_2021/cleaned_packets.py" rel="noopener ugc nofollow" target="_blank">文件</a>中访问。</p><h1 id="cbc7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">体系结构</h1><p id="40db" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在遥测技术中，数据包通常以有序的方式出现。然而，在某些情况下，由于我们无法控制的网络条件，这些数据包会延迟到达。为了防止意外的包重新排序，并保持数据的完整性，我们选择用消息队列来实现通信架构。</p><p id="6f1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">消息队列已经存在了几十年，是消费者和生产者之间异步通信的一种方式。它是操作系统(如基于UNIX的操作系统)内部进程间通信的先驱，并将其功能扩展到许多其他领域。由于这些原因，消息队列非常适合我们的叙述。</p><p id="3fdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">消息存储在队列中，直到被消费者处理/消费。一旦它们被消耗，它们就从队列中被消除。每条消息只被处理一次，并且只由一个消费者处理。如果有几个消费者，每个消费者将处理不同的消息。</p><p id="d4e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们架构的消息队列提供者是<a class="ae jc" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>，这是一个广为人知的完全开源的消息代理，能够集成上述所有功能。我已经创建了一个生产者(<a class="ae jc" href="https://mdpreviewer.github.io/telemetry_f1_2021/mq_producer.py" rel="noopener ugc nofollow" target="_blank"> mq_producer.py </a>)和一个数据/接收者的消费者(<a class="ae jc" href="https://mdpreviewer.github.io/telemetry_f1_2021/mq_receiver.py" rel="noopener ugc nofollow" target="_blank"> mq_receiver.py </a>)。生产者的目的是从F1 2021游戏中获取消息，并将它们添加到我们的消息队列中。作为补充，接收者将通过<strong class="ig hi"> web sockets </strong>使用队列中的消息，并将这些消息“注入”到我们的Oracle JET驱动的仪表板中，以便实时可视化游戏中实际发生的事情。</p><p id="cec0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是对建筑的描述:</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/fa021dab0dde6bfc3b50a41515e442ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mo-CYaQ43ssekL_x"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx">Architecture</figcaption></figure><h1 id="6a86" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">消息队列</h1><p id="626f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在这一节中，我们将解释我们用来实现消息代理架构的代码。</p><h1 id="c1a0" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">生产者</h1><p id="2e50" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们使用<a class="ae jc" href="https://github.com/jasperan/f1-telemetry-oracle" rel="noopener ugc nofollow" target="_blank">遥测_f1_2021监听器Python库</a>对游戏中的数据包进行编码/解码，这有助于我们以人类可读的格式读取这些数据包。</p><p id="2d8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们绑定端口20777来监听来自F1 2021游戏的UDP数据包。该端口可以更改；然而，游戏中的默认端口被配置为20777。如果你打算改变这一点，请确保改变游戏中的遥测设置。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7a0f" class="ld je hh kz b fi le lf l lg lh">from telemetry_f1_2021.packets import HEADER_FIELD_TO_PACKET_TYPE<br/>from telemetry_f1_2021.packets import PacketSessionData, PacketMotionData, PacketLapData, PacketEventData, PacketParticipantsData, PacketCarDamageData<br/>from telemetry_f1_2021.packets import PacketCarSetupData, PacketCarTelemetryData, PacketCarStatusData, PacketFinalClassificationData, PacketLobbyInfoData, PacketSessionHistoryData<br/>from telemetry_f1_2021.listener import TelemetryListener</span><span id="8096" class="ld je hh kz b fi lu lf l lg lh">cli_parser = argparse.ArgumentParser(<br/>    description="Script that records telemetry F1 2021 weather data into a RabbitMQ queue"<br/>)</span><span id="56b2" class="ld je hh kz b fi lu lf l lg lh">cli_parser.add_argument('-g', '--gamehost', type=str, help='Gamehost identifier (something unique)', required=True)<br/>args = cli_parser.parse_args()</span><span id="0d0f" class="ld je hh kz b fi lu lf l lg lh">def _get_listener():<br/>    try:<br/>        print('Starting listener on localhost:20777')<br/>        return TelemetryListener()<br/>    except OSError as exception:<br/>        print('Unable to setup connection: {}'.format(exception.args[1]))<br/>        print('Failed to open connector, stopping.')<br/>        exit(127)</span></pre><p id="8c47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过下面的代码，我们使用Pika Python客户端声明了一个阻塞连接。值得一提的是，RabbitMQ能够与多种协议进行通信。Pika是RabbitMQ团队推荐的Python客户端。它使用AMQP 0–9–1协议进行消息传递。我们指定主机作为我们测试的本地地址，因为我们在与消息队列生产者/接收者相同的计算机上运行F1 2021游戏。如果接收方在其他地方，请将主机更改为指向该IPv4地址。</p><p id="14f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还声明了一个队列名。在我们的例子中，因为它似乎与架构相关，我们对每种包类型使用一个队列，以区分它们。做出这个决定还有另一个重要原因:不是所有的包类型都有相同的频率。</p><p id="50b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，大多数数据包类型都是由F1 2021游戏以20Hz(每秒20次)的频率发出的，但也有一些例外。如果我们只是为所有的数据包类型包含相同的队列，我们会以不同的速度将不同类型的数据接收到相同的队列中(不理想)(不酷，会使可视化不正确，不是实时的，这正是我们所寻求的)。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c825" class="ld je hh kz b fi le lf l lg lh">def main():</span><span id="803e" class="ld je hh kz b fi lu lf l lg lh">connection = pika.BlockingConnection(<br/>    pika.ConnectionParameters(host='localhost', heartbeat=600, blocked_connection_timeout=300))<br/>    channel = connection.channel()</span><span id="938f" class="ld je hh kz b fi lu lf l lg lh">list_packet_types = ['PacketMotionData', 'PacketSessionData', 'PacketLapData', 'PacketEventData', 'PacketParticipantsData',<br/>        'PacketCarSetupData', 'PacketCarTelemetryData', 'PacketCarStatusData', 'PacketFinalClassificationData', 'PacketLobbyInfoData',<br/>        'PacketCarDamageData', 'PacketSessionHistoryData']</span><span id="5ca9" class="ld je hh kz b fi lu lf l lg lh"># declare all queues<br/>    for x in list_packet_types:<br/>        channel.queue_declare(queue='{}'.format(x))</span><span id="5629" class="ld je hh kz b fi lu lf l lg lh">listener = _get_listener()</span><span id="9655" class="ld je hh kz b fi lu lf l lg lh">try:<br/>        while True:<br/>            packet = listener.get()<br/>            if isinstance(packet, PacketSessionData):<br/>                save_packet('PacketSessionData', packet, channel)<br/>            elif isinstance(packet, PacketMotionData):<br/>                save_packet('PacketMotionData', packet, channel)<br/>            elif isinstance(packet, PacketLapData):<br/>                save_packet('PacketLapData', packet, channel)<br/>            elif isinstance(packet, PacketEventData):<br/>                save_packet('PacketEventData', packet, channel)<br/>            elif isinstance(packet, PacketParticipantsData):<br/>                save_packet('PacketParticipantsData', packet, channel)<br/>            elif isinstance(packet, PacketCarSetupData):<br/>                save_packet('PacketCarSetupData', packet, channel)<br/>            elif isinstance(packet, PacketCarTelemetryData):<br/>                save_packet('PacketCarTelemetryData', packet, channel)<br/>            elif isinstance(packet, PacketCarStatusData):<br/>                save_packet('PacketCarStatusData', packet, channel)<br/>            elif isinstance(packet, PacketFinalClassificationData):<br/>                save_packet('PacketFinalClassificationData', packet, channel)<br/>            elif isinstance(packet, PacketLobbyInfoData):<br/>                save_packet('PacketLobbyInfoData', packet, channel)<br/>            elif isinstance(packet, PacketCarDamageData):<br/>                save_packet('PacketCarDamageData', packet, channel)<br/>            elif isinstance(packet, PacketSessionHistoryData):<br/>                save_packet('PacketSessionHistoryData', packet, channel)</span><span id="3775" class="ld je hh kz b fi lu lf l lg lh">except KeyboardInterrupt:<br/>        print('Stop the car, stop the car Checo.')<br/>        print('Stop the car, stop at pit exit.')<br/>        print('Just pull over to the side.')<br/>        connection.close()</span></pre><p id="9086" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将save_packet函数声明为:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6db8" class="ld je hh kz b fi le lf l lg lh">def save_packet(collection_name, packet, channel):<br/>    dict_object = packet.to_dict()</span><span id="d199" class="ld je hh kz b fi lu lf l lg lh">channel.basic_publish(exchange='', routing_key=collection_name, body='{}'.format(dict_object))</span><span id="8426" class="ld je hh kz b fi lu lf l lg lh">print('{} | MQ {} OK'.format(datetime.datetime.now(), collection_name)) # simple debug</span></pre><p id="39fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，每次数据包进入这些队列时，它都会被插入到队列中。</p><h1 id="2082" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">消费者</h1><p id="2c3a" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在消费者端，我们从队列中读取消息，并将它们传输到Oracle JET仪表板。</p><p id="9c85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从Python代码的角度来看，我们可以创建这样一个脚本，它在开发过程中检查消息队列中的连接性问题时非常有用。我们可以运行它来查看消息是否从队列中弹出，以及所有网络配置是否正确:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f4a8" class="ld je hh kz b fi le lf l lg lh">def main():<br/>    connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', heartbeat=600, blocked_connection_timeout=300))<br/>    channel = connection.channel()</span><span id="f01f" class="ld je hh kz b fi lu lf l lg lh">list_packet_types = ['PacketMotionData', 'PacketSessionData', 'PacketLapData', 'PacketEventData', 'PacketParticipantsData',<br/>        'PacketCarSetupData', 'PacketCarTelemetryData', 'PacketCarStatusData', 'PacketFinalClassificationData', 'PacketLobbyInfoData',<br/>        'PacketCarDamageData', 'PacketSessionHistoryData']</span><span id="4fb4" class="ld je hh kz b fi lu lf l lg lh"># declare all queues, in case the receiver is initialized before the producer.<br/>    for x in list_packet_types:<br/>        channel.queue_declare(queue='{}'.format(x))</span><span id="398d" class="ld je hh kz b fi lu lf l lg lh"># this is the function that will be executed every time<br/>    def callback(ch, method, properties, body):<br/>        print(" [x] Received %r" % body.decode())</span><span id="85c8" class="ld je hh kz b fi lu lf l lg lh"># consume all queues<br/>    for x in list_packet_types:<br/>        channel.basic_consume(queue='{}'.format(x), on_message_callback=callback, auto_ack=True)</span><span id="8445" class="ld je hh kz b fi lu lf l lg lh">print(' [*] Waiting for messages. To exit press CTRL+C')<br/>    channel.start_consuming()</span></pre><h1 id="1561" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Web套接字</h1><p id="2faa" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在我们的例子中，Web套接字尤其重要，因为它们是我们选择的与前端(Oracle JET-powered网站)和消息队列进行通信的方式。</p><p id="63db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Web套接字是标准套接字(位于传输层)的一种实现。但是，它们通过应用层进行通信。正如我们从电信工程中所知，标准套接字位于传输层之上，这使得它们非常高效。另一方面，web套接字位于应用层之上，这意味着它们通过HTTP封装传输层中的套接字，这种封装还允许有更简单的编程接口:编程语法和技术比我们使用标准套接字编程要容易得多。大多数关于连接、心跳、异常等等的东西都被从等式中去掉，并在一个简单的API中呈现给我们。</p><p id="3af1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，web套接字的目的是将web前端与消息队列后端进行通信。当前端请求消息时，会从队列中使用/弹出消息，并向后端发送确认消息，以验证消息是否被正确接收。</p><p id="b006" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样重要的是要注意，虽然我们在使用web套接字时受益于更简单的API，但我们损失了一些性能。然而，在我们的例子中，在我们的架构中发送的KB/s的数量，差异是可以忽略的，它根本不影响我们前端的实时仪表板的性能。</p><p id="5271" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，总结一下:在我们的用例中，客户机将是JET中实现的前端，而服务器将是我们将数据插入RabbitMQ消息队列的遥测监听器。前端使用web套接字发出请求，并根据我们收到的内容更改显示值。</p><h1 id="7e3e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">WS服务器(后端)</h1><p id="c617" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在后端，我们将使用我们的消息队列，并将请求的信息发送给客户端:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a05b" class="ld je hh kz b fi le lf l lg lh"># this variable stores the most recent packet received from the queue<br/>global _CURRENT_PACKET<br/># Initialize message queue from where we're getting the data.<br/>connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', heartbeat=600, blocked_connection_timeout=300))<br/>channel = connection.channel()<br/># declare our queues<br/>channel.queue_declare(queue='PacketCarTelemetryData')<br/>channel.queue_declare(queue='PacketSessionData')</span><span id="ca93" class="ld je hh kz b fi lu lf l lg lh">cli_parser = argparse.ArgumentParser()<br/>cli_parser.add_argument('-g', '--gamehost', type=str, help='Gamehost identifier (something unique)', required=True)<br/>args = cli_parser.parse_args()</span><span id="a8df" class="ld je hh kz b fi lu lf l lg lh"># instead of having a random packet and randomizing, get from rabbitmq queue.<br/>def save_packet(collection_name):<br/>    print('{} | WS {} OK'.format(datetime.datetime.now(), collection_name))<br/>    channel.basic_qos(prefetch_count=1)<br/>    # consume queue<br/>    method, properties, body = channel.basic_get(queue=collection_name, auto_ack=True) # we get 1 packet exactly<br/>    del method, properties # we don't need these two values<br/>    try:<br/>        _CURRENT_PACKET = body.decode()<br/>        print(_CURRENT_PACKET)<br/>    except AttributeError as e: # in case there are no packets in the queue, we just create an empty packet for the front-end to interpret.<br/>        _CURRENT_PACKET = {}<br/>    print(_CURRENT_PACKET)<br/>    return json.dumps(_CURRENT_PACKET)</span><span id="521b" class="ld je hh kz b fi lu lf l lg lh"># this code is run every time a WS request comes in.<br/>async def handler(websocket):<br/>    while True:<br/>        message = await websocket.recv()</span><span id="21bb" class="ld je hh kz b fi lu lf l lg lh">if message == 'getPacketCarTelemetryData':<br/>            result = save_packet('PacketCarTelemetryData')<br/>        elif message == 'getPacketSessionData':<br/>            result = save_packet('PacketSessionData')</span><span id="4bda" class="ld je hh kz b fi lu lf l lg lh">await websocket.send(result)</span><span id="97d3" class="ld je hh kz b fi lu lf l lg lh">async def main(): # we declare this python script as a web socket server<br/>    async with websockets.serve(handler, "", 8001):<br/>        await asyncio.Future()  # run forever</span></pre><h1 id="3c5f" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">WS客户端(前端)</h1><p id="d4d1" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在前端，我们将定期向web socket服务器发出请求，并使用JavaScript更新要显示的值。这个功能的原始JavaScript代码可以在这个文件中的<a class="ae jc" href="https://github.com/peppertech/FormulaPi/blob/main/src/components/content/index.tsx" rel="noopener ugc nofollow" target="_blank">中找到。</a></p><p id="0653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开发过程中，开发了一个类似的代码来检查接收到的web套接字请求/响应。这段代码非常简单:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3506" class="ld je hh kz b fi le lf l lg lh"># Client simulator for web socket connection to a server located in the below mentioned IP address and port.<br/># This "client" will make constant requests (of 2 types, interchangeably), to test during development.</span><span id="dc7b" class="ld je hh kz b fi lu lf l lg lh">async def hello(uri):<br/>    async with connect(uri) as websocket:<br/>        while True:<br/>            await websocket.send("getPacketCarTelemetryData")<br/>            message = await websocket.recv()<br/>            print(message)</span><span id="6d65" class="ld je hh kz b fi lu lf l lg lh">await websocket.send("getPacketSessionData")<br/>            message = await websocket.recv()<br/>            print(message)</span><span id="c426" class="ld je hh kz b fi lu lf l lg lh">asyncio.run(hello("ws://WS_SERVER_IP_ADDRESS:WS_PORT"))</span></pre><p id="b05c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，所选择的命令<strong class="ig hi">getpacketcarteletrydata</strong>和<strong class="ig hi"> getPacketSessionData </strong>必须是网络套接字服务器中接受的命令。在我们的例子中，它们是相互一致的，这就是我们得到响应的原因。</p><h1 id="4f82" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">信用</h1><p id="193d" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">请注意，<a class="ae jc" href="https://github.com/chrishannam" rel="noopener ugc nofollow" target="_blank">克里斯·汉南</a>已经做了大量关于F1 2021遥测解码的工作。我们的存储库只是扩展了与RabbitMQ和Oracle数据库集成的功能。</p><p id="78a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另外，衷心感谢<a class="ae jc" href="https://www.linkedin.com/in/wojciechpluta/" rel="noopener ugc nofollow" target="_blank"> Wojciech Pluta </a>和<a class="ae jc" href="https://www.linkedin.com/in/johnabrock/" rel="noopener ugc nofollow" target="_blank"> John Brock </a>为<a class="ae jc" href="https://314piday.com/" rel="noopener ugc nofollow" target="_blank">alma Linux+Oracle Pi Day 2022</a>开发概念验证(POC)仪表板做出的贡献，我们在此展示了此POC以展示Oracle JET和Raspberry Pi的功能。</p><p id="07fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，记得检查一下<a class="ae jc" href="https://github.com/peppertech/FormulaPi" rel="noopener ugc nofollow" target="_blank">这个库</a>中的前端代码。</p><h1 id="e4f5" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加入对话！</h1><p id="c231" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">如果你对Oracle开发人员在他们的自然环境中发生的事情感到好奇，就来参加我们的公共休闲频道吧！我们不介意成为你的鱼缸🐠</p><p id="6eed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下周三，也就是3月30日，我们会有一个关于这个的现场会议。请务必在此加入我们。</p><h1 id="b95a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">许可证</h1><p id="b0a2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">由<a class="ae jc" href="https://www.linkedin.com/in/ignacio-g-martinez/" rel="noopener ugc nofollow" target="_blank">伊格纳西奥·吉尔勒莫·马丁内兹</a><a class="ae jc" href="https://github.com/jasperan" rel="noopener ugc nofollow" target="_blank">@贾斯珀兰</a>撰写，由<a class="ae jc" href="https://github.com/GreatGhostsss" rel="noopener ugc nofollow" target="_blank">大幽灵</a>编辑</p><p id="6d3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">版权所有2021 Oracle和/或其附属公司。</p><p id="79d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据通用许可许可证(UPL)1.0版进行许可。</p><p id="1095" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">详见<a class="ae jc" href="https://github.com/jasperan/f1-telemetry-oracle/blob/main/LICENSE" rel="noopener ugc nofollow" target="_blank">许可证</a>。</p></div></div>    
</body>
</html>