<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison Part 1:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协同程序和rx Java——异步比较第1部分:</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a?source=collection_archive---------0-----------------------#2018-04-04">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a?source=collection_archive---------0-----------------------#2018-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/18676cc14a903fa65cbd05cb255d7502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7LB4AZ7yki5D20AptFU_w.png"/></div></div></figure><div class=""/><div class=""><h2 id="d10b" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">异步编程</h2></div><h1 id="e06d" class="jh ji hs bd jj jk jl jm jn jo jp jq jr iy js iz jt jb ju jc jv je jw jf jx jy bi translated">介绍</h1><p id="8ba2" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">在这个博客系列中，我将比较<a class="ae kv" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"><strong class="kb ht"/></a><strong class="kb ht">和</strong> <a class="ae kv" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ht"> RxJava </strong> </a>，因为它们都试图解决Android开发中的一个常见问题:<strong class="kb ht">异步编程</strong>。</p><h1 id="633a" class="jh ji hs bd jj jk jl jm jn jo jp jq jr iy js iz jt jb ju jc jv je jw jf jx jy bi translated">用例:创建异步重物，实现快速应用启动！</h1><p id="2201" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated"><a class="ae kv" href="https://developer.android.com/topic/performance/launch-time.html" rel="noopener ugc nofollow" target="_blank">启动时性能</a>至关重要！如果你想让你的应用程序快速启动，如何处理对象创建是很重要的。</p><p id="cb67" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">有些计算可能需要一些时间(例如初始化重物)。您不希望这种情况发生在UI线程中！如果是这样，你的应用程序将会跳过帧，用户将会有滞后的体验。有什么能影响这个？SDK初始化、创建加密对象等。</p><p id="393e" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">对于我们的第一个用例，我们只想在后台线程中执行一个繁重的操作。</p><h2 id="344f" class="lb ji hs bd jj lc ld le jn lf lg lh jr ki li lj jt km lk ll jv kq lm ln jx lo bi translated">RxJava</h2><p id="f287" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">尽管RxJava是JVM的一个<a class="ae kv" href="http://reactive extensions" rel="noopener ugc nofollow" target="_blank">反应式扩展</a>库，但是您也可以使用它在后台运行异步任务。</p><p id="5edc" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">在这个场景中，我们忽略了RxJava传输元素流的能力，我们只需要初始化一些东西。</p><p id="0f1e" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们需要什么RxJava构建操作符来实现这一点？一个<a class="ae kv" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ht">可完成的</strong> </a>！</p><blockquote class="lp lq lr"><p id="35ca" class="jz ka ls kb b kc kw it ke kf kx iw kh lt ky kk kl lu kz ko kp lv la ks kt ku ha bi translated">根据RxJava文档:Completable表示一个延迟的计算，没有任何值，只有完成或异常的指示。</p></blockquote><p id="a77c" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated"><strong class="kb ht">我们如何创建一个Completable来初始化我们想要的对象？</strong></p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="3d91" class="lb ji hs mb b fi mf mg l mh mi">fun initializeObjectsAsync(): Completable {<br/>    return Completable.create <strong class="mb ht">{ </strong>emitter <strong class="mb ht">-&gt;<br/>        </strong>try {<br/>            <strong class="mb ht">heavyInitialization()<br/></strong>            if (emitter != null &amp;&amp; !emitter.<em class="ls">isDisposed</em>) {<br/>                <strong class="mb ht">emitter?.onComplete</strong>()<br/>            }<br/>        } catch (e: Exception) {<br/>            if (emitter != null &amp;&amp; !emitter.<em class="ls">isDisposed</em>) {<br/>                <strong class="mb ht">emitter?.onError</strong>(e)<br/>            }<br/>        }<br/>    <strong class="mb ht">}<br/></strong>}</span></pre><p id="5fe4" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">如你所见，我们已经创建了一个函数，它将返回一个<strong class="kb ht"> Completable对象</strong>。在函数内部，我们用<code class="du mj mk ml mb b">Completable.create</code>创建了我们的自定义Completable，它将接受一个发射器(可能订阅它的对象)。</p><p id="0770" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">在执行了繁重的初始化之后，我们将通知发射器它成功了。如果有错误，我们将通知发生的错误。这是因为发射器的类型是<a class="ae kv" href="http://reactivex.io/RxJava/javadoc/io/reactivex/CompletableEmitter.html" rel="noopener ugc nofollow" target="_blank"><strong class="kb ht"><em class="ls">completablemitter</em></strong></a>以及<code class="du mj mk ml mb b">onComplete</code>和<code class="du mj mk ml mb b">onError</code>是可用于将结果传达给订户的方法。</p><p id="be79" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">另一种方法是使用<code class="du mj mk ml mb b"><a class="ae kv" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html#fromCallable-java.util.concurrent.Callable-" rel="noopener ugc nofollow" target="_blank">Completable.fromCallable()</a></code></p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="f6d0" class="lb ji hs mb b fi mf mg l mh mi">fun initializeObjectsAsync(): Completable {<br/>    return Completable.fromCallable(<strong class="mb ht">{</strong><br/>            <strong class="mb ht">heavyInitialization()<br/></strong>    })<strong class="mb ht"><br/></strong>}</span></pre><p id="0586" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们如何使用该功能？</p><p id="b769" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们知道，Observables，和(per extension) Completables，在RxJava中都是<a class="ae kv" rel="noopener" href="/@benlesh/hot-vs-cold-observables-f8094ed53339"><strong class="kb ht"><em class="ls"/></strong></a>。这意味着只有当我们订阅时，<code class="du mj mk ml mb b">Completable.create</code>中的代码才会被执行。需要记住的是，每次您订阅它时，它都会被执行。</p><p id="9e91" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们必须订阅我们在上面创建的<code class="du mj mk ml mb b">initializeObjectsAsync</code>函数中创建的Completable。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="17b1" class="lb ji hs mb b fi mf mg l mh mi">fun initializeObjects() {<br/>    initializeObjectsAsync()<br/>        .<strong class="mb ht">subscribeOn</strong>(Schedulers.computation())<br/>        .<strong class="mb ht">observeOn</strong>(AndroidSchedulers.mainThread())<br/>        .<strong class="mb ht">subscribe</strong>(<strong class="mb ht">{<br/>            </strong>// The initialization succeeded!<br/>            // We can perform UI changes here <br/>        <strong class="mb ht">}</strong>, <strong class="mb ht">{<br/>            </strong>// An Error occurred!<br/>        <strong class="mb ht">}</strong>)<br/>}</span></pre><p id="d418" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们如何告诉RxJava我们希望初始化在后台线程上执行？我们使用<code class="du mj mk ml mb b"><a class="ae kv" href="http://reactivex.io/documentation/operators/subscribeon.html" rel="noopener ugc nofollow" target="_blank">subscribeOn</a></code>操作符告诉RxJava我们希望在后台线程上执行<code class="du mj mk ml mb b">Completable.create</code>中的代码。</p><p id="0eba" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">由于我们希望在初始化完成后对UI进行一些修改，我们可以使用<code class="du mj mk ml mb b"><a class="ae kv" href="http://reactivex.io/documentation/operators/observeon.html" rel="noopener ugc nofollow" target="_blank">observeOn</a></code>操作符告诉RxJava我们希望在Android主线程上监听结果。</p><blockquote class="mm"><p id="2342" class="mn mo hs bd mp mq mr ms mt mu mv ku dx translated">只有当您订阅Completable时，Completable.create中的代码才会被执行。</p></blockquote><p id="23d0" class="pw-post-body-paragraph jz ka hs kb b kc mw it ke kf mx iw kh ki my kk kl km mz ko kp kq na ks kt ku ha bi translated">在定义线程之后，我们希望订阅Completable并在它完成时得到通知。我们用<code class="du mj mk ml mb b">.subscribe(successBlockOfCode,failureBlockOfCode)</code>来做这件事。我们传递两个代码块:第一个定义成功场景，第二个定义失败场景。</p><p id="b803" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">例如，如果我们希望在创建Android活动时执行这段代码，我们可以在onCreate方法中调用这个方法。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="7d2a" class="lb ji hs mb b fi mf mg l mh mi">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<em class="ls">activity_main</em>)<br/><br/>    initializeObjects()<br/>}</span></pre><p id="e117" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们如何对协程做同样的事情呢？</p><h2 id="fe94" class="lb ji hs bd jj lc ld le jn lf lg lh jr ki li lj jt km lk ll jv kq lm ln jx lo bi translated">科特林协程</h2><p id="a4cd" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">有了协程，这就更简单了！从概念上讲，协程在许多方面类似于线程:我们可以编写可以在特定线程上运行的顺序代码。</p><p id="140d" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我将写另一篇关于RxJava和协程线程的博文。现在，您需要知道我们可以用一个<a class="ae kv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">协程调度器</a>在<a class="ae kv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/index.html" rel="noopener ugc nofollow" target="_blank">协程上下文</a>中定义一个协程的线程策略。我们可以用一个CoroutineBuilder用一个特定的CoroutineContext创建一个coroutine。</p><blockquote class="lp lq lr"><p id="edcf" class="jz ka ls kb b kc kw it ke kf kx iw kh lt ky kk kl lu kz ko kp lv la ks kt ku ha bi translated">一个<strong class="kb ht">协程构建器</strong>是一个函数，它创建一个协程，运行一段代码，并以某种形式让你访问它的结果。CoroutineBuilder的例子有:启动、异步、运行阻塞…</p></blockquote><p id="e996" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">假设我们想像之前在<code class="du mj mk ml mb b">onCreate</code>方法中一样调用<code class="du mj mk ml mb b">heavyInitialization()</code>方法，我们可以用<a class="ae kv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" rel="noopener ugc nofollow" target="_blank"> CoroutineBuilder launch </a>创建一个Coroutine，并在正在运行的代码块中执行繁重的初始化。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="959c" class="lb ji hs mb b fi mf mg l mh mi">fun initializeObjects() {<br/>    <em class="ls">launch</em>(CommonPool) <strong class="mb ht">{<br/>        heavyInitialization()</strong><br/>    <strong class="mb ht">}<br/></strong>}</span></pre><p id="17cf" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">协程调度器<a class="ae kv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ht">共享池</strong> </a>类似于RxJava <code class="du mj mk ml mb b">Schedulers.computation()</code>。这将在后台运行代码，我们不必担心其他任何事情。</p><p id="0f14" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">让我们模仿用RxJava构建的例子:我们想知道它什么时候完成了对重对象和错误处理的初始化。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="037c" class="lb ji hs mb b fi mf mg l mh mi">fun initializeObjects() {<br/>    <em class="ls">launch</em>(CommonPool) <strong class="mb ht">{<br/>        </strong>try {<br/>            heavyInitialization()<br/>            // The initialization succeeded!<br/>            <strong class="mb ht"><em class="ls">withContext</em>(<em class="ls">UI</em>)</strong> <strong class="mb ht">{<br/>                </strong>// We can perform UI changes here<br/>            <strong class="mb ht">}<br/>        </strong>} catch (e: Exception) {<br/>            // An Error occurred!<br/>        }<br/>    <strong class="mb ht">}<br/></strong>}</span></pre><p id="67c3" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">由于协程(所谓的<strong class="kb ht"> <em class="ls">暂停λ</em></strong>)内的代码是顺序执行的，所以初始化成功后会执行<code class="du mj mk ml mb b">heavyInitialization()</code>之后的行。</p><p id="a565" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">和以前一样，我们可以将调用包装在try catch块中进行错误处理。它将以同样的方式工作。</p><p id="c933" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们如何切换到UI线程并执行UI更改？您可以在一个名为<code class="du mj mk ml mb b"><a class="ae kv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" rel="noopener ugc nofollow" target="_blank"><strong class="kb ht">withContext</strong></a></code>的协程中调用一个函数，该函数使用另一个协程上下文来运行其中的代码块。基本上，它会切换到Android UI线程来执行代码。</p><blockquote class="lp lq lr"><p id="3dbc" class="jz ka ls kb b kc kw it ke kf kx iw kh lt ky kk kl lu kz ko kp lv la ks kt ku ha bi translated">我们在示例中看到的UI CoroutineContext不是标准Kotlin Coroutines库的一部分。因为它是Android特有的，所以它可以在另一个库中找到:<code class="du mj mk ml mb b">org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines_version</code>。</p></blockquote><h1 id="82cf" class="jh ji hs bd jj jk jl jm jn jo jp jq jr iy js iz jt jb ju jc jv je jw jf jx jy bi translated">第二个用例:斐波那契示例的后台处理</h1><p id="eb76" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">对于我们的第二个用例，除了在后台执行某些东西，我们还想返回值。现在，我们想计算当用户按下按钮时一个数字的斐波那契数列。</p><p id="4ecb" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">假设我们有以下代码来计算一个数的斐波那契数列:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="6833" class="lb ji hs mb b fi mf mg l mh mi">private fun fib(n: Long): Long {        <br/>    return if (n &lt;= 1) n        <br/>    else fib(n - 1) + fib(n - 2)    <br/>}</span></pre><p id="2075" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">如何在后台计算这个并返回结果？</p><h2 id="13b5" class="lb ji hs bd jj lc ld le jn lf lg lh jr ki li lj jt km lk ll jv kq lm ln jx lo bi translated">RxJava</h2><p id="ce4e" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">在我们的第一个用例中，我们已经看到了大部分这些概念。我们需要一个可以返回对象的RxJava building操作符。我们可以用一首<a class="ae kv" href="http://reactivex.io/documentation/single.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ht"> <em class="ls">单曲</em> </strong> </a>来说明！</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="3a09" class="lb ji hs mb b fi mf mg l mh mi">fun fibonacciAsync(number: Long): Single&lt;Long&gt; = <br/>    <strong class="mb ht">Single.create</strong>({ emitter -&gt;<br/>            <strong class="mb ht">val result = fib(number)</strong> <br/>            if (emitter != null &amp;&amp; !emitter.<em class="ls">isDisposed</em>) {       <br/>                 <strong class="mb ht">emitter.onSuccess(result)</strong><br/>            }<br/>})</span></pre><p id="e0ca" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">在<code class="du mj mk ml mb b">Single.create</code>中的代码将在我们订阅它时被执行，我们可以像以前一样使用它。当我们收到用户交互时，我们只订阅fibonacci方法返回的Single。</p><p id="d504" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">您还可以使用我们在Completable示例中看到的fromCallable函数:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="a5f1" class="lb ji hs mb b fi mf mg l mh mi">fun fibonacciAsync(number: Long): Single&lt;Long&gt; = <br/>    <strong class="mb ht">Single.fromCallable</strong>({<br/>        <strong class="mb ht">return fib(number)</strong><br/>    })</span></pre><p id="abd4" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">我们将我们想要的数字作为该函数的参数传递，它也将在代码块<code class="du mj mk ml mb b">Single.create</code>中使用。例如，我们可以从EditText中获取该数字。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="76e7" class="lb ji hs mb b fi mf mg l mh mi">@OnClick(R.id.my_button)<br/>fun onButtonClicked() { <br/><strong class="mb ht">    fibonacciAsync(numberInputEditText.text.toString().toLong())</strong><br/>       .subscribeOn(Schedulers.computation())<br/>       .observeOn(AndroidSchedulers.mainThread())<br/>       .subscribe({ fibonacciNumber -&gt; <br/>           //Update UI with the result <br/>          <strong class="mb ht"> myTextView.text = fibonacciNumber</strong><br/>       },{<br/>           // Error happened<br/>       })<br/>}</span></pre><p id="f2c9" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">每次用户点击按钮，我们都要计算一个新的斐波那契数。如果用户更改numberInputEditText内部的值，结果将会不同！</p><h2 id="e55b" class="lb ji hs bd jj lc ld le jn lf lg lh jr ki li lj jt km lk ll jv kq lm ln jx lo bi translated">科特林协程</h2><p id="308a" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">这个例子和上面的一样简单。当用户点击按钮时，我们希望启动一个协程并计算我们想要的数字的斐波那契数列。我们已经知道做这件事所需的一切:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="4a15" class="lb ji hs mb b fi mf mg l mh mi">@OnClick(R.id.my_button)<br/>fun onButtonClicked() { <br/>    <strong class="mb ht"><em class="ls">launch</em></strong>(CommonPool) {<strong class="mb ht"><br/>        val result = fib</strong>(<br/>            numberInputEditText.<em class="ls">text</em>.toString().toLong()<br/>        )<br/>        <em class="ls">withContext</em>(<em class="ls">UI</em>) {<strong class="mb ht"><br/>            fibonacciResultTextView.<em class="ls">text </em>= result<br/></strong>        }<br/>    }<strong class="mb ht"><br/></strong>}</span></pre></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><h1 id="cb1b" class="jh ji hs bd jj jk ni jm jn jo nj jq jr iy nk iz jt jb nl jc jv je nm jf jx jy bi translated">接下来会发生什么？</h1><p id="8cc0" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">本系列<a class="ae kv" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068">第二部</a>将是关于<strong class="kb ht">取消执行</strong>！</p><p id="9e11" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">你如何取消一个可观察的？还有协程？下周不要错过！</p></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><h1 id="ce0a" class="jh ji hs bd jj jk ni jm jn jo nj jq jr iy nk iz jt jb nl jc jv je nm jf jx jy bi translated">更多教育</h1><p id="2aa7" class="pw-post-body-paragraph jz ka hs kb b kc kd it ke kf kg iw kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">想了解更多关于Kotlin的信息？看看这篇文章！</p><div class="hg hh ez fb hi nn"><a href="https://proandroiddev.com/kotlin-education-d0b958740d6a" rel="noopener  ugc nofollow" target="_blank"><div class="no ab dw"><div class="np ab nq cl cj nr"><h2 class="bd ht fi z dy ns ea eb nt ed ef hr bi translated">科特林教育</h2><div class="nu l"><h3 class="bd b fi z dy ns ea eb nt ed ef dx translated">超越基础</h3></div><div class="nv l"><p class="bd b fp z dy ns ea eb nt ed ef dx translated">proandroiddev.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ho nn"/></div></div></a></div><p id="f930" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">RxJava呢？看看这些文章！</p><div class="hg hh ez fb hi nn"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/rxjava-android-mvvm-app-structure-with-retrofit-a5605fa32c00"><div class="no ab dw"><div class="np ab nq cl cj nr"><h2 class="bd ht fi z dy ns ea eb nt ed ef hr bi translated">RxJava: Android MVVM应用程序结构的改进</h2><div class="nu l"><h3 class="bd b fi z dy ns ea eb nt ed ef dx translated">介绍</h3></div><div class="nv l"><p class="bd b fp z dy ns ea eb nt ed ef dx translated">medium.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob ho nn"/></div></div></a></div><div class="hg hh ez fb hi nn"><a rel="noopener follow" target="_blank" href="/capital-one-developers/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e"><div class="no ab dw"><div class="np ab nq cl cj nr"><h2 class="bd ht fi z dy ns ea eb nt ed ef hr bi translated">RxJava 2: Android MVVM生命周期应用程序结构与改进2</h2><div class="nu l"><h3 class="bd b fi z dy ns ea eb nt ed ef dx translated">自从我写了关于MVVM、RxJava和翻新的文章已经两年多了。我们来更新一下。</h3></div><div class="nv l"><p class="bd b fp z dy ns ea eb nt ed ef dx translated">medium.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob ho nn"/></div></div></a></div><p id="6a8c" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">感谢阅读，</p><p id="9097" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated">曼努埃尔·维森特Vivo</p></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><p id="82e8" class="pw-post-body-paragraph jz ka hs kb b kc kw it ke kf kx iw kh ki ky kk kl km kz ko kp kq la ks kt ku ha bi translated"><em class="ls">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>