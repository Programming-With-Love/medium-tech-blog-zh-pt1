<html>
<head>
<title>Diffable Data Source in iOS 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 13中的不同数据源</h1>
<blockquote>原文：<a href="https://medium.com/globant/diffable-data-source-in-ios-13-34e2dbbe5983?source=collection_archive---------2-----------------------#2020-07-20">https://medium.com/globant/diffable-data-source-in-ios-13-34e2dbbe5983?source=collection_archive---------2-----------------------#2020-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/aee282b55fba42ddf057232b59c23ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QftA1sJWhaYzahSS0PxV7A.png"/></div></div></figure><p id="fe9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从iOS SDK开始，表视图只管理其数据的显示，而不管理数据本身。要管理数据，您需要为表提供一个数据源对象。这是一个实现<code class="du jn jo jp jq b">UITableViewDataSource</code>协议的对象。数据源对象响应表中与数据相关的请求。此外，还提供了TableView中的单元格。我们需要实现协议方法，并确保我们的支持模型与数据源正确同步，以避免任何崩溃。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="9e65" class="jz ka hh jq b fi kb kc l kd ke">optional func number of sections(in tableView: UITableView) -&gt; Int<br/>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br/>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell</span></pre><p id="cd98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，如果我们需要对TableView中的部分和行执行更新。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="50d2" class="jz ka hh jq b fi kb kc l kd ke">tableView.beginUpdates()</span><span id="ed8d" class="jz ka hh jq b fi kf kc l kd ke">// Delete section 1 and 2<br/>tableView.reloadSections([1,2], with: .automatic)</span><span id="5c36" class="jz ka hh jq b fi kf kc l kd ke">// Insert at section 1 and row 1<br/>tableView.insertRows(at: [IndexPath(row: 1, section: 1)], with: .automatic)</span><span id="c3f9" class="jz ka hh jq b fi kf kc l kd ke">// delete at section 1 and row 3<br/>tableView.deleteRows(at: [IndexPath(row: 3, section: 1)], with: .automatic)</span><span id="c9b4" class="jz ka hh jq b fi kf kc l kd ke">tableView.endUpdates()</span></pre><p id="88b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据新旧数据之间的值，很难确保每次插入、重新加载和删除时所有的部分和行都得到正确的更新。</p><p id="81af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是当我们错误地更新TableView时UIKit抛出的错误。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="371c" class="jz ka hh jq b fi kb kc l kd ke"><strong class="jq hi">* Terminating app due to uncaught exception ‘NSInternalInconsistencyException’, reason: ‘Invalid update: invalid number of sections. The number of sections contained in the table view after the update (10) must be equal to the number of sections contained in the table view before the update (10), plus or minus the number of sections inserted or deleted (0 inserted, 1 deleted).’<br/>***</strong></span></pre><p id="dad8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在WWDC 2019年，苹果宣布了一个非常酷的表格视图和集合视图功能。UITableViewDiffableDataSource和uicollectionviewdiffabledata source。</p><p id="cc2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些新的不同数据源类允许我们根据快照为集合和表视图定义数据源。快照充当我们的视图和数据源之间的真实来源。然后，差异数据源会将新快照与旧快照进行比较，并自动应用其内容的任何插入、删除和重新排序。所有的差异，视图更新与动画将自动为我们执行。</p><blockquote class="kg kh ki"><p id="d249" class="ip iq kj ir b is it iu iv iw ix iy iz kk jb jc jd kl jf jg jh km jj jk jl jm ha bi translated"><a class="ae kn" href="https://developer.apple.com/videos/play/wwdc2019/220/" rel="noopener ugc nofollow" target="_blank">你可以从苹果WWDC 2019会议</a>上了解更多信息</p></blockquote><p id="a1fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我们将看到TableView的不同数据源。因为除了一些类名之外，表视图数据源与集合视图版本非常相似。</p><p id="7657" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">可区分数据源区分策略。</strong></p><p id="a6f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要提供能够提供独特价值的部分和项目类型表示。它们都需要按照下面的UITableViewDiffableDataSource类的声明实现一个可散列的协议。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="2279" class="jz ka hh jq b fi kb kc l kd ke">@available(iOS 13.0, tvOS 13.0, *)<br/>open class UITableViewDiffableDataSource&lt;SectionIdentifierType, ItemIdentifierType&gt; : NSObject, UITableViewDataSource where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable</span></pre><p id="e2fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">SectionIdentifierType和ItemIdentifierType是我们在声明和初始化类时必须提供的泛型。不同的数据源使用所有标识符的哈希值来确定发生了什么变化。</p><p id="c885" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们看看使用不同数据源的另一个关键因素。</p><p id="479b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">快照</strong>:</p><p id="428d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当表视图需要更新时，必须使用最新数据创建数据源快照，并将其应用于数据源对象。它与应用它的不同数据源具有相同的通用参数。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="ce79" class="jz ka hh jq b fi kb kc l kd ke">struct NSDiffableDataSourceSnapshot&lt;SectionIdentifierType, ItemIdentifierType&gt; <br/> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable</span></pre><h1 id="b224" class="ko ka hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">示例:</h1><p id="cd52" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">我们必须首先为UITableViewDiffableDataSource创建SectionIdentifier和ItemIdentifier。我们将使用enum来提供一个部分，因为它们已经被确认为Hashable协议。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="a52e" class="jz ka hh jq b fi kb kc l kd ke">enum Section {<br/> case City<br/>}</span></pre><p id="2556" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于ItemIdentifier，我们将创建一个单独的模型。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="efdc" class="jz ka hh jq b fi kb kc l kd ke">struct MyCity: Hashable {<br/> var cityName:String<br/>}</span><span id="71e7" class="jz ka hh jq b fi kf kc l kd ke">Class ViewController: UIViewController {</span><span id="4e0f" class="jz ka hh jq b fi kf kc l kd ke">@IBOutlet weak var cityTextfield: UITextField!<br/>@IBOutlet weak var tableview: UITableView!<br/>private var cityList = [City(name: “Mumbai”), City(name: “Pune”), City(name: “Nasik”)]<br/>fileprivate var dataSource: UITableViewDiffableDataSource!</span><span id="234e" class="jz ka hh jq b fi kf kc l kd ke">override func viewDidLoad() {</span><span id="3a6b" class="jz ka hh jq b fi kf kc l kd ke">super.viewDidLoad()</span><span id="afa7" class="jz ka hh jq b fi kf kc l kd ke">configureDataSource()</span><span id="8026" class="jz ka hh jq b fi kf kc l kd ke">createSnapshot()</span><span id="ac6d" class="jz ka hh jq b fi kf kc l kd ke">}</span></pre><p id="70c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们不必编写<strong class="ir hi"> cellForRowAt indexPath </strong>和其他方法，而是只需编写几行代码来加载UITableview。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="68ad" class="jz ka hh jq b fi kb kc l kd ke">func configureDataSource() {</span><span id="b6b4" class="jz ka hh jq b fi kf kc l kd ke">dataSource = UITableViewDiffableDataSource&lt;Section, MyCity&gt;(tableView: tableview) { (tableview, indexPath, city) -&gt; UITableViewCell? in<br/>let cell = tableview.dequeueReusableCell(withIdentifier: “cell”, for: indexPath)</span><span id="35c2" class="jz ka hh jq b fi kf kc l kd ke">    cell.textLabel?.text = city.cityName<br/>    return cell<br/>}</span></pre><p id="7f19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以编辑我们的表格视图</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="0662" class="jz ka hh jq b fi kb kc l kd ke">func tableViewEditOperations() {</span><span id="03a2" class="jz ka hh jq b fi kf kc l kd ke">let cityObject = City(cityName: cityTextfield.text ?? "")</span><span id="d120" class="jz ka hh jq b fi kf kc l kd ke">//Adding row to tableview<br/>cityList.append(cityObject)</span><span id="e911" class="jz ka hh jq b fi kf kc l kd ke">//Deleting row from Tableview<br/>cityList.remove(at: 1)</span><span id="aed4" class="jz ka hh jq b fi kf kc l kd ke">//Inserting row to Tableview<br/>cityList.insert(cityObject, at: 1)</span><span id="d0d5" class="jz ka hh jq b fi kf kc l kd ke">createSnapshot()</span><span id="29ff" class="jz ka hh jq b fi kf kc l kd ke">}</span></pre><p id="23a0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们为快照创建了一个单独的函数。我们只需要在每次操作后调用这个函数，它就会为你改变不同的变化。</p><pre class="jr js jt ju fd jv jq jw jx aw jy bi"><span id="f943" class="jz ka hh jq b fi kb kc l kd ke">func createSnapshot() {<br/>var snapshot = NSDiffableDataSourceSnapshot&lt;Section, MyCity&gt;()</span><span id="f5f7" class="jz ka hh jq b fi kf kc l kd ke">snapshot.appendSections([.Main])<br/>snapshot.appendItems(cityList,toSection:.Main)</span><span id="4f0c" class="jz ka hh jq b fi kf kc l kd ke">dataSource.apply(snapshot, animatingDifferences:true)<br/>}</span></pre><p id="2655" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果需要的话，apply()方法可以动态显示这些更改。我们可以用下面的动画看到所有的编辑操作。</p><figure class="jr js jt ju fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/622c1eb4ba01142da325da85a2ee4ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*Sf1SSpvqv-Wr-Pvt46oOFA.gif"/></div></figure><h1 id="c572" class="ko ka hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论:-</h1><p id="b82c" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">UITableViewDiffableDataSource只是管理数据并为表格视图提供单元格。这是一个通用类，它删除了许多样板代码，使我们能够以一种非常声明性的方式创建一个datasource对象。</p></div></div>    
</body>
</html>