<html>
<head>
<title>In the Not Too Distant Future…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不太遥远的将来…</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/in-the-not-too-distant-future-e2d0ad28e91?source=collection_archive---------3-----------------------#2017-08-24">https://medium.com/capital-one-tech/in-the-not-too-distant-future-e2d0ad28e91?source=collection_archive---------3-----------------------#2017-08-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="1f07" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">建立一个包含频道、Goroutines和选择的期货库</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/26887a33a055716e6a424fe51774ebf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVIuenQxyu-Pa4PAH_3bjQ.jpeg"/></div></div></figure><p id="bac5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" rel="noopener" href="/@jon_43067"> <strong class="jk hi"> <em class="kf">一系列帖子中的第4张</em> </strong> </a></p><p id="6940" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" rel="noopener" href="/@jon_43067">在之前的博客文章</a>中，我们已经了解了如何使用通道来构建无限队列、池以及管理多个并行请求。我们能够用通道做所有这些事情，在这些情况下，抽象是有意义的，但有时，我们希望以不同的方式来处理并发问题。例如，Node.js开发人员使用未来(有时称为承诺)的概念来组织回调和后台任务。如何在Go中构建futures来实现同样的工作流程？</p><p id="4cf8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你对期货不熟悉，<a class="ae ke" href="http://dist-prog-book.com/chapter/2/futures.html" rel="noopener ugc nofollow" target="_blank">下面是基本思路</a>。它们是一种编程抽象，允许您在后台运行一点代码，并立即获得对结果的引用。当您最终尝试从引用中读取结果时，future会检查结果是否已经计算出来。如果有，它会立即返回。如果没有，您要等到结果被填充。</p><p id="c50f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">期货有两个重要的属性。首先，您不必等到实际需要结果时才等待后台进程的结果。第二，使用futures隐藏了并发编程中经常涉及的许多混乱的样板文件，使您的源代码更容易理解。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://twitter.com/CapitalOneDevEx"><div class="er es kg"><img src="../Images/a94559d31aeb80a7fd55aff68f92d34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGp3B7rAWWoCgY2i_nC6TA.png"/></div></a></figure><h1 id="ecb4" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">设计API</h1><p id="5515" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">所以，让我们弄清楚一个基本未来的API会是什么样子。我们希望:</p><ul class=""><li id="a78c" class="le lf hh jk b jl jm jo jp jr lg jv lh jz li kd lj lk ll lm bi translated">传入要运行的代码</li><li id="89a9" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">返回一个引用，该引用最终将包含由代码计算的值</li></ul><p id="2088" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们先来看返回类型。因为这是Go，所以我们有一些特定于语言的细节需要注意。</p><p id="8ea6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，再一次，Go中没有泛型，所以我们需要尽可能用最通用的术语来写东西，并让我们的客户端代码将响应转换成正确的数据类型。这意味着使用<code class="du ls lt lu lv b">interface{}</code>作为返回的数据类型。</p><p id="cd98" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第二，在Go中处理错误的惯用方法是返回一个<code class="du ls lt lu lv b">error</code>作为最终参数，所以我们也需要返回一个<code class="du ls lt lu lv b">error</code>，以防将来出现错误。</p><p id="4b0e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们不能只返回一个填充了值的<code class="du ls lt lu lv b">struct</code>，因为我们会立即返回引用，稍后再填充数据。这意味着我们需要调用一个可能会等待数据出现的方法。与其使用具体的类型，不如公开一个<code class="du ls lt lu lv b">interface</code>更有意义，给我们最大的灵活性。因此，我们的返回类型将看起来像:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="71d7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们传入的函数呢？因为Go有闭包，所以我们可以用一个闭包来包装我们真正想运行的代码。这意味着我们不需要担心向函数传递参数；我们将从环境中捕捉它们。我们确实需要从闭包中返回值，以便填充我们的<code class="du ls lt lu lv b">future.Interface </code>实现，所以我们的函数必须返回<code class="du ls lt lu lv b">(interface{}, error)</code>。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="7066" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们已经定义了输入和输出类型，下面是我们的API的第一遍:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="9297" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将很快填充实现。下面是创建未来时客户端代码的样子:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="ecab" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">首次实施</h1><p id="212b" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">现在我们知道了代码对外界应该是什么样子，我们可以开始考虑它将如何做它需要做的事情。让我们看看我们是否可以只用标准的Go并发机制来实现我们的未来:<code class="du ls lt lu lv b">select</code>、通道和goroutines。</p><p id="c6e6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，我们需要一个结构来保存数据和实现接口。我们不想向我们的客户公开它，因为他们应该只使用接口和工厂函数。这意味着它的名字的第一个字符应该是小写字母。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4d33" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可能会对类型为<code class="du ls lt lu lv b">struct{}</code>的done通道感到惊讶。我们将利用围棋中的一种模式，这种模式用于在工作完成时发出信号。当通道无缓冲时，试图从通道中读取将暂停读取程序，直到发生以下两种情况之一:向通道写入值或关闭通道。我们的<code class="du ls lt lu lv b">done</code>通道永远不会写入值；它的存在只是为了在工作完成时关闭。这允许你使用一个封闭的通道作为一个永久的信号，从一个goroutine到另一个go routine，它可以继续下去。</p><p id="6ad1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们需要实现<code class="du ls lt lu lv b">New</code>:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="5163" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我们的代码中，<code class="du ls lt lu lv b">New</code>创建一个<code class="du ls lt lu lv b">futureImpl</code>，然后启动一个goroutine来运行传入函数，将函数返回的值和错误赋给我们的<code class="du ls lt lu lv b">futureImpl</code>中的字段，并关闭<code class="du ls lt lu lv b">done</code>通道。同时，<code class="du ls lt lu lv b">Get</code>方法等待，直到<code class="du ls lt lu lv b">done</code>通道关闭，然后返回值和错误。如果再调用<code class="du ls lt lu lv b">Get</code>，关闭的<code class="du ls lt lu lv b">done</code>通道会立即返回，我们会不等待的取回值和错误。</p><p id="48f4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们已经用大约20行代码得到了未来工作的基本结构；一点也不坏。</p><p id="fdd1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">如果你想看到它工作，在Go Playground上查看</em> <a class="ae ke" href="https://play.golang.org/p/9gNEkgQihl" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这个链接</em> </a> <em class="kf">。</em></p><h1 id="5826" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">不要永远等待</h1><p id="0fb3" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">现在基础工作已经完成，是时候为我们的未来添加更多的功能了。你可能想到的第一件事是，不必永远等待未来的完成是件好事。毕竟，未来可能比我们想要等待的时间更长。我们应该在我们的接口中添加第二个方法，这样我们就可以限制我们愿意等待的时间:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="b4c3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">调用<code class="du ls lt lu lv b">GetUntil</code>而不是<code class="du ls lt lu lv b">Get</code>只会等待指定的<code class="du ls lt lu lv b">Duration</code>。如果结果在超时前返回，我们希望在那个点返回。如果结果在那个点之后回来，我们想要停止等待。为了知道请求是否超时，除了值和错误之外，我们还返回一个布尔标志。如果标志设置为真，则请求超时。如果是false，返回的值和误差就是我们的函数计算的值和误差。</p><p id="c3e4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了支持<code class="du ls lt lu lv b">GetUntil</code>，我们不需要修改<code class="du ls lt lu lv b">New</code>或者<code class="du ls lt lu lv b">Get</code>。我们只需要添加以下方法实现:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="69f9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du ls lt lu lv b">select</code>语句等待<code class="du ls lt lu lv b">f</code>中的<code class="du ls lt lu lv b">done</code>通道和<code class="du ls lt lu lv b">time.After</code>返回的通道。哪个先返回将决定返回哪个结果。</p><p id="7d5a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">还要注意，如果<code class="du ls lt lu lv b">GetUntil</code>超时，您还没有丢失您的工作。可以再调用<code class="du ls lt lu lv b">Get</code>或者<code class="du ls lt lu lv b">GetUntil</code>得到未来的结果。<code class="du ls lt lu lv b">GetUntil</code>所做的只是防止你等待结果被计算出来。</p><p id="d491" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是使用<code class="du ls lt lu lv b">GetUntil</code>的示例客户端代码:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="5a83" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">如果你想看到它工作，请在Go Playground上查看</em> <a class="ae ke" href="https://play.golang.org/p/8CnYCaEpLR" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这个链接</em> </a> <em class="kf">。</em></p><h1 id="5aee" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">建立一个链条</h1><p id="9121" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">很好，我们未来的实现正在向前推进。再补充点别的吧。</p><p id="2f0f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">期货通常具有的另一个特征是被链接在一起的能力。如果你有几个相互依赖的长时间运行的进程，让未来自动从一个进程调用另一个进程会很好。如果链中的一个调用失败，我们希望停止处理链中的工作，并返回导致失败的错误。这意味着需要向我们的接口添加一个新方法:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="0010" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的新方法叫做<code class="du ls lt lu lv b">Then</code>。它接受一个函数并返回一个新的未来接口。传递给<code class="du ls lt lu lv b">Then</code>的函数与传递给<code class="du ls lt lu lv b">New</code>的函数略有不同。这个函数只有一个输入参数，它是链中上一步的输出，因此得名。</p><p id="61c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">同样，我们可以在不修改任何现有代码的情况下添加新方法实现。我们将调用现有的<code class="du ls lt lu lv b">New</code>函数来创建一个新的未来。由于<code class="du ls lt lu lv b">New</code>函数需要一个没有输入参数的函数，我们将传递给它一个闭包，它做三件事:</p><p id="10b9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">1.对链中的前一个未来调用Get方法。</p><p id="b85e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">2.检查前一个未来是否返回错误。如果是的话，退回去。</p><p id="0560" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">3.否则，用前一个未来的结果调用下一个函数。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="53cd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">向未来添加一个<code class="du ls lt lu lv b">Then</code>步骤相当简单:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="f00a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有了这个补充，我们有了一个相当完整的未来实现。我们可以在后台运行作业，选择我们希望等待它们完成的时间，并用非常简洁的语法将作业链接在一起。但是添加未来链接意味着还有一件更好的事情:取消。</p><p id="7fa6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">你可以在Go Playground上的</em> <a class="ae ke" href="https://play.golang.org/p/yphIk3BJ4W" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这个链接</em> </a> <em class="kf">看到这个执行的样本代码。</em></p><h1 id="2d20" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">对抗未来</h1><p id="5eea" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">取消和超时之间的区别很微妙，但是很重要。超时意味着我现在不想等待工作完成，但是工作会在后台继续进行，以防您稍后想要回来查看结果。</p><p id="92b9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">取消意味着我不关心结果，如果在当前步骤完成后还有任何额外的步骤，不要运行它们。</p><p id="b90a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与我们的其他添加不同，添加取消支持需要修改我们现有的代码。这有道理；我们正在添加一种方法来中断以前无法中断的事情。幸运的是，Go的并发特性使得添加这种支持变得很容易。</p><p id="2dca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，我们需要在未来的界面中增加取消功能:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="57fe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有一点要明确的是<code class="du ls lt lu lv b">Cancel</code>不能阻止当前运行的函数完成；一旦一个函数开始执行，在函数之外你无法阻止它。我们所能做的就是立即停止等待它的结果，并阻止<code class="du ls lt lu lv b">Then</code>链中任何额外的项目运行。</p><p id="e2e8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，我们将修改<code class="du ls lt lu lv b">futureImpl</code>，并添加我们的<code class="du ls lt lu lv b">Cancel</code>和<code class="du ls lt lu lv b">IsCancelled</code>实现:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="c66c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们需要向<code class="du ls lt lu lv b">futureImpl</code>添加一个字段，这样我们就可以跟踪取消状态。<code class="du ls lt lu lv b">Cancel</code>和<code class="du ls lt lu lv b">IsCancelled</code>的实现非常简单。在<code class="du ls lt lu lv b">Cancel</code>中，我们仅在<code class="du ls lt lu lv b">cancel</code>通道尚未关闭且<code class="du ls lt lu lv b">done</code>尚未首先关闭的情况下关闭该通道。这两种方法都利用了<code class="du ls lt lu lv b">select</code>中的<code class="du ls lt lu lv b">default</code>子句来确保有立即的响应。</p><p id="b29b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可能会注意到<code class="du ls lt lu lv b">futureImpl</code>中添加了另一个新字段。Go对频道的一个规则是多次关闭一个频道会导致恐慌。由于死机会杀死正在运行的应用程序，我们需要确保我们的<code class="du ls lt lu lv b">cancel</code>通道只关闭一次。如果多个goroutines都同时在同一个未来调用<code class="du ls lt lu lv b">Cancel</code>，那么有可能不止一个goroutines会在select中成为默认情况。</p><p id="ddd7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go标准库有解决这个问题的方法。它包括一个名为sync.Once的类型，将取消通道关闭包装在一个由sync调用的闭包中。Once.Do方法确保只有一个goroutine会真正关闭通道，不管是否有许多go routine同时尝试这样做。</p><p id="0da2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了填充和使用<code class="du ls lt lu lv b">cancel</code>通道，我们需要修改<code class="du ls lt lu lv b">New</code>、<code class="du ls lt lu lv b">Then</code>、<code class="du ls lt lu lv b">Get</code>和<code class="du ls lt lu lv b">GetUntil</code>:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="2ea7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对<code class="du ls lt lu lv b">Get</code>和<code class="du ls lt lu lv b">GetUntil</code>的更改只是增加了对<code class="du ls lt lu lv b">cancel</code>通道的检查。对<code class="du ls lt lu lv b">New</code>的改动稍微复杂一些。我们想取消一次，影响未来整个链条。最简单的方法是让所有的期货都监听同一个取消频道。链中的初始条目没有取消通道，所以我们需要创建它。在<code class="du ls lt lu lv b">Then</code>中添加的所有后续<code class="du ls lt lu lv b">Steps</code>将使用为第一个未来创建的取消通道。</p><p id="3085" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">共享对同一通道的引用会将取消通道的状态广播给未来链中的所有步骤。因为关闭的通道总是立即返回，所以所有的goroutines都能够读取一个值而不会发生冲突。</p><p id="c519" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一些演示取消的示例代码:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="2357" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">你可以在Go游乐场的</em> <a class="ae ke" href="https://play.golang.org/p/JtdclgBHGc" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这个链接</em> </a> <em class="kf">运行这个代码。</em></p><h1 id="6db3" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">将未来置于背景中</h1><p id="a5f1" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">如果我们想要我们的直接功能之外的东西来触发取消呢？也许我们有一个请求应该只运行一定的时间。在这种情况下，我们应该使用上下文。Go 1.7将上下文添加到了1.7的标准库中。但这是什么呢？</p><p id="94c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上下文是围棋中两个重叠问题的解决方案:</p><ol class=""><li id="7571" class="le lf hh jk b jl jm jo jp jr lg jv lh jz li kd ly lk ll lm bi translated">如何支持goroutine局部变量？</li></ol><p id="44b8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">2.我如何给goroutine发信号让它停止工作？</p><p id="d09b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上下文是一个接口，提供对以下内容的访问:</p><ul class=""><li id="a593" class="le lf hh jk b jl jm jo jp jr lg jv lh jz li kd lj lk ll lm bi translated">从请求的早期阶段传递到后期阶段的键/值对(例如将用户放入身份验证处理程序中，并将其用作数据库查询的一部分)。</li><li id="57a5" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">一个done通道，当到了停止处理当前请求的时间或者当上下文被显式取消时关闭。</li><li id="eb13" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">一个截止日期，告诉你什么时候完成通道将关闭。</li><li id="eba8" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">一个告诉你为什么done通道被关闭的错误。context包包含创建带有期限和值的上下文的函数，以及访问上下文的cancel函数。</li></ul><p id="65a6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以利用上下文的取消支持来为我们的未来创建定时取消。只需为期货添加一个新的工厂函数，NewWithContext:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="5d7d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果为我们提供了一个设置了取消通道的上下文<em class="kf"> </em>，我们需要设置一个goroutine，在未来完成它的工作之前，等待查看上下文是否被取消。如果是的话，我们就触发未来的取消。</p><p id="ae01" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用它的代码如下所示:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="19d9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">你可以在Go游乐场的</em> <a class="ae ke" href="https://play.golang.org/p/1yZppI2E50" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这个链接</em> </a> <em class="kf">运行这个代码。</em></p><h1 id="d50f" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">未来扩展</h1><p id="90fe" class="pw-post-body-paragraph ji jj hh jk b jl kz ii jn jo la il jq jr lb jt ju jv lc jx jy jz ld kb kc kd ha bi translated">在其他未来的实现中还会发现其他的特性。有许多选项，但其中一些包括:</p><ul class=""><li id="0137" class="le lf hh jk b jl jm jo jp jr lg jv lh jz li kd lj lk ll lm bi translated">获取值和错误，并立即返回是否完成。</li><li id="dfee" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">只在出错时运行的阶段。</li><li id="022a" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">指定未来要运行的多个函数，并等待其中任何一个函数完成。</li><li id="8db9" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">指定未来要运行的多个函数，并等待所有函数完成。</li><li id="ce42" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated">将多个未来的值合并到一个未来。</li></ul><p id="7e19" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">添加这些特性超出了本文的范围，但是所有这些特性都可以通过使用我已经概述的构建模块来构建。通道、goroutines和selects允许我们使用简单的代码来构建这些复杂的结构，这些代码比大多数其他语言提供的线程和互斥体的集合更容易理解。</p><p id="7efe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果有人对使用这个未来图书馆感兴趣，Capital One已经开源了一个更高级的版本，可以在https://github.com/capitalone/go-future-context找到。请随意分叉它，并提交带有附加功能和错误修复的拉请求。</p><p id="4bd1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="kf">披露声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权是其各自所有者的所有权。本文为2017首都一。</em>T5】</strong></p><p id="d169" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">附加链接</strong></p><ul class=""><li id="d9f8" class="le lf hh jk b jl jm jo jp jr lg jv lh jz li kd lj lk ll lm bi translated"><a class="ae ke" rel="noopener" href="/capital-one-developers/buffered-channels-in-go-what-are-they-good-for-43703871828">缓冲通道——它们有什么用？</a></li><li id="2f7d" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated"><a class="ae ke" rel="noopener" href="/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5">闭包是Go的泛型</a></li><li id="d60b" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated"><a class="ae ke" rel="noopener" href="/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd">在Go中构建无界通道</a></li><li id="75d6" class="le lf hh jk b jl ln jo lo jr lp jv lq jz lr kd lj lk ll lm bi translated"><a class="ae ke" href="https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中构建REST API</a></li></ul></div></div>    
</body>
</html>