<html>
<head>
<title>New APIs in the Android Gradle Plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Gradle插件中的新API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/new-apis-in-the-android-gradle-plugin-f5325742e614?source=collection_archive---------0-----------------------#2020-07-29">https://medium.com/androiddevelopers/new-apis-in-the-android-gradle-plugin-f5325742e614?source=collection_archive---------0-----------------------#2020-07-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4f2da04570761ba8f65cac83f1062297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idoNj7WMAAZecVB0j6OL0A.png"/></div></div></figure><div class=""/><p id="074e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">与</em> <a class="jo jp ge" href="https://medium.com/u/c7609de1c53?source=post_page-----f5325742e614--------------------------------" rel="noopener" target="_blank">合著<em class="jn">杰罗姆·多切兹</em> </a></p><p id="3c54" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Gradle插件是Android应用程序支持的构建系统，支持编译许多不同类型的源代码，并将它们链接到一个可以在物理Android设备或仿真器上运行的应用程序中。</p><p id="00ce" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Gradle插件与Android Studio分离——Android Studio可以打开使用相应Android Gradle插件或任何以前稳定版本的项目，目前一直到Android Gradle插件1.1。</p><p id="0488" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Gradle和Android Gradle插件提供了根据用例以不同方式配置和扩展构建的能力。</p><p id="3068" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于配置主要是声明性的简单项目，Android Gradle插件可以在用<a class="ae ju" href="https://docs.gradle.org/current/userguide/groovy_build_script_primer.html" rel="noopener ugc nofollow" target="_blank"> Gradle构建语言</a>编写的<code class="du jq jr js jt b">build.gradle</code>文件中进行配置，或者在Groovy脚本之上构建的领域特定语言(DSL ),或者用最近引入的<a class="ae ju" href="https://docs.gradle.org/current/userguide/kotlin_dsl.html" rel="noopener ugc nofollow" target="_blank"> Gradle Kotlin DSL </a>编写的<code class="du jq jr js jt b">build.gradle.kts</code>文件。</p><p id="ab50" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Gradle Plugin DSL是在Gradle Kotlin DSL推出之前编写的，需要更新才能与Gradle Kotlin DSL配合使用。Android Gradle插件4.1现在完全支持新的Kotlin DSL。</p><p id="b656" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">DSL并不是扩展构建的唯一方式。为了在项目中重用，可以用Groovy或Kotlin编写脚本，并在多个构建文件中应用，但通常定制命令式逻辑的更好地方是<a class="ae ju" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" rel="noopener ugc nofollow" target="_blank"> buildSrc </a>，它可以使用Java、Groovy和Kotlin，并且为了在单独的项目中重用，或者可以通过用Java、Groovy或Kotlin编写的<a class="ae ju" href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:custom_plugins_standalone_project" rel="noopener ugc nofollow" target="_blank">二进制插件</a>定制构建。Android Gradle插件本身就是一个二进制插件。</p><p id="d49c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">许多构建作者希望扩展Android Gradle插件，例如通过以细粒度的方式配置特定的变体，生成有助于最终工件的附加工件或转换中间工件。Android Gradle插件已经为所有这些用例提供了API，但它们需要更新以兼容<a class="ae ju" href="https://docs.gradle.org/current/userguide/lazy_configuration.html" rel="noopener ugc nofollow" target="_blank"> Gradle的惰性配置</a>，并减少与Android Gradle插件内部实现细节的耦合，从而为未来的更大灵活性提供更好的基础。</p><h1 id="bdb4" class="jv jw hs bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">Android Gradle插件中的新特性:DSL接口和文档</h1><ul class=""><li id="79e2" class="kt ku hs ir b is kv iw kw ja kx je ky ji kz jm la lb lc ld bi translated">Android Gradle插件4.1包括从现有实现中提取的新DSL接口。</li><li id="387d" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">从这些接口中，<a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api" rel="noopener ugc nofollow" target="_blank">发布了Android Gradle插件的DSL和API的新文档</a>。</li><li id="7b71" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">为了更好地支持Kotlin脚本，现在Kotlin中提供了API和DSL接口，这导致我们对现有Kotlin脚本用户进行了一些突破性的更改。</li></ul><p id="73d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着Android Gradle插件周围的生态系统的增长，我们现有的DSL定义已经跟不上了。对于哪些API是稳定的，哪些是实验性的，没有一个明确的定义，更糟糕的是，一些内部实现细节泄露到了DSL和插件实现类的表面API中。此外，我们的文档生成器是Gradle的旧版本，缺少对Java 8语言特性和Kotlin的支持。</p><p id="1ece" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于构建作者与Android Gradle项目的API交互的各种方式的不同兼容性要求，清理这一切变得更具挑战性。简单的项目可能只使用Groovy DSL，有些项目已经采用了Kotlin DSL，有些项目使用buildSrc，同时使用Java和Kotlin，还有许多项目引入了二进制插件。在清理过程中，我们希望避免破坏与任何用例的兼容性，特别是Groovy DSL兼容性和插件的二进制兼容性。</p><p id="0411" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了保持二进制兼容性，我们必须保留现有的DSL实现类。我们决定在Kotlin的<code class="du jq jr js jt b">gradle-api</code>工件中创建接口，这些接口定义了DSL的所有公共函数，并由现有的实现类实现，目标是成为Android Gradle插件API的唯一真实来源。Android Gradle插件的<a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api" rel="noopener ugc nofollow" target="_blank">文档</a>现在直接从这些Kotlin接口生成，提供了一组文档，对每个使用或扩展Android Gradle插件的人都有帮助，无论是编写Groovy或Kotlin脚本，构建Src还是添加功能的二进制插件。</p><p id="5512" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中定义接口时，我们强制明确了几个关于空性和可变性的决定。从长远来看，这是非常有帮助的，但不幸的是，对于构建作者已经接受Gradle的Kotlin脚本支持的现有项目来说，这可能是一个源代码级别的突破性更改，虽然大多数突破会导致某些错误的源代码兼容性突破，这些错误在以前的版本中会表现为运行时错误，但在某些情况下，我们不得不决定对以前可以工作的东西进行突破性更改。我们希望通过现在进行这些改变，我们可以避免在未来做出这种突破性的改变。</p><p id="6032" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们被迫做出的最具挑战性的选择是如何表达在DSL中被设计为变异的集合类型。这些类型现在统一定义为<code class="du jq jr js jt b">val collection: MutableCollectionType</code>。</p><p id="7181" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着在Kotlin脚本中不能再为以前支持的收藏分配收藏，<code class="du jq jr js jt b">collection = collectionTypeOf(...)</code></p><p id="97b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，改变集合是统一支持的，所以<code class="du jq jr js jt b">collection += …</code>和<code class="du jq jr js jt b">collection.add(...) </code>现在应该可以在任何地方工作。</p><p id="947f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然Gradle Kotlin DSL和Gradle Groovy DSL看起来非常相似，但是有些在Groovy中符合人体工程学的构造在Kotlin脚本中并不适用。一个常见的例子就是使用<code class="du jq jr js jt b">=</code>操作符。大多数Android项目使用整数Android <code class="du jq jr js jt b">compileSdkVersion</code>，在Groovy脚本中，编写<code class="du jq jr js jt b">compileSdkVersion = 30</code>会导致调用<code class="du jq jr js jt b">setCompileSdkVersion(30)</code>。然而，对于一些带有预览版和插件的用例，编译sdk是一个字符串，例如<code class="du jq jr js jt b">compileSdkVersion = "android-R"</code>。在Groovy中，这只是映射到一个不同的<code class="du jq jr js jt b">setCompileSdkVersion(...)</code>方法，而在Kotlin中，我们被迫为属性分配一个类型。</p><p id="b7b8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android Gradle插件4.1中，我们引入了一些新的属性，使得用Kotlin脚本编写更加容易。我们期望大多数构建简单地使用<code class="du jq jr js jt b">var compileSdk: Int</code>，对于更特殊的情况，我们引入了<code class="du jq jr js jt b">var compileSdkPreview: String</code>和助手方法<code class="du jq jr js jt b">compileSdkAddon(vendor: <a class="ae ju" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html" rel="noopener ugc nofollow" target="_blank">String</a>, name: <a class="ae ju" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html" rel="noopener ugc nofollow" target="_blank">String</a>, version: <a class="ae ju" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html" rel="noopener ugc nofollow" target="_blank">Int</a>): <a class="ae ju" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html" rel="noopener ugc nofollow" target="_blank">Unit</a></code>。我们的目标是让这些新属性最终取代<code class="du jq jr js jt b">compileSdkVersion</code>，但是在社区迁移之前，它们将继续并肩工作。</p><h1 id="e7e5" class="jv jw hs bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">新变体API</h1><blockquote class="lj lk ll"><p id="e4cb" class="ip iq jn ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">更新:本节已经更新，以反映自最初发布以来API中命名的变化。</p></blockquote><p id="2efc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Gradle插件已经有了一个变体API，但是它的设计选择有一些限制。我们决定引入一个新的API来解决这些问题，提供一个更清晰的扩展模型，与Android Gradle插件的内部分离，而不是通过向现有API添加新的扩展性来继续积累技术债务。现有的API将暂时保留，我们将努力帮助插件和作者迁移到新系统。我们还发布了一个使用新变体和工件API的样本库<a class="ae ju" href="https://github.com/android/gradle-recipes" rel="noopener ugc nofollow" target="_blank">,我们将继续对其进行扩展。</a></p><p id="765a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与以前的API相比，新的变体API在配置期间运行得更早。这允许以影响构建流程的方式修改变体，不像以前的API，在以前的API中，这些决定在API运行时就已经做出了。这些改变既可以是显式的，允许设置影响构建流程的属性，也可以是隐式的，如果存在与变体API中公开的内容不兼容的优化，则可以简单地在使用该API的条件下完成。</p><p id="8ff0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">新的API进一步分成不同的回调，<code class="du jq jr js jt b">beforeVariants</code>和<code class="du jq jr js jt b">onVariants</code>，并分别用于测试组件<code class="du jq jr js jt b">beforeAndroidTest</code>和<code class="du jq jr js jt b">onAndroidTest</code>，以及<code class="du jq jr js jt b">beforeUnitTest</code>和<code class="du jq jr js jt b">onUnitTest</code>。</p><p id="5ecc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jq jr js jt b">beforeVariants</code>为将要创建的每个对象运行给定的操作。构建作者和插件作者可以使用它来定制影响整个构建流程的属性，<a class="ae ju" href="https://github.com/android/gradle-recipes/blob/agp-4.2/BuildSrc/testVariantFilteringOnBuildType/buildSrc/src/main/kotlin/CustomPlugin.kt" rel="noopener ugc nofollow" target="_blank">，例如是否启用了特定的变体或测试组件</a>。之后，调用<code class="du jq jr js jt b">onVariants</code>回调，允许构建作者和插件作者创建定制逻辑并注册消耗或修改构建中间产品的任务。</p><p id="17f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是Android项目构建所经历的各个阶段的概述:</p><ol class=""><li id="b577" class="kt ku hs ir b is it iw ix ja lp je lq ji lr jm ls lb lc ld bi translated">运行构建脚本，允许构建和插件配置Android Gradle插件DSL对象以及注册变体回调。</li><li id="50fb" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">Android Gradle插件结合了构建类型和产品风格来创建变体和测试组件。</li><li id="d229" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">为每个变量调用<code class="du jq jr js jt b">beforeVariants</code> API，允许变量设置的定制，为每个测试组件调用<code class="du jq jr js jt b">before[Android|Unit]Test</code> API。</li><li id="5710" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">为每个被启用的变体调用<code class="du jq jr js jt b">onVariants</code> API，为每个被启用的测试组件调用<code class="du jq jr js jt b">on[Android|Unit]Test</code> API，从而允许使用或修改构建中间产品的任务的注册。</li><li id="a454" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">Android Gradle插件在调用了<code class="du jq jr js jt b">before[Component]</code>和<code class="du jq jr js jt b">on[Component]</code>回调之后为变量注册任务。</li><li id="545d" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">使用注册的任务为每个变体调用先前的变体API。</li><li id="d118" class="kt ku hs ir b is le iw lf ja lg je lh ji li jm ls lb lc ld bi translated">Gradle计算任务图，构建可以开始执行。</li></ol><p id="0a69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jq jr js jt b">onVariants</code> API利用了<a class="ae ju" href="https://docs.gradle.org/current/userguide/lazy_configuration.html" rel="noopener ugc nofollow" target="_blank">的梯度属性和提供者</a>。属性允许延迟计算值，并在同一位置跟踪依赖信息，允许使用API，而不必担心任何特定属性的值何时已知。<code class="du jq jr js jt b">beforeVariants</code> API不使用属性，因为值是在配置时使用的，所以不会因为懒惰而受益。它确实受益于在配置期间更早地运行，这就是为什么它可以提供比以前的API更大的灵活性，以前的API受任务创建后运行的限制。</p><h2 id="127f" class="lt jw hs bd jx lu lv lw kb lx ly lz kf ja ma mb kj je mc md kn ji me mf kr mg bi translated">工件API</h2><p id="7ce6" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">Android Gradle插件的先前变体API暴露了构建的任务，以便允许构建的消费或扩展。例如，在Android Gradle Plugin 4.0中，为了将库的AAR输出应用到自定义任务，构建作者或插件作者可能已经编写了如下内容:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="cea3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这看起来很简单，特别是在这个小例子中，输出已经作为附带依赖信息的提供者可用，但这与产生最终AAR的任务的实现是紧密耦合的。如果代码被编译成二进制插件，它将阻止Android Gradle插件从任务中移除公共方法，改变任务的类型或将其拆分以改善构建流程。例如，我们考虑过从使用内置的Gradle Zip任务切换到构建AARs的自定义任务，但是我们还没有这样做，因为它破坏了常用的二进制插件。</p><p id="bdf5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的例子只获得定制任务消费的工件。如果可能的话，使用以前的API来替换或转换工件通常是非常脆弱的，因为它需要协调多个任务并更新工件的每个消费者。</p><p id="d832" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Android Gradle Plugin 4.2中的新构件API，您现在可以编写:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="e523" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的不同之处在于，对任务的引用消失了:API提供了更多的灵活性，同时也与Android Gradle插件中的内部实现解耦。</p><p id="5ff5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Gradle插件为所有输入、输出和中间文件管理附加到每个变体的工件的注册表，表示为附加了依赖信息的提供者。这个注册表在整个Android Gradle插件中使用，以取代任务的手动连接，并管理工件的位置，以避免意外冲突和不一致。</p><p id="d5fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些工件的子集通过新的变体属性API公开。</p><p id="a58a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个注册表的键是<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact" rel="noopener ugc nofollow" target="_blank">Artifact</a></code>的实例。无论工件是文件还是目录，都被表示为其类型的一部分。编写自定义任务时，使用正确的对应<code class="du jq jr js jt b"><a class="ae ju" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html" rel="noopener ugc nofollow" target="_blank">Property</a></code>，即<code class="du jq jr js jt b"><a class="ae ju" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/DirectoryProperty.html" rel="noopener ugc nofollow" target="_blank">DirectoryProperty</a></code>或<code class="du jq jr js jt b"><a class="ae ju" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/RegularFileProperty.html" rel="noopener ugc nofollow" target="_blank">RegularFileProperty</a></code>，这一点很重要。工件的基数也编码在它的类型中，当处理一个<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.MultipleArtifact" rel="noopener ugc nofollow" target="_blank">MultipleArtifact</a></code>类型时，必须使用特定的API与<code class="du jq jr js jt b"><a class="ae ju" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/ListProperty.html" rel="noopener ugc nofollow" target="_blank">ListProperty</a></code>交互。</p><p id="cb15" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">修饰工件的其他接口指出了可以在工件上执行的操作类型。这种操作允许定制任务通过用<a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.Replaceable" rel="noopener ugc nofollow" target="_blank">替换</a>、<a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.Transformable" rel="noopener ugc nofollow" target="_blank">转换</a>或<a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.Appendable" rel="noopener ugc nofollow" target="_blank">添加</a>工件来参与Android构建过程，所有这些都不需要具体了解参与构建过程的其他任务是如何生产或消费这些项目的。</p><p id="9ed0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在可以对工件进行的操作包括:</p><h2 id="71c3" class="lt jw hs bd jx lu lv lw kb lx ly lz kf ja ma mb kj je mc md kn ji me mf kr mg bi translated">得到</h2><p id="f24e" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">该操作获得工件的最终版本。不管工件是如何产生的，有时是如何被任务转换的，调用<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifacts.html#get(com.android.build.api.artifact.ArtifactType)" rel="noopener ugc nofollow" target="_blank">get</a></code>(或者<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifacts.html#getall" rel="noopener ugc nofollow" target="_blank">getAll</a></code>代表<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.MultipleArtifact" rel="noopener ugc nofollow" target="_blank">MultipleArtifact</a></code> s)将总是确保工件的最终版本被提供。它是一个只读值:不允许修改由<code class="du jq jr js jt b">get</code>获得的工件。因此，<code class="du jq jr js jt b">get</code>方法的返回类型是<code class="du jq jr js jt b">Provider</code>而不是<code class="du jq jr js jt b">Property</code>。这个<code class="du jq jr js jt b">Provider</code>只能作为任务输入。</p><p id="81a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，您可能对访问合并后的清单感兴趣，不是为了修改它，而是为了确保权限没有改变:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="e2a5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在您可以连接您的任务:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="d8f5" class="lt jw hs bd jx lu lv lw kb lx ly lz kf ja ma mb kj je mc md kn ji me mf kr mg bi translated">转换</h2><p id="d442" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">这个操作以某种方式修改了工件。原始工件作为给定任务的输入，以及输出转换后工件的新位置。</p><p id="fbdd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个通过将版本设置为git head value来转换合并清单的任务。</p><p id="771c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，让我们定义将计算git头的任务:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="678e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，创建一个任务，它将使用前一个任务计算的git版本来转换清单文件。</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="db2f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">布线清楚地表明了意图:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="e075" class="lt jw hs bd jx lu lv lw kb lx ly lz kf ja ma mb kj je mc md kn ji me mf kr mg bi translated">附加</h2><p id="84bf" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">Append只与用MultipleArtifact修饰的工件类型相关。因为这种类型被表示为目录或正则文件的列表，所以任务可以声明将被附加到列表的输出。</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="4087" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接线与其他操作类似:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="8ee4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，在这一点上，我们还没有发布一个公共的<code class="du jq jr js jt b"><a class="ae ju" href="https://developer.android.com/reference/tools/gradle-api/com/android/build/api/artifact/Artifact.MultipleArtifact" rel="noopener ugc nofollow" target="_blank">MultipleArtifact</a></code>工件，所以这个API只会在将来变得有用。</p><h2 id="5bfe" class="lt jw hs bd jx lu lv lw kb lx ly lz kf ja ma mb kj je mc md kn ji me mf kr mg bi translated">创造</h2><p id="5e41" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">这个操作用一个新的提供者替换一个工件的当前提供者，放弃所有以前的生产者。这是一个“out”操作，任务声明自己是工件的唯一提供者。如果有多个任务声明自己是工件提供者，那么最后一个任务获胜。</p><p id="887a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，自定义任务可能不使用内置的清单合并，而是依赖于签入源代码管理工具的手动合并的清单。</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="2db0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">连线至:</p><figure class="mk ml mm mn fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="6c94" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个定制任务正在创建一个工件时，该工件的所有原始生产者/转换者都不会成为构建过程的一部分，除非需要产生另一个工件。我们不期望很多构建使用这一点，因为我们考虑的大多数用例将通过转换得到更好的服务。如果你发现自己正在使用creation解决Android Gradle插件中的一个限制，请<a class="ae ju" href="https://developer.android.com/studio/report-bugs#build-bugs" rel="noopener ugc nofollow" target="_blank">提交一个问题或功能请求</a>。</p><p id="eb47" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过关注工件而不是任务，定制插件或构建脚本可以安全地扩展Android Gradle插件，而不会受到构建流程变化或任务实现等私有细节的影响，我们希望这些变化意味着构建作者可以在未来更容易地升级他们的Gradle插件。</p><p id="e1c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们计划在即将到来的版本中允许更多的变体配置，并使更多的工件作为公共类型可用，我们将继续添加更多的<a class="ae ju" href="https://github.com/android/gradle-recipes/" rel="noopener ugc nofollow" target="_blank">示例</a>。</p></div></div>    
</body>
</html>