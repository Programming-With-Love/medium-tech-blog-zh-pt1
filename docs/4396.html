<html>
<head>
<title>Kotlin Native. New Memory management Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林本地人。新的内存管理模型</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/kotlin-native-new-memory-management-model-7191fa30db30?source=collection_archive---------1-----------------------#2021-12-06">https://medium.com/google-developer-experts/kotlin-native-new-memory-management-model-7191fa30db30?source=collection_archive---------1-----------------------#2021-12-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/9982e95287268f37c04f2aa5884cbc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tUyPsjM8mctWV9pIrbZKkw.png"/></div></figure><div class=""/><p id="1caa" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在之前的帖子中，我们描述了如何使用本地并发机制<a class="ae jk" rel="noopener" href="/p/373663bf5a09/"><em class="jj"/></a><em class="jj">和</em><a class="ae jk" rel="noopener" href="/google-developer-experts/kotlin-native-multithreading-without-coroutines-56599ea33620"><em class="jj"/></a><em class="jj">】。现在我们来谈谈新的内存管理模型。</em></p><p id="f6d5" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">8月31日，Jetbrains公司为Kotlin/Native推出了新的内存管理模型。主要关注点是线程安全、线程间的安全上下文和数据共享、内存泄漏修复以及无需使用特殊注释的工作。还有几个协程的改进。因为现在可以在不需要冻结的情况下在上下文之间切换。Ktor在新版本中支持所有这些更新。</p><p id="8c69" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们总结一下建议的内存模型的新特性:</p><p id="5db7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">1.无冻结的多线程()。据称，我们可以从代码中移除所有的freeze()块，甚至从后台工作人员中移除，并且可以在上下文和线程之间切换，而不会出现任何阻塞和问题。</p><p id="63f9" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.atomic references/FreezableAtomicReference不会产生任何泄漏。</p><p id="d1ca" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">3.使用全局常量时不需要ShareImmutable。</p><p id="ad64" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">4.Worker.execute的生成器不再返回依赖关系的孤立图。</p><p id="0d2b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">还有一些细微差别和副作用:</p><ol class=""><li id="bad8" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">我们仍然必须对原子引用使用freeze()。若要处理它，请改用FreezableAtomicReference。我们也可以用<strong class="in hp"> <em class="jj"> AtomicRef </em> </strong>从<strong class="in hp"> <em class="jj"> atomicfu </em> </strong>。</li></ol><p id="1fb7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.所有全局常量都是延迟启动的。在以前的版本中，所有的全局变量都在开始时立即初始化。在新版本中使用<strong class="in hp"><em class="jj">eagerinization</em></strong><em class="jj"/>来保持这样的行为。</p><p id="8c49" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">3.不能保证挂起函数会将完成处理程序返回到主线程中。所以我们需要将它包装在iOS的<em class="jj">dispatch queue . main . async {…}</em>中。</p><p id="bc47" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">4.<em class="jj">Swift/ObjC对象的Deinit </em>可以在其他线程中调用。</p><p id="1544" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">说到协程，也有一些改进和变化。您可以在支持新内存模型的特殊版本分支中查看它们:</p><p id="ab2a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">1.我们可以与工人、渠道和流程一起工作，而不会冻结。与native-mt版本相比，频道的所有内容可能会意外冻结。</p><p id="2e17" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.<em class="jj">调度员。默认</em>现在被绑定到全局队列。</p><p id="a057" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">3.<em class="jj"> newSingleThreadContext </em>和<em class="jj">newFixedThreadPoolContext</em>可用于创建新的协程调度程序，支持一个或几个工作者的池。</p><p id="8c19" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">4.<em class="jj">调度员。主</em>与<em class="jj">绑定<em class="jj">达尔文</em>的调度主队列</em>和其他本地平台的特殊工人。建议不要用于单元测试，因为在主线程队列中不会调用任何东西。</p><p id="41ec" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，有一堆不同的改进，变化，细微差别，也有一些性能缺陷和问题。所有这些都是已知的，并在文档中进行了描述<a class="ae jk" href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/NEW_MM.md" rel="noopener ugc nofollow" target="_blank">。目前它只是一个预览版本，而不是Alpha版本，Jetbrains命令仍然在改进和发展它。</a></p><p id="ad73" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">好了，让我们将所有新特性应用到我们的代码示例中。<br/>首先，我们将为协程和Kotlin安装正确的版本:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="a0fc" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从协程中添加正确的依赖关系:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="130b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jj">重要！您必须安装Xcode 12.5或更高版本。它与1 . 6 . 0-M1–139版本最低兼容。如果您已经安装了多个版本，您需要使用xcode-select切换到正确的版本。然后关闭Kotlin多平台项目，调用Invalidate cache并重启。</em></p><p id="80e2" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们将从非协同程序代码中删除所有的freeze()块:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="1f60" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从我们在NSUrlSession中使用的所有参数中删除所有的freeze()。记住，我们处理的是本地网络客户端:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="a83d" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们还需要从AtomicReference切换到FreezableAtomicReference:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="16dc" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将更改应用于代码:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="8a2c" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们的代码是干净和新鲜的，我们的应用程序在飞，尽管GC仍然不能完美地工作。<br/>现在让我们调整一下协程示例:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="19c7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将使用默认可用的标准调度程序。为了检查全局队列，我们需要从ioDispatcher输出一个关于协程上下文的信息。</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="1f7a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们从流和通道中移除所有的冻结()。</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="70f1" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它工作得又好又快。不要忘记在主线程中发送答案:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="6054" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jj">重要！为了防止iOS端的内存泄漏，在autoreleasepool </em>中用lot Swift/ObjC包装块会很有用</p><p id="f19a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们来查几个案例。我们将从MainScope发出请求，并使用<em class="jj"> newSingleThreadContext </em>指定一些其他后台调度程序:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="6f29" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">工作没有任何麻烦。似乎新的内存管理模型将是所有开发人员的完美解决方案，并简化我们的工作。</p><p id="459b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是！这可能是目前不支持新mm的库的一些问题。在某些情况下，可能会出现<em class="jj">invalidmatabilityexception</em>或<em class="jj"> FreezingException </em>。<br/>为了处理它们和<em class="jj">科特林1.6.0-M1 </em>或更新版本我们必须禁用嵌入式冻结:</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="1fed" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">更多信息请点击此处:<a class="ae jk" href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/NEW_MM.md" rel="noopener ugc nofollow" target="_blank">https://github . com/JetBrains/kot Lin/blob/master/kot Lin-native/NEW _ mm . MD</a></p><p id="45a8" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">部分片段示例:<br/><a class="ae jk" href="https://github.com/anioutkazharkova/kotlin_native_network_client/tree/feature/1.6-kn/sample" rel="noopener ugc nofollow" target="_blank">https://github . com/anioutkazharkova/kot Lin _ native _ network _ client/tree/feature/1.6-kn/sample</a></p></div></div>    
</body>
</html>