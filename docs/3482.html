<html>
<head>
<title>The JS Bifrost — Efficient Code with JS functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS Bifrost——带有JS函数的高效代码</h1>
<blockquote>原文：<a href="https://medium.com/globant/cleaner-code-with-javascript-functions-d08d3bb37836?source=collection_archive---------1-----------------------#2020-09-03">https://medium.com/globant/cleaner-code-with-javascript-functions-d08d3bb37836?source=collection_archive---------1-----------------------#2020-09-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5483" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解纯函数和高阶函数来编写最先进的代码！</h2></div></div><div class="ab cl iw ix go iy" role="separator"><span class="iz bw bk ja jb jc"/><span class="iz bw bk ja jb jc"/><span class="iz bw bk ja jb"/></div><div class="ha hb hc hd he"><p id="acb8" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">欢迎来到JS Bifrost，这是您通向上帝级JavaScript坚实基础的道路。这是该系列的第一篇文章。这篇文章是关于如何利用JavaScript函数生成高效代码的。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es jz"><img src="../Images/d23f4fac30fe04efd7dbebff1ccc9a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELWvf6PnEgpkacagUSa3NQ.png"/></div></div></figure><p id="d766" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">编程的技巧是将一组需求分解成一组<em class="kl">功能</em>和<em class="kl">数据结构</em>。</p><p id="e203" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">函数是编程的关键组成部分之一。它们被定义为执行特定的任务，并在被调用时反复执行。简单明了，对吧？</p><p id="2bce" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">但是…</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es km"><img src="../Images/f672f7dcc2b00d852769375ef7afcea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQ5B1lArEP7ZT7iDgKnYyw.jpeg"/></div></div></figure><blockquote class="kn ko kp"><p id="6407" class="jd je kl jf b jg jh ii ji jj jk il jl kq jn jo jp kr jr js jt ks jv jw jx jy ha bi translated">JavaScript最棒的地方是它的函数实现。它几乎把一切都做对了。但是，正如您应该预料到的那样，JavaScript并没有完全正确。— <strong class="jf hi">道格拉斯·克洛克福特，JavaScript:精彩部分</strong></p></blockquote><p id="7bf1" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">JavaScript一直都是这样的！！</p><p id="e164" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">让我们从一个非常实际的角度来探索函数，这样我们就在利用JavaScript的能力方面领先一步。</p><p id="bfe6" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">函数主要用于:</p><ul class=""><li id="a5b2" class="kt ku hh jf b jg jh jj jk jm kv jq kw ju kx jy ky kz la lb bi translated"><strong class="jf hi">动作</strong>:一个函数用于执行一系列<strong class="jf hi">动作</strong>，这些动作在我们的代码中是多余的。因此它也被称为<strong class="jf hi">程序</strong>。在需要执行特定过程(动作序列)的地方，可以调用它任意次。</li><li id="ece5" class="kt ku hh jf b jg lc jj ld jm le jq lf ju lg jy ky kz la lb bi translated"><strong class="jf hi">关联</strong>:函数<strong class="jf hi">根据其设计执行的动作，将</strong> <em class="kl">(映射)</em> <strong class="jf hi"> </strong>输入关联到输出。</li><li id="48b5" class="kt ku hh jf b jg lc jj ld jm le jq lf ju lg jy ky kz la lb bi translated"><strong class="jf hi">内部通信</strong>:一个功能也可用于<strong class="jf hi">通过输入和输出操作与系统的其他部分</strong>进行交互。</li></ul><p id="8dab" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">理解了函数的用法之后，让我们来讨论两种类型的函数，你应该知道这两种类型的函数可以用来编写更干净有效的代码。</p><h1 id="9951" class="lh li hh bd lj lk ll lm ln lo lp lq lr in ls io lt iq lu ir lv it lw iu lx ly bi translated">纯函数</h1><p id="e6ff" class="pw-post-body-paragraph jd je hh jf b jg lz ii ji jj ma il jl jm mb jo jp jq mc js jt ju md jw jx jy ha bi translated">纯粹的功能:</p><ul class=""><li id="5dd1" class="kt ku hh jf b jg jh jj jk jm kv jq kw ju kx jy ky kz la lb bi translated">总是为相同的输入提供相同的输出。</li><li id="afab" class="kt ku hh jf b jg lc jj ld jm le jq lf ju lg jy ky kz la lb bi translated">不会产生副作用。</li></ul><p id="931e" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">如果一个函数满足这两点，它就是一个纯函数。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div class="er es me"><img src="../Images/ac52df77d78d0591eb18680a8cc4dd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*-YvOvw7xuTF5oA30YEwQUw.jpeg"/></div></figure><p id="68ba" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">因此，纯函数是关于映射的。它会接受输入，如果输入重复，它会给你同样的输出，否则它会给你相应的输出。这意味着，如果一组输入存在一组输出，纯函数将输入映射到输出。</p><blockquote class="mf"><p id="ccd7" class="mg mh hh bd mi mj mk ml mm mn mo jy dx translated">一个纯函数独立于程序执行过程中的任何状态或数据变化。它必须只依赖于它的输入。</p></blockquote><p id="07a2" class="pw-post-body-paragraph jd je hh jf b jg mp ii ji jj mq il jl jm mr jo jp jq ms js jt ju mt jw jx jy ha bi translated">我们用一个例子来理解纯函数。</p><p id="dc3d" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">下面是一个简单的问候函数，它将人名作为输入。</p><pre class="ka kb kc kd fd mu mv mw mx aw my bi"><span id="0a6a" class="mz li hh mv b fi na nb l nc nd">const greeting = "Hello"</span><span id="a9ce" class="mz li hh mv b fi ne nb l nc nd">const greet = <em class="kl">person</em> =&gt; `${greeting} ${person}!`;</span><span id="7ed1" class="mz li hh mv b fi ne nb l nc nd">console.log(greet("Ashmit")); // "Hello Ashmit!"</span></pre><p id="b0ff" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">你可能认为这将每次在相同的输入上给出相同的输出！是的，没错！</p><p id="a3c1" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">但是它并不独立于函数之外发生的任何事情。如果我们将变量“greeting”更改为“Howdy ”,即使我们没有更改“greeting”函数的输入，输出也会发生变化。</p><pre class="ka kb kc kd fd mu mv mw mx aw my bi"><span id="cfb3" class="mz li hh mv b fi na nb l nc nd">const greeting = "Howdy"</span><span id="b411" class="mz li hh mv b fi ne nb l nc nd">const greet = <em class="kl">person</em> =&gt; `${greeting} ${person}!`;</span><span id="09ab" class="mz li hh mv b fi ne nb l nc nd">console.log(greet("Ashmit")); // "Howdy Ashmit!"</span></pre><p id="f1d8" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">一个纯函数应该<strong class="jf hi">独立于任何外部可变状态</strong>。它应该只依赖于它的输入。上面的场景使我们的功能变得不纯，因为它与外部可变世界的<em class="kl">交互</em>，这被称为<strong class="jf hi">副作用</strong>。</p><p id="c175" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">让我们来详细看看，对于纯函数，副作用实际上意味着什么。</p><h2 id="d046" class="mz li hh bd lj nf ng nh ln ni nj nk lr jm nl nm lt jq nn no lv ju np nq lx nr bi translated">副作用</h2><p id="ab4f" class="pw-post-body-paragraph jd je hh jf b jg lz ii ji jj ma il jl jm mb jo jp jq mc js jt ju md jw jx jy ha bi translated">副作用是函数内部与外界的任何交互。这可能是任何事情，从改变存在于函数外部的变量，或者从函数内部调用另一个方法，到从函数外部访问变量。</p><p id="622f" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">注意:如果一个纯函数调用一个纯函数，这不是副作用，调用函数仍然是纯的。</p><p id="cd57" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">让我们把<strong class="jf hi">不纯的</strong>‘greet’函数变纯，稍微修改一下。我们知道，纯粹的功能应该只依赖于输入，即使外面的世界着火了，它也应该工作。所以我们会这样做，</p><pre class="ka kb kc kd fd mu mv mw mx aw my bi"><span id="8707" class="mz li hh mv b fi na nb l nc nd">const greeting = "Hello"</span><span id="b6a0" class="mz li hh mv b fi ne nb l nc nd">const greet = (<em class="kl">greeting</em>, <em class="kl">person</em>) =&gt; `${greeting} ${person}!`;</span><span id="79b9" class="mz li hh mv b fi ne nb l nc nd">console.log(greet(greeting, "Ashmit"));// "Hello Ashmit!"</span></pre><p id="5377" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">现在我们的函数‘greet’是纯<strong class="jf hi">的</strong>，因为它<strong class="jf hi">只依赖于它的输入</strong>。它总是以相同的输入给出相同的输出。</p><h2 id="0c46" class="mz li hh bd lj nf ng nh ln ni nj nk lr jm nl nm lt jq nn no lv ju np nq lx nr bi translated">纯函数的好处</h2><ul class=""><li id="bba8" class="kt ku hh jf b jg lz jj ma jm ns jq nt ju nu jy ky kz la lb bi translated">纯函数一旦创建就可以立即测试，并且有助于维护和重构代码。</li><li id="027a" class="kt ku hh jf b jg lc jj ld jm le jq lf ju lg jy ky kz la lb bi translated">纯函数的输出可以被<strong class="jf hi">记忆</strong>，因为它们对于相同的输入总是给出相同的输出。这在<strong class="jf hi">动态编程</strong>中证明非常有用，在动态编程中，最佳子结构是必须的。</li></ul><p id="c8e3" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">纯函数的一个非常重要的用例是在<strong class="jf hi">Redux</strong>(react js的状态管理)中。<strong class="jf hi">减速器必须始终是纯函数</strong>,因为减速器对状态执行动作。如果对于应用状态的相同动作状态来说，还原剂是不纯的，那么它将产生不同的结果，因此将不能达到它的目的！<br/>(顺便说一句，如果你还不知道ReactJS，我强烈推荐你去学)</p><h1 id="417f" class="lh li hh bd lj lk ll lm ln lo lp lq lr in ls io lt iq lu ir lv it lw iu lx ly bi translated">高阶函数</h1><p id="d0b3" class="pw-post-body-paragraph jd je hh jf b jg lz ii ji jj ma il jl jm mb jo jp jq mc js jt ju md jw jx jy ha bi translated">JavaScript中广泛使用高阶函数。如果你用JavaScript编程已经有一段时间了，你可能已经在不知不觉中使用它们了。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es nv"><img src="../Images/010f4c2f689d61105858fb13c1b41c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyZ-bXf-1nOsIHb9QdK71A.png"/></div></div></figure><p id="f162" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">在JavaScript中，函数是<strong class="jf hi">第一类公民</strong>，我说的<em class="kl">第一类</em>，是指函数被视为值。所以它们也可以作为值传递。</p><p id="242a" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated"><strong class="jf hi">高阶函数<em class="kl"> </em> </strong>是承担其他函数的函数，要么将它们作为自变量，要么返回它们。因为JavaScript支持一级函数，所以我们利用这个工具来创建高阶函数。</p><blockquote class="mf"><p id="f861" class="mg mh hh bd mi mj mk ml mm mn mo jy dx translated">高阶函数允许我们抽象出<em class="nw">动作</em>，而不仅仅是值。</p></blockquote><p id="ef58" class="pw-post-body-paragraph jd je hh jf b jg mp ii ji jj mq il jl jm mr jo jp jq ms js jt ju mt jw jx jy ha bi translated">将另一个函数作为参数通常被称为<strong class="jf hi"> <em class="kl">回调函数</em> </strong>，因为它被高阶函数回调。这是JavaScript大量使用的一个概念。</p><p id="ca16" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">让我们用一个处理数组时经常使用的函数的例子来理解高阶函数- <strong class="jf hi"> Array.prototype.map()。</strong></p><p id="58b8" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated"><strong class="jf hi"> <em class="kl"> Map() </em> </strong>返回一个新数组，其中填充了对调用数组中的每个元素调用提供的函数(回调)的结果。基本上，<em class="kl"> map() </em>接受一个函数作为输入，并对数组的每个元素执行该函数。它返回一个用结果值填充的新数组。</p><p id="edd8" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">让我们看一个简单的例子。</p><pre class="ka kb kc kd fd mu mv mw mx aw my bi"><span id="d71b" class="mz li hh mv b fi na nb l nc nd">const double = n =&gt; n * 2; // Callback function</span><span id="9534" class="mz li hh mv b fi ne nb l nc nd">console.log([1, 2, 3, 4].map(double)); // [2, 4, 6, 8]</span></pre><p id="661c" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这里，<em class="kl"> map() </em>将“double”函数作为输入，使其成为高阶函数。同样，如果一个函数返回一个函数，那么它将是一个高阶函数。</p><h2 id="10aa" class="mz li hh bd lj nf ng nh ln ni nj nk lr jm nl nm lt jq nn no lv ju np nq lx nr bi translated">使用高阶函数的好处</h2><ul class=""><li id="1ee7" class="kt ku hh jf b jg lz jj ma jm ns jq nt ju nu jy ky kz la lb bi translated">我们可以创建更小的函数，只处理一部分逻辑。</li><li id="a354" class="kt ku hh jf b jg lc jj ld jm le jq lf ju lg jy ky kz la lb bi translated">我们可以用不同的更小更简单的函数来组合复杂的函数。这增加了代码的可重用性，减少了错误，使我们的代码更容易阅读和理解。</li></ul><p id="836c" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">像纯函数一样，Redux中也使用高阶函数。减速器只是一个函数，所以当我们将这种模式应用于减速器时，我们称它们为<strong class="jf hi">高阶减速器</strong>。</p><p id="0a4b" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">当你不得不在你的每一个减速器中复制逻辑时，这变得非常麻烦。<strong class="jf hi">高阶减速器</strong>通过在开关的默认情况下返回减速器，帮助我们减少负载。这样，我们可以将调用代理到原始的缩减器。由于reducers是纯函数，这创造了一个美丽的组合，产生了一个处理复杂代码的块，它具有纯函数的所有优点，但是更高阶。</p><h1 id="0f4d" class="lh li hh bd lj lk ll lm ln lo lp lq lr in ls io lt iq lu ir lv it lw iu lx ly bi translated">结束语</h1><p id="b562" class="pw-post-body-paragraph jd je hh jf b jg lz ii ji jj ma il jl jm mb jo jp jq mc js jt ju md jw jx jy ha bi translated">编写干净高效的代码是当前的需要。我们的代码应该精确有效。最大限度地利用语言的特性本身就是一个挑战。</p><blockquote class="kn ko kp"><p id="7ab4" class="jd je kl jf b jg jh ii ji jj jk il jl kq jn jo jp kr jr js jt ks jv jw jx jy ha bi translated">写干净的代码是你必须做的，这样你才能称自己为专业人士。没有任何合理的借口可以让你不尽力而为。罗伯特·c·马丁，《干净的代码:敏捷软件工艺手册》</p></blockquote><p id="a969" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">纯函数和<strong class="jf hi">高阶函数</strong>是JavaScript的两个这样的特性，它们将函数提升到了一个新的水平，为我们提供了交付清晰、干净和高效代码的工具。我们必须尽可能地将这些整合到我们的代码中，以提高我们编写的代码的质量。</p><p id="434f" class="pw-post-body-paragraph jd je hh jf b jg jh ii ji jj jk il jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated"><em class="kl">观看此空间，通过</em><strong class="jf hi"><em class="kl">“JS彩虹桥”在通往“神级JavaScript”的道路上取得更多进步。</em>T9】</strong></p></div><div class="ab cl iw ix go iy" role="separator"><span class="iz bw bk ja jb jc"/><span class="iz bw bk ja jb jc"/><span class="iz bw bk ja jb"/></div><div class="ha hb hc hd he"><h2 id="53de" class="mz li hh bd lj nf ng nh ln ni nj nk lr jm nl nm lt jq nn no lv ju np nq lx nr bi translated">参考资料:</h2><div class="nx ny ez fb nz oa"><a href="https://eloquentjavascript.net/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab dw"><div class="oc ab od cl cj oe"><h2 class="bd hi fi z dy of ea eb og ed ef hg bi translated">雄辩的JavaScript</h2><div class="oh l"><h3 class="bd b fi z dy of ea eb og ed ef dx translated">各种艺术家的插图:封面和章节插图。像素艺术在第7章和…</h3></div><div class="oi l"><p class="bd b fp z dy of ea eb og ed ef dx translated">eloquentjavascript.net</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kj oa"/></div></div></a></div><div class="nx ny ez fb nz oa"><a href="https://www.digitalocean.com/community/tutorials/redux-higher-order-reducers" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab dw"><div class="oc ab od cl cj oe"><h2 class="bd hi fi z dy of ea eb og ed ef hg bi translated">Redux | DigitalOcean中的高阶减速器</h2><div class="oh l"><h3 class="bd b fi z dy of ea eb og ed ef dx translated">在重置Redux状态中，我们看到了一种通过创建根reducer来重用reducer逻辑以重置状态的方法。但是…</h3></div><div class="oi l"><p class="bd b fp z dy of ea eb og ed ef dx translated">www.digitalocean.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo kj oa"/></div></div></a></div></div></div>    
</body>
</html>