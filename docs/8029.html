<html>
<head>
<title>Solr Anti-patterns — Part2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solr反模式—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/solr-anti-patterns-part2-ad6b15a6e991?source=collection_archive---------0-----------------------#2021-06-30">https://medium.com/walmartglobaltech/solr-anti-patterns-part2-ad6b15a6e991?source=collection_archive---------0-----------------------#2021-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="43eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<a class="ae jc" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">反模式</strong> </a>是对一个重复出现的问题的常见回应，这种回应通常是无效的，并且有可能产生非常不利的后果。</p><p id="b2a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是<a class="ae jc" href="https://dineshkumarnaik.medium.com/anti-patterns-in-solr-9361a9ae04e7" rel="noopener"> Solr反模式的延续—第1部分</a>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5b68ed678a3488b8e497efd5a9ce8f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIky-UG55AsZklqmkIeKGg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Image by <a class="ae jc" href="https://pixabay.com/users/davidzydd-985081/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2502391" rel="noopener ugc nofollow" target="_blank">David Zydd</a> from <a class="ae jc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2502391" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="e0d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">常见的反模式有:</p><h2 id="d5c8" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">1.过度伐木</h2><p id="1972" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Solr日志是了解系统中发生了什么的一个重要途径。有几种方法可以调整默认的<a class="ae jc" href="https://solr.apache.org/guide/8_8/configuring-logging.html" rel="noopener ugc nofollow" target="_blank">记录配置</a>。</p><p id="a863" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尝试记录所有内容会对集群的性能产生影响，因为它需要更多的资源和线程来记录所有调试/信息日志。</p><p id="96ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:将日志级别设置为warn/error，并启用<a class="ae jc" href="https://solr.apache.org/guide/8_8/configuring-logging.html#logging-slow-queries" rel="noopener ugc nofollow" target="_blank">慢速查询日志</a>来捕获运行时间超过指定时间的查询。</p><p id="45cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在调试任何问题时，您可以临时更改日志级别<a class="ae jc" href="https://solr.apache.org/guide/8_8/configuring-logging.html#temporary-logging-settings" rel="noopener ugc nofollow" target="_blank">并在捕获日志后将其恢复。</a></p><h2 id="4adc" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">2.过度缓存</h2><p id="5855" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">为了获得最佳的查询性能，Solr使用内存缓存来存储几条不同的信息。结果集、过滤器和文档字段都被缓存，以便可以快速处理后续的类似搜索。</p><p id="82e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">“大缓存”不过是“垃圾”的一个花哨词。</strong>如果您让对象在缓存中累积，Java虚拟机的垃圾收集器最终将不得不将其全部清除。拥有大量垃圾会增加垃圾收集的持续时间，并损害应用程序的响应能力。</p><p id="e21a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:</p><ol class=""><li id="29da" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">不要在筛选查询中保留提取大量记录集的子句/criteria，在主查询中使用包含大量记录集的子句来限制总体结果计数。</li><li id="a646" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">不要在过滤标准中保留动态子句，这将导致无效的缓存。</li><li id="1749" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在带有匹配文档子集的过滤查询中使用静态子句，以获得更好的查询性能。</li></ol><h2 id="0ece" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">3.频繁提交</h2><p id="618d" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">solr中有两种类型的提交:</p><ul class=""><li id="4605" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lh kz la lb bi translated"><strong class="ig hi">硬提交:</strong>这由solrconfig.xml中的&lt;自动提交&gt;选项或来自客户端的显式调用(通过浏览器、cURL或类似的SolrJ或HTTP)控制。硬提交会截断当前段，并在索引中打开一个新段。</li><li id="af80" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lh kz la lb bi translated"><strong class="ig hi">软提交:</strong>一种比硬提交(openSearcher=true)开销更低的操作，也使文档对搜索可见。软提交不会截断事务日志。</li></ul><p id="048b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">软提交“更便宜”，但仍然不是免费的。您应该使软提交间隔尽可能长，以获得最佳性能！</p><p id="bb80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:避免显式提交，并在solrconfig.xml中定义提交设置(<code class="du lj lk ll lm b">autoCommit and autoSoftCommit</code>)</p><h2 id="2f13" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">4.繁重的暖化查询</h2><p id="f4ab" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><em class="li">缓存预热查询</em>是一个预先配置的查询(在<em class="li"> solrconfig.xml </em>中)，它针对新的搜索者执行，以便填充新的搜索者的缓存。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/56ccb37d36867ed463f0beddaa8090fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25hiH8fBok60bmNHub_83w.png"/></div></div></figure><p id="be66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拥有复杂的或很多的暖化查询会导致打开新搜索者的长时间延迟。点击阅读更多关于温暖搜索者<a class="ae jc" href="https://solr.apache.org/guide/8_8/query-settings-in-solrconfig.html#maxwarmingsearchers" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="f067" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:</p><p id="46d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仔细使用这个特性经过全面测试后，Solr附带了warming queries部分的注释，如上例所示。最好保持这种状态。</p><p id="8a73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预热查询应该是您的应用程序经常使用的查询，并且足够快，不会对新的搜索者造成任何延迟。</p><h2 id="8532" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">5.布尔查询</h2><p id="bfe9" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Solr对布尔查询的术语数量有限制。你可以增加限制，如果你想，但它可以降低性能，由于大量的条款和得分开销。请阅读<a class="ae jc" href="https://dineshkumarnaik.medium.com/maxbooleanclauses-behavior-in-solr-7-x-vs-8-x-a02f9ec0f5af" rel="noopener">此处</a>了解更多详情。</p><p id="0997" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:如果您的布尔查询术语超过1000，请使用<a class="ae jc" href="https://solr.apache.org/guide/8_8/other-parsers.html#terms-query-parser" rel="noopener ugc nofollow" target="_blank">术语查询解析器</a>。</p><h2 id="0cc5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">6.带有嵌套文档的DBQ</h2><p id="ad60" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如果应用程序中有嵌套文档，应该避免DBQ(通过查询删除)。</p><p id="bdf4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嵌套文档可以根据应用程序的需要，通过添加包含更多或更少文档的新文档来简单替换。除了Solr注意确保现有版本的所有相关子文档都被删除之外，这方面与更新任何普通文档没有什么不同。</p><p id="bf2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要<strong class="ig hi">而不是</strong>添加一个具有相同子文档ID的根文档。<em class="li">这将违反Solr期望的完整性假设。</em>如果您尝试使用子文档的ID，将不会发生任何事情，因为只考虑根文档ID。</p><p id="666e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:要删除嵌套文档，可以通过根文档的ID来删除它。如果你使用Solr的查询删除API，你<strong class="ig hi">必须非常小心</strong>以确保没有任何子文档被删除。<em class="li">否则将违反Solr期望的完整性假设。</em></p><h2 id="0e76" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">7.多级旋转</h2><p id="5540" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Solr pivot分面或决策树分面或子分面用于提供更详细的索引数据视图。您可以计算父方面的子方面，或者生成树状数据结构并在应用程序中显示，这有助于做出更好的决策。</p><p id="e495" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一些用户需要深入了解数据的分析应用程序中，为了满足这种类型的要求，您可以对两个或三个以上的字段使用pivot faceting，但这并不是免费的，多级pivot需要更多的CPU和内存来进行计算。</p><p id="e0fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:尝试限制pivots、facet/pivot on docValue enabled字段的结果集数量，并使用<a class="ae jc" href="https://solr.apache.org/guide/8_8/json-facet-api.html" rel="noopener ugc nofollow" target="_blank"> json facet API </a>代替旧式的faceting。</p><h2 id="96dc" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">8.无模式模式</h2><p id="6480" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">无模式模式消除了在使用搜索之前设计模式的需要。这有助于您更快地使用搜索，但是无模式模式比使用特意设计的模式效率更低。</p><p id="f657" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这有可能索引每个字段(甚至是不可搜索的字段),从而导致性能下降。</p><p id="4fb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">无模式</strong>模式实际上是一种<strong class="ig hi">猜测字段并添加到模式</strong>模式。因此，当Solr看到一个新字段时，它会尝试猜测字段类型并将其添加到模式中。这种猜测通常不会针对每个字段进行优化。</p><p id="8072" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:</p><p id="159c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">坚持使用默认的非无模式模式。</p><p id="b7a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用动态字段/映射作为替代。</p><ol class=""><li id="03a9" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">动态字段允许Solr索引模式中没有明确定义的字段。</li><li id="1e66" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">当您忘记定义一个或多个字段时，请使用动态字段。</li><li id="3318" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">添加动态字段，通过为可以添加到Solr的文档提供灵活性，使应用程序不那么脆弱。</li></ol><h2 id="83c9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">9.对于写入量大的系统，没有节流</h2><p id="6169" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Solr承担了其他数据库不具备的功能，比如二级索引、非结构化文本搜索、刻面、枢轴、聚合、流式查询、词汇化、短语搜索等。这不是免费的。</p><p id="b67b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当数据进入集群时，必须维护和更改提供这些功能的索引。尤其是更新可能是一项开销很大的操作，给索引维护操作带来了额外的负担。因此，如果突发更新流量在接收前没有被抑制，Solr很容易被阻塞。</p><p id="56fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:通过在接收到Solr之前添加消息队列来抑制接收，并尽量避免大批量。</p><h2 id="5d48" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">10.高摄取期间的配置重新加载/上传</h2><p id="62ea" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">应避免在活动生产集群上进行配置上传或重新加载，因为副本可能会进入恢复阶段(根据索引大小恢复数据可能需要相当长的时间)。</p><p id="2aeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:停止正在进行配置上载/重新加载的集合的写入，或者在写入流量较低时在非工作时间执行此活动。</p><h1 id="bb76" class="lo ju hh bd jv lp lq lr jz ls lt lu kd lv lw lx kg ly lz ma kj mb mc md km me bi translated">结论</h1><p id="0602" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">避免这些反模式有助于我们通过减少CPU、内存、I/O操作等资源的使用，高效地管理许多不同规模和用例的关键集群。通过实施这些解决方案，您不仅可以节省运营成本，还可以提高集群性能和稳定性。</p></div></div>    
</body>
</html>