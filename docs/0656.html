<html>
<head>
<title>Pushing the right buttons in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中按右按钮</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/pushing-the-right-buttons-in-jetpack-compose-124cb4b17197?source=collection_archive---------0-----------------------#2021-08-13">https://medium.com/androiddevelopers/pushing-the-right-buttons-in-jetpack-compose-124cb4b17197?source=collection_archive---------0-----------------------#2021-08-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/55dba42507fbdc7b10af4f31524ded2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1_mgbHto-Mlo6NqzGc9OQ.png"/></div></div></figure><div class=""/><p id="3314" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">以下帖子由Jetpack Compose团队的Louis Pullen-Freilich(软件工程师)、</em><a class="ae jo" href="https://twitter.com/matvei_jj" rel="noopener ugc nofollow" target="_blank"><em class="jn">mat vei Malkov</em></a><em class="jn">(软件工程师)和</em><a class="ae jo" href="https://twitter.com/p3srini?lang=en" rel="noopener ugc nofollow" target="_blank"><em class="jn">Preethi Srinivas</em></a><em class="jn">(UX研究员)撰写。</em></p><p id="26d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Jetpack Compose最近<a class="ae jo" href="https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html" rel="noopener ugc nofollow" target="_blank">发布了</a> 1.0，带来了一组稳定的API来构建ui。今年早些时候，我们发布了我们的<a class="ae jo" href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md" rel="noopener ugc nofollow" target="_blank"> API指南</a>，概述了编写Jetpack Compose APIs的最佳实践和API设计模式。这些指导方针是我们的API表面上多次迭代的结果，但是没有显示这些模式是如何出现的，也没有显示我们做出决策背后的推理。</p><p id="73c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">今天，我们将带您经历一个相对“简单”的组件<code class="du jp jq jr js b">Button</code>的进化之旅，让您深入了解我们是如何将API设计得既易用又灵活的。这需要根据开发人员的反馈对API的可用性进行一些调整和改进。</p><h1 id="8cf0" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">绘制可点击的矩形</h1><p id="caef" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">谷歌Android Toolkit团队有一个内部笑话，我们所做的一切只是在屏幕上画一个彩色矩形，并让它点击。事实证明，这是UI工具包中最难做到的事情之一。</p><p id="f57c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">人们可能会认为按钮是一个简单的组件——一个带有单击监听器的彩色矩形。有许多不同的事情使得设计<code class="du jp jq jr js b">Button</code> API变得复杂:可发现性、参数的顺序和命名等等。一个额外的约束是灵活性:<code class="du jp jq jr js b">Button</code>提供了许多参数，以便开发人员可以根据自己的喜好定制单个元素。默认情况下，一些参数使用主题中的值，而一些参数可以依赖于其他参数的值。这些结合起来使得设计<code class="du jp jq jr js b">Button</code> API成为一个有趣的挑战。</p><p id="e1b7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两年前，我们在第一次迭代<code class="du jp jq jr js b">Button</code> API时，从<a class="ae jo" href="https://github.com/androidx/androidx/commit/d4f91b3a79ced7473e21c7c000edd469d24c318b" rel="noopener ugc nofollow" target="_blank">公共提交</a>开始:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Initial Button API</figcaption></figure><p id="d494" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了名字之外，<code class="du jp jq jr js b">Button</code> API的最初形式与我们已经确定的最终版本几乎没有共同之处。它已经发展了许多次，我们将带你经历这些。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">1.0 Button API</figcaption></figure><h1 id="366b" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">获取开发人员的反馈</h1><p id="3ae6" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">在Compose的研究和实验阶段，我们的<code class="du jp jq jr js b">Button</code>组件接受了一个<code class="du jp jq jr js b">ButtonStyle</code>参数。<code class="du jp jq jr js b">ButtonStyle</code>为<code class="du jp jq jr js b">Button</code>建模的视觉配置，如颜色、形状等。这使我们能够表示三种不同的<a class="ae jo" href="https://material.io/components/buttons" rel="noopener ugc nofollow" target="_blank">材料按钮类型</a>(包含、概述&amp;文本)；我们简单地公开了顶级构建器函数，这些函数返回与材料规范中的按钮类型相对应的<code class="du jp jq jr js b"><a class="ae jo" href="https://github.com/androidx/androidx/commit/401f755476bfb330bcf4580709a86b170f1c9442" rel="noopener ugc nofollow" target="_blank">ButtonStyle</a></code>实例。开发人员可以选择这些内置样式中的一个进行小的调整，或者通过从头开始创建一个新的<code class="du jp jq jr js b">ButtonStyle</code>来完全定制一个<code class="du jp jq jr js b">Button</code>。我们对最初版本的<code class="du jp jq jr js b">Button</code> API感到满意——这是一个可重用的API，包含易于使用的风格。</p><p id="8051" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了验证我们的假设和设计方法，我们邀请开发人员参加编码会议，使用<code class="du jp jq jr js b">Button</code> API完成简单的编程练习。编程练习包括构建这个屏幕:</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es lg"><img src="../Images/4183e02c10613f5aea414dcf8f56da2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*IZIDONCp0W0tvekWITATXA.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx">The screen of the <a class="ae jo" href="https://material.io/design/material-studies/rally.html" rel="noopener ugc nofollow" target="_blank">Rally</a> Material Study that developers were tasked to build</figcaption></figure><p id="27ea" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<a class="ae jo" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.222.7327&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">认知维度框架</a>对这些编码会话中的观察结果进行审查，以便<a class="ae jo" href="https://cacm.acm.org/magazines/2016/6/202645-improving-api-usability/fulltext" rel="noopener ugc nofollow" target="_blank">评估<code class="du jp jq jr js b">Button</code> API的可用性</a>。</p><p id="24f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们立即在这些会话中观察到一个有趣的模式——一些开发人员开始使用<code class="du jp jq jr js b">Button</code> API:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Using the Button API</figcaption></figure><p id="e18f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其他人试图创建一个<code class="du jp jq jr js b">Text</code>组件并用圆角矩形包围它:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Adding Padding around some Text to try and emulate a Button</figcaption></figure><p id="fe31" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当时，使用样式API如<code class="du jp jq jr js b">themeShape</code>或<code class="du jp jq jr js b">themeTextStyle</code>需要前面的<code class="du jp jq jr js b">+</code>操作符。这是由于当时Compose运行时的某些限制造成的。开发人员研究表明，开发人员发现很难知道运营商做了什么。从这一观察中得到的一个重要结论是，API设计者无法直接控制的方面会影响人们对API的看法。例如，我们听到一位开发人员对运营商做出了如下评论:</p><blockquote class="lh"><p id="b274" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="lr">“据我所知，这是重用现有的样式，或者在它的基础上进行扩展”</em></p></blockquote><p id="72d2" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">大多数开发人员指出了组合API之间的不一致性——例如，用于样式化<code class="du jp jq jr js b">Button</code>的技术与样式化<code class="du jp jq jr js b">Text</code>组件的技术不同。</p><p id="584d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，我们观察到大多数开发人员在将圆角边框应用到<code class="du jp jq jr js b">Button</code>时遇到了很大的困难，这是一项人们认为非常简单的编码任务。通常，他们深入实现的多个层次来理解API结构。</p><blockquote class="lh"><p id="2748" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="lr">“我只是在这里随便放些东西，绝对不相信这能成功”</em></p></blockquote><figure class="lx ly lz ma mb hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Correctly customizing a Button’s text style, color, and shape</figcaption></figure><p id="3be8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这影响了开发人员如何将样式应用于一个<code class="du jp jq jr js b">Button</code>。例如，<code class="du jp jq jr js b">ContainedButtonStyle</code>并没有映射到开发者在为Android应用程序实现按钮时已经知道的东西。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="mc lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Early insights from developer research</figcaption></figure><p id="96e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从编码会议中，我们了解到我们需要简化<code class="du jp jq jr js b">Button</code> API，以便更容易实现简单的定制，同时仍然支持复杂的用例。我们从可发现性和可定制性开始，这给我们带来了下一组挑战:<em class="jn">样式</em>和<em class="jn">命名</em>。</p><h1 id="5b9a" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">维护API一致性</h1><p id="0cfe" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">在我们的编码会议中，样式给开发人员带来了很多问题。为了理解其中的一些，让我们后退一步，评估一下为什么样式作为一个概念存在于Android框架和其他工具包中。</p><p id="91fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<em class="jn">‘style’</em>本质上是一个UI相关属性的集合，可以应用于一个组件，比如一个<code class="du jp jq jr js b">Button</code>。样式有两个主要好处:</p><p id="764a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.将UI配置与业务逻辑分离</p><p id="6fe5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在命令式工具包中，能够独立定义样式有助于分离关注点，并使代码更容易阅读:UI可以在一个地方定义，如XML文件，回调和业务逻辑可以分别定义和附加。</p><p id="fcfb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在诸如Compose这样的声明性工具包中，业务逻辑和UI在设计上耦合较少。像<code class="du jp jq jr js b">Button</code>这样的组件大多是无状态的，只显示您传递给它们的数据，而不需要在新值到达时更新内部状态。因为组件只是函数，所以可以通过向<code class="du jp jq jr js b">Button</code>函数传递一个参数来进行定制，就像对任何其他函数一样。但是这使得UI配置和行为配置的分离变得困难。例如，在<code class="du jp jq jr js b">Button</code>上设置<code class="du jp jq jr js b">enabled = false</code>不仅可以控制<code class="du jp jq jr js b">Button</code>的行为，还可以控制<code class="du jp jq jr js b">Button</code>的外观。</p><p id="e808" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就引出了一个问题:<code class="du jp jq jr js b">enabled</code>应该是一个顶级参数还是应该作为一个属性在样式中传递？其他可以应用于<code class="du jp jq jr js b">Button</code>的样式呢，比如提升，或者当<code class="du jp jq jr js b">Button</code>被按下时颜色的变化？设计可用API的核心原则是保持一致性；我们认识到确保不同UI组件之间的API一致性是非常重要的。</p><p id="ef92" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.自定义一个组件的多个实例</p><p id="079c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在经典的Android <code class="du jp jq jr js b">View</code>系统中，样式是有益的，因为创建一个新组件的成本非常高:你需要创建一个子类，实现构造函数，应用自定义属性。样式允许以更简洁的方式表达一组共享的属性。例如，考虑创建一个<code class="du jp jq jr js b">LoginButtonStyle</code>来定义应用程序中所有登录按钮的外观。在Compose中，可能如下所示:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Defining a style for a login button</figcaption></figure><p id="ea4a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jp jq jr js b">LoginButtonStyle</code>现在可以在用户界面的多个<code class="du jp jq jr js b">Button</code>中重用，而不需要在每个<code class="du jp jq jr js b">Button</code>上显式设置所有这些参数。但是，如果您也想提取文本，所以每个登录按钮都有相同的文本:<em class="jn">“log in”</em>怎么办？</p><p id="cce0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Compose中，每个组件都是一个函数，所以这里自然的解决方案是定义一个函数，在内部调用<code class="du jp jq jr js b">Button</code>，并向<code class="du jp jq jr js b">Button</code>提供正确的文本:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Creating a semantically meaningful LoginButton function</figcaption></figure><p id="77ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于组件的无状态特性，以这种方式提取函数的成本非常低:参数可以直接从包装函数传递到内部按钮。而且由于你不是在扩展一个类，你只需要公开你想要的参数；其他一切都可以放在<code class="du jp jq jr js b">LoginButton</code>的实现内部，防止颜色和文本被覆盖。这种方法允许比仅使用一种样式更大范围的定制。</p><p id="9617" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，创建一个<code class="du jp jq jr js b">LoginButton</code>函数比将一个<code class="du jp jq jr js b">LoginButtonStyle</code>传递给一个<code class="du jp jq jr js b">Button</code>函数在语义上更有意义。我们还从研究会议中观察到，独立的函数比样式更容易被发现。</p><p id="ac62" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">没有样式，<code class="du jp jq jr js b">LoginButton</code>现在可以被重构，直接将参数传递给底层的<code class="du jp jq jr js b">Button</code>，而不需要样式对象，与任何其他定制一致:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">The final LoginButton implementation</figcaption></figure><p id="3630" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们<a class="ae jo" href="https://github.com/androidx/androidx/commit/e386f97dd769da18d9f3103958714e43d797219f" rel="noopener ugc nofollow" target="_blank">移除了样式</a>并将参数直接平铺到组件中——这既是为了与整体组合理念保持一致，也是为了鼓励开发人员创建语义上有意义的“包装”函数:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">OutlinedButton in 1.0</figcaption></figure><h1 id="2e1a" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">提高API的可发现性或可见性</h1><p id="99e3" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">我们还在研究中观察到一个重大缺陷，即如何将形状应用于按钮。为了定制<code class="du jp jq jr js b">Button</code>的形状，开发人员可以使用shape参数，该参数接受一个<code class="du jp jq jr js b">Shape</code>对象。负责创建具有捷径的按钮的开发人员通常采用这种方法:</p><ol class=""><li id="7544" class="md me hs ir b is it iw ix ja mf je mg ji mh jm mi mj mk ml bi translated">使用默认值创建一个简单的<code class="du jp jq jr js b">Button</code></li><li id="8f09" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated">从<code class="du jp jq jr js b">MaterialTheme.kt</code>源文件中寻找一些与形状主题相关的线索</li><li id="fad7" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated">查看<code class="du jp jq jr js b">MaterialButtonShapeTheme</code>功能</li><li id="4d51" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated">确定<code class="du jp jq jr js b">RoundedCornerShape</code>，并尝试使用类似的方法创建一个带有切角的形状</li></ol><p id="d578" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数开发人员在这一点上迷失了，当审查API和源代码时，他们经常会被自己所经历的深度所淹没。我们观察到开发人员在发现<code class="du jp jq jr js b">CutCornerShape</code>时遇到了很大的困难，因为它是在一个独立于其他shape APIs的包中公开的。</p><p id="1af2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可见性是对开发人员定位完成目标所需的功能或参数的难易程度的一种度量。它与编码时所需的认知努力直接相关；寻找和使用方法的搜索路径越长，API就越不可见。因此，这会导致开发人员的工作效率和满意度降低。基于这种认识，我们<a class="ae jo" href="https://github.com/androidx/androidx/commit/468c797c109cf24a561dad6a496310964d2a4a2b" rel="noopener ugc nofollow" target="_blank">将CutCornerShape </a>移到了与其他shape APIs相同的包中，以支持轻松发现。</p><h1 id="6a83" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">映射到开发人员的工作框架</h1><p id="798c" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">现在是时候获得更多反馈了——我们在一系列进一步的编码会议中回头评估了<code class="du jp jq jr js b">Button</code> API的可用性。在这些会议中，我们按照材料设计规范中的规定准确命名按钮:<code class="du jp jq jr js b">Button</code>变成了<code class="du jp jq jr js b">ContainedButton</code>以符合规范。然后我们测试了新的命名以及当时我们拥有的<code class="du jp jq jr js b">Button</code>的整体API。评估了两个主要的开发者目标:</p><ul class=""><li id="bae9" class="md me hs ir b is it iw ix ja mf je mg ji mh jm mr mj mk ml bi translated">创建一个<code class="du jp jq jr js b">Button</code>并处理点击事件</li><li id="48d8" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mr mj mk ml bi translated">使用预定义的材质主题设计<code class="du jp jq jr js b">Button</code>的样式</li></ul><figure class="kw kx ky kz fd hj er es paragraph-image"><a href="https://material.io/components/buttons"><div class="er es ms"><img src="../Images/92224d56ad91c00748de034334b3a9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TOS6monPPA5U36jL"/></div></a><figcaption class="lc ld et er es le lf bd b be z dx">Material Buttons from material.io</figcaption></figure><p id="fad9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们从这些会议中得到的一个关键见解是，大多数开发人员不熟悉用于材质按钮的命名约定。例如，许多人无法区分<code class="du jp jq jr js b">ContainedButton</code>和<code class="du jp jq jr js b">OutlinedButton</code>:</p><blockquote class="lh"><p id="ebb0" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="lr">“contained button是什么意思？”</em></p></blockquote><p id="fdfb" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们观察到开发人员在输入<code class="du jp jq jr js b">Button</code>时花费了相当多的精力猜测，并看到自动完成提示了三个<code class="du jp jq jr js b">Button</code>组件。大多数开发人员希望默认为<code class="du jp jq jr js b">ContainedButton</code>，因为它是最常用的，也是最像“按钮”的。很明显，我们需要一个开发人员可以使用的默认值，而不需要阅读材料设计指南。另外，基于视图的<a class="ae jo" href="https://github.com/material-components/material-components-android" rel="noopener ugc nofollow" target="_blank"> MDC-Android </a> <code class="du jp jq jr js b">Button</code>默认为一个包含的按钮，所以这里也有使用它作为默认按钮的先例。</p><h1 id="8856" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">更清晰地表达角色</h1><p id="d584" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">研究中的另一个困惑点是存在两个版本的<code class="du jp jq jr js b">Button</code>:一个<code class="du jp jq jr js b">Button</code>接受文本的<code class="du jp jq jr js b">String</code>参数，另一个<code class="du jp jq jr js b">Button</code>接受表示一般内容的可组合lambda参数。这里的目的是在两个不同的层中提供API:</p><ul class=""><li id="cbba" class="md me hs ir b is it iw ix ja mf je mg ji mh jm mr mj mk ml bi translated">一个更简单的带文本的<code class="du jp jq jr js b">Button</code>，更容易实现</li><li id="7a7d" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mr mj mk ml bi translated">一个更高级的<code class="du jp jq jr js b">Button</code>，对放在里面的内容不那么固执己见</li></ul><p id="a2fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们观察到开发人员在选择一个而不是另一个时遇到了困难:<code class="du jp jq jr js b">String</code>重载开始很简单，但是当从<code class="du jp jq jr js b">String</code>重载转移到lambda重载时，定制<em class="jn">“悬崖”</em>的存在使得增量定制<code class="du jp jq jr js b">Button</code>变得很有挑战性。我们从开发人员那里听到的一个常见请求是用<code class="du jp jq jr js b">String</code>重载为<code class="du jp jq jr js b">Button</code>添加一个<code class="du jp jq jr js b">TextStyle</code>参数:</p><blockquote class="lh"><p id="19f9" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="lr">它将允许定制内部文本样式，而不必使用lambda重载。</em></p></blockquote><p id="6322" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们提供<code class="du jp jq jr js b">String</code>重载的目的是使<em class="jn">最简单的用例变得简单</em>，但是这阻碍了开发人员使用带有可组合lambda的重载，导致对<code class="du jp jq jr js b">String</code>重载的额外功能的请求。这两种独立的API形状的存在不仅让开发人员感到困惑，而且很明显,“原始”重载存在一些根本性的问题:那些接受原始类型(如<code class="du jp jq jr js b">String</code>而不是可组合的lambdas)的重载。</p><h2 id="ab38" class="mt ju hs bd jv mu mv mw jz mx my mz kd ja na nb kh je nc nd kl ji ne nf kp ng bi translated">逐句通过代码</h2><p id="d2e5" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">一个原始的<code class="du jp jq jr js b">Button</code>重载直接接受文本作为参数，减少了开发人员创建一个包含文本的<code class="du jp jq jr js b">Button</code>所需的代码量。我们从简单的<code class="du jp jq jr js b">String</code>文本参数开始，但是认识到<code class="du jp jq jr js b">String</code>没有为文本的不同部分提供单独的样式。</p><p id="78ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这个用例，Compose提供了<code class="du jp jq jr js b">AnnotatedString</code> API，它允许开发人员对一些文本的不同部分应用定制样式。然而，这为简单用例增加了一些开销，因为开发人员首先需要将他们的简单<code class="du jp jq jr js b">String</code>转换成一个<code class="du jp jq jr js b">AnnotatedString</code>。这让我们质疑我们是否应该为<code class="du jp jq jr js b">Button</code>重载提供<em class="jn"/><code class="du jp jq jr js b">String</code>和<code class="du jp jq jr js b">AnnotatedString</code>参数来支持简单和更高级的情况。</p><p id="e873" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于图像和图标，我们的API设计讨论更加复杂，比如在<code class="du jp jq jr js b">FloatingActionButton</code>中使用时。<code class="du jp jq jr js b">icon</code>参数的类型应该是<code class="du jp jq jr js b">Vector</code>还是<code class="du jp jq jr js b">Bitmap</code>？如何支持动画图标？即使我们尽了最大努力，我们认识到我们只能支持Compose中可用的类型——任何第三方图像类型都需要开发人员自己编写支持这些类型的重载。</p><h2 id="9dc6" class="mt ju hs bd jv mu mv mw jz mx my mz kd ja na nb kh je nc nd kl ji ne nf kp ng bi translated">紧耦合的副作用</h2><p id="3696" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">Compose最大的优势之一是可组合性。创建一个可组合功能的小成本使得分离关注点、构建可重用和隔离的组件变得更加容易。对于可组合的lambda重载，很容易看出关注点的分离:一个<code class="du jp jq jr js b">Button</code>是内容的可点击容器，但是它不需要知道内容是什么。</p><p id="1621" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是对于原语重载，这就有点复杂了:一个直接接受文本的<code class="du jp jq jr js b">Button</code>现在既负责可点击的容器，<em class="jn">和</em>在里面发出<code class="du jp jq jr js b">Text</code>组件。这意味着它现在需要为这两者管理API表面，这就提出了另一个重要的问题:<code class="du jp jq jr js b">Button</code>应该公开什么文本相关的参数？这也将<code class="du jp jq jr js b">Button</code>的API面与<code class="du jp jq jr js b">Text</code>捆绑在一起:如果未来有新的参数和功能加入到<code class="du jp jq jr js b">Text</code>中，这是否意味着<code class="du jp jq jr js b">Button</code>也需要加入对它们的支持？这种紧密耦合是Compose试图避免的问题之一，很难在所有组件中以一致的方式回答这些问题，这导致了我们的API表面的不一致。</p><h2 id="6926" class="mt ju hs bd jv mu mv mw jz mx my mz kd ja na nb kh je nc nd kl ji ne nf kp ng bi translated">支持工作框架</h2><p id="0865" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">通过设计，基元重载允许开发人员避免使用可组合的lambda重载，以减少可能的自定义。但是当开发人员想要定制一些在原语重载中不可能的东西时会发生什么呢？唯一的选择是使用可组合的lambda重载，然后从原始重载中复制粘贴内部实现，并进行所需的更改。我们在研究中发现，这种定制<em class="jn">‘cliff’</em>阻碍了开发人员使用更灵活、可组合的API，因为在不同层之间移动所需的工作似乎比实际情况更具挑战性。</p><h2 id="e643" class="mt ju hs bd jv mu mv mw jz mx my mz kd ja na nb kh je nc nd kl ji ne nf kp ng bi translated">救援槽</h2><p id="7023" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">鉴于上述问题，我们决定移除<code class="du jp jq jr js b">Button</code>的原始重载，为每个<code class="du jp jq jr js b">Button</code>留下一个API，其中包含一个可组合的lambda参数作为其内容。我们开始将这种通用API形状称为“<em class="jn"> slot API </em>”，这种形状现在被广泛应用于各个组件。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es nh"><img src="../Images/6b168360d20a5c959f3a65d6b05a8d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/0*8bhKKLSdPiRCgFP3"/></div></figure><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">A Button with an empty ‘slot’</figcaption></figure><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es ni"><img src="../Images/154ff0fb0416a0fe4ca82640965d2763.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/0*8EtbJDoPzl8e8ho7"/></div></figure><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx">A Button with an image and text placed in a row</figcaption></figure><p id="0f1f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<em class="jn">‘slot’</em>指的是一个可组合的lambda参数，它代表一个组件内部的任意内容，比如<code class="du jp jq jr js b">Text</code>或者<code class="du jp jq jr js b">Icon</code>。Slot APIs增加了可组合性，使组件更简单，并减少了跨组件的独特概念的数量，使开发人员更容易开始使用新组件，或在组件之间移动。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><a href="https://github.com/androidx/androidx/commit/e386f97dd769da18d9f3103958714e43d797219f"><div class="er es nj"><img src="../Images/b52241b50a3a932565a78536631654df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*xTkLsuEesW1B--kKXSkXiQ.png"/></div></a><figcaption class="lc ld et er es le lf bd b be z dx">CL removing the primitive overloads</figcaption></figure><h1 id="b18d" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">展望未来</h1><p id="8d74" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">我们在<code class="du jp jq jr js b">Button</code>API上所做的改变的数量，我们在会议上讨论<code class="du jp jq jr js b">Button</code>所花费的时间，以及我们在获取开发者反馈上所付出的努力都是惊人的。也就是说，我们对这个API的结果非常满意。事后看来，我们可以看到Compose中的<code class="du jp jq jr js b">Button</code>是如何变得更容易被发现、更可定制，并且最重要的是，促进了一种<em class="jn">可组合</em>的心态。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="lc ld et er es le lf bd b be z dx"><a class="ae jo" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt;l=96?q=Button.kt" rel="noopener ugc nofollow" target="_blank">1.0 Button API</a></figcaption></figure><p id="f855" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是要认识到，我们的大多数设计决策都基于以下原则:</p><blockquote class="lh"><p id="e329" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="lr">“让简单的事情变得简单，让困难的事情变得可能”</em></p></blockquote><p id="0a9d" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们试图通过移除重载和扁平化“样式”来简化事情，同时对Android Studio自动完成进行改进，以帮助开发人员提高工作效率。</p><p id="7561" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从整个API设计过程中，我们有两个主要的收获需要明确提出:</p><ol class=""><li id="e0be" class="md me hs ir b is it iw ix ja mf je mg ji mh jm mi mj mk ml bi translated"><strong class="ir ht"> API设计是一个迭代过程</strong>。在一个API的第一次迭代中，想出完美的东西几乎是不可能的。有些需求很容易被忽略。作为一个API的作者，你必须做一些假设。这些包括开发人员背景的不同环境，导致不同的思维方式，影响人们发现和使用API的方式。调整将是不可避免的，这是一件好事，因为迭代会带来更有用和更直观的API。</li><li id="caf3" class="md me hs ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated"><strong class="ir ht">当迭代一个API设计</strong>时，开发者使用API的经验反馈环是你的武器库中最有价值的工具之一 <strong class="ir ht">。当一个开发者说“这个API太复杂”时，理解它意味着什么对我们的团队来说是绝对重要的。这通常是因为我们需要了解API的不正确使用并从中学习，这通常会导致开发人员的成功率和生产率下降。激发这种需求的一个关键驱动力是我们设计易于使用和令人愉快的API的意图。为此，我们使用了多种研究方法来创建开发人员反馈循环——从现场编码sessions⁴到要求开发人员记录其experiences⁵.日志的远程方法我们已经能够理解开发人员如何处理一个API，以及他们如何找到他们想要实现的功能的正确句柄。框架的支柱，如程序员的思维方式和认知维度，对我们的跨职能团队来说特别有帮助，不仅在审查和交流开发人员的反馈时，而且在进行API设计讨论时，都有帮助。特别是，这个框架有助于我们在评估用户体验和功能之间的取舍时形成对话。</strong></li></ol><p id="da27" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们承认，尽管我们喜欢当前版本的<code class="du jp jq jr js b">Button</code> API，但我们知道它并不完美。有多种开发人员的思维方式，加上不同的工作环境，以及新出现的需求，这些都要求我们应对新的挑战。还有<em class="jn">那也行</em>！对于我们和开发者社区来说,<code class="du jp jq jr js b">Button</code>的整个发展过程非常有价值。所有这些都是说，我们的过程已经帮助设计和形成了一个可用于Compose的<code class="du jp jq jr js b">Button</code>API——屏幕上一个简单的可点击矩形。</p><p id="f005" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望这篇文章揭示了您的反馈如何影响Compose的<code class="du jp jq jr js b">Button</code> API改进的幕后真相。像往常一样，如果您在Compose中实现时遇到任何问题，或者有一个可以改善您的体验的新API的想法，请在此处提交bug<a class="ae jo" href="http://goo.gle/compose-feedback" rel="noopener ugc nofollow" target="_blank"/>。我们也在寻找开发者参与未来的用户研究会议——在此注册<a class="ae jo" href="https://g.co/userresearch/androiddev21" rel="noopener ugc nofollow" target="_blank">参与研究。</a></p></div><div class="ab cl nk nl go nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ha hb hc hd he"><p id="8e66" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[1]大多数开发人员期望在使用<code class="du jp jq jr js b">+themeButtonStyle</code>或<code class="du jp jq jr js b">+buttonStyle</code>的样式中“<em class="jn">加“</em>，类似于他们使用<code class="du jp jq jr js b">+themeTextStyle</code>将样式应用于<code class="du jp jq jr js b">Text</code>组件的方式。</p><p id="14fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[2]这种想法是基于Randal L. Schwartz、Brian D Foy和Tom Phoenix的著名著作《学习Perl:让简单的事情变得简单，让困难的事情变得可能》中的一句话</p><p id="f5fb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[3] <a class="ae jo" href="https://www.linkedin.com/in/meitaltagor/" rel="noopener ugc nofollow" target="_blank">来自Android开发者UX团队的Meital Tagor Sbero </a>开发了程序员思维风格框架，其灵感来自于在<a class="ae jo" href="https://docs.microsoft.com/en-us/archive/blogs/stevencl/making-effective-use-of-personas-in-design" rel="noopener ugc nofollow" target="_blank">设计</a>和<a class="ae jo" href="https://www.researchgate.net/profile/Marian-Petre-4/publication/200085937_Usability_Analysis_of_Visual_Programming_Environments_A_%27Cognitive_Dimensions%27_Framework/links/02bfe50fbf23476730000000/Usability-Analysis-of-Visual-Programming-Environments-A-Cognitive-Dimensions-Framework.pdf" rel="noopener ugc nofollow" target="_blank">认知维度框架</a>中对<a class="ae jo" href="https://medium.com/inclusive-software/tagged/thinking-styles" rel="noopener">人物角色&amp;思维风格</a>的研究。程序员思维风格框架有助于利用程序员的动机和对他们在给定时间需要的“解决方案类型”的态度来确定API可用性的设计考虑。它考虑了普通程序员的工作方式，有助于优化频繁编程任务的易用性。</p><p id="bc1f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[4]我们通常使用这种方法来评估API特定方面的可用性。例如，每次会议都有一组开发人员使用Button API来完成一组编码任务，这些任务旨在特别公开我们对收集反馈最感兴趣的API区域。我们使用大声思考协议来获取更多关于开发人员在寻找什么和他们的假设是什么的信息；在这些会议中，研究人员还会向开发人员询问后续问题，以更好地了解开发人员的需求。我们能够回顾这些会议，以确定所有开发人员在编码任务中导致成功和/或失败的行为模式。</p><p id="5b5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[5]我们通常使用这种方法来评估一段时间内API的可用性和可学性。这种方法可以帮助捕捉开发人员旅途中困惑和快乐的时刻，方法是在他们的自然工作环境中倾听开发人员的声音。在这种方法中，我们有一组开发人员在他们选择的项目上工作，同时确保他们也使用我们有兴趣评估的API。开发人员在日记中自我报告的体验、研究人员基于认知维度框架特别策划的深度问卷调查(<a class="ae jo" href="https://arxiv.org/pdf/1703.09846.pdf" rel="noopener ugc nofollow" target="_blank">示例</a>)以及后续采访会议的组合有助于我们确定API的可用性。</p></div></div>    
</body>
</html>