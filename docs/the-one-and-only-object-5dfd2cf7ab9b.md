# 唯一的一件物品

> 原文：<https://medium.com/androiddevelopers/the-one-and-only-object-5dfd2cf7ab9b?source=collection_archive---------2----------------------->

![](img/70fba01ba4a45cb602c88d394a663914.png)

## 科特林词汇

在 Java 中，`static`关键字用于表示属于*对象*的方法和属性，而不是属于对象的*实例*的方法和属性。`static`关键字也用于创建[单例](https://en.wikipedia.org/wiki/Singleton_pattern)，这是最广泛使用的设计模式之一。单例帮助您创建一个对象的单个实例，它可以被其他对象访问和共享。

科特林有一个更优雅的方法来处理这个问题。你可以使用一个关键字:`object`，来实现单例模式。请继续阅读，了解在 Java 和 Kotlin 中实现单例的区别，如何在 Kotlin 中不使用`static`关键字创建单例(通过使用`object`关键字来破坏这一点)，并了解当您使用`object`时会发生什么。

首先，让我们回顾一下，找出为什么我们需要一个对象的单个实例，也就是 Singleton。

# 什么是独生子女？

Singleton 是一种设计模式，它确保一个类只有一个实例，并提供对对象的全局访问点。对于需要在应用程序的不同部分之间共享的对象，以及创建成本高昂的资源，单例模式尤其有用。

# Java 中的 Singleton

为了保证一个类只有一个实例，您需要控制如何创建对象。若要创建只有一个实例的类，请将构造函数设为私有，并创建对象的公共可访问静态引用。这样做的时候，你并不真的想在启动时创建 Singleton，因为 Singleton 用于创建代价很高的对象。为此，提供一个静态方法来检查对象是否被创建。方法必须返回以前创建的实例，或者调用构造函数并返回实例。

上面的代码看起来不错，但是有一个主要问题。**该代码不是线程安全的**。在任何时候，一个线程都可以通过 if 检查，但在另一个线程创建 singleton 时会被挂起。当第一个线程在`if`块中恢复时，它会创建另一个实例。

要解决线程问题，可以使用双重检查锁定。使用双重检查锁定，如果实例是`null`，`synchronized`关键字创建一个锁，第二次检查确保实例仍然是`null`。如果实例是`null`，那么创建单例。然而，这还不够，实例还需要标记`[volatile](https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java)`。Volatile 关键字告诉编译器，并发运行的线程可能会异步修改变量。

所有这些导致了很多样板文件，每次你需要一个单例时都需要重复这些文件。因为对于这样一个简单的任务来说，这段代码太复杂了，所以枚举在大多数时候被用于在 Java 中创建单例。

# 科特林的单身族

现在，让我们来看看科特林。Kotlin 没有静态方法或字段，那么我们如何在 Kotlin 中创建一个 Singleton？

其实 Android Studio/IntelliJ 可以帮助我们理解。当您将 Java 中的 Singleton 代码转换为 Kotlin 时，所有静态属性和方法都被移动到一个`companion object`中。

转换后的代码按预期工作，但我们可以使它更简单。为了简化代码，从`object`中移除构造函数和`companion`关键字。`object`和`companion objects`之间的区别将在本文后面介绍。

当您想使用`count()`方法时，您可以通过 Singleton 对象访问它。在 Kotlin 中，`object`是一个只有一个实例的特殊类。如果用`object`关键字而不是`class`创建一个类，Kotlin 编译器会将构造函数设为私有，为对象创建一个静态引用，并在静态块中初始化引用。

静态块只在第一次访问静态字段时调用一次。JVM 以类似于同步块的方式处理静态块，即使它们没有`synchronized`关键字。当这个单例类初始化时，JVM 获得同步块上的一个锁，使得另一个线程无法访问它。当锁被释放时，Singleton 实例已经被创建，因此静态块不会再次执行。这保证了只有一个 Singleton 实例，它实现了 Singleton 契约。另外，该对象是线程安全的，并且是在第一次访问时延迟创建的。瞧啊。

让我们来看看反编译的 Kotlin 字节码，以了解幕后发生了什么。

> 要检查 Kotlin 类的字节码，选择**工具> Kotlin >显示 Kotlin 字节码**。一旦 Kotlin 字节码显示出来，点击**反编译**显示反编译的 Java 代码。

然而，`object`有一个限制。对象声明不能有构造函数，这意味着它们不能带参数。即使他们这样做了，也不可能传递参数，因为构造函数中传递的非静态参数不能从静态块中访问。

> ⚠️静态初始化块，就像其他静态方法一样，只能访问类的静态属性。静态块在构造函数之前被调用，因此它们无法访问对象的属性或构造函数中传递的参数。

# 伴随物体

`companion object`类似于`object`。总是在类中声明，它们的属性可以通过使用主机对象来访问。`companion object`不需要名字。如果`companion object`有名字，调用者可以使用`companion object`的名字访问成员。

例如，这里我们有相似的有名字和没有名字的伴随对象。任何调用者都可以访问`SomeClass`上的`count()`方法，就像它是`SomeClass`的静态成员一样。或者，任何调用者都可以通过使用`Counter`来访问`count()`方法，就像使用`AnotherClass`的静态成员一样。

伴随对象用私有构造函数反编译成内部类。宿主类通过只有它才能访问的合成构造函数初始化内部类。host 类保存了对 companion 对象的公共引用，可以从其他类访问该对象。

# 对象表达式

到目前为止，我们已经看到了在对象声明中使用的`object`关键字。`object`关键字也可以用在对象表达式中。当用作表达式时，`object`关键字帮助你创建匿名对象和匿名内部类。

假设您需要一个临时对象来保存一些值。您可以当场用所需的值声明和初始化您的对象，并在以后访问它们。

在生成的代码中，这转化为一个匿名 Java 类，用`<undefinedtype>`标记，用生成的 getters 和 setters 存储匿名对象。

`object`关键字还可以帮助您创建匿名类，而无需编写任何样板代码。您可以使用对象表达式，Kotlin 编译器生成包装类声明来创建匿名类。

`object`关键字帮助你用更少的代码创建线程安全的单例、匿名对象和匿名类。使用`object`和`companion object`，Kotlin 生成所有代码来实现`static`关键字提供的相同功能。另外，您可以使用对象表达式创建匿名对象和类，而无需任何样板代码。