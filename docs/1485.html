<html>
<head>
<title>How to Work with Forms, Inputs and Events in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中使用表单、输入和事件</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/how-to-work-with-forms-inputs-and-events-in-react-c337171b923b?source=collection_archive---------0-----------------------#2017-11-09">https://medium.com/capital-one-tech/how-to-work-with-forms-inputs-and-events-in-react-c337171b923b?source=collection_archive---------0-----------------------#2017-11-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/38905e71a2b911a7ad708fc8f01abb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyoHrTBOFPbnHSOCsYxrOg.png"/></div></div></figure><p id="ea38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">这是本书摘录的</em> </strong> <a class="ae jo" href="https://www.manning.com/books/react-quickly" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="jn">反应迅速</em> </strong> </a> <strong class="ir hi"> <em class="jn">，可用在</em></strong><a class="ae jo" href="https://manning.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="jn">【manning.com】</em></strong></a></p><p id="e21a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文介绍了如何捕获文本输入以及通过其他表单元素(如<input/>、<textarea>和<option>)进行输入。使用它们对于web开发来说是至关重要的，因为它们允许我们的应用程序接收来自用户的数据(例如文本)和动作(例如点击)。</option></textarea></p><h2 id="2d39" class="jp jq hh bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated"><strong class="ak">React中使用表单的推荐方式</strong></h2><p id="155e" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">在常规HTML中，当我们处理input元素时，页面的DOM在其DOM节点中维护该元素的值。可以通过像:<code class="du kp kq kr ks b">document.getElementById(‘email’).value</code>这样的方法或者使用jQuery方法来访问这个值。大教堂是我们的储藏室。</p><p id="a9ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在React中，当处理表单或任何其他用户输入字段(如独立的文本字段或按钮)时，开发人员有一个有趣的问题需要解决。来自React的文档:<em class="jn">“React组件必须表示视图在任何时间点的状态，而不仅仅是在初始化时。”React就是通过使用声明式风格来描述用户界面，让事情变得简单。React描述了UI、它的结束阶段以及它应该是什么样子。</em></p><p id="3979" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你能发现冲突吗？在传统的HTML表单元素中，元素的状态会随着用户输入而改变。React使用声明性方法来描述UI。输入需要是动态的，以正确反映状态。</p><p id="e85e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果开发人员选择不维护组件状态(在JavaScript中)，也不与视图同步，那么就会产生问题——可能会出现内部状态和视图不同，而React不知道状态发生变化的情况。这可能导致各种各样的麻烦，并削弱了React的简单哲学。最佳实践是让React的<code class="du kp kq kr ks b">render() </code>尽可能接近真实的DOM，这包括表单元素中的数据。</p><p id="1a14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑这个文本输入字段的例子。React必须在组件的<code class="du kp kq kr ks b">render()</code>中包含新值。因此，我们需要使用<code class="du kp kq kr ks b">value</code>将元素的值设置为新值。如果我们像以前在HTML中一样实现一个<code class="du kp kq kr ks b"> &lt;input&gt;</code>字段，React将使<code class="du kp kq kr ks b"> render()</code>与真正的DOM保持同步。React不允许用户更改该值。你自己试试。这可能感觉很疯狂，但这是反应的适当行为！</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="d67c" class="jp jq hh ks b fi lb lc l ld le">render() {</span><span id="7777" class="jp jq hh ks b fi lf lc l ld le">  return &lt;input type=”text” name=”title” value=”Mr.” /&gt;</span><span id="361a" class="jp jq hh ks b fi lf lc l ld le">}</span></pre><p id="627b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的代码表示任何状态下的视图，值始终为“Mr”。对于输入字段，它们必须响应于用户的击键而改变。鉴于以上几点，让我们将价值动态化。</p><p id="eb40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个更好的实现，因为它将从以下状态进行更新:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="5907" class="jp jq hh ks b fi lb lc l ld le">render() {</span><span id="3af2" class="jp jq hh ks b fi lf lc l ld le">  return &lt;input type=”text” name=”title” value={this.state.title} /&gt;</span><span id="6eba" class="jp jq hh ks b fi lf lc l ld le">}</span></pre><p id="5328" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">国家的价值是什么？React不知道用户在表单元素中键入的内容。开发人员需要实现一个事件处理程序来捕捉<code class="du kp kq kr ks b">onChange</code>的变化。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="fd8e" class="jp jq hh ks b fi lb lc l ld le">handleChange(event) {</span><span id="a441" class="jp jq hh ks b fi lf lc l ld le">  this.setState({title: event.target.value})</span><span id="1ddc" class="jp jq hh ks b fi lf lc l ld le">}</span><span id="9317" class="jp jq hh ks b fi lf lc l ld le">render() {</span><span id="5af1" class="jp jq hh ks b fi lf lc l ld le">  return &lt;input type=”text” name=”title” value={this.state.title} <br/>    onChange={this.handleChange.bind(this)}/&gt;</span><span id="e55a" class="jp jq hh ks b fi lf lc l ld le">}</span></pre><p id="8d4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">鉴于以上几点，对于开发人员来说，最佳做法是实现以下内容，以便将内部状态与视图同步(图1):</p><p id="e71c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.使用状态的值在<code class="du kp kq kr ks b">render() </code>中定义元素。</p><p id="ffc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.使用<code class="du kp kq kr ks b">onChange()</code>捕捉形状元素发生的变化。</p><p id="cbc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.更新事件处理程序中的内部状态。</p><p id="0a54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4.新值保存在状态中，然后视图由新的<code class="du kp kq kr ks b">render()</code>更新。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/08a01d07fe0a011489e551bb5e4dc156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*WCns9IAIsOAYvh9arVVrkA.jpeg"/></div></figure><p id="d1ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">图1:捕捉输入变化并应用到状态</em> </strong></p><p id="09d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乍看之下，这似乎是一项很大的工作，但我希望通过更多地使用React，您会欣赏这种方法。之所以称之为单向绑定，是因为状态只改变视图。没有返程，只有从一个州到另一个州的单程旅行。使用单向绑定时，库不会自动更新状态(或模型)。单向绑定的一个主要好处是，它在处理大型应用程序时消除了复杂性，在大型应用程序中，许多视图可以隐式更新许多状态(数据模型)，反之亦然——图2。</p><p id="84f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简单并不总是意味着更少的代码。有时，就像这种情况一样，开发人员必须编写额外的代码来手动将来自事件处理程序的数据设置为状态(呈现为视图)。但当涉及到复杂的用户界面和具有无数视图和状态的单页应用程序时，这种方法往往更优越。简言之:<strong class="ir hi"> <em class="jn">简单并不总是容易。</em> </strong></p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/af41b78f3df540d609de18d92d7694f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iSFKsOFpMXDdulZHCrXlA.png"/></div></div></figure><p id="62e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">图2:单向与双向绑定 </strong></p><p id="9b84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相反，双向绑定允许视图自动更改状态，而无需开发人员显式实现。双向绑定是Angular 1的工作方式。有趣的是，Angular 2从React借用了单向绑定的概念，并将其设为默认值(您仍然可以显式地拥有双向绑定)。</p><p id="bfbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们将首先介绍使用表单的推荐方法。它被称为受控组件，确保内部组件状态始终与视图同步。另一种方法是不受控制的成分。</p><p id="da5f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，我们已经了解了在reactor中使用输入字段的最佳做法，即捕获更改并将其应用于状态，如图1所示(更改视图的输入)。接下来，让我们看看如何定义一个表单及其元素。</p><h1 id="a48d" class="li jq hh bd jr lj lk ll jv lm ln lo jz lp lq lr kc ls lt lu kf lv lw lx ki ly bi translated">定义形式及其在反应中的事件</h1><p id="95d4" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">我们将从<code class="du kp kq kr ks b"> &lt;form&gt;</code>元素开始。通常，我们不希望我们的输入元素随机挂在DOM中。如果我们有许多功能不同的输入集，这可能会变得很糟糕。相反，我们将具有共同目的的输入元素包装在一个<code class="du kp kq kr ks b"> &lt;form&gt;&lt;/form&gt;</code>元素中。</p><p id="a57c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">没有必要有一个<code class="du kp kq kr ks b">&lt;form&gt;</code>包装。在简单的用户界面中单独使用表单元素完全没问题。在更复杂的ui中，开发人员可能在一个页面上有多组元素。在这种情况下，对每个组使用<code class="du kp kq kr ks b">&lt;form&gt;</code>是明智的。React的<code class="du kp kq kr ks b"> &lt;form&gt;</code>呈现在HTML <code class="du kp kq kr ks b">&lt;form&gt;</code>中，我们对React的<code class="du kp kq kr ks b">&lt;form&gt; </code>元素应用的任何规则也是如此。根据HTML5规范，开发者不应该嵌套表单(它说内容是流内容，但是没有<code class="du kp kq kr ks b">&lt;form&gt; </code>元素后代)。</p><p id="3647" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表单元素本身可以有事件。除了标准的React DOM事件之外，React还支持表单的三个事件:</p><ul class=""><li id="fc25" class="lz ma hh ir b is it iw ix ja mb je mc ji md jm me mf mg mh bi translated"><code class="du kp kq kr ks b">onChange</code>:当表单的任何输入元素发生变化时触发。</li><li id="96bf" class="lz ma hh ir b is mi iw mj ja mk je ml ji mm jm me mf mg mh bi translated"><code class="du kp kq kr ks b">onInput</code>:每次改变<code class="du kp kq kr ks b"> &lt;textarea&gt;</code>和<code class="du kp kq kr ks b"> &lt;input&gt;</code>元素值时触发。React团队不建议使用它(见下文)。</li><li id="6a79" class="lz ma hh ir b is mi iw mj ja mk je ml ji mm jm me mf mg mh bi translated"><code class="du kp kq kr ks b">onSubmit</code>:提交表单时触发，通常是按enter键。</li></ul><h1 id="b5cc" class="li jq hh bd jr lj lk ll jv lm ln lo jz lp lq lr kc ls lt lu kf lv lw lx ki ly bi translated">onChange与onInput</h1><p id="ed85" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">React的<code class="du kp kq kr ks b">onChange</code>在每次改变时触发，与之相反的是<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/Events/change" rel="noopener ugc nofollow" target="_blank">DOM的改变事件</a>，它可能不会在每次值改变时触发，而是在失去焦点时触发。例如，对于<code class="du kp kq kr ks b">&lt;input type=”text”&gt;</code>,用户可以在没有onChange的情况下输入，只有在用户按下tab或者用他/她的鼠标点击另一个元素(失去焦点)之后，onChange才会在HTML中被触发(常规浏览器事件)。如前所述，在React中，onChange在每次击键时触发，而不仅仅是在失去焦点时。</p><p id="3d79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，React中的onInput是DOM的onInput的包装器，它在每次更改时触发。因此，React团队建议在onInput上使用onChange。底线是React的onChange与HTML中的onChange工作方式不同，因为它更一致(也更像HTML的onInput)。onChange在每次更改时触发，而不是在失去焦点时触发。</p><p id="6a19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">React中推荐的方法是只在需要访问onInput事件的本机行为时才使用onChange和onInput。原因是React的onChange包装器行为提供了一致性。</p><h1 id="6fb1" class="li jq hh bd jr lj lk ll jv lm ln lo jz lp lq lr kc ls lt lu kf lv lw lx ki ly bi translated">使用表单事件</h1><p id="715d" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">除了上面列出的三个事件，<code class="du kp kq kr ks b"> &lt;form&gt; </code>还可以有标准的反应事件，比如<code class="du kp kq kr ks b"> onKeyUp</code>或<code class="du kp kq kr ks b">onClick</code>。当我们需要捕获整个表单(一组输入元素)的特定事件时，使用表单事件可能会很方便。</p><p id="6ce2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，允许用户在按下enter键时提交数据是一个很好的UX(假设您不在textarea字段中，在这种情况下，enter应该会创建一个新行)。我们可以通过创建一个触发<code class="du kp kq kr ks b">this.handleSubmit()</code>的事件监听器来监听表单提交事件。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="559c" class="jp jq hh ks b fi lb lc l ld le">handleSubmit(event) {</span><span id="dce2" class="jp jq hh ks b fi lf lc l ld le">…</span><span id="6c20" class="jp jq hh ks b fi lf lc l ld le">}</span><span id="aa2a" class="jp jq hh ks b fi lf lc l ld le">render() {</span><span id="fb18" class="jp jq hh ks b fi lf lc l ld le">  return (<br/>    &lt;form onSubmit={this.handleSubmit}&gt;</span><span id="3aad" class="jp jq hh ks b fi lf lc l ld le">      &lt;input type=”text” name=”email” /&gt;</span><span id="9d74" class="jp jq hh ks b fi lf lc l ld le">    &lt;/form&gt;<br/>  )</span><span id="6d67" class="jp jq hh ks b fi lf lc l ld le">}</span></pre><p id="405f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">请注意:</strong>我们需要在render()之外实现handleSubmit函数，就像我们处理其他事件一样。React不要求任何命名约定，您可以随意命名事件处理程序，只要它是可理解的和一致的。现在，我们将坚持使用最流行的约定，在事件处理程序前面加上单词“handle ”,以区别于常规的类方法。</p><p id="664e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">提醒一下，不要调用方法(不要放括号)，不要在花括号周围用双引号(正确做法:EVENT={this。方法})时设置事件处理程序。在React中，我们传递函数的定义，而不是它的结果，我们使用花括号作为JSX属性值。</p><p id="0d37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在enter上实现表单提交的另一种方式是通过手动监听key up事件(<code class="du kp kq kr ks b">onKeyUp</code>)并检查键码(13代表enter)。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="d1d6" class="jp jq hh ks b fi lb lc l ld le">handleKeyUp(event) {</span><span id="9d78" class="jp jq hh ks b fi lf lc l ld le">  if (event.keyCode == 13) return this.sendData()</span><span id="2d14" class="jp jq hh ks b fi lf lc l ld le">}</span><span id="376e" class="jp jq hh ks b fi lf lc l ld le">render() {</span><span id="5ad0" class="jp jq hh ks b fi lf lc l ld le">  return &lt;form onKeyUp={this.handleKeyUp}&gt;</span><span id="6287" class="jp jq hh ks b fi lf lc l ld le">    …</span><span id="e670" class="jp jq hh ks b fi lf lc l ld le">  &lt;/form&gt;</span><span id="1e11" class="jp jq hh ks b fi lf lc l ld le">}</span></pre><p id="e832" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，<code class="du kp kq kr ks b">sendData</code>方法是在代码中的其他地方实现的。此外，我们需要在<code class="du kp kq kr ks b">constructor()</code>中绑定(这个)事件处理程序。</p><p id="04e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总而言之，在React中，我们可以在表单元素上拥有事件，而不仅仅是表单中的单个元素。</p><p id="30ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">注意</em> </strong> <em class="jn">:本文中的例子的源代码在GitHub资源库</em> <a class="ae jo" href="https://github.com/azat-co/react" rel="noopener ugc nofollow" target="_blank"> <em class="jn">的ch04文件夹中，azat-co/react-quick</em></a><em class="jn">。还有一些演示可以在http://reactquickly.co/demos的</em><a class="ae jo" href="http://reactquickly.co/demos" rel="noopener ugc nofollow" target="_blank"><em class="jn"/></a><em class="jn">找到。</em></p><blockquote class="mn"><p id="fd4b" class="mo mp hh bd mq mr ms mt mu mv mw jm dx translated">本文到此结束，更多关于React及其无数用途的信息，请查看manning.com<a class="ae jo" href="https://manning.com/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae jo" href="https://www.manning.com/books/react-quickly" rel="noopener ugc nofollow" target="_blank">快速反应</a>。</p></blockquote><figure class="my mz na nb nc ii er es paragraph-image"><a href="https://www.manning.com/books/react-quickly"><div class="er es mx"><img src="../Images/e414c0fc7852d187b5178e1199ef35c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*oG74PX30gosuGg0eqgp39g.jpeg"/></div></a></figure><p id="a7c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em> </strong></p></div></div>    
</body>
</html>