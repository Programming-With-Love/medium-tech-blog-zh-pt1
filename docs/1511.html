<html>
<head>
<title>Event Sourcing with Aggregates in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust中的骨料进行事件采购</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/event-sourcing-with-aggregates-in-rust-4022af41cf67?source=collection_archive---------0-----------------------#2018-02-12">https://medium.com/capital-one-tech/event-sourcing-with-aggregates-in-rust-4022af41cf67?source=collection_archive---------0-----------------------#2018-02-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/eda276a924cfb6585a1c3f4b67b36e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tm86YlRThRTW-6NE36Ti7g.png"/></div></div></figure><p id="55ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个开发人员都喜欢<em class="jn">事件源</em>，直到他们必须实现它的那一刻。在那一刻，当你试图将这种模式映射到你的业务领域时，所有从会议出席中收集的精彩白板绘图和灵感都嘎然而止。</p><p id="22df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无可否认，我曾在那艘沉船上。我是不可变数据流、事件源、命令和查询分离以及将状态视为事件流的函数的好处的大力倡导者。然而，考虑到所有这些，我只能实现一些“纯粹的”事件源系统。黑客出现了——他们从敞开的伤口流血，他们像啮齿动物一样从你墙上的咬洞爬进来，他们破坏一切。</p><p id="56d0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您对这个概念不熟悉，<em class="jn">事件源</em>是指您的共享状态在适当的位置是不可变的。相反，它是连续应用不可变事件的结果，这些事件代表过去发生的事情。正如我在书中所说，<a class="ae jo" href="https://www.amazon.com/Cloud-Native-Applications-Microservices-Developers/dp/0672337797/ref=sr_1_2?ie=UTF8&amp;qid=1519135681&amp;sr=8-2&amp;keywords=cloud+native+go" rel="noopener ugc nofollow" target="_blank">云原生Go </a>和<a class="ae jo" href="https://www.amazon.com/Building-Microservices-ASP-NET-Core-Cross-Platform/dp/1491961732/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1519135704&amp;sr=1-4&amp;keywords=microservices+with+asp.net+core" rel="noopener ugc nofollow" target="_blank">微服务采用ASP.NET核心</a>，<em class="jn">现实是事件源</em>。你的大脑消耗多种输入流，并根据头脑中存储的历史、感官输入等来计算状态(我们对“现实”的概念)。一旦你开始把问题想象成事件源问题，就很难以其他方式看待它们。</p><p id="cb7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">集合</em>是一个领域驱动设计(DDD)的概念，非常适合事件采购。简而言之:您将一个<strong class="ir hi"> <em class="jn">命令</em> </strong> <em class="jn"> </em>应用于一个<strong class="ir hi"><em class="jn"/></strong>集合，然后该集合产生一个或多个<strong class="ir hi"> <em class="jn">事件</em> </strong>。通过顺序应用事件流，聚集可以填充(重新水合)其状态。</p><p id="f70b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于这个话题的更多信息，请随意去谷歌<em class="jn">活动采购</em>的兔子洞。在这篇文章的剩余部分，我想讨论我们如何实现类似于<em class="jn">事件源</em>和<em class="jn">聚合</em>在<strong class="ir hi"> Rust </strong>中的东西，而不让黑客从缝隙中钻进来。</p><p id="3bfe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个问题是——你如何表现一个事件？在我的示例中，我正在处理一个领域，在这个领域中，我们的产品(由一个<strong class="ir hi"> SKU </strong>惟一标识)在仓库中有一个可测量的现有量。产品可能发生的事件包括被保留(未发货订单“预订”了一些数量)、被发布(订单被取消)或被发货(之前保留的数量实际上已经离开仓库)。</p><p id="785c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我的第一反应是创建一些结构:</p><ul class=""><li id="7280" class="jp jq hh ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">产品装运</li><li id="826d" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">产品保留</li><li id="34e5" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">产品发布</li></ul><p id="9cca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些结构中的每一个都有一些有效载荷数据，比如时间戳等。然后，我可以将这些序列化到队列中，以便进行下游处理。表面上看，这对我来说是个好主意。</p><p id="c34e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">直到我设想了“切换”语句，在那里我必须打开<em class="jn">类型</em>，而不是<em class="jn">内容</em>。这对我来说就像是一个警告信号，表明我走错了方向。使用Rust，我可以很容易地对内容进行模式匹配，所以我决定使用带有struct变量的枚举:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a1fe" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">struct </strong>ProductEventData {<br/>    quantity: <strong class="ki hi">usize</strong>,<br/>    timestamp: <strong class="ki hi">usize</strong>,<br/>    sku: String,<br/>}<br/><br/><strong class="ki hi">enum </strong>ProductEvent {<br/>    <em class="jn">Reserved</em>(ProductEventData),<br/>    <em class="jn">Released</em>(ProductEventData),<br/>    <em class="jn">Shipped</em>(ProductEventData),<br/>}</span></pre><p id="f2f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我有一个结构，如果我愿意，我可以为它派生序列化，但有趣的是，现在我有了代表产品可能发生的每种事件类型的<code class="du ks kt ku ki b">ProductEvent::*</code>枚举，并且我可以<em class="jn">将所有产品事件作为单一类型</em>。当我想要构建一个聚合时，这非常方便。</p><p id="dd40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，聚合表示计算状态。然而，它也是执行<em class="jn">命令</em>的对象。一个命令是一个<em class="jn">命令</em>,用于聚合验证。如果命令成功，那么聚合将返回一个准备发出的事件列表。一些ES实现喜欢让聚合直接发出事件，但是我喜欢将事件发出作为它自己的关注点，允许我直接测试我的业务逻辑，而不必模拟队列客户端。</p><p id="63e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，产品聚合可能有一个名为<strong class="ir hi"> <em class="jn"> ship(…) </em> </strong>的命令。如果成功，我可能会得到<code class="du ks kt ku ki b">ProductEvent::Shipped(...)</code> enum作为响应。我可以得到多个事件来响应一个命令，这在很多领域都是如此。</p><p id="3fdd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么我们如何定义一个集合呢？所有聚合必须能够将事件按顺序应用到它们的状态。从数学上来说，看起来是这样的:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d7a1" class="km kn hh ki b fi ko kp l kq kr">f(state`1 + event) = state`2</span></pre><p id="d359" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将一个事件应用于聚合的结果是产生具有新状态的聚合。这是一个非常<em class="jn">功能化的</em>看待它的方式，稍后我会解释更多关于我对不变性的喜爱。</p><p id="98a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，让我们构建一个描述事件集合的特征:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9bd2" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">trait </strong>Aggregate {<br/>    <strong class="ki hi">type </strong>Item;<br/><br/>    <strong class="ki hi">fn </strong>version(&amp;<strong class="ki hi">self</strong>) -&gt; <strong class="ki hi">u64</strong>;<br/>    <strong class="ki hi">fn </strong>apply(&amp;<strong class="ki hi">self</strong>, evt: &amp;<strong class="ki hi">Self</strong>::Item) -&gt; <strong class="ki hi">Self where Self</strong>:Sized;<br/>}</span></pre><p id="4a2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们说所有的聚合必须有一个版本，并且它们都必须有一个<em class="jn"> apply </em>方法，该方法接受一个<code class="du ks kt ku ki b">Item</code>类型的事件并产生一个<code class="du ks kt ku ki b">Self</code>类型的新东西(实现特征的东西的真实类型，而不是特征类型本身)。要求<code class="du ks kt ku ki b">Self:Sized</code>仅仅意味着我们需要一个可预测内存占用的东西，而不是一个装箱的特征对象。</p><p id="2829" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，因为枚举在Rust中是如此强大和灵活，所以让我们添加一些方便的方法，这样我们就可以创建新的枚举以及它们的内部结构有效载荷:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="acdc" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">impl </strong>ProductEvent {<br/>    <strong class="ki hi">fn <em class="jn">reserved</em></strong>(sku: &amp;<strong class="ki hi">str</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; ProductEvent {<br/>        ProductEvent::<em class="jn">Reserved</em>(ProductEventData {<br/>            quantity: qty,<br/>            sku: sku.to_owned(),<br/>            timestamp: 1,<br/>        })<br/>    }<br/>    <strong class="ki hi">fn <em class="jn">shipped</em></strong>(sku: &amp;<strong class="ki hi">str</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; ProductEvent {<br/>        ProductEvent::<em class="jn">Shipped</em>(ProductEventData {<br/>            quantity: qty,<br/>            sku: sku.to_owned(),<br/>            timestamp: 1,<br/>        })<br/>    }<br/>    <strong class="ki hi">fn <em class="jn">released</em></strong>(sku: &amp;<strong class="ki hi">str</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; ProductEvent {<br/>        ProductEvent::<em class="jn">Released</em>(ProductEventData {<br/>            quantity: qty,<br/>            sku: sku.to_owned(),<br/>            timestamp: 1,<br/>        })<br/>    }<br/>}</span></pre><p id="f9cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经准备好开始实现一个特定于领域的聚合，<code class="du ks kt ku ki b">ProductAggregate</code>，它代表了一个产品的计算状态。这也是我认为经常被忽视的重要一点——聚合是对单个实体的计算，而不是对应用程序的整个状态的计算。进一步说，<em class="jn">聚集体是短命的</em>。它们的寿命足以计算状态和验证命令，就这样<em class="jn"/>。如果您正在构建一个无状态的服务，它将在请求结束时处理这个集合。</p><p id="70b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里是我们的<code class="du ks kt ku ki b">ProductAggregate</code>:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="c6c7" class="km kn hh ki b fi ko kp l kq kr">#[derive(Debug)]<br/><strong class="ki hi">struct </strong>ProductAggregate {<br/>    version: <strong class="ki hi">usize</strong>,<br/>    qty_on_hand: <strong class="ki hi">usize</strong>,<br/>    sku: String,<br/>}</span></pre><p id="1d19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们正在维护版本，这对于任何复杂性的事件源实现都是必不可少的。这允许我们处理重放情况(重放到版本“x”)，并且当多个聚集同时持久化时，可能解决“合并冲突”……但是那是另一篇博文的内容了😀</p><p id="527d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们将一些命令放在我们的集合中:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d98d" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">impl </strong>ProductAggregate {<br/>    <strong class="ki hi">fn <em class="jn">new</em></strong>(sku: &amp;<strong class="ki hi">str</strong>, initial_quantity: <strong class="ki hi">usize</strong>) -&gt; ProductAggregate {<br/>        ProductAggregate {<br/>            version: 1,<br/>            qty_on_hand: initial_quantity,<br/>            sku: sku.to_owned(),<br/>        }<br/>    }<br/><br/>    <strong class="ki hi">fn reserve_quantity</strong>(&amp;<strong class="ki hi">self</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; Result&lt;Vec&lt;ProductEvent&gt;, String&gt; {<br/>        <strong class="ki hi">if </strong>qty &gt; <strong class="ki hi">self</strong>.qty_on_hand {<br/>            <strong class="ki hi">let </strong>msg = format!(<br/>                "Cannot reserve more than on hand quantity ({})",<br/>                <strong class="ki hi">self</strong>.qty_on_hand<br/>            );<br/>            <em class="jn">Err</em>(msg)<br/>        } <strong class="ki hi">else if self</strong>.version == 0 {<br/>            <em class="jn">Err</em>(<br/>                "Cannot apply a command to an un-initialized aggregate. Did you forget something?"<br/>                    .to_owned(),<br/>            )<br/>        } <strong class="ki hi">else </strong>{<br/>            <em class="jn">Ok</em>(vec![ProductEvent::<em class="jn">reserved</em>(&amp;<strong class="ki hi">self</strong>.sku, qty)])<br/>        }<br/>    }<br/><br/>    <strong class="ki hi">fn release_quantity</strong>(&amp;<strong class="ki hi">self</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; Result&lt;Vec&lt;ProductEvent&gt;, String&gt; {<br/>        <em class="jn">Ok</em>(vec![ProductEvent::<em class="jn">released</em>(&amp;<strong class="ki hi">self</strong>.sku, qty)])<br/>    }<br/><br/>    <strong class="ki hi">fn ship_quantity</strong>(&amp;<strong class="ki hi">self</strong>, qty: <strong class="ki hi">usize</strong>) -&gt; Result&lt;Vec&lt;ProductEvent&gt;, String&gt; {<br/>        <em class="jn">Ok</em>(vec![ProductEvent::<em class="jn">shipped</em>(&amp;<strong class="ki hi">self</strong>.sku, qty)])<br/>    }<br/><br/>    <strong class="ki hi">fn </strong>quantity(&amp;<strong class="ki hi">self</strong>) -&gt; <strong class="ki hi">usize </strong>{<br/>        <strong class="ki hi">self</strong>.qty_on_hand<br/>    }<br/>}</span></pre><p id="becd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我试图保持领域逻辑简单，这样我们就可以关注重要的部分(命令模式)。在<code class="du ks kt ku ki b">reserve_quantity</code>的情况下，如果我们试图保留比我们手头更多的库存，我们将返回一个<code class="du ks kt ku ki b">Err</code>。在真实世界的应用程序中，可能会有更多的验证步骤，但是这里的<code class="du ks kt ku ki b">Result</code>类型工作得很好——成功时我们得到一个<code class="du ks kt ku ki b">Vec</code>事件，否则我们得到一个包含字符串的<code class="du ks kt ku ki b">Err</code>。同样值得注意的是，返回的事件<em class="jn">并不应用于聚合</em>。我非常明确地保持命令操作<em class="jn">没有副作用</em>并且尽可能地遵守功能原则。</p><p id="e840" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想在调用命令后将返回的事件应用到集合<em class="jn">，那是您的选择，但是至少那些阅读您代码的人会清楚地知道发生了什么以及(希望)为什么。</em></p><p id="b810" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如您可能已经猜到的那样，聚合验证传入命令的能力依赖于它已经计算出状态这一事实。为了计算状态，我们通过<em class="jn">应用</em>方法抽取一个事件流。很多人喜欢这里的<strong class="ir hi">可变</strong>聚合，他们在同一个聚合上反复调用<em class="jn">应用</em>。</p><p id="a2a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于个人原因，由于可变聚合在生产中造成的长期和传奇的、难以诊断的问题，我想采用一种更函数化的方法，让我的<em class="jn"> apply </em>方法返回一个<em class="jn">全新的</em>聚合，其计算状态为:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="e5cf" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">impl </strong>Aggregate <strong class="ki hi">for </strong>ProductAggregate {<br/>    <strong class="ki hi">type </strong>Item = ProductEvent;<br/><br/>    <strong class="ki hi">fn </strong>version(&amp;<strong class="ki hi">self</strong>) -&gt; <strong class="ki hi">u64 </strong>{<br/>        <strong class="ki hi">self</strong>.version<br/>    }<br/><br/>    <strong class="ki hi">fn </strong>apply(&amp;<strong class="ki hi">self</strong>, evt: &amp;ProductEvent) -&gt; ProductAggregate {<br/>      ProductAggregate {<br/>        version: <strong class="ki hi">self</strong>.version + 1,<br/>        qty_on_hand: <strong class="ki hi">match </strong>evt {<br/>           &amp;ProductEvent::<em class="jn">Released</em>(<br/>            ProductEventData { quantity: qty, .. }) =&gt; {<br/>                  <strong class="ki hi">self</strong>.qty_on_hand + qty<br/>           },<br/>           &amp;ProductEvent::<em class="jn">Reserved</em>(<br/>            ProductEventData { quantity: qty, .. }) =&gt; {<br/>                    <strong class="ki hi">self</strong>.qty_on_hand - qty<br/>           },<br/>            _ =&gt; <strong class="ki hi">self</strong>.qty_on_hand,<br/>          },<br/>        sku: <strong class="ki hi">self</strong>.sku.clone(),<br/>       }<br/>   }<br/>}</span></pre><p id="7804" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在前面的代码中发生了大量非常酷的错误。首先，你会注意到我使用了一个<em class="jn">关联类型</em>来表示这个聚合流程的类型<code class="du ks kt ku ki b">Item</code>是<code class="du ks kt ku ki b">ProductEvent</code>变体。然后我可以在我的模式匹配中使用<em class="jn">析构</em>来取出<em class="jn">只是<code class="du ks kt ku ki b">ProductEventData</code>结构的<code class="du ks kt ku ki b">qty</code>字段，以便产生新计算的集合。</em></p><p id="f9b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有人向我指出，有一种更好的方式来做<code class="du ks kt ku ki b">apply</code>。在我对<em class="jn">易变性</em>的偏执反抗中，我忽略了Rust对<em class="jn">移动</em>的概念。在Rust中，当你赋值的时候，默认的行为是<em class="jn">将</em>的值从一个地方移动到另一个地方(让之前的位置作为变量不可用)。在这一过程中，进行变异是安全的(也是最受欢迎的),因为<em class="jn">你可以保证在那一刻没有其他代码引用你正在变异的东西</em>。这是在编译时强制执行的<em class="jn">，同时也是一个令人沮丧和解放的特性。</em></p><p id="67ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接受移动并在<code class="du ks kt ku ki b">apply</code>内改变聚合避免了堆栈上的额外分配，并避免了在SKU字符串上对<code class="du ks kt ku ki b">clone()</code>的调用:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d284" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">fn</strong> <strong class="ki hi">apply</strong>(mut <strong class="ki hi">self</strong>, evt: &amp;ProductEvent) -&gt; ProductAggregate {<br/>  <strong class="ki hi">self</strong>.version += 1;<br/>  <strong class="ki hi">self</strong>.qty_on_hand = <strong class="ki hi">match</strong> evt {<br/>    &amp;ProductEvent::Released(<br/>       ProductEventData{quantity:qty,..}) =&gt; <br/>         <strong class="ki hi">self</strong>.qty_on_hand.<strong class="ki hi">checked_add</strong>(qty).unwrap_or(0),<br/>    &amp;ProductEvent::Reserved(<br/>       ProductEventData{quantity:qty,..}) =&gt; <br/>         <strong class="ki hi">self</strong>.qty_on_hand.<strong class="ki hi">checked_sub</strong>(qty).unwrap_or(0),<br/>    _ =&gt; <strong class="ki hi">self</strong>.qty_on_hand,<br/>  };<br/>  <strong class="ki hi">self</strong><br/>}</span></pre><p id="8268" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个替代版本更高效、更易读，并且它还强调了一个微妙但关键的点:有对<code class="du ks kt ku ki b">checked_sub</code>或<code class="du ks kt ku ki b">checked_add</code>的调用，这些调用将一个可能引起恐慌的数学运算转换成一个<code class="du ks kt ku ki b">Option</code>类型。这里我调用<code class="du ks kt ku ki b">unwrap_or(0)</code>来使用值0，如果真实的数量会产生溢出。</p><p id="afe6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这让我想到了另一个我们经常忽略的事件源领域:<em class="jn">聚合的损坏</em>。这里真正应该发生的是，如果<code class="du ks kt ku ki b">checked_sub</code>返回<code class="du ks kt ku ki b">None</code>，我们应该将<code class="du ks kt ku ki b">self.over_reserved</code>(或一些类似的故障指示器)设置为true。如果我们真的很勤奋，我们可能还想保存对产生腐败的事件的引用。</p><p id="7db5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">理想情况下，不应该有任何东西进入持久事件存储库，否则会破坏集合，但是我们应该始终警惕这样的事情。<em class="jn">命令</em>验证器补丁中的一段坏代码可能会让一个事件通过，这可能会搞乱我们的聚合，<em class="jn">尤其是</em>如果命令和查询服务被隔离的话。这种逻辑会产生连锁故障。如果您的代码基于静默抑制聚合的不良事件序列做出决策，它可能会在下游创建进一步的损坏事件。<em class="jn">永远不要让一件坏事产生一个好的总和</em>。</p><p id="e525" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，现在我们已经实现了聚合的命令和应用方面，我们可以调用apply来计算状态:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="5ee6" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">let </strong>soap = ProductAggregate::<em class="jn">new</em>("SOAP", 100);<br/><strong class="ki hi">let </strong>u = soap.apply(&amp;ProductEvent::<em class="jn">reserved</em>("SOAP", 10));<br/><strong class="ki hi">let </strong>u = u.apply(&amp;ProductEvent::<em class="jn">reserved</em>("SOAP", 30));</span></pre><p id="d231" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的另一个微妙之处是，<em class="jn"> apply </em>方法接受一个对事件的<em class="jn">引用</em>。这明确地告诉聚合的使用者，它没有声明事件的所有权。如果我们使用的是效率更高的<code class="du ks kt ku ki b">apply</code>版本，那么如果我们在第一次调用<code class="du ks kt ku ki b">apply</code>后试图引用<code class="du ks kt ku ki b">soap</code>，我们就会与Rust臭名昭著的借项检查器发生冲突(错误消息会显示产生错误的确切行，并类似于<em class="jn">“移动后此处使用的值”</em>)。</p><p id="f86c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">前面的代码是<em class="jn">好的</em>，但是既然我们使用了Rust，我想我们可以做得更好。前面我提到过，想要一个更函数化的方法来计算状态可能是别有用心的。那些已经在函数式语言中工作了一段时间的人可能会认识到，重复地将一个事物重新赋值给该事物的新版本正是一个<strong class="ir hi"> <em class="jn"> fold </em> </strong>所做的事情。</p><p id="383e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以将一个事件向量转换成一个迭代器，并通过一个<strong class="ir hi">文件夹</strong>将它们传送出去，如下所示:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="675d" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">let </strong>agg = v.iter()<br/>    .fold(ProductAggregate::<em class="jn">new</em>("CEREAL", 100), |a, <strong class="ki hi">ref </strong>b| {<br/>        a.apply(b)<br/>    });</span></pre><p id="ee84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们已经有了最初的产品，我们可以写得更简单:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="224e" class="km kn hh ki b fi ko kp l kq kr"><strong class="ki hi">let</strong> agg = v.iter().fold(init, |a, <strong class="ki hi">ref</strong> b| a.apply(b));</span></pre><p id="5ee7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在<em class="jn">这个</em>就是事情开始有回报的地方。那里有很多力量在发生。在Rust中，可变性是由消费者选择的，而不是由结构决定的。因此，fold的<code class="du ks kt ku ki b">init</code>参数，即我的“第一个”值，是一个初始现有量为100的<em class="jn">不可变集合</em>。然后我可以调用fold，在fold的每次迭代中，我只需返回<code class="du ks kt ku ki b">a.apply(b)</code>。在更高效的<code class="du ks kt ku ki b">apply</code>版本中，这将聚合移入返回值，而不是分配一个新值。现在我们开始看到这种重构的一些好处:事件向量越大，<code class="du ks kt ku ki b">apply</code>的“复制和分配”版本的性能就越差。</p><p id="2a90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我不是在整个文件夹中传递一个可变值。相反，我在每一步之后都返回一个新的、不变的值。最后，<code class="du ks kt ku ki b">agg</code>变量是不可变的，它将包含我所有的计算状态。因为我已经让所有的命令方法<em class="jn">返回</em>事件，而不是改变集合本身，所以我可以直接对<code class="du ks kt ku ki b">agg</code>变量发出命令，而不必担心改变可变性或与Rust的借用检查器冲突。</p><p id="1ded" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总之，这只是一个事件采购从业者的观点和示例实现。我在这里的目标不是向大家展示有史以来最好的ES实现，而是提醒大家，我们仍然可以拥有Rust的所有低级性能和安全性，同时仍然可以为高级模式(如事件源和CQRS)生成简单而优雅的代码。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><p id="984d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">披露声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>