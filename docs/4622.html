<html>
<head>
<title>Why I use Tape
Instead of Mocha &amp;
So Should You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我用胶带代替摩卡&amp;你也应该这样</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4?source=collection_archive---------0-----------------------#2015-07-13">https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4?source=collection_archive---------0-----------------------#2015-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0863" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">测量软件质量</h2></div></div><div class="ha hb hc hd he"><blockquote class="iw ix iy"><p id="4206" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">更新:我现在用<a class="ae jw" href="https://github.com/paralleldrive/riteway" rel="noopener ugc nofollow" target="_blank"> RITEway </a>代替胶带。它包装了磁带，使得编写优秀的单元测试更加简单，当单元测试失败时，可以提供清晰的错误报告。参见<a class="ae jw" rel="noopener" href="/javascript-scene/rethinking-unit-test-assertions-55f59358253f">“重新思考单元测试断言”</a>了解更多细节。</p><p id="4bc4" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">TL；DR:摩卡是一辆15万美元的保时捷Panamera，而最好的工具是一辆3万美元的特斯拉Model 3。不要把你的资源浪费在测试华而不实的东西上。相反，投资他们来创建你的应用程序。</p></blockquote><p id="c0cd" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">有时受欢迎程度是质量的标志。其他时候，受欢迎的东西是因为受欢迎而受欢迎，而不是因为它们比替代品更好。</p><p id="125c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">在实际的生产项目中，我使用过Jasmine、Mocha、NodeUnit、Tape和其他一些解决方案。我已经调查了<em class="jb">许多其他的选择。</em>在过去的几年里，我已经并将继续在我所有的个人项目和我领导的项目中使用<a class="ae jw" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank"> Tape </a>和Supertest(用于API测试)。</p><h2 id="de3c" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">什么是单元测试？</h2><p id="f933" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">单元测试的存在是为了测试软件功能的单个单元。单元是一个模块、组件或函数。它们是程序的一部分，可以独立于程序的其他部分工作。单元测试的存在意味着软件是以模块化的方式设计的。你可能偶尔会听说有办法让软件“更易测试”</p><p id="1329" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果你发现很难在不嘲笑其他东西的情况下为你的程序编写单元测试，那就是你的程序不够模块化的迹象。揭示紧密耦合(模块化的对立面)是单元测试在软件创建中扮演的许多重要角色之一。</p><p id="47ad" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">每个模块都应该有单元测试，每个应用程序都应该由模块组成。换句话说，如果你不写单元测试，你应该写。</p><h2 id="a076" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">摩卡、茉莉等怎么了…？</h2><ol class=""><li id="3157" class="la lb hh jc b jd kv jg kw jx lc jy ld jz le jv lf lg lh li bi translated"><strong class="jc hi">太多配置:</strong>选择一个断言库，选择一个报告库，选择一个任务运行器(Grunt，Gulp，等等…)然后弄清楚如何将文档示例翻译成你选择的报告库/任务运行器。所有这些都是太多的认知负荷。<em class="jb"> Vs:选择胶带。完成了。</em></li><li id="727a" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv lf lg lh li bi translated"><strong class="jc hi"> Globals: </strong> Mocha、Jasmine和其他几个替代品用类似<em class="jb"> `describe` </em>、<em class="jb"> `it` </em>等函数污染了全球环境……一些断言库扩展了内置原型。除了去除简单模块导出的自文档化特性之外，这些决定可能会与您试图测试的代码发生冲突。<em class="jb"> Vs:磁带的简单模块导出。</em></li><li id="07b1" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv lf lg lh li bi translated"><strong class="jc hi">共享状态:</strong>像<em class="jb"> `beforeEach` </em>和<em class="jb"> `afterEach` </em>这样的功能积极鼓励你做一些你<strong class="jc hi">绝对不应该做的事情</strong>:在测试之间共享状态。<em class="jb"> Vs. Tape:全局状态共享无此功能。相反，从单个测试中调用setup和teardown例程，并且</em> <strong class="jc hi"> <em class="jb">包含所有状态到局部测试变量。</em>T13】</strong></li></ol><h2 id="e36b" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">为什么是磁带？</h2><p id="5682" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">Mocha做了太多，给了开发人员太多的断言选择，这导致了<a class="ae jw" href="http://en.wikipedia.org/wiki/Analysis_paralysis" rel="noopener ugc nofollow" target="_blank">分析瘫痪</a>和生产力损失。每次我看到Mocha被用在一个项目上，我都看到开发人员在测试框架和测试环境上浪费了太多的时间。</p><p id="3479" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">当我咆哮的时候，如果我没有提到如果你在mocks和stubs上花了很多时间，那是一种强烈的代码味道，那我就失职了。通过将你的应用程序分成更多的模块，你可以极大地简化你的测试和应用程序。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="0d66" class="lw lx hh bd ly lz ma mb mc md me jv dx translated">嘲讽是一种代码气味。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="5061" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这里和那里的一些简单的模拟是确定的。你的一些应用将不可避免地涉及副作用(例如，从网络或文件系统中读取或写入)。当你真的需要模仿时，保持简单。比基本存根多一点是理想的。但是在许多项目中，我看到了许多原本不需要存在的过于复杂的模拟。为什么要维护不必要的代码呢？</p><p id="1290" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">你越是将问题分解成简单的<a class="ae jw" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯</a> <a class="ae jw" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4">函数</a>，就越容易在没有模仿的情况下测试你的代码<em class="jb">。</em></p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="a9c6" class="lw lx hh bd ly lz ma mb mc md me jv dx translated">测试不是你应该花大部分时间去做的事情。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="807c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">在有限的时间内，你应该花大部分时间考虑如何创建最好的、最灵活的、性能最好的解决方案。在软件开发的世界里，时间就是价值，你不应该浪费一分钟。</p><p id="850b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果你喜欢烧钱，就用摩卡、茉莉花茶、Jest，等等。但是如果你珍惜你的时间，继续读下去。</p><p id="577c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">在许多BDD断言库中，有一些带有副作用的getters。在我工作的一家公司(不指名道姓)，这在我们的一个测试中埋下了一个bug，我们花了太多时间调试测试用例，而不是开发实际的应用程序代码。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="6235" class="lw lx hh bd ly lz ma mb mc md me jv dx translated">测试断言应该非常简单，<br/> &amp; <a class="ae jw" href="https://en.wikipedia.org/wiki/Magic_(programming)" rel="noopener ugc nofollow" target="_blank">完全没有魔法</a>。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="e33b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><em class="jb"> `equal` </em>，<em class="jb"> `deepEqual` </em>，<em class="jb">` pass `</em>&amp;<em class="jb">` fail `</em>是我主要的首选断言。如果<em class="jb"> `equal` </em>和<em class="jb"> `deepEqual` </em>是唯一可用的断言，那么测试界可能会因此变得更好。</p><p id="e43c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">为什么？<em class="jb">` equal`</em>&amp;<em class="jb">` deep equal`</em>提供了关于期望的质量信息，并且它们导致非常简洁的测试用例，这些测试用例<strong class="jc hi">易于阅读&amp;维护。</strong></p><p id="03e7" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">当你写bug报告时，你应该总是<em class="jb">提供描述，</em>解释<em class="jb">你期望看到的</em>，解释<em class="jb">你实际看到的</em>。</p><p id="4d96" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">测试用例应该以大致相同的方式编写:</p><ol class=""><li id="5234" class="la lb hh jc b jd je jg jh jx mf jy mg jz mh jv lf lg lh li bi translated">用简单的英语描述你正在测试的特性。</li><li id="4d9a" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv lf lg lh li bi translated">提供测试的预期结果。这部分就是为什么很多单元测试被称为<em class="jb">期望的原因。</em></li><li id="b158" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv lf lg lh li bi translated">将其与<em class="jb">实际值进行比较。</em></li></ol><p id="a64a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">当一个单元测试失败时，错误消息就是你的错误报告。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="cb76" class="lw lx hh bd ly lz ma mb mc md me jv dx translated">你的测试描述应该足够清晰，可以作为文档使用。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><figure class="mi mj mk ml fd mm"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="2ca0" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果您以这种方式编写测试，您的测试错误消息应该足够清晰，可以用作错误报告:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="6750" class="ka kb hh mq b fi mu mv l mw mx">TAP version 13<br/># A passing test<br/>ok 1 This test will pass.<br/># Assertions with tape.<br/>not ok 2 Given two mismatched values, .equal() should produce a nice bug report<br/>  ---<br/>    operator: equal<br/>    expected: 'something to test'<br/>    actual:   'sonething to test'<br/>  ...</span><span id="4571" class="ka kb hh mq b fi my mv l mw mx">1..2<br/># tests 2<br/># pass 1<br/># fail 1</span></pre></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="63d1" class="lw lx hh bd ly lz ma mb mc md me jv dx translated">你的自动化测试错误消息<br/>就是你的错误报告。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="e05e" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">简单测试断言提供:</p><ul class=""><li id="5ae8" class="la lb hh jc b jd je jg jh jx mf jy mg jz mh jv mz lg lh li bi translated">可读性更好。</li><li id="ec26" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv mz lg lh li bi translated">代码更少。</li><li id="214a" class="la lb hh jc b jd lj jg lk jx ll jy lm jz ln jv mz lg lh li bi translated">维护更少。</li></ul><p id="aa88" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这些功能胜过世界上所有的花里胡哨。</p><p id="5f26" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><strong class="jc hi">没有比赛。</strong></p><h2 id="76bc" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">测试工具应该是模块化的</h2><p id="3745" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">一些测试框架(Mocha、Jest等)提供了比简单的测试运行程序更多的服务。他们想把你的测试格式化，以便于阅读，否则他们会自动地嘲笑你。(还记得我说过的测试套件中的魔法吗？)</p><p id="5f08" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">他们试图成为端到端的测试解决方案。从将Mocha驱动的测试框架从仅客户端测试移植到通用JavaScript测试的经验来看，请相信我:有时端到端可能会很糟糕。</p><p id="3181" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">Jest标榜自己是一个更好的端到端解决方案，可以自动模仿节点模块。你大概可以想象我对此的看法。</p><p id="7f98" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">像Mocha和Jasmine这样的解决方案比磁带更难适应您的持续集成管道。</p><h2 id="50f4" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">轻敲，水龙头</h2><p id="ae8f" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">TAP是从1987年就存在的<a class="ae jw" href="https://en.wikipedia.org/wiki/Test_Anything_Protocol#History" rel="noopener ugc nofollow" target="_blank">测试任何东西协议</a>。几乎所有重要的自动化测试工具都支持TAP输出。有生成彩色控制台报告的TAP处理器，有制作漂亮、有风格的HTML的处理器，有可以对结果进行分支并触发各种钩子的处理器，等等…</p><p id="ce88" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">您可以将Tape视为一个纯粹的CLI工具，它将单元测试作为输入，并将TAP作为输出。使用每个节点平台上可用的标准Unix工具，您可以将磁带与几乎任何可以从stdin读取并理解TAP输出的工具集成在一起。</p><p id="f94d" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">还记得上面平淡无奇的测试输出吗？它看起来是这样的:</p><figure class="mi mj mk ml fd mm er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/0f1990c3e4c7dfb93f19ba5f48bbf304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMh82PZ4qSbqj1bEjDxTGQ.png"/></div></div></figure><h2 id="7efb" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">轮到你了！</h2><p id="c5b9" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">复制并粘贴上面的测试代码，并在您的终端中运行以下命令:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="2b0a" class="ka kb hh mq b fi mu mv l mw mx">npm install -g babel-cli tape faucet browserify browser-run<br/>npm install --save-dev babel-preset-es2015 babelify tape</span></pre><p id="6f41" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">您还需要一个<em class="jb"> `.babelrc` </em>文件:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="8e13" class="ka kb hh mq b fi mu mv l mw mx">{<br/>  "presets": ["es2015"]<br/>}</span></pre><p id="1269" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">那就试一试:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="b4f3" class="ka kb hh mq b fi mu mv l mw mx">babel-node test.js | faucet</span></pre><p id="1049" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">很酷吧。</p><p id="9e3c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">但是如果您想在浏览器中运行您的测试呢？试试这个:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="ab90" class="ka kb hh mq b fi mu mv l mw mx">browserify -t babelify test.js | browser-run -p 2222</span></pre><p id="f01f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">打开浏览器，导航至:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="14cf" class="ka kb hh mq b fi mu mv l mw mx">http://localhost:2222</span></pre><p id="01fa" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果你正盯着一张白纸，不要担心。切换回你的控制台看看。您应该看到这个:</p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="c7e1" class="ka kb hh mq b fi mu mv l mw mx">TAP version 13<br/># A passing test<br/>ok 1 This test will pass.<br/># Assertions with tape.<br/>not ok 2 Given two mismatched values, .equal() should produce a nice bug report<br/>  ---<br/>   operator: equal<br/>   expected: ‘something to test’<br/>    actual: ‘sonething to test’<br/>   at: Test.assert (http://localhost:2222/bundle.js?87789b09:5195:17)<br/>  ...</span><span id="dcb9" class="ka kb hh mq b fi my mv l mw mx">1..2<br/># tests 2<br/># pass 1<br/># fail 1</span></pre><p id="2051" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">眼熟吗？你甚至可以通过<em class="jb">【水龙头】:</em></p><pre class="mi mj mk ml fd mp mq mr ms aw mt bi"><span id="5702" class="ka kb hh mq b fi mu mv l mw mx">browserify -t babelify test.js | browser-run -p 2222 | faucet</span></pre><figure class="mi mj mk ml fd mm er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es nh"><img src="../Images/c1c070b76b3de8f5367bcf44cccf1b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngzfOQOLpjd9hodsdyv7-w.png"/></div></div></figure><h2 id="9f16" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">模块化&gt; *</h2><p id="b895" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">摩卡，茉莉，杰斯特和其他的？对杂乱说不。简化你的生活。体验<strong class="jc hi">试禅。</strong></p><p id="6517" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">您真的需要一个认为<em class="jb">自己的方式是唯一方式的端到端解决方案，</em>还是想要一个可以直接插入任何标准系统工作流的解决方案？</p><p id="4ace" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果你是为了接近100%的覆盖率而写的(你应该这样)，你的测试套件很可能比你的应用程序要大。如果您决定明天改变您的测试工作流程，该怎么办？你认为你一天能移植多少测试套件？</p><p id="5cf3" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我最近开始在单元测试中使用承诺。我从胶带换成了蓝色胶带，它只是胶带周围的一层薄薄的包装，以增加承诺支持。我不需要改变一个单元测试就能让它工作。我根本不需要改变我的测试和持续交付管道中的任何东西。</p><p id="77de" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">几周前，我将整个应用测试套件从QUnit (jQuery测试框架)移植到磁带上。花了5分钟。在最近的一项工作中，我将大量内联断言从实时代码转移到单元测试中(这是这些特定断言的更好位置)。我真的复制，粘贴，做了一个搜索和替换。</p><h2 id="d880" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">平行测试</h2><p id="50dc" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">认为您会错过automagic测试并行化吗？我将不同模块的测试保存在不同的文件中。编写一个小小的包装器需要大约五分钟的时间，这个包装器将在你所有的机器核心上激发工人，并并行地压缩它们。</p><h2 id="4d06" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">之前/之后/之前/之后</h2><p id="b2ac" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">你不需要这些。它们不利于您的测试套件。真的。我经常看到这些人被滥用来分享全球状态。<em class="jb">试试这个，改为:</em></p><figure class="mi mj mk ml fd mm"><div class="bz dy l di"><div class="mn mo l"/></div></figure><h2 id="02ca" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">更少的功能是新的功能丰富</h2><p id="02b8" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">因为磁带是一个如此简单的模块，具有如此简单的功能，所以很容易对其进行扩展，使其适合许多不同的工作流。例如，看一看<a class="ae jw" href="https://github.com/cloverfield-tools/prod-module-boilerplate" rel="noopener ugc nofollow" target="_blank">clover field prod-module-boilerplate</a><a class="ae jw" href="https://github.com/cloverfield-tools/prod-module-boilerplate/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package . JSON</a>。</p><p id="97e2" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><em class="jb"> `blue-tape` </em>只是一个简单的磁带包装器，增加了promise支持，所以你可以编写这样的测试:</p><figure class="mi mj mk ml fd mm"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="825c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">将所有这些东西与持续集成服务集成也是轻而易举的事情。我们将prod-module-boilerplate配置为在<a class="ae jw" href="https://travis-ci.org/cloverfield-tools/prod-module-boilerplate" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>和<a class="ae jw" href="https://circleci.com/gh/cloverfield-tools/prod-module-boilerplate/tree/master" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>中验证我们的新包提交。</p><p id="c52b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">注:如果你正在单元测试<a class="ae jw" rel="noopener" href="/javascript-scene/baby-s-first-reaction-2103348eccdd"> React组件</a>，使用<a class="ae jw" href="http://simonsmith.io/unit-testing-react-components-without-a-dom/" rel="noopener ugc nofollow" target="_blank">浅层渲染器</a>。</p><p id="855d" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">你想要华而不实的东西，还是想要灵活性？如果你想让你的测试不碍事，让你专注于构建东西…</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><blockquote class="lv"><p id="e6cd" class="lw lx hh bd ly lz ma mb mc md me jv dx translated"><strong class="ak">你打不过</strong> <a class="ae jw" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">胶带</strong> </a> <strong class="ak">。</strong></p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h1 id="920b" class="ni kb hh bd kc nj nk nl kg nm nn no kk in np io kn iq nq ir kq it nr iu kt ns bi translated">编辑:2018年11月</h1><p id="763b" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">最近，我在我的“测试应该非常简单”的哲学上加倍努力，写了一个薄薄的磁带包装，只暴露了深层的等式断言。换句话说，也许你可以通过删除磁带上的特征来击败磁带。</p><p id="6d47" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">查看<a class="ae jw" rel="noopener" href="/javascript-scene/rethinking-unit-test-assertions-55f59358253f">“重新思考单元测试断言”</a>了解更多信息。</p><blockquote class="lv"><p id="1990" class="lw lx hh bd ly lz ma mb mc md me jv dx translated"><a class="ae jw" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank">跟随埃里克·埃利奥特学习JavaScript】</a></p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="b25b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><strong class="jc hi"> <em class="jb">埃里克·艾略特</em> </strong> <em class="jb">著有《编程JavaScript应用》</em>  <em class="jb"> (O'Reilly)，纪录片《制作中的主持人，</em> <strong class="jc hi"> <em class="jb">【编程素养】</em> </strong> <em class="jb">。他为Adobe Systems</em><strong class="jc hi"><em class="jb"/></strong><em class="jb"/><strong class="jc hi"><em class="jb">尊巴健身</em></strong><em class="jb"/><strong class="jc hi"><em class="jb">华尔街日报</em></strong><em class="jb"/><strong class="jc hi"><em class="jb">【ESPN</em></strong><em class="jb"/><strong class="jc hi"><em class="jb">BBC</em></strong><em class="jb">等顶级录音师贡献了软件经验</em></p><p id="61a2" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>