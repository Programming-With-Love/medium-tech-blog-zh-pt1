# 物体构图的隐藏宝藏

> 原文：<https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381?source=collection_archive---------1----------------------->

![](img/b5319c93f5a4237f1472d1686f5b1e6f.png)

Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)

> **注:**这是《作曲软件》系列的一部分**s**[(现在一本书！)](https://leanpub.com/composingsoftware) 从基础开始学习 JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！[*买书*](https://leanpub.com/composingsoftware) *|* [*索引*](/javascript-scene/composing-software-the-book-f31c77fc3ddc)*|*[*<上一篇*](/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f) *|* [*下一篇>*](/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1)

> "对象组合组装或组合对象以获得更复杂的行为."~四人帮，[《设计模式:可复用面向对象软件的要素》](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612//ref=as_li_ss_tl?ie=UTF8&linkCode=ll1&tag=eejs-20&linkId=06ccc4a53e0a9e5ebd65ffeed9755744)
> 
> "优先选择对象组合而不是类继承."~四人帮，“设计模式”。

软件开发中最常见的错误之一是倾向于过度使用类继承。类继承是一种代码重用机制，其中实例与基类形成关系。如果您试图使用 *is-a* 关系(例如，一只鸭子 *is-a* bird)来为您的域建模，那么您一定会遇到麻烦，因为类继承是面向对象设计中最紧密的耦合形式，这会导致许多常见问题，包括(除其他之外):

*   脆弱的基础类问题
*   大猩猩/香蕉问题
*   必然复制问题

类继承通过将公共接口抽象成基类来实现重用，子类可以继承、添加和覆盖基类。**抽象**有两个重要部分:

*   **概括**仅提取服务于一般用例的共享属性和行为的过程
*   **专门化**提供为特殊情况服务所需的实现细节的过程

有很多方法可以实现代码的一般化和特殊化。类继承的一些好的替代方法包括简单函数、高阶函数和*对象组合*。

不幸的是，对象构成很容易被误解，许多人很难从对象构成的角度来思考问题。是时候更深入地探讨这个话题了。

# 什么是物体构成？

> 在计算机科学中，复合数据类型或复合数据类型是可以在程序中使用编程语言的原始数据类型和其他复合类型构建的任何数据类型。[……]构造复合类型的行为称为组合。”~维基百科

围绕对象组合的混乱的原因之一是，任何形成复合对象的基元类型的组装都是对象组合的一种形式，但是继承技术经常与对象组合相对照来讨论，好像它们是不同的东西。双重意义的原因是宾语成分的语法和语义有区别。

当讨论对象组合和类继承时，我们不是在讨论具体的技术:我们在讨论组成对象之间的*语义关系*和*耦合度*。我们正在谈论的是*的意思*，而不是*语法*。人们经常搞不清这种区别，陷入语法细节的泥沼。他们只见树木不见森林。

有许多不同的方式来组成对象。不同的组合形式会产生不同的组合结构和不同的对象关系。当对象依赖于与之相关的对象时，这些对象是耦合的，这意味着改变一个对象可能会破坏另一个对象。

“四人帮”建议“优先选择对象组合而不是类继承”,这让我们认为我们的对象是由更小的、松散耦合的对象组合而成的，而不是从一个单一的基类大量继承而来的。GoF 将紧密耦合的对象描述为“整体系统，在这个系统中，如果不理解和更改许多其他类，就不能更改或删除一个类。这个系统变得非常庞大，很难学习、移植和维护。”

# 三种不同形式的对象组合

在“设计模式”中，四人组声称，“你会看到对象组合在设计模式中一次又一次地被应用”，并继续描述各种类型的组合关系，包括*聚合*和*委托*。

“设计模式”的作者主要使用 Smalltalk 和 C++(后来，例子被翻译成 Java)。在这些语言中，在运行时构建和更改对象关系要比在 JavaScript 中复杂得多，所以可以理解的是，它们并没有包括这个主题的很多细节。然而，如果不讨论动态对象扩展，即*串联，那么关于 JavaScript 中对象组合的讨论就不完整。*

出于对 JavaScript 的适用性和形成更清晰的概括的原因，我们将稍微偏离“设计模式”中使用的定义*。例如，我们不需要聚合*暗示对子对象生命周期的*控制。这在具有动态对象扩展的语言中是不正确的。*

选择错误的公理会不必要地限制一个有用的概括，并迫使我们为同一总体思想的特例想出另一个名称。软件开发人员不喜欢在我们不需要的时候重复我们自己。

*   **聚合**当一个对象由一个可枚举的子对象集合构成时。换句话说，一个*包含*其他对象的对象。每个子对象保留其自己的引用标识，使得它可以从聚集中被析构而没有信息丢失，例如数组、树等。
*   **串联**当一个对象通过向一个现有对象添加新属性而形成时。属性可以一次连接一个，也可以从现有对象复制，例如，通过将新方法连接到 jQuery 委托原型`jQuery.fn`来创建 jQuery 插件。
*   **委托**当一个对象转发或*委托给*另一个对象时。例如，[伊凡·苏泽兰的画板](https://youtu.be/3wrn9cxlgls?t=250) (1962)(发表在他的[有影响力的 1963 年论文](https://dspace.mit.edu/handle/1721.1/14979)中)包括引用“主人”的实例，这些“主人”被委托给共享属性。Photoshop 包括“智能对象”,作为本地代理，委托给外部资源。JavaScript 的原型也是委托:数组实例将内置数组方法调用转发给`Array.prototype`，将对象转发给`Object.prototype`，等等...

值得注意的是，这些不同形式的组合并不相互排斥。可以使用聚合实现委托，在 JavaScript 中使用委托实现类继承。许多软件系统使用不止一种类型的组合，例如，jQuery 的插件使用串联来扩展 jQuery 委托原型`jQuery.fn`。当客户端代码调用插件方法时，请求被委托给连接到委托原型的方法。

> *代码示例说明下面的代码示例将共享以下设置代码:*

```
const objs = [
  { a: 'a', b: 'ab' },
  { b: 'b' },
  { c: 'c', b: 'cb' }
];
```

# 聚合

聚合是指一个对象由一个可枚举的子对象集合构成。一个集合是一个*包含*其他对象的对象。聚合中的每个子对象都保留自己的引用标识，并且可以从聚合中无损析构。聚集体可以用各种各样的结构来表示。

## 例子

*   数组
*   地图
*   设置
*   图表
*   树
*   DOM 节点(一个 DOM 节点可能*包含*子节点)
*   UI 组件(一个组件可能*包含*子组件)

## 何时使用

每当存在需要共享公共操作的对象集合时，例如 iterables、stacks、queues、trees、graphs、state machines 或 composite pattern(当您希望单个项目与多个项目共享同一个接口时)。

## 考虑

聚合非常适合应用通用抽象，例如对聚合的每个成员应用一个函数(例如`array.map(fn)`)，将向量转换为单个值，等等。然而，如果潜在地存在几十万或几百万个子对象，那么流处理可能更有效。

## 代码示例

阵列聚合:

```
const collection = (a, e) => a.concat([e]);const a = objs.reduce(collection, []);console.log( 
  'collection aggregation',
  a,
  a[1].b,
  a[2].c,
  `enumerable keys: ${ Object.keys(a) }`
);
```

这将产生:

```
collection aggregation
[{"a":"a","b":"ab"},{"b":"b"},{"c":"c","b":"cb"}]
b c
enumerable keys: 0,1,2
```

使用对的链表聚合:

```
const pair = (a, b) => [b, a];const l = objs.reduceRight(pair, []);console.log(
  'linked list aggregation',
  l,
  `enumerable keys: ${ Object.keys(l) }`
);/*
linked list aggregation
[
  {"a":"a","b":"ab"}, [
    {"b":"b"}, [
      {"c":"c","b":"cb"},
      []
    ]
  ]
]
enumerable keys: 0,1
*/
```

链表是许多其他数据结构和聚合的基础，比如数组、字符串和各种树。还有许多其他可能的聚合类型。这里我们不会深入讨论它们。

# 串联

串联是指通过向现有对象添加新属性来形成对象。

## 例子

*   插件通过串联被添加到`jQuery.fn`
*   状态缩减器(例如 Redux)
*   功能混合蛋白

何时使用:在运行时逐步组装数据结构非常有用的任何时候，例如，合并 JSON 对象、合并来自多个来源的应用程序状态、创建对不可变状态的更新(通过合并以前的状态和新数据)等

## 考虑

*   改变现有对象时要小心。共享的可变状态是许多错误的根源。
*   用串联来模拟类的层次结构和 is-a 关系是可能的。同样的问题也适用。从组成小的、独立的对象的角度考虑，而不是从“基础”实例继承道具并应用差异继承。
*   当心隐含的组件间依赖。
*   属性名冲突按连接顺序解决:后来者居上。这对于默认/覆盖行为很有用，但是如果顺序不重要的话可能会有问题。

```
const concatenate = (a, o) => ({...a, ...o});const c = objs.reduce(concatenate, {});console.log(
  'concatenation',
  c,
  `enumerable keys: ${ Object.keys(c) }`
);// concatenation { a: 'a', b: 'cb', c: 'c' } enumerable keys: a,b,c
```

# 委托

委托是指一个对象转发或*委托给*另一个对象。

## 例子

*   JavaScript 的内置类型使用委托将内置方法调用向上转发到原型链。例如，`[].map()`代表到`Array.prototype.map()`，`obj.hasOwnProperty()`代表到`Object.prototype.hasOwnProperty()`等等。
*   jQuery 插件依靠委托在所有 jQuery 对象实例之间共享内置方法和插件方法。
*   画板的“主人”是动态的代表。对委托的修改会立即反映在所有对象实例中。
*   Photoshop 使用称为“智能对象”的代理来引用单独文件中定义的图像和资源。智能对象引用的对象更改会反映在智能对象的所有实例中。

## 何时使用

1.  节约内存:任何时候都可能存在一个对象的多个实例，在每个实例之间共享相同的属性或方法是很有用的，否则就需要分配更多的内存。
2.  动态更新多个实例:任何时候，一个对象的多个实例需要共享相同的状态，这可能需要动态更新，并且变化会即时反映在每个实例中，例如 Sketchpad 的“masters”或 Photoshop 的“smart objects”。

## 考虑

*   委托通常用于模仿 JavaScript 中的类继承(由`extends`关键字连接)，但实际上很少需要。
*   委托可以用来精确模拟类继承的行为和限制。事实上，JavaScript 中的类继承是通过原型委托链建立在静态委托之上的。避免*是-一种*思维。
*   使用常见的机制，如`Object.keys(instanceObj)`，委托属性是不可枚举的。
*   委托以牺牲属性查找性能为代价节省了内存，并且一些 JS 引擎优化对于动态委托(创建后会改变的委托)是关闭的。然而，即使在最慢的情况下，属性查找性能也是以每秒百万次运算来衡量的——这很可能不是您的瓶颈，除非您正在构建一个用于对象操作或图形编程的实用程序库，例如 RxJS 或 three.js
*   需要区分实例状态和委托状态。
*   动态委托上的共享状态不是实例安全的。所有实例共享更改。动态委托上的共享状态通常(但不总是)是一个错误。
*   ES6 类不会在 ES6 中创建可重新分配的委托。它们可能看起来在巴别塔工作，但是在真实的 ES6 环境中会很难成功。

# 代码示例

```
const delegate = (a, b) => Object.assign(Object.create(a), b);

const d = objs.reduceRight(delegate, {});

console.log(
  'delegation',
  d,
  `enumerable keys: ${ Object.keys(d) }`
);

// delegation { a: 'a', b: 'ab' } enumerable keys: a,b

console.log(d.b, d.c); // ab c
```

# 结论

我们了解到:

*   所有由其他对象和语言原语构成的对象都是*复合对象*。
*   创建复合对象的行为被称为*合成*。
*   有不同种类的对象组成。
*   根据对象的构成方式，我们在构成对象时形成的关系和依赖关系会有所不同。
*   *Is-a 关系*(由类继承形成的那种)是面向对象设计中最紧密的耦合形式，实际应用时一般应该避免。
*   “四人帮”告诫我们要通过将较小的功能组合成较大的整体来构成对象，而不是从单一的基类或基对象继承。"优先选择对象组合而不是类继承."
*   聚合将对象组成可枚举的集合，集合中的每个成员都保留自己的身份，例如数组、DOM 树等
*   委托通过将对象委托链链接在一起来构成对象，其中一个对象将属性查找转发或委托给另一个对象。例如，`[].map()`代表到`Array.prototype.map()`
*   串联通过用新属性扩展现有对象来组成对象，例如`Object.assign(destination, a, b)`、`{...a, ...b}`。
*   不同种类的对象组合的定义并不相互排斥。委托是聚合的子集，串联可以用来形成委托和聚合，等等…

这不是仅有的三种物体构成。还可以通过熟人/关联关系在对象之间形成松散的动态关系，其中对象作为参数传递给其他对象(依赖注入)，等等。

所有的软件开发都是合成。有简单、灵活的方式来组合对象，也有脆弱、有关节炎的方式。一些形式的对象组合形成了对象之间的松散耦合关系，而另一些则形成了非常紧密的耦合。

在程序需求的小变化只需要代码实现的小变化的地方，寻找组合的方法。清楚简明地表达你的意图，记住:如果你认为你需要类继承，很可能有更好的方法。

# 在 EricElliottJS.com 了解更多信息

EricElliottJS.com 的会员可以上关于物体构成的视频课。如果你还不是会员，今天就注册吧。

[![](img/649c1c875d8140aa42e9e3d9ffedf8e5.png)](https://ericelliottjs.com/premium-content/lesson-pure-functions)

[Start your free lesson on EricElliottJS.com](https://ericelliottjs.com/premium-content/lesson-pure-functions)

***艾里克·艾略特*** *著有《书籍》、* [*【排版软件】*](https://leanpub.com/composingsoftware)*[*【编程 JavaScript 应用】*](http://pjabook.com) *。作为*[*【EricElliottJS.com】*](https://ericelliottjs.com)*和*[*devanywhere . io*](https://devanywhere.io)*的联合创始人，他教授开发者必备的软件开发技能。他为加密项目组建开发团队并提供建议，为 Adobe Systems、* ***、Zumba Fitness、*** ***《华尔街日报》、*******【ESPN、*******BBC、*** *和顶级录音师(包括****【Usher】******

**他和世界上最美丽的女人享受着与世隔绝的生活方式。**