<html>
<head>
<title>CRUD application with NestJS and MongoDB using Mongoose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mongoose的NestJS和MongoDB的CRUD应用程序</h1>
<blockquote>原文：<a href="https://medium.com/globant/crud-application-using-nestjs-and-mongodb-99a0756adb76?source=collection_archive---------0-----------------------#2022-04-12">https://medium.com/globant/crud-application-using-nestjs-and-mongodb-99a0756adb76?source=collection_archive---------0-----------------------#2022-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/358bc5c61e9067fb5129263447d9b945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAY7yw8HjNiDhC64k3hS5g.png"/></div></div></figure><h1 id="0bc0" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak"> <em class="jn">简介</em> </strong> <em class="jn"> : </em></h1><p id="84ab" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">NestJS和MongoDB是实现可伸缩后端的绝佳组合。在这篇博客中，我们将学习如何使用Mongoose作为ORM，用NestJS和MongoDB创建CRUD应用程序。</p><p id="e1eb" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">实现这个CRUD应用程序的先决条件是，</p><ul class=""><li id="92f2" class="kr ks hh jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">我们需要MongoDB数据库，要么应该安装在本地，要么也可以使用云MongoDB数据库。在这个例子中，我在本地机器上运行了一个MongoDB服务器。如果需要，你可以从这个<a class="ae la" href="https://www.mongodb.com/try/download/community" rel="noopener ugc nofollow" target="_blank">链接</a>下载MongoDB社区版。</li><li id="7772" class="kr ks hh jq b jr lb jv lc jz ld kd le kh lf kl kw kx ky kz bi translated">应该已经安装了NestJS CLI，如果没有，请使用以下命令安装。</li></ul><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fc7b" class="lp iq hh ll b fi lq lr l ls lt">npm i @nestjs/cli</span></pre><p id="911d" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">安装完成后，我们使用下面的命令验证它是否已安装，它应该会返回已安装的NestJS CLI。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3aa7" class="lp iq hh ll b fi lq lr l ls lt">nest --version</span></pre><h1 id="62a8" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">安装:</strong></h1><p id="f6b7" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">首先，创建一个新的NestJS项目，并通过执行以下命令安装MongoDB依赖项。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7a63" class="lp iq hh ll b fi lq lr l ls lt">nest new nestjs-mongodb-crud<br/>npm install --save @nestjs/mongoose mongoose</span></pre><h1 id="932f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak"> NestJS MongoDB配置:</strong></h1><p id="efcd" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">一旦项目创建完成，我们将在<strong class="jq hi"><em class="lu">app . module . ts</em></strong>文件的导入中添加MongoDB连接。这里<strong class="jq hi"> <em class="lu"> forRoot() </em> </strong>方法从Mongoose包中接受与<strong class="jq hi"><em class="lu">mongose . connect()</em></strong>相同的配置对象。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8d19" class="lp iq hh ll b fi lq lr l ls lt">@Module({<br/>  imports: [<br/>    <!-- -->MongooseModule.forRoot('mongodb://localhost:27017',{dbName: 'studentdb'})<!-- -->,<br/>  ],<br/>})<br/>export class AppModule {}</span></pre><p id="9a86" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">如果用户名和密码存在，那么我们还需要在连接URL中提及。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="cabd" class="lp iq hh ll b fi lq lr l ls lt">@Module({<br/>  imports: [<!-- -->MongooseModule.forRoot('mongodb://&lt;username&gt;:&lt;password&gt;@localhost:27017',{dbName: 'studentdb'})<!-- -->,<br/>  ],<br/>})<br/>export class AppModule {}</span></pre><h1 id="0046" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">创建猫鼬模式:</strong></h1><p id="a680" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">添加数据库连接后，下一步是创建一个mongoose模型。新建一个文件夹<strong class="jq hi"> <em class="lu"> schema </em> </strong>并在其中新建一个schema文件<strong class="jq hi"><em class="lu">student . schema . ts</em></strong>。然后将所需的学生属性添加到文件中。添加属性后，文件将如下所示。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e812" class="lp iq hh ll b fi lq lr l ls lt">import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose"</span><span id="9e06" class="lp iq hh ll b fi lv lr l ls lt">@Schema()<br/>export class Student {<br/>   @Prop()<br/>   name: string;</span><span id="1b9b" class="lp iq hh ll b fi lv lr l ls lt">   @Prop()<br/>   roleNumber: number;</span><span id="3e7a" class="lp iq hh ll b fi lv lr l ls lt">   @Prop()<br/>   class: number;</span><span id="46f0" class="lp iq hh ll b fi lv lr l ls lt">   @Prop()<br/>   gender: string;</span><span id="ba15" class="lp iq hh ll b fi lv lr l ls lt">   @Prop()<br/>   marks: number;<br/>}</span><span id="65ca" class="lp iq hh ll b fi lv lr l ls lt">export const StudentSchema = SchemaFactory.createForClass(Student);</span></pre><p id="fef0" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">在上面的代码中，我们使用了两个NestJS装饰器:</p><p id="42e0" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">1&gt; <strong class="jq hi">模式</strong>:这个装饰器将类固定为模式定义。在这里，无论我们给这个类取什么名字，它都将作为集合的名字出现。这将把我们的学生类映射到MongoDB学生集合</p><p id="13f2" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">2&gt; <strong class="jq hi"> Prop </strong>:基本上，这个装饰器定义了文档中的一个属性。例如，在上面的模式中，我们共有5个属性，如<strong class="jq hi"> <em class="lu">名称</em> </strong>，<strong class="jq hi"> <em class="lu">角色编号</em> </strong>，<strong class="jq hi"> <em class="lu">类</em> </strong>，<strong class="jq hi"> <em class="lu">性别</em> </strong>和<strong class="jq hi"> <em class="lu">标志</em> </strong>。使用Typescript的元数据和类反射，可以自动推断这些属性的类型。</p><p id="5476" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">模式创建完成后，我们需要将其添加到模块级配置中。换句话说，我们必须在应用程序的上下文中指定这个模式的存在。我们需要在导入数组中添加一个条目。我们使用<strong class="jq hi"> <em class="lu"> forFeature() </em> </strong>的方法来注册当前范围内的模型。修改后的<strong class="jq hi"> <em class="lu"> app.module.ts </em> </strong>如下图。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c6c4" class="lp iq hh ll b fi lq lr l ls lt">import { Module } from '<a class="ae la" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>';<br/>import { MongooseModule } from '<a class="ae la" href="http://twitter.com/nestjs/mongoose" rel="noopener ugc nofollow" target="_blank">@nestjs/mongoose</a>';<br/>import { AppController } from './app.controller';<br/>import { AppService } from './app.service';<br/>import { StudentSchema } from './schema/student.schema';</span><span id="a2d4" class="lp iq hh ll b fi lv lr l ls lt"><a class="ae la" href="http://twitter.com/Module" rel="noopener ugc nofollow" target="_blank">@Module</a>({<br/>  imports: [MongooseModule.forRoot('mongodb://localhost:27017/studentdb'),<br/>  MongooseModule.forFeature([{ name: 'Student', schema: StudentSchema }])],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})<br/>export class AppModule {}</span></pre><h1 id="5fea" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">创建一个接口:</strong></h1><p id="6bfb" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">一旦mongoose模型创建完成，我们就可以为student模式创建一个接口，它定义了我们的数据对象结构的外观。现在新建一个文件夹<strong class="jq hi"> <em class="lu"> interface </em> </strong>并在其中创建<strong class="jq hi"><em class="lu">student . interface . ts</em></strong>文件。这里接口将从mongoose文档类继承属性。所有属性都是只读的，所以不能修改。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="558a" class="lp iq hh ll b fi lq lr l ls lt">import { Document } from 'mongoose';</span><span id="da0a" class="lp iq hh ll b fi lv lr l ls lt">export interface IStudent extends Document{<br/>    readonly name: string;<br/>    readonly roleNumber: number;<br/>    readonly class: number;<br/>    readonly gender: string;<br/>    readonly marks: number;<br/>}</span></pre><h1 id="0f3b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">创建DTO文件:</strong></h1><p id="f4c5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在继续创建DTO文件之前，需要安装一些依赖项。实现d to级验证需要类验证器和类转换器。安装下列软件包。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4683" class="lp iq hh ll b fi lq lr l ls lt">npm install class-validator --save<br/>npm install class-transformer --save</span></pre><p id="7b8f" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">所以现在我们将继续创建DTO文件，这些文件对定义对象模型很有用。DTO文件也可以用来定义swagger属性。现在新建一个文件夹<strong class="jq hi"> <em class="lu"> dto </em> </strong>和<strong class="jq hi"><em class="lu">create-student . dto . ts</em></strong>文件在里面。添加所有属性以及所需的验证。将属性添加到<strong class="jq hi"><em class="lu">create-student . dto . ts</em></strong>文件后，将如下所示。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bad0" class="lp iq hh ll b fi lq lr l ls lt">import { IsNotEmpty, IsNumber, IsString, MaxLength } from "class-validator";</span><span id="2f8d" class="lp iq hh ll b fi lv lr l ls lt">export class CreateStudentDto {<br/>    @IsString()<br/>    @MaxLength(30)<br/>    @IsNotEmpty()<br/>    readonly name: string;</span><span id="b60b" class="lp iq hh ll b fi lv lr l ls lt">    @IsNumber()<br/>    @IsNotEmpty()<br/>    readonly roleNumber: number;<br/>    <br/>    @IsNumber()<br/>    @IsNotEmpty()<br/>    readonly class: number;</span><span id="b1b6" class="lp iq hh ll b fi lv lr l ls lt">    @IsString()<br/>    @MaxLength(30)<br/>    @IsNotEmpty()<br/>    readonly gender: string;</span><span id="4fd5" class="lp iq hh ll b fi lv lr l ls lt">    @IsNumber()<br/>    @IsNotEmpty()<br/>    readonly marks: number;<br/>}</span></pre><p id="4fb0" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">在创建DTO文件来更新学生之前，请确保以下包存在，它将允许我们使用现有的DTO类属性</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4eeb" class="lp iq hh ll b fi lq lr l ls lt">npm i <a class="ae la" href="http://twitter.com/nestjs/mapped-types" rel="noopener ugc nofollow" target="_blank">@nestjs/mapped-types</a> --save</span></pre><p id="c23e" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">现在我们可以在<strong class="jq hi"> <em class="lu"> dto </em> </strong>文件夹中创建<strong class="jq hi"><em class="lu">update-student . dto . ts</em></strong>文件。在这个文件中<strong class="jq hi"><em class="lu">UpdateStudentDto</em></strong>将使用<strong class="jq hi"> <em class="lu"> PartialType </em> </strong>扩展<strong class="jq hi"><em class="lu">createsudentdto</em></strong>类，使createsudentdto的属性可选，可以根据需要在UpdateStudentDto类中使用。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a250" class="lp iq hh ll b fi lq lr l ls lt">import { PartialType } from '@nestjs/mapped-types';<br/>import { CreateStudentDto } from './create-student.dto';</span><span id="c55c" class="lp iq hh ll b fi lv lr l ls lt">export class UpdateStudentDto extends PartialType(CreateStudentDto) {}</span></pre><p id="d0ed" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">为了使<strong class="jq hi"><em class="lu">create-student . dto . ts</em></strong>文件中提到的验证生效，我们还需要在<strong class="jq hi"> <em class="lu"> main.ts </em> </strong>文件中注册验证管道。修改后，主文件将如下所示。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d186" class="lp iq hh ll b fi lq lr l ls lt">import { ValidationPipe } from '@nestjs/common';<br/>import { NestFactory } from '@nestjs/core';<br/>import { AppModule } from './app.module';</span><span id="f5e6" class="lp iq hh ll b fi lv lr l ls lt">async function bootstrap() {<br/>   const app = await NestFactory.create(AppModule);<br/>   app.useGlobalPipes(new ValidationPipe());<br/>   await app.listen(3000);<br/>}</span><span id="a538" class="lp iq hh ll b fi lv lr l ls lt">bootstrap();</span></pre><h1 id="4ea0" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">创建服务:</strong></h1><p id="0639" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">现在下一步是创建一个服务类。这个服务类充当请求处理程序和数据库之间的桥梁。<br/>新建一个文件夹<strong class="jq hi"> <em class="lu">服务</em> </strong>和<strong class="jq hi"> <em class="lu"> </em> </strong>使用以下命令在其中创建<strong class="jq hi"><em class="lu">student . service . ts</em></strong>文件。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="860c" class="lp iq hh ll b fi lq lr l ls lt">nest generate service student</span></pre><p id="db57" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">服务文件生成完成后，我们将实现从底层的<strong class="jq hi"> <em class="lu">学生</em> </strong>集合中创建、读取、更新和删除学生文档的方法。我们将使用<strong class="jq hi"> <em class="lu">学生模型</em> </strong>可用的标准方法来实现CRUD操作。实现这些方法后，学生服务文件将如下所示。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="863b" class="lp iq hh ll b fi lq lr l ls lt">import { Injectable, NotFoundException } from '@nestjs/common';<br/>import { InjectModel } from '@nestjs/mongoose';<br/>import { CreateStudentDto } from 'src/dto/create-student.dto';<br/>import { IStudent } from 'src/interface/student.interface';<br/>import { Model } from "mongoose";<br/>import { UpdateStudentDto } from 'src/dto/update-student.dto';</span><span id="5e97" class="lp iq hh ll b fi lv lr l ls lt">@Injectable()<br/>export class StudentService {</span><span id="250d" class="lp iq hh ll b fi lv lr l ls lt">constructor(@InjectModel('Student') private studentModel:Model&lt;IStudent&gt;) { }</span><span id="b5d2" class="lp iq hh ll b fi lv lr l ls lt">async createStudent(createStudentDto: CreateStudentDto): Promise&lt;IStudent&gt; {<br/>   const newStudent = await new this.studentModel(createStudentDto);<br/>   return newStudent.save();<br/>}</span><span id="f089" class="lp iq hh ll b fi lv lr l ls lt">async updateStudent(studentId: string, updateStudentDto: UpdateStudentDto): Promise&lt;IStudent&gt; {<br/>    const existingStudent = await        this.studentModel.findByIdAndUpdate(studentId, updateStudentDto, { new: true });</span><span id="0cbc" class="lp iq hh ll b fi lv lr l ls lt">   if (!existingStudent) {<br/>     throw new NotFoundException(`Student #${studentId} not found`);<br/>   }<br/>   return existingStudent;<br/>}</span><span id="8d92" class="lp iq hh ll b fi lv lr l ls lt">async getAllStudents(): Promise&lt;IStudent[]&gt; {<br/>    const studentData = await this.studentModel.find();</span><span id="af29" class="lp iq hh ll b fi lv lr l ls lt">    if (!studentData || studentData.length == 0) {<br/>        throw new NotFoundException('Students data not found!');<br/>    }<br/>    return studentData;<br/>}</span><span id="96bd" class="lp iq hh ll b fi lv lr l ls lt">async getStudent(studentId: string): Promise&lt;IStudent&gt; {<br/>   const existingStudent = await     this.studentModel.findById(studentId).exec();</span><span id="2406" class="lp iq hh ll b fi lv lr l ls lt">   if (!existingStudent) {<br/>    throw new NotFoundException(`Student #${studentId} not found`);<br/>   }<br/>   return existingStudent;<br/>}</span><span id="c701" class="lp iq hh ll b fi lv lr l ls lt">async deleteStudent(studentId: string): Promise&lt;IStudent&gt; {<br/>    const deletedStudent = await this.studentModel.findByIdAndDelete(studentId);</span><span id="679c" class="lp iq hh ll b fi lv lr l ls lt">   if (!deletedStudent) {<br/>     throw new NotFoundException(`Student #${studentId} not found`);<br/>   }<br/>   return deletedStudent;<br/>}<br/>}</span></pre><p id="9735" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">学生服务类是用<strong class="jq hi"><em class="lu"/>@ injectable()</strong>decorator呈现的。这意味着我们可以使用依赖注入的原则将服务类注入到其他类中。<br/>在构造函数中<strong class="jq hi"> <em class="lu"> studenModel </em> </strong>被注入到服务中，<strong class="jq hi"><em class="lu">@ inject model</em></strong>decorator用于注入操作。只有在app模块配置中注册了模式之后，才可能进行这种注入。<br/>我们还需要通过将学生服务添加到应用程序模块，使其在上下文中可用。基本上，我们将其添加到<strong class="jq hi"> <em class="lu">提供者</em> </strong>数组中。</p><h1 id="9dd0" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">创建控制器:</strong></h1><p id="462c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">现在，最后一步是实现控制器，以创建适当的请求处理程序来执行CRUD操作。通过执行下面的命令，创建一个新的文件夹<strong class="jq hi"> <em class="lu">控制器</em> </strong>并在其中创建一个<strong class="jq hi"> <em class="lu">学生.控制器. ts </em> </strong>文件。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1efd" class="lp iq hh ll b fi lq lr l ls lt">nest generate controller student</span></pre><p id="7757" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">一旦生成了控制器文件，在构造函数中我们将在运行时注入StudentService类，NestJS将向控制器提供StudentService类的实例，以访问服务文件中实现的方法。</p><p id="bfa8" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">我们实现了标准的<strong class="jq hi"> <em class="lu"> POST、PUT、DELETE </em> </strong>和<strong class="jq hi"> <em class="lu"> GET </em> </strong>请求处理程序，并使用StudentService实例调用适当的方法在其中执行各种操作。</p><p id="3e6e" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">实现这些方法后，控制器文件将如下所示。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6c7e" class="lp iq hh ll b fi lq lr l ls lt">import { Body, Controller, Delete, Get, HttpStatus, Param, Post, Put, Res } from '@nestjs/common';<br/>import { CreateStudentDto } from 'src/dto/create-student.dto';<br/>import { UpdateStudentDto } from 'src/dto/update-student.dto';<br/>import { StudentService } from 'src/service/student/student.service';</span><span id="b36d" class="lp iq hh ll b fi lv lr l ls lt">@Controller('student')<br/>export class StudentController {<br/>   constructor(private readonly studentService: StudentService) { }</span><span id="6ea7" class="lp iq hh ll b fi lv lr l ls lt">@Post()<br/>   async createStudent(@Res() response, @Body() createStudentDto: CreateStudentDto) {<br/>  try {<br/>    const newStudent = await this.studentService.createStudent(createStudentDto);</span><span id="2bce" class="lp iq hh ll b fi lv lr l ls lt">    return response.status(HttpStatus.CREATED).json({<br/>    message: 'Student has been created successfully',<br/>    newStudent,});<br/> } catch (err) {<br/>    return response.status(HttpStatus.BAD_REQUEST).json({<br/>    statusCode: 400,<br/>    message: 'Error: Student not created!',<br/>    error: 'Bad Request'<br/> });<br/> }<br/>}</span><span id="6f59" class="lp iq hh ll b fi lv lr l ls lt">@Put('/:id')<br/>async updateStudent(@Res() response,@Param('id') studentId: string,<br/>@Body() updateStudentDto: UpdateStudentDto) {<br/>  try {<br/>   const existingStudent = await this.studentService.updateStudent(studentId, updateStudentDto);</span><span id="82cb" class="lp iq hh ll b fi lv lr l ls lt">  return response.status(HttpStatus.OK).json({<br/>  message: 'Student has been successfully updated',<br/>  existingStudent,});</span><span id="c1e2" class="lp iq hh ll b fi lv lr l ls lt"> } catch (err) {<br/>   return response.status(err.status).json(err.response);<br/> }<br/>}</span><span id="32ba" class="lp iq hh ll b fi lv lr l ls lt">@Get()<br/>async getStudents(@Res() response) {<br/>try {<br/>  const studentData = await this.studentService.getAllStudents();<br/>  return response.status(HttpStatus.OK).json({<br/>  message: 'All students data found successfully',studentData,});<br/> } catch (err) {<br/>  return response.status(err.status).json(err.response);<br/> }<br/>}</span><span id="fdf1" class="lp iq hh ll b fi lv lr l ls lt">@Get('/:id')<br/>async getStudent(@Res() response, @Param('id') studentId: string) {<br/> try {<br/>    const existingStudent = await<br/>this.studentService.getStudent(studentId);</span><span id="3ab2" class="lp iq hh ll b fi lv lr l ls lt">    return response.status(HttpStatus.OK).json({<br/>    message: 'Student found successfully',existingStudent,});<br/> } catch (err) {<br/>   return response.status(err.status).json(err.response);<br/> }<br/>}</span><span id="5c2f" class="lp iq hh ll b fi lv lr l ls lt">@Delete('/:id')<br/>async deleteStudent(@Res() response, @Param('id') studentId: string)<br/>{<br/>  try {<br/>    const deletedStudent = await this.studentService.deleteStudent(studentId);</span><span id="1812" class="lp iq hh ll b fi lv lr l ls lt">    return response.status(HttpStatus.OK).json({<br/>    message: 'Student deleted successfully',<br/>    deletedStudent,});<br/>  }catch (err) {<br/>    return response.status(err.status).json(err.response);<br/>  }<br/> }<br/>}</span></pre><p id="e19b" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">最后，我们需要将<strong class="jq hi"><em class="lu">student controller</em></strong>添加到app模块中，使其在上下文中可用。基本上，我们将其添加到<strong class="jq hi"> <em class="lu">控制器</em> </strong>数组中。</p><p id="5531" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">最终的<strong class="jq hi"><em class="lu">app . module . ts</em></strong>文件将如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c010" class="lp iq hh ll b fi lq lr l ls lt">import { Module } from '@nestjs/common';<br/>import { MongooseModule } from '@nestjs/mongoose';<br/>import { AppController } from './app.controller';<br/>import { AppService } from './app.service';<br/>import { StudentController } from './controller/student/student.controller';<br/>import { StudentSchema } from './schema/student.schema';<br/>import { StudentService } from './service/student/student.service';</span><span id="4e0e" class="lp iq hh ll b fi lv lr l ls lt">@Module({<br/>  imports:[MongooseModule.forRoot('mongodb://localhost:27017/studentdb'),<br/>MongooseModule.forFeature([{ name: 'Student', schema: StudentSchema }])],</span><span id="38ce" class="lp iq hh ll b fi lv lr l ls lt">  controllers: [AppController,StudentController],<br/>  providers: [AppService,StudentService],<br/>})<br/>export class AppModule {}</span></pre><p id="2cb8" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">毕竟，文件被创建，最终的代码结构将如下。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/7e7137d599500e78858c89cac3f9472b.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*52VvJxXU7agq6REIIzJUGg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Project Structure</figcaption></figure><p id="9a1b" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">现在我们通过使用命令<strong class="jq hi"> <em class="lu"> npm run start </em> </strong>启动NestJS应用程序，我们将能够访问位于<a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><strong class="jq hi"><em class="lu">http://localhost:3000</em></strong></a>的CRUD端点。</p><h1 id="814b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">REST API客户端执行结果:</h1><p id="667c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">现在，一旦我们的项目开始运行，我们就可以在REST API客户端的帮助下验证端点的工作情况。对于所有<strong class="jq hi"> <em class="lu">得到</em> </strong> <em class="lu">，</em> <strong class="jq hi"> <em class="lu">放</em> </strong> <em class="lu">，</em><strong class="jq hi"><em class="lu">POST</em></strong><em class="lu"/>和<em class="lu"> </em> <strong class="jq hi"> <em class="lu">删除</em> </strong>端点我们得到如下成功响应。</p><p id="2523" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">1 &gt;创建用户:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/1bd457709da0bf169bc0c103b9ef8147.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*mzC5eeiQ2dP67LXeo-UAig.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Create a user</figcaption></figure><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="99fc" class="lp iq hh ll b fi lq lr l ls lt">curl --location --request POST '<a class="ae la" href="http://localhost:3000/student/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/student/'</a> \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>    "name":"Jack",<br/>    "roleNumber": 101,<br/>    "class": 10,<br/>    "gender": "Male",<br/>    "marks": 65<br/>}'</span></pre><p id="d357" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">2 &gt;获取所有用户:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/18bcff086c94c8ac8ae8435de3bc4f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*63vZEwUNLSbqzuQOz9SYZg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Get all users</figcaption></figure><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="50f3" class="lp iq hh ll b fi lq lr l ls lt">curl --location --request GET '<a class="ae la" href="http://localhost:3000/student/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/student/'</a></span></pre><p id="73e3" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">3 &gt;按id更新用户:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es md"><img src="../Images/5c391c90c199596f8a0cd3eaca046430.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*Cj4wusr9UqBn2eWPt-K55A.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Update a user by id</figcaption></figure><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fb35" class="lp iq hh ll b fi lq lr l ls lt">curl --location --request GET '<a class="ae la" href="http://localhost:3000/student/624b5bce68ff4ddf506dfeba'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/student/624b5bce68ff4ddf506dfeba'</a></span></pre><p id="0a99" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">4 &gt;通过id获取用户:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es me"><img src="../Images/b4e297cce785beae133adf2f2e26d96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*n5GNykcAEygy4VdGITo6Fw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Get a user by id</figcaption></figure><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="34bd" class="lp iq hh ll b fi lq lr l ls lt">curl --location --request PUT '<a class="ae la" href="http://localhost:3000/student/624b5bce68ff4ddf506dfeba'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/student/624b5bce68ff4ddf506dfeba'</a> \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>    "class": 11,<br/>    "marks": 70<br/>}'</span></pre><p id="5ba2" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">5 &gt;按id删除用户:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/50415dc97617f17e4f33c08c4e044cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*EzLUdbz6ySISZgwwP3N2UA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Delete a user by id</figcaption></figure><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="635e" class="lp iq hh ll b fi lq lr l ls lt">curl --location --request DELETE '<a class="ae la" href="http://localhost:3000/student/624b5bce68ff4ddf506dfeba'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/student/624b5bce68ff4ddf506dfeba'</a></span></pre><h1 id="d627" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">结论:</strong></h1><p id="4470" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">通过遵循上面记录的过程，我们已经使用NestJS和MongoDB成功地创建了CRUD应用程序。我们使用mongoose作为ORM来连接应用程序和数据库。我们还使用REST API客户机检查了创建的端点的工作情况，并验证了成功的响应。你可以在这个<a class="ae la" href="https://github.com/niranjangawali1993/nestjs-mongodb-crud.git" rel="noopener ugc nofollow" target="_blank">链接</a>上查看实现的代码。</p><p id="29d6" class="pw-post-body-paragraph jo jp hh jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">如果你对此有任何意见或疑问，请在下面的评论区提出。</p></div></div>    
</body>
</html>