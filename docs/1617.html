<html>
<head>
<title>Using Kubernetes ConfigMap Resources for Dynamic Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Kubernetes配置图资源用于动态应用程序</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-kubernetes-configmap-resources-for-dynamic-apps-9e23ef589121?source=collection_archive---------0-----------------------#2018-11-01">https://medium.com/capital-one-tech/using-kubernetes-configmap-resources-for-dynamic-apps-9e23ef589121?source=collection_archive---------0-----------------------#2018-11-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b47784c2c40e1003f7b5899116baf504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OretSGeE2lQw968THXhZLw.jpeg"/></div></div></figure><h1 id="fb4f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是配置图？</h1><p id="0972" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">根据<a class="ae kl" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">文档</a>，在Kubernetes中，ConfigMap资源<em class="km">“允许您将配置工件从图像内容中分离出来，以保持容器化的应用程序的可移植性。”</em>与Kubernetes pods一起使用，configmaps可用于动态添加或更改容器使用的文件。</p><h1 id="9e4a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">用例</h1><p id="57fa" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">作为Kubernetes安装程序的一部分，我们的团队希望为Kubernetes集群部署一个轻量级文件服务器来处理默认(根路径)入口请求。而且，我们认为，如果我们能够编辑index.html和CSS文件，而不必重新部署应用程序，那就太好了。</p><p id="5b07" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">为了解决这个用例，我们决定构建一个Golang应用程序，将它的部分文件系统映射到Kubernetes configmap资源。</p><h1 id="bdaf" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Golang文件服务器</h1><p id="2d96" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">文件服务器应用程序非常简单。它只是为了提供静态内容，帮助Kubernetes用户使用入口功能。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e6ce" class="lb iq hh kx b fi lc ld l le lf">package main</span><span id="a790" class="lb iq hh kx b fi lg ld l le lf">import (<br/>“log”<br/>“net/http”<br/>)</span><span id="565f" class="lb iq hh kx b fi lg ld l le lf">func main() {<br/>fs := http.FileServer(http.Dir(“html”))<br/>http.Handle(“/”, fs)</span><span id="96cc" class="lb iq hh kx b fi lg ld l le lf">log.Println(“Listening…”)<br/>http.ListenAndServe(“:8080”, nil)<br/>}</span></pre><p id="49ed" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">应用程序容器映像是用下面的<code class="du lh li lj kx b">Dockerfile</code>构建的。它是一个两阶段Dockerfile，首先在Alpine容器中执行Golang构建，然后将编译后的二进制文件和空的<code class="du lh li lj kx b">html</code>目录复制到最终的基于暂存的映像。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="994d" class="lb iq hh kx b fi lc ld l le lf"># build stage  <br/>FROM golang:alpine AS builder  <br/>WORKDIR /usr/local/go/src  <br/>COPY  main.go .  <br/>RUN CGO_ENABLED=0 GOOS=linux go build -o main .  <br/>  <br/>  <br/># final stage  <br/>FROM scratch  <br/>WORKDIR /  <br/>COPY --from=builder /usr/local/go/src/main main  <br/>COPY html html  <br/>EXPOSE 8080  <br/>ENTRYPOINT ["/main"]</span></pre><p id="dc4a" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在Golang应用程序中使用<a class="ae kl" href="https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/" rel="noopener ugc nofollow" target="_blank"> scratch containers </a>是部署Golang容器的一种更加安全和轻量级的方法。</p><h1 id="a2ae" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">构建和运行</h1><p id="a3f7" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我使用<code class="du lh li lj kx b"><a class="ae kl" href="https://www.gnu.org/software/make/manual/html_node/Introduction.html" rel="noopener ugc nofollow" target="_blank">make</a></code>来自动化码头操作。下面是该应用的<code class="du lh li lj kx b">Makefile</code>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2188" class="lb iq hh kx b fi lc ld l le lf">VERSION ?= 0.0.1  <br/>NAME ?= "ingress-default"  <br/>AUTHOR ?= "Jimmy Ray"  <br/>PORT_EXT ?= 8080  <br/>PORT_INT ?= 8080   <br/>NO_CACHE ?= true  <br/>  <br/>  <br/>.PHONY: build run stop clean  <br/>  <br/>  <br/>build:  <br/>docker build -f scratch.dockerfile . -t $(NAME)\:$(VERSION) --no-cache=$(NO_CACHE)  <br/>  <br/>  <br/>run:  <br/>docker run --name $(NAME) -d -p $(PORT_EXT):$(PORT_INT) $(NAME)\:$(VERSION) &amp;&amp; docker ps -a --format "{{.ID}}\t{{.Names}}"|grep $(NAME)  <br/>  <br/>  <br/>stop:  <br/>docker rm $$(docker stop $$(docker ps -a -q --filter "ancestor=$(NAME):$(VERSION)" --format="{{.ID}}"))  <br/>  <br/>  <br/>clean:  <br/><a class="ae kl" href="http://twitter.com/rm" rel="noopener ugc nofollow" target="_blank">@rm</a> -f main  <br/>  <br/>  <br/>DEFAULT: build</span></pre><p id="b267" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">使用<code class="du lh li lj kx b">make</code>可以消除重复性任务之间的可变性。有了上面的<code class="du lh li lj kx b">Makefile</code>，在我将测试过的应用程序部署到Kubernetes之前，我可以在Docker中构建并运行我的应用程序。</p><h1 id="71de" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">配置Kubernetes</h1><p id="23fc" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">对于这个解决方案，我们需要配置Kubernetes名称空间、configmap、部署、服务和入口。我们通过使用<a class="ae kl" href="https://kubernetes-v1-4.github.io/docs/user-guide/kubectl/kubectl_apply/" rel="noopener ugc nofollow" target="_blank"> </a> <code class="du lh li lj kx b"><a class="ae kl" href="https://kubernetes-v1-4.github.io/docs/user-guide/kubectl/kubectl_apply/" rel="noopener ugc nofollow" target="_blank">kubectl apply</a> -f</code>方法来做到这一点。这是一种将更改应用到Kubernetes集群资源的声明性方法。</p><p id="878f" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">下面是我们将要购买的Kubernetes资源的YAML文件。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="18b9" class="lb iq hh kx b fi lc ld l le lf">apiVersion: v1  <br/>kind: Namespace  <br/>metadata:  <br/>  name: ingress-default <br/>  labels:  <br/>    app: ingress-default  <br/>---  <br/>kind: ConfigMap  <br/>apiVersion: v1  <br/>metadata:  <br/>  name: ingress-default-static-files  <br/>  namespace: ingress-default   <br/>  labels:  <br/>    app: ingress-default   <br/>data:  <br/>  index.html: |  <br/>    &lt;!doctype html&gt;  <br/>    &lt;html&gt;  <br/>      &lt;head&gt;  <br/>        &lt;meta charset="utf-8"&gt;  <br/>        &lt;title&gt;Cluster Ingress Index&lt;/title&gt;  <br/>        &lt;link rel="stylesheet" href="main.css"&gt;  <br/>      &lt;/head&gt;  <br/>      &lt;body&gt;  <br/>        &lt;table class="class1"&gt;  <br/>          &lt;tr&gt;  <br/>            &lt;td class="class2"&gt;Kubernetes Platform&lt;/td&gt;  <br/>          &lt;/tr&gt;  <br/>          &lt;tr&gt;  <br/>            &lt;td class="class1"&gt;  <br/>              &lt;table class="class3"&gt;  <br/>                &lt;tr&gt;&lt;td&gt;&lt;h1&gt;Cluster Ingress Index&lt;/h1&gt;&lt;/td&gt;&lt;/tr&gt;  <br/>              &lt;/table&gt;  <br/>            &lt;/td&gt;  <br/>          &lt;/tr&gt;  <br/>          &lt;tr&gt;  <br/>            &lt;td&gt;  <br/>              &lt;table class="class3"&gt;  <br/>                &lt;tr&gt;  <br/>                &lt;td&gt;  <br/>                   &lt;h2&gt;The following are links to this cluster's ingress resources:&lt;/h2&gt;  <br/>                  &lt;/td&gt;  <br/>                &lt;/tr&gt;  <br/>                &lt;tr&gt;  <br/>                &lt;td class="class4"&gt;  <br/>                    &lt;a href="https://&lt;ROOT_INGRESS_PATH&gt;" target="_blank"&gt;Root Ingress&lt;/a&gt;&lt;br/&gt;  <br/>                    &lt;a href="https://&lt;OTHER_INGRESS_PATH&gt;" target="_blank"&gt;Other Ingress&lt;/a&gt;&lt;br/&gt;   <br/>                 &lt;/td&gt;  <br/>               &lt;/tr&gt;  <br/>              &lt;/table&gt;  <br/>            &lt;/td&gt;  <br/>          &lt;/tr&gt;  <br/>         &lt;/table&gt;  <br/>      &lt;/body&gt;  <br/>    &lt;/html&gt;  <br/>  main.css: |  <br/>    body {  <br/>      background-color: rgb(224,224,224);  <br/>      font-family: Verdana, Arial, Helvetica, sans-serif;  <br/>      font-size: 100%;  <br/>    }  <br/>    .class1 {  <br/>  ... <br/>    }  <br/>    .class2 {  <br/>  ... <br/>    }  <br/>    .class3 {  <br/>  ... <br/>    }  <br/>    .class4 {  <br/>     ...<br/>    }   <br/>---  <br/>apiVersion: apps/v1  <br/>kind: Deployment  <br/>metadata:  <br/>  labels:  <br/>    app: ingress-default   <br/>  name: ingress-default  <br/>  namespace: ingress-default <br/>spec:  <br/>  selector:  <br/>    matchLabels:  <br/>      app: ingress-default  <br/>  replicas: 1  <br/>  template:  <br/>    metadata:  <br/>      labels:  <br/>        app: ingress-default    <br/>      name: ingress-default  <br/>    spec:  <br/>      containers:  <br/>        - name: ingress-default  <br/>          image: &lt;IMAGE_REGISTRY_REPO_TAG&gt;  <br/>          imagePullPolicy: Always  <br/>          resources:  <br/>            limits:  <br/>              cpu: 100m  <br/>              memory: 10Mi  <br/>            requests:  <br/>              cpu: 100m  <br/>              memory: 10Mi  <br/>          volumeMounts:  <br/>            - readOnly: true  <br/>              mountPath: html  <br/>              name: html-files  <br/>      volumes:  <br/>        - name: html-files  <br/>          configMap:  <br/>            name: ingress-default-static-files  <br/>---  <br/>kind: Service  <br/>apiVersion: v1  <br/>metadata:  <br/>  name: ingress-default  <br/>  namespace: ingress-default  <br/>  labels:  <br/>    app: ingress-default  <br/>spec:  <br/>  selector:  <br/>    app: ingress-default  <br/>  ports:  <br/>  - name: http  <br/>    protocol: TCP  <br/>    port: 80  <br/>    targetPort: 8080  <br/>---  <br/>apiVersion: extensions/v1beta1  <br/>kind: Ingress  <br/>metadata:  <br/>  name: default-ingress  <br/>  namespace: ingress-default  <br/>  annotations:   <br/>    nginx.ingress.kubernetes.io/rewrite-target: /  <br/>    kubernetes.io/ingress.class: "nginx"    <br/>  labels:  <br/>    app: ingress-default  <br/>spec:  <br/>  rules:  <br/>  - http:  <br/>      paths:  <br/>      - path: /  <br/>        backend:  <br/>          serviceName: ingress-default  <br/>          servicePort: 80</span></pre><p id="7fd6" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">正如您在YAML中看到的，<code class="du lh li lj kx b">ingress-default-static-files</code>配置图包含了<code class="du lh li lj kx b">index.html</code>和<code class="du lh li lj kx b">main.css</code>文件的内容。通过编辑或替换此配置图，我们可以更改Golang文件服务器应用程序提供的这些文件。</p><h1 id="fd50" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">将配置图用作卷</h1><p id="4799" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在Docker和Kubernetes的世界中，体积用于解决两个问题:</p><ol class=""><li id="ad55" class="lk ll hh jp b jq kn ju ko jy lm kc ln kg lo kk lp lq lr ls bi translated">对持久文件系统的需求。</li><li id="e636" class="lk ll hh jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">需要在容器之间共享文件系统。</li></ol><p id="22d8" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">对于我们的解决方案，我们将部署的容器中的卷映射到configmap资源。在下面的代码片段中，<code class="du lh li lj kx b">html-files</code>卷被配置为可能被pod中的所有容器使用。卷映射到在<code class="du lh li lj kx b">ingress-default-static-files</code>配置图中配置的数据。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2296" class="lb iq hh kx b fi lc ld l le lf">...volumes:  <br/>     - name: html-files  <br/>       configMap:  <br/>         name: ingress-default-static-files...</span></pre><p id="ff8d" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">一旦在pod级别配置了卷，我们就在容器级别配置卷挂载。该卷挂载映射到pod中配置的<code class="du lh li lj kx b">html-files</code>卷。有了这个映射，应用程序容器现在可以访问configmap中的两个文件— <code class="du lh li lj kx b">html/index.html</code>和<code class="du lh li lj kx b">html/main.css</code>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="be3a" class="lb iq hh kx b fi lc ld l le lf">...volumeMounts:  <br/>     - readOnly: true  <br/>       mountPath: html  <br/>       name: html-files</span></pre><p id="0e54" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">当Golang应用程序在Kubernetes集群中启动时，<code class="du lh li lj kx b">ingress-default</code>入口规则会导致在NGINX入口控制器中配置一个上游规则。由此产生的路径将通过NGINX入口控制器将集群的边缘连接到<code class="du lh li lj kx b">ingress-default</code>服务。该服务指向Golang文件服务器应用程序pod。运行时，它在入口控制器的根路径上提供默认的web应用程序。如果需要更改此网页，我们只需编辑/替换configmap资源。</p><h1 id="2682" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="a6c1" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">容器编排的一个关键好处是有望消除供应和管理多个容器化工作负载所需的“无差别的繁重工作”。通过使用Kubernetes的声明性配置特性，如ConfigMap，可以提高应用程序部署和集群状态更改的效率和速度。通过使用ConfigMap资源作为安装的卷，使用运行的容器，可以从容器中提取配置和内容，从而减少对映像重构和容器重新部署的需求。</p><h1 id="e1ea" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">相关</strong></h1><ul class=""><li id="5cb2" class="lk ll hh jp b jq jr ju jv jy ly kc lz kg ma kk mb lq lr ls bi translated"><a class="ae kl" rel="noopener" href="/capital-one-tech/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203">策略启用了开放策略代理的Kubernetes】</a></li><li id="5813" class="lk ll hh jp b jq lt ju lu jy lv kc lw kg lx kk mb lq lr ls bi translated"><a class="ae kl" rel="noopener" href="/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622">使用Terraform部署多个环境</a></li><li id="1acb" class="lk ll hh jp b jq lt ju lu jy lv kc lw kg lx kk mb lq lr ls bi translated"><a class="ae kl" rel="noopener" href="/capital-one-tech/multi-region-deployments-with-terraform-kubernetes-a1f51bb96974">使用Terraform进行多区域部署</a></li></ul></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="af61" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><em class="km">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>