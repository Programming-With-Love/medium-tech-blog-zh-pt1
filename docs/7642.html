<html>
<head>
<title>Make Your React Components Pretty 💅</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的反应组件漂亮💅</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/make-your-react-components-pretty-a1ae4ec0f56e?source=collection_archive---------0-----------------------#2016-09-27">https://medium.com/walmartglobaltech/make-your-react-components-pretty-a1ae4ec0f56e?source=collection_archive---------0-----------------------#2016-09-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2449053ff95f4ac221436bbcf7f12544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-U7Fy39j8YCrLqsooTIKzQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">I took this picture. With my phone. Art.</figcaption></figure><p id="bd84" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在<a class="ae jr" href="http://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank">沃尔玛实验室</a>我们做了大量的同行代码评审，这很棒，因为我看到了各种聪明的方法来编写来自各种天才工程师的React组件。在这篇文章中，我将分享我最喜欢的五种模式和捷径。</p><p id="3144" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是首先…</p><h2 id="3932" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">为什么漂亮的代码更好</h2><p id="f5d8" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">有不止一种方法来剥一只猫的皮，也有不止一种方法来编写一个React组件。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/867f68c15e17a5be2b4b9078e7bf55dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*R091Ifwl9oeikb3v1rsG1w.png"/></div></figure><p id="fcf6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，仅仅因为你<em class="kx">可以</em>以任何你认为合适的方式编写组件，并不意味着你<em class="kx">应该</em>。代码是要被人类阅读的；计算机只是解释你扔给它们的任何杂乱无章的字符。🤖</p><p id="c340" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你让你的组件内部和外部一样漂亮，你的开发同行会感谢你的。</p><p id="a1d2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">漂亮的组件…</p><ul class=""><li id="0a40" class="ky kz hh iv b iw ix ja jb je la ji lb jm lc jq ld le lf lg bi translated">💡即使没有注释,<strong class="iv hi">容易理解吗</strong></li><li id="8ac6" class="ky kz hh iv b iw lh ja li je lj ji lk jm ll jq ld le lf lg bi translated">🚀甚至比笨重的代码更有性能</li><li id="17c0" class="ky kz hh iv b iw lh ja li je lj ji lk jm ll jq ld le lf lg bi translated">🐛增加<strong class="iv hi">在bug</strong>到达QA之前捕获它们的机会</li><li id="81d5" class="ky kz hh iv b iw lh ja li je lj ji lk jm ll jq ld le lf lg bi translated">📝<strong class="iv hi">是否简洁</strong>并以少言多</li></ul><blockquote class="lm"><p id="67b2" class="ln lo hh bd lp lq lr ls lt lu lv jq dx translated">“少即是多。”</p><p id="794f" class="ln lo hh bd lp lq lw lx ly lz ma jq dx translated">密斯·凡·德·罗</p></blockquote><h1 id="34d0" class="mb jt hh bd ju mc md me jy mf mg mh kc mi mj mk kf ml mm mn ki mo mp mq kl mr bi translated">1.无状态功能组件(SFC)</h1><p id="a767" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">我最喜欢的React组件优化，也是经常被忽略的，是无状态功能组件，简称SFC。我喜欢sfc，因为它们大大减少了扩展React组件类带来的负担，并将提供**性能优势作为额外的好处！</p><p id="4751" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">基本上，SFC会让你的应用程序运行得更快，看起来更棒。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/bcef63286df1cf4fe0e047f065427d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DTpcI6WC_VDpIU5BbNZYEQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">The Batmobile is an example of a Stateless Functional Component.</figcaption></figure><p id="3238" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">* *在幕后，sfc只是被包装在一个具有唯一渲染功能的简单组件中，但这种模式很快将能够受益于额外的优化:</p><blockquote class="mt mu mv"><p id="05a0" class="it iu kx iv b iw ix iy iz ja jb jc jd mw jf jg jh mx jj jk jl my jn jo jp jq ha bi translated">未来，我们还将能够通过避免不必要的检查和内存分配，针对[sfc]进行性能优化。</p><p id="f5e6" class="it iu kx iv b iw ix iy iz ja jb jc jd mw jf jg jh mx jj jk jl my jn jo jp jq ha bi translated">—本·阿尔珀特，<a class="ae jr" href="https://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html#stateless-function-components" rel="noopener ugc nofollow" target="_blank">反应博客</a></p></blockquote><h2 id="4178" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">实际例子</h2><p id="8a76" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">让我们来看看SFC如何大大减少编写简单的相关搜索组件所需的代码量:</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/933f51150ffe5525e3a835c8e1a91471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qp0jyX7GK_Oimlvc2leeA.png"/></div></div></figure><p id="49b7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">即使作为一个传统的反应。组件扩展，显示相关搜索的列表并不需要太多时间:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="40eb" class="js jt hh nb b fi nf ng l nh ni">export default class RelatedSearch extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="03b2" class="js jt hh nb b fi nj ng l nh ni">    this._handleClick = this._handleClick.bind(this);<br/>  }</span><span id="df75" class="js jt hh nb b fi nj ng l nh ni">  _handleClick(suggestedUrl, event) {<br/>    event.preventDefault();<br/>    this.props.onClick(suggestedUrl);<br/>  }</span><span id="8a51" class="js jt hh nb b fi nj ng l nh ni">  render() {<br/>    return (<br/>      &lt;section className="related-search-container"&gt;<br/>        &lt;h1 className="related-search-title"&gt;Related Searches:&lt;/h1&gt;<br/>        &lt;Layout x-small={2} small={3} medium={4} padded={true}&gt;<br/>          {this.props.relatedQueries.map((query, index) =&gt;<br/>            &lt;Link<br/>              className="related-search-link"<br/>              onClick={(event) =&gt;<br/>                this._handleClick(query.searchQuery, event)}<br/>              key={index}&gt;<br/>              {query.searchText}<br/>            &lt;/Link&gt;<br/>          )}<br/>        &lt;/Layout&gt;<br/>      &lt;/section&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="973d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，SFC替代方案提供了29%的代码节省<strong class="iv hi">！</strong></p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="22a0" class="js jt hh nb b fi nf ng l nh ni">const _handleClick(suggestedUrl, onClick, event) =&gt; {<br/>  event.preventDefault();<br/>  onClick(suggestedUrl);<br/>};</span><span id="0624" class="js jt hh nb b fi nj ng l nh ni">const RelatedSearch = ({ relatedQueries, onClick }) =&gt;<br/>  &lt;section className="related-search-container"&gt;<br/>    &lt;h1 className="related-search-title"&gt;Related Searches:&lt;/h1&gt;<br/>    &lt;Layout x-small={2} small={3} medium={4} padded={true}&gt;<br/>      {relatedQueries.map((query, index) =&gt;<br/>        &lt;Link<br/>          className="related-search-link"<br/>          onClick={(event) =&gt;<br/>            _handleClick(query.searchQuery, onClick, event)}<br/>          key={index}&gt;<br/>          {query.searchText}<br/>        &lt;/Link&gt;<br/>      )}<br/>    &lt;/Layout&gt;<br/>  &lt;/section&gt;</span><span id="c045" class="js jt hh nb b fi nj ng l nh ni">export default RelatedSearch;</span></pre><p id="2cbf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这种惊人的代码减少主要通过两种方式实现，这源于ES2015类扩展的缺失:</p><ul class=""><li id="dd50" class="ky kz hh iv b iw ix ja jb je la ji lb jm lc jq ld le lf lg bi translated">无构造器(5个位置)</li><li id="1c7f" class="ky kz hh iv b iw lh ja li je lj ji lk jm ll jq ld le lf lg bi translated">使用箭头语法的简明呈现语句(4 LOC)</li></ul><p id="6d7b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，SFC真正伟大的地方是可读性大大提高了。首先，<strong class="iv hi">sfc以尽可能好的方式代表</strong><a class="ae jr" rel="noopener" href="/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.5sgngec83"><strong class="iv hi"/></a><strong class="iv hi"/>纯组件，高度关注返回组件的JSX。移除不再需要的构造函数，并在组件外部重构<em class="kx"> _handleClick() </em>函数也有助于提高可读性，因为关注点被更清晰地分离了。</p><p id="df62" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">SFC中我最喜欢的部分之一是如何使用ES2015 <a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring" rel="noopener ugc nofollow" target="_blank">对象析构</a>语法在函数参数列表的顶部清晰地定义属性:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="b7ce" class="js jt hh nb b fi nf ng l nh ni">const RelatedSearch = (<strong class="nb hi">{ relatedQueries, onClick }</strong>) =&gt;</span></pre><p id="5b41" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是一个方便的地方，可以快速查看组件接收到的所有属性，也是一种避免到处引用this.props的方法，使代码整体上更容易阅读。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/52f43802c178265d1d834f8def716b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jlmj_CbYXqUfw7AIFXFIhw.png"/></div></figure><h2 id="d63f" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">什么时候可以使用sfc？</h2><p id="35cf" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">大概sfc最好的部分是<strong class="iv hi">它们可以在任何可以使用纯组件的地方使用</strong>。在沃尔玛实验室，我们使用Redux来管理应用程序的状态，这意味着我们几乎所有的组件都是sfc的候选者。</p><p id="5e76" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是，在两种情况下，无状态组件不能是SFC:</p><ul class=""><li id="1444" class="ky kz hh iv b iw ix ja jb je la ji lb jm lc jq ld le lf lg bi translated">当需要组件生命周期方法时</li><li id="bc86" class="ky kz hh iv b iw lh ja li je lj ji lk jm ll jq ld le lf lg bi translated">当引用被使用时</li></ul><p id="c184" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然这两种情况相当罕见，但通过仔细的架构和规划，通常可以完全避免。</p><h1 id="5fa5" class="mb jt hh bd ju mc md me jy mf mg mh kc mi nk mk kf ml nl mn ki mo nm mq kl mr bi translated">2.条件成分</h1><p id="eecc" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">JSX不允许if语句，所以为了避免仅仅为了使用条件逻辑而将代码重构为子模块，请尝试三元组:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="c6ad" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  &lt;div class="search-results-container"&gt;<br/>    {this.props.isGrid<br/>      ? &lt;SearchResultsGrid /&gt;<br/>      : &lt;SearchResultsList /&gt;}<br/>  &lt;/div&gt;<br/>}</span></pre><p id="570c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果满足或不满足某个条件，这个表达式在返回一个或另一个组件方面非常棒。但是，对于组件应该呈现还是不呈现的情况，三元组可能不是最佳选择:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="65a0" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  &lt;div class="search-results-list"&gt;<br/>    {this.props.isSoftSort<br/>      ? &lt;SoftSortBanner /&gt;<br/>      : null<br/>    }<br/>  &lt;/div&gt;<br/>}</span></pre><p id="afc6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是可行的，但是这就像告诉React“渲染这个组件，否则！”</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es nn"><img src="../Images/ac92c9d2d4ae3fc36baa3c0cb1df32b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*7cAgXhCHZndyCJKWc5ZJ_w.png"/></div></figure><p id="34db" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一种更具语义且更简洁的方法是使用逻辑and双&amp;符号返回条件分量或false:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="3a87" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  &lt;div class="search-results-list"&gt;<br/>    {!!this.props.isSoftSort &amp;&amp; &lt;SoftSortBanner /&gt;}<br/>  &lt;/div&gt;<br/>}</span></pre><p id="b61b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这当然取决于个人偏好，有些人更喜欢任何条件成分的三元方法。</p><p id="da87" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">编辑——在这篇文章的前一个版本中，我省略了布尔型转换！！<em class="kx">来自左边的操作数，这是很危险的，因为一些假值比如</em>零<em class="kx">可能会被React无意中渲染。使用</em> &amp; &amp; <em class="kx">时，始终转换左侧操作数。感谢Reddit用户</em><a class="ae jr" href="https://www.reddit.com/r/reactjs/comments/54uez2/heres_5_useful_patterns_to_make_your_component/d859jq2" rel="noopener ugc nofollow" target="_blank"><em class="kx">miketa 1957</em></a><em class="kx"/><a class="ae jr" href="https://www.reddit.com/r/reactjs/comments/54uez2/heres_5_useful_patterns_to_make_your_component/d85aufz" rel="noopener ugc nofollow" target="_blank"><em class="kx">HumansAreDumb</em></a><em class="kx"/><a class="ae jr" href="https://www.reddit.com/r/reactjs/comments/54uez2/heres_5_useful_patterns_to_make_your_component/d85jmfm" rel="noopener ugc nofollow" target="_blank"><em class="kx">Alex Barrett</em></a><em class="kx">指出这一点。</em></p><h1 id="2af1" class="mb jt hh bd ju mc md me jy mf mg mh kc mi nk mk kf ml nl mn ki mo nm mq kl mr bi translated">3.React和Redux中的箭头语法</h1><p id="2569" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">ES2015充满了漂亮的语法快捷键，其中我最喜欢的是<a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头符号</a>。这些在编写组件时特别有用，但是我经常看到它们没有发挥出全部潜力:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="3668" class="js jt hh nb b fi nf ng l nh ni">const SoftSort = ({ hardSortUrl, sortByName, onClick }) =&gt; {<br/>  return (<br/>    &lt;div className="SearchInfoMessage"&gt;<br/>      Showing results sorted by both Relevance and {sortByName}.<br/>      &lt;Link<br/>        href={`?${hardSortUrl}`}<br/>        onClick={(ev) =&gt; onClick(ev, hardSortUrl)}&gt;<br/>        Sort results by {sortByName} only<br/>      &lt;/Link&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="d198" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个函数只返回JSX，所以我们可以更简洁:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="05b8" class="js jt hh nb b fi nf ng l nh ni">const SoftSort = ({ hardSortUrl, sortByName, onClick }) =&gt;<br/>  &lt;div className="SearchInfoMessage"&gt;<br/>    Showing results sorted by both Relevance and {sortByName}.<br/>    &lt;Link<br/>      href={`?${hardSortUrl}`}<br/>      onClick={(ev) =&gt; onClick(ev, hardSortUrl)}&gt;<br/>      Sort results by {sortByName} only<br/>    &lt;/Link&gt;<br/>  &lt;/div&gt;</span></pre><p id="0cf5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这相当于减少了25%的代码行——现在代码行减少到了11行！</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es no"><img src="../Images/4758021c0d807d92e3d09728f56107b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ZqsKC6SGQ0dh7_AOAYTgow.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Use Arrow functions the way they were meant to be!</figcaption></figure><p id="86ea" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一个我经常看到箭头函数没有充分发挥潜力的地方是在Redux <em class="kx"> mapStateToProps </em>函数中:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="d69e" class="js jt hh nb b fi nf ng l nh ni">const mapStateToProps = ({isLoading}) =&gt; {<br/>  return ({<br/>    loading: isLoading,<br/>  });<br/>};</span></pre><p id="c8d3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是在这里要小心，当返回一个对象时，你必须用括号把它括起来:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="a75d" class="js jt hh nb b fi nf ng l nh ni">const mapStateToProps = ({isLoading}) =&gt; ({<br/>  loading: isLoading<br/>});</span></pre><p id="1192" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kx">编辑—感谢</em><a class="np nq ge" href="https://medium.com/u/14bb25afc42b?source=post_page-----a1ae4ec0f56e--------------------------------" rel="noopener" target="_blank"><em class="kx">Victor Storozhenko</em></a><em class="kx">指出本例中对象析构的改进。</em></p><p id="ce9f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">优化箭头函数的目的是<strong class="iv hi">通过关注函数</strong>的重要部分并移除不必要的返回语句和括号的背景噪音来提高可读性。</p><h1 id="3692" class="mb jt hh bd ju mc md me jy mf mg mh kc mi nk mk kf ml nl mn ki mo nm mq kl mr bi translated">4.说出你对对象析构和传播属性的理解</h1><p id="cf5d" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">大型构件经常患有<strong class="iv hi"><em class="kx"/>综合症</strong>。也就是说，你会看到短语<em class="kx"> this.props </em>到处都是，不幸的是，它作为额外噪音的来源降低了可读性。幸运的是，有了ES2015对象析构，我们有了一种在JSX中简洁地编写道具的方法。举一个产品价格组件的例子，它有许多道具要呈现:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="1799" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  return (<br/>    &lt;ProductPrice<br/>      hidePriceFulfillmentDisplay=<br/>       {this.props.hidePriceFulfillmentDisplay}<br/>      primaryOffer={this.props.primaryOffer}<br/>      productType={this.props.productType}<br/>      productPageUrl={this.props.productPageUrl}<br/>      inventory={this.props.inventory}<br/>      submapType={this.props.submapType}<br/>      ppu={this.props.ppu}<br/>      isLoggedIn={this.props.isLoggedIn}<br/>      gridView={this.props.isGridView}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="9656" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">哇，好多这种道具啊！这里有一个减少<em class="kx">噪音的方法:</em></p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="6608" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  const {<br/>    hidePriceFulfillmentDisplay,<br/>    primaryOffer,<br/>    productType,<br/>    productPageUrl,<br/>    inventory,<br/>    submapType,<br/>    ppu,<br/>    isLoggedIn,<br/>    gridView<br/>  } = this.props;</span><span id="fe91" class="js jt hh nb b fi nj ng l nh ni">  return (<br/>    &lt;ProductPrice<br/>      hidePriceFulfillmentDisplay={hidePriceFulfillmentDisplay}<br/>      primaryOffer={primaryOffer}<br/>      productType={productType}<br/>      productPageUrl={productPageUrl}<br/>      inventory={inventory}<br/>      submapType={submapType}<br/>      ppu={ppu}<br/>      isLoggedIn={isLoggedIn}<br/>      gridView={isGridView}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="1fa1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这增加了几行代码，但也使我们的代码更容易阅读，并且<strong class="iv hi">清楚地指出我们在组件</strong>中使用了哪些道具。在大型组件中这样做是有意义的，因为相同的属性可能会在多个子组件中多次使用，但是在这个简单的例子中，我们可以使用<a class="ae jr" href="https://facebook.github.io/react/docs/jsx-spread.html#spread-attributes" rel="noopener ugc nofollow" target="_blank"> Spread Attributes </a>作为超级快捷方式:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="0e72" class="js jt hh nb b fi nf ng l nh ni">render() {<br/>  const props = this.props;<br/>  return &lt;ProductPrice {...props} /&gt;<br/>}</span></pre><p id="76c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">无状态功能组件(如前所述)大量使用对象析构，因为它们接收props作为参数:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="c855" class="js jt hh nb b fi nf ng l nh ni">const ProductPrice = ({<br/>  hidePriceFulfillmentDisplay,<br/>  primaryOffer,<br/>  productType,<br/>  productPageUrl,<br/>  inventory,<br/>  submapType,<br/>  ppu,<br/>  isLoggedIn,<br/>  gridView<br/>}) =&gt;<br/>  &lt;ProductPrice<br/>    hidePriceFulfillmentDisplay={hidePriceFulfillmentDisplay}<br/>    primaryOffer={primaryOffer}<br/>    productType={productType}<br/>    productPageUrl={productPageUrl}<br/>    inventory={inventory}<br/>    submapType={submapType}<br/>    ppu={ppu}<br/>    isLoggedIn={isLoggedIn}<br/>    gridView={isGridView}<br/>  /&gt;</span></pre><h1 id="df99" class="mb jt hh bd ju mc md me jy mf mg mh kc mi nk mk kf ml nl mn ki mo nm mq kl mr bi translated">5.方法定义速记</h1><p id="b249" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">这个技巧可能不是非常有用，但它确实很漂亮。💅</p><p id="bda5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">无论何时你在一个对象中编写方法，你都可以使用ES2015 <a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">方法定义简写</a>，而不是枯燥的旧ES5做事方式。这在<em class="kx"> defaultProps </em>声明中特别方便:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="198e" class="js jt hh nb b fi nf ng l nh ni">Link.defaultProps = {<br/>  onClick(event) {<br/>    event.preventDefault();<br/>    Logger.log(event);<br/>  }<br/>};</span></pre><p id="12dc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另外，如果您只想设置一个默认的无操作方法，这非常简单:</p><pre class="kt ku kv kw fd na nb nc nd aw ne bi"><span id="4341" class="js jt hh nb b fi nf ng l nh ni">ProductRating.defaultProps = {<br/>  onStarsClick() {}<br/>};</span></pre><h1 id="589c" class="mb jt hh bd ju mc md me jy mf mg mh kc mi nk mk kf ml nl mn ki mo nm mq kl mr bi translated">最后</h1><p id="6bbd" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">我希望我分享的这些技巧能让你的React应用程序变得更漂亮，并且你会积极思考如何让你的代码更漂亮。记住，<strong class="iv hi">漂亮的代码做了很多不用多说</strong>。</p><blockquote class="lm"><p id="dc57" class="ln lo hh bd lp lq lw lx ly lz ma jq dx translated">“说话轻声细语，拿着大棒。”</p><p id="cc56" class="ln lo hh bd lp lq lw lx ly lz ma jq dx translated">—西奥多·罗斯福</p></blockquote></div></div>    
</body>
</html>