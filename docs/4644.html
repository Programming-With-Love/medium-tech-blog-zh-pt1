<html>
<head>
<title>Master the JavaScript Interview: What’s the Difference Between Class &amp; Prototypal Inheritance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript面试:类和原型继承有什么区别？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9?source=collection_archive---------1-----------------------#2016-01-19">https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9?source=collection_archive---------1-----------------------#2016-01-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1d3911725c24277e559e66d53fa4e0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtVyaoswTo9iljufAz7Y8A.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Electric Guitar — Feliciano Guimarães (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="c189" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“掌握JavaScript面试”是一系列的帖子，旨在帮助候选人准备在申请中高级JavaScript职位时可能遇到的常见问题。这些是我在真实面试中经常用到的问题。想从头开始吗？参见<a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.6xq65f6f5">“什么是闭包？”</a></p><p id="0385" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:本文使用ES6示例。如果你还没学过ES6，请看<a class="ae jv" rel="noopener" href="/javascript-scene/how-to-learn-es6-47d9a1ac2620">“如何学习ES6”</a>。</p></blockquote><p id="a7dd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript中经常使用对象，了解如何有效地使用它们将大大提高您的工作效率。事实上，糟糕的面向对象设计可能会导致项目失败，在最坏的情况下，<a class="ae jv" rel="noopener" href="/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b">公司失败</a>。</p><p id="a61c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">与大多数其他语言不同，JavaScript的对象系统基于<strong class="iz hi">原型，而不是类</strong>。不幸的是，大多数JavaScript开发人员不理解JavaScript的对象系统，也不知道如何最好地利用它。其他人理解它，但希望它的行为更像基于类的系统。结果是JavaScript的对象系统具有令人困惑的分裂个性，这意味着JavaScript开发人员需要了解一些关于原型和类的知识。</p><h2 id="fae2" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jw kk kl km jx kn ko kp jy kq kr ks kt bi translated">类继承和原型继承有什么区别？</h2><p id="295c" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">这可能是一个棘手的问题，你可能需要通过后续的问答来为你的答案辩护，所以要特别注意了解它们的区别，以及如何应用这些知识来编写更好的代码。</p><p id="f8ec" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">类继承:</strong> <strong class="iz hi"> <em class="iy">类就像一个蓝图——对要创建的对象的描述。</em> </strong>类继承自类，<strong class="iz hi">创建子类关系</strong>:层次类分类法。</p><p id="334e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">实例通常通过带有<em class="iy"> `new` </em>关键字的构造函数来实例化。类继承可能使用也可能不使用ES6中的<em class="iy"> `class` </em>关键字。从技术上讲，JavaScript中并不存在Java等语言中的类。而是使用构造函数。ES6 <em class="iy"> `class` </em>关键字反糖到一个构造函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b369" class="jz ka hh le b fi li lj l lk ll">class Foo {}<br/>typeof Foo // 'function'</span></pre><p id="5fa3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中，类继承是在原型继承之上实现的，但是这并不意味着它做同样的事情</p><p id="6349" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript的类继承使用原型链将子<em class="iy"> `Constructor.prototype` </em>连接到父<em class="iy"> `Constructor.prototype` </em>进行委托。通常，<em class="iy"> `super()` </em>构造函数也被调用。这些步骤形成了<strong class="iz hi">单祖先父/子层次</strong>和<strong class="iz hi"> <em class="iy">创建了OO设计中最紧密的耦合。</em>T11】</strong></p><blockquote class="lm"><p id="3f4a" class="ln lo hh bd lp lq lr ls lt lu lv ju dx translated">"类从类继承并且<strong class="ak">创建子类关系</strong>:层次类分类法."</p></blockquote><p id="47b8" class="pw-post-body-paragraph iw ix hh iz b ja lw jc jd je lx jg jh jw ly jk jl jx lz jo jp jy ma js jt ju ha bi translated"><strong class="iz hi">原型继承:</strong> <strong class="iz hi"> <em class="iy">原型是工作对象实例。</em> </strong>对象直接继承其他对象。</p><p id="9d4d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">实例可以由许多不同的源对象组成，允许简单的选择性继承和扁平的[[Prototype]]委托层次结构。换句话说，<strong class="iz hi">类分类法不是原型OO </strong> : <em class="iy">的自动副作用，这是一个关键的区别。</em></p><p id="3a42" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">实例通常通过工厂函数、对象文字或<em class="iy"> `Object.create()` </em>进行实例化。</p><blockquote class="lm"><p id="d252" class="ln lo hh bd lp lq lr ls lt lu lv ju dx translated"><strong class="ak"> <em class="mb">“原型是一个工作对象的实例。</em> </strong>对象直接继承其他对象。”</p></blockquote><h2 id="ceb3" class="jz ka hh bd kb kc mc ke kf kg md ki kj jw me kl km jx mf ko kp jy mg kr ks kt bi translated">为什么这很重要？</h2><p id="665b" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">继承从根本上说是一种代码重用机制:不同种类的对象共享代码的一种方式。分享代码的方式很重要，因为如果你做错了，<strong class="iz hi">它会产生很多问题，</strong>具体来说:</p><p id="b58c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">类继承的副作用是创建父/子对象分类法</strong>。</p><p id="c068" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些分类法实际上不可能对所有的新用例都正确，基类的广泛使用导致了<strong class="iz hi">脆弱的基类问题，</strong>当它们出错时，很难修复。<strong class="iz hi"> </strong>事实上，类继承导致了OO设计中许多众所周知的问题:</p><ul class=""><li id="6ff2" class="mh mi hh iz b ja jb je jf jw mj jx mk jy ml ju mm mn mo mp bi translated"><strong class="iz hi">紧耦合问题</strong>(类继承是oo设计中可用的最紧耦合)，导致下一个…</li><li id="c4f5" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><strong class="iz hi">脆弱的基础类问题</strong></li><li id="b83b" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><strong class="iz hi">不灵活的层级问题</strong>(最终，所有进化的层级对于新的用途都是错误的)</li><li id="ea96" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><strong class="iz hi">必然的复制问题</strong>(由于不灵活的层次结构，新的用例通常是通过复制，而不是修改现有的代码来实现的)</li><li id="d178" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><strong class="iz hi">大猩猩/香蕉问题</strong>(你想要的是一只香蕉，但你得到的是一只拿着香蕉的大猩猩，以及整个丛林)</li></ul><p id="2631" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所有这些问题的解决方案是优先选择对象组合而不是类继承。</p><blockquote class="lm"><p id="d1e6" class="ln lo hh bd lp lq lr ls lt lu lv ju dx translated">"优先选择对象组合而不是类继承."<br/> ~四人帮，<a class="ae jv" href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=WMUILDJNIUXY4NSH" rel="noopener ugc nofollow" target="_blank">《设计模式:可复用面向对象软件的要素》</a></p></blockquote><p id="309f" class="pw-post-body-paragraph iw ix hh iz b ja lw jc jd je lx jg jh jw ly jk jl jx lz jo jp jy ma js jt ju ha bi translated">总结得很好:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h2 id="2bd7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jw kk kl km jx kn ko kp jy kq kr ks kt bi translated">所有的遗传都是不好的吗？</h2><p id="a217" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">当人们说“偏好组合胜过继承”时，那是“偏好组合胜过<strong class="iz hi">类</strong>继承”的简称(最初引自四人帮的“设计模式”)。这是OO设计中的常识，因为<strong class="iz hi">类继承有很多缺陷</strong>并导致很多问题。当人们谈论类继承时，经常会省略掉单词<strong class="iz hi"> class </strong>，这听起来好像所有的继承都是不好的——但事实并非如此。</p><p id="5015" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">实际上有几种不同类型的继承，其中大多数非常适合从多个组件对象组成复合对象。</p><h2 id="465a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jw kk kl km jx kn ko kp jy kq kr ks kt bi translated">三种不同的原型遗传</h2><p id="ef3f" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">在我们深入其他种类的继承之前，让我们仔细看看我所说的<strong class="iz hi">类继承</strong>是什么意思:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="mx mw l"/></div></figure><p id="33ed" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以在Codepen 上试验这个例子。</p><p id="6f8d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><em class="iy"> `BassAmp` </em>继承自<em class="iy"> `GuitarAmp` </em>，<em class="iy"> `ChannelStrip` </em>继承自<em class="iy">` bassamp `</em>&amp;<em class="iy">` guitar amp `。这是面向对象设计出错的一个例子。通道条实际上不是一种吉他放大器，实际上根本不需要音箱。更好的选择是创建一个新的基础类，放大器和通道条都从该基础类继承而来，但即使这样也有局限性。</em></p><p id="217b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">最终，新的共享基类策略也失败了。</p><p id="34aa" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">有更好的方法。使用对象组合，您可以继承您真正需要的东西:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="mx mw l"/></div></figure><p id="a6a1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><a class="ae jv" href="http://codepen.io/ericelliott/pen/XXzadQ?editors=001" rel="noopener ugc nofollow" target="_blank">在CodePen </a>上做这个实验。</p><p id="e50e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你仔细观察，你可能会发现我们对哪些对象获得哪些属性变得更加具体，因为有了composition，<strong class="iz hi"> <em class="iy">我们可以</em> </strong>。对于类继承来说，这并不是一个真正的选择。当你继承了一个类，你就得到一切，<em class="iy">即使你不想要。</em></p><p id="6503" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">此时，您可能会对自己说，“这很好，但是原型在哪里呢？”</p><p id="6db9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">要理解这一点，你必须理解有三种不同的原型OO。</p><p id="36ff" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">串联继承:</strong>通过复制源对象属性，从一个对象直接向另一个对象继承特性的过程。在JavaScript中，源原型通常被称为<strong class="iz hi">混合。</strong>从ES6开始，这个特性在JavaScript中有一个便利的实用程序，叫做<em class="iy"> `Object.assign()` </em>。在ES6之前，这通常是用下划线/Lodash的<em class="iy"> `.extend()` </em> jQuery的<em class="iy"> `$。extend()`、</em>等等……上面的合成例子使用了串联继承。</p><p id="0984" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">原型委托:</strong>在JavaScript中，一个对象可以链接到<strong class="iz hi">委托</strong>的原型。如果在对象上找不到属性，查找将被<strong class="iz hi">委托</strong>给<strong class="iz hi">委托原型，</strong>可能有一个到它自己的委托原型的链接，依此类推，直到到达根委托<em class="iy"> `Object.prototype` </em>。这是当你附加到一个<em class="iy">` constructor . prototype`</em>并使用<em class="iy"> `new '实例化时得到的原型。</em>你也可以使用<em class="iy"> `Object.create()` </em>来实现这个目的，甚至可以将这种技术与串联混合使用，以便将多个原型展平为一个委托，或者在创建后扩展对象实例。</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/f0ef7efeade80d93baee8b913aa9f303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lu-BaawSayDz1itKPk2u4w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The JavaScript Prototype Chain</figcaption></figure><p id="e429" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">函数继承:</strong>在JavaScript中，任何函数都可以创建一个对象。当该函数不是构造函数(或<em class="iy"> `class` </em>)时，它被称为<strong class="iz hi">工厂函数</strong>。函数继承的工作方式是从工厂产生一个对象，并通过直接为其分配属性(使用串联继承)来扩展所产生的对象。道格拉斯·克洛克福特创造了这个术语，但是函数继承在JavaScript中已经普遍使用了很长时间。</p><p id="0fdf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可能已经开始意识到，<strong class="iz hi">串联继承是JavaScript </strong>中支持对象组合的秘密武器，这使得原型委托和函数继承变得更加有趣。</p><p id="0f53" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当大多数人想到JavaScript中的原型OO时，他们会想到原型委托。现在你应该明白他们错过了很多。委托原型不是类继承的很好的替代物— <strong class="iz hi">对象组合是</strong>。</p><h2 id="4d1a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jw kk kl km jx kn ko kp jy kq kr ks kt bi translated"><strong class="ak">为什么复合对脆弱基类问题免疫</strong></h2><p id="32b5" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">要理解脆弱基类问题以及为什么它不适用于合成，首先你必须理解它是如何发生的:</p><ol class=""><li id="00c5" class="mh mi hh iz b ja jb je jf jw mj jx mk jy ml ju mz mn mo mp bi translated"><em class="iy"> `A` </em>是基类</li><li id="5b6c" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mz mn mo mp bi translated"><em class="iy"> `B` </em>继承自<em class="iy"> `A` </em></li><li id="0a97" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mz mn mo mp bi translated"><em class="iy"> `C` </em>继承自<em class="iy"> `B` </em></li><li id="0c89" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mz mn mo mp bi translated"><em class="iy"> `D` </em>继承自<em class="iy"> `B` </em></li></ol><p id="0db8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><em class="iy">“C”</em>调用<em class="iy">“超级”</em>，后者在<em class="iy">“B”</em>中运行代码。<em class="iy">“b”</em>调用<em class="iy">“super”【T9 },后者在<em class="iy">“a”</em>中运行代码。</em></p><p id="f4b1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><em class="iy">“a”和</em>“b”包含<em class="iy">“c”和&amp;<em class="iy">“d”都需要的不相关特征。<em class="iy">“d”</em>是一个新的用例，需要<em class="iy">在<em class="iy">“a”</em>的初始化代码中有一点不同于<em class="iy">“c”</em>需要的</em>行为。所以新手开发者去调整<em class="iy">的初始化代码。<em class="iy"> ` </em>、<strong class="iz hi">、<em class="iy"> C` </em>因为依赖于已有行为而断裂</strong>，并且<em class="iy"> `D` </em>开始工作。</em></em></em></p><p id="0edd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们这里有分布在<em class="iy">‘a’</em>和<em class="iy">‘b’</em>之间的特性，即<em class="iy">‘c’</em>和<em class="iy">‘d’</em>需要以各种方式使用。<em class="iy">“C”和</em>“D”并没有使用<em class="iy">“A”和</em>“B”的所有特性……他们只是想继承一些已经在<em class="iy">“A”和</em>“B”中定义的东西。但是通过继承和调用<em class="iy">‘super’，</em> <strong class="iz hi">你不能对你继承的东西有所选择</strong>。您继承了一切:</p><blockquote class="it iu iv"><p id="00e6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“…面向对象语言的问题在于，他们随身携带着所有这些隐含的环境。<strong class="iz hi">你想要一根香蕉，但是你得到的是一只大猩猩拿着香蕉</strong>和整个丛林。”~乔·阿姆斯特朗— <a class="ae jv" href="http://www.amazon.com/gp/product/1430219483?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=1430219483&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=3MNWRRZU3C4Q4BDN" rel="noopener ugc nofollow" target="_blank">“程序员在工作”</a></p></blockquote><p id="7ce6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">有了组合</strong> <br/>想象你有特征而不是类:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6783" class="jz ka hh le b fi li lj l lk ll">feat1, feat2, feat3, feat4</span></pre><p id="324f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><em class="iy">“c”</em>需要<em class="iy">“feat 1”</em>和<em class="iy">“feat 3”</em>、<em class="iy">“d”</em>需要<em class="iy">“feat 1”、“feat2”、“feat 4”</em>:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5fd2" class="jz ka hh le b fi li lj l lk ll">const C = compose(feat1, feat3);<br/>const D = compose(feat1, feat2, feat4);</span></pre><p id="1076" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在，假设您发现<em class="iy">` d}</em>需要<strong class="iz hi">与<em class="iy">` feat 1}</em>稍微不同的</strong>行为。实际上不需要改变<em class="iy">“feat 1”</em>，相反<strong class="iz hi">你可以定制<em class="iy">“feat 1”</em>“T90”并使用。您仍然可以继承<em class="iy">“feat 2”</em>和<em class="iy">“feat 4”</em>中的现有行为，没有任何变化:</strong></p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="862a" class="jz ka hh le b fi li lj l lk ll">const D = compose(custom1, feat2, feat4);</span></pre><p id="29f8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><em class="iy">`</em><strong class="iz hi">' T98】c`不受</strong>影响。</p><p id="ea5f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">使用类继承不可能做到这一点的原因是因为<strong class="iz hi">当您使用类继承时，您购买了整个现有的类分类法。</strong></p><p id="0529" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你想为一个新的用例做一点调整，你要么复制现有分类法的一部分(必然的复制问题)，要么你重构所有依赖于现有分类法的东西，使分类法适应新的用例，因为<strong class="iz hi">脆弱的基类问题</strong>。</p><p id="c7b8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">组合对两者都是免疫的。</p><h2 id="c646" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jw kk kl km jx kn ko kp jy kq kr ks kt bi translated">你认为你了解原型，但是…</h2><p id="2310" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated">如果你被教导构建类或构造函数并继承它们，你被教导的是<strong class="iz hi">而不是原型继承</strong>。你学会了如何<strong class="iz hi">使用原型</strong>模仿类继承。参见<a class="ae jv" rel="noopener" href="/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a#.khem2m91q">“JavaScript中关于继承的常见误解”</a>。</p><p id="dfb8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中，类继承建立在很久以前构建在语言中的非常丰富、灵活的原型继承特性之上，但是当您使用类继承时——即使是构建在原型之上的ES6+ <em class="iy"> `class` </em>继承，您也没有使用原型OO的全部功能&amp;灵活性。事实上，你把自己画到了角落里，选择了所有的类继承问题。</p><blockquote class="lm"><p id="3144" class="ln lo hh bd lp lq lr ls lt lu lv ju dx translated">在JavaScript中使用类继承就像把你的新Tesla Model S开到经销商那里，换一辆生锈的1973年福特Pinto。</p></blockquote><h2 id="f945" class="jz ka hh bd kb kc mc ke kf kg md ki kj jw me kl km jx mf ko kp jy mg kr ks kt bi translated">探索该系列</h2><ul class=""><li id="b3c2" class="mh mi hh iz b ja ku je kv jw na jx nb jy nc ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.ecfskj935">什么是关闭？</a></li><li id="a716" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1">类和原型继承有什么区别？</a></li><li id="5846" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.4256pjcfq">什么是纯函数？</a></li><li id="9469" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0#.i84zm53fb">什么是函数构成？</a></li><li id="e45a" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#.jddz30xy3">什么是函数式编程？</a></li><li id="415f" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated">什么是承诺？</li><li id="d09d" class="mh mi hh iz b ja mq je mr jw ms jx mt jy mu ju mm mn mo mp bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466">软技能</a></li></ul><h1 id="32e4" class="nd ka hh bd kb ne nf ng kf nh ni nj kj nk nl nm km nn no np kp nq nr ns ks nt bi translated">提升你的技能</h1><p id="d412" class="pw-post-body-paragraph iw ix hh iz b ja ku jc jd je kv jg jh jw kw jk jl jx kx jo jp jy ky js jt ju ha bi translated"><a class="ae jv" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟Eric Elliott学JavaScript】。如果你不是会员，你就错过了！</a></p><figure class="kz la lb lc fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es nu"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl nv nw go nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ha hb hc hd he"><p id="2db8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">是一位科技产品和平台顾问，《T5】 <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【作曲软件】</em></a><em class="iy"/><a class="ae jv" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="iy">【EricElliottJS.com】</em></a><em class="iy"/><a class="ae jv" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="iz hi"> <em class="iy">、Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">【华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【BBC】</em></strong><em class="iy">等顶级录音艺人和包括</em> <strong class="iz hi"> <em class="iy"> Usher、【Metallica】</em></strong></em></p><p id="61a2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>