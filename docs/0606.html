<html>
<head>
<title>Bridging the gap between coroutines, threads, and concurrency problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弥合协程、线程和并发问题之间的差距</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/bridging-the-gap-between-coroutines-jvm-threads-and-concurrency-problems-864e563bd7c?source=collection_archive---------1-----------------------#2021-02-03">https://medium.com/androiddevelopers/bridging-the-gap-between-coroutines-jvm-threads-and-concurrency-problems-864e563bd7c?source=collection_archive---------1-----------------------#2021-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/343ffaf7a38ebe195b53da089ffaa34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hW9fFeCaJNdcoJgOgaoGA.png"/></div></div></figure><div class=""/><p id="93b7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“<em class="jn">协程是轻量级线程</em>”，你读过多少遍了？这对你有什么意义吗？大概不会。继续阅读，了解更多关于<strong class="ir ht">协同程序如何在Android运行时</strong>上实际执行，它们如何与线程相关，以及使用Java编程语言线程模型时不可避免的<strong class="ir ht">并发问题</strong>。</p><h1 id="f94d" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">协程和线程</h1><p id="4ccf" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">协程旨在简化异步执行的代码。当谈到Android运行时上的协同程序时，<strong class="ir ht">作为lambda传递给协同程序构建器的代码块最终在特定的线程上执行</strong>。例如，这个简单的<a class="ae kr" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契</a>计算:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0512" class="lb jp hs kx b fi lc ld l le lf">// Coroutine that calculates the 10th Fibonacci number in a background thread<br/>someScope.launch(Dispatchers.Default) {<br/>    val fibonacci10 = synchronousFibonacci(10)<br/>    saveFibonacciInMemory(10, fibonacci10)<br/>}</span><span id="7d72" class="lb jp hs kx b fi lg ld l le lf">private fun synchronousFibonacci(n: Long): Long { /* ... */ }</span></pre><p id="a409" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的<code class="du lh li lj kx b">async</code>协程代码块执行同步和分块斐波那契计算，并将其保存到内存中，<strong class="ir ht">被分派和调度到由协程库</strong>管理的线程池中执行，协程库是为<code class="du lh li lj kx b">Dispatchers.Default</code>配置的。根据线程池的策略，代码将在未来的某个时间在线程池的线程中执行。</p><p id="e8ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，上面的代码在一个线程中执行，因为它没有挂起。如果执行被移动到不同的调度程序，或者如果块包含可能在使用线程池的调度程序中产生/挂起的代码，则一个协同例程可能在不同的线程中执行。</p><p id="5603" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，如果没有协程，您可以使用线程手动执行上述逻辑，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b779" class="lb jp hs kx b fi lc ld l le lf">// Create a thread pool of 4 threads<br/>val executorService = Executors.newFixedThreadPool(4)</span><span id="ac15" class="lb jp hs kx b fi lg ld l le lf">// Schedule and execute this code in one of those threads<br/>executorService.execute {<br/>    val fibonacci10 = synchronousFibonacci(10)<br/>    saveFibonacciInMemory(10, fibonacci10)<br/>}</span></pre><p id="8893" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然可以自己手动管理线程池，但由于内置的取消支持、更简单的错误处理、<em class="jn">结构化并发性</em>降低了内存泄漏的可能性，以及与Jetpack库的集成，<strong class="ir ht"> coroutines是Android上异步编程的推荐解决方案。</strong></p><h2 id="ddd0" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">在后台</h2><p id="ffc4" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从创建协程的那一刻起，直到它在线程上执行，会发生什么？当您使用标准协程构建器创建协程时，您可以指定在哪个<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt" rel="noopener ugc nofollow" target="_blank">CoroutineDispatcher</a></code>上运行它；如果没有，则使用<code class="du lh li lj kx b">Dispatchers.Default</code>。</p><p id="43df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">协程调度器负责将一个协程的执行分派给一个线程</strong>。在底层，当一个<code class="du lh li lj kx b">CoroutineDispatcher</code>被使用时，它使用这个<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt#L99" rel="noopener ugc nofollow" target="_blank">interceptContinuation</a></code>方法拦截协程，这个方法是<strong class="ir ht">将</strong> <code class="du lh li lj kx b"><strong class="ir ht">Continuation</strong></code> <strong class="ir ht">(即协程)包装在一个</strong> <code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">DispatchedContinuation</strong></a></code>中。这是可能的，因为<code class="du lh li lj kx b">CoroutineDispatcher</code>实现了<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/ContinuationInterceptor.kt" rel="noopener ugc nofollow" target="_blank">ContinuationInterceptor</a></code>接口。</p><blockquote class="lx ly lz"><p id="139f" class="ip iq jn ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">如果你读过我关于<a class="ae kr" href="https://manuelvivo.dev/suspend-modifier" rel="noopener ugc nofollow" target="_blank">协程如何在幕后工作</a>的文章，你已经知道编译器创建了一个状态机，状态机的信息(例如接下来需要执行什么)保存在一个<a class="ae kr" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation.html" rel="noopener ugc nofollow" target="_blank">延续</a>对象中。</p></blockquote><p id="7a0a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果一个延续需要在不同的调度程序中执行，<code class="du lh li lj kx b">DispatchedContinuation</code>的<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt#L178" rel="noopener ugc nofollow" target="_blank">resumeWith</a></code>方法负责将协程调度到合适的调度程序！</p><p id="eb06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，<strong class="ir ht">一个</strong> <code class="du lh li lj kx b"><strong class="ir ht">DispatchedContinuation</strong></code> <strong class="ir ht">从</strong> <code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">DispatchedTask</strong></a></code>抽象类扩展而来，该抽象类在Java编程语言实现中是实现<code class="du lh li lj kx b">Runnable</code>接口的类型。所以一个<code class="du lh li lj kx b">DispatchedContinuation</code>可以在一个线程上运行！多酷啊。当一个<code class="du lh li lj kx b">CoroutineDispatcher</code>被指定时，协程被转换成一个<code class="du lh li lj kx b">DispatchedTask</code>，作为一个<code class="du lh li lj kx b">Runnable</code>被分派到一个线程上执行！</p><p id="6a7c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在…当你创建一个协程时，如何调用<code class="du lh li lj kx b">dispatch</code>方法？当您使用标准协程构建器创建协程时，您可以用类型<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineStart</a></code>的<code class="du lh li lj kx b">start</code>参数指定协程如何启动。例如，您可以使用<code class="du lh li lj kx b">CoroutineStart.LAZY</code>将其配置为仅在需要时启动。默认情况下，使用<code class="du lh li lj kx b">CoroutineStart.DEFAULT</code>,它根据协程的<code class="du lh li lj kx b">CoroutineDispatcher</code>调度协程的执行。答对了。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/5c22af7aefd05f18deaa480ebe6780e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BDIVBAhji84RLRtT"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx">Illustration of how the block of code in a coroutine ends up executing in a Thread</figcaption></figure><h2 id="933d" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">调度程序和线程池</h2><p id="401a" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过使用<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html" rel="noopener ugc nofollow" target="_blank">Executor.asCoroutineDispatcher()</a></code>扩展函数将协程转换为<code class="du lh li lj kx b">CoroutineDispatcher</code>，您可以在任何应用程序线程池中执行协程。或者，您可以使用协程库中默认的<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt" rel="noopener ugc nofollow" target="_blank">Dispatchers</a></code>。</p><p id="ab1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以看到在这个<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt#L22" rel="noopener ugc nofollow" target="_blank">createDefaultDispatcher</a></code>方法中<code class="du lh li lj kx b">Dispatchers.Default</code>是如何初始化的。默认情况下，使用<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/Dispatcher.kt" rel="noopener ugc nofollow" target="_blank">DefaultScheduler</a></code>。如果您查看一下<code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt#L118" rel="noopener ugc nofollow" target="_blank">Dispatchers.IO</a></code>的实现，它也使用了<code class="du lh li lj kx b">DefaultScheduler</code>，并且允许按需创建至少64个线程。<code class="du lh li lj kx b">Dispatchers.Default</code>和<code class="du lh li lj kx b">Dispatchers.IO</code>隐式地链接在一起，因为它们使用相同的线程池，这将我带到下一个主题。用不同的调度程序调用<code class="du lh li lj kx b">withContext</code>的运行时开销是多少？</p><h2 id="35e6" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">线程和上下文性能</h2><p id="7aca" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在Android运行时，如果创建的线程多于可用的CPU内核，线程之间的切换会带来一些运行时开销。<a class="ae kr" href="https://en.wikipedia.org/wiki/Context_switch" rel="noopener ugc nofollow" target="_blank"> <em class="jn">上下文切换</em> </a>不便宜！操作系统需要保存和恢复执行上下文，CPU需要花时间调度线程，而不是运行实际的应用程序工作。除此之外，如果线程正在运行阻塞的代码，可能会发生上下文切换。如果线程是这种情况，那么在不同的调度程序中使用<code class="du lh li lj kx b">withContext</code>会有什么性能损失吗？</p><p id="b161" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，正如您所想象的，线程池为我们管理了所有这些复杂性，试图尽可能地优化要执行的工作(这就是为什么在线程池上执行工作比手动在线程中执行要好)。协程也从中受益，因为它们是在线程池中调度的！最重要的是，协程不会阻塞线程，而是<em class="jn">暂停</em>它们的工作！甚至更高效！</p><p id="054a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"/><code class="du lh li lj kx b"><a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">CoroutineScheduler</strong></a></code>是Java编程语言实现中默认使用的线程池，<strong class="ir ht">以最有效的方式将分派的协程分配给工作线程</strong>。由于<code class="du lh li lj kx b">Dispatchers.Default</code>和<code class="du lh li lj kx b">Dispatchers.IO</code>使用相同的线程池，它们之间的切换被优化以尽可能避免线程切换。协程库可以优化这些调用，保持在相同的调度程序和线程上，并遵循快速路径。</p><p id="34e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du lh li lj kx b">Dispatchers.Main</code>通常是UI应用中的不同线程，在协同程序中的<code class="du lh li lj kx b">Dispatchers.Default</code>和<code class="du lh li lj kx b">Dispatchers.Main</code>之间切换不会带来巨大的性能成本，因为协同程序只是暂停(即停止在一个线程中执行)，并被调度到另一个线程中执行。</p><h1 id="d29b" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">协同程序中的并发问题</h1><p id="c7b9" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">由于不同线程上的调度工作非常简单，协程确实使异步编程变得更加容易。另一方面，这种简单性可能是一把双刃剑:<strong class="ir ht">由于协程运行在Java编程语言线程模型上，它们不能简单地避免线程模型带来的并发问题</strong>。因此，你必须注意避免这种情况。</p><p id="1bba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多年来，像不变性这样的良好实践已经减轻了您可能面临的一些与线程相关的问题。然而，有些情况是不可避免的。所有并发问题的根源是状态管理！特别是在多线程环境下访问<strong class="ir ht"> <em class="jn">可变状态</em> </strong>。</p><p id="202f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多线程应用中的操作顺序是不可预测的。除了可以对操作重新排序的编译器优化之外，线程不能保证以特定的顺序运行，并且上下文切换可能随时发生。如果在访问可变状态时没有采取必要的预防措施，线程可能会看到陈旧的数据，丢失更新，或者遭受<a class="ae kr" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank"> <em class="jn">竞争条件</em> </a>等问题。</p><blockquote class="lx ly lz"><p id="f334" class="ip iq jn ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">请注意，可变状态和访问顺序的讨论并不特定于Java编程语言。它们也会影响其他平台上的协程。</p></blockquote><p id="2481" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用协程的应用本质上是一个多线程应用。<strong class="ir ht">使用协程并包含可变状态的类必须采取预防措施</strong> <strong class="ir ht">使其可预测</strong>，即确保协程中执行的代码看到最新版本的数据。这样，不同的线程不会互相干扰。并发问题会导致你的应用程序中非常细微的错误，非常难以调试，甚至<a class="ae kr" href="https://en.wikipedia.org/wiki/Heisenbug" rel="noopener ugc nofollow" target="_blank"> <em class="jn">海森伯格</em> </a>！</p><p id="0bf5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些类型的课程并不少见。也许类需要在内存中保存登录用户的信息，或者在应用程序运行时缓存一些值。如果不小心的话，并发问题仍然会在协程中发生！使用<code class="du lh li lj kx b">withContext(defaultDispatcher)</code>的挂起函数不能保证总是在同一个线程中执行！</p><p id="e10f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们有一个缓存用户事务的类。如果没有正确访问缓存，例如下面的例子，可能会发生并发错误:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><blockquote class="lx ly lz"><p id="be70" class="ip iq jn ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">即使我们谈论的是Kotlin，Brian Goetz的书<em class="hs">Java concurrency in practice</em>也是了解这个主题和Java编程语言系统中并发复杂性的极好资源。或者，Jetbrains也有关于共享可变状态和并发性的文档。</p></blockquote><h1 id="ad96" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">保护可变状态</h1><p id="73b8" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如何保护可变状态，或者找到一个好的<a class="ae kr" href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="jn">同步</em> </a> <em class="jn">策略</em>，完全取决于数据的性质和涉及的操作。这一节将介绍您可能面临的并发问题，而不是列出所有不同的方法和API来保护可变状态。尽管如此，这里有一些技巧和API可以让你的可变变量线程安全。</p><h2 id="63e0" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">包装</h2><p id="4774" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">可变状态应该被封装，并且由一个类拥有。这个类集中了对状态的访问，并将使用更适合用例的同步策略来保护读写。</p><h2 id="8e58" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">线程限制</h2><p id="d7e6" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">一种解决方案是限制对一个线程的读/写访问。对可变状态的访问可以使用队列以生产者/消费者的方式完成。关于这一点，JetBrains在T21有很好的文档。</p><h2 id="a9d4" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">不要多此一举</h2><p id="29ba" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在Android运行时中，有一些线程安全的数据结构可以用来保护可变变量。例如，对于简单计数器的情况，可以使用<code class="du lh li lj kx b"><a class="ae kr" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" rel="noopener ugc nofollow" target="_blank">AtomicInteger</a></code>。或者，为了保护上面代码片段的映射，您可以使用一个<code class="du lh li lj kx b"><a class="ae kr" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" rel="noopener ugc nofollow" target="_blank">ConcurrentHashMap</a></code>。<code class="du lh li lj kx b">ConcurrentHashMap</code>是一个线程安全的同步集合，它优化了对map的读写吞吐量。</p><p id="1735" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，线程安全的数据结构不能防止调用者排序问题，它们只是确保内存访问是原子性的。当逻辑不太复杂时，它们有助于避免使用锁。例如，它们不能在上面显示的<code class="du lh li lj kx b">transactionCache</code>示例中使用，因为操作的顺序和它们之间的逻辑需要线程和访问保护。</p><p id="f172" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，这些线程安全数据结构中的数据需要是不可变的或受保护的，以防止在修改已经存储在其中的对象时出现竞争情况。</p><h2 id="7320" class="lb jp hs bd jq lk ll lm ju ln lo lp jy ja lq lr kc je ls lt kg ji lu lv kk lw bi translated">定制解决方案</h2><p id="1ff7" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果您有需要同步的复合动作，<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/" rel="noopener ugc nofollow" target="_blank">@Volatile</a></code>变量或线程安全数据结构不会有帮助！而且有可能内置的<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-synchronized/" rel="noopener ugc nofollow" target="_blank">@Synchronized</a></code>注释不够精细，不足以让您的用例高效。</p><p id="ad07" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这些情况下，您可能需要使用并发实用程序来创建自己的同步机制，如<a class="ae kr" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html" rel="noopener ugc nofollow" target="_blank">闩锁</a>、<a class="ae kr" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">信号量</a>或<a class="ae kr" href="https://en.wikipedia.org/wiki/Barrier_(computer_science)" rel="noopener ugc nofollow" target="_blank">屏障</a>。其他时候，您可以使用<a class="ae kr" href="https://en.wikipedia.org/wiki/Lock_(computer_science)" rel="noopener ugc nofollow" target="_blank">锁</a>或互斥锁无条件地保护多线程对代码的访问。</p><p id="2a03" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin中的<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html" rel="noopener ugc nofollow" target="_blank">Mutex</a></code>有挂起函数<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html" rel="noopener ugc nofollow" target="_blank">lock</a></code>和<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html" rel="noopener ugc nofollow" target="_blank">unlock</a></code>来手动保护你的协程代码的一部分。方便的是，扩展功能<code class="du lh li lj kx b"><a class="ae kr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html" rel="noopener ugc nofollow" target="_blank">Mutex.withLock</a></code>更易于使用:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="fe5e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于使用<code class="du lh li lj kx b">Mutex</code>的协程会暂停执行，直到可以继续执行，这比阻塞线程的Java编程语言锁要有效得多。在协程中使用Java编程语言同步类时要小心，因为这会阻塞正在执行协程的线程，并产生<a class="ae kr" href="https://en.wikipedia.org/wiki/Liveness" rel="noopener ugc nofollow" target="_blank">活性</a>问题。</p></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="47d0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">传递给协程构建器的代码块最终在一个或多个线程上执行。因此，协同程序运行在Android运行时线程模型上，并带有所有的约束。使用协程，仍然有可能编写出易受攻击的错误多线程代码。因此，在代码中要注意对共享可变状态的访问！</p></div></div>    
</body>
</html>