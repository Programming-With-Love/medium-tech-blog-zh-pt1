<html>
<head>
<title>Google I/O 2018 app — Architecture and Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google I/O 2018应用程序—架构和测试</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/google-i-o-2018-app-architecture-and-testing-f546e37fc7eb?source=collection_archive---------3-----------------------#2018-08-20">https://medium.com/androiddevelopers/google-i-o-2018-app-architecture-and-testing-f546e37fc7eb?source=collection_archive---------3-----------------------#2018-08-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/38d9be9eaf9a6e71065a9d40b087fdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cR-yYVLLyonll5RzDF-oXQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration by <a class="ae it" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><p id="3681" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Google I/O应用程序是一个开源项目，它显示了年度Google I/O会议的日程和信息。它面向活动的参与者和远程观众。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/4f3770411a98883edcd863b1eda84df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7zzhaif7gbwltvWX.png"/></div></div></figure><p id="2f3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">今年我们有机会从头开始。我们可以选择工具，考虑应用程序架构的整体设计。什么是最好的建筑？使您团队中的开发人员最具生产力的方法。他们应该能够在不重新发明轮子的情况下工作，专注于用户特性。此外，开发人员应该能够获得关于他们工作的及时反馈。开发这款应用的大多数团队成员都是20%的人——谷歌人将20%的时间投入到这个项目中——他们来自不同的团队、背景和时区，这是做这些决定时需要考虑的因素。</p><h1 id="8d45" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">体系结构</h1><p id="72a0" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">由多元化团队开发的项目需要关于如何面对共同问题的明确指导方针。例如，开发人员需要一种方法让<strong class="iw hi">脱离主线程</strong>。提供一个框架来始终如一地做到这一点是有意义的。此外，一个好的架构应该很难被打破:定义应用程序的<strong class="iw hi">层</strong>并清楚地描述它们的关系，避免错误并简化代码审查。</p><p id="94ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们从<a class="ae it" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>中获取概念来解决这两个问题(分层和后台执行)。该应用程序分为三层结构:</p><ul class=""><li id="9c02" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">表示层(视图和视图模型)</li><li id="ee14" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">领域层(用例)</li><li id="b258" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">数据层(存储库、用户管理器)</li></ul><p id="ec18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">表示层不能直接与数据层对话。一个视图模型只能通过一个或多个用例到达一个存储库。这个限制确保了独立性和可测试性。这也带来了一个跳到后台线程的好机会:所有用例都在后台执行，保证UI线程上不会发生数据访问。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/08a44c131a0a5b5b2b28a893be69cade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWigoCU4Q_O25hscjOq-fg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">General architecture of the app</figcaption></figure><h2 id="9426" class="lp jy hh bd jz lq lr ls kd lt lu lv kh jf lw lx kl jj ly lz kp jn ma mb kt mc bi translated">表示层:视图+视图模型+数据绑定</h2><p id="7368" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">视图模型通过<a class="ae it" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>向视图提供数据。实际的UI调用是通过<a class="ae it" href="https://developer.android.com/topic/libraries/data-binding/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">数据绑定</strong> </a>完成的，将活动和片段从样板文件中释放出来。</p><p id="140f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们使用一个<strong class="iw hi">事件包装器</strong>来处理事件，它被建模为UI状态的一部分。在这篇博文中阅读更多关于这种模式的内容。</p><h2 id="040d" class="lp jy hh bd jz lq lr ls kd lt lu lv kh jf lw lx kl jj ly lz kp jn ma mb kt mc bi translated">领域层:用例</h2><p id="0b2c" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">领域层围绕着<a class="ae it" href="https://github.com/google/iosched/blob/master/shared/src/main/java/com/google/samples/apps/iosched/shared/domain/UseCase.kt" rel="noopener ugc nofollow" target="_blank">用例</a>类，这个类经历了很多迭代。为了避免<a class="ae it" href="https://www.google.es/search?q=callback+hell" rel="noopener ugc nofollow" target="_blank">回调地狱</a>，我们决定使用LiveData来公开用例的结果。</p><p id="257d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">默认情况下，用例在一个<code class="du md me mf mg b"><a class="ae it" href="https://github.com/google/iosched/blob/master/shared/src/main/java/com/google/samples/apps/iosched/shared/domain/internal/TaskScheduler.kt#L38" rel="noopener ugc nofollow" target="_blank">DefaultScheduler</a></code>(一个Kotlin <code class="du md me mf mg b">object</code>)上执行，稍后可以从测试修改为同步运行的<a class="ae it" href="https://github.com/google/iosched/blob/master/mobile/src/test/java/com/google/samples/apps/iosched/test/util/SyncTaskExecutorRule.kt" rel="noopener ugc nofollow" target="_blank">。我们发现这比处理一个定制的Dagger图来注入一个同步调度器更容易。</a></p><h2 id="04b2" class="lp jy hh bd jz lq lr ls kd lt lu lv kh jf lw lx kl jj ly lz kp jn ma mb kt mc bi translated">数据层</h2><p id="75cc" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">该应用处理了3种<em class="mh">类型</em>的数据，考虑到它们变化的频率:</p><ul class=""><li id="48c9" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">从不改变的静态数据:地图、议程等。</li><li id="33dc" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">每天更改0-10次的数据:日程数据(会话、演讲者、标签等。)</li><li id="4a1d" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">即使没有用户交互也不断变化的数据:预订和会话主演</li></ul><p id="d47b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">app的一个重要要求是<strong class="iw hi">离线支持</strong>。用户应该在第一次运行时就可以获得每一条数据，即使是在Wi-Fi连接不稳定的情况下(我们不能假设场馆有完美的覆盖，我们应该假设许多游客会关闭他们的漫游数据)。</p><p id="b0bf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">静态数据是硬编码的。例如，agenda存储库最初是一个嵌入式JSON文件，但是它非常静态，为了简单和性能，我们将其转换为Kotlin。</p><p id="e599" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">会议数据来自一个相对较大的JSON文件(大约600Kb未压缩)。它的初始版本包含在APK中，以实现完全的离线支持。每当用户刷新时间表时，或者当应用程序收到请求刷新的<a class="ae it" href="https://firebase.google.com/docs/cloud-messaging/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">Firebase Cloud Messaging</strong></a>信号时，应用程序会从静态URL下载新数据。会议数据被下载到由<a class="ae it" href="https://developer.android.com/reference/android/app/job/JobScheduler" rel="noopener ugc nofollow" target="_blank">作业调度器</a>管理的作业中，以确保用户的数据被负责任地使用。</p><p id="037f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<a class="ae it" href="http://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> OkHttp </strong> </a>缓存下载的JSON，这样下次启动应用程序时，就会使用缓存的版本，而不是引导文件。这种方法使我们不必直接处理文件。</p><p id="96c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于用户数据(预订、会话启动、上传Firebase令牌等。)我们用的是<a class="ae it" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> Firestore </strong> </a>，这是一个NoSQL云数据库。它带有离线支持，因此我们能够毫不费力地在Android、web和iOS之间同步用户数据。</p><p id="f88e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<a class="ae it" href="https://firebase.google.com/docs/auth/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> Firebase认证</strong> </a>实现了登录支持。一个<code class="du md me mf mg b"><a class="ae it" href="https://firebase.google.com/docs/reference/android/com/google/firebase/auth/FirebaseAuth.AuthStateListener" rel="noopener ugc nofollow" target="_blank">AuthStateListener</a></code>使用一个LiveData observable来指示当前用户何时改变(例如，从注销到登录)。</p><h1 id="a036" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">库和工具</h1><p id="325e" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">我们决定避免使用不稳定的依赖关系，所以没有使用<a class="ae it" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank">协程</a>、<a class="ae it" href="https://developer.android.com/topic/libraries/architecture/navigation/" rel="noopener ugc nofollow" target="_blank">导航</a>组件和<a class="ae it" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器</a>。</p><p id="7b62" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了前面已经讨论过的工具之外，值得一提的还有:</p><ul class=""><li id="84ad" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated"><a class="ae it" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank">依赖注入的Dagger2 </a></li><li id="4712" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><a class="ae it" href="https://github.com/JakeWharton/timber" rel="noopener ugc nofollow" target="_blank">木材</a>用于伐木</li><li id="5237" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><a class="ae it" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> Gson </a>用于JSON解析</li><li id="e061" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">用于处理日期和时间</li><li id="d1b6" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><a class="ae it" href="http://try.crashlytics.com/" rel="noopener ugc nofollow" target="_blank">防撞系统</a></li></ul><p id="8cca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们广泛使用了LiveData来创建一个反应式架构，其中所有的东西都被连接起来，所以当数据改变时UI会自动更新。在这篇<a class="ae it" rel="noopener" href="/google-developers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7">文章</a>中，你可以找到更多关于使用ViewModel之外的LiveData的信息。</p><h1 id="b63c" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">梯度模块和代码组织</h1><p id="be9b" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">良好的模块化策略对于良好的开发体验至关重要。事实上，依赖性问题通常是糟糕的架构或模块化方法的标志。我们创建了以下模块:</p><ul class=""><li id="ac9e" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated"><code class="du md me mf mg b">model</code>:包含应用程序中使用的实体</li><li id="d7b6" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><code class="du md me mf mg b">shared</code>:业务逻辑和核心类</li><li id="7589" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><code class="du md me mf mg b">mobile</code>:移动应用，包括活动、片段、视图模型和UI相关的类，如数据绑定适配器、BottomSheetBehavior等。</li><li id="3cc4" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><code class="du md me mf mg b">tv</code>:安卓电视应用</li><li id="eae7" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><code class="du md me mf mg b">test-shared</code>:所有模块中所有单元测试使用的测试数据</li><li id="17d6" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><code class="du md me mf mg b">androidTest-shared</code>:所有模块中所有UI测试要使用的实用程序</li></ul><p id="2249" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的一般规则是创建尽可能多的模块来改进封装，通常会导致更快的增量构建。在我们的例子中，<code class="du md me mf mg b">shared</code>和<code class="du md me mf mg b">mobile</code>模块可以进一步分割。</p><h1 id="ec21" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">测试和口味</h1><p id="11c2" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">在特性开发之前，为了使应用程序可测试，投入了大量的精力。开发人员只有在他们所做的事情能够得到早期反馈的情况下才是高效的，而不是依赖于其他人。</p><h2 id="6cc5" class="lp jy hh bd jz lq lr ls kd lt lu lv kh jf lw lx kl jj ly lz kp jn ma mb kt mc bi translated">单元测试</h2><p id="6270" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">架构和模块化方法允许良好的测试隔离、伪造依赖和快速执行。域和数据层都经过了广泛的单元测试。只有表示层中的一些util类经过了单元测试。</p><p id="4d8d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们最初没有在项目中添加<a class="ae it" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>来避免嘲笑。我们尽可能使用接口，伪造测试中的依赖关系，这比模仿要干净得多。然而，最终<a class="ae it" href="https://github.com/google/iosched/commit/efd6167da84c184d7ba707b29a39b1e68b9bbf11" rel="noopener ugc nofollow" target="_blank">添加了</a>mock ITO来创建外部依赖的模拟。我们使用了<a class="ae it" href="https://github.com/nhaarman/mockito-kotlin/" rel="noopener ugc nofollow" target="_blank"> Mockito-Kotlin </a>来获得更地道的体验。</p><p id="e861" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们使用了一个内部持续集成工具，它拒绝了破坏构建或单元测试的变更列表。在一个有这么多贡献者的项目中，这是至关重要的，当有多个变体时尤其重要，因为Android Studio只构建活动的一个。对于Github，我们添加了<a class="ae it" href="https://github.com/google/iosched/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>。</p><h2 id="fd1a" class="lp jy hh bd jz lq lr ls kd lt lu lv kh jf lw lx kl jj ly lz kp jn ma mb kt mc bi translated">UI测试</h2><p id="8915" class="pw-post-body-paragraph iu iv hh iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">我们确保<a class="ae it" href="https://developer.android.com/training/testing/espresso/" rel="noopener ugc nofollow" target="_blank"> Espresso </a>不需要<a class="ae it" href="https://developer.android.com/training/testing/espresso/idling-resource" rel="noopener ugc nofollow" target="_blank">空闲资源</a>，因此用例框架提供了一种设置同步任务执行器的方法。此外，我们确保测试将密封运行:使用假货，以避免使用不可靠的依赖，如网络。首选项、时间和任务调度程序都是使用JUnit规则从测试中修改而来的，这提供了稳定性和可重复的测试。</p><p id="17ac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">UI测试只在<code class="du md me mf mg b">staging</code>风格上运行。这个应用程序的特殊变种总是假装一个登录的用户，不发出任何网络请求。手动测试应用程序时，这也有助于加快迭代速度。</p><p id="4689" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当UI处于繁重的开发中时，维护UI测试可能是一种负担。我们计划在整合了UI设计之后引入它们。然而，UI测试被延迟了，我们发布了第一个没有合适套件的版本。这导致了生产中的几次<a class="ae it" href="https://github.com/google/iosched/issues/268" rel="noopener ugc nofollow" target="_blank">崩溃</a>，这些崩溃本可以通过在<a class="ae it" href="https://firebase.google.com/docs/test-lab/" rel="noopener ugc nofollow" target="_blank"> Firebase测试实验室</a>上简单地运行一条快乐路径(只关心正常操作，而不关心不太频繁的交互的测试)来避免。</p><p id="0925" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在一个理想的世界中，我们不需要仅仅为了测试而修改我们的<em class="mh">可发布的</em>代码，但是我们确实需要做一些改变:</p><ul class=""><li id="63e8" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">我们必须添加一种方法来禁用<a class="ae it" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/widget/BottomSheetBehavior.kt#L210" rel="noopener ugc nofollow" target="_blank"> BottomSheetBehavior </a>类中的动画，因为它不使用任何动画框架(所以动画不会自动禁用)。</li><li id="5d4d" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">我们不得不添加一个函数，当某个动画在<a class="ae it" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/schedule/filters/EventFilterView.kt#L255" rel="noopener ugc nofollow" target="_blank"> EventFilterView </a>类中完成时执行。</li></ul></div><div class="ab cl mi mj go mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ha hb hc hd he"><p id="710e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将我们的架构分成不同的层，并记录每一层的责任，这对我们分布式的贡献者团队来说效果很好。例如，强制使用用例框架从存储库层检索数据使得脱离主线程成为默认行为，避免从一开始就引入jank，而不是在以后不得不追踪它。还有，大多数测试问题都是伪装的架构问题；打下一个良好的基础对于构建一个合理的测试体验是必不可少的。</p><p id="1195" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Iosched是一款拥有真实用户的真实应用，并且有一个非常真实的截止日期。因此，我们希望在一些领域继续努力，以保持代码库的健康、可维护性，并使其成为更好的示例应用。例如,<code class="du md me mf mg b"><a class="ae it" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/schedule/ScheduleViewModel.kt" rel="noopener ugc nofollow" target="_blank">ScheduleViewModel</a></code>是有机生长的，可以用来分解。我们计划公开改进该应用程序，添加新的架构组件，修复问题，重构和增加代码覆盖率。</p><p id="999d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您发现问题或想要为项目做出贡献，请随时打开<a class="ae it" href="https://github.com/google/iosched/issues" rel="noopener ugc nofollow" target="_blank">问题</a>！</p></div></div>    
</body>
</html>