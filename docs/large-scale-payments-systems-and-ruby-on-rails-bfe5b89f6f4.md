# 大规模支付系统和 Ruby on Rails

> 原文：<https://medium.com/airbnb-engineering/large-scale-payments-systems-and-ruby-on-rails-bfe5b89f6f4?source=collection_archive---------0----------------------->

米歇尔·韦克斯勒

![](img/bc8142ec74a10b006d58618da449cb12.png)

在过去的 30 年里，我一直在为乐趣和工作编写代码，无论是在小型创业公司还是大型公司。

多年来，我迷上了支付行业，过去十年我一直在支付相关公司工作。在来 Airbnb 从事支付工作之前，我为 [PayPal](http://www.paypal.com/) 工作，为[几家](http://www.causes.com/) [初创公司](http://www.progressfin.com/)工作，然后是谷歌 NFC 钱包项目的一部分。

支付领域很有趣，因为它结合了对核心计算机科学的强烈需求和建立在老龄化基础上的行业。尽管位置感知和强加密等技术已经变得无处不在，但全球支付的基本方式基本保持不变。该行业变革的时机已经成熟，但却极其抗拒变革。这是一个有趣的技术问题，也是一个棘手的商业问题。

这些年来，我见过用各种语言编写的支付系统。我注意到支付工作的方式转化为影响语言和框架选择权衡的需求。例如，支付应用程序通常需要强大的交易完整性、强大的审计跟踪和非常可预测的故障行为。

# 挑战

Ruby on Rails 以其快速的迭代周期和大量加速开发和简化原型的神奇工具而闻名。这些好处集中在改进开发过程上，但是在某些情况下使得生产系统的维护更加困难。就支付方式而言，它的一些缺点意味着麻烦。

# 易测性

[ActiveRecord 模式](http://en.wikipedia.org/wiki/Active_record_pattern)支持包含数据库访问逻辑和业务逻辑的大型整体模型类。测试这些类是困难的。除了它们所依赖的数据库表之外，描述它们的依赖关系并不容易，因此很难为它们编写好的、全面的单元测试。这使得很难对他们的行为进行推理。例如:*如果没有真正好的单元测试，你真的能保证这个触及我们交易表的 3000 行模型不包含一分误差吗？*

# 审查跟踪

对于涉及金钱或用户信息的每一项更改，维护“谁在何时做了什么”的日志是任何支付系统的重要组成部分。ActiveRecord 使得修改数据库变得非常容易，但却很难确保改变数据的每一部分代码都记录了审计线索。此外，在某些情况下(比如像 [update_all](http://apidock.com/rails/ActiveRecord/Base/update_all/class) 这样的批量更新)，没有办法强制每个数据库更改都创建一个审计跟踪。编程捕获所有数据突变的唯一方法是通过[数据库触发器](http://en.wikipedia.org/wiki/Database_trigger)。

# 可预测的故障行为

在公共接口方法的开始显式检查预期的条件和参数值通常是一个好主意。例如，如果一个参数不能为 nil，那么如果传递了 nil，就会引发一个异常。这转化为非常响亮的失败场景，但最终确保问题出现并得到解决，并使错误更容易被跟踪。

Ruby 的弱类型使得执行这些规则更加困难。在强类型语言中，如果你在应该是字符串的地方传入一个 int，编译器会报错。

此外，Ruby 在很多情况下使用 nil 作为标记来表示“没有返回值”。这很危险，因为 nil 也是未初始化变量的默认值。这使得很难识别变量名键入错误或没有正确初始化的错误。

# Airbnb 的方式

考虑到这些问题，payments 可能更适合数据库访问模型更受限制的强类型语言。然而，在 Airbnb，我们使用 Rails 进行支付。我们没有因为 Rails 的缺点而抛弃它，而是想出了它的主要问题的解决方案，让它很好地用于支付。这使我们能够继续享受它提供的许多好处。

# 减少 ActiveRecord 的表面积

适当审计跟踪的一个关键要求是减少代码对原始数据库数据的访问。为了实现这一点，我们开始在 ***ActiveRecord*** 之上使用一个层，我们称之为***protected access***，它控制对底层表的更改，并确保写入审计线索。它还通过在默认情况下不公开 ActiveRecord 的所有数据突变方法，极大地减少了 active record 的表面积，从而迫使开发人员思考他们调用什么方法，这使得在代码审查期间更有可能捕获不需要的数据突变。

***ProtectedAccess*** 旨在替换现有的***active record::Base***类。它公开了一些相同的接口，但实际上隐藏了大多数改变对象的方法。这个想法是不允许对一个不容易被审计跟踪的模型进行大部分变更，对于那些可以的，创建一个透明地创建审计跟踪的垫片。

例如，假设您有一个 ***付款*** 模型，该模型有一个 ***金额*** 字段。通过扩展***active record::Base***，公开了一个 setter***amount =***。任何一段代码都可以调用:

这将创建支付记录的未经审计的修改。

相比之下，***protected access***在表面区域之间创建一个 shim，其中仍然包含***amount =******save***，以及 ***ActiveRecord*** 模型。当 ***保存*** 被调用时，它创建并保存记录的新版本，而不是覆盖现有版本。任何人都无法调用可以访问付款表的实际模型，因为它不存在，除了 Payment***类的私有成员< ProtectedAccess*** 对象。

# 参数验证—快速失败(并且声音很大！)和显式依赖关系

我们使用声明性框架进行参数验证，使服务对象(以及方法)能够检查参数的类型和值范围是否正确，确保强制参数存在，并确保没有意外参数传入。它的灵感大致来自于[芭乐的前置职业](http://guava-libraries.googlecode.com/svn-history/r14/trunk/javadoc/com/google/common/base/Preconditions.html)。

一个例子可能是服务对象的 ***验证*** 方法的实现:

这并不是试图让 ruby 成为强类型(尽管这可能不是一个坏主意……)，而是一种显式声明和强制对象或方法的依赖关系的方式。它也不像某些[依赖](https://github.com/google/guice) [注入](http://square.github.io/dagger/)框架那样处理实例化。但是它可以让阅读一段代码的人更清楚它的依赖关系是什么。它还会导致更快的故障。如果没有验证，bug 会导致一个意外的值在代码中传播，直到(希望)某个东西爆炸了，或者(更有可能)向用户显示一个奇怪的结果，而没有任何来源的指示。验证时会抛出一个异常，进程崩溃，开发人员会得到问题的警告。可以说，告诉用户某个地方出错了，比呈现某个可能完全出错的地方要好。

冻结常数是我们使用的另一个相关方法，除了 ruby 解释器在修改常数时发出的警告之外。

参数验证非常通用，可以用于任何 Ruby 应用程序。我们目前正在评估何时可能是开源它的合适时机。

# 服务对象

我们没有将业务逻辑放在模型中，而是保持模型精简，只关注数据检索和存储。所有的业务逻辑都放在服务对象中，服务对象是单一用途的业务逻辑对象，用一组明确定义的参数进行初始化，然后对它们执行操作。它们往往体积较小，非常专注于执行特定的任务。因为它们有一组定义良好的参数，所以更容易测试，并且可以主要使用 mocking 进行测试(与创建测试数据库条目或测试网络服务相反)。

例如，假设您有一些代码调用一些外部网关来完成事务。它可能看起来像

服务对象可能看起来像:

调用此服务对象的方式如下:

服务对象框架将进行一些飞行前日志记录，然后调用 perform，随后进行飞行后日志记录。

请注意，验证、日志记录和其他管理现在被分离到它们自己的方法中，而 ***执行*** 方法可以专注于纯业务逻辑。它可以对参数做出许多假设，因为这些假设已经过强有力的验证。代码中有趣的部分也更容易被试图弄清楚它在做什么的人所理解。
因为 ***o.validate*** 必须声明每一个可以传递给服务对象的参数，所以真的很清楚它依赖的是什么。这是一种不会过时的代码文档形式。

# 严格的代码风格和代码复杂性过滤器

为了让代码更容易理解，我们在一些回购中使用了 [rubocop](https://github.com/bbatsov/rubocop) 和 [cane](https://github.com/square/cane) 。这些工具在我们的代码上实施了一种共同的风格(rubocop ),并确保代码不会过于复杂(cane)。

Rubocop 非常适合帮助新手了解“地形”,并让每个人都知道什么是预期的代码风格。Cane 测量 [ABC 代码大小度量](http://c2.com/cgi/wiki?AbcMetric)的能力对于强制创建小的、易于阅读和理解的方法非常有用。我们偶尔会看到我们选择的 cane 阈值(15 ABC 分数)过于严格的情况，但总的来说，它促使我们在代码中保持清晰和简洁。

以下面的情况为例:

它的 ABC 分数是 12。

将其与同等产品进行比较:

其 ABC 分数为 8。

区别很简单:

1.  早期评估边缘情况条件，并暂停处理，而不是使用 ***else*** 子句。
2.  提取 ***电子邮件*** 参数，而不是通过参数和消息取消引用。

Cane 并没有提出那些改变，它只是提醒你有太多的复杂性。当发生这种情况时，由团队来建立如何降低复杂性的经验法则。

# 干涸的东西——宝石和模块

在宝石或混合宝石中，大量使用[干燥](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)东西的做法。

Gems 通常用于提取需要在多个内部应用程序之间共享的常用功能。我们的一些宝石也是[开源](http://nerds.airbnb.com/open-source/)。除了这些开源示例之外，我们还有内部的 gems，用于将信用卡信息安全地发送到我们的信用卡处理器，用于在我们的各种应用程序之间保持货币信息的一致性，以及用于参数验证。

如果需要在同一个应用程序中重用功能，我们有时会使用模块混合——将功能放在一个模块中，然后在需要的地方包含它。

# 禁用副本读取

MySQL 环境中一个常见的扩展策略是使用数据库副本进行读取，从而减少主 MySQL 上的流量。这样做的缺点是，您的代码有时可能会得到陈旧的数据。对于支付，我们通常会禁用副本读取，以牺牲主数据库的负载来换取数据完整性。例如，您进行的新交易不包括上一笔交易的结果是不可接受的。

# 过渡

在过去的几年里，我们学到了很多关于建立和维护大规模支付系统的知识。我们学到的一些东西已经在我们的代码库中实现了，并且是我们日常最佳实践的一部分。其他的学习仍然是相当新的，他们所依赖的框架仍在建设中。一如既往，我们的系统在不断发展，我们也在不断寻找方法让它变得更好、更强大。

如果你有兴趣更积极地参与到我们打造更好、更具扩展性和健壮性的系统的过程中，我很乐意听到你的声音——michel.weksler@airbnb.com

![](img/3913f6470a7657e02386189e67b4eb30.png)

## 在 [airbnb.io](http://airbnb.io) 查看我们所有的开源项目，并在 Twitter 上关注我们:[@ Airbnb eng](https://twitter.com/AirbnbEng)+[@ Airbnb data](https://twitter.com/AirbnbData)

*原载于 2015 年 2 月 26 日 nerds.airbnb.com**[*。*](http://nerds.airbnb.com/large-scale-payments-systems-ruby-rails/)*