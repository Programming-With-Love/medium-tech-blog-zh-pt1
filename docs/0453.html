<html>
<head>
<title>Zero-cost* abstractions in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的零成本*抽象</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/zero-cost-abstractions-in-kotlin-19b953f3a936?source=collection_archive---------1-----------------------#2020-01-22">https://medium.com/androiddevelopers/zero-cost-abstractions-in-kotlin-19b953f3a936?source=collection_archive---------1-----------------------#2020-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/32f9975fd0c3198a5203e0e15df3b9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3V2U8qG7bua3PGlA5t_KA.png"/></div></div></figure><div class=""/><div class=""><h2 id="30a5" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated"><code class="du jh ji jj jk b">inline</code>科特林词汇:类</h2></div><p id="2ba0" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><em class="kh">*条款和条件适用</em></p><blockquote class="ki"><p id="6b59" class="kj kk hs bd kl km kn ko kp kq kr kg dx translated">⚠️<em class="ks">【2021年5月更新】内联类的内联修饰符现在已经过时了！</em> ⚠️</p></blockquote><p id="184a" class="pw-post-body-paragraph jl jm hs jn b jo kt it jq jr ku iw jt ju kv jw jx jy kw ka kb kc kx ke kf kg ha bi translated"><em class="kh">警告:这篇博文涵盖了Kotlin的一个实验性特性，可能会有变化。本文是使用Kotlin 1.3.50编写的。</em></p><p id="9abb" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">类型安全防止我们犯错误或者以后不得不调试它们。对于Android资源类型，如<code class="du jh ji jj jk b">String</code>、<code class="du jh ji jj jk b">Font</code>或<code class="du jh ji jj jk b">Animation</code>资源，我们可以使用<code class="du jh ji jj jk b">androidx.annotations</code>，如<code class="du jh ji jj jk b">@StringRes</code>、<code class="du jh ji jj jk b">@FontRes</code>，Lint强制我们传递正确类型的参数:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="db8c" class="lg lh hs jk b fi li lj l lk ll">fun myStringResUsage(@StringRes string: Int){ }</span><span id="b510" class="lg lh hs jk b fi lm lj l lk ll">// Error: expected resource of type String<br/>myStringResUsage(1)</span></pre><p id="0004" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">如果我们的id不是Android资源，而是像<code class="du jh ji jj jk b">Doggo</code>或<code class="du jh ji jj jk b">Cat</code>这样的域对象的id，那么区分这两个<code class="du jh ji jj jk b">Int</code>id就不容易了。为了实现类型安全，即编码狗的id与猫的id不同，您必须将您的id包装在一个类中。这样做的缺点是，你要付出性能代价，因为需要实例化一个新对象，而实际上，你所需要的只是一个原语。</p><p id="d9c8" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">Kotlin <a class="ae ln" href="https://kotlinlang.org/docs/reference/inline-classes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jn ht">内联类</strong> </a>允许你创建这些包装器类型<strong class="jn ht">而没有</strong>性能成本。这是Kotlin 1.3中添加的一个实验性特性。内联类必须正好有一个属性。在编译时，内联类实例在可能的情况下被替换为它们的底层属性(取消装箱)，从而降低了常规包装类的性能成本。这对于被包装的对象是原始类型的情况更为重要，因为编译器已经对它们进行了优化。因此，如果可能的话，在内联类中包装基元类型会导致在运行时将值表示为基元值。</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="bd2b" class="lg lh hs jk b fi li lj l lk ll">inline class DoggoId(val id: Long)<br/>data class Doggo(val id: DoggoId, … )</span><span id="4ea9" class="lg lh hs jk b fi lm lj l lk ll">// usage<br/>val goodDoggo = Doggo(DoggoId(doggoId), …)<br/>fun pet(id: DoggoId) { … }</span></pre><h1 id="6842" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">获得内嵌</h1><p id="89d0" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">内联类的唯一作用是作为一个类型的包装器，因此Kotlin实施了许多限制:</p><ul class=""><li id="6d33" class="mk ml hs jn b jo jp jr js ju mm jy mn kc mo kg mp mq mr ms bi translated">不超过一个参数(对类型没有限制)</li><li id="6694" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">没有<a class="ae ln" href="https://kotlinlang.org/docs/reference/properties.html#backing-fields" rel="noopener ugc nofollow" target="_blank">支持字段</a></li><li id="ad80" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">没有初始化块</li><li id="0c21" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">没有扩展类</li></ul><p id="3f0c" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">但是，内联类可以:</p><ul class=""><li id="b65f" class="mk ml hs jn b jo jp jr js ju mm jy mn kc mo kg mp mq mr ms bi translated">从接口继承</li><li id="ef32" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">具有属性和功能</li></ul><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="9352" class="lg lh hs jk b fi li lj l lk ll">interface Id<br/>inline class DoggoId(val id: Long) : Id {<br/>    <br/>    val stringId<br/>    get() = id.toString()</span><span id="ad3b" class="lg lh hs jk b fi lm lj l lk ll">    fun isValid()= id &gt; 0L<br/>}</span></pre><blockquote class="my mz na"><p id="0cc6" class="jl jm kh jn b jo jp it jq jr js iw jt nb jv jw jx nc jz ka kb nd kd ke kf kg ha bi translated">⚠️警告:<a class="ae ln" href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jn ht"> Typealias </strong> </a>可能看起来类似于内联类，但是，类型别名只是为现有类型提供了一个替代名称，而内联类<strong class="jn ht">创建了一个新类型</strong>。</p></blockquote><h1 id="efa4" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">表示—包装或不包装？</h1><p id="d17c" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">由于内联类相对于手动包装类的最大优势是内存分配的影响，重要的是要记住这很大程度上取决于您在哪里以及如何使用内联类。一般规则是，如果内联类用作另一种类型，参数将被包装(装箱)。</p><blockquote class="ki"><p id="650d" class="kj kk hs bd kl km kn ko kp kq kr kg dx translated">当用作另一种类型时，参数被装箱</p></blockquote><p id="cef0" class="pw-post-body-paragraph jl jm hs jn b jo kt it jq jr ku iw jt ju kv jw jx jy kw ka kb kc kx ke kf kg ha bi translated">例如，如果您在需要一个对象或任何对象时使用它，例如在集合、数组中或作为可空对象。根据您如何检查两个内联类的结构相等性，它们中的一个或一个都不会被装箱:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="d95a" class="lg lh hs jk b fi li lj l lk ll">val doggo1 = DoggoId(1L)</span><span id="b0ac" class="lg lh hs jk b fi lm lj l lk ll">val doggo2 = DoggoId(2L)</span></pre><p id="8453" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b">doggo1 == doggo2</code>—doggo 1和doggo2都没有被装箱</p><p id="3290" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b">doggo1.equals(doggo2)</code> — doggo1被用作原语，但doggo2被装箱</p><h1 id="76bf" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">在后台</h1><p id="018d" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">让我们来看一个简单的内联类:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="8efe" class="lg lh hs jk b fi li lj l lk ll">interface Id<br/>inline class DoggoId(val id: Long) : Id</span></pre><p id="3683" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">让我们一步一步地看看反编译的Java编程语言代码是什么样子，以及它们对使用内联类有什么影响。你可以在这里找到完整的反编译代码<a class="ae ln" href="https://gist.github.com/florina-muntenescu/2a9d07edbe8fc701bfcb32143bf2a090#file-ids-decompiled-java" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="d41d" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">引擎盖下——构造函数</h1><figure class="ky kz la lb fd hj"><div class="bz dy l di"><div class="ne nf l"/></div></figure><p id="06ea" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">DoggoId有两个构造函数:</p><ul class=""><li id="6ce0" class="mk ml hs jn b jo jp jr js ju mm jy mn kc mo kg mp mq mr ms bi translated">私人合成建造商<code class="du jh ji jj jk b">DoggoId(long id)</code></li><li id="05e2" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">一次公开<code class="du jh ji jj jk b">constructor-impl</code></li></ul><p id="1e29" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">创建对象的新实例时，使用公共构造函数:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="aecf" class="lg lh hs jk b fi li lj l lk ll">val myDoggoId = DoggoId(1L)</span><span id="f543" class="lg lh hs jk b fi lm lj l lk ll">// decompiled<br/>static final long myDoggoId = DoggoId.constructor-impl(1L);</span></pre><p id="7b99" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">如果我们尝试用Java创建doggo id，我们会得到一个错误:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="b8b1" class="lg lh hs jk b fi li lj l lk ll">DoggoId u = new DoggoId(1L);<br/>// Error: DoggoId() in DoggoId cannot be applied to (long)</span></pre><blockquote class="ki"><p id="4983" class="kj kk hs bd kl km ng nh ni nj nk kg dx translated">你不能从Java实例化一个内联类</p></blockquote><p id="1f9d" class="pw-post-body-paragraph jl jm hs jn b jo kt it jq jr ku iw jt ju kv jw jx jy kw ka kb kc kx ke kf kg ha bi translated">参数化的构造函数是私有的，第二个构造函数的名称中包含一个<code class="du jh ji jj jk b">-</code>，这在Java中是一个无效字符。这意味着内联类不能从Java实例化。</p><h1 id="2779" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">引擎盖下—参数用法</h1><figure class="ky kz la lb fd hj"><div class="bz dy l di"><div class="ne nf l"/></div></figure><p id="9e33" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">id以两种方式公开:</p><ul class=""><li id="5ea0" class="mk ml hs jn b jo jp jr js ju mm jy mn kc mo kg mp mq mr ms bi translated">作为原语，通过<code class="du jh ji jj jk b">getId</code></li><li id="b935" class="mk ml hs jn b jo mt jr mu ju mv jy mw kc mx kg mp mq mr ms bi translated">通过一个创建DoggoId新实例的<code class="du jh ji jj jk b">box_impl</code>方法作为一个对象</li></ul><p id="e561" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">当在可以使用原语的地方使用内联类时，Kotlin编译器将知道这一点，并将直接使用原语:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="2c00" class="lg lh hs jk b fi li lj l lk ll">fun walkDog(doggoId: DoggoId) {}</span><span id="4a27" class="lg lh hs jk b fi lm lj l lk ll">// decompiled Java code<br/>public final void walkDog_Mu_n4VY(<strong class="jk ht">long</strong> doggoId) { }</span></pre><blockquote class="ki"><p id="2f9e" class="kj kk hs bd kl km ng nh ni nj nk kg dx translated">当需要一个对象时，Kotlin编译器将使用我们原语的装箱版本，每次都会创建一个新的对象。</p></blockquote><p id="8e46" class="pw-post-body-paragraph jl jm hs jn b jo kt it jq jr ku iw jt ju kv jw jx jy kw ka kb kc kx ke kf kg ha bi translated">当需要一个对象时，Kotlin编译器将使用我们原语的装箱版本，每次都会创建一个新的对象<strong class="jn ht">。例如:</strong></p><h2 id="4f48" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">可空对象</h2><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="74f6" class="lg lh hs jk b fi li lj l lk ll">fun pet(<strong class="jk ht">doggoId: DoggoId?</strong>) {}</span><span id="8fc2" class="lg lh hs jk b fi lm lj l lk ll">// decompiled Java code<br/>public static final void pet_5ZN6hPs/* $FF was: pet-5ZN6hPs*/(@Nullable InlineDoggoId doggo) {}</span></pre><p id="54c0" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">因为只有对象可以为空，所以使用装箱的实现。</p><h2 id="f8c9" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">收集</h2><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="ba6f" class="lg lh hs jk b fi li lj l lk ll">val doggos = listOf(myDoggoId)</span><span id="4642" class="lg lh hs jk b fi lm lj l lk ll">// decompiled Java code<br/>doggos = CollectionsKt.listOf(<strong class="jk ht">DoggoId.box-impl(myDoggoId)</strong>);</span></pre><p id="cb43" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b">CollectionsKt.listOf</code>的签名是:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="1768" class="lg lh hs jk b fi li lj l lk ll">fun &lt;T&gt; listOf(element: T): List&lt;T&gt;</span></pre><p id="e171" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">因为这个方法需要一个对象，所以Kotlin编译器将我们的原语打包，确保使用了一个对象。</p><h2 id="7d72" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">基类</h2><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="f967" class="lg lh hs jk b fi li lj l lk ll">fun handleId(id: Id) {}</span><span id="8a4e" class="lg lh hs jk b fi lm lj l lk ll">fun myInterfaceUsage() {<br/>    handleId(myDoggoId)<br/>}</span><span id="5556" class="lg lh hs jk b fi lm lj l lk ll">// decompiled Java code<br/>public static final void myInterfaceUsage() {<br/>    handleId(<strong class="jk ht">DoggoId.box-impl(myDoggoId)</strong>);<br/>}</span></pre><p id="962a" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">因为这里我们期望一个超类型，所以使用了装箱的实现。</p><h1 id="440e" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">引擎盖下—平等检查</h1><p id="41ce" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">Kotlin编译器尽可能使用unboxed参数。为此，内联类有3种不同的等式实现:一个equals的重写和2个生成的方法:</p><figure class="ky kz la lb fd hj"><div class="bz dy l di"><div class="ne nf l"/></div></figure><p id="482c" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b"><strong class="jn ht">doggo1.equals(doggo2)</strong></code></p><p id="70fe" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">equals方法调用一个生成的方法:<code class="du jh ji jj jk b">equals_impl(long, Object)</code>。由于equals需要一个对象，因此doggo2值将被装箱，但doggo1将被用作原语:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="a4aa" class="lg lh hs jk b fi li lj l lk ll">DoggoId.equals-impl(doggo1, DoggoId.box-impl(doggo2))</span></pre><p id="203d" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b"><strong class="jn ht">doggo1 == doggo2</strong></code></p><p id="18b0" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">使用<code class="du jh ji jj jk b">==</code>生成:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="3113" class="lg lh hs jk b fi li lj l lk ll">DoggoId.equals-impl0(doggo1, doggo2)</span></pre><p id="d8b9" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">所以在<code class="du jh ji jj jk b">==</code>的情况下，原语将被用于doggo1和doggo2。</p><p id="ff6a" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b"><strong class="jn ht">doggo1 == 1L</strong></code></p><p id="dc6c" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">如果Kotlin能够确定doggo1实际上是一个long类型，那么您可以预期这个等式检查会起作用。但是，因为我们使用内联类是为了它们的类型安全，那么，编译器要做的第一件事就是检查我们要比较的两个对象的类型是否相同。而既然不是，我们会得到一个编译错误:<em class="kh">运算符</em> <code class="du jh ji jj jk b"><em class="kh">==</em></code> <em class="kh">不能应用于long和DoggoId </em>。最后，对于编译器来说，这就好像我们说了<code class="du jh ji jj jk b">cat1 == doggo1</code>，这肯定不是真的。</p><p id="ea47" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b"><strong class="jn ht">doggo1.equals(1L)</strong></code></p><p id="46f5" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">这种相等性检查确实可以编译，因为Kotlin编译器使用equals实现，该实现需要一个long和一个Object。但是，因为这个方法做的第一件事是检查对象的类型，这个等式检查将是假的，因为对象不是DoggoId。</p><h1 id="77b3" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">用原语和内联类参数重写函数</h1><p id="9375" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">Kotlin编译器允许使用原始的和不可空的内联类作为参数来定义函数:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="f927" class="lg lh hs jk b fi li lj l lk ll">fun pet(doggoId: <strong class="jk ht">Long</strong>) {}<br/>fun pet(doggoId: <strong class="jk ht">DoggoId</strong>) {}</span><span id="b9df" class="lg lh hs jk b fi lm lj l lk ll">// decompiled Java code<br/>public static final void pet(long id) { }<br/>public final void <strong class="jk ht">pet_Mu_n4VY</strong>(long doggoId) { }</span></pre><p id="6e74" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">在反编译的代码中，我们可以看到两个函数都使用了原语。</p><p id="f1d2" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">为了实现这一功能，Kotlin编译器将把内联类作为一个参数，从而破坏函数的名称。</p><h1 id="ce4c" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">在Java中使用内联类</h1><p id="fc84" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">我们已经看到，我们不能在Java中实例化一个内联类。使用它们怎么样？</p><h2 id="d8fe" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">✅将内联类传递给Java函数</h2><p id="e5c1" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">我们可以将它们作为参数传递，用作对象，我们可以获得它们包装的属性。</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="7d94" class="lg lh hs jk b fi li lj l lk ll">void myJavaMethod(DoggoId doggoId){<br/>    long id = doggoId.getId();<br/>}</span></pre><h2 id="4fc4" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">在Java函数中使用内联类实例的✅</h2><p id="a31c" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">如果我们有定义为顶级对象的内联类实例，我们可以在Java中将它们作为原语进行引用，如</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="e913" class="lg lh hs jk b fi li lj l lk ll">// Kotlin declaration<br/>val doggo1 = DoggoId(1L)</span><span id="262f" class="lg lh hs jk b fi lm lj l lk ll">// Java usage<br/>long myDoggoId = GoodDoggosKt.getU1();</span></pre><h2 id="c405" class="lg lh hs bd lp nl nm nn lt no np nq lx ju nr ns lz jy nt nu mb kc nv nw md nx bi translated">将内联类作为参数的✅&amp; ❌calling·科特林函数</h2><p id="ac09" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">如果我们有一个接收内联类参数的Java函数，并且我们想调用一个接受内联类的Kotlin函数，我们会得到一个编译错误:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="23e5" class="lg lh hs jk b fi li lj l lk ll">fun pet(doggoId: <strong class="jk ht">DoggoId</strong>) {}</span><span id="60d4" class="lg lh hs jk b fi lm lj l lk ll">// Java<br/>void petInJava(doggoId: DoggoId){<br/>    <strong class="jk ht">pet(doggoId)</strong> <br/>    // compile error: pet(long) cannot be applied to pet(DoggoId)<br/>}</span></pre><p id="af33" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">对于Java来说，<code class="du jh ji jj jk b">DoggoId</code>是一个新类型，但是编译器生成的是<code class="du jh ji jj jk b">pet(long)</code>，<code class="du jh ji jj jk b">pet(DoggoId)</code>不存在。</p><p id="c5e1" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">但是，我们能够传递底层类型:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="fda9" class="lg lh hs jk b fi li lj l lk ll">fun pet(doggoId: <strong class="jk ht">DoggoId</strong>) {}</span><span id="aa30" class="lg lh hs jk b fi lm lj l lk ll">// Java<br/>void petInJava(doggoId: DoggoId){<br/>    pet(doggoId.<strong class="jk ht">getId</strong>)<br/>}</span></pre><p id="4de2" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">如果在同一个类中，我们用内联类和底层类型重写了一个函数，当我们从Java中调用这个函数时，我们会得到一个错误，因为编译器无法判断我们实际上想要调用哪个函数:</p><pre class="ky kz la lb fd lc jk ld le aw lf bi"><span id="126a" class="lg lh hs jk b fi li lj l lk ll">fun pet(doggoId: <strong class="jk ht">Long</strong>) {}</span><span id="dfdb" class="lg lh hs jk b fi lm lj l lk ll">fun pet(doggoId: <strong class="jk ht">DoggoId</strong>) {}</span><span id="0f47" class="lg lh hs jk b fi lm lj l lk ll">// Java<br/>TestInlineKt.pet(1L);</span><span id="3fcb" class="lg lh hs jk b fi lm lj l lk ll">Error: Ambiguous method call. Both pet(long) and pet(long) match</span></pre><h1 id="5ed9" class="lo lh hs bd lp lq lr ls lt lu lv lw lx iy ly iz lz jb ma jc mb je mc jf md me bi translated">内嵌还是不内嵌</h1><p id="4e0b" class="pw-post-body-paragraph jl jm hs jn b jo mf it jq jr mg iw jt ju mh jw jx jy mi ka kb kc mj ke kf kg ha bi translated">类型安全有助于我们编写更健壮的代码，但从历史上看，这可能会影响性能。内联类提供了两个世界最好的东西，类型安全<em class="kh">而没有</em>成本——你应该总是使用它们吗？</p><p id="52cf" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">内联类带来了一系列限制，确保您创建的对象只扮演一个角色:作为包装器。这意味着在将来，不熟悉代码的开发人员将无法像处理数据类那样，通过向构造函数添加其他参数来错误地增加类的复杂性。</p><p id="1393" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">在性能方面，我们已经看到Kotlin编译器尽可能使用底层类型，但在许多情况下仍然会创建新的对象。</p><p id="1c82" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">使用Java有几个注意事项，因此，如果您还没有完全迁移到Kotlin，您可能会遇到无法使用内联类的情况。</p><p id="17bb" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">最后，这仍然是一个实验性的特性，一旦它稳定下来，它的实现是否会保持不变，以及它是否真的会升级到稳定，这都带来了不确定性。</p><p id="c93b" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">所以现在您已经理解了内联类的好处和限制，您可以就是否以及何时使用它们做出明智的决定。</p></div></div>    
</body>
</html>