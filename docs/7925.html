<html>
<head>
<title>An Approach to Application Performance Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种应用程序性能优化方法</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/an-approach-to-application-performance-optimisation-cdb8ea192cdf?source=collection_archive---------0-----------------------#2020-10-28">https://medium.com/walmartglobaltech/an-approach-to-application-performance-optimisation-cdb8ea192cdf?source=collection_archive---------0-----------------------#2020-10-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在当今微服务架构、不断增加的服务数量和严格的服务SLA的世界中，应用性能对于确保客户的E2E无缝体验至关重要。</p><p id="9f2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文提供了对应用程序性能评估的见解，并设计了关于如何使用特定的<strong class="ig hi"> Azure服务</strong>和其他代码优化来提高应用程序性能的解决方案。</p><h2 id="d88e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">了解应用程序的组件</h2><p id="3c2e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">构建的大多数应用程序都使用目前可用的依赖注入框架。一个应用程序嵌入了多个组件。对它们中的每一个进行优化对于拥有一个高性能的应用程序是至关重要的。</p><p id="9f43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个应用程序可以包括—</p><ul class=""><li id="5e66" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">RDBMS和非SQL数据库的CRUD操作</li><li id="33e8" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">使用不同种类的设计模式处理业务逻辑的API。</li><li id="3d3b" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">缓存。</li><li id="fb44" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">异步处理。</li><li id="f6e3" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">批量处理。</li><li id="9647" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">预定数据处理。</li></ul><p id="5a0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有更多..</p><h1 id="3534" class="kq jd hh bd je kr ks kt ji ku kv kw jm kx ky kz jp la lb lc js ld le lf jv lg bi translated"><strong class="ak">性能优化方法</strong></h1><p id="47c3" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">性能优化是一个迭代的过程，包括对应用程序运行多个负载测试，以了解每个组件的行为。我们将研究最常用的组件，以及如何寻找相同的优化。</p><p id="c0c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> SQL DB优化</strong> <br/>大多数云提供商都有性能监控工具来衡量与组件性能相关的不同指标。Microsoft Azure提供了智能性能工具，该工具可以洞察查询性能，并通过提供不同的建议来帮助优化查询。很少有人-</p><ul class=""><li id="b9bb" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">根据需要添加或删除索引。</li><li id="5c27" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">减少资源使用的缓存执行计划的参数化查询。</li></ul><p id="d3b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">内存使用审查<br/> </strong>在应用程序准备好投入生产之前，有必要分析内存使用情况，以确保没有内存泄漏阻碍性能。当应用程序在高负载下运行时，使用以下命令拍摄堆快照—</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="feaf" class="jc jd hh lm b fi lq lr l ls lt">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><span id="12b8" class="jc jd hh lm b fi lu lr l ls lt">pid - process id of the java process running on the server.</span></pre><p id="bd7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以连接到远程应用程序，并使用VisualVM等工具了解正在运行的应用程序的内存使用情况。这将需要在服务器端进行一些防火墙更改，以确保您可以连接到远程服务器上的应用程序。</p><ul class=""><li id="324f" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">堆利用率查看</strong> <br/>可以使用VisualVM上的VisualGC插件查看JVM堆利用率。这提供了在将对象移动到old gen之前每个GC如何影响Eden和Survivor空间的见解。图中向上的斜率和向下的斜率表示内存利用率如何随时间增加和减少。这两个斜率都表示内存利用率是健康的。</li></ul><figure class="lh li lj lk fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lv"><img src="../Images/4bcde81a743814a761ea6ee2a415b0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BekjUqPTDIwlQj0m4spJkg.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Heap Utilization</figcaption></figure><figure class="lh li lj lk fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es mh"><img src="../Images/346cdc440b62821b67d4745cda95790f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqqpIl9RcUMFWSI8lj1piQ.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Heap Graphs</figcaption></figure><p id="f5a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的完全Eden空间利用率表明对象分配更好，堆得到了最大程度的利用。</p><ul class=""><li id="9f91" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">内存泄漏</strong> <br/>内存泄漏是降低应用程序性能的主要原因之一，最终会导致应用程序崩溃。<br/> VisualVM提供内存和CPU分析器和采样器。内存分析器中对象的生成计数提供了存活时间最长的对象的数据，可以指示内存泄漏。我们可以肯定，它需要更多的分析来解释为什么对象能够在垃圾收集周期中存活，但是任何存活时间更长的对象，如果不是为了在垃圾收集周期中存活而特别需要的，都很可能导致内存泄漏。</li><li id="b1ea" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">使用IntelliJ进行代码检查</strong> <br/> IntelliJ提供了一种漂亮的方式来分析代码，并提供与内存和性能相关的问题。大多数时候，我们没有意识到集合有默认的内存分配，并且过度使用集合中数据较少的集合会导致更高的内存利用率。通过IntelliJ的Inspect Code实用程序，它为我们提供了改进性能的建议。我们几乎总是无法初始化集合的大小。由于内存分配失败，这可能会导致更高的GC。<br/>另一个需要解决的问题是匿名类的使用。匿名类有悬挂引用的危险，这些引用永远不会被垃圾收集，会导致内存泄漏。所有这些性能和内存问题的建议都应该在每次代码提交之前考虑。</li><li id="c4f8" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">垃圾收集日志<br/> </strong>垃圾收集日志有助于识别JVM堆利用率、与内存相关的问题，并可能指示内存泄漏。<br/>在构建应用程序时，我们无法识别JVM的年轻一代和老一代内存分配。这是JVM的默认设置。但是JVM提供了一种使用-XX:NewSize和-XX:MaxNewSize标志来调整新旧代内存分配比例的方法。当我们意识到由于数据处理中固有的应用复杂性，应用需要比老一代空间更大的年轻一代空间时，这些标志可以帮助更好地利用年轻一代和老一代空间。<br/>可以使用许多开源网站来分析GCLogs，例如:<a class="ae mi" href="https://www.gceasy.io/" rel="noopener ugc nofollow" target="_blank">https://www.gceasy.io/</a></li></ul><p id="22f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以通过将下面的命令附加到catalina opts来获得GC日志。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7dd9" class="jc jd hh lm b fi lq lr l ls lt">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCCause -Xloggc:&lt;folderName&gt;\&lt;filename&gt;.log</span></pre><ul class=""><li id="c799" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">线程软引用<br/> </strong>对象映射器和异步线程处理使用软引用在请求处理期间更快地检索对象。软引用对象可以在内存中停留更长的时间，而不会受到大规模GC的影响。只有当内存需求达到阈值时，才会对它们进行GC。当您使用对象映射器处理大型json文档或进行大量异步处理时，这会导致应用程序崩溃。有两种方法可以缓解这个问题— <br/> —在对象映射器的JsonFactory中禁用特性<em class="mj">USE _ THREAD _ LOCAL _ FOR _ BUFFER _ RECYCLING</em>。<br/> —调整JVM标志的值:-XX:SoftRefLRUPolicyMSPerMB。</li><li id="479c" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">缓存<br/> </strong>缓存是应用程序中广泛使用的概念之一，它可以帮助存储更快检索所需的静态数据。虽然我们有多个可用的缓存库，或者我们可以简单地使用静态对象，但重要的是要注意它们之间的权衡，并使用最佳方式在应用程序中缓存数据。<br/>使用从不刷新且不断增长的静态缓存的一个主要缺点是会导致内存泄漏。缓存应该总是有一个刷新/驱逐标准的设置，这样我们就永远不会保留那些对象的引用，这些引用可能会超出应用程序处理时间的上下文。</li></ul><p id="50da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> CPU利用率审查</strong></p><p id="a2fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在任何应用程序中，编译后的每一行代码都会占用CPU。因此，应该最佳地利用CPU资源。应用程序使用CPU处理来创建资源，如线程/执行器、GC、计算等。</p><p id="620d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是构建应用程序或分析CPU性能时需要考虑的一些事情:</p><ul class=""><li id="ce8f" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">异步处理</strong> <br/>当我们创建或使用算法来解决任何用例时，我们应该知道何时在应用中应用异步处理和异步并行处理逻辑。<br/>理想情况下，异步处理应该保持在事务上下文之外，因为它在用于事务处理时会产生数据不一致。任何IO密集型操作，如调用依赖服务或从SQL获取数据，都可以在事务上下文之外通过异步处理来完成。<br/>我们应该总是在应用程序启动时创建资源，如执行器，并使用相同的资源进行异步处理。创建执行器是一项CPU密集型的工作，为每个请求创建执行器是不可取的，因为这会严重降低CPU性能。<br/>在Spring boot应用程序中创建执行器的一种方法如下:</li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4cf7" class="jc jd hh lm b fi lq lr l ls lt">@Bean(ServiceConstants.<strong class="lm hi"><em class="mj">TEST_EXECUTOR</em></strong>)<br/><strong class="lm hi">public </strong>ExecutorService getTestExecutorService() {<br/>  <strong class="lm hi">return </strong>MDCRetainingExecutor.<em class="mj">wrap</em>(<br/>      Executors.<em class="mj">newFixedThreadPool</em>(<br/>         ConfigService.<em class="mj">getIntegerValue</em>(ConfigConstants.<strong class="lm hi"><em class="mj">TEST_EXECUTOR_POOL_SIZE</em></strong>)));<br/>}</span></pre><p id="0c6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用一种可以保留MDC的executor服务，这样我们可以将跟踪id和MDC上下文从主线程传递给Executor线程。<br/>在异步中使用线程之后，MDC应该总是被清除，以便对象变得适合GC。</p><ul class=""><li id="2bf0" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">批处理/批量处理<br/> </strong>批处理用于多种环境，如批量请求处理、数据库(SQL和NoSQL)的数据插入等。给我们带来丰硕成果的一个实验是，当我们在请求中获得数据集合时，在请求处理期间使用批量处理。我们使用集合批量处理所有数据，并将它们批量/批量保存到数据库中。<br/>如果您在DAO层使用JDBC预处理语句执行查询，最好使用批量处理来保存数据，因为按顺序处理可以节省大量处理时间。Spring JPA还为SQL DB的批量持久化数据提供了接口。<br/> <strong class="ig hi">微软Azure Cosmos </strong>提供了批量执行器库，该库提供了一种跨多个分区将文档导入到Cosmos DB的高效方法，具有多主机设置。</li><li id="9799" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">每个API步骤的处理时间分析<br/> </strong>虽然我们为每个用例都准备了一个算法，但我们总是希望分析每个处理步骤中每个请求所花费的时间。这提供了对每个相关服务调用、数据源调用和内存计算时间所用时间的洞察。这些数据将有助于分析代码的细微细节，并使代码达到所需的SLA。此活动还有助于设计处理请求的新策略，如以异步方式进行独立的服务调用，比要求的顺序高得多，这有助于提高CPU利用率和加快处理时间。</li></ul><p id="3d7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">其他绩效指标</strong></p><ul class=""><li id="aea8" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><strong class="ig hi">诊断工具</strong> <br/>微软Azure提供诊断工具来衡量一个WebApp的内存和CPU性能。这提供了关于应用程序在较长时间内的运行情况的数据，这在浸泡测试运行期间很有帮助。</li><li id="cbc9" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">成本优化措施<br/> </strong>成本是构建应用程序的一个固有方面。所使用的每个部件都增加了成本。所有绩效改进措施都直接有助于更好地利用成本。<br/>应对平台组件进行成本核算，以了解资源供应情况，从而与生产环境中的预期TPS和SLA相匹配。</li><li id="193d" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">监控工具<br/> </strong>每个云服务为每个PaaS组件提供多个监控工具，可以帮助了解性能指标，如给定时间范围内的p95、p90、p99请求、垃圾收集指标、堆指标等。我们还可以集成Prometheus、Grafana等工具和OpenZipkin等分布式跟踪工具。</li><li id="2964" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">负载测试&amp;浸泡测试<br/> </strong>需要对应用程序进行负载/压力测试，以分析高压力下的性能。如上所述，这有助于确定差距和需要改进的地方，从而优化应用程序。<br/>浸泡测试允许我们对应用程序进行更长时间的性能/压力测试。这是另一种方式来发掘任何未知的，可能导致长期性能下降。<br/>负载和浸泡测试都是应用程序生产就绪前的强制性要求。<br/>可以使用Jmeter等工具来执行测试，这些工具允许我们为应用程序编写测试脚本，以满足预期的TPS。</li><li id="4e86" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">分布式性能测试<br/> </strong>衡量性能的一个重要指标是客户端和服务器之间的网络延迟。在万维网时代，对我们来说，重要的是部署我们的服务时，地理边界不应该决定最终用户的体验。因此，建议始终运行分布式性能测试，以便我们了解客户端分布，并在需要时优化请求的网络跳数，拥有分布式部署策略，从而将网络延迟降至最低，并且不会影响全球客户体验。</li><li id="643a" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">SLA/响应时间要求<br/> </strong>在微服务领域，每项服务的响应时间决定了端到端系统的行为，并最终决定了客户体验。因此，为每个服务接口定义SLA响应时间需求是至关重要的。<br/>在我们的系统中，我们通过p95来衡量SLA，在压力测试和浸泡测试期间，每个接口的响应时间应低于<strong class="ig hi"><em class="mj">500毫秒</em> </strong>。这确保了用户界面的编排服务期望在500毫秒内得到所有响应，以便它们能够在不到一秒的时间内提供所需的数据。</li><li id="e0f2" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">吞吐量计算<br/> </strong>吞吐量或TPS(TransactionsPerSecond)/RPS(requests second)是给定应用服务器在1秒钟内可以处理的请求数量的度量。吞吐量可以通过两种方式计算或实现。<br/>首先，如果我们已经知道一个系统在给定的时间框架内需要处理的事务总数，我们可以回溯以获得每个接口的TPS。<br/>其次，如果我们不知道一个系统在给定的时间框架内需要处理的事务总数，我们可以根据应用程序的实际需求来假设数据，然后回溯以获得每个接口的TPS。<br/>在这两种情况下，都需要做出峰值流量假设，并根据该假设改变请求数量，然后得出最坏情况下的TPS要求。性能测试应该总是在考虑请求的最坏情况的情况下进行，然后将其分摊以匹配平均TPS要求。</li><li id="3165" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><strong class="ig hi">资源供应</strong><br/>PaaS组件的资源供应与性能测试密切相关。随着TPS需求的逐渐增加，资源供应也会增加。任何应用程序在经过一定的优化后都会达到一个极限，然后应该进行水平扩展以满足SLA和TPS要求。CPU和内存是水平扩展的主要决定因素。理想情况下，一个实例不应超过70%的内存和60%的CPU利用率。这个数字是有争议的，但这可以确保在自动扩展资源之前，可以处理由于请求高峰而导致的任何CPU和内存使用高峰，并且在资源可用之前，可以处理额外的负载，而不会影响客户体验。</li></ul><h1 id="409a" class="kq jd hh bd je kr ks kt ji ku kv kw jm kx ky kz jp la lb lc js ld le lf jv lg bi translated">结论</h1><p id="9e9a" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">总之，可以采取很多步骤来优化应用程序的性能。上述性能评估仅提供了优化代码和资源消耗以及降低性能影响风险的方法。作为一名应用程序开发人员，我们应该始终牢记可接受和不可接受的权衡，并采取相应的行动。</p></div></div>    
</body>
</html>