<html>
<head>
<title>Mobile HTTP SSL PINNING: Decoding the untold</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动HTTP SSL锁定:解码未知</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/http-ssl-pinning-decoding-the-untold-1fa751c63c3e?source=collection_archive---------1-----------------------#2020-10-10">https://medium.com/walmartglobaltech/http-ssl-pinning-decoding-the-untold-1fa751c63c3e?source=collection_archive---------1-----------------------#2020-10-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e57d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HTTPS是一种与服务器通信的安全方式。这个标准已经被接受了很长一段时间，十年来一切都很好。随着黑客技术的进步，传统的建立安全SSL连接的方式已经不能满足当今的安全需求。这种需求催生了SSL pinning。SSL pinning越来越受欢迎，在移动应用程序中被广泛采用，最近甚至浏览器都支持web应用程序的pinning。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/4fbe94dbff577bef666d9edf97cd5e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnRSEAqkcmYubGDZ2eII0w.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image Source<a class="ae js" href="https://pixabay.com/photos/post-it-note-office-list-memo-1277427/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/photos/post-it-note-office-list-memo-1277427/</a></figcaption></figure><p id="ba37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要解码SSL固定的目的，我们需要首先弄清楚两个概念。</p><ul class=""><li id="f902" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">握手期间的SSL证书验证。</li><li id="d2f2" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">MITM攻击</li></ul><p id="bdee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">握手期间的SSL证书验证。</strong></p><p id="7038" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从握手开始，最重要的一步是第二步。在这里，应用程序在信任存储中已经存在的根CA的帮助下验证服务器提供的证书是否有效。这种验证是通过在信任存储中已经存在的根CA公钥的帮助下确认证书是否被数字签名来完成的。现在，让我们试着了解一下，如果有人试图拦截流量，在进行这种验证的情况下会发生什么。这导致了MITM的攻击。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kh"><img src="../Images/4f8f32716d549c11375ae5eee275a0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXJ-LpS2fG01jBqaSph2SQ.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">SSL certificate verification during the handshake</figcaption></figure><p id="23be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> MITM遇袭</strong></p><p id="ebce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们理解这种攻击的流程，稍后我们将看到SSL认证验证如何防止MITM攻击。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ki"><img src="../Images/34fd5863f8dba4f9a5a35cb8f9c46392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX9P78yPgNnJdmf5aqeX-A.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">MITM flow</figcaption></figure><p id="ed7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设:一个真正的用户正试图访问xyz.com，这是一个有效的网站，具有由CA之一颁发的有效SSL证书。</p><p id="2165" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一步:</strong>与真实用户在同一个局域网上的黑客截获SSL握手。</p><p id="ab3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二步:黑客现在将通过启动他的SSL连接作为xyz.com的真正用户。</p><p id="0b38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第三步</strong>:黑客在握手过程中收到来自xyz.com的证书。</p><p id="1e02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤4 </strong>:黑客不是将xyz.com证书转发给正版用户，而是将自己的证书提供给正版用户。</p><p id="5245" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第五步</strong>:证书验证发生在客户端。</p><p id="d42e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第六步:</strong>黑客开始解密所有网络流量，并开始查看。</p><p id="46b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在步骤4中，出现了一个问题，黑客为什么要发布他的证书？</p><p id="a9fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">原因是他只拥有他发给真正用户的相应证书的私钥。因此，黑客将能够解密SSL流量。如果黑客传递了由xyz.com颁发的相同证书，那么黑客就不能解密流量，因为黑客没有对应于xyz.com证书的私钥。这仅适用于xyz.com。</p><p id="7ea0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们知道了MITM是如何发生的。让我们看看，这种攻击在现实世界中有效吗？我上面描述的流程将会实时失败。因为证书的数字签名是在客户端验证的。从而防止用户接受无效证书并成为MITM的受害者。通常，每当应用程序遇到无效证书时，应用程序就会停止握手或请求用户同意继续。</p><p id="9427" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好哇！！！所以我们是安全的，SSL握手会检查我的连接是否安全，并保护我免受MITM攻击。</p><p id="9e8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等等，我们有没有考虑过这样一种情况，其中一个根CA遭到破坏，或者黑客已经能够将他自己的CA推入您的客户端信任存储中？:(</p><p id="449b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述问题引导我们找到了两种实现MITM的方法:</p><p id="0ba8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">案例1:黑客攻破了一个真正的根CA(这意味着黑客拥有用于签署证书的CA的私钥)</strong></p><p id="f042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于黑客拥有有效的根CA私钥，他可以开始为他选择的任何域生成有效的证书。因此在MITM的第4步中，颁发给客户端的证书将是有效的。因此，导致一个成功的MITM。</p><p id="acfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于已经存在的根CA被黑客破坏，他可以对任何用户执行MITM。</p><p id="aa91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">案例2:黑客将自己的CA推送到客户端信任库</strong></p><p id="0ab5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于黑客自己的CA证书被推送到客户端的信任库，他可以开始为他选择的任何域生成他的有效证书。因此在MITM的第4步中，颁发给客户端的证书将是有效的。因此，导致一个成功的MITM。</p><p id="52d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，因为黑客的根CA被推入客户端信任存储，所以MITM仅限于黑客的根CA被推入的客户端。</p><p id="7a9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上两种情况可以总结在下图中:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kj"><img src="../Images/b873e51eeab153bdc0ab28707fa1082a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoAWR7TnNGIReLabdGEQ6g.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">MITM flow with compromised CA</figcaption></figure><p id="1bad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">案例1和案例2有共同的解决方案吗？</p><p id="dc96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是SSL固定概念的由来。SSL固定在防止MITM的SSL验证中又增加了一步。</p><p id="4a93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么是SSL pin？</strong></p><p id="bc65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SSL固定意味着在客户端固定(或硬编码)与证书相关的信息，以验证证书是否有效。不要将这与证书的数字签名验证混淆，两者是两个不同的概念。随着我的解释，进一步的概念将变得更加清晰。</p><p id="6e6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以固定的证书相关信息列表包括:</p><ul class=""><li id="59bf" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">服务器证书本身</li><li id="1d9d" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">证书散列</li><li id="e6cf" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">证书中存在的公钥</li><li id="0720" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">公钥的哈希</li></ul><p id="b737" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SSL pin验证的流程如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kk"><img src="../Images/9d2803a55013839a9c342ace3c2a0d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eiX3KD4QhWnBuQtJPvoSA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">SSL pinning verification flow</figcaption></figure><p id="b437" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看出，通过交叉检查数字签名来验证证书是否有效。还需要一个验证步骤。在此步骤中，应用程序验证服务器证书的已锁定信息是否与SSL握手期间发布的证书信息相匹配。这就是SSL固定的全部含义。</p><p id="1c28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在出现的问题是，SSL pin如何防止前面描述的MITM的情况1和情况2？</p><p id="071b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在MITM的步骤5中，如果我们注意到黑客必须发布他的证书，该证书可能是由有效的CA签署的有效证书。在这种情况下，签名验证将通过，但是，固定的信息将是服务器证书的信息，它将与黑客颁发的证书不匹配。因此，在两种情况下都防止了MITM。</p><p id="20ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总结一下，我们已经了解了使用SSL固定的原因，什么是SSL固定？又是如何实现的？。尽管如此，我还没有提供关于如何实现pinning的信息，这是最好的pinning方式，pinning的任何缺点，以及我们如何克服笔测试的SSL pinning。敬请关注即将到来的博客，在那里我将解释所有这些有趣的概念。</p><p id="9faf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">参考文献:</strong></p><p id="0f42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://developer.android.com/training/articles/security-ssl" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/training/articles/security-SSL</a></p></div></div>    
</body>
</html>