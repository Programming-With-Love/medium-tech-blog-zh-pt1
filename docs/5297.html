<html>
<head>
<title>Part I: Develop stream processing apps using Apache Kafka Streams on Oracle Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:在Oracle Cloud上使用Apache Kafka流开发流处理应用程序</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/part-i-develop-stream-processing-apps-using-kafka-streams-on-oracle-cloud-6c840bc95a16?source=collection_archive---------0-----------------------#2017-09-05">https://medium.com/oracledevs/part-i-develop-stream-processing-apps-using-kafka-streams-on-oracle-cloud-6c840bc95a16?source=collection_archive---------0-----------------------#2017-09-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d230" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本博客展示了如何使用Kafka Streams库和Oracle云服务来开发和部署有状态流处理微服务— <a class="ae jc" href="https://cloud.oracle.com/en_US/event-hub" rel="noopener ugc nofollow" target="_blank"> Oracle Event Hub cloud </a>、<a class="ae jc" href="https://cloud.oracle.com/en_US/application-container-cloud" rel="noopener ugc nofollow" target="_blank">Oracle Application Container Cloud</a>、&amp;、<a class="ae jc" href="https://cloud.oracle.com/en_US/developer-service" rel="noopener ugc nofollow" target="_blank"> Oracle Developer Cloud </a></p><blockquote class="jd je jf"><p id="4f45" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">它分为两部分——第一部分(这部分)涵盖了核心概念和开发方面，接下来是第二部分处理设置、部署&amp; CI/CD部分</p></blockquote><h2 id="dce0" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">Oracle活动中心云</h2><p id="03f8" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">简而言之，Oracle Event Hub Cloud由Kafka(即服务)管理，其支持的Kafka版本<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/event-hub-cloud/whats-new/index.html#EHCWN-GUID-B527C303-EDD7-4320-B4A4-3DC187F6E7A9" rel="noopener ugc nofollow" target="_blank">已升级至0.10.2 </a>(从0.9.0)。卡夫卡迷可能知道这意味着什么——卡夫卡流<strong class="ig hi">支持！博客中的示例应用程序将利用这一点</strong></p><h2 id="4ec7" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">Oracle应用容器云</h2><p id="a7f5" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">它是一个应用平台即服务(<em class="jg"> aPaaS </em>)，支持多语言运行时(Java SE、Node.js、PHP、Ruby、Python等)。)</p><p id="2be2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本博客所展示的用例环境中，它扮演了两个主要角色</p><ul class=""><li id="cb4c" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">作为我们的<em class="jg">有状态</em>流处理(微)服务的可水平扩展的平台</li><li id="4e38" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">它的<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/cache/index.html" rel="noopener ugc nofollow" target="_blank">缓存功能</a>使它成为我们的流处理应用程序的(中间)状态的分布式存储的最佳选择——细节如下</li></ul><h2 id="1477" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">Oracle开发人员云</h2><p id="adde" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">充当CI/CD和敏捷开发平台</p></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="8c3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从示例应用程序概述、核心概念开始，然后看一些代码</p><h1 id="3f57" class="lf jl hh bd jm lg lh li jq lj lk ll ju lm ln lo jx lp lq lr ka ls lt lu kd lv bi translated">应用:高级概述</h1><p id="8bc9" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">该应用程序及其目标很简单——给定一个连续的tweets流，跟踪一组选定的关键字(如java、paas、kafka等)的出现次数。).这类似于标准的<em class="jg">字数统计</em>问题，希望足够简单来演示所需的概念</p><p id="d250" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有三个主要的组成部分——下面是它们是什么以及它们如何相互作用的简要概述</p><h2 id="c9e4" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">卡夫卡连接</h2><p id="b416" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">Kafka connect twitter (source)连接器接收tweet流，并将它们推送到Kafka主题。点击查看<a class="ae jc" href="https://github.com/Eneco/kafka-connect-twitter" rel="noopener ugc nofollow" target="_blank">这个很酷的项目</a></p><blockquote class="jd je jf"><p id="e5d2" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">报道Kafka Connect超出了本博客的范围——在<a class="ae jc" href="https://kafka.apache.org/documentation/#connect" rel="noopener ugc nofollow" target="_blank"> Kafka文档</a>中阅读更多相关内容</p></blockquote><h2 id="4265" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">托管Kafka broker (Oracle事件中心云)</h2><p id="0738" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">Oracle Event Hub Cloud托管Kafka集群和主题(详见<strong class="ig hi">设置&amp;部署</strong>部分),并充当流数据平台</p><h2 id="14a5" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">推特分析应用</h2><p id="3bef" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">Oracle Application Container Cloud托管(基于Kafka流的)<em class="jg"> tweet analysis </em>应用以及<em class="jg">状态存储</em>(缓存)——更多信息请参见<strong class="ig hi">设置&amp;部署</strong>部分</p><p id="7eac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是这个系统在高层次上的样子</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es lw"><img src="../Images/769b1c5c8f34dfa07d55b2b000e3bc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Vj8jITSwS1vGL0LWYCSlg.jpeg"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">High level overview</figcaption></figure></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><h1 id="859a" class="lf jl hh bd jm lg mm li jq lj mn ll ju lm mo lo jx lp mp lr ka ls mq lu kd lv bi translated">概念</h1><p id="f617" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">本节涵盖了与本博客上下文相关的一些基本概念，包括<strong class="ig hi"> Kafka Streams </strong>以及<strong class="ig hi"> Oracle应用程序容器云</strong></p><blockquote class="jd je jf"><p id="0d98" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">关于详细信息，我建议深入阅读Kafka Streams和Oracle应用容器云的文档</p></blockquote><h2 id="673a" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">卡夫卡流概述</h2><p id="655c" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">简而言之，<a class="ae jc" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a>是一个库，您可以将它包含在基于Java的应用程序中，以便在Apache Kafka的基础上构建流处理应用程序。其他分布式计算平台如<a class="ae jc" href="http://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>、<a class="ae jc" href="http://storm.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Storm </a>等。在大数据流处理世界中被广泛使用，但是Kafka Streams在这方面带来了一些独特的主张</p><ul class=""><li id="592f" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">建立在Kafka之上:利用其可伸缩和容错能力。如果您在您的生态系统中使用Kafka，那么利用Kafka Streams在Kafka主题之间产生流数据是非常合理的</li><li id="3460" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">灵活部署&amp;弹性本质</strong>:您不受特定部署模型的限制(例如基于集群)。该应用程序可以灵活地打包和部署，并且可以轻松地扩展和缩减</li><li id="a594" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">对于快速数据(也是如此)</strong>:利用Kafka流的力量在实时系统中处理大量数据——不需要达到大数据规模</li><li id="c9b7" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">其他</strong>:支持有状态、容错、一次一条记录和窗口操作</li></ul><h2 id="6c0e" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">Kafka流API</h2><p id="5ec6" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">Kafka Streams有两种类型的API用于编写流处理应用程序</p><ul class=""><li id="552b" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">DSL API :它是一个高级的、流畅的API，使得表达流处理拓扑变得容易</li><li id="1a1c" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><code class="du mr ms mt mu b"><strong class="ig hi">Processor</strong></code> <strong class="ig hi"> API: </strong>这是一个低级API，可以在你需要更多控制、灵活性和定制的时候使用</li></ul><h2 id="3028" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">卡夫卡溪流国营商店</h2><p id="5cc6" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">Kafka Streams提供了一个<em class="jg">状态存储</em>特性，应用程序可以使用该特性存储其本地处理结果(状态)。<a class="ae jc" href="http://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>用作默认状态存储，可用于<em class="jg">持久或内存</em>模式。就这些而言，有几个选择——你可以</p><ul class=""><li id="05ac" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">使用现成的状态实现，例如RocksDB、内存中或，</li><li id="b36b" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">编写一个<a class="ae jc" href="https://kafka.apache.org/0110/documentation/streams/developer-guide#streams_developer-guide_interactive-queries_custom-stores" rel="noopener ugc nofollow" target="_blank">自定义状态存储实现</a>，即实现/扩展Kafka Streams接口/类，或者，</li><li id="3903" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">使用底层的<code class="du mr ms mt mu b">Processor</code> API来插入您自己的状态存储——这是我们示例的实现选择(在下一小节中会有更多的介绍)</li></ul><blockquote class="jd je jf"><p id="9c9e" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">请注意，到目前为止(Kafka Streams 0.11.0.0 ),自定义实现(上面的选项#2和#3)只能与低级处理器API一起使用</p></blockquote><h2 id="81a9" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">Oracle应用程序容器云<em class="mv">缓存</em>作为状态存储</h2><p id="702c" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">在我们的示例应用程序中，我们关心的状态是我们选择跟随的关键字出现的<em class="jg">计数——它是如何实现的？</em></p><p id="eddc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle应用容器云<em class="jg"> </em>提供对<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/cache/caches-oracle-application-container-cloud-service.html" rel="noopener ugc nofollow" target="_blank">可扩展内存缓存</a>的访问，并在我们的用例中使用<em class="jg">自定义状态存储</em></p><ul class=""><li id="3137" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">单词及其计数存储为键值对</li><li id="1b52" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">高速缓存专用逻辑被插入基于低级处理器API的实现中</li><li id="8a94" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">使用Oracle应用程序容器云<a class="ae jc" href="https://github.com/oracle/accs-caching-java-sdk" rel="noopener ugc nofollow" target="_blank"> Java缓存SDK </a></li></ul><p id="3521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更多细节将在接下来的<strong class="ig hi">代码</strong>部分介绍</p><blockquote class="jd je jf"><p id="5d4e" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">你可以在<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/cache/index.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读更多关于<strong class="ig hi">缓存</strong>特性的信息</p></blockquote><p id="1378" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是一些好处</p><ul class=""><li id="1700" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">最重要的一点是，对本地状态(在缓存中)的访问既快速又容易实现(与Kafka Streams提供的原生API <code class="du mr ms mt mu b">StreamsMetadata</code>)有关详细信息，请参考<a class="ae jc" href="https://kafka.apache.org/0110/documentation/streams/developer-guide#streams_developer-guide_interactive-queries_discovery" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="5716" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">Oracle Application Container cloud cache本质上是分布式的(所有应用实例都可以访问同一个缓存)，具有高可用性、可伸缩性，并通过<em class="jg"> Java SDK </em>以及<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/rest.html" rel="noopener ugc nofollow" target="_blank"> <em class="jg"> REST API </em> </a>提供访问</li><li id="2851" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">如果需要，其他应用程序/微服务(部署在Oracle应用程序容器云中)也可以访问缓存内容(即本例中的流处理状态)</li></ul><h2 id="fbe0" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">可量测性</h2><p id="13e0" class="pw-post-body-paragraph ie if hh ig b ih kf ij ik il kg in io ip kh ir is it ki iv iw ix kj iz ja jb ha bi translated">我们的流处理服务可以双向扩展(详情见<a class="ae jc" href="http://docs.oracle.com/en/cloud/paas/app-container-cloud/csjse/exploring-application-overview-page.html" rel="noopener ugc nofollow" target="_blank">文档</a>),即弹性扩展</p><ul class=""><li id="b482" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">向上和向下—增加/减少内存(RAM)</li><li id="0c8f" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">进出—减少/增加应用程序的实例数量</li></ul><blockquote class="jd je jf"><p id="34d7" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">在<strong class="ig hi">横向扩展</strong>的情况下，Kafka Streams在所有应用程序实例之间分配(流)处理负载——这由主题中的分区数量决定，例如，如果您有10个分区和5个应用程序实例，那么每个实例将处理来自两个分区的数据</p></blockquote><p id="9bdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是Oracle应用容器云上的流处理服务的一个更细粒度的视图</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es lw"><img src="../Images/84dfdcd446caedfa30137fcd3e1b937b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf1zaN1M_DupvFgQBIQFEg.jpeg"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Implementation details</figcaption></figure></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><h1 id="4750" class="lf jl hh bd jm lg mm li jq lj mn ll ju lm mo lo jx lp mp lr ka ls mq lu kd lv bi translated">密码</h1><h2 id="a10b" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">成分</h2><ul class=""><li id="86d3" class="kk kl hh ig b ih kf il kg ip mw it mx ix my jb kp kq kr ks bi translated"><strong class="ig hi">卡夫卡溪流</strong>图书馆</li><li id="af97" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">泽</strong>(基于JDK)HTTP容器</li><li id="68c5" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">面向Oracle应用容器云缓存的Java客户端SDK </strong></li></ul><p id="e734" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来看一些代码片段——这个项目可以在这里找到<a class="ae jc" href="https://github.com/abhirockzz/accs-kafka-streams" rel="noopener ugc nofollow" target="_blank"/></p><p id="7c99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KafkaStreamsAppBootstrap.java启动球衣HTTP容器和Kafka Streams应用程序</p><figure class="lx ly lz ma fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="7a7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">KafkaStreamsTweetAnalysisJob.java</strong>设置Kafka Streams应用程序和处理器拓扑</p><figure class="lx ly lz ma fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="a9a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">TweetStreamProcessor.java</strong>扩展<code class="du mr ms mt mu b">org.apache.kafka.streams.processor.Processor</code>T22】封装主处理逻辑</p><figure class="lx ly lz ma fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="e53d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">TweetAnalysisStateStore.java</strong>在甲骨文ACCS Java缓存客户端SDK上充当包装器，并公开<code class="du mr ms mt mu b">put </code>和<code class="du mr ms mt mu b">get </code>操作</p><figure class="lx ly lz ma fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="73fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">TweetStateResource.java</strong>是暴露状态的REST端点，即我们正在跟踪的关键词的当前计数。它查询Oracle ACCS缓存以获得结果</p><figure class="lx ly lz ma fd mb"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="83fa" class="jk jl hh bd jm jn jo jp jq jr js jt ju ip jv jw jx it jy jz ka ix kb kc kd ke bi translated">其他人</h2><ul class=""><li id="b10f" class="kk kl hh ig b ih kf il kg ip mw it mx ix my jb kp kq kr ks bi translated"><strong class="ig hi">TweetCountSerializer.java</strong>—用于缓存内容的定制串行化(&amp;解串行化)逻辑(扩展<code class="du mr ms mt mu b">com.oracle.cloud.cache.basic.io.Serializer</code>)(转换b/w <code class="du mr ms mt mu b">Long </code>和<code class="du mr ms mt mu b">byte[]</code>)</li><li id="c4e4" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><strong class="ig hi">Stat.java</strong>—表示状态(计数)的JAXB注释类</li></ul></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="725a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一部分到此为止——接下来继续第二部分</p><ul class=""><li id="8662" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">Oracle云组件的配置和部署</li><li id="cfdf" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">如何运行/测试应用程序</li></ul><h1 id="b2d2" class="lf jl hh bd jm lg lh li jq lj lk ll ju lm ln lo jx lp lq lr ka ls lt lu kd lv bi translated">不要忘记…</h1><ul class=""><li id="61c5" class="kk kl hh ig b ih kf il kg ip mw it mx ix my jb kp kq kr ks bi translated">查看Oracle应用容器云的教程<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/create-first-applications.html" rel="noopener ugc nofollow" target="_blank">——每个运行时都有一些内容！</a></li><li id="e9c3" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated"><a class="ae jc" href="http://bit.ly/2gR3nrV" rel="noopener ugc nofollow" target="_blank">应用容器云上的其他博客</a></li></ul><blockquote class="jd je jf"><p id="eb0a" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated"><em class="hh">本文表达的观点是我个人的观点，不一定代表甲骨文的观点。</em></p></blockquote></div></div>    
</body>
</html>