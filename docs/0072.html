<html>
<head>
<title>Migrating from Mocha to Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从摩卡迁移到Jest</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/unlocking-test-performance-migrating-from-mocha-to-jest-2796c508ec50?source=collection_archive---------0-----------------------#2017-06-15">https://medium.com/airbnb-engineering/unlocking-test-performance-migrating-from-mocha-to-jest-2796c508ec50?source=collection_archive---------0-----------------------#2017-06-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b291" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">用Mocha运行我们的测试套件花了12多分钟。与我们强大的构建机器相比，我们现在能够在<strong class="ak"> 4分30秒内运行整个Jest套件。</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/0e9013be2927fc8f58d04c81f29a441e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5fW6m__TAaZRynRdzlC9Q.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Come check out our new digs at 999 Brannan, our second office in San Francisco!</figcaption></figure><p id="2f2e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">自2013年9月以来，我们一直在Airbnb使用<a class="ae ki" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>，但由于成长的烦恼越来越多，我们最近从摩卡迁移到了<a class="ae ki" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>。事实证明，迁移只需要对我们的测试和基础设施进行最小的改动，并且提供了无数的好处。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es kj"><img src="../Images/b9c09b702b553f25028f991a4a95c5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1TsEIg9JAhIJszzdJUjUUg.gif"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Comparison of Mocha vs Jest, testing that 1 + 2 === 3</figcaption></figure><h2 id="b73a" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">对测试的最小改动</h2><p id="313a" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">我们付出了巨大的努力来确保我们的测试遵循最佳实践和相当严格的编码风格。这有助于我们减少碎片，并支持跨团队协作，因为测试在我们代码的不同部分看起来是一样的。我们的测试文件在迁移之前/之后看起来或多或少是一样的，这对我们来说非常重要。</p><p id="66cf" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">大多数团队不需要改变他们测试文件的内容。事实上，在Airbnb，下面的片段足以掩盖我们使用Mocha和Jest之间的差异。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b710" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是可能的，因为<a class="ae ki" href="https://facebook.github.io/jest/docs/api.html" rel="noopener ugc nofollow" target="_blank"> Jest API </a>和<a class="ae ki" href="https://mochajs.org/#hooks" rel="noopener ugc nofollow" target="_blank"> Mocha API </a>是相似的，只是函数名略有不同。您需要控制哪些函数(或者在您的测试中进行更改),这在很大程度上取决于您正在使用哪些函数。我们也有一些<code class="du lm ln lo lp b">test</code>呼叫，它们可以用<code class="du lm ln lo lp b">it</code>1:1替换，这是我们已经确定的标准。下面是一个简单的例子，展示了我们在移植到Jest之前和之后的测试情况。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="c383" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">简化的测试架构</h2><p id="ab1c" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">我们最初在2016年1月使用伊斯坦布尔和Mocha推出了代码覆盖，但我们发现检测我们的源文件非常昂贵，并且给我们的测试增加了不合理的时间。</p><p id="97f2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了解决这个问题，我们编写了一些定制的逻辑来将我们的测试分成块，在单独的进程中运行它们，收集每个进程的覆盖率，然后在最后将覆盖率合并到一个报告中。</p><p id="e0b4" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">覆盖率是在与我们的测试套件不同的CI作业中收集(和执行)的。测试套件本身后来通过将测试套件的块分派到不同的工作机并在最后聚集结果而被并行化。</p><p id="f75d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Jest自动处理跨流程的分割测试，收集和聚合覆盖率。这对我们来说是一项重大的额外津贴。通过利用这一事实，我们能够在两个作业中删除我们的自定义逻辑，并完全依靠Jest来为我们智能地处理这一点。</p><h2 id="611f" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">改进的性能</h2><p id="3cf8" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">对于有许多测试文件的项目，Jest将使您开箱即可获得改进的性能。它能够通过几种机制做到这一点。</p><ol class=""><li id="d155" class="lq lr hh jo b jp jq js jt jv ls jz lt kd lu kh lv lw lx ly bi translated">并行化。这可能是Jest最受关注的地方，而且理由很充分。如果您还没有对CPU受限的工作进行并行化，那么这样做有望获得巨大的性能提升。</li><li id="7062" class="lq lr hh jo b jp lz js ma jv mb jz mc kd md kh lv lw lx ly bi translated">如上所述，我们已经在Airbnb并行化我们的测试，但我们是通过获得所有测试文件的列表并将它们平均分配给我们的工作人员来实现的。这给工作人员留下了获得异常快或异常慢的测试队列的机会，并导致了CPU周期的浪费。Jest采用循环法，首先运行最慢的测试，帮助你最大限度地利用你的处理能力。</li><li id="51e8" class="lq lr hh jo b jp lz js ma jv mb jz mc kd md kh lv lw lx ly bi translated">它有一个内置的巴别塔变换缓存。对代码应用转换是非常消耗CPU资源的。通过利用跨进程共享的缓存，您可以将CPU专用于运行代码，并减少大量运行时间。</li></ol><p id="765f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用Mocha，我们的套件在本地运行需要大约45分钟，有时由于在单线程中运行整个套件的内存压力，它根本不会完成。当地时间缩短至14.5分钟。我们在我们的构建服务器上看到了类似的改进，Mocha的计时时间为12分钟以上(在我们的跨机器并行化工作之后), Jest在4.5分钟内完成。</p><h2 id="b4a4" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">减少片状剥落</h2><p id="56f8" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">当你有一个像我们这样大的测试套件(几千个测试文件)时，在单线程中运行你的测试将不可避免地导致剥落。当我们开始迁移工作时，由于flake，大约12%的构建需要重新运行，我们套件中的测试需要首先运行其他测试，否则它们不会通过。</p><p id="2d48" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">隔离运行意味着测试不可能因为套件中其他测试文件的副作用而失败。这对于在测试完成后发生的<code class="du lm ln lo lp b">setTimeout</code>调用中抛出的错误尤其有用。现在，通过检查测试和源文件中的任何异步代码，我们可以更容易地调查不可靠的测试。</p><p id="a20f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在迁移到Jest并修复了单独失败的测试后，我们能够将我们的剥落率降低到1%左右。这为我们的开发人员节省了每个工作日的时间，因为他们不再需要等待构建失败，并重复运行测试套件直到它通过。此外，在罕见的情况下，鳞片确实发生，我们能够更准确地确定它来自哪里。更容易识别，因为文件在它自己的进程中运行，所以可以保证片状剥落来自该文件。对于Mocha，文件x中的错误计时器可能会导致文件y中的测试失败。</p><p id="cd4b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你致力于减少片状剥落，你可以更进一步，通过终止测试中设置的计时器来减少测试中的片状剥落。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="c682" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">让性能更上一层楼</h2><p id="28a2" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">Jest对我们来说开箱即用要快得多，但最初我们并没有看到我们预期的那种改进。在分析了几次运行之后，我们发现我们的全局<code class="du lm ln lo lp b">spec_helper.js</code>文件是罪魁祸首。这是我们用Mocha设置的一个文件，用来配置一些全局助手，使我们的测试编写起来更加方便。例如，我们使用<a class="ae ki" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank">酶</a>来测试我们的React代码，为了使编写测试更容易，我们加入了<a class="ae ki" href="https://github.com/producthunt/chai-enzyme" rel="noopener ugc nofollow" target="_blank"> chai-enzyme </a>。我们没有让所有开发人员在每个测试文件中手动连接这个库，而是在所有测试之前运行的<code class="du lm ln lo lp b">spec_helper.js</code>中连接它。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="851f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这被证明是一个非常有问题的笑话。因为每个测试文件都在一个干净的虚拟机中运行，Jest为每个测试文件重新运行一次<code class="du lm ln lo lp b">spec_helper.js</code>文件。在上面的例子中，导入chai-enzyme启动了一个链，它导入所有的酶，然后导入所有的React和ReactDOM。即使不包括React的测试也需要480毫秒。在我们的例子中，480毫秒*几千个文件意味着我们花了一分多钟来设置这个库。使用Mocha，我们不会感到这种痛苦，因为它不是并行的，并且只运行一次<code class="du lm ln lo lp b">spec_helper.js</code>文件。</p><p id="5d5a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了解决这个问题，我们对Jest的嘲讽功能进行了一点创新。通过利用<code class="du lm ln lo lp b">jest.mock()</code>上的回调，我们能够拦截酶的输入，并且只为需要它的测试加载chai-enzyme。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="9702" class="kk kl hh bd km kn ko kp kq kr ks kt ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">开发者情绪</h2><p id="c77d" class="pw-post-body-paragraph jm jn hh jo b jp lf ii jr js lg il ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">我们这次迁移的最终目标是改善开发人员的体验，无论是在编写测试还是运行测试时。我们只是在Jest上呆了几个星期，但到目前为止我们只看到了积极的反馈:</p><blockquote class="me mf mg"><p id="7d79" class="jm jn mh jo b jp jq ii jr js jt il ju mi jw jx jy mj ka kb kc mk ke kf kg kh ha bi translated">只是想在这里给任何从事Jest实现的人一个大大的++奖励。它节省的开发时间是不可思议的。比如，以前需要3个小时才能写完的东西现在只需要30分钟。不开玩笑。</p></blockquote></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><p id="de16" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><em class="mh">我们一直在寻找有才华、有好奇心的人来</em> <a class="ae ki" href="https://www.airbnb.com/careers/departments/engineering" rel="noopener ugc nofollow" target="_blank"> <em class="mh">加入团队</em> </a> <em class="mh">。或者，如果你只是想谈谈工作，可以随时在twitter上联系我</em><a class="ae ki" href="https://twitter.com/garyborton" rel="noopener ugc nofollow" target="_blank"><em class="mh">@ Gary borton</em></a><em class="mh">。</em></p></div></div>    
</body>
</html>