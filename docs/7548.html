<html>
<head>
<title>Automatic ACME SSL Certificate Rotation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动ACME SSL证书轮换</h1>
<blockquote>原文：<a href="https://medium.com/version-1/automatic-acme-ssl-certificate-rotation-3707f2d5954c?source=collection_archive---------0-----------------------#2022-05-11">https://medium.com/version-1/automatic-acme-ssl-certificate-rotation-3707f2d5954c?source=collection_archive---------0-----------------------#2022-05-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2bf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">技术需要安全，但我们也希望它易于使用。这对于管理SSL证书及其轮换的美国工程师来说是一样的。您可以获得长期证书，但是为什么您可以通过自动证书管理环境(ACME协议)获得免费证书呢？这通常是因为它们将在3个月内到期，而您不希望每3个月更新和部署一次，尤其是当您有许多服务需要维护时。因此，我有一个更新证书的模式和设计，它也可以适用于任何服务或云提供商。</p><p id="44d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种设计使用特定的技术，但是由于它的组成，每个组件都可以与您使用的任何技术进行交换。例如，我使用Azure Key Vault来存储证书，这可以很容易地交换为AWS证书管理器。这也是为什么它是一个非常好的设计，因为它可以支持多种类型的服务、语言和提供商。</p><p id="a817" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于本文，我使用了以下技术</p><p id="5ea0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">azure devo PS-部署软件<br/><a class="ae jc" href="https://azure.microsoft.com/en-us/services/devops/" rel="noopener ugc nofollow" target="_blank">https://azure.microsoft.com/en-us/services/devops/</a></p><p id="3f62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">莱斯加密证书提供商<br/>【https://letsencrypt.org/docs/client-options/ T4】</p><p id="a6bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">azure Key Vault-证书存储<br/><a class="ae jc" href="https://docs.microsoft.com/en-us/azure/key-vault/general/basic-concepts" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/Key-Vault/general/basic-concepts</a></p><p id="fd89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Azure虚拟机(Linux)-应用程序主机<br/><a class="ae jc" href="https://azure.microsoft.com/en-us/services/virtual-machines/linux/" rel="noopener ugc nofollow" target="_blank">https://azure . Microsoft . com/en-us/services/Virtual-machines/Linux/</a></p><p id="3521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Azure DNS - DNS提供商<br/><a class="ae jc" href="https://azure.microsoft.com/en-gb/services/dns/#overview" rel="noopener ugc nofollow" target="_blank">https://azure.microsoft.com/en-gb/services/dns/#overview</a></p><p id="4439" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动生成证书<br/><a class="ae jc" href="https://poshac.me/docs/v4/Tutorial/" rel="noopener ugc nofollow" target="_blank">https://poshac.me/docs/v4/Tutorial/</a></p><h1 id="9eb6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/e4bda1fd43239c7c19d56e302a59120f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inFHRiVQmsYH_dbjJl_RLw.png"/></div></div></figure><p id="272f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如你从设计中看到的，是Azure DevOps完成了证书的请求。这是因为每个域都有一个单独的源来执行请求，而不是由每个资源来执行。这可以节省每个域所需的请求数和证书数。您可以申请一个证书，使用该域的所有资源都可以受益。</p><h1 id="c270" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">申请证书</h1><p id="07cb" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">本节将解释Azure DevOps从let获取新证书的工作，加密并将其存储在Azure Key Vault中。</p><h1 id="4786" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">获取证书脚本</h1><p id="6671" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们从设置脚本中使用的变量开始，这些变量将配置脚本的使用方式。</p><p id="c6ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">环境是环境，它在以后用于决定让加密服务器使用什么。使用生产服务器时，您受限于每天每个域可以发出多少请求，因此对于较低的环境，使用分段服务器是有意义的，因为在部署期间您可能会多次请求该服务器。</p><p id="d8ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">acmeContact是一个用于Posh-ACME帐户的电子邮件联系人，但也可以是任何电子邮件，只要其格式为电子邮件即可。</p><p id="8589" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该域是您将为其请求证书的URL的完全限定域名。</p><p id="8963" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，您拥有了Azure Subscription名称，该名称包含Azure DNS资源，稍后将使用该资源获取请求的访问令牌。这是因为您的资源没有托管在同一个Azure Subscription中，但是如果它们托管在同一个Azure Subscription中，那么您总是可以使用az cli来获取当前的Subscription。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="98a1" class="kx je hh kt b fi ky kz l la lb">$env="staging"<br/>$acmeContact="me@email.com"<br/>$domain="www.example.com"<br/>$dnsSubscription="DNS-Subscription-Example"</span><span id="c71c" class="kx je hh kt b fi lc kz l la lb">if ($env -eq "production" -or $env -eq "staging") {</span><span id="c4f7" class="kx je hh kt b fi lc kz l la lb">    $leServer="LE_PROD"</span><span id="ae26" class="kx je hh kt b fi lc kz l la lb">}else {</span><span id="97d9" class="kx je hh kt b fi lc kz l la lb">    $leServer="LE_STAGE"</span><span id="00f2" class="kx je hh kt b fi lc kz l la lb">}</span></pre><p id="49ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们可以安装Posh-ACME PowerShell模块。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="31b1" class="kx je hh kt b fi ky kz l la lb"># Set Posh-ACME working directory<br/>Write-Host "Install Module"<br/>Install-Module -Name Posh-ACME -Scope CurrentUser -Force</span></pre><p id="9643" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设置让加密服务器并为脚本安装Azure插件。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="7455" class="kx je hh kt b fi ky kz l la lb"># Configure Posh-ACME server<br/>Write-Host "Configure LE Server $leServer"<br/>Set-PAServer $leServer<br/>Get-PAPlugin Azure</span></pre><p id="112f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Posh-ACME时，您需要为续保设置一个附属于该域的帐户，该帐户可以使用我们之前设置的acmeContact电子邮件自动生成。如果您已经设置了帐户，下面的脚本也可以进行锻炼，如果是，它将使用现有的帐户。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="7fc9" class="kx je hh kt b fi ky kz l la lb"># Configure Posh-ACME account<br/>Write-Host "Setup Account"<br/>$account = Get-PAAccount</span><span id="a8dc" class="kx je hh kt b fi lc kz l la lb">if (-not $account) {</span><span id="2063" class="kx je hh kt b fi lc kz l la lb"># New account<br/>Write-Host "Create New Account"<br/>$account = New-PAAccount -Contact $acmeContact -AcceptTOS</span><span id="b823" class="kx je hh kt b fi lc kz l la lb">} elseif ($account.contact -ne "<a class="ae jc" href="mailto:$acmeContact" rel="noopener ugc nofollow" target="_blank">mailto:$acmeContact</a>") {</span><span id="a3ad" class="kx je hh kt b fi lc kz l la lb"># Update account contact<br/>Write-Host "Set Existing Account $($account.id)"<br/>Set-PAAccount -ID $account.id -Contact $acmeContact</span><span id="3f2d" class="kx je hh kt b fi lc kz l la lb">}</span></pre><p id="f250" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们需要获取Azure DNS资源订阅ID和访问令牌，以传递到证书生成中。如果您的DNS资源没有托管在您当前的订阅中，那么您可以使用此脚本获取订阅详细信息，然后请求访问令牌。如果是，那么您可以删除设置订阅名称的部分，只显示当前订阅上下文(` az account show-query ' id '-o tsv ')。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="26d7" class="kx je hh kt b fi ky kz l la lb"># Acquire access token for Azure (as we want to leverage the existing connection)<br/>Write-Host "Get Azure Details"<br/>$azAccount = az account show -s $dnsSubscription -o json | ConvertFrom-Json<br/>Write-Host "Azure DNS Sub $($azAccount.name)"<br/>$token = (az account get-access-token --resource '<a class="ae jc" href="https://management.core.windows.net/" rel="noopener ugc nofollow" target="_blank">https://management.core.windows.net/</a>' | ConvertFrom-Json).accessToken</span></pre><p id="2f0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您现在可以使用Post-ACME命令和获得的设置请求新的证书。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="c9f4" class="kx je hh kt b fi ky kz l la lb"># Request certificate<br/>$pArgs = @{<br/>AZSubscriptionId = $azAccount.id<br/>AZAccessToken = $token<br/>}</span><span id="2901" class="kx je hh kt b fi lc kz l la lb">New-PACertificate $domain -Plugin Azure -PluginArgs $pArgs -Verbose<br/>$generatedCert=$(Get-PACertificate)<br/>Write-Host($generatedCert)</span></pre><h1 id="e67b" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Azure DevOps设置</h1><p id="35d2" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">现在我们不想每次都运行这个脚本，所以我们可以在之前添加一个额外的脚本来检查这一点。它将检查证书是否存在，如果存在，它将检查其有效期是否在14天内。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="e6a9" class="kx je hh kt b fi ky kz l la lb">- task: AzureCLI@2<br/>  displayName: 'Check if Cert expired in ${{ parameters.keyVaultName }}'<br/>  name: cert<br/>  inputs:<br/>    azureSubscription: '${{ parameters.subscriptionName }}'<br/>    scriptType: 'pscore'<br/>    scriptLocation: 'inlineScript'<br/>    inlineScript: |</span><span id="a2a0" class="kx je hh kt b fi lc kz l la lb">      $keyVaultName="${{ parameters.keyVaultName }}"<br/>      $certName="${{ parameters.certName}}"<br/>      $exportedCerts = az keyvault certificate list --vault-name $keyVaultName --query "[? name=='$certName']" -o json | ConvertFrom-Json</span><span id="2424" class="kx je hh kt b fi lc kz l la lb">      $expired=$false</span><span id="9984" class="kx je hh kt b fi lc kz l la lb">      if ($null -ne $exportedCerts -and $exportedCerts.length -gt 0){</span><span id="8353" class="kx je hh kt b fi lc kz l la lb">      Write-Host "Certificate Found"<br/>      $exportedCert = $exportedCerts[0]</span><span id="80e3" class="kx je hh kt b fi lc kz l la lb">      Write-Host "Certificate Expires $($exportedCert.attributes.expires)"<br/>      $expiryDate=(get-date $exportedCert.attributes.expires).AddDays(-14)</span><span id="a674" class="kx je hh kt b fi lc kz l la lb">      Write-Host "Certificate Forced Expiry is $expiryDate"</span><span id="834b" class="kx je hh kt b fi lc kz l la lb">      if ($expiryDate -lt (get-date)){</span><span id="2ff9" class="kx je hh kt b fi lc kz l la lb">        Write-Host "Certificate has expired"<br/>        $expired=$true</span><span id="1f27" class="kx je hh kt b fi lc kz l la lb">      } else {</span><span id="b787" class="kx je hh kt b fi lc kz l la lb">        Write-Host "Certificate has NOT expired"<br/>      }</span><span id="fec0" class="kx je hh kt b fi lc kz l la lb">      } else {</span><span id="bddd" class="kx je hh kt b fi lc kz l la lb">        Write-Host "Certificate NOT Found"</span><span id="eec0" class="kx je hh kt b fi lc kz l la lb">       $expired=$true<br/>     }</span><span id="cb35" class="kx je hh kt b fi lc kz l la lb">  Write-Host "##vso[task.setvariable variable=expired;isOutput=true]$expired"</span></pre><p id="243b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可以用来决定是否运行证书请求脚本作为任务条件的一部分。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="1fa3" class="kx je hh kt b fi ky kz l la lb">- task: AzureCLI@2<br/>  name: acmecert<br/>  displayName: 'Request LE Cert for ${{ parameters.domain }}'<br/>  condition: and(succeeded(), eq(variables['cert.expired'], 'True'))<br/>  inputs:<br/>    azureSubscription: '${{ parameters.subscriptionName }}'<br/>    scriptType: 'pscore'<br/>    scriptLocation: 'inlineScript'<br/>    inlineScript: |</span><span id="720c" class="kx je hh kt b fi lc kz l la lb">      $env="${{ parameters.environment }}"<br/>      $acmeContact="me@email.com"<br/>      $domain="${{ parameters.domain }}"<br/>      $dnsSubscription="Reform-CFT-Mgmt"</span><span id="a4cb" class="kx je hh kt b fi lc kz l la lb">      if ($env -eq "production" -or $env -eq "staging") {<br/>        $leServer="LE_PROD"<br/>      }else {<br/>        $leServer="LE_STAGE"<br/>      }</span><span id="bdaa" class="kx je hh kt b fi lc kz l la lb">      # Set Posh-ACME working directory<br/>      Write-Host "Install Module"<br/>      Install-Module -Name Posh-ACME -Scope CurrentUser -Force</span><span id="5aff" class="kx je hh kt b fi lc kz l la lb">      # Configure Posh-ACME server<br/>      Write-Host "Configure LE Server $leServer"<br/>      Set-PAServer $leServer<br/>      Get-PAPlugin Azure</span><span id="5c7b" class="kx je hh kt b fi lc kz l la lb">      # Configure Posh-ACME account<br/>      Write-Host "Setup Account"<br/>      $account = Get-PAAccount</span><span id="c8c6" class="kx je hh kt b fi lc kz l la lb">      if (-not $account) {</span><span id="4db7" class="kx je hh kt b fi lc kz l la lb">        # New account<br/>        Write-Host "Create New Account"<br/>        $account = New-PAAccount -Contact $acmeContact -AcceptTOS<br/>      }<br/>      elseif ($account.contact -ne "<a class="ae jc" href="mailto:$acmeContact" rel="noopener ugc nofollow" target="_blank">mailto:$acmeContact</a>") {</span><span id="b9da" class="kx je hh kt b fi lc kz l la lb">        # Update account contact<br/>        Write-Host "Set Existing Account $($account.id)"<br/>        Set-PAAccount -ID $account.id -Contact $acmeContact<br/>      }</span><span id="f031" class="kx je hh kt b fi lc kz l la lb">      # Acquire access token for Azure (as we want to leverage the existing connection)<br/>      Write-Host "Get Azure Details"<br/>      $azAccount = az account show -s $dnsSubscription -o json | ConvertFrom-Json</span><span id="af8b" class="kx je hh kt b fi lc kz l la lb">      Write-Host "Azure DNS Sub $($azAccount.name)"<br/>      $token = (az account get-access-token --resource '<a class="ae jc" href="https://management.core.windows.net/" rel="noopener ugc nofollow" target="_blank">https://management.core.windows.net/</a>' | ConvertFrom-Json).accessToken</span><span id="2461" class="kx je hh kt b fi lc kz l la lb">      # Request certificate<br/>      $pArgs = @{<br/>        AZSubscriptionId = $azAccount.id<br/>        AZAccessToken = $token<br/>      }</span><span id="4013" class="kx je hh kt b fi lc kz l la lb">      New-PACertificate $domain -Plugin Azure -PluginArgs $pArgs -Verbose</span><span id="6fce" class="kx je hh kt b fi lc kz l la lb">      $generatedCert=$(Get-PACertificate)<br/>      Write-Host($generatedCert)</span><span id="cb21" class="kx je hh kt b fi lc kz l la lb">Write-Host "##vso[task.setvariable variable=certPath;isOutput=true]$($generatedCert.CertFile)"Write-Host "##vso[task.setvariable variable=privateKeyPath;isOutput=true]$($generatedCert.KeyFile)"<br/>Write-Host "##vso[task.setvariable variable=pfxPath;isOutput=true]$($generatedCert.PfxFullChain)"<br/>Write-Host "##vso[task.setvariable variable=pfxPass;isOutput=true;issecret=true]$pfxPassword"</span></pre><h1 id="83e0" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">存储证书</h1><p id="aa7e" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">最后，一旦生成了证书，我们就可以通过使用az cli导入生成的证书，将其导出并放入Azure Key Vault中。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="b063" class="kx je hh kt b fi ky kz l la lb">- task: AzureCLI@2<br/>displayName: 'Import Certificate into ${{ parameters.keyVaultName }}'<br/>condition: and(succeeded(), eq(variables['cert.expired'], 'True'))<br/>inputs:<br/>  azureSubscription: '${{ parameters.subscriptionName }}'<br/>  scriptType: 'pscore'<br/>  scriptLocation: 'inlineScript'<br/>  inlineScript: |</span><span id="bbcb" class="kx je hh kt b fi lc kz l la lb">    $keyVaultName="${{ parameters.keyVaultName }}"<br/>    $certName="${{ parameters.certName}}"<br/>    $password="$(acmecert.pfxPass)"<br/>    $pfxPath="$(acmecert.pfxPath)"</span><span id="acca" class="kx je hh kt b fi lc kz l la lb">    az keyvault certificate import --vault-name $keyVaultName -n     $certName -f $pfxPath --password $password</span></pre><h1 id="7788" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">安装证书</h1><p id="d2c8" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在此阶段，我们假设已经遵循了上述步骤，因此生成了有效的证书，并将其导入到Azure Key Vault中。</p><p id="1383" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还将假设您为Linux虚拟机(虚拟机)安装了Azure CLI，并将Azure托管身份(MI)附加到虚拟机以进行身份验证。</p><p id="43a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在虚拟机上存储证书，我们还使用了Keytools，它与Linux机器上的Java应用程序一起使用。</p><p id="8c9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的脚本中，我们获取了所有变量并登录到Azure CLI中。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="fc03" class="kx je hh kt b fi ky kz l la lb">miClientId="${managedIdentityClientId}"<br/>az login --identity --username $miClientId</span><span id="5997" class="kx je hh kt b fi lc kz l la lb">keyVaultName="${keyVaultName}"<br/>certName="${certName}"<br/>domain="${domain}"</span><span id="ef3a" class="kx je hh kt b fi lc kz l la lb">jksPath="/usr/local/conf/ssl.jks"<br/>jksPass="${certPassword}"</span></pre><p id="c9f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们将获得证书列表，并生成我们认为过期的日期，即证书的过期日期减去14天。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="bc89" class="kx je hh kt b fi ky kz l la lb">expiryDate=$(keytool -list -v -keystore $jksPath -storepass $jksPass | grep until | sed 's/.*until: //')</span><span id="6b9d" class="kx je hh kt b fi lc kz l la lb">echo "Certificate Expires $expiryDate"<br/>expiryDate="$(date -d "$expiryDate - 14 days" +%Y%m%d)"</span><span id="2bcf" class="kx je hh kt b fi lc kz l la lb">echo "Certificate Forced Expiry is $expiryDate"<br/>today=$(date +%Y%m%d)</span></pre><p id="4a3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果今天的日期早于到期日，我们将不会尝试获取新证书，但如果证书不存在或其到期日早于今天，我们将续订。</p><p id="533c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们将从密钥库中下载证书，但由于它下载时没有密码，因此我们使用开放SSL CLI来导入/导出带密码的证书。</p><p id="6dff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将生成一个新的PFX，在删除现有证书后，我们将它导入到Keytools中。</p><pre class="kc kd ke kf fd ks kt ku kv aw kw bi"><span id="34d8" class="kx je hh kt b fi ky kz l la lb">if [[ $expiryDate -lt $today ]]; then<br/>  echo "Certificate has expired"<br/>  downloadedPfxPath="downloadedCert.pfx"<br/>  signedPfxPath="signedCert.pfx"</span><span id="e258" class="kx je hh kt b fi lc kz l la lb">  rm -rf $downloadedPfxPath || true</span><span id="fdd3" class="kx je hh kt b fi lc kz l la lb">  az keyvault secret download --file $downloadedPfxPath --vault-name $keyVaultName --encoding base64 --name $certName</span><span id="238b" class="kx je hh kt b fi lc kz l la lb">  rm -rf $signedPfxPath || true</span><span id="e2f8" class="kx je hh kt b fi lc kz l la lb">  openssl pkcs12 -in $downloadedPfxPath -out tmpmycert.pem -passin pass: -passout pass:$jksPass</span><span id="27b2" class="kx je hh kt b fi lc kz l la lb">  openssl pkcs12 -export -out $signedPfxPath -in tmpmycert.pem -passin pass:$jksPass -passout pass:$jksPass</span><span id="7f94" class="kx je hh kt b fi lc kz l la lb">  keytool -delete -alias 1 -keystore $jksPath -storepass $jksPass</span><span id="119f" class="kx je hh kt b fi lc kz l la lb">  keytool -importkeystore -srckeystore $signedPfxPath -srcstoretype pkcs12 -destkeystore $jksPath -deststoretype JKS -deststorepass $jksPass -srcstorepass $jksPass</span><span id="ea87" class="kx je hh kt b fi lc kz l la lb">else</span><span id="f51f" class="kx je hh kt b fi lc kz l la lb">  echo "Certificate has NOT expired"</span><span id="51c1" class="kx je hh kt b fi lc kz l la lb">fi</span></pre><p id="d341" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，您可以将其放在每天的cron作业中，检查证书是否有效。</p><p id="fd16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">唯一遇到的问题是管道时间表和上面的更新脚本时间表重叠。如果您将它们都放在每日计划中，一个用于续订证书，一个用于获取新证书，则您可能会在证书续订之前运行证书提取计划。尽管这并不理想，但由于我们提前14天续订，因此您仍有13天的时间来赶上进度。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es ld"><img src="../Images/16a6aed9682f5295a33280f5601de43d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PY9nByRuVnhXsCvYeiZ9LQ.png"/></div></div></figure><p id="322e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作者简介:<br/>  Christopher Pateman是Version 1的高级Azure DevOps工程师。</p></div></div>    
</body>
</html>