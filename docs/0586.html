<html>
<head>
<title>Migrating from Dagger to Hilt — Is it worth it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从匕首到刀柄的迁移——值得吗？</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-from-dagger-to-hilt-is-it-worth-it-4cbbc8c93e33?source=collection_archive---------6-----------------------#2020-11-24">https://medium.com/androiddevelopers/migrating-from-dagger-to-hilt-is-it-worth-it-4cbbc8c93e33?source=collection_archive---------6-----------------------#2020-11-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b07555fbeb7cabf07ce1f73109da516b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cp9m4LO4zkpgv2s30Cg9A.png"/></div></div></figure><div class=""/><p id="3d8a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Hilt于2020年6月发布，作为一种标准化Android中依赖注入(DI)的方式。对于新项目，Hilt提供了编译时正确性、运行时性能和可伸缩性(在这里阅读更多关于T5的内容)！但是，对于一个已经使用Dagger的应用程序来说，有什么好处呢？<strong class="ir ht">你应该彻底迁移</strong>你当前的应用吗？以下是您的团队是否应该投资从匕首到刀柄的迁移的一些原因。</p><h1 id="de38" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">✅安卓扩展公司</h1><p id="f120" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果您已经使用Dagger处理ViewModels或WorkManager，您会发现连接ViewModelFactory和WorkerFactory需要大量样板代码和Dagger知识。最常见的实现使用<a class="ae jn" href="https://dagger.dev/dev-guide/multibindings.html" rel="noopener ugc nofollow" target="_blank">多绑定</a>，这是Dagger中最复杂的特性之一，开发人员常常难以理解。通过删除样板代码，Hilt使得使用AndroidX变得容易多了。更好的是，你甚至不需要在Android框架类中注入工厂，你调用它就好像Hilt不存在一样。有了<code class="du kr ks kt ku b">@ViewModelInject</code>，Hilt为你生成了<code class="du kr ks kt ku b">@AndroidEntryPoint</code>活动和片段可以直接使用的正确的<code class="du kr ks kt ku b">ViewModelProvider.Factory</code>。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="cd1c" class="ld jp hs ku b fi le lf l lg lh">class PlayViewModel <strong class="ku ht">@ViewModelInject</strong> constructor(<br/>  val db: MusicDatabase,<br/>) : ViewModel() { ... }</span><span id="5538" class="ld jp hs ku b fi li lf l lg lh">@AndroidEntryPoint<br/>class PlayActivity : AppCompatActivity() {</span><span id="5232" class="ld jp hs ku b fi li lf l lg lh"><strong class="ku ht">  val viewModel: PlayViewModel by viewModels()</strong></span><span id="7844" class="ld jp hs ku b fi li lf l lg lh">  override fun onCreate(savedInstanceState: Bundle) {<br/>    super.onCreate(bundle)<br/>    viewModel.play()<br/>  }<br/>}</span></pre><h1 id="1100" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">✅测试API</h1><p id="a319" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">DI应该使测试更容易，但是具有讽刺意味的是，让Dagger在测试中工作需要大量的工作。事实上，你必须同时维护刺和测试匕首图，这使得它明显比<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-testing" rel="noopener ugc nofollow" target="_blank">刀柄的方法</a>差。</p><p id="1e3e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Hilt测试可以使用<code class="du kr ks kt ku b"><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-testing#replace-binding" rel="noopener ugc nofollow" target="_blank">@UninstallModules</a></code>功能显式修改DI图。除此之外，您还可以获得其他额外的好处，比如<code class="du kr ks kt ku b"><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-testing#binding-new" rel="noopener ugc nofollow" target="_blank">@BindValue</a></code>，它允许您轻松地将测试字段绑定到DI图中。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="57a0" class="ld jp hs ku b fi le lf l lg lh"><strong class="ku ht">@UninstallModules(AnalyticsModule::class)<br/></strong>@HiltAndroidTest<br/>class ExampleTest {</span><span id="469b" class="ld jp hs ku b fi li lf l lg lh">  @get:Rule<br/>  var hiltRule = HiltAndroidRule(this)</span><span id="3a4a" class="ld jp hs ku b fi li lf l lg lh"><strong class="ku ht">  @BindValue @JvmField<br/>  val analyticsRepository = FakeAnalyticsRepository()</strong></span><span id="291f" class="ld jp hs ku b fi li lf l lg lh">  @Test <br/>  fun myTest() { ... }<br/>}</span></pre><h1 id="059f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">✅一致性</h1><p id="409c" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在Dagger中有多种方法可以实现相同的功能。Android应用程序历史上缺乏指导(去年我们<a class="ae jn" href="https://developer.android.com/training/dependency-injection/dagger-basics" rel="noopener ugc nofollow" target="_blank">在</a>解决了这个问题)已经在社区中引起了多次辩论，并最终导致开发人员在他们的Android应用程序中使用和设置Dagger的方式不一致。</p><p id="a31e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能会争辩说，你目前的匕首设置真的很好，你完全知道一切是如何工作的，一切是如何被注射的。所以，迁移到Hilt不值得！对你来说这可能是真的，但是对团队的其他人(以及潜在的未来同事)来说也是这样吗？当切换到一个新项目时，你会知道一切是如何工作的吗？理解Dagger在一个应用程序中的设置和使用可能是一项挑战和耗时的工作。</p><p id="466c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在你的应用程序中使用Hilt可以大大减少这个时间，因为所有的应用程序都使用相同的设置。一个新的开发人员加入你的团队不会对你的手柄设置感到惊讶，因为这和他们习惯的差不多。</p><h1 id="f04e" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">✅定制组件</h1><p id="841b" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">除了已定义的标准组件，Hilt还提供了一种创建定制组件的方法，并将其添加到层次结构中，你可以在这里阅读更多关于<a class="ae jn" rel="noopener" href="/androiddevelopers/hilt-adding-components-to-the-hierarchy-96f207d6d92d">的内容</a>。</p><p id="b2ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使定制组件降低了一致性，您仍然可以获得很多好处！模块自动发现功能(即<code class="du kr ks kt ku b"><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules" rel="noopener ugc nofollow" target="_blank">@InstallIn</a></code>注释功能)以及测试替换功能也适用于定制组件。</p><p id="dcd6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，自定义组件和Hilt内置组件的区别在于，你失去了将那些组件自动注入Android框架类的能力(即<code class="du kr ks kt ku b">@AndroidEntryPoint</code>所做的)。</p><h1 id="8020" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">✅匕首和刀柄互操作</h1><p id="7e28" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">剑柄和匕首可以共存！如果你允许希尔特接管你的<code class="du kr ks kt ku b">SingletonComponent</code>，你可以在应用程序的某些部分受益于希尔特，同时保留其他最适合使用匕首的部分。这也意味着<a class="ae jn" href="https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt#0" rel="noopener ugc nofollow" target="_blank">移植到刀柄可以逐渐完成</a>。</p><h1 id="6c72" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">❌组件依赖关系</h1><p id="81ee" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">固执己见意味着它替你做决定。Hilt为组件关系使用子组件，在这里阅读为什么<a class="ae jn" href="https://dagger.dev/hilt/monolithic" rel="noopener ugc nofollow" target="_blank"/>。如果你坚信你的应用程序使用组件依赖会更好，那么Hilt并不适合你的应用程序。</p></div><div class="ab cl lj lk go ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ha hb hc hd he"><p id="977d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在大多数项目中，从匕首移植到刀柄是值得的。Hilt给你的应用程序带来的好处超过了升级的努力。但你不是一个人！我们提供了大量资源来帮助您完成这一旅程:</p><ul class=""><li id="df9b" class="lq lr hs ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated">综合迁移<a class="ae jn" href="https://dagger.dev/hilt/migration-guide" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="6569" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">从匕首到刀柄的迁移<a class="ae jn" href="https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt#0" rel="noopener ugc nofollow" target="_blank">代码实验室</a></li><li id="5e04" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">迁移Google I/O应用程序以处理<a class="ae jn" rel="noopener" href="/androiddevelopers/migrating-the-google-i-o-app-to-hilt-f3edf03affe5">博客文章</a>和<a class="ae jn" href="https://github.com/google/iosched/commit/9c20fdd52d446e5fdb03369e50fb196c31ae16e3" rel="noopener ugc nofollow" target="_blank">提交</a></li><li id="8c8c" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">刀柄和辅助注射一起工作<a class="ae jn" href="https://gist.github.com/manuelvicnt/437668cda3a891d347e134b1de29aee1" rel="noopener ugc nofollow" target="_blank">要点</a></li></ul><p id="a792" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你有任何问题或者你错过了更多的信息，请在下面留下你的评论！</p></div></div>    
</body>
</html>