<html>
<head>
<title>Using texture counters in the Android GPU Inspector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android GPU检查器中使用纹理计数器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-texture-counters-in-the-android-gpu-inspector-cc0f0dd4a798?source=collection_archive---------0-----------------------#2020-09-14">https://medium.com/androiddevelopers/using-texture-counters-in-the-android-gpu-inspector-cc0f0dd4a798?source=collection_archive---------0-----------------------#2020-09-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e4363bb3eff03f24046b451e343f0021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BD3o25JvQXdJmMXTSsMy4w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Low poly Android GPU Inspector analyzing low poly game</figcaption></figure><div class=""/><p id="bcfa" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android GPU Inspector (AGI)让我们窥视Android上的内部GPU工作。最苛刻的GPU任务之一是从着色器中提取和过滤纹理数据。我们可以使用AGI通过捕获三类纹理GPU性能计数器来监控纹理相关的GPU工作负载:带宽、缓存行为和过滤。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">a higher-bandwidth version of much of this information</figcaption></figure><p id="3cc4" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我总是从查看纹理带宽开始，因为它表明一帧中有多少纹理数据被传输到GPU，并且可以快速突出潜在的纹理性能问题。</p><p id="824b" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当谈到纹理带宽时，一个好的经验法则是确保<strong class="iw hx">纹理读取带宽</strong>平均不高于<strong class="iw hx"> 1GB/s，并且其峰值保持在5GB/s </strong>以下。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/ef23c080c687c9cdfeef29ab5a9aa03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3XTN1LGsSrYwL7-N"/></div></div></figure><p id="37b4" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，这个游戏消耗了大量的纹理带宽，平均超过4GB/s，在接近帧结束时达到峰值，超过6GB/s。</p><p id="2fac" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">预计后期处理步骤会对纹理带宽造成特别大的负担；你可能会同意在帧的末尾花费一部分带宽预算来制作像高光溢出和色调映射这样的特效。但是，如果游戏的颜色通道具有较高的纹理读取带宽峰值，您可能需要调查潜在的性能问题。</p><p id="c642" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于这款游戏，纹理带宽消耗非常大，需要进一步调查。</p><p id="7f3e" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了研究一个潜在的纹理带宽问题，我首先来看看纹理缓存的行为。我的重点是纹理暂停的百分比，L1和L2获取失误。当在L1缓存中找不到纹理提取的纹理数据时，请求被转发到L2缓存，然后到系统内存。每一步都会引入更多的等待时间并消耗更多的能量。<strong class="iw hx">平均L1缓存未命中应低于10%，峰值应低于50% </strong>。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jz"><img src="../Images/e2c6203d7735caf0d3ea3fa3740b2d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iQOGV74qgPpMRK4Z"/></div></div></figure><p id="97ab" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该游戏的GPU系统捕获显示，L1缓存未命中的平均百分比超过20%，最高可达80%或更多。</p><p id="12d4" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些数字再次非常高。</p><p id="d434" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">高比例的纹理暂停的典型原因是未压缩的纹理、复杂的过滤(如各向异性过滤)和纹理未被纹理贴图。</p><p id="cc13" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了调查纹理缓存未命中的潜在原因，我查看了各向异性过滤纹理提取的百分比，这在移动设备上非常昂贵，并查看了<strong class="iw hx">非基本级别</strong>纹理提取的百分比。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ka"><img src="../Images/80c195d1486c6b67f2edc79f61f505c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0TnArDQIKLkfCCuw"/></div></div></figure><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/d60b451045b8392cb0e6d16c5078c5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m3iNan9Nt5cGyx70"/></div></div></figure><p id="4e12" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">非基本级别纹理提取的百分比是对纹理小中见大贴图提取效率的估计。当这个数字为0时，意味着GPU总是访问纹理mipmap链的顶层，即最大的切片，或者纹理根本没有进行mi pmap。</p><p id="372c" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这在大多数3D游戏中都是一个问题，但在2D游戏中通常是可以接受的。</p><p id="df27" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在渲染GUI或后期处理过程中，访问非小中见大贴图纹理是可以的，但在任何其他情况下，这会带来很大的性能损失，并导致缓存行为不佳。</p><p id="41e0" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，获取纹理会消耗大量的系统带宽，并可能会带来延迟，增加电池寿命，并导致热量问题，从长远来看，这将进一步降低性能。</p><p id="292f" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">分析与纹理行为相关的GPU计数器有助于发现潜在的大而易举的结果，在修复后可以显著改善用户体验。</p><p id="e467" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要找到这些与纹理相关的GPU性能问题，请使用<a class="ae kc" href="https://gpuinspector.dev/" rel="noopener ugc nofollow" target="_blank"><em class="kd">Android GPU Inspector</em></a>跟踪您的游戏，并将GPU计数器的值和趋势与这里给出的准则进行比较。</p></div></div>    
</body>
</html>