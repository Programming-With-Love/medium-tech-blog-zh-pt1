<html>
<head>
<title>Use view binding to replace findViewById</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用视图绑定替换findViewById</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc?source=collection_archive---------0-----------------------#2020-02-13">https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc?source=collection_archive---------0-----------------------#2020-02-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/5d81e0a6e6d42c62d9d400e932bea11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42FZcmYQhmznt6mIYKKJAw.png"/></div></div></figure><div class=""/><p id="4f60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Studio 3.6中新增的视图绑定让您能够用生成的绑定对象替换<code class="du jn jo jp jq b">findViewById</code>，以简化代码，消除bug，并避免所有<code class="du jn jo jp jq b">findViewById</code>的样板文件。</p><h2 id="290b" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="12b8" class="km kn hs ir b is ko iw kp ja kq je kr ji ks jm kt ku kv kw bi translated">在<code class="du jn jo jp jq b">build.gradle</code>中启用视图绑定(没有库依赖)</li><li id="1773" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">视图绑定为模块中的每个布局生成一个绑定对象(<code class="du jn jo jp jq b">activity_awesome.xml</code> → <code class="du jn jo jp jq b">ActivityAwesomeBinding.java</code>)</li><li id="1945" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">绑定对象为布局中具有id的每个视图包含一个属性—具有正确的类型和空安全</li><li id="63c0" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated">完全支持Java编程语言和Kotlin</li></ul><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h2 id="5301" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">更新<code class="du jn jo jp jq b">build.gradle</code>以启用视图绑定</h2><p id="9b52" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">您不需要包含任何额外的库来启用视图绑定。从Android Studio 3.6中发布的版本开始，它被内置到Android Gradle插件中。要启用视图绑定，请在您的模块级<code class="du jn jo jp jq b">build.gradle</code>文件中配置<code class="du jn jo jp jq b">viewBinding</code>。</p><pre class="lc ld le lf fd ll jq lm ln aw lo bi"><span id="300f" class="jr js hs jq b fi lp lq l lr ls">// Available in Android Gradle Plugin 3.6.0<br/>android {<br/>    viewBinding {<br/>        enabled = true<br/>    }<br/>}</span></pre><p id="7e36" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android Studio 4.0中，<code class="du jn jo jp jq b">viewBinding</code>被移到了<code class="du jn jo jp jq b">buildFeatures</code> [ <a class="ae lt" href="https://developer.android.com/studio/preview/features/#agp-4-0-0" rel="noopener ugc nofollow" target="_blank">发布说明</a>中，你应该使用:</p><pre class="lc ld le lf fd ll jq lm ln aw lo bi"><span id="fc68" class="jr js hs jq b fi lp lq l lr ls">// Android Studio 4.0<br/>android {<br/>    buildFeatures {<br/>        viewBinding = true<br/>    }<br/>}</span></pre><p id="0ae1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦为项目启用，视图绑定将自动为您的所有布局生成一个绑定类。您不必对XML进行修改，它会自动与您现有的布局协同工作。</p><blockquote class="lv"><p id="de57" class="lw lx hs bd ly lz ma mb mc md me jm dx translated">视图绑定使用现有的XML，并将为模块中的每个布局生成一个绑定对象。</p></blockquote><p id="8db0" class="pw-post-body-paragraph ip iq hs ir b is mf iu iv iw mg iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">无论何时展开布局，如<code class="du jn jo jp jq b">Fragment</code>、<code class="du jn jo jp jq b">Activity</code>，甚至是RecyclerView <code class="du jn jo jp jq b">Adapter</code>(或<code class="du jn jo jp jq b">ViewHolder</code>)，都可以使用binding类。</p><h2 id="b5cd" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">在活动中使用视图绑定</h2><p id="1de9" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">如果您有一个名为<code class="du jn jo jp jq b"><a class="ae lt" href="https://gist.github.com/objcode/3ee41edae40ba13f13da569b8f27333a" rel="noopener ugc nofollow" target="_blank">activity_awesome.xml</a></code>的布局，其中包含一个按钮和两个文本视图，视图绑定会生成一个名为<code class="du jn jo jp jq b">ActivityAwesomeBinding</code>的小类，其中包含布局中每个带有ID的视图的属性。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="mk lh l"/></div></figure><p id="0b64" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用视图绑定时，您不必调用<code class="du jn jo jp jq b">findViewById</code>——相反，只需使用所提供的属性来引用布局中带有id的任何视图。</p><p id="793a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">布局的根元素总是存储在一个自动生成的名为<code class="du jn jo jp jq b">root</code>的属性中。在一个<code class="du jn jo jp jq b">Activity</code>的<code class="du jn jo jp jq b">onCreate</code>方法中，你将<code class="du jn jo jp jq b">root</code>传递给<code class="du jn jo jp jq b">setContentView</code>来告诉活动使用绑定对象的布局。</p><blockquote class="ml mm mn"><p id="a33a" class="ip iq lu ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><strong class="ir ht">易错:</strong>用布局资源id而不是膨胀的绑定对象调用<code class="du jn jo jp jq b">setContentView(…)</code>是一个容易犯的错误。这导致布局被放大两次，监听器被安装在错误的布局对象上。</p><p id="89ce" class="ip iq lu ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><strong class="ir ht">解决方案:</strong>当在一个<code class="du jn jo jp jq b">Activity</code>中使用视图绑定时，你应该总是用<code class="du jn jo jp jq b">setContentView(binding.root)</code>从绑定对象中传递布局。</p></blockquote><h2 id="fba6" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">使用绑定对象的安全代码</h2><p id="9419" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated"><code class="du jn jo jp jq b">findViewById</code>是Android中许多面向用户的bug的来源。很容易传递一个不在当前布局中的id——产生<code class="du jn jo jp jq b">null</code>和崩溃。而且，因为它没有内置任何类型安全，所以很容易发布调用<code class="du jn jo jp jq b">findViewById&lt;TextView&gt;(R.id.image)</code>的代码。视图绑定用一个简洁、安全的替代方法取代了<code class="du jn jo jp jq b">findViewById</code>。</p><p id="b2d4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">视图绑定是…</p><ul class=""><li id="7ece" class="km kn hs ir b is it iw ix ja mr je ms ji mt jm kt ku kv kw bi translated"><strong class="ir ht">类型安全</strong>，因为属性总是<em class="lu">基于布局中的视图</em>被正确键入。因此，如果您在布局中放置一个<code class="du jn jo jp jq b">TextView</code>，视图绑定将公开一个<code class="du jn jo jp jq b">TextView</code>属性。</li><li id="f577" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><strong class="ir ht">空安全</strong>用于在多个配置中定义的布局。视图绑定将检测视图是否只存在于某些配置中，并创建一个<code class="du jn jo jp jq b">@Nullable</code>属性。</li></ul><p id="5e9b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于生成的绑定类是带有Kotlin友好注释的常规Java类，所以可以从Java编程语言和Kotlin中使用视图绑定。</p><h2 id="7a61" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">它会生成什么代码？</h2><p id="73b7" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">视图绑定生成一个Java类，取代了代码中对<code class="du jn jo jp jq b">findViewById</code>的需求。在映射名称时，它将为模块中的每个XML布局生成一个绑定对象，因此<code class="du jn jo jp jq b">activity_awesome.xml</code>映射到<code class="du jn jo jp jq b">ActivityAwesomeBinding.java</code>。</p><p id="db4e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当在Android Studio中编辑XML布局时，代码生成将被优化为仅<em class="lu">更新与该XML文件相关的绑定对象，并且它将在内存中这样做以使事情变得更快。这意味着对绑定对象的更改在编辑器中立即可用，您不必等待完整的重新构建。</em></p><blockquote class="lv"><p id="1d7e" class="lw lx hs bd ly lz ma mb mc md me jm dx translated">Android Studio经过优化，可以在编辑XML布局时立即更新绑定对象。</p></blockquote><p id="c51a" class="pw-post-body-paragraph ip iq hs ir b is mf iu iv iw mg iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">让我们浏览一下本文前面为示例XML布局<a class="ae lt" href="https://gist.github.com/objcode/3ee41edae40ba13f13da569b8f27333a" rel="noopener ugc nofollow" target="_blank">生成的代码，以了解视图绑定会生成什么。</a></p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="mk lh l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Properties generated by view binding are correctly typed and null-safe.</figcaption></figure><p id="24b4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">视图绑定将为每个具有指定<code class="du jn jo jp jq b">id</code>的视图生成一个正确类型的属性。它还将生成一个名为<code class="du jn jo jp jq b">rootView</code>的属性，该属性通过一个getter <code class="du jn jo jp jq b">getRoot</code>公开。视图绑定不做任何逻辑处理——它只是在一个绑定对象中公开您的视图，这样您就可以将它们连接起来，而不需要对<code class="du jn jo jp jq b">findViewById</code>进行容易出错的调用。这使生成的文件保持简单(并避免减慢构建)。</p><p id="a5a6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您使用的是Kotlin，那么这个类针对互操作性进行了优化。因为所有属性都用<code class="du jn jo jp jq b">@Nullable</code>或<code class="du jn jo jp jq b">@NonNull</code>标注，所以科特林知道如何将它们公开为空安全类型。要了解关于语言间互操作的更多信息，请查阅从Kotlin 调用Java的文档。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="mk lh l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">View binding generates an inflate method, which is the primary way to make new binding objects.</figcaption></figure><p id="5e69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jn jo jp jq b">ActivityAwesomeBinding.java</code>中，视图绑定生成一个公共的<code class="du jn jo jp jq b">inflate</code>方法。单参数版本将<code class="du jn jo jp jq b">null</code>作为父视图传递，并且不附加到父视图。视图绑定还公开了一个三参数版本的<code class="du jn jo jp jq b">inflate</code>，让您在需要时传递<code class="du jn jo jp jq b">parent</code>和<code class="du jn jo jp jq b">attachToParent</code>参数。</p><p id="f10b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对<code class="du jn jo jp jq b">bind</code>的调用是奇迹发生的地方。它将采用展开的布局并绑定所有属性，并添加一些错误检查来生成可读的错误消息。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="mk lh l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Simplified version of the generated public bind method.</figcaption></figure><p id="3283" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">bind</code>方法是生成的绑定对象中最复杂的代码，每个要绑定的视图都有一个对<code class="du jn jo jp jq b">findViewById</code>的调用。这里您可以看到神奇的事情发生了——因为编译器可以直接从XML布局中检查每个属性的类型和潜在的空性，它可以安全地调用<code class="du jn jo jp jq b">findViewById</code>。</p><p id="e78f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，<code class="du jn jo jp jq b">bind</code>方法实际生成的代码更长，并且使用带标签的break来优化字节码。查看杰克·沃顿的<a class="ae lt" href="https://jakewharton.com/optimizing-bytecode-by-manipulating-source-code/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，了解更多关于优化的应用。</p><p id="3803" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在每个绑定类上，视图绑定公开了三个公共静态函数来创建绑定对象，下面是何时使用每个函数的快速指南:</p><ul class=""><li id="a921" class="km kn hs ir b is it iw ix ja mr je ms ji mt jm kt ku kv kw bi translated"><code class="du jn jo jp jq b"><strong class="ir ht">inflate(inflater)</strong></code>–在没有父视图传递给绑定对象的<code class="du jn jo jp jq b">Activity</code> <code class="du jn jo jp jq b">onCreate</code>中使用。</li><li id="7063" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><code class="du jn jo jp jq b"><strong class="ir ht">inflate(inflater, parent, attachToParent)</strong></code>–在需要将<code class="du jn jo jp jq b">parent</code> <code class="du jn jo jp jq b">ViewGroup</code>传递给绑定对象的<code class="du jn jo jp jq b">Fragment</code>或回收视图<code class="du jn jo jp jq b">Adapter</code>(或<code class="du jn jo jp jq b">ViewHolder</code>)中使用。</li><li id="b4de" class="km kn hs ir b is kx iw ky ja kz je la ji lb jm kt ku kv kw bi translated"><code class="du jn jo jp jq b"><strong class="ir ht">bind(rootView)</strong></code>–当您已经放大了视图，并且您只想使用视图绑定来避免<code class="du jn jo jp jq b">findViewById</code>时，使用此选项。这对于将视图绑定融入您现有的基础设施以及重构代码以使用<code class="du jn jo jp jq b">ViewBinding</code>非常有用。</li></ul><h2 id="735d" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">包含的布局呢</h2><p id="328d" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">模块中的每个<code class="du jn jo jp jq b">layout.xml</code>都会生成一个绑定对象。即使当另一个布局是这个布局时也是如此。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="mk lh l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Example of include tag in view binding. Note that the &lt;include&gt; tag has an id!</figcaption></figure><p id="7952" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在包含布局的情况下，视图绑定将创建对包含布局的绑定对象的引用。</p><p id="dcf6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，<code class="du jn jo jp jq b">&lt;include&gt;</code>标签有一个id: <code class="du jn jo jp jq b">android:id="@+id/includes"</code>。这是视图绑定生成属性所必需的(就像普通视图一样)。</p><blockquote class="lv"><p id="31c4" class="lw lx hs bd ly lz ma mb mc md me jm dx translated">Include标记必须有id才能生成绑定属性。</p></blockquote><figure class="my mz na nb nc hj"><div class="bz dy l di"><div class="mk lh l"/></div></figure><p id="ca6c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">视图绑定将生成对<code class="du jn jo jp jq b">ActivityAwesomeBinding</code>中<code class="du jn jo jp jq b">IncludedButtonsBinding</code>对象的引用。</p></div><div class="ab cl nd ne go nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ha hb hc hd he"><h2 id="90e4" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">使用视图绑定和数据绑定</h2><p id="3970" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">视图绑定只是对<code class="du jn jo jp jq b">findViewById</code>的替代。如果你也想自动绑定XML视图，你可以使用<a class="ae lt" href="https://www.google.com/search?q=data+binding+android&amp;rlz=1C5CHFA_enUS871US871&amp;oq=data+binding+androi&amp;aqs=chrome.0.0j69i57j0l3j69i60l3.4174j0j4&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">数据绑定</a>库。这两个库可以应用于同一个模块，它们可以一起工作。</p><p id="8f2d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当两者都启用时，使用<code class="du jn jo jp jq b">&lt;layout&gt;</code>标签的布局将使用数据绑定来生成绑定对象。所有其他布局将使用视图绑定来生成绑定对象。</p><blockquote class="lv"><p id="e6e5" class="lw lx hs bd ly lz ma mb mc md me jm dx translated">您可以在同一个模块中使用数据绑定和视图绑定。</p></blockquote><p id="ac6f" class="pw-post-body-paragraph ip iq hs ir b is mf iu iv iw mg iy iz ja mh jc jd je mi jg jh ji mj jk jl jm ha bi translated">除了数据绑定之外，我们还开发了视图绑定，因为许多开发人员提供了反馈，他们想要一个轻量级的解决方案来代替没有数据绑定库的其他部分的<code class="du jn jo jp jq b">findViewById</code>——视图绑定提供了这种解决方案。</p><h2 id="e6ad" class="jr js hs bd jt ju jv jw jx jy jz ka kb ja kc kd ke je kf kg kh ji ki kj kk kl bi translated">查看装订和Kotlin合成纤维或ButterKnife</h2><p id="a330" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">关于视图绑定最常见的问题之一是，“我应该使用视图绑定而不是Kotlin合成或ButterKnife吗？”这两个库都被许多应用程序成功使用，并解决了相同的问题。</p><p id="fedf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于大多数应用程序，我们建议尝试视图绑定而不是这些库，因为视图绑定提供了更安全、更简洁的视图查找。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nk"><img src="../Images/1c0a292e7d5f461abe9ba6f177c5f803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APXv8swJYGv2O8CAqV1jLQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx">Comparing features of View binding, ButterKnife, and Kotlin synthetics.</figcaption></figure><blockquote class="ml mm mn"><p id="336b" class="ip iq lu ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated">虽然ButterKnife在运行时验证可空/非空，但编译器不会检查您是否正确匹配了布局中的内容</p></blockquote><blockquote class="lv"><p id="3374" class="lw lx hs bd ly lz nl nm nn no np jm dx translated">我们建议尝试视图绑定，以实现安全、简洁的视图查找。</p></blockquote><h2 id="d170" class="jr js hs bd jt ju nq jw jx jy nr ka kb ja ns kd ke je nt kg kh ji nu kj kk kl bi translated">了解更多信息</h2><p id="d825" class="pw-post-body-paragraph ip iq hs ir b is ko iu iv iw kp iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">要了解更多关于视图绑定的信息，请查看官方文档。</p><p id="b9d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们很乐意在twitter上听到你使用<a class="ae lt" href="https://twitter.com/search?q=%23ViewBinding" rel="noopener ugc nofollow" target="_blank"> #ViewBinding </a>图书馆的经历！</p></div></div>    
</body>
</html>