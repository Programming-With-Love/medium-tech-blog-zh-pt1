<html>
<head>
<title>Curry and Function Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">咖喱与功能组合</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983?source=collection_archive---------0-----------------------#2018-11-13">https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983?source=collection_archive---------0-----------------------#2018-11-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="62a6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列<strong class="iz hi"> s </strong> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">(现在一本书！)</strong> </a>关于从基础开始学习JavaScript 6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<em class="hh"> <br/> </em> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="hh">买书</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc"> <em class="hh">索引</em></a><em class="hh">|</em><a class="ae jv" rel="noopener" href="/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99"><em class="hh">&lt;上一篇</em></a><em class="hh">|</em><em class="hh">下一篇&gt; </em> </p></blockquote><p id="da3a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">随着主流JavaScript中函数式编程的迅速崛起，curried函数在许多应用程序中变得很常见。了解它们是什么，它们是如何工作的，以及如何很好地使用它们是很重要的。</p><h1 id="61b1" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是咖喱功能？</h1><p id="5980" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">curried函数是一个一次接受多个参数<em class="iy">的函数。</em>给定一个有3个参数的函数，curried版本将接受一个参数并返回一个接受下一个参数的函数，后者返回一个接受第三个参数的函数。最后一个函数返回将该函数应用于其所有参数的结果。</p><p id="aca1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">你可以用更多或更少的参数做同样的事情。例如，给定两个数字，<code class="du lc ld le lf b">a</code>和<code class="du lc ld le lf b">b</code>，返回<code class="du lc ld le lf b">a</code>和<code class="du lc ld le lf b">b</code>的和:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="e278" class="lo ka hh lf b fi lp lq l lr ls">// add = a =&gt; b =&gt; Number<br/>const add = a =&gt; b =&gt; a + b;</span></pre><p id="e330" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">要使用它，我们必须使用函数应用程序语法应用这两个函数。在JavaScript中，函数引用后的括号<code class="du lc ld le lf b">()</code>触发函数调用。当一个函数返回另一个函数时，可以通过添加一组额外的括号来立即调用返回的函数:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="1bf5" class="lo ka hh lf b fi lp lq l lr ls">const result = add(2)(3); // =&gt; 5</span></pre><p id="0fb7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">首先，函数取<code class="du lc ld le lf b">a</code>，然后<em class="iy">返回一个新函数，</em>再取<code class="du lc ld le lf b">b</code>返回<code class="du lc ld le lf b">a</code>和<code class="du lc ld le lf b">b</code>之和。每次一个参数。如果函数有更多的参数，它可以简单地继续返回新的函数，直到提供了所有的参数，应用程序可以完成。</p><p id="88bc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du lc ld le lf b">add</code>函数接受一个参数，然后返回自身的一个<strong class="iz hi">分部应用</strong>，其中<code class="du lc ld le lf b">a</code> <strong class="iz hi">固定在闭包范围内</strong>。一个<strong class="iz hi">闭包</strong>是一个与其词法范围捆绑在一起的函数。闭包是在运行时函数创建期间创建的。Fixed意味着在闭包的绑定范围内为变量赋值。</p><p id="9dcf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">上例中的括号代表函数调用:<code class="du lc ld le lf b">add</code>被<code class="du lc ld le lf b">2</code>调用，返回部分应用的函数，其中<code class="du lc ld le lf b">a</code>被固定为<code class="du lc ld le lf b">2</code>。我们没有将返回值赋给变量或使用它，而是通过将<code class="du lc ld le lf b">3</code>传递给括号中的函数来立即调用返回的函数，这完成了应用程序并返回<code class="du lc ld le lf b">5</code>。</p><h1 id="14b7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是局部应用？</h1><p id="6051" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">一个<strong class="iz hi">部分应用</strong>是一个已经被应用到它的一些，但不是全部参数的函数。换句话说，它是一个在其闭包范围内有固定参数<em class="iy">的函数</em>。某些参数固定的函数被称为<em class="iy">部分应用</em>。</p><h1 id="cd8f" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">有什么区别？</h1><p id="5cc7" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">分部应用程序一次可以根据需要接受或多或少的参数。另一方面，Curried函数总是返回一元函数:一个带一个参数的函数。</p><p id="319c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所有的约束函数都返回部分应用，但并不是所有的部分应用都是约束函数的结果。</p><p id="01f8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对定制函数的一元要求是一个重要的特性。</p><h1 id="f729" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是无点风格？</h1><p id="e8b8" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">无点风格是一种编程风格，其中函数定义不引用函数的参数。让我们看看JavaScript中的函数定义:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="fb86" class="lo ka hh lf b fi lp lq l lr ls">function foo (/* parameters are declared here*/) {<br/>  // ...<br/>}</span><span id="5259" class="lo ka hh lf b fi lt lq l lr ls">const foo = (/* parameters are declared here */) =&gt; // ...</span><span id="1adf" class="lo ka hh lf b fi lt lq l lr ls">const foo = function (/* parameters are declared here */) {<br/>  // ...<br/>}</span></pre><p id="b64d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如何在不引用所需参数的情况下在JavaScript中定义函数？嗯，我们不能使用<code class="du lc ld le lf b">function</code>关键字，也不能使用箭头函数(<code class="du lc ld le lf b">=&gt;</code>)，因为它们需要声明任何形式参数(这会引用它的参数)。所以我们需要做的是调用一个返回函数的函数。</p><p id="892b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">创建一个函数，无论你传递给它什么数字，它都用无点方式递增1。记住，我们已经有一个名为<code class="du lc ld le lf b">add</code>的函数，它接受一个数字并返回一个部分应用的函数，它的第一个参数固定为您传入的任何值。我们可以用它来创建一个名为<code class="du lc ld le lf b">inc()</code>的新函数:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="c1ee" class="lo ka hh lf b fi lp lq l lr ls">// inc = n =&gt; Number<br/>// Adds 1 to any number.<br/>const inc = add(1);</span><span id="663a" class="lo ka hh lf b fi lt lq l lr ls">inc(3); // =&gt; 4</span></pre><p id="595b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">作为一般化和特殊化的机制，这变得很有趣。返回的函数只是更一般的<code class="du lc ld le lf b">add()</code>函数的<em class="iy">专门版本</em>。我们可以使用<code class="du lc ld le lf b">add()</code>创建尽可能多的专用版本:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="b7cd" class="lo ka hh lf b fi lp lq l lr ls">const inc10 = add(10);<br/>const inc20 = add(20);</span><span id="f179" class="lo ka hh lf b fi lt lq l lr ls">inc10(3); // =&gt; 13<br/>inc20(3); // =&gt; 23</span></pre><p id="fd61" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当然，这些都有它们自己的闭包范围(闭包是在函数创建时创建的——当<code class="du lc ld le lf b">add()</code>被调用时)，所以最初的<code class="du lc ld le lf b">inc()</code>继续工作:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="0182" class="lo ka hh lf b fi lp lq l lr ls">inc(3) // 4</span></pre><p id="cb68" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当我们用函数调用<code class="du lc ld le lf b">add(1)</code>创建<code class="du lc ld le lf b">inc()</code>时，<code class="du lc ld le lf b">add()</code>中的<code class="du lc ld le lf b">a</code>参数在被赋值给<code class="du lc ld le lf b">inc</code>的返回函数中被<em class="iy">固定为</em>到<code class="du lc ld le lf b">1</code>。</p><p id="e5ea" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">然后当我们调用<code class="du lc ld le lf b">inc(3)</code>时，<code class="du lc ld le lf b">add()</code>内的<code class="du lc ld le lf b">b</code>参数被替换为实参值<code class="du lc ld le lf b">3</code>，应用完成，返回<code class="du lc ld le lf b">1</code>和<code class="du lc ld le lf b">3</code>之和。</p><p id="c3ac" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所有的curried函数都是高阶函数的一种形式，它允许您为手边的特定用例创建原始函数的专门版本。</p><h1 id="fd1b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我们为什么要咖喱？</h1><p id="6217" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">Curried函数在函数组合的上下文中特别有用。</p><p id="63c0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在代数中，给定两个函数，<code class="du lc ld le lf b">g</code>和<code class="du lc ld le lf b">f</code>:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="7fb8" class="lo ka hh lf b fi lp lq l lr ls">g: a -&gt; b<br/>f: b -&gt; c</span></pre><p id="e3d7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以将这些函数组合在一起创建一个新函数，<code class="du lc ld le lf b">h</code>从<code class="du lc ld le lf b">a</code>直接到<code class="du lc ld le lf b">c</code>:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="382c" class="lo ka hh lf b fi lp lq l lr ls">// Algebra definition, borrowing the `.` composition operator<br/>// from Haskell</span><span id="76cc" class="lo ka hh lf b fi lt lq l lr ls">h: a -&gt; c<br/>h = f . g = f(g(x))</span></pre><p id="9d92" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="23eb" class="lo ka hh lf b fi lp lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="dde3" class="lo ka hh lf b fi lt lq l lr ls">const h = x =&gt; f(g(x));</span><span id="2eeb" class="lo ka hh lf b fi lt lq l lr ls">h(20); //=&gt; 42</span></pre><p id="bf9a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">代数定义:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="798f" class="lo ka hh lf b fi lp lq l lr ls">f . g = f(g(x))</span></pre><p id="5bc1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">可以翻译成JavaScript:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="ee5d" class="lo ka hh lf b fi lp lq l lr ls">const compose = (f, g) =&gt; x =&gt; f(g(x));</span></pre><p id="8166" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是一次只能完成两个功能。在代数中，可以写成:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="c219" class="lo ka hh lf b fi lp lq l lr ls">f . g . h</span></pre><p id="b03d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们可以写一个函数来组合任意多的函数。换句话说，<code class="du lc ld le lf b">compose()</code>创建了一个函数管道，一个函数的输出连接到下一个函数的输入。</p><p id="b0cb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我通常是这样写的:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="a422" class="lo ka hh lf b fi lp lq l lr ls">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</span></pre><p id="6d56" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个版本接受任意数量的函数并返回一个取初始值的函数，然后使用<code class="du lc ld le lf b">reduceRight()</code>从右到左迭代<code class="du lc ld le lf b">fns</code>中的每个函数<code class="du lc ld le lf b">f</code>，并依次将其应用到累计值<code class="du lc ld le lf b">y</code>。我们在这个函数中用累加器<code class="du lc ld le lf b">y</code>累加的是由<code class="du lc ld le lf b">compose()</code>返回的函数的返回值。</p><p id="e83a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在我们可以这样写作文了:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="aaac" class="lo ka hh lf b fi lp lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="1337" class="lo ka hh lf b fi lt lq l lr ls">// replace `x =&gt; f(g(x))` with `compose(f, g)`<br/>const h = compose(f, g);</span><span id="cf3c" class="lo ka hh lf b fi lt lq l lr ls">h(20); //=&gt; 42</span></pre><h1 id="c293" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">找到；查出</h1><p id="2d34" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">使用无指针风格的函数组合创建了非常简洁、易读的代码，但是它可能会以易于调试为代价。如果你想检查函数之间的值呢？是一个方便的工具，可以让你做到这一点。它采取了一种约定俗成的功能形式:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="56ff" class="lo ka hh lf b fi lp lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span></pre><p id="4b94" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在我们可以检查管道:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="ff86" class="lo ka hh lf b fi lp lq l lr ls">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</span><span id="eacd" class="lo ka hh lf b fi lt lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="99fd" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="81bc" class="lo ka hh lf b fi lt lq l lr ls">/*<br/>Note: function application order is<br/>bottom-to-top:<br/>*/<br/>const h = compose(<br/>  trace('after f'),<br/>  f,<br/>  trace('after g'),<br/>  g<br/>);</span><span id="25f6" class="lo ka hh lf b fi lt lq l lr ls">h(20);<br/>/*<br/>after g: 21<br/>after f: 42<br/>*/</span></pre><p id="e575" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du lc ld le lf b">compose()</code>是一个很好的工具，但是当我们需要组合两个以上的函数时，如果我们能按照从上到下的顺序阅读它们，有时会很方便。我们可以通过颠倒函数的调用顺序来实现。还有另一个叫做<code class="du lc ld le lf b">pipe()</code>的合成工具，它以相反的顺序合成:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="1a88" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span></pre><p id="b538" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在我们可以这样写上面的代码:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="bcc3" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="971d" class="lo ka hh lf b fi lt lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="88ff" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="f55f" class="lo ka hh lf b fi lt lq l lr ls">/*<br/>Now the function application order<br/>runs top-to-bottom:<br/>*/<br/>const h = pipe(<br/>  g,<br/>  trace('after g'),<br/>  f,<br/>  trace('after f'),<br/>);</span><span id="11b7" class="lo ka hh lf b fi lt lq l lr ls">h(20);<br/>/*<br/>after g: 21<br/>after f: 42<br/>*/</span></pre><h1 id="9478" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">咖喱和功能组合在一起</h1><p id="ff33" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">即使在函数组合的上下文之外，currying当然也是一个有用的抽象，我们可以用它来专门化函数。例如，一个curried版本的<code class="du lc ld le lf b">map()</code>可以专门做许多不同的事情:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="5fdd" class="lo ka hh lf b fi lp lq l lr ls">const map = fn =&gt; mappable =&gt; mappable.map(fn);</span><span id="8a89" class="lo ka hh lf b fi lt lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);<br/>const log = (...args) =&gt; console.log(...args);</span><span id="a9b1" class="lo ka hh lf b fi lt lq l lr ls">const arr = [1, 2, 3, 4];<br/>const isEven = n =&gt; n % 2 === 0;</span><span id="1eb7" class="lo ka hh lf b fi lt lq l lr ls">const stripe = n =&gt; isEven(n) ? 'dark' : 'light';<br/>const stripeAll = map(stripe);<br/>const striped = stripeAll(arr); <br/>log(striped);<br/>// =&gt; ["light", "dark", "light", "dark"]</span><span id="ab43" class="lo ka hh lf b fi lt lq l lr ls">const double = n =&gt; n * 2;<br/>const doubleAll = map(double);<br/>const doubled = doubleAll(arr);<br/>log(doubled);<br/>// =&gt; [2, 4, 6, 8]</span></pre><p id="105c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是curried函数的真正强大之处在于它们简化了函数的组合。一个函数可以接受任意数量的输入，但只能返回一个输出。为了使函数可组合，输出类型必须与预期的输入类型一致:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="9854" class="lo ka hh lf b fi lp lq l lr ls">f: a =&gt; b<br/>g:      b =&gt; c<br/>h: a    =&gt;   c</span></pre><p id="7d29" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果上面的<code class="du lc ld le lf b">g</code>函数需要两个参数，那么<code class="du lc ld le lf b">f</code>的输出不会与<code class="du lc ld le lf b">g</code>的输入一致:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="96f4" class="lo ka hh lf b fi lp lq l lr ls">f: a =&gt; b<br/>g:     (x, b) =&gt; c<br/>h: a    =&gt;   c</span></pre><p id="b289" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这个场景中，我们如何让<code class="du lc ld le lf b">x</code>进入<code class="du lc ld le lf b">g</code>？通常回答是要<em class="iy">库里</em> <code class="du lc ld le lf b"><em class="iy">g</em></code> <em class="iy">。</em></p><p id="d962" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">请记住，定制函数的定义是一个一次接受多个参数的函数<em class="iy">通过接受第一个参数并返回一系列函数，每个函数接受下一个参数，直到收集完所有参数。</em></p><p id="ebbe" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个定义的关键词是“一次一个”。curried函数对于函数组合如此方便的原因是，它们将需要多个参数的函数转换为可以接受单个参数的函数，从而使它们适合函数组合管道。以前面的<code class="du lc ld le lf b">trace()</code>函数为例:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="c047" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="bc3e" class="lo ka hh lf b fi lt lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="9fe4" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="efa9" class="lo ka hh lf b fi lt lq l lr ls">const h = pipe(<br/>  g,<br/>  trace('after g'),<br/>  f,<br/>  trace('after f'),<br/>);</span><span id="2faa" class="lo ka hh lf b fi lt lq l lr ls">h(20);<br/>/*<br/>after g: 21<br/>after f: 42<br/>*/</span></pre><p id="c007" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du lc ld le lf b">trace()</code>定义了两个参数，但一次只接受一个，这允许我们对内联函数进行专门化。如果没有咖喱，我们就不能这样使用它。我们必须像这样编写管道:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="77bf" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="5480" class="lo ka hh lf b fi lt lq l lr ls">const trace = (label, value) =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="98ff" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="d920" class="lo ka hh lf b fi lt lq l lr ls">const h = pipe(<br/>  g,<br/>  // the trace() calls are no longer point-free,<br/>  // introducing the intermediary variable, `x`.<br/>  x =&gt; trace('after g', x),<br/>  f,<br/>  x =&gt; trace('after f', x),<br/>);</span><span id="4fb1" class="lo ka hh lf b fi lt lq l lr ls">h(20);</span></pre><p id="f9b7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是简单地奉承一个功能是不够的。您还需要确保函数期望参数以正确的顺序来专门化它们。看看如果我们再次搜索<code class="du lc ld le lf b">trace()</code>，但是颠倒参数顺序会发生什么:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="6e8a" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="ed2b" class="lo ka hh lf b fi lt lq l lr ls">const trace = value =&gt; label =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="339c" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="f52a" class="lo ka hh lf b fi lt lq l lr ls">const h = pipe(<br/>  g,<br/>  // the trace() calls can't be point-free,<br/>  // because arguments are expected in the wrong order.<br/>  x =&gt; trace(x)('after g'),<br/>  f,<br/>  x =&gt; trace(x)('after f'),<br/>);</span><span id="f5ac" class="lo ka hh lf b fi lt lq l lr ls">h(20);</span></pre><p id="81b7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您遇到困难，可以使用一个名为<code class="du lc ld le lf b">flip()</code>的函数来解决这个问题，这个函数只需颠倒两个参数的顺序:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="13fd" class="lo ka hh lf b fi lp lq l lr ls">const flip = fn =&gt; a =&gt; b =&gt; fn(b)(a);</span></pre><p id="0c46" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在我们可以创建一个<code class="du lc ld le lf b">flippedTrace()</code>函数:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="23da" class="lo ka hh lf b fi lp lq l lr ls">const flippedTrace = flip(trace);</span></pre><p id="3494" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">像这样使用它:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="895a" class="lo ka hh lf b fi lp lq l lr ls">const flip = fn =&gt; a =&gt; b =&gt; fn(b)(a);<br/>const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="f3de" class="lo ka hh lf b fi lt lq l lr ls">const trace = value =&gt; label =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};<br/>const flippedTrace = flip(trace);</span><span id="9fcc" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="41bd" class="lo ka hh lf b fi lt lq l lr ls">const h = pipe(<br/>  g,<br/>  flippedTrace('after g'),<br/>  f,<br/>  flippedTrace('after f'),<br/>);</span><span id="90d8" class="lo ka hh lf b fi lt lq l lr ls">h(20);</span></pre><p id="a644" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是更好的方法是首先正确地编写函数。这种风格有时被称为“数据最后”，这意味着您应该首先获取专门化的参数，然后获取函数将最后处理的数据。这给了我们函数的原始形式:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="de26" class="lo ka hh lf b fi lp lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span></pre><p id="5df4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对一个<code class="du lc ld le lf b">label</code>的<code class="du lc ld le lf b">trace()</code>的每个应用创建一个在流水线中使用的跟踪函数的专用版本，其中标签被固定在返回的<code class="du lc ld le lf b">trace</code>的部分应用中。所以这个:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="9689" class="lo ka hh lf b fi lp lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="9439" class="lo ka hh lf b fi lt lq l lr ls">const traceAfterG = trace('after g');</span></pre><p id="df14" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">…相当于这样:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="709a" class="lo ka hh lf b fi lp lq l lr ls">const traceAfterG = value =&gt; {<br/>  const label = 'after g';<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span></pre><p id="4aac" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果我们把<code class="du lc ld le lf b">trace('after g')</code>换成<code class="du lc ld le lf b">traceAfterG</code>，意思是一样的:</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="e9ca" class="lo ka hh lf b fi lp lq l lr ls">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);</span><span id="f234" class="lo ka hh lf b fi lt lq l lr ls">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="8bfb" class="lo ka hh lf b fi lt lq l lr ls">// The curried version of trace()<br/>// saves us from writing all this code...<br/>const traceAfterG = value =&gt; {<br/>  const label = 'after g';<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span><span id="d92b" class="lo ka hh lf b fi lt lq l lr ls">const g = n =&gt; n + 1;<br/>const f = n =&gt; n * 2;</span><span id="656d" class="lo ka hh lf b fi lt lq l lr ls">const h = pipe(<br/>  g,<br/>  traceAfterG,<br/>  f,<br/>  trace('after f'),<br/>);</span><span id="dce7" class="lo ka hh lf b fi lt lq l lr ls">h(20);</span></pre><h1 id="3558" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="176f" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated"><strong class="iz hi">简化函数</strong>是一个一次接受多个参数的函数，通过接受第一个参数，并返回一系列函数，每个函数接受下一个参数，直到所有参数都已固定，并且函数应用程序可以完成，此时返回结果值。</p><p id="c33c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">部分应用</strong>是一个已经被应用到它的一些——但不是全部——参数的函数。已经应用了该函数的自变量被称为<em class="iy">固定参数</em>。</p><p id="c4d2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">无点风格</strong>是一种不参考参数定义函数的方式。通常，通过调用返回函数的函数来创建无点函数，例如curried函数。</p><p id="78b3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">规约函数非常适合函数合成，</strong>因为它们允许您轻松地将一个n元函数转换为函数合成管道所需的一元函数形式:管道中的函数必须正好有一个参数。</p><p id="d45d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">数据最后函数</strong>便于函数组合，因为它们可以方便地以无点方式使用。</p><blockquote class="it iu iv"><p id="5c2a" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="hh">买书</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc"> <em class="hh">索引</em></a><em class="hh">|</em><a class="ae jv" rel="noopener" href="/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99"><em class="hh">&lt;上一张</em></a><em class="hh">|</em><em class="hh">下一张&gt; </em> </p></blockquote><h1 id="bc7f" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">在EricElliottJS.com了解更多信息</h1><p id="5484" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">EricElliottJS.com会员可以参加互动代码挑战视频课程。如果你还不是会员，今天就注册吧。</p></div><div class="ab cl lu lv go lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ha hb hc hd he"><p id="5fe0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"><em class="iy">Eric Elliott</em></strong><em class="iy">是一位分布式系统专家，著有《编写软件》</em><a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"><em class="iy"/></a><em class="iy"/><a class="ae jv" href="https://ericelliottjs.com/product/programming-javascript-applications-ebook/" rel="noopener ugc nofollow" target="_blank"><em class="iy">【编程JavaScript应用】</em> </a> <em class="iy">等书籍。作为</em><a class="ae jv" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em><strong class="iz hi"><em class="iy">【Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">【华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC、</em> </strong> <em class="iy">等顶级录音艺术家提供软件体验</em></p><p id="3135" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>