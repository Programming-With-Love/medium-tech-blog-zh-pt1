<html>
<head>
<title>Kotlin Coroutines on Android: Things I Wish I Knew at the Beginning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的Kotlin协同程序:我希望一开始就知道的事情</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/kotlin-coroutines-on-android-things-i-wish-i-knew-at-the-beginning-c2f0b1f16cff?source=collection_archive---------0-----------------------#2018-04-22">https://medium.com/capital-one-tech/kotlin-coroutines-on-android-things-i-wish-i-knew-at-the-beginning-c2f0b1f16cff?source=collection_archive---------0-----------------------#2018-04-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2a218c76884fb9f89f0303bc70d57198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luSIFGB_qQ33DaVg-rlghA.jpeg"/></div></div></figure><p id="bf4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协程是Kotlin的一个伟大的新特性，它允许您以顺序的方式编写异步代码。与任何新的异步解决方案一样，都有一个学习曲线。但在我看来，没有像RxJava那样陡峭。然而，像RxJava一样，协程有许多细微之处，您最终会在开发期间自己学会，或者从其他人那里学到一些技巧。</p><p id="f84e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的团队已经使用协程几个月了，总的来说这是一次美妙的经历。我想写下我们一路上学到的一些东西，如果我们在旅程开始时就知道，就会导致我们做出一些不同的架构决策，并减少一些调试难题。</p><p id="ab96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你是第一次使用协同程序，我强烈建议你仔细阅读罗曼·埃利扎罗夫在KotlinConf 2017上的演讲，并阅读GitHub官方页面上的主要指南:</p><ul class=""><li id="42d5" class="jp jq hh ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">Coroutines @ KotlinConf<br/>T3】https://www.youtube.com/watch?v=_hfBv0a09Jc简介</li><li id="e5cb" class="jp jq hh ir b is jz iw ka ja kb je kc ji kd jm ju jv jw jx bi translated">深入研究JVM @ KotlinConf上的协程:<br/><a class="ae jy" href="https://www.youtube.com/watch?v=YrrUCSi72E8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=YrrUCSi72E8</a></li><li id="74c4" class="jp jq hh ir b is jz iw ka ja kb je kc ji kd jm ju jv jw jx bi translated">主GitHub指南:<br/><a class="ae jy" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/kot Lin/kot linx . coroutines/blob/master/coroutines-guide . MD</a></li></ul><p id="4fc3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从我们开始使用以来，GitHub协程指南已经更新了很多次，并且包括了一些我们自己学到的内容。一旦你对协程有了感觉，通读问题列表<a class="ae jy" href="https://github.com/Kotlin/kotlinx.coroutines/issues" rel="noopener ugc nofollow" target="_blank">也是有帮助的，因为维护人员已经非常积极地以一种非常有教育意义的方式回应(和添加)它们。</a></p><h1 id="df81" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">名单</h1><p id="7eae" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated"><strong class="ir hi"> <em class="lh">更新:</em> </strong> <em class="lh">自本文撰写以来，该列表中的许多项目都发生了变化或演变。自从我们最初集成到1.0之前的版本/实验版以来，协程已经走过了漫长的道路！</em></p><h2 id="3654" class="li kf hh bd kg lj lk ll kk lm ln lo ko ja lp lq ks je lr ls kw ji lt lu la lv bi translated">您可以将执行器转换为协同调度器</h2><p id="4e81" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">执行器通常用作管理各种线程池的一种方式。如果您正在将协程集成到现有的应用程序中，您可能需要一种重用现有池的方法。幸运的是，协程依赖在执行器上添加了一个方便的扩展函数，您可以将它们转换成协程调度器:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="5019" class="li kf hh mb b fi mf mg l mh mi">val executorService = Executors.newFixedThreadPool(100)<br/>val coroutineDispatcher = executorService.<em class="lh">asCoroutineDispatcher</em>()<br/><br/><em class="lh">launch </em>(coroutineDispatcher) <strong class="mb hi">{<br/>  </strong>// ...<br/><strong class="mb hi">}</strong></span></pre><p id="0943" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android上，这对于将AsyncTask线程池转换为dispatcher来允许Espresso测试在您的协程上等待也非常有用:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="0192" class="li kf hh mb b fi mf mg l mh mi"><em class="lh">launch </em>(AsyncTask.<em class="lh">THREAD_POOL_EXECUTOR</em>.<em class="lh">asCoroutineDispatcher</em>()) <strong class="mb hi">{<br/>  </strong>// ...<br/><strong class="mb hi">}</strong></span></pre><p id="6652" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我建议将您喜欢的调度程序保存在类似匕首图的东西中，以便您可以根据您的情况来交换它们。</p><h2 id="6d95" class="li kf hh bd kg lj lk ll kk lm ln lo ko ja lp lq ks je lr ls kw ji lt lu la lv bi translated">您可以创建一个“根”协程父级</h2><p id="0010" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated"><strong class="ir hi"> <em class="lh">更新:</em> </strong> <em class="lh">这个现在换成了</em> <a class="ae jy" href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#coroutine-scope" rel="noopener ugc nofollow" target="_blank"> <em class="lh">范围界定</em> </a> <em class="lh">！</em></p><p id="73cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您习惯于使用RxJava并通过单个对象管理可处置资源，那么在协程中也有一个等效的方法，即创建一个空白父作业并将其用于多个协程:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="e96a" class="li kf hh mb b fi mf mg l mh mi">val rootParent = <em class="lh">Job</em>()<br/><br/>fun foo() {<br/>  <em class="lh">launch</em>(<em class="lh">UI</em>, parent = rootParent) <strong class="mb hi">{<br/>    </strong>// ...<br/>  <strong class="mb hi">}<br/></strong>}<br/><br/>fun bar() {<br/>  <em class="lh">launch</em>(CommonPool, parent = rootParent) <strong class="mb hi">{<br/>    </strong>// ...<br/>  <strong class="mb hi">}<br/></strong>}<br/><br/>fun destroy() { rootParent.cancel() }</span></pre><p id="a1d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你想取消所有的下游子节点时，你可以只取消你的根父节点，假设所有的子节点都是可协同取消的，它们将会自动清除。</p><h2 id="27bc" class="li kf hh bd kg lj lk ll kk lm ln lo ko ja lp lq ks je lr ls kw ji lt lu la lv bi translated">公共池的大小非常有限</h2><p id="4da3" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">如果在启动协程时没有指定调度程序，那么CommonPool就是当前的“默认”调度程序。它<em class="lh">还</em>包装了一个numProcessors-1大小的线程池(最小为1)，如<a class="ae jy" href="https://github.com/Kotlin/kotlinx.coroutines/blob/eb98bc8e84db9ed620cba9d88384244dea92d002/core/kotlinx-coroutines-core/src/main/kotlin/kotlinx/coroutines/experimental/CommonPool.kt#L56" rel="noopener ugc nofollow" target="_blank">源代码</a>所示:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="109b" class="li kf hh mb b fi mf mg l mh mi">private fun createPlainPool(): ExecutorService {<br/>    val threadId = AtomicInteger()<br/>    return Executors.newFixedThreadPool(defaultParallelism()) <strong class="mb hi">{<br/>        </strong>Thread(it, "CommonPool-worker-${threadId.incrementAndGet()}").apply <strong class="mb hi">{ </strong>isDaemon = true <strong class="mb hi">}<br/>    }<br/></strong>}<br/><br/>private fun defaultParallelism() = (Runtime.getRuntime().availableProcessors() - 1).coerceAtLeast(1)</span></pre><p id="a493" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据你的Android应用支持的API等级，这可能是一个真正的问题。有相当多的旧设备型号是单核或双核的，这意味着公共池的大小只有1。如果你习惯于AsyncTask线程池，这也是<em class="lh">不同的</em>，async task线程池最少有<a class="ae jy" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/0c4f6fffd60c832d06cbbccfeac7b3f15d8a751e/core/java/android/os/AsyncTask.java#L183-L187" rel="noopener ugc nofollow" target="_blank">两个线程</a>。</p><p id="ebed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据您的应用程序对协程的处理，这可能会导致特定于设备的死锁问题，这是一个很难调试的问题。</p><p id="4ea4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，这个修复并不太糟糕——当没有达到最小线程数要求时，您可以创建自己的线程池，并把它放在一个集中的地方。例如，以下将使用CommonPool，但在双核或单核设备上除外，在这种情况下将使用大小为2的单独线程池:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="b67d" class="li kf hh mb b fi mf mg l mh mi">val backgroundPool: CoroutineDispatcher by <em class="lh">lazy </em><strong class="mb hi">{<br/>  </strong>val numProcessors = Runtime.getRuntime().availableProcessors()<br/>  when {<br/>    numProcessors &lt;= 2 -&gt; <em class="lh">newFixedThreadPoolContext</em>(2, "background")<br/>    else -&gt; CommonPool<br/>  }<br/><strong class="mb hi">}</strong></span></pre><p id="be60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你也可以选择完全抛弃公共池，一直使用你自己的。正如我前面提到的，如果您将首选的协程调度程序集中在某个地方，并将其注入到您的应用程序中，以后就很容易切换出来。</p><h2 id="e6e3" class="li kf hh bd kg lj lk ll kk lm ln lo ko ja lp lq ks je lr ls kw ji lt lu la lv bi translated">如果不小心的话，异步可能会“吞下”异常</h2><p id="8284" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">如果在一个<em class="lh">异步</em>块中抛出一个异常，这个异常实际上并没有立即抛出。相反，它会在你调用wait 的时候抛出。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="0624" class="li kf hh mb b fi mf mg l mh mi">// This won't crash...<br/>val deferred = <em class="lh">async </em><strong class="mb hi">{<br/>  </strong>throw Exception("Something failed")<br/><strong class="mb hi">}<br/><br/></strong><em class="lh">launch </em><strong class="mb hi">{<br/>  </strong><em class="lh">delay</em>(5000)<br/>  // ... until 5  seconds have elapsed and we call await()<br/>  deferred.await()<br/><strong class="mb hi">}</strong></span></pre><p id="5eef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您忘记调用await()或者它在一个被遗漏的代码分支中，那么异常就被有效地吞掉了(这可能是也可能不是一件坏事)。</p><p id="d5b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的建议是，除非您的特定用例需要，否则不要使用异步(或者，至少要意识到这种行为)。协程的好处在于，您或多或少可以编写顺序异步代码，因此通常不需要使用面向未来的编码。</p><p id="ade3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，这可能也是您感兴趣的一个特性——将异常处理推迟到以后。</p><h2 id="dd95" class="li kf hh bd kg lj lk ll kk lm ln lo ko ja lp lq ks je lr ls kw ji lt lu la lv bi translated"><strong class="ak">你可以在一个挂起函数</strong>中获得对周围协同上下文的引用</h2><p id="14a3" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated"><strong class="ir hi"> <em class="lh">更新:</em> </strong> <em class="lh">感谢</em> <a class="jn jo ge" href="https://medium.com/u/9862bd834329?source=post_page-----c2f0b1f16cff--------------------------------" rel="noopener" target="_blank"> <em class="lh">路易CAD </em> </a> <em class="lh">告诉我这个特性现在已经可以在Kotlin标准库中使用了</em><a class="ae jy" href="https://github.com/JetBrains/kotlin/blob/v1.2.30/libraries/stdlib/src/kotlin/coroutines/experimental/CoroutinesLibrary.kt#L108" rel="noopener ugc nofollow" target="_blank"><em class="lh">1 . 2 . 30</em></a><em class="lh">！</em></p><p id="eedc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您可以简单地在挂起函数中引用<code class="du mj mk ml mb b">coroutineContext</code>来访问当前协程的上下文。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="9b66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢上面的说明，你可以更新到Kotlin 1.2.30，但下面是旧的解决方案，并对问题进行了解释，以防对任何人有所帮助。</p><p id="9fff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协同取消协程要求您在协程之间建立父子关系:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="630c" class="li kf hh mb b fi mf mg l mh mi"><em class="lh">launch </em><strong class="mb hi">{<br/>  </strong><em class="lh">launch </em>(coroutineContext) <strong class="mb hi">{<br/>    </strong>// Now the inner coroutine will cancel with the outer coroutine<br/>  <strong class="mb hi">}<br/>}</strong></span></pre><p id="50b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是如果你有这样的情况呢:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="5ad0" class="li kf hh mb b fi mf mg l mh mi">fun foo() {<br/>  <em class="lh">launch </em><strong class="mb hi">{ <br/>    </strong>bar()<br/>  <strong class="mb hi">}<br/></strong>}<br/><br/>suspend fun bar() {<br/>  <em class="lh">launch </em><strong class="mb hi">{<br/>    </strong>// ...<br/>  <strong class="mb hi">}<br/></strong>}</span></pre><p id="fef8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">取消foo的协同程序不会取消bar的。相反，您必须实际传递CoroutineContext或parent-to-use作为参数，这不是很好:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="ddf0" class="li kf hh mb b fi mf mg l mh mi">fun foo() {<br/>  <em class="lh">launch </em><strong class="mb hi">{<br/>    </strong>bar(coroutineContext)<br/>  <strong class="mb hi">}<br/></strong>}<br/><br/>suspend fun bar(coroutineContext: CoroutineContext) {<br/>  <em class="lh">launch</em>(coroutineContext) <strong class="mb hi">{<br/>    </strong>// ...<br/>  <strong class="mb hi">}<br/></strong>}</span></pre><p id="2c0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，目前有一个公开的问题，增加了从挂起函数中轻松获取上下文的支持:<br/><a class="ae jy" href="https://youtrack.jetbrains.com/issue/KT-17609" rel="noopener ugc nofollow" target="_blank">https://youtrack.jetbrains.com/issue/KT-17609</a></p><p id="74e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前，您可以使用以下解决方法:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="ef3d" class="li kf hh mb b fi mf mg l mh mi">import kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn</span><span id="f02e" class="li kf hh mb b fi mt mg l mh mi">suspend fun coroutineContext(): CoroutineContext =   <br/>  <em class="lh">suspendCoroutineOrReturn </em><strong class="mb hi">{ </strong>cont <strong class="mb hi">-&gt; </strong>cont.context <strong class="mb hi">}</strong></span></pre><p id="ead8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像这样使用它:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="1b8a" class="li kf hh mb b fi mf mg l mh mi">suspend fun bar() {<br/>  val context = coroutineContext()<br/>  <em class="lh">launch</em>(context) <strong class="mb hi">{<br/>    </strong>// ...<br/>  <strong class="mb hi">}<br/></strong>}</span></pre><p id="ed82" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这可以让你保持你的参数列表的整洁，并且还可以让你很容易地设置取消链！</p><p id="bc07" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协程是Kotlin的一个很棒的新特性，可以帮助您比以往更容易地编写异步代码。我们的团队和他们有过很好的经历，我希望分享一些微妙和技巧也能改善你和他们的经历！</p></div></div>    
</body>
</html>