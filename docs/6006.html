<html>
<head>
<title>Python-oracledb Thin mode Object performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python-oracledb瘦模式对象性能</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/python-oracledb-thin-mode-object-performance-8a230fe2bf4?source=collection_archive---------0-----------------------#2022-11-23">https://medium.com/oracledevs/python-oracledb-thin-mode-object-performance-8a230fe2bf4?source=collection_archive---------0-----------------------#2022-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6460723b72a69ada1e226d95d660c976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H2WgFoYdfKB3n46b"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@nhoizey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Hoizey</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a726" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">访问Oracle对象和集合可能需要在应用程序和数据库之间进行几次“往返”,以收集元数据和进行其他编组。所以对我来说，获取对象比获取简单的标量类型慢并不奇怪。对其他人来说，性能差异是显而易见的，并成为一个话题。我看到的最常见的对象性能问题来自Oracle Spatial的用户，他们正在获取<code class="du js jt ju jv b">MDSYS.SDO_GEOMETRY</code>类型。</p><p id="d29f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Anthony Tuininga和我们的驱动团队刚刚在<a class="ae it" href="https://oracle.github.io/python-oracledb/" rel="noopener ugc nofollow" target="_blank"> python-oracledb </a> 1.2的瘦模式中增加了对Oracle对象和集合的支持。我想将这个新的实现与传统的胖模式(使用Oracle客户端库)进行比较。</p><p id="a3fa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于已经有了一个来自之前调查的带有<code class="du js jt ju jv b">SDO_GEOMETRY</code>列的数据集，我很快就能够编写一个简单的脚本来实现<code class="du js jt ju jv b">"select geometry from t where rownum &lt;= :n"</code>。我添加了一些计时和往返计数代码，并在我的笔记本电脑上用VirtualBox中运行的“本地”Oracle Database 23c Beta实例运行了一次。代表性的结果是:</p><pre class="jw jx jy jz fd ka jv kb bn kc kd bi"><span id="a146" class="ke kf hh jv b be kg kh l ki kj">$ python objperf.py <br/>Thin mode: rows=190000 arraysize=1000 roundtrips=199 seconds=2.65<br/><br/>$ DRIVER_TYPE=thick python objperf.py <br/>Thick mode: rows=190000 arraysize=1000 roundtrips=216 seconds=6.02</span></pre><p id="13a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这对于瘦模式来说非常好。</p><p id="c030" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">无论我获取了多少行，往返行程的减少都是恒定的。这只是反映了两种模式的初始元数据收集差异。在通过网络开始获取数据后，内部驱动程序处理会带来好处。无论有多少行，瘦模式的大约两倍的性能似乎都保持不变。当我将数据集放在一台非常远程的机器上时，这一点也很明显:</p><pre class="jw jx jy jz fd ka jv kb bn kc kd bi"><span id="3051" class="ke kf hh jv b be kg kh l ki kj">$ python objperf.py <br/>Thin mode: rows=3000 arraysize=1000 roundtrips=12 seconds=10.15<br/><br/>$ DRIVER_TYPE=thick python objperf.py <br/>Thick mode: rows=3000 arraysize=1000 roundtrips=29 seconds=19.66</span></pre><p id="f0fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总的来说，我们真的很高兴能够通过python-oracledb瘦模式为您带来这种性能提升。</p><p id="081b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，在处理对象时，其他一些通用的性能技巧包括保留从<code class="du js jt ju jv b">connection.gettype()</code>中显式检索的元数据，因为这将需要几次往返来获取对象元数据。也许您可以在SQL语句中提取对象属性，并将其作为标量类型返回，这样就不会有对象提取了。或者您可以在数据库中完成所有的处理，例如在PL/SQL中？在某些慢速网络的情况下，使用具有大量属性的对象，您也许能够将查询中的对象字符串化，然后在应用程序中重新组合它们？如果不需要优化到第n次(原谅空间双关)，那就忽略这一切，直接简单的取对象。</p></div></div>    
</body>
</html>