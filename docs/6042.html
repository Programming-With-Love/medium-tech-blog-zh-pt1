<html>
<head>
<title>Serving configuration data at scale with high availability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以高可用性提供大规模配置数据</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/serving-configuration-data-at-scale-with-high-availability-8612521c1108?source=collection_archive---------2-----------------------#2015-03-06">https://medium.com/pinterest-engineering/serving-configuration-data-at-scale-with-high-availability-8612521c1108?source=collection_archive---------2-----------------------#2015-03-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="529c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pavan Chitumalla和Jiacheng Hong | Pinterest工程师，基础设施</p><p id="a75f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有许多重要和常见的数据，这些数据不经常修改，但访问频率非常高。一个例子是我们的垃圾邮件域黑名单。因为我们不想向Pinners显示垃圾Pin，所以在呈现Pin时，我们的app/API服务器需要对照域黑名单检查Pin的域。这只是一个例子，但是每秒钟有几十万个Pin请求，这就产生了对这个列表的巨大访问需求。</p><h2 id="0ddc" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">存在的问题</h2><p id="4a94" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">以前，我们将这种列表存储在一个<a class="ae kc" href="http://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>排序的集合中，这个集合为我们提供了一个简单的访问来保持列表结构的时间排序顺序。我们还有一个本地内存和基于文件的缓存，通过轮询Redis主机的任何更新来保持同步。一开始一切都很顺利，但是随着服务器数量和列表大小的增长，我们开始看到网络饱和的问题。在列表更新后的五分钟内，所有服务器都试图从单个Redis主服务器下载最新的数据副本，导致Redis主服务器上的网络饱和，并导致大量Redis连接错误。</p><p id="8768" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们确定了几个潜在的解决方案:</p><ol class=""><li id="b334" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">将此数据的下载分散到更长的时间段。但是对于我们的用例，我们希望更新最多在几分钟内收敛。</li><li id="5d98" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">分割数据。不幸的是，由于这个数据是一个单一的列表，分割它会增加更多的复杂性。</li><li id="f89c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">复制这些数据。使用一个Redis主服务器和多个Redis从服务器来存储这些数据，并随机选择一个从服务器进行读取。然而，我们对Redis复制没有信心(我们运行的是2.6版)。此外，由于客户端缓存，这些Redis框在大部分时间(当数据没有更新时)都是空闲的，因此成本效益不高。</li></ol><h2 id="db35" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">解决办法</h2><p id="f32b" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">由于上述每个解决方案都有自己的缺点，我们问自己，如果我们从头开始构建，我们将如何设计解决方案？</p><p id="7ac8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">形式化问题的要求:</p><ul class=""><li id="b4d6" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb kr kj kk kl bi translated">频繁的读访问(&gt; 100k/秒)和很少的更新(最多一天几次)。</li><li id="59bb" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb kr kj kk kl bi translated">快速(在一分钟内，或最多几分钟内)将更新集中到所有机器上。理想情况下，是基于推送的模型，而不是客户端轮询更新。</li></ul><p id="e21a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们通过组合较小问题的解决方案设计了一个解决方案:</p><ul class=""><li id="5bdb" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb kr kj kk kl bi translated">将数据缓存在内存中，这样高读取访问就不会成为问题。</li><li id="984e" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb kr kj kk kl bi translated">使用<a class="ae kc" href="http://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇动物园管理员</a>作为更新时的通知。</li></ul><p id="dec9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这在概念上类似于<a class="ae kc" href="https://engineering.pinterest.com/post/77933733851/zookeeper-resilience-at-pinterest" rel="noopener ugc nofollow" target="_blank"> ZooKeeper resiliency，</a>的设计，但是如果我们将全部数据存储在一个ZooKeeper节点中，它仍然会在更新期间导致ZooKeeper节点上的网络流量出现巨大的峰值。由于ZooKeeper是分布式的，负载将分布在多个ZooKeeper节点上。然而，我们不想给动物园管理员增加不必要的负担，因为这是我们基础设施的重要组成部分。</p><p id="da43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们最终达成了一个解决方案，使用ZooKeeper作为通知程序，S3作为存储程序。由于S3提供了非常高的可用性和吞吐量，它似乎非常适合我们吸收突发负载峰值的用例。我们称这个解决方案为管理列表，也就是config v2。</p><h2 id="9e81" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">工作中的配置v2</h2><p id="e3e7" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">Config v2充分利用了我们已经完成的工作，只是真实的来源在S3。此外，我们添加了逻辑来避免并发更新和处理S3最终一致性。我们在ZooKeeper节点中存储了一个版本号(实际上是一个时间戳),它也是S3路径的后缀，用于标识当前数据。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es ks"><img src="../Images/fb6c14f6ddf12ed546a2ca3f5a03f980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*E3IJhR5VRCCxJ84I.png"/></div></figure><p id="beec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果需要修改托管列表的数据，开发人员可以选择通过管理web UI或控制台应用程序来更改它。以下步骤由更新程序应用程序在保存时执行:</p><ul class=""><li id="fd9b" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb kr kj kk kl bi translated">首先，获取一个Zk锁来防止对同一个托管列表的并发写入。</li><li id="8f20" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb kr kj kk kl bi translated">然后，将旧数据与S3的数据进行比较，如果匹配，只将新数据上传到S3——比较并交换更新。这可以防止前一次更新收敛时出现脏写。</li><li id="8585" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb kr kj kk kl bi translated">最后，将版本写入Zk节点，释放Zk锁。</li></ul><p id="e486" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Zk节点的值一更新，ZooKeeper就通知它所有的观察者。在这种情况下，触发所有服务器上的守护进程从S3下载数据。</p><h2 id="fa4f" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">我们如何应对S3的一致性模型</h2><p id="66d1" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">亚马逊的S3即使在重负载下也能提供很好的可用性和耐用性保证，但它最终是一致的。我们需要的是“写后读”的一致性。幸运的是，它确实在某些区域提供了“创建后读取”的一致性*。我们为每次写入创建一个新文件，而不是更新同一个S3文件。然而，这带来了在所有节点上同步新的S3文件名的新问题。我们通过使用ZooKeeper在所有节点上保持文件名同步来解决这个问题。</p><h2 id="523e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">介绍决定者</h2><p id="2080" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">当一个新的特性或服务准备好发布时，我们会逐渐增加新代码路径中的流量，并在全部投入之前检查以确保一切正常。这导致需要构建一个交换机，允许开发人员决定应该向新功能发送多少流量。此外，这种流量提升工具(又名“决策器”)应该足够灵活，以便开发人员可以添加新的实验和更改现有实验的值，而无需重新部署到整个车队。此外，任何变更都应该在整个车队中快速可靠地聚合。</p><h2 id="c732" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">早期解决方案</h2><p id="4c6c" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">每个实验都是一个ZooKeeper节点，并且有一个值[0–100 ],可以从web UI控制。当值在web UI中被更改时，它在相应的节点中被更新，ZooKeeper负责更新所有的观察器。虽然这种解决方案有效，但它受到了我们之前遇到的<a class="ae kc" href="https://engineering.pinterest.com/post/77933733851/zookeeper-resilience-at-pinterest" rel="noopener ugc nofollow" target="_blank">相同的扩展问题</a>的困扰，因为整个车队都直接连接到ZooKeeper。</p><p id="9535" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的Decider框架由两个组件组成:一个基于web的管理UI来控制实验，一个库(Python和Java版本)可以插入到需要分支控制的地方。</p><h2 id="afcc" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">当前解决方案</h2><p id="7ab4" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">一旦我们意识到<em class="la">托管列表</em>的好处，我们就构建<em class="la">托管散列表</em>，并迁移包含实验的所有Zk节点的值。本质上，底层托管hashmap文件内容是哈希表的json转储，其中包含作为键的实验名称和作为值的整数[0–100]。</p><h2 id="21b5" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">应用程序接口</h2><pre class="kt ku kv kw fd lb lc ld le aw lf bi"><span id="1b89" class="jc jd hh lc b fi lg lh l li lj">def decide_expermiment(experiment_name):<br/>    return random.randrange(0, 100, 1)</span></pre><p id="0db7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如何在代码中使用它:</p><pre class="kt ku kv kw fd lb lc ld le aw lf bi"><span id="afc7" class="jc jd hh lc b fi lg lh l li lj">if decide_experiment("my_rocking_experiment"):<br/>    // new code<br/>else<br/>    // existing code</span></pre><h2 id="f547" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">Decider的另一个用例:暗读和暗写</h2><p id="fedc" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">当我们复制生产读或写请求并将其发送给新服务时，我们使用术语“暗读”和“暗写”。我们称之为黑暗，因为无论成功还是失败，来自新服务的响应都不会影响原始代码路径。如果需要异步行为，那么我们在gevent.spawn()中包装新的代码路径。</p><p id="3470" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是黑暗阅读的代码片段:</p><p id="6e3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尝试:</p><pre class="kt ku kv kw fd lb lc ld le aw lf bi"><span id="6111" class="jc jd hh lc b fi lg lh l li lj">if decider.decide_experiment("dark_read_for_new_service"):<br/>        new_service.foo()<br/>except Exception as e:<br/>    log.info("new_service.foo exception: %s" % e)</span></pre><p id="79a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">*在S3因最终一致性而返回“文件未找到”的罕见情况下，守护程序被设计为每30分钟刷新一次所有内容，这些节点最终会跟上。到目前为止，我们还没有看到任何节点不同步超过几分钟的情况。</em></p><p id="aa50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对这样的工程挑战感兴趣，<a class="ae kc" href="https://about.pinterest.com/en/careers/engineering-product" rel="noopener ugc nofollow" target="_blank">加入我们的团队</a>！</p><p id="2fd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la"> Pavan Chitumalla和Jiacheng Hong是基础设施团队的软件工程师。</em></p><p id="40cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">获取Pinterest工程新闻和更新，关注我们的工程</em><a class="ae kc" href="https://www.pinterest.com/malorie/pinterest-engineering-news/" rel="noopener ugc nofollow" target="_blank"><em class="la">Pinterest</em></a><em class="la">，</em> <a class="ae kc" href="https://www.facebook.com/pinterestengineering" rel="noopener ugc nofollow" target="_blank"> <em class="la">脸书</em> </a> <em class="la">和</em><a class="ae kc" href="https://twitter.com/PinterestEng" rel="noopener ugc nofollow" target="_blank"><em class="la">Twitter</em></a><em class="la">。有兴趣加入团队吗？查看我们的</em> <a class="ae kc" href="https://about.pinterest.com/en/careers/engineering-product" rel="noopener ugc nofollow" target="_blank"> <em class="la">招聘网站</em> </a> <em class="la">。</em></p></div></div>    
</body>
</html>