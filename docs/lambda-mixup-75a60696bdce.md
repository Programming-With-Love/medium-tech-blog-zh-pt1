# λ混合

> 原文：<https://blog.kotlin-academy.com/lambda-mixup-75a60696bdce?source=collection_archive---------1----------------------->

![](img/9ab7dd0e0957f881f8b7497aaf88001f.png)

对于我们这些使用 [SonarQube](https://www.sonarqube.org/) 在 CI 上检查代码的人来说，对 Kotlin 的官方支持最近终于到来，我们开始在我们的服务器上部署它的最新版本。但是，当我查看我们第一份报告中的警告并试图快速修复其中一些警告时，我遇到了一个关于我的 lambdas 的令人困惑的情况。

假设你有一个函数`foo`，它有两个参数，这两个参数都有默认值。它可能看起来像这样:

```
fun foo(lambda1: () -> Unit = {}, lambda2: () -> Unit = {}) {
    lambda1()
    println("----")
    lambda2()
}
```

这个函数应该执行它的两个参数函数，并在它们之间打印一些破折号。例如，如果我们这样称呼它:

```
foo({ println("1") }, { println("2") })
```

结果应该是:

```
1
----
2
```

但是现在，如果我只用一个参数调用这个函数会发生什么？它是在破折号打印之前还是之后执行？

事实证明，这要视情况而定。假设我这样称呼它:

```
foo({ println("A") })
```

结果将是:

```
A
----
```

这正是我所期待的。我只给了一个参数，没有命名，所以 Kotlin 正确地假设它是函数签名中的第一个参数。但是如果我在代码中写下这一行，SonarQube 会建议我利用一个很好的 Kotlin 技巧，将 lambda 从括号中移除。所以让我们试试，把代码改成这样:

```
foo { println("A") }
```

让我们运行它:

```
----
A
```

显然，删除括号改变了我们代码的行为。这是为什么呢？

嗯，问题来自于我们刚刚使用的语法糖(将一个 lambda 移出括号)只适用于函数签名中的最后一个 lambda。在我们的例子中，它是第二个λ。所以 Kotlin 现在假设我们提供的参数，在括号之外，是我们的第二个(也是最后一个)参数，并在破折号之后执行它。

毫无疑问，这是一个极限情况，但是如果你在代码中使用 RxJava，你可能有一些对 subscribe 方法的调用需要两个或三个 lambda(`onNext`、`onComplete`或`onError`事件的回调),把它们封装在一个有可选参数的函数中是很诱人的，这样如果你没有为某些类型的事件(特别是错误事件)提供处理程序，你就不会冒异常的风险。只是要注意，在函数中使用几个 lambdas 可能有点棘手！

在这种情况下，手动重载函数可能是明智的。例如，您可以选择声明以下单独的方法:

```
fun foo(lambda1: () -> Unit = {}) = foo(lambda1) {}
fun foo(lambda1: () -> Unit, lambda2: () -> Unit) {...}
```

在这种情况下，你可以用零个、一个或两个参数调用你的函数，用一个 lambda 调用`foo()`总是会得到相同的结果，不管你用不用括号。然而，代价是不能只使用第二个参数来调用它。

只有你能判断这是否可以接受。如果您只需要使用第一个或第二个参数进行调用，您可能最好保持原始语法，并始终使用命名参数来确保哪个参数应该接收 lambda 表达式是显而易见的。

所以下一次 SonarQube 告诉你把一个 lambda 移出括号时，在遵从之前要三思。花时间仔细检查代码中的这个微小变化不会有任何意想不到的副作用，这肯定会让您省去一些麻烦。

你需要 Kotlin 工作室吗？请访问我们的网站,看看我们能为您做些什么。

了解卡帕头最新的重大新闻。学院、[订阅时事通讯](https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&id=d2ba84960a)、[观察推特](https://twitter.com/ktdotacademy)并在媒体上关注。

[![](img/5ce68714efe3efc036e06786166954ff.png)](http://eepurl.com/diMmGv)