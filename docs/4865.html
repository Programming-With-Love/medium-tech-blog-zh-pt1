<html>
<head>
<title>How Kotlin makes editing your Gradle build less frustrating</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin如何让编辑你的Gradle build不那么令人沮丧</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/gradle-kotlin-the-missing-piece-of-the-puzzle-7528a85f0d2c?source=collection_archive---------0-----------------------#2018-10-10">https://blog.kotlin-academy.com/gradle-kotlin-the-missing-piece-of-the-puzzle-7528a85f0d2c?source=collection_archive---------0-----------------------#2018-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3aa3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过<a class="ae kc" href="https://github.com/jmfayard/buildSrcVersions" rel="noopener ugc nofollow" target="_blank">Gradle builds版本</a>更好的依赖管理</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/8c7b0e5074ab821a52b08757447a29af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaD989bFWN5_E4tUN9_46Q.png"/></div></div></figure><p id="ba91" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">朋友们好，我现在正从阿姆斯特丹和一个<a class="ae kc" href="https://kotlinconf.com/" rel="noopener ugc nofollow" target="_blank">科特林康夫2018 </a>飞回来，我真的很喜欢。</p><p id="aa79" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">特别是与Gradle Kotlin-DSL  的对话<strong class="kr io"> </strong> <a class="ae kc" href="https://eskatos.github.io/kotlinconf2018-type-safe-build-logic/#/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">类型安全构建逻辑给了我灵感，让我写了一个我最近一直非常喜欢的主题，甚至启动了一个在我脑海深处的IMHO整洁的小项目</strong></a></p><div class="ll lm gp gr ln lo"><a href="https://github.com/jmfayard/buildSrcVersions" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">jmfayard/buildSrcVersions</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">Gradle buildSrcVersions -无痛依赖管理- jmfayard/buildSrcVersions</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc kn lo"/></div></div></a></div><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk"><a class="ae kc" href="https://www.useloom.com/share/7edceb83fd594f319356240fcce304d5" rel="noopener ugc nofollow" target="_blank">https://www.useloom.com/share/7edceb83fd594f319356240fcce304d5</a></figcaption></figure><h1 id="3a98" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">一份供词</h1><p id="79dc" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">了解我的人可能会感到惊讶，我即将写关于和赞扬格雷德尔。我经常表达我和格拉德的爱恨情仇。</p><p id="9c03" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">很多人都在关注Gradle性能的话题(实际上是Android构建工具的<br/>)。在这方面也做了大量的工作(据我所知，很快还会有更多的工作)，但是我想在这里把重点放在问题的后半部分。</p><blockquote class="ng"><p id="596b" class="nh ni in bd nj nk nl nm nn no np lk dk translated"><strong class="ak">维护这些build.gradle文件可能会变得非常繁琐… </strong></p></blockquote><p id="dcd7" class="pw-post-body-paragraph kp kq in kr b ks nq jo ku kv nr jr kx ky ns la lb lc nt le lf lg nu li lj lk ig bi translated">Gradle的优点是它为表带来了强大的功能和灵活性，构建文件具有很强的声明性，易于阅读。</p><p id="89ce" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是随着强大的能力而来的是对强大工具的需求……或者是令人沮丧的用户体验。</p><p id="395c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这就是格雷尔的阴暗面。虽然<code class="fe nv nw nx ny b">build.gradle</code>文件很容易被<strong class="kr io">读取</strong>，但是它们很难被<strong class="kr io">写入</strong>。当你需要定制它们的时候，大部分都是靠自己。通常一段时间都不行，你也不知道为什么。然后在某个时候，你复制粘贴了正确的解决方案，它起作用了，但是你也不知道为什么。</p><p id="e76e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">实际情况是，Groovy的动态特性与Gradle中完成的所有元编程结合得很差，给了我们很差的工具支持。</p><p id="2ce9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">好了，这就是Gradle和JetBrains一直在默默研究的<a class="ae kc" href="https://github.com/gradle/kotlin-dsl" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> kotlin-dsl </strong> </a>项目的背景。<a class="ae kc" href="https://blog.gradle.org/gradle-kotlin-dsl-release-candidate" rel="noopener ugc nofollow" target="_blank">快要到成熟期了</a>，现在是关注话题的好时机。</p><h1 id="eb48" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">如何迁移</h1><p id="53ca" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated"><a class="ae kc" href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/" rel="noopener ugc nofollow" target="_blank">将构建逻辑从Groovy迁移到Kotlin </a>提到了两种可能的策略</p><ol class=""><li id="dece" class="nz oa in kr b ks kt kv kw ky ob lc oc lg od lk oe of og oh bi translated"><em class="oi">将现有的语法一点一点地移植到Kotlin，同时保留结构——我们称之为机械移植</em></li><li id="3d73" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated"><em class="oi">朝着Gradle最佳实践重组您的构建逻辑，并切换到Kotlin DSL作为这项工作的一部分</em></li></ol><p id="98d6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">对于我们现有的项目，后者通常更有意义。<br/>有一个故事说，很多C程序员就是从这一小步开始做C++的。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="oo me l"/></div></figure><p id="7114" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">本着这种精神，我将把重点放在你现在可以与Gradle &amp; Kotlin一起迈出的实际的第一步。</p><h1 id="b31c" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">依赖性管理</h1><p id="882f" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">Gradle允许我们以非常简洁的方式声明依赖关系</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="oo me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk"><a class="ae kc" href="https://gist.github.com/jmfayard/41fcdf1efbaa3ffbea280b4cf9c84f15" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/41fcdf1efbaa3ffbea280b4cf9c84f15</a></figcaption></figure><p id="5e9e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我对这段代码有一些问题:</p><ol class=""><li id="3c1d" class="nz oa in kr b ks kt kv kw ky ob lc oc lg od lk oe of og oh bi translated">编辑魔术字符串是容易出错的。</li><li id="31ce" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">如何集中多模块项目中的依赖关系？</li><li id="f2fe" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">什么是克朗格？</li><li id="3c73" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">有新版本的Okio和RxJava吗？</li></ol><p id="4b7c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">使用Groovy，我们可以用<a class="ae kc" href="https://gist.github.com/gabrielemariotti/ad6672902464ee2392d0" rel="noopener ugc nofollow" target="_blank"> dependencies.gradle模式</a>解决集中化问题。</p><p id="eba5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">对科特林做同样的事情很容易:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="oo me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk"><a class="ae kc" href="https://gist.github.com/jmfayard/71735e8528d7b7883f0c1bc0ed566205" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/71735e8528d7b7883f0c1bc0ed566205</a></figcaption></figure><p id="9044" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">来自<a class="ae kc" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> buildSrc </strong> </a>文件夹的代码自动可用于您所有的<code class="fe nv nw nx ny b">build.gradle</code>或<code class="fe nv nw nx ny b">build.gradle.kts</code>文件。</p><h1 id="f9e5" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">懒惰是程序员的一大优点</h1><p id="9231" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">我已经为几个项目这样做了，一开始我很高兴。在我的第三个项目中，提取所有这些字符串变得很乏味。</p><p id="a107" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">此外，我们还没有解决克兰格尔是什么的问题。有哪些新版本？</p><p id="e0de" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">有一个来自Ben Manes的非常好的插件，<code class="fe nv nw nx ny b"><a class="ae kc" href="https://github.com/ben-manes/gradle-versions-plugin" rel="noopener ugc nofollow" target="_blank">gradle-versions-plugin</a>,</code>曾经应用于你的Gradle项目回答了这个问题。所以作为一个懒惰的程序员，我想知道:我能扩展它来精确地生成我需要的kotlin代码吗？</p><p id="e023" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">事实证明这是可能的，所以让我介绍我的新Gradle插件！</p><h1 id="6293" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">包括Gradle版本</h1><p id="c275" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">在您的top <code class="fe nv nw nx ny b">build.gradle</code>文件中，添加:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="oo me l"/></div></figure><p id="3c80" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这个新的声明插件块是声明插件的首选方式，而不是提供更差的kotlin DSL用户体验的<code class="fe nv nw nx ny b">buildscript {...}</code>语法。</p><h1 id="763a" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">$ ./gradlew buildSrcVersions</h1><p id="9cd4" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">这是您第一次运行的命令，每次您添加一个新的依赖项或者只是想检查有哪些可用的版本。</p><p id="b8d8" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">它首先执行连接到互联网的任务<strong class="kr io"> :dependencyUpdates </strong>，可能需要一段时间。这个任务生成一个<a class="ae kc" href="https://github.com/jmfayard/sample-synclibs/blob/syncLibs/report.json" rel="noopener ugc nofollow" target="_blank"> JSON报告</a>，其中包含关于所有依赖项的元数据，Kotlinpoet 帮助将这些元数据转换成下面的代码。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="oo me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk"><a class="ae kc" href="https://gist.github.com/jmfayard/5c1abb7423333c9bdf335a9c04139969" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/5c1abb7423333c9bdf335a9c04139969</a></figcaption></figure><h1 id="a529" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">IDE集成</h1><p id="f1ca" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">这些生成的代码是我们体验Gradle的<strong class="kr io"> kotlin-dsl </strong>在<strong class="kr io"><em class="oi">IntelliJ IDEA</em></strong><em class="oi">或</em><strong class="kr io"><em class="oi">Android Studio≥3.2</em></strong>中提供的更好的IDE集成所需要的全部</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk"><a class="ae kc" href="https://www.useloom.com/share/7edceb83fd594f319356240fcce304d5" rel="noopener ugc nofollow" target="_blank">https://www.useloom.com/share/7edceb83fd594f319356240fcce304d5</a></figcaption></figure><p id="6184" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们现在已经解决了我们想要解决的问题</p><ol class=""><li id="447d" class="nz oa in kr b ks kt kv kw ky ob lc oc lg od lk oe of og oh bi translated">不再有神奇的字符串，我们键入<code class="fe nv nw nx ny b">Libs.&lt;TAB&gt;</code>，自动完成剩下的工作。</li><li id="762b" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">我们可以在所有的<code class="fe nv nw nx ny b">build.gradle(.kts)</code>文件中使用它们。</li><li id="6d51" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">要发现什么是<a class="ae kc" href="https://github.com/holgerbrandl/krangl" rel="noopener ugc nofollow" target="_blank"> <em class="oi">克朗格</em> </a>，我们按下<code class="fe nv nw nx ny b">&lt;F1&gt; Quick documentation</code>并点击网站链接。</li><li id="e72e" class="nz oa in kr b ks oj kv ok ky ol lc om lg on lk oe of og oh bi translated">要知道哪些新版本可用，我们只需从IDE跳转到<code class="fe nv nw nx ny b">Libs.okio</code>，然后从那里跳转到当前使用的<code class="fe nv nw nx ny b">Libs.Versions.okio.</code> 2.0.0，一条有用的注释告诉我们2.1.0可用。(插件从不自动应用依赖更新，那应该是开发者的工作！！).</li></ol><h1 id="012e" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">试一试</h1><p id="8a31" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">Groovy <code class="fe nv nw nx ny b">build.gradle</code>和Kotlin <code class="fe nv nw nx ny b">build.gradle.kts</code>文件一经编写看起来几乎相似。完全不同的是它的编写体验，所以我会鼓励你火起来<em class="oi"> IntelliJ IDEA </em>或者<em class="oi"> Android Studio≥3.2。</em></p><p id="eef5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我开始坦白我讨厌格雷尔的黑魔法。用科特林打开黑盒非常有用。我意识到Gradle只是一个很好的、有用的、有良好文档记录的API。一个API，您可以像使用任何其他Java API一样使用您的开发人员工具和技能。一个其优点对我们隐藏的API。如果有足够的兴趣，我计划在下面的文章中更深入。</p><h1 id="5647" class="mj mk in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">链接</h1><p id="5eb2" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">格雷尔的迁移指南</p><div class="ll lm gp gr ln lo"><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">将构建逻辑从Groovy迁移到Kotlin</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">如果您想要配置的插件依赖于groovy.lang.Closure的方法签名或者使用其他动态Groovy…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">guides.gradle.org</p></div></div><div class="lx l"><div class="op l lz ma mb lx mc kn lo"/></div></div></a></div><p id="ed46" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe nv nw nx ny b">gradle/kotlin-dsl</code>中的示例是了解事物如何工作的最佳方式之一。</p><div class="ll lm gp gr ln lo"><a href="https://github.com/gradle/kotlin-dsl" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">格雷尔/科特林数字用户线</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">对Gradle构建脚本的Kotlin语言支持。通过在…上创建帐户，为gradle/kotlin-dsl的发展做出贡献</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="oq l lz ma mb lx mc kn lo"/></div></div></a></div><p id="d61f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我的插件</p><div class="ll lm gp gr ln lo"><a href="https://github.com/jmfayard/buildSrcVersions" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">jmfayard/buildSrcVersions</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">Gradle buildSrcVersions -无痛依赖管理- jmfayard/buildSrcVersions</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc kn lo"/></div></div></a></div><p id="4086" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">你需要Kotlin工作室吗？请访问我们的网站,看看我们能为您做些什么。</p></div><div class="ab cl or os hr ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ig ih ii ij ik"><p id="17fb" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">了解卡帕头最新的重大新闻。学院、<a class="ae kc" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>、<a class="ae kc" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi oy"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>