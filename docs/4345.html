<html>
<head>
<title>Companion Objects: Kotlin’s most unassuming power feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">伴侣物品:科特林最谦逊的功能</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/companion-objects-kotlins-most-unassuming-power-feature-fb5c0451fbd0?source=collection_archive---------1-----------------------#2021-02-26">https://medium.com/google-developer-experts/companion-objects-kotlins-most-unassuming-power-feature-fb5c0451fbd0?source=collection_archive---------1-----------------------#2021-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a5a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我认为Kotlin的伙伴对象是语言特性的克拉克·肯特，看起来非常强大，我们可以如何使用它们来创建增强API设计的方法。</p><h1 id="a530" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">TL；速度三角形定位法(dead reckoning)</h1><blockquote class="ka kb kc"><p id="8666" class="ie if kd ig b ih ii ij ik il im in io ke iq ir is kf iu iv iw kg iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">“伴随对象不仅仅是常数和其他静态的占位符；它们允许新的策略来帮助组织我们的代码，或者提供可重用的工厂和验证功能。”</em> </strong></p></blockquote><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/ced41929d2524f65ac148c2bd90af775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcfcDnfH5MzG2k25czvU0g.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Image by Colin Behrens from Pixabay</figcaption></figure></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="07bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Kotlin世界中开发人员热衷的所有特性中，你听说最少的一个是不起眼的<a class="ae le" href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank">伴侣对象</a>。从表面上看，它们只是一个方便的替代品，可以用来放置静态状态。但是，就这样放弃它们是过早地将它们一笔勾销——我们已经为它们发现了几个非常有趣的用例。</p><p id="89c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不相信我？如果你做了，我会失望的😉。让我们看几个简单的例子，都是基于Java的可信的<code class="du lf lg lh li b">LocalDate</code>类。</p><h2 id="d21b" class="lj jd hh bd je lk ll lm ji ln lo lp jm ip lq lr jq it ls lt ju ix lu lv jy lw bi translated">API扩展点</h2><p id="848b" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">伴随对象给我们的一个基本(也可能是最无聊的)能力是作为不断增长的相似主题函数或值集合的扩展点。如果你定义了一个简单的概念或抽象，它将在你的系统中被使用和重用，我鼓励在类/接口定义中增加一个伴随对象。这提供了一个地方来附加与所有场景中的核心概念都不相关的扩展，并避免把水搅浑…想象一下这对一个开发人员(或者你自己写的)来说有多可怕！)遇到一个有二十个功能而不是两个的界面！</p><p id="b0ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这还允许开发人员在您自己的其他部分或另一个代码模块中定义所述抽象的新实现，以便有一个地方来收集/组织它们IDE将选取所有这些扩展并通过自动完成提供给您，而不是将它们分散在代码中。</p><p id="afc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以从下面的例子中看到这一点——我们定义了一个简单的<code class="du lf lg lh li b">Validation</code>谓词，并为它附加了各种扩展函数/实现/属性。注意下面的<code class="du lf lg lh li b">fun interface </code>是Kotlin的一个特性，它将单个函数接口转换成一个<a class="ae le" href="https://www.baeldung.com/java-8-functional-interfaces" rel="noopener ugc nofollow" target="_blank"> Java SAM类型</a>，并允许我们创建一个没有完整声明的接口:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="6947" class="lj jd hh bd je lk ll lm ji ln lo lp jm ip lq lr jq it ls lt ju ix lu lv jy lw bi translated">解析器/工厂</h2><p id="a1b8" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">我们还可以使用伴生对象来提供一个地方，以确保从其他格式中正确构造微类型(如上所述，这些也可以适当地位于基类的外部)。在下面的例子中，我们有一个简单的<code class="du lf lg lh li b">LocalDate</code>值包装器。但是我们也希望能够正确解析、验证和显示来自我们奇怪的ISO兼容格式(YYYY-DDD)的值:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="e510" class="lj jd hh bd je lk ll lm ji ln lo lp jm ip lq lr jq it ls lt ju ix lu lv jy lw bi translated">改变你的编程模式！</h2><p id="0468" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">上述方法的一个问题是，当验证错误发生时，传统的parse/require模式会出现异常——标准对象构造技术没有给我们机会将更多的函数式编程模型(如Result/要么monads)应用到我们的领域。</p><p id="b2fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这些模型中，我们积极地试图避免异常——为了帮助我们，我们可以将<code class="du lf lg lh li b">BirthDate</code>构造函数私有化，并编写一个函数来将错误捕获到一个<a class="ae le" href="https://github.com/fork-handles/forkhandles/tree/trunk/result4k" rel="noopener ugc nofollow" target="_blank"> Result4k </a>类型中，然后我们可以<code class="du lf lg lh li b">map/flatMap()</code>该类型:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="4472" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们想要插入一个不同的结果单子(比如Arrow的<code class="du lf lg lh li b">Either</code>)或者在失败时返回<code class="du lf lg lh li b">null</code>，添加扩展函数来覆盖这些类型是微不足道的。伴随物体给了我们选择...</p><h2 id="2858" class="lj jd hh bd je lk ll lm ji ln lo lp jm ip lq lr jq it ls lt ju ix lu lv jy lw bi translated">提取再利用！</h2><p id="f55f" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">许多开发人员没有意识到的是，该伴侣具有与任何其他Kotlin对象完全相同的功能——这包括从类或接口的传统继承。</p><p id="5dcb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回到更简单的基于异常的解析示例，我们可以将公共代码提取到可以重用的超类或委托中。进一步考虑这一点，我们意识到任何添加到超类/接口的扩展函数也将自动添加到我们的伙伴对象中！</p><p id="7741" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们为所有“日期包装器”类提取了一个公共超类<code class="du lf lg lh li b">DateValueFactory</code>——这个类中的每个函数现在都由<code class="du lf lg lh li b">OrderDate</code>和<code class="du lf lg lh li b">DeliveryDate</code>继承(通过它们的同伴)。如前所述，我们还为Result4k构造案例的所有<code class="du lf lg lh li b">DateValueFactory</code>实例添加了一个扩展函数:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="2ebd" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">摘要</h1><p id="63b3" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">我只介绍了过去几年使用Kotlin时遇到的几个用例，但这肯定只是冰山一角，还会有更多的用例等着我去发现。这些能力的实现增强了我的信念，那就是我们应该在科特林特征的表面下抓挠，看看有什么可能。</p><p id="27f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与许多发明一样，甚至JetBrains也可能没有真正意识到通过添加这样一个不起眼的功能所能释放的深度——我很想了解Kotlin标准库中任何这种类型的使用。</p><h1 id="47cd" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">PS。</h1><p id="c2c5" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">对于如何在现实世界中使用这些类型创建技术的实际例子，您可以看看基础的<a class="ae le" href="https://github.com/fork-handles/forkhandles/tree/trunk/values4k" rel="noopener ugc nofollow" target="_blank"> Values4k </a>库，该库使用它们来提供不可变值类型的实例化、验证、解析和打印。</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="9632" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kd">喜欢这篇文章吗？你可以在https://dentondav.id/writing</em><a class="ae le" href="https://dentondav.id/writing" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kd"/></strong></a><em class="kd">阅读我所有的科技文章。</em></p></div></div>    
</body>
</html>