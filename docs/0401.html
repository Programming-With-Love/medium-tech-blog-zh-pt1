<html>
<head>
<title>Coroutines on Android (part II): getting started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的协同程序(第二部分):入门</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd?source=collection_archive---------0-----------------------#2019-05-02">https://medium.com/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd?source=collection_archive---------0-----------------------#2019-05-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a0be03964836145a1dc72cbfd017a28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K__YGB4eb12WKTRwpvAuhg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="ca23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是关于在Android上使用协程的系列文章的一部分。这篇文章的重点是开始工作和跟踪已经开始的工作。</p><h2 id="3600" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated"><strong class="ak">本系列其他文章:</strong></h2><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第一部分):了解背景</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">协程解决什么问题？</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第三部分):实际工作</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">了解如何使用协程来完成实际工作，比如使用数据库或发出网络请求。</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><h1 id="21c8" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">跟踪协程</h1><p id="0055" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在第一部分中，我们探索了协程擅长解决的问题。总的来说，协程是两个常见编程问题的绝佳解决方案:</p><ol class=""><li id="e89a" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><strong class="iw hy">长时间运行的任务</strong>是花费太长时间来阻塞主线程的任务。</li><li id="cf6e" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy"> Main-safety </strong>允许你确保任何挂起函数都可以从主线程调用。</li></ol><p id="ba2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了解决这些问题，协程通过添加<strong class="iw hy">挂起</strong>和<strong class="iw hy">恢复</strong>来构建常规函数。当一个特定线程上的所有协程被挂起时，该线程可以自由地做其他工作。</p><p id="b7ca" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，协程本身并不能帮助您跟踪正在进行的工作。拥有大量的协程——数百个甚至数千个——并让它们同时挂起是再好不过了。虽然协程很便宜，但它们执行的工作通常很昂贵，比如读取文件或发出网络请求。</p><p id="f9c2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用代码手动跟踪一千个协程是非常困难的。您<em class="mm">可以</em>尝试跟踪所有这些任务，并手动确保它们完成或取消，但是像这样的代码是乏味且容易出错的。如果代码不完美，它会失去对协程的跟踪，这就是我所说的<em class="mm">工作泄漏</em>。</p><p id="d9a3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个<em class="mm">工作泄漏</em>就像一个内存泄漏，但是更糟糕。这是一个已经丢失的协程。除了使用内存之外，工作泄漏还可以继续使用CPU、磁盘，甚至发起网络请求。</p><blockquote class="mn"><p id="0b3f" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">泄漏的协程会浪费内存、CPU、磁盘，甚至启动不需要的网络请求。</p></blockquote><p id="7fb3" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">为了帮助避免泄漏协程，Kotlin引入了<a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">结构化并发</strong> </a>。结构化并发是语言特性和最佳实践的结合，遵循这些特性和实践，可以帮助您跟踪协程中运行的所有工作。</p><p id="ddb6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，我们可以使用结构化并发做三件事:</p><ol class=""><li id="256a" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated">取消不再需要的工作。</li><li id="df56" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">在工作运行的同时跟踪工作。</li><li id="ae2e" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">协程失效时的信号错误</strong>。</li></ol><p id="1fa0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们深入其中的每一个，看看结构化并发如何帮助我们确保永远不会丢失协程和泄漏工作。</p><h1 id="3b61" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">取消使用范围的工作</h1><p id="8523" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在Kotlin中，协程必须在一个叫做<code class="du nc nd ne nf b">CoroutineScope</code>的东西中运行。一个<code class="du nc nd ne nf b">CoroutineScope</code>跟踪你的协程，甚至是暂停的协程。与我们在第一部分中讨论的<code class="du nc nd ne nf b">Dispatchers</code>不同，它实际上并不执行你的协程——它只是确保你不会跟不上它们。</p><p id="3533" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了确保跟踪所有的协程，Kotlin不允许您在没有<code class="du nc nd ne nf b">CoroutineScope</code>的情况下启动一个新的协程。你可以把<code class="du nc nd ne nf b">CoroutineScope</code>想象成拥有超能力的<code class="du nc nd ne nf b">ExecutorService</code>的轻量级版本。它使您能够启动新的协程，这些协程带有我们在第一部分中探讨的所有挂起和恢复的优点。</p><p id="e7cc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个<code class="du nc nd ne nf b">CoroutineScope</code>跟踪你所有的协程，它可以取消所有在它里面启动的协程。这非常适合Android开发，在Android开发中，当用户离开时，您需要确保清理由屏幕启动的所有内容。</p><blockquote class="mn"><p id="e6a5" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">协程作用域跟踪你所有的协程，它可以取消在它里面启动的所有协程。</p></blockquote><h2 id="67d3" class="js jt hx bd ju jv ng jx jy jz nh kb kc jf ni ke kf jj nj kh ki jn nk kk kl km bi translated">开始新的协程</h2><p id="b426" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">需要注意的是，你不能从任何地方调用一个<code class="du nc nd ne nf b">suspend</code>函数。挂起和恢复机制要求您从正常函数切换到协程。</p><p id="1861" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">启动协程有两种方式，它们有不同的用途:</p><ol class=""><li id="6da1" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">launch</strong></a>builder将启动一个新的协程，该协程是“启动并忘记”——这意味着它不会将结果返回给调用者。</li><li id="371f" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">async</strong></a>builder将启动一个新的协程，它允许你用一个名为<code class="du nc nd ne nf b">await</code>的挂起函数返回一个结果。</li></ol><p id="4196" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">几乎在所有情况下，如何从常规函数启动协程的正确答案是使用<code class="du nc nd ne nf b">launch</code>。由于常规函数没有办法调用<code class="du nc nd ne nf b">await</code>(记住，它不能直接调用暂停函数)，所以使用<code class="du nc nd ne nf b">async</code>作为协程的主入口没有多大意义。我们稍后将讨论何时使用<code class="du nc nd ne nf b">async</code>是有意义的。</p><p id="8d91" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相反，您应该使用协程作用域，通过调用<code class="du nc nd ne nf b">launch</code>来启动协程。</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="4027" class="js jt hx nf b fi nt nu l nv nw">scope.launch {<br/>    // This block starts a new coroutine <br/>    // "in" the scope.<br/>    // <br/>    // It can call suspend functions<br/>   fetchDocs()<br/>}</span></pre><p id="f84e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以将<code class="du nc nd ne nf b">launch</code>看作是将您的代码从常规函数带入协程世界的桥梁。在<code class="du nc nd ne nf b">launch</code>主体内部，你可以调用暂停函数并创建主安全，就像我们在上一篇文章中提到的那样。</p><blockquote class="mn"><p id="b9f5" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">启动是从常规函数到协程的桥梁。</p></blockquote><blockquote class="nx ny nz"><p id="d02b" class="iu iv mm iw b ix mx iz ja jb my jd je oa mz jh ji ob na jl jm oc nb jp jq jr ha bi translated">警告:<em class="hx"/><code class="du nc nd ne nf b"><em class="hx">launch</em></code><em class="hx">和</em> <code class="du nc nd ne nf b"><em class="hx">async</em></code> <em class="hx">的一个很大区别就是他们处理异常的方式。</em> <code class="du nc nd ne nf b"><em class="hx">async</em></code> <em class="hx">预计你最终会调用</em> <code class="du nc nd ne nf b"><em class="hx">await</em></code> <em class="hx">得到一个结果(或者异常)所以默认情况下不会抛出异常。这意味着如果你使用</em> <code class="du nc nd ne nf b"><em class="hx">async</em></code> <em class="hx">来启动一个新的协程，它将会悄悄地丢弃异常。</em></p></blockquote><p id="0b73" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为<code class="du nc nd ne nf b">launch</code>和<code class="du nc nd ne nf b">async</code>只在<code class="du nc nd ne nf b">CoroutineScope</code>上可用，所以您知道您创建的任何协程都将被作用域跟踪。Kotlin只是不让您创建未被跟踪的协程，这大大避免了工作泄漏。</p><h2 id="e55b" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">从视图模型开始</h2><p id="ef10" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">因此，如果一个<code class="du nc nd ne nf b">CoroutineScope</code>跟踪所有在其中启动的协程，并且<code class="du nc nd ne nf b">launch</code>创建一个新的协程，那么你应该在哪里调用<code class="du nc nd ne nf b">launch</code>并放置你的作用域呢？什么时候取消一个作用域中启动的所有协程是有意义的？</p><p id="5c62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，将一个<code class="du nc nd ne nf b">CoroutineScope</code>与用户屏幕相关联通常是有意义的。这让您可以避免泄漏协程或为不再与用户相关的<code class="du nc nd ne nf b">Activities</code>或<code class="du nc nd ne nf b">Fragments</code>做额外的工作。当用户导航离开屏幕时，与屏幕关联的<code class="du nc nd ne nf b">CoroutineScope</code>可以<code class="du nc nd ne nf b">cancel</code>全部工作。</p><blockquote class="mn"><p id="57f8" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">结构化并发保证当一个<strong class="ak">作用域</strong> <strong class="ak">取消</strong>时，它的所有<strong class="ak">协同程序</strong> <strong class="ak">取消</strong>。</p></blockquote><p id="7de1" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">当将协同程序与Android架构组件集成时，您通常希望将<code class="du nc nd ne nf b">launch</code>协同程序放在<code class="du nc nd ne nf b">ViewModel</code>中。这是一个很自然的地方，因为大多数严肃的工作都是从这里开始的——而且您不必担心轮换会杀死所有的协程。</p><p id="f1bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要在<code class="du nc nd ne nf b">ViewModel</code>中使用协程，可以使用来自<code class="du nc nd ne nf b">lifecycle-viewmodel-ktx:2.1.0-alpha04</code>的<code class="du nc nd ne nf b">viewModelScope</code> <a class="ae hu" href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/extension-functionsproperties.html" rel="noopener ugc nofollow" target="_blank">扩展属性</a>。<code class="du nc nd ne nf b">viewModelScope</code>即将在<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/lifecycle" rel="noopener ugc nofollow" target="_blank"> AndroidX生命周期(v2.1.0) </a>中发布，目前处于alpha阶段。你可以在<a class="ae hu" href="http://manuelvicnt" rel="noopener ugc nofollow" target="_blank"> @manuelvicnt </a>的<a class="ae hu" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">博客文章</a>中了解更多关于它是如何工作的。由于该库目前处于alpha版本，可能会有一些错误，API可能会在最终版本发布前发生变化。如果发现任何bug，你可以在这里把它们<a class="ae hu" href="https://issuetracker.google.com/issues?q=componentid:413132" rel="noopener ugc nofollow" target="_blank">归档。</a></p><p id="389b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看一下这个例子:</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="03f8" class="js jt hx nf b fi nt nu l nv nw">class MyViewModel(): ViewModel() {<br/>    fun userNeedsDocs() {<br/>        // Start a new coroutine in a ViewModel<br/>        viewModelScope.launch {<br/>            fetchDocs()<br/>        }<br/>    }<br/>}</span></pre><p id="d627" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当<code class="du nc nd ne nf b">viewModelScope</code>被清除时(当<code class="du nc nd ne nf b">onCleared()</code>回调被调用时),它将自动取消任何由此<code class="du nc nd ne nf b">ViewModel</code>启动的协程。这通常是正确的行为——如果我们没有获取文档，而用户关闭了应用程序，我们可能只是在浪费他们的电池来完成请求。</p><p id="3eb7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更加安全，一个<code class="du nc nd ne nf b">CoroutineScope</code>会自我传播。因此，如果您启动的一个协程继续启动另一个协程，它们将在相同的作用域中结束。这意味着，即使您所依赖的库从您的<code class="du nc nd ne nf b">viewModelScope</code>启动了一个协程，您也有办法取消它们！</p><blockquote class="nx ny nz"><p id="36da" class="iu iv mm iw b ix iy iz ja jb jc jd je oa jg jh ji ob jk jl jm oc jo jp jq jr ha bi translated">警告:<em class="hx">协程被</em> <a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html#cancellation-and-timeouts" rel="noopener ugc nofollow" target="_blank"> <em class="hx">协同取消</em> </a> <em class="hx">在协程挂起时抛出</em> <code class="du nc nd ne nf b"><em class="hx">CancellationException</em></code> <em class="hx">。捕获像</em> <code class="du nc nd ne nf b"><em class="hx">Throwable</em></code> <em class="hx">这样的顶级异常的异常处理程序会捕获这个异常。如果您在异常处理程序中使用异常，或者从不挂起，那么协程将停留在半取消状态。</em></p></blockquote><p id="aad4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，当您需要一个协同程序运行得和一个<code class="du nc nd ne nf b">ViewModel</code>一样长时，使用<code class="du nc nd ne nf b">viewModelScope</code>从常规函数切换到协同程序。然后，因为<code class="du nc nd ne nf b">viewModelScope</code>会自动为你<code class="du nc nd ne nf b">cancel</code>协程，所以在这里写一个无限循环而不产生漏洞是完全没问题的。</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="9be6" class="js jt hx nf b fi nt nu l nv nw">fun runForever() {<br/>    // start a new coroutine in the ViewModel<br/>    viewModelScope.launch {<br/>        // cancelled when the ViewModel is cleared<br/>        while(true) {<br/>            delay(1_000)<br/>            // do something every second<br/>        }<br/>    }<br/>}</span></pre><p id="6c15" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过使用<code class="du nc nd ne nf b">viewModelScope</code>,你能够确保所有的工作，甚至这个无限循环，在不再需要的时候被取消。</p><h1 id="6418" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">跟踪工作</h1><p id="44ea" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">启动一个协程是好的——对于许多代码来说，这确实是您需要做的全部工作。启动一个协程，发出一个网络请求，并将结果写入数据库。</p><p id="badf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不过，有时候你需要更复杂一点。假设您想在一个协程中同时处理两个网络请求——要做到这一点，您需要启动更多的协程！</p><p id="60e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了生成更多的协程，任何挂起函数都可以通过使用另一个名为<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank">协程作用域</a>或其表亲<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" rel="noopener ugc nofollow" target="_blank">监督作用域</a>的构建器来启动更多的协程。老实说，这个API有点令人困惑。<code class="du nc nd ne nf b">coroutineScope</code> builder和<code class="du nc nd ne nf b">CoroutineScope</code>是不同的东西，尽管它们的名字只有一个字符不同。</p><p id="8093" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到处启动新的协程是造成潜在工作泄漏的一种方式。调用者可能不知道新的协同程序，如果不知道，它如何跟踪工作呢？</p><p id="4569" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了解决这个问题，结构化并发可以帮助我们。也就是说，它保证当一个<code class="du nc nd ne nf b">suspend</code>函数返回时，它的所有工作都完成了。</p><blockquote class="mn"><p id="4916" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">结构化并发保证当挂起函数返回时，它的所有工作都已完成。</p></blockquote><p id="4928" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">这里有一个使用<code class="du nc nd ne nf b">coroutineScope</code>获取两个文档的例子:</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="aead" class="js jt hx nf b fi nt nu l nv nw">suspend fun fetchTwoDocs() {<br/>    coroutineScope {<br/>        launch { fetchDoc(1) }<br/>        async { fetchDoc(2) }<br/>    }<br/>}</span></pre><p id="bbbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，从网络上同时获取两个文档。第一个是在一个以<code class="du nc nd ne nf b">launch</code>开始的协程中获取的，它是“启动并忘记”——这意味着它不会将结果返回给调用者。</p><p id="6159" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用<code class="du nc nd ne nf b">async</code>获取第二个文档，因此该文档可以返回给调用者。这个例子有点奇怪，因为通常你会对两个文档都使用<code class="du nc nd ne nf b">async</code>——但是我想展示你可以根据需要混合搭配<code class="du nc nd ne nf b">launch</code>和<code class="du nc nd ne nf b">async</code>。</p><blockquote class="mn"><p id="52bb" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">协程作用域和超级作用域让您可以从挂起函数中安全地启动协程。</p></blockquote><p id="7446" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">但是请注意，这段代码从来不会显式地等待任何一个新的协程！看起来<code class="du nc nd ne nf b">fetchTwoDocs</code>会在协程运行时返回！</p><p id="07a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了实现结构化并发并避免工作泄漏，我们希望确保当像<code class="du nc nd ne nf b">fetchTwoDocs</code>这样的挂起函数返回时，它的所有工作都已完成。这意味着它启动的两个协程必须在<code class="du nc nd ne nf b">fetchTwoDocs</code>返回之前完成。</p><p id="a615" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">科特林用<code class="du nc nd ne nf b">coroutineScope</code>生成器确保工作不会从<code class="du nc nd ne nf b">fetchTwoDocs</code>泄露。<code class="du nc nd ne nf b">coroutineScope</code>构建器将挂起自己，直到它内部启动的所有协程都完成。因此，在<code class="du nc nd ne nf b">coroutineScope</code>构建器中启动的所有协程完成之前，无法从<code class="du nc nd ne nf b">fetchTwoDocs</code>返回。</p><h2 id="be1b" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">很多很多的工作</h2><p id="7f33" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">既然我们已经探索了跟踪一个和两个协程，那么是时候全力以赴，尝试跟踪一千个协程了！</p><p id="034d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看看下面的动画:</p><figure class="nl nm nn no fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es od"><img src="../Images/f6eb715782577e27c4e23f90cef2d592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OeFUzbFsbBz034aZB4fbAw.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Animation showing how a coroutineScope can keep track of one thousand coroutines.</figcaption></figure><p id="581a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mm">这个例子显示了同时发出一千个网络请求。在真正的Android代码中不建议这样做——你的应用程序会使用大量资源。</em></p><p id="d6f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这段代码中，我们在一个<code class="du nc nd ne nf b">coroutineScope</code>构建器中启动了一千个带有<code class="du nc nd ne nf b">launch</code>的协同程序。你可以看到东西是如何连接起来的。因为我们在一个<code class="du nc nd ne nf b">suspend</code>函数中，某处的一些代码一定使用了一个<code class="du nc nd ne nf b">CoroutineScope</code>来创建一个协程。我们对那个<code class="du nc nd ne nf b">CoroutineScope</code>一无所知，它可能是一个<code class="du nc nd ne nf b">viewModelScope</code>或在其他地方定义的其他<code class="du nc nd ne nf b">CoroutineScope</code>。无论调用范围是什么，<code class="du nc nd ne nf b">coroutineScope</code>构建器都会将其作为它所创建的新范围的父范围。</p><p id="7dc1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，在<code class="du nc nd ne nf b">coroutineScope</code>块中，<code class="du nc nd ne nf b">launch</code>将在新的作用域中启动协程。当由launch启动的协程完成时，新的作用域将跟踪它们。最后，一旦在<code class="du nc nd ne nf b">coroutineScope</code>中启动的所有协程都完成了，<code class="du nc nd ne nf b">loadLots</code>就可以自由返回。</p><p id="4cc6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mm">注意:</em>作用域和协程之间的父子关系是使用<code class="du nc nd ne nf b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">Job</a></code>对象创建的。但是您经常可以想到协程和作用域之间的关系，而不必深入到那个层次。</p><blockquote class="mn"><p id="9c4b" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">协同作用域和监督作用域将等待子协同作用域完成。</p></blockquote><p id="6b3c" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">这里面发生了很多事情——但重要的是，使用<code class="du nc nd ne nf b">coroutineScope</code>或<code class="du nc nd ne nf b">supervisorScope</code>你可以<code class="du nc nd ne nf b">launch</code>一个协程安全地避开任何挂起函数。即使它将启动一个新的协同程序，您也不会意外地泄漏工作，因为您将总是挂起调用者，直到新的协同程序完成。</p><p id="e3b1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">真正酷的是<code class="du nc nd ne nf b">coroutineScope</code>将创建一个子范围。因此，如果父作用域被取消，它将把取消传递给所有新的协程。如果调用者是<code class="du nc nd ne nf b">viewModelScope</code>，当用户离开屏幕时，所有1000个协程将被自动取消。相当整洁！</p><p id="4070" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们继续讨论错误之前，有必要花点时间讨论一下<code class="du nc nd ne nf b">supervisorScope</code>和<code class="du nc nd ne nf b">coroutineScope</code>。主要区别在于，无论何时任何一个子节点失败，a <code class="du nc nd ne nf b">coroutineScope</code>都会<code class="du nc nd ne nf b">cancel</code>。因此，如果一个网络请求失败，所有其他请求都会立即取消。相反，如果您想在一个请求失败时继续其他请求，您可以使用<code class="du nc nd ne nf b">supervisorScope</code>。一个<code class="du nc nd ne nf b">supervisorScope</code>不会在一个孩子失败的时候取消其他孩子。</p><h1 id="34d6" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">协程失败时发出错误信号</h1><p id="0b62" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在协程中，错误是通过抛出异常来发出信号的，就像常规函数一样。resume会将来自<code class="du nc nd ne nf b">suspend</code>函数的异常重新抛出给调用者。就像常规函数一样，您并不局限于使用try/catch来处理错误，如果您愿意，您可以构建抽象来用其他样式执行错误处理。</p><p id="5f77" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，在协程中也有错误丢失的情况。</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="f630" class="js jt hx nf b fi nt nu l nv nw">val unrelatedScope = MainScope()</span><span id="c812" class="js jt hx nf b fi oe nu l nv nw">// example of a lost error<br/>suspend fun lostError() {<br/>    // async without structured concurrency<br/>    unrelatedScope.async {<br/>        throw InAsyncNoOneCanHearYou("except")<br/>    }<br/>}</span></pre><p id="a0e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意这段代码声明了一个不相关的协程作用域，该作用域将启动一个没有结构化并发的新协程。还记得我在开始时说过，结构化并发是类型和编程实践的结合，在挂起函数中引入不相关的协程范围并不符合结构化并发的编程实践。</p><p id="6119" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该错误在这段代码中丢失了，因为<code class="du nc nd ne nf b">async</code>假设您最终将调用<code class="du nc nd ne nf b">await</code>，在那里它将再次抛出异常。但是，如果你从来没有调用过<code class="du nc nd ne nf b">await</code>，这个异常将会被永久保存，耐心等待被引发。</p><blockquote class="mn"><p id="9245" class="mo mp hx bd mq mr ms mt mu mv mw jr dx translated">结构化并发保证当协程出错时，它的调用者或作用域会得到通知。</p></blockquote><p id="bad2" class="pw-post-body-paragraph iu iv hx iw b ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn nb jp jq jr ha bi translated">如果您对上述代码使用结构化并发，错误将被正确地抛出给调用者。</p><pre class="nl nm nn no fd np nf nq nr aw ns bi"><span id="d3bd" class="js jt hx nf b fi nt nu l nv nw">suspend fun foundError() {<br/>    coroutineScope {<br/>        async { <br/>            throw StructuredConcurrencyWill("throw")<br/>        }<br/>    }<br/>}</span></pre><p id="fec7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于<code class="du nc nd ne nf b">coroutineScope</code>将等待所有子进程完成，所以当它们失败时，它也可以得到通知。如果由<code class="du nc nd ne nf b">coroutineScope</code>启动的协程抛出异常，<code class="du nc nd ne nf b">coroutineScope</code>可以将它抛出给调用者。由于我们使用的是<code class="du nc nd ne nf b">coroutineScope</code>而不是<code class="du nc nd ne nf b">supervisorScope</code>，当异常抛出时，它也会立即取消所有其他的子进程。</p><h1 id="a155" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">使用结构化并发</h1><p id="daca" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在这篇文章中，我介绍了结构化并发，并展示了它如何使我们的代码与Android <code class="du nc nd ne nf b">ViewModel</code>很好地匹配，以避免工作泄漏。</p><p id="c843" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我还谈到了它如何使挂起函数更容易推理。既要确保它们在返回之前完成工作，又要确保它们通过显示异常来发出错误信号。</p><p id="0b30" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们使用非结构化并发，协程很容易意外泄漏调用者不知道的工作。这项工作是不可取消的，也不能保证会再次抛出异常。这将使我们的代码更加令人惊讶，并可能产生难以理解的错误。</p><p id="013e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您<em class="mm">可以通过引入一个新的不相关的<code class="du nc nd ne nf b">CoroutineScope</code>(注意大写的<code class="du nc nd ne nf b">C</code>)或者通过使用一个名为<code class="du nc nd ne nf b">GlobalScope</code>的全局作用域</em>来创建非结构化并发，但是您应该只在极少数情况下考虑非结构化并发，当您需要协同程序比调用作用域存在更长时间的时候。然后自己添加结构是一个好主意，这样可以确保跟踪非结构化的协程，处理错误，并有一个好的取消故事。</p><p id="2c2a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您有非结构化并发的经验，那么结构化并发确实需要一些时间来适应。这种结构和保证使得与<code class="du nc nd ne nf b">suspend</code>功能的交互更加安全和容易。尽可能地使用结构化并发是一个好主意，因为它有助于使代码更容易阅读，也不那么令人惊讶。</p><p id="fd56" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章的开始，我列出了结构化并发为我们解决的三件事情</p><ol class=""><li id="4d5a" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><strong class="iw hy">取消不再需要的工作</strong>。</li><li id="27e3" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">在工作运行时跟踪工作。</strong></li><li id="fabf" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">协程失效时的信号错误</strong>。</li></ol><p id="c555" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了实现这种结构化并发，我们对代码有了一些保证。以下是结构化并发的保证。</p><ol class=""><li id="0dce" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated">当一个<strong class="iw hy">范围</strong> <strong class="iw hy">取消</strong>时，其所有<strong class="iw hy">协程</strong> <strong class="iw hy">取消</strong>。</li><li id="85f6" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">当一个<strong class="iw hy">挂起fun </strong> <strong class="iw hy">返回</strong>时，其所有<strong class="iw hy">工作完成</strong>。</li><li id="8559" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">当一个<strong class="iw hy">协程</strong> <strong class="iw hy">出错</strong>时，其<strong class="iw hy">调用者或作用域被通知</strong>。</li></ol><p id="e3ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总之，结构化并发的保证使我们的代码更安全，更容易推理，并允许我们避免泄漏工作！</p><h1 id="30f6" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">下一步是什么？</h1><p id="96de" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在这篇文章中，我们探讨了如何在视图模型中启动Android上的协同程序，以及如何使用结构化并发来使我们的代码不那么令人惊讶。</p><p id="1e9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一篇文章中，我们将更多地讨论如何在实际情况中使用协程！读一读:</p><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第三部分):实际工作</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">了解如何使用协程来完成实际工作，比如使用数据库或发出网络请求。</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div></div></div>    
</body>
</html>