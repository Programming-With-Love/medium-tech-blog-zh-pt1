<html>
<head>
<title>Scala 3: these 10 major changes could influence your everyday coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 3:这10个主要变化可能会影响你的日常编码</h1>
<blockquote>原文：<a href="https://medium.com/globant/scala-3-these-10-major-changes-could-influence-your-everyday-coding-3a5075b5ae6f?source=collection_archive---------0-----------------------#2022-03-23">https://medium.com/globant/scala-3-these-10-major-changes-could-influence-your-everyday-coding-3a5075b5ae6f?source=collection_archive---------0-----------------------#2022-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/55e727c6450cf7030056af142ab4dbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7KBnMB9mEDVMhK-EmL7vg.png"/></div></div></figure><div class=""/><h1 id="f116" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">新版本，许多变化…</h1><p id="7d36" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Scala 3已经存在一段时间了(在我写这篇文章的时候，它的版本是3.1.1)。如果您来自Scala 2，想要进入版本3，无论是出于好奇还是因为即将到来的项目，本文将向您展示语言语法和结构的10个主要变化，它们将影响您的日常编码任务。</p><h2 id="9a5d" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">1:作为程序入口点</h2><p id="1408" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">通常Scala 2程序的入口点是这样的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="74ab" class="kl iq hs le b fi li lj l lk ll">object MyScalaMainProgram{<br/> def main(args: Array[String]): Unit = {<br/>  println(s"Hello ${args(0}}!")<br/> }<br/>}</span></pre><p id="9dfd" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">或者这个:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="94ea" class="kl iq hs le b fi li lj l lk ll">object MyScalaMainProgram extends App {<br/>  println(s"Hello ${args(0}}!")<br/>}<!-- --> </span></pre><p id="a22c" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">此外，Scala 3通过使用<strong class="jp ht"> <em class="lr"> @main </em> </strong>注释将一个函数定义为我们程序的入口点，如下所示:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e541" class="kl iq hs le b fi li lj l lk ll">@main def mainProgramFunction(name: String): Unit = {<br/>  <!-- -->println(s"Hello $name!")<br/>}</span></pre><p id="3c6e" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">请注意，该函数具有类型化参数，因此，如果在命令行中提供了正确值的字符串表示，它们将自动转换为相应参数的数据类型(当然，这是一个只有一个字符串参数的非常简单的示例)。这个特性有助于避免所有与简单命令行参数解析相关的样板代码。</p><p id="9cdc" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">如果您想从命令行获得旧式的字符串值，您可以使用<em class="lr"> varargs语法</em>编写函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="230c" class="kl iq hs le b fi li lj l lk ll">@main def mainProgramFunction(args: String*): Unit = {<br/>  <!-- -->println(s"Hello ${args(0)}!")<br/>}</span></pre><h2 id="8fdf" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">2:可选的基于缩进的语法</h2><p id="5c9e" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Scala 3为if-else、for-comprehensions、模式匹配和函数等表达式提供了一种新的、替代的(but <strong class="jp ht"> <em class="lr">可选的</em> </strong>)语法，该语法基于缩进而不是括号。据称，这种新语法是为了吸引非Scala受众，即Python开发人员。这里我们有一些例子:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6c6a" class="kl iq hs le b fi li lj l lk ll">// for-comprehension, cycle style<br/>for<br/>  i &lt;- 1 to n if n % 2 == 0<br/>do<br/>  <em class="lr">println</em>(i)<br/>  <em class="lr">println</em>("-------")<br/>end for</span><span id="25ce" class="kl iq hs le b fi ls lj l lk ll">// for-comprehension with yield<br/>val result =<br/>  for<br/>    i &lt;- 1 to 5<br/>    j &lt;- 1 to 5<br/>  yield<br/>    val z = i * j<br/>    z<br/>// You can also use 'end for' here if you like</span><span id="e636" class="kl iq hs le b fi ls lj l lk ll">// if-else, control structure style<br/>if n % 2 == 0 then<br/>  <em class="lr">println</em>("Yes")<br/>  <em class="lr">println</em>(s"<strong class="le ht">$</strong>n is an odd number")<br/>else<br/>  <em class="lr">println</em>("Nope")<br/>  <em class="lr">println</em>(s"<strong class="le ht">$</strong>n is not an odd number")<br/>end if</span><span id="8533" class="kl iq hs le b fi ls lj l lk ll">// if-else, expression style<br/>if n % 2 == 0 then<br/>  "Yes"<br/>else<br/>  "Nope"<br/>// You can use 'end if' here if you like</span><span id="e8b9" class="kl iq hs le b fi ls lj l lk ll">// Class with brace-less syntax<br/>class Point2D(val x: Double, val y: Double):<br/><br/>  def distance: Double = <em class="lr">sqrt</em>(<em class="lr">pow</em>(x, 2.0) + <em class="lr">pow</em>(y, 2.0))<br/><br/>  def angle: Double = angleForQuadrant(x, y) + 180 / <em class="lr">Pi </em>* <em class="lr">atan</em>(y/x)</span><span id="dc14" class="kl iq hs le b fi ls lj l lk ll">  // A method with a sample pattern matching<br/>  private def angleForQuadrant(x: Double, y: Double)  =<br/>    (x.sign, y.sign) match<br/>      case (1.0, 1.0) =&gt; 0<br/>      case (-1.0, _) =&gt; 180<br/>      case (1.0, -1.0) =&gt; 360<br/><br/>end Point2D</span></pre><p id="75b8" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">你可能已经注意到了<strong class="jp ht"> <em class="lr">结尾的</em> </strong>字后跟<strong class="jp ht"> <em class="lr"> if </em> </strong>，<strong class="jp ht"> <em class="lr">为</em> </strong>甚至是一个类或函数/方法名。这叫做<em class="lr">结束标记</em>，在代码块很长的情况下使用，以帮助读者区分代码块的结束位置，从而避免混淆；它是完全可选的，如上面的例子所示。</p><h2 id="d3d3" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">3:扩展方法而不是隐式转换</h2><p id="5084" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">通常，我们有一个类型/类，它的代码不受我们的控制，例如第三方库中的一个类，但是我们希望它有一个目前没有的方法。在那些情况下，我们求助于<em class="lr">隐式转换</em>。</p><p id="077b" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">例如，假设我们想要一个方法<strong class="jp ht"> Int.times() </strong>来执行一个动作，次数与Int的值一样多。我们首先在包对象中创建一个隐式类:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="49f0" class="kl iq hs le b fi li lj l lk ll">package object conversion {<br/>  implicit class EnrichedInt(val n: Int) {<br/>    def times(action: =&gt; Unit): Unit = for {_ &lt;- 1 to n } action<br/>  }<br/>}</span></pre><p id="03dc" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">然后我们在代码中使用:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="89ea" class="kl iq hs le b fi li lj l lk ll">10.times { <em class="lr">println</em>(s"Hello, <strong class="le ht">$</strong>{args(0)}") }</span></pre><p id="fd9f" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">相反，Scala 3的特点是<em class="lr">扩展方法</em>。让我们看看如何在Scala 3中添加上述额外的方法:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="99b6" class="kl iq hs le b fi li lj l lk ll">extension (n: Int) def times(action: =&gt; Unit): Unit =<br/> for _ &lt;- 1 to n do action</span></pre><p id="cea3" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">更少的样板代码。此外，扩展方法不需要包对象来包含它们(下一节将详细介绍)。</p><h2 id="5262" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">4:顶级定义而不是包对象</h2><p id="bd24" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Scala中的包对象让我们持有包范围的定义，例如:</p><ul class=""><li id="2f99" class="lt lu hs jp b jq lm ju ln jy lv kc lw kg lx kk ly lz ma mb bi translated">键入别名</li><li id="06e7" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">常量值/对象</li><li id="8706" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">向现有类型添加方法的隐式类<em class="lr">(见上一节)</em></li><li id="58f1" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">不作为类中的方法应用的函数</li></ul><p id="1fed" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">然而，在Scala 3中，所有这些都被认为是<em class="lr">顶级定义</em>，所以我们要做的只是在Scala文件中定义它们，如下所示:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4c0c" class="kl iq hs le b fi li lj l lk ll">package io.picetti.scala3.article</span><span id="2d64" class="kl iq hs le b fi ls lj l lk ll">//We already know this: extension function<br/>extension (n: Int) def times(action: =&gt; Unit): Unit =<br/> for _ &lt;- 1 to n do action<br/><br/>// Immutable variables<br/>val X_COORD: Double = 35.5<br/>val Y_COORD: Double = 45.2<br/><br/>def fizzBuzz(num: Int) =<br/>  num match<br/>    case n if n % 15 == 0 =&gt;<br/>      <em class="lr">print</em>("Fizzbuzz")<br/>      <em class="lr">println</em>("!")<br/>    case n if n % 5 == 0 =&gt;<br/>      <em class="lr">print</em>("Buzz")<br/>      <em class="lr">println</em>("!")<br/>    case n if n % 3 == 0 =&gt;<br/>      <em class="lr">print</em>("Fizz")<br/>      <em class="lr">println</em>("!")<br/>    case _ =&gt;<br/>      <em class="lr">println</em>(num)<br/>  end match</span></pre><h2 id="9dcf" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">5:联合和相交类型</h2><p id="ab83" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">让我们考虑用Scala 2编写的以下函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="757f" class="kl iq hs le b fi li lj l lk ll">def divideXByY(x: Int, y: Int): Either[String, Int] = {<br/>  if (y == 0) <em class="lr">Left</em>("Dude, can't divide by 0")<br/>  else <em class="lr">Right</em>(x / y)<br/>}</span></pre><p id="37f3" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">它使用<strong class="jp ht"><em class="lr">【E，V】</em></strong>类型返回结果或错误消息。在Scala 3中使用<em class="lr">联合类型</em>可以获得相同的结果。这种类型允许您定义返回的类型或提供的参数是A <strong class="jp ht"> <em class="lr">或</em> </strong> B <strong class="jp ht"> <em class="lr">或</em> </strong> …。让我们在上面的例子中使用这个，而不是任何一个:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9f9b" class="kl iq hs le b fi li lj l lk ll">def divideXByY(x: Int, y: Int): String | Int =<br/>  if y == 0 then "Dude, can't divide by 0" else x / y</span></pre><p id="c010" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">当然，这个例子是琐碎的，并没有反映出联合类型的力量。但是，如果我们想扩展这个函数的逻辑，使它返回:</p><ul class=""><li id="1c95" class="lt lu hs jp b jq lm ju ln jy lv kc lw kg lx kk ly lz ma mb bi translated">两个整数的整除，如果它们可以被整除的话</li><li id="f4d5" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">在两个整数都不能被整除的情况下，带小数的精确除法<em class="lr">和</em></li><li id="1aeb" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">除数为零时的常见错误消息。</li></ul><p id="d0f9" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">在这种情况下，Scala 3中的函数可以这样表达:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e255" class="kl iq hs le b fi li lj l lk ll">ef divideXByY(x: Int, y: Int): String | Double | Int =<br/>  if y == 0 then<br/>    "Dude, can't divide by 0"<br/>  else if x % y != 0 then<br/>    (x * 1.0) / (y * 1.0)<br/>  else x / y</span></pre><p id="62f5" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">这种情况不能用<strong class="jp ht"> <em class="lr">或者【E，V】</em></strong>处理，否则代码会过于复杂，因为其中任何一个都只处理2种类型(我将把上面代码的实现留给读者作为练习)</p><p id="5267" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">类似地，<em class="lr">交集类型</em>让我们将返回类型或提供的参数定义为类型A <strong class="jp ht"> <em class="lr">和</em> </strong> B <strong class="jp ht"> <em class="lr">和</em> </strong> …。让我们来看看下面的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="75aa" class="kl iq hs le b fi li lj l lk ll">trait Point2D:<br/>  val x: Double<br/>  val y: Double<br/><br/>  def draw: Unit<br/><br/>trait Polarizable:<br/>  def distance: Double<br/>  def angle: Double<br/><br/>class PolarPoint(<br/>  override val x: Double,<br/>  override val y: Double<br/>  ) extends Point2D with Polarizable:<br/><br/>  override def draw: Unit =<br/>    <em class="lr">println</em>("Let's assume the point is drawn here")<br/>  end draw<br/><br/>  override def distance: Double = <em class="lr">sqrt</em>(<em class="lr">pow</em>(x, 2.0) + <em class="lr">pow</em>(y, 2.0))<br/><br/>  override def angle: Double =<br/>    angleForQuadrant(x, y) + 180 / <em class="lr">Pi </em>* <em class="lr">atan</em>(y/x)<br/><br/>  private def angleForQuadrant(x: Double, y: Double) =<br/>    (x.sign, y.sign) match<br/>      case (1.0, 1.0) =&gt; 0<br/>      case (-1.0, _) =&gt; 180<br/>      case (1.0, -1.0) =&gt; 360<br/><br/>end PolarPoint</span></pre><p id="df48" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">那么像下面这样的函数是可能的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="972a" class="kl iq hs le b fi li lj l lk ll">def drawPolar(point: Point2D &amp; Polarizable): Unit =<br/>  <em class="lr">println</em>(<br/>    s"""<br/>       |Drawing Point(<strong class="le ht">$</strong>{point.x},<strong class="le ht">$</strong>{point.y})<br/>       |with polar distance: <strong class="le ht">$</strong>{point.distance}<br/>       |and angle: <strong class="le ht">$</strong>{point.angle}<br/>       |""".stripMargin)</span></pre><p id="f9bd" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">无论我们定义哪一类点，该函数都只接受那些扩展点2d<strong class="jp ht"><em class="lr"/></strong><strong class="jp ht"><em class="lr">和</em> </strong> <strong class="jp ht"> <em class="lr">可极化</em> </strong>的点。</p><h2 id="b45c" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">6:给定/使用而不是隐式值和参数</h2><p id="57c5" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Scala的<em class="lr">隐式</em>是Scala 2中一个多方面的特性；使用它们，您可以定义以下内容:</p><ul class=""><li id="d98e" class="lt lu hs jp b jq lm ju ln jy lv kc lw kg lx kk ly lz ma mb bi translated">上下文参数</li><li id="3eba" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">用新方法扩展现有类型</li><li id="8643" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">隐式转换</li></ul><p id="60cc" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">然而，这意味着关键字<strong class="jp ht"> <em class="lr">隐式</em> </strong>有许多用途，并使代码有些混乱，甚至对编译器来说，导致意想不到的效果。这就是为什么Scala 3将这个单一特性分成了一组特性:</p><ul class=""><li id="3046" class="lt lu hs jp b jq lm ju ln jy lv kc lw kg lx kk ly lz ma mb bi translated">扩展方法<em class="lr">(参见第3节)</em></li><li id="ca21" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">隐式转换需要显式定义(即需要更多的工作)</li><li id="fe89" class="lt lu hs jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">上下文参数用关键字<strong class="jp ht"> <em class="lr">给定</em> </strong> / <strong class="jp ht"> <em class="lr">使用</em> </strong></li></ul><p id="f5eb" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">我们将集中讨论后者。回到上面的<strong class="jp ht"> <em class="lr"> Point2D </em> </strong>示例trait，假设我们想要让<strong class="jp ht"> <em class="lr"> draw </em> </strong>方法在不同的设备上绘制一个点，每个设备都被建模为一个<strong class="jp ht"><em class="lr">graphic context</em></strong>，其实现在程序的不同部分可能会有所不同。所以我们这样重新定义我们的绘制方法:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="daa0" class="kl iq hs le b fi li lj l lk ll">trait Point2D(val x: Double, val y: Double):<br/>  <strong class="le ht">def draw(using ctx: GraphicContext): Unit</strong></span></pre><p id="0d67" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">注意使用关键字 的<strong class="jp ht"> <em class="lr">表示必须提供一个上下文值。这个值可以在一个类中定义，也可以在一个包/子包中定义为顶级定义，就像我们过去对隐式所做的那样:</em></strong></p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6b63" class="kl iq hs le b fi li lj l lk ll">given ctx: GraphicContext = GraphicContext()</span></pre><p id="cd5c" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">注意<strong class="jp ht"> <em class="lr">给出了</em> </strong>关键字来表示一个上下文值。上面的定义也可以写成一个匿名的上下文值，就像这样:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="72b4" class="kl iq hs le b fi li lj l lk ll">given GraphicContext = GraphicContext()</span></pre><h2 id="9230" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">7:特质参数</h2><p id="6241" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在Scala 3中，特征<em class="lr">可以有参数</em>，和类一样。例如，上面第5节中的例子定义了特征<strong class="jp ht"> <em class="lr">点2D </em> </strong>:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6ad4" class="kl iq hs le b fi li lj l lk ll">trait Point2D:<br/>  val x: Double<br/>  val y: Double<br/><br/>  def draw: Unit</span></pre><p id="bbc0" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">相同的特征可以写成:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="73b7" class="kl iq hs le b fi li lj l lk ll">trait Point2D(val x: Double, val y: Double):<br/>  def draw: Unit</span></pre><p id="ce84" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">和class PolarPoint应适当更改为:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="01d5" class="kl iq hs le b fi li lj l lk ll">class PolarPoint(<br/>  override val x: Double,<br/>  override val y: Double<br/>  ) extends <strong class="le ht">Point2D(x,y)</strong> with Polarizable:<br/>// Rest of class definition</span></pre><p id="49ec" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">此时，你可以说:<em class="lr">“嗯？为什么不是抽象类Point2D？”</em>。我承认这个例子是琐碎的，因为它是用来说教的，但是记住<em class="lr">抽象类只对单一继承</em>有效，而特征让你<em class="lr">以类似“多重继承”的方式组合</em>。</p><h2 id="693b" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">8:通用应用方法:不需要“new”关键字</h2><p id="6a8c" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">正如我们已经知道的，在Scala 2中，case类的实例可以在不使用关键字<strong class="jp ht"> <em class="lr"> new </em> </strong>的情况下创建，因为编译器向该类添加了一个<strong class="jp ht"> <em class="lr"> apply() </em> </strong>方法，以及其他自动添加的方法。Scala 3将一个<strong class="jp ht"> <em class="lr"> apply() </em> </strong>方法的添加扩展到了<em class="lr">所有的具体类</em>。这意味着上面代码片段中的类<strong class="jp ht"> <em class="lr"> PolarPoint </em> </strong>的实例可以简单地创建为:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="fbb5" class="kl iq hs le b fi li lj l lk ll">val polarPoint = PolarPoint(X_COORD, Y_COORD)</span></pre><p id="bb05" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated"><em class="lr"> (btw，X_COORD和Y_COORD来自第4节的片段)</em></p><h2 id="db27" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">9:枚举</h2><p id="b3ae" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">到目前为止，为了创建枚举，我们不得不求助于Java <strong class="jp ht"> <em class="lr">枚举</em> </strong>或第三方库。现在Scala 3有了自己的<em class="lr">枚举类型</em>。我们可以这样定义一个简单的枚举:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c6c5" class="kl iq hs le b fi li lj l lk ll">enum Currency:<br/>  case Dollar, Yen, Euro</span></pre><p id="a8db" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">或者使用<em class="lr">参数化枚举</em>获得更多信息:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0c64" class="kl iq hs le b fi li lj l lk ll">enum Currency(val code: String):<br/>  case Dollar extends Currency("USD")<br/>  case Yen extends Currency("JPY")<br/>  case Euro extends Currency("EUR")</span></pre><p id="2d0e" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">我们可以用刚刚定义的枚举做一些事情:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="57d0" class="kl iq hs le b fi li lj l lk ll">val currency = Currency.Dollar</span><span id="7817" class="kl iq hs le b fi ls lj l lk ll"><em class="lr">println</em>(currency.code)<br/><em class="lr">println</em>(Currency.valueOf("Yen").ordinal)</span></pre><p id="f978" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">TBD:合计类型</p><h2 id="c556" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated">10:参数解耦</h2><p id="c9fe" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在我们有元组列表并且需要使用元组的值将它映射到另一个列表的情况下，我们通常有两种方法。第一种方法是像这样访问元组的元素:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="bbe2" class="kl iq hs le b fi li lj l lk ll">val points = <em class="lr">List</em>(<br/>  (PolarPoint(100,100), PolarPoint(20,200)),<br/>  (PolarPoint(100,100), PolarPoint(100,200)),<br/>)<br/>val sumPoints = points.map { pointPair =&gt;<br/> (pointPair._1.x + pointPair._2.x, pointPar._1.y + pointPair._2.y)<br/>}</span></pre><p id="0a89" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">然而，在重要的代码中，这被认为是一种不好的做法，因为读者无法知道_1或_2中有什么。如果生成元组列表的代码不明显，并且有人更改了元组中数据的顺序，情况会变得更糟。因此，我们有第二种选择:用一个<strong class="jp ht"><em class="lr"/></strong>事例去结构化元组:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="48d5" class="kl iq hs le b fi li lj l lk ll">val sumPoints = points.map { case (p1, p2) =&gt;<br/> (p1.x + p2.x, p1.y + p2.y)<br/>}</span></pre><p id="54af" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">好多了，但是现在的情况表明模式匹配如果不彻底可能会失败。Scala 3提供了更清晰的选择:<em class="lr">参数解耦</em>。让我们看看前面的代码片段是什么样子的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5ca8" class="kl iq hs le b fi li lj l lk ll">val sumPoints = points.map {<br/>  (p1, p2) =&gt; (p1.x + p2.x, p1.y + p2.y)<br/>}</span></pre><p id="1a61" class="pw-post-body-paragraph jn jo hs jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ha bi translated">元组将被非结构化成它的组件，而不使用模式匹配的<strong class="jp ht"> <em class="lr"> case </em> </strong>。</p><h1 id="eee5" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="3211" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们已经介绍了Scala 3中的10个主要变化，如果你在Scala 3中开始一个新项目，这些变化将影响你的日常编码任务。当然，还涉及到更多的东西，比如对工具链、库和框架的支持，但是我希望这篇文章能让你对用Scala 3编写代码有一个初步的了解。</p></div></div>    
</body>
</html>