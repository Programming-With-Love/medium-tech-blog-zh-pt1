<html>
<head>
<title>A safer way to collect flows from Android UIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Android用户界面收集流量的更安全方式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda?source=collection_archive---------0-----------------------#2021-03-24">https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda?source=collection_archive---------0-----------------------#2021-03-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/2a372fb025837b24aa27f7bf6f192120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFYXKcW3Gae_2MFWwFX5lg.png"/></div></div></figure><div class=""/><p id="e251" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android应用中，<a class="ae jn" href="https://developer.android.com/kotlin/flow" rel="noopener ugc nofollow" target="_blank"> Kotlin流</a>通常从UI层收集，以在屏幕上显示数据更新。但是，您希望收集这些流，确保在视图转到后台时，您没有做不必要的工作，没有浪费资源(CPU和内存)或泄漏数据。</p><p id="3bf2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您将了解到<code class="du jo jp jq jr b">Lifecycle.repeatOnLifecycle</code>和<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>API如何保护您不浪费资源，以及为什么它们是UI层中用于流收集的良好默认设置。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="98ed" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">浪费资源</h1><p id="a8c0" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">建议<a class="ae jn" href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices#coroutines-data-layer" rel="noopener ugc nofollow" target="_blank"/>从应用层次的较低层公开<code class="du jo jp jq jr b">Flow&lt;T&gt;</code> API，而不考虑流生成器实现细节。但是，您也应该安全地收集它们。</p><p id="71cf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由<a class="ae jn" href="https://kotlinlang.org/docs/channels.html" rel="noopener ugc nofollow" target="_blank">通道</a>支持或使用带有<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html" rel="noopener ugc nofollow" target="_blank">buffer</a></code>、<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" rel="noopener ugc nofollow" target="_blank">conflate</a></code>、<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" rel="noopener ugc nofollow" target="_blank">flowOn</a></code>或<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html" rel="noopener ugc nofollow" target="_blank">shareIn</a></code>等缓冲区的操作符的冷流<strong class="ir ht">使用一些现有的API(如<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" rel="noopener ugc nofollow" target="_blank">CoroutineScope.launch</a></code>、<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" rel="noopener ugc nofollow" target="_blank">Flow&lt;T&gt;.launchIn</a></code>或<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">LifecycleCoroutineScope.launchWhenX</a></code>)来收集</strong>是不安全的，除非您在活动转到后台时手动取消启动协程的<code class="du jo jp jq jr b">Job</code>。这些API将使底层流生产者保持活动，同时在后台将项目发送到缓冲区，从而浪费资源。</p><blockquote class="lc ld le"><p id="a028" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:<strong class="ir ht">冷</strong>流是一种在新订户收集时按需执行生产者代码块的流。</p></blockquote><p id="2191" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，考虑这个使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html" rel="noopener ugc nofollow" target="_blank">callbackFlow</a></code>发出位置更新的流程:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><blockquote class="lc ld le"><p id="221f" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:在内部，<code class="du jo jp jq jr b"><em class="hs">callbackFlow</em></code>使用一个<a class="ae jn" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank">通道</a>，它在概念上与阻塞<a class="ae jn" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a>非常相似，默认容量为64个元素。</p></blockquote><p id="f0d1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用前面提到的任何API从UI层收集这个流可以保持流的发出位置，即使视图没有在UI中显示它们！请参见下面的示例:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e836" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">暂停协程的执行。新的位置不被处理，但是<code class="du jo jp jq jr b">callbackFlow</code>制作人仍然继续发送位置。使用<code class="du jo jp jq jr b">lifecycleScope.launch</code>或<code class="du jo jp jq jr b">launchIn</code>API甚至更危险，因为即使在后台，视图也会不断消耗位置！这可能会使您的应用程序崩溃。</p><p id="889c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要用这些API解决这个问题，您需要在视图转到后台取消<code class="du jo jp jq jr b">callbackFlow</code>时手动取消收集，以避免位置提供者发送项目和浪费资源。例如，您可以执行如下操作:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="073b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个很好的解决方案，但这是样板，朋友们！如果有一个关于Android开发者的普遍真理，那就是我们绝对厌恶编写样板代码。不必编写样板代码的最大好处之一是代码越少，出错的机会就越少！</p><h1 id="81b7" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">生命周期.重复生命周期</h1><p id="b888" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">既然我们都在同一页上，知道问题在哪里，是时候想出一个解决方案了。解决方案需要1)简单，2)友好或易于记忆/理解，更重要的是3)安全！它应该适用于所有用例，不管流程实现细节如何。</p><p id="e1ac" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事不宜迟，你应该使用的API是<a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/lifecycle" rel="noopener ugc nofollow" target="_blank"> <em class="lf">生命周期-运行时-ktx </em> </a>库中可用的<code class="du jo jp jq jr b"><strong class="ir ht">Lifecycle.repeatOnLifecycle</strong></code>。</p><blockquote class="lc ld le"><p id="31b9" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:这些API可以在<code class="du jo jp jq jr b"><em class="hs">androidx.lifecycle:lifecycle-runtime-ktx:2.4.0</em></code>库或更高版本中获得。</p></blockquote><p id="29a4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看一下下面的代码:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="aee3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">repeatOnLifecycle</code>是一个suspend函数，它以一个<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State" rel="noopener ugc nofollow" target="_blank">Lifecycle.State</a></code>作为参数，用于<strong class="ir ht">自动创建并启动一个新的协程</strong>，当生命周期到达那个<code class="du jo jp jq jr b">state</code>时，将块传递给它，当生命周期低于<code class="du jo jp jq jr b">state</code>时，<strong class="ir ht">取消正在执行该块的协程</strong>。</p><p id="156c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这避免了任何样板代码，因为当不再需要协同程序时，取消协同程序的相关代码是由<code class="du jo jp jq jr b">repeatOnLifecycle</code>自动完成的。正如您所猜测的，建议在活动的<code class="du jo jp jq jr b">onCreate</code>或片段的<code class="du jo jp jq jr b">onViewCreated</code>方法中调用这个API，以避免意外的行为。请参见下面使用片段的示例:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c5b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">重要:</strong>片段应该<em class="lf">总是</em>使用<code class="du jo jp jq jr b">viewLifecycleOwner</code>来触发UI更新。然而，对于有时可能没有<code class="du jo jp jq jr b">View</code>的<code class="du jo jp jq jr b">DialogFragment</code>来说，情况并非如此。对于<code class="du jo jp jq jr b">DialogFragment</code> s，可以使用<code class="du jo jp jq jr b">lifecycleOwner</code>。</p><blockquote class="lc ld le"><p id="41df" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:这些API可以在<code class="du jo jp jq jr b"><em class="hs">androidx.lifecycle:lifecycle-runtime-ktx:2.4.0</em></code>库或更高版本中获得。</p></blockquote><h2 id="c905" class="lu ka hs bd kb lv lw lx kf ly lz ma kj ja mb mc kn je md me kr ji mf mg kv mh bi translated">引擎盖下！</h2><p id="c968" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><code class="du jo jp jq jr b">repeatOnLifecycle</code>挂起调用的协程，当生命周期移入和移出目标<code class="du jo jp jq jr b">state</code>时，在一个<em class="lf">新的</em>协程中重新启动该块，当 <code class="du jo jp jq jr b"><strong class="ir ht">Lifecycle</strong></code> <strong class="ir ht">被破坏</strong>时，<strong class="ir ht">恢复调用的协程。最后一点非常重要:调用<code class="du jo jp jq jr b">repeatOnLifecycle</code>的协程不会恢复执行，直到生命周期被破坏。</strong></p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="24ea" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">视觉图</h1><p id="136e" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">回到起点，直接从以<code class="du jo jp jq jr b">lifecycleScope.launch</code>开始的协程中收集<code class="du jo jp jq jr b">locationFlow</code>是危险的，因为即使视图在后台，收集也会继续进行。</p><p id="3d0c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">repeatOnLifecycle</code>防止您浪费资源和应用崩溃，因为当生命周期移入和移出目标状态时，它会停止和重新启动流收集。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/7c4ccdac15212371c71b85ee4d76d227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmQRBPMPpnO7NAO2bg0GKw.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx">Difference between using and not using the repeatOnLifecycle API</figcaption></figure><h1 id="1b7b" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">Flow.flowWithLifecycle</h1><p id="f913" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">当您只有一个流要收集时，您也可以使用<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>操作符。这个API使用底层的<code class="du jo jp jq jr b">repeatOnLifecycle</code> API，当<code class="du jo jp jq jr b">Lifecycle</code>移入和移出目标状态时，发出项目并取消底层的生产者。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><blockquote class="lc ld le"><p id="eb04" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:这个API名称以<code class="du jo jp jq jr b">Flow.flowOn(CoroutineContext)</code>操作符为先例，因为<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>改变了用于收集上游流量的<code class="du jo jp jq jr b">CoroutineContext</code>，同时保持下游不受影响。此外，与<code class="du jo jp jq jr b">flowOn</code>类似，<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>增加了一个缓冲，以防消费者跟不上生产者。这是因为它的实现使用了一个<code class="du jo jp jq jr b">callbackFlow</code>。</p></blockquote><h1 id="e654" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">配置基础生成器</h1><p id="0266" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">即使您使用这些API，也要小心那些即使没有人收集也可能浪费资源的<em class="lf">热</em>流！它们有一些有效的用例，但是请记住这一点，并在需要时记录下来。让底层的流生产者在后台活动，即使浪费资源，对某些用例来说也是有益的:您可以立即获得新的数据，而不是<em class="lf">追赶</em>并暂时显示陈旧的数据。<strong class="ir ht">根据用例，决定生产者是否需要总是活动的</strong>。</p><p id="8c31" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">MutableStateFlow</code>和<code class="du jo jp jq jr b">MutableSharedFlow</code>API公开了一个<code class="du jo jp jq jr b">subscriptionCount</code>字段，当<code class="du jo jp jq jr b">subscriptionCount</code>为零时，您可以使用该字段来停止底层生产者。默认情况下，只要保存流实例的对象在内存中，它们就会使生成器保持活动状态。尽管这有一些有效的用例，例如，使用<code class="du jo jp jq jr b">StateFlow</code>从ViewModel向UI公开一个<code class="du jo jp jq jr b">UiState</code>。没关系！这个用例要求ViewModel总是向视图提供最新的UI状态。</p><p id="3385" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html" rel="noopener ugc nofollow" target="_blank">Flow.stateIn</a></code>和<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html" rel="noopener ugc nofollow" target="_blank">Flow.shareIn</a></code>操作符可以通过<a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/index.html" rel="noopener ugc nofollow" target="_blank">共享启动策略</a>进行配置。<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html" rel="noopener ugc nofollow" target="_blank">WhileSubscribed()</a></code>会在没有主动观察者的时候停止底层生产者！相反，<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-eagerly.html" rel="noopener ugc nofollow" target="_blank">Eagerly</a></code>或<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-lazily.html" rel="noopener ugc nofollow" target="_blank">Lazily</a></code>将保持底层生产者活动，只要他们使用的<code class="du jo jp jq jr b">CoroutineScope</code>是活动的。</p><blockquote class="lc ld le"><p id="b7e2" class="ip iq lf ir b is it iu iv iw ix iy iz lg jb jc jd lh jf jg jh li jj jk jl jm ha bi translated">注意:本文中显示的API是从UI收集流的一个很好的默认设置，无论流实现细节如何，都应该使用这些API。这些API做了它们需要做的事情:如果UI在屏幕上不可见，就停止收集。它是否应该总是活动的取决于流实现。</p></blockquote><h1 id="27a9" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">Jetpack Compose中的安全流收集</h1><p id="8d61" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">如果您正在使用Jetpack Compose构建一个Android应用程序，使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code> API从您的UI中以生命周期感知的方式收集流。</p><p id="94b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>是一个可组合的函数，它从流中收集值，并以生命周期感知的方式将最新的值表示为Compose <code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State" rel="noopener ugc nofollow" target="_blank">State</a></code>。每次出现新的流发射时，这个<code class="du jo jp jq jr b">State</code>对象的值都会更新。这会导致组合中每个<code class="du jo jp jq jr b">State.value</code>用法的重组。</p><p id="4188" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#started" rel="noopener ugc nofollow" target="_blank">Lifecycle.State.STARTED</a></code>来开始和停止从流中收集值。当生命周期移入和移出目标状态时，会发生这种情况。这个生命周期状态可以在<code class="du jo jp jq jr b">minActiveState</code>参数中配置。</p><p id="dc61" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的代码片段展示了这个API的作用:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e26d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有关更多信息，请查看Jetpack Compose博客文章中的<a class="ae jn" rel="noopener" href="/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3">安全消费流。</a></p><div class="hg hh ez fb hi mn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd ht fi z dy ms ea eb mt ed ef hr bi translated">在Jetpack Compose中安全地使用流</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">以生命周期感知的方式收集流量是Android上收集流量的推荐方式。使用…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ho mn"/></div></div></a></div><h1 id="5810" class="jz ka hs bd kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw bi translated">与LiveData的比较</h1><p id="0605" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">您可能已经注意到这个API的行为类似于<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>，这是真的！<code class="du jo jp jq jr b">LiveData</code>知道生命周期，它的重启行为使它非常适合从用户界面观察数据流。对于<code class="du jo jp jq jr b">Lifecycle.repeatOnLifecycle</code>和<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>API也是如此！</p><p id="77cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<em class="lf"> Kotlin专用的</em>应用中，使用这些API收集流是对<code class="du jo jp jq jr b">LiveData</code>的自然替代。如果您使用这些API进行流收集，<code class="du jo jp jq jr b">LiveData</code>并不会比协程和流提供任何好处。此外，流量更加灵活，因为它们可以从任何<code class="du jo jp jq jr b">Dispatcher</code>收集，并且可以通过所有<a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener ugc nofollow" target="_blank">操作器</a>供电。与<code class="du jo jp jq jr b">LiveData</code>相反，它只有有限的可用操作符，其值总是从UI线程中观察到的。</p><h2 id="bbb4" class="lu ka hs bd kb lv lw lx kf ly lz ma kj ja mb mc kn je md me kr ji mf mg kv mh bi translated">数据绑定中的状态流支持</h2><p id="d05a" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">换句话说，您可能使用<code class="du jo jp jq jr b">LiveData</code>的原因之一是因为它受数据绑定的支持。嗯，<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow" rel="noopener ugc nofollow" target="_blank">StateFlow</a></code>也是！关于数据绑定中<code class="du jo jp jq jr b">StateFlow</code>支持的更多信息，<a class="ae jn" href="https://developer.android.com/topic/libraries/data-binding/observability#stateflow" rel="noopener ugc nofollow" target="_blank">查看官方文档</a>。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="b8ef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jo jp jq jr b">Lifecycle.repeatOnLifecycle</code>或<code class="du jo jp jq jr b">Flow.flowWithLifecycle</code>API安全地从Android的UI层收集流。</p></div></div>    
</body>
</html>