<html>
<head>
<title>5 Questions Every Unit Test Must Answer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个单元测试必须回答的5个问题</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d?source=collection_archive---------0-----------------------#2015-08-29">https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d?source=collection_archive---------0-----------------------#2015-08-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f163" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何编写更好的测试</h2></div></div><div class="ha hb hc hd he"><h1 id="ddcc" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">大多数开发人员不知道如何测试</h1><p id="faf2" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">每个开发人员都知道我们应该编写单元测试，以防止缺陷被部署到产品中。</p><p id="b29b" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">大多数开发人员不知道的是<strong class="jq hi">每个单元测试</strong>的基本成分。我无法开始计算我看到单元测试失败的次数，只是为了调查和发现我完全不知道开发人员试图测试什么特性，更不用说它是如何出错的或者它为什么重要。</p><p id="0489" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">在我最近的一个项目中，我们让大量的单元测试进入测试套件，完全没有对测试目的的任何描述。我们有一个伟大的团队，所以我放松了警惕。结果呢？我们仍然有大量的单元测试，只有作者才能真正理解。</p><p id="277b" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">幸运的是，我们正在完全重新设计API，我们将扔掉整个套件并从头开始——否则，这将是我的修复列表中的第一优先事项。</p><p id="d66f" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">不要让这种事发生在你身上。</p><h1 id="2dde" class="iw ix hh bd iy iz kp jb jc jd kq jf jg in kr io ji iq ks ir jk it kt iu jm jn bi translated">为什么要担心测试纪律呢？</h1><p id="9818" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">你的测试是你对抗软件缺陷的第一道也是最好的防线。你的测试比林挺&amp;静态分析更重要(它只能找到错误的子类，而不是你实际程序逻辑的问题)。测试和实现本身一样重要(重要的是代码满足需求——如何实现根本不重要，除非实现得很差)。</p><p id="4054" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">单元测试结合了许多使它们成为应用程序成功的秘密武器的特性:</p><ol class=""><li id="fa63" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj kz la lb lc bi translated">设计帮助:首先编写测试让你对理想的API设计有一个更清晰的认识。</li><li id="3ab4" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">特性文档(面向开发人员):</strong>测试描述在代码中记录了每个实现的特性需求。</li><li id="7a82" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">测试你的开发人员的理解力:</strong>开发人员对问题的理解是否足以在代码中阐明所有关键的组件需求？</li><li id="8c81" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">质量保证:</strong>人工QA容易出错。以我的经验来看，开发人员不可能在进行修改以重构、添加新特性或删除特性之后，记住所有需要测试的特性。</li><li id="a467" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">持续交付帮助:</strong>自动化的QA提供了自动防止不完整的构建被部署到产品中的机会。</li></ol><p id="690a" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">单元测试不需要被扭曲或操纵来服务于所有这些广泛的目标。相反，满足所有这些需求是单元测试的本质。这些好处都是一个写得好、覆盖面广的测试套件的副作用。</p><h2 id="56e5" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">TDD的科学</h2><p id="7ef9" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">证据显示:</p><ul class=""><li id="ad27" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj lw la lb lc bi translated"><strong class="jq hi"> TDD可以降低bug密度。</strong></li><li id="0718" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated">TDD可以鼓励更多的模块化设计(增强软件敏捷性/团队速度)。</li><li id="4802" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated">TDD可以降低代码复杂度。</li></ul><p id="e5c8" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated"><strong class="jq hi">说科学:</strong>有<em class="lx">重要的经验证据表明TDD有效* </em>。</p><h1 id="caeb" class="iw ix hh bd iy iz kp jb jc jd kq jf jg in kr io ji iq ks ir jk it kt iu jm jn bi translated">首先编写测试</h1><p id="ae0d" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">来自微软研究院、IBM和Springer的研究测试了先测试和后测试方法的效率，并且一致发现先测试的过程比以后添加测试产生更好的结果。非常清楚:在实现之前，编写测试。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><blockquote class="mf"><p id="7085" class="mg mh hh bd mi mj mk ml mm mn mo kj dx translated">在你实现之前，<br/> <strong class="ak"> <em class="mp">编写测试。</em> </strong></p></blockquote></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h1 id="894d" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">好的单元测试包含什么？</h1><p id="4445" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">好的，TDD是可行的。先写测试。更有纪律性。相信过程…我们明白了。但是<strong class="jq hi">如何编写好的单元测试呢？</strong></p><p id="8ff4" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">我们将从一个真实项目中查看一个非常简单的例子来探索这个过程:来自<a class="ae mq" href="https://github.com/stampit-org/stamp-specification" rel="noopener ugc nofollow" target="_blank"> Stamp规范</a>的<em class="lx"> `compose()` </em>函数。</p><p id="5eff" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">我们将<a class="ae mq" rel="noopener" href="/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4">使用胶带</a>进行测试，因为它清晰明了且简单明了。</p><p id="883e" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">在我们回答如何编写一个好的单元测试之前，首先我们必须了解单元测试是如何使用的:</p><ul class=""><li id="bd45" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj lw la lb lc bi translated"><strong class="jq hi">设计辅助:</strong>设计阶段编写，<em class="lx">实施前</em>。</li><li id="e2b5" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated"><strong class="jq hi">特性文档&amp;开发人员理解测试:</strong>测试应该提供被测试特性的<em class="lx">清晰描述。</em></li><li id="625d" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated">QA/连续交付:测试应该在失败时停止交付管道，并且<em class="lx">在失败时产生一个好的错误报告。</em></li></ul><h1 id="e139" class="iw ix hh bd iy iz kp jb jc jd kq jf jg in kr io ji iq ks ir jk it kt iu jm jn bi translated">作为错误报告的单元测试</h1><p id="2814" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">当一个测试失败时，测试失败报告通常是关于到底哪里出了问题的第一个也是最好的线索——快速追踪根本原因的秘密是知道从哪里开始寻找。当你有一个真正清晰的错误报告时，这个过程会变得容易得多。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><blockquote class="mf"><p id="6dbd" class="mg mh hh bd mi mj mk ml mm mn mo kj dx translated">失败的测试应该像高质量的错误报告一样阅读<br/>。</p></blockquote></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h2 id="eb4f" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">一份好的测试失败bug报告有什么内容？</h2><ol class=""><li id="f984" class="ku kv hh jq b jr js ju jv jx mr kb ms kf mt kj kz la lb lc bi translated">您在测试什么？</li><li id="8820" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated">它应该做什么？</li><li id="e2a1" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">输出是什么(实际行为)？</strong></li><li id="d9c0" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">预期输出(预期行为)是什么？</strong></li></ol></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><figure class="mv mw mx my fd mz er es paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="er es mu"><img src="../Images/19f7f12a43282739752775753ac58081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhYZ6dcMUKAhFyhsWJ6qGg.png"/></div></div><figcaption class="ng nh et er es ni nj bd b be z dx">Example of a good failure report.</figcaption></figure></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><h2 id="53d9" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">首先回答“你在测试什么？”：</h2><ul class=""><li id="4e57" class="ku kv hh jq b jr js ju jv jx mr kb ms kf mt kj lw la lb lc bi translated">你正在测试哪个组件方面？</li><li id="3f45" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated"><strong class="jq hi">功能应该做什么？你正在测试什么特定的行为需求？</strong></li></ul><p id="be1e" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated"><em class="lx"> `compose()` </em>函数获取任意数量的戳记(可组合的工厂函数)并生成一个新的戳记。</p><p id="8fd7" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">为了编写这个测试，我们将从任何单一测试的最终目标开始逆向工作:测试一个特定的行为需求。为了通过这个测试，代码必须产生什么特定的行为？</p><h2 id="9111" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">该功能应该做什么？</h2><p id="ad4c" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我喜欢先写一串。没有分配到任何东西。没有传递给任何函数。只是明确关注组件必须满足的特定需求。在这种情况下，我们将从<em class="lx"> `compose()` </em>函数应该返回一个函数这一事实开始。</p><p id="4676" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">一个简单的、可测试的需求:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="810e" class="li ix hh nl b fi np nq l nr ns">'compose() should return a function.'</span></pre><p id="27be" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">现在我们将跳过一些内容，充实余下的测试。这根弦是我们的目标。事先声明有助于我们关注奖励。</p><h2 id="b9cd" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">我们测试的是哪个组件方面？</h2><p id="cb64" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">您所说的“组件方面”在不同的测试中会有所不同，这取决于为测试中的组件提供足够的覆盖率所需的粒度。</p><p id="bd17" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">在这种情况下，我们将测试<em class="lx"> `compose()` </em>函数的返回类型，以确保它返回正确的类型，而不是<em class="lx"> `undefined` </em>或什么都不做，因为当您运行它时它会抛出。</p><p id="0acb" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">让我们把这个问题翻译成测试代码。答案进入测试描述。这一步也是我们进行函数调用并传递测试运行程序在测试运行时将调用的回调函数的地方:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="902d" class="li ix hh nl b fi np nq l nr ns">test('&lt;What component aspect are we testing?&gt;', assert =&gt; {<br/>});</span></pre><p id="6386" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">在本例中，我们测试compose函数的输出:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="2ef7" class="li ix hh nl b fi np nq l nr ns">test('Compose function output type.', assert =&gt; {<br/>});</span></pre><p id="ad64" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">当然我们仍然需要我们的第一个描述。它位于回调函数内部:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="691c" class="li ix hh nl b fi np nq l nr ns">test('Compose function output type.', assert =&gt; {<br/>  'compose() should return a function.'<br/>});</span></pre><h1 id="b324" class="iw ix hh bd iy iz kp jb jc jd kq jf jg in kr io ji iq ks ir jk it kt iu jm jn bi translated">产出是什么(预期和实际)？</h1><p id="8299" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><em class="lx"> `equal()` </em>是我最喜欢的断言。如果每个测试套件中唯一可用的断言是<em class="lx"> `equal()`，</em>那么世界上几乎所有的测试套件都会更适合它。为什么？</p><p id="8958" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">因为<em class="lx"> `equal()` </em>，本质上回答了<strong class="jq hi">每个单元测试必须回答的两个最重要的问题</strong>，但是大多数不回答:</p><ul class=""><li id="ca3d" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj lw la lb lc bi translated"><strong class="jq hi">实际产量是多少？</strong></li><li id="ca60" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated"><strong class="jq hi">预期产量是多少？</strong></li></ul><p id="5a47" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">如果你没有回答那两个问题就完成了一个测试，你就没有真正的单元测试。你有一个草率的，半生不熟的测试。</p><p id="9db9" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">如果你只从这篇文章中得到一样东西，那就是:</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><blockquote class="mf"><p id="fb4b" class="mg mh hh bd mi mj mk ml mm mn mo kj dx translated">等于是新的默认断言。这是每一个好的测试套件的主要部分。</p></blockquote></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="4a81" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">所有那些有数百个不同的花哨断言的花哨断言库正在破坏你的测试质量。</p><h2 id="043e" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">挑战</h2><p id="bf77" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">想更好地编写单元测试吗？在接下来的一周，尝试使用<em class="lx"> `equal()` </em>或<em class="lx"> `deepEqual()`、</em>或它们在你选择的断言库中的等价物来编写每一个断言。不要担心对你的套房质量的影响。我敢打赌，这项运动将会显著改善它。</p><p id="8ee0" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">这在代码中是什么样子的？</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="3b72" class="li ix hh nl b fi np nq l nr ns">  const actual = '&lt;what is the actual output?&gt;';<br/>  const expected = '&lt;what is the expected output?&gt;';</span></pre><p id="d6f5" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">第一个问题在测试失败时确实起了双重作用。通过回答这个问题，您的代码也回答了另一个问题:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="7c83" class="li ix hh nl b fi np nq l nr ns">  const actual = '&lt;how is the test reproduced?&gt;';</span></pre><p id="5b17" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">需要注意的是，<strong class="jq hi"><em class="lx">` actual`</em>值必须通过使用一些组件的公共API来产生。</strong>否则，测试没有价值。我见过测试套件充斥着模仿、存根、铃声和哨声，以至于一些测试从来没有测试过任何应该被测试的代码。</p><p id="df69" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">让我们回到这个例子:</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="73bd" class="li ix hh nl b fi np nq l nr ns">  const actual = typeof compose();<br/>  const expected = 'function';</span></pre><p id="0dad" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">您可以构建一个断言，而不用专门给名为<em class="lx">`实际`</em>和<em class="lx">`预期`、</em>的变量赋值，但是我最近开始在每个测试中专门给名为<em class="lx">`实际`</em>和<em class="lx">`预期`</em> <strong class="jq hi">的变量赋值，并且发现<strong class="jq hi">使我的测试更容易阅读。</strong></strong></p><p id="56ff" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">看到它是如何澄清断言的了吗？</p><pre class="mv mw mx my fd nk nl nm nn aw no bi"><span id="92d4" class="li ix hh nl b fi np nq l nr ns">  assert.equal(actual, expected,<br/>    'compose() should return a function.');</span></pre><p id="2473" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">它将测试主体中的“如何”和“什么”分开。</p><ul class=""><li id="707b" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj lw la lb lc bi translated">想知道<strong class="jq hi">我们是怎么得到结果的？</strong>看看<em class="lx">变量赋值</em>。</li><li id="6ec4" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj lw la lb lc bi translated">想知道我们在测试什么吗？看<em class="lx">断言的描述</em>。</li></ul><p id="2380" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">结果是测试本身就像高质量的错误报告一样容易阅读。</p><p id="339d" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">让我们来看看整个事情的来龙去脉</p><figure class="mv mw mx my fd mz"><div class="bz dy l di"><div class="nt nu l"/></div></figure><p id="bfd1" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">下次编写测试时，记得回答所有问题:</p><ol class=""><li id="59ff" class="ku kv hh jq b jr kk ju kl jx kw kb kx kf ky kj kz la lb lc bi translated">你在测试什么？</li><li id="5937" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated">它应该做什么？</li><li id="0674" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">实际产量是多少？</strong></li><li id="aeb7" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">预期产量是多少？</strong></li><li id="0729" class="ku kv hh jq b jr ld ju le jx lf kb lg kf lh kj kz la lb lc bi translated"><strong class="jq hi">测试如何复现？</strong></li></ol><p id="26db" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">最后一个问题由用于导出<em class="lx"> `actual` </em>值的代码来回答。</p><h2 id="db6c" class="li ix hh bd iy lj lk ll jc lm ln lo jg jx lp lq ji kb lr ls jk kf lt lu jm lv bi translated">单元测试模板:</h2><figure class="mv mw mx my fd mz"><div class="bz dy l di"><div class="nt nu l"/></div></figure><p id="5e53" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">很好地使用单元测试还有很多，但是知道如何编写一个好的测试还有很长的路要走。</p><h1 id="036d" class="iw ix hh bd iy iz kp jb jc jd kq jf jg in kr io ji iq ks ir jk it kt iu jm jn bi translated"><strong class="ak">接下来的步骤</strong></h1><p id="2d32" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><a class="ae mq" href="https://tddday.com" rel="noopener ugc nofollow" target="_blank">参加TDD日，观看一整天录制的网络广播TDD课程</a>。TDD日是让您的团队掌握高级测试驱动开发技能的理想方式。了解不同种类的测试及其作用，如何编写更多可测试的软件，以及<a class="ae mq" rel="noopener" href="/javascript-scene/tdd-changed-my-life-5af0ce099f80">TDD如何让我成为更好的开发人员</a>，以及它如何为你做同样的事情。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><blockquote class="mf"><p id="9a96" class="mg mh hh bd mi mj mk ml mm mn mo kj dx translated">观看网络直播录音，<br/> TDD在ES6 &amp;反应如何</p><p id="dda2" class="mg mh hh bd mi mj mk ml mm mn mo kj dx translated">&amp;更有了<br/> <a class="ae mq" href="https://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">终身访问通行证</a></p></blockquote></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="3f6f" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated"><strong class="jq hi"> <em class="lx">埃里克·艾略特</em> </strong> <em class="lx">著有</em> <a class="ae mq" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="lx">【编程JavaScript应用】</em> </a> <em class="lx">(奥赖利)，以及</em> <a class="ae mq" href="https://leanpub.com/learn-javascript-react-nodejs-es6/" rel="noopener ugc nofollow" target="_blank"> <em class="lx">【学习JavaScript通用App开发用节点，ES6，&amp;【React】</em></a><em class="lx">。他为Adobe Systems</em><strong class="jq hi"><em class="lx"/></strong><em class="lx"/><strong class="jq hi"><em class="lx">尊巴健身</em></strong><em class="lx"/><strong class="jq hi"><em class="lx">华尔街日报</em></strong><em class="lx"/><strong class="jq hi"><em class="lx">【ESPN</em></strong><em class="lx"/><strong class="jq hi"><em class="lx">BBC</em></strong><em class="lx">等顶级录音师贡献了软件经验</em></p><p id="61a2" class="pw-post-body-paragraph jo jp hh jq b jr kk ii jt ju kl il jw jx km jz ka kb kn kd ke kf ko kh ki kj ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>