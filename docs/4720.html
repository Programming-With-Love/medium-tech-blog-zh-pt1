<html>
<head>
<title>Why Composition is Harder with Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么写作越来越难</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa?source=collection_archive---------1-----------------------#2017-07-27">https://medium.com/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa?source=collection_archive---------1-----------------------#2017-07-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="69e6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《排版软件》系列<strong class="iz hi"> s </strong> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">(现在一本书！)</strong> </a>从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae jv" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1"> &lt;上一个</a> | &lt; &lt; <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-an-introduction-27b72500d6ea">从第1部分开始</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/composable-datatypes-with-functions-aec72db3b093">下一个&gt; </a></p></blockquote><p id="4f33" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">之前，我们研究了工厂函数，并了解了使用函数混合将它们用于组合是多么容易。现在我们要更详细地看一下类，并检查一下<code class="du jz ka kb kc b">class</code>的机制是如何妨碍合成的。</p><p id="b16d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们还将看看类的良好用例，以及如何安全地使用它们。</p><p id="a258" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">ES6包含了一个方便的<code class="du jz ka kb kc b">class</code>语法，所以你可能想知道我们为什么要关心工厂。最明显的区别是构造函数和<code class="du jz ka kb kc b">class</code>需要<code class="du jz ka kb kc b">new</code>关键字。但是<code class="du jz ka kb kc b">new</code>实际上做什么呢？</p><ul class=""><li id="a212" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">创建一个新对象，并在构造函数中将<code class="du jz ka kb kc b">this</code>绑定到它。</li><li id="8d30" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">隐式返回<code class="du jz ka kb kc b">this</code>，除非你显式返回另一个对象。</li><li id="4c6d" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">将实例<code class="du jz ka kb kc b">[[Prototype]]</code>(内部参考)设置为<code class="du jz ka kb kc b">Constructor.prototype</code>，以便<code class="du jz ka kb kc b">Object.getPrototypeOf(instance) === Constructor.prototype</code>和<code class="du jz ka kb kc b">instance.__proto__ === Constructor.prototype</code>。</li><li id="27b8" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">设置<code class="du jz ka kb kc b">instance.constructor === Constructor</code>。</li></ul><p id="cb46" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所有这些都意味着，与工厂函数不同，类不是组成函数混合的好解决方案。您仍然可以使用<code class="du jz ka kb kc b">class</code>实现合成，但是这是一个更复杂的过程，正如您将看到的，额外的成本通常不值得额外的努力。</p><h2 id="7a9a" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">委托原型</h2><p id="1de9" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">您可能最终需要从一个类重构到一个工厂函数，如果您要求调用者使用<code class="du jz ka kb kc b">new</code>关键字，那么重构可能会以几种方式破坏您甚至没有意识到的客户端代码。首先，与类和构造函数不同，工厂函数不会自动连接委托原型链接。</p><p id="837c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du jz ka kb kc b">[[Prototype]]</code>链接用于原型委托，如果您有数百万个对象，这是一种节省内存的便捷方式，或者如果您需要在16毫秒的渲染循环周期内访问一个对象的数万个属性，这是一种从程序中挤出微性能提升的便捷方式。</p><p id="1153" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果不<em class="iy">需要</em>对内存或性能进行微优化的话，<code class="du jz ka kb kc b">[[Prototype]]</code>环节弊大于利。原型链支持JavaScript中的<code class="du jz ka kb kc b">instanceof</code>操作符，不幸的是<code class="du jz ka kb kc b">instanceof</code>因为两个原因而撒谎:</p><p id="e7ff" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在ES5中，<code class="du jz ka kb kc b">Constructor.prototype</code>链接是动态的和可重新配置的，如果你需要创建一个抽象工厂，这可能是一个方便的特性——但是如果你使用这个特性，如果<code class="du jz ka kb kc b">Constructor.prototype</code>当前在内存中没有引用实例<code class="du jz ka kb kc b">[[Prototype]]</code>引用的同一个对象，那么<code class="du jz ka kb kc b">instanceof</code>将会给你一个错误的否定:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="6822" class="kr ks hh kc b fi lz ma l mb mc">class User {<br/>  constructor ({userName, avatar}) {<br/>    this.userName = userName;<br/>    this.avatar = avatar;<br/>  }<br/>}</span><span id="dbd9" class="kr ks hh kc b fi md ma l mb mc">const currentUser = new User({<br/>  userName: 'Foo',<br/>  avatar: 'foo.png'<br/>});</span><span id="8ccd" class="kr ks hh kc b fi md ma l mb mc">User.prototype = {};</span><span id="5759" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  currentUser instanceof User, // &lt;-- false -- Oops!</span><span id="38a8" class="kr ks hh kc b fi md ma l mb mc">// But it clearly has the correct shape:<br/>  // { avatar: "foo.png", userName: "Foo" }<br/>  currentUser<br/>);</span></pre><p id="a6b4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Chrome通过在属性描述符中制作<code class="du jz ka kb kc b">Constructor.prototype</code>属性<code class="du jz ka kb kc b">configurable: false</code>解决了这个问题。然而，Babel目前并不反映这种行为，所以Babel编译的代码将像ES5构造函数一样工作。如果您试图重新配置<code class="du jz ka kb kc b">Constructor.prototype</code>属性，V8会自动失败。无论哪种方式，都不会得到你期望的结果。更糟糕的是:行为不一致，现在在Babel中工作的代码将来很可能会崩溃。</p><blockquote class="me"><p id="1062" class="mf mg hh bd mh mi mj mk ml mm mn ju dx translated">我不建议重新分配<code class="du jz ka kb kc b">Constructor.prototype</code>。</p></blockquote><p id="2f2a" class="pw-post-body-paragraph iw ix hh iz b ja mo jc jd je mp jg jh jw mq jk jl jx mr jo jp jy ms js jt ju ha bi translated">一个更常见的问题是JavaScript有多个执行上下文——内存沙箱，其中相同的代码将访问不同的物理内存位置。例如，如果在父框架中有一个构造函数，并且在<code class="du jz ka kb kc b">iframe</code>中有相同的构造函数，则父框架的<code class="du jz ka kb kc b">Constructor.prototype</code>将不会引用与<code class="du jz ka kb kc b">iframe</code>中的<code class="du jz ka kb kc b">Constructor.prototype</code>相同的内存位置。JavaScript中的对象值是引擎盖下的内存引用，不同的帧指向内存中不同的位置，所以<code class="du jz ka kb kc b">===</code>检查会失败。</p><p id="c892" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du jz ka kb kc b">instanceof</code>的另一个问题是，它是一个名义类型检查而不是结构类型检查，这意味着如果你从一个<code class="du jz ka kb kc b">class</code>开始，然后切换一个工厂，所有使用<code class="du jz ka kb kc b">instanceof</code>的调用代码将不会理解新的实现，即使它们满足相同的接口契约。例如，假设你的任务是构建一个音乐播放器界面。稍后，产品团队会告诉您添加对视频的支持。之后，他们会要求你添加对360视频的支持。它们都提供相同的控制:播放、停止、倒带、快进。</p><p id="6574" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是如果你使用<code class="du jz ka kb kc b">instanceof</code>检查，你的视频接口类的成员不会满足代码库中已经存在的<code class="du jz ka kb kc b">foo instanceof AudioInterface</code>检查。</p><p id="42b4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他们会在应该成功的时候失败。其他语言中的可共享接口通过允许一个类声明它实现了一个特定的接口来解决这个问题。这在JavaScript中是不可能的。</p><p id="da97" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中处理<code class="du jz ka kb kc b">instanceof</code>的最好方法是在不需要的时候断开委托原型链接，让<code class="du jz ka kb kc b">instanceof</code>在每次调用时都失败。这样你就不会有一种错误的可靠感。不要听<code class="du jz ka kb kc b">instanceof</code>的，它永远不会骗你。</p><h2 id="9f20" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">的。构造函数属性</h2><p id="68bc" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">属性<code class="du jz ka kb kc b">.constructor</code>在JavaScript中是一个很少使用的特性，但是它可能非常有用，将它包含在对象实例中是一个好主意。如果您不尝试使用它来进行类型检查，它基本上是无害的(因为<code class="du jz ka kb kc b">instanceof</code>是不安全的，所以它也是不安全的)。</p><p id="d5e6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">理论上，</strong> <code class="du jz ka kb kc b">.constructor</code>可以用来创建泛型函数，这些函数能够返回您传入的任何对象的新实例。</p><p id="11d8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">实际上，</strong>在JavaScript中有许多不同的方法来创建事物的新实例——拥有对构造函数的引用并不等同于知道如何用它实例化一个新对象——即使是为了看似微不足道的目的，比如创建一个给定对象的空实例:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="9911" class="kr ks hh kc b fi lz ma l mb mc">// Return an empty instance of any object type?<br/>const empty = ({ constructor } = {}) =&gt; constructor ?<br/>  new constructor() :<br/>  undefined<br/>;</span><span id="cb57" class="kr ks hh kc b fi md ma l mb mc">const foo = [10];</span><span id="1937" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  empty(foo) // []<br/>);</span></pre><p id="d1fc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">它似乎适用于数组。让我们用承诺来试试:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="4648" class="kr ks hh kc b fi lz ma l mb mc">// Return an empty instance of any type?<br/>const empty = ({ constructor } = {}) =&gt; constructor ?<br/>  new constructor() :<br/>  undefined<br/>;</span><span id="44b7" class="kr ks hh kc b fi md ma l mb mc">const foo = Promise.resolve(10);</span><span id="6d3c" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  empty(foo) // [TypeError: Promise resolver undefined is<br/>             //  not a function]<br/>);</span></pre><p id="85e4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">注意代码中的关键字<code class="du jz ka kb kc b">new</code>。这是大部分的问题。假设您可以对任何工厂函数使用<code class="du jz ka kb kc b">new</code>关键字是不安全的。有时，这将导致错误。</p><p id="66b7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">要实现这一点，我们需要一种标准的方法，使用不需要<code class="du jz ka kb kc b">new</code>的标准工厂函数将一个值传递给一个新实例。对此有一个规范:任何工厂或构造函数上都有一个名为<code class="du jz ka kb kc b">.of()</code>的静态方法。<a class="ae jv" href="https://github.com/fantasyland/fantasy-land#of-method" rel="noopener ugc nofollow" target="_blank"/><code class="du jz ka kb kc b"><a class="ae jv" href="https://github.com/fantasyland/fantasy-land#of-method" rel="noopener ugc nofollow" target="_blank">.of()</a></code><a class="ae jv" href="https://github.com/fantasyland/fantasy-land#of-method" rel="noopener ugc nofollow" target="_blank">方法</a>是一个工厂，它返回数据类型的一个新实例，该实例包含您传递给<code class="du jz ka kb kc b">.of()</code>的任何内容。</p><p id="4780" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们可以使用<code class="du jz ka kb kc b">.of()</code>来创建通用<code class="du jz ka kb kc b">empty()</code>函数的更好版本:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="8f11" class="kr ks hh kc b fi lz ma l mb mc">// Return an empty instance of any type?<br/>const empty = ({ constructor } = {}) =&gt; constructor.of ?<br/>  constructor.of() :<br/>  undefined<br/>;</span><span id="c12e" class="kr ks hh kc b fi md ma l mb mc">const foo = [23];</span><span id="f37c" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  empty(foo) // []<br/>);</span></pre><p id="2b92" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">不幸的是，静态<code class="du jz ka kb kc b">.of()</code>方法刚刚开始在JavaScript中获得支持。<code class="du jz ka kb kc b">Promise</code>对象确实有一个类似于<code class="du jz ka kb kc b">.of()</code>的静态方法，但是它被称为<code class="du jz ka kb kc b">.resolve()</code>，所以我们的泛型<code class="du jz ka kb kc b">empty()</code>不能使用承诺:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="e71e" class="kr ks hh kc b fi lz ma l mb mc">// Return an empty instance of any type?<br/>const empty = ({ constructor } = {}) =&gt; constructor.of ?<br/>  constructor.of() :<br/>  undefined<br/>;</span><span id="4bf7" class="kr ks hh kc b fi md ma l mb mc">const foo = Promise.resolve(10);</span><span id="b9ed" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  empty(foo) // undefined<br/>);</span></pre><p id="9b2b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">同样，在撰写本文时，JavaScript中没有针对字符串、数字、对象、映射、弱映射或集合的<code class="du jz ka kb kc b">.of()</code>。</p><p id="04de" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果对<code class="du jz ka kb kc b">.of()</code>方法的支持在其他标准JavaScript数据类型中流行起来，那么<code class="du jz ka kb kc b">.constructor</code>属性最终会成为该语言一个更有用的特性。我们可以用它来构建一个丰富的实用函数库，能够作用于各种函子、单子和其他代数数据类型。</p><p id="0250" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">很容易向工厂添加对<code class="du jz ka kb kc b">.constructor</code>和<code class="du jz ka kb kc b">.of()</code>的支持:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="0366" class="kr ks hh kc b fi lz ma l mb mc">const createUser = ({<br/>  userName = 'Anonymous',<br/>  avatar = 'anon.png'<br/>} = {}) =&gt; ({<br/>  userName,<br/>  avatar,<br/>  constructor: createUser<br/>});</span><span id="f41e" class="kr ks hh kc b fi md ma l mb mc">createUser.of = createUser;</span><span id="f33b" class="kr ks hh kc b fi md ma l mb mc">// testing .of and .constructor:<br/>const empty = ({ constructor } = {}) =&gt; constructor.of ?<br/>  constructor.of() :<br/>  undefined<br/>;</span><span id="ec5d" class="kr ks hh kc b fi md ma l mb mc">const foo = createUser({ userName: 'Empty', avatar: 'me.png' });</span><span id="856f" class="kr ks hh kc b fi md ma l mb mc">console.log(<br/>  empty(foo), // { avatar: "anon.png", userName: "Anonymous" }<br/>  foo.constructor === createUser.of, // true<br/>  createUser.of === createUser       // true<br/>);</span></pre><p id="5803" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您甚至可以通过添加到委托原型来使<code class="du jz ka kb kc b">.constructor</code>不可枚举:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="e1b1" class="kr ks hh kc b fi lz ma l mb mc">const createUser = ({<br/>  userName = 'Anonymous',<br/>  avatar = 'anon.png'<br/>} = {}) =&gt; ({<br/>  __proto__: {<br/>    constructor: createUser<br/>  },<br/>  userName,<br/>  avatar<br/>});</span></pre><h2 id="f590" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">类到工厂是一个突破性的变化</h2><p id="d988" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">工厂允许以下列方式增加灵活性:</p><ul class=""><li id="9866" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">将实例化细节从调用代码中分离出来。</li><li id="184a" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">允许您返回任意对象——例如，使用对象池来驯服垃圾收集器。</li><li id="d822" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">不要假装提供任何类型保证，这样调用者就不会使用<code class="du jz ka kb kc b">instanceof</code>和其他不可靠的类型检查方法，这些方法可能会在执行上下文中破坏代码，或者如果您切换到抽象工厂。</li><li id="ea49" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">因为工厂不会假装提供类型保证，所以它们可以动态地将实现换成抽象工厂。例如，为不同媒体类型交换出<code class="du jz ka kb kc b">.play()</code>方法的媒体播放器。</li><li id="ae9b" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">工厂更容易添加组合功能。</li></ul><p id="f35a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">虽然使用类来完成这些目标中的大部分是可能的，但是使用工厂来完成更容易。潜在的bug陷阱更少，复杂程度更低，代码也更少。</p><p id="7720" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">出于这些原因，从<code class="du jz ka kb kc b">class</code>到工厂的重构通常是可取的，但这可能是一个复杂的、容易出错的过程。从类到工厂的重构是每一种面向对象语言的普遍需求。你可以在Martin Fowler，Kent Beck，John Brant，William Opdyke和Don Roberts所著的<a class="ae jv" href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=e7d5f652bc860f02c27ec352e1b8342c" rel="noopener ugc nofollow" target="_blank">“重构:改进现有代码的设计”</a>中了解更多信息。</p><p id="388e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">由于<code class="du jz ka kb kc b">new</code>改变了被调用函数的行为，从类或构造函数改变为工厂函数是一个潜在的破坏性改变。换句话说，强迫调用者使用<code class="du jz ka kb kc b">new</code>可能会无意中将调用者锁定在构造函数实现中，因此<code class="du jz ka kb kc b">new</code>会将潜在的破坏实现的细节泄露到调用API中。</p><p id="4c07" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">正如我们已经看到的，以下隐含行为会使切换成为一个突破性的变化:</p><ul class=""><li id="3e8c" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">工厂实例中缺少<code class="du jz ka kb kc b">[[Prototype]]</code>链接将破坏调用者<code class="du jz ka kb kc b">instanceof</code>检查。</li><li id="267e" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">工厂实例中缺少<code class="du jz ka kb kc b">.constructor</code>属性可能会破坏依赖它的代码。</li></ul><p id="4ab2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这两个问题都可以通过在工厂中手工连接这些属性来解决。</p><p id="d520" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在内部，您还需要注意的是<code class="du jz ka kb kc b">this</code>可能是从工厂调用站点动态绑定的，当调用者使用<code class="du jz ka kb kc b">new</code>时就不是这样了。如果您想将替代的抽象工厂原型作为静态属性存储在工厂中，这可能会使事情变得复杂。</p><p id="926e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">还有另一个问题。所有<code class="du jz ka kb kc b">class</code>调用方必须使用<code class="du jz ka kb kc b">new</code>。在ES6中关闭它总是会抛出:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="cfb9" class="kr ks hh kc b fi lz ma l mb mc">class Foo {};</span><span id="99da" class="kr ks hh kc b fi md ma l mb mc">// TypeError: Class constructor Foo cannot be invoked without 'new'<br/>const Bar = Foo();</span></pre><p id="2c15" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在ES6+中，箭头函数通常用于创建工厂，但是因为箭头函数在JavaScript中没有自己的<code class="du jz ka kb kc b">this</code>绑定，所以用<code class="du jz ka kb kc b">new</code>调用箭头函数会抛出一个错误:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="0328" class="kr ks hh kc b fi lz ma l mb mc">const foo = () =&gt; ({});</span><span id="3f32" class="kr ks hh kc b fi md ma l mb mc">// TypeError: foo is not a constructor<br/>const bar = new foo();</span></pre><p id="f5bf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所以，如果你试图从一个类重构到一个箭头函数工厂，它将在原生ES6环境中失败，这是可以的。努力失败是好事。</p><p id="7a41" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是，如果你把箭头函数编译成标准函数，就会<em class="iy">失败</em>失败。这很糟糕，因为这应该是一个错误。它会在你构建应用程序时“工作”,但在生产中可能会失败，这会影响用户体验，甚至阻止应用程序工作。</p><p id="66eb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">编译器默认设置的改变可能会破坏你的应用程序，即使你没有改变任何你自己的代码。这一点值得重复:</p><blockquote class="it iu iv"><p id="3aeb" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi"/></p></blockquote><h2 id="0073" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">要求new的代码违反了开放/封闭原则</h2><p id="ed56" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">我们的API应该对扩展开放，但对突破性的改变关闭。由于对一个类的常见扩展是把它变成一个更灵活的工厂，但是重构是一个突破性的改变，需要<code class="du jz ka kb kc b">new</code>关键字的代码对扩展是封闭的，对突破性的改变是开放的。那和我们想要的正好相反。</p><p id="938e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这件事的影响比一开始看起来要大。如果你的<code class="du jz ka kb kc b">class</code> API是公共的，或者如果你和一个非常大的团队一起开发一个非常大的应用程序，重构很可能会破坏你甚至没有意识到的代码。更好的办法是完全废弃这个类，用一个工厂函数来代替它。</p><p id="89d6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个过程将一个可以通过代码悄悄解决的小技术问题变成了一个需要意识、教育和认同的无界的人的问题——一个更昂贵的改变！</p><p id="1aae" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我已经多次看到<code class="du jz ka kb kc b">new</code>问题导致非常昂贵的头痛，而且很容易避免:</p><blockquote class="me"><p id="aa41" class="mf mg hh bd mh mi mj mk ml mm mn ju dx translated">导出工厂而不是类。</p></blockquote><h1 id="59db" class="mt ks hh bd kt mu mv mw kx mx my mz lb na nb nc le nd ne nf lh ng nh ni lk nj bi translated"><code class="du jz ka kb kc b">class</code>关键字和扩展</h1><p id="10de" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">对于JavaScript中的对象创建模式来说，<code class="du jz ka kb kc b">class</code>关键字应该是一种更好的语法，但是它在几个方面存在不足:</p><h2 id="22a2" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">友好的语法</h2><p id="c364" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated"><code class="du jz ka kb kc b">class</code>的主要目的是提供一个友好的语法来模仿JavaScript中其他语言的<code class="du jz ka kb kc b">class</code>。我们应该问自己的问题是，JavaScript真的需要模仿其他语言的<code class="du jz ka kb kc b">class</code>吗？</p><p id="bfd3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript的工厂函数提供了一个更加友好的现成语法，并且复杂度更低。通常，一个对象文字就足够了。如果您需要创建许多实例，工厂是一个很好的下一步。</p><p id="e981" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在Java和C++中，工厂比类更复杂，但无论如何它们通常是值得构建的，因为它们提供了增强的灵活性。在JavaScript中，工厂没有类复杂，也更灵活。</p><p id="3502" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">比较班级:</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="82eb" class="kr ks hh kc b fi lz ma l mb mc">class User {<br/>  constructor ({userName, avatar}) {<br/>    this.userName = userName;<br/>    this.avatar = avatar;<br/>  }<br/>}</span><span id="3bea" class="kr ks hh kc b fi md ma l mb mc">const currentUser = new User({<br/>  userName: 'Foo',<br/>  avatar: 'foo.png'<br/>});</span></pre><p id="6b6b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">与同等工厂相比…</p><pre class="lr ls lt lu fd lv kc lw lx aw ly bi"><span id="7812" class="kr ks hh kc b fi lz ma l mb mc">const createUser = ({ userName, avatar }) =&gt; ({<br/>  userName,<br/>  avatar<br/>});</span><span id="3315" class="kr ks hh kc b fi md ma l mb mc">const currentUser = createUser({<br/>  userName: 'Foo',<br/>  avatar: 'foo.png'<br/>});</span></pre><p id="12cd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">熟悉了JavaScript和arrow函数之后，工厂显然语法更少，更容易阅读。也许你更喜欢看到<code class="du jz ka kb kc b">new</code>关键词，但是有很好的理由避免<code class="du jz ka kb kc b">new</code>。熟悉偏见可能会阻碍你的发展。</p><p id="3e97" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">还有哪些论点？</p><h2 id="8563" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">性能和内存</h2><blockquote class="me"><p id="b705" class="mf mg hh bd mh mi mj mk ml mm mn ju dx translated">代表原型的好用例很少。</p></blockquote><p id="a007" class="pw-post-body-paragraph iw ix hh iz b ja mo jc jd je mp jg jh jw mq jk jl jx mr jo jp jy ms js jt ju ha bi translated"><code class="du jz ka kb kc b">class</code>语法比ES5构造函数的等价语法好一点，但是主要目的是连接委托原型链，委托原型的好用例很少。这真的归结为性能。</p><p id="2717" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du jz ka kb kc b">class</code>提供了两种性能优化:存储在委托原型上的属性的共享内存，以及属性查找优化。</p><p id="28fe" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi">委托原型</strong>内存优化对工厂和类都可用。工厂可以通过在对象文本中设置<code class="du jz ka kb kc b">__proto__</code>属性或者使用<code class="du jz ka kb kc b">Object.create(proto)</code>来设置原型。</p><p id="2fec" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">即便如此，大多数现代设备的内存都是以千兆字节计算的。在使用委托原型之前，您应该分析并确保它是真正需要的。</p><p id="8f24" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">任何类型的闭包作用域或<strong class="iz hi">属性访问</strong>都是以每秒数十万次或数百万次操作来衡量的，因此在应用程序的上下文中<em class="iy">很难衡量</em>性能差异，更不用说影响了。</p><p id="59ad" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当然，也有例外。RxJS使用了<code class="du jz ka kb kc b">class</code>实例，因为它们比闭包作用域更快，但是RxJS是一个通用的实用程序库，可以用于需要压缩到16ms渲染循环中的成千上万个操作的上下文中。</p><p id="2a67" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">ThreeJS使用类，但ThreeJS是一个3d渲染库，它可能用于游戏引擎每16毫秒处理数千个对象。</p><p id="6c8f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对于像ThreeJS和RxJS这样的库来说，尽可能地进行极端优化是有意义的。</p><p id="e2ea" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在应用程序的上下文中，我们应该避免过早的优化，并且只将我们的努力集中在它们会产生巨大影响的地方。对于大多数应用程序来说，这意味着我们的网络调用&amp;有效载荷、动画、资产缓存策略等…</p><p id="40fd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">除非您已经注意到了性能问题，分析了您的应用程序代码，并确定了真正的瓶颈，否则不要对性能进行微优化。</p><p id="9993" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">相反，您应该为了维护和灵活性而优化代码。</p><h2 id="bd72" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">类型检查</h2><p id="61af" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">JavaScript中的类是动态的，并且<code class="du jz ka kb kc b">instanceof</code>检查不能跨执行上下文工作，所以基于<code class="du jz ka kb kc b">class</code>的类型检查是不可行的。不靠谱。这很可能会导致错误，并使您的应用程序变得不必要的僵化。</p><h2 id="a618" class="kr ks hh bd kt ku kv kw kx ky kz la lb jw lc ld le jx lf lg lh jy li lj lk ll bi translated">带有“extends”的类继承</h2><p id="e6a1" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">类继承导致了几个值得重复的众所周知的问题:</p><ul class=""><li id="686f" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">紧密耦合:类继承是面向对象设计中最紧密的耦合形式。</li><li id="4f89" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated"><strong class="iz hi">不灵活的层次结构:</strong>如果有足够的时间和用户，所有的类层次结构对于新的用例来说最终都是错误的，但是紧密耦合使得重构变得困难。</li><li id="9a9f" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated"><strong class="iz hi">大猩猩/香蕉问题:</strong>没有选择性遗传。“你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。”~乔·阿姆斯特朗在<a class="ae jv" href="https://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483/ref=as_li_ss_tl?s=books&amp;ie=UTF8&amp;qid=1500436305&amp;sr=1-1&amp;keywords=coders+at+work&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=45e89bc5d776b1326c2ae90355e9ccac" rel="noopener ugc nofollow" target="_blank">《工作中的编码员》</a></li><li id="9f12" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated"><strong class="iz hi">必要的复制:</strong>由于不灵活的层次结构和大猩猩/香蕉问题，代码重用通常是通过复制/粘贴来完成的，这违反了DRY(不要重复自己)，并且首先破坏了继承的全部目的。</li></ul><p id="f93c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du jz ka kb kc b">extends</code>的唯一目的是创建单祖先类分类法。一些聪明的黑客读到这里会说，“啊哈！不是这样的！可以做班级作文！”对此我的回答是，“啊，但是现在你在使用对象组合而不是类继承，在JavaScript中有更容易、更安全的方法来做到这一点，而不需要使用<code class="du jz ka kb kc b">extends</code>”</p><h1 id="cc70" class="mt ks hh bd kt mu mv mw kx mx my mz lb na nk nc le nd nl nf lh ng nm ni lk nj bi translated">如果你小心的话，上课是可以的</h1><p id="b0ff" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">随着所有警告的消失，出现了一些清晰的指导方针，可以帮助您安全地使用类:</p><ul class=""><li id="a383" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">避免<code class="du jz ka kb kc b">instanceof</code>——这是因为JavaScript是动态的，有多个执行上下文，而<code class="du jz ka kb kc b">instanceof</code>在这两种情况下都会失败。如果您以后转到抽象工厂，也会带来问题。</li><li id="3d29" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">避免<code class="du jz ka kb kc b">extends</code>——不要多次扩展一个层次结构。"优先选择对象组合而不是类继承."~ <a class="ae jv" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8/ref=as_li_ss_tl?s=digital-text&amp;ie=UTF8&amp;qid=1500478917&amp;sr=1-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=7443052c45c6e7d9cb7f6b06fa58b488" rel="noopener ugc nofollow" target="_blank">“设计模式:可复用面向对象软件的要素”</a></li><li id="1150" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">避免导出您的类。在内部使用<code class="du jz ka kb kc b">class</code>来提高性能，但是导出一个创建实例的工厂来阻止用户扩展你的类，并避免强迫调用者使用<code class="du jz ka kb kc b">new</code>。</li><li id="95f5" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated">避开<code class="du jz ka kb kc b">new</code>。只要有意义就尽量避免直接使用，不要强迫你的呼叫者使用。(改为导出工厂)。</li></ul><p id="f8bb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在以下情况下可以使用class:</p><ul class=""><li id="e504" class="kd ke hh iz b ja jb je jf jw kf jx kg jy kh ju ki kj kk kl bi translated">你正在为一个框架构建UI组件，比如React或Angular。这两个框架都将组件类包装到工厂中，并为您管理实例化，因此您不必在自己的代码中使用<code class="du jz ka kb kc b">new</code>。</li><li id="b7d5" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated"><strong class="iz hi">你永远不会从你自己的类或组件中继承。相反，尝试对象组合、函数组合、高阶函数、高阶组件或模块——它们都是比类继承更好的代码重用模式。</strong></li><li id="3e2e" class="kd ke hh iz b ja km je kn jw ko jx kp jy kq ju ki kj kk kl bi translated"><strong class="iz hi">你需要优化性能。</strong>记住导出一个工厂，这样调用者就不必使用<code class="du jz ka kb kc b">new</code>也不会被诱入<code class="du jz ka kb kc b">extends</code>陷阱。</li></ul><p id="6839" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在大多数其他情况下，工厂会为你提供更好的服务。</p><p id="0260" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">工厂比JavaScript中的类或构造函数简单。总是从最简单的解决方案开始，只在需要时才发展到更复杂的解决方案。</p><p id="9d8b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/composable-datatypes-with-functions-aec72db3b093"> <strong class="iz hi"> <em class="iy">接下来:带函数的可组合数据类型&gt; </em> </strong> </a></p><h1 id="ed7f" class="mt ks hh bd kt mu mv mw kx mx my mz lb na nk nc le nd nl nf lh ng nm ni lk nj bi translated">后续步骤</h1><p id="e44a" class="pw-post-body-paragraph iw ix hh iz b ja lm jc jd je ln jg jh jw lo jk jl jx lp jo jp jy lq js jt ju ha bi translated">想了解更多关于用JavaScript进行对象组合的知识吗？</p><p id="6a7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><a class="ae jv" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟埃里克·艾略特学习JavaScript】。如果你不是会员，你就错过了！</a></p><figure class="lr ls lt lu fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es nn"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl no np go nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">著有</em> <a class="ae jv" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【编程JavaScript应用】</em> </a> <em class="iy">(奥赖利)，以及</em> <a class="ae jv" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【跟埃里克·艾略特学JavaScript】</em></a><em class="iy">。他为Adobe Systems</em><strong class="iz hi"><em class="iy"/></strong><em class="iy"/><strong class="iz hi"><em class="iy">尊巴健身</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">华尔街日报</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC</em></strong><em class="iy">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>