# 从消息验证到用户状态，提高应用的加密能力

> 原文：<https://medium.com/androiddevelopers/improve-your-apps-cryptography-from-message-authentication-to-user-presence-869277f50d34?source=collection_archive---------0----------------------->

![](img/dd2f1b345daff7db9b6cc12284e2fcd7.png)

在一个完美的世界里，没有人需要密码。每个人都把自己的手、眼睛和耳朵留给自己；每个包裹都没有被篡改地交付给预期的收件人；而且每个发件人都值得信任。但是我们并不是生活在一个完美的世界里。在过去的几十年里，加密技术已经发展到不仅通过加密来确保机密性，还确保消息的完整性、身份验证和不可否认性，所有这些都是为了保持消息的私密性、真实性和可靠性。

人们可能会想，如果您的系统有加密的可靠实现，那么您就不需要生物识别来验证用户的存在。为了理解为什么验证用户存在在加密世界中可能是重要的，让我们依次看看加密的几个属性的成功和失败。从这一点上看，作为银行或医疗保健等高价值服务的提供商，除了加密之外，您为什么还想实施生物认证。

# 加密本身并不能防止某些类型的攻击

你可以把加密想象成一个函数，比如说`E`，它接收一条消息`m`和一个密钥`k`，并从这些参数中产生一个密文`c`。密文通常是人们日常所说的加密，但实际上加密是一种产生对手无法读取的加密信息的算法。加密的信息本身被称为密文。

`c = E(m,k)`

当你仅仅部分知道`m`或`c`时，实际上不可能确定秘密密钥`k`，只要`k`的值足够大。但是对手不需要解密信息就可以篡改它。对手可能能够编辑密文、删除密文或重新发送包含密文的消息(使用称为重放的过程)。

不是所有的对手都想窃取你的数据；他们可能只是想给你带来不便。想象一下，一个对手只是重放了你为购买笔记本电脑而向电脑商店支付的 2000 美元的加密交易。假设这是一个与计算机商店无关的第三方对手，这个对手什么也没偷。和电脑商店发生一些纠纷后，你会拿回你的钱。然而，在时间和情绪能量方面，你仍然会受到一些伤害。更糟糕的是，观察敏锐的对手可能会用其他银行账户替换计算机商店的银行账户，而无需解密密文。

当然，我们只是触及了表面。还有许多针对纯加密解决方案的众所周知的攻击。即使你的加密算法设法挫败了所有已知的攻击，爱默生的预言仍然是*让自己为人所知是真理的特权*。简单地说，你不能永远保持一条消息的私密性。即使有最好的实用加密设计，当前技术进步的速度也只能让你的信息再保密 30 年，运气好的话可能 50 年。因此，加密本身并不能很好地抵御消息完整性攻击者。您还需要某种身份验证，这将在下一节中探讨。

# 通过消息认证保持原创性

在敏感的情况下被欺骗性地误导是有害的。这是启发安全工程师创造消息认证码(又名 MAC 或 HMAC)的基本事实。如果发送者随消息一起发送 MAC，那么对手就不能再修改消息并假装它是原始消息。对手也不能重放消息。对手能做的最好的事情就是删除消息，这样通信就完全失败了。

什么是 MAC？MAC `a`类似于密文，因为它是使用消息和密钥计算的。本质上，发送方通过函数`h`运行消息`m`和密钥`k`，生成 MAC。然后，发送方将消息和 MAC 发送给接收方。

`m,a = h(m,k)`

由于鸽笼原理，MAC 的每条消息都不是唯一的，这基本上是说，如果你的鸽子比洞多，那么一些洞将不得不容纳一只以上的鸽子。MAC 有预先确定的大小，因此可能的消息比 MAC 多得多。只是搜索空间太大，对手无法在不知道密钥的情况下猜测哪台 MAC 会使用修改过的消息。因此，MAC 对消息修改有效的原因是因为秘密密钥`k`只有发送者和预期接收者知道。如果对手改变消息，对手也必须改变 MAC 来匹配，而不知道密钥，这实际上是不可能的。重放攻击失败是因为连续运行`m,a = h(m,k)`两次会导致两个不同的 MAC。这是因为在实践中，函数中通常有一个严格递增的第三个参数`t`:因此我们可以将等式改写为`m,a = h(m,k,t)`。因此，MAC 功能帮助合法接收者容易地验证重放攻击是否发生。

MAC 本质上需要攻击者破解密钥。在 MAC 存在的情况下，对原始信息的模仿不再能够成功。正直是内在的。尽管苹果电脑很有用，但它们在保密方面确实有一些限制，这将在下一节解释。

# 签字但未盖章

值得注意的是，MAC 只是对信息进行签名，并不进行密封，因此不存在保密性。对手仍然可以读取消息；他们只是不能有效地改变它。但是在邮件上签名和盖章并不困难。不用计算`m,a = h(m,kₐ)`，只需用代数代换得到`c,a = h(c,kₐ)`，其中`c`是从`c = E(m,k𝒸)`得到的密文。

好的密码算法就像好的房子。人们认为它们可以抵御风暴不止一天，而是 30 年或更长时间。更具体地说，对于密码学家来说，这意味着预期对手不仅会在明天或下个月，而是在 10 年、30 年后试图破解你的算法——到那时，他们将拥有甚至尚未发明的技术优势。因此，MAC 并不能使加密牢不可破。这只会让对手的工作更加困难。30 年后，攻击者可能能够使用像[生日攻击](https://en.wikipedia.org/wiki/Birthday_attack#:~:text=A%20birthday%20attack%20is%20a,between%20two%20or%20more%20parties.)或[中间相遇攻击](https://en.wikipedia.org/wiki/Meet-in-the-middle_attack)这样的技术来猜测 MAC 对一条编辑过的消息的价值，从而使接收者接受模仿的消息。

# 非对称加密更优雅地扩展

到目前为止，我们已经讨论了密码学家如何将加密与 MAC 配对来创建签名和密封的消息。我们还讨论了攻击者能做的最好的事情就是删除这样的消息；否则，消息将被成功地、秘密地、完整地传递。听起来这就是我们所需要的。但是还有更多。但是在我们讨论“更多”之前，让我们先讨论一下规模。

到目前为止讨论的大多数技术统称为*对称加密*。简单地说，它们依赖于发送方和接收方使用完全相同的密钥来加密和解密消息，以及创建和验证 MAC。这种方法的问题是，如果一个组有 10 个成员，那么每个成员需要共享和存储 9 个不同的密钥，以便在任意两个成员之间发送加密的消息。总共有 45 把钥匙。对 20 个人来说，已经是 190 把钥匙了；更普遍的是，对于`n`人来说是`(n-1)n/2`键。想象一下，如果您的联系人列表中的每个人都有不同的个人电话号码，那该有多好？因此，每次你交一个新朋友时，你需要购买一个额外的电话号码，而不是只有一个电话号码发给每个联系人。这就是对称加密的问题。扩展是艰难的。谢天谢地，有不对称加密技术。

*非对称加密*使用数论的见解——特别是[有限域理论](https://mathworld.wolfram.com/FiniteField.html)和[单向函数](https://mathworld.wolfram.com/One-WayFunction.html)——来实现它的优雅。实际上，每个人都创建一个公钥和一个私钥。任何想和你交流的人都可以用你的公钥给你发送加密的消息，但是只有你的私钥可以解密那些消息。

这里的目的不是深入数论，而是将非对称加密引入对话。您必须使用非对称加密来支持不可否认性，这是我们下面讨论的加密的下一个属性。

# 不可否认的需要

不可否认只是说“不可收回”的一种专业方式电子商务革命将这一非常简单的公平竞争规则带到了密码学世界的前沿和中心。

在对称密钥的世界中，接收消息的人(比如 Bob)无法向法官证明发送者(比如 Alice)就是实际发送消息的人。那是因为爱丽丝和鲍勃共享同一个密钥。也许爱丽丝确实发送了原始消息，但是鲍勃修改了它，或者爱丽丝在撒谎。无论哪种情况，法官都无法判断。

然而，使用非对称密钥，只有持有私钥的人才能签署消息。世界上的任何人都可以阅读签名，因为公钥毕竟是公开的。因此，事情会是这样的:当 Alice 需要从 Bob 那里买东西时，她会使用 Bob 的公钥加密交易，但使用她自己的私钥给交易添加签名。然后，当 Bob 接收到消息时，他将使用 Alice 的公钥来验证 Alice 的私钥被用于签署交易，然后使用他自己的私钥来解密消息。因此，签名用于提供不可否认性。MAC 和 Signature 本质上是一回事，只不过一个是对称加密，一个是非对称加密。

# 简要回顾

现在让我们回顾一下。密码术用于加密和验证消息，并提供不可否认性。当应用正确的技术时，身份验证和加密部分可能很难破解，它们依赖于非常困难的数学问题，如素数因式分解、离散对数和椭圆曲线，然后应用于有限域。需要指出的是，虽然使用数学分析获取加密密钥可能很困难，但有许多其他方法可以侵入安全系统，如社会工程，其中个人可能会被诱骗泄露机密信息。此外，我们在讨论中没有包括密钥生成和认证，因为已经充分说明了这一点:作为一门工程学科，密码学将需要继续发展以满足时代的需求，以试图保持领先于对手。

然而，与加密和认证不同，不可否认性有点棘手，这是用户存在验证可能给对手增加额外难度的地方。

# 在场的重要性

在这一点上，我们已经表明，加密完全是关于安全级别的:对手篡改通信的代价(时间、金钱、能量)有多高。尽管如此，仍然存在一个主要问题:仅仅因为一条消息来自我拥有的设备，并且用我的私钥进行了签名，并不意味着我发送了这条消息。可能是病毒或未经授权的用户发送了该邮件。出于这些和类似的原因，尽管数字签名已经作为[设计](https://en.wikipedia.org/wiki/Electronic_Signatures_in_Global_and_National_Commerce_Act)成为国际法律，但许多全球商家仍然不信任它们，因为在没有用户存在的证据的情况下，很难论证不可否认性，并且举证责任确实在于商家。

为了增强商家对不可否认性的信心，业界引入了[双因素认证](https://en.wikipedia.org/wiki/Multi-factor_authentication) (2FA)。因为网络罪犯一再闯入仅受用户名和密码保护的在线账户，2FA 提出了一个想法，要求声称是合法用户的代理人*再做一件事*。那个*还有一件事*通常属于三类中的一类:你知道的事、你拥有的事或你是什么样的人。2FA 的目的是让商家相信用户在交易过程中确实在场。2FA 最常见的两种形式是密钥卡和验证码，它们通常使用 SMS 发送。密钥卡和类似硬件令牌的问题是它们可能会丢失或被盗。如果受危害的设备是接收 SMS 或推送通知的同一设备，则 SMS 消息为 2FA 提供零深度防御。因此，今天 2FA 的最高级形式属于*你是*的东西。生物认证就是这种高级 2FA 的一个例子。

通过将生物识别技术(验证用户存在)纳入您的安全实施中，您的应用将变得更加安全，认可将成为您业务模式的一个可靠特性。对于医疗保健或酒店应用程序，这可能意味着更可靠的用户签到或取消。对于一个电子商务或银行应用程序，这可能意味着你的客户服务团队花更少的时间为幼儿无意购买的商品退款，花更多的时间用更令人愉快的方式让你的客户开心。

使生物识别认证成为对抗安全系统对手的真正额外障碍的根本原因是，虽然生物识别和加密完全相互独立，但它们都很难被对手篡改。因此，他们的联合力量使得对手的工作更加困难。

例如，在 Android 上，生物特征验证是一条单行道。用户的生物特征信息不会离开设备，也不会与应用程序共享。当用户决定将他们的生物特征添加到他们的 Android 设备时，他们必须通过系统的设置应用程序来完成。如果他们使用指纹(或面部)，他们将手指放在传感器上，传感器将指纹图像直接传递到 Android 设备上的一个受限区域，称为*可信执行环境* (TEE)。然后，当您的应用程序希望通过生物认证来验证用户存在时，Android 框架和 Android 上的生物识别系统(位于 TEE 中)会为您的应用程序处理整个用户存在验证过程。由于该框架使得欺骗设备所有者的生物特征变得极其困难，因此您可以对用户存在确认有很高的信心。

要更深入地了解生物识别如何在 Android 上工作，以增强您的安全解决方案的不可否认性，请参见我们在[上的博客文章将生物识别提示与 cryptobject](/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7)结合使用。

# 摘要

在这篇文章中，你学到了以下内容:

*   为什么一个好的加密实现需要解决机密性、认证和不可否认性。
*   为什么加密本身不足以保护信息免受敌人攻击。
*   为什么 MAC/HMAC 能有效防止消息修改
*   为什么非对称加密比对称加密具有更好的扩展性
*   为什么在现实生活中，没有生物认证就很难实现不可否认性
*   为什么生物认证通过用户存在验证使加密实现更强大。
*   如何在您的应用中实现生物认证？

我们还撰写了大量关于工程最佳实践、设计指南和将生物识别技术融入应用的技巧的博客文章。

*   要了解更多关于如何使用生物认证实现你的应用的信息，请查看这个由两部分组成的博客系列:[第一部分](/androiddevelopers/biometric-authentication-on-android-part-1-264523bce85d)、[第二部分](/androiddevelopers/biometric-authentication-on-android-part-2-bc4d0dae9863)。
*   如果您的应用程序包含使用 FingerprintManager 的旧逻辑，我们建议您改用 BiometricPrompt。在[One Biometric API Over all Android](https://android-developers.googleblog.com/2019/10/one-biometric-api-over-all-android.html)中全面了解 BiometricPrompt，并在本帖中了解如何完成迁移:[从 FingerprintManager 迁移到 BiometricPrompt](/androiddevelopers/migrating-from-fingerprintmanager-to-biometricprompt-4bc5f570dccd)

编码快乐！