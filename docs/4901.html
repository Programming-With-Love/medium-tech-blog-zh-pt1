<html>
<head>
<title>Mastering Kotlin Scoped and Higher-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Kotlin作用域和高阶函数</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/mastering-kotlin-scoped-and-higher-order-functions-23e2dd34d660?source=collection_archive---------0-----------------------#2019-11-12">https://blog.kotlin-academy.com/mastering-kotlin-scoped-and-higher-order-functions-23e2dd34d660?source=collection_archive---------0-----------------------#2019-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5ae3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">学习如何创造，而不是如何使用</p><p id="7846" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您正在使用Kotlin，您一定见过如下表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b42b9bfaff3749b16640a0a53529c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wZoYYxqh_7_B8JQ2.png"/></div></div></figure><h2 id="2cfa" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">暂时忘记表中所说的内容。不要背表。让我们从头开始。</strong></h2><p id="a65d" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">声明:这将是一篇长文(掌握一些需要努力的东西)。我会将文章分成几个部分，并添加休息，每当你看到一个休息标题，休息一下。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="5402" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一会儿💆</h1><p id="13c5" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">网上有很多(我是认真的)文章解释作用域函数做什么以及如何使用它们。本文更进了一步。我们不仅会理解他们做了什么，而且会“掌握这个概念”</p><blockquote class="mq mr ms"><p id="4f39" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated"><strong class="jm io">大师都是做什么的？大师是这样的人，他的基础很清楚，他知道如何创造东西，而不仅仅是如何使用。</strong></p></blockquote><p id="4854" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要理解两个非常简单和容易的概念，你就能成为大师。</p><ol class=""><li id="0586" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated"><strong class="jm io">扩展功能</strong></li><li id="a7de" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><strong class="jm io">高阶函数和λ</strong></li></ol><p id="7889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如果你想知道为什么这两个概念与作用域函数(let、apply、also、run等)相关。)</strong>！你很快就会知道。这里我们快速复习一下题目。如果你没有用过这两个概念，我推荐你多读官方文档和文章。</p><h2 id="30c0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">扩展功能</h2><p id="83b3" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">根据<a class="ae nl" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">官方文档，Kotlin提供了用新功能扩展类的能力，而不必从类继承或使用设计模式，如Decorator。</a></p><p id="7b42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，您可以在一个类中声明一个新的函数，而无需更改原始代码，并使用该类的实例来调用该函数。您甚至不必访问该类的源代码。</p><p id="00c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语法是:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3b0d" class="ku kv in nn b gy nr ns l nt nu">fun AnyClass.yourNewFunction(optionalParamIfNeeded : Type) {<br/>    <br/>   // do your magic here and use the instance of AnyClass as `this`</span><span id="5785" class="ku kv in nn b gy nv ns l nt nu">}</span></pre><p id="f05f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您希望在<code class="fe nw nx ny nn b">String</code>类中有一个函数将值转换为<code class="fe nw nx ny nn b">camelcase</code>。你可以定义一个<code class="fe nw nx ny nn b">function</code>:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ce45" class="ku kv in nn b gy nr ns l nt nu">fun String.toCamelCase() { <br/>// some magic, the instance of String is available as `this`<br/>  <!-- -->return camelCased;<br/>}</span><span id="44fc" class="ku kv in nn b gy nv ns l nt nu">fun String.toCamelCase() {<br/>   this.substring(1)   // referring the caller as this<em class="mt"><br/>   </em>return camelCased;<br/>}</span></pre><h2 id="4454" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">高阶函数和λ</h2><p id="9c29" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated"><a class="ae nl" href="https://kotlinlang.org/docs/reference/lambdas.html" rel="noopener ugc nofollow" target="_blank">根据这里的官方文档</a>，高阶函数是以函数为参数或者返回函数的函数。让我们看一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="c980" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: () -&gt; Unit) {<br/>}</span></pre><p id="bc4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数<code class="fe nw nx ny nn b">doSomething</code>接受一个没有参数的函数<code class="fe nw nx ny nn b">() -&gt; Unit</code>并返回单位。Kotlin中没有void的概念，如果一个函数返回nothing，那么它返回Unit(编译器为你添加return语句)。该函数在参数中是必需的，参数名为<code class="fe nw nx ny nn b">block</code>您可以随意命名，甚至xyz</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="7c8b" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(xyz: () -&gt; Unit) { // valid, xyz is the param name<br/>}</span></pre><p id="aee1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">doSomething</code>函数如何调用传递的参数函数？语法非常简单:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="70dd" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(xyz: () -&gt; Unit) {<br/>    xyz() // call like a normal function<br/>}</span></pre><p id="8c96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案是像普通函数一样调用。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4792" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: () -&gt; Unit) {<br/>    block() // call like a normal function<br/>}</span></pre></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="3b6f" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一会儿💆</h1><p id="0053" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">让我们看看高阶函数的另一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="014b" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: () -&gt; String) {<br/>    val someString:String = block()  // param funtion returns String<br/>}</span></pre><p id="16b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一次，<code class="fe nw nx ny nn b">parameter</code>T2返回一个<code class="fe nw nx ny nn b">String</code>。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="8685" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: (i:Int) -&gt; String) { <br/>    // param funtion returns String<br/>    val someString:String = block(1)  <br/>}</span></pre><p id="ee1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这次，<code class="fe nw nx ny nn b">parameter</code>T5接受一个Int并返回一个<code class="fe nw nx ny nn b">String</code>。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="c085" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: () -&gt; String):String {<br/>    return block()  // param funtion returns String<br/>}</span></pre><p id="7a04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一次，<code class="fe nw nx ny nn b">doSomething</code>使用<code class="fe nw nx ny nn b">block</code>返回它想要的字符串，因为这个块也返回一个字符串</p><h2 id="a6e2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">将函数作为参数传递</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="bf1c" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>doSomething(block: () -&gt; Unit) {<br/>}</span></pre><p id="7078" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">doSomething</code>想要一个没有参数，返回单位的函数。</p><p id="c975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有几种方法可以调用<code class="fe nw nx ny nn b">doSomething</code>并传递函数</p><h2 id="747c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">方式1 —传递与结构匹配的现有函数</h2><p id="d063" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">假设我们有一个函数:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2763" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>randomFunction(){ println("I am random function") }</span></pre><p id="60b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，随机函数不接受任何参数，也不返回任何内容(该结构与我们在<code class="fe nw nx ny nn b">doSomething)</code>中想要的相匹配)</p><p id="b2a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以打电话给:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="8975" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething</em>(::randomFunction)</span></pre><p id="6b3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们调用<code class="fe nw nx ny nn b">doSomething</code>函数，并将<code class="fe nw nx ny nn b">randomFunction</code>作为参数传递。语法<code class="fe nw nx ny nn b">::</code>是引用一个函数</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="893f" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>randomFunction(){ println("I am random") }</span><span id="6323" class="ku kv in nn b gy nv ns l nt nu"><strong class="nn io">fun </strong>doSomething(block: () -&gt; Unit) {<br/>   block() // It will print "I am random"<br/>}</span><span id="d627" class="ku kv in nn b gy nv ns l nt nu"><em class="mt">doSomething</em>(::randomFunction) </span></pre><h2 id="722d" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">用参数调用传递的函数</h2><p id="6929" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">假设传递的<code class="fe nw nx ny nn b">function</code>接受<code class="fe nw nx ny nn b">parameters</code>，调用它和其他函数没什么区别:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="803f" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>randomFunction(){ println("I am random") }</span><span id="0128" class="ku kv in nn b gy nv ns l nt nu"><strong class="nn io">fun </strong>doSomething(block: (i:Int) -&gt; Unit) {}</span><span id="7b81" class="ku kv in nn b gy nv ns l nt nu">// will not compile ❌ as randomFunction does not accept Int</span><span id="b29a" class="ku kv in nn b gy nv ns l nt nu"><em class="mt">doSomething</em>(::randomFunction)</span></pre><h2 id="e569" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">方式2—传递匿名函数</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ce30" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>doSomething(block: (i:Int) -&gt; Unit) {}</span></pre><p id="6593" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以传递一个匿名函数，如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f354" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething </em>(fun(x:Int){<br/>    <br/>})</span></pre><p id="b24a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，我们创建了一个匿名函数，并作为参数传递。如果从<code class="fe nw nx ny nn b">doSomething</code>调用<code class="fe nw nx ny nn b">block(99)</code>，那么我们传递的函数将被调用，x的值为99</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="5a2d" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一会儿💆</h1><h2 id="d3b2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">方式3—创建一个扩展函数类型的类，并传递你的类的实例</h2><h2 id="e305" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">例1。</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="654a" class="ku kv in nn b gy nr ns l nt nu">interface CustomFunctionType : () -&gt; Unit {<br/>    override fun invoke()<br/>}</span></pre><p id="aa67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们创建了一个扩展了<code class="fe nw nx ny nn b">function</code>类型的<code class="fe nw nx ny nn b">interface</code>。这个<code class="fe nw nx ny nn b">function</code>的定义是它接受no <code class="fe nw nx ny nn b">parameter</code>并返回<code class="fe nw nx ny nn b">Unit</code>。</p><p id="6966" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的定义等于有了一个函数:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e4a0" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>customFunction() {}</span></pre><p id="0b93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不同之处在于我们可以创建<code class="fe nw nx ny nn b">CustomFunctionType</code>的实例，并在运行时提供实现，如下所示:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5c20" class="ku kv in nn b gy nr ns l nt nu">// Here we are creating an anonymous class<strong class="nn io"><br/>val </strong>dynamic = <strong class="nn io">object </strong>: CustomFunctionType{<br/>    <strong class="nn io">override fun </strong>invoke() {<br/>      // do your magic here    <br/>    }<br/>}</span></pre><p id="137e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们有一个期待类似签名函数的函数，我们可以传递上面创建的对象</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6bc6" class="ku kv in nn b gy nr ns l nt nu"><strong class="nn io">fun </strong>doSomething(block: () -&gt; Unit) {<br/>   block() // It will print "I am random"<br/>}</span><span id="520c" class="ku kv in nn b gy nv ns l nt nu">doSomething(dynamic)</span></pre><p id="acc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">乍一看，这似乎有点困难。重点是我们可以创建接口/类，它用涉及参数和返回类型的签名来扩展函数类型，例如<code class="fe nw nx ny nn b">()-&gt;Unit</code>，并且我们可以在函数签名匹配的地方将该类/接口的实例作为参数传递。</p><h2 id="dbc0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">例2。</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="505f" class="ku kv in nn b gy nr ns l nt nu">interface CustomFunctionType : (Int) -&gt; Unit {<br/>    override fun invoke(i:Int)<br/>}</span></pre><p id="0bee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们创建了另一个扩展函数类型的接口。这个函数的定义是:它接受一个int参数，不返回任何东西。</p><h2 id="1bb5" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">例3。</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fe78" class="ku kv in nn b gy nr ns l nt nu">interface CustomFunctionType : (Int, Int) -&gt; String {<br/>    override fun invoke(i:Int, j:Int):String<br/>}</span></pre><p id="b86c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这相当于一个接受两个int并返回一个String的函数。</p><h2 id="99c2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">加分</h2><p id="1292" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我想你的大脑正在嗡嗡作响。正如我们所知，高阶函数也可以赋给变量。这里有一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="87ff" class="ku kv in nn b gy nr ns l nt nu">fun doSum(i:Int, j:Int):Int{ <br/>  return i + j <br/>}</span><span id="5a91" class="ku kv in nn b gy nv ns l nt nu">val<strong class="nn io"> </strong>sum: (Int, Int) -&gt; Int = ::doSum</span></pre><p id="d2a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里sum的类型是<code class="fe nw nx ny nn b">functionType</code>,它接受两个Int参数并返回一个Int。我们用参考号<code class="fe nw nx ny nn b">::</code>分配函数<code class="fe nw nx ny nn b">doSum</code></p><p id="f1a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以称之为</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="cf7a" class="ku kv in nn b gy nr ns l nt nu">sum(1, 1) // equivalent to doSum(1,1)</span></pre></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="e68a" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一会儿💆</h1><h2 id="1658" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">方式4—进入Lambda世界</h2><p id="8678" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">正如我们在上面看到的，我们可以扩展函数类型并传递你的类的实例。科特林有一个同样的简写语法。这是一个λ。我们可以在任何需要FunctionType的地方使用lambda。语法是花括号，后面是参数，后面是正文。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="35bf" class="ku kv in nn b gy nr ns l nt nu">val<strong class="nn io"> </strong>sum: (Int, Int) -&gt; Int = {x: Int, y: Int -&gt; x + y}</span></pre><p id="81b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">右边是一个lambda，我们知道在kotlin中的类型推断，我们可以省略参数的类型。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="03bd" class="ku kv in nn b gy nr ns l nt nu">val<strong class="nn io"> </strong>sum: (Int, Int) -&gt; Int = {x, y -&gt; x + y}</span></pre><p id="b28b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所知，我们可以在任何需要FunctionType的地方使用lambda。这意味着我们可以使用一个lambda，在这里我们使用一个函数作为函数参数。让我们看同一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="d788" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: () -&gt; Unit) {<br/>}</span></pre><p id="f17e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，<code class="fe nw nx ny nn b">doSomething</code>需要一个函数，我们刚刚说过我们可以在这里使用λ。这个函数不接受任何参数，也不返回任何东西(这意味着Unit)，下面是一个用lambda的调用</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fba8" class="ku kv in nn b gy nr ns l nt nu">doSomething({})</span></pre><p id="425a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，就是这么简单。</p><p id="950f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何用lambda接受参数？同样非常简单，我们可以输入参数名，然后输入类型。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f21d" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: (i:Int, j:Int) -&gt; Unit) {<br/>}</span><span id="fafe" class="ku kv in nn b gy nv ns l nt nu">// call with lambda<br/>doSomething({x:int, y:Int -&gt; })</span></pre><p id="2743" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们如何从λ返回呢？我们知道科特林很聪明。lambda的最后一行被推断为返回，并且类型必须与预期的类型相匹配。示例:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="392d" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: (i:Int, j:Int) -&gt; String) {<br/>}</span><span id="fc82" class="ku kv in nn b gy nv ns l nt nu">// call with lambda<br/>doSomething({x:int, y:Int -&gt; <br/>// do some magic here <br/>"TheStringToReturn"<br/>})</span></pre><p id="71a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们正在返回<code class="fe nw nx ny nn b">TheStringToReturn</code>，因为函数类型期望接受两个int并返回一个String。当然，这是科特林，我们不需要罗嗦。我们可以省略参数类型</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5bb8" class="ku kv in nn b gy nr ns l nt nu">doSomething({x, y -&gt; <br/>// do some magic here <br/>})</span></pre><h2 id="7709" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">Lambda语法:特殊语法</h2><p id="d9e4" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">如果您调用的函数接受lambda(函数类型)，您可以在函数调用后键入lambda。乍一看似乎很奇怪，但这是一个简短的语法。我们可以将上面的lambda调用写成:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ba96" class="ku kv in nn b gy nr ns l nt nu">doSomething(){x, y -&gt; <br/>// do some magic here <br/>}</span></pre><h2 id="c64b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">Lambda语法:特殊的一个——还有一个技巧</h2><p id="a27a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">如果没有其他参数，只有lambda，我们也可以省略花括号。所以上面的例子变成了:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="5abd" class="ku kv in nn b gy nr ns l nt nu">doSomething {x, y -&gt; <br/>// do some magic here <br/>}</span></pre><p id="8b8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，这是合法的，真的很短。</p><h2 id="5ead" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">Lambda语法:特殊的一个——最后一招</h2><p id="567b" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">如果lambda中只有一个参数，也可以省略名称。默认名称是<code class="fe nw nx ny nn b"><strong class="jm io">it,</strong></code> <strong class="jm io"> </strong>是的，你可以访问lambda里面的参数为<code class="fe nw nx ny nn b"><strong class="jm io">it</strong></code></p><p id="5636" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="aeea" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: (i:Int) -&gt; String) { <br/>  block(5)<br/>}</span><span id="47b2" class="ku kv in nn b gy nv ns l nt nu">doSomething{"Hello, the value of single parameter passed is : $it"}</span></pre><p id="ca92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码片段调用了接受函数类型的<code class="fe nw nx ny nn b">doSomething</code>函数。我们使用了具有Kotlin提供的最短语法的lambda表达式。我们没有使用花括号，也没有使用lambda参数名，因为只有一个。我们指的是<code class="fe nw nx ny nn b">$it</code>。lambda返回的字符串是Lambda的最后一行。不需要return语句。</p><blockquote class="mq mr ms"><p id="4d36" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">实际上用lambda调用也没什么神奇的。科特林创建了一个类型为<code class="fe nw nx ny nn b">FunctionXX.</code>的匿名类</p></blockquote></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="0496" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一会儿💆</h1><h2 id="6139" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">接收器类型和λ</h2><p id="3bd4" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在我们进入作用域函数<code class="fe nw nx ny nn b">let, apply, also etc.</code>之前，我们需要理解最后一个概念。<code class="fe nw nx ny nn b"><strong class="jm io">Receiver Type</strong></code></p><p id="5493" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道了扩展函数和函数类型参数，在这个上下文中考虑接收器类型是两者的组合。我们可以用扩展函数语法定义函数类型param:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="0e14" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: String.() -&gt; Unit) {<br/>}</span></pre><p id="9391" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们在函数类型参数前使用了<code class="fe nw nx ny nn b">String.</code>。它说，新的<code class="fe nw nx ny nn b">function</code>成为了<code class="fe nw nx ny nn b">String</code>类的匿名扩展，需要一个<code class="fe nw nx ny nn b">String</code>的实例来调用这个<code class="fe nw nx ny nn b">function</code>类型。这里有一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="1cf8" class="ku kv in nn b gy nr ns l nt nu">fun<strong class="nn io"> </strong>doSomething(block: String.() -&gt; Unit) {</span><span id="0772" class="ku kv in nn b gy nv ns l nt nu">  block() <br/>  // ❌ not allowed as the function type is extension of String</span><span id="d7a0" class="ku kv in nn b gy nv ns l nt nu">  "Gaurav".block() <br/>  // ✅allowed, we are using String instance to call<br/>}</span><span id="5de5" class="ku kv in nn b gy nv ns l nt nu">// the shortest syntax<br/>doSomething {</span><span id="f91a" class="ku kv in nn b gy nv ns l nt nu"><strong class="nn io"> this</strong>.<em class="mt">substring</em>(1) </span><span id="4cff" class="ku kv in nn b gy nv ns l nt nu"> // this is referring to String instance, in this case Gaurav<br/>}</span></pre><p id="87e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们看到了字符串接收类型和函数类型参数的使用。它在String类上创建了一个匿名扩展函数。该函数被分配给参数名称，并且只能在我们可以访问该参数<code class="fe nw nx ny nn b">block.</code>的地方调用，但是如果我们不想硬编码接收方类型甚至返回类型，该怎么办呢？是的，你能猜到。</p><h2 id="7e77" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">具有泛型的接收器类型</h2><p id="e53e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">Kotlin和Java中的泛型是编译时类型，但它们令人惊叹，编译器在给运行时错觉方面做得非常出色。关于泛型的细节超出了本文的范围。这里是官方文件，我建议你读一些博客。让我们来看看Generic的实际应用:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="cdc1" class="ku kv in nn b gy nr ns l nt nu">fun&lt;R&gt; doSomething(block: String.(i: Int) -&gt; R) {<br/>    <em class="mt">println</em>("Gaurav".block(1))<br/>}</span></pre><p id="b1d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一次我们在函数类型参数的返回类型中使用了Generic + Receiver类型。我们可以用<code class="fe nw nx ny nn b">&lt;Type&gt;</code>调用如下函数:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3f07" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething</em>&lt;Int&gt; {<br/>  // do something here<br/>  100<br/>}</span></pre><p id="3ef5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的调用是用<code class="fe nw nx ny nn b">&lt;Int&gt;</code>进行的，所以编译器会要求函数类型返回Int。上面的lambda是返回100。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2170" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething</em>&lt;String&gt; {<br/>  // do something here<br/>  "Gaurav Khanna"<br/>}</span></pre><p id="7ac0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们使用String并返回一个字符串。记住，科特林很聪明，它能推断出类型。为什么要申报？Kotlin可以从lambda的最后一条语句中推断出返回类型:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="bb65" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething </em>{<br/>  // do something here<br/>  "Gaurav Khanna"<br/>}</span></pre><p id="730f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述调用相当于用<string>调用</string></p><p id="2569" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，我们可以将泛型与接收器类型一起使用:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="774b" class="ku kv in nn b gy nr ns l nt nu">fun&lt;T,R&gt; doSomething(t:T, block: T.() -&gt; R) {<br/>    <em class="mt">println</em>(t.block())<br/>}</span></pre><p id="d580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们用一个通用的接收者类型声明了函数类型，这意味着调用者将在这里定义类型。我们是这样称呼它的:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="9888" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething</em>&lt;String, Int&gt;("Gaurav") {<br/>    this.<em class="mt">substring</em>(1)<br/>    "from inside"<br/>    1<br/>}</span></pre><p id="6c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们明确指出，调用者是字符串类型，返回类型是Int类型。我们需要传递一个Caller类型的实例(本例中为String)。否则，函数<code class="fe nw nx ny nn b">doSomething</code>不能调用函数类型，因为它需要一个由调用者定义的类型<code class="fe nw nx ny nn b">T</code>的实例。是的，我们可以再次省略类型，编译器会为我们推断。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="def1" class="ku kv in nn b gy nr ns l nt nu"><em class="mt">doSomething</em>("Gaurav") {<br/>    this.<em class="mt">substring</em>(1)<br/>    "from inside"<br/>    1<br/>}</span></pre><p id="4b56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述函数调用相当于使用<string int=""/></p><p id="48d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一个带有接收器类型的通用示例:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="e694" class="ku kv in nn b gy nr ns l nt nu">fun&lt;T,R&gt; T.doSomething(block: T.() -&gt; R) {<br/>    <em class="mt">println</em>(block())<br/>}</span></pre><p id="a6cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">🥺🥺If，你的大脑嗡嗡嗡，继续站着。不要放弃。</p><p id="17bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，<code class="fe nw nx ny nn b">doSomething</code>被定义为一个带有泛型<code class="fe nw nx ny nn b">T</code> ( <code class="fe nw nx ny nn b">T.doSomething</code>)的扩展函数，这意味着它是每个调用方的扩展函数。是的，字面上每个实例都可以调用它是一个成员函数。</p><p id="1543" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">function type也是type T <code class="fe nw nx ny nn b">(T.() -&gt; R</code>上的一个匿名扩展函数，也就是说每个类的每个实例。</p><p id="e95a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我们不需要T的实例来调用上面例子中的<code class="fe nw nx ny nn b">block()</code>？答案是<code class="fe nw nx ny nn b">doSomething</code>也是扩展函数，<code class="fe nw nx ny nn b">block</code>也是扩展函数。间接的，它们是T类型的成员函数，同一个类的两个成员函数可以直接或者用关键字<code class="fe nw nx ny nn b">this</code>互相调用，如下所示</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="31fc" class="ku kv in nn b gy nr ns l nt nu">fun&lt;T,R&gt; T.doSomething(block: T.() -&gt; R) {<br/>    <em class="mt">println</em>(this.block())<br/>}</span></pre><h2 id="ba0f" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">🥺🥺If，你的大脑嗡嗡嗡，继续站着。不要放弃。</h2><p id="7b55" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这里，<code class="fe nw nx ny nn b">doSomething</code>被定义为一个带有泛型<code class="fe nw nx ny nn b">T</code> ( <code class="fe nw nx ny nn b">T.doSomething</code>)的扩展函数，这意味着它是每个调用者的扩展函数。是的，字面上每个实例都可以调用它是一个成员函数。</p><p id="360a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">function type也是type T <code class="fe nw nx ny nn b">(T.() -&gt; R</code>上的匿名扩展函数，也就是说每个类的每个实例。</p><p id="e6f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我们不需要T的实例来调用上面例子中的<code class="fe nw nx ny nn b">block()</code>？答案是<code class="fe nw nx ny nn b">doSomething</code>也是一个扩展函数，<code class="fe nw nx ny nn b">block</code>也是一个扩展函数。间接的，它们是T类型的成员函数，同一个类的两个成员函数可以直接或者用关键字<code class="fe nw nx ny nn b">this</code>互相调用，如下所示</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="cc84" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">休息一下，修改总结💆💆</h1><h1 id="d071" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">最后，让我们来看看Kotlin提供的范围函数</h1><p id="6edb" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">或者让我们等一段时间</p><p id="4372" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想创造一些例子，向你展示我们以前读过的东西的力量。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="b750" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T&gt; T.callMyAnonymousLambda(block: (T) -&gt; Unit) {<br/>   block(this)<br/>}</span></pre><p id="8098" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码片段中，我们用泛型声明了一个扩展函数。它接受一个函数类型的参数，该参数有一个与caller类型相同的参数，并且不返回任何内容(Unit)。</p><p id="1454" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">block(this)</code>用于调用lambda，因为它需要一个参数类型T，而<code class="fe nw nx ny nn b">this</code>是指来自&lt; T &gt;的函数<code class="fe nw nx ny nn b">callMyAnonymousLambda</code>的调用者。下面是一个调用上述函数的示例:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="48f2" class="ku kv in nn b gy nr ns l nt nu">"Gaurav".<em class="mt">callMyAnonymousLambda </em>{name -&gt;<br/>    <em class="mt">println</em>("My name is $name")<br/>}</span></pre><p id="9d57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在T变成了<code class="fe nw nx ny nn b">String</code>并且<code class="fe nw nx ny nn b">lambda</code>有一个参数<code class="fe nw nx ny nn b">String</code>作为<code class="fe nw nx ny nn b">name</code>传递</p><p id="f0c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住。如果我们没有在单个参数<code class="fe nw nx ny nn b">lambda</code>中给<code class="fe nw nx ny nn b">parameter</code>一个明确的名称，我们可以使用<code class="fe nw nx ny nn b">it</code></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6a9c" class="ku kv in nn b gy nr ns l nt nu">"Gaurav".<em class="mt">callMyAnonymousLambda </em>{<br/>    <em class="mt">println</em>("My name is $it")<br/>}</span></pre><h1 id="aa25" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">我的朋友，我们刚刚创建了自己的<code class="fe nw nx ny nn b">let</code>函数，类似于Kotlin</h1><p id="313a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">下面是let功能代码:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a0bc" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {<br/>    return block(this)<br/>}</span></pre><p id="ff83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">let</code>用<code class="fe nw nx ny nn b">Generic T</code>定义为每个类的扩展函数。调用者变成了<code class="fe nw nx ny nn b">T</code>，返回类型既可以显式声明，也可以由编译器推断。<code class="fe nw nx ny nn b">function-type</code>参数<code class="fe nw nx ny nn b">block</code>接受一个类型为<code class="fe nw nx ny nn b">T</code>的参数(在我们的例子中是调用者)并返回<code class="fe nw nx ny nn b">R</code>。函数<code class="fe nw nx ny nn b">let</code>也返回<code class="fe nw nx ny nn b">R.</code>；T24不知道<code class="fe nw nx ny nn b">R</code>，所以它使用<code class="fe nw nx ny nn b">block</code>返回<code class="fe nw nx ny nn b">R</code></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="6258" class="ku kv in nn b gy nr ns l nt nu">"Gaurav".<em class="mt">let</em>{ name-&gt;<br/>    <em class="mt">println</em>("My name is $name")<br/>}</span></pre><p id="26d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以省略单个参数，并参考<code class="fe nw nx ny nn b">it</code></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a4ba" class="ku kv in nn b gy nr ns l nt nu">"Gaurav".<em class="mt">let</em>{ <br/>    <em class="mt">println</em>("My name is $it")<br/>}</span></pre><p id="8a24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得上表中的<code class="fe nw nx ny nn b">let</code>条目吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/28a53e316c6f577ff3bf4532812d48bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AFw0wNVNkv5Bf_ntBjxyw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">function, refer inside lambda, return</figcaption></figure><p id="b050" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">let是一个扩展函数，lambda有一个参数(这是默认名称),它返回lambda的最后一条语句，因为let函数<code class="fe nw nx ny nn b">returns block(this)</code></p><h2 id="81a2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">让我们创建另一个自定义函数:</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4ad9" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T&gt; T.callExtensionLambdaAndReturnSelf(block: T.() -&gt; Unit) {<br/>    block()<br/>}</span></pre><p id="3cc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里用<code class="fe nw nx ny nn b">Generics &lt;T&gt;</code>定义了<code class="fe nw nx ny nn b">callExtensionLambdaAndReturnSelf</code>，所以这里调用者变成了<code class="fe nw nx ny nn b">T</code>。它接受匿名扩展<code class="fe nw nx ny nn b">function-type</code>，该扩展不接受<code class="fe nw nx ny nn b">parameter</code>，也不返回任何内容。我们的自定义<code class="fe nw nx ny nn b">function</code>也不返回任何东西(<code class="fe nw nx ny nn b">Unit</code>)</p><p id="d9b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<code class="fe nw nx ny nn b">callExtensionLambda_AndReturnSelf</code>和<code class="fe nw nx ny nn b">block</code>都是t类型的扩展成员，所以<code class="fe nw nx ny nn b">block()</code>在没有任何对象的情况下被调用。它们不需要任何显式引用。你也可以使用<code class="fe nw nx ny nn b">this.block()</code>来表达同样的意思。</p><h1 id="4351" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">我的朋友，我们刚刚创建了自己的<code class="fe nw nx ny nn b">apply</code>函数，类似于Kotlin</h1><p id="026e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">以下是应用功能代码:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="401d" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {<br/>    block()<br/>    return this<br/>}</span></pre><p id="9d87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里apply是任何类型<t>上的扩展函数，function-type参数也是类型<t>上的匿名扩展函数。apply函数调用带有内部引用<code class="fe nw nx ny nn b">this</code>的<code class="fe nw nx ny nn b">block</code>并返回调用者<code class="fe nw nx ny nn b">this</code></t></t></p><p id="a964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个例子:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="1f98" class="ku kv in nn b gy nr ns l nt nu">class Workshop(val car:Car){}<br/>workshop = Workshop(Ferrari())</span><span id="974f" class="ku kv in nn b gy nv ns l nt nu">workshop.<em class="mt">apply</em>&lt;Workshop&gt; {  }<br/>OR<br/>workshop.apply{ <br/>// do some magic here<br/>// the caller is `this` workshop with member ferrari car<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/582ed0b84b9fc6494c4607df2e772337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SN5nPZ1drqfhz8TL8TMlbw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">function, refer inside lambda, return</figcaption></figure><p id="e8d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我相信你已经掌握了这个概念，你不只是试图记住这个表。以下是其他作用域函数</p><h1 id="63b5" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">也</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="675c" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T {<br/>    block(this)<br/>    return this<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b346fb9bdd003ee7559a40b6f32db6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rq1ctLG4bnTfZf9lP283ww.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">function, refer inside lambda, return</figcaption></figure><p id="4f4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">also</code>函数也是一个带有<code class="fe nw nx ny nn b">Generic &lt;T&gt;</code>的扩展函数，它接受一个函数类型的参数，该参数具有一个与调用者相同的<code class="fe nw nx ny nn b">T</code>类型的参数。apply函数返回调用者的类型。lambda内部的<code class="fe nw nx ny nn b">it</code>背后的原因是对lambda的调用<code class="fe nw nx ny nn b">block(this),</code>你可以随意命名任何你想命名的东西。</p><h1 id="8d0a" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">奔跑</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="093b" class="ku kv in nn b gy nr ns l nt nu">fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {<br/>    return block()<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/5321d293dae33794404e3b83c20b83e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2arBreQU5ojcB0KLnlALQ.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">function, refer inside lambda, return</figcaption></figure><p id="3934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所见，<code class="fe nw nx ny nn b">run</code>函数是用泛型&lt; T &gt;定义的扩展函数，因此任何调用者都可以像调用成员函数一样调用它，它接受lambda，这也是T类型的匿名扩展。run函数返回R类型，它将R类型委托给lambda。我们以<code class="fe nw nx ny nn b">this</code>的形式访问调用者，因为它是一个扩展函数。</p><h1 id="2940" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">随着</h1><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="de33" class="ku kv in nn b gy nr ns l nt nu">with(receiver: T, block: T.() -&gt; R): R {<br/>    return receiver.block()<br/>}</span></pre><p id="6936" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里with不是扩展函数，但函数类型参数是。这次我们将T作为参数<code class="fe nw nx ny nn b">receiver</code>传递，并使用它来调用<code class="fe nw nx ny nn b">block</code> Rest。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/54b2cb0b16306974058a3e1382c8b890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOehXgZXCtchFHEheoiD9g.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk">function, refer inside lambda, return</figcaption></figure><h1 id="d0da" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">但是在哪里使用哪个呢？</h1><p id="f9c2" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这篇文章旨在教你scoped <code class="fe nw nx ny nn b">functions</code>的内部和基础知识。不可否认<code class="fe nw nx ny nn b">functions</code>起初看起来令人困惑。你可以在你的项目中随意使用它们，但是让我分享一些使用案例:</p><p id="e359" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b"><strong class="jm io">apply</strong></code>一般用于设置你感兴趣的对象和调用者对象作为返回类型(可选)。例如</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ed2b" class="ku kv in nn b gy nr ns l nt nu">dialog.<strong class="nn io">apply</strong> { <br/>  setOkButton("Ok")<br/>  setCancelButton("cancel")<br/>}</span></pre><p id="3b7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">let</code>用于改变范围和我们感兴趣的结果时的λ。它非常适合可空类型。例如</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="9834" class="ku kv in nn b gy nr ns l nt nu">fun doMagic(car:Car?) {  <br/>  car?.<strong class="nn io">let</strong> {<br/>    it.start() <br/>  }<br/>}</span></pre><p id="1823" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">run</code>有两个变量，1用于改变范围，这样你就可以使用你的变量并返回一些东西。其他<code class="fe nw nx ny nn b">run</code>定义为调用方的听筒类型参数的扩展函数。</p><p id="86e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语义上<code class="fe nw nx ny nn b">also</code>可以用来链接函数调用。例如</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="329f" class="ku kv in nn b gy nr ns l nt nu">car.also{ // do soem magic }.also{ // do more magic }</span></pre><p id="dcc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nw nx ny nn b">with</code>可以像<code class="fe nw nx ny nn b">apply</code>一样使用，一个用例是在不参考<code class="fe nw nx ny nn b">this</code>和<code class="fe nw nx ny nn b">dot</code>的情况下改变属性，例如</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2454" class="ku kv in nn b gy nr ns l nt nu">with(car) { model ="x6" manu ="bmw" }</span></pre><h1 id="509d" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">结论</h1><p id="2016" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我希望你能从这篇文章中学到一些东西。我的目的是让您成为一名大师，这样您不仅可以使用限定了作用域的函数，还可以自己创建一个。这都是关于基本面的。我们看到<code class="fe nw nx ny nn b">extension functions</code>和<code class="fe nw nx ny nn b">function-type</code>参数起到了非常重要的作用。作用域函数只是让你的生活变得简单的工具。不需要记忆任何表格。弄清楚你的基本知识，并明智地使用它。不要混淆<code class="fe nw nx ny nn b">this</code>和<code class="fe nw nx ny nn b">it,</code>之间的关系，总是要理解它的来源和背后的原因。最后，<strong class="jm io">练习，练习，再练习</strong>。</p><p id="d8af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我写关于Android、Java、Kotlin和软件的文章。如果你来到这里并且喜欢/学习了这篇文章，请在你的圈子里分享。关注我在 <a class="ae nl" href="https://twitter.com/khanna2402" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">推特</strong> </a> <strong class="jm io">或</strong> <a class="ae nl" href="https://medium.com/@gaurav.khanna" rel="noopener"> <strong class="jm io">中</strong> </a> <strong class="jm io">或访问</strong> <a class="ae nl" href="https://gaurav-khanna.in" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">我的网站</strong> </a></p><p id="d69f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我写的另一个长系列(现在不要看，书签以后用):</p><div class="on oo gp gr op oq"><a href="https://gaurav-khanna.in/blogs/programming/java-to-kotlin/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">Java到Kotlin的完整指南</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">简化学习</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">高拉夫-卡纳</p></div></div></div></a></div><p id="dd4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不断学习，不断分享。</p><h1 id="806b" class="lz kv in bd kw ma nz mc kz md oa mf lc mg ob mi lf mj oc ml li mm od mo ll mp bi translated">最后，休息一下💆💆💆</h1><p id="62ca" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">自我推销</p><div class="on oo gp gr op oq"><a href="https://share.goodapp.in/gaurav" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">Google Play上的优秀应用程序、20多个健康应用程序和2个大脑游戏应用程序</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">当你可以在一个应用中获得所有功能时，为什么要为20多个应用付费呢？GoodApp旨在改善您的生活。它触及:📱数字…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">share.goodapp.in</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="86a5" class="lz kv in bd kw ma mb mc kz md me mf lc mg mh mi lf mj mk ml li mm mn mo ll mp bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="9dd4" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae nl" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae nl" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><p id="1ed6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要一个科特林工作室，看看我们如何能帮助你:<a class="ae nl" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi pf"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>