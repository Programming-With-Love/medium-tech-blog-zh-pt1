<html>
<head>
<title>Leveraging Akka and Machine Learning in a Reactive Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在反应式微服务架构中利用Akka和机器学习</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/leveraging-akka-and-machine-learning-in-a-reactive-microservices-architecture-57b2da0c949e?source=collection_archive---------5-----------------------#2019-04-29">https://medium.com/capital-one-tech/leveraging-akka-and-machine-learning-in-a-reactive-microservices-architecture-57b2da0c949e?source=collection_archive---------5-----------------------#2019-04-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2d4ee3e560973a27adfeac6a14ac067a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WC0KY_lUUMzxMD8U2WZqg.png"/></div></div></figure><p id="297f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个新的技术时代即将来临！软件让最终用户更容易在他们想做的时候，通过他们选择的设备，立即完成他们需要做的事情。支持这些解决方案的软件架构也变得越来越智能、响应越来越快、弹性越来越大、可伸缩性越来越强。构成这些架构的几个基础支柱包括<em class="jn">机器学习、反应式框架和</em> <a class="ae jo" href="https://developer.capitalone.com/blog-post/delivering-microservices-for-enterprise-with-devops/" rel="noopener ugc nofollow" target="_blank"> <em class="jn">微服务</em> </a>。</p><p id="abf7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jo" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">之前的帖子</a>中，我们讨论了如何在反应式微服务架构中利用<a class="ae jo" rel="noopener" href="/capital-one-tech/comparing-and-contrasting-open-source-bpm-projects-196833f23391">开源BPM </a>和机器学习。它提供了机器学习的基本概述，Kafka，H20，并解释了一种方法，当你有人类工作流参与时，这种方法是有价值的。</p><p id="9039" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jo" rel="noopener" href="/capital-one-tech/building-microservices-a-reactive-framework-comparison-fb49d8f3c8f4">另一篇之前的帖子</a>中，我们讨论了反应式架构，并涵盖了一些运行在JVM之上的领先反应式框架的基本概念，如Akka和Vert.x。这些框架非常强大，提供了创建反应式架构所需的工具。</p><p id="c7b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，如果您有一个不涉及人工工作流的用例，而主要是您希望在反应式微服务架构中与机器学习集成的系统到系统交互，该怎么办呢？让我们仔细看看如何解决这个特殊的问题。</p><h1 id="8eb3" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">理解问题</h1><p id="12e7" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在我们开始解决问题之前，确保你对你试图解决的问题有一个真正好的理解总是一个好的最佳实践。这有助于您为您的特定用例找到合适的技术和架构模式。通常，团队认为他们知道问题，当他们只是在表面上。他们需要深入几个层次才能找到根源。这往往需要提问并继续问<em class="jn">“为什么？”</em>直到你到达那里。你要避免的是找到一个不适合你试图解决的问题的解决方案。这可能导致解决方案过于复杂。</p><p id="1ec1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当使用反应式架构时，这变得更加重要，因为由于异步概念的引入，默认情况下会增加额外的复杂性。</p><h1 id="679d" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">反应式微服务和系统的集成选项</h1><p id="cb53" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">当考虑机器学习和集成不同的反应系统时，根据使用情况，有几种方法可以采用。每当有多个系统需要集成时，<a class="ae jo" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">反应式架构</a>的一个关键原则就是保持这些系统的解耦。</p><p id="ecb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一种方法是通过命令和事件，你可以在我的<a class="ae jo" rel="noopener" href="/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c">以前的帖子</a>中读到更多。Kafka是一种用于实现命令和事件的常用技术。它可以用来将微服务<em class="jn">集成到</em>反应式应用中，以分离各种应用组件。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1ba26291567e6aede4fe6e97a9000c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-BStYgs_WaRohHPdEnwuQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Leveraging Kafka within a reactive system</figcaption></figure><p id="0bdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在 中利用Kafka <strong class="ir hi"> <em class="jn">可以很好地适应反应系统:</em></strong></p><ul class=""><li id="4900" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">如果您的反应系统中的微服务本质上是多语言的，这意味着技术的混合(例如，Spring Boot、Java、Akka)。</li><li id="d02b" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">如果希望避免局限于特定的反应式框架进行交流。</li></ul><p id="c29c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kafka也可以用于集成<em class="jn">跨</em>反应式系统。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/8426cc0512554fbbb35543528f16b1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JWnc2-zl3GeMEuQeK5r5A.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Leveraging Kafka across reactive systems</figcaption></figure><p id="12cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">利用Kafka <strong class="ir hi"> <em class="jn">跨越</em> </strong>的反应系统可能是一个不错的选择:</p><ul class=""><li id="57bd" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">如果你的反应系统本质上是多语言的(Akka Actor系统，Java)。</li><li id="53f5" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">如果希望避免锁定到特定的反应式框架来进行交叉反应式系统通信。</li></ul><p id="17bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也可以利用<a class="ae jo" rel="noopener" href="/capital-one-tech/building-microservices-a-reactive-framework-comparison-fb49d8f3c8f4"> Akka </a>的功能来实现类似的结果。Akka使您能够构建一个可以包含多个演员的演员系统。为了在反应式系统中进行<em class="jn">沟通，参与者可以通过Akka的内置消息传递功能(例如，通过EventStream构造询问、告知或发布/订阅)相互沟通。</em></p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/dcf63aeb10855fb9055cf875f718a432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odWD1PiOHedcYuVnF8f18g.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Leveraging the Akka Ask or Tell built-in messaging</figcaption></figure><p id="5c1a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您的所有微服务都是同一个Actor系统的一部分时，在反应式系统中利用Akka可能是一个很好的选择。</p><p id="4cf9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于跨Akka系统的通信，<a class="ae jo" href="https://doc.akka.io/docs/akka-http/current" rel="noopener ugc nofollow" target="_blank"> Akka HTTP </a>或<a class="ae jo" href="https://developer.lightbend.com/docs/akka-grpc/current/" rel="noopener ugc nofollow" target="_blank"> Akka gRPC </a>可用于同步无阻塞通信，而<a class="ae jo" href="https://doc.akka.io/docs/akka-stream-kafka/current/home.html" rel="noopener ugc nofollow" target="_blank"> Akka Streams Kafka </a>可用于异步通信。这些方法中的每一种都将背压作为消息流的一部分。此外，通信的另一端可以用Akka之外的东西来实现。</p><p id="68fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您还可以将其中一些模式结合在一起，这可以让您利用每种方法的优势。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c6132f96e7e074cd4663c6a1447f86b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zB8OIHndeNyKj7rkydQc-Q.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Leveraging Kafka within and across reactive systems AND leveraging Akka within a reactive system</figcaption></figure><p id="da15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种方法利用Kafka在一个反应式系统内和跨角色系统传递消息。它还利用Akka在actor系统中传递消息。当您希望在微服务和反应式系统级别最大化去耦并支持多语言通信时，这种方法非常合适。在下一节中，我们将展示如何采用这种模式，并使用反应式框架和机器学习来实现一个示例。</p><h1 id="d26e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个示例实现</h1><p id="b3ba" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">让我们通过一个例子来说明如何利用Akka框架、Lagom、H20、Kafka和基于Java的微服务来实现基于机器学习的解决方案，该解决方案使用反应式微服务架构。你也可以在下面找到我和我的同事在2018年反应式峰会上发表的关于这个主题的演讲和视频。</p><p id="96db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jo" href="https://www.reactivesummit.org/2018/schedule/integrating-machine-learning-reactive-microservices-and-akka-with-kafka" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">将机器学习、反应式微服务、Akka与Kafka整合—@ react ivesummit</strong><em class="jn">react ive18—很多公司都在尝试机器学习，看看他们如何更好地预测未来……【www.reactivesummit.org】T4</em></a></p><p id="588e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本例中，我们创建了一个预测欺诈性信用卡交易的解决方案。28个数值特征被计算并输入到执行预测的H20模型中。在我的<a class="ae jo" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">上一篇</a>中，我们提供了Akka、H20和Kafka的概述。我们之前没有讨论过的新技术组件是<a class="ae jo" href="https://www.lagomframework.com/" rel="noopener ugc nofollow" target="_blank"> Lagom </a>。Lagom是一个开源框架，可以更容易地将微服务连接在一起(例如，它可以将Akka Actors作为RESTful APIs公开)。在我们的例子中，我们用它来为Kafka提供一个引导带。现在，让我们看看使用所有这些组件的建议体系结构。我们重用了许多来自<a class="ae jo" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">开源BPM示例</a>的相同组件，请看这篇文章，了解H20组件的详细介绍。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/6a5ae49ed127ed05282b0fa92f3c6ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qz_3E0OqANjYnq5aNuvGqQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Architecture for example</figcaption></figure><p id="878c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述解决方案利用了命令和事件。您将看到一个带有Akka Actors的Akka系统，它使用内置的Akka消息传递(ask/tell)，以及发布和订阅Kafka来与基于Java的微服务进行通信。该解决方案的关键微服务包括:</p><ul class=""><li id="5b6d" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated"><strong class="ir hi"> Kafka Producer(上面未显示)</strong> —基于Java的微服务，用于通过在Kafka主题card.transaction上放置命令“Calc Features”来模拟系统流程。</li><li id="2986" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><strong class="ir hi"> Saga Actor </strong> —基于Java的Akka Actor，订阅Kafka上的card.transaction主题。对事件“Features Calculated”作出反应，并使用Akka的内置消息传递功能通过“ask”向RunModelMS Actor发送命令，传递28个模型输入。</li><li id="3fdf" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><strong class="ir hi"> CalcFeaturesMS </strong> —基于Java的微服务，订阅Kafka上的card.transaction主题。通过计算28个数字特征并将它们发布回Kafka主题和事件“计算的特征”来响应命令“计算特征”。</li><li id="cace" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><strong class="ir hi"> RunModelMS </strong> —基于Java的Akka Actor，封装了基于Java的H20模型代码。从Saga演员接收命令以运行H20模型。运行模型并将带有事件“交易正常”或“欺诈性交易”的输出发布到card.transaction Kafka主题。</li></ul><p id="1a68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总体流程可以通过下图直观显示。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dde720fd4bd567ec664af801314aac9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b79niOvuMjv9ek5qc351jw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">overall flow for example</figcaption></figure><p id="b0bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们仔细看看这个例子中新增的代码片段。Kafka生成器功能由TestKafkaProducer类实现，该类扩展了ProducerExample类。ProducerExample创建一个连接到本地Kafka实例的Actor系统。TestKafkaProducer在card.transaction Kafka主题上传递“Calc Features”命令。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/caaa0ac1ea857c728463a322c3500ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDVlHCOP7ykJrzGZ0iXCQQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Kafka Producer example</figcaption></figure><p id="7789" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的传奇演员是通过一系列四个独立的组件实现的。第一个是application.conf，它位于类路径的根，用于将Akka的配置信息传递给ActorSystem实例。我们的application.conf文件指向Saga演员，我们称之为通信模块。</p><blockquote class="lr ls lt"><p id="6748" class="ip iq jn ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">play . modules . enabled+= com . capital one . ACC . impl . communication s module</p></blockquote><p id="d047" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CorrespondenceModule.java是Kafka与服务实现类绑定的地方:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f78962095c26a1f3c1079e92260c1ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3w2dOsi3aa0hUyAFkP4Ydw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">CorrespondenceModule.java</figcaption></figure><p id="0dce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">服务实现类创建Saga Actor和StartEventCmd的实例。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a0822a41bd82f4cf8b698eb4fd6b5870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ6iUe4-tLnTo2QVwOT8WA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Service Implementation Class</figcaption></figure><p id="98fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Saga Actor中的startEventCmd接收消息，并向RunModelMS(在本例中称为ProcessAppActor)发送一条tell消息。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8dc618d99f04f1f1a0eae70a61b47917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYdpGpaaeuydmD4CyQlrNg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">startEventCmd in Saga Actor</figcaption></figure><p id="5808" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">RunModelMS(在代码中称为ProcessAppActor)检查消息以查看是否已经计算了特性。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e77bf679c8d3793f9af833b86967186f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qz-iVISE_zEqA16lPIfIjA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">checks EventId for “Features Calculated”</figcaption></figure><p id="fef1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果已经计算了特征，那么它将执行H20模型，你可能从我们的<a class="ae jo" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">上一篇文章</a>中的例子中认出它。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/ca1ef9cc92d433f4979ec4ee37d0eb16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pV9A39C7W7c2e3EFmyKcw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Execution of H20 model</figcaption></figure><h1 id="b90a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理故障</h1><p id="3eba" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在这一点上，您可能想知道的一件事是，我如何在这样的分布式架构中处理故障？有许多方法可以在应用程序级别加以利用。下面就让我们一起走过几个。</p><ul class=""><li id="5bb9" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">使用try / catch块捕捉异常。注意，我们是在执行上面的H20模型时这样做的。</li><li id="f49f" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">将您的处理设计成幂等的。这意味着设计您的处理，这样它就不需要记住哪里出错了，而是您可以从头开始重新处理。这种方法可能是简化设计的一种很好的方式，但根据使用案例的不同，可能并不总是可行的。</li><li id="9871" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">利用Kafka消费者群体，仅在您知道处理成功时提交补偿。对于Kafka消费群，Zookeeper会跟踪偏移量，即消息流中要消费的当前点。一旦消息被读取，消费者可以控制提交偏移量或自动提交。通过控制何时提交偏移量，使用者可以等待特定的成功条件发生。如果在Kafka中继续产生消息时，消费者进程停止，当消费者恢复时，它将能够处理任何未提交的消息。</li><li id="87f0" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">利用Akka持久性，因为它通过存储参与者的内部状态来提供容错。这使得参与者的状态可以在崩溃时恢复。你可以在我之前的博客中找到更多的细节。</li></ul><h1 id="2055" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="368b" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在反应式微服务架构中结合Akka、Lagom、H20和Kafka的力量，可以将您的机器学习用例提升到一个新的水平。它提供了一种分离内部组件的方法，支持异步处理，同时通过发布和订阅功能支持与各种多语言反应系统的集成。这种模式对于系统到系统类型的交互(非人类工作流)是一种很好的模式。我希望这篇文章对你有所帮助，感谢你的时间！</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="9f0f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2019首都一。</em></p><h1 id="4307" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">相关:</h1></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><ul class=""><li id="1bb8" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">在反应式微服务架构中使用机器学习和开源BPM</a></li><li id="1e96" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/building-microservices-a-reactive-framework-comparison-fb49d8f3c8f4">构建微服务:反应式框架比较</a></li><li id="af75" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c">微服务——何时应对，何时协调</a></li></ul><figure class="ks kt ku kv fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/microservices/home"><div class="er es mf"><img src="../Images/2132c86b1c39616ff166fde946b3ebe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9af31vCvgZICb7ZSvGV1Sg.jpeg"/></div></a></figure></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><blockquote class="mg"><p id="632a" class="mh mi hh bd mj mk ml mm mn mo mp jm dx translated"><em class="mq">披露声明:2019首创一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></blockquote></div></div>    
</body>
</html>