<html>
<head>
<title>Learning to Use Go Reflection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用Go反射</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/learning-to-use-go-reflection-822a0aed74b7?source=collection_archive---------0-----------------------#2017-12-13">https://medium.com/capital-one-tech/learning-to-use-go-reflection-822a0aed74b7?source=collection_archive---------0-----------------------#2017-12-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6729" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><a class="ae iw" rel="noopener" href="/@jon_43067"><strong class="ak"/></a>连发五发</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2316aecb8df3329a624a49c51b8e902d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYmPAeP6c0pLJzNBf6UGyw.jpeg"/></div></div></figure><h1 id="7af4" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">什么是反思？</strong></h1><p id="ea85" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">大多数时候，Go中的变量、类型和函数都非常简单。当您需要一个类型时，您可以定义一个类型:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="ce1c" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">当你需要一个变量时，你定义一个变量:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8d06" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">当你需要一个函数时，你定义一个函数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="dddf" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">但是有时你想在运行时使用程序编写时不存在的信息来处理变量。也许您正试图将文件或网络请求中的数据映射到变量中。也许你想建立一个工具，与不同类型的作品。在那些情况下，你需要使用<em class="le">反射</em>。反射使您能够在运行时检查类型。它还允许您在运行时检查、修改和创建变量、函数和结构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://twitter.com/CapitalOneDevEx"><div class="er es lf"><img src="../Images/a94559d31aeb80a7fd55aff68f92d34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGp3B7rAWWoCgY2i_nC6TA.png"/></div></a></figure><p id="8c48" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">Go中的反射是围绕三个概念构建的:<strong class="kd hi"> <em class="le">类型、种类、值</em> </strong>。标准库中的反射包是在Go中实现反射的类型和函数的家。</p><h1 id="813b" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">找到你的类型</strong></h1><p id="dad7" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">首先让我们看看类型。您可以使用反射，通过函数调用varType := reflect来获取变量var的类型。类型(变量)。这将返回反射类型的变量。类型，它的方法包含了定义传入变量的类型的各种信息。</p><p id="9bae" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">我们要看的第一个方法是Name()。毫不奇怪，这将返回类型的名称。一些类型，如切片或指针，没有名字，这个方法返回一个空字符串。</p><p id="1c93" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">下一个方法，也是我认为第一个真正有用的方法，是Kind()。种类是类型的组成部分——切片、映射、指针、结构、接口、字符串、数组、函数、int或其他一些原始类型。种类和类型之间的区别很难理解，但是请这样想。<em class="le">如果定义了一个名为Foo的struct，则种类为struct，类型为Foo </em>。</p><p id="fdad" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">使用反射时需要注意的一点是:反射包中的所有东西都假设您知道自己在做什么，如果使用不当，许多函数和方法调用将会死机。例如，如果调用reflect上的方法。类型关联的类型与当前类型不同，您的代码将会出错。永远记住使用你的反射类型来知道哪些方法将会工作，哪些方法将会崩溃。</p><p id="e09f" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">如果您的变量是指针、映射、切片、通道或数组，您可以使用varType找出包含的类型。Elem()。</p><p id="df7e" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">如果您的变量是一个结构，您可以使用反射来获取该结构中的字段数，并获取反射中包含的每个字段的结构。结构字段结构。反映。StructField为您提供了字段上的名称、顺序、类型和结构标记。</p><p id="16c2" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">因为几行源代码抵得上千言万语，所以这里有一个简单的例子来转储各种变量的类型信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4dbd" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">输出如下所示:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="aa8a" class="ll jk hh lh b fi lm ln l lo lp">Type is  and kind is slice<br/>	 Contained type:<br/>	 Type is int and kind is int<br/> Type is string and kind is string<br/> Type is  and kind is ptr<br/>	 Contained type:<br/>	 Type is string and kind is string<br/> Type is Foo and kind is struct<br/>	 Field 1 name is A type is int and kind is int<br/>		 Tag is tag1:"First Tag" tag2:"Second Tag"<br/>		 tag1 is First Tag tag2 is Second Tag<br/>	 Field 2 name is B type is string and kind is string<br/> Type is  and kind is ptr<br/>	 Contained type:<br/>	 Type is Foo and kind is struct<br/>		 Field 1 name is A type is int and kind is int<br/>			 Tag is tag1:"First Tag" tag2:"Second Tag"<br/>			 tag1 is First Tag tag2 is Second Tag<br/>		 Field 2 name is B type is string and kind is string</span></pre><p id="7687" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><strong class="kd hi"> <em class="le">你可以在</em></strong><a class="ae iw" href="https://play.golang.org/p/lZ97yAUHxX" rel="noopener ugc nofollow" target="_blank"><strong class="kd hi"><em class="le">【https://play.golang.org/p/lZ97yAUHxX】</em></strong></a>运行这个例子</p><h1 id="1f1d" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">创建新实例</strong></h1><p id="9cd1" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">除了检查变量的类型，您还可以使用反射来读取、设置或创建值。首先你需要使用refVal := reflect。ValueOf(var)创建一个反射。变量的值实例。如果希望能够使用反射来修改值，就必须用refPtrVal := reflect获得一个指向变量的指针。value of(&amp; var)；如果没有，可以使用反射读取值，但不能修改它。</p><p id="dcc5" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">一旦你有了反思。值，你可以得到反映。使用Type()方法的变量的类型。</p><p id="739e" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">如果你想修改一个值，记住它必须是一个指针，并且你必须首先取消对指针的引用。您使用refPtrVal。Elem()。Set(newRefVal)进行更改，传递给Set()的值必须是一个反射。也值。</p><p id="22ed" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">如果您想创建一个新值，可以使用函数调用newPtrVal := reflect来实现。New(varType)，传入一个reflect.Type。这将返回一个指针值，然后您可以修改它。使用Elem()。如上所述设置()。</p><p id="b565" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">最后，您可以通过调用Interface()方法返回到普通变量。因为<a class="ae iw" rel="noopener" href="/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5"> Go没有泛型</a>，所以变量的原始类型丢失；该方法返回接口{}类型的值。如果您创建了一个指针以便可以修改值，那么您需要使用Elem()取消对反射指针的引用。接口()。在这两种情况下，您都需要将空接口转换为实际类型才能使用它。</p><p id="7cc3" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">以下是演示这些概念的一些代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="f031" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">输出如下所示:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="74c7" class="ll jk hh lh b fi lm ln l lo lp">hello<br/>goodbye<br/>{A:20 B:Greetings}, 20, Greetings</span></pre><p id="c403" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><strong class="kd hi"> <em class="le">你可以在</em></strong><a class="ae iw" href="https://play.golang.org/p/PFcEYfZqZ8" rel="noopener ugc nofollow" target="_blank"><strong class="kd hi"><em class="le">https://play.golang.org/p/PFcEYfZqZ8</em></strong></a>运行这个例子</p><h1 id="ac17" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">有制作无制作</strong></h1><p id="90ba" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">除了生成内置和用户定义类型的实例之外，还可以使用反射来生成通常需要make函数的实例。您可以使用反射制作切片、贴图或通道。做一个切片，反射。制作地图，并反映出来。MakeChan函数。在所有情况下，你提供一个反射。键入并得到一个反射。可以用反射操作的值，或者可以赋回标准变量的值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="23df" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">此代码的输出是:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="ce5c" class="ll jk hh lh b fi lm ln l lo lp">[10]<br/>map[hello:10]</span></pre><p id="9a47" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><strong class="kd hi"> <em class="le">你可以在</em></strong><a class="ae iw" href="https://play.golang.org/p/z4tnyEf6bH" rel="noopener ugc nofollow" target="_blank"><strong class="kd hi"><em class="le"/></strong></a><strong class="kd hi"><em class="le">运行例子。</em> </strong></p><h1 id="a91c" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">制作功能</strong></h1><p id="76f0" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">反射不仅仅让你创造新的地方来存储数据。您可以使用反射来创建新的函数。MakeFunc函数。这个函数需要反射。我们要创建的函数的类型，以及输入参数类型为[]reflect的闭包。值，其输出参数也是[]reflect.Value类型。下面是一个简单的例子，它为传递给它的任何函数创建一个计时包装器:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8aa2" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">您可以在这里运行代码<a class="ae iw" href="https://play.golang.org/p/QZ8ttFZzGx" rel="noopener ugc nofollow" target="_blank">https://play.golang.org/p/QZ8ttFZzGx</a>并查看输出:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="6400" class="ll jk hh lh b fi lm ln l lo lp">starting<br/>ending<br/>calling main.timeMe took 1s<br/>starting<br/>ending<br/>calling main.timeMeToo took 2s<br/>4</span></pre><h1 id="17b4" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated">我想要一个新的结构</h1><p id="141d" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">在Go中使用反射还可以做一件事。通过传递一个反射片，你可以在运行时创建全新的结构。要反射的StructField实例。函数的结构。这张有点奇怪。我们正在制造一个新的类型，但是我们还没有给它起一个名字，所以你不能真的把它变回一个“正常”的变量。您可以创建一个新的实例，并使用<code class="du lq lr ls lh b">Interface() </code>将值放入interface{}类型的变量中，但是如果您想要在其上设置任何值，则需要使用反射。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0f50" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">运行此代码将返回:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="bac7" class="ll jk hh lh b fi lm ln l lo lp">0<br/>20<br/><br/>reflect me<br/>[]<br/>[1 2 3]</span></pre><p id="3f03" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">【https://play.golang.org/p/lJiTP6vYYN】<em class="le">的代号是</em><a class="ae iw" href="https://play.golang.org/p/lJiTP6vYYN" rel="noopener ugc nofollow" target="_blank"><strong class="kd hi"><em class="le"/></strong></a></p><h1 id="fd32" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">你有什么不能做的？</strong></h1><p id="7e80" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">反射有一个很大的限制。虽然您可以使用反射来创建新的<em class="le">函数</em>，但是无法在运行时创建新的<em class="le">方法</em>。这意味着您不能在运行时使用反射来实现接口。这也意味着使用反射来创建一个新的结构可能会以奇怪的方式中断。当您从一部分结构字段中创建新结构时，与Go中我最喜欢的特性之一——通过匿名结构字段的委托——的交互会出现一些问题。</p><p id="5793" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">下面是对委托的快速回顾。大多数情况下，当结构中有一个字段时，需要给它一个名称。在本例中，我们有两种类型，Foo和Bar:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="2ae8" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">如果你在https://play.golang.org/p/aeroNQ7bEI运行这段代码，你会看到两件事。首先，Bar中的Foo字段没有名字。这使得它成为一个匿名或嵌入字段。第二，Bar被视为遇到Doubler接口，即使Double方法仅由Foo实现。这种能力叫做委托；在编译时，Go会自动在Bar上生成与Foo上的方法相匹配的方法。这不是继承。如果您试图将一个Bar传递给一个需要Foo的函数，您的代码将无法编译。</p><p id="58cb" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">然而，如果您使用反射来构建一个具有嵌入字段的结构，并试图访问这些字段上的方法，您会得到一些非常奇怪的行为。最好的办法是不要使用它们。Go GitHub库中有一个问题要解决这个https://github.com/golang/go/issues/15924的<a class="ae iw" href="https://github.com/golang/go/issues/15924" rel="noopener ugc nofollow" target="_blank">，另一个问题是要求用一组方法</a><a class="ae iw" href="https://github.com/golang/go/issues/16522" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/issues/16522</a>定义一个新类型的通用能力。不幸的是，这两个问题暂时都没有任何进展。</p><p id="86cb" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">这有什么大不了的？如果我们能动态实现接口，我们能做什么？嗯，就像我们能够通过利用Go对生成函数的支持来为函数生成包装器一样，我们也可以为接口生成包装器。在Java中，这种功能被称为动态代理。当与注释结合使用时，它提供了一种从命令式编程风格转变为声明式编程风格的强大方法。JDBI 就是一个很好的例子。它是一个Java库，允许您通过定义一个用SQL查询注释的接口来构建DAO层。通常为支持数据库交互而编写的所有样板代码都是在运行时动态生成的。那是强大的。</p><h1 id="97a8" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated"><strong class="ak">太好了，但是有什么意义呢？</strong></h1><p id="ec64" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated">但是即使有这个限制，反射仍然是一个强大的工具，每个Go开发人员都应该在他们的工具箱中拥有它。但是他们能用它做什么呢？在下一篇博文中，我将探索反射在现有库中的一些用途，并使用反射构建一些新的东西。</p><h2 id="5197" class="ll jk hh bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">在此阅读第2部分<a class="ae iw" rel="noopener" href="/capital-one-developers/learning-to-use-go-reflection-part-2-c91657395066">。</a></h2></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="22ab" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><em class="le">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权是其各自所有者的所有权。本文为2017首都一。</em></p><h1 id="5876" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi translated">附加链接</h1><p id="5dc9" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/in-the-not-too-distant-future-e2d0ad28e91">在不久的将来… </a></p><p id="b2d9" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/buffered-channels-in-go-what-are-they-good-for-43703871828">缓冲通道——它们有什么用？</a></p><p id="5670" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated">闭包是Go的泛型</p><p id="45d2" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><a class="ae iw" rel="noopener" href="/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd">在Go中构建无界通道</a></p><p id="70ae" class="pw-post-body-paragraph kb kc hh kd b ke kz ii kg kh la il kj kk lb km kn ko lc kq kr ks ld ku kv kw ha bi translated"><a class="ae iw" href="https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中构建REST API</a></p></div></div>    
</body>
</html>