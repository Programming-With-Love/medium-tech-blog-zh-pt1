<html>
<head>
<title>BigQuery: Legacy SQL vs. Standard SQL Conundrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery:传统SQL与标准SQL的难题</h1>
<blockquote>原文：<a href="https://medium.com/globant/bigquery-legacy-sql-vs-standard-sql-conundrum-f8628abd1e82?source=collection_archive---------0-----------------------#2022-12-21">https://medium.com/globant/bigquery-legacy-sql-vs-standard-sql-conundrum-f8628abd1e82?source=collection_archive---------0-----------------------#2022-12-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="dfbd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">案例研究</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/201732a6cf9cc5053c3292b940173932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LdDvzIil0tolbJEp"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@benjaminlehman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">benjamin lehman</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="76d4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在这篇博客中，我们将了解<a class="ae jm" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql" rel="noopener ugc nofollow" target="_blank">遗留SQL </a>中的一些限制，这些限制阻止了用户利用<a class="ae jm" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/introduction" rel="noopener ugc nofollow" target="_blank">标准SQL </a>的优化优势。借助案例研究的概述，展示了如何在BigQuery中使用分区和集群来帮助您使用标准SQL方言优化成本和性能。</p><h1 id="fa76" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">简短的大查询</h1><p id="3774" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/introduction" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>作为一种全面管理的企业数据仓库解决方案，在大数据世界中被广泛应用于各种用例，并且每天都有越来越多的人采用它。BigQuery提供机器学习、地理空间分析和商业智能功能，帮助您管理和分析数据。其无服务器架构允许您使用SQL查询来回答您组织的最大问题，而无需管理任何基础架构。使用BigQuery可扩展的分布式分析引擎，您可以在几秒钟内查询数万亿字节的数据。BigQuery ML(机器学习)文档有助于数据分析师、数据工程师、仓库管理员或数据科学家做出重要的业务决策。</p><h1 id="5a52" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">传统SQL和标准SQL </strong></h1><p id="d550" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">Bigquery表可以用两种方言查询:遗留SQL和标准SQL。遗留SQL是BigQuery 2.0发布之前的一种较老的SQL方言，标准SQL是当前的首选SQL方言。成本和性能优化优势(如集群和分区)在传统SQL方言中不可用，只能在标准SQL方言中使用。尽管标准SQL方言是Google建议在BigQuery中使用的方言，并且所有未来的改进都承诺只使用这种方言，但在一些情况下，用户仍然在使用遗留的SQL，因为他们对更改SQL方言有所保留。如果我们让用户用两种方言查询同一个BigQuery表，并且我们希望为用标准SQL方言查询的用户优化性能和成本，该怎么办？这就是我们要解决的问题。</p><h1 id="49da" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">分区表</strong></h1><p id="378c" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">分区表是被分成称为分区的段的表。这提高了查询性能并降低了查询成本，因为查询扫描的数据量减少了。目前，只能在一列上进行分区。要对BigQuery表进行分区，可以使用时间戳、日期或日期时间列、BigQuery接收数据时的时间戳或整数列。这允许BigQuery删除与查询中的合格过滤器不匹配的分区，从而提高查询性能。当查询的where子句中添加的列与我们对表进行分区的列相同时，分区会限制扫描的数据量。这是一种广泛使用的查询性能和成本优化策略。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/91bfc17ff5e646fa928fc4aed8e45432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgxYReBhQUVm3EGNNsoo0Q.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image referred from <a class="ae jm" href="https://cloud.google.com/blog/topics/developers-practitioners/bigquery-explained-storage-overview" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><h1 id="b947" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">聚集表</strong></h1><p id="0324" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">聚集表可以提高查询性能并降低查询成本。BigQuery中的聚簇表使用<em class="lh">聚簇列</em>具有用户定义的列排序顺序。聚集表对存储块中指定列的列值进行排序。当对这样的表执行查询时，它只根据查询中提到的键列值扫描相关的块。目前，一个表中最多只能对四列进行聚类。可以结合集群和分区来进一步优化它。应该有策略地选择用于聚集和分区的列，考虑对相应表执行的查询类型，以充分利用这一可用特性。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/45cac134bac6a788ea5d416014bb1e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BKtww0zmcMtnOSeN"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image referred from <a class="ae jm" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/b5a909d94aea859ccacd4e5a9fcab3ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B_ASVF2LgeET9WWp"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image referred from <a class="ae jm" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><h1 id="14b1" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">案例研究问题陈述</strong></h1><p id="0ce2" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">每天增长500 -700 GB的TB级数据仓库表。此表是分析团队、数据科学团队和平台团队的事实来源。由于分析团队正在使用遗留的SQL方言来查询表，并且不会继续对其进行更改，因此不可能应用表优化策略，如表分区和聚类等。这意味着运行几个查询来扫描整个万亿字节的BigQuery表，这导致了指数级的高成本。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/12d8fb60506b77f908d5b719bd012007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5G7FuhEnvpM8S5fbz560Q.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image: Created by the Author</figcaption></figure><h2 id="341c" class="lk kk hh bd kl ll lm ln kp lo lp lq kt jw lr ls kv ka lt lu kx ke lv lw kz lx bi translated"><strong class="ak">一种变通方法</strong></h2><p id="b215" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">Hadoop分布式文件系统(<a class="ae jm" href="https://data-flair.training/blogs/hadoop-hdfs-architecture/" rel="noopener ugc nofollow" target="_blank"> HDFS </a>)是Hadoop集群的底层文件系统。它提供可扩展、容错、机架感知的数据存储，旨在部署在商用硬件上。该团队实施的一个节省成本的解决方案是，每天将整个表数据移动到本地集群上的HDFS，所有其他作业在Spark SQL中执行。这节省了由于扫描大量数据而查询BigQuery所产生的高成本。这仍然是一个大问题；即使节省了成本，仅仅为了运行查询而从云中转移数据也是乏味且容易失败的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/6c280e6a2f1c1602635cf8c6c2ccd103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBiTEK5u2Lq8fCsKTTJkkg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image: Created by the Author</figcaption></figure><h1 id="fe9f" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">解决方案</strong></h1><p id="b737" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">当问题可以在大查询本身中解决时，每天将TB级的数据移出大查询。应用以下步骤在成本、性能和整个问题的复杂性方面产生了巨大的差异。</p><ul class=""><li id="2d17" class="lz ma hh jp b jq jr jt ju jw mb ka mc ke md ki me mf mg mh bi translated">使用<em class="lh">CTAS</em>'<em class="lh">Create Table AS '</em>，在同一个数据集中创建一个临时BigQuery表。这将在执行所有日常作业之前创建一个表。</li><li id="93dc" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated">在<em class="lh">‘create _ date’</em>列上对临时表进行分区，并基于<em class="lh">‘id’</em>列向临时表添加聚类。</li><li id="344e" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated">执行该表上的所有查询和作业。</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/caf9c3ada0bf048e04d63d8a761e0c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WG1VRqI6QPk-6XasafcHUA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image: Created by the Author</figcaption></figure><ul class=""><li id="4074" class="lz ma hh jp b jq jr jt ju jw mb ka mc ke md ki me mf mg mh bi translated">在所有作业完成后删除该表。</li></ul><h1 id="e92a" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">改进对比</strong></h1><p id="d631" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">这是将查询移动到HDFS执行或在BigQuery中执行查询而不进行优化与在BigQuery中通过应用分区和集群等优化策略执行查询之间的快速比较。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mo"><img src="../Images/71e1e2eedc8cbb7f82360a8ab7694613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShACSelEkNNrBVMWVKVKEg.png"/></div></div></figure><h1 id="4eca" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">总结</strong></h1><p id="22b0" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">在由于产品的局限性和充分利用我们拥有的其他功能而受到束缚的情况下，提出一个优化的解决方案将会节省您大量的时间、复杂性和金钱。在上面的场景中，BigQuery是问题，BigQuery是解决方案。新用户大多使用标准SQL方言在BigQuery中进行查询，但也有少数老用户仍然使用遗留SQL。即使在这种情况下，我们仍然可以使用变通方法为标准SQL用户优化同一个表。</p><p id="2458" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这就结束了对分区和集群如何在BigQuery中拯救成本和提高性能的演示，即使由于遗留SQL方言的限制而不可能做到这一点。</p><h1 id="56b3" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="b635" class="lz ma hh jp b jq lb jt lc jw mp ka mq ke mr ki me mf mg mh bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/introduction" rel="noopener ugc nofollow" target="_blank">大查询</a></li><li id="0070" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql" rel="noopener ugc nofollow" target="_blank">遗留SQL </a></li><li id="6577" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/introduction" rel="noopener ugc nofollow" target="_blank">标准SQL </a></li><li id="6663" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">big query中的分区</a></li><li id="1bcc" class="lz ma hh jp b jq mi jt mj jw mk ka ml ke mm ki me mf mg mh bi translated"><a class="ae jm" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">big query中的聚类</a></li></ul></div></div>    
</body>
</html>