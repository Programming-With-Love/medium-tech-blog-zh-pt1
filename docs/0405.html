<html>
<head>
<title>WorkManager meets Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作经理会见科特林</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/workmanager-meets-kotlin-b9ad02f7405e?source=collection_archive---------2-----------------------#2019-06-12">https://medium.com/androiddevelopers/workmanager-meets-kotlin-b9ad02f7405e?source=collection_archive---------2-----------------------#2019-06-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/739581b125423e435cd00a9f47a7b6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbuR_lQZI5qGOL76"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="14be" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">欢迎来到我们的工作管理器系列的第三篇文章。<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/" rel="noopener ugc nofollow" target="_blank"> WorkManager </a>是一个<a class="ae hu" href="https://developer.android.com/jetpack/" rel="noopener ugc nofollow" target="_blank"> Android Jetpack </a>库，它使得调度可推迟的、必须可靠运行的异步任务变得容易。这是目前Android上大多数后台工作的最佳实践。</p><p id="6fa8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您一直在关注，我们已经讨论了:</p><ul class=""><li id="01b6" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/introducing-workmanager-2083bcfc4712">什么是工作管理器，何时使用工作管理器</a></li><li id="3870" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-basics-beba51e94048">如何使用工作管理器API调度工作</a></li></ul><p id="cd87" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博文中，我将介绍:</p><ul class=""><li id="1ac6" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">在Kotlin中使用工作管理器</li><li id="f66c" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" rel="noopener ugc nofollow" target="_blank">CoroutineWorker</a></code>阶级</li><li id="dce3" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">如何使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/testing/TestListenableWorkerBuilder" rel="noopener ugc nofollow" target="_blank">TestListenableWorkerBuilder</a></code>测试你的<code class="du kg kh ki kj b">CoroutineWorker</code>类？</li></ul><h1 id="10fa" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">科特林的工作经理</h1><p id="d68a" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">这篇博文中的代码片段在Kotlin中，使用了<a class="ae hu" href="https://developer.android.com/kotlin/ktx" rel="noopener ugc nofollow" target="_blank"> KTX库</a> (KoTlin扩展)。WorkManager的KTX版本为更简洁和惯用的Kotlin提供了扩展函数。您可以使用工作管理器的KTX版本向您的<code class="du kg kh ki kj b">build.gradle</code>文件添加对<code class="du kg kh ki kj b">androidx.work:work-runtime-ktx</code>工件的依赖，如工作管理器的<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/work" rel="noopener ugc nofollow" target="_blank">发行说明</a>中所述。这个构件包括<code class="du kg kh ki kj b">CoroutineWorker</code>和其他对WorkManager有用的扩展方法。</p><h1 id="66de" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">更简洁、更地道</h1><p id="ec00" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">当您需要构建一个数据对象来传入或传出一个<code class="du kg kh ki kj b">Worker</code>类时，WorkManager的KTX提供了一个更好的语法。在这种情况下，Java语法如下所示:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="e839" class="lv kl hx kj b fi lw lx l ly lz">Data myData = new Data.Builder()<br/>                      .putInt(KEY_ONE_INT, aInt)<br/>                      .putIntArray(KEY_ONE_INT_ARRAY, aIntArray)<br/>                      .putString(KEY_ONE_STRING, aString)<br/>                      .build();</span></pre><p id="9252" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Kotlin中，我们可以使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/package-summary#workdataof" rel="noopener ugc nofollow" target="_blank">workDataOf</a></code>辅助函数做得更好:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="949d" class="lv kl hx kj b fi lw lx l ly lz">inline fun workDataOf(vararg pairs: Pair&lt;String, Any?&gt;): Data</span></pre><p id="4638" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这允许将前面的Java表达式写成:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="1c58" class="lv kl hx kj b fi lw lx l ly lz">val data = workDataOf(<br/>        KEY_MY_INT to myIntVar,<br/>        KEY_MY_INT_ARRAY to myIntArray,<br/>        KEY_MY_STRING to myString<br/>    )</span></pre><h1 id="9892" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker.html" rel="noopener ugc nofollow" target="_blank">CoroutineWorker</a></code></h1><p id="79ad" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">除了Java中可用的worker类(<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Worker.html" rel="noopener ugc nofollow" target="_blank">Worker</a></code>、<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker" rel="noopener ugc nofollow" target="_blank">ListenableWorker</a></code>和<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/RxWorker.html" rel="noopener ugc nofollow" target="_blank">RxWorker</a></code>)，还有一个Kotlin only类，它使用<a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin的协程</a>为您工作。</p><p id="ebd0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du kg kh ki kj b">Worker</code>类和<code class="du kg kh ki kj b">CoroutineWorker</code>的主要区别在于<code class="du kg kh ki kj b">CoroutineWorker</code>中的<code class="du kg kh ki kj b">doWork()</code>方法是一个挂起函数，可以运行异步任务，而<code class="du kg kh ki kj b">Worker</code>的<code class="du kg kh ki kj b">doWork()</code>只能执行同步对话。另一个<code class="du kg kh ki kj b">CoroutineWorker</code>特性是它自动处理停止和取消，而工人类需要实现<code class="du kg kh ki kj b">onStopped()</code>方法来处理这些情况。</p><p id="8e11" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于这些不同选项的完整内容，您可以参考工作管理器指南中的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/threading" rel="noopener ugc nofollow" target="_blank">线程。</a></p><p id="518f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我想把重点放在什么是<code class="du kg kh ki kj b">CoroutineWorker</code>上，涵盖一些微小但重要的差异，然后深入研究如何使用WorkManager v2.1中引入的新测试特性来测试您的<code class="du kg kh ki kj b">CoroutineWorker</code>类。</p><p id="f1b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们之前写的，<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker.html#dowork" rel="noopener ugc nofollow" target="_blank">CoroutineWorker#doWork()</a></code>只是一个暂停函数。默认情况下，这在<code class="du kg kh ki kj b">Dispatchers.Default</code>启动:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="a2b6" class="lv kl hx kj b fi lw lx l ly lz">class MyWork(context: Context, params: WorkerParameters) :<br/>        CoroutineWorker(context, params) {</span><span id="a9c0" class="lv kl hx kj b fi ma lx l ly lz">override suspend fun doWork(): Result {</span><span id="7280" class="lv kl hx kj b fi ma lx l ly lz">return try {<br/>            // Do something<br/>            Result.success()<br/>        } catch (error: Throwable) {<br/>            Result.failure()<br/>        }<br/>    }<br/>}</span></pre><p id="65da" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当使用<code class="du kg kh ki kj b">CoroutineWorker</code>代替<code class="du kg kh ki kj b">Worker</code>或<code class="du kg kh ki kj b">ListenableWorker</code>时，理解这一点很重要:</p><blockquote class="mb mc md"><p id="b761" class="iu iv me iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated"><em class="hx">与</em> <code class="du kg kh ki kj b"><em class="hx">Worker</em></code> <em class="hx">不同，此代码不会在您的工作管理器配置中指定的</em> <code class="du kg kh ki kj b"><em class="hx">Executor</em></code> <em class="hx">上运行。</em></p></blockquote><p id="4756" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们刚才说过，<code class="du kg kh ki kj b">CoroutineWorker#doWork()</code>默认为<code class="du kg kh ki kj b">Dispatchers.Default</code>。您可以使用<code class="du kg kh ki kj b">withContext()</code>对此进行定制:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="ec93" class="lv kl hx kj b fi lw lx l ly lz">class MyWork(context: Context, params: WorkerParameters) :<br/>        CoroutineWorker(context, params) {</span><span id="a684" class="lv kl hx kj b fi ma lx l ly lz">override suspend fun doWork(): Result = withContext(Dispatchers.IO) {</span><span id="16bd" class="lv kl hx kj b fi ma lx l ly lz">return try {<br/>            // Do something<br/>            Result.success()<br/>        } catch (error: Throwable) {<br/>            Result.failure()<br/>        }<br/>    }<br/>}</span></pre><blockquote class="mb mc md"><p id="99f0" class="iu iv me iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">很少需要改变你的<code class="du kg kh ki kj b">CoroutineWorker</code>正在使用的<code class="du kg kh ki kj b">Dispatcher</code>，并且<code class="du kg kh ki kj b">Dispatchers.Default</code>在大多数情况下是一个好的选择。</p></blockquote><p id="7302" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解更多关于如何在Kotlin中使用WorkManager的信息，你可以试试<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/" rel="noopener ugc nofollow" target="_blank">这个codelab </a>。</p><h1 id="ce0c" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">测试工作类</h1><p id="2392" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">WorkManager有几个额外的构件，允许轻松地测试您的工作。您可以在<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing" rel="noopener ugc nofollow" target="_blank">工作管理器的测试文档页面</a>和新的“<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing-210" rel="noopener ugc nofollow" target="_blank">使用工作管理器2.1.0进行测试</a>”指南中了解更多信息。这个测试助手的最初实现使得定制WorkManager成为可能，这样它就可以同步工作，然后您可以使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/testing/WorkManagerTestInitHelper#gettestdriver" rel="noopener ugc nofollow" target="_blank">WorkManagerTestInitHelper#getTestDriver()</a></code>来模拟延迟和测试周期性工作。</p><p id="8e12" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的关键点是，您正在修改驱动您的<code class="du kg kh ki kj b">Worker</code>类的行为或工作管理器，以使测试它们成为可能。</p><p id="be50" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">WorkManager v2.1添加了一个新的<code class="du kg kh ki kj b">TestListenableWorkerBuilder</code>功能，它引入了一种新的方法来测试您的<code class="du kg kh ki kj b">Worker</code>类。</p><p id="540f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这对于<code class="du kg kh ki kj b">CoroutineWorker</code>来说是一个非常重要的更新，因为使用<code class="du kg kh ki kj b">TestListenableWorkerBuilder</code>你实际上是直接运行你的工人类来测试他们的逻辑。</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="ed50" class="lv kl hx kj b fi lw lx l ly lz">@RunWith(JUnit4::class)<br/>class MyWorkTest {<br/>    private lateinit var context: Context</span><span id="d053" class="lv kl hx kj b fi ma lx l ly lz">    @Before<br/>    fun setup() {<br/>        context = ApplicationProvider.getApplicationContext()<br/>    }</span><span id="8e80" class="lv kl hx kj b fi ma lx l ly lz">    @Test<br/>    fun testMyWork() {<br/>        // Get the ListenableWorker<br/>        val worker = <br/>            TestListenableWorkerBuilder&lt;MyWork&gt;(context).build()</span><span id="a4f4" class="lv kl hx kj b fi ma lx l ly lz">        // Run the worker synchronously<br/>        val result = worker.startWork().get()</span><span id="1cd4" class="lv kl hx kj b fi ma lx l ly lz">        assertThat(result, `is`(Result.success()))<br/>    }<br/>}</span></pre><p id="dcb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里重要的是运行<code class="du kg kh ki kj b">CoroutineWorker</code>的结果是同步获得的，您可以直接检查您的Worker类逻辑行为是否正确</p><p id="2c0a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<code class="du kg kh ki kj b">TestListenableWorkerBuilder</code>你可以将输入数据传递给你的<code class="du kg kh ki kj b">Worker</code>或者设置<code class="du kg kh ki kj b">runAttemptCount</code>，这对测试你工作中的重试逻辑是有用的。</p><p id="7b71" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">举个例子，如果你上传一些数据到服务器，你可能想要添加一些重试逻辑来考虑连接问题。</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="70a8" class="lv kl hx kj b fi lw lx l ly lz">class MyWork(context: Context, params: WorkerParameters) :<br/>        CoroutineWorker(context, params) {</span><span id="40eb" class="lv kl hx kj b fi ma lx l ly lz">    override suspend fun doWork(): Result {<br/>        val serverUrl = inputData.getString("SERVER_URL")</span><span id="c4c2" class="lv kl hx kj b fi ma lx l ly lz">        return try {<br/>            // Do something with the URL<br/>            Result.success()<br/>        } catch (error: TitleRefreshError) {<br/>            if (runAttemptCount &lt;3) {<br/>                Result.retry()<br/>            } else {<br/>                Result.failure()<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="bd88" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，您可以使用<code class="du kg kh ki kj b">TestListenableWorkerBuilder</code>在您的测试中测试这个重试逻辑:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="17a2" class="lv kl hx kj b fi lw lx l ly lz">@Test<br/>fun testMyWorkRetry() {<br/>    val data = workDataOf("SERVER_URL" to "<a class="ae hu" href="http://fake.url" rel="noopener ugc nofollow" target="_blank">http://fake.url</a>")</span><span id="f5d2" class="lv kl hx kj b fi ma lx l ly lz">    // Get the ListenableWorker with a RunAttemptCount of 2<br/>    val worker = TestListenableWorkerBuilder&lt;MyWork&gt;(context)   <br/>                     .setInputData(data)<br/>                     .setRunAttemptCount(2)<br/>                     .build()</span><span id="ee76" class="lv kl hx kj b fi ma lx l ly lz">    // Start the work synchronously<br/>    val result = worker.startWork().get()</span><span id="60ae" class="lv kl hx kj b fi ma lx l ly lz">    assertThat(result, `is`(Result.retry()))<br/>}</span><span id="127f" class="lv kl hx kj b fi ma lx l ly lz">@Test<br/>fun testMyWorkFailure() {<br/>    val data = workDataOf("SERVER_URL" to "<a class="ae hu" href="http://fake.url" rel="noopener ugc nofollow" target="_blank">http://fake.url</a>")</span><span id="8be9" class="lv kl hx kj b fi ma lx l ly lz">    // Get the ListenableWorker with a RunAttemptCount of 3<br/>    val worker = TestListenableWorkerBuilder&lt;MyWork&gt;(context)<br/>                     .setInputData(data)<br/>                     .setRunAttemptCount(3)<br/>                     .build()</span><span id="69ea" class="lv kl hx kj b fi ma lx l ly lz">    // Start the work synchronously<br/>    val result = worker.startWork().get()</span><span id="154a" class="lv kl hx kj b fi ma lx l ly lz">    assertThat(result, `is`(Result.failure()))<br/>}</span></pre><h1 id="582c" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="2244" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">随着WorkManager v2.1的发布和workmanager-testing中的新特性，<code class="du kg kh ki kj b">CoroutineWorker</code>因其简单性和功能性而大放异彩。测试现在真的很容易，在Kotlin的整体体验非常棒。</p><p id="0961" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你还没有尝试过<code class="du kg kh ki kj b">CoroutineWorker</code>和<code class="du kg kh ki kj b">workmanager-runtime-ktx</code>中包含的其他扩展，我强烈建议你在自己的项目中尝试一下。当我和Kotlin一起工作时(现在总是这样)，这是我使用WorkManager的首选方式！</p><p id="77f4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望这篇文章对你有用，我很想知道你是如何使用WorkManager的，或者WorkManager的哪些特性可以得到更好的解释或记录。</p><p id="c22f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在推特<a class="ae hu" href="https://twitter.com/pfmaggi" rel="noopener ugc nofollow" target="_blank"> @pfmaggi </a>上找到我。</p><h1 id="6a79" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">资源</h1><ul class=""><li id="bbee" class="js jt hx iw b ix li jb lj jf mi jj mj jn mk jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/" rel="noopener ugc nofollow" target="_blank">程序员指南</a></li><li id="b995" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/package-summary" rel="noopener ugc nofollow" target="_blank">参考指南</a></li><li id="4c38" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/" rel="noopener ugc nofollow" target="_blank"> Codelab:工作管理器的后台工作</a></li><li id="2eba" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://issuetracker.google.com/issues?q=componentid:409906" rel="noopener ugc nofollow" target="_blank">工作管理器公共发行跟踪器</a></li><li id="1c1e" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/work" rel="noopener ugc nofollow" target="_blank">发行说明</a></li><li id="1d65" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://stackoverflow.com/questions/tagged/android-workmanager" rel="noopener ugc nofollow" target="_blank">堆栈溢出【android-workmanager】标签</a></li><li id="4a6f" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/master/work" rel="noopener ugc nofollow" target="_blank">工作管理器源代码(AOSP的一部分)</a></li></ul></div></div>    
</body>
</html>