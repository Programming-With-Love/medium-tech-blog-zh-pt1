<html>
<head>
<title>Stricter Tests for Expectations Set on Nil in RSpec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在RSpec中对零设置了更严格的期望测试</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/stricter-tests-for-expectations-set-on-nil-in-rspec-1b33244ca75d?source=collection_archive---------3-----------------------#2015-06-19">https://medium.com/square-corner-blog/stricter-tests-for-expectations-set-on-nil-in-rspec-1b33244ca75d?source=collection_archive---------3-----------------------#2015-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8837" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">当期望值为零时，使RSpec测试失败。</h2></div><p id="6490" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="jt ju ge" href="https://medium.com/u/feb32780d540?source=post_page-----1b33244ca75d--------------------------------" rel="noopener" target="_blank">撰写<em class="js">莉丝奔</em> </a> <em class="js">。</em></p><blockquote class="jv"><p id="ae00" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="890e" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated">当我在Square开始编写第一批代码时，我的任务是确保数据平台团队的Ruby程序在遇到非暂时性错误时不会不断重试数据查询。我们的日志被关于多个查询的信息填满，甚至在一个错误之后——比如找不到表。无论我们重试多少次，都找不到那张表！因此，当我着手防止一些过度的查询时，我从我们的测试开始。</p><h1 id="84e5" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">愚蠢的测试导致愚蠢的代码</h1><p id="5215" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">当我的队友审查我的代码时，他们很快发现了一个错误:我一直在重构一些变量，在这样做的过程中，我忘记了确保我的实例变量被正确地实例化。我迫不及待地将我们的@logger改成了我们正在讨论的类的initialize方法中的logger。这是一个容易犯的错误，幸运的是，也是一个容易发现的错误。我们很快发现了代码审查中的错误，并疑惑为什么我们的测试仍然通过。我们又在本地做了测试。我浏览了与PR相关的构建输出。一切都是绿色的。</p><p id="054e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在几次“啊，这太奇怪了”之后，我们决定再运行一次测试，看看会发生什么。这次我们看了测试。果然，它们仍然是绿色的，但这一次我们看到了一些我们以前没有看到的屏幕输出。它们是来自RSpec的警告！</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es li"><img src="../Images/e9a32a5351e1ee5efaae01d1a7a6881d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wv-B_ArVRQgaGh_a.png"/></div></div></figure><p id="1c50" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这暴露了测试中的两个常见问题。开发人员很懒:如果您必须向上滚动才能看到输出，您可能不会看到。<br/> 2。如果一切正常，测试中的问题就不会被发现。</p><h1 id="53d0" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">为更好的代码进行更严格的测试</h1><p id="a66e" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">为了解决上述问题，我们认为当期望值为零时，强制测试失败是有益的。在RSpec-mocks中，已经有了在测试中设置一个标记来抑制警告消息的选项。我们希望我们的代码更加严格；当我们把期望值设为零时，我们希望测试失败。让我们抓住那些误报！</p><p id="9e28" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们一开始只是简单地模仿已经存在的抑制警告信息的行为。您可以在测试中调用一个方法allow _ message _ expectations _ on _ nil来实现这一点。我们以完全相同的方式实现了一个disallow _ message _ expectations _ on _ nil方法<a class="ae kf" href="https://github.com/lizrush/rspec-mocks/commit/e6cf52138a8d5ad32f24a4e21a0a53b1b9ebe660" rel="noopener ugc nofollow" target="_blank">。在讨论如何实现这一点时，我们立即想到将它作为一个配置标志有多好，您可以简单地在您的RSpec配置中设置它，但是我们决定不立即这样做。由于这是库的一个小而新的特性，我们决定最好做最小可行的实现并公开一个PR，这样我们可以从维护者那里得到反馈，看看他们是否想首先集成它。</a></p><p id="fa03" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，维护者的第一个评论是，是的，他们希望包含这个特性，但是作为一个全局配置不是更好吗？有人建议我们像这样实现这个更严格的测试配置:</p><pre class="lj lk ll lm fd lu lv lw lx aw ly bi"><span id="148d" class="lz km hh lv b fi ma mb l mc md">RSpec.configure do |config|<br/>  config.mock_with :rspec do |mocks|<br/>    mocks.allow_message_expectations_on_nil = false<br/>  end<br/>end</span></pre><p id="fc3a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过重构allow _ message _ expectations _ on _ nil标志，我们不仅能够将它移动到一个地方，在那里您不必再为每个需要该设置的测试调用该API，而且我们还扩展了模拟应该如何表现的选项。以前，唯一的选项是允许警告或允许和禁止警告。</p><p id="7860" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们有以下可以在RSpec模拟配置中设置的选项:</p><ul class=""><li id="7005" class="me mf hh iy b iz ja jc jd jf mg jj mh jn mi jr mj mk ml mm bi translated">对配置标志不做任何事情，保留默认行为:</li><li id="ba40" class="me mf hh iy b iz mn jc mo jf mp jj mq jn mr jr mj mk ml mm bi translated">当期望值设置为零时，RSpec将警告用户，但测试不会失败(原始行为)。</li><li id="f84a" class="me mf hh iy b iz mn jc mo jf mp jj mq jn mr jr mj mk ml mm bi translated">将allow_expectations_on_nil设置为true:</li><li id="53a4" class="me mf hh iy b iz mn jc mo jf mp jj mq jn mr jr mj mk ml mm bi translated">RSpec将抑制警告消息(原始行为)。</li><li id="0765" class="me mf hh iy b iz mn jc mo jf mp jj mq jn mr jr mj mk ml mm bi translated">将allow_expectations_on_nil设置为false:</li><li id="aa73" class="me mf hh iy b iz mn jc mo jf mp jj mq jn mr jr mj mk ml mm bi translated">当期望值设置为nil(新行为)时，RSpec将无法通过测试。</li></ul><h1 id="af11" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">测试测试框架</h1><p id="5f77" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">这一改变的好处之一是我们能够重构一些已经准备好的警告代码。虽然以前它只是ProxyForNil类内部的一个方法，用硬编码的字符串调用Kernel.warn('message here ')，但我们能够通过使用ErrorGenerator类来清理它，该类必须在以后的某个时间点创建。事实上，ProxyForNil类已经实例化了ErrorGenerator的一个实例，但它没有被使用。现在，当调用默认行为warning或引发错误的新实现时，这两种方法都使用ErrorGenerator类。这不仅创建了一个更加一致的错误和警告实现，而且还允许框架本身的测试更加精确！</p><p id="0724" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为测试框架做贡献的另一个主要挑战是用框架来测试自己。如果你用来测试的措辞和你正在测试的措辞是一样的，那么阅读测试就要困难得多。最终，我们在测试中加入了这一行，起初看起来有点令人难以置信:</p><pre class="lj lk ll lm fd lu lv lw lx aw ly bi"><span id="aa04" class="lz km hh lv b fi ma mb l mc md">expect { expect(nil).to receive(:foo) }.to raise_error(RSpec::Mocks::MockExpectationError)</span></pre><p id="a3e2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在达到我们可以期望我们所有的期望以我们想要的方式运行的程度之后，另一个挑战是弄清楚如何测试框架的配置，而不从您的测试中改变整个套件的配置。这让我困惑了很长时间。当我们使用新特性来禁止对nil的期望时，我们可以通过我的测试，但是更严格的配置会使套件中的其他测试失败！</p><p id="191b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">谢天谢地，在我们怀疑会遇到类似问题的其他测试中，我们在库的spec_helper文件中找到了一个方便的共享上下文:</p><pre class="lj lk ll lm fd lu lv lw lx aw ly bi"><span id="3efa" class="lz km hh lv b fi ma mb l mc md">context 'configured to disallow expectations on nil' do<br/>       include_context 'with isolated configuration'<br/>        it 'raises an error when expectations on nil are disallowed' do<br/>          RSpec::Mocks.configuration.allow_message_expectations_on_nil = false<br/>          expect { expect(nil).to receive(:foo)     }.to raise_error(RSpec::Mocks::MockExpectationError)<br/>          expect { expect(nil).not_to receive(:bar) }.to raise_error(RSpec::Mocks::MockExpectationError)<br/>        end<br/>      end</span></pre><p id="8aa1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过包含隔离配置的共享上下文，测试测试框架变得容易了。当库的维护者像Rspec团队一样乐于助人、反应迅速、热情好客时，这也很有帮助——特别感谢<a class="ae kf" href="https://twitter.com/jonrowe" rel="noopener ugc nofollow" target="_blank">乔恩·罗</a>、<a class="ae kf" href="https://twitter.com/xshay" rel="noopener ugc nofollow" target="_blank">泽维尔·谢伊</a>、和<a class="ae kf" href="https://twitter.com/myronmarston" rel="noopener ugc nofollow" target="_blank">米隆·马斯顿</a>以及团队的其他成员！</p><h1 id="67a6" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">合并了！</h1><p id="2366" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated"><a class="ae kf" href="https://github.com/rspec/rspec-mocks/pull/983" rel="noopener ugc nofollow" target="_blank">请购单已成功合并</a>并已到位供您使用。下次运行测试套件时，考虑通过禁止对nil的期望来强制进行更严格的测试，并查看有多少先前通过的测试是误报的。</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><div class="lj lk ll lm fd mz"><a rel="noopener follow" target="_blank" href="/@lizmrush"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hi fi z dy ne ea eb nf ed ef hg bi translated">利兹·拉什-简介</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">答案，这些问题和答案直接相互映射。“你叫什么名字”可以被问一千次…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ls mz"/></div></div></a></div></div></div>    
</body>
</html>