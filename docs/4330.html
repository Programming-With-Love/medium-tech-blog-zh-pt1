<html>
<head>
<title>Advanced FP for the Enterprise Bee: Higher Kinded Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业蜂的高级FP:更高级的类型</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527?source=collection_archive---------3-----------------------#2021-01-22">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527?source=collection_archive---------3-----------------------#2021-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e73aaa04f0e95e7a43d74cfac77c47cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cXrhKidxYGGJABB1.jpg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">A Stack of Honeycomb</figcaption></figure><h1 id="3cf0" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">介绍</h1><p id="92dd" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">这是我们系列文章的第三篇，涵盖了典型Kotlin开发人员的高级FP概念。在第一篇文章中，我们展示了<em class="kq">遍历</em>操作符是多么有用。在这个过程中，我们遇到了三个陌生的概念——<em class="kq">应用</em>、<em class="kq">半群</em>和<em class="kq">高级类型</em> (HKT的)。</p><p id="a766" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">我们的<a class="ae kp" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c">第二篇文章</a>处理了<em class="kq">应用</em>和<em class="kq">半群</em>。本文将通过解释<em class="kq">更高级的种类</em>来完善这一套。我们将从重温最初的问题开始，然后从头解释HKT的问题。</p><p id="25d6" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">一如既往，本系列的所有代码都可以在这个库中找到。</p><h1 id="40c1" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">最初的问题</h1><p id="040a" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">检查下面的代码。特别要考虑函数<em class="kq">输出1 </em>、<em class="kq">输出2 </em>和<em class="kq">输出3 </em>的参数类型。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="704f" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">我们看到<em class="kq">数据1 </em>是从一到五的映射结果，为每个数字生成一个<em class="kq">右</em>。所以想必<em class="kq"> output1 </em>可以带某种<em class="kq"> List &lt;要么&gt;要么</em>。事实确实如此。</p><p id="d339" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">当我们查看<em class="kq">数据2 </em>时，我们看到它是遍历相同范围的结果。所以我们希望结果是某种<em class="kq">或者&lt;列表&gt; </em>。不幸的是，正如对<em class="kq"> fix </em>的调用所暗示的，情况并非完全如此。</p><p id="0395" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">以下是匹配函数:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7945" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">如果我们在列表及其内容上调用<em class="kq"> fix </em>，那么我们可以调用<em class="kq"> output2 </em>，传入一个<em class="kq">或者&lt; Int，List &lt; Int &gt; &gt; </em>。没有这些神奇的咒语，实际类型是令人困惑的:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="da8c" class="lh iu hh ld b fi li lj l lk ll">Kind&lt;EitherPartialOf&lt;Nothing&gt;, Kind&lt;ForListK, Int&gt;&gt;</span></pre><p id="70b8" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">理解这里发生的事情是学习Arrow的最大障碍之一，并且困惑了我很长一段时间。所以，让我们慢慢地梳理一下这些概念。</p><h1 id="3893" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">一个更简单的例子</h1><p id="07ce" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">看看这个有点做作的例子。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7908" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">我们有一个竞争对象，它将判断一个<em class="kq">或者</em>或者一个<em class="kq">验证过的</em>对象是代表赢家还是输家。对于<em class="kq">或者</em>来说，正确的<em class="kq">案例代表赢家，而对于<em class="kq">有效的</em>来说，它是<em class="kq">有效的</em>案例。</em></p><p id="1a5c" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">下面是生成的输出:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="5cad" class="lh iu hh ld b fi li lj l lk ll">winner<br/>loser<br/>winner<br/>loser</span></pre><p id="1040" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">让我们假设这种逻辑对当前的应用程序很重要，所以我们决定定义一个接口来表示竞赛的想法。看看你是否能找出这次尝试的问题所在:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="41b9" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">合乎逻辑。我们用三个类型参数来声明我们的接口，然后给出一个方法，该方法采用一个<em class="kq"> U </em>和<em class="kq"> V </em>的<em class="kq"> T </em>。遗憾的是，这将无法编译。问题是在Kotlin和大多数编程语言中，<strong class="jt hi">不可能嵌套类型参数</strong>。</p><h1 id="ba12" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">为什么这很重要</h1><p id="0b75" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">使用类型参数作为泛型类型的参数最初是很奇怪的。这不是我们这样的工蜂会做的事情。但事实证明，这对围绕FP构建的库的设计者来说非常重要。</p><p id="4fb3" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">正如我们已经看到的，许多FP都是围绕以下内容构建的:</p><ul class=""><li id="af98" class="lm ln hh jt b ju kr jy ks kc lo kg lp kk lq ko lr ls lt lu bi translated">容器(<em class="kq">选项</em>、<em class="kq">任一</em>、<em class="kq">已验证</em>、<em class="kq">未来</em>、<em class="kq"> IO </em>等)</li><li id="11b9" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">我们放在容器中的类型(<em class="kq">客户、</em>等)</li><li id="b3d6" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">对值容器列表的操作(<em class="kq">映射</em>、<em class="kq">遍历</em>等)</li></ul><p id="2050" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">因此，我们想要定义代表这些交互“形状”的接口。当用英语解释类似<em class="kq">的FP形状时，我们可以这样说:</em></p><blockquote class="ma mb mc"><p id="8966" class="jr js kq jt b ju kr jw jx jy ks ka kb md kt ke kf me ku ki kj mf kv km kn ko ha bi translated">此操作适用于一个或多个<em class="hh"> T </em>，其中每个<em class="hh"> T </em>都是一个容器，容纳一个<em class="hh"> U </em>或一个<em class="hh"> V </em>。</p></blockquote><p id="9d0e" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">我们希望能够在代码中做同样的事情。这需要嵌套类型参数的能力。当创建像Arrow这样的库时，我们无法做到这一点是一个大问题。特别是它阻止你创建一个叫做<em class="kq">类型类</em>的东西。但这是另一篇文章的主题。</p><h1 id="8179" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">Scala的一个简短的题外话</h1><p id="614e" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">如果我们用Scala写这段代码，那么<em class="kq">更高级的类型</em>将直接为我们所用。</p><p id="210c" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">下面是我们的<em class="kq">竞赛</em>接口(又名。特质):</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f5fd" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">最重要的一点是这个语法:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="0fa4" class="lh iu hh ld b fi li lj l lk ll">Competition[T[_,_]]</span></pre><p id="4020" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">它表明<em class="kq">竞争</em>类型需要一个类型参数T，而T又需要自己的两个类型实参。在<em class="kq">判断</em>的实现中，我们可以自由地声明输入是<em class="kq">【U，V】</em>或<em class="kq">验证的【U，V】</em>。</p><p id="7394" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">这是Kotlin和Scala不同价值主张的一个很好的例子。Kotlin提供了一般开发人员所需的FP，但并不是库作者想要的所有东西。这保持了语言的极简主义和浅的学习曲线。</p><p id="e5a1" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">相反，Scala给了你FP和OO范例的所有特性，假设你会明智地结合它们。这意味着可能性更大，但学习曲线更陡峭。</p><p id="35a7" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">假设我们已经把我们的小马套在了科特林的马车上，我们可以用什么来代替<em class="kq"> T[ _，_ ] </em>？</p><h1 id="ea9f" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">解决科特林的问题</h1><p id="0ee6" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">以下是科特林问题的解决方案。我在下面完整地展示了它，所以我们可以逐步地把它分开:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b392" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">如你所见，我们的竞争接口采用标准类型参数<em class="kq"> T </em>，而<em class="kq">判断</em>方法采用<em class="kq"> U </em>和<em class="kq"> V </em>。到目前为止一切顺利，但是我们需要通知编译器<em class="kq"> U </em>和<em class="kq"> V </em>嵌套在<em class="kq"> T </em>中。</p><p id="05ff" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">实现这一点的方法是:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="ab0a" class="lh iu hh ld b fi li lj l lk ll">input: Kind2&lt;T, U, V&gt;</span></pre><p id="09ef" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated"><strong class="jt hi">当我们在Arrow中使用<em class="kq">种类</em>类型时，我们对第一个类型参数是后面类型的容器这一事实进行了编码。我们根据需要递归嵌套<em class="kq">类</em>实例，使用类型别名来简化命名。</strong></p><p id="b129" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">下面是来自Arrow源代码的声明:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="61a9" class="lh iu hh ld b fi li lj l lk ll">interface Kind&lt;out F, out A&gt;<br/>typealias Kind2&lt;F, A, B&gt; = Kind&lt;Kind&lt;F, A&gt;, B&gt;</span></pre><p id="1a44" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">目前，别名上升到第22类第22类第23类。看起来已经很多了。</p><p id="d611" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">我们正在做的是<strong class="jt hi">用一个组合关系</strong>取代一个层级关系。Kotlin不提供前者，所以我们使用后者。</p><p id="195a" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">如果你够老了，这可能会让你想起遥远的过去——这类似于我们在90年代用过程语言模拟继承的方式。C和Visual Basic 6是最常见的例子。如果这对你来说太复古了，这也类似于JavaScript如何通过原型链接来模拟继承。</p><p id="9a99" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">当我们实现接口时，我们用所谓的“见证对象”替换了类型。按照惯例，这些对象的名称以“For”开头。因此，我们用<em class="kq">代替</em>，用<em class="kq">代替已验证的</em>。</p><p id="dde7" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">以下是匹配的声明:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="37ce" class="lh iu hh ld b fi li lj l lk ll">class ForEither private constructor() { companion object }<br/>class ForValidated private constructor() { companion object }</span></pre><p id="b745" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">如你所见，这些类型并不起眼。它们的存在只是为了用作键值。如果我们检查我们的容器类型的声明，就可以看到它们将事物联系在一起的方式。</p><p id="a949" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">以下是<em class="kq">或</em>的声明:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="4fae" class="lh iu hh ld b fi li lj l lk ll">sealed class Either&lt;out A, out B&gt; : EitherOf&lt;A, B&gt; { ... }<br/>typealias EitherOf&lt;A, B&gt; = arrow.Kind2&lt;ForEither, A, B&gt;<br/>typealias EitherPartialOf&lt;A&gt; = arrow.Kind&lt;ForEither, A&gt;</span></pre><p id="76f2" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">以下是经过验证的的声明:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="119a" class="lh iu hh ld b fi li lj l lk ll">sealed class Validated&lt;out E, out A&gt; : ValidatedOf&lt;E, A&gt; { ... }<br/>typealias ValidatedOf&lt;E, A&gt; = arrow.Kind2&lt;ForValidated, E, A&gt;<br/>typealias ValidatedPartialOf&lt;E&gt; = arrow.Kind&lt;ForValidated, E&gt;</span></pre><p id="e2a3" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">正如你可以看到的，一旦我们解开类型别名，无论是还是<em class="kq">验证的</em>都继承自<em class="kq"> Kind2 </em>。一个<em class="kq">或者一个</em>扩展<em class="kq">种类2 &lt;用于验证A、B &gt;而一个<em class="kq">验证</em>扩展<em class="kq">种类2 &lt;用于验证A、B&gt;。</em>这是一种模式，我们可以根据需要在自己的容器类型中重复使用。</em></p><p id="974c" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">有了这样的安排，我们就能在科特林模仿更高级的种类。这里有一个简单的客户端来证明它的工作:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="d8ca" class="lh iu hh ld b fi li lj l lk ll">winner<br/>loser<br/>winner<br/>loser</span></pre><h1 id="6e2e" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">缺失的元素</h1><p id="f91b" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">如果你真的注意了，那么你可能已经注意到我漏掉了一步。这是我们不得不手动插入的对<em class="kq"> fix </em>的多次调用。</p><p id="9d61" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">Arrow将尽可能管理从<em class="kq">类</em>实例到匹配容器的转换。但是当这不可能时，你调用<em class="kq"> fix </em>方法，它执行运行时强制转换。</p><p id="b30f" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">这里是<em class="kq">或者</em>的定义，你可以看到它并不复杂:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="0654" class="lh iu hh ld b fi li lj l lk ll">@Suppress("UNCHECKED_CAST", "NOTHING_TO_INLINE")<br/>inline fun &lt;A, B&gt; EitherOf&lt;A, B&gt;.fix(): Either&lt;A, B&gt; =<br/>  this as Either&lt;A, B&gt;</span></pre><p id="bde5" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">因为<em class="kq">或者</em>类型是从<em class="kq"> Kind2 </em>扩展而来的，所以子类型的标准OO规则适用。当需要一个<em class="kq"> Kind2 </em>，但提供了一个<em class="kq">或</em>时，自动进行向上转换。</p><p id="e088" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">然而，当你有一个类型为<em class="kq"> Kind2，</em>的引用，但是需要一个<em class="kq">或者</em>时，你必须向编译器保证你愿意承担向下转换的风险。这通常是通过调用<em class="kq"> fix，</em>来完成的，但是你也可以用你喜欢的任何其他方式来完成。</p><h1 id="9300" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="7ddd" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">当我第一次开始使用Arrow时，我不知道HKT是怎么回事，只是简单地采用了“构建者鲍勃”的方法来处理编译器错误:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/2688bac2595fe9ae1a4a57b1374fd3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PPCW_-ala8xTTNHe.jpg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Slogan for Bob the Builder</figcaption></figure><p id="5afb" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">但是希望你现在对正在发生的事情有一个更好的了解。总结一下我们所讲的内容:</p><ul class=""><li id="5938" class="lm ln hh jt b ju kr jy ks kc lo kg lp kk lq ko lr ls lt lu bi translated">像Kotlin这样的主流语言是为普通开发人员优化的，所以它们省略了不太有用的特性，比如嵌套类型参数的能力。</li><li id="beec" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">然而，这些更高级的类型对于试图表现FP中使用的公共容器和操作的库作者来说非常有用。</li><li id="423d" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">幸运的是，有一种方法可以使用复合来模拟这种类型参数的层次结构。大多数时候这并不是一个不便。</li><li id="efd2" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">然而，当浏览Arrow文档时，您会看到对<em class="kq">类</em>实例的频繁引用。A <em class="kq">类&lt; A、B&gt;T25】是对<em class="kq"> A &lt; B &gt;的替代。</em></em></li><li id="2e16" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">在箭头容器类型中，比如<em class="kq">或者</em>继承<em class="kq">种类。</em>该模式的一个限制是，有时你需要执行手动向下转换，通常是通过<em class="kq"> fix </em>方法。</li></ul><p id="79cf" class="pw-post-body-paragraph jr js hh jt b ju kr jw jx jy ks ka kb kc kt ke kf kg ku ki kj kk kv km kn ko ha bi translated">目前就这些。下次我们将调查克雷斯利。</p><h1 id="79db" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">参考</h1><p id="f38e" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">您可能会发现查看以下内容会有所帮助:</p><ul class=""><li id="bcf1" class="lm ln hh jt b ju kr jy ks kc lo kg lp kk lq ko lr ls lt lu bi translated">这些概念的描述在<a class="ae kp" href="https://arrow-kt.io/docs/patterns/glossary/" rel="noopener ugc nofollow" target="_blank">箭头词汇表</a>中</li><li id="5701" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">这是用低级语言谈论高级类型</li><li id="28e6" class="lm ln hh jt b ju lv jy lw kc lx kg ly kk lz ko lr ls lt lu bi translated">关于'<a class="ae kp" href="https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf" rel="noopener ugc nofollow" target="_blank">轻量级高级多态</a>的原始论文</li></ul><h1 id="ea6e" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">谢谢</h1><p id="b0b8" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">感谢<a class="ae kp" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kp" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。所有的错误当然是我自己的。</p></div></div>    
</body>
</html>