<html>
<head>
<title>Measure and improve performance with Macrobenchmark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Macrobenchmark衡量和提高性能</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/measure-and-improve-performance-with-macrobenchmark-560abd0aa5bb?source=collection_archive---------0-----------------------#2022-04-20">https://medium.com/androiddevelopers/measure-and-improve-performance-with-macrobenchmark-560abd0aa5bb?source=collection_archive---------0-----------------------#2022-04-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="88f8" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><em class="iw">Jetpack宏基准和基准配置文件简介</em></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ad07ab04e52579b37439109d0ad40b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0eXjqbYyCGSsHQLEmTnFw.png"/></div></div></figure><p id="15f7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">你是否在考虑优化你的应用程序的性能，但不知道从何下手？或者您是否优化了性能并怀疑是否还有改进的空间？</p><p id="2333" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">您可以对您的应用进行基准测试！</p><p id="49e9" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在本文中，我们将了解<a class="ae kf" href="https://developer.android.com/studio/profile/macrobenchmark-overview" rel="noopener ugc nofollow" target="_blank"> Jetpack Macrobenchmark库</a>如何帮助您了解应用程序的性能，以及如何<a class="ae kf" href="https://android-developers.googleblog.com/2022/01/improving-app-performance-with-baseline.html" rel="noopener ugc nofollow" target="_blank">使用基线配置文件将应用程序的启动时间提高30% </a>！</p><h1 id="d808" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">什么是Jetpack宏基准</h1><p id="e2ef" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">Jetpack Macrobenchmark是用于测量(和基准测试)应用程序性能的库。宏基准适用于端到端用例，如应用启动、跨活动导航、滚动列表或其他UI操作。该库直接在Android Studio中提供结果，并将结果写入JSON文件。这使得它不仅适用于在您的工作站上进行本地测量，还适用于持续集成(CI)中的性能测试。</p><p id="d3c7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">借助Jetpack Macrobenchmark，您可以:</p><ul class=""><li id="919b" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">使用确定的启动模式和滚动速度多次测量应用程序</li><li id="0848" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">控制应用程序的编译状态——性能稳定性的主要因素</li><li id="871c" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">通过本地复制谷歌Play商店执行的安装时优化来检查真实世界的性能</li></ul><p id="2a8a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">使用这个库的检测不直接调用您的应用程序代码，而是像用户一样导航您的应用程序。如果您想直接测量您的应用程序代码的一部分，请参见<a class="ae kf" href="https://developer.android.com/studio/profile/microbenchmark-overview" rel="noopener ugc nofollow" target="_blank"> Jetpack微基准</a>。</p><p id="8ac7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">宏基准测试在一个单独的进程中运行，以允许重启或预编译您的应用程序。这意味着像Espresso这样的进程内机制不起作用，你可以使用<code class="du lr ls lt lu b"><a class="ae kf" href="https://developer.android.com/training/testing/other-components/ui-automator" rel="noopener ugc nofollow" target="_blank">UiAutomator</a></code>来与目标应用程序交互。</p><p id="5e86" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">理论讲够了，我们开始吧。</p><h1 id="f5b3" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">将基准添加到项目中</h1><p id="7a49" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">在本文中，我们将向<a class="ae kf" href="https://github.com/android/sunflower" rel="noopener ugc nofollow" target="_blank">向日葵示例</a>应用程序添加宏基准。</p><p id="96cf" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">宏基准测试需要在项目中添加一个新的Gradle模块。最简单的开始方式是使用Android Studio模板(至少需要北极狐2020.3.1)。</p><ol class=""><li id="e6d6" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke lv lj lk ll bi translated">在<strong class="jl hi">项目</strong>面板中右键单击您的项目或模块。</li><li id="2921" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">选择<strong class="jl hi">新&gt;模块</strong>。</li><li id="6b12" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">从<strong class="jl hi">模板</strong>窗格中选择<strong class="jl hi">基准</strong>。</li><li id="6db3" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">选择<strong class="jl hi">宏基准</strong>作为基准模块类型，并填写详细信息。</li><li id="978c" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">设置你要基准测试的<strong class="jl hi">最低SDK </strong>，至少需要Android 6 (API等级23)。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/3c460ac3bca813a59293f3094ea8b6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SZR9ZftmzMWBSfPE"/></div></div></figure><p id="6406" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">向导为您做了几件事:</p><ul class=""><li id="8b70" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">为宏基准创建一个<code class="du lr ls lt lu b">com.android.test</code>模块。</li><li id="0573" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">添加将<code class="du lr ls lt lu b">debuggable</code>设置为假并将<code class="du lr ls lt lu b">signingConfig</code>设置为<code class="du lr ls lt lu b">debug</code>的<code class="du lr ls lt lu b">benchmark</code>构建类型。</li><li id="6413" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">将<code class="du lr ls lt lu b">&lt;profileable&gt;</code>标签添加到AndroidManifest。</li><li id="dc9a" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">创建一个基本的启动基准框架。</li></ul><p id="2e00" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们将<code class="du lr ls lt lu b">signingConfig</code>设置为<code class="du lr ls lt lu b">debug</code>只是为了能够在不需要生产密钥库的情况下进行构建。我们还需要禁用<code class="du lr ls lt lu b">debuggable</code>,因为它增加了很多性能开销，并使结果计时不稳定。然而，因为我们禁用了<code class="du lr ls lt lu b">debuggable</code>，所以我们需要添加<code class="du lr ls lt lu b">&lt;profileable&gt;</code>标签，以允许基准测试通过发布性能来分析您的应用。要获得更多关于<code class="du lr ls lt lu b">&lt;profileable&gt;</code>的信息，请查看我们的<a class="ae kf" href="https://developer.android.com/studio/profile#profileable-apps" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="6c16" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在我们可以开始编写实际的基准测试了。</p><h1 id="f6c8" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">测量应用程序启动</h1><p id="d120" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated"><a class="ae kf" href="https://developer.android.com/topic/performance/vitals/launch-time" rel="noopener ugc nofollow" target="_blank">应用启动时间</a>，或者说用户开始使用你的应用所需的时间，是衡量用户参与度的一个关键指标。要使用macrobenchmarks测量应用程序的启动时间，请编写如下的<code class="du lr ls lt lu b">@Test</code>(如果您使用模板创建了模块，Android Studio已经为您创建了该模块):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f0ac" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们来分解一下这一切意味着什么。<br/>宏基准是常规的插装单元测试，因此它们使用JUnit语法— <code class="du lr ls lt lu b">@RunWith</code>、<code class="du lr ls lt lu b">@Rule</code>、<code class="du lr ls lt lu b">@Test</code>等。编写基准时，您的入口点是<code class="du lr ls lt lu b">MacrobenchmarkRule</code>的<code class="du lr ls lt lu b">measureRepeated</code>函数，在这里您至少需要指定这些参数:</p><ul class=""><li id="3a25" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><code class="du lr ls lt lu b">packageName</code>–由于基准测试在单独的进程中运行，您需要指定要测量的应用程序。</li><li id="f91d" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">metrics</code>–捕获信息的主要类型。在我们的例子中，我们关心启动时间。</li><li id="50b9" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">iterations</code>–循环将重复多少次。更多的迭代意味着更稳定的结果，但代价是更长的执行时间。</li><li id="1aa9" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">measureBlock</code>(最后一个lambda参数)–macro benchmark将在此块中跟踪并记录定义的指标。您在这里执行想要测量的动作。</li></ul><p id="2275" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">也可以选择指定<code class="du lr ls lt lu b">CompilationMode</code>和<code class="du lr ls lt lu b">StartupMode</code>。</p><p id="5839" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><code class="du lr ls lt lu b">CompilationMode</code>定义了如何将应用程序预编译成机器代码，并有以下选项:</p><ul class=""><li id="35b3" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><code class="du lr ls lt lu b">None()</code>–不预编译应用程序，但JIT在应用程序执行过程中仍然启用。</li><li id="c85b" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">Partial()</code>–使用基线配置文件和/或预热运行预编译应用。</li><li id="681b" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">Full()</code>–预编译整个应用程序。这是Android 6 (API 23)和更低版本上的唯一选项。</li></ul><p id="b45f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><code class="du lr ls lt lu b">StartupMode</code>允许您定义您的应用程序<a class="ae kf" href="https://developer.android.com/topic/performance/vitals/launch-time" rel="noopener ugc nofollow" target="_blank">应该如何在基准开始时</a>启动。可用选项有<code class="du lr ls lt lu b">COLD</code>、<code class="du lr ls lt lu b">WARM</code>和<code class="du lr ls lt lu b">HOT</code>。您可以从代表您的应用程序必须完成的最大工作量的<code class="du lr ls lt lu b">StartupMode.COLD</code>开始。</p><p id="b48a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们运行它——与您运行任何单元测试的方式相同——在测试旁边使用gutter图标。</p><p id="38a2" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">您应该在真实设备上进行基准测试，而不是在Android模拟器上。如果您试图在模拟器上运行基准测试，它将在运行时失败，并警告您可能会给出不正确的结果。虽然从技术上讲，您可以在模拟器上运行它(如果您<a class="ae kf" href="https://developer.android.com/studio/profile/macrobenchmark-instrumentation-args#suppresserrors" rel="noopener ugc nofollow" target="_blank">抑制警告</a>)，但您基本上是在测量您的主机性能——如果它处于重负载下，您的基准测试会显得更慢，反之亦然。</p><p id="ae2d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在执行过程中，基准将启动和停止您的应用几次(基于<code class="du lr ls lt lu b">iterations</code>)，然后它将结果输出到Android Studio:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/6e4db55c3899a6eacb6daa245d5f1882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npFWM-9y3Ne1GoaCo_-yOg.png"/></div></div></figure><p id="8d55" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">结果以毫秒为单位给出了你的应用程序启动 ( <code class="du lr ls lt lu b">timeToInitialDisplayMs</code>)所用的时间<a class="ae kf" href="https://developer.android.com/topic/performance/vitals/launch-time#time-initial" rel="noopener ugc nofollow" target="_blank">。每个结果本身都是一个带有系统跟踪的链接，您可以在Android Studio中打开它，进一步调查初创公司的情况，并采取措施进行优化。</a></p><p id="db8e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">一个常见的情况是测量应用程序已经完全加载了内容，用户可以与之交互，也称为<a class="ae kf" href="https://developer.android.com/topic/performance/vitals/launch-time#time-full" rel="noopener ugc nofollow" target="_blank">完全显示的时间</a>。为了告诉系统这种情况何时发生，您必须调用<code class="du lr ls lt lu b">Activity.reportFullyDrawn()</code>。如果这样做，启动基准将自动捕获<code class="du lr ls lt lu b">timeToFullDisplayMs</code>。请注意，您需要等待基准中的内容，否则基准会在第一个渲染帧结束，并可能跳过指标。</p><p id="7e31" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">例如，下面的代码片段一直等到<code class="du lr ls lt lu b">garden_list</code>有了几个孩子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f883" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">好了，我们已经测量了应用启动时间！我们能做得更多吗？可以测帧，调查jank！</p><h1 id="b1ab" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">测量帧时序并检测jank</h1><p id="fd55" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">在你的用户登陆你的应用后，他们遇到的第二个指标是应用的流畅程度。或者用我们的话来说，应用程序能以多快的速度生成帧。为了测量它，我们将使用<code class="du lr ls lt lu b"><a class="ae kf" href="https://developer.android.com/reference/androidx/benchmark/macro/FrameTimingMetric" rel="noopener ugc nofollow" target="_blank">FrameTimingMetric</a></code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/fa20571fa3650d052ca69b4b9b217235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TEi_ClWls6Iy4sFi"/></div></div></figure><p id="4993" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">要使用Macrobenchmark实现上述流程，您需要编写如下基准:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="2c29" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们以与启动基准测试相同的方式运行它，并获得以下结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/653dac775df795593859ed709c0dd031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Insa1GnJYcnkc0Tw"/></div></div></figure><p id="ffe1" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">此指标输出第50、90、95和99百分位的帧持续时间，单位为毫秒(<code class="du lr ls lt lu b">frameDurationCpuMs</code>)。在Android 12 (API level 31)及更高版本上，它还会返回你的帧数超过限制多长时间(<code class="du lr ls lt lu b">frameOverrunMs</code>)。该值可以是负数，这意味着产生一帧的剩余时间。</p><div class="mc md ez fb me mf"><a href="https://goo.gle/benchmarking-codelab" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">与Macrobenchmark | Android开发人员一起检查应用性能</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在这个codelab中，您将学习使用macrobenchmark库。你将测量应用程序的启动时间，这是一个关键…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">咕咕</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jh mf"/></div></div></a></div><h1 id="6683" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">我们已经测量过了，那又怎样？</h1><p id="b6c7" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">Macrobenchmarks为每次迭代生成系统跟踪，让您进一步调查执行期间发生了什么。你可以在Android Studio中直接打开跟踪文件，方法是从结果中点击迭代(或者在应用启动的情况下点击min/median/max)。</p><p id="f871" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">正如我们在基准测试中看到的，当打开工厂细节时，一些帧被跳过。我们可以开始调查跟踪文件的问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/ccb3ecd2946700a7ec5306716a95dc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4509x61c5lbaxDsL"/></div></div></figure><p id="a420" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">系统跟踪显示平台代码捕获的各个部分，以及作为应用程序一部分的库。通常它没有足够的信息。为了改善这一点，使用<code class="du lr ls lt lu b">trace(“MySection”) { /* this will be in the trace */ }</code>添加带有<a class="ae kf" href="https://developer.android.com/jetpack/androidx/releases/tracing" rel="noopener ugc nofollow" target="_blank"> AndroidX跟踪</a>库的定制跟踪部分。有关读取跟踪和<a class="ae kf" href="https://developer.android.com/topic/performance/tracing/custom-events#kotlin" rel="noopener ugc nofollow" target="_blank">添加自定义</a>事件的更多信息，请访问<a class="ae kf" href="https://developer.android.com/topic/performance/tracing" rel="noopener ugc nofollow" target="_blank">系统跟踪概述</a>。</p><p id="30d4" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在，关于提高性能。</p><h1 id="0e6f" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">使用基线配置文件提高性能</h1><p id="3971" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">基线配置文件是APK中包含的类和方法的列表，它们在应用程序安装过程中预编译为机器码。这可以使你的应用程序启动更快，减少jank，并提高一般性能。这是因为JIT编译器在遇到代码的指定部分时不需要被触发。</p><p id="e250" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">您可以通过将定制项目添加到您的<code class="du lr ls lt lu b">src/main</code>目录下的<code class="du lr ls lt lu b">baseline-prof.txt</code>文件中来将它们添加到基线概要文件中。但是，如果您不想自己编写成百上千个重要的方法到文件中，您可以简化过程，用Macrobenchmark生成基线概要文件！查看<a class="ae kf" href="https://developer.android.com/studio/profile/baselineprofiles" rel="noopener ugc nofollow" target="_blank">基线配置文件</a>了解更多关于这些如何工作的信息。</p><p id="3884" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">通常，你会为你的应用程序的典型用户旅程生成配置文件。<br/>在我们的示例中，我们可以识别这三种旅程:</p><ol class=""><li id="0952" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke lv lj lk ll bi translated">启动应用程序(这对大多数应用程序来说至关重要)</li><li id="b6c0" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">转到工厂列表(来自上一示例)</li><li id="af48" class="ld le hh jl b jm lm jp ln js lo jw lp ka lq ke lv lj lk ll bi translated">转到工厂详情</li></ol><p id="3313" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了生成概要文件，您将使用<code class="du lr ls lt lu b">BaselineProfileRule</code>(而不是之前的<code class="du lr ls lt lu b">MacrobenchmarkRule</code>)并调用<code class="du lr ls lt lu b">collectBaselineProfile(packageName)</code>。下面的代码片段显示了如何为提到的旅程生成配置文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="51ab" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">要运行这个，你需要一个运行Android 9 (API级别28)或更高版本的<code class="du lr ls lt lu b">userdebug</code>或根仿真器(没有谷歌Play商店)。在运行测试之前，通过从终端调用<code class="du lr ls lt lu b">adb root</code>以root权限重启adb。现在您可以运行测试来生成概要文件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/9f69be63469c9a45fd1c2aba68c12f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*geclDWVw99n9ISLP"/></div></div></figure><p id="41ef" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">运行测试后，您需要做几件事来使基线配置文件与您的应用程序一起工作:</p><ol class=""><li id="a80b" class="ld le hh jl b jm jn jp jq js lf jw lg ka lh ke lv lj lk ll bi translated">您需要将生成的基线概要文件放到您的<code class="du lr ls lt lu b">src/main</code>文件夹中(在<code class="du lr ls lt lu b">AndroidManifest.xml</code>旁边)。要检索该文件，您可以从位于<code class="du lr ls lt lu b">project_root/macrobenchmark/build/outputs/</code>的<code class="du lr ls lt lu b">connected_android_test_additional_output</code>文件夹中复制它，如下图所示。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/cdf50b8aa62d69b6c342b8531cada07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*egMSXtwkRK79yqR2"/></div></div></figure><p id="394d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">或者，您可以点击Android Studio输出中的<code class="du lr ls lt lu b">Baseline Profile <strong class="jl hi">results</strong></code>链接并保存内容，或者使用输出中打印的<code class="du lr ls lt lu b">adb pull</code>命令。</p><p id="04a2" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">2.您需要将文件重命名为<code class="du lr ls lt lu b">baseline-prof.txt</code>。</p><p id="9ee6" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">3.向您的应用程序添加profileinstaller依赖项</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="4482" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了验证基线概要文件被正确加载，您可以运行我们之前定义的基准，但是使用<code class="du lr ls lt lu b">CompilationMode.Partial()</code>作为<code class="du lr ls lt lu b">compilationMode</code>参数。默认情况下，此参数要求基线配置文件在应用程序安装期间可用。</p><p id="20e0" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在下面的截图中，我们可以看到两个基准测试的结果— <code class="du lr ls lt lu b">startupCompilationPartial</code>使用了基线概要文件，而<code class="du lr ls lt lu b">startupCompilationNone</code>没有。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/ff9948b8ee68baa9589c8d463e013e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lxKJorBvgjX-54e-"/></div></div></figure><p id="11fa" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">从结果中我们可以看到，未编译应用程序的<code class="du lr ls lt lu b">timeToFullDisplayMs</code>中值为<strong class="jl hi">293.9毫秒</strong>，而使用基准配置文件的应用程序的中值为<strong class="jl hi">239.9毫秒</strong>。这给了我们<strong class="jl hi"> ~22% </strong>更快的启动时间！这是一个使用视图的示例应用程序，视图是为整个系统预先编译的。如果您的应用程序使用Jetpack Compose，其中UI代码包含在您的APK中，性能增益将会更大！</p><div class="mc md ez fb me mf"><a href="https://goo.gle/baseline-profiles-codelab" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">借助基线档案提高应用性能| Android开发人员</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在这个codelab中，您将了解如何生成基线配置文件来优化您的应用程序的性能，以及如何…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">咕咕</p></div></div><div class="mo l"><div class="mx l mq mr ms mo mt jh mf"/></div></div></a></div><h1 id="ded0" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">接下来呢？</h1><p id="db3c" class="pw-post-body-paragraph jj jk hh jl b jm ky ii jo jp kz il jr js la ju jv jw lb jy jz ka lc kc kd ke ha bi translated">本文只是触及了宏基准测试的皮毛。</p><p id="12ad" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在本地运行基准测试来发现是否有问题是很好的，但是在您的CI上跟踪性能会更好。现在，您可以查看<a class="ae kf" href="https://developer.android.com/studio/profile/benchmarking-in-ci" rel="noopener ugc nofollow" target="_blank">文档</a>，其中我们展示了如何在CI中进行基准测试，并查看我们示例中Firebase测试实验室的<a class="ae kf" href="https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample/ftl" rel="noopener ugc nofollow" target="_blank">设置。</a></p><p id="b163" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果你想深入了解，我们最近修改了我们的<a class="ae kf" href="https://developer.android.com/studio/profile/macrobenchmark-overview" rel="noopener ugc nofollow" target="_blank">文档</a>，所以来看看吧。如果您遗漏了什么，或者您有一个想要测量的想法，请在我们的<a class="ae kf" href="https://issuetracker.google.com/issues/new?component=975669&amp;template=1519452" rel="noopener ugc nofollow" target="_blank">追踪器</a>中告诉我们！我们感谢任何反馈。</p><p id="1d0b" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">此外，请让我们知道您使用基线配置文件在应用中获得了哪些性能优势！</p></div></div>    
</body>
</html>