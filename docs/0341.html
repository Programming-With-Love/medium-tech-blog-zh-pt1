<html>
<head>
<title>Underspanding spans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下跨跨度</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/underspanding-spans-1b91008b97e4?source=collection_archive---------2-----------------------#2018-04-04">https://medium.com/androiddevelopers/underspanding-spans-1b91008b97e4?source=collection_archive---------2-----------------------#2018-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/2a9a5047f8abb44cc95342eefd90939f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Te49GZFBFW3PP8fiWv9oQA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="5dae" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">跨度是强大的概念，通过提供对TextPaint和Canvas等组件的访问，允许在字符或段落级别对文本进行样式化。在以前的文章中，我们讨论了如何使用跨度，开箱即用的跨度是什么，如何轻松地创建自己的跨度，以及如何测试它们。</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/google-developers/spantastic-text-styling-with-spans-17b0c16b4568"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">带跨度的文本样式</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">要在Android中样式化文本，使用spans！改变一些字符的颜色，使它们可以点击，缩放…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><p id="18b7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看在处理文本时，可以使用哪些API来确保特定用例的最佳性能。我们将探索更多关于跨度的内幕，以及框架如何使用它们。最后，我们将看到如何在同一个流程中或流程之间传递跨度，并基于此，在决定创建您自己的定制跨度时，您需要注意什么样的警告。</p><h1 id="c4c3" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">引擎盖下:跨度如何工作</h1><p id="f88c" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">Android框架在几个类中处理文本样式和跨度:<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html" rel="noopener ugc nofollow" target="_blank">TextView</a></code>、<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/EditText.html" rel="noopener ugc nofollow" target="_blank">EditText</a></code>、布局类(<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Layout.html" rel="noopener ugc nofollow" target="_blank">Layout</a></code>、<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/StaticLayout.html" rel="noopener ugc nofollow" target="_blank">StaticLayout</a></code>、<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/DynamicLayout.html" rel="noopener ugc nofollow" target="_blank">DynamicLayout</a></code>)和<code class="du lk ll lm ln b">TextLine</code>(在<code class="du lk ll lm ln b">Layout</code>中使用的一个包私有类)，它取决于几个参数:</p><ul class=""><li id="d25a" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr lt lu lv lw bi translated">文本类型:可选、可编辑或不可选择</li><li id="2be4" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.BufferType.html" rel="noopener ugc nofollow" target="_blank">BufferType</a></code></li><li id="eda9" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><code class="du lk ll lm ln b">TextView</code>的<code class="du lk ll lm ln b">LayoutParams</code>型</li><li id="2218" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated">等等</li></ul><p id="ba94" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">框架检查<code class="du lk ll lm ln b">Spanned</code>对象是否包含不同框架跨度的实例，并触发不同的动作。</p><p id="7ac6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">文本布局和绘制背后的逻辑是复杂的，并分布在不同的类中；在这一节中，我们只能简单地介绍文本是如何处理的，而且只限于某些情况。</p><p id="8268" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每次跨度改变时，<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/TextView.java" rel="noopener ugc nofollow" target="_blank">TextView</a>.spanChange</code>检查跨度是否是<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/UpdateAppearance.html" rel="noopener ugc nofollow" target="_blank">UpdateAppearance</a></code>、<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/ParagraphStyle.html" rel="noopener ugc nofollow" target="_blank">ParagraphStyle</a></code>或<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/CharacterStyle.html" rel="noopener ugc nofollow" target="_blank">CharacterStyle</a></code>的实例，如果是，则使其自身无效，触发视图的新绘制。</p><p id="0d72" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/text/TextLine.java" rel="noopener ugc nofollow" target="_blank">TextLine</a></code>类表示一行样式化的文本，它专门用于扩展<code class="du lk ll lm ln b">CharacterStyle</code>、<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/MetricAffectingSpan.html" rel="noopener ugc nofollow" target="_blank">MetricAffectingSpan</a></code>和<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/ReplacementSpan.html" rel="noopener ugc nofollow" target="_blank">ReplacementSpan</a></code>的跨度。这是触发<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/MetricAffectingSpan.html#updateMeasureState(android.text.TextPaint)" rel="noopener ugc nofollow" target="_blank">MetricAffectingSpan.updateMeasureState</a></code>和<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/CharacterStyle.html#updateDrawState(android.text.TextPaint)" rel="noopener ugc nofollow" target="_blank">CharacterStyle.updateDrawState</a></code>的类。</p><p id="1700" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">管理屏幕上可视元素中文本布局的基类是<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Layout.html" rel="noopener ugc nofollow" target="_blank">android.text.Layout</a></code>。<code class="du lk ll lm ln b">Layout</code>和它的两个子类<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/StaticLayout.html" rel="noopener ugc nofollow" target="_blank">StaticLayout</a></code>和<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/DynamicLayout.html" rel="noopener ugc nofollow" target="_blank">DynamicLayout</a></code>检查文本上设置的跨度，以计算行高和布局边距。除此之外，每当显示在<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/DynamicLayout.html" rel="noopener ugc nofollow" target="_blank">DynamicLayout</a></code>中的范围被更新时，布局检查该范围是否是<code class="du lk ll lm ln b">UpdateLayout</code>范围，并为受影响的文本生成新的布局。</p><h1 id="085d" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">设置文本以获得最佳性能</h1><p id="262a" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">根据您的需要，有几种节省内存的方式来设置<code class="du lk ll lm ln b">TextView</code>中的文本。</p><h1 id="2faa" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.设置在<code class="du lk ll lm ln b">TextView</code>上的文本从不改变</h1><p id="4fa9" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">如果您只在TextView上设置了一次文本，并且从未更新过它，那么您可以创建一个新的<code class="du lk ll lm ln b">SpannableString</code>或<code class="du lk ll lm ln b">SpannableStringBuilder</code>实例，设置所需的跨度，然后调用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank">textView.setText(spannable)</a></code>。因为您不再处理文本，所以没有更多性能需要改进。</p><h1 id="09a5" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">2.通过添加/移除跨度来更改文本样式</h1><p id="a373" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">让我们考虑这样一种情况，文本没有改变，但是附加在它上面的跨度改变了。例如，假设每当点击一个按钮时，您希望文本中的一个单词变成灰色。所以，我们需要给文本添加一个新的跨度。要做到这一点，您很可能会尝试调用两次<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank">textView.setText(CharSequence)</a></code>:第一次是设置初始文本，第二次是在单击按钮时。一个更好的解决方案是调用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence,%20android.widget.TextView.BufferType)" rel="noopener ugc nofollow" target="_blank">textView.setText(CharSequence, BufferType)</a></code>并在点击按钮时更新<code class="du lk ll lm ln b">Spannable</code>对象的范围。</p><p id="8c3d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是这些选项背后的情况:</p><p id="d269" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">选项1:多次调用</strong><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">textview . settext(char sequence)</strong></a><strong class="iw hy">—次优</strong></p><p id="15a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当调用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank">textView.setText(CharSequence)</a></code>时，<code class="du lk ll lm ln b">TextView</code>会创建一个你的<code class="du lk ll lm ln b">Spannable</code>的副本作为<code class="du lk ll lm ln b">SpannedString</code>，并将其作为<code class="du lk ll lm ln b">CharSequence</code>保存在内存中。这样做的结果是您的<strong class="iw hy">文本和跨度是不可变的</strong>。因此，当您需要更新文本样式时，您将不得不创建一个新的<code class="du lk ll lm ln b">Spannable</code>，带有文本和跨度，再次调用<code class="du lk ll lm ln b">textView.setText</code>，这将依次创建对象的新副本。</p><p id="28a9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">选项二:调用</strong><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence,%20android.widget.TextView.BufferType)" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">textview . settext(char sequence，BufferType) </strong> </a> <strong class="iw hy">一次，更新一个Spannable对象— optimal </strong></p><p id="e534" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当调用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence,%20android.widget.TextView.BufferType)" rel="noopener ugc nofollow" target="_blank">textView.setText(CharSequence, BufferType)</a></code>时，<code class="du lk ll lm ln b">BufferType</code>参数告诉<code class="du lk ll lm ln b">TextView</code>设置了什么类型的文本:静态(调用<code class="du lk ll lm ln b">textView.setText(CharSequence)</code>时的默认类型)、可样式化/可扩展文本或可编辑文本(将由<code class="du lk ll lm ln b">EditText</code>使用)。</p><p id="277b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们正在处理可以设置样式的文本，所以我们可以调用:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="7a46" class="mk ki hx ln b fi ml mm l mn mo">textView.setText(spannableObject, <strong class="ln hy">BufferType.SPANNABLE</strong>)</span></pre><p id="a0f4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，<code class="du lk ll lm ln b">TextView</code>不再创建一个<code class="du lk ll lm ln b">SpannedString</code>，但是它将在<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.Factory.html" rel="noopener ugc nofollow" target="_blank">Spannable.Factory</a></code>类型的成员对象的帮助下创建一个<code class="du lk ll lm ln b">SpannableString</code>。因此现在，<code class="du lk ll lm ln b">TextView</code>保存的<code class="du lk ll lm ln b">CharSequence</code>副本有<strong class="iw hy">可变标记和</strong>不可变文本。</p><p id="077f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更新跨度，我们首先获取文本作为<code class="du lk ll lm ln b">Spannable</code>，然后根据需要更新跨度。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="bf70" class="mk ki hx ln b fi ml mm l mn mo">// if setText was called with BufferType.SPANNABLE<br/>textView.setText(spannable, BufferType.SPANNABLE)</span><span id="7ef3" class="mk ki hx ln b fi mp mm l mn mo">// the text can be cast to Spannable<br/>val spannableText = textView.text as Spannable</span><span id="93e6" class="mk ki hx ln b fi mp mm l mn mo">// now we can set or remove spans<br/>spannableText.setSpan(<br/>     ForegroundColorSpan(color), <br/>     8, spannableText.length, <br/>     SPAN_INCLUSIVE_INCLUSIVE)</span></pre><p id="bd45" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这个选项，我们只创建初始的<code class="du lk ll lm ln b">Spannable</code>对象。<code class="du lk ll lm ln b">TextView</code>将保存它的副本，但是当我们需要修改它时，我们不需要创建任何其他对象，因为我们将直接处理由<code class="du lk ll lm ln b">TextView</code>保存的<code class="du lk ll lm ln b">Spannable</code>文本的实例。然而，<code class="du lk ll lm ln b">TextView</code>将仅被告知跨度的添加/移除/重新定位。如果您更改了span的一个内部属性，您将不得不调用<code class="du lk ll lm ln b">invalidate()</code>或<code class="du lk ll lm ln b">requestLayout()</code>，这取决于更改的类型。详见下面的“<em class="mq">奖金绩效提示</em>”。</p><h1 id="6f18" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">3.文本更改(重用文本视图)</h1><p id="17aa" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">假设我们想要重用一个<code class="du lk ll lm ln b">TextView</code>并多次设置文本，就像在一个<code class="du lk ll lm ln b">RecyclerView.ViewHolder</code>中一样。默认情况下，独立于<code class="du lk ll lm ln b">BufferType</code>集合，<code class="du lk ll lm ln b">TextView</code>创建一个<code class="du lk ll lm ln b">CharSequence</code>对象的副本并保存在内存中。这确保了当开发人员出于其他原因更改<code class="du lk ll lm ln b">CharSequence</code>值时，所有的<code class="du lk ll lm ln b">TextView</code>更新都是有意的，而不是偶然的。</p><p id="fd2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的选项2中，我们看到当通过<code class="du lk ll lm ln b">textView.setText(spannableObject, BufferType.SPANNABLE)</code>设置文本时，<code class="du lk ll lm ln b">TextView</code>通过使用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.Factory.html" rel="noopener ugc nofollow" target="_blank">Spannable.Factory</a></code>实例创建一个新的<code class="du lk ll lm ln b">SpannableString</code>来复制<code class="du lk ll lm ln b">CharSequence</code>。所以每次我们设置一个新的文本，它就会创建一个新的对象。如果您想对这个过程进行更多的控制，并避免额外的对象创建，请实现您自己的<code class="du lk ll lm ln b">Spannable.Factory</code>，覆盖<a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.Factory.html#newSpannable(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank">newSpannable(char sequence)</a>，并将工厂设置为<code class="du lk ll lm ln b">TextView</code>。</p><p id="ddb3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们自己的实现中，我们希望避免创建新的对象，所以我们可以将<code class="du lk ll lm ln b">CharSequence</code>转换为<code class="du lk ll lm ln b">Spannable</code>。请记住，为了做到这一点，您必须调用<code class="du lk ll lm ln b">textView.setText(spannableObject, BufferType.SPANNABLE)</code>，否则，源<code class="du lk ll lm ln b">CharSequence</code>将是<code class="du lk ll lm ln b">Spanned</code>的一个实例，它不能被强制转换为<code class="du lk ll lm ln b">Spannable</code>，从而产生一个<code class="du lk ll lm ln b">ClassCastException</code>。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="b906" class="mk ki hx ln b fi ml mm l mn mo">val spannableFactory = object : Spannable.Factory() {<br/>    override fun newSpannable(source: CharSequence?): Spannable {<br/>        return source <strong class="ln hy">as Spannable<br/>    </strong>}<br/>}</span></pre><p id="db49" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">设置<strong class="iw hy">扳手。在你得到对你的<code class="du lk ll lm ln b">TextView</code>的引用后，工厂</strong>对象一旦出现。如果你使用的是<code class="du lk ll lm ln b">RecyclerView</code>，那么在你第一次放大你的视图时就这样做。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="c462" class="mk ki hx ln b fi ml mm l mn mo"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setSpannableFactory(android.text.Spannable.Factory)" rel="noopener ugc nofollow" target="_blank">textView.setSpannableFactory</a>(spannableFactory)</span></pre><p id="7aa6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这样，您就可以避免每次您的<code class="du lk ll lm ln b">RecyclerView</code>向您的<code class="du lk ll lm ln b">ViewHolder</code>绑定一个新项目时创建额外的对象。</p><p id="31f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了在处理文本和<code class="du lk ll lm ln b">RecyclerViews</code>时获得更好的性能，不要从<code class="du lk ll lm ln b">ViewHolder</code>中的<code class="du lk ll lm ln b">String</code>中创建<code class="du lk ll lm ln b">Spannable</code>对象，而是在将列表传递给 <code class="du lk ll lm ln b"><strong class="iw hy">Adapter</strong></code>之前创建<strong class="iw hy">。这允许您在后台线程上构造<code class="du lk ll lm ln b">Spannable</code>对象，以及您对列表元素所做的任何其他工作。然后你的<code class="du lk ll lm ln b">Adapter</code>可以保存一个对<code class="du lk ll lm ln b">List&lt;Spannable&gt;</code>的引用。</strong></p><h1 id="3cc7" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">额外绩效提示</h1><p id="913a" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">如果你只需要改变一个跨度的内部属性(例如，一个自定义项目符号跨度的项目符号颜色)，你不需要再次调用<code class="du lk ll lm ln b">TextView.setText</code>，只需要调用<code class="du lk ll lm ln b">invalidate()</code>或者<code class="du lk ll lm ln b">requestLayout()</code>。再次调用<code class="du lk ll lm ln b">setText</code>会导致不必要的逻辑被触发和对象被创建，当视图需要重新绘制或重新测量时。</p><p id="f720" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您需要做的是保存对可变跨度的引用，并根据您在视图中更改的属性类型，调用:</p><ul class=""><li id="a414" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr lt lu lv lw bi translated"><code class="du lk ll lm ln b"><strong class="iw hy">TextView.invalidate()</strong> </code>如果你只是改变<strong class="iw hy">文本外观</strong>，触发<strong class="iw hy">重绘</strong>并跳过重做布局。</li><li id="d893" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><code class="du lk ll lm ln b"><strong class="iw hy">TextView.requestLayout()</strong></code>如果你做了一个改变，使<strong class="iw hy">影响到文字的尺寸</strong>，那么视图就可以照顾到<strong class="iw hy">的测量、排版和绘图</strong>。</li></ul><p id="af12" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设您有自己的自定义项目符号实现，其中默认的项目符号颜色是红色。每当您按下一个按钮时，您都希望将项目符号的颜色更改为灰色。实现如下所示:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="3da7" class="mk ki hx ln b fi ml mm l mn mo">class MainActivity : AppCompatActivity() {<br/>    // keeping the span as a field<br/>    val bulletSpan = BulletPointSpan(color = Color.<em class="mq">RED</em>)</span><span id="b62d" class="mk ki hx ln b fi mp mm l mn mo">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        …<br/>        val spannable = SpannableString(“Text is spantastic”)<br/>        // setting the span to the bulletSpan field<br/>        spannable.setSpan(<br/>            bulletSpan, <br/>            0, 4, <br/>            Spanned.<em class="mq">SPAN_INCLUSIVE_INCLUSIVE</em>)<br/>        styledText.setText(spannable)<br/>        button.setOnClickListener( {<strong class="ln hy"><br/>            </strong>// change the color of our mutable span<br/>            bulletSpan.<em class="mq">color </em>= Color.<em class="mq">GRAY<br/>            </em>// color won’t be changed until invalidate is called<br/>            <strong class="ln hy">styledText.invalidate()</strong><br/>        }<strong class="ln hy"><br/>    </strong>}</span></pre><h1 id="cf8e" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">幕后:在进程内和进程间传递文本</h1><p id="370a" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated"><em class="mq">TL；博士:</em></p><p id="adef" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mq">当跨越对象在进程内或进程间传递时，将不使用自定义跨越属性。如果仅仅使用框架跨度就可以实现想要的样式，那么</em> <strong class="iw hy"> <em class="mq">更喜欢应用多个框架跨度</em> </strong> <em class="mq">来实现自己的跨度。否则，最好实现扩展一些基本接口或抽象类的自定义范围。</em></p><p id="87dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android中，文本可以在同一进程中传递(进程内)，例如通过意图从一个活动传递到另一个活动，以及当文本从一个应用程序复制到另一个应用程序时在进程之间传递(进程间)。</p><p id="be7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自定义span实现不能跨越流程边界，因为其他流程不知道它们，也不知道如何处理它们。Android框架跨度是全局对象，但是<strong class="iw hy">只有从</strong> <code class="du lk ll lm ln b"><strong class="iw hy">ParcelableSpan</strong></code> <strong class="iw hy">延伸的跨度可以在进程内和进程间传递。</strong>该功能允许打包和解包框架中定义的范围的所有属性。<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/TextUtils.html#writeToParcel(java.lang.CharSequence,%20android.os.Parcel,%20int)" rel="noopener ugc nofollow" target="_blank">TextUtils.writeToParcel</a></code>方法负责将跨度信息保存在<code class="du lk ll lm ln b">Parcel</code>中。</p><p id="8314" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，您可以在同一个流程中通过一个意图在<code class="du lk ll lm ln b">Activities</code>之间传递跨度:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="813d" class="mk ki hx ln b fi ml mm l mn mo">// start Activity with text with spans<br/>val intent = Intent(this, MainActivity::class.java)<br/>intent.putExtra(TEXT_EXTRA, mySpannableString)<br/>startActivity(intent)</span><span id="c3f2" class="mk ki hx ln b fi mp mm l mn mo">// read text with Spans<br/>val intentCharSequence = intent.getCharSequenceExtra(TEXT_EXTRA)</span></pre><blockquote class="mr ms mt"><p id="eaf0" class="iu iv mq iw b ix iy iz ja jb jc jd je mu jg jh ji mv jk jl jm mw jo jp jq jr ha bi translated">所以，即使你在同一个过程中传递跨度，只有框架<code class="du lk ll lm ln b">ParcelableSpans</code>能够通过意图传递。</p></blockquote><p id="332e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lk ll lm ln b">ParcelableSpans</code>还允许从一个流程到另一个流程复制文本和跨度。复制和粘贴文本的过程通过<code class="du lk ll lm ln b">ClipboardService</code>进行，它在幕后使用相同的<code class="du lk ll lm ln b">TextUtil.writeToParcel</code>方法。因此，即使您从您的应用程序中复制跨度并将其粘贴到同一个应用程序中，这也是一个进程间操作，需要打包，因为文本要经过<code class="du lk ll lm ln b">ClipboardService</code>。</p><p id="bdf7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">默认情况下，任何实现<code class="du lk ll lm ln b">Parcelable</code>的类都可以从<code class="du lk ll lm ln b">Parcel</code>编写和恢复。当在进程间传递一个<code class="du lk ll lm ln b">Parcelable</code>对象时，唯一能保证被正确恢复的类是框架类。如果试图从<code class="du lk ll lm ln b">Parcel</code>恢复数据的进程由于数据类型在不同的应用程序中定义而无法构建对象，那么进程将崩溃。</p><p id="7087" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有两大警告:</p><ol class=""><li id="2938" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr mx lu lv lw bi translated">当带有span的文本被传递时，无论是在同一个进程中还是在进程间，<strong class="iw hy">只有框架的</strong> <code class="du lk ll lm ln b"><strong class="iw hy">ParcelableSpans</strong></code> <strong class="iw hy">引用被保留</strong>。因此，自定义跨度样式不会传播。</li><li id="5acf" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr mx lu lv lw bi translated"><strong class="iw hy">不能自己创建</strong> <code class="du lk ll lm ln b"><strong class="iw hy">ParcelableSpan</strong></code> <strong class="iw hy">。</strong>为了避免未知数据类型导致的崩溃，框架不允许实现自定义的<code class="du lk ll lm ln b">ParcelableSpan</code>，通过定义两个方法<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/text/ParcelableSpan.java#L39" rel="noopener ugc nofollow" target="_blank">getSpanTypeIdInternal</a></code>和<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/text/ParcelableSpan.java#L47" rel="noopener ugc nofollow" target="_blank">writeToParcelInternal</a></code>为隐藏的。两个都是<code class="du lk ll lm ln b">TextUtils.writeToParcel</code>用的。</li></ol><p id="15b8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设您想要定义一个允许自定义项目符号大小的项目符号跨度，因为现有的<code class="du lk ll lm ln b">BulletSpan</code>定义了4px的固定半径大小。以下是如何实现它以及每种方法的后果:</p><ol class=""><li id="4419" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr mx lu lv lw bi translated"><strong class="iw hy">创建一个</strong> <code class="du lk ll lm ln b"><strong class="iw hy">CustomBulletSpan</strong></code> <strong class="iw hy">，它扩展了</strong> <code class="du lk ll lm ln b"><strong class="iw hy">BulletSpan</strong></code>，但也允许设置子弹大小的参数。当跨度从一个活动传递到另一个活动或通过复制文本时，附加到文本的跨度将是<code class="du lk ll lm ln b"><strong class="iw hy">BulletSpan</strong></code>。这意味着当文本被绘制时，它将具有框架的默认项目符号半径，而不是在<code class="du lk ll lm ln b">CustomBulletSpan</code>中设置的半径。</li><li id="0d2c" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr mx lu lv lw bi translated"><strong class="iw hy">创建一个</strong> <code class="du lk ll lm ln b"><strong class="iw hy">CustomBulletSpan</strong></code> <strong class="iw hy">，它只是从</strong> <code class="du lk ll lm ln b"><strong class="iw hy">LeadingMarginSpan</strong></code>扩展而来，并重新实现了项目符号功能。当跨度从一个<code class="du lk ll lm ln b">Activity</code>传递到另一个<code class="du lk ll lm ln b">Activity</code>或通过复制文本时，附加到文本的跨度将是<code class="du lk ll lm ln b">LeadingMarginSpan</code>。这意味着当文本被绘制时，它将失去所有的样式。</li></ol><p id="7f6b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果仅仅使用框架跨度就可以实现想要的样式，那么最好应用多个框架跨度来实现您自己的框架跨度。否则，最好实现扩展一些基本接口或抽象类的自定义范围。这样，当对象在进程内或进程间传递时，可以避免框架的实现被应用到spannable。</p></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="4726" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过了解Android如何使用spans渲染文本，希望你可以在你的应用程序中有效地使用它。下一次您需要样式化文本时，决定您是否应该应用多个框架范围或者创建您自己的自定义范围，这取决于您对该文本所做的进一步工作。</p><p id="590e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android中处理文本是如此常见的任务，以至于调用正确的<code class="du lk ll lm ln b">TextView.setText</code>方法可以帮助你减少应用程序的内存使用并提高其性能。</p><blockquote class="mr ms mt"><p id="cb2b" class="iu iv mq iw b ix iy iz ja jb jc jd je mu jg jh ji mv jk jl jm mw jo jp jq jr ha bi translated"><em class="hx">多多感谢</em> <a class="ae hu" href="https://twitter.com/siyamed" rel="noopener ugc nofollow" target="_blank"> <em class="hx">斯亚梅德</em> </a> <em class="hx">，克拉拉【巴亚里】<a class="nf ng ge" href="https://medium.com/u/22c02a30ae04?source=post_page-----1b91008b97e4--------------------------------" rel="noopener" target="_blank"> <em class="hx">尼克</em> </a> <em class="hx">。</em></em></p></blockquote></div></div>    
</body>
</html>