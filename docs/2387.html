<html>
<head>
<title>Pass Interface Parameters by Reference in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中通过引用传递接口参数</h1>
<blockquote>原文：<a href="https://medium.easyread.co/today-i-learned-pass-by-reference-on-interface-parameter-in-golang-35ee8d8a848e?source=collection_archive---------1-----------------------#2019-04-01">https://medium.easyread.co/today-i-learned-pass-by-reference-on-interface-parameter-in-golang-35ee8d8a848e?source=collection_archive---------1-----------------------#2019-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c8f9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一篇简单的日记，关于我在Golang通过引用了解到的一件简单的事情</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dac8a4a497be6bd4dc555be3364aa724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6yBB5K1_k_aetILAqT8iw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">pass by reference on interface parameter in Golang</figcaption></figure><p id="2def" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">回到大学时代，我记得向函数传递参数有两种方法。一个通过值传递，另一个通过引用传递。这两种方式有不同的概念，有时会给程序员带来困惑。</p><p id="5cf0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">简单地说，按值传递是指我们传递参数时没有指向值的源地址的指针。而按引用传递是指我们用一个指向给定参数的指针来传递参数。</p><p id="af6f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在Golang，我们可以在下面的例子中看到这两个。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="b76f" class="lt lu in lp b gy lv lw l lx ly">func passByValue(item <strong class="lp io">string</strong>){}<br/>func passByReference(item <strong class="lp io">*string</strong>){}</span></pre><h2 id="c340" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">Golang中的按引用传递和按值传递</h2><p id="6667" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">实际上，我们在互联网上已经可以找到很多关于如何在Golang中通过引用和通过值传递的例子。</p><p id="8a07" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以在这里，我就举个简单的例子。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="1728" class="lt lu in lp b gy lv lw l lx ly">package main</span><span id="91af" class="lt lu in lp b gy mv lw l lx ly">import (<br/> "fmt"<br/>)</span><span id="0c34" class="lt lu in lp b gy mv lw l lx ly">func main() {<br/> item := ""<br/> passByValue(item)<br/> fmt.Println(item)<br/> passByReference(&amp;item)<br/> fmt.Println(item)<br/>}</span><span id="84fd" class="lt lu in lp b gy mv lw l lx ly">func passByValue(item string) {<br/> item = "hello"<br/>}</span><span id="b24e" class="lt lu in lp b gy mv lw l lx ly">func passByReference(item *string) {<br/> *item = "world"<br/>}</span></pre><p id="f711" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的例子展示了一种基于类型传递参数的典型方式(通过引用或通过值)。</p><h2 id="a7df" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">在Golang中通过引用传递接口参数</h2><p id="d35e" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">但是，有一天。我遇到了一个需要解决的关于通过引用传递参数的问题。不像我以前做的任何一个普通的，这个使用了参数的接口。所以基本上，这个函数接受<code class="fe mw mx my lp b">interface{}</code>中的任何内容，并根据函数内部发生的逻辑填充值。</p><p id="c714" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该函数如下所示。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="f075" class="lt lu in lp b gy lv lw l lx ly">func doSomethinWithThisParam(item interface{}){}</span></pre><p id="2371" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个函数很简单，它只接受一个接口，并在里面做一些事情。它不会返回任何错误，所以它只是用一个值来水合这个项目。</p><p id="1645" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以为了解决这个奇怪的行为，我试着自己去解决。下面我将解释我解决这个问题的步骤。</p><h2 id="b3a8" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">第一次尝试:指向接口的指针[不起作用]</h2><p id="61a3" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">起初，我试着去喜欢非接口的。我在界面上放了一个指针。但是不管用。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="f02d" class="lt lu in lp b gy lv lw l lx ly">package main</span><span id="e83f" class="lt lu in lp b gy mv lw l lx ly">import (<br/> "fmt"<br/>)</span><span id="3b5b" class="lt lu in lp b gy mv lw l lx ly">func main() {<br/> var item Student<br/> doSomethinWithThisParam(&amp;item)<br/> fmt.Printf("%+v", item)<br/>}</span><span id="290c" class="lt lu in lp b gy mv lw l lx ly">type Student struct {<br/> ID   string<br/> Name string<br/>}</span><span id="1658" class="lt lu in lp b gy mv lw l lx ly">func doSomethinWithThisParam(item *interface{}) {<br/> *item = &amp;Student{<br/>  ID:   "124",<br/>  Name: "Iman Tumorang",<br/> }<br/>}</span></pre><p id="e4a5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个不能编译，它抛出错误。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="e06e" class="lt lu in lp b gy lv lw l lx ly">cannot use &amp;item (type *Student) as type *interface {} in argument to doSomethinWithThisParam:<br/>	*interface {} is pointer to interface, not interface</span></pre><h2 id="c599" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">第二次尝试:直接给接口赋值[不工作]</h2><p id="806e" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">第二个，我尝试不使用指向接口的指针，而是将值直接赋给给定的参数。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="a340" class="lt lu in lp b gy lv lw l lx ly">func doSomethinWithThisParam(item interface{}) {<br/> item = &amp;Student{<br/>  ID:   "124",<br/>  Name: "Iman Tumorang",<br/> }<br/>}</span><span id="f3ec" class="lt lu in lp b gy mv lw l lx ly">// Print: {ID: Name:}</span></pre><p id="5e1a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">打印数据后，它仍然没有工作。它打印空值。</p><h2 id="0bd2" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">第三次尝试:转换为原始类型并赋值。]</h2><p id="2c1d" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">后来尝试了很多东西，找到了一个管用的。参数仍然是一个接口{}，但是我没有直接赋值，而是先把它转换回原来的类型。这个时候，就有点棘手了。我们必须小心使用它。请看下面的不同之处。</p><p id="3cc0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">未奏效一<br/>T3】下面这个例子是未奏效的。</strong></p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="b97a" class="lt lu in lp b gy lv lw l lx ly">func doSomethinWithThisParam(item interface{}) {<br/> origin := item.(*Student)<br/> origin = &amp;Student{<br/>  ID:   "124",<br/>  Name: "Iman Tumorang",<br/> }<br/> item = origin<br/>}</span><span id="0251" class="lt lu in lp b gy mv lw l lx ly">// Print: {ID: Name:}</span></pre><p id="4ce6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">工作过一次<br/> </strong>但这次是工作过了。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="1621" class="lt lu in lp b gy lv lw l lx ly">func doSomethinWithThisParam(item interface{}) {<br/> origin := item.(*Student)<br/> origin.Name = "Iman Tumorang"<br/> origin.ID = "124"<br/>}</span><span id="1d19" class="lt lu in lp b gy mv lw l lx ly">// Print: {ID:124 Name:Iman Tumorang}</span></pre><p id="6029" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">真的吗？？？？？😱<br/>一开始，我有点困惑。这里到底发生了什么？当我像这样做的时候，它怎么可能不工作。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="b3f6" class="lt lu in lp b gy lv lw l lx ly">origin := item.(*Student)<br/> origin = &amp;Student{<br/>  ID:   "124",<br/>  Name: "Iman Tumorang",<br/> }</span></pre><p id="7360" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但这次成功了。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="2182" class="lt lu in lp b gy lv lw l lx ly">origin := item.(*Student)<br/>origin.Name = "Iman Tumorang"</span></pre><p id="3e0e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">需要几分钟来解决这个问题。但后来我明白了为什么会这样。</p><p id="536c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">另一个工作过的人<br/> </strong>想通这个问题后，我意识到了一些事情。第一个失败，因为它替换了地址。因此，我尝试了一种只改变值的新方法，而不是替换地址。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="f34c" class="lt lu in lp b gy lv lw l lx ly">func doSomethinWithThisParam(item interface{}) {<br/> origin := item.(*Student)<br/> <strong class="lp io">*origin</strong> = Student{<br/>  ID:   "124",<br/>  Name: "Iman Tumorang",<br/> }<br/> item = origin<br/>}</span><span id="9eae" class="lt lu in lp b gy mv lw l lx ly">// Print: {ID:124 Name:Iman Tumorang}</span></pre><p id="6f2c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个很好用。这使我意识到，当我们想改变指针变量中的值时，我们需要直接设置该值，而不是改变地址本身。</p><p id="78d4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">最终解析器<br/>T5】所以在经过多次试验后，最终我选择了最后一个。因为基于我当前的任务，我正在处理的这个函数有点通用，所以我对它进行了转换，并添加了开关情况条件，这样它将基于我创建的开关情况更加通用。</strong></p><p id="7f9e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">简单地说，我当前任务的所有工作都可以在下面的例子中描述。有一个通用函数将接受接口{}，并在其中做一些事情。它支持许多结构。</p><p id="05df" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">代码片段如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="d78d" class="lt lu in bd lz ma mb dn mc md me dp mf lb mg mh mi lf mj mk ml lj mm mn mo mp bi translated">结论</h2><p id="cb99" class="pw-post-body-paragraph ks kt in ku b kv mq jo kx ky mr jr la lb ms ld le lf mt lh li lj mu ll lm ln ig bi translated">这在戈兰真的是一件非常严肃的事情。我们在使用按引用传递和接口{}时必须非常小心。为了避免任何不必要的错误，我建议为每个使用引用传递方法的函数添加一个单元测试。</p><p id="21b9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nb">说实话，我在这个问题上卡住了一个小时。因此，如果你认为这是一件值得知道的好事，请分享这篇文章，这样任何人都不会陷入同样的问题。</em></p></div></div>    
</body>
</html>