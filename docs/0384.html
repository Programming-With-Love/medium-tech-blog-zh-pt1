<html>
<head>
<title>WorkManager basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作管理器基础</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/workmanager-basics-beba51e94048?source=collection_archive---------0-----------------------#2019-01-22">https://medium.com/androiddevelopers/workmanager-basics-beba51e94048?source=collection_archive---------0-----------------------#2019-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/625031c7fa42635a149fd5355f7f5682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_fXBLlwf_uEp7nDj"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="fe47" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">欢迎来到我们的工作管理器系列的第二篇文章。WorkManager是一个<a class="ae hu" href="https://developer.android.com/jetpack/" rel="noopener ugc nofollow" target="_blank"> Android Jetpack </a>库，当工作的约束得到满足时，它运行可推迟的、有保证的后台工作。对于许多类型的后台工作，WorkManager是当前的最佳实践。<a class="ae hu" rel="noopener" href="/androiddevelopers/introducing-workmanager-2083bcfc4712">在第一篇博文</a>中，我们讨论了什么是工作管理器以及何时使用工作管理器。</p><p id="fdc6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博文中，我将介绍:</p><ul class=""><li id="b444" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">将后台任务定义为工作</li><li id="4414" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">定义具体工作应该如何运行</li><li id="9a8a" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">运行您的工作</li><li id="1696" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用链条进行从属工作</li><li id="5699" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">观察你的工作状态</li></ul><p id="f968" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我还将解释WorkManager的幕后<strong class="iw hy">发生了什么，以便您可以就如何使用它做出明智的决定。</strong></p><h1 id="85c2" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">从一个例子开始</h1><p id="c072" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">假设你有一个图像编辑应用程序，可以让你给图像加滤镜，然后上传到网上让全世界看到。您希望创建一系列应用滤镜、压缩图像，然后上传它们的后台任务。在每个阶段，都有一个需要检查的约束条件——过滤图像时有足够的电池，压缩图像时有足够的存储空间，上传图像时有网络连接。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/5116067e76de2ba1599d0f4d26405ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GuigyLoSuBZ86hH1"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The example, visualized</figcaption></figure><p id="77a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个任务示例:</p><ul class=""><li id="12d6" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy"> Deferrable </strong>，因为你不需要它立即发生，事实上可能想要等待一些约束条件被满足(比如等待网络连接)。</li><li id="065f" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">需要<strong class="iw hy">保证</strong>运行，不管应用程序是否存在，因为如果你的用户过滤后的图片不与外界分享，他们会非常不高兴！</li></ul><p id="06f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些特征使我们的图像过滤和上传任务成为WorkManager的完美用例。</p><h1 id="4724" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">添加工作管理器依赖项</h1><p id="d768" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">这篇博文中的代码片段是在Kotlin中，使用了KTX库(KoTlin扩展)。库的KTX版本提供了<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/package-summary#extension-functions-summary" rel="noopener ugc nofollow" target="_blank">扩展函数</a>以获得更简洁和习惯的Kotlin。您可以使用KTX版本的WorkManager，使用此依赖关系:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="e5af" class="lt kh hx lp b fi lu lv l lw lx">dependencies {<br/> def work_version = "1.0.0-beta02"<br/> implementation "android.arch.work:work-runtime-ktx:$work_version"<br/>}</span></pre><p id="f976" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在这里找到库<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/adding-components#workmanager" rel="noopener ugc nofollow" target="_blank">的最新版本</a>。如果想使用Java依赖，只需去掉“-ktx”。</p><h1 id="34d6" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">定义你的工作是什么</h1><p id="4139" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在我们开始将多个任务链接在一起之前，让我们先关注如何执行一项工作。我将放大上传任务。首先，您需要创建自己的<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Worker" rel="noopener ugc nofollow" target="_blank">Worker</a></code>类的实现。我将调用我们的类<code class="du ly lz ma lp b">UploadWorker</code>，并覆盖<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Worker.html#doWork()" rel="noopener ugc nofollow" target="_blank">doWork(</a>)</code>方法。</p><p id="1e13" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ly lz ma lp b">Worker</code>年代:</p><ul class=""><li id="1bc5" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">定义你的工作实际上<strong class="iw hy">做什么</strong>。</li><li id="c273" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">接受输入并产生输出。输入和输出都表示为键值对。</li><li id="a799" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">总是返回代表成功、失败或重试的值。</li></ul><p id="5c4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面的例子展示了如何实现一个上传图像的<code class="du ly lz ma lp b">Worker</code>:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="c946" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需要注意两件事:</p><ul class=""><li id="6c26" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">输入和输出作为<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Data" rel="noopener ugc nofollow" target="_blank">Data</a></code>传递，本质上是原语类型和数组的映射。对象应该非常小——实际上输入/输出的总大小是有限制的。这由<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Data.html#MAX_DATA_BYTES" rel="noopener ugc nofollow" target="_blank">MAX_DATA_BYTES</a></code>设定。如果你需要传递更多的数据进出你的<code class="du ly lz ma lp b">Worker</code>，你应该把你的数据放在其他地方，比如一个<a class="ae hu" href="https://developer.android.com/training/data-storage/room/" rel="noopener ugc nofollow" target="_blank">房间数据库</a>。举个例子，我传入的是上面图片的URI，而不是图片本身。</li><li id="a419" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">在代码中，我展示了两个返回示例，<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#success()" rel="noopener ugc nofollow" target="_blank">Result.success()</a></code>和<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#failure()" rel="noopener ugc nofollow" target="_blank">Result.failure()</a></code>。还有一个<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#retry()" rel="noopener ugc nofollow" target="_blank">Result.retry()</a></code>选项，它将在稍后重试您的工作。</li></ul><h1 id="f70f" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">定义你的工作应该如何运行</h1><p id="9125" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">a <code class="du ly lz ma lp b">Worker</code>定义工作<strong class="iw hy">做什么</strong>，而a <code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkRequest" rel="noopener ugc nofollow" target="_blank">WorkRequest</a></code>定义<strong class="iw hy">工作应该如何以及何时运行</strong>。</p><p id="c408" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有一个为你的<code class="du ly lz ma lp b">UploadWorker</code>创建一个<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" rel="noopener ugc nofollow" target="_blank">OneTimeWorkRequest</a></code>的例子。也有可能有重复的<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" rel="noopener ugc nofollow" target="_blank">PeriodicWorkRequest</a></code>:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="ca2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个<code class="du ly lz ma lp b">WorkRequest</code>接受<code class="du ly lz ma lp b">imageData: Data</code>对象作为输入并尽快运行。</p><p id="d904" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设<code class="du ly lz ma lp b">UploadWork</code>不应该总是立即运行——它应该只在设备有网络连接的情况下运行。您可以通过添加一个<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/Constraints.Builder" rel="noopener ugc nofollow" target="_blank">Constraints</a></code>对象来做到这一点。您可以像这样创建一个约束:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="c168" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是其他受支持约束的示例:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="b81a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，还记得<code class="du ly lz ma lp b">Result.retry()</code>吗？我前面说过，如果一个<code class="du ly lz ma lp b">Worker</code>返回<code class="du ly lz ma lp b">Result.retry()</code>，WorkManager将重新安排工作。当您创建新的<code class="du ly lz ma lp b">WorkRequest</code>时，您可以自定义补偿标准。这允许您定义何时应该重试工作。</p><p id="e222" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/WorkRequest.Builder#setbackoffcriteria" rel="noopener ugc nofollow" target="_blank">回退标准</a>由两个属性定义:</p><ul class=""><li id="cc2a" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/BackoffPolicy" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">退避策略</strong> </a>，默认为指数型，但可以设置为线性。</li><li id="fb6c" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">持续时间</strong>，默认为30秒。</li></ul><p id="730b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用约束、输入和自定义回退策略将上传工作排队的组合代码为:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h1 id="be9c" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">运行工作</h1><p id="8937" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">这很好，但是你还没有真正安排好你的工作。下面是您需要告诉WorkManager安排您的工作的一行代码:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="6b0c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您首先需要获得<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager" rel="noopener ugc nofollow" target="_blank">WorkManager</a></code>的实例，它是负责执行您的工作的单例。调用<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager#enqueue(androidx.work.WorkRequest)" rel="noopener ugc nofollow" target="_blank">enqueue</a></code>开始了<code class="du ly lz ma lp b">WorkManager</code>跟踪和调度工作的整个过程。</p><h1 id="c9b9" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">幕后——工作如何运行</h1><p id="efe1" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">那么你能指望<code class="du ly lz ma lp b">WorkManager</code>为你做什么呢？默认情况下，<code class="du ly lz ma lp b">WorkManager</code>会:</p><ul class=""><li id="55c5" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">从主线程中运行你的工作<strong class="iw hy">(这假设你正在扩展<code class="du ly lz ma lp b">Worker</code>类，如上面的<code class="du ly lz ma lp b">UploadWorker</code>所示)。</strong></li><li id="d378" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">保证</strong>你的工作会执行(它不会忘记运行你的工作，即使你重启设备或者app退出)。</li><li id="f823" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">根据用户API级别的<strong class="iw hy">最佳实践运行(如<a class="ae hu" rel="noopener" href="/androiddevelopers/introducing-workmanager-2083bcfc4712">上一篇文章</a>中所述)。</strong></li></ul><p id="370f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们探索一下WorkManager如何确保您的工作脱离主线程运行并保证执行。在幕后，工作管理器包括以下部分:</p><ul class=""><li id="b393" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy">内部TaskExecutor </strong> : <strong class="iw hy"> </strong>单线程<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/java/util/concurrent/Executor" rel="noopener ugc nofollow" target="_blank">Executor</a></code>处理所有入队工作的请求。如果你不熟悉<code class="du ly lz ma lp b">Executors</code>，你可以在这里阅读更多关于它们的信息<a class="ae hu" href="https://developer.android.com/reference/java/util/concurrent/Executor" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="d8a0" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">工作管理器数据库</strong>:一个本地数据库，跟踪你所有工作的所有信息和状态。这包括工作的当前状态、工作的输入和输出以及工作的任何约束。该数据库使WorkManager能够保证您的工作能够完成，如果您用户的设备重新启动并且工作中断，可以从数据库中提取工作的所有详细信息，并且可以在设备再次启动时重新开始工作。</li><li id="77e0" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">worker factory * *</strong>:<strong class="iw hy"/>一个创建你的<code class="du ly lz ma lp b">Worker</code>实例的默认工厂。我们将在以后的博客文章中解释为什么以及如何配置它。</li><li id="b667" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">默认执行人** </strong> : <strong class="iw hy"> </strong>运行您的工作的默认执行人，除非您另外指定。这确保了默认情况下，您的工作在主线程之外同步运行。</li></ul><p id="a6bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">**这些部件可以被覆盖以具有不同的行为。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/bded2c9b2925372e3935b17adda4c985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wbw_Hi1u5SJ1QtJYemV4g.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Credit: <a class="ae hu" href="https://youtu.be/83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">Working with WorkManager</a> Presentation Android Developer Summit 2018</figcaption></figure><p id="2f44" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您将<code class="du ly lz ma lp b">WorkRequest</code>加入队列时:</p><ol class=""><li id="c94e" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr mf jy jz ka bi translated">内部TaskExecutor立即将您的<code class="du ly lz ma lp b">WorkRequest</code>信息保存到WorkManager数据库中。</li><li id="c479" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mf jy jz ka bi translated">稍后，当<code class="du ly lz ma lp b">WorkRequest</code>的<code class="du ly lz ma lp b">Constraints</code>被满足时(可能是立即)，内部TaskExecutor告诉<code class="du ly lz ma lp b">WorkerFactory</code>创建一个<code class="du ly lz ma lp b">Worker</code>。</li><li id="93c7" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mf jy jz ka bi translated">然后默认的<code class="du ly lz ma lp b">Executor</code>从主线程中调用你的<code class="du ly lz ma lp b">Worker</code>的<code class="du ly lz ma lp b">doWork()</code>方法<strong class="iw hy">。</strong></li></ol><p id="81a5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这样，默认情况下，您的工作既保证了执行，又保证了脱离主线程运行。</p><p id="3cce" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，如果您想使用默认的<code class="du ly lz ma lp b">Executor</code>之外的其他机制来运行您的工作，您可以这样做！对于协同程序(<code class="du ly lz ma lp b">CoroutineWorker</code>)和RxJava ( <code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/RxWorker" rel="noopener ugc nofollow" target="_blank">RxWorker</a></code>)作为工作方式，有现成的支持。</p><p id="69bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者您可以通过使用<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker" rel="noopener ugc nofollow" target="_blank">ListenableWorker</a></code>来指定工作是如何执行的。<code class="du ly lz ma lp b">Worker</code>实际上是<code class="du ly lz ma lp b">ListenableWorker</code>的一个实现，默认在默认的<code class="du ly lz ma lp b">Executor</code>上运行你的工作，因此是同步的。所以如果你想完全控制你的工作的线程策略或者异步运行工作，你可以子类化<code class="du ly lz ma lp b">ListenableWorker</code>(细节将在后面的文章中讨论)。</p><p id="d477" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">WorkManager不厌其烦地将所有工作信息保存到数据库中，这一事实使得它非常适合需要保证执行的任务。这也使得WorkManager对于不需要这种保证，只需要在后台线程上执行的任务来说是大材小用。例如，假设你已经下载了一张图片，你想根据这张图片改变你的用户界面的颜色。这是应该在主线程之外运行的工作，但是，因为它与UI直接相关，如果您关闭应用程序，就不需要继续。所以在这种情况下，不要使用工作管理器——坚持使用更轻量级的东西，比如<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0" rel="noopener ugc nofollow" target="_blank"> Kotlin协程</a>或者创建自己的<code class="du ly lz ma lp b">Executor</code>。</p><h1 id="ec24" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用链条进行从属工作</h1><p id="1113" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我们的过滤器示例包含不止一个任务——我们想要过滤多个图像，然后压缩，然后上传。如果您想依次或并行运行一系列的<code class="du ly lz ma lp b">WorkRequest</code>，您可以使用<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced#chained" rel="noopener ugc nofollow" target="_blank">链</a>。示例图显示了一个链，其中有三个并行运行的筛选器任务，随后是按顺序运行的压缩任务和上传任务:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/d558de2142ad8a929e282453bd30499b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4VeMy6t8hLS1OyrM"/></div></div></figure><p id="7c9a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有了WorkManager，这变得非常简单。假设您已经用适当的约束创建了所有的工作请求，代码如下所示:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="d198" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">三个过滤图像<code class="du ly lz ma lp b">WorkRequest</code>并行执行。一旦所有三个过滤器<code class="du ly lz ma lp b">WorkRequests</code>都完成(且仅当所有三个都完成时)，<code class="du ly lz ma lp b">compressWorkRequest</code>发生，随后是<code class="du ly lz ma lp b">uploadWorkRequest</code>。</p><p id="257b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">链的另一个简洁特征是一个<code class="du ly lz ma lp b">WorkRequest</code>的输出作为下一个<code class="du ly lz ma lp b">WorkRequest</code>的输入。因此，假设您正确设置了输入和输出数据，就像我在上面的<code class="du ly lz ma lp b">UploadWorker</code>示例中所做的那样，这些值将会自动传递。</p><p id="f7cb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了处理并行运行的三个过滤器工作请求的输出，您可以使用一个<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/InputMerger" rel="noopener ugc nofollow" target="_blank">InputMerger</a></code>，特别是<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ArrayCreatingInputMerger" rel="noopener ugc nofollow" target="_blank">ArrayCreatingInputMerger</a></code>。这看起来像:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="29f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，<code class="du ly lz ma lp b">InputMerger</code>被添加到<code class="du ly lz ma lp b">compressWorkRequest</code>中，而不是并行运行的三个过滤器请求。</p><p id="0904" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们假设每个过滤器工作请求的输出是映射到图像URI的关键字“KEY_IMAGE_URI”。添加<code class="du ly lz ma lp b">ArrayCreatingInputMerger</code>的作用是从并行运行的请求中获取输出，当这些输出具有匹配的<strong class="iw hy">键</strong>时，它会创建一个包含所有输出值的数组，映射到单个键。看起来像这样:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/a8cae035722f944dd87a4a54aa582ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ft-4gVTZVjVtz6xIaEtNOg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">A visual of what an <code class="du ly lz ma lp b">ArrayCreatingInputMerger</code> does</figcaption></figure><p id="d582" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，<code class="du ly lz ma lp b">compressWorkRequest</code>的输入将最终成为映射到过滤图像URIs数组的“KEY_IMAGE_URI”对。</p><h1 id="0804" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">观察您的工作请求状态</h1><p id="bea6" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">观察工作最简单的方法是使用<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>类。如果你不熟悉<code class="du ly lz ma lp b">LiveData</code>，它是一个生命周期感知的可观察数据容器，在这里有更详细的描述。</p><p id="ca0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调用<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager.html#getWorkInfoById(java.util.UUID)" rel="noopener ugc nofollow" target="_blank">getWorkInfoByIdLiveData</a></code>返回一个<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkInfo" rel="noopener ugc nofollow" target="_blank">WorkInfo</a></code>的<code class="du ly lz ma lp b">LiveData</code>。<code class="du ly lz ma lp b">WorkInfo</code>包括输出数据和代表工作状态的枚举。当工作成功完成时，其'<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/State" rel="noopener ugc nofollow" target="_blank">State</a></code>为<code class="du ly lz ma lp b">SUCCEEDED</code>。例如，当工作完成时，您可以通过编写如下观察代码来自动显示该图像:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="6999" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需要注意一些事情:</p><ul class=""><li id="21fc" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">每个<code class="du ly lz ma lp b">WorkRequest</code>都有一个<a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkRequest.html#getId()" rel="noopener ugc nofollow" target="_blank">唯一id </a>，该唯一id是查找相关<code class="du ly lz ma lp b">WorkInfo</code>的一种方式。</li><li id="da71" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">当<code class="du ly lz ma lp b">WorkInfo</code>改变时，观察和被通知的能力是<code class="du ly lz ma lp b">LiveData</code>提供的一个特征。</li></ul><p id="ec1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">工作有一个生命周期，由不同的<code class="du ly lz ma lp b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/State" rel="noopener ugc nofollow" target="_blank">State</a></code>表示。当观察<code class="du ly lz ma lp b">LiveData&lt;WorkInfo&gt;</code>时，你会看到那些状态；例如，您可能会看到:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/50a24d4d4d41279756c88d7bd2620ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygDDGGdiBm8_c2_u3rXWkQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The “happy path” or work States</figcaption></figure><p id="132d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">工作经历的“快乐路径”状态有:</p><ol class=""><li id="5d46" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr mf jy jz ka bi translated"><code class="du ly lz ma lp b">BLOCKED</code>:只有当工作在一个链中，并且不是链中的下一个工作时，才会出现这种状态。</li><li id="3eb6" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mf jy jz ka bi translated"><code class="du ly lz ma lp b">ENQUEUED</code>:只要工作链中的下一个工作符合运行条件，工作就进入此状态。这部作品可能还在等待<code class="du ly lz ma lp b">Constraint</code>号的接应。</li><li id="9d31" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mf jy jz ka bi translated"><code class="du ly lz ma lp b">RUNNING</code>:此状态下，工作正在积极执行。对于<code class="du ly lz ma lp b">Worker</code> s，这意味着已经调用了<code class="du ly lz ma lp b">doWork()</code>方法。</li><li id="e868" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mf jy jz ka bi translated"><code class="du ly lz ma lp b">SUCCEEDED</code>:当<code class="du ly lz ma lp b">doWork()</code>返回<code class="du ly lz ma lp b">Result.success()</code>时，工作进入此终止状态。</li></ol><p id="c086" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在当工作是<code class="du ly lz ma lp b">RUNNING</code>时，你可能会调用<code class="du ly lz ma lp b">Result.retry()</code>。这将导致工作返回到<code class="du ly lz ma lp b">ENQUEUED</code>。工作也可以<code class="du ly lz ma lp b">CANCELLED</code>在任何点。</p><p id="b943" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果工作结果是<code class="du ly lz ma lp b">Result.failure()</code>而不是成功，其状态将在<code class="du ly lz ma lp b">FAILED</code>结束。因此，状态的完整流程图如下所示:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/c061ffd051ed623816aa3f32157d4bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nliDtycHUhVVlKlWO-oQ2Q.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">(Credit: <a class="ae hu" href="https://youtu.be/83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">Working with WorkManager</a> Presentation Android Developer Summit 2018)</figcaption></figure><p id="24bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要获得精彩的视频解释，请查看<a class="ae hu" href="https://youtu.be/83a4rYXsDs0?t=1144" rel="noopener ugc nofollow" target="_blank"> WorkManager Android开发者峰会演讲</a>。</p><h1 id="1e4c" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="32f3" class="pw-post-body-paragraph iu iv hx iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">这是工作管理器API的基础。使用我们刚刚介绍的片段，您现在可以:</p><ul class=""><li id="bbcb" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">创建具有输入和输出的<code class="du ly lz ma lp b">Worker</code>。</li><li id="c19f" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用<code class="du ly lz ma lp b">WorkRequest</code>、<code class="du ly lz ma lp b">Constraint</code>启动输入和回退策略，配置<code class="du ly lz ma lp b">Worker</code>将如何运行。</li><li id="652b" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">入队<code class="du ly lz ma lp b">WorkRequest</code> s</li><li id="7210" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">了解<code class="du ly lz ma lp b">WorkManager</code>在默认情况下，在线程和保证执行方面做了什么。</li><li id="7629" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">创建复杂的相互依赖的工作链，按顺序和并行运行。</li><li id="ec66" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用<code class="du ly lz ma lp b">WorkInfo</code>观察您的<code class="du ly lz ma lp b">WorkRequest</code>状态。</li></ul><p id="9f83" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">想自己试试WorkManager吗？看看codelab，它在<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/index.html?index=..%2F..index#0" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>和<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager/index.html?index=..%2F..index#0" rel="noopener ugc nofollow" target="_blank"> Java </a>中。</p><p id="3a37" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们继续这个系列的时候，请继续关注更多关于WorkManager主题的博客文章。有什么问题或你想让我们回答的吗？请在评论区告诉我们！</p><p id="10a3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="md">感谢</em> <a class="ae hu" rel="noopener" href="/@pmaggi"> <em class="md">皮埃特罗·马吉。</em>T9】</a></p><h1 id="aa5b" class="kg kh hx bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">工作经理的资源</h1><ul class=""><li id="d786" class="js jt hx iw b ix le jb lf jf mj jj mk jn ml jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="37bc" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/package-summary" rel="noopener ugc nofollow" target="_blank">参考指南</a></li><li id="2415" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/docs/release-notes#january_15_2019" rel="noopener ugc nofollow" target="_blank">工作管理器1.0.0-beta02发行说明</a></li><li id="85b3" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">Codelab: <a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/index.html?index=..%2F..index#0" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>和<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager/index.html?index=..%2F..index#0" rel="noopener ugc nofollow" target="_blank"> Java </a>。</li><li id="c56d" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/master/work" rel="noopener ugc nofollow" target="_blank">源代码(AOSP的一部分)</a></li><li id="77f0" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">使用work manager(2018年Android开发峰会)演示文稿</a></li><li id="e17e" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://issuetracker.google.com/issues?q=componentid:409906" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a></li><li id="5d6e" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://stackoverflow.com/questions/tagged/android-workmanager" rel="noopener ugc nofollow" target="_blank">关于StackOverflow的工作管理器问题</a></li><li id="d1ef" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://android-developers.googleblog.com/search/label/Power%20series" rel="noopener ugc nofollow" target="_blank">谷歌的Power博客文章系列</a></li></ul></div></div>    
</body>
</html>