<html>
<head>
<title>Continuous integration for iOS with Nix and Buildkite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS与Nix和Buildkite的持续集成</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/continuous-integration-for-ios-with-nix-and-buildkite-ef5b36c5292d?source=collection_archive---------2-----------------------#2017-08-31">https://medium.com/pinterest-engineering/continuous-integration-for-ios-with-nix-and-buildkite-ef5b36c5292d?source=collection_archive---------2-----------------------#2017-08-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="1ece" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">奥斯汀·劳登| Pinterest工程师，核心体验</p><p id="84fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每月有数千万人使用iOS版Pinterest应用。为了确保我们的用户在Apple设备上获得高质量的体验，我们使用持续集成(CI)来测试即将发布的代码。我们最近在CI基础设施中采用了Nix和Buildkite，以使这个过程更快，对开发人员更友好。通过实施这些工具，我们创建了一个沙盒开发环境，允许工程师在本地进行更改，并期望在CI上得到相同的结果。它还使新工程师的入职变得更加容易，节省了CI容量并提高了开发人员的工作效率。在本帖中，我们将分享我们与Jenkins一起面临的挑战，为什么我们迁移到Nix和Buildkite，以及我们如何更无缝地采用这些服务。</p><h1 id="16c8" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">收集开发人员的反馈</h1><p id="fc77" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们现有的CI设置难以理解和维护。使用<a class="ae kf" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>，我们用Groovy和bash编写的代码遍布整个iOS仓库。我们还在Jenkins配置中存储了大量代码，这些代码不受版本控制。</p><p id="9f00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过此设置，我们确定了开发人员对当前配置项的关注，包括:</p><ul class=""><li id="36f1" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">我的构建在本地通过，但在CI上失败</li><li id="7a6f" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“很难在我的机器上重现CI上运行的内容。”</li><li id="6b6d" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“很难增加新的管道或新的建造机器。”</li><li id="f085" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“构建速度不够快。”</li><li id="0ac3" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“很难说出我的构建失败的原因。”</li></ul><p id="faeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">前两个问题的根源是我们的构建不够<em class="ku">可复制</em>。缺乏可再现性可能是开发人员生产力的主要障碍。寻找bug变成了对两种环境之间差异的徒劳追求——有一个可怕的失败例子，“它在我的机器上工作得很好！”。</p><p id="ddda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二类问题与Jenkins和我们如何使用它有关。虽然Jenkins以可靠的开源CI系统而闻名，但我们面临的问题激励我们寻找替代方案。</p><h1 id="9de2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">不可再生的环境</h1><p id="6554" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在解决再现性问题时，我们意识到问题的范围不仅限于我们的CI系统。我们希望让我们的工程师能够在相同的环境中运行CI上运行的<em class="ku"> exact命令</em>，因此我们检查了开发人员设置他们自己的本地环境的方式。</p><p id="07f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在任何公司，新工程师都需要安装所有必要的依赖项，然后才能开始工作。对于iOS工程师来说，这意味着运行一个名为<em class="ku"> setup_environment.sh </em>的脚本。这是一个必要的、包罗万象的脚本，它安装了构建应用程序所需的最少的<em class="ku"> </em>。</p><p id="6f3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">setup_environment.sh 只在开发人员的机器上运行，不在CI上运行。这些机器有自己的一套脚本和依赖项。随着时间的推移，工程师和竞争情报之间的关系越来越疏远。几乎不可能在本地运行在CI上运行的命令。经过一番讨论，我们提出了我们的挑战:<em class="ku">用一个命令，我们能让一个工程师的本地环境与CI完全相同，以至于任意一个开发人员的笔记本电脑都能变成CI机器吗？</em></p><h2 id="d5f0" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">初始尝试</strong></h2><p id="68bb" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们的依赖性问题主要源于Python和Ruby。例如，我们使用Ruby gem <a class="ae kf" href="https://fastlane.tools" rel="noopener ugc nofollow" target="_blank"> fastlane </a>处理代码签名，使用Python包<a class="ae kf" href="https://github.com/boto/boto" rel="noopener ugc nofollow" target="_blank"> boto </a>向亚马逊S3发送工件和构建数据。</p><p id="01ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要确保所有的机器都能够使用几个软件的特定版本。我们的web团队非常依赖Docker来解决这样的问题，但是不支持在Docker容器中运行macOS。</p><p id="14ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于Ruby，我们尝试了<a class="ae kf" href="https://github.com/rbenv/rbenv" rel="noopener ugc nofollow" target="_blank"> rbenv </a>和<a class="ae kf" href="http://bundler.io/" rel="noopener ugc nofollow" target="_blank"> bundler </a>。对于Python，我们尝试了<a class="ae kf" href="https://virtualenv.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>并用<a class="ae kf" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> Homebrew </a>安装了其他杂项依赖项。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/9512f23f64192303b9ba2d4db43999a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*44mZGF-c1cxdNR9V."/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Figure 1. Our iOS build dependency graph</figcaption></figure><p id="67f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终，我们对这种方法不满意，原因如下:</p><ol class=""><li id="0cec" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb lz km kn ko bi translated">几层深度意味着依赖关系树中的任何错误都可能导致问题。例如，如果rbenv选择了错误的Ruby版本，就会影响fastlane。</li><li id="d8db" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb lz km kn ko bi translated">最终，开发人员或CI很难使用它。开发人员不确定需要哪些命令来运行特定的虚拟环境，而CI必须在每个构建中激活rbenv和virtualenv。</li><li id="761b" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb lz km kn ko bi translated">家酿啤酒的设计并没有考虑到可重复性。我们考虑创造一个内部自制水龙头作为解决办法，但最终决定寻找其他地方。</li></ol><h1 id="b3b2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">Nix的驾驶再现性</h1><p id="29d4" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">输入<a class="ae kf" href="https://nixos.org/nix/about.html" rel="noopener ugc nofollow" target="_blank"> Nix </a>。Nix是一个包管理器，在函数式编程社区中很流行。它让我们能够创造出我们一直在寻找的可复制的环境。我们已经用一个简单安装Nix的脚本替换了我们的<em class="ku"> setup_environment.sh </em>脚本。这在新开发人员入职和配置新CI机器时使用。</p><p id="6d76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Nix和其他包管理器的关键区别在于，Nix将包视为不可变的值——包一旦构建，<em class="ku">就永远不会改变</em>。Nix利用<em class="ku">将包作为不可变值</em>的思想衍生出几个特性。</p><p id="900e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我们如何利用这些特性来创建我们的共享环境。</p><h2 id="e01e" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak"> Nix运行/nix目录下的所有包</strong></h2><p id="f047" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">像virtualenv、rbenv、bundler和brew这样的软件给路径带来了很多复杂性。我们过去遇到过许多问题，包括本地或CI上的错误路径。使用Nix，会根据当时需要的依赖项自动设置路径。例如:</p><p id="dee6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku">Nix之前:</em></p><pre class="lk ll lm ln fd ma mb mc md aw me bi"><span id="1c98" class="kv jd hh mb b fi mf mg l mh mi">𝝺 which ruby</span><span id="2812" class="kv jd hh mb b fi mj mg l mh mi">/Users/alouden/.rbenv/shims/ruby</span><span id="6880" class="kv jd hh mb b fi mj mg l mh mi">𝝺 which python</span><span id="40a1" class="kv jd hh mb b fi mj mg l mh mi">/usr/bin/python</span></pre><p id="c707" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku">nix-shell内部:</em></p><pre class="lk ll lm ln fd ma mb mc md aw me bi"><span id="9499" class="kv jd hh mb b fi mf mg l mh mi">[nix-shell:~/ios]$ which ruby</span><span id="9201" class="kv jd hh mb b fi mj mg l mh mi">/nix/store/gxkwkw3g8m3mpb524rssfsg4m7q1jnzk-ruby-2.3.3/bin/ruby</span><span id="e751" class="kv jd hh mb b fi mj mg l mh mi">[nix-shell:~/ios]$ which python</span><span id="c006" class="kv jd hh mb b fi mj mg l mh mi">/nix/store/6hn46zk4fs9v80ablii3zkr3xal42fp6-python-2.7.13/bin/python</span></pre><p id="fdf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包名前的乱码文本是包的构建依赖图的加密散列。这使得我们可以轻松地安装同一个包的多个版本。我们不需要担心覆盖工程师可能已经在本地安装的内容。一旦我们进入nix-shell，它将成为我们的特定版本。</p><h2 id="83c3" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">可以在nix-shell中使用“-run”</strong>运行单个命令</h2><p id="e301" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在进入nix-shell之前，nix确保所有必需的依赖项都已安装并位于您的路径中。这就像说，“运行这个命令，但是使用我指定的所有依赖项。”</p><pre class="lk ll lm ln fd ma mb mc md aw me bi"><span id="31eb" class="kv jd hh mb b fi mf mg l mh mi">𝝺 which fastlane</span><span id="e658" class="kv jd hh mb b fi mj mg l mh mi">fastlane not found</span></pre><p id="b563" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，没有全局安装的fastlane(上图)，但是当我在nix-shell中运行fastlane命令时，它找到了正确的包(下图)。如果Nix已经安装了fastlane，它将使用该版本，否则它将从Nix的共享缓存或预先指定的位置下载预编译的二进制文件。</p><pre class="lk ll lm ln fd ma mb mc md aw me bi"><span id="75d5" class="kv jd hh mb b fi mf mg l mh mi">𝝺 nix-shell . --run “which fastlane”</span><span id="b5c0" class="kv jd hh mb b fi mj mg l mh mi">/nix/store/6d39qpkan48l075iwkvd2vapk7ih5rrv-pinterest/bin/fastlane</span></pre><h2 id="4513" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">通过修改一个表达式，可以在任何地方添加新的依赖关系</strong></h2><p id="205d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">由于我们在nix-shell中运行大多数命令，CI或开发人员机器会自动安装任何新的依赖项。这不断为我们节省时间和CI容量，因为:</p><ul class=""><li id="2bd5" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">我们不再需要在每次添加依赖项时重新配置CI机器。这是一个非常耗时的过程，因为它需要构建一个新的虚拟机，并将更新后的虚拟机手动部署到所有Mac Pros上。</li><li id="e6ef" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">在重新调配资源时，我们不再需要关闭CI机器。</li><li id="1f52" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">工程师永远不需要重新运行“setup_environment”脚本。他们只需在nix-shell中运行命令，它就会<em class="ku">正常工作</em>。</li></ul><h2 id="5f7a" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">我们的Nix设置</strong></h2><p id="578b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">上面显示的多级依赖树已经被我们保存在iOS存储库的根中的这个简短的Nix表达式所取代。</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="bb3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们重温前两点反馈:</p><ul class=""><li id="461d" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><strong class="ig hi"> <em class="ku">我的构建在本地通过，但在配置项上失败。</em> </strong>既然CI环境与开发人员的本地环境完全相同，我们相信失败应该是一致的。</li><li id="ac1f" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">很难在我的机器上重现CI上运行的内容。  <em class="ku"> </em>在CI上运行的每个命令都可以通过nix-shell在本地运行。这意味着工程师能够在提交拉取请求之前对他们的补丁进行全面测试，从而节省时间和CI容量。</li></ul><p id="5a2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值得注意的是，虽然Nix帮助我们创造环境，但环境只是可复制性的一部分。我们也在探索像<a class="ae kf" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank"> Bazel </a>这样的技术，以使构建完全可复制，我们希望在以后的帖子中讨论这一点。</p><h1 id="e331" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">持续集成服务</h1><p id="5eb4" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">由于对我们新的沙盒环境充满信心，我们开始解决CI的其余问题:</p><ul class=""><li id="ebe0" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">“很难增加新的管道或新的建造机器。”</li><li id="a498" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“构建速度不够快。”</li><li id="c8c7" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">“很难说出我的构建失败的原因。”</li></ul><p id="6ef1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑到让我们的Jenkins设置满足这些需求所需的工作量，我们决定评估备选构建系统(包括<a class="ae kf" href="https://jenkins.io/projects/blueocean/" rel="noopener ugc nofollow" target="_blank"> Jenkins蓝海</a>)。经过一些研究，我们开始测试<a class="ae kf" href="https://buildkite.com/" rel="noopener ugc nofollow" target="_blank"> Buildkite </a>。采用一种新的服务是一个困难的决定，所以这里看一下我们的设置和它相对于Jenkins的优势。</p><h2 id="da7e" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">任何机器都可以在几秒钟内成为Buildkite代理</strong></h2><p id="464f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这将安装并启动buildkite代理。</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="756c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就是这样。这台机器可以立即开始加工工作。与Jenkins不同，我们不再需要担心连接主节点和从节点、配置启动代理或安装其他任何东西。</p><p id="b1ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的环境已经沙箱化，任何机器都可以在几秒钟内成为代理。当我们从Jenkins过渡到Buildkite时，我们甚至将一些个人iMacs转变为构建机器来增加容量。</p><h2 id="c14d" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">默认情况下，Buildkite构建是并行的</strong></h2><p id="6cb9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">默认情况下，Buildkite在不同的代理上运行每个步骤。这导致了构建时间的减少，因为它鼓励我们尽可能地并行化。以下是Pinterest iOS应用程序中每一个pull请求运行的管道:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="caf2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Buildkite解析YAML文件并显示如下所示的管道。注意每一步是如何在不同的机器上运行以及如何在nix-shell中运行的。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mm"><img src="../Images/d547f5af3784a803f33e88263937ad20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3xICmXYDy7VnMiHH."/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx"><strong class="bd je">Figure 2. The Buildkite pipeline run on each pull request</strong></figcaption></figure><h2 id="42b9" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">构建步骤可以在不同的代理上运行</strong></h2><p id="39a7" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">与构建我们的Android和web应用的Linux代理相比，我们的本地Mac Pro集群是有限的。这意味着我们只在macOS上运行那些<em class="ku">必须在macOS </em>上运行的部分，比如构建和签署. ipa。其他不太重要的部分可以外包给Linux机器。</p><h2 id="9564" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">很容易判断构建失败的地方</strong></h2><p id="5af3" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">多亏了Buildkite的UI，开发人员很容易找到构建失败的地方。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/7b5541c30c260694af35e6ac2819fa14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vT5FPU9jdZXl3QAV."/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Figure 3. A successful and failing step</figcaption></figure><p id="8609" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">失败的步骤可以扩展。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/fd7d91f69b2d29baff88652b149028c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C2252wVRwTuDiWf-."/></div></div></figure><p id="a865" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们可以定位错误。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/7119b92e8c744d8546febaeb53ac2d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K2J3nJHXf5HISOYs."/></div></div></figure><h1 id="0689" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">潜在的不利因素</h1><p id="6f7e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在正式切换之前，我们研究了构建kite的潜在不利因素，并制定了减轻这些不利因素的策略。</p><h2 id="99c1" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">服务与开源软件</strong></h2><p id="4dbe" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">Buildkite是一家公司，而不是像Jenkins那样的开源项目，所以我们CI系统的未来，在某种程度上是和Buildkite的未来捆绑在一起的。另一方面，Jenkins并不依赖于特定的公司。</p><p id="111a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">经过审查，我们觉得在将来如果需要的话，切换回Jenkins或其他服务不会太难。由于所有构建代码现在都在iOS存储库中的脚本中，我们可以继续在任何服务上使用这些脚本。</p><h2 id="385c" class="kv jd hh bd je kw kx ky ji kz la lb jm ip lc ld jq it le lf ju ix lg lh jy li bi translated"><strong class="ak">安全</strong></h2><p id="9b96" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">Jenkins的一个伟大之处在于它可以完全保持在内部。相反，Buildkite需要远程执行。我们的硬件运行通过开源<a class="ae kf" href="https://github.com/buildkite/agent" rel="noopener ugc nofollow" target="_blank"> Buildkite代理</a>接收的命令。</p><p id="cf5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了降低风险，我们将构建机器与网络的其余部分隔离开来。我们还利用了Buildkite特性，该特性可以防止代理运行控制台命令。这允许对存储库中的脚本进行评估，提供了防止远程执行漏洞的安全网。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/9ccc48ca5fd88312e1be4f130d189840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UXRKt9IfLmeUYSoN."/></div></div></figure><h1 id="18ce" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">评估成功</strong></h1><p id="f0a5" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在过去的几个月里，我们在Buildkite上运行了数千个任务。在这段时间里，Buildkite已经超出了预期。</p><p id="3c7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回顾我们之前关注的问题:</p><ul class=""><li id="d2c2" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><strong class="ig hi"> <em class="ku">很难添加新的管道或新的构建机器</em>。</strong>我们现在能够在几秒钟内添加新机器。添加新管道就像添加YAML文件一样简单。</li><li id="682f" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi"> <em class="ku">构建不够快</em>。</strong>完全并行的构建在构建时间上产生了显著的差异，有时对于某些工作来说，差异高达50%。</li><li id="2760" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">很难说出我的构建失败的原因。Buildkite用户界面使定位构建失败和识别错误的地方变得容易。</li></ul><p id="7614" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们选择接手这个项目是为了帮助开发人员更快地行动，同时确保保持高质量。然而，仍然有许多工作要做。如果你对构建支持Pinterest应用的工具和框架感兴趣，从UI到构建系统，<a class="ae kf" href="https://careers.pinterest.com/" rel="noopener ugc nofollow" target="_blank">来核心体验团队</a>工作吧。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es mn"><img src="../Images/c2e708437034ef3a06c845ca00e483ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/1*VS-SIyipZqIIfQYxAvva3A.png"/></div></figure></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="0b4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku">鸣谢:感谢Brandon Kase、Harry Shamansky、Kevin Grandon、Rahul Malik以及Core Platform团队的其他成员所做的贡献。</em></p></div></div>    
</body>
</html>