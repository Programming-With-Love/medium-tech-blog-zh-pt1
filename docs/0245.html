<html>
<head>
<title>Intercepting everything with CoordinatorLayout Behaviors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CoordinatorLayout行为截取所有内容</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/intercepting-everything-with-coordinatorlayout-behaviors-8c6adc140c26?source=collection_archive---------0-----------------------#2016-02-17">https://medium.com/androiddevelopers/intercepting-everything-with-coordinatorlayout-behaviors-8c6adc140c26?source=collection_archive---------0-----------------------#2016-02-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/da163e6648a110853525623a462a77f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*voovH-sZjps4amAdRiwRuw.png"/></div></figure><p id="3ecc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果不碰到<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jk">【coordinator layout</em></a>——设计库中的许多视图都需要一个<em class="jk"> CoordinatorLayout </em>，你就无法深入探索<a class="ae jj" href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android设计支持库</a>。但是为什么呢？<em class="jk"> CoordinatorLayout </em>本身实际上并没有做太多事情:将它与标准框架视图一起使用，它的行为就像一个常规的<em class="jk">框架布局</em>。那么魔力来自哪里呢？那就是<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> CoordinatorLayout的地方。</em>s进来的行为。<strong class="in hi">通过将<em class="jk">行为</em>附加到<em class="jk"> CoordinatorLayout </em>的直接子节点，您将能够拦截触摸事件、窗口插入、测量、布局和嵌套滚动</strong>。设计库大量使用行为来增强您看到的许多功能。</a></p><h2 id="9571" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">创造一种行为</h2><p id="2dd4" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">创建行为非常简单:扩展<em class="jk">行为</em>。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="dd61" class="jl jm hh kq b fi ku kv l kw kx">public class FancyBehavior&lt;V extends View&gt;<br/>    extends CoordinatorLayout.Behavior&lt;V&gt; {</span><span id="c566" class="jl jm hh kq b fi ky kv l kw kx">  /**<br/>   * Default constructor for instantiating a FancyBehavior in code.<br/>   */<br/>  public FancyBehavior() {<br/>  }</span><span id="6484" class="jl jm hh kq b fi ky kv l kw kx">  /**<br/>   * Default constructor for inflating a FancyBehavior from layout.<br/>   *<br/>   * @param context The {@link Context}.<br/>   * @param attrs The {@link AttributeSet}.<br/>   */<br/>  public FancyBehavior(Context context, AttributeSet attrs) {<br/>    super(context, attrs);<br/>    // Extract any custom attributes out<br/>    // preferably prefixed with behavior_ to denote they<br/>    // belong to a behavior<br/>  }<br/>}</span></pre><p id="057a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请注意附加到该类的泛型类型。这里，我们要说的是你可以将一个<em class="jk"> FancyBehavior </em>附加到任何<em class="jk"> View </em>类上。然而，如果您想只允许将<em class="jk">行为</em>附加到特定种类的<em class="jk">视图</em>上，您可以将它写成:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="38a3" class="jl jm hh kq b fi ku kv l kw kx">public class FancyFrameLayoutBehavior<br/>    extends CoordinatorLayout.Behavior&lt;FancyFrameLayout&gt;</span></pre><p id="ccc9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这将使您不必将方法调用中收到的许多参数从视图转换为正确的子类型——简单方便而已。</p><p id="76d6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有用<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#setTag(android.view.View,%20java.lang.Object)" rel="noopener ugc nofollow" target="_blank"><em class="jk">Behavior . settag()</em></a>/<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#getTag(android.view.View)" rel="noopener ugc nofollow" target="_blank">/<em class="jk">Behavior . gettag()</em></a>保存临时数据的方法，也有用<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onSaveInstanceState(android.support.design.widget.CoordinatorLayout,%20V)" rel="noopener ugc nofollow" target="_blank"><em class="jk">onSaveInstanceState()</em></a>/<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onRestoreInstanceState(android.support.design.widget.CoordinatorLayout,%20V,%20android.os.Parcelable)" rel="noopener ugc nofollow" target="_blank">/<em class="jk">onRestoreInstanceState()</em></a>保存行为相关实例状态的方法。我鼓励你尽可能地构建轻量级的行为，但是这些方法有助于实现有状态的行为。</p><h1 id="d8ef" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">附加行为</h1><p id="f7d1" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">当然，行为本身不会做任何事情——它们需要被附加到一个<em class="jk"> CoordinatorLayout </em>的子视图上才能被真正调用。有三种主要方式可以做到这一点:以编程方式、以XML格式或通过注释自动完成。</p><h2 id="dd7c" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">以编程方式附加行为</h2><p id="5775" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">当您将<em class="jk">行为</em>视为附加到CoordinatorLayout中每个视图的附加内容时，了解到<strong class="in hi">行为实际上存储在每个视图</strong>的<em class="jk"> LayoutParams </em>中并不奇怪(如果您已经阅读了我们的<a class="ae jj" rel="noopener" href="/@ianhlake/layouts-attributes-and-you-9e5a4b4fe32c"> Layouts博文</a>)——这也是为什么行为需要在<em class="jk"> CoordinatorLayout </em>的直接子元素上声明，因为只有这些子元素具有layout的特定行为存储子类</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="9ed5" class="jl jm hh kq b fi ku kv l kw kx">FancyBehavior fancyBehavior = new FancyBehavior();<br/>CoordinatorLayout.LayoutParams params =<br/>    (CoordinatorLayout.LayoutParams) yourView.getLayoutParams();<br/>params.setBehavior(fancyBehavior);</span></pre><p id="fd30" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这种情况下，您会看到我们使用默认的无参数构造函数。但这并不意味着你不能有一个接受你想要的任何参数的构造函数——当用代码做事情时，你能做的没有限制。</p><h2 id="7157" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">在XML中附加行为</h2><p id="c30a" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">当然，每次都用代码做所有的事情会有点乱。与大多数定制的<em class="jk"> LayoutParams </em>一样，有一个相应的<em class="jk"> layout_ </em>属性来做同样的事情。在本例中，那就是<strong class="in hi"> <em class="jk">布局_行为</em> </strong>属性:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="a97a" class="jl jm hh kq b fi ku kv l kw kx">&lt;FrameLayout<br/>  android:layout_height=”wrap_content”<br/>  android:layout_width=”match_parent”<br/>  app:layout_behavior=”.FancyBehavior” /&gt;</span></pre><p id="41f3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里，与代码案例不同的是，<em class="jk">fancy behavior(Context Context，AttributeSet attrs) </em>构造函数总是被调用的那个。另外，您可以声明任何其他想要的自定义属性，并从XML AttributeSet中提取它们——如果您希望开发人员能够通过XML自定义您的行为功能(您确实这样做了),这一点很重要。</p><blockquote class="lq lr ls"><p id="588a" class="il im jk in b io ip iq ir is it iu iv lt ix iy iz lu jb jc jd lv jf jg jh ji ha bi translated"><strong class="in hi">注意</strong>:类似于父类负责解析和理解的属性的layout_ naming约定，<strong class="in hi">使用<em class="hh"> behavior_ </em>前缀</strong>作为行为专用的任何属性。</p></blockquote><h2 id="0af3" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">自动附加行为</h2><p id="f857" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">如果您正在构建一个需要自定义行为的自定义视图(例如设计库中的许多组件)，那么您可能希望默认附加该行为，而不需要每次都在代码或XML中手动指定它。要做到这一点，您的自定义视图只需要一个附加到其类顶部的简单注释:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="fa8d" class="jl jm hh kq b fi ku kv l kw kx">@CoordinatorLayout.DefaultBehavior(FancyFrameLayoutBehavior.class)<br/>public class FancyFrameLayout extends FrameLayout {<br/>}</span></pre><p id="8769" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您会发现您的行为是用默认构造函数调用的，这与以编程方式附加行为非常相似。注意，任何存在的layout_behavior属性都将覆盖一个<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.DefaultBehavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jk">default behavior</em></a>。</p><h1 id="0b44" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">拦截触摸事件</h1><p id="4e0b" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">一旦你把你的行为都设置好了，你就准备好实际去做一些事情了。行为可以做的事情之一是拦截触摸事件。</p><p id="b822" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果没有<em class="jk"> CoordinatorLayout </em>，这通常会涉及到每个<em class="jk">视图组</em>的子类，正如在<a class="ae jj" href="http://developer.android.com/training/gestures/viewgroup.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">管理触摸事件培训</a>中所谈到的。然而，使用<em class="jk"> CoordinatorLayout </em>，<em class="jk"> CoordinatorLayout </em>将把对其<a class="ae jj" href="http://developer.android.com/reference/android/view/ViewGroup.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onInterceptTouchEvent(android.view.MotionEvent)" rel="noopener ugc nofollow" target="_blank"><em class="jk">on interceptouchevent()</em></a>的调用传递到您行为的<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onInterceptTouchEvent(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.MotionEvent)" rel="noopener ugc nofollow" target="_blank"><em class="jk">on interceptouchevent()</em></a>，<strong class="in hi">上，从而允许您的<em class="jk">行为</em>有机会拦截触摸事件</strong>。通过在那里返回<em class="jk">真</em>，你的行为然后通过<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onTouchEvent(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.MotionEvent)" rel="noopener ugc nofollow" target="_blank"><em class="jk">onTouchEvent()</em></a>接收所有未来的触摸事件——所有这些都没有视图知道正在发生什么。例如，<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/SwipeDismissBehavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jk">SwipeDismissBehavior</em></a>在任何视图上都是这样工作的。</p><p id="8568" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">还有另一种更严厉的触摸拦截:阻止所有的交互。只需在<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#blocksInteractionBelow(android.support.design.widget.CoordinatorLayout,%20V)" rel="noopener ugc nofollow" target="_blank"><em class="jk">blocksInteractionBelow()</em></a>中返回<em class="jk">真</em>即可。当然，你可能希望有一些交互被阻止的视觉信号(以免他们认为应用程序完全坏了)——这就是为什么<em class="jk"> blocksInteractionBelow() </em>的默认功能实际上依赖于<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#getScrimOpacity(android.support.design.widget.CoordinatorLayout,%20V)" rel="noopener ugc nofollow" target="_blank"><em class="jk">getscrimopiaty()</em></a>的值——在这里返回一个非零值将在视图上绘制一种覆盖颜色(颜色<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#getScrimColor(android.support.design.widget.CoordinatorLayout,%20V)" rel="noopener ugc nofollow" target="_blank"><em class="jk">【getScrimColor()</em></a>，默认为黑色)并同时禁用触摸交互。方便。</p><h1 id="eabf" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">截取窗口插入</h1><p id="8333" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">假设您阅读了<a class="ae jj" rel="noopener" href="/google-developers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog">我为什么要安装系统Windows？博客</a>。在那里，我们深入讨论了fitsSystemWindows实际上是做什么的，但归结起来就是为您提供避免在系统窗口(如状态栏和导航栏)下绘制所需的窗口插入。行为在这里也得到了自己的机会——如果您的视图<em class="jk">符合SystemWindows="true" </em>，那么任何附加的<em class="jk">行为</em>都将获得对<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onApplyWindowInsets(android.support.design.widget.CoordinatorLayout,%20V,%20android.support.v4.view.WindowInsetsCompat)" rel="noopener ugc nofollow" target="_blank"><em class="jk">on applywindowsets()</em></a>的调用，使其优先于视图本身。</p><blockquote class="lq lr ls"><p id="d0aa" class="il im jk in b io ip iq ir is it iu iv lt ix iy iz lu jb jc jd lv jf jg jh ji ha bi translated"><strong class="in hi">注意</strong>:在大多数情况下，如果你的行为没有消耗整个窗口Insets，它应该通过<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#dispatchApplyWindowInsets(android.view.View,%20android.support.v4.view.WindowInsetsCompat)" rel="noopener ugc nofollow" target="_blank">T3】viewcompt . dispatchapplywindowsets()T5】传递insets，以确保任何子视图都有机会看到窗口insets。</a></p></blockquote><h1 id="4d59" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">截取测量和布局</h1><p id="cba6" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">尺寸和布局是Android如何绘制视图的关键组成部分。因此，行为作为所有事物的拦截者，也通过<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onMeasureChild(android.support.design.widget.CoordinatorLayout,%20V,%20int,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="jk">【onMeasureChild()</em></a>和<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onLayoutChild(android.support.design.widget.CoordinatorLayout,%20V,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="jk">onLayoutChild()</em></a>回调首先获得度量和布局才有意义。</p><p id="48a0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，让我们取任意一个通用视图组，并为其添加一个maxWidth:</p><figure class="kl km kn ko fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="2a87" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">编写适用于所有情况的通用行为是有用的，但是请记住，您通常可以通过假设应用程序内部的行为是如何使用的来简化您的生活。(不是每个<em class="jk">行为</em>都需要完全通用！)</p><h1 id="f075" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">了解视图之间的依赖关系</h1><p id="5bf8" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">所有上述功能只需要一个视图。但是行为的真正力量在于建立视图之间的依赖关系——也就是说，当另一个视图改变时，您的<em class="jk">行为</em>可以得到回调，根据外部条件改变其功能。</p><p id="e5ef" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">行为可能以两种不同的方式依赖于视图:当它的视图锚定到另一个视图时(一种隐含的依赖)，或者当您在<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#layoutDependsOn(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View)" rel="noopener ugc nofollow" target="_blank"><em class="jk">layoutDependsOn()</em></a>中显式返回<em class="jk"> true </em>时。</p><p id="a072" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当您的视图利用<em class="jk"> CoordinatorLayout </em>的<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.LayoutParams.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#getAnchorId()" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> layout_anchor </em> </a>属性时，就会发生锚定。这与<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.LayoutParams.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#anchorGravity" rel="noopener ugc nofollow" target="_blank"><em class="jk">layout _ anchor gravity</em></a>属性相结合，允许您有效地将两个视图的位置联系在一起。例如，您可以将<em class="jk">浮动操作按钮</em>锚定到<em class="jk"> AppBarLayout </em>和<em class="jk">浮动操作按钮。如果<em class="jk"> AppBarLayout </em>滚动出屏幕，行为</em>将使用隐式依赖来隐藏FAB。</p><p id="9002" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在任一种情况下，当一个依赖视图被删除时，您的<em class="jk">行为</em>获得对<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onDependentViewRemoved(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View)" rel="noopener ugc nofollow" target="_blank"><em class="jk">ondependtviewremoved()</em></a>的回调，并且每当该依赖视图发生变化时(即，调整自身大小或重新定位自身)，获得对<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onDependentViewChanged(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View)" rel="noopener ugc nofollow" target="_blank"><em class="jk">ondependtviewchanged()</em></a>的回调。</p><p id="da72" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种将视图联系在一起的能力是设计库的大部分更酷的功能——以<em class="jk">浮动操作按钮</em>和<em class="jk">小吃条</em>之间的交互为例。FAB的<em class="jk">行为</em>依赖于<em class="jk"> Snackbar </em>的实例被添加到<em class="jk"> CoordinatorLayout </em>中，然后使用o<em class="jk">nDependentViewChanged()</em>回调将FAB向上平移以避免与<em class="jk"> Snackbar </em>重叠。</p><blockquote class="lq lr ls"><p id="2153" class="il im jk in b io ip iq ir is it iu iv lt ix iy iz lu jb jc jd lv jf jg jh ji ha bi translated"><strong class="in hi">注意</strong>:当您添加一个依赖关系时，无论子视图的顺序如何，<em class="hh">视图</em>总是在依赖视图布局之后进行布局。</p></blockquote><h1 id="0f70" class="kz jm hh bd jn la lb lc jr ld le lf jv lg lh li jy lj lk ll kb lm ln lo ke lp bi translated">嵌套滚动</h1><p id="4b4c" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">啊，嵌套滚动。一篇博文，我将在这里简单介绍一下。有几件事要记住:</p><ol class=""><li id="e078" class="ly lz hh in b io ip is it iw ma ja mb je mc ji md me mf mg bi translated">您不需要声明嵌套滚动视图的依赖关系。<em class="jk"> CoordinatorLayout </em>的每个子节点都有机会接收嵌套的滚动事件</li><li id="ce67" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji md me mf mg bi translated">嵌套滚动不仅可以源自<em class="jk"> CoordinatorLayout </em>的直接子视图，还可以源自<strong class="in hi">任何</strong>子视图(例如<em class="jk"> CoordinatorLayout </em>的子视图的子视图)</li><li id="440a" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji md me mf mg bi translated">我称之为嵌套滚动，但这实际上涵盖了滚动(1:1移动到滚动)和投掷</li></ol><p id="2dc5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，声明您对嵌套滚动事件的兴趣从<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onStartNestedScroll(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View,%20android.view.View,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="jk">onStartNestedScroll()</em></a>开始。您将接收滚动轴(例如水平或垂直——很容易忽略某个方向的滚动),并且<strong class="in hi">必须返回<em class="jk"> true </em>以接收该方向的进一步滚动事件</strong>。</p><p id="61ab" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在将<em class="jk"> true </em>返回到<em class="jk"> onStartNestedScroll() </em>之后，嵌套滚动分两步运行:</p><ul class=""><li id="dd73" class="ly lz hh in b io ip is it iw ma ja mb je mc ji mm me mf mg bi translated"><a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onNestedPreScroll(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View,%20int,%20int,%20int[])" rel="noopener ugc nofollow" target="_blank"/></li><li id="6cb9" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji mm me mf mg bi translated"><a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onNestedScroll(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View,%20int,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="jk"/></a>onNestedScroll()在滚动视图时被调用——你会得到视图滚动了多少以及未消耗(过度滚动)的数量。</li></ul><p id="94bd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于fling操作也有一个等价的方法(尽管预fling回调必须消耗全部或者不消耗fling——没有部分消耗)。</p><p id="b8c1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当嵌套滚动(或投掷)完成时，您将得到对<a class="ae jj" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog#onStopNestedScroll(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View)" rel="noopener ugc nofollow" target="_blank"><em class="jk">onStopNestedScroll()</em></a>的调用。这标志着滚动的结束——在下一次滚动开始之前，期待对<em class="jk"> onStartNestedScroll() </em>的新调用。</p><p id="a7d8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">举个例子，你想在向下滚动的时候隐藏一个FloatingActionButton，在向上滚动的时候显示它——这只涉及到重写<em class="jk"> onStartNestedScroll() </em>和<em class="jk"> onNestedScroll() </em>，如这个<a class="ae jj" href="https://github.com/ianhanniballake/cheesesquare/blob/scroll_aware_fab/app/src/main/java/com/support/android/designlibdemo/FABAwareScrollingViewBehavior.java?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jk">fabawarescrollingviewphabehavior</em></a>所示。</p><h2 id="466b" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">这仅仅是开始</h2><p id="8fc3" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">虽然一个行为的每个部分都很有趣，但是当它们都聚集在一起时——这就是奇迹发生的地方。我强烈建议您查看设计库的源代码以了解更多高级行为——<a class="ae jj" href="https://chrome.google.com/webstore/detail/android-sdk-search/hgcbffeicehlpmgmnhnkjbjoldkfhoin?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">Android SDK搜索Chrome扩展</a>仍然是我探索AOSP代码的最喜欢的资源之一(尽管包含在<em class="jk">&lt;Android-SDK&gt;/extras/Android/m2 repository</em>中的源代码总是最新的)。</p><p id="e92b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有了<em class="jk">行为</em>能做什么的坚实基础，让我知道你如何使用它们来# BuildBetterApps</p><p id="fe58" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">加入关于<a class="ae jj" href="https://plus.google.com/+AndroidDevelopers/posts/WojFEkDdFNe?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Google+帖子</a>的讨论，关注<a class="ae jj" href="https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_coordinatorlayoutbehavior_021716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集</a>了解更多！</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/d2bfcdbe45b58454fb507a15e5be2ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fEWv1fv16mfHBygS2eu5A.png"/></div></div></figure></div></div>    
</body>
</html>