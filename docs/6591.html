<html>
<head>
<title>Using CDN to Prevent Broken Website During Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CDN防止部署期间网站崩溃</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/using-cdn-to-prevent-broken-website-during-deployment-78253642069a?source=collection_archive---------3-----------------------#2019-02-22">https://medium.com/quick-code/using-cdn-to-prevent-broken-website-during-deployment-78253642069a?source=collection_archive---------3-----------------------#2019-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b4de79c101e182041417c7e035e05964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JbZhQuXhlotghS-s"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们最近推出了我们的新网站🍻在这个新网站的发展过程中，我学到了很多东西。其中之一是CDN如何帮助我们在持续集成(CI)的部署阶段防止中断。作为背景，我们刚刚在我们的服务上实现了CI，我有一个在我们的网站上使用CDN的计划，但是直到这个问题发生之前，我一直没有时间去实现它。</p><p id="634a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们正在使用Gitlab CI和AWS弹性集装箱服务(ECS)的组合，用于我们所有的docker集装箱。目前，我们所有的系统环境中运行着大约10项服务。其中一项服务是我们使用Express.js和Nuxt.js构建的新前端网站。这个新的前端网站大量使用javascript并具有服务器端呈现(SSR)功能。最初，我们希望有完全单页应用程序(SPA)，但这种应用程序将使搜索引擎机器人难以抓取我们的网站(除了谷歌机器人)，这就是我们在我们的新网站上有SSR功能的原因。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es js"><img src="../Images/35fe21ce7eba2ad514268b4edc1c03f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*BQwzwtbNeOEHCpKDJK33vg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Architecture Setup</figcaption></figure><p id="c6d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在部署过程中，ECS将根据服务配置中设置的所需数量启动新的容器(或称之为任务)。如果所需的任务编号为2，则ECS将根据新任务定义启动2个新任务。这两个新任务将与之前部署的两个旧任务一起添加到服务中。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jx"><img src="../Images/b09dbf9b441caf4d2a2e90d4c4c75688.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*hYzvM8B_S7saBgVFfD0xHA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Architecture Setup with new task</figcaption></figure><p id="fcc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，如果所有的新任务都已达到运行状态，ECS将在关闭任务之前耗尽与每个旧任务的连接。这个过程通常需要几分钟才能删除所有旧任务。在此转换过程中，如果服务是一个前端网站服务，它提供到用户浏览器的HTTP连接，则此转换将有可能使网站对用户中断。</p><h1 id="4ca4" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么？</h1><p id="a961" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">在我们进入部署流程之前，我们在配置项上有一个“构建”流程。在构建过程中，我们将所有的Vue模板(因为我们使用的是Nuxt.js)构建成javascript包，并将Typescripts文件编译成普通的javascript(我们将Typescript用于Express.js应用程序)。这个过程将生成新的生产就绪的javascript包，它在文件名中包含散列版本控制。例子:<code class="du lb lc ld le b">app.072413282a677463d5a9.js</code>。然后，这些文件被注册到内部清单应用程序，以便以后当用户访问网站时，它可以为用户提供正确的文件版本。所有编译后的文件都保存在本地容器中，问题来了。</p><p id="7497" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们开始一些说明。正如我之前解释的那样，在部署期间，ECS将在删除旧任务之前启动新任务。因此有一个新旧任务同时服务于负载均衡器的时刻。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lf"><img src="../Images/c240e7250e66dc898e6a06477e88e332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3NuKlSgH6jfRdBPxsx1mg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Initial HTML Request by Browser</figcaption></figure><p id="f4ae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，用户A在部署过程中访问站点，负载均衡器将HTTP连接重定向到一个容器(让我们忽略负载均衡器此时用来确定目标容器的算法)。在这种情况下，接收HTTP请求的容器是任务A，它是旧的容器。任务A生成对用户浏览器的HTML响应，该HTML响应包含脚本或样式标签，该脚本或样式标签加载本地存储在任务A的清单文件上的旧版本，即<code class="du lb lc ld le b">app.old.js</code>。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/8fe846f1160e11241e9c53c3d7b0d730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmAIv8Yz2psel6Oa1LJZaA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">app.old.js is not found in new task</figcaption></figure><p id="915d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">HTML响应加载到用户浏览器后，浏览器会尝试加载已经在HTML上定义的脚本<code class="du lb lc ld le b">app.old.js</code>。这个请求然后被传递到负载平衡器，负载平衡器决定将流量发送到任务B，这是一个新的容器。因为所有的静态资源都存储在本地，所以任务b上没有<code class="du lb lc ld le b">app.old.js</code>，只有<code class="du lb lc ld le b">app.new.js</code>。浏览器无法加载资源，最终网站崩溃。</p><p id="3a34" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个问题看起来很简单，因为这只发生在持续几分钟的部署过程中。但是假如有这个问题的用户是第一次来网站的新用户呢。用户在结帐过程中看到破损的页面或功能，然后决定不再继续付款。</p><p id="6019" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，有一个乐于助人的用户试图联系客户服务，以确保他们能够付款，但这种类型的用户非常少见。大多数情况下，如果用户看到页面被破坏，他们就会离开网站，再也不会回来。这个问题对业务不利，我们需要解决这个问题。</p><h1 id="b814" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">怎么会？</h1><p id="00f1" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">解决办法很简单。我们需要做的就是将所有静态资源转移到第三方存储服务。由于我们使用亚马逊网络服务，我们可以使用他们的S3服务来存储文件。然后我想，为什么只用S3，为什么不用CloudFront (CDN)坐在S3·巴特的前面。</p><p id="d365" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">老实说，我从来没有建立CDN的经验。所以这对我来说很有趣。由于技术非常具体，我将解释我们如何在c I构建过程中创建自动化CDN部署的技术细节。作为背景，我们使用Nuxt.js作为Vue.js的包装器，以允许我们轻松配置服务器端呈现，然后我们再次将Nuxt.js包装在Express.js内，这样我们可以在同一个应用程序中提供Nuxt.js SSR页面和网站API。</p><p id="bea7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们能够在CloudFront上提供静态文件之前，我们需要将所有文件上传到S3作为原始资源。你可以在CloudFront上找到很多关于如何制作S3水桶的资源。在我们的新站点中，有两种类型的资源，静态和动态资源。</p><p id="dc45" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">动态资源是我们的用户上传的照片或视频等文件。这些资源已经存储在S3上，所以我们并没有做太多工作来让这些资源可以通过CloudFront提供服务。这只是一个将网址从S3网址改为CloudFront网址的问题。例如，我们将<code class="du lb lc ld le b">DYNAMIC_PUBLIC_RESOURCE_PREFIX</code>从<code class="du lb lc ld le b">https://s3-us-west-2.amazonaws.com/bucket-name/static</code>设置为<code class="du lb lc ld le b"><a class="ae it" href="https://random-subdomain.cloudfront.net/static." rel="noopener ugc nofollow" target="_blank">https://random-subdomain.cloudfront.net/static</a></code>到<a class="ae it" href="https://random-subdomain.cloudfront.net/static." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7f03" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">静态资源是在构建过程中生成的文件，它通常是javascript文件、CSS文件和小图像文件，如图标或背景图像。构建静态资源时，所有url(如图片或字体)都将引用本地资源，因此我们需要在<code class="du lb lc ld le b">nuxt.config.js</code>上设置额外的配置，以确保在CI构建过程中编译资源时，URL被转换为CloudFront端点。</p><p id="bb1f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我搜索了代码库之后，有3种情况，静态资源url用于应用程序，<code class="du lb lc ld le b">background-image</code> CSS属性和字体资产用于我们的SCSS文件(我们使用SCSS作为我们的CSS预处理程序)，<code class="du lb lc ld le b">background-image</code> CSS属性用于Vue模板，图片<code class="du lb lc ld le b">src</code>属性用于Vue模板。</p><h1 id="b46b" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">SCSS文件上的资产URL</h1><p id="d509" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">更改SCSS文件上的资产URL很简单。你所需要做的就是将CloudFront CDN URL放在<code class="du lb lc ld le b">nuxt.config.js</code>构建配置的<code class="du lb lc ld le b">publicPath</code>上。因为我们在构建期间将URL存储在环境变量中，所以我们可以只使用<code class="du lb lc ld le b">CLOUDFRONT_ENDPOINT</code>环境变量来检索URL。此外，我们必须确保这仅适用于生产或暂存构建，因此我们依赖于<code class="du lb lc ld le b">NODE_ENV</code>，以确保我们仅在开发中使用默认的<code class="du lb lc ld le b">/build/</code>目录。但是我们必须确保它已经被导入到Nuxt.js环境变量中，因为如果不是这样，你就不能在配置中使用<code class="du lb lc ld le b">CLOUDFRONT_ENDPOINT</code>和<code class="du lb lc ld le b">NODE_ENV</code>。</p><p id="97a2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们总结所有这些配置，结果差不多是这样的:</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="03b5" class="ll jz hh le b fi lm ln l lo lp">module.exports = {<br/>  env: {<br/>    NODE_ENV: process.env.CLOUDFRONT_ENDPOINT,<br/>    CLOUDFRONT_ENDPOINT: process.env.CLOUDFRONT_ENDPOINT<br/>  },<br/>  build: {<br/>    publicPath:<br/>      process.env.NODE_ENV !== "development"<br/>        ? process.env.CLOUDFRONT_ENDPOINT<br/>        : "/build/",<br/>  }<br/>}</span></pre><h1 id="b971" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Vue模板上的背景图像CSS属性</h1><p id="521c" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">接下来是如何将包含<code class="du lb lc ld le b">url()</code>的<code class="du lb lc ld le b">background-image</code> CSS属性转换为使用CloudFront端点，而不是使用本地端点。在Vue模板中，我们有包含组件CSS属性的<code class="du lb lc ld le b">&lt;style&gt;</code>部分。在我们的网站上，我们只有一个普通的CSS文件，格式为SCSS文件，然后所有的样式应该放在Vue组件中，因为这使我们更容易组织代码。通过设置公共路径配置似乎不会自动改变这个<code class="du lb lc ld le b">background-image</code>属性的URL。找到这个问题的解决方案是相当具有挑战性的，因为我们还没有在互联网上找到任何合适的例子。</p><p id="4ad4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们发现Nuxt.js默认使用Post CSS，我们可以在<code class="du lb lc ld le b">nuxt.config.js</code>中更改Post CSS的配置。所以我们需要做的就是改变<code class="du lb lc ld le b">postcss-url</code>插件配置，将资产url从本地转换到CloudFront端点。所以我们最终有了这样的配置。</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="aff6" class="ll jz hh le b fi lm ln l lo lp">module.exports = {<br/>  env: {<br/>    NODE_ENV: process.env.CLOUDFRONT_ENDPOINT,<br/>    CLOUDFRONT_ENDPOINT: process.env.CLOUDFRONT_ENDPOINT<br/>  },<br/>  build: {<br/>    publicPath:<br/>      process.env.NODE_ENV !== "development"<br/>        ? process.env.CLOUDFRONT_ENDPOINT<br/>        : "/build/",<br/>    postcss: {<br/>      plugins: {<br/>        "postcss-import": {},<br/>        "postcss-url": {<br/>          url: asset =&gt; {<br/>            // Exclude development mode<br/>            if (process.env.NODE_ENV === "development") {<br/>              return asset.url;<br/>            }<br/><br/>            // Exclude data-url resources<br/>            if (asset.url.substr(0, 4) === "data") {<br/>              return asset.url;<br/>            }<br/><br/>            // Exclude non image asset<br/>            if (asset.url.substr(0, 8) !== "/img/") {<br/>              return asset.url;<br/>            }<br/><br/>            // Return cdn url<br/>            return process.env.CLOUDFRONT_ENDPOINT + asset.url;<br/>          }<br/>        }<br/>      }<br/>  }<br/>}</span></pre><p id="a7a5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该配置基本上说，我们仍然在开发环境中使用本地url，如果它是<code class="du lb lc ld le b">data-url</code>格式，则保留资产url，跳过所有非图像资产URL，如果我们在样式上找到图像资产URL，则在URL上做一些格式化。</p><h1 id="7e68" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><code class="du lb lc ld le b">Vue</code>模板上的图像<code class="du lb lc ld le b">src</code>属性HTML</h1><p id="ae8c" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">最后一个是改变Vue模板上的静态图像URL。在Vue文件中有一个叫做<code class="du lb lc ld le b">&lt;template&gt;</code>的部分，我们把HTML代码放在那里，并且总是有机会在上面使用静态文件图像。像这样:</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="6e69" class="ll jz hh le b fi lm ln l lo lp">&lt;template&gt;<br/>  &lt;div id="header"&gt;<br/>    &lt;img src="/img/icon.png"&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="e8af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们如何将这段代码的url从本地url更改为CloudFront端点？在尝试了各种方法后，我们最终在Nuxt.js应用程序中使用自定义插件，通过使用注入模块来交换这个URL。</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="727d" class="ll jz hh le b fi lm ln l lo lp">export default ({ store }, inject) =&gt; {<br/>  inject("image", path =&gt; {<br/>    if (process.env.NODE_ENV === "development") {<br/>      return `/img/${path}`;<br/>    }<br/><br/>    return `${process.env.CLOUDFRONT_ENDPOINT}/img/${path}`;<br/>  });<br/>};</span></pre><p id="9dfb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们将这个插件附加到<code class="du lb lc ld le b">nuxt.config.js</code>上。</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="ead6" class="ll jz hh le b fi lm ln l lo lp">module.exports = {<br/>  plugins: [<br/>    { src: "~/plugins/image.js" }<br/>  ]<br/>}</span></pre><p id="bd07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">之后，我们能够像这样在Vue组件上使用<code class="du lb lc ld le b">$image</code>模块:</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="f2a4" class="ll jz hh le b fi lm ln l lo lp">&lt;template&gt;<br/>  &lt;div id="header"&gt;<br/>    &lt;img :src="$image('/icon.png')"&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="c871" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过使用这个简单的插件，我们能够根据机器的环境交换静态图像url。当然，我必须找到并替换所有的url，这导致我们的git提交发生了巨大的变化。</p><p id="40af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好了，我们可以改变静态和动态资源的URL了。然后，我们还需要更改配置项配置，以确保所有这些文件。幸运的是，我们可以在<a class="ae it" href="https://nuxtjs.org/faq/deployment-aws-s3-cloudfront#overview" rel="noopener ugc nofollow" target="_blank"> Nuxt.js文档</a>中找到那个配置。在该文档中，我们可以上传所有编译好的脚本到<code class="du lb lc ld le b">dist</code>文件夹中，我们需要改变配置，使我们所有的静态图像也上传到AWS S3。这个改动非常简单，我们只需要把<code class="du lb lc ld le b">gulp.src('./' + config.distDir + '/**');</code>改成<code class="du lb lc ld le b">gulp.src(['./' + config.distDir + '/**', './static']);</code>。</p><p id="c76c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还需要通过npm脚本将这个gulp任务包含到我们的order文件中，以便在CI到达构建流程时被触发。在我们的package.json中，我们添加了这个gulp脚本。</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="88f3" class="ll jz hh le b fi lm ln l lo lp">{<br/>  ...<br/>  "scripts": {<br/>    "cdn:deploy": "gulp deploy"<br/>  },<br/>  ...<br/>}</span></pre><p id="b04d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们将npm任务添加到Dockerfile。</p><pre class="jt ju jv jw fd lh le li lj aw lk bi"><span id="020d" class="ll jz hh le b fi lm ln l lo lp"># Install application<br/>RUN npm install \<br/>    &amp;&amp; npm run build \<br/>    &amp;&amp; npm run cdn:deploy</span></pre><p id="4850" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在所有这些变化之后，现在我们可以放松了，因为在CI部署期间，用户不会再看到我们的网站被破坏。尽管这个过程似乎已经完成，我们仍然没有实现从S3桶中清除旧文件的功能。因此，我们仍然需要偶尔手动清理旧文件。如果我以某种方式找到如何自动做到这一点，我会更新这个职位，以反映这一功能。</p><p id="e9e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就这些了，如果你目前有使用Nuxt.js部署CDN的问题，我希望这篇文章可以帮助你。下次见。</p><p id="09ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更新:</p><p id="62a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嘿，我找到了移除Nuxt.js生成的旧文件的方法，你可以在这个帖子里看到:<a class="ae it" rel="noopener" href="/@alfianeffendy/how-we-manage-to-remove-unused-compiled-nuxt-js-files-on-aws-s3-ab3b6cfe2993">https://medium . com/@ alfianeffendy/how-we-manage-to-remove-unused-compiled-nuxt-js-files-on-AWS-S3-ab 3b 6 cfe 2993</a></p></div></div>    
</body>
</html>