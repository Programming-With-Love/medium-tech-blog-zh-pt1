<html>
<head>
<title>Android Data Binding: Observability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:可观察性</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-observability-9de4ff3fe038?source=collection_archive---------0-----------------------#2016-09-22">https://medium.com/androiddevelopers/android-data-binding-observability-9de4ff3fe038?source=collection_archive---------0-----------------------#2016-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/983f4b7717fe7ccf5a457e769de51aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5QWfGL5yB_9Nf1pc21ZgQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="dc95" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">保持用户界面最新</h2></div><p id="3c4f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Android数据绑定是将数据插入UI的一种非常简单的方法。到目前为止，<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-adding-some-variability-1fe001b3abcc#.hrbxwmacc">我只展示了如何使用普通java对象(POJO)</a>来实现这一点。然而，当数据更新时，没有更新UI的通知。当服务器发送了一个更新，而你想让用户看到这个变化时，这就不好了。Android数据绑定为您提供了几种方法来保持数据与UI同步。</p><h2 id="756f" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">波乔</h2><p id="9eb5" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">我有一个普通的老式Java对象“Foo ”,有一个属性“bar ”,我将它绑定到我的UI:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="7abd" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>Foo {<br/>    <strong class="lj ht">private int bar</strong>;<br/><br/>    <strong class="lj ht">public int </strong>getBar() {<br/>        <strong class="lj ht">return bar</strong>;<br/>    }<br/><br/>    <strong class="lj ht">public void </strong>setBar(<strong class="lj ht">int </strong>bar) {<br/>        <strong class="lj ht">this</strong>.<strong class="lj ht">bar </strong>= bar;<br/>    }<br/>}</span></pre><p id="b86d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我希望每次调用“setBar”时UI都发生变化，所以让我们看看如何使数据绑定跟上变化:</p><h2 id="6f20" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">可观察量</h2><p id="ff38" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">最灵活的机制是让您的对象实现Observable接口，它有以下两种方法:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="34eb" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">void </strong>addOnPropertyChangedCallback(OnPropertyChangedCallback c);<br/><em class="lr"><br/></em><strong class="lj ht">void </strong>removeOnPropertyChangedCallback(OnPropertyChangedCallback c);</span></pre><p id="9ce8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您的字段发生更改时，必须通知OnPropertyChangedCallback:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e016" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public abstract void </strong>onPropertyChanged(Observable sender,<br/>                                       <strong class="lj ht">int </strong>propertyId);</span></pre><p id="f729" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该类还必须用“@Bindable”注释任何应该观察到的getters。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e183" class="ke kf hs lj b fi ln lo l lp lq">@Bindable<br/><strong class="lj ht">public int </strong>getBar() {<br/>    <strong class="lj ht">return bar</strong>;<br/>}</span></pre><p id="2024" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这告诉数据绑定框架该属性是可观察的，并在应用程序包的“BR”类中生成一个标识符。这个类类似于“R”类，但是用于propertyId的绑定资源。</p><p id="94a2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Android数据绑定为您提供了PropertyChangeRegistry类，使跟踪侦听器变得更加容易:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="39af" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>Foo <strong class="lj ht">implements </strong>Observable {<br/>    <strong class="lj ht">private </strong>PropertyChangeRegistry <strong class="lj ht">registry </strong>= <br/>        <strong class="lj ht">new </strong>PropertyChangeRegistry();<br/>    <strong class="lj ht">private int bar</strong>;<br/><br/>    @Bindable<br/>    <strong class="lj ht">public int </strong>getBar() {<br/>        <strong class="lj ht">return bar</strong>;<br/>    }<br/><br/>    <strong class="lj ht">public void </strong>setBar(<strong class="lj ht">int </strong>bar) {<br/>        <strong class="lj ht">this</strong>.<strong class="lj ht">bar </strong>= bar;<br/>        <strong class="lj ht">registry</strong>.notifyChange(<strong class="lj ht">this</strong>, BR.bar);<br/>    }<br/><br/>    @Override<br/>    <strong class="lj ht">public void </strong>addOnPropertyChangedCallback(<br/>                   OnPropertyChangedCallback callback) {<br/>        <strong class="lj ht">registry</strong>.add(callback);<br/>    }<br/><br/>    @Override<br/>    <strong class="lj ht">public void </strong>removeOnPropertyChangedCallback(<br/>                   OnPropertyChangedCallback callback) {<br/>        <strong class="lj ht">registry</strong>.remove(callback);<br/>    }<br/>}</span></pre><h2 id="56bd" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">基本可观察的</h2><p id="4d41" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">如果您的模型对象可以扩展基类，BaseObservable通过为您实现Observable接口使它变得更容易。您只需要注释属性并通知更改:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="75be" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>Foo <strong class="lj ht">extends </strong>BaseObservable {<br/>    <strong class="lj ht">private int bar</strong>;<br/><br/>    @Bindable<br/>    <strong class="lj ht">public int </strong>getBar() {<br/>        <strong class="lj ht">return bar</strong>;<br/>    }<br/><br/>    <strong class="lj ht">public void </strong>setBar(<strong class="lj ht">int </strong>bar) {<br/>        <strong class="lj ht">this</strong>.<strong class="lj ht">bar </strong>= bar;<br/>        notifyPropertyChanged(BR.bar);<br/>    }<br/>}</span></pre><h2 id="cfd3" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">可观察视野</h2><p id="c074" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">Observable和BaseObservable对于简单的用法来说有点复杂，所以我们引入了ObservableField和它的原始对应物。要使用ObservableFields，只需在类中声明公共的final字段。这次我将使用两个属性来演示基本类型和引用类型:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="3516" class="ke kf hs lj b fi ln lo l lp lq"><strong class="lj ht">public class </strong>Foo {<br/>    <strong class="lj ht">public final </strong>ObservableInt <strong class="lj ht">bar </strong>= <strong class="lj ht">new </strong>ObservableInt();<br/>    <strong class="lj ht">public final </strong>ObservableField&lt;String&gt; <strong class="lj ht">baz </strong>= <br/>        <strong class="lj ht">new </strong>ObservableField&lt;&gt;();<br/>}</span></pre><p id="1a22" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以在绑定表达式中使用这些作为普通属性:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="5c99" class="ke kf hs lj b fi ln lo l lp lq">&lt;<strong class="lj ht">TextView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="<em class="lr">@{foo.baz}</em>"</strong>/&gt;</span></pre><p id="d6a5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然绑定表达式仍然吸引人，但是Java需要调用setters和getters:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="6d3d" class="ke kf hs lj b fi ln lo l lp lq">foo.<strong class="lj ht">bar</strong>.set(age);<br/>String name = foo.<strong class="lj ht">baz</strong>.get();</span></pre><h2 id="6025" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">可观察地图</h2><p id="6779" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">有些时候，数据没有很好地定义。您可能仍在构建原型，来自服务器的数据格式仍在不断变化，您不想为它们创建对象。ObservableMap及其实现ObservableArrayMap就是为这些更加模糊的数据结构而创建的。</p><p id="0009" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用ObservableMap，您可以像访问任何普通地图一样访问地图中的值，并且当发生变化时，UI将会更新。例如:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="b3ad" class="ke kf hs lj b fi ln lo l lp lq">&lt;<strong class="lj ht">data</strong>&gt;<br/>    &lt;<strong class="lj ht">variable name="product"<br/>    type="<em class="lr">android.databinding.ObservableMap&amp;lt;String, Object&amp;gt;</em>"</strong>/&gt;<br/>&lt;/<strong class="lj ht">data</strong>&gt;<br/><br/>&lt;!-- ... --&gt;<br/>&lt;<strong class="lj ht">TextView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text='<em class="lr">@{product["name"]}</em>'</strong>/&gt;</span></pre><p id="b933" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以在代码中使用ObservableMap:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="0440" class="ke kf hs lj b fi ln lo l lp lq">ObservableMap&lt;String, Object&gt; product = <strong class="lj ht">new </strong>ObservableArrayMap&lt;&gt;();<br/>binding.setProduct(product);<br/>product.put(<strong class="lj ht">"name"</strong>, <strong class="lj ht">"Golf Ball"</strong>);</span></pre><p id="7952" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">任何时候产品对象发生变化，它都会更新UI。</p><h2 id="c734" class="ke kf hs bd kg kh ki kj kk kl km kn ko jq kp kq kr ju ks kt ku jy kv kw kx ky bi translated">结论</h2><p id="0971" class="pw-post-body-paragraph jh ji hs jj b jk kz it jm jn la iw jp jq lb js jt ju lc jw jx jy ld ka kb kc ha bi translated">许多用户界面不需要被告知数据的变化，所以你不需要为你的整个模型增加可观察性。另一方面，当您的服务器发送新数据或用户对UI的一部分进行更改，而UI的其余部分自动更新时，让UI自动更新会很好。</p><p id="2e00" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">选择你喜欢的观察方法。大多数会扩展BaseObservable或使用ObservableFields，但其他的也有它们的用途。</p></div></div>    
</body>
</html>