<html>
<head>
<title>gRPC Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC简化版</h1>
<blockquote>原文：<a href="https://medium.com/globant/grpc-simplified-d3edbec6c56d?source=collection_archive---------1-----------------------#2022-12-21">https://medium.com/globant/grpc-simplified-d3edbec6c56d?source=collection_archive---------1-----------------------#2022-12-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ff59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">了解如何用Java创建基本的gRPC客户机和服务器</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/9862eebd905d2bbce5df83f3faab6ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DZrDJDp-THsUfAi8"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathew Schwartz</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e40f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你一定在想，这个gRPC到底是什么？为什么当我们有其他交流方式的时候，这种情况还会存在？这种新技术会有什么帮助呢？嗯，没有什么是“完全符合所有需求”的。我们对一个问题有多种解决方案，但是我们应该知道每种解决方案的利弊，然后从中做出选择。就像在数据传输速度问题上，我们可以选择gRPC而不是REST。</p><p id="4c4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">gRPC是Google开发的一种消息传递技术。gRPC中的“g”不代表“Google”；每个版本都不一样。比如gRPC <code class="du jt ju jv jw b">1.12</code>中的“g”<strong class="ig hi"/>代表“光荣”，gRPC <code class="du jt ju jv jw b">1.1</code>中代表“良好”。</p><p id="aab8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">gRPC是一个现代的开源、高性能远程过程调用(RPC)框架，可以在任何环境中运行。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。</p><p id="3e6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，gRPC没有提供创建web APIs的指南；它执行规则。在大多数情况下，gRPC更快、更健壮，因为它定义了每个请求和响应应该遵守的一组特定的规则。</p><h1 id="b8d7" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">请求流</h1><p id="7665" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">让我们看看gRPC的请求流:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="ab fe cl la"><img src="../Images/4a989aca63dc4bb174dcd3d42ff1939f.png" data-original-src="https://miro.medium.com/v2/format:webp/0*eoTsSOJmSS7QGRj8.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">RPC Mechanism. The client and server are internal services, and the client cannot be a browser.</figcaption></figure><ol class=""><li id="50ee" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">客户端首先打包请求，并将所有必要的数据发送到客户端存根，然后由客户端存根将数据整理并发送到服务器。</li><li id="cfab" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">RPC运行时包含负责在客户端和服务器<em class="lp"> </em>存根<em class="lp">之间传输RPC数据包的运行时例程。</em></li><li id="c7a1" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">服务器端存根从客户端接收请求，并对请求进行解包(解组)。服务器存根创建并整理响应，然后将其发送给客户端。</li><li id="5477" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">这个响应是在客户端接收的。客户端存根开始解组(解包)响应。</li></ol><p id="f603" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">gRPC的基本构件是<code class="du jt ju jv jw b"><a class="ae js" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">protobuf</a></code>。谷歌的<code class="du jt ju jv jw b">protobuf</code>或<code class="du jt ju jv jw b">proto</code>只是一种序列化结构化数据的机制。让我们看一个消息发送服务的例子<code class="du jt ju jv jw b">proto</code>。</p><pre class="jd je jf jg fd lq jw lr bn ls lt bi"><span id="5de0" class="lu jy hh jw b be lv lw l lx ly">syntax = "proto3";<br/>option java_multiple_files = true;<br/><br/>message MessageRequest {<br/>  string recipient = 1;<br/>  string message = 2;<br/>}<br/><br/>message MessageResponse {<br/>  string response = 1;<br/>}<br/>service MessageService {<br/>  rpc send(MessageRequest) returns (MessageResponse);<br/>}</span></pre><p id="51cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码片段中，我们有一个服务和多个消息块，它们在编译后分别被转换为类和模型。原型编译有多种方式:</p><ul class=""><li id="9c3d" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">使用<code class="du jt ju jv jw b">protoc</code>命令:</li></ul><pre class="jd je jf jg fd lq jw lr bn ls lt bi"><span id="2846" class="lu jy hh jw b be lv lw l lx ly">protoc -I -java_out=${OUTPUT_DIR} path/to/proto/file</span></pre><ul class=""><li id="8fb9" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">使用<code class="du jt ju jv jw b"><a class="ae js" href="https://mvnrepository.com/artifact/io.grpc/protoc-gen-grpc-java" rel="noopener ugc nofollow" target="_blank"><em class="lp">maven-plugin</em></a></code>并将其添加到Maven的编译生命周期阶段进行自动生成。让我们看一个使用消息<code class="du jt ju jv jw b">proto</code>的gRPC客户机和服务器的例子。</li></ul><pre class="jd je jf jg fd lq jw lr bn ls lt bi"><span id="2ba4" class="lu jy hh jw b be lv lw l lx ly">import io.grpc.ManagedChannel;<br/>import io.grpc.ManagedChannelBuilder;<br/><br/>public class Client {<br/>  public static void main(String[] args) throws InterruptedException {<br/>    ManagedChannel channel = ManagedChannelBuilder<br/>      .forAddress("localhost", 8080)<br/>      .usePlaintext()<br/>      .build();<br/><br/>    MessageServiceGrpc.MessageServiceBlockingStub stub = <br/>      MessageServiceGrpc.newBlockingStub(channel);<br/><br/>    org.example.grpc.MessageResponse messageResponse = stub<br/>      .send(org.example.grpc.MessageRequest.newBuilder()<br/>        .setMessage("Welcome back!!")<br/>        .setRecipient("Daniel")<br/>        .build());<br/><br/>    System.out.println("Response received from server:\n" +<br/>      messageResponse);<br/><br/>    channel.shutdown();<br/>  }<br/>}</span></pre><p id="3669" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码片段中，客户端负责创建一个与服务器通信的纯文本通道。<code class="du jt ju jv jw b">Messaging service stub</code>被分配给已创建的通道，用于在其上调用<code class="du jt ju jv jw b"><em class="lp">messageService.send()</em></code>。</p><pre class="jd je jf jg fd lq jw lr bn ls lt bi"><span id="7a53" class="lu jy hh jw b be lv lw l lx ly">import io.grpc.ServerBuilder;<br/><br/>import java.io.IOException;<br/><br/>public class Server {<br/>  public static void main(String[] args) throws IOException,<br/>    InterruptedException {<br/>      Server server = ServerBuilder.forPort(8080)<br/>        .addService(new MessageServiceImpl()).build();<br/><br/>      System.out.println("Starting server...");<br/>      server.start();<br/>      System.out.println("Server started!");<br/>      server.awaitTermination();<br/>    }<br/>}</span></pre><p id="e286" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码中，我们使用<code class="du jt ju jv jw b">ServerBuilder</code>创建了一个服务器，并通过在其上调用<code class="du jt ju jv jw b">addService()</code>附加了一个消息服务。我们在这个服务器上调用start方法，并等待传入的客户端连接。</p><pre class="jd je jf jg fd lq jw lr bn ls lt bi"><span id="f397" class="lu jy hh jw b be lv lw l lx ly">import io.grpc.stub.StreamObserver;<br/><br/>public class MessageServiceImpl extends MessageServiceImplBase{<br/><br/>    @Override<br/>    public void send(org.example.grpc.MessageRequest request, <br/>StreamObserver&lt;org.example.grpc.MessageResponse&gt; responseObserver) {<br/>        System.out.println("Request received from client:\n" + request);<br/><br/>        String greeting = new StringBuilder().append("Hello, ")<br/>                .append(request.getRecipient())<br/>                .append(" ")<br/>                .append(request.getMessage())<br/>                .toString();<br/><br/>        org.example.grpc.MessageResponse response = <br/>                 org.example.grpc.MessageResponse.newBuilder()<br/>                .setResponse(greeting)<br/>                .build();<br/><br/>        responseObserver.onNext(response);<br/>        responseObserver.onCompleted();<br/>    }<br/>}</span></pre><p id="cfe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">MessageServiceImpl</code>类扩展了<code class="du jt ju jv jw b">MessageServiceImplBase</code>，是在<code class="du jt ju jv jw b">proto</code>文件编译后自动生成的。我们需要实现<code class="du jt ju jv jw b"><em class="lp">send()</em></code>方法，该方法将读取请求并创建发送给客户端的响应。</p><h1 id="4a23" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">优势</h1><p id="5f46" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">以下是gRPC的一些优势:</p><ul class=""><li id="32bf" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">gRPC使用<code class="du jt ju jv jw b">protobuff</code>和http2，以二进制传输<strong class="ig hi">数据，支持<strong class="ig hi">双工流</strong>。</strong></li><li id="39c8" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated"><code class="du jt ju jv jw b">protoc</code>帮助<strong class="ig hi">自动生成</strong>客户代码。</li><li id="a762" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">gRPC库受到持续监控，以确保速度可靠性。</li><li id="2bd6" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">我们可以通过托管通道拥有一个<strong class="ig hi">连接池</strong>。</li><li id="6407" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">gRPC库有一个用于<strong class="ig hi">负载平衡的内置库。</strong></li><li id="b960" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated"><strong class="ig hi">语言无关，</strong>Java客户端可以无缝连接到Python服务器。</li></ul><h1 id="9c92" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">限制</h1><p id="d203" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">尽管gRPC具有优势，但它也有一些限制:</p><ul class=""><li id="8df2" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">没有浏览器支持，所以它只能在内部API中使用。</li><li id="6c03" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated"><a class="ae js" href="https://blog.postman.com/postman-now-supports-grpc/" rel="noopener ugc nofollow" target="_blank">新版中对</a>的邮差支持非常有限，但是其他客户端像<a class="ae js" href="https://github.com/bloomrpc/bloomrpc" rel="noopener ugc nofollow" target="_blank"> BloomRpc </a>和<a class="ae js" href="https://kreya.app/" rel="noopener ugc nofollow" target="_blank"> Kreya </a>都有很好的支持。</li></ul><h1 id="4cfa" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">案例使用</h1><p id="d727" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">以下是gRPC的一些使用案例:</p><ul class=""><li id="7b5e" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">对于内部微服务。</li><li id="9b36" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">适用于需要传输大量数据的服务。</li></ul><h1 id="6e8b" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论</h1><p id="aa60" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">最后，对于负载较重的服务器，gRPC APIs的性能要好得多，接收数据的速度快7倍，发送数据的速度快10倍。这个结论是对应用程序的内部服务进行测试的结果。但是如果服务器只为少数请求服务，REST就足够了。</p><h1 id="dada" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">参考</h1><p id="0800" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这些参考资料会有所帮助:</p><ul class=""><li id="4a45" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lz lh li lj bi translated">gRPC的基础知识在<a class="ae js" href="https://grpc.io/docs/languages/java/basics/" rel="noopener ugc nofollow" target="_blank">链接</a>中解释。</li><li id="f958" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">gRPC与java <a class="ae js" href="https://github.com/grpc/grpc-java" rel="noopener ugc nofollow" target="_blank">库</a>。</li><li id="3291" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lz lh li lj bi translated">gRPC客户端和服务器<a class="ae js" href="https://github.com/eugenp/tutorials/tree/master/grpc" rel="noopener ugc nofollow" target="_blank">示例</a>。</li></ul></div></div>    
</body>
</html>