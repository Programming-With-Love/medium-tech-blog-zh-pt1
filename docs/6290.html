<html>
<head>
<title>What we learned from an iOS app OOMs incident</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们从iOS应用OOMs事件中学到了什么</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/what-we-learned-from-an-ios-app-ooms-incident-eb31eada251?source=collection_archive---------0-----------------------#2021-06-03">https://medium.com/pinterest-engineering/what-we-learned-from-an-ios-app-ooms-incident-eb31eada251?source=collection_archive---------0-----------------------#2021-06-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="eb96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">马良|软件工程师，应用基础</p><p id="3a2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在2020年初，我们开始看到Pinterest iOS应用程序中内存不足(OOM)崩溃的显著增加。该事件导致无崩溃用户率(CFUR)下降，从之前的<strong class="ig hi"> 99%下降到</strong>96%，降幅很大。发生了什么事？</p><p id="a911" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一过程中，我们改进了许多系统，但是这些经验可以在一篇单独的博客中发表。<em class="jc">这篇</em>博文的主要目的是与更广泛的iOS社区分享我们从这个iOS特定问题中学到的东西。</p><h1 id="da85" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">有什么问题？</h1><p id="9cf2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">对于上下文，在Pinterest iOS应用程序中，我们使用<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsession" rel="noopener ugc nofollow" target="_blank"> NSURLSession </a>与Pinterest REST API端点对话。大多数端点已经在HTTP2上存在了很多年，有些端点因为各种原因被抛弃了。在花费大量时间进行故障排除后，我们排除了同一时期的其他转移注意力的问题，并发现当HTTP2在某些端点上启用时，Pinterest iOS应用程序将比平时多经历约20倍的OOM崩溃。</p><p id="7a29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的图是在后来的复制测试中获得的，可能会让您感觉到它们是如何紧密地联系在一起的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/9c625ddec0e967ff1f60c095a63690dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XxhGET1J69iENPS2"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 1 — when HTTP2 was enabled on that endpoint</figcaption></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/86b87d65e67b0a86b8fb6ef4168308ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Dz1OUkrVq9ocCmQ"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 2 — OOMs spiked instantly and aligned w/ HTTP2 timeline.</figcaption></figure><p id="7e7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> TL'DR —罪魁祸首是在我们的代码</strong>中错误地使用了<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407341-httpbodystream?language=objc" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">http bodystream</strong></a><strong class="ig hi">模式。当特定的错误被触发时，它们可以在一分钟内泄漏数千兆字节的内存，从而导致OOM崩溃。更多细节将在下面讨论。</strong></p><h1 id="9a6d" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们是如何解决这个问题的？</h1><p id="0428" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">将OOM崩溃的高峰与HTTP2联系起来，并进一步将根本原因缩小到代码中的一个普通HTTP问题，并不是那么简单——事实上，我们花了几个月的时间来解决这个问题。以下是我们做的几件事:</p><ul class=""><li id="89d6" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><strong class="ig hi">复制一个测试端点:</strong>我们为了HTTP2测试/验证的目的复制了一个测试端点，通过实验控制iOS客户端连接到那个端点。这个临时端点的另一个好处是，在我们在原始端点上再次打开HTTP2之前(在这种情况下，几乎是一年之后)，我们将修补过的应用程序版本指向这个端点以采用HTTP2。</li><li id="3a3a" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><strong class="ig hi">上下文日志记录:</strong>我们记录内存元数据(<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsprocessinfo/1408211-physicalmemory" rel="noopener ugc nofollow" target="_blank">总计</a>、<a class="ae kg" href="https://developer.apple.com/documentation/os/3191911-os_proc_available_memory" rel="noopener ugc nofollow" target="_blank">可用</a>、内存占用、峰值等来自<a class="ae kg" href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/osfmk/mach/task_info.h.auto.html" rel="noopener ugc nofollow" target="_blank"> task_vm_info </a>)和网络指标(延迟、错误代码、有效负载大小等)。)，以及现有的上下文事件。它们有助于找出oom的模式，如内存如何积累并响应前台/后台模式切换、异常网络超时等事件。</li><li id="cb2c" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><strong class="ig hi">Xcode的记忆工具:</strong>这些记忆工具是我们用来将根本原因缩小到精确代码的终极武器:</li><li id="b0c8" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><strong class="ig hi">监控内存报告</strong>并在发现内存异常增加时，准备调试仪器中的内存图或配置文件。</li></ul><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/5243237aaeabdf9c17dc291649874aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f0cUqfJdzu9kIyWD"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 3 — mocked by triggering errors, on the simulator.</figcaption></figure><ul class=""><li id="d092" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><strong class="ig hi">诊断内存图</strong></li></ul><p id="da58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了内存图，深入研究内存分配并找出哪些对象是可疑的就容易多了。还有命令行工具(vmmap、leaks等。)在分析raw时非常有用。记忆图文件也是。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ll"><img src="../Images/d9b231318db0c2f1a29e9cb83ce3d29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gt4EyrGUQi5X74Nm"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 4 — generate memory graph</figcaption></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/e51af1e93cea326d8287f1ae40e35ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P7JPYb1c6wJy9UJu"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 5 — CFNetwork objects are listed on the top.</figcaption></figure><ul class=""><li id="8c1f" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><strong class="ig hi">进一步沟通</strong></li></ul><p id="1abe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过与Apple团队的交流，我了解到一个已知的问题，即如果HTTP头太大，网络请求可能会进入一个循环，从而消耗过多的内存。我能够用模拟的大标题重现OOM崩溃，幸运的是，我们的应用程序中没有大请求标题问题。但是这个线索激发了我去更深入地挖掘更低的网络层。</p><h1 id="83c7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">根本原因</h1><p id="9f71" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">如前所述，根本原因是对<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407341-httpbodystream?language=objc" rel="noopener ugc nofollow" target="_blank"> HTTPBodyStream </a>的不正确使用。在我们的代码中，一些请求使用HTTPBodyStream来提供主体数据，即使没有实现<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">-URL session:task:needNewBodyStream:</a>，这在正常情况下也能正常工作。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lm"><img src="../Images/0a501cce666569616c0ac0b3e21e4397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*Ku4FWtyzodZqdWsgLjpNaA.png"/></div></figure><p id="b252" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是根据图6(摘自<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">-URL session:task:needNewBodyStream:</a>的API文档):</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ln"><img src="../Images/37f5dcfc81c472caad2a3aae9c8e1292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yOSxaKyTSOjGABNt"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 6 — <a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">API documentation</a></figcaption></figure><p id="96d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果请求设置了HTTPBodyStream，则必须实现委托方法-URL session:task:needNewBodyStream:<strong class="ig hi">才能在所有情况下正常工作。哎呀！</strong></p><h1 id="0db3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这里的问题:</h1><ul class=""><li id="2260" class="kx ky hh ig b ih kb il kc ip lo it lp ix lq jb lc ld le lf bi translated">人们可能认为将<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407341-httpbodystream?language=objc" rel="noopener ugc nofollow" target="_blank"> HTTPBodyStream </a>设置为<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest" rel="noopener ugc nofollow" target="_blank"> NSURLRequest </a>后，工作就完成了，苹果网络会处理好一切。他们可能没有意识到他们还需要实现<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">-URL session:task:needNewBodyStream:</a>因为它在正常情况下工作良好，直到“认证挑战或可恢复的服务器错误”发生。</li><li id="642b" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">可恢复的服务器错误可能并不罕见，但是请求超时失败可以被认为是可恢复的错误。还有，我们<strong class="ig hi"> <em class="jc"> </em>发现</strong> <a class="ae kg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> HTTP重定向</strong> </a> <strong class="ig hi">也是一个原因，而且肯定会触发内存问题</strong>(结合上面的<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407341-httpbodystream?language=objc" rel="noopener ugc nofollow" target="_blank"> HTTPBodyStream </a>问题):</li></ul><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/76f959b9fdfed3d55ad4a47f9a40b17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pZF7_IxCz_d-sHN2"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 7 — OOMs chart</figcaption></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lr"><img src="../Images/f137722e5df536f293c754c5700bd862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*vFEaa43dboUJOsbO"/></div><figcaption class="kt ku et er es kv kw bd b be z dx">Figure 8 — HTTP 3xx timeline</figcaption></figure><ul class=""><li id="d13f" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">API文档并没有明确说明丢失<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">-URL session:task:needNewBodyStream:</a>的后果，并不是请求失败那么简单。相反，当问题被触发时，很可能会遇到过多的网络跳数，并最终导致OOM问题。</li></ul><p id="5ffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能想知道为什么oom只发生在某些端点上。这主要是因为这些端点请求错误地使用了HTTPBodyStream，并且它们比其他端点被调用得更频繁。它们可以继续在后台模式下运行，这两种模式加在一起更有可能出错。</p><h1 id="2947" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">修复</h1><ul class=""><li id="a3e3" class="kx ky hh ig b ih kb il kc ip lo it lp ix lq jb lc ld le lf bi translated">在适当的情况下直接发送请求<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlrequest/1411317-httpbody?language=objc" rel="noopener ugc nofollow" target="_blank"> HTTPBody </a>,或者</li><li id="4d6d" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">使用<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest/1409529-httpbodystream?language=objc" rel="noopener ugc nofollow" target="_blank"> HTTPBodyStream </a>并相应地实现<a class="ae kg" href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1410001-urlsession/" rel="noopener ugc nofollow" target="_blank">-URL session:task:needNewBodyStream:</a>方法</li></ul><p id="d665" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们能够在下面的组合中验证我们的修复:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ls"><img src="../Images/8056bf1e9d70bfb760268076fd91564a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*jAK55Pg917TYZYRD8wE8sw.png"/></div></figure><h1 id="2ce3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">关键要点</h1><ul class=""><li id="0b59" class="kx ky hh ig b ih kb il kc ip lo it lp ix lq jb lc ld le lf bi translated">严格遵循苹果的API指南，因为在生产中修复此类错误的成本可能非常高。</li><li id="8bf5" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">OOM崩溃至关重要，应该是你的应用程序稳定性得分的一部分</li><li id="f52e" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">WWDC <a class="ae kg" href="https://developer.apple.com/videos/play/wwdc2018/416/" rel="noopener ugc nofollow" target="_blank"> iOS记忆深潜视频</a>值得一看</li></ul><p id="07c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">致谢:感谢Bill Kunz、Jon Parise、Scott Beardsley、iOS平台团队&amp; Arpit Diggi一路走来的大力支持。向所有参与其中的人致敬。</em></p><p id="889d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">要在Pinterest了解更多关于工程的信息，请查看我们的</em> <a class="ae kg" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="jc">工程博客</em> </a> <em class="jc">，并访问我们的</em><a class="ae kg" href="https://labs.pinterest.com/" rel="noopener ugc nofollow" target="_blank"><em class="jc">Pinterest Labs</em></a><em class="jc">网站。要查看和申请公开招聘机会，请访问我们的</em> <a class="ae kg" href="https://www.pinterestcareers.com/homepage" rel="noopener ugc nofollow" target="_blank"> <em class="jc">招聘</em> </a> <em class="jc">页面。</em></p></div></div>    
</body>
</html>