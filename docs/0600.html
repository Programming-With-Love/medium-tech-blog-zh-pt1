<html>
<head>
<title>Using and testing Room Kotlin APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用和测试Room Kotlin APIs</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-and-testing-room-kotlin-apis-4d69438f9334?source=collection_archive---------4-----------------------#2021-01-05">https://medium.com/androiddevelopers/using-and-testing-room-kotlin-apis-4d69438f9334?source=collection_archive---------4-----------------------#2021-01-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f54d5257763f1249e0482b52c4b4c9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2aKnfPkmj71LZWVghXjcQ.png"/></div></div></figure><div class=""/><p id="7f22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Room是SQLite的一个包装器，它使得在Android上使用数据库变得更加容易，也是迄今为止我最喜欢的Jetpack库。在这篇文章中，我想告诉你如何使用和测试Room Kotlin APIs，同时，我也将分享事情是如何在幕后工作的。</p><p id="bab3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用带有view codelab 的<a class="ae jn" href="https://developer.android.com/codelabs/android-room-with-a-view-kotlin#0" rel="noopener ugc nofollow" target="_blank">房间作为基础。在这里，我们正在构建一个保存在数据库中并显示在屏幕上的单词列表。用户也可以向列表中添加单词。</a></p><h1 id="5b85" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">定义数据库表</h1><p id="1b5a" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在我们的数据库中，我们只有一个表:包含单词的表。<code class="du kr ks kt ku b">Word</code>类表示表中的一个条目，它需要用<code class="du kr ks kt ku b">@Entity</code>进行注释。我们使用<code class="du kr ks kt ku b">@PrimaryKey</code>来定义表的主键。基于此，Room将生成一个SQLite表，与类名同名。该类的每个成员都成为表中不同的列。列名和类型由每个字段的名称和类型给出。您可以使用<code class="du kr ks kt ku b">@ColumnInfo</code>注释来更改它。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="ab93" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们建议您总是使用<code class="du kr ks kt ku b">@ColumnInfo</code>注释，因为它给了您更大的灵活性来重命名成员，而不必更改数据库列名。更改列名会导致数据库模式发生变化，因此您需要实现迁移。</p><h1 id="c783" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">访问表中的数据</h1><p id="e386" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了访问表中的数据，我们创建了一个数据访问对象(DAO)。这将是一个名为<code class="du kr ks kt ku b">WordDao</code>的接口，标注为<code class="du kr ks kt ku b">@Dao</code>。我们想要从表中插入、删除和获取数据，所以这些将被定义为DAO中的抽象方法。使用数据库是一项耗时的I/O操作，因此需要在后台线程上完成。我们将使用与Kotlin协程和流的房间集成来实现这一点。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="9f4c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个Kotlin词汇视频中，我们已经介绍了使用协程的基础知识。查看<a class="ae jn" href="https://youtu.be/emk9_tVVLcc?list=PLWz5rJ2EKKc_T0fSZc9obnmnWcjvmJdw_" rel="noopener ugc nofollow" target="_blank">这个视频</a>了解心流的信息。</p><h1 id="a502" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">插入数据</h1><p id="0b09" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">要插入数据，创建一个抽象的suspend函数，将要插入的单词作为参数，并用@Insert对其进行注释。Room将生成在数据库中插入数据所需的所有工作，因为我们使函数挂起，所以Room将所有要做的工作转移到后台线程。因此，这个挂起函数是主安全的:从主线程调用是安全的。</p><pre class="kv kw kx ky fd lb ku lc ld aw le bi"><span id="2be1" class="lf jp hs ku b fi lg lh l li lj">@Insert<br/>suspend fun insert(word: Word)</span></pre><p id="d624" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">引擎盖下的房间生成道的实现。下面是我们的insert方法的实现:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="14b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">调用函数，有3个参数:数据库，一个表示我们是否在事务中的标志和一个对象。<code class="du kr ks kt ku b">Callable.call()</code>包含处理数据库插入的代码。</p><p id="9725" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们检查<code class="du kr ks kt ku b">CoroutinesRoom.execute()</code> <a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:room/ktx/src/main/java/androidx/room/CoroutinesRoom.kt;l=47?q=CoroutinesRoom" rel="noopener ugc nofollow" target="_blank">实现</a>，我们会看到房间将<code class="du kr ks kt ku b">callable.call()</code>移动到不同的<code class="du kr ks kt ku b">CoroutineContext</code>。这来源于您在构建数据库时提供的执行器，或者默认情况下将使用架构组件IO执行器。</p><h1 id="3f15" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">查询数据</h1><p id="b8c7" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了查询该表，我们将创建一个抽象函数并用<code class="du kr ks kt ku b">@Query</code>对其进行注释，传入获取所需数据所需的SQL查询:word表中的所有单词，按字母顺序排序。</p><p id="10c4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当数据库中的数据发生变化时，我们都希望得到通知，所以我们返回一个<code class="du kr ks kt ku b">Flow&lt;List&lt;Word&gt;&gt;</code>。由于返回类型的原因，Room在后台线程上运行查询。</p><pre class="kv kw kx ky fd lb ku lc ld aw le bi"><span id="4913" class="lf jp hs ku b fi lg lh l li lj">@Query(“SELECT * FROM word_table ORDER BY word ASC”)<br/>fun getAlphabetizedWords(): Flow&lt;List&lt;Word&gt;&gt;</span></pre><p id="ec9c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">引擎盖下，房间为我们生成了<code class="du kr ks kt ku b">getAlphabetizedWords()</code>:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="bdcd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到一个<code class="du kr ks kt ku b">CoroutinesRoom.createFlow()</code>调用，有4个参数:数据库、一个指示我们是否在事务中的标志、应该观察变化的表列表(在我们的例子中只是<code class="du kr ks kt ku b">word_table</code>)和一个<code class="du kr ks kt ku b">Callback</code>。<code class="du kr ks kt ku b">Callback.call()</code>包含要触发的查询的实现。</p><p id="95ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们检查<code class="du kr ks kt ku b">CoroutinesRoom.createFlow()</code> <a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:room/ktx/src/main/java/androidx/room/CoroutinesRoom.kt;l=99?q=CoroutinesRoom" rel="noopener ugc nofollow" target="_blank">实现</a>，我们会看到这里查询调用也被移动到不同的<code class="du kr ks kt ku b">CoroutineContext</code>。与插入调用一样，这个调度程序是从构建数据库时提供的执行器派生出来的，或者默认情况下将使用架构组件IO执行器。</p><h1 id="aafc" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建数据库</h1><p id="1a8a" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们已经定义了要存储在数据库中的数据以及如何访问它，现在是时候定义数据库本身了。为此，我们创建一个扩展了<code class="du kr ks kt ku b">RoomDatabase</code>的抽象类，用<code class="du kr ks kt ku b">@Database</code>对其进行注释，传入<code class="du kr ks kt ku b">Word</code>作为要存储的实体，1作为数据库版本。</p><p id="9ca6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将定义一个返回<code class="du kr ks kt ku b">WordDao</code>的抽象方法。一切都是抽象的，因为房间是为我们生成实现的地方。像这样，有许多逻辑我们不再需要实现。</p><p id="9631" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">剩下的唯一一步是构建数据库。我们希望确保不会同时打开多个数据库实例，并且我们需要应用程序上下文来初始化数据库。因此，处理这个问题的一种方法是在我们的类的伴生对象中定义一个RoomDatabase实例，以及一个构建数据库的getDatabase函数。如果我们希望在不同于由Room创建的IO执行器的执行器上执行Room查询，我们可以通过调用<code class="du kr ks kt ku b"><a class="ae jn" href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder#setQueryExecutor(java.util.concurrent.Executor)" rel="noopener ugc nofollow" target="_blank">setQueryExecutor()</a></code>在构建器中传递它。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="a419" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">测试道</h1><p id="e73f" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了测试Dao，我们需要实现一个<code class="du kr ks kt ku b">AndroidJUnit</code>测试，因为Room在设备上创建了一个SQLite数据库。</p><p id="799d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当实现Dao测试时，在每个测试运行之前，我们创建数据库。在每个测试运行之后，我们关闭数据库。由于我们不需要将数据保存在设备上，因此在创建数据库时，我们可以使用内存中的数据库。由于这是一个测试，我们可以允许查询在主线程上运行。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="7784" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了测试单词是否成功插入，我们将创建一个单词，插入它，从按字母顺序排列的单词列表中获取第一个单词，并确保它与我们创建的单词相同。由于我们调用暂停函数，我们将在runBlocking块中运行测试。因为这是一个测试，所以我们不介意测试是否阻塞了测试线程。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure></div><div class="ab cl lk ll go lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ha hb hc hd he"><p id="639b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Room提供了比我们所介绍的更多的功能和灵活性——您可以定义Room应该如何处理数据库冲突，您可以存储原本使用SQLite无法存储的类型，<a class="ae jn" rel="noopener" href="/androiddevelopers/room-time-2b4cf9672b98">如</a> <code class="du kr ks kt ku b"><a class="ae jn" rel="noopener" href="/androiddevelopers/room-time-2b4cf9672b98">Date</a></code>，通过创建<code class="du kr ks kt ku b">TypeConverters</code>，您可以实现复杂的查询，使用<code class="du kr ks kt ku b">JOIN</code>和其他SQL功能，<a class="ae jn" href="https://developer.android.com/training/data-storage/room/creating-views" rel="noopener ugc nofollow" target="_blank">创建数据库视图</a>，预先填充您的数据库或在创建或打开数据库时触发某些数据库操作。</p><p id="056f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看我们的<a class="ae jn" href="https://developer.android.com/training/data-storage/room" rel="noopener ugc nofollow" target="_blank">房间文档</a>了解更多信息，查看<a class="ae jn" href="https://developer.android.com/codelabs/android-room-with-a-view-kotlin" rel="noopener ugc nofollow" target="_blank">房间查看</a> codelab进行实践学习。</p></div></div>    
</body>
</html>