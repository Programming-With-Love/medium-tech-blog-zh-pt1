<html>
<head>
<title>Building Microservices: A Reactive Framework Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建微服务:反应式框架比较</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/building-microservices-a-reactive-framework-comparison-fb49d8f3c8f4?source=collection_archive---------1-----------------------#2017-11-20">https://medium.com/capital-one-tech/building-microservices-a-reactive-framework-comparison-fb49d8f3c8f4?source=collection_archive---------1-----------------------#2017-11-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/11d16b256ee51d339713804f2d79a970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uetkjlOgqSpevJ4Nf8OssQ.png"/></div></div></figure><p id="58ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们大多数人都听说过关于<a class="ae jn" rel="noopener" href="/capital-one-tech/delivering-microservices-for-enterprise-with-devops-fd253a6c2f1e">微服务</a>及其好处的传言。在之前的一篇文章中，我讨论了<a class="ae jn" rel="noopener" href="/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c">微服务</a>，以及在实现它们时什么时候编排与反应可能是有意义的。如果你选择反击，有很多选择。<a class="ae jn" rel="noopener" href="/capital-one-developers/being-proactively-reactive-7e112abf1579">反应式编程</a>现在是一个热门话题，因为最近发布的<a class="ae jn" href="https://docs.oracle.com/javase/9/" rel="noopener ugc nofollow" target="_blank"> Java 9 </a>和<a class="ae jn" href="http://projects.spring.io/spring-framework/" rel="noopener ugc nofollow" target="_blank"> Spring Framework 5 </a>都内置了反应式功能。根据您的使用情况，反应式编程有许多附加选项。我倾向于把它们分成四个不同的类别。</p><ul class=""><li id="5fb4" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">可用于构建前端反应式应用的Javascript库，如Angular.js、React.js、Ractive.js或Node.js。</li><li id="c6f9" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">具有自然反应能力的语言。我们提到了Java 9和Spring Framework 5。其他几个(但不限于)包括Clojure、Scala和GoLang。</li><li id="da16" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">运行在JDK之上并实现反应流规范(我们将稍后讨论)的反应式框架，如<a class="ae jn" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应器</a>、<a class="ae jn" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> Akka </a>、<a class="ae jn" href="http://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>和<a class="ae jn" href="https://ratpack.io/" rel="noopener ugc nofollow" target="_blank"> Ratpack </a>。</li><li id="4b42" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">反应式扩展也称为<a class="ae jn" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>，为许多语言提供了许多反应式功能，其中最流行的是<a class="ae jn" href="https://github.com/ReactiveX/RxJava/wiki" rel="noopener ugc nofollow" target="_blank"> RxJava </a></li></ul><p id="4046" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些类别都围绕着一些关键原则。2013年，编写了<a class="ae jn" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">反应宣言</a>，确立了反应系统的四个关键原则:<strong class="ir hi"> <em class="kc">反应迅速、富有弹性、消息驱动</em> </strong>、<strong class="ir hi"> <em class="kc">和弹性</em> </strong></p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kd"><img src="../Images/e6c9e5200a0105789bb1124a448747b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*mZ65T252PYkZscy67WjR_A.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">graphic from <a class="ae jn" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank"><em class="km">https://www.reactivemanifesto.org/</em></a></figcaption></figure><p id="01e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">反应系统应该<strong class="ir hi"> <em class="kc">反应灵敏</em> </strong>这意味着它们应该总是及时做出反应。他们应该是<strong class="ir hi"> <em class="kc">有弹性的</em> </strong>这意味着当失败发生时他们应该保持响应。它们应该是<strong class="ir hi"> <em class="kc">消息驱动的</em> </strong>，并支持异步消息传递，从而在组件之间建立一个边界(这有助于保持组件的解耦和位置透明)。最后，它们应该是<strong class="ir hi"> <em class="kc">弹性的</em> </strong>以使组件能够根据工作负载需求动态伸缩，有效地利用资源。</p><p id="3fb2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2013年末，关于<a class="ae jn" href="http://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank">反应流</a>规范的另一项关键工作开始了。该规范的主要好处是它使实现它的反应库具有互操作性。具体来说，它允许跨库边界组合序列、取消和反压力，同时允许最终用户根据需要在实现之间切换。Reactive Streams于2015年4月发布，2017年成为<a class="ae jn" href="http://download.java.net/java/jdk9/docs/api/java/util/concurrent/Flow.html" rel="noopener ugc nofollow" target="_blank"> JDK9 </a>的一部分。有几个反应式框架运行在JDK之上并实现反应流规范，例如<a class="ae jn" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应堆</a>、<a class="ae jn" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> Akka </a>、<a class="ae jn" href="http://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>和<a class="ae jn" href="https://ratpack.io/" rel="noopener ugc nofollow" target="_blank"> Ratpack </a>。</p><p id="0231" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据openhub.net的消息，Akka在2009年首次提交，Vert.x和Reactor在2013年，Ratpack在2014年。Akka和Vert.x是两种常用的反应式框架，运行在JDK之上。让我们更深入地了解这两者，并从以下几个方面对它们进行比较/对比:</p><ul class=""><li id="9513" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">微服务层级和内部通信</li><li id="ad80" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">交付机制和恢复能力</li><li id="e452" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">开源视角和支持的语言</li><li id="5a67" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">附加组件以及监控选项</li><li id="b30e" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">微服务层级和内部通信</li></ul><p id="cfd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">前面我提到了Reactive Manifesto的消息驱动原则，它支持微服务之间的异步消息传递。Akka和Vert.x都提供了一种内置的消息传递机制，这种机制有相似之处，也有不同之处。首先，我们应该讨论层次结构范式，因为这是两者之间的一个显著差异。</p><p id="62b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Akka是基于<a class="ae jn" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank"> actor模型</a>(由Carl Hewitt于1973年创建)构建的，它提供了一个处理并发计算的模型。在Akka中，执行单元是<em class="kc">演员</em>，你的微服务是作为演员构建的。actor是轻量级的，每GB堆内存可以有几百万个actor。actor是一个封装了状态和行为的对象，它通过交换放入收件人邮箱中的消息来进行专门的通信。下图说明了这一点。</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kn"><img src="../Images/95baecad9f0bd8f0e61c9311e937e5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*iIl2HfNjv4f7N0kufG9JQA.jpeg"/></div></figure><p id="db45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">参与者是参与者系统的一部分，可以按层次结构排列。以下是在执行元系统中创建顶级执行元的示例:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/b0004bc6ce2c16d2449844c1f7ddd54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*T1ylDB0nbfX0F6Tuch2n6g.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Example is from </em><a class="ae jn" href="http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html" rel="noopener ugc nofollow" target="_blank"><em class="km">http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html</em></a></figcaption></figure><p id="43c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着他们可以将任务分解并委派给儿童演员。子参与者受到监督，并将他们的失败委托给他们的父参与者。参与者可以以请求/响应模式(称为“询问”)或“一发即忘”模式(称为“告知”)向其他参与者发送消息。下面是一个提问的例子:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kp"><img src="../Images/5f06d2c8e66db2bed1f2eb5715fdae11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*j5qZmB9R4OfVAYEqACX3MQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Example is from </em><a class="ae jn" href="http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html" rel="noopener ugc nofollow" target="_blank"><em class="km">http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html</em></a></figcaption></figure><p id="0fc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个例子:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/92bb6bbb4e61ca5051a2b9ac6639590e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*Zo-xqPf_aFQBznSl0Nx3mw.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Example is from </em><a class="ae jn" href="http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html" rel="noopener ugc nofollow" target="_blank"><em class="km">http://doc.akka.io/docs/akka/current/java/guide/tutorial_2.html</em></a></figcaption></figure><p id="dca3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Vert.x基于扁平的层次结构，不实现actor模型。相反，它基于事件循环模型。这是从Akka发出呼叫的第一个不同之处。</p><p id="3554" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Vert.x中的执行单位被称为<em class="kc">垂直</em>。它通过事件循环处理传入的事件，这在异步编程模型中很典型。下图说明了这一点:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kr"><img src="../Images/378bfad8a4f392aba0751960647382e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*U2A90pZvDxbB1EuUGZ0xcw.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Diagram is from </em><a class="ae jn" href="http://vertx.io/docs/guide-for-java-devs/" rel="noopener ugc nofollow" target="_blank"><em class="km">http://vertx.io/docs/guide-for-java-devs/</em></a></figcaption></figure><p id="3ac1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们看看代码:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/a936091c39df420f1732420054e5b7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*ZwdPxowwZ0FWRh6Zr1QI5Q.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">Example is from <a class="ae jn" href="http://vertx.io/docs/guide-for-java-devs/" rel="noopener ugc nofollow" target="_blank">http://vertx.io/docs/guide-for-java-devs/</a></figcaption></figure><p id="6784" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个verticle被传递配置信息，并且可以被多次部署，如下所示:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es kt"><img src="../Images/c440da8d3f8a4ab0efce18e11bbd2a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*KYj5ORYj7g9uZva8JdxVIQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Diagram is from </em><a class="ae jn" href="http://vertx.io/docs/guide-for-java-devs/" rel="noopener ugc nofollow" target="_blank"><em class="km">http://vertx.io/docs/guide-for-java-devs/</em></a></figcaption></figure><p id="1f6d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与Akka一样，Vert.x通过事件总线提供了一种内部消息传递机制，这是垂直企业通过异步消息传递进行通信的方式:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es ku"><img src="../Images/95140ca26ae1958afa2333f607e3b4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*ev1H5wM9mh4BwnrrziVYww.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Diagram is from </em><a class="ae jn" href="http://vertx.io/docs/guide-for-java-devs/" rel="noopener ugc nofollow" target="_blank"><em class="km">http://vertx.io/docs/guide-for-java-devs/</em></a></figcaption></figure><p id="2b33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">垂直对象如何通信是Akka和Vert.x之间的另一个区别。在Akka中，参与者之间的交互可以通过ask和tell方法进行，这是点对点的，这意味着参与者必须知道它想要向谁发送消息。Akka也有现成的发布和订阅功能，它使用EventStream结构。发布和订阅意味着消息可以发布到事件流，而发布者不知道谁将接收消息。在这种方法中，参与者订阅等同于对象(在Java中)的通道，因此参与者指定一个特定的类来接收该类或子类的任何消息。</p><p id="cb62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与Akka类似，Vert.x也支持点对点和发布-订阅模式。区别在于Vert.x的消息传递是语言不可知的，使用JSON来传递数据，而Akka使用Scala或Java中的特定对象。此外，Akka中的订户需要知道它想要接收的对象的类别，而在Vert.x中这是不必要的。下面是一个Vert.x示例:</p><h2 id="4e0b" class="kv kw hh bd kx ky kz la lb lc ld le lf ja lg lh li je lj lk ll ji lm ln lo lp bi translated">注册事件处理程序:</h2><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/12a543770dc585bde0852296d612732b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9FYCEDfgzfNTxNL6PsKCA.png"/></div></div></figure><h2 id="65ab" class="kv kw hh bd kx ky kz la lb lc ld le lf ja lg lh li je lj lk ll ji lm ln lo lp bi translated">发件人:</h2><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/e119ee4f7784312a1623c5b184caf9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUzYhq8invjwS0u53Wts-w.png"/></div></div></figure><h2 id="2012" class="kv kw hh bd kx ky kz la lb lc ld le lf ja lg lh li je lj lk ll ji lm ln lo lp bi translated">接收者:</h2><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/f8afa0563f2c5475557cd61aefd7e887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1O3OgpCpnq-56I4NchcdQ.png"/></div></div></figure><h1 id="7b96" class="lt kw hh bd kx lu lv lw lb lx ly lz lf ma mb mc li md me mf ll mg mh mi lo mj bi translated">交付机制和恢复能力</h1><p id="a46b" class="pw-post-body-paragraph ip iq hh ir b is mk iu iv iw ml iy iz ja mm jc jd je mn jg jh ji mo jk jl jm ha bi translated">有弹性是反应宣言中的另一个原则。从故障状态中恢复并在此期间继续响应的能力有多强？</p><p id="e954" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Akka提供了一个称为Akka持久性的附加组件，可用于存储参与者的内部状态。这使得参与者的状态可以在崩溃时恢复。Akka持久性使用一种<a class="ae jn" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank">事件源</a>模式，将参与者状态的任何变化存储在事件存储中。事件存储中的事件是不可变的。通过重放事件存储中的事件来恢复参与者。</p><p id="a487" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个来自<a class="ae jn" href="http://doc.akka.io/docs/akka/current/java/persistence.html?_ga=2.152741241.1329911211.1506458416-1980958307.1504904637" rel="noopener ugc nofollow" target="_blank"> akka.io网站</a>的Akka持久性示例，该网站使用<em class="kc"> AbstractPersistentActor </em>类支持事件源。persist方法由一个actor使用，该actor扩展此类来持久保存和处理事件。该行为通过实现<em class="kc"> createReceiveRecover </em>和<em class="kc"> createReceive来定义。</em></p><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/50ce5cffedc1ca432f48152abebb73a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFIMJqwi2fJLq9ENgah3XQ.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">code example from <a class="ae jn" href="https://doc.akka.io/docs/akka/current/java/persistence.html" rel="noopener ugc nofollow" target="_blank">https://doc.akka.io/docs/akka/current/java/persistence.html</a></figcaption></figure><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/f1ff3bf860a1f8b93754fc3e028f9918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fL_jgGcfg64zi_OClplaGg.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">code example from <a class="ae jn" href="https://doc.akka.io/docs/akka/current/java/persistence.html" rel="noopener ugc nofollow" target="_blank">https://doc.akka.io/docs/akka/current/java/persistence.html</a></figcaption></figure><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/e6deb9af7a0fcde3a63f4fdfb87eb8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVEU7aSIx-AUHuNlpfuxWA.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">code example from <a class="ae jn" href="https://doc.akka.io/docs/akka/current/java/persistence.html" rel="noopener ugc nofollow" target="_blank">https://doc.akka.io/docs/akka/current/java/persistence.html</a></figcaption></figure><p id="c2f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前，Vert.x不提供开箱即用的恢复功能。从消息传递可靠性的角度来看，Akka最多提供一次开箱即用，并且在利用Akka持久性时至少提供一次。与Akka类似，Vert.x最多提供一次，但不提供至少一次的功能。最多一次意味着数据可能会丢失。至少传递一次保证消息至少传递一次。</p><p id="26f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从消息排序的角度来看，当一个参与者使用tell操作符直接向另一个参与者发送消息时，Akka可以保证消息排序。如果有多个参与者向同一个目的地发送消息，它们将按发送者排序，但没有全局排序保证。Vert.x还将按照从特定发件人发送消息的顺序将消息传递给任何处理程序。</p><h1 id="d090" class="lt kw hh bd kx lu lv lw lb lx ly lz lf ma mb mc li md me mf ll mg mh mi lo mj bi translated">开源视角和支持的语言</h1><p id="d44c" class="pw-post-body-paragraph ip iq hh ir b is mk iu iv iw ml iy iz ja mm jc jd je mn jg jh ji mo jk jl jm ha bi translated">Akka和Vert.x都是开源项目。Akka支持Scala和Java，而Vert.x支持Java、Groovy、Ruby、JavaScript、Ceylon、Scala和Kotlin。</p><p id="307b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从成熟度的角度来看，Akka已经存在了最长时间，从2009年开始，到本文发表时已经8.5岁了。Vert.x始于2013年，本文发表时大约4岁。<a class="ae jn" href="https://akka.io/team/" rel="noopener ugc nofollow" target="_blank"> Lightbend </a>是为Akka提供核心贡献者的主要公司，而<a class="ae jn" href="http://vertx.io/community/" rel="noopener ugc nofollow" target="_blank"> RedHat </a>有许多全职开发人员在Vert.x上工作。</p><p id="ba66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">截至2017年9月，Akka在openhub.net上的活跃程度非常高，去年有1554次提交，共有601名贡献者:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/de891eef94a3e61aef89a22e817ce84e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*oLULwKisKyDny1Dx28udNQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">dashboard from openhub.net</figcaption></figure><p id="1a15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Vert.x也非常活跃，去年提交了704项，共有124名贡献者:</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/891f191fae189b7ddf42dadb0efa16b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*M9_csrISEWx9giIofXK2CA.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">dashboard from openhub.net</figcaption></figure><h1 id="f9ae" class="lt kw hh bd kx lu lv lw lb lx ly lz lf ma mb mc li md me mf ll mg mh mi lo mj bi translated">附加组件和监控选项</h1><p id="7cfb" class="pw-post-body-paragraph ip iq hh ir b is mk iu iv iw ml iy iz ja mm jc jd je mn jg jh ji mo jk jl jm ha bi translated">前面我提到了Akka持久性组件，它可以用于额外的恢复功能。Akka还具有附加组件，包括但不限于Akka集群和Akka流。Akka聚类有助于参与者的位置透明性。如果一个参与者需要向另一个参与者发送消息，它使用ID(而不是actor ref ), Akka集群负责将消息路由到正确的集群。如果一个参与者死亡，集群将负责重新启动该参与者。Akka Streams是对Akka actors的流抽象。Dean Wampler有一个比较Akka流和其他流技术的演示。他提到这有利于低延迟和复杂的事件处理用例。就每秒可以处理的消息数量而言，Akka Streams可以处理非常大的容量，并且它对工作负载的并行化有很好的支持，但它不支持像Spark和Flink那样的分布式物化。对于Vert.x，没有任何附加组件。</p><p id="5b05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从监控的角度来看，<a class="ae jn" href="https://www.datadoghq.com/lpg/?utm_source=Advertisement&amp;utm_medium=GoogleAdsBrand&amp;utm_campaign=GoogleAdsBrand-US&amp;utm_content=Datadog&amp;utm_keyword=%7Bkeyword%7D&amp;utm_matchtype=%7Bmatchtype%7D&amp;gclid=Cj0KCQjwjdLOBRCkARIsAFj5-GAnW2ktbP58e6Fq9n5IpGMhTmtVgfsGcwxYymvQ_qTQqXP5bx_rAAcaAqPAEALw_wcB" rel="noopener ugc nofollow" target="_blank"> DataDog </a>(见下面截图)和<a class="ae jn" href="https://developer.lightbend.com/docs/opsclarity/latest/home.html" rel="noopener ugc nofollow" target="_blank"> OpsClarity </a>至少是监控Akka的两种选择。</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es mu"><img src="../Images/eb1b0221f8fdd494536aed354c87bd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*5HaVrq1FWFGKl8I7SFjuSg.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Diagram taken from </em><a class="ae jn" href="https://www.datadoghq.com/blog/monitor-lightbend/" rel="noopener ugc nofollow" target="_blank"><em class="km">https://www.datadoghq.com/blog/monitor-lightbend/</em></a></figcaption></figure><p id="922a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Vert.x，有几个选项，包括<a class="ae jn" href="http://vertx.io/docs/vertx-hawkular-metrics/java/" rel="noopener ugc nofollow" target="_blank"> Hawkular </a>(见下面截图)和<a class="ae jn" href="http://vertx.io/docs/vertx-dropwizard-metrics/java/" rel="noopener ugc nofollow" target="_blank"> DropWizard </a> (JMX)。</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/941b09ce0250bac032ab069dcff33b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*_VzuVoZ4RnPt3ONB7PpXyw.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx"><em class="km">Diagram taken from </em><a class="ae jn" href="https://github.com/pilhuhn/hawkfx" rel="noopener ugc nofollow" target="_blank"><em class="km">https://github.com/pilhuhn/hawkfx</em></a></figcaption></figure><h1 id="14be" class="lt kw hh bd kx lu lv lw lb lx ly lz lf ma mb mc li md me mf ll mg mh mi lo mj bi translated">摘要</h1><p id="0d26" class="pw-post-body-paragraph ip iq hh ir b is mk iu iv iw ml iy iz ja mm jc jd je mn jg jh ji mo jk jl jm ha bi translated">在本文中，我们讨论了反应式编程的一些历史背景，同时也触及了Akka和Vert.x之间的一些相似之处和不同之处。</p><ul class=""><li id="2576" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">更喜欢为您的微服务使用参与者层次模型</li><li id="2459" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">擅长使用特定于语言的对象在参与者之间传递消息数据</li><li id="dfce" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">需要Akka持久性附带的恢复和持久性功能，以便在崩溃时可以持久化和恢复参与者的内部状态</li><li id="360b" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">如果您需要至少一次交付(Akka持久性)</li></ul><p id="dae9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一般来说，Vert.x vs. Akka的一些原因包括:</p><ul class=""><li id="50d9" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">更喜欢使用扁平的层次结构，而不是Actor模型</li><li id="5a90" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">在传递消息数据时，更喜欢使用非特定语言的JSON，而不是特定语言的对象</li><li id="3267" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">需要对Scala和Java之外的语言提供更广泛的支持(例如Groovy、Ruby、JavaScript、Ceylon、Kotlin)</li><li id="8289" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">擅长最多一次传递(这可能导致消息丢失)</li></ul><p id="ae72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你的项目的具体需求将帮助你决定哪一个是你的正确选择，我鼓励你在每个项目上做一个原型。好消息是——两者都实现了Reactive Streams规范，这意味着如果该选项对您的用例有意义，您可以一起使用它们。</p><p id="b5e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kc">注意—本文中的分析基于Akka 2.5.4和Vert.x v3.4.2 </em></p><p id="be6d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kc">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em></p><h1 id="a6ea" class="lt kw hh bd kx lu lv lw lb lx ly lz lf ma mb mc li md me mf ll mg mh mi lo mj bi translated">相关:</h1><p id="f704" class="pw-post-body-paragraph ip iq hh ir b is mk iu iv iw ml iy iz ja mm jc jd je mn jg jh ji mo jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/comparing-and-contrasting-open-source-bpm-projects-196833f23391">对比开源BPM项目</a></p><p id="97e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/microservices-when-to-react-vs-orchestrate-c6b18308a14c">微服务——何时应对，何时协调</a></p><p id="cae6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/being-proactively-reactive-7e112abf1579">主动做出反应</a></p><figure class="ke kf kg kh fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/microservices/home"><div class="er es mv"><img src="../Images/a9f346eff65776bdedf685617e2c446d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2JclrB8CYu03pOGCn4TCw.jpeg"/></div></a></figure></div></div>    
</body>
</html>