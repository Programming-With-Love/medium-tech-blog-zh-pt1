# 被遗忘的 OOP 历史

> 原文：<https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f?source=collection_archive---------1----------------------->

![](img/b5319c93f5a4237f1472d1686f5b1e6f.png)

Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)

> **注:**这是《作曲软件》系列的一部分**s**[(现在一本书！)](https://leanpub.com/composingsoftware) 从基础开始学习 JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！
> [买书](https://leanpub.com/composingsoftware) | [索引](/javascript-scene/composing-software-the-book-f31c77fc3ddc)|[|<上一张](/javascript-scene/javascript-monads-made-simple-7856be57bfe8) | [下一张>](/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381)

我们今天使用的函数式和命令式编程范式最初是在 20 世纪 30 年代用 lambda 演算和图灵机进行数学探索的，它们是通用计算的替代公式(可以执行一般计算的形式化系统)。丘奇·图灵论文表明λ演算和图灵机在功能上是等价的——任何可以用图灵机计算的东西都可以用λ演算来计算，反之亦然。

> 注意:有一种普遍的误解，认为图灵机可以计算任何可计算的东西。有几类问题(例如[停机问题](https://en.wikipedia.org/wiki/Halting_problem))在某些情况下是可以计算的，但一般情况下，使用图灵机是无法计算所有情况的。当我在本文中使用“可计算”这个词时，我的意思是“可由图灵机计算”。

Lambda 演算代表了一种自顶向下的函数应用计算方法，而图灵机的纸带/寄存器机器公式代表了一种自底向上的命令式(一步一步)计算方法。

像机器代码和汇编这样的低级语言出现在 20 世纪 40 年代，到 20 世纪 50 年代末，第一批流行的高级语言出现了。Lisp 方言今天还在通用，包括 Clojure，Scheme，AutoLISP 等。FORTRAN 和 COBOL 都出现在 20 世纪 50 年代，是今天仍在使用的命令式高级语言的例子，尽管对于大多数应用程序来说，C 族语言已经取代了 COBOL 和 FORTRAN。

命令式编程和函数式编程都源于计算理论的数学，早于数字计算机。“面向对象编程”(OOP)是由 Alan Kay 大约在 1966 年或 1967 年在读研究生时创造的。

伊凡·苏泽兰开创性的画板应用程序是 OOP 的早期灵感。它创作于 1961 年至 1962 年之间，并于 1963 年发表在他的[画板论文](https://dspace.mit.edu/handle/1721.1/14979)中。这些对象是表示显示在示波器屏幕上的图形图像的数据结构，并通过动态委托表现出继承性，伊凡·苏泽兰在他的论文中称之为“主人”。任何对象都可以成为“主对象”，对象的其他实例称为“事件”。Sketchpad 的 masters 与 JavaScript 的原型继承有很多共同之处。

> **注:**麻省理工学院林肯实验室的 TX-2 是早期使用的图形计算机显示器之一，它使用光笔进行直接屏幕交互。EDSAC 在 1948-1958 年间运行，可以在屏幕上显示图形。麻省理工学院的旋风在 1949 年有一个工作的示波器显示器。该项目的动机是创造一个通用的飞行模拟器，能够模拟多架飞机的仪表反馈。这导致了 SAGE 计算系统的开发。[TX-2 是 SAGE](http://www.computerhistory.org/revolution/real-time-computing/6/123) 的测试电脑。

第一种被广泛认为是“面向对象”的编程语言是 Simula，于 1965 年指定。像画板一样，Simula 以对象为特色，并最终引入了类、类继承、子类和虚方法。

> 注意:**虚拟方法**是定义在一个类上的方法，它被设计成被子类覆盖。虚拟方法允许程序调用在编译代码时可能不存在的方法，通过使用动态分派来确定在运行时调用什么具体方法。JavaScript 以动态类型为特色，并使用委托链来确定调用哪些方法，因此不需要向程序员公开虚方法的概念。换句话说，JavaScript 中的所有方法都使用运行时方法分派，因此 JavaScript 中的方法不需要声明为“虚拟”来支持该特性。

# 伟大的想法

> “我创造了‘面向对象’这个术语，我可以告诉你我脑子里没有 C++”~艾伦·凯，OOPSLA '97

Alan Kay 于 1966 年或 1967 年在研究生院创造了“面向对象编程”这个术语。最重要的想法是在软件中使用封装的微型计算机，通过信息传递而不是直接的数据共享进行通信——以停止将程序分解成单独的“数据结构”和“过程”。

"递归设计的基本原则是使各部分具有与整体相同的能力."~ Bob Barton，B5000 的主要设计师，b 5000 是一种为运行 Algol-60 而优化的大型机。

Smalltalk 是由艾伦·凯、丹·英格尔斯、阿黛尔·戈德堡和施乐 PARC 公司的其他人开发的。Smalltalk 比 Simula 更面向对象——small talk 中的一切都是对象，包括类、整数和块(闭包)。最初的 Smalltalk-72 没有子类化功能。这是丹·英格尔斯在 Smalltalk-76 中介绍的。

虽然 Smalltalk 支持类并最终支持子类化，但 Smalltalk 并不涉及类或子类化。这是一种受 Lisp 和 Simula 启发的函数式语言。Alan Kay 认为业界对子类化的关注分散了对面向对象编程真正好处的关注。

> 很抱歉，我很久以前就为这个主题创造了“对象”这个术语，因为它让许多人关注次要的概念。最重要的想法是信息传递。”
> ~艾伦·凯

在 2003 年的一次电子邮件交流中，艾伦·凯澄清了他称 Smalltalk 为“面向对象”的意思:

> “对我来说，OOP 只意味着消息传递、本地保留、保护和隐藏状态流程，以及所有东西的极端后期绑定。”
> ~艾伦·凯

换句话说，根据 Alan Kay 的说法，OOP 的基本成分是:

*   信息传递
*   包装
*   动态绑定

值得注意的是，艾伦·凯并不认为继承和子类多态性是 OOP 的基本组成部分，他创造了这个术语并把 OOP 带给了大众。

# 面向对象的本质

消息传递和封装的结合有一些重要的目的:

*   通过封装状态和将其他对象与本地状态变化隔离来避免共享的可变状态。影响另一个对象状态的唯一方法是通过发送消息来请求(而不是命令)该对象改变它。状态变化在本地、细胞水平上被控制，而不是暴露给共享访问。
*   **将**对象彼此解耦——消息发送者只是通过消息传递 API 松散地耦合到消息接收者。
*   **通过后期绑定对运行时变化的适应性和弹性**。运行时适应性提供了许多 Alan Kay 认为对 OOP 至关重要的好处。

这些想法是通过 Alan Kay 的生物学背景和 Arpanet(互联网的早期版本)的设计影响，从生物细胞和/或网络上的个人计算机中受到启发的。甚至在早期，艾伦·凯就设想了在一台巨大的分布式计算机(互联网)上运行的软件，其中各个计算机就像生物细胞一样，在它们自己孤立的状态下独立运行，并通过消息传递进行通信。

> “我意识到细胞/整台计算机的比喻将摆脱数据[…]”
> ~艾伦·凯

通过“摆脱数据”，Alan Kay 肯定意识到了共享可变状态问题和由共享数据引起的紧密耦合——这是当今常见的主题。

但是在 20 世纪 60 年代后期，ARPA 的程序员感到沮丧，因为他们需要在构建软件之前为他们的程序选择一个数据模型表示。与特定数据结构耦合过紧的过程无法适应变化。他们希望对数据进行更加同质的处理。

> “[……]OOP 的全部意义在于不必担心对象内部的内容。在不同的机器上用不同的语言制造的物体应该能够互相交谈[…]”~艾伦·凯

对象可以抽象并隐藏数据结构实现。对象的内部实现可以改变，而不会破坏软件系统的其他部分。事实上，通过极端的后期绑定，一个完全不同的计算机系统可以接管一个对象的职责，而软件可以继续工作。同时，对象可以公开一个标准接口，该接口可以处理对象内部碰巧使用的任何数据结构。同一个接口可以处理链表、树、流等等。

艾伦·凯也将对象视为代数结构，这为它们的行为提供了某些数学上可证明的保证:

> “我的数学背景让我意识到，每个对象都可能有几个与之相关的代数，可能有几个代数族，这些代数将非常非常有用。”
> ~艾伦·凯

这已被证明是正确的，并形成了承诺和透镜等物体的基础，这两者都是由范畴理论启发的。

Alan Kay 对对象的设想的代数本质将允许对象提供形式验证、确定性行为和改进的可测试性，因为代数本质上是遵循方程形式的一些规则的运算。

在程序员的行话中，代数就像是由函数(运算)组成的抽象，伴随着由那些函数必须通过的单元测试强制执行的特定法则(公理/方程)。

这些想法在大多数 C 族面向对象语言中被遗忘了几十年，包括 C++、Java、C#等。，但是它们开始在最广泛使用的 OO 语言的最新版本中找到自己的路。

你可能会说，编程世界正在重新发现面向对象语言环境中函数式编程和理性思维的好处。

和之前的 JavaScript 和 Smalltalk 一样，大多数现代 OO 语言越来越成为“多范式语言”。没有理由在函数式编程和 OOP 之间做出选择。当我们审视各自的历史本质时，它们不仅是兼容的，而且是互补的思想。

因为它们有如此多的共同点，我喜欢说 JavaScript 是 Smalltalk 对世界误解 OOP 的报复。Smalltalk 和 JavaScript 都支持:

*   目标
*   一级函数和闭包
*   动态类型
*   后期绑定(运行时函数/方法可变)
*   无类继承的 OOP

面向对象程序设计的本质是什么(根据艾伦·凯)？

*   包装
*   信息传递
*   动态绑定(程序在运行时进化/适应的能力)

什么是非必要的？

*   班级
*   类继承
*   对象/功能/数据的特殊处理
*   `new`关键字
*   多态性
*   静态类型
*   将类识别为“类型”

如果您的背景是 Java 或 C#，您可能会认为静态类型和多态是必不可少的成分，但是 Alan Kay 更喜欢以代数形式处理一般行为。例如，来自 Haskell 的:

```
fmap :: (a -> b) -> f a -> f b
```

这是仿函数映射签名，它一般作用于未指定的类型`a`和`b`，在`a`的仿函数的上下文中应用从`a`到`b`的函数来产生`b`的仿函数。Functor 是数学术语，本质上意味着“支持映射操作”。如果你熟悉 JavaScript 中的`[].map()`，你应该已经知道这是什么意思了。

以下是 JavaScript 中的两个例子:

```
// isEven = Number => Boolean
const isEven = n => n % 2 === 0;const nums = [1, 2, 3, 4, 5, 6];// map takes a function `a => b` and an array of `a`s (via `this`)
// and returns an array of `b`s.
// in this case, `a` is `Number` and `b` is `Boolean`
const results = nums.map(isEven);console.log(results);
// [false, true, false, true, false, true]
```

`.map()`方法是通用的，因为`a`和`b`可以是任何类型，并且`.map()`处理得很好，因为数组是实现代数`functor`法则的数据结构。类型对`.map()`来说无关紧要，因为它并不试图直接操纵它们，而是应用一个函数来期望并返回应用程序的正确类型。

```
// matches = a => Boolean
// here, `a` can be any comparable type
const matches = control => input => input === control;const strings = ['foo', 'bar', 'baz'];const results = strings.map(matches('bar'));console.log(results);
// [false, true, false]
```

在 TypeScript 这样的语言中，这种泛型类型关系很难正确和彻底地表达，但在 Haskell 的 Hindley Milner 类型中，通过对更高级类型(类型的类型)的支持，这种关系很容易表达。

大多数类型系统限制太多，不允许自由表达动态和功能思想，如函数组合、自由对象组合、运行时对象扩展、组合子、透镜等。换句话说，静态类型经常使编写可组合软件变得更加困难。

如果你的类型系统限制太多(例如，TypeScript，Java)，你就不得不写更多复杂的代码来实现同样的目标。这并不意味着静态类型是个坏主意，也不意味着所有的静态类型实现都具有同等的限制性。我遇到的 Haskell 类型系统的问题要少得多。

如果您是静态类型的粉丝，并且不介意这些限制，那么您将获得更多的权力，但是如果您发现本文中的一些建议很难，因为很难对组合函数和组合代数结构进行类型化，那么请责怪类型系统，而不是思想。人们喜欢他们的 SUV 的舒适，但没有人抱怨他们不让你飞。为此，你需要一辆自由度更高的车。

如果限制让你的代码更简单，那太好了！但是如果限制迫使你写更复杂的代码，也许限制是错误的。

# 什么是对象？

这些年来，物品显然有了很多内涵。我们在 JavaScript 中称之为“对象”的只是复合数据类型，与基于类的编程或 Alan Kay 的消息传递没有任何关系。

在 JavaScript 中，这些对象可以并且经常支持封装、消息传递、通过方法的行为共享，甚至子类多态性(尽管使用委托链而不是基于类型的分派)。您可以将任何功能分配给任何属性。您可以动态构建对象行为，并在运行时更改对象的含义。JavaScript 还支持使用闭包来实现隐私的封装。但所有这些都是选择加入的行为。

我们目前对对象的概念仅仅是一个复合数据结构，不需要更多的东西就可以被认为是对象。但是，使用这些类型的对象进行编程并不会使您的代码“面向对象”，就像使用函数进行编程不会使您的代码“函数化”一样。

## 面向对象不再是真正的面向对象

因为“对象”在现代编程语言中的意义远不如它对 Alan Kay 的意义，所以我用“组件”而不是“对象”来描述真正 OOP 的规则。很多*对象*被 JavaScript 中的其他代码直接拥有和操纵，但是**组件**要封装和控制自己的状态。

真正的面向对象意味着:

*   用**组件**编程(艾伦·凯的“对象”)
*   组件状态必须被封装
*   使用消息传递进行对象间通信
*   可以在运行时添加/更改/替换组件

大多数组件行为都可以用代数数据结构来描述。这里不需要继承。组件可以重用共享函数和模块化导入中的行为，而无需共享它们的数据。

在 JavaScript 中操作*对象*或使用*类继承*并不意味着你在“做 OOP”。以这种方式使用组件*可以。*但是流行的用法是如何定义单词，所以也许我们应该放弃面向对象编程，称之为“面向消息编程(MOP)”而不是“面向对象编程(OOP)”。

拖把被用来收拾残局是巧合吗？

# 什么样的拖把是好的

在大多数现代软件中，有一些 UI 负责管理用户交互，一些代码管理应用程序状态(用户数据)，还有一些代码管理系统或网络 I/O。

这些系统中的每一个都可能需要长期存在的进程，比如事件侦听器、状态来跟踪诸如网络连接、ui 元素状态和应用程序状态本身之类的事情。

好的 MOP 意味着系统通过消息调度与其他组件进行通信，而不是所有这些系统相互联系并直接操纵彼此的状态。当用户点击保存按钮时，可能会发送一条`"SAVE"`消息，应用程序状态组件可能会解释这条消息并将其传递给状态更新处理程序(比如一个纯粹的 reducer 函数)。也许在状态更新后，状态组件可能会向 UI 组件发送一条`"STATE_UPDATED"`消息，UI 组件将依次解释状态，协调 UI 的哪些部分需要更新，并将更新后的状态传递给处理 UI 的这些部分的子组件。

同时，网络连接组件可能正在监视用户与网络上另一台机器的连接，监听消息，并调度更新的状态表示以在远程机器上保存数据。它在内部跟踪网络心跳计时器，不管连接当前是在线还是离线，等等。

这些系统不需要知道系统其他部分的细节。只关心他们个人的，模块化的问题。系统组件是可分解和可重组的。他们实现了标准化的接口，以便能够进行互操作。只要接口令人满意，您就可以用不同方式做相同事情的替代物，或者用相同的消息做完全不同的事情。您甚至可以在运行时这样做，一切都会正常工作。

同一软件系统的组件甚至不需要位于同一台机器上。该系统可以是分散的。网络存储可能会在像 [IPFS](https://en.wikipedia.org/wiki/InterPlanetary_File_System) 这样的分散存储系统中共享数据，这样用户就不需要依赖任何特定机器的健康状况来确保他们的数据得到安全备份，并且不会被黑客窃取。

OOP 部分受到 Arpanet 的启发，Arpanet 的目标之一是建立一个分散的网络，可以抵御像原子弹这样的攻击。据阿帕网开发期间 DARPA 主任斯蒂芬·j·卢卡西克([“为什么要建阿帕网”](https://ieeexplore.ieee.org/document/5432117)):

> 目标是利用新的计算机技术来满足军事指挥和控制核威胁的需要，实现对美国核力量的生存控制，并改进军事战术和管理决策。

***注:****Arpanet 最初的推动力是便利而非核威胁，其明显的防御优势是后来才显现出来的。ARPA 使用三台独立的计算机终端与三个独立的计算机研究项目进行通信。鲍勃·泰勒想要一个单一的计算机网络将每个项目与其他项目连接起来。*

一个好的 MOP 系统可能会在应用程序运行时使用可热插拔的组件来共享互联网的健壮性。如果用户使用手机，但由于进入隧道而离线，它仍可以继续工作。如果飓风破坏了服务器所在的一个数据中心的电源，它可以继续工作。

软件世界是时候放下失败的类继承实验，拥抱最初定义 OOP 精神的数学和科学原则了。

现在是我们开始构建更灵活、更有弹性、更好组合的软件的时候了，让 MOP 和函数式编程和谐地工作。

> 注意:首字母缩写词 MOP 已经被用来描述“面向监控的编程”,它不太可能出现的 OOP 将会悄然消失。
> 
> 如果 MOP 没有作为编程行话流行起来，不要沮丧。一定要把你的脏东西擦干净。

# 在 EricElliottJS.com 了解更多信息

EricElliottJS.com 的会员可以上函数式编程的视频课。如果你还不是会员，今天就注册吧。

***Eric Elliott*** *是一位分布式系统专家，著有以下书籍:* [*【排版软件】*](https://leanpub.com/composingsoftware)*[*【编程 JavaScript 应用】*](http://pjabook.com) *。作为*[*devanywhere . io*](https://devanywhere.io)*的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，为 Adobe Systems、* ***、Zumba Fitness、*** ***、华尔街日报、*******【ESPN、*******BBC、*** *以及包括* ***亚瑟、弗兰克·奥申、金属乐队在内的顶级录音艺术家提供软件体验******

**他和世界上最美丽的女人享受着与世隔绝的生活方式。**