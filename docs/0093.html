<html>
<head>
<title>React Native at Airbnb: The Technology</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb的本土反应:技术</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838?source=collection_archive---------0-----------------------#2018-06-19">https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838?source=collection_archive---------0-----------------------#2018-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b9a5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">技术细节</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/4e8230b713c13a127ca0830f6423e078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaYan0f1NeQlzGnwzjXEvg.jpeg"/></div></div></figure><p id="b0ed" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">这是</em> <a class="ae kf" rel="noopener" href="/airbnb-engineering/react-native-at-airbnb-f95aa460be1c"> <em class="ke">系列博文</em> </a> <em class="ke">中的第二篇，在这篇博文中，我们概述了React Native的体验以及Airbnb的下一步移动应用。</em></p><p id="bddf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Android、iOS、web和跨平台框架的交叉领域中，React Native本身是一个相对较新且发展较快的平台。两年后，我们可以有把握地说，React Native在许多方面都是革命性的。这是移动领域的一次范式转变，我们能够从它的许多目标中获益。然而，它的好处并非没有重大的痛点。</p><h1 id="5ae2" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">什么效果好</h1><h2 id="4775" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">跨平台</h2><p id="8781" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native的主要好处是，您编写的代码可以在Android和iOS上本地运行。使用React Native的大多数特性能够实现<em class="ke">95–100%共享代码</em>和<em class="ke"> 0.2%的文件是特定于平台的</em> (*.android.js/*.ios.js)。</p><h2 id="63d2" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">统一设计语言系统(DLS)</h2><p id="fa7a" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们开发了一种跨平台的设计语言，叫做<a class="ae kf" href="https://airbnb.design/building-a-visual-language/" rel="noopener ugc nofollow" target="_blank"> DLS </a>。我们有每个组件的Android、iOS、React Native和web版本。拥有统一的设计语言有助于编写跨平台的特性，因为这意味着设计、组件名称和屏幕在不同的平台上是一致的。然而，我们仍然能够在适用的情况下做出适合平台的决策。例如，我们使用Android上的原生<a class="ae kf" href="https://developer.android.com/reference/android/support/v7/widget/Toolbar" rel="noopener ugc nofollow" target="_blank">工具栏</a>和iOS上的<a class="ae kf" href="https://developer.apple.com/documentation/uikit/uinavigationbar" rel="noopener ugc nofollow" target="_blank"> UINavigationBar </a>，我们选择隐藏Android上的<a class="ae kf" href="https://developer.apple.com/ios/human-interface-guidelines/views/tables/" rel="noopener ugc nofollow" target="_blank">披露指示器</a>，因为它们不符合Android平台设计指南。</p><p id="2a18" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们选择重写组件，而不是包装原生组件，因为为每个平台单独制作适合平台的API更可靠，并减少了Android和iOS工程师的维护开销，他们可能不知道如何正确测试React Native中的更改。然而，它确实导致了平台之间的碎片化，其中同一组件的本地版本和反应本地版本会不同步。</p><h2 id="8c53" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">反应</h2><p id="0db2" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React是最受欢迎的web框架是有原因的。它简单而强大，可以很好地扩展到大型代码库。我们特别喜欢的一些东西是:</p><ul class=""><li id="aefb" class="lr ls hh jk b jl jm jo jp jr lt jv lu jz lv kd lw lx ly lz bi translated"><strong class="jk hi">组件:</strong> React组件通过定义良好的属性和状态来加强关注点的分离。这是React可伸缩性的主要贡献者。</li><li id="3193" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated"><strong class="jk hi">简化的生命周期:</strong> Android的生命周期以及在较小程度上iOS的生命周期是出了名的<a class="ae kf" href="https://i.stack.imgur.com/fRxIQ.png" rel="noopener ugc nofollow" target="_blank">复杂</a>。功能性的reactive React组件从根本上解决了这个问题，使得学习React Native比学习Android或iOS简单得多。</li><li id="170f" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">声明性的:React的声明性本质有助于我们的UI与底层状态保持同步。</li></ul><h2 id="3ccc" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">迭代速度</h2><p id="44c8" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">在React Native中开发时，我们能够可靠地使用<a class="ae kf" href="https://facebook.github.io/react-native/blog/2016/03/24/introducing-hot-reloading.html" rel="noopener ugc nofollow" target="_blank">热重装</a>在短短一两秒钟内测试我们在Android和iOS上的更改。尽管构建性能是我们原生应用的重中之重，但它从未接近我们使用React Native实现的迭代速度。在最好的情况下，本机编译时间为15秒，但对于完整版本，可能高达20分钟。</p><h2 id="637f" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">投资基础设施</h2><p id="d3d4" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们开发了与本地基础设施的广泛集成。所有的核心部分，比如网络、i18n、实验、共享元素转换、设备信息、帐户信息以及其他许多内容都被封装在一个React Native API中。这些桥是一些更复杂的部分，因为我们希望将现有的Android和iOS APIs包装成对React一致和规范的东西。虽然使这些桥与新基础设施的快速迭代和开发保持同步是一个不断追赶的游戏，但是基础设施团队的投资使产品工作变得更加容易。</p><p id="7ff6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果没有在基础设施上的大量投资，React Native将会导致低劣的开发人员和用户体验。因此，我们认为，如果没有大量持续的投资，React Native不能简单地附加到现有的应用程序上。</p><h2 id="6904" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">表演</h2><p id="c21f" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native最大的问题之一是它的性能。然而，在实践中，这很少成为问题。我们大多数的React原生屏幕感觉和我们的原生屏幕一样流畅。性能通常被认为是一个单一的维度。我们经常看到移动工程师看着JS，认为“比Java慢”。然而，在许多情况下，将业务逻辑和<a class="ae kf" href="https://github.com/facebook/yoga" rel="noopener ugc nofollow" target="_blank">布局</a>移出主线程实际上会提高渲染性能。</p><p id="97f3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们确实看到性能问题时，它们通常是由过度渲染引起的，并通过有效使用<a class="ae kf" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank"> shouldComponentUpdate </a>、<a class="ae kf" href="https://facebook.github.io/react-native/docs/view.html#removeclippedsubviews" rel="noopener ugc nofollow" target="_blank"> removeClippedSubviews </a>以及更好地使用Redux来缓解。</p><p id="57de" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，初始化和首次渲染时间(如下所述)使得React Native在启动屏幕、深度链接方面表现不佳，并且增加了在屏幕之间导航时的TTI时间。此外，丢帧的屏幕很难调试，因为<a class="ae kf" href="https://github.com/facebook/yoga" rel="noopener ugc nofollow" target="_blank"> Yoga </a>在React本地组件和本地视图之间转换。</p><h2 id="9a95" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">Redux</h2><p id="68fe" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们使用<a class="ae kf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>进行状态管理，我们发现这很有效，可以防止UI与状态不同步，并支持跨屏幕的轻松数据共享。然而，Redux因其样板文件而臭名昭著，并且具有相对困难的学习曲线。我们为一些常见的模板提供了生成器，但在使用React Native时，这仍然是最具挑战性的部分之一，也是混乱的来源。值得注意的是，这些挑战并不是本地特有的。</p><h2 id="e5ab" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">由本地人支持</h2><p id="b88e" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">因为React Native中的一切都可以通过本机代码来桥接，所以我们最终能够构建许多我们在开始时不确定是否可行的东西，例如:</p><ol class=""><li id="b8e1" class="lr ls hh jk b jl jm jo jp jr lt jv lu jz lv kd mf lx ly lz bi translated"><em class="ke">共享元素转换</em>:我们构建了一个<em class="ke">&lt;Shared element&gt;</em>组件，它由Android和iOS上的原生共享元素代码支持。这甚至可以在本机屏幕和React本机屏幕之间工作。</li><li id="e223" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd mf lx ly lz bi translated"><em class="ke"> Lottie: </em>我们能够通过包装Android和iOS上的现有库，让Lottie在React Native中工作。</li><li id="f4b0" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd mf lx ly lz bi translated"><em class="ke">原生网络堆栈:</em> React Native在两个平台上都使用我们现有的原生网络堆栈和缓存。</li><li id="040a" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd mf lx ly lz bi translated"><em class="ke">其他核心基础设施:</em>就像网络一样，我们包装了现有的本地基础设施，如i18n、experimentation等。以便在React Native中无缝工作。</li></ol><h2 id="cc6f" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">静态分析</h2><p id="89c0" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们在网络上使用eslint 有很长的历史，我们能够利用这一点。然而，我们是Airbnb的第一个平台，开创了T2更漂亮的T3。我们发现它能有效减少PRs上的虱卵和自行车脱落。我们的网络基础设施团队正在积极调查Prettier。</p><p id="797e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们还使用分析来测量渲染时间和性能，以确定哪些屏幕是调查性能问题的重中之重。</p><p id="1f3a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为React Native比我们的web基础设施更小更新，所以它被证明是新想法的一个很好的试验台。我们为React Native创建的许多工具和想法正在被web now采用。</p><h2 id="faf4" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">动画片</h2><p id="7835" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">感谢React Native <a class="ae kf" href="https://facebook.github.io/react-native/docs/animated.html" rel="noopener ugc nofollow" target="_blank">动画</a>库，我们能够实现无jank动画，甚至交互驱动的动画，如滚动视差。</p><h2 id="2072" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">JS/React开源</h2><p id="218f" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">因为React Native真正运行React和javascript，所以我们能够利用极其大量的javascript项目，如redux、reselect、jest等。</p><h2 id="f11a" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">Flexbox</h2><p id="56c8" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">react Native handles layout with<a class="ae kf" href="https://github.com/facebook/yoga" rel="noopener ugc nofollow" target="_blank">Yoga</a>，一个跨平台C库，通过<a class="ae kf" href="https://www.w3schools.com/css/css3_flexbox.asp" rel="noopener ugc nofollow" target="_blank"> flexbox </a> API处理布局计算。在早期，我们遇到了Yoga的局限性，比如缺乏长宽比，但在随后的更新中已经添加了这些限制。此外，像<a class="ae kf" href="https://flexboxfroggy.com/" rel="noopener ugc nofollow" target="_blank"> flexbox froggy </a>这样有趣的教程让入职变得更加愉快。</p><h2 id="1064" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">与网络协作</h2><p id="4b2b" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">在React Native探索的后期，我们开始同时为web、iOS和Android构建。考虑到web也使用Redux，我们发现大量代码可以在web和本地平台之间共享，而无需修改。</p><h1 id="f291" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">哪些地方做得不好</h1><h2 id="27c3" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">反应天生的不成熟</h2><p id="df5f" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native不如Android或iOS成熟。它更新换代，雄心勃勃，发展速度极快。虽然React Native在大多数情况下都工作得很好，但在某些情况下，它的不成熟会让一些在Native中无关紧要的事情变得非常困难。不幸的是，这些情况很难预测，可能需要几个小时到几天才能解决。</p><h2 id="b2ac" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">维护React Native的分支</h2><p id="d8a8" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">由于React Native的不成熟，有时我们需要修补React Native的源代码。除了对React Native作出贡献，我们还必须<a class="ae kf" href="https://github.com/airbnb/react-native/commits/0.46-canary" rel="noopener ugc nofollow" target="_blank">维护一个分支</a>,在其中我们可以快速合并更改并修改我们的版本。两年来，我们不得不在React Native上添加大约50个提交。这使得React Native的升级过程极其痛苦。</p><h2 id="c7f5" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">JavaScript工具</h2><p id="a4ed" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">JavaScript是一种非类型语言。缺乏类型安全不仅难以扩展，而且成为习惯于类型化语言的移动工程师的争论点，否则他们可能会对学习React Native感兴趣。我们探索了采用<a class="ae kf" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流程</a>，但是神秘的错误信息导致了令人沮丧的开发体验。我们也探索了<a class="ae kf" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，但是将它集成到我们现有的基础设施中，例如<a class="ae kf" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>和<a class="ae kf" href="https://github.com/facebook/metro" rel="noopener ugc nofollow" target="_blank"> metro bundler </a>被证明是有问题的。然而，我们正在继续积极研究网络上的类型脚本。</p><h2 id="89df" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">重构</h2><p id="40de" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">JavaScript无类型化的一个副作用是重构极其困难并且容易出错。重命名道具，尤其是像<em class="ke"> onClick </em>这样有一个普通名字的道具，或者是通过多个组件传递的道具，对于精确重构来说是一场噩梦。更糟糕的是，重构在生产中而不是在编译时中断，并且很难添加适当的静态分析。</p><h2 id="59ae" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">JavaScriptCore不一致</h2><p id="3cbf" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native的一个微妙和棘手之处在于它是在一个<a class="ae kf" href="https://facebook.github.io/react-native/docs/javascript-environment.html" rel="noopener ugc nofollow" target="_blank"> JavaScriptCore环境</a>上执行的。以下是我们遇到的结果:</p><ul class=""><li id="8985" class="lr ls hh jk b jl jm jo jp jr lt jv lu jz lv kd lw lx ly lz bi translated">iOS自带开箱即用的<a class="ae kf" href="https://developer.apple.com/documentation/javascriptcore" rel="noopener ugc nofollow" target="_blank">JavaScript core</a>。这意味着iOS基本上是一致的，对我们来说没有问题。</li><li id="eaac" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">Android没有自己的JavaScriptCore，所以React Native有自己的包。但是，你默认得到的<a class="ae kf" href="https://github.com/facebook/react-native/issues/10245" rel="noopener ugc nofollow" target="_blank">是古代的</a>。结果，我们不得不特意捆绑一个<a class="ae kf" href="https://github.com/react-community/jsc-android-buildscripts" rel="noopener ugc nofollow" target="_blank">更新的</a>。</li><li id="657f" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">调试时，React Native会附加到一个Chrome开发者工具实例。这很棒，因为它是一个强大的调试器。然而，一旦附加了调试器，所有的JavaScript都在Chrome的V8引擎中运行。这在99.9%的情况下都没问题。然而，在一个例子中，当toLocaleString在iOS上工作，但在调试时只在Android上工作时，我们被咬了一口。事实证明，Android JSC <a class="ae kf" href="https://github.com/facebook/react-native/issues/15717" rel="noopener ugc nofollow" target="_blank">不包括它</a>，它会静静地失败，除非你在调试，在这种情况下，它使用的是V8。如果不知道这样的技术细节，对于产品工程师来说，这可能会导致几天痛苦的调试。</li></ul><h2 id="4cd1" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">React原生开源库</h2><p id="5803" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">学习一个平台既困难又费时。大多数人只对一两个平台比较了解。React拥有地图、视频等原生桥梁的原生库。需要对所有三个平台有相同的了解才能成功。我们发现大多数React原生开源项目是由只有一两个经验的人编写的。这导致了Android或iOS上的不一致或意想不到的错误。</p><p id="d2f3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Android上，许多React原生库也要求您使用node_modules的相对路径，而不是发布与社区预期不一致的maven工件。</p><h2 id="b699" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">并行基础设施和功能工作</h2><p id="a74a" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们在Android和iOS上积累了多年的原生基础设施。然而，在React Native中，我们从一张白纸开始，必须编写或创建所有现有基础架构的桥梁。这意味着有时产品工程师需要一些尚不存在的功能。在这一点上，他们要么不得不在他们不熟悉的平台上工作，并且在他们的项目范围之外来构建它，要么被阻止直到它可以被创建。</p><h2 id="988c" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">碰撞监控</h2><p id="57eb" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们使用<a class="ae kf" href="https://www.bugsnag.com/" rel="noopener ugc nofollow" target="_blank"> Bugsnag </a>在Android和iOS上进行崩溃报告。虽然我们能够在两个平台上正常工作，但它不太可靠，而且比在我们的其他平台上需要更多的工作。因为React Native在行业中相对较新且罕见，所以我们必须构建大量的基础设施，例如在内部上传源地图，并且必须与Bugsnag合作，以便能够通过React Native中发生的事件来过滤崩溃。</p><p id="b8dc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于React Native周围的定制基础设施的数量，我们偶尔会遇到严重的问题，其中没有报告崩溃或没有正确上传源代码。</p><p id="676a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后，如果问题跨越React本机和本机代码，调试React本机崩溃通常更具挑战性，因为堆栈跟踪不会在React本机和本机代码之间跳转。</p><h2 id="992a" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">本地桥</h2><p id="e5a9" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native有一个<a class="ae kf" href="https://facebook.github.io/react-native/docs/communication-ios.html" rel="noopener ugc nofollow" target="_blank">桥API </a>在Native和React Native之间进行通信。虽然它像预期的那样工作，但是写起来非常麻烦。首先，它需要正确设置所有三个开发环境。我们也经历了许多问题，来自JavaScript的类型是意想不到的。例如，整数通常由字符串包装，这个问题直到通过桥才被意识到。更糟糕的是，有时iOS会无声无息地失败，而Android会崩溃。我们在2017年底开始研究从TypeScript定义自动生成桥代码，但为时已晚。</p><h2 id="e53d" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">初始化时间</h2><p id="fcc8" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">在React Native可以第一次渲染之前，你必须初始化它的运行时。不幸的是，对于我们这种规模的应用来说，这需要几秒钟，即使是在高端设备上。这使得对启动屏幕使用React Native几乎是不可能的。我们通过在应用启动时初始化React Native，最大限度地缩短了它的首次渲染时间。</p><h2 id="2ad6" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">初始渲染时间</h2><p id="0d13" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">与原生屏幕不同，React Native需要至少一个完整的主线程-&gt; js -&gt; yoga layout线程-&gt;主线程往返，才能有足够的信息来第一次渲染一个屏幕。我们在iOS上看到的平均初始p90渲染时间为280毫秒，在Android上为440毫秒。在Android上，我们使用了通常用于共享元素转换的<a class="ae kf" href="https://developer.android.com/reference/android/app/Activity.html#postponeEnterTransition()" rel="noopener ugc nofollow" target="_blank">延迟界面转换</a> API来延迟显示屏幕，直到它被渲染。在iOS上，我们遇到了从React Native设置navbar配置不够快的问题。因此，我们为所有React本机屏幕转换添加了50毫秒的人工延迟，以防止配置加载后导航条闪烁。</p><h2 id="1d50" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">应用程序大小</h2><p id="e045" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native对app大小也有不可忽视的影响。在Android上，React Native (Java + JS +本机库，如Yoga + Javascript Runtime)的总大小为每个ABI 8mb。如果在一个APK中同时包含x86和arm(仅32位),它应该接近12mb。</p><h2 id="ad42" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">64位</h2><p id="7bbc" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">由于T4的这个问题，我们仍然不能在Android上发布64位APK。</p><h2 id="2083" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">手势</h2><p id="0f79" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们避免对涉及复杂手势的屏幕使用React Native，因为Android和iOS的触摸子系统差异很大，为整个React Native社区提供统一的API一直是一个挑战。然而，工作仍在继续进行中，而<a class="ae kf" href="https://github.com/kmagiera/react-native-gesture-handler" rel="noopener ugc nofollow" target="_blank">react-native-手势处理器</a>刚刚发布了1.0。</p><h2 id="5221" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">长长的名单</h2><p id="a899" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">React Native在这方面取得了一些进展，推出了像<a class="ae kf" href="https://facebook.github.io/react-native/docs/flatlist.html" rel="noopener ugc nofollow" target="_blank"> FlatList </a>这样的库。然而，它们远没有Android上的<a class="ae kf" href="https://developer.android.com/guide/topics/ui/layout/recyclerview" rel="noopener ugc nofollow" target="_blank">recycle view</a>或iOS上的<a class="ae kf" href="https://developer.apple.com/documentation/uikit/uicollectionview" rel="noopener ugc nofollow" target="_blank"> UICollectionView </a>成熟和灵活。由于螺纹的原因，许多限制很难克服。适配器数据不能被同步访问，因此当视图在快速滚动时异步呈现时，可以看到视图闪烁。文本也不能同步测量，因此iOS无法使用预先计算的单元格高度进行某些优化。</p><h2 id="0981" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">升级React Native</h2><p id="e502" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">尽管大多数React原生升级都是微不足道的，但也有一些升级是痛苦的。特别是，使用React Native 0.43(2017年4月)到0.49(2017年10月)几乎是不可能的，因为它使用了React 16 alpha和beta。这是一个很大的问题，因为大多数为web使用而设计的React库不支持预发布的React版本。为这次升级争论适当的依赖关系的过程是2017年年中其他React原生基础设施工作的主要损害。</p><h2 id="7d3f" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">易接近</h2><p id="d078" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">2017年，我们进行了一次重大的<a class="ae kf" href="https://airbnb.design/designing-for-access/" rel="noopener ugc nofollow" target="_blank">无障碍改造</a>，我们投入了巨大的努力，以确保残疾人可以使用Airbnb预订能够满足他们需求的房源。然而，React本机可访问性API中有许多漏洞。为了满足最低可接受的可访问性要求，我们不得不<a class="ae kf" href="https://github.com/airbnb/react-native/commits/0.46-canary" rel="noopener ugc nofollow" target="_blank">维护我们自己的React Native分支</a>，在那里我们可以合并修复。对于这些情况，Android或iOS上的一行修复程序最终花了几天时间来弄清楚如何将它添加到React Native，挑选它，然后在React Native core上提交一个问题，并在未来几周内跟进。</p><h2 id="b58e" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">麻烦的撞车事故</h2><p id="cd0f" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">我们不得不处理一些很难修复的非常奇怪的崩溃。例如，我们目前正在经历<a class="ae kf" href="https://issuetracker.google.com/issues/37045084" rel="noopener ugc nofollow" target="_blank">这个关于<em class="ke"> @ReactProp </em>注释的崩溃</a>，并且已经无法在任何设备上重现它，甚至是那些与在野外崩溃的设备具有相同硬件和软件的设备。</p><h2 id="bd4c" class="ky kh hh bd ki kz la lb km lc ld le kq jr lf lg ks jv lh li ku jz lj lk kw ll bi translated">Android上跨进程保存的实例</h2><p id="6068" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">Android经常清理后台进程，但是给它们一个机会<a class="ae kf" href="https://developer.android.com/topic/libraries/architecture/saving-states#use_onsaveinstancestate_as_backup_to_handle_system_initiated_process_death" rel="noopener ugc nofollow" target="_blank">同步保存它们的状态在一个包</a>中。然而，在React Native上，所有状态只能在js线程中访问，所以这不能同步完成。即使不是这种情况，redux作为一个状态存储也与这种方法不兼容，因为它混合了可序列化和不可序列化的数据，并且可能包含比savedInstanceState捆绑包中所能容纳的更多的数据，这将导致生产中的<a class="ae kf" rel="noopener" href="/@mdmasudparvez/android-os-transactiontoolargeexception-on-nougat-solved-3b6e30597345">崩溃</a>。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="a114" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是一系列博客文章的第二部分，重点介绍了我们使用React Native的体验以及Airbnb的下一步移动应用。</p><ul class=""><li id="bf7c" class="lr ls hh jk b jl jm jo jp jr lt jv lu jz lv kd lw lx ly lz bi translated"><a class="ae kf" rel="noopener" href="/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">第一部分:在Airbnb上反应本土</a></li><li id="9d01" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated"><a class="ae kf" rel="noopener" href="/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838"> <em class="ke">第二部分:技术</em> </a></li><li id="13f5" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated"><a class="ae kf" rel="noopener" href="/airbnb-engineering/building-a-cross-platform-mobile-team-3e1837b40a88">第3部分:建立跨平台移动团队</a></li><li id="5fa0" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated"><a class="ae kf" rel="noopener" href="/airbnb-engineering/sunsetting-react-native-1868ba28e30a">第4部分:做出反应原生的决定</a></li><li id="e178" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated"><a class="ae kf" rel="noopener" href="/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab">第五部分:手机的下一步是什么</a></li></ul></div></div>    
</body>
</html>