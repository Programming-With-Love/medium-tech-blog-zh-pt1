<html>
<head>
<title>Cross data center replication in Solr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solr中的跨数据中心复制</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/cross-dc-replication-in-solr-df8881ab1a9d?source=collection_archive---------1-----------------------#2021-06-09">https://medium.com/walmartglobaltech/cross-dc-replication-in-solr-df8881ab1a9d?source=collection_archive---------1-----------------------#2021-06-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4298" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">跨DC(数据中心)复制是指在不同DC独立运行的一个或多个Solr集群中的数据保持同步的过程。这实质上意味着，如果一个Solr集群中出现更新，它会在其他Solr集群中传播或可用，以便Solr集群之间的搜索结果是一致的。</p><h1 id="4a0e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">Solr中需要跨DC复制</h1><p id="6576" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">以下是Solr中需要跨DC复制的一些原因:</p><p id="8617" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">灾难恢复</strong>:如果某个特定的数据中心因任何原因停机/不可用，最好有一个不同的数据中心可用并保持同步，这样应用程序就可以故障转移到新的数据中心，而不会出现长时间的停机。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/5925206e54dc5e960105dd6e0e0dc96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXhpjNge-4Yy8B8O-r0w9w.png"/></div></div></figure><p id="01dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">减少延迟</strong>:在分布式服务中，您可能希望客户端应用程序通过减少搜索延迟来连接到地理位置更近的Solr集群。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kr"><img src="../Images/ad9a1656f49f6ad892662c4f46969551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKszdtBfyvMuARN4HX3fjw.png"/></div></div></figure><h1 id="2f05" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">Solr中实现跨DC复制的方法</strong></h1><ol class=""><li id="52e2" class="ks kt hh ig b ih ka il kb ip ku it kv ix kw jb kx ky kz la bi translated">Solr进行的跨DC复制:Solr进行的跨DC复制有很多错误，而且由于它的设计方式而非常不稳定。这个特性已经被弃用，并将在Solr 9.0中被移除。Solr的《CDCR建筑》<a class="ae lb" href="https://solr.apache.org/guide/8_6/cdcr-architecture.html" rel="noopener ugc nofollow" target="_blank">参见</a>。有关问题详情<a class="ae lb" href="https://yonik.com/solr-cross-data-center-replication/" rel="noopener ugc nofollow" target="_blank">，请参考</a></li><li id="a6df" class="ks kt hh ig b ih lc il ld ip le it lf ix lg jb kx ky kz la bi translated"><strong class="ig hi">使用队列的跨DC复制</strong>:</li></ol><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lh"><img src="../Images/c94fa18bb819b427ef590026a5ba7306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZRHXfmfVJ_4JyhmNZJpKw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">This diagram shows 1 way replication assuming 1 active DC</figcaption></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lm"><img src="../Images/1d09b41fea550ff448f86540e26cf128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8pdyEm3S62mzs6OYzgfgA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">The above diagram shows N way replication assuming 1 active DC</figcaption></figure><p id="bece" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法有助于通过N路复制进行设置。一些重要的组件如下:</p><ul class=""><li id="4969" class="ks kt hh ig b ih ii il im ip ln it lo ix lp jb lq ky kz la bi translated"><strong class="ig hi">更新请求处理器链</strong>:源自客户端应用程序的所有更新请求都经过更新请求处理链，并且仅当文档是新记录或者文档的版本高于集群中的现有版本时，它才接受/插入文档。它还发送队列中的请求，然后根据配置将请求复制到N个数据中心。</li><li id="bdea" class="ks kt hh ig b ih lc il ld ip le it lf ix lg jb lq ky kz la bi translated"><strong class="ig hi">跨DC消费者应用程序</strong>:该应用程序从目的地队列中读取数据，并提交给目的地Solr集群。它还处理失败时向目标队列的重新提交。</li><li id="d6ac" class="ks kt hh ig b ih lc il ld ip le it lf ix lg jb lq ky kz la bi translated"><strong class="ig hi">处理删除</strong>:在设置了CDCR的情况下，删除数据有点棘手，因为您不希望意外删除的数据被复制并从其他数据中心删除。因此，在此设置中,“按查询删除”请求被禁用,“按id删除”请求被转换为“更新”请求，该请求将相关联的文档标记为已删除，因此它不会出现在任何搜索结果中。设置单独的作业来清理这些标记为已删除的文档。</li><li id="17c1" class="ks kt hh ig b ih lc il ld ip le it lf ix lg jb lq ky kz la bi translated"><strong class="ig hi">不一致检测</strong>:检测DC之间的数据不一致很重要，以确保Solr集群之间的搜索结果一致。在检查文档数量的同时，检查Solr集群之间文档id和版本的组合是否一致也很重要。为了修复检测到的不一致，可以有单独的作业来完成。关于不一致性检测和修复的更多细节将在单独的博客中介绍。</li><li id="33c2" class="ks kt hh ig b ih lc il ld ip le it lf ix lg jb lq ky kz la bi translated"><strong class="ig hi">失败条件</strong>:如果负责将写入同步到另一个DC队列的源队列由于任何原因不可用，这不会影响发生在源Solr DC上的写入，因为只有异步事件侦听器会接收到失败，并且事件侦听器的失败请求也会被写入一个单独的队列。</li></ul><p id="16e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。基于客户端的多写</strong>:保持两个Solr DC同步的另一种方法是客户端应用程序对两个DC进行多写。在这里，客户端应用程序负责将数据写入两个DC。客户端应用程序管理请求失败和重试。这种方法有许多挑战，其中一些是客户的重复工作，需要一种方法来检查一致性，并在发现不一致的情况下发出警报，在1 DC不可用时进行处理。此外，在提供托管服务时，客户/顾客总是希望由平台来处理数据复制。</p><h1 id="666d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">摘要</h1><p id="614e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">使用队列设置跨DC复制有助于以可伸缩的方式在多个Solr集群之间设置N路复制。</p></div></div>    
</body>
</html>