<html>
<head>
<title>Leetcode — Casual to Competitor’s Guide to DFS + Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">leet code——不符合竞争对手的DFS +记忆指南</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/leetcode-casual-to-competitors-guide-to-dfs-memoization-3667cdbabf68?source=collection_archive---------2-----------------------#2020-05-12">https://medium.com/quick-code/leetcode-casual-to-competitors-guide-to-dfs-memoization-3667cdbabf68?source=collection_archive---------2-----------------------#2020-05-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/b09e7c7946ffb0d1c7509d854b65415d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DENauUixUf2DS-VfgKCXlA.png"/></div></figure><div class=""/><h1 id="bc05" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">什么？</h1><p id="4c1b" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><strong class="jl hp">记忆是保存计算值的技术</strong></p><h1 id="653b" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">什么时候？</strong></h1><p id="68d5" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">当我们想要保存一个函数的特定输入的计算值时，我们使用记忆化，因为我们知道我们将需要再次计算那个输入。例如，如果我计算F(1) = 10，那么我们可以把它保存在某个地方，这样当有人问我F(1)是什么时，我们可以不做任何计算就给他。</p><h1 id="31a4" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">为什么？</h1><p id="cd55" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">记忆大大降低了算法的时间复杂度。有时很难看出它减少了多少运行时间，但它确实减少了。</p><h1 id="e6ab" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">怎么会？</h1><p id="82db" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">让我们深入下面的例子，看看有的<strong class="jl hp">和没有记忆</strong>的<strong class="jl hp">的相同问题的解决方案</strong></p><h1 id="c940" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">139.移行点</h1><p id="6534" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><a class="ae kh" href="https://leetcode.com/problems/word-break/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/word-break/</a></p><h1 id="4923" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">问题:</h1><p id="a937" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">给定一个<strong class="jl hp">非空</strong>字符串<em class="ki"> s </em>和一个包含一系列<strong class="jl hp">非空</strong>单词的字典<em class="ki"> wordDict </em>，确定<em class="ki"> s </em>是否可以分割成一个或多个字典单词的空格分隔序列。</p><p id="5f48" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">注:</strong></p><ul class=""><li id="a15a" class="ko kp ho jl b jm kj jq kk ju kq jy kr kc ks kg kt ku kv kw bi translated">词典中的同一个单词可以在分段中重复使用多次。</li><li id="652e" class="ko kp ho jl b jm kx jq ky ju kz jy la kc lb kg kt ku kv kw bi translated">你可以假设字典中没有重复的单词。</li></ul><p id="0df7" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">例1 <br/>输入:<br/></strong>s =<code class="du lc ld le lf b">catsanddog</code><br/>word dict =<code class="du lc ld le lf b">["cat", "cats", "and", "sand", "dog"]</code><br/><strong class="jl hp">输出:<br/> </strong> <code class="du lc ld le lf b">[<br/> "cats and dog",<br/> "cat sand dog"<br/>]</code></p><h1 id="b07a" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">解决方案:(无记忆)</h1><p id="f720" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><strong class="jl hp">暴力部队DFS-o(n * 2^n):</strong></p><p id="d309" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">我们可以通过尝试从0到I的每次拆分，并更新当前字符串来解决这个问题。例如，对于热狗，我们可以将其分解为以下内容:</p><p id="5151" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">DFS(热狗)分解成…<br/>h→otdog<br/>ho→tdog<br/>hot→dog<br/>hotd→og<br/>hotdo→g<br/>hotdog→</p><p id="c08c" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">我们首先检查左边的单词是否是有效的词典单词。如果不是，那就不要递归。然而，如果是，我们在右边的单词中再次调用DFS。基本情况是</p><ol class=""><li id="fa41" class="ko kp ho jl b jm kj jq kk ju kq jy kr kc ks kg lg ku kv kw bi translated">整个字符串都是一个有效的单词→可以断词</li><li id="9b31" class="ko kp ho jl b jm kx jq ky ju kz jy la kc lb kg lg ku kv kw bi translated">字符串的长度=1，并且不是有效的单词→这种递归是不可能的</li></ol><p id="8566" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">时间复杂度:</strong>我们可以通过下面的归约来分析我们分成子串单词的次数。假设给我们一个长度为n的单词，我们可以把这个单词分成n-1部分。所以我们可以决定拆分单词的选择数是2^n-1，因为我们可以在那个分区拆分它，也可以不拆分。此外，在大多数编程语言中，substring()方法的时间是O(N ),所以总复杂度是O(n * 2^n)</p><p id="f284" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">DFS+记忆化:O(N)时间+ O(N)空间</strong></p><p id="2157" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">提醒</strong>:记忆是一种我们缓存(存储)计算值的技术。例如，如果我们计算了<strong class="jl hp"> word_break(dog) </strong>，那么记忆它将意味着把它保存在某个地方，例如在一个hashmap或一个带有键值的数组中:“dog”-&gt;true</p><p id="16bd" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">在你知道你可以使用记忆化之前，要检查的一件事是我们是否多次解决了相同的子问题。让我们看看能否在这个问题中使用记忆化。</p><p id="0ba6" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">当我们调用DFS(hotdog)时，我们的一些递归调用是DFS(otdog)和DFS(dog)。但是，注意，当我们调用DFS(otdog)时，这最后也是从DFS(otdog)→check _ if _ word(ot)&amp; &amp; DFS(dog)求解DFS(dog)。这是这个问题需要记忆的主要暗示。</p><p id="5bb7" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">现在让我们记住:</p><ul class=""><li id="0fc0" class="ko kp ho jl b jm kj jq kk ju kq jy kr kc ks kg kt ku kv kw bi translated"><strong class="jl hp">步骤1 </strong> : <strong class="jl hp">定义状态</strong> —我们需要定义一种有效的方式来表示计算出的值。比如我们应该如何存储DFS(狗)？是否应该做一个string - &gt; boolean的hashmap？这听起来不错，但是存储每个子串听起来效率很低。因为我们知道DFS调用的每个子串都是原始字符串的后缀，所以我们可以只用一个数字来表示状态。我们用整数来定义吧。我们将定义我们的int[]数组，名为DP[]，定义DP[i]如下:I表示从索引I到原字符串结束索引的子串。DP[i] =我们是否能破解这个单词的布尔值</li><li id="99f7" class="ko kp ho jl b jm kx jq ky ju kz jy la kc lb kg kt ku kv kw bi translated"><strong class="jl hp">步骤2:编辑强力代码— </strong>这是我们定义DP[]表的地方，在每个DFS的末尾添加缓存，在每个DFS调用的开始，我们首先检查是否看到了它。我们可以通过检查DP[i]是否为空值来做到这一点。如果是，那我们以前从未见过。</li></ul><p id="244f" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">时间复杂度:</strong></p><p id="be1f" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">我们可以通过计算多少个状态来确定记忆DFS的时间复杂度。因为我们的DFS()调用接受一个整数来定义字符串的索引，并且该整数的范围可以从0到N，所以我们知道有N个状态。现在，每个DFS调用做O(N)工作，因为我们迭代每个索引，获得子串，如果可能的话递归。因此，我们的总运行时间是O(N)</p><p id="efd9" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">空间复杂度:</strong></p><p id="7b23" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">这只是我们拥有的州的数量。因为我们有N个状态，所以时间复杂度是O(N)。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="ee11" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">现在让我们试试每周竞赛188中的一个更难的问题</p><h1 id="c0dd" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">1444.切比萨饼的方法数量(硬)</h1><h1 id="7d5a" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">问题</h1><p id="b959" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">给定一个矩形披萨，表示为包含以下字符的<code class="du lc ld le lf b">rows x cols</code>矩阵:<code class="du lc ld le lf b">'A'</code>(一个苹果)和<code class="du lc ld le lf b">'.'</code>(空单元格)，并给定整数<code class="du lc ld le lf b">k</code>。你必须用<code class="du lc ld le lf b">k-1</code>刀把披萨切成<code class="du lc ld le lf b">k</code>块。</p><p id="37c1" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">对于每一次切割，您选择方向:垂直或水平，然后选择单元格边界处的切割位置，将比萨饼切成两片。如果你垂直切比萨饼，把比萨饼的左边部分给一个人。如果你横着切披萨，把披萨的上半部分给一个人。把最后一块披萨给最后一个人。</p><p id="a805" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><em class="ki">返回切披萨的方式数，这样每块披萨至少包含</em> <strong class="jl hp"> <em class="ki">个苹果。</em>由于答案可以是一个很大的数字，返回这个模1⁰⁹ + 7。</strong></p><h1 id="faab" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">解决办法</h1><p id="00a8" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><strong class="jl hp"> DFS +记忆化(更简单的动态编程)——</strong></p><p id="d727" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">这个问题求DFS +内存化/ DP。如果你不熟悉或不擅长DP，那你来对地方了。我将一步一步地解释如何在所有面试和大多数比赛中得出最优解并解决任何DP问题。让我们开始吧:</p><p id="6180" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">蛮力——回溯/DFS: (TLE): O(K*M^N) </strong>在任何类似这样的问题中，当我们被要求最小化/最大化某个数字时，我的第一直觉是首先编写一个蛮力解决方案。当然，暴力解决方案会超过时间限制(TLE ),但这是最佳解决方案的垫脚石。<br/>我们可以用下面的方式蛮力:</p><p id="6d3e" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">状态</strong>:首先，我们需要一种方式来表示我们目前的进度。在这种情况下，这就是我们正在处理的比萨饼的大小。由于比萨饼是一个矩形，我们将用左上角点和右下角点来表示当前的比萨饼切片。这是编程中用两点表示矩形的常用技巧。我们还需要记录我们削减的次数。</p><p id="8e2b" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">尝试可能的走法:</strong>根据问题，我们可能的走法是横向和纵向分割披萨。因此，我们将这样做。我们会用许多不同的方法来分割比萨饼，并在这些比萨饼切片上递归。对于水平切割，这将简单地遍历每一行，并通过在一个较小的行上重复来“切割比萨饼”。类似于垂直，但有柱。我们也</p><p id="755a" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">基础案例:</strong>如果我们切k-1次，那么我们知道我们完成了。我们只需要k个切片，所以切割k-1次意味着我们划分了正确的次数。</p><p id="5d9d" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">综合起来:</strong>我们从调用整个披萨开始，即从(0，0)到(m-1，n-1)，cut = 0。然后，我们迭代每个可能的切割，并递归这些新的比萨饼切片。我们需要跟踪的一件事是，每个切口必须包含一个苹果。要在O(1)时间内确定一个矩形是否有一个苹果，我们可以使用另一个DP表。如果不使用DP，时间复杂度会增加O(MN)，所以需要实现这个简单的表。这被称为不可变2D查询，你可以在这里查看:【https://leetcode.com/problems/range-sum-query-2d-immutable/<br/>一旦我们到达我们的基本情况，即我们已经进行了k-1次切割，我们需要检查这个矩形切片上是否有一个苹果。如果是的话，我们给全局返回变量加1。如果没有，那么就返回并在这里完成递归分支。</p><p id="c7b3" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated"><strong class="jl hp">接受:O(MNK) —带记忆的DFS:</strong></p><p id="b6fd" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">首先，我们需要做一些聪明的事情。注意我们的蛮力是如何跟踪状态的5个变量的。左上角的点，由两个变量行和列组成，右下角的点，也是另外两个变量，第五个变量，我们进行的切割次数。我们可以减少变量的数量来保持状态，通过注意到问题说，对于我们进行的每一次切割，当我们垂直切割时，我们保持右半部分，或者当我们水平切割时，保持下半部分。这意味着我们的比萨饼切片将始终包含点(m-1，n-1)，即比萨饼的右下部分。因此，没有必要再跟踪右下角的点，因为它总是(m-1，n-1)。因此，我们的新状态是左上角的点和切割数。</p><p id="e345" class="pw-post-body-paragraph jj jk ho jl b jm kj jo jp jq kk js jt ju kl jw jx jy km ka kb kc kn ke kf kg ha bi translated">现在，我们只需要将我们的DFS暴力转化为记忆。这是通过保存每个递归调用的值，并在最后返回这些递归调用的总和来实现的。我们还需要将它存储在一个全局DP表中，以缓存调用。在每次递归调用的开始，我们首先检查这个状态以前是否已经解决过。如果它已经被归还了。搞定了。你刚刚解决了问题！</p><h1 id="3fdf" class="il im ho bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">接触</h1><p id="b4a3" class="pw-post-body-paragraph jj jk ho jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">如有任何问题或代码，请发电子邮件至<strong class="jl hp">samatbryan@berkeley.edu</strong>给我！一定要给这个帖子竖起大拇指，并对未来的上传给予反馈！我通常参加leetcode比赛，所以我们会在排行榜上见面。</p></div></div>    
</body>
</html>