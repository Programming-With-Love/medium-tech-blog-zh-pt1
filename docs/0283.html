<html>
<head>
<title>Android Data Binding: Inverse Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:反函数</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-inverse-functions-95aab4b11873?source=collection_archive---------0-----------------------#2017-03-31">https://medium.com/androiddevelopers/android-data-binding-inverse-functions-95aab4b11873?source=collection_archive---------0-----------------------#2017-03-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/52858ab58aa42c4aef7506b968eb20d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*aWDwkzl32E1j4SXF3dpWUw.gif"/></div></figure><div class=""/><div class=""><h2 id="e40d" class="pw-subtitle-paragraph il hn ho bd b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc dx translated">双向转换</h2></div><p id="26b6" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">正如我之前所写的，<a class="ae jz" rel="noopener" href="/google-developers/android-data-binding-lets-flip-this-thing-dc17792d6c24#.d315my6dm">你可以绑定数据来自动设置用户输入到视图模型中</a>。例如，您可能希望绑定一个用户名，以便当用户更改它时，它可以立即在视图模型中使用:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="b793" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">EditText<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:text="@={data.firstName}"<br/>    android:textSize="16sp"</strong>/&gt;</span></pre><p id="68e3" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">当视图模型的类型与属性类型匹配时，将属性直接绑定到属性会很有效。不幸的是，情况并非总是如此。如果用户在编辑文本中输入一个数值，它不会自动转换成整数。</p><h2 id="7b18" class="kj kk ho bd kp kq kr ks kt ku kv kw kx jm ky kz la jq lb lc ld ju le lf lg lh bi translated">单向转换函数</h2><p id="85f9" class="pw-post-body-paragraph jd je ho jf b jg li ip ji jj lj is jl jm lk jo jp jq ll js jt ju lm jw jx jy ha bi translated">使用单向数据绑定，从视图模型转换到视图的属性类型非常容易——只需使用静态方法。例如:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="0921" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">TextView android:text="@{Integer.toString(user.age)}" ...</strong>/&gt;</span></pre><p id="f3ad" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">或者，您可以使用字符串串联作为快捷方式:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="b221" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">TextView android:text="@{`` + user.age}" ...</strong>/&gt;</span></pre><p id="f191" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">最好的方法可能是使用字符串格式:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="29f8" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">TextView android:text="@{@string/ageFormat(user.age)}" ...</strong>/&gt;</span></pre><p id="a9a3" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这允许格式化考虑本地化。</p><h2 id="c9f6" class="kj kk ho bd kp kq kr ks kt ku kv kw kx jm ky kz la jq lb lc ld ju le lf lg lh bi translated">双向转换</h2><p id="e439" class="pw-post-body-paragraph jd je ho jf b jg li ip ji jj lj is jl jm lk jo jp jq ll js jt ju lm jw jx jy ha bi translated">双向转换更加困难，因为静态方法没有逆方法，当然也没有任意字符串格式的转换。然而，这是一个非常常见的需求，所以增加了一些转换工具。</p><p id="1a3b" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">字符串到原语的转换非常常见，可以使用双向数据绑定表达式的字符串串联语法来完成，但只能使用空字符串:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="779a" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">EditText android:text="@={`` + user.age}" ...</strong>/&gt;</span></pre><p id="ae28" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这对于最简单的转换非常有效。有时用户输入了无效的内容(例如，空文本)，这些简单的转换通过简单地不使用无效的转换更新视图模型来处理这个问题。</p><p id="c1e9" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">很多时候，应用程序需要不同的转换。例如，您可能需要将选择整数转换为枚举。对于单向绑定，这类似于:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="32ac" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">Spinner<br/>    android:selectedItemPosition="@{Conv.toInt(user.numberType)}"<br/>    .../</strong>&gt;</span></pre><p id="e86f" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这里，<code class="du ln lo lp kf b">Conv</code>类包含:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="de22" class="kj kk ho kf b fi kl km l kn ko"><strong class="kf hp">public class </strong>Conv {<br/>    <strong class="kf hp">public static int </strong>toInt(PhoneNumberType phoneNumberType) {<br/>        <strong class="kf hp">return </strong>phoneNumberType.<strong class="kf hp">ordinal()</strong>;<br/>    }<br/>}</span></pre><p id="9c7c" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">但是当您想要使用双向转换时，您需要提供从整数转换回枚举的函数。在<a class="ae jz" href="https://developer.android.com/studio/index.html" rel="noopener ugc nofollow" target="_blank"> Android Studio 2.3 </a>中新增，你现在可以使用<code class="du ln lo lp kf b">@InverseMethod</code>注释来声明一个转换方法的逆:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="faa1" class="kj kk ho kf b fi kl km l kn ko"><strong class="kf hp">public class </strong>Conv {<br/>    @InverseMethod(<strong class="kf hp">"toPhoneNumberType"</strong>)<br/>    <strong class="kf hp">public static int </strong>toInt(PhoneNumberType phoneNumberType) {<br/>        <strong class="kf hp">return </strong>phoneNumberType.<strong class="kf hp">ordinal</strong>();<br/>    }<br/><br/>    <strong class="kf hp">public static </strong>PhoneNumberType toPhoneNumberType(<strong class="kf hp">int </strong>ordinal) {<br/>        <strong class="kf hp">return </strong>PhoneNumberType.<strong class="kf hp"><em class="lq">values</em></strong>()[ordinal];<br/>    }<br/>}</span></pre><p id="73fa" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这个表达式现在可以双向表达:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="7e07" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">Spinner<br/>    android:selectedItemPosition="@={Conv.toInt(user.numberType)}"<br/>    .../</strong>&gt;</span></pre><p id="cec1" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这里有一个稍微复杂一点的例子。假设您想要使用主语言环境来显示和解析来自EditText的double。转换函数是:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="a9c0" class="kj kk ho kf b fi kl km l kn ko"><strong class="kf hp">public class </strong>Converter {<br/>    @InverseMethod(<strong class="kf hp">"toDouble"</strong>)<br/>    <strong class="kf hp">public static </strong>String toString(TextView view, <strong class="kf hp">double </strong>oldValue,<br/>            <strong class="kf hp">double </strong>value) {<br/>        NumberFormat numberFormat = <em class="lq">getNumberFormat</em>(view);<br/>        <strong class="kf hp">try </strong>{<br/>            <em class="lq">// Don't return a different value if the parsed value<br/>            // doesn't change<br/>            </em>String inView = view.getText().toString();<br/>            <strong class="kf hp">double </strong>parsed = <br/>                numberFormat.parse(inView).doubleValue();<br/>            <strong class="kf hp">if </strong>(parsed == value) {<br/>                <strong class="kf hp">return </strong>view.getText().toString();<br/>            }<br/>        } <strong class="kf hp">catch </strong>(ParseException e) {<br/>            <em class="lq">// Old number was broken<br/>        </em>}<br/>        <strong class="kf hp">return </strong>numberFormat.format(value);<br/>    }<br/><br/>    <strong class="kf hp">public static double </strong>toDouble(TextView view, <strong class="kf hp">double </strong>oldValue,<br/>            String value) {<br/>        NumberFormat numberFormat = <em class="lq">getNumberFormat</em>(view);<br/>        <strong class="kf hp">try </strong>{<br/>            <strong class="kf hp">return </strong>numberFormat.parse(value).doubleValue();<br/>        } <strong class="kf hp">catch </strong>(ParseException e) {<br/>            Resources resources = view.getResources();<br/>            String errStr = resources.getString(R.string.<strong class="kf hp"><em class="lq">badNumber</em></strong>);<br/>            view.setError(errStr);<br/>            <strong class="kf hp">return </strong>oldValue;<br/>        }<br/>    }<br/><br/>    <strong class="kf hp">private static </strong>NumberFormat getNumberFormat(View view) {<br/>        Resources resources= view.getResources();<br/>        Locale locale = resources.getConfiguration().<strong class="kf hp">locale</strong>;<br/>        NumberFormat format = <br/>            NumberFormat.<em class="lq">getNumberInstance</em>(locale);<br/>        <strong class="kf hp">if </strong>(format <strong class="kf hp">instanceof </strong>DecimalFormat) {<br/>            DecimalFormat decimalFormat = (DecimalFormat) format;<br/>            decimalFormat.setGroupingUsed(<strong class="kf hp">false</strong>);<br/>        }<br/>        <strong class="kf hp">return </strong>format;<br/>    }<br/>}</span></pre><p id="342c" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">您会注意到转换方法有三个参数，而不是只有一个。可以传递任意数量的参数，逆方法必须接受相同数量的参数。除了转换的最后一个参数之外，所有参数及其倒数都是相同的。转换的最终参数类型(这里是double)和它的反函数的返回类型必须匹配。同样，反函数的最终参数类型(这里是String)必须与转换方法的返回类型相匹配。</p><p id="385a" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">对于双向转换，传递的其他参数是相同的。从double转换成String应该相当简单，但是<code class="du ln lo lp kf b">toString()</code>方法多做了一步。转换时，如果解析值没有变化，字符串值也不会变化。当文本为“10.0”并且用户删除“0”以使文本为“10”时解析后的值是“10 ”,并且您不希望文本在用户编辑期间更改为“10”。</p><p id="2684" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">当在<code class="du ln lo lp kf b">toString()</code>方法中没有使用时，传递<code class="du ln lo lp kf b">oldValue</code>似乎也有点奇怪。但是，该值用于逆向方法，因此也必须传递给转换方法。</p><p id="908b" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">逆方法<code class="du ln lo lp kf b">toDouble()</code>必须将字符串解析为double。值可能是无效的，我们必须警告用户。该转换器在无法解析double时在EditText上显示错误。转换器还必须返回一个double值，因此当它无法解析文本时，将返回旧的double值。</p><p id="30a4" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">使用此转换器的绑定表达式为:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="20bf" class="kj kk ho kf b fi kl km l kn ko">&lt;<strong class="kf hp">EditText<br/>    android:id="@+id/total"<br/>    android:inputType="numberDecimal"<br/>    android:text="@={Converter.toString(total, user.val, user.val)}"<br/>    ...</strong>/&gt;</span></pre><h2 id="53d4" class="kj kk ho bd kp kq kr ks kt ku kv kw kx jm ky kz la jq lb lc ld ju le lf lg lh bi translated">摘要</h2><p id="0a4c" class="pw-post-body-paragraph jd je ho jf b jg li ip ji jj lj is jl jm lk jo jp jq ll js jt ju lm jw jx jy ha bi translated">Android数据绑定提供了几种使用双向数据绑定表达式进行转换的方法。使用空字符串和一个原语连接将为您提供一个快速和肮脏的双向绑定，用于EditText。另一种方法是提供你自己的转换方法，用<code class="du ln lo lp kf b">@InverseMethod</code>标注。如上所示，逆向方法允许您在转换期间做一些非常强大的事情，包括设置错误文本。双向转换功能应该使应用程序开发更容易从用户那里获取数据。</p></div></div>    
</body>
</html>