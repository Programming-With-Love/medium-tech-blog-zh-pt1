<html>
<head>
<title>Optimizing Graphing Performance on the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Web上的图形性能</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/optimizing-graphing-performance-on-the-web-660c88753a01?source=collection_archive---------3-----------------------#2021-01-21">https://medium.com/capital-one-tech/optimizing-graphing-performance-on-the-web-660c88753a01?source=collection_archive---------3-----------------------#2021-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="46bd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我个人对终极Mandelbrot集查看器的追求</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/725b9ee981c1ea0fee35e9a5578478c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCsPb_1fqWdKNKFFWZQBFQ.png"/></div></div></figure><p id="9d9f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对我来说，作为一名工程师，我需要尝试新事物。当有一个难题要解决或者有一种新的方式来表达一个想法时，编程是有趣的。当我试图学习一种新工具时，我通常会去寻找一个我可以用它来解决的问题。不用说，当我试图为一个不熟悉的工具找一个项目时(而不是相反)，我经常以构建一些唯一积极的描述是“创造性”的东西而告终。不过，其他时候，我有一个我想做一段时间的项目，和一项我一直想学习的技术，它们意外地合作得很好。希望这是其中的一个故事。</p><p id="db7a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我决定构建一个Mandelbrot集合查看器时，并不是因为我觉得这个世界需要在已经存在的许多实现之上再多一个实现。相反，这是因为我有一个Rust/WebAssembly/Web Worker形状的钉，我想用它来工作，并且感觉Mandelbrot集是将它锤入的正确形状的孔。对我来说幸运的是，Mandelbrot集合实际上非常适合，通过我的项目，我学到了很多关于这些新技术和web性能的知识。</p><h1 id="f5b8" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">TL；博士；医生</h1><p id="3308" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">如果你想跳到最后的结果，这里是查看器:<a class="ae lb" href="https://mandelbrot.rk0.xyz/" rel="noopener ugc nofollow" target="_blank">https://mandelbrot.rk0.xyz/</a>，这里是相关的GitHub回购:【https://github.com/RyanKadri/mandelbrot-viewer】T2。</p><h1 id="0ac5" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">什么是曼德勃罗集合？</h1><p id="ea49" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><em class="lc">声明:我不是数学家。要更深入地了解曼德勃罗集，请查看</em><a class="ae lb" href="https://www.youtube.com/watch?v=FFftmWSzgmk" rel="noopener ugc nofollow" target="_blank"><em class="lc"/></a><em class="lc">。</em></p><p id="6d3b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Mandelbrot集是一个数学定义的结构，它基于一个非常简单的公式。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ld"><img src="../Images/bbf556db1da890164d04ca374e1d9aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3OnJOmsoNsE1OYCatd4EA.png"/></div></div></figure><p id="460e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">可以绘制出无限复杂的形状，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es le"><img src="../Images/6b8d5f2baec3c03cb841391fdf28ab50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aD8R_WUinGy5ge3Rm-OZw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx"><em class="lj">“Mandelbrot set” (https://en.wikipedia.org/wiki/File:Mandel_zoom_00_mandelbrot_set.jpg) by Wolfgang Beyer (https://commons.wikimedia.org/wiki/User:Wolfgangbeyer) is licensed under (CC BY-SA 3.0) (https://creativecommons.org/licenses/by-sa/3.0/deed.en)”</em></figcaption></figure><p id="6526" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你逐步放大黑色区域的边界，你会发现一个无限深的有趣拓扑特征的世界。带着探索的想法，我想建立一个基于网络的工具，受谷歌地图的启发，让用户在图中移动，放大或缩小，并玩一些算法参数，看看它们如何影响渲染。像谷歌地图，我希望用户能够点击和拖动平移，或滚动缩放。我建议使用上方的<a class="ae lb" href="http://mandelbrot.rk0.xyz/" rel="noopener ugc nofollow" target="_blank">查看器来尝试一下。</a></p><h1 id="a8e0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Mandelbrot集合是如何工作的？</h1><p id="d5a6" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">对于Mandelbrot图中的所有复杂性，它由这个简单的函数定义:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lk"><img src="../Images/7cd82fee8ab92c677a3a03ed90f0ae9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*751bLoaGuVbYf2MY3tGNtQ.png"/></div></div></figure><p id="16ab" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以及以下两个细节:</p><ol class=""><li id="c44d" class="ll lm hh jk b jl jm jo jp jr ln jv lo jz lp kd lq lr ls lt bi translated">该函数迭代应用于图形中的每个像素，像素颜色由结果决定。</li><li id="555a" class="ll lm hh jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">该函数是用复数而不是普通实数来计算的。图像中的每个像素对应于复平面中的一个点。</li></ol><p id="8b4c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">功能和这两个细节是上图中视觉复杂性的主要来源。如果你认为需要一些额外的“信息”来计算一个有如此多视觉细节的形状，你并不孤单。如此简单的规则可以产生如此有趣的结构，这一事实是研究<a class="ae lb" href="https://en.wikipedia.org/wiki/Chaos_theory" rel="noopener ugc nofollow" target="_blank">混沌理论</a>的早期灵感之一。</p><h1 id="5e5f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">复数</h1><p id="248c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><em class="lc">下面一节是对复数的概述。如果您已经熟悉这个主题，请随意跳到下一部分。</em></p><p id="f682" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">复数是具有一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Real_number" rel="noopener ugc nofollow" target="_blank">实部</a>和一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Imaginary_number" rel="noopener ugc nofollow" target="_blank">虚部</a>的数字。</p><ul class=""><li id="a98d" class="ll lm hh jk b jl jm jo jp jr ln jv lo jz lp kd lz lr ls lt bi translated"><strong class="jk hi">实数</strong>是日常生活中的正常数字。它们包括从负无穷大到正无穷大的一切，以及介于两者之间的所有分数/小数/无理数。</li><li id="14f7" class="ll lm hh jk b jl lu jo lv jr lw jv lx jz ly kd lz lr ls lt bi translated"><strong class="jk hi">虚数</strong>有点不一样。他们允许你回答问题<em class="lc">“负数的平方根是多少？”如果不清楚为什么这个问题的答案不是一个实数，试着想一个数，当它与自身相乘时是-4。虚数的基本“单位”是I，即-1的平方根。其他虚数表示为I的倍数。</em></li></ul><p id="6c32" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">a是一个实数和一个虚数的和。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ma"><img src="../Images/7d00187393c14b4d1e01ee465b592cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgLUmtB8YYRf4tyzSSGC_Q.png"/></div></div></figure><p id="2152" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从图形的角度来看，复数可以被看作是空间中的一个点。实数有一条“数字线”，而复数有一个<em class="lc">数字平面</em>。复数可以表示为复平面中的点(a，b)。横轴表示实部的大小，纵轴表示虚部的大小。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mb"><img src="../Images/ce1e50ba9ea89e3feed4023558f82306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4j-VShbvtJXWc-ZI9JgdQ.png"/></div></div></figure><p id="a39f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">复数可以加、减、乘，但是比普通的实数需要更多的思考。要将复数相加，请分别将实数部分和虚数部分相加。要乘以复数，使用<a class="ae lb" href="https://en.wikipedia.org/wiki/FOIL_method" rel="noopener ugc nofollow" target="_blank">箔片法</a>计算新的实数和复数部分。</p><p id="b52a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后，复数可以有绝对值。从图形上看，这是复平面上直线的长度，可以使用2D矢量长度的标准公式来计算:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/4c2402569068069a4f889373bfa0c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERNbJ94ezglkYbA6dmR83w.png"/></div></div></figure><h1 id="069d" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">计算Mandelbrot集</h1><p id="550d" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">要绘制Mandelbrot集，您需要遍历绘图空间中的每个像素并计算其颜色。绘图空间代表复平面中的一个矩形，绘图中的每个像素代表一个单独的复数。要决定像素的颜色，您可以使用上面的函数，为z插入0，为c插入像素的坐标，将结果作为复数值进行评估。再次进行计算，用之前的结果替换z，将c作为原始像素的坐标。像素的颜色由z的绝对值在您无限重复此过程时增长的速度决定。例如，如果c = 1，您将计算以下部分序列:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/c8b77e4d350b0e03db517797a88b90ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxt3iLk480Iggtaf9Uz6CQ.png"/></div></div></figure><p id="4c89" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，z快速增长，并且将得到代表快速增长的颜色。用c = -1做同样的计算，得到一个序列，其中z增长缓慢，并被赋予对比色。</p><p id="f53b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于我们的查看者来说，不是迭代到无穷大，我们可能会迭代序列最多500次，如果绝对值大于2，我们可以猜测输入增长很快，并且是蓝色的。缓慢增长(z永远不会大于2)将与黑色相关联。</p><p id="5434" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从这个算法转换成代码后的样子来看，有几个重要的要点:</p><ol class=""><li id="6d47" class="ll lm hh jk b jl jm jo jp jr ln jv lo jz lp kd lq lr ls lt bi translated">复数乘法需要4次乘法和3次加法。对应于发散数的像素将花费我们函数的大约500次迭代。</li><li id="efa9" class="ll lm hh jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">一个640x640的图有大约409k个像素。对于一些绘图区域，大多数坐标不会发散，需要全部500次迭代来确认。发散(并且发散很快)的像素计算起来要便宜得多。</li><li id="bea5" class="ll lm hh jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">因此，Mandelbrot集合的一些渲染可能需要数亿甚至数十亿次的算术计算。</li><li id="01c6" class="ll lm hh jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">大多数现代处理器在单个执行线程/内核中每秒最多运行约30亿条指令。因此，绘制Mandelbrot集可能是一个计算挑战。</li></ol><h1 id="54f0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">一个单纯(幼稚？)Mandelbrot集合实现</h1><p id="b361" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">为了开始这个项目，我决定同步绘制Mandelbrot集的静态图像，而不考虑性能。像一个优秀的程序员一样，我将复数建模为一个对象，其中一个字段用于实部，另一个字段用于虚部。对于复数算术，我编写了接收复数并返回新复数的纯函数。我使用绘制Mandelbrot集，因为我希望能够直接绘制像素。我最终没有引入任何复杂算术或图形的依赖项，因为我的用例易于实现，并且我希望完全控制性能的调优。</p><p id="9f12" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是我最初的Mandelbrot set实现的一个简略示例。如果你想看到完整的绘图逻辑，请查看我上面的页面:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="7db7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这省略了一些绘图逻辑，但抓住了计算Mandelbrot集的主要思想。最后的drawPixel函数调用获取迭代次数，并使用它来决定最终的像素颜色。还要注意，当复数的绝对值太大时，迭代Mandelbrot函数会短路。</p><p id="99fb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">那么，这种绘制曼德勃罗集合的初步尝试效果如何呢？上面的代码在功能上是正确的，但是需要相当长的计算时间。如果我使用这种方法在我的1080x1920显示器和MacBook Pro上绘制Mandelbrot集，在页面加载完成后，大约需要7.5秒来渲染。计时会根据您的具体硬件而有所不同，但它至少告诉我，我需要注意性能。请记住，在这个简单的实现中，所有这些计算都是同步完成的。7秒钟的同步等待总是让人感觉很慢。</p><h1 id="0370" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">改进简单的方法</h1><p id="1528" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">那么我们如何改进缓慢的天真方法呢？开发人员工具是解决web性能问题的好地方。下面是计算Mandelbrot集合时浏览器所做工作的火焰图截图。</p><p id="b24d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">如果您想进行性能故障排除，请尝试使用实时Mandelbrot查看器，选择“Naive JS ”,然后取消选中“计算工作线程”。最后，打开开发工具，在Performance选项卡中开始记录一个会话，然后点击redraw。这应该给出一个很好的性能指标，因为它完全依赖于已经下载的客户端代码。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/a3cee8c7ca0abde52860165cdb9078e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scmxUxUcTs096J3b5AF66Q.png"/></div></div></figure><p id="edc9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为一个健全的检查，这是一个很好的迹象，主要的渲染时间花在我写的函数(相对于浏览器渲染)。接下来我们要弄清楚的是浏览器大部分时间花在哪里。为此，我可以在同一个性能选项卡中查看“自下而上”视图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/1c2c2fb79cbb67079011299eff549aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEBMsQC4zksC3CyKNAkVxg.png"/></div></div></figure><p id="74eb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这种“自下而上”的观点很不寻常。对于一个7秒的计算，浏览器花费了超过3秒的时间进行垃圾收集(截图中的次要垃圾收集)。现代浏览器中的垃圾收集非常有效，通常不会花这么长时间。尽管对上面天真的实现思考得更久一点，这个结果还是很有意义的。计算Mandelbrot集涉及大量的复数运算。通过尝试遵循函数式编程实践，并使每个复数成为一个新对象，我陷入了一个巨大的性能陷阱。每一个复杂的数学运算都会产生一个新的对象，最终需要被垃圾回收。在正常的应用程序中，对象分配既便宜又快速，但是因为我创建了(多达)数亿个对象，所以它可能会增加。</p><p id="3a9c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">那么，我如何减少对象分配，从而减少垃圾收集呢？一个选择是在我的数学运算中放弃不变性的想法。例如，我的数学运算可以修改我传入的一个对象。不过，感觉有点草率。我应该修改哪个操作数？当我重构代码时，这种选择安全吗？此外，有一个叫做“加法”的数学运算，并让它修改其中一个数字，感觉是错误的。另一个操作可能是使用有点奇特的JS内存管理技术，比如<a class="ae lb" href="https://www.html5rocks.com/en/tutorials/speed/static-mem-pools" rel="noopener ugc nofollow" target="_blank">对象池</a>。对于一个相当简单的项目来说，这似乎有些矫枉过正，并且需要额外的依赖和/或重构我的代码。</p><p id="4fcb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我决定采用的优化方法不是最干净的，但我觉得它是简单性和可读性的最佳折衷。我选择将复数对象分解成基本部分，并将它们作为两个独立的参数传递。如果我想减少对象分配，我可以完全避免对象！</p><p id="577e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个没有对象时我的代码的例子:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="50b8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Mandelbrot set算法非常简单，使用单独的原语不会对代码的可读性造成太大的损害。然而，直接使用原语对性能有很大的影响。这是使用这个优化JavaScript的开发人员工具的另一个视图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/7098b23ce7310047ada841537c3cb172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8u0g0TaSxxfMIY5EO1-ygA.png"/></div></div></figure><p id="7d3c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">火焰图底部的所有黄色装饰都消失了，从底部向上的视图显示根本没有时间花在垃圾收集上！</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/06c011194e70a8d2bbeaebfa93afdfcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brisUFfrm5_FHZEUwzz7-g.png"/></div></div></figure><p id="95cf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于使用内存管理语言的开发人员来说，在长时间运行的阻塞任务中不进行垃圾收集可能会令人惊讶，但在这种情况下这是有意义的。我没有创建任何JavaScript对象，所以不需要收集任何东西。更确切地说，我的所有原始变量都直接存储在堆栈中，并在给定的堆栈帧完成时移除。</p><p id="44f1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">最后一句话不一定100%正确，但在当前版本的Chrome浏览器中似乎是正确的。JavaScript是一种内存管理语言，语言规范实际上并没有说明JavaScript如何布置内存。一个足够先进的解释器/编译器实际上可以自由地分析我的代码，并决定在堆栈上分配我的原始复杂对象类型。目前，浏览器似乎没有做到这一点，但如果它们足够聪明地做到这一点，我希望我的Mandelbrot集的“幼稚”实现会变得更接近我的“优化”版本。现在，我们可以说我的优化JavaScript通过在堆栈上分配来节省垃圾收集。</em></p><h1 id="e59d" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">更奇特的解决方案:WebAssembly</h1><p id="3611" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">因为整个项目一开始是作为学习性能优化的一种方式，所以我不想停止编写优化的JavaScript。我在网上听到了一种新语言的低语。一个可以纠正JavaScript许多错误的方法。一个将向所有其他在JavaScript严酷统治下屈服的语言开放网络的平台。那种语言就是WebAssembly。</p><p id="d24a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">WebAssembly 很像JVM的字节码<a class="ae lb" href="https://en.wikipedia.org/wiki/Java_bytecode" rel="noopener ugc nofollow" target="_blank">。它不是你通常会手写的东西，但它可以是许多不同语言的编译目标。像字节码或汇编语言一样，WebAssembly更接近于在您的计算机上执行的实际机器代码。它可以访问线性内存块，不使用垃圾收集，并且几乎没有高级编程语言功能。</a></p><p id="85b1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">另一方面，像JavaScript一样，浏览器中的WebAssembly不提供对底层操作系统的访问，并且可以被标准浏览器沙箱绑定。此外，与C中生成的机器码不同，WebAssembly保证了安全，避免了某些内存漏洞，如缓冲区溢出和控制流劫持。</p><p id="4ced" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">基于这些特征，我猜测WebAssembly可能非常适合我的Mandelbrot viewer项目。我一直在寻找一种真正有效的方法来进行数学计算，我读过的几乎所有编程语言的比较都表明，编译型、静态类型的语言往往比解释型语言更快(想想Java和Python)。同样，数据结构和编程构造更接近计算机的真实内存和CPU架构的语言往往比那些结构更抽象的语言更快(想想C与Haskell)。现代JavaScript适合于编译语言和解释语言之间的一个奇怪的中间空间(查看<a class="ae lb" href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" rel="noopener ugc nofollow" target="_blank"> JIT编译器</a>了解更多信息)，并且它肯定有一些更高层次的数据结构复杂性，包括闭包和原型。也许WebAssembly可以做得更好。</p><p id="1dc1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了创建一个WebAssembly版本的Mandelbrot viewer，我必须选择一种可以编译成WebAssembly的语言。幸运的是，铁锈完全符合要求。深入探究Rust到底是什么或者为什么它如此棒，还需要一些博客文章，但是从高层次上来说，Rust是静态类型的，低层次到足以编写高性能代码，最有趣的是，它提供了没有垃圾收集器的内存管理。此外，通过一个名为<a class="ae lb" href="https://github.com/rustwasm/wasm-bindgen" rel="noopener ugc nofollow" target="_blank"> wasm-bindgen </a>的工具，你可以用自动生成的包装器将Rust编译成WebAssembly，以帮助从TypeScript中调用它。为了“公平”地比较WebAssembly和JavaScript，我大多只是将我的TypeScript代码直接移植到等价的Rust。这看起来是这样的:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="a172" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">免责声明:我对Rust很陌生，这是一个有意的1-1端口。请温柔点。</em></p><p id="ca4b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我把我的Mandelbrot算法移植到Rust之后，我用wasm-bindgen把它编译成WebAssembly，用Webpack把它和我的JavaScript捆绑在一起。这是关键时刻。我再次通过性能工具运行我的Mandelbrot计算，发现…不多。WebAssembly的运行速度和我在Firefox中优化的JavaScript差不多，实际上在Chrome1中运行速度慢了10%。这是非常令人惊讶的！我只是在语言之间切换了一次上下文，并没有做任何不必要的内存复制。我还在页面完全加载后多次运行了WebAssembly代码，因此应该不会有任何与网络/启动相关的问题。不确定发生了什么，我深入研究了性能工具。自下而上的视图向我展示了与优化后的JavaScript基本相同的配置文件。几乎没有垃圾收集。在我点击redraw按钮开始绘图过程后，几乎所有的计算时间都花在了运行代码的实际任务上。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/0a90d8da21b19dcdf0c078bc02939d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7YhQTNhMSovdpXr2UcfSA.png"/></div></div></figure><p id="94ba" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">那么，为什么我编译的、低级的、静态类型的代码会比解释的、高级的、动态类型的JavaScript代码差呢？</p><p id="bc6a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc"> 1在Safari中，WebAssembly的运行速度比JavaScript快4到5倍，但JavaScript比Chrome和Firefox慢4到5倍，所以最高速度的结果是相似的。</em></p><h1 id="34e1" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">JavaScript万岁</h1><p id="984c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在查看我的WebAssembly代码的performance选项卡时，我意识到Rust生成的WebAssembly并不慢。相反，JavaScript真的很快。回到我之前的观点，称JavaScript为解释型语言并不完全准确。在现代浏览器中，当快速启动时间很重要时，JavaScript被解释。当性能至关重要时，浏览器会透明地将JavaScript编译成高度优化的机器码。此外，虽然JavaScript是一种动态类型语言，但我的优化代码本质上是高度静态的。我没有创建任何带有附加属性的Franken对象，也没有依赖于深度原型树。我优化过的代码做了计算机自诞生以来就被优化过的事情。它用原始简单的参数运行数学函数。类似我写的代码可能是浏览器优化编译器中第一批优化的。</p><p id="edf4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">JavaScript是一种有点独特的编程语言，因为它是浏览器直接支持的唯一客户端语言，所以自动获得了巨大的市场份额。因为网络无处不在，所以对尽可能积极优化JavaScript有着巨大的需求。一些最流行的JavaScript运行时拥有大型专家工程师团队，他们多年来一直在优化这种语言。</p><p id="7377" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这并不是说WebAssembly赶不上JavaScript。WebAssembly是一项相当新的技术，还没有机会以同样的方式进行大量优化。它还有一些真正能让它在JavaScript上占据优势的特性。我避免的一些JavaScript特性(例如，动态改变对象形状)可能会出现在JavaScript代码库中的任何地方，并且可能会损害编译器的优化能力。JavaScript引擎也有许多性能“去优化”,异常的代码结构会阻止优化编译器产生高效的代码。像Rust这样严格得多的语言通常可以在第一时间阻止这些情况出现。</p><p id="6498" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Rust还有一些额外的性能优势，这些优势也与我的Mandelbrot绘图算法相关。因为Rust是静态类型的，并且对内存布局有更多的控制，所以它已经可以利用V8等现代JavaScript引擎所没有的一些优化。例如，我应该能够将我的“幼稚的”JavaScript方法移植到Rust，并让它像我的原始数学Rust一样高效地运行(尽管不幸的是没有优化的JavaScript快)。如果我在Rust中定义了一个“复杂”类型，我就有了语言级别的保证，即对象对于数字的实部只有一个浮点字段，对于虚部只有一个浮点字段。有了两个简单的字段，Rust就可以把我的复数直接放到堆栈上，就像JavaScript处理原语一样。这意味着在Rust，我可以有我的蛋糕，也吃它。我可以编写使用对象的干净代码，并且不会因为垃圾收集而损失性能。在像我的Mandelbrot set grapher这样的简单项目中，这可能不是什么大事。在具有更复杂逻辑的项目中，能够编写干净的代码而仍然避免垃圾收集可能是一个巨大的胜利。</p><h1 id="897e" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">外卖食品</h1><p id="e66d" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在这个项目的过程中，我有机会打破一些干净编码的标准规则。我没有将相关数据分组到一个对象中，而是将其表示为原语，并在单独的变量中传递它们。我没有编写单一责任的助手函数来进行计算，而是内联地进行计算。我还在工具箱中引入了一种新的编程语言和编译目标，试图从浏览器中获得尽可能多的单线程性能。对于大多数“普通”的web应用程序来说，这种性能上的跳跃并不是真正必要的。过早的优化是许多问题的根源，应用程序通常会因为I/O而不是计算而变慢。然而，网络不断承担更多的责任，在浏览器中运行更多计算密集型应用程序变得可能。3D游戏、客户端图像处理和其他通常为本地应用程序保留的任务似乎正在浏览器中获得立足点。这就是计算性能调优再次变得重要的地方。</p><p id="1be3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">优化的JavaScript在快速计算方面有很大潜力，但它的新合作伙伴WebAssembly可能会为一系列全新的移植应用程序打开大门，这些应用程序是用Rust和其他以前只有本地语言编写的。尽管WebAssembly目前可能不会给我们带来比高度优化的JavaScript更大的收益，但随着时间的推移，它只会变得更快。更重要的是，对于一大类复杂的程序，像Rust这样的静态类型、注重性能的语言将迫使开发人员编写代码，自然地移植到高性能的WebAssembly。这种开发方式可能会在未来几年为许多新的浏览器功能打开大门。看到我们将要建造的东西是令人兴奋的。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><p id="655d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">披露声明:2021资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="7fa9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">最初发表于</em><a class="ae lb" href="https://www.capitalone.com/tech/software-engineering/optimizing-graphing-performance-on-the-web-mandelbrot-project/" rel="noopener ugc nofollow" target="_blank">T5【https://www.capitalone.com】</a><em class="lc">。</em></p></div></div>    
</body>
</html>