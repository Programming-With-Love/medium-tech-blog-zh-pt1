<html>
<head>
<title>An Introduction to Kotlin for server-side applications — Part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于服务器端应用程序的Kotlin介绍—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/an-introduction-to-kotlin-for-server-side-applications-part-1-d9cbcfba34a2?source=collection_archive---------6-----------------------#2020-04-13">https://medium.com/globant/an-introduction-to-kotlin-for-server-side-applications-part-1-d9cbcfba34a2?source=collection_archive---------6-----------------------#2020-04-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1b82fba188fa29c2737263cde4369a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7pbOPhPZ9rPR5d5H"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Ried</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1f00" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在过去的几十年中，web和移动应用程序开发发生了重大变化。Java和JVM仍然是服务器端编程的重要平台，但是像Ruby on rails这样的流行框架已经被Node.js和Go language这样的其他工具集所加入。在网络上，像React和Angular这样的客户端JavaScript框架已经变得突出，而iOS和Android的移动客户端现在主要是使用Swift和Kotlin构建的。Node.js特有的好处之一是，开发人员可以专注于使用单一语言JavaScript来开发系统的前端和后端部分。使用单一语言有助于开发团队专注于应用程序需求，花更少的时间掌握多种语言，并减少您需要使用的工具集数量。</p><p id="1a7a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Swift和Kotlin在移动开发中的出现为开发人员提供了一个类似的机会，让他们在构建前端和后端系统的同时专注于单一语言。此外，这两种语言都是高性能和静态类型的，因此它们也使得开发更安全的后端应用程序成为可能，这些应用程序比JavaScript或Python等动态类型语言更快，错误更少。</p><p id="bcce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Kotlin比其他SDK有优势，因为它不仅涵盖了移动和web上的前端开发，还涵盖了服务器端开发。你不仅可以使用Kotlin创建很酷的移动和网络应用，还可以创建与之交互的网络服务！。在服务器端，有几个框架可以用来用Kotlin构建web应用程序和web服务。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="a98d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我们将看到如何使用http4k构建一个服务器。它完全是在Kotlin中构建的，是一组提供服务和消费HTTP服务的功能性工具包的库，专注于简单、一致和可测试的API。因此，尽管它确实提供了对与服务和消费HTTP 相关的各种API<em class="jz">的支持，但它并没有提供所有的集成——仅仅是允许这些集成被挂接的简单点。</em></p><p id="5290" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于来自Twitter的令人敬畏的<a class="ae it" href="https://monkey.org/~marius/funsrv.pdf" rel="noopener ugc nofollow" target="_blank">“你的服务器作为一种功能”</a>的论文，http4k应用程序通过组合两种简单、独立的功能来建模。</p><h1 id="22b9" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.HttpHandler</h1><p id="f919" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">通过将HTTP请求映射到响应来将HTTP请求处理成响应是一种抽象。</p><p id="61d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">例如</strong></p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="fa29" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这段代码展示了一个由单个Kotlin function应用程序组成的全功能应用程序，我们将它嵌入到一个Jetty服务器中，这是一个可供我们选择的服务器实现示例。注意这里的类型HttpHandler，它代表了“作为功能的服务器”这一概念中的两个基本概念之一</p><h1 id="13ac" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.过滤器</h1><p id="c789" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">这是一种抽象，可以为HttpHandler添加预处理和后处理，如缓存、调试、身份验证处理等。过滤器是可组合/堆叠的。</p><p id="abf9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">例如</strong></p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="d814" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个在进行任何操作之前捕捉所有错误的简单示例，同样，我们可以在使用过滤器进行任何API调用之前设置content-type。</p><p id="6c6d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个应用程序都可以由HttpHandlers和过滤器组合而成，这两者都是普通Kotlin函数类型的简单类型别名。</p><h1 id="6517" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">按指定路线发送</h1><p id="d028" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated"><a class="ae it" href="https://www.http4k.org/blog/meet_http4k/#routing" rel="noopener ugc nofollow" target="_blank">http4k中的路由</a>可以处理任意层次的嵌套，这种方式可以完美地工作，因为路由本身会产生一个新的HttpHandler。</p><p id="7c51" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">例如</strong></p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="1c5e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">带镜头的类型安全HTTP</h1><h2 id="a4bf" class="lj kb hh bd kc lk ll lm kg ln lo lp kk jf lq lr ko jj ls lt ks jn lu lv kw lw bi translated">基本定义</h2><p id="90cc" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">镜头瞄准复杂对象的特定部分，以获取或设置值。基本上，它是一个函数——或者更准确地说是两个函数！</p><pre class="ld le lf lg fd lx ly lz ma aw mb bi"><span id="0876" class="lj kb hh ly b fi mc md l me mf">Extract: (HttpMessage) -&gt; X<br/>Inject: (X, HttpMessage) -&gt; HttpMessage</span></pre><p id="aff5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">把对象想象成<em class="jz">整体</em>，把场想象成<em class="jz">部分</em>。getter取一个整体，返回镜头聚焦的对象部分。setter接受一个整体，并接受一个值来设置part，然后返回一个新的整体和更新的part。记住，镜头既可以用来拍摄也可以用来拍摄整个物体的一部分。</p><h1 id="7d15" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">http4k中的镜头</h1><p id="abcc" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">根据透镜的基本思想，http4k透镜是双向实体，可用于从http消息中获取或设置特定值。</p><p id="c11e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相应的描述镜头的API以DSL的形式出现，它也让我们定义我们安装镜头的HTTP部分的需求(可选的和强制的)。由于HTTP消息是一个相当复杂的容器，我们可以将镜头聚焦于消息的不同区域:查询、标题、路径、表单域、正文。</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="4803" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用Lens从HTTP请求中检索值</h1><p id="9ee6" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">对于上面的路由示例，我们可以使用查询镜头生成器，然后调用()消息上的镜头来提取目标值:</p><p id="c62a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="2f49" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们创建一个双向镜头，聚焦于消息的查询部分，从中提取一个必需的非空名称。现在，如果客户端碰巧调用端点而没有提供名称查询参数，那么lens会自动返回一个错误，因为它被定义为“required”和“nonEmpty”。</p><h2 id="c2ab" class="lj kb hh bd kc lk ll lm kg ln lo lp kk jf lq lr ko jj ls lt ks jn lu lv kw lw bi translated">使用Lens设置HTTP请求中的值</h2><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4848" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个例子展示了我们如何创建一个Request实例，并通过一个或多个镜头注入一个值。我们可以使用Lens::inject函数来指定我们想要设置到Request的任意实例中的值。</p><p id="864b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最终代码将如下所示:</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="c157" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">部署</h1><p id="7c5c" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">Kotlin应用可以部署到任何支持Java Web应用的主机上，包括亚马逊Web服务、谷歌云平台等等。</p><h1 id="8dd8" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">总结</strong></h1><p id="310d" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">我个人在几周内学会了欣赏科特林。一旦您熟悉了基本概念，快速开发前端、服务器端应用程序就变得容易了，这也为移动开发人员熟悉web开发打开了大门。我们可以说Kotlin是真正的全栈解决方案，使用它我们可以开发多平台应用。我们已经看到了如何使用一个完全用Kotlin构建的框架来开发一个简单的服务器端应用程序。</p><p id="a8a2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一部分，我们将看到JSON处理、REST API示例和一个小应用程序。</p></div></div>    
</body>
</html>