<html>
<head>
<title>Implementing Adaptive Icons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现自适应图标</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/implementing-adaptive-icons-1e4d1795470e?source=collection_archive---------3-----------------------#2017-07-10">https://medium.com/androiddevelopers/implementing-adaptive-icons-1e4d1795470e?source=collection_archive---------3-----------------------#2017-07-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2d9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android O引入了一种新的应用程序图标格式，称为<a class="ae jc" href="https://developer.android.com/preview/features/adaptive-icons.html" rel="noopener ugc nofollow" target="_blank">自适应图标</a>，旨在使设备上的所有图标更加连贯。这篇文章将探讨如何为你的应用程序构建自适应图标。很多应用程序不太可能很快变成26，所以这篇文章也将尽可能高效地研究添加这个额外图标的技术。</p><p id="4811" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样值得指出的是，Android Studio 3.0包括一个<a class="ae jc" href="https://developer.android.com/preview/features/adaptive-icons.html#studio" rel="noopener ugc nofollow" target="_blank">新向导</a>来帮助你创建自适应图标，我们不会在这里讨论；我们将坚持基本的格式和技术。</p><p id="0700" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对这种格式的背景或者如何设计一个适应性图标感兴趣，可以看看这些帖子:</p><div class="jh ji ez fb jj jk"><a rel="noopener follow" target="_blank" href="/@crafty/understanding-android-adaptive-icons-cee8a9de93e2"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">了解Android自适应图标</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">Android O为应用程序图标引入了一种新的格式，称为自适应图标。为了更好地理解动机和…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">medium.com</p></div></div><div class="jt l"><div class="ju l jv jw jx jt jy jz jk"/></div></div></a></div><div class="jh ji ez fb jj jk"><a rel="noopener follow" target="_blank" href="/@crafty/designing-adaptive-icons-515af294c783"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">设计适应性图标</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">Android O引入了新的应用程序图标格式:自适应图标。自适应图标可以通过统一使设备更加一致…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">medium.com</p></div></div><div class="jt l"><div class="ka l jv jw jx jt jy jz jk"/></div></div></a></div><h2 id="c1f7" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">基础</h2><p id="8f02" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">自适应图标是一种新的可绘制类型，即<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/drawable/AdaptiveIconDrawable.html" rel="noopener ugc nofollow" target="_blank">AdaptiveIconDrawable</a></code>。您可能永远不需要直接使用该类，而是用XML定义它并从您的清单中指向它。您可以使用以下格式:</p><pre class="lb lc ld le fd lf jg lg lh aw li bi"><span id="9308" class="kb kc hh jg b fi lj lk l ll lm">&lt;adaptive-icon&gt;<br/>  &lt;background android:drawable="@[drawable|mipmap|color]/bar"/&gt;<br/>  &lt;foreground android:drawable="@[drawable|mipmap|color]/foo"/&gt;&lt;/adaptive-icon&gt;</span></pre><p id="1ac2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个可拉伸的<strong class="ig hi">必须</strong>的尺寸为108dp * 108dp背景绘画必须是不透明的，而前景可以包含透明度。</p><blockquote class="ln lo lp"><p id="94ec" class="ie if lq ig b ih ii ij ik il im in io lr iq ir is ls iu iv iw lt iy iz ja jb ha bi translated">你还需要用<code class="du jd je jf jg b">buildToolsVersion</code> 26.0.0或更高版本来构建你的apk。</p></blockquote><h2 id="2f35" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">实际上明斯克是26岁</h2><p id="d73c" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">因为自适应图标只在API 26+上使用，所以您可以依赖某些可用的特性。专门挺能干的<code class="du jd je jf jg b">VectorDrawable</code>支持。</p><blockquote class="ln lo lp"><p id="2fc6" class="ie if lq ig b ih ii ij ik il im in io lr iq ir is ls iu iv iw lt iy iz ja jb ha bi translated">不幸的是，你不能使用自定义可提取的通货膨胀；因为你的图标会被其他应用程序的进程加载，所以你需要坚持使用平台可绘制类型。</p></blockquote><p id="4c7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">利用向量是有吸引力的，因为它允许我们以非常紧凑的格式指定一次drawable。这意味着它在任何密度下都是酥脆的，不会使你的APK膨胀。</p><p id="28a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">特别是，许多开发者似乎没有利用<code class="du jd je jf jg b">VectorDrawable</code>对渐变的支持。关于这个话题，我推荐阅读<a class="lu lv ge" href="https://medium.com/u/51a4f24f5367?source=post_page-----1e4d1795470e--------------------------------" rel="noopener" target="_blank"> Ian Lake </a>最近发表的关于实现自适应图标的文章，其中涵盖了一些基础知识。</p><div class="jh ji ez fb jj jk"><a rel="noopener follow" target="_blank" href="/@ianhlake/vectordrawable-adaptive-icons-3fed3d3205b5"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">可矢量绘制的自适应图标</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">随着Android O最终成为API 26，现在是时候开始考虑添加一个自适应的图标，而不会有…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">medium.com</p></div></div></div></a></div><p id="b7ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">伊恩展示了如何使用一个简单的线性渐变，但是<code class="du jd je jf jg b">VectorDrawable</code>有一些更好的技巧。这是一个使用多色阶径向渐变实现“长阴影”的例子。我还使用了<a class="ae jc" href="https://developer.android.com/guide/topics/resources/complex-xml-resources.html" rel="noopener ugc nofollow" target="_blank">内联资源语法</a>，它允许你将多个文件嵌入到一个文件中(通过AAPT技巧，通常与<code class="du jd je jf jg b">AnimatedVectorDrawable</code> s一起使用):</p><pre class="lb lc ld le fd lf jg lg lh aw li bi"><span id="4268" class="kb kc hh jg b fi lj lk l ll lm">&lt;vector ...&gt;</span><span id="dcca" class="kb kc hh jg b fi lw lk l ll lm">  &lt;path android:name="long-shadow"<br/>        android:pathData="..."&gt;</span><span id="3088" class="kb kc hh jg b fi lw lk l ll lm">    &lt;aapt:attr name="android:fillColor"&gt;</span><span id="3eaf" class="kb kc hh jg b fi lw lk l ll lm">      &lt;gradient<br/>          android:type="radial"<br/>          android:centerX="54"<br/>          android:centerY="54"<br/>          android:gradientRadius="76.37"&gt;</span><span id="9b7f" class="kb kc hh jg b fi lw lk l ll lm">        &lt;!-- 15% black from center to 32% stop --&gt;<br/>        &lt;item android:offset="0.0" android:color="#26000000" /&gt;<br/>        &lt;item android:offset="0.32" android:color="#26000000" /&gt;</span><span id="0b2d" class="kb kc hh jg b fi lw lk l ll lm">        &lt;!-- 2% black at 62% stop --&gt;<br/>        &lt;item android:offset="0.62" android:color="#05000000" /&gt;</span><span id="c13f" class="kb kc hh jg b fi lw lk l ll lm">        &lt;!-- fade to transparent --&gt;<br/>        &lt;item android:offset="1.0" android:color="#00000000" /&gt;</span><span id="0e6e" class="kb kc hh jg b fi lw lk l ll lm">      &lt;/gradient&gt;</span><span id="1f8e" class="kb kc hh jg b fi lw lk l ll lm">    &lt;/aapt:attr&gt;</span><span id="4aaa" class="kb kc hh jg b fi lw lk l ll lm">  &lt;/path&gt;</span><span id="a6cf" class="kb kc hh jg b fi lw lk l ll lm">  ...</span><span id="a368" class="kb kc hh jg b fi lw lk l ll lm">&lt;/vector&gt;</span></pre><figure class="lb lc ld le fd ly er es paragraph-image"><div class="er es lx"><img src="../Images/c892a9430a1ebd556158e22a94352e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*XwETOHbx50_CT4tRbbBdog.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">The shadow produced by the radial gradient.</figcaption></figure><p id="8e1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数图标都包含某种投影元素(根据<a class="ae jc" href="https://material.io/guidelines/style/icons.html#icons-product-icons" rel="noopener ugc nofollow" target="_blank">材质指南</a>)，不幸的是<code class="du jd je jf jg b">VectorDrawable</code>不支持。使用自适应图标，有两个功能使向量更相关:</p><ol class=""><li id="a3be" class="me mf hh ig b ih ii il im ip mg it mh ix mi jb mj mk ml mm bi translated">启动器现在负责屏蔽整体的可绘制性，并为整个形状提供任何投影。你不再需要在阴影中烘焙整个形状。</li><li id="4540" class="me mf hh ig b ih mn il mo ip mp it mq ix mr jb mj mk ml mm bi translated">图标由背景和前景图像组成，因此如果其中一个图层不需要任何阴影，那么它可以利用矢量。</li></ol><p id="7dc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一些简单的阴影可以用渐变来近似，但不幸的是不是所有的都可以。</p><h2 id="1294" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">最小可行栅格</h2><p id="8729" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">如果你不能用向量来实现你的设计，那么用png来实现也很好。你的启动图标是如此重要的一项资产，它绝对值得额外增加几个字节来给人留下正确的印象。</p><p id="b3a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，有一个巧妙的技巧，你可以利用资产的透明区域…这在自适应图标前景中有些常见。虽然这种资源可能在构建时压缩得很好，但在运行时，无论不透明度如何，每个像素都要占用8位内存。为了最大限度地减少这种情况，如果透明度在边缘周围，您可以从PNG中修剪这些区域，并使用<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/guide/topics/resources/drawable-resource.html#Inset" rel="noopener ugc nofollow" target="_blank">InsetDrawable</a></code>将其包裹，并将其填充到108dp大小。现在不幸的是<code class="du jd je jf jg b">InsetDrawable</code>不喜欢被调整大小(也就是说，如果你设置了16dp的顶部插入，无论可绘制的边界如何调整大小，它都将始终是16dp ),所以在API26 <em class="lq">中添加了分数</em>插入来缓解这种情况。这可以让你指定插入占整个可绘制图形的百分比，这样它们就可以正确缩放。</p><p id="0ddc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，假设您有一个54dp*54dp的前景资产；除了将它放在108dp*108dp的透明资产中，您可以执行以下操作。</p><pre class="lb lc ld le fd lf jg lg lh aw li bi"><span id="6cd7" class="kb kc hh jg b fi lj lk l ll lm">&lt;inset ...<br/>    android:drawable="@mipmap/<strong class="jg hi">ic_fg_trimmed</strong>"<br/>    android:insetLeft="25%"<br/>    android:insetTop="25%"<br/>    android:insetRight="25%"<br/>    android:insetBottom="25%" /&gt;</span></pre><p id="9535" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是<a class="ae jc" href="https://github.com/nickbutcher/AdaptiveIconPlayground/blob/master/app/src/main/res/drawable-xxxhdpi/ic_launcher_alt_foreground.xml" rel="noopener ugc nofollow" target="_blank">使用这种技术的一个例子</a>，我们移除了原本包含透明度的资产的顶部/左侧部分，并插入了一个经过修剪的版本:</p><figure class="lb lc ld le fd ly er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es ms"><img src="../Images/00311d99dc6e0cf51f7a26f5a31b4ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slPwmRAoMkR0aQqdj_PzYg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx"><em class="mx">No need to ship/load transparent pixels</em></figcaption></figure><p id="96c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，您仍然需要以不同的密度提供经过修剪的栅格资产，但至少每个密度会更小，内存大小也会大大减小。</p><h2 id="086d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">走捷径</h2><p id="3ebf" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">自适应图标不仅仅用于<em class="lq">应用</em>图标，它们也用于<a class="ae jc" href="https://developer.android.com/guide/topics/ui/shortcuts.html" rel="noopener ugc nofollow" target="_blank">应用快捷方式</a>。应用程序快捷方式可以固定在主屏幕上，因此它们需要与应用程序图标相适应。(pre-O) <a class="ae jc" href="https://material.io/guidelines/style/icons.html#icons-app-shortcut-icons" rel="noopener ugc nofollow" target="_blank">设计规范</a>要求快捷图标位于灰色圆形背景上。在Android-O中，背景应该填充自适应图标遮罩。如果你不更新到自适应，你的快捷图标将被缩小，并放置在白色背景上。</p><figure class="lb lc ld le fd ly er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es my"><img src="../Images/98fc28b566cec39b67a08684eb81e2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TADH3ryfMLFjlKzDfkmXxA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx"><em class="mx">Plaid’s search shortcut; before and after becoming adaptive</em></figcaption></figure><p id="f00b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在我的应用程序<a class="ae jc" href="https://github.com/nickbutcher/plaid" rel="noopener ugc nofollow" target="_blank">格子</a>中实现这一点，我最初<a class="ae jc" href="https://github.com/nickbutcher/plaid/commit/b7f0ed1" rel="noopener ugc nofollow" target="_blank">在v26配置中添加了新图标</a>，为自适应网格和<a class="ae jc" rel="noopener" href="/google-design/designing-adaptive-icons-515af294c783#aad8">关键线</a>重新绘制。我对这种方法不满意，因为它们本质上是v25图标的缩小版；这意味着我现在有两个图标需要维护。<a class="ae jc" href="https://github.com/nickbutcher/plaid/commit/2d8d428" rel="noopener ugc nofollow" target="_blank">最终</a>我决定将v25图标分为前景(如搜索图标)和背景(灰色圆圈)，并用一个<code class="du jd je jf jg b">LayerDrawable</code>将它们组合起来:</p><pre class="lb lc ld le fd lf jg lg lh aw li bi"><span id="83b9" class="kb kc hh jg b fi lj lk l ll lm">&lt;layer-list ...&gt;</span><span id="4bba" class="kb kc hh jg b fi lw lk l ll lm">  &lt;item android:drawable="@drawable/<strong class="jg hi">ic_app_shortcut_background</strong>"/&gt;</span><span id="a4b6" class="kb kc hh jg b fi lw lk l ll lm">  &lt;item android:drawable="@drawable/<strong class="jg hi">ic_shortcut_search_foreground</strong>"/&gt;</span><span id="f2ae" class="kb kc hh jg b fi lw lk l ll lm">&lt;/layer-list&gt;</span></pre><p id="2353" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我可以在自适应图标中使用相同的前景资产。在v25上，app快捷图标是一个48dp资产内的24dp在v26上，它们是108dp资产中的44dp:</p><figure class="lb lc ld le fd ly er es paragraph-image"><div class="er es mz"><img src="../Images/bf914c52629f6b2e931d3c83a825ba3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*6kLde9OxebWfWOm7pLVCqA.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx"><em class="mx">App shortcut icon foreground assets required on API 25 &amp; API 26</em></figcaption></figure><p id="dcdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用同样的48dp文件，我需要插入它，这样图标一旦放大就有正确的大小了(耶矢量！)到108dp自适应图标大小。背景是用一个<code class="du jd je jf jg b">ColorDrawable</code>实现的:</p><pre class="lb lc ld le fd lf jg lg lh aw li bi"><span id="7ea0" class="kb kc hh jg b fi lj lk l ll lm">&lt;adaptive-icon ...&gt;</span><span id="062b" class="kb kc hh jg b fi lw lk l ll lm">  &lt;background android:drawable="@color/light_grey" /&gt;</span><span id="0210" class="kb kc hh jg b fi lw lk l ll lm">  &lt;foreground&gt;</span><span id="9f1d" class="kb kc hh jg b fi lw lk l ll lm">    &lt;!-- 10dp padding on each side of 108dp asset --&gt;<br/>    &lt;inset<br/>      android:drawable="@drawable/<strong class="jg hi">ic_shortcut_search_foreground</strong>"<br/>      android:inset="9.26%" /&gt;</span><span id="ef6a" class="kb kc hh jg b fi lw lk l ll lm">  &lt;/foreground&gt;</span><span id="8497" class="kb kc hh jg b fi lw lk l ll lm">&lt;/adaptive-icon&gt;</span></pre><blockquote class="ln lo lp"><p id="6056" class="ie if lq ig b ih ii ij ik il im in io lr iq ir is ls iu iv iw lt iy iz ja jb ha bi translated"><code class="du jd je jf jg b">AdaptiveIconDrawable</code>会将提供的资源缩放到108dp，因此要计算生成44dp图标所需的插图:48/24 * 44 = 88；也就是说，我们需要将按比例放大的资产每边插入10dp:10/108→9.26%</p></blockquote><p id="0570" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于位图图像快捷方式，使用<a class="ae jc" href="https://developer.android.com/reference/android/graphics/drawable/Icon.html#createWithAdaptiveBitmap(android.graphics.Bitmap)" rel="noopener ugc nofollow" target="_blank">图标# createwithaptivebitmap</a>。</p><h2 id="557d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">玩耍</h2><p id="1f3c" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">如果你正在构建一个自适应图标，那么自适应图标游乐场应用程序可能会对你有用。它可以让您预览设备上的自适应图标，查看它们在应用不同遮罩后的外观，并探索一些运动效果。</p><figure class="lb lc ld le fd ly er es paragraph-image"><div class="er es na"><img src="../Images/fb96c0d06882b977a5e6e607d4a05fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*REFtTZHdFnu8TAK_Q4-XYA.gif"/></div></figure><p id="2c6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以<a class="ae jc" href="https://github.com/nickbutcher/AdaptiveIconPlayground/releases" rel="noopener ugc nofollow" target="_blank">获得一个APK </a>(针对已经运行Android-O的设备)或者在github上查看:</p><div class="jh ji ez fb jj jk"><a href="https://github.com/nickbutcher/AdaptiveIconPlayground" rel="noopener  ugc nofollow" target="_blank"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">nick butcher/adaptive icon playground</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">AdaptiveIconPlayground一个用于试验自适应图标的Android应用程序。</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">github.com</p></div></div><div class="jt l"><div class="nb l jv jw jx jt jy jz jk"/></div></div></a></div><h2 id="a467" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ip km kn ko it kp kq kr ix ks kt ku kv bi translated">适应了</h2><p id="a65a" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">希望这些提示能帮助你构建令人敬畏的自适应图标，让你的应用程序更好地驻留在用户的设备上。如果你有任何实现自适应图标的技巧，请在评论中告诉我。</p></div></div>    
</body>
</html>