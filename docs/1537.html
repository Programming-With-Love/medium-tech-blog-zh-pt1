<html>
<head>
<title>What to Expect from Java 10 — One Developer’s View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从一个开发者的角度来看，Java 10有什么值得期待的</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/what-to-expect-from-java-10-one-developers-view-44b7168ebbcc?source=collection_archive---------0-----------------------#2018-03-29">https://medium.com/capital-one-tech/what-to-expect-from-java-10-one-developers-view-44b7168ebbcc?source=collection_archive---------0-----------------------#2018-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="cedd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">需要了解的11个基本特性</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/3a606035b6f93860076ea45b5c13a226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14eseex5Se9-ceqKIpq4Ig.png"/></div></div></figure><p id="afbf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">多年来，Java已经发展成为一个生态系统，而不仅仅是一种编程语言。Java开发人员知道Java已经承诺了六个月的发布周期，Java 10 ( <a class="ae ke" href="http://download.oracle.com/otndocs/jcp/java_se-10-pfd-spec/index.html" rel="noopener ugc nofollow" target="_blank"> JDK 10) </a>即将发布，而<a class="ae ke" href="http://openjdk.java.net/projects/jdk/11/" rel="noopener ugc nofollow" target="_blank"> JDK 11 </a>将于秋季发布。</p><p id="c242" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为<a class="ae ke" href="https://www.jcp.org/en/jsr/overview" rel="noopener ugc nofollow" target="_blank"> Java社区进程(SM)项目</a>的一员，我能够在JDK 10的早期版本上玩一玩并亲自动手。虽然有超过100个JEPs将成为JDK 10的一部分，但在我看来，这11个特性将成为游戏规则的改变者* <em class="kf"> : </em></p><p id="9c86" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">* <em class="kf">请注意，对于每个版本，这些功能都通过Java增强流程(JEP)或Java社区流程(JCP)进行跟踪，其中一些功能在最终版本(GA)中可能会被丢弃。</em></p><h1 id="1864" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 1。</strong> <strong class="ak">更多容器支持</strong></h1><p id="7962" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">容器是软件领域最新的革命之一，它改变了软件开发和部署的模式。市场上有各种各样的集装箱解决方案，如<a class="ae ke" href="https://github.com/docker/docker.github.io" rel="noopener ugc nofollow" target="_blank">码头工人</a>、<a class="ae ke" href="https://github.com/grammarly/rocker" rel="noopener ugc nofollow" target="_blank">摇杆</a>、<a class="ae ke" href="https://dcos.io/" rel="noopener ugc nofollow" target="_blank"> DCOS </a>等等，适用于各种用途。以下是JDK 10之后容器在Java中的工作方式的变化。</p><ul class=""><li id="85ab" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">有了JDK 10，Java将会自我意识到它是运行在容器内部还是主机上。</li><li id="e061" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">JDK 10将为容器如何控制内存和CPU设置引入新的JVM选项。这两个选项都将用于配置容器内的JVM，以便它从Linux CGroup获取最大堆大小:</li><li id="0779" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><strong class="jk hi">XX:-使用容器支持</strong>-允许禁用容器支持。默认:真，即:启用。</li></ul><p id="18e2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">-XX:+UseCGroupMemoryLimitForHeap</strong>—选择使用/sys/fs/cgroup/memory/memory . limit _ in _ bytes中的值作为phys_mem的值。</p><p id="5ff9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">-XX:ActiveProcessorCount = XX</strong>—这允许覆盖CPU的数量。即使未启用UseContainerSupport，也将使用此标志。</p><p id="6bd5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">-XX:+unlockeexperimentalvmoptions</strong>—启用容器支持的实验性VM选项。</p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="fa4c" class="lw kh hh ls b fi lx ly l lz ma">docker run -m 2.5G -ti — rm openjdk:10-jdk java -XshowSettings:vm -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=1 -version<br/> Max. Heap Size (Estimated): 1.84G</span></pre><h1 id="c814" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 2。局部变量类型推理</strong></h1><p id="29ff" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">允许开发人员通过增强类型推断来声明变量，换句话说，允许您在不定义关联类型的情况下声明变量。</p><p id="4a71" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这意味着这在JDK 10:</p><ul class=""><li id="a5bc" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">var my list = new ArrayList<string>()；</string></li><li id="d7cd" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">var my stream = list . stream()；</li></ul><p id="c0aa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将仅限于循环中的局部变量和索引。这将<em class="kf">不会</em>在JDK 10中对方法形式、构造器形式、方法返回类型、字段、catch形式或任何其他类型的变量声明可用。</p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="c446" class="lw kh hh ls b fi lx ly l lz ma">jshell&gt; var myList=new ArrayList&lt;&gt;();</span><span id="06bd" class="lw kh hh ls b fi mb ly l lz ma">myList ==&gt; []</span><span id="d402" class="lw kh hh ls b fi mb ly l lz ma">jshell&gt; myList.add(“Muktesh”);</span><span id="e00e" class="lw kh hh ls b fi mb ly l lz ma">$5 ==&gt; true</span><span id="6641" class="lw kh hh ls b fi mb ly l lz ma">jshell&gt; myList.add(“Java10”);</span><span id="ea4c" class="lw kh hh ls b fi mb ly l lz ma">$6 ==&gt; true</span><span id="410b" class="lw kh hh ls b fi mb ly l lz ma">jshell&gt; System.out.println(myList);</span><span id="cb0c" class="lw kh hh ls b fi mb ly l lz ma">[Muktesh, Java10]</span><span id="5168" class="lw kh hh ls b fi mb ly l lz ma">jshell&gt; System.out.println(myList.getClass().getName());</span><span id="6ef3" class="lw kh hh ls b fi mb ly l lz ma">java.util.ArrayList</span><span id="efee" class="lw kh hh ls b fi mb ly l lz ma">jshell&gt; var x;</span><span id="5f67" class="lw kh hh ls b fi mb ly l lz ma">| Error:</span><span id="7395" class="lw kh hh ls b fi mb ly l lz ma">| cannot infer type for local variable x</span><span id="cdde" class="lw kh hh ls b fi mb ly l lz ma">| (cannot use ‘var’ on variable without initializer)</span><span id="a548" class="lw kh hh ls b fi mb ly l lz ma">| var x;</span><span id="ac0a" class="lw kh hh ls b fi mb ly l lz ma">| ^ — — ^</span></pre><h1 id="01e4" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 3。</strong> <strong class="ak">收藏改进</strong></h1><p id="3dd4" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">像每个Java版本一样，JDK 10对集合进行了升级。新方法<strong class="jk hi"> toUnmodifiableList </strong>、<strong class="jk hi"> toUnmodifiableSet </strong>和<strong class="jk hi">tounmodifiablemapwhere</strong>已经添加到流包的Collectors类中，允许将流的元素收集到不可修改的集合中。</p><h1 id="0154" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">4.<strong class="ak">通过Java访问非Java API</strong></h1><p id="993e" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">也被称为<a class="ae ke" href="http://openjdk.java.net/projects/panama/" rel="noopener ugc nofollow" target="_blank">巴拿马项目</a>。这个Java社区正在努力为非Java APIs敞开大门(其中很多都是原生C/C++接口)。这将实现:</p><ul class=""><li id="b7c5" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">在堆中创建新的数据布局。</li><li id="d964" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">JVM的本机元数据定义。</li><li id="8aee" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">面向本机的JIT优化。</li><li id="cc7d" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">从JVM或JVM内部访问本机数据</li><li id="b58d" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">此外，JVM正试图引入专门为本地语言开发的面向本地的解释器</li></ul><h1 id="60a8" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">5.<strong class="ak">多语言VM</strong>T21【支持</h1><p id="fe43" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">也被称为<a class="ae ke" href="https://github.com/oracle/graal" rel="noopener ugc nofollow" target="_blank">项目Graal </a>，这允许通过API公开VM功能。这是一个为JVM展示新的多语言运行时的努力。这可以通过以下方式实现:</p><ul class=""><li id="a5fb" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">Graal  —动态编译器。</li><li id="ef7d" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">用于实现使用Graal作为编译器的语言。</li><li id="f54b" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">利用Graal实现Java应用程序的提前编译。</li><li id="4321" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">Graal SDK—Graal VM的API集合。</li></ul><h1 id="033e" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 6。</strong> <strong class="ak">应用类-数据共享</strong></h1><p id="0b86" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">类数据共享在Java中已经存在很长时间了。它有很多好处，比如通过在不同的Java进程之间共享相同的数据来提高JVM的启动性能和减少内存。</p><ul class=""><li id="ff0f" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">在JDK 10中，内置系统类装入器、内置平台类装入器和自定义类装入器可以装入存档的类。以前，它仅限于引导类装入器。</li></ul><p id="a470" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">-XX:+UseAppCDS将允许所有的类加载器共享数据。</p><ul class=""><li id="f05e" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">此外，还可以通过只允许存档指定类别集来关闭它。这可以通过关闭整个共享并仅启用选定的共享来实现。</li></ul><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="8889" class="lw kh hh ls b fi lx ly l lz ma">Jshell&gt; java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=com.test -cp Test.jar EntryClass</span></pre><h1 id="bd6a" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 7。</strong> <strong class="ak">改进根证书配置aka Cacerts </strong></h1><p id="355c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">cacerts密钥库(JDK的一部分)包含一组根证书。目前，它是空的，这就是为什么配置安全协议(如TLS)会变得如此困难。在JDK 10中，它将在JDK提供一组默认的根认证证书。</p><h1 id="03c0" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 8。垃圾收集的改进</strong></h1><p id="5e3f" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">与其他版本一样，<a class="ae ke" href="http://openjdk.java.net/jeps/304" rel="noopener ugc nofollow" target="_blank">垃圾</a> <a class="ae ke" href="http://openjdk.java.net/jeps/307" rel="noopener ugc nofollow" target="_blank">收集</a>将在JDK 10中得到改进。这包括:</p><ul class=""><li id="4e99" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">G1垃圾收集器的并行完全垃圾收集。G1在JDK 9中成为默认GC，现在通过允许完全GC并行变得更加强大。</li><li id="34cc" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated">添加了垃圾收集器接口，这将使用户能够配置替代的垃圾收集器。</li></ul><h1 id="f8f3" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 9。</strong> <strong class="ak">在多个设备上分配堆</strong></h1><p id="397a" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">这一改变将使用户能够将JVM堆分配到多个设备上。<strong class="jk hi"> </strong>这是一个WIP，但将支持大型应用程序(如大数据应用程序)在多个堆中运行。<a class="ae ke" href="http://openjdk.java.net/jeps/316" rel="noopener ugc nofollow" target="_blank">到目前为止，还没有完全决定哪些内容将留在DRAM中，哪些内容将放在备用内存位置中。</a></p><ul class=""><li id="20ac" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated">JVM中将引入一个新的标志XX:AllocateHeapAt= <path>,这将允许在备用路径上分配堆。</path></li></ul><h1 id="fdf1" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak"> 10。线程局部握手</strong></h1><p id="6856" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">JDK 10将通过允许在线程上执行回调而无需执行全局虚拟机安全点来提高并发代码的效率。这将使停止单个线程变得更加容易和便宜。它还将改善虚拟机延迟，因为它将花费更少的精力来查询全局虚拟机中的线程状态。</p><h1 id="719c" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">11.<strong class="ak">通用数据类型创建或通用运行时类型</strong></h1><p id="daed" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">也被称为<a class="ae ke" href="http://openjdk.java.net/projects/valhalla/" rel="noopener ugc nofollow" target="_blank">项目Valhalla </a>，这将允许开发人员在堆中定义平面数据类型——即无引用数据类型。这将减少内存使用并提高局部性。</p><p id="3675" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">总的来说，Java似乎正在为新的改进计划一个频繁的发布周期，路线图的核心领域集中并致力于容器化和优化。随着每六个月推出一个新版本，随着时间的推移，我们将继续看到一系列令人兴奋的改进。</p><p id="3855" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我鼓励大家亲自试用JDK 10，看看这些新功能，包括我没有在这里列出的功能。</p><p id="1feb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2018首都一。</em></p></div></div>    
</body>
</html>