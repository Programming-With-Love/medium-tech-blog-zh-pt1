<html>
<head>
<title>JavaScript Factory Functions with ES6+</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6+的JavaScript工厂功能</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1?source=collection_archive---------0-----------------------#2017-07-20">https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1?source=collection_archive---------0-----------------------#2017-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="69e6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列<strong class="iz hi"> s </strong> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">(现在一本书！)</strong> </a>关于从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">买书</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">索引</a>|<a class="ae jv" rel="noopener" href="/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381">|&lt;上一张</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/functional-mixins-composing-software-ffb66d5e731c">下一张&gt; </a></p></blockquote><p id="35dd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">工厂函数是任何一个函数，它不是一个返回(假设是新的)对象的类或构造函数。在JavaScript中，任何函数都可以返回一个对象。当它在没有关键字<code class="du jz ka kb kc b">new</code>的情况下这样做时，它是一个工厂函数。</p><p id="e8f6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">工厂函数在JavaScript中一直很有吸引力，因为它们提供了轻松生成对象实例的能力，而无需陷入类和<code class="du jz ka kb kc b">new</code>关键字的复杂性。</p><p id="75d7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript提供了非常方便的对象文字语法。它看起来像这样:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="1c87" class="kl km hh kc b fi kn ko l kp kq">const user = {<br/>  userName: 'echo',<br/>  avatar: 'echo.png'<br/>};</span></pre><p id="9fa9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">像JSON(基于JavaScript的对象文字符号)一样，<code class="du jz ka kb kc b">:</code>的左边是属性名，右边是值。您可以使用点符号访问道具:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="94a6" class="kl km hh kc b fi kn ko l kp kq">console.log(user.userName); // "echo"</span></pre><p id="e8da" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以使用方括号符号来访问计算属性名:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="37c2" class="kl km hh kc b fi kn ko l kp kq">const key = 'avatar';</span><span id="3081" class="kl km hh kc b fi kr ko l kp kq">console.log( user[key] ); // "echo.png"</span></pre><p id="07ed" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果作用域内的变量与预期的属性名同名，则可以在对象文字创建中省略冒号和值:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="df5b" class="kl km hh kc b fi kn ko l kp kq">const userName = 'echo';<br/>const avatar = 'echo.png';</span><span id="ebb0" class="kl km hh kc b fi kr ko l kp kq">const user = {<br/>  userName,<br/>  avatar<br/>};</span><span id="a4a6" class="kl km hh kc b fi kr ko l kp kq">console.log(user);<br/>// { "avatar": "echo.png",   "userName": "echo" }</span></pre><p id="f723" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对象文字支持简洁的方法语法。我们可以添加一个<code class="du jz ka kb kc b">.setUserName()</code>方法:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="d73d" class="kl km hh kc b fi kn ko l kp kq">const userName = 'echo';<br/>const avatar = 'echo.png';</span><span id="3786" class="kl km hh kc b fi kr ko l kp kq">const user = {<br/>  userName,<br/>  avatar,</span><span id="7eba" class="kl km hh kc b fi kr ko l kp kq">  setUserName (userName) {<br/>    this.userName = userName;<br/>    return this;<br/>  }<br/>};</span><span id="56b5" class="kl km hh kc b fi kr ko l kp kq">console.log(user.setUserName('Foo').userName); // "Foo"</span></pre><p id="3629" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在简洁的方法中，<code class="du jz ka kb kc b">this</code>指的是方法被调用的对象。要调用对象上的方法，只需使用对象点符号访问该方法，并使用括号调用它，例如，<code class="du jz ka kb kc b">game.play()</code>会将<code class="du jz ka kb kc b">.play()</code>应用于<code class="du jz ka kb kc b">game</code>对象。为了应用使用点符号的方法，该方法必须是所讨论的对象的属性。您还可以使用函数原型方法、<code class="du jz ka kb kc b">.call()</code>、<code class="du jz ka kb kc b">.apply()</code>或<code class="du jz ka kb kc b">.bind()</code>将方法应用于任何其他任意对象。</p><p id="bb6f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这种情况下，<code class="du jz ka kb kc b">user.setUserName('Foo')</code>将<code class="du jz ka kb kc b">.setUserName()</code>应用于<code class="du jz ka kb kc b">user</code>，所以<code class="du jz ka kb kc b">this === user</code>。在<code class="du jz ka kb kc b">.setUserName()</code>方法中，我们通过<code class="du jz ka kb kc b">this</code>绑定来更改<code class="du jz ka kb kc b">user</code>对象的<code class="du jz ka kb kc b">.userName</code>属性，并返回相同的对象实例用于方法链接。</p><h1 id="3dd3" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">文字代表一个，工厂代表多个</h1><p id="41d3" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">如果您需要创建许多对象，您将希望结合对象文字和工厂函数的力量。</p><p id="ca0f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">使用工厂函数，您可以创建任意多的用户对象。例如，如果您正在构建一个聊天应用程序，您可以有一个代表当前用户的用户对象，以及许多代表当前登录并聊天的所有其他用户的其他用户对象，因此您也可以显示他们的姓名和头像。</p><p id="5585" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">让我们把我们的<code class="du jz ka kb kc b">user</code>对象变成一个<code class="du jz ka kb kc b">createUser()</code>工厂:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="6b7a" class="kl km hh kc b fi kn ko l kp kq">const createUser = ({ userName, avatar }) =&gt; ({<br/>  userName,<br/>  avatar,<br/>  setUserName (userName) {<br/>    this.userName = userName;<br/>    return this;<br/>  }<br/>});</span><span id="f607" class="kl km hh kc b fi kr ko l kp kq">console.log(createUser({ userName: 'echo', avatar: 'echo.png' }));</span><span id="174f" class="kl km hh kc b fi kr ko l kp kq">/*<br/>{<br/>  "avatar": "echo.png",<br/>  "userName": "echo",<br/>  "setUserName": [Function setUserName]<br/>}<br/>*/</span></pre><h1 id="1060" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">返回对象</h1><p id="6404" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">箭头函数(<code class="du jz ka kb kc b">=&gt;</code>)有一个隐式返回特性:如果函数体由单个表达式组成，可以省略<code class="du jz ka kb kc b">return</code>关键字:<code class="du jz ka kb kc b">() =&gt; 'foo'</code>是一个不带参数的函数，返回字符串，<code class="du jz ka kb kc b">"foo"</code>。</p><p id="0e64" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">返回对象文本时要小心。默认情况下，JavaScript假设您想在使用大括号时创建一个函数体，例如<code class="du jz ka kb kc b">{ broken: true }</code>。如果您想对对象文字使用隐式返回，您需要通过将对象文字括在括号中来消除歧义:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="bcaf" class="kl km hh kc b fi kn ko l kp kq">const noop = () =&gt; { foo: 'bar' };<br/>console.log(noop()); // undefined</span><span id="7719" class="kl km hh kc b fi kr ko l kp kq">const createFoo = () =&gt; ({ foo: 'bar' });<br/>console.log(createFoo()); // { foo: "bar" }</span></pre><p id="74be" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在第一个例子中，<code class="du jz ka kb kc b">foo:</code>被解释为一个标签，<code class="du jz ka kb kc b">bar</code>被解释为一个没有被赋值或返回的表达式。该函数返回<code class="du jz ka kb kc b">undefined</code>。</p><p id="131c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在<code class="du jz ka kb kc b">createFoo()</code>示例中，括号强制将括号解释为待计算的表达式，而不是函数体块。</p><h1 id="f246" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">解构</h1><p id="0a43" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">请特别注意函数签名:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="eb85" class="kl km hh kc b fi kn ko l kp kq">const createUser = ({ userName, avatar }) =&gt; ({</span></pre><p id="418d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这一行中，大括号(<code class="du jz ka kb kc b">{</code>，<code class="du jz ka kb kc b">}</code>)代表对象析构。这个函数接受一个参数(一个对象)，但是从这个参数中析构两个形参<code class="du jz ka kb kc b">userName</code>和<code class="du jz ka kb kc b">avatar</code>。然后，这些参数可以用作函数体范围内的变量。您也可以析构数组:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="e49c" class="kl km hh kc b fi kn ko l kp kq">const swap = ([first, second]) =&gt; [second, first];</span><span id="c52f" class="kl km hh kc b fi kr ko l kp kq">console.log( swap([1, 2]) ); // [2, 1]</span></pre><p id="a3fd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以使用rest and spread语法(<code class="du jz ka kb kc b">...varName</code>)从数组(或参数列表)中收集剩余的值，然后将这些数组元素分散回各个元素:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="d02a" class="kl km hh kc b fi kn ko l kp kq">const rotate = ([first, ...rest]) =&gt; [...rest, first];</span><span id="e4d2" class="kl km hh kc b fi kr ko l kp kq">console.log( rotate([1, 2, 3]) ); // [2, 3, 1]</span></pre><h1 id="1da6" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">计算属性键</h1><p id="ffc1" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">之前，我们使用方括号计算属性访问符号来动态确定要访问的对象属性:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="46ad" class="kl km hh kc b fi kn ko l kp kq">const key = 'avatar';</span><span id="52b0" class="kl km hh kc b fi kr ko l kp kq">console.log( user[key] ); // "echo.png"</span></pre><p id="fc9d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们还可以计算要分配给的键值:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="fdea" class="kl km hh kc b fi kn ko l kp kq">const arrToObj = ([key, value]) =&gt; ({ [key]: value });</span><span id="98df" class="kl km hh kc b fi kr ko l kp kq">console.log( arrToObj([ 'foo', 'bar' ]) ); // { "foo": "bar" }</span></pre><p id="0676" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这个例子中，<code class="du jz ka kb kc b">arrToObj</code>接受一个由键/值对(也称为元组)组成的数组，并将其转换为一个对象。因为我们不知道键的名称，所以我们需要计算属性名称，以便在对象上设置键/值对。为此，我们从computed property访问器中借用方括号符号的概念，并在构建对象文字的上下文中重用它:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="3a40" class="kl km hh kc b fi kn ko l kp kq">{ [key]: value }</span></pre><p id="e785" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">插值完成后，我们得到了最终的对象:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="0ed6" class="kl km hh kc b fi kn ko l kp kq">{ "foo": "bar" }</span></pre><h1 id="7799" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">默认参数</h1><p id="543e" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">JavaScript中的函数支持默认参数值，这有几个好处:</p><ol class=""><li id="7596" class="lu lv hh iz b ja jb je jf jw lw jx lx jy ly ju lz ma mb mc bi translated">用户可以用合适的默认值省略参数。</li><li id="6937" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated">该函数更加自文档化，因为默认值提供了预期输入的示例。</li><li id="8615" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated">ide和静态分析工具可以使用默认值来推断参数的预期类型。例如，<code class="du jz ka kb kc b">1</code>的默认值意味着参数可以接受<code class="du jz ka kb kc b">Number</code>类型的成员。</li></ol><p id="53cc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">使用默认参数，我们可以为我们的<code class="du jz ka kb kc b">createUser</code>工厂记录预期的界面，如果没有提供用户信息，则自动填写<code class="du jz ka kb kc b">'Anonymous'</code>细节:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="8364" class="kl km hh kc b fi kn ko l kp kq">const createUser = ({<br/>  userName = 'Anonymous',<br/>  avatar = 'anon.png'<br/>} = {}) =&gt; ({<br/>  userName,<br/>  avatar<br/>});</span><span id="5313" class="kl km hh kc b fi kr ko l kp kq">console.log(<br/>  // { userName: "echo", avatar: 'anon.png' }<br/>  createUser({ userName: 'echo' }),</span><span id="0a16" class="kl km hh kc b fi kr ko l kp kq">  // { userName: "Anonymous", avatar: 'anon.png' }<br/>  createUser()<br/>);</span></pre><p id="1644" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">函数签名的最后一部分可能看起来有点滑稽:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="a0e2" class="kl km hh kc b fi kn ko l kp kq">} = {}) =&gt; ({</span></pre><p id="9f21" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">就在参数签名结束之前的最后一个<code class="du jz ka kb kc b">= {}</code>位意味着如果没有为这个参数传递任何东西，我们将使用一个空对象作为缺省值。当您试图从空对象中析构值时，属性的默认值将被自动使用，因为这就是默认值的作用:用一些预定义的值替换<code class="du jz ka kb kc b">undefined</code>。</p><p id="00ee" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果没有默认值<code class="du jz ka kb kc b">= {}</code>，没有参数的<code class="du jz ka kb kc b">createUser()</code>将会抛出一个错误，因为您不能尝试从<code class="du jz ka kb kc b">undefined</code>访问属性。</p><h2 id="5152" class="kl km hh bd kt mi mj mk kx ml mm mn lb jw mo mp lf jx mq mr lj jy ms mt ln mu bi translated">类型推理</h2><p id="ee19" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">在撰写本文时，JavaScript没有任何原生类型注释，但几年来出现了几种竞争格式来填补空白，包括JSDoc(由于更好的选项的出现而衰落)，<a class="ae jv" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">脸书的Flow </a>，以及<a class="ae jv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">微软的TypeScript </a>。我在文档中使用<a class="ae jv" href="https://github.com/ericelliott/rtype" rel="noopener ugc nofollow" target="_blank">rtype</a>——我发现这种符号比函数式编程的TypeScript可读性更好。</p><p id="157c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在撰写本文时，类型注释还没有明确的赢家。没有一种替代方案得到了JavaScript规范的认可，而且它们似乎都有明显的缺点。</p><p id="f4ca" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">类型推断是根据使用类型的上下文来推断类型的过程。在JavaScript中，它是类型注释的一个非常好的替代品。</p><p id="380c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您在标准JavaScript函数签名中提供了足够的推断线索，您将获得类型注释的大部分好处，而没有任何成本或风险。</p><p id="025c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">即使您决定使用像TypeScript或Flow这样的工具，您也应该尽可能多地使用类型推断，并在类型推断不充分的情况下保存类型注释。例如，JavaScript中没有指定共享接口的本地方法。这对于TypeScript或rtype来说既简单又有用。</p><p id="1763" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Tern.js 是一个流行的JavaScript类型推理工具，它为许多代码编辑器和ide提供了插件。</p><p id="9677" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">微软的Visual Studio代码不需要Tern，因为它将TypeScript的类型推断能力带到了常规的JavaScript代码中。</p><p id="1c16" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当您在JavaScript中为函数指定默认参数时，能够进行类型推断的工具(如Tern.js、TypeScript和Flow)可以提供ide提示来帮助您正确使用正在使用的API。</p><p id="a2ea" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果没有缺省值，ide(通常是人类)没有足够的提示来确定预期的参数类型。</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/c2e09d427e3103c2ecc469ef23ea6595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sP_9k1e0dkgYqdEPs0G3g.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Without defaults, the type is unknown for `userName`.</figcaption></figure><p id="f5a8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">使用缺省值，ide(通常是人类)可以从例子中推断出类型。</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/c4811b0e4d6b61d03c942f5122818253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFUXCLA8ClAzsPgZXGGR9A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">With defaults, the IDE can suggest that `userName` is expecting a string.</figcaption></figure><p id="49c9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">将参数限制为固定类型并不总是有意义的(这将使泛型函数和高阶函数变得困难)，但是当有意义时，默认参数通常是最好的方法，即使您使用的是TypeScript或Flow。</p><h1 id="fb43" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">混音合成的工厂功能</h1><p id="87eb" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">工厂非常擅长使用漂亮的调用API来生产对象。通常，它们是您所需要的全部，但是偶尔，您会发现自己在不同类型的对象中构建相似的特性，并且您会想要将这些特性抽象成功能混合，以便可以更容易地重用它们。</p><p id="c5e1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这就是功能性混音的亮点。让我们构建一个<code class="du jz ka kb kc b">withConstructor</code> mixin，将<code class="du jz ka kb kc b">.constructor</code>属性添加到所有对象实例中。</p><p id="fab0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du jz ka kb kc b">with-constructor.js</code>:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="cb2f" class="kl km hh kc b fi kn ko l kp kq">const withConstructor = constructor =&gt; o =&gt; ({<br/>  // create the delegate [[Prototype]]<br/>  __proto__: {<br/>    // add the constructor prop to the new [[Prototype]]<br/>    constructor<br/>  },<br/>  // mix all o's props into the new object<br/>  ...o<br/>});</span></pre><p id="ba72" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在您可以导入它并将其与其他mixins一起使用:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="ca97" class="kl km hh kc b fi kn ko l kp kq">import withConstructor from `./with-constructor';</span><span id="b7c3" class="kl km hh kc b fi kr ko l kp kq">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);<br/>// or `import pipe from 'lodash/fp/flow';`</span><span id="94a5" class="kl km hh kc b fi kr ko l kp kq">// Set up some functional mixins<br/>const withFlying = o =&gt; {<br/>  let isFlying = false;<br/>  return {<br/>    ...o,<br/>    fly () {<br/>      isFlying = true;<br/>      return this;<br/>    },<br/>    land () {<br/>      isFlying = false;<br/>      return this;<br/>    },<br/>    isFlying: () =&gt; isFlying<br/>  }<br/>};</span><span id="d83c" class="kl km hh kc b fi kr ko l kp kq">const withBattery = ({ capacity }) =&gt; o =&gt; {<br/>  let percentCharged = 100;<br/>  return {<br/>    ...o,<br/>    draw (percent) {<br/>      const remaining = percentCharged - percent;<br/>      percentCharged = remaining &gt; 0 ? remaining : 0;<br/>      return this;<br/>    },<br/>    getCharge: () =&gt; percentCharged,<br/>    getCapacity: () =&gt; capacity<br/>  };<br/>};</span><span id="d450" class="kl km hh kc b fi kr ko l kp kq">const createDrone = ({ capacity = '3000mAh' }) =&gt; pipe(<br/>  withFlying,<br/>  withBattery({ capacity }),<br/>  withConstructor(createDrone)<br/>)({});</span><span id="c709" class="kl km hh kc b fi kr ko l kp kq">const myDrone = createDrone({ capacity: '5500mAh' });</span><span id="dc77" class="kl km hh kc b fi kr ko l kp kq">console.log(`<br/>  can fly:  ${ myDrone.fly().isFlying() === true }<br/>  can land: ${ myDrone.land().isFlying() === false }<br/>  battery capacity: ${ myDrone.getCapacity() }<br/>  battery status: ${ myDrone.draw(50).getCharge() }%<br/>  battery drained: ${ myDrone.draw(75).getCharge() }% remaining<br/>`);</span><span id="f0b5" class="kl km hh kc b fi kr ko l kp kq">console.log(`<br/>  constructor linked: ${ myDrone.constructor === createDrone }<br/>`);</span></pre><p id="bed4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如您所见，可重用的<code class="du jz ka kb kc b">withConstructor()</code> mixin与其他mixin一起被简单地放入管道中。<code class="du jz ka kb kc b">withBattery()</code>可用于其他类型的物体，如机器人、电动滑板或便携式设备充电器。<code class="du jz ka kb kc b">withFlying()</code>可用于制作飞行汽车、火箭或热气球模型。</p><p id="3bc9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">合成更多的是一种思维方式，而不是代码中的一种特殊技术。你可以用很多方法来完成它。函数组合只是从头构建它的最简单方法，工厂函数是围绕实现细节包装友好API的简单方法。</p><h1 id="1290" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h1><p id="7a87" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">ES6为处理对象创建和工厂功能提供了方便的语法。大多数时候，这就是你所需要的，但是因为这是JavaScript，有另一种方法让它看起来更像Java:关键字<code class="du jz ka kb kc b">class</code>。</p><p id="ffad" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中，类比工厂更加冗长和严格，并且在重构时有点像雷区，但它们也已经被React和Angular等主要前端框架所接受，并且有几个罕见的用例使复杂性变得值得。</p><blockquote class="it iu iv"><p id="ebef" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“有时候，优雅的实现只是一个函数。不是方法。不是一个班。不是框架。只是一个功能。”~约翰·卡马克</p></blockquote><p id="383a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">从最简单的实现开始，只在需要时才转向更复杂的实现。</p><p id="57bb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><a class="ae jv" rel="noopener" href="/javascript-scene/why-composition-is-harder-with-classes-c3e627dcd0aa"> <strong class="iz hi"> <em class="iy">接下来:为什么跟班作文更难&gt; </em> </strong> </a></p><h1 id="8818" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">后续步骤</h1><p id="e44a" class="pw-post-body-paragraph iw ix hh iz b ja lp jc jd je lq jg jh jw lr jk jl jx ls jo jp jy lt js jt ju ha bi translated">想了解更多关于用JavaScript进行对象组合的知识吗？</p><p id="6a7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><a class="ae jv" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟Eric Elliott学JavaScript】。如果你不是会员，你就错过了！</a></p><figure class="kd ke kf kg fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es mx"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">是一位科技产品和平台顾问，《T5】 <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【作曲软件】</em></a><em class="iy"/><a class="ae jv" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="iy">【EricElliottJS.com】</em></a><em class="iy"/><a class="ae jv" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="iz hi"> <em class="iy">、Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">【华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【BBC】</em></strong><em class="iy">等顶级录音艺人和包括</em> <strong class="iz hi"> <em class="iy"> Usher、【Metallica】</em></strong></em></p><p id="98ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>