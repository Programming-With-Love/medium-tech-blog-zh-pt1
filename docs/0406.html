<html>
<head>
<title>WorkManager periodicity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作管理器周期</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/workmanager-periodicity-ff35185ff006?source=collection_archive---------0-----------------------#2019-06-14">https://medium.com/androiddevelopers/workmanager-periodicity-ff35185ff006?source=collection_archive---------0-----------------------#2019-06-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/739581b125423e435cd00a9f47a7b6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbuR_lQZI5qGOL76"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="2ccc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">欢迎来到我们的工作管理器系列的第四篇文章。WorkManager是一个Android Jetpack库，它使得调度必须可靠运行的可推迟的异步任务变得容易。这是目前Android上大多数后台工作的最佳实践。<br/>如果您一直在关注，我们已经讨论了:</p><ul class=""><li id="e9ea" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/introducing-workmanager-2083bcfc4712">什么是工作管理器，什么时候使用工作管理器</a>。</li><li id="bc66" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-basics-beba51e94048">如何使用工作管理器API调度工作</a></li><li id="ef5f" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-meets-kotlin-b9ad02f7405e">工作管理器的Kotlin扩展和</a> <code class="du kg kh ki kj b"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-meets-kotlin-b9ad02f7405e">CoroutineWorker</a></code></li></ul><p id="e7f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博文中，我将介绍:</p><ul class=""><li id="036b" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">定义定期工作</li><li id="fb47" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">取消工作</li><li id="e3e5" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">自定义工作管理器配置</li></ul><h1 id="ba86" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">重复工作</h1><p id="2683" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">在之前的博客中，我们已经看到你可以使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" rel="noopener ugc nofollow" target="_blank">OneTimeWorkRequest</a></code>来安排工作，但是如果你希望你的工作定期重复，你可以使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" rel="noopener ugc nofollow" target="_blank">PeriodicWorkRequest</a></code>。</p><p id="7738" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们来看看这两种类型的<code class="du kg kh ki kj b">WorkRequest</code>有什么区别:</p><ul class=""><li id="4893" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">最小周期长度为15分钟(与<a class="ae hu" href="https://developer.android.com/reference/android/app/job/JobScheduler" rel="noopener ugc nofollow" target="_blank">作业调度器</a>相同)</li><li id="fa8a" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">工人类不能在<code class="du kg kh ki kj b">PeriodicWorkRequest</code>中链接</li><li id="1203" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">在v2.1-alpha02之前，不可能创建具有初始延迟的<code class="du kg kh ki kj b">PeriodicWorkRequest</code>。</li></ul><p id="2fea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在会议上遇到的一些最常见的问题是关于周期性工作的。在本文中，我将介绍周期性工作的基础知识、一些常见的用例以及一些常见的错误。此外，我们将介绍几种为工人类编写测试的方法。</p><h1 id="9df5" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">应用程序接口</h1><p id="dcae" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">构建周期性工作请求的调用与我们看到的一次性工作没有太大的不同。我们有一个额外的参数来指定最小重复间隔:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="af9b" class="lv kl hx kj b fi lw lx l ly lz">val work = PeriodicWorkRequestBuilder&lt;MyWorker&gt;(1, TimeUnit.HOURS)<br/>                   .build()</span></pre><p id="8a8e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它被称为最小间隔，因为Android的电池优化，因为你可以限制延长重复之间的时间。例如，如果您指定工作仅在设备充电时运行，即使您的最小间隔已过，如果设备未充电，此工作也不会运行，直到设备接通电源。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div class="ab fe cl ma"><img src="../Images/70b3967104ff0b4118042465b86576d7.png" data-original-src="https://miro.medium.com/v2/0*q3Y_JZcx8H-e6ARs"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">PeriodicWorkRequest with a charging constraints</figcaption></figure><p id="da6e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，我们向<code class="du kg kh ki kj b">PeriodicWorkRequest</code>添加一个收费约束，并对其进行排队:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="6aeb" class="lv kl hx kj b fi lw lx l ly lz">val constraints = Constraints.Builder()<br/>                   .setRequiresCharging(true)<br/>                   .build()</span><span id="cce3" class="lv kl hx kj b fi mb lx l ly lz">val work = PeriodicWorkRequestBuilder&lt;MyWorker&gt;(1, TimeUnit.HOURS)<br/>                   .setConstraints(constraints)<br/>                   .build()</span><span id="f946" class="lv kl hx kj b fi mb lx l ly lz">val workManager = WorkManager.getInstance(context)<br/>workManager.enqueuePeriodicWork(work)</span></pre><p id="848e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于如何检索WorkManager实例的说明。</p><blockquote class="mc md me"><p id="9738" class="iu iv mf iw b ix iy iz ja jb jc jd je mg jg jh ji mh jk jl jm mi jo jp jq jr ha bi translated">工作管理器v2.1已经废弃了<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager.html#getInstance()" rel="noopener ugc nofollow" target="_blank">WorkManager#getInstance()</a></code>，现在有了一个新的<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager.html#getInstance(android.content.Context)" rel="noopener ugc nofollow" target="_blank">WorkManager#getInstance(context: Context)</a></code>，它以同样的方式工作，但支持新的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#on-demand" rel="noopener ugc nofollow" target="_blank">按需初始化</a>。在本文中，我将使用这种新语法，它要求我们传递一个上下文来检索WorkManager实例。</p></blockquote><p id="f1d9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于“最小间隔”的提醒。WorkManager正在平衡两种不同的需求:应用程序及其<code class="du kg kh ki kj b">WorkRequest</code>，以及Android操作系统限制电池消耗的需求。出于这个原因，即使满足了对一个<code class="du kg kh ki kj b">WorkRequest</code>设置的所有约束，您的工作仍然会有一些额外的延迟。</p><p id="e38b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android包括一套电池优化策略:当用户不使用设备时，操作系统会最大限度地减少活动以保存电池。如果您的设备处于<a class="ae hu" href="https://developer.android.com/training/monitoring-device-state/doze-standby" rel="noopener ugc nofollow" target="_blank">休眠模式</a>，则运行工作可能会延迟到下一个<a class="ae hu" href="https://developer.android.com/training/monitoring-device-state/doze-standby#understand_doze" rel="noopener ugc nofollow" target="_blank">维护窗口</a>。</p><h1 id="6ba6" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">区间和弹性区间</h1><p id="2407" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">正如我们所看到的，工作管理器并不是以精确的时间间隔执行。如果这是您的需求，那么您就找错了API。鉴于重复间隔实际上是一个最小间隔，WorkManager提供了一个额外的参数，您可以使用它来指定Android可以执行您的工作的窗口。</p><p id="1787" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，您可以指定第二个间隔来控制何时允许您的定期工作器在重复周期的一部分内运行。第二个间隔(灵活间隔)位于重复间隔本身的末尾。</p><p id="78e9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子。假设您想要构建一个周期为30分钟的周期性工作请求。您可以指定一个小于此时间段的弹性时间间隔，比如15分钟的弹性时间间隔。</p><p id="4954" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用该参数构建<code class="du kg kh ki kj b">PeriodicWorkPequest</code>的实际代码是:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="4a83" class="lv kl hx kj b fi lw lx l ly lz">val logBuilder = PeriodicWorkRequestBuilder&lt;MyWorker&gt;(<br/>                         30, TimeUnit.MINUTES, <br/>                         15, TimeUnit.MINUTES)</span></pre><p id="15df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果是，我们的工人将在下半段时间内被处决(灵活间隔时间总是位于重复周期的末尾):</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/354be0680c8aa7d1dabb9af121c11dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BhKfF2c5AVgzBndl"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">PeriodicWorkRequest with a 30' Interval and a 15' flexInterval</figcaption></figure><p id="4198" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，这些计时总是取决于工作请求中包含的约束条件以及设备的状态。</p><p id="bbd9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解更多关于该功能的信息，您可以阅读<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest.Builder" rel="noopener ugc nofollow" target="_blank">PeriodicWorkRequest.Builder</a></code> <a class="ae hu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest.Builder" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="9f6c" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">日常工作</h1><p id="130f" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">因为周期间隔并不精确，所以您不能构建每天在特定时间执行的周期工作请求。即使我们放松精度也不行。</p><p id="cd47" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以指定一个24小时的期限，但是因为工作是根据安卓的电池优化策略来执行的，您只能期望您的工人在这个时间左右被执行。然后，您可以在第一天早上5:00、第二天早上5:25、第三天早上5:15，然后第二天早上5:30执行，依此类推。随着时间的推移，误差会越来越大。</p><p id="1bd0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">来自<a class="ae hu" href="https://github.com/evernote/android-job" rel="noopener ugc nofollow" target="_blank"> Evernote Android-Job </a>库的开发人员有时会要求在指定时间运行日常工作。</p><p id="f85b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">目前，如果您需要每天大致在同一时间<strong class="iw hy"/>处决一名工人，您最好的选择是使用带有初始延迟的<code class="du kg kh ki kj b">OneTimeWorkRequest</code>，以便在正确的时间执行:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="c3fb" class="lv kl hx kj b fi lw lx l ly lz">This is my new defaultval currentDate = Calendar.getInstance()<br/>val dueDate = Calendar.getInstance()</span><span id="48d5" class="lv kl hx kj b fi mb lx l ly lz">// Set Execution around 05:00:00 AM<br/>dueDate.set(Calendar.HOUR_OF_DAY, 5)<br/>dueDate.set(Calendar.MINUTE, 0)<br/>dueDate.set(Calendar.SECOND, 0)</span><span id="b0f9" class="lv kl hx kj b fi mb lx l ly lz">if (dueDate.before(currentDate)) {<br/>    dueDate.add(Calendar.HOUR_OF_DAY, 24)<br/>}<br/>val timeDiff = dueDate.timeInMillis — currentDate.timeInMillis<br/>val dailyWorkRequest = OneTimeWorkRequestBuilder&lt;DailyWorker&gt; <br/>        .setConstraints(constraints) .setInitialDelay(timeDiff, TimeUnit.MILLISECONDS)<br/>         .addTag(TAG_OUTPUT) .build()</span><span id="e26a" class="lv kl hx kj b fi mb lx l ly lz">WorkManager.getInstance(context).enqueue(dailyWorkRequest)</span></pre><p id="eccd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将处理第一次执行。当我们成功完成时，我们需要将这项工作的下一次执行排队:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="55ce" class="lv kl hx kj b fi lw lx l ly lz">class DailyWorker(ctx: Context, params: WorkerParameters) : Worker(ctx, params) {</span><span id="a443" class="lv kl hx kj b fi mb lx l ly lz">  override fun doWork(): Result {<br/>    val currentDate = Calendar.getInstance()<br/>    val dueDate = Calendar.getInstance()</span><span id="f8d6" class="lv kl hx kj b fi mb lx l ly lz">    // Set Execution around 05:00:00 AM<br/>    dueDate.set(Calendar.HOUR_OF_DAY, 5)<br/>    dueDate.set(Calendar.MINUTE, 0)<br/>    dueDate.set(Calendar.SECOND, 0)</span><span id="4720" class="lv kl hx kj b fi mb lx l ly lz">    if (dueDate.before(currentDate)) { <br/>      dueDate.add(Calendar.HOUR_OF_DAY, 24)<br/>    }</span><span id="05ce" class="lv kl hx kj b fi mb lx l ly lz">    val timeDiff = dueDate.timeInMillis — currentDate.timeInMillis</span><span id="caa1" class="lv kl hx kj b fi mb lx l ly lz">    val dailyWorkRequest = OneTimeWorkRequestBuilder&lt;DailyWorker&gt;()<br/>            .setInitialDelay(timeDiff, TimeUnit.MILLISECONDS)<br/>            .addTag(TAG_OUTPUT)<br/>            .build()</span><span id="ebb5" class="lv kl hx kj b fi mb lx l ly lz">    WorkManager.getInstance(applicationContext)<br/>            .enqueue(dailyWorkRequest)</span><span id="c0e1" class="lv kl hx kj b fi mb lx l ly lz">return Result.success()<br/>  }<br/>}</span></pre><p id="935b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，工作者被执行的确切时间取决于您在工作请求中使用的约束以及Android平台所做的优化。</p><h1 id="4334" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">定期工作的状态</h1><p id="44a5" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">我们发现，与一次性工作相比，周期性工作的区别之一是不可能用周期性工作请求来构建工作链。这种限制的原因是，在工作链中，当一个工人转换到<code class="du kg kh ki kj b">SUCCEEDED</code>状态时，您会从一个工人转换到链中的下一个工人。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/065fb9d48cef0fd05f5a7c5c35c3fe5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_CmmoONDkgcmadix"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><code class="du kg kh ki kj b">PeriodicWorkRequest</code> states</figcaption></figure><blockquote class="mc md me"><p id="3cd0" class="iu iv mf iw b ix iy iz ja jb jc jd je mg jg jh ji mh jk jl jm mi jo jp jq jr ha bi translated">周期性工作<strong class="iw hy">永远不会</strong>结束于<code class="du kg kh ki kj b">SUCCEEDED</code>状态；它会一直运行，直到被取消。当你从一个周期工作者调用<code class="du kg kh ki kj b">Result#success()</code>或<code class="du kg kh ki kj b">Result#failure()</code>时，它转换回<code class="du kg kh ki kj b">ENQUEUED</code>状态，等待下一次执行。</p></blockquote><p id="5377" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，当您处理周期性工作时，您不能构建链，甚至不能处理唯一的工作请求。在这种情况下，周期性的工作请求失去了追加工作的能力:您只能使用<code class="du kg kh ki kj b">KEEP</code>和<code class="du kg kh ki kj b">REPLACE</code>，而不能使用<code class="du kg kh ki kj b">APPEND</code>。</p><h1 id="1547" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">数据输入和输出</h1><p id="b2b4" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">WorkManager允许您将一个数据对象传递给worker，并在成功或失败调用时返回一个新的数据对象(当您返回一个<code class="du kg kh ki kj b">Result#retry()</code>时，没有数据输出选项，因为worker执行是无状态的)。</p><p id="7d69" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在一次性工人链中，从一个工人返回的输出成为链中下一个工人的输入。正如我们已经看到的，周期性的工作不能在工作链中使用，因为它真的从来没有“成功地”完成；它只能以取消结束。</p><p id="38d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么，我们在哪里可以看到和使用用<code class="du kg kh ki kj b">Result#success(outData)</code>返回的数据呢？</p><p id="89e1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以通过<code class="du kg kh ki kj b">PeriodicWorkRequest</code>的WorkInfo观察这些数据，但是只能观察到下一次执行周期性工作，并且我们只能依靠处于<code class="du kg kh ki kj b">ENQUEUED</code>状态的工人来检查其输出:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="5e41" class="lv kl hx kj b fi lw lx l ly lz">val myPeriodicWorkRequest =<br/>        PeriodicWorkRequestBuilder&lt;MyPeriodicWorker&gt;(1, TimeUnit.HOURS).build()</span><span id="2154" class="lv kl hx kj b fi mb lx l ly lz">WorkManager.getInstance(context).enqueue(myPeriodicWorkRequest)</span><span id="4dc0" class="lv kl hx kj b fi mb lx l ly lz">WorkManager.getInstance()<br/>        .getWorkInfoByIdLiveData(myPeriodicWorkRequest.id)<br/>        .observe(lifecycleOwner, Observer { workInfo -&gt; <br/>  if ((workInfo != null) &amp;&amp; <br/>      (workInfo.state == WorkInfo.State.ENQUEEDED)) {<br/>    val myOutputData = workInfo.outputData.getString(KEY_MY_DATA)<br/>  }<br/>})</span></pre><p id="ad3a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您需要定期员工提供一些结果，这可能不是您的最佳选择。更好的选择是通过另一种媒介传递数据，比如数据库中的表。</p><p id="b5dd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有关如何检索工作状态的更多信息，您可以参考本系列的第二篇博文<a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-basics-beba51e94048">和工作管理器文档:</a><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/states-and-observation" rel="noopener ugc nofollow" target="_blank">工作状态和观察工作</a>。</p><h1 id="d51a" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">独特的作品</h1><p id="5d73" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">一些工作管理器用例可能会陷入一种模式，即应用程序一启动就将一些工作排入队列。这可以是您希望定期运行的后台同步任务，也可以是计划的内容下载。不管它是什么，常见的模式是，应用程序一启动，它就需要排队。</p><p id="625b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我见过这种模式出现几次，在您的<code class="du kg kh ki kj b">Application#onCreate</code>中，开发人员创建一个工作请求并将其排队。一切都很好，直到你发现同一个工作运行了两次或更多次。如果没有取消，这对于永远不会到达最终状态的周期性工作尤其相关。</p><p id="09ef" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们喜欢说，即使您的应用程序关闭或设备重启，WorkManager也能保证您工作的执行。因此，在每次启动应用程序时让您的工作线程入队会导致每次都添加一个新的<code class="du kg kh ki kj b">WorkRequest</code>。如果你用的是<code class="du kg kh ki kj b">OneTimeWorkRequest</code>，这可能没什么大不了的。一旦工作运行完成，它就完成了。但是对于周期性工作，“完成”是一个不同的概念，您可以很容易地将多个周期性工作请求排入队列。</p><p id="fa1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种情况下的解决方案是使用<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/WorkManager.html#enqueueUniquePeriodicWork(java.lang.String,%20androidx.work.ExistingPeriodicWorkPolicy,%20androidx.work.PeriodicWorkRequest)" rel="noopener ugc nofollow" target="_blank">WorkManager#enqueueUniquePeriodicWork()</a></code>将您的<code class="du kg kh ki kj b">WorkRequest</code>作为唯一工作排队:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="9d25" class="lv kl hx kj b fi lw lx l ly lz">class MyApplication: Application() {</span><span id="fd14" class="lv kl hx kj b fi mb lx l ly lz">  override fun onCreate() {<br/>    super.onCreate()<br/>    val myWork = PeriodicWorkRequestBuilder&lt;MyWorker&gt;(<br/>                         1, TimeUnit.HOURS)<br/>                         .build()</span><span id="b912" class="lv kl hx kj b fi mb lx l ly lz">    WorkManager.getInstance(this).enqueueUniquePeriodicWork(<br/>        “MyUniqueWorkName”,<br/>        ExistingPeriodicWorkPolicy.KEEP,<br/>        myWork)<br/>  }<br/>}</span></pre><p id="3117" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这可以避免您多次将工作排入队列。</p><h2 id="242b" class="lv kl hx bd km mk ml mm kq mn mo mp ku jf mq mr ky jj ms mt lc jn mu mv lg mw bi translated">保留还是替换？</h2><p id="fc60" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">你选择这些政策中的哪一个，实际上取决于你对你的员工做了什么。就个人而言，我默认使用<code class="du kg kh ki kj b">KEEP</code>策略，因为它更轻量级，不需要替换现有的<code class="du kg kh ki kj b">WorkRequest</code>。它还避免了取消已经运行的工作线程的可能性。</p><p id="0429" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">只有在有充分理由的情况下，我才会切换到<code class="du kg kh ki kj b">REPLACE</code>策略(例如，如果我想从<code class="du kg kh ki kj b">doWork()</code>方法中重新调度<code class="du kg kh ki kj b">Worker</code>)。</p><p id="cdfe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您选择一个<code class="du kg kh ki kj b">REPLACE</code>策略，那么您的Worker应该能够优雅地处理停止，因为如果在Worker运行时有一个新的<code class="du kg kh ki kj b">WorkRequest</code>加入队列，那么WorkManager可能必须取消一个正在运行的实例。但是您无论如何都应该这样做，因为如果在Worker的执行过程中不再满足约束，WorkManager可能会停止您的工作。</p><p id="6f57" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于独特作品的更多信息，可以参考文档:<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work" rel="noopener ugc nofollow" target="_blank">独特作品</a>。</p><h1 id="1582" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">测试定期工作</h1><p id="ecf6" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing" rel="noopener ugc nofollow" target="_blank"> WorkManager的测试文档</a>非常全面，涵盖了基本场景。在WorkManager v2.1发布后，现在有两种方法来测试您的员工:</p><ul class=""><li id="a094" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/testing/WorkManagerTestInitHelper" rel="noopener ugc nofollow" target="_blank">WorkManagerTestInitHelper</a></code></li><li id="48e9" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/testing/TestWorkerBuilder" rel="noopener ugc nofollow" target="_blank">TestWorkerBuilder</a></code>和<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/testing/TestListenableWorkerBuilder" rel="noopener ugc nofollow" target="_blank">TestListenableWorkerBuilder</a></code></li></ul><p id="40f8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<code class="du kg kh ki kj b">WorkManagerTestInitHelper</code>您可以测试您的工人类模拟延迟，满足约束和周期要求。这种测试工人的方法的优点是，它可以处理工人将自己或另一个工人类排队的情况(就像我们在上面看到的示例中一样，我们实现了一个“DailyWorker ”,它在每天大致相同的时间运行。要了解这方面的更多信息，您可以阅读WorkManager的<a class="ae hu" href="https://d.android.com/topic/libraries/architecture/workmanager/how-to/integration-testing" rel="noopener ugc nofollow" target="_blank">测试文档</a>。</p><p id="80b9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你需要测试一个<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker.html" rel="noopener ugc nofollow" target="_blank">CoroutineWorker</a></code>、<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/RxWorker.html" rel="noopener ugc nofollow" target="_blank">RxWorker</a></code>或者<code class="du kg kh ki kj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/ListenableWorker" rel="noopener ugc nofollow" target="_blank">ListenableWorker</a></code>，使用<code class="du kg kh ki kj b">WorkManagerTestInitHelper</code>会有一些额外的复杂性，因为你不能依赖它的<code class="du kg kh ki kj b">SynchronousExecutor</code>。</p><p id="0319" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更直接地测试这些类，WorkManager v2.1包含了一组新的WorkRequest builder:</p><ul class=""><li id="602c" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><code class="du kg kh ki kj b">TestWorkerBuilder</code>直接调用工人类</li><li id="c6ab" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><code class="du kg kh ki kj b">TestListenableWorkerBuilder</code>直接调用<code class="du kg kh ki kj b">ListenableWorker</code>、<code class="du kg kh ki kj b">RxWorker</code>或<code class="du kg kh ki kj b">CoroutineWorker</code></li></ul><p id="ccbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这样做的好处是，您可以测试任何类型的工人类，因为在这种情况下，您可以直接运行它。</p><p id="fc14" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing-210" rel="noopener ugc nofollow" target="_blank">文档</a>中读到更多关于这些的内容，并且您可以在<a class="ae hu" href="https://github.com/googlesamples/android-sunflower/blob/master/app/src/androidTest/java/com/google/samples/apps/sunflower/worker/SeedDatabaseWorkerTest.kt" rel="noopener ugc nofollow" target="_blank">向日葵示例应用</a>中看到使用这些新构建器的测试示例:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="8541" class="lv kl hx kj b fi lw lx l ly lz">import android.content.Context<br/>import androidx.test.core.app.ApplicationProvider<br/>import androidx.work.ListenableWorker.Result<br/>import androidx.work.WorkManager<br/>import androidx.work.testing.TestListenableWorkerBuilder<br/>import com.google.samples.apps.sunflower.workers.SeedDatabaseWorker<br/>import org.hamcrest.CoreMatchers.`is`<br/>import org.junit.Assert.assertThat<br/>import org.junit.Before<br/>import org.junit.Test<br/>import org.junit.runner.RunWith<br/>import org.junit.runners.JUnit4</span><span id="b229" class="lv kl hx kj b fi mb lx l ly lz">@RunWith(JUnit4::class)<br/>class RefreshMainDataWorkTest {</span><span id="3275" class="lv kl hx kj b fi mb lx l ly lz">  private lateinit var context: Context</span><span id="2ed0" class="lv kl hx kj b fi mb lx l ly lz">  @Before<br/>  fun setup() {<br/>    context = ApplicationProvider.getApplicationContext()<br/>  }</span><span id="76cb" class="lv kl hx kj b fi mb lx l ly lz">  @Test<br/>  fun testRefreshMainDataWork() {<br/>    // Get the ListenableWorker<br/>    val worker = TestListenableWorkerBuilder&lt;SeedDatabaseWorker&gt;(context).build()</span><span id="281d" class="lv kl hx kj b fi mb lx l ly lz">    // Start the work synchronously<br/>    val result = worker.startWork().get()<br/>    assertThat(result, `is`(Result.success()))<br/>  }<br/>}</span></pre><h1 id="340f" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="2955" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">我希望这篇文章对你有用，我很想知道你是如何使用WorkManager的，或者WorkManager的哪些特性可以得到更好的解释或记录。</p><p id="ec7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以通过推特<a class="ae hu" href="https://twitter.com/pfmaggi" rel="noopener ugc nofollow" target="_blank"> @pfmaggi </a>联系到我。</p><h1 id="27f5" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">工作经理的资源</h1><ul class=""><li id="95d8" class="js jt hx iw b ix li jb lj jf mx jj my jn mz jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager/" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="c3c3" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/reference/androidx/work/package-summary" rel="noopener ugc nofollow" target="_blank">参考指南</a></li><li id="c8cd" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/work" rel="noopener ugc nofollow" target="_blank">工作管理器发行说明</a></li><li id="fb8f" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/index.html" rel="noopener ugc nofollow" target="_blank"> Codelab </a></li><li id="0725" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/introducing-workmanager-2083bcfc4712">介绍WorkManager博客文章</a></li><li id="43ab" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-basics-beba51e94048">工作管理器基础博客文章</a></li><li id="abc4" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/workmanager-meets-kotlin-b9ad02f7405e">工作经理会见科特林博客文章</a></li><li id="e1aa" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/master/work" rel="noopener ugc nofollow" target="_blank">源代码(AOSP的一部分)</a></li><li id="cbc3" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">使用work manager(2018年Android开发峰会)演示文稿</a></li><li id="a0ad" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://issuetracker.google.com/issues?q=componentid:409906" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a></li><li id="09af" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://stackoverflow.com/questions/tagged/android-workmanager" rel="noopener ugc nofollow" target="_blank">关于StackOverflow的工作管理器问题</a></li><li id="7be6" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://android-developers.googleblog.com/search/label/Power%20series" rel="noopener ugc nofollow" target="_blank">谷歌的Power博客文章系列</a></li></ul></div></div>    
</body>
</html>