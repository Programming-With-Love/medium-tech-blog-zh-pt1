<html>
<head>
<title>19 tips for Gradle in Android projects — 2019 Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android项目中Gradle的19个提示— 2019版</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/19-tips-for-gradle-in-android-projects-2019-edition-11af704eb06e?source=collection_archive---------1-----------------------#2019-05-19">https://medium.com/google-developer-experts/19-tips-for-gradle-in-android-projects-2019-edition-11af704eb06e?source=collection_archive---------1-----------------------#2019-05-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c6b887c5ffa88a85ad2035cb3108dc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROtLiywLehTgpfJ71haXFw.png"/></div></div></figure><p id="5dc5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Google I/O 2019上，我们与Gradle在Android项目上进行了两场精彩的会谈:<a class="ae jn" href="http://What's New in the Android Studio Build System" rel="noopener ugc nofollow" target="_blank">“Android Studio构建系统的新功能”</a>和“构建更大、更好:Gradle用于大型项目”。</p><p id="9447" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是上一篇文章的总结，用例子解释了不同的建议。我知道这个标题可能有点吸引人，但是从字面上看，这个演示中有19个很棒的技巧。</p><p id="f137" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">会议由Xavier Ducrohet和Aurimas Liutikas主持:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="2e60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">介绍分为三个部分:模块化，配置和调查。强烈推荐你和你的团队一起看。让我们一节一节地看:</p><h1 id="75d8" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">模块化</h1><p id="0015" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">如今，模块化在Android世界无处不在。如果你还需要更多信息，你有极好的资源<a class="ae jn" href="https://jeroenmols.com/blog/2019/04/02/modularizationexample/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jn" rel="noopener" href="/androiddevelopers/a-patchwork-plaid-monolith-to-modularized-app-60235d9f212e">这里</a>。甚至在今年的I/O大会上，也有一个关于Android模块化良好实践的<a class="ae jn" href="https://www.youtube.com/watch?v=PZBg5DIzNww" rel="noopener ugc nofollow" target="_blank">演讲。</a></p><p id="393e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">今天，我们在团队中根据特性或架构的特定部分工作，为什么我们要对项目中我们不接触的部分进行重建呢？除了从架构角度来看的好处(当然还有测试)，模块化与Gradle Build系统非常匹配。对于大型整体项目，很难获得缓存或避免编译这样的好处。</p><p id="b109" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 1-创建纯Java/Kotlin库</strong></p><p id="3a70" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个技巧是尽可能创建纯Kotlin/Java模块。自从Android世界采用了干净架构的概念后，开发者越来越不依赖于框架。例如，如果您的领域层中有您的业务逻辑，这些模块不需要使用Android依赖项。通常，这些模块将是纯Kotlin/Java实现，不引用框架。最后，从架构角度讲，Android将是你的业务逻辑的实现细节。</p><p id="5b2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于构建系统，拥有一个纯Java/Kotlin对构建有影响。这里你可以看到基本<code class="du kx ky kz la b">java</code>插件的<code class="du kx ky kz la b">:libjava:assemble</code>的任务依赖图:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/530b6b17930c7d051d0f39f74fd2760e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*0ynyCK44jw2f-1EbCJTRGA.png"/></div></div></figure><p id="357a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来很简单，我们只有5个任务，如果我们想显示一个简单的<code class="du kx ky kz la b">com.android.library</code>的<code class="du kx ky kz la b">:lib1:assembleDebug</code>的任务依赖图，这个图是:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/6ed1ed45950f252c84914e0da025a3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuGWpml9oNmzvq4is3cYeA.png"/></div></div></figure><p id="0e28" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很明显哪个任务会更快。这个建议不仅仅适用于领域层。当你不依赖Android时，你可以应用于你的特定架构。</p><p id="e51c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2- <strong class="ir hi">仅应用需要的插件</strong></p><p id="ac09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的项目中使用插件是很正常的，但有时要么因为我们不知道，要么因为我们在复制和粘贴，我们会在配置文件中包含不需要的插件。</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="8b30" class="lh jv hh la b fi li lj l lk ll">apply plugin: 'com.android.application'<br/>apply plugin: 'kotlin-android'<br/>apply plugin: 'kotlin-android-extensions'<br/>apply plugin: 'maven-publish'<br/>apply plugin: 'kotlin-kapt'<br/>apply plugin: 'talaiot'<br/>apply plugin: 'com.github.triplet.play'</span></pre><p id="d3d0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Gradle的配置阶段，为应用到每个模块的每个插件配置任务，在我们的构建中增加了额外的时间和资源开销。</p><p id="6dca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是要仔细检查我们的配置文件中是否需要插件，并确定插件在独立模块中的使用范围。</p><p id="07ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3范围注释处理器</strong></p><p id="2c02" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注释处理在我们的构建中仍然是一项昂贵的任务。从Gradle 4.7开始，我们可以使用增量处理。一些最流行的注释处理器库已经更新，以符合增量处理准则。</p><p id="5ce0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">演示中的建议是将注释处理器的使用隔离在一个独立的模块中。</p><p id="6a0f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">提醒一下，从Kotlin 1.3.30开始，KAPT现在以实验模式支持增量注释处理器，您可以更新<code class="du kx ky kz la b">gradle.properties</code>中的值:</p><p id="69e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kx ky kz la b">kapt.incremental.apt=true</code></p><p id="0cad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 4-在最终应用模块上运行Lint</strong></p><p id="db90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">lint工具检查可能影响Android应用程序质量和性能的结构代码问题。强烈建议您在发布应用程序之前更正lint检测到的任何错误。</p><p id="c2e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在模块化项目中，我们可能会浪费时间在所有模块中运行lint。这里的建议是通过在最终的app模块上运行lint来避免重复工作。Lint将运行最终的模块和二进制依赖项。</p><p id="264f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 5-使用api和实施配置</strong></p><p id="5581" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Gradle 3.4引入了新的配置实现/api。实现/api包括术语“配置避免”，这有助于防止泄漏多模块项目的可传递依赖关系。</p><p id="4bca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出现在<code class="du kx ky kz la b">api</code>配置中的依赖项将被传递给库的消费者。在<code class="du kx ky kz la b">implementation</code>配置中发现的依赖项不会向消费者公开。</p><p id="1ec6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<em class="lm">Android Studio构建系统的新特性</em>中，他们详细解释了在4个模块的用例中使用API/实现的影响:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/6caf2a72a0cdacbabbc1169a5444a827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnNYS22YQ03TkHqyA-q3Yw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx"><a class="ae jn" href="https://www.youtube.com/watch?v=LFRCzsD7UhY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=LFRCzsD7UhY</a></figcaption></figure><p id="6b98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在你的依赖模块中使用api/implementation，不管怎样，如果你使用<code class="du kx ky kz la b">compile</code>，Gradle会显示一个警告</p><p id="602b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 6-版本依赖关系的额外配置</strong></p><p id="02bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在模块化的世界里，不同的模块使用相同的库是一个典型的例子。例如，在您的特性ui模块中，您正在使用相同的recyclerview依赖项<code class="du kx ky kz la b">androidx.recyclerview:recyclerview:1.0.0</code>。如果您有20个模块，并且您想要更新一个依赖项的版本，您会注意到用新版本更新每个模块并不是非常理想的过程。</p><p id="94af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以通过对所有模块可见的配置文件中的依赖项和版本进行扩展来集中这种版本控制:</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="30ed" class="lh jv hh la b fi li lj l lk ll">ext.versions = [<br/>        'compileSdk'         : 28,<br/>        'minSdk'             : 23,<br/>        'targetSdk'          : 28,<br/>        'appcompat'          : '1.1.0-alpha04',<br/>        'androidx'           : '1.0.0',<br/>        'androidxCollection' : '1.0.0'<br/>]</span></pre><p id="2531" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自4-5年前以来，演示中解释的这个技巧在Android世界中广泛使用。我相信你们所有人都曾在某个项目中使用过这种技术。</p><p id="b124" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 7 —为版本依赖关系构建src</strong></p><p id="0ca5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更好的版本依赖方法是使用<code class="du kx ky kz la b">buildSrc</code>。按照惯例，Gradle会自动编译和测试<code class="du kx ky kz la b">buildSrc</code>代码，并将其放入构建脚本的类路径中。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/ee1c5f00e6bb394f3aa0f48c9d2269ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*pz4aeTZ-scGNHRdUmbCfIg.png"/></div></figure><p id="29f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您只需要在根文件夹中创建一个名为<code class="du kx ky kz la b">buildSrc</code>的模块。当然，你可以用科特林</p><p id="54e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们的示例，我们将创建Dependencies(com . Dependencies . Dependencies . kt)类，并将定义不同模块的依赖项和版本:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/df2237586c6353fee2c4c96c4184df4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkKBHeMJeZU0UWiBtVMkKg.png"/></div></div></figure><p id="dae9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦编译完成，这个类就包含在我们项目的类路径中，我们可以在我们的<code class="du kx ky kz la b">build.grade</code>配置文件中使用它(是的，带有自动完成功能):</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="8323" class="lh jv hh la b fi li lj l lk ll">implementation(Dependencies.supportAppcompat)<br/>implementation(Dependencies.supportRecycler)<br/>implementation(Dependencies.supportCardView)<br/>implementation(Dependencies.workManager)</span></pre><p id="8118" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 8-实现定制插件</strong></p><p id="20e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在了解了在类路径中包含依赖项的好处之后，我们可以更进一步。</p><p id="e2d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">演示中引用的最酷的想法之一是在<code class="du kx ky kz la b">buildSrc</code>中定义和定制插件，以封装逻辑并减小配置文件的大小。</p><p id="7675" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我想提一下<a class="lu lv ge" href="https://medium.com/u/71457ef24fa1?source=post_page-----11af704eb06e--------------------------------" rel="noopener" target="_blank"> Anton Malinskiy </a>，去年我们是Agoda实施这种方法的先锋，通过不同的插件降低了构建配置的复杂性。</p><p id="673f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们来看一个例子，我们想创建一个插件，在我们的模块中封装Android库插件的逻辑(<code class="du kx ky kz la b">com.android.library</code>)。第一件事是创建插件:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="989e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该插件将应用Android库插件，然后我们在检索库扩展时应用一个配置，<code class="du kx ky kz la b">configure</code>是库扩展的一个扩展函数:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="4da7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们需要在<code class="du kx ky kz la b">buildSrc</code>文件夹的<code class="du kx ky kz la b">build.gradle.kts</code>中注册插件:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="113c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这使我们有可能为我们的android库模块定义配置文件，例如:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="7ffe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">漂亮吧？这只是一个基本的例子，但是你可以实现更高级的插件，比如抽象多变量配置或者减少与验证任务相关的配置。</p><h1 id="3ee0" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Confs做对了</h1><p id="2cb9" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">演示的第二部分是关于我们在项目中构建的配置。这里的一般建议是“尽可能少做”，保持简单的配置文件。这绝对有意义，但是当我们试图协调部署、聚合、报告和构建配置时，很容易弄乱，而没有注意到我们可以改进整个过程。</p><p id="ce50" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">9-打造相关变型</strong></p><p id="801a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本节的第一个建议是“只构建相关的变体”。构建变体是构建类型+风格的组合。在定义多种构建类型和风格的项目中，我们产生了更多的构建变体，增加了我们构建的成本。</p><p id="8f17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">建议是分离不同构建类型的职责。调试版本应该是轻量级的，通常由开发人员使用。此外，对于CI执行，只构建相关的变体(避免使用general <code class="du kx ky kz la b">assemble</code>)。</p><p id="c3fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">10-使用惰性任务配置</strong></p><p id="b1c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Gradle提供了<a class="ae jn" href="https://docs.gradle.org/current/userguide/lazy_configuration.html" rel="noopener ugc nofollow" target="_blank">惰性配置</a>，它将属性值的计算延迟到需要的时候。在使用惰性属性的好处中，我们发现:在配置阶段避免资源工作，基于任务的连接自动确定任务的依赖关系，以及将梯度模型连接在一起，而不用担心何时会知道特定属性的值。</p><p id="5a4a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在演讲<em class="lm">Android Build Tools Studio的新特性</em>中，他们展示了在配置阶段在100个模块中使用惰性配置的影响:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/e5e1ec3d9d8ae9b5202f06a453249e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB-xCM2tDwld89IdSLE0yA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Impressive!</figcaption></figure><p id="0fa8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Gradle用两个接口表示惰性属性:</p><ul class=""><li id="a01b" class="ly lz hh ir b is it iw ix ja ma je mb ji mc jm md me mf mg bi translated">Provider:表示只能查询且不能更改的值。</li><li id="02f9" class="ly lz hh ir b is mh iw mi ja mj je mk ji ml jm md me mf mg bi translated">Property:表示可以查询和更改的值。</li></ul><p id="c71c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个如何在一个任务中应用属性的示例:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="7912" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任务<code class="du kx ky kz la b">AndroidMessage</code>使用一个<code class="du kx ky kz la b">Property&lt;String&gt;</code>来表示一个值，稍后我们将在控制台中打印该值。<code class="du kx ky kz la b">Provider&lt;String&gt;</code>代表计算的只读消息。惰性属性将被传递，并且只有在需要时才会被查询，通常是在执行阶段。此外，我们将添加一个扩展来设置值。</p><p id="a65e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">稍后我们将注册我们的任务:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="92a0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">获得以下输出:</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="9d14" class="lh jv hh la b fi li lj l lk ll">&gt; Task :what<br/> Android Rules!!!</span><span id="e036" class="lh jv hh la b fi mm lj l lk ll">BUILD SUCCESSFUL</span></pre><p id="531d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该值仅在任务执行过程中被查询时被检索，而不是在配置阶段。</p><p id="88e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Lazy API提供了更多类型，以适应任务定义中的常见用例，如<code class="du kx ky kz la b">DirectoryProperty</code>或<code class="du kx ky kz la b">RegularFileProperty</code>，并且还可以处理集合和地图。</p><p id="f1fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，也许你已经注意到我们在任务中使用了<code class="du kx ky kz la b">open</code>标识符。然而，在演示中引起我注意的一件事是，您可以将任务和扩展定义为抽象类。这将有助于我们简化任务的声明，我们将让Gradle处理任务的初始化和修饰:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="3934" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，建议在我们的任务和插件中使用惰性配置。</p><p id="b99b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">11-任务接线</strong></p><p id="fe43" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们在项目中创建不同的任务时，我们可能会在它们之间创建一些依赖关系。我们想到的第一种方法是使用<code class="du kx ky kz la b">Task.dependOn</code>。这可能导致不希望的依赖性。</p><p id="d749" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在前一点中，我们已经看到了使用惰性属性的一个好处是，它根据任务的连接来确定任务的依赖关系。让我们看看它是如何工作的，下一个例子基于演示中提到的例子:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="db75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有两个任务，我们希望依赖其中一个任务。请注意，在这两种情况下，我们都使用了前面提到的<code class="du kx ky kz la b">abstract</code>方式和属性类型的用法(DirectoryProperty)。现在我们只需要注册任务:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="bde4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">flatmap方法从使用给定函数转换的提供者的值中返回一个新的提供者。它以一种懒惰的方式传播值和依赖性，分离TaskConsumer上的显式关系。一旦我们用工件提供者设置了TaskConsumer的输入，我们就创建了两个任务之间的依赖关系。</p><p id="9e10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">TashConsumer的任务依赖图:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es mn"><img src="../Images/20c9d6d693ce72d2799132887a5a41a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*rzZn1PB82OmpQiPaAbIjxg.png"/></div></figure><p id="3b42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">综上所述，不要用<code class="du kx ky kz la b">dependsOn</code>并且牢记懒人配置，都是优点。</p><p id="a394" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 12-使用Gradle Worker API </strong></p><p id="d6f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Gradle Worker API提供了将任务动作的执行分解成工作单元，然后并发和异步执行该工作的能力。Android团队与Gradle密切合作，带来了这一特性，并改进了AGP中的多线程。</p><p id="654f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<em class="lm">Android Studio构建系统的新特性中，</em>这是解释的主要主题之一:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/a38ac8defbbad261390da80e9160f4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7h0I4A6HlAq2jogQ-hmr8w.png"/></div></div></figure><p id="d833" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该团队已经将超过90%的AGP任务转换为使用工人。3.5中默认启用(<code class="du kx ky kz la b">android.enableWorkers</code>)。</p><p id="25eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你正在开发插件或者使用定制任务，推荐使用Workers。</p><p id="693e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看一个简单的<a class="ae jn" href="https://guides.gradle.org/using-the-worker-api/" rel="noopener ugc nofollow" target="_blank">官方文档</a>的例子，我们需要创建一个定制任务来生成一组可配置文件的MD5散列。可运行的是:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="beef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们增加了三秒钟的睡眠时间，以更清楚地展示该特性的优势。任务是:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="827e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任务的动作是迭代一个源文件夹，并为每个文件生成MD5散列。该动作被安排在任务中定义的<code class="du kx ky kz la b">WorkerExecutor</code>中。最后，我们需要注册我们的任务:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="lw jt l"/></div></figure><p id="d8ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用<code class="du kx ky kz la b">./gradlew md5</code>执行任务，并尝试在没有工人的情况下创建相同的任务，以了解使用工人的好处。</p><p id="dd7c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，提到在抽象模式下使用属性lazy configurations将帮助您抽象使用WorkerExecutor初始化和调度任务的复杂性，这又是一个好处。</p><p id="979d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 13-梯度任务的自定义类型</strong></p><p id="af1a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个建议与用自定义类型声明任务有关。当然，我们可以用简单的方式创建任务，比如:</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="ca2f" class="lh jv hh la b fi li lj l lk ll">task("customTask"){<br/>  doWhatever()<br/>}</span></pre><p id="1511" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，这里的问题是在任务的配置阶段<code class="du kx ky kz la b">doWhatever</code>将被执行。如果你正在考虑使用<code class="du kx ky kz la b">doLast</code>也不是一个解决方案。</p><p id="5b57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用自定义类型，定义输入/输出并使用工人:</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="8b8d" class="lh jv hh la b fi li lj l lk ll">abstract class TaskProducer : DefaultTask() {<br/>    @get:OutputDirectory<br/>    abstract val output : DirectoryProperty<br/>}</span></pre><p id="b2a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 14-不在配置上应用计算</strong></p><p id="d5f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，在本节中，建议不要在配置阶段应用计算，这看起来很普遍，但仍然是项目中速度缓慢的主要原因之一。避免使用昂贵的计算操作，比如在配置节中获取git信息，或者使用同样昂贵的操作来定义BuildConfig值。</p><h1 id="c31d" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">调查指南</h1><p id="6cbd" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">在回顾了模块化和配置的技巧之后，现在是检查调查技巧的时候了。我们关于构建系统的决策应该由测量、回归和实验来驱动。</p><p id="3258" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 15-构建扫描</strong></p><p id="152d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://scans.gradle.com" rel="noopener ugc nofollow" target="_blank"> Build-Scans </a>是Gradle Inc .提供的一个很棒的工具。它给你关于构建的有价值的信息，你需要应用插件，当构建完成时，它会将信息上传到Gradle服务器。如果您正在享受Gradle企业服务，您可以汇总信息。</p><p id="8e79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建扫描是一个完美的工具，可以找到一些有价值的数据，如找到不懒惰的任务，甚至检查CG的时间。</p><p id="0501" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 15.b- Talaiot </strong></p><p id="c96c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个有助于测量的工具是Talaiot:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/cdsap/Talaiot" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">cdsap/Talaiot</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">简单和可扩展的插件来跟踪你的Gradle项目的任务时间。cdsap/Talaiot</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng in ms"/></div></div></a></div><p id="9b64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Talaiot非常适合应用回归和实验，结果可以发布到您的时间序列系统中(本文中的一些图表是由该插件生成的)。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nh"><img src="../Images/e2bc07a8d3a66e385cfe91f99e98c5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tipZUNqe0oqq8qmkyFGMfw.png"/></div></div></figure><p id="d30b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 15.c- Gradle剖面仪</strong></p><p id="f1c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个来自Gradle公司的工具是<a class="ae jn" href="https://github.com/gradle/gradle-profiler" rel="noopener ugc nofollow" target="_blank"> Gradle Profiler </a>。这是一个为Gradle构建自动收集分析和基准信息的工具。一个很好的概念是场景，您可以定义更复杂的场景来进行基准测试或分析。场景文件以类型安全格式描述:</p><pre class="jo jp jq jr fd ld la le lf aw lg bi"><span id="33ff" class="lh jv hh la b fi li lj l lk ll">assemble {<br/>    tasks = ["clean"]<br/>    }<br/>    clean_build {<br/>    versions = ["5.1","4.10.2"]<br/>    tasks = ["assembleDebug"]<br/>    gradle-args = ["--parallel"]<br/>    cleanup-tasks = ["clean"]<br/>    run-using = cli<br/>    warm-ups = 20<br/>}</span></pre><p id="5470" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 16级内存限制</strong></p><p id="52cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的项目中，我们不断地添加更多的特性、依赖、模块和插件。我们错误地认为增加JVM的值，比如最大堆内存(-Xmx)，会导致更快的构建。这并不完全正确。在会议上，有人提到添加更多内存并不意味着构建速度更快:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ni"><img src="../Images/3be0574ad283d74f953755d7aa532994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPJ6R2zqqnENcDysz1vdXw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">more memory != faster build</figcaption></figure><p id="eeb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您分析构建时间时，记住花费在GC上的时间是很重要的。高GC压力是一个问题，根据Gradle团队的这个<a class="ae jn" href="https://www.youtube.com/watch?v=OV-medORVsU" rel="noopener ugc nofollow" target="_blank">精彩的网络广播</a>，建议不要在您的构建中花费超过1–2%的GC时间。</p><p id="7e86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一个例子表明，为构建增加内存并不意味着构建时间的改进:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nj"><img src="../Images/14520e7e63143c65fa660505d934f0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oFJwNTi6RJ1Ahs_eDpm2A.png"/></div></div></figure><p id="6bb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 17-工人等级限制</strong></p><p id="2367" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像前一点一样，使用更多的工人并不意味着更快的构建，默认情况下，Gradle将使用可用的CPU来并行化您的构建，从而增加内存的使用。耗尽内存将强制GC。</p><p id="612b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">测量并试验在您的项目中更有效的值。为了更新您的构建可用的工人数量，您将使用<code class="du kx ky kz la b">gradle.properties</code>和:</p><p id="f692" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kx ky kz la b">org.gradle.workers.max</code></p><p id="2289" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的实验中，我们为同样的任务申请了不同数量的工人:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nk"><img src="../Images/1feb68e886839b88c91045b59879e358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMjwIjnM_vaFCmlkqSCnxg.png"/></div></div></figure><p id="9618" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，使用两个工人意味着构建时间更短。在下一个实验中，我们想要测量2个工作人员对4个工作人员执行相同一般任务的使用情况:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/b9718be97f4218494b5bc3fdce4c0b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6i54sEHtiuOW8ffDQwNdQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">no significant improvement using 4 Workers</figcaption></figure><p id="f831" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 18-配置项和本地机器的不同值</strong></p><p id="618c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的调查中，我们必须根据不同的环境尝试不同的价值观。我们不应该在本地机器上为CI环境和开发应用相同的配置。这意味着我们的回归和实验环境应该适用于不同的上下文报告和独立决策。</p><p id="7641" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 19-示踪剂</strong></p><p id="727e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后但同样重要的是，在两次演讲中，他们宣布了示踪剂:</p><div class="mp mq ez fb mr ms"><a href="https://android.googlesource.com/platform/tools/base/+/refs/heads/mirror-goog-studio-master-dev/tracer/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">tracer——平台/工具/基础Google的Git</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">Android/platform/tools/base/refs/heads/mirror-goog-studio-master-dev/。/ tracer</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">android.googlesource.com</p></div></div></div></a></div><p id="62a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Tracer允许以非常直观的方式显示构建中每个线程正在调度的所有任务:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/90c481087475a3c4c81cd5a4fd8bf315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmRXE6__hMS8yz6ds0pN3g.png"/></div></div></figure><p id="3a17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个工具不仅适用于任务，也非常适合分析插件。</p><p id="c0ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用Tracer将它附加到JVM，或者您可以使用带有API的事件将它集成到您的项目中。它将生成一个JSON文件，您可以将其导出到Chrome Trace工具中。</p><h1 id="e331" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最后的话</h1><p id="5e99" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">感谢您阅读到最后，正如我在开始时提到的，我强烈建议您和您的团队一起观看演示文稿，并开始优化您的构建。</p><p id="ee91" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢Android Tools和Gradle团队帮助我们开发新功能和资源，比如这些演示文稿。</p><p id="d411" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在该存储库中找到所有不同的示例:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/cdsap/LibraryBuildPlugins" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">cdsap/LibraryBuildPlugins</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">使用扩展插件的例子。在…上创建一个帐户，为cdsap/LibraryBuildPlugins开发做贡献</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nn l nd ne nf nb ng in ms"/></div></div></a></div></div></div>    
</body>
</html>