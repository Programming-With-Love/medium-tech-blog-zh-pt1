<html>
<head>
<title>A little reflection about coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于协程的一点思考</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/a-little-reflection-about-coroutines-34050cbc4fe6?source=collection_archive---------3-----------------------#2019-09-03">https://blog.kotlin-academy.com/a-little-reflection-about-coroutines-34050cbc4fe6?source=collection_archive---------3-----------------------#2019-09-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b752fa3c0d918ae6eb9b90321252dccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQqtx1IKoj0HlPlkgMGkog.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code reflection</figcaption></figure><p id="e328" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最近有人问我，如果后端服务不再存在，<a class="ae kx" href="https://github.com/speekha/httpmocker" rel="noopener ugc nofollow" target="_blank"> HttpMocker </a>是否有可能自动模仿现有Android应用的REST API。我在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/httpmock-my-first-oss-library-5bae8adbccf4">的上一篇文章</a>中解释了如何定义相应的场景，但这里的想法是这样的:假设我们已经有了<a class="ae kx" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改进的</a>接口来访问服务，并且用于映射JSON响应的数据类都有默认参数，我们是否可以找到一种方法来返回所有API调用的默认对象，而无需为每个调用编写特定的场景？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="0d1c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们用一个具体的例子来说明:</p><ul class=""><li id="4303" class="lf lg in kb b kc kd kg kh kk lh ko li ks lj kw lk ll lm ln bi translated">我们有一个使用协程的服务接口来发出网络请求并解析结果:</li></ul><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d9e9" class="lx ly in lt b gy lz ma l mb mc">interface ApiEndPoints {</span><span id="999b" class="lx ly in lt b gy md ma l mb mc">    @GET("/simplePath")<br/>    suspend fun simplePath(): SimpleObject</span><span id="dde0" class="lx ly in lt b gy md ma l mb mc">}</span></pre><ul class=""><li id="84d7" class="lf lg in kb b kc kd kg kh kk lh ko li ks lj kw lk ll lm ln bi translated">和一个看起来像这样的<code class="fe me mf mg lt b">SimpleObject</code>数据类:</li></ul><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3518" class="lx ly in lt b gy lz ma l mb mc">data class SimpleObject(<br/>    val stringField: String = "a simple object"<br/>)</span></pre><p id="ace6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">经过一点小修小补，似乎有可能实现一个针对<em class="mh"> HttpMocker </em>的通用场景，可以解决大多数可能性，但是我认为这个选项并不是最理想的:它意味着对返回类型的一些了解，最重要的是，它意味着将数据类序列化为JSON的一种方式(这不一定是这样的:您可能使用了一些特定的注释或解析器来将JSON流转换为对象，但是不包括用于反向操作的相应代码)。</p><p id="25f0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您必须研究<em class="mh">改进</em>服务来创建返回对象，为什么要麻烦序列化只是为了立即反序列化它们呢？在这种情况下，更有意义的做法是完全放弃<em class="mh"> HttpMocker </em>(它在<em class="mh"> OkHttp </em>级别工作:我将在另一篇文章中讨论该选项),而是通过提供自己的服务接口实现，在<em class="mh">改进</em>级别拦截调用。<strong class="kb io">换句话说，我们可以通过使用反射编写我们自己的服务接口实现来尝试模仿refuge所做的事情。</strong>那么，让我们来看看如何做到这一点。</p><h1 id="6305" class="mi ly in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">实现接口</h1><p id="ea99" class="pw-post-body-paragraph jz ka in kb b kc nf ke kf kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw ig bi translated">因为我们有一个接口来定义我们的服务，但是没有具体的实现(它是由<em class="mh">翻新</em>动态提供的)，所以用我们的来替换那个调用是相当容易的。所以让我们从简单的开始，去掉接口中的关键字<code class="fe me mf mg lt b">suspend</code>,这样我们就不用担心协程了:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9a12" class="lx ly in lt b gy lz ma l mb mc">interface ApiEndpoints {</span><span id="58bb" class="lx ly in lt b gy md ma l mb mc">    @GET("/simplePath")<br/>    fun simplePath(): SimpleObject</span><span id="606a" class="lx ly in lt b gy md ma l mb mc">}</span></pre><p id="5f2b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的应用运行在一个JVM兼容的平台上，这意味着我们可以使用该接口的一个<code class="fe me mf mg lt b">Proxy</code>实例(这也是<em class="mh">改进</em>实际上所做的)。<code class="fe me mf mg lt b">Proxy</code>是来自JVM的一个类，可以动态实现任何接口。每当在该代理上调用一个方法时，它会将调用委托给一个<code class="fe me mf mg lt b">InvocationHandler</code>，后者必须根据方法签名和参数提供正确的结果。</p><p id="235f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们的例子中，这个处理程序相当简单:它检索预期的返回类型并不带参数地调用其构造函数，以便对每个字段使用默认值。</p><p id="4ce5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，一个简单的实现可能如下所示:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b0cd" class="lx ly in lt b gy lz ma l mb mc">inline fun &lt;reified T : Any&gt; createService(): T {<br/>    val service = T::class.java<br/>    return <strong class="lt io">Proxy.newProxyInstance(</strong><br/>        service.classLoader,<br/>        <em class="mh">arrayOf</em>(service)<br/>    <strong class="lt io">)</strong> <strong class="lt io">{ </strong>_: Any, method: Method, _: Array&lt;out Any&gt; <strong class="lt io">-&gt;<br/>        val type = method.returnType<br/>        val constructor = type.constructors.first { it.parameterCount == 0 }<br/>        constructor.newInstance()</strong><br/>    <strong class="lt io">} </strong>as T<br/>}</span></pre><p id="c384" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">到目前为止，一切顺利:调用该代码有效，对<code class="fe me mf mg lt b">service.simplePath() </code>的调用返回一个<code class="fe me mf mg lt b">stringField</code>值为<code class="fe me mf mg lt b">"a simple object"</code>的<code class="fe me mf mg lt b">SimpleObject</code>。</p><h1 id="2679" class="mi ly in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">用花冠调味</h1><p id="7435" class="pw-post-body-paragraph jz ka in kb b kc nf ke kf kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw ig bi translated">到目前为止这很简单，但是<em class="mh">改型</em>不提供那样的同步接口。通常，如果您使用<em class="mh"> RxJava </em>，您需要返回一个<code class="fe me mf mg lt b">Call&lt;SimpleObject&gt;</code>(您可以同步或异步调用它)，一个<code class="fe me mf mg lt b">Single&lt;SimpleObject&gt;</code>，或者如果您喜欢使用协程，只需将您的方法声明为suspendable即可。</p><p id="c0fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">后一种语法似乎是最容易使用的，因为它不包含任何额外的泛型类型。让我们把关键字<code class="fe me mf mg lt b">suspend</code>放回去，运行我们的代码:</p><p id="4d94" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe me mf mg lt b">java.lang.ClassCastException: java.lang.Object cannot be cast to SimpleObject</code></p><p id="fd64" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看起来我们的代码设法找到了一个返回类型并调用了它的构造函数。但是为什么我们的结果不再是一个<code class="fe me mf mg lt b">SimpleObject</code>而是一个<code class="fe me mf mg lt b">Object</code>？这与幕后的协程有关。</p><p id="09ca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在Kotlin方面，看起来方法签名并没有改变:相同的名称、相同的参数、相同的返回类型……但是在JVM方面，它改变了:增加了一个<code class="fe me mf mg lt b">Continuation</code>参数，返回类型变成了<code class="fe me mf mg lt b">Object</code>。这两种变化都允许函数随意停止和启动。当协程中断时，会返回协程的当前状态，并将其用作恢复执行的参数。</p><p id="282b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于这种编译魔法，参数和返回类型不再能通过<a class="ae kx" href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html" rel="noopener ugc nofollow" target="_blank"> Java反射</a>被信任。现在是时候通过将Java <code class="fe me mf mg lt b">Method</code>对象转换为Kotlin <code class="fe me mf mg lt b">KFunction</code>来切换到<a class="ae kx" href="https://kotlinlang.org/docs/reference/reflection.html" rel="noopener ugc nofollow" target="_blank"> Kotlin反射</a>了。谢天谢地，一个<code class="fe me mf mg lt b">kotlinFunction</code>扩展帮我们做到了:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="79aa" class="lx ly in lt b gy lz ma l mb mc">val function: KFunction&lt;*&gt;? = <!-- -->method.kotlinFunction</span></pre><p id="0cb1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Kotlin反射API类似于Java自省API，但它允许根据Kotlin编译器添加的所有额外元数据，从Kotlin的角度操作您的代码。</p><p id="2f39" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">读取返回类型现在会返回在Kotlin代码中声明的类型(作为一个<code class="fe me mf mg lt b">KType</code>)，不管字节代码看起来像什么。此外，寻找不带参数的构造函数不再有效，因为我们的类只有一个带一个(可选)参数的构造函数。但是，您可以直接访问主构造函数，而不提供任何参数:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6dcf" class="lx ly in lt b gy lz ma l mb mc">inline fun &lt;reified T : Any&gt; createService(): T {<br/>    val service = T::class.java<br/>    return Proxy.newProxyInstance(<br/>        service.classLoader,<br/>        <em class="mh">arrayOf</em>(service)<br/>    ) {<strong class="lt io"> </strong>_: Any, method: Method, _: Array&lt;out Any&gt; -&gt;<strong class="lt io"><br/>        method.kotlinFunction?.let {<br/>            val type: KClass&lt;*&gt; = it.returnType.jvmErasure<br/>            val constructor: KFunction&lt;Any&gt; = type.primaryConstructor ?: error("No primary constructor") <br/>            constructor.callBy(<em class="mh">emptyMap</em>())</strong><br/>        }<br/>    }<strong class="lt io"> </strong>as T<br/>}</span></pre><p id="84f8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">老实说，我们可以通过直接调用不带参数的<code class="fe me mf mg lt b">createInstance</code>来完全跳过构造函数解析(同样的方法，我们可以在Java实现上调用<code class="fe me mf mg lt b">newInstance()</code>，而不是查找构造函数)，但是值得注意的是，Kotlin处理带可选参数的构造函数(或方法)的方式与Java不同，因为这个概念在Java中并不存在。所以我们可以进一步简化我们的代码:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b392" class="lx ly in lt b gy lz ma l mb mc">inline fun &lt;reified T : Any&gt; createService(): T {<br/>    val service = T::class.java<br/>    return Proxy.newProxyInstance(<br/>        service.classLoader,<br/>        <em class="mh">arrayOf</em>(service)<br/>    ) {<strong class="lt io"> </strong>_: Any, method: Method, _: Array&lt;out Any&gt; -&gt;<strong class="lt io"><br/>        method.kotlinFunction<br/>            ?.returnType<br/>            ?.jvmErasure<br/>            ?.createInstance()</strong><br/>    }<strong class="lt io"> </strong>as T<br/>}</span></pre><p id="a168" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">顺便提一下，如果我们没有<code class="fe me mf mg lt b">kotlinFunction</code>扩展，通过匹配名称和参数，根据JVM方法签名识别正确的Kotlin函数仍然很容易，只要我们注意到一些差异:</p><ul class=""><li id="e5fb" class="lf lg in kb b kc kd kg kh kk lh ko li ks lj kw lk ll lm ln bi translated">在Kotlin中，<code class="fe me mf mg lt b">KFunctions</code>有一个额外的第一个参数<code class="fe me mf mg lt b">INSTANCE</code>来指定函数本身。</li><li id="799b" class="lf lg in kb b kc nk kg nl kk nm ko nn ks no kw lk ll lm ln bi translated">因为我们的函数是suspendable，所以会在JVM端添加<code class="fe me mf mg lt b">Continuation</code>参数。</li></ul><p id="d8c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，使用Kotlin反射而不是Java反射的好处是，我们的代码现在可以同时用于函数的同步和异步版本。</p><h1 id="8c62" class="mi ly in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">结论</h1><p id="2b6c" class="pw-post-body-paragraph jz ka in kb b kc nf ke kf kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw ig bi translated">反射是一种以通用方式解决某些问题的聪明方法，因为Java和Kotlin都提供了操作类、对象、属性、函数等的功能。当您的代码只在JVM上运行时，很容易认为您可以很容易地混合它们。但事实是，由于Kotlin中对象和函数工作方式的一些差异，有一些微妙的特性使得在两个世界之间导航很危险。将协程添加到组合中更进了一步，因为它揭示了给我们带来这些强大特性的巧妙的字节码操作。</p><p id="987c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一方面，<a class="ae kx" href="https://kotlinlang.org/docs/reference/reflection.html" rel="noopener ugc nofollow" target="_blank"> Kotlin reflection </a>提供了一个API，它不仅与你的Kotlin代码一致，还公开了最初说服我们放弃Java的语言特性。不过，代价是这个API不是默认stdlib的一部分，需要你在项目中包含一个额外的包<code class="fe me mf mg lt b"><a class="ae kx" href="https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect" rel="noopener ugc nofollow" target="_blank">kotlin-reflect.jar</a></code>，到目前为止，这意味着你的应用程序增加了2.7MB，而Java reflection API是JVM的一部分(虽然有<a class="ae kx" href="https://github.com/Kotlin/kotlinx.reflect.lite" rel="noopener ugc nofollow" target="_blank">较小的替代包</a>，但功能有限)。</p><p id="d21f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">合乎逻辑的结论是，如果您试图限制应用程序使用的磁盘空间，在使用Kotlin反射之前，您可能需要三思。但是，如果反射是不可避免的途径，那么与旧的、有些不足的Java反射相比，它可能值得额外的重视。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="6b7c" class="mi ly in bd mj mk np mm mn mo nq mq mr ms nr mu mv mw ns my mz na nt nc nd ne bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="306f" class="pw-post-body-paragraph jz ka in kb b kc nf ke kf kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kx" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kx" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="cbea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kx" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi nu"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>