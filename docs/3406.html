<html>
<head>
<title>How I recreated a JavaScript Promise from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何从零开始重建一个JavaScript承诺的</h1>
<blockquote>原文：<a href="https://medium.com/globant/how-i-recreated-a-javascript-promise-from-scratch-f649931dadfe?source=collection_archive---------3-----------------------#2020-04-19">https://medium.com/globant/how-i-recreated-a-javascript-promise-from-scratch-f649931dadfe?source=collection_archive---------3-----------------------#2020-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/383f7ad813b08ea9951b379744cc266e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rdDj4XW82-CDqSgI"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@miryam_leon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Miryam León</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6851" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是承诺？</h1><p id="d350" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">JavaScript中的承诺是一个表示异步操作的对象，可以有三种状态之一:</p><ul class=""><li id="b397" class="kq kr hh ju b jv ks jz kt kd ku kh kv kl kw kp kx ky kz la bi translated"><strong class="ju hi"><em class="lb"/></strong>:初始状态，既不履行也不拒绝。</li><li id="2df6" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp kx ky kz la bi translated"><strong class="ju hi"> <em class="lb">完成</em> </strong>:表示操作成功完成。</li><li id="729a" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp kx ky kz la bi translated"><strong class="ju hi"> <em class="lb">拒绝</em> </strong>:表示操作失败。</li></ul><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">A promise with a positive attitude</figcaption></figure><h1 id="78aa" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">关于承诺的困惑</h1><p id="6d74" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">承诺允许在外部API的帮助下异步执行JavaScript代码，但经常被混淆为异步本身。为了消除这个神话，为了向自己证明承诺没有什么不同步，我继续创造了我自己的小“假”承诺。为了简单起见，我实现了它的resolve部分。我鼓励你自己去推断被拒绝的部分。</p><h2 id="7474" class="ln iv hh bd iw lo lp lq ja lr ls lt je kd lu lv ji kh lw lx jm kl ly lz jq ma bi translated">步骤1:在机器周围创建外壳</h2><p id="dca2" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们像往常一样开始写承诺，只是这次我们把它命名为<em class="lb"> FakePromise </em>。我们稍后将实现这个类，但是现在，我们的假承诺看起来与真承诺一样，包含以下部分:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h2 id="e2d8" class="ln iv hh bd iw lo lp lq ja lr ls lt je kd lu lv ji kh lw lx jm kl ly lz jq ma bi translated">步骤2:创建FakePromise函数构造函数</h2><p id="94cc" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们现在创建刚刚实例化的FakePromise类，记住以下几点:</p><ol class=""><li id="0afb" class="kq kr hh ju b jv ks jz kt kd ku kh kv kl kw kp mb ky kz la bi translated">必须将名为“resolve”的方法传递给给FakePromise构造函数的回调</li><li id="be5c" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">当回调的异步任务结束时，必须运行该方法。</li></ol><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="cd69" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">现在我们有了，</p><ol class=""><li id="6a3c" class="kq kr hh ju b jv ks jz kt kd ku kh kv kl kw kp mb ky kz la bi translated">接受回调的FakePromise类</li><li id="e8d9" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">一个resolve方法，该方法向下传递给此回调，并在回调结束其异步任务时调用</li></ol><p id="1337" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">让我们弄清楚这个resolveCallback是什么。</p><h2 id="d59d" class="ln iv hh bd iw lo lp lq ja lr ls lt je kd lu lv ji kh lw lx jm kl ly lz jq ma bi translated">第三步:那么“然后”呢？</h2><p id="041e" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">想想看，‘解决’和‘然后’有什么关系？我们传递一个值，这个值代表了一个解决方法的承诺的实现，这个值<em class="lb">奇迹般地从传递给‘then’方法的回调中导出。</em></p><p id="1bdc" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">记住这种关系，让我们定义“然后”。</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="19af" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">在这里，“then”方法接受一个最终为“this.resolveCallback”的回调。这是一种方法，通过这种方法，承诺的结果将被挖掘出来。</p><p id="1ca5" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">我们在哪里见过这个解决方案？没错，就是看到被resolve方法调用，被赋予了承诺的结果。让我们再看一下下面的代码:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="ll lm l"/></div></figure></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><h1 id="6b17" class="iu iv hh bd iw ix mm iz ja jb mn jd je jf mo jh ji jj mp jl jm jn mq jp jq jr bi translated">摘要</h1><p id="bc8d" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">以下是夏洛克·福尔摩斯为您带来的一系列事件；)</p><ol class=""><li id="cf86" class="kq kr hh ju b jv ks jz kt kd ku kh kv kl kw kp mb ky kz la bi translated">异步setTimeout是在浏览器API的帮助下完成的(没有任何承诺的帮助，谢谢)</li><li id="edaa" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">在与setTimout相同的函数中，我们调用resolve方法，并向其传递表示承诺实现的最终值。</li><li id="9679" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">当resolve被调用时，它运行一个叫做resolveCallback的东西，并向它传递最终值</li><li id="aeb0" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">惊喜！resolveCallback作为参数提供给了“then”。现在它已经被resolve方法调用，并且有了最终值(在我们的例子中，它是一个字符串，表示“这是在5秒钟后异步完成的”)</li><li id="2857" class="kq kr hh ju b jv lc jz ld kd le kh lf kl lg kp mb ky kz la bi translated">我们已经在正在运行的对“then”(resolve callback)的回调中实现了这个最终值的使用。在我们的例子中，我们只是将字符串记录到控制台。</li></ol><p id="fe97" class="pw-post-body-paragraph js jt hh ju b jv ks jx jy jz kt kb kc kd mc kf kg kh md kj kk kl me kn ko kp ha bi translated">正如我们所见，承诺只是对回调概念的巧妙抽象，而不是ES6中神奇的异步部分！</p></div></div>    
</body>
</html>