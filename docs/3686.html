<html>
<head>
<title>MapStruct — Advanced Concepts and Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapStruct —高级概念和依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/globant/mapstruct-advanced-concepts-and-dependency-injection-46f28af54e33?source=collection_archive---------0-----------------------#2021-06-04">https://medium.com/globant/mapstruct-advanced-concepts-and-dependency-injection-46f28af54e33?source=collection_archive---------0-----------------------#2021-06-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c0bb3d54343ad132ac0c0e4b65230c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EDaDIPSzhXfsg4PGrWxCA.png"/></div></div></figure><h1 id="3a0c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="6e1a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在我之前的博客中，我们讨论了如何使用基本的映射场景来设置<em class="kl"> MapStruct </em>。如果你是第一次接触<em class="kl"> MapStruct </em>并且还没有浏览过它，我强烈推荐你在继续这个之前浏览一下<a class="ae km" rel="noopener" href="/@akshay.jain_76848/mapstruct-let-me-write-the-tedious-piece-of-code-for-you-d3c27f667314"><strong class="jp hi"><em class="kl"/></strong></a>…</p><p id="171e" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">欢迎回来，现在让我们看看一些高级映射配置，它们为我们提供了基于业务需求配置特殊行为的灵活性，并且还与<em class="kl"> Spring依赖注入</em>相集成。</p><p id="2111" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">所以让我们开始吧-</p><h2 id="5927" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated">使用类型转换映射<strong class="ak">:</strong></h2><p id="2ec3" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Mapstruct隐式提供了无缝的类型转换。一些支持的转换是-</p><ul class=""><li id="f459" class="lg lh hh jp b jq kn ju ko jy li kc lj kg lk kk ll lm ln lo bi translated">在所有的<em class="kl"> Java原语</em>数据类型和它们对应的<em class="kl">包装器</em>类型之间，例如在<em class="kl"> int </em>和<em class="kl"> Integer </em>之间。</li><li id="5ec0" class="lg lh hh jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">在所有的<em class="kl"> Java原语编号</em>类型和<em class="kl">包装器</em>类型中，例如在<em class="kl"> int </em>和<em class="kl"> long </em>之间。</li><li id="da85" class="lg lh hh jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">在所有的<em class="kl"> Java原语</em>类型(包括它们的<em class="kl">包装器</em>和<em class="kl">字符串</em>之间。</li><li id="5fbb" class="lg lh hh jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">在<em class="kl">枚举</em>类型和<em class="kl">串</em>之间。</li><li id="36b3" class="lg lh hh jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">不同类型的<em class="kl">日期</em>对象和<em class="kl">字符串</em>之间。</li></ul><blockquote class="lu lv lw"><p id="d8fa" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><strong class="jp hi"> <em class="hh">注意:</em> </strong>从较大的数据类型转换为较小的数据类型(例如从<code class="du ma mb mc md b"><em class="hh">long</em></code>转换为<code class="du ma mb mc md b"><em class="hh">int</em></code>)会导致值或精度损失。<strong class="jp hi">映射器</strong>注释有一个方法<code class="du ma mb mc md b"><strong class="jp hi"><em class="hh">typeConversionPolicy</em></strong></code> <strong class="jp hi"> </strong>来控制警告/错误。</p></blockquote><p id="dc62" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">让我们以日期和字符串之间的转换为例。为了实现这一点，我们的制图仪看起来像-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/db9779b6b848a512e2fd134f7cab78dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKGY8A1k_1q3Mqbb6dOwfw.png"/></div></div></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="24bc" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">忽略来自目标Bean的字段</strong>:</h2><p id="c2ff" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">可能会出现某些属性不应该从源传播到目标的情况。忽略这些属性，我们要做的就是-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/f91a175242fec64627161684b65b5934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61wDaYbME9CQpbc33zsBCw.png"/></div></div></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="0b87" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">映射默认值和常量</strong>:</h2><p id="9056" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">有些情况下，如果源字段为空，或者如果我们希望始终为特定的目标字段输入一个常数值，我们会希望输入一些默认值。为了实现这一点，我们的制图仪看起来像-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/ec00550a595e4e363156b5a430fcff17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xo9Q1D2SlHVlC-k7YmBN0g.png"/></div></div></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="5cb9" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">更新现有的Bean实例</strong>:</h2><p id="f0bf" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在某些情况下，您需要的映射不会创建目标类型的新实例，而是更新该类型的现有实例。这种映射可以通过为目标对象添加一个参数并用<strong class="jp hi"> <em class="kl"> @MappingTarget </em> </strong>标记这个参数来实现。下面显示了一个示例-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/0289bbe9fd4d86ba50bd915dc296e53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzwGHSn0TyNlnnlF4YkX2A.png"/></div></div></figure><blockquote class="lu lv lw"><p id="f828" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><strong class="jp hi">注意</strong> —这次方法的返回类型是void。</p></blockquote></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="a712" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">使用Java表达式进行映射:</strong></h2><p id="8036" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">MapStruct为我们提供了包含Java代码构造的灵活性，同时提供了字段映射，因为整个源对象都可以在表达式中使用。</p><p id="8b14" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">应该注意只插入有效的Java代码，因为MapStruct不会在生成时验证表达式，但是在编译过程中会在生成的类中显示错误。</p><p id="f467" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">考虑一个例子，我们为其中一个目标字段提供一个随机id。</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/de4ad3f9d756f22d4dd0120c3ad4d2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWLtby7M3VynXzz45eKhcQ.png"/></div></div></figure><blockquote class="lu lv lw"><p id="9ad9" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><strong class="jp hi">重要提示</strong> —如果您的表达式引用了其他一些类，那么您需要在@Mapper <em class="hh"> </em>批注的imports方法中指定所有这些类，比如—</p><p id="d8a3" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><code class="du ma mb mc md b">@Mapper(imports = UUID.class)</code></p><p id="a9f2" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><code class="du ma mb mc md b">or</code></p><p id="f373" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><code class="du ma mb mc md b">@Mapper(imports = {UUID.class, Date.class})</code></p></blockquote></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="f82f" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">使用限定词选择映射方法:</strong></h2><p id="3f18" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">有时，您必须执行一些复杂的步骤来映射两个字段。在这种情况下，我们可以使用<em class="kl"> @Mapping </em>注释的<code class="du ma mb mc md b"><em class="kl">qualifiedByName</em></code> <em class="kl"> </em>方法来指定应该调用哪个方法来执行映射。</p><ul class=""><li id="5a6c" class="lg lh hh jp b jq kn ju ko jy li kc lj kg lk kk ll lm ln lo bi translated">如果使用Java 8及以后的版本，可以在同一个接口内定义为<em class="kl">默认</em>或<em class="kl">静态</em>方法。</li><li id="ee58" class="lg lh hh jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">如果使用比Java 8更早的Java版本，可以在一个<em class="kl">抽象</em>类中定义所有映射，而不是在<em class="kl">接口</em>中定义。</li></ul><p id="77b3" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">包含逻辑的方法必须用注释<code class="du ma mb mc md b"><em class="kl">@Named</em></code> <em class="kl"> </em>进行注释，并且它必须包含与您提供给<code class="du ma mb mc md b"><em class="kl">qualifiedByName</em></code> <em class="kl"> </em>方法的字符串相同的名称。</p><p id="17f5" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">让我们看一个简单的例子来更好地理解我们是如何把美元转换成美分的</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/bbed297b10bd6953820be31469e6d5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK_UV1tHeQ-Ij_H6k4xceA.png"/></div></div></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="62df" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">映射集合:</strong></h2><p id="f3f3" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">集合类型的映射(<em class="kl">列表，集合</em>等)。)是以与映射bean类型相同的方式完成的，即通过在映射器接口中用所需的源和目标类型定义映射方法。</p><p id="7d65" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">生成的代码将包含一个循环，该循环遍历源集合，转换每个元素并将其放入目标集合。</p><p id="b362" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">让我们看看下面的映射器-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/2078fa298d299d094931c3939440e110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXy6Fs9wo2WYTx_3JD4r5w.png"/></div></div></figure><p id="2250" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在上面的映射器中，我们已经声明了用于将列表转换为列表、将集合转换为集合以及将列表转换为集合的映射方法，MapStruct支持来自<a class="ae km" href="http://docs.oracle.com/javase/tutorial/collections/intro/index.html" rel="noopener ugc nofollow" target="_blank"> Java集合框架</a>的多种可迭代类型。</p><p id="9ef1" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">以类似的方式，我们可以为Map定义一个映射器。下面显示了一个示例:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/ff7a701aac1d71722cca8ecdd93e9a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUrSGGoNbGZ_BJs4UdRvTw.png"/></div></div></figure><blockquote class="mw"><p id="2ae9" class="mx my hh bd mz na nb nc nd ne nf kk dx translated">花几分钟思考一下上面的代码。你注意到什么不同了吗？？？</p></blockquote><p id="8e0f" class="pw-post-body-paragraph jn jo hh jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ha bi translated">是的，你完全正确。我们在这里使用了一个特殊的注释<code class="du ma mb mc md b"><em class="kl">@MapMapping</em></code> <em class="kl"> </em>，而不是通常的<code class="du ma mb mc md b"><em class="kl">@Mapping</em></code>注释，并为我们的地图值指定了日期格式。</p><p id="a311" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><strong class="jp hi"> <em class="kl"> @MapMapping </em> </strong>注释有几种方法来配置我们的地图转换，好的一面是，一如既往，我们不需要提供任何实现。Mapstruct 会为我们写这个。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="56d7" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">调用其他映射器:</strong></h2><p id="5a4f" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">可能会有这样的情况，我们希望调用其他映射器，不管是<em class="kl"> MapStruct </em>生成的还是手写的，来为我们做一些工作，在所有这些情况下，我们都可以使用<em class="kl"> @Mapper </em>注释中的<code class="du ma mb mc md b"><em class="kl">uses</em></code> <em class="kl"> </em>方法来调用这些外部映射器。为了更好地理解，让我们举个例子:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/6572014c84589f4aec04f6274ed5fd55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZylCIyzhJuB9NdksTvoZCQ.png"/></div></div></figure><p id="8ef4" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">假设Order.java和OrderDto.java的<em class="kl">分别是Customer.java</em>和CustomerDto.java的<em class="kl">的嵌套豆。当生成实现<em class="kl">customerToCustomerDto()</em>方法的代码时，<em class="kl"> MapStruct </em>将在<em class="kl">OrderMapper.java</em>中寻找一个在<em class="kl">订单</em>和<em class="kl">订单</em>之间具有映射逻辑的方法，并将调用该方法。</em></p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="7c0e" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">映射前和映射后注释:</strong></h2><p id="9d34" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这些注释用于标记在映射逻辑前后调用的方法。</p><p id="4ca3" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在我们可能希望将一个行为应用于接口的所有映射方法的场景中，它们非常有用。</p><p id="ac76" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">让我们看看下面的例子-</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/04e5c297026703306d3faf589c491284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVNLCwQYMe_CRc36dXBRmA.png"/></div></div></figure><p id="9a4a" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><strong class="jp hi"><em class="kl">@ before mapping</em>—</strong>标有此注释的方法将作为我们映射器的每个映射方法的第一条语句被调用。</p><p id="142b" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><strong class="jp hi"><em class="kl">@ after mapping</em>—</strong>标有此注释的方法将作为我们映射器的每个映射方法的最后一条语句被调用。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h1 id="82d4" class="ip iq hh bd ir is nm iu iv iw nn iy iz ja no jc jd je np jg jh ji nq jk jl jm bi translated">检索映射器和依赖注入</h1><h2 id="03d8" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">在没有依赖注入的情况下检索映射器:</strong></h2><p id="b444" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在查看Spring与Mapstruct的集成之前，让我们先看看获取mapper实例的方法。</p><ul class=""><li id="b2d4" class="lg lh hh jp b jq kn ju ko jy li kc lj kg lk kk ll lm ln lo bi translated">当不使用阿迪框架时，可以通过<code class="du ma mb mc md b"><strong class="jp hi">org.mapstruct.factory.Mappers</strong></code>类检索映射器实例。只需调用<code class="du ma mb mc md b"> <strong class="jp hi">getMapper()</strong></code>方法，传递映射器的接口类型返回，如下所示:</li></ul><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nr"><img src="../Images/1a9bec8b2812a89f7408f96d14982044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bmx9Dw4bp_hNHpPxGiW_Ow.png"/></div></div></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="0612" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated"><strong class="ak">使用依赖注入检索映射器:</strong></h2><p id="bc84" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">MapStruct 为Java企业应用提供了与依赖注入的无缝集成。目前MapStruct支持<a class="ae km" href="http://jcp.org/en/jsr/detail?id=346" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> CDI </strong> </a>(针对JavaTM EE的上下文和依赖注入)<a class="ae km" href="https://jcp.org/en/jsr/detail?id=330" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> JSR330 </strong> </a>(针对Java的依赖注入)和<a class="ae km" href="http://www.springsource.org/spring-framework" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> Spring框架</strong> </a> <strong class="jp hi">。</strong></p><p id="47de" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">建议通过依赖注入而不是上述的Mappers类来获取mapper对象。为了实现映射器类实例的依赖注入，<em class="kl"> MapStruct </em>提供了一个非常简单的方法。我们所要做的就是在<code class="du ma mb mc md b"><em class="kl">componentModel</em></code> <em class="kl"> </em>方法中指定DI框架的<strong class="jp hi"><em class="kl">@ Mapper</em></strong><em class="kl"/>注释，让我们看看如何——</p><ul class=""><li id="8471" class="lg lh hh jp b jq kn ju ko jy li kc lj kg lk kk ll lm ln lo bi translated"><strong class="jp hi"> <em class="kl">如果使用CDI: </em> </strong></li></ul><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ns"><img src="../Images/669d2d297da730107ba7f9383743fbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXkXSFg--pCIaMPT2rBwCg.png"/></div></div></figure><ul class=""><li id="b0b9" class="lg lh hh jp b jq kn ju ko jy li kc lj kg lk kk ll lm ln lo bi translated"><strong class="jp hi"> <em class="kl">如果使用弹簧:</em> </strong></li></ul><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nt"><img src="../Images/93012e43757ea6b6e1d13e4af460a094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_U4yuUg28-kCMDKaE3fweQ.png"/></div></div></figure><p id="8aca" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在上面的例子中，你可以看到我们已经指定我们想要使用<em class="kl"> Spring </em>作为我们的依赖框架，依赖注入应该使用<em class="kl">字段</em>来完成。</p><p id="cd9e" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">通过做这个简单的配置，MapStruct将把实现类标记为<em class="kl">组件</em>类，并且<em class="kl"> Spring </em>将为它创建一个bean。因此，每当我们需要使用我们的映射器时，我们所要做的就是<em class="kl">自动连接</em>映射器<em class="kl">接口并使用它。</em></p><blockquote class="lu lv lw"><p id="9a97" class="jn jo kl jp b jq kn js jt ju ko jw jx lx kp ka kb ly kq ke kf lz kr ki kj kk ha bi translated"><strong class="jp hi">额外提示:</strong>有些情况下，您需要执行一些复杂的逻辑，同时将一个字段映射到您的映射器，如自动连接其他bean，以获得一些信息，如<em class="hh">active spring profiles</em>by auto wiring Environment bean。在这种情况下，你不能使用<em class="hh">接口</em>作为你的映射器。相反，使用<em class="hh">抽象</em>类将映射方法声明为抽象方法。</p></blockquote></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h1 id="e16f" class="ip iq hh bd ir is nm iu iv iw nn iy iz ja no jc jd je np jg jh ji nq jk jl jm bi translated">结论</h1><p id="aeff" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我希望这个博客会鼓励你在你的项目中使用<em class="kl"> Mapstruct </em>来节省一些时间，这样你就可以投入到你最喜欢的活动中，而不是编写一些复杂的bean映射代码。</p><p id="9a24" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我试图涵盖所有常用的Mapstruct的特性，但是T2 map struct提供的远不止这些。你可以随时参考<a class="ae km" href="https://mapstruct.org/documentation/stable/reference/html/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi"> Mapstruct官方文档</strong> </a>深入了解<em class="kl"> MapStruct </em>的世界。</p><h2 id="1175" class="ks iq hh bd ir kt ku kv iv kw kx ky iz jy kz la jd kc lb lc jh kg ld le jl lf bi translated">编码快乐！</h2></div></div>    
</body>
</html>