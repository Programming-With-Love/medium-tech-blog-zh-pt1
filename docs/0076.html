<html>
<head>
<title>Building Mixed-Language iOS Project with Buck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Buck构建混合语言iOS项目</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/building-mixed-language-ios-project-with-buck-8a903b0e3e56?source=collection_archive---------2-----------------------#2017-07-18">https://medium.com/airbnb-engineering/building-mixed-language-ios-project-with-buck-8a903b0e3e56?source=collection_archive---------2-----------------------#2017-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fc98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Airbnb，我们认识到开发者经验是优秀工程的关键。我们的团队——Mobile Developer Infra——的目标是优化我们移动应用的构建时间。</p><p id="0b34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">六月，我们获得了<a class="ae jc" href="https://buckbuild.com/" rel="noopener ugc nofollow" target="_blank">美元</a>成功开发我们的iOS应用。这对我们来说是一个巨大的里程碑:在我们开始工作之前，Buck不支持混合语言的iOS项目，我们的iOS代码库由Swift和Objective-C组成，随着这一变化，我们看到<strong class="ig hi">CI构建速度提高了50%</strong>并且<strong class="ig hi">应用程序大小减少了30%</strong>。</p><p id="b370" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">达到这个里程碑是一个复杂的过程。在本帖中，我们想分享一些技术细节，关于我们面临的挑战，以及我们如何在我们的iOS代码库中使用Buck。希望这对其他对类似事业感兴趣的人有用。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="ca37" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">iOS应用程序是如何构建的</h1><p id="0802" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">当我们研究Xcode到底是如何构建一个iOS项目的时候，我们发现了<a class="ae jc" href="https://www.bignerdranch.com/blog/manual-swift-understanding-the-swift-objective-c-build-pipeline/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">这个牛逼的帖子</strong> </a>，里面详细解释了这个过程。</p><p id="f41b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，构建过程包括以下步骤:</p><ol class=""><li id="ae79" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">将桥接头文件(作者维护)和Swift源文件传递给<code class="du kw kx ky kz b">swift</code>工具，生成两种文件:<br/> a) <code class="du kw kx ky kz b">.o</code>，用于生成最终可执行二进制的机器码文件。<br/> b) <code class="du kw kx ky kz b">*-Swift.h</code>，包含Swift代码中定义的所有类和接口。这些可以在Objective-C文件中显式导入，以便使用Swift代码中定义的功能。</li><li id="8f69" class="kn ko hh ig b ih la il lb ip lc it ld ix le jb ks kt ku kv bi translated">将所有的Objective-C源文件和<code class="du kw kx ky kz b">*-Swift.h</code>文件传递给<code class="du kw kx ky kz b">clang</code>工具，为每个Objective-C文件生成<code class="du kw kx ky kz b">.o</code>文件。</li><li id="6ae9" class="kn ko hh ig b ih la il lb ip lc it ld ix le jb ks kt ku kv bi translated">将所有<code class="du kw kx ky kz b">.o</code>文件传递给<code class="du kw kx ky kz b">ld</code>命令，该命令将链接所有机器码文件并生成最终的可执行文件。</li></ol><h1 id="4966" class="jk jl hh bd jm jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh bi translated">降压转换器和Xcode的区别</h1><p id="a22e" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">Buck使用大致相同的过程来构建iOS项目。然而，有一个关键的区别使得支持像我们这样的混合语言项目更具挑战性。</p><p id="10ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Xcode独立构建每个模块，产生动态链接的框架。对于一个特定的模块<code class="du kw kx ky kz b">M</code>，可执行二进制文件和相关的资源/资产在最终的app文件夹中的<code class="du kw kx ky kz b">App.app/Framework/M.framework</code>下结束。</p><p id="6c06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Buck将这些模块视为静态库，将它们链接在一起，生成一个可执行的二进制文件。这种方法可以有效地减少二进制文件的大小，因为:<br/> a)如果多个模块正在使用相同的资源/资产，则不需要将相同的文件复制到每个<code class="du kw kx ky kz b">*.framework</code>文件夹中。b)它可以去除更多未使用的符号，因为所有库都是静态链接在一起的。</p><p id="c036" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这在纯Objective-C或纯Swift项目中非常有效。不幸的是，这种优化给混合语言项目带来了问题。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="22b5" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak"> <em class="lk">标志导入底层模块</em>不工作</strong></h1><p id="3559" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated"><code class="du kw kx ky kz b">-import-underlying-module</code> <em class="ll"> </em> build标志导致Objective-C文件在同一模块内隐式导入Swift。不幸的是，这面旗子不适用于巴克。</p><p id="55d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当Xcode生成框架时，它会生成<code class="du kw kx ky kz b">module.modulemap</code>和<code class="du kw kx ky kz b">.hmap</code>头文件来指示头文件的位置。<code class="du kw kx ky kz b">swift</code>工具稍后使用这些文件导入Objective-C头文件。然而，由于Buck不生成独立的框架，所以它不生成这些文件。因此，<code class="du kw kx ky kz b">-import-underlying-module</code>标志在<code class="du kw kx ky kz b">swift</code>工具中不起作用。</p><p id="07cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着我们必须显式地将桥接头传递给<code class="du kw kx ky kz b">swift</code>工具。然而，这样做会导致更多的问题。</p><h2 id="9d11" class="lm jl hh bd jm ln lo lp jq lq lr ls ju ip lt lu jy it lv lw kc ix lx ly kg lz bi translated">无法使用桥接标头</h2><p id="e50f" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">考虑<a class="ae jc" href="https://github.com/airbnb/BuckSample/tree/master/src/ImportObjC" rel="noopener ugc nofollow" target="_blank">这个</a>例子:<code class="du kw kx ky kz b">A.h</code> <em class="ll"> </em>包含了<em class="ll"> </em> <code class="du kw kx ky kz b">#import “B.h”</code>这条线，但是<code class="du kw kx ky kz b">B.h</code>放在了<code class="du kw kx ky kz b">folderB/</code>下面。在<code class="du kw kx ky kz b">.hmap</code>的帮助下，这与Xcode完美配合。但是在Buck中，这不起作用，因为它不能定位<code class="du kw kx ky kz b">B.h</code>。</p><p id="a85f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jc" href="https://github.com/facebook/buck/pull/1164" rel="noopener ugc nofollow" target="_blank">这个PR </a>中，我们更新了Buck，使其能够生成供<code class="du kw kx ky kz b">swift</code>工具使用的头文件，允许工具定位头文件并导入它们。</p><h2 id="880f" class="lm jl hh bd jm ln lo lp jq lq lr ls ju ip lt lu jy it lv lw kc ix lx ly kg lz bi translated">在*-Swift.h中找不到桥接标头</h2><p id="1b37" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">当<code class="du kw kx ky kz b">swift</code>工具生成<code class="du kw kx ky kz b">*-Swift.h</code>文件时，它显式导入Objective-C定义的桥接头。这打破了巴克建立。</p><p id="a245" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据<a class="ae jc" href="https://github.com/apple/swift/blob/e7a0ba84339e318853f17f6a2a6b72af6bbe2917/lib/PrintAsObjC/PrintAsObjC.cpp#L2569" rel="noopener ugc nofollow" target="_blank">苹果的代码</a>，当使用<code class="du kw kx ky kz b">-import-underlying-module</code>标志时，生成的<code class="du kw kx ky kz b">*-Swift.h</code>文件导入项目头。例如:</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="1f80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，当显式提供桥接头文件时(就像我们需要Buck做的那样)，生成的<code class="du kw kx ky kz b">*-Swift.h</code>文件最终直接导入桥接头文件:</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="30d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，导入的路径是一个相对路径。当另一个文件导入这个<code class="du kw kx ky kz b">*-Swift.h</code>文件时，它将无法定位桥接头。</p><p id="274a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jc" href="https://github.com/airbnb/buck/commit/8a1908d3d84b18ef7b53b14903087fe7045a7277" rel="noopener ugc nofollow" target="_blank">提交</a>中，我们更新了Buck来传递<code class="du kw kx ky kz b">-iquote buckRootPath</code>作为编译器参数。这明确地告诉<code class="du kw kx ky kz b">swift</code>工具在<code class="du kw kx ky kz b">buckRootPath</code>寻找桥接头文件。</p><h2 id="cf62" class="lm jl hh bd jm ln lo lp jq lq lr ls ju ip lt lu jy it lv lw kc ix lx ly kg lz bi translated"><code class="du kw kx ky kz b">@import</code>不起作用</h2><p id="ab97" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">将头文件导入Objective-C有两种方式，<code class="du kw kx ky kz b">#import</code>和<code class="du kw kx ky kz b">@import</code>。<code class="du kw kx ky kz b">@import</code>在Buck中不起作用，因为Buck不产生<code class="du kw kx ky kz b">module.modulemap</code>。</p><p id="2f64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这实际上要求我们将<code class="du kw kx ky kz b">@import M</code>替换为<code class="du kw kx ky kz b">#import &lt;M/M.h&gt;</code>和/或<code class="du kw kx ky kz b">#import &lt;M/M-Swift.h&gt;</code>。这对于我们自己的源代码来说已经足够简单了。然而，对于生成的代码来说，这有点棘手。例如，<code class="du kw kx ky kz b">*-Swift.h</code>文件总是使用<code class="du kw kx ky kz b">@import</code>。</p><p id="fb86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我们使用了一个公认的黑客解决方案，引入<a class="ae jc" href="https://github.com/airbnb/BuckSample/blob/master/scripts/transform_buck_swift_header.py#L31" rel="noopener ugc nofollow" target="_blank">这个脚本</a>来动态执行替换。在<a class="ae jc" href="https://github.com/airbnb/buck/commit/93453a5730445c0dd799872b6e8bba49233430d7" rel="noopener ugc nofollow" target="_blank">这个提交</a>中，我们向Buck的<code class="du kw kx ky kz b">apple_library</code>构建规则添加了一个新的<code class="du kw kx ky kz b">objc_header_transform_script</code>参数，它允许我们调用所有<code class="du kw kx ky kz b">*-Swift.h</code>文件上的替换脚本。</p><p id="3615" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个变化打倒了我们最后一个使用Buck的大盖帽。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="ed51" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">巴克样本</h1><p id="bea7" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">为了帮助说明我们所做的工作，我们创建了这个<a class="ae jc" href="https://github.com/airbnb/BuckSample" rel="noopener ugc nofollow" target="_blank">示例</a>项目，您可以随意克隆它并亲自测试它！</p><p id="e7d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">构建混合语言库</strong> <br/>如前所述，在构建混合语言库时，我们需要将桥接头文件传入<code class="du kw kx ky kz b">apple_library</code>构建规则。</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="04e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">构建协同pod<br/></strong>我们将每个pod视为一个单独的库，对每个pod使用不同的构建规则。</p><p id="6d64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在大多数情况下，pod包括其源代码，因此我们可以简单地使用<code class="du kw kx ky kz b">apple_library</code>来构建它。</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="3bf2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当一个pod只提供一个编译过的二进制文件时(例如<code class="du kw kx ky kz b">libSample.a</code>，我们使用<code class="du kw kx ky kz b"><a class="ae jc" href="https://buckbuild.com/rule/prebuilt_cxx_library.html" rel="noopener ugc nofollow" target="_blank">prebuilt_cxx_library</a></code>构建规则。</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="025d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当一个pod提供一个框架文件时，我们使用<code class="du kw kx ky kz b"><a class="ae jc" href="https://buckbuild.com/rule/prebuilt_apple_framework.html" rel="noopener ugc nofollow" target="_blank">prebuilt_apple_framework</a></code>构建规则。此构建规则的更多示例可在<a class="ae jc" href="https://github.com/facebook/buck/tree/7ccef04e22ea0289c17c9289a455da6879a9243d/test/com/facebook/buck/apple/testdata/prebuilt_apple_framework_builds" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="ma mb mc md fd me"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="1729" class="lm jl hh bd jm ln lo lp jq lq lr ls ju ip lt lu jy it lv lw kc ix lx ly kg lz bi translated">下一步是什么？</h2><p id="32a9" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们仍然面临一些挑战:</p><ol class=""><li id="eaf5" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">启用<code class="du kw kx ky kz b">buck project</code>生成Xcode项目文件。我们计划的工作流程包括在本地开发中使用Xcode，在CI中使用Buck。</li><li id="d07c" class="kn ko hh ig b ih la il lb ip lc it ld ix le jb ks kt ku kv bi translated">升级Buck来构建模块库，这样<code class="du kw kx ky kz b">-import-underlying-module</code>就可以工作，我们的黑客就可以被移除了。</li><li id="c57d" class="kn ko hh ig b ih la il lb ip lc it ld ix le jb ks kt ku kv bi translated">为iOS优化降压缓存。我们在Buck缓存机制中发现了一些改进的空间，并将继续对其进行投资。</li><li id="9dbe" class="kn ko hh ig b ih la il lb ip lc it ld ix le jb ks kt ku kv bi translated">进一步分析从Xcode切换到Buck能获得多少收益。</li></ol></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><p id="653c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您有任何问题/反馈，请随时联系我们。如果你想帮助我们应对这些挑战，请加入我们！</p></div></div>    
</body>
</html>