<html>
<head>
<title>Parallelism in Python starter pack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python starter pack中的并行性</h1>
<blockquote>原文：<a href="https://medium.com/globant/parallelism-in-python-starter-pack-84cd6a3d5e6c?source=collection_archive---------1-----------------------#2022-07-06">https://medium.com/globant/parallelism-in-python-starter-pack-84cd6a3d5e6c?source=collection_archive---------1-----------------------#2022-07-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fdbc3fdaf8a9bd11cde82c062366f998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1JfheDrD3fYdcBpdTfPqw.jpeg"/></div></div></figure><h1 id="06c4" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="db60" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">同时做许多事情被认为是非常高效的，至少当我们谈论计算的时候。如果您是一名软件工程师，您会希望利用这一点，以便您构建的应用程序可以运行得更快。</p><p id="d794" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">当您在终端窗口中运行Hello World文件时，它会在计算机CPU上的单个操作系统进程中运行。您使用的计算机很可能有多个CPU，因此您编写的程序将在其中一个CPU上运行。</p><p id="2143" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">假设我们没有一个程序可以完成打印Hello World这样简单的任务。相反，我们的程序要复杂得多，比如向外部请求数据、向磁盘写入大文件，或者进行昂贵的数学计算，比如机器学习。在那里，我们有更高的概率碰到被称为<em class="kq">阻塞</em>的东西。当它停止我们逻辑中的一切，直到我们等待某事发生时，就会发生这种情况，就像我之前告诉你的等待时间。我们可以用这些时间来做其他事情，减少总的执行时间，最大限度地减少<a class="ae kr" href="https://en.grenoble-em.com/news-digital-sobriety-using-digital-technology-sensibly-what-roles-do-companies-have-play" rel="noopener ugc nofollow" target="_blank"><em class="kq"/></a>(程序运行的时间越短，用的电就越少，我们留下的碳足迹也就越少)。</p><p id="81ea" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们都听说过<em class="kq">并行</em>、<em class="kq">多任务</em>这几个字。尽管人们可能认为它们指的是同一件事，但事实远非如此。在开始编码之前，我们将逐一解释。</p><p id="ff6f" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">并行性，也叫做<em class="kq">多重处理</em>，就像<em class="kq">打开一个新的终端窗口来再次运行你的程序。也许用不同的参数来得到不同的输出。发生的情况是，每个程序同时在同一台机器的不同CPU上的不同进程中独立运行。我们可以通过编程实现这一点。</em></p><p id="1bcc" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">并发性或<em class="kq">多任务</em>，也称为<em class="kq">多线程</em>，是指程序将负责同时运行不同的事情(在不同的线程中)，通过廉价的上下文切换在单个进程上提供并行性的感知。一些编程语言实现比如<em class="kq">CPython</em>(Python最流行的实现)不允许多线程，因为<a class="ae kr" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">全局锁解释器</a>。</p><p id="89b5" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">通过在单个进程中使用单个线程，也有可能产生并发的错觉。这可以通过实现一种叫做<em class="kq">事件循环</em>的机制来实现。是的，JavaScript的核心设计和使Node.js在后端应用程序中如此出名的原因。因为这是一种设计模式，所以它可以在任何编程语言中实现。</p><h1 id="add2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">让我们编码</h1><p id="5df5" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">既然我们已经介绍了每种异步编程的基础知识，我们就可以看一些示例实现了。虽然示例是用Python编写的，但是逻辑可以用任何支持指定特性的编程语言来实现。如果你想深入研究这些话题，有大量的文献。</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="d7ef" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">首先，我们将实现我们想要并行化的主要逻辑。一个简单的函数，通过使用流行的<a class="ae kr" href="https://requests.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">请求</a>库，请求公共GitHub API获取给定用户名的存储库列表。</p><h1 id="95b5" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">多线程操作</h1><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8d87" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在上面的例子中，我们使用<a class="ae kr" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程</a>包来创建多个线程，这些线程将“同时”执行我们的函数来打印存储库。让我们记住，因为有了<em class="kq"> GIL </em>，我们每个进程只能运行一个线程(除非你决定使用另一个Python实现，比如<em class="kq"> Jython </em>或<em class="kq">pypypy</em>)。<code class="du ky kz la lb b">join</code>功能用于阻塞程序流程，直到所有任务完成。</p><h1 id="8b13" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">多重处理</h1><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="e00d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">用法非常类似于多线程。相反，我们使用<a class="ae kr" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多重处理</a>包。在这里，您可以以编程方式启动在不同CPU上运行该函数的多个进程。请考虑您拥有的CPU数量，您不希望使用8核处理器同时运行1000个进程。如果是这种情况，您可能想查看一下<a class="ae kr" href="https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers" rel="noopener ugc nofollow" target="_blank">池</a>类。</p><h1 id="738f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">异步输入输出</h1><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="6d20" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在单个进程中实现并发的真正方法是使用<a class="ae kr" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>包(从Python 3.4开始提供)。AsyncIO将给你一个<em class="kq"> Eventloop </em>的能力，通过使用<code class="du ky kz la lb b">async</code> / <code class="du ky kz la lb b">await</code>关键字以一种非常直接的方式执行多个任务。值得一提的是，我们应该使用另一个支持异步请求的HTTP库，所以<code class="du ky kz la lb b">get_repos</code>函数不能满足这个目的。对此，可以推荐<a class="ae kr" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>。让我们看看如何用aiohttp实现<code class="du ky kz la lb b">get_repos_async</code>函数:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="5845" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">任务排队</h1><p id="3d4d" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是一个特别的问题，我们不想在这篇文章中遗漏。任务队列是允许通过专用的<em class="kq">工作器</em>在不同的进程甚至不同的机器中分配任务(或作业)的实现。它们使用集中式非关系键值内存数据库服务来管理队列，充当消息代理。最受欢迎的是<a class="ae kr" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>。有很多任务队列，你可以找到一个适合你的需求。如果你想要一些开始测试的建议，你可以看看<a class="ae kr" href="https://docs.celeryq.dev/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">芹菜</a>。</p><h1 id="c4da" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="d3a5" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们探讨了实现并行性和并发性的各种方法。它们不会解决应用程序通常存在的任何性能问题。然而，了解这些概念以及何时应用它们是很重要的。甚至所有上述解决方案都会带来一个或多个缺点。您应该考虑的最重要的事情是避免出现竞争情况，在这种情况下，多个任务试图同时对单个资源执行操作，从而导致不一致或意外的变化。如果您处理了所有这些边缘情况，那么您就可以享受拥有高性能解决方案的好处。</p></div></div>    
</body>
</html>