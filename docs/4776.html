<html>
<head>
<title>Abstract Data Types and the Software Crisis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象数据类型和软件危机</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/abstract-data-types-and-the-software-crisis-671ea7fc72e7?source=collection_archive---------0-----------------------#2020-05-05">https://medium.com/javascript-scene/abstract-data-types-and-the-software-crisis-671ea7fc72e7?source=collection_archive---------0-----------------------#2020-05-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f362" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">抽象如何帮助我们管理软件复杂性</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/95bf053802e9e2c9c4d4d23d46684d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSu4IJYOeNzJbQIip9oTVg.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Image: <a class="ae jm" href="https://www.flickr.com/photos/68397968@N07/11432696204" rel="noopener ugc nofollow" target="_blank">MattysFlicks — Smoke Art — Cubes to Smoke</a> (<a class="ae jm" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">CC BY 2.0</a>)</figcaption></figure><blockquote class="jn jo jp"><p id="1246" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hi">注:</strong>这是《作曲软件》系列的一部分<strong class="jt hi">s</strong><a class="ae jm" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">T5】(现在一本书！) </a>从基础开始学习JavaScript 6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<em class="hh"> <br/> </em> <a class="ae jm" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">买书</a> | <a class="ae jm" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">索引</a>|<a class="ae jm" rel="noopener" href="/javascript-scene/abstraction-composition-cb2849d5bdd6">|&lt;上一张</a> | <a class="ae jm" rel="noopener" href="/javascript-scene/functors-categories-61e031bac53f">下一张&gt; </a></p></blockquote><h1 id="1e69" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">抽象数据类型</h1><blockquote class="jn jo jp"><p id="0811" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hi"> <em class="hh">不要与</em> </strong>混淆</p><p id="319b" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hi">代数数据类型</strong>(有时缩写为ADT或AlgDT)。代数数据类型是指编程语言(如Rust、Haskell、F#)中显示特定代数结构的某些属性的复杂类型。例如，总和类型和产品类型。</p><p id="be4b" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hi">代数结构。代数结构是从抽象代数中研究和应用的，像ADT一样，抽象代数也通常根据公理的代数描述来指定，但是其应用远远超出了计算机和代码的世界。一个代数结构是不可能完全用软件建模的。相比之下，抽象数据类型作为规范和指南来正式验证工作软件。</strong></p></blockquote><p id="b721" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">抽象数据类型(ADT)是由公理定义的抽象概念，这些公理表示一些数据和对这些数据的操作。ADT<em class="js">不是</em>根据具体实例定义的，并且<em class="js">不指定</em>具体的数据类型、结构或实现中使用的算法。相反，ADT只根据它们的操作以及这些操作必须遵守的公理来定义数据类型。</p><h1 id="cb0e" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">常见ADT示例</h1><ul class=""><li id="8a42" class="li lj hh jt b ju lk jx ll lf lm lg ln lh lo km lp lq lr ls bi translated">目录</li><li id="cff7" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">堆</li><li id="1398" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">长队</li><li id="c589" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">一组</li><li id="f1d8" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">地图</li><li id="2d2a" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">溪流</li></ul><p id="aac1" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">ADT可以表示对任何类型数据的任何操作集。换句话说，所有可能的ADT的穷尽列表是无限的，原因与所有可能的英语句子的穷尽列表是无限的相同。ADT是对未指定数据的一组操作的抽象概念，而不是一组特定的具体数据类型。一个常见的误解是，很多大学课程和数据结构教材中教授的ADT的具体例子就是ADT。许多这样的教科书将数据结构标记为“ADT ”,然后跳过ADT，用具体的术语描述数据结构，而没有向学生展示数据类型的实际抽象表示。糟糕！</p><p id="7115" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">ADT可以表达许多有用的代数结构，包括半群、幺半群、函子、幺半群等。<a class="ae jm" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻想世界规范</a>是由ADTs描述的代数结构的有用目录，以鼓励JavaScript中的互操作实现。库构建者可以使用提供的公理来验证他们的实现。</p><h1 id="4f7f" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">为什么是ADTs？</h1><p id="d71f" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">抽象数据类型是有用的，因为它们为我们提供了一种以数学上合理、精确和明确的方式正式定义可重用模块的方法。这允许我们共享一种公共语言来引用有用的软件构建块的大量词汇:当我们在领域、框架甚至编程语言之间移动时，学习和携带这些有用的思想。</p><h1 id="689a" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">ADTs的历史</h1><p id="bca7" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">在20世纪60年代和70年代初，许多程序员和计算机科学研究者都对软件危机感兴趣。正如Edsger Dijkstra在他的图灵奖演讲中所说:</p><blockquote class="jn jo jp"><p id="efda" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">“软件危机的主要原因是计算机的功能强大了几个数量级！说得直白一点:只要没有机器，编程根本不成问题；当我们只有几台较弱的计算机时，编程成了一个温和的问题，而现在我们有了巨型计算机，编程成了一个同样巨大的问题。”</p></blockquote><p id="8ad5" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">他指的问题是软件很复杂。美国宇航局阿波罗登月舱和导航系统的印刷版本大约有一个文件柜的高度。代码太多了。想象一下试图阅读和理解其中的每一行。</p><p id="d313" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">现代软件要复杂得多。2015年，脸书大约有6200万行代码。如果你每页打印50行，你将填满124万页。如果你把这些纸叠起来，你会得到每英尺1800页，或者688英尺。这比旧金山的<a class="ae jm" href="https://en.wikipedia.org/wiki/Millennium_Tower_(San_Francisco)" rel="noopener ugc nofollow" target="_blank">千禧塔</a>还要高，T3是撰写本文时旧金山最高的住宅建筑。</p><p id="c4ad" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">管理软件复杂性是几乎每个软件开发人员面临的主要挑战之一。在20世纪60年代和70年代，他们没有我们今天认为理所当然的语言、模式或工具。像linters，intellisense，甚至静态分析工具还没有被发明出来。</p><p id="84e8" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">许多软件工程师指出，他们用来构建东西的硬件大部分都能工作。但是软件通常是复杂、混乱和脆弱的。软件通常是:</p><ul class=""><li id="4be6" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated">超出预算</li><li id="e948" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">晚</li><li id="8d23" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">婴儿车</li><li id="c7a7" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">缺失的需求</li><li id="a72a" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">难以维护</li></ul><p id="f913" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">如果你能以模块化的方式考虑软件，你就不需要理解整个系统来理解如何使系统的一部分工作。软件设计的原则被称为局部性。为了获得局部性，你需要<em class="js">模块</em>，你可以独立于系统的其余部分来理解它们。您应该能够明确地描述一个模块，而不必过度指定它的实现。这就是ADT解决的问题。</p><p id="9267" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">从20世纪60年代一直延伸到今天，提高软件模块化的状态是一个核心问题。正是考虑到这些问题，包括Barbara Liskov(SOLID OO design principles的Liskov Substitution Principle中引用的相同lis kov)、Alan Kay、Bertrand Meyer和其他计算机科学传奇人物在内的人们致力于描述和指定各种工具来实现模块化软件，分别包括ADT、面向对象编程和契约式设计。</p><p id="de46" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">1974年到1975年间，ADT出现在Liskov和她的学生对CLU编程语言的研究中。他们对软件模块规范的艺术状态做出了重大贡献——我们用来描述允许软件模块交互的接口的语言。形式上可证明的接口一致性使我们更加接近软件的模块化和互操作性。</p><p id="062e" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">2008年，Liskov因其在数据抽象、容错和分布式计算方面的工作获得了图灵奖。ADT在这一成就中发挥了重要作用，今天，几乎每所大学的计算机科学课程都包含ADT。</p><p id="07be" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">软件危机从来没有完全解决，任何专业开发人员都应该熟悉上面描述的许多问题，但是学习如何使用像对象、模块和ADT这样的工具肯定会有所帮助。</p><h1 id="8575" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">ADT的规格</h1><p id="8448" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">可以使用几个标准来判断ADT规范的适用性。我称这些标准为<strong class="jt hi">著名的</strong>，但我只是发明了助记符。最初的标准是由Liskov和Zilles在他们著名的论文<a class="ae jm" href="http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf" rel="noopener ugc nofollow" target="_blank">“数据抽象的规范技术”中发表的</a></p><ul class=""><li id="5b2c" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated"><strong class="jt hi">正式的。</strong>规格一定要正规。规范中每个元素的含义必须定义得足够详细，以便目标受众有相当好的机会从规范中构建一个符合规范的实现。对于规范中的每个公理，必须能够用代码实现代数证明。</li><li id="afa3" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">适用。</strong> ADTs要广泛适用。对于许多不同的具体用例，ADT通常应该是可重用的。在代码的特定部分用特定的语言描述特定的实现的ADT可能是过度指定的。相反，ADT最适合描述通用数据结构、库组件、模块、编程语言特性等的行为。例如，描述堆栈操作的ADT，或描述承诺行为的ADT。</li><li id="d799" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">极小。</strong> ADT规格应尽可能小。规范应该包括有趣的和广泛适用的行为部分，仅此而已。每一个行为都应该被精确和明确的描述，但是要尽可能的不具体。大多数ADT规范应该可以使用一些公理来证明。</li><li id="3350" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">可扩展。</strong>ADT应该是可扩展的。需求中的小变化应该只导致规范中的小变化。</li><li id="10dc" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">陈述性的。</strong>声明性规范描述<em class="js">是什么，</em>不是<em class="js">如何。</em>ADT应该根据事物是什么以及输入和输出之间的关系映射来描述，而不是创建数据结构的步骤或每个操作必须执行的特定步骤。</li></ul><p id="d4c9" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">一个好的ADT应该包括:</p><ul class=""><li id="4f44" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated"><strong class="jt hi">人类可读的描述。如果没有人类可读的描述，ADT可能会相当简洁。自然语言描述与代数定义相结合，可以互相检查，以消除规范中的任何错误或读者理解中的歧义。</strong></li><li id="6c07" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">定义。</strong>明确定义规范中使用的任何术语，以避免任何歧义。</li><li id="64af" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">抽象签名。描述预期的输入和输出，但不要将它们与具体的类型或数据结构联系起来。</strong></li><li id="0d8c" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">公理。</strong>公理不变量的代数定义，用于证明一个实现已经满足规范的要求。</li></ul><h1 id="3cd1" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">堆栈ADT示例</h1><p id="14df" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">堆栈是一个后进先出(LIFO)的项目堆，它允许用户通过将新项目推到堆栈顶部，或者从堆栈顶部弹出最近推送的项目来与堆栈进行交互。</p><p id="a08f" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">堆栈通常用于解析、排序和数据整理算法。</p><h1 id="8cec" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">定义</h1><ul class=""><li id="cf66" class="li lj hh jt b ju lk jx ll lf lm lg ln lh lo km lp lq lr ls bi translated"><code class="du me mf mg mh b">a</code>:任意类型</li><li id="492a" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">b</code>:任意类型</li><li id="afa2" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">item</code>:任何类型</li><li id="6328" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">stack()</code>:空栈</li><li id="5aeb" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">stack(a)</code>:一叠<code class="du me mf mg mh b">a</code></li><li id="2bdf" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">[item, stack]</code>:一对<code class="du me mf mg mh b">item</code>和<code class="du me mf mg mh b">stack</code></li></ul><h1 id="c4b0" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">抽象签名</h1><h2 id="cb47" class="mi ko hh bd kp mj mk ml kt mm mn mo kx lf mp mq kz lg mr ms lb lh mt mu ld mv bi translated">建筑</h2><p id="c8e5" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated"><code class="du me mf mg mh b">stack</code>操作接受任意数量的项目，并返回这些项目的堆栈。通常，构造函数的抽象签名是根据其自身来定义的。请不要将这与递归函数混淆。</p><ul class=""><li id="a6a7" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated"><code class="du me mf mg mh b">stack(...items) =&gt; stack(...items)</code></li></ul><h2 id="1179" class="mi ko hh bd kp mj mk ml kt mm mn mo kx lf mp mq kz lg mr ms lb lh mt mu ld mv bi translated">堆栈操作(返回堆栈的操作)</h2><ul class=""><li id="c926" class="li lj hh jt b ju lk jx ll lf lm lg ln lh lo km lp lq lr ls bi translated"><code class="du me mf mg mh b">push(item, stack()) =&gt; stack(item)</code></li><li id="a37e" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><code class="du me mf mg mh b">pop(stack) =&gt; [item, stack]</code></li></ul><h1 id="aeeb" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">公理</h1><p id="292e" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">堆栈公理主要处理堆栈和项目标识、堆栈项目的顺序以及堆栈为空时pop的行为。</p><h2 id="07ec" class="mi ko hh bd kp mj mk ml kt mm mn mo kx lf mp mq kz lg mr ms lb lh mt mu ld mv bi translated">身份</h2><p id="d3c9" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">推动和弹出没有副作用。如果您压入一个堆栈，并立即从同一个堆栈弹出，堆栈应该处于压入前的状态。</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="6d1d" class="mi ko hh mh b fi na nb l nc nd">pop(push(a, stack())) = [a, stack()]</span></pre><ul class=""><li id="5270" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated">给定:将<code class="du me mf mg mh b">a</code>压入堆栈，并立即从堆栈中弹出</li><li id="fc1f" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">应该:还一对<code class="du me mf mg mh b">a</code>和<code class="du me mf mg mh b">stack()</code>。</li></ul><h2 id="a592" class="mi ko hh bd kp mj mk ml kt mm mn mo kx lf mp mq kz lg mr ms lb lh mt mu ld mv bi translated">顺序</h2><p id="02f3" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">从堆栈中弹出应该遵守顺序:后进先出(LIFO)。</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="c3b7" class="mi ko hh mh b fi na nb l nc nd">pop(push(b, push(a, stack())) = [b, stack(a)]</span></pre><ul class=""><li id="f111" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated">给定:将<code class="du me mf mg mh b">a</code>推入堆栈，然后将<code class="du me mf mg mh b">b</code>推入堆栈，然后从堆栈中弹出</li><li id="529a" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">应:回一对<code class="du me mf mg mh b">b</code>和<code class="du me mf mg mh b">stack(a)</code>。</li></ul><h2 id="b802" class="mi ko hh bd kp mj mk ml kt mm mn mo kx lf mp mq kz lg mr ms lb lh mt mu ld mv bi translated">空的</h2><p id="24c3" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">从空堆栈中弹出会导致未定义的项目值。具体来说，这可以用一个可能(项目)，什么都没有，或者两者都有来定义。在JavaScript中，习惯使用<code class="du me mf mg mh b">undefined</code>。从空堆栈中弹出不会改变堆栈。</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="b049" class="mi ko hh mh b fi na nb l nc nd">pop(stack()) = [undefined, stack()]</span></pre><ul class=""><li id="6b47" class="li lj hh jt b ju jv jx jy lf mb lg mc lh md km lp lq lr ls bi translated">给定:从空堆栈中弹出</li><li id="3eec" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">应:返回一对未定义的和<code class="du me mf mg mh b">stack()</code>。</li></ul><h1 id="e157" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">具体实施</h1><p id="3a52" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">一个抽象数据类型可以有许多具体的实现，在不同的语言、库、框架等中。下面是上述stack ADT的一个实现，使用了一个封装的对象和该对象上的纯函数:</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="bb71" class="mi ko hh mh b fi na nb l nc nd">const stack = (...items) =&gt; ({<br/>  push: item =&gt; stack(...items, item),<br/>  pop: () =&gt; {<br/>    // create a item list<br/>    const newItems = [...items];</span><span id="30ea" class="mi ko hh mh b fi ne nb l nc nd">    // remove the last item from the list and<br/>    // assign it to a variable<br/>    const [item] = newItems.splice(-1);</span><span id="9d0e" class="mi ko hh mh b fi ne nb l nc nd">    // return the pair<br/>    return [item, stack(...newItems)];<br/>  },<br/>  // So we can compare stacks in our assert function<br/>  toString: () =&gt; `stack(${ items.join(',') })`<br/>});</span><span id="e99c" class="mi ko hh mh b fi ne nb l nc nd">const push = (item, stack) =&gt; stack.push(item);<br/>const pop = stack =&gt; stack.pop();</span></pre><p id="2c4c" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">另一个是根据JavaScript现有的<code class="du me mf mg mh b">Array</code>类型的纯函数实现堆栈操作:</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="2f5c" class="mi ko hh mh b fi na nb l nc nd">const stack = (...elements) =&gt; [...elements];</span><span id="cfed" class="mi ko hh mh b fi ne nb l nc nd">const push = (a, stack) =&gt; stack.concat([a]);</span><span id="4498" class="mi ko hh mh b fi ne nb l nc nd">const pop = stack =&gt; {<br/>  const newStack = stack.slice(0);<br/>  const item = newStack.pop();<br/>  return [item, newStack];<br/>};</span></pre><p id="486b" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">两个版本都满足以下公理证明:</p><pre class="ix iy iz ja fd mw mh mx my aw mz bi"><span id="9fb1" class="mi ko hh mh b fi na nb l nc nd">// A simple assert function which will display the results<br/>// of the axiom tests, or throw a descriptive error if an<br/>// implementation fails to satisfy an axiom.<br/>const assert = ({given, should, actual, expected}) =&gt; {<br/>  const stringify = value =&gt; Array.isArray(value) ?<br/>    `[${ value.map(stringify).join(',') }]` :<br/>    `${ value }`;<br/><br/>  const actualString = stringify(actual);<br/>  const expectedString = stringify(expected);<br/><br/>  if (actualString === expectedString) {<br/>    console.log(`OK:<br/>      given: ${ given }<br/>      should: ${ should }<br/>      actual: ${ actualString }<br/>      expected: ${ expectedString }<br/>    `);<br/>  } else {<br/>    throw new Error(`NOT OK:<br/>      given ${ given }<br/>      should ${ should }<br/>      actual: ${ actualString }<br/>      expected: ${ expectedString }<br/>    `);<br/>  }<br/>};</span><span id="cd48" class="mi ko hh mh b fi ne nb l nc nd">// Concrete values to pass to the functions:<br/>const a = 'a';<br/>const b = 'b';</span><span id="281b" class="mi ko hh mh b fi ne nb l nc nd">// Proofs<br/>assert({<br/>  given: 'push `a` to the stack and immediately pop from the stack',<br/>  should: 'return a pair of `a` and `stack()`',<br/>  actual: pop(push(a, stack())),<br/>  expected: [a, stack()]<br/>})</span><span id="7a3b" class="mi ko hh mh b fi ne nb l nc nd">assert({<br/>  given: 'push `a` to the stack, then push `b` to the stack, then pop from the stack',<br/>  should: 'return a pair of `b` and `stack(a)`.',<br/>  actual: pop(push(b, push(a, stack()))),<br/>  expected: [b, stack(a)]<br/>});</span><span id="fa33" class="mi ko hh mh b fi ne nb l nc nd">assert({<br/>  given: 'pop from an empty stack',<br/>  should: 'return a pair of undefined, stack()',<br/>  actual: pop(stack()),<br/>  expected: [undefined, stack()]<br/>});</span></pre><h1 id="abc5" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">结论</h1><ul class=""><li id="bd96" class="li lj hh jt b ju lk jx ll lf lm lg ln lh lo km lp lq lr ls bi translated"><strong class="jt hi">抽象数据类型(ADT) </strong>是由公理定义的抽象概念，这些公理表示一些数据和对这些数据的操作。</li><li id="36b4" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">抽象数据类型关注的是什么，而不是如何</strong>(它们是声明性的，不指定算法或数据结构)。</li><li id="a2e7" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">常见的例子</strong>包括列表、堆栈、集合等。</li><li id="2d3c" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">ADT为我们提供了一种正式定义可重用模块的方法，这种方法在数学上是合理的、精确的、明确的。</li><li id="dce5" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated">ADT产生于20世纪70年代Liskov和学生对CLU编程语言的研究。</li><li id="9530" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi"> ADTs要出名。正式的、广泛适用的、最小的、可扩展的和声明性的。</strong></li><li id="e84a" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">ADT应该包括</strong>人类可读的描述、定义、抽象签名和形式上可验证的公理。</li></ul><blockquote class="jn jo jp"><p id="2016" class="jq jr js jt b ju jv ii jw jx jy il jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hi">额外提示:</strong>如果您不确定是否应该封装一个函数，问问自己是否会将它包含在组件的ADT中。请记住，ADT应该是最小的，所以如果它不是必需的，缺乏与其他操作的内聚性，或者它的规范可能会改变，就封装它。</p></blockquote><h1 id="e789" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">词汇表</h1><ul class=""><li id="d755" class="li lj hh jt b ju lk jx ll lf lm lg ln lh lo km lp lq lr ls bi translated"><strong class="jt hi">公理</strong>是数学上合理的陈述，必须成立。</li><li id="e515" class="li lj hh jt b ju lt jx lu lf lv lg lw lh lx km lp lq lr ls bi translated"><strong class="jt hi">数学上合理的</strong>意味着每一个术语都有很好的数学定义，因此可以根据它们写出明确的、可证明的事实陈述。</li></ul><h1 id="09c5" class="kn ko hh bd kp kq kr ks kt ku kv kw kx in ky io kz iq la ir lb it lc iu ld le bi translated">后续步骤</h1><p id="d787" class="pw-post-body-paragraph jq jr hh jt b ju lk ii jw jx ll il jz lf ly kc kd lg lz kg kh lh ma kk kl km ha bi translated">EricElliottJS.com有许多小时的视频课程和类似主题的互动练习。如果你喜欢这个内容，请考虑加入。</p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><p id="2602" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated"><strong class="jt hi"> <em class="js">埃里克·艾略特</em> </strong> <em class="js">是一位科技产品和平台顾问，《T5】 <a class="ae jm" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="js">【作曲软件】</em></a><em class="js"/><a class="ae jm" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="js">【EricElliottJS.com】</em></a><em class="js"/><a class="ae jm" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="js">devanywhere . io</em></a><em class="js">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="jt hi"> <em class="js">、Zumba Fitness、</em> </strong> <em class="js"> </em> <strong class="jt hi"> <em class="js">【华尔街日报、</em></strong><em class="js"/><strong class="jt hi"><em class="js">【ESPN、</em></strong><em class="js"/><strong class="jt hi"><em class="js">【BBC】</em></strong><em class="js">等顶级录音艺人和包括</em> <strong class="jt hi"> <em class="js"> Usher、【Metallica】</em></strong></em></p><p id="4acf" class="pw-post-body-paragraph jq jr hh jt b ju jv ii jw jx jy il jz lf kb kc kd lg kf kg kh lh kj kk kl km ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>