<html>
<head>
<title>Screen Scraping Becomes API Calling — Gathering OpenWorld 2017 Session Catalog with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">截屏变成API调用——用Node.js聚集OpenWorld 2017会议目录</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/when-screen-scraping-became-api-calling-gathering-oracle-openworld-2017-session-catalog-with-node-c5e9a89b043a?source=collection_archive---------0-----------------------#2017-08-10">https://medium.com/oracledevs/when-screen-scraping-became-api-calling-gathering-oracle-openworld-2017-session-catalog-with-node-c5e9a89b043a?source=collection_archive---------0-----------------------#2017-08-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5a8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拥有一个包含即将到来的甲骨文全球大会2017大会所有会议的数据集是很好的——用于许多技术的实验和演示。会议目录公布在网站上—<a class="ae jc" href="https://events.rainfocus.com/catalog/oracle/oow17/catalogoow17" rel="noopener ugc nofollow" target="_blank">https://events . ra focus . com/catalog/Oracle/oow 17/catalogow 17</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b740e2039afad11e9fec14870de47bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*W4pj64JUAbit-eMg."/></div></figure><p id="db7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过搜索、过滤和滚动，可以检查所有可用的会话。如果数据在浏览器中可用，则可以通过编程方式进行检索，并在本地保存在例如JSON文档中。一种典型的方法是web抓取:让服务器端程序像浏览器一样，从web站点检索HTML，并从响应中查询数据。在这篇文章中描述了这个过程的例子——<a class="ae jc" href="https://codeburst.io/an-introduction-to-web-scraping-with-node-js-1045b55c63f7" rel="noopener" target="_blank">https://code burst . io/an-introduction-to-web-scraping-with-node-js-1045 b 55 c 63 f 7</a>——用于Node和<a class="ae jc" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> Cheerio库</a>。</p><p id="ecfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，只有当HTML是静态的时，HTML的服务器端屏幕抓取才会成功。动态HTML是通过执行操纵浏览器DOM的JavaScript代码在浏览器中构建的。如果这是网站背后的机制，服务器端抓取至少要复杂得多(因为它要求服务器在很大程度上模拟现代的web浏览器)。Selenium已经在这样的情况下使用了——提供一个服务器端的、可编程访问的浏览器引擎。或者，屏幕抓取也可以在浏览器内部执行——例如由<a class="ae jc" href="https://github.com/epiqueras/getsy" rel="noopener ugc nofollow" target="_blank"> Getsy库</a>支持。</p><p id="fb2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您将在本文中发现的——当服务器端抓取失败时，客户端抓取可能是一个非常复杂的解决方案。富客户端web应用程序很有可能使用REST API，以JSON文档的形式提供数据。一个我们的服务器端程序也可以轻松利用的API。OOW 2017网站的情况就是如此——因此，与复杂的HTML解析和服务器端甚至客户端抓取不同，手头的挑战只不过是一点点REST调用。</p><h1 id="9af3" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">服务器端抓取</h1><p id="4dc0" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">服务器端抓取从客户端检查网站开始，使用您喜欢的浏览器中的开发工具。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ko"><img src="../Images/cdc0ccf6ad13a0ea9afca9b3c2632d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AeYL4xM_VdI70MuZ."/></div></div></figure><p id="4020" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于cheerio来说，了解H1标签内容的第一步很简单:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kt"><img src="../Images/aceb832497452c3c217b426fa029304a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/0*mTp8DafvBt3Qx6X-."/></div></figure><p id="63fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们检查一下网页，在那里我们可以找到这些会话的详细信息:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/d6eb349a8ef95268496732908892108b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/0*6O7aOO1embEChXr0."/></div></figure><p id="b6f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们正在寻找一个RF-list-item CSS类的LI元素。通过查询这些元素来扩展我们的小节点程序:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kv"><img src="../Images/3215760962f07b36b6a5a683a5b27d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*L-DcuSSBEPkvuAn5."/></div></figure><p id="37b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果令人失望。显然，我们用请求-承诺提取的文档不包含这些列表项。正如我前面提到的，这并不奇怪:这些项目是在运行时由JavaScript代码添加到DOM中的，这些代码是在Ajax调用用于获取会话数据之后执行的。</p><h1 id="f56d" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">分析REST API调用</h1><p id="db2b" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">使用浏览器中的开发工具，不难发现是哪个调用获取了这些结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/f2c6dc4631f1f370a976e03a46b511ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*YgCKYjCG49Lzre4o."/></div></figure><p id="94d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">URL就在那里:<a class="ae jc" href="https://events.rainfocus.com/api/search." rel="noopener ugc nofollow" target="_blank">https://events.rainfocus.com/api/search.</a>现在的问题是:作为请求的一部分，向API发送什么头部和参数——应该是什么HTTP操作(GET，POST，…)？</p><p id="8d86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">浏览器工具中的信息揭示了:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/b0998545adc8d7d04bcfd8761173916c.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/0*nZHmHWc9eF1VwRxX."/></div></figure><p id="0e31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对Postman中API的自定义调用做了一点试验，结果表明rfWidgetId和rfApiProfileId是表单数据所必需的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/c165e209c12f01e9e3b815491af2d8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*62kTe-yR77SkSTcE."/></div></figure><p id="8b93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Postman提供了一个优秀的特性，可以快速地使用许多技术中的源代码来进行您刚刚整理好的REST调用:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/4a31239d9981e714fe0d10f45f9b5f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/0*IVP6ijtPgG62sfqR."/></div></figure><h1 id="56ab" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">节点中的剩余呼叫</h1><p id="c690" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">我的第一次尝试:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/17e2f67a8d4965439c1621e7a25d8dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*kTequrEq0iC15s8I."/></div></figure><p id="1fa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以Postman生成的示例为起点，创建将遍历所有会话类型的节点应用程序并不困难— TUT、BOF、GEN、CON等等；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/221eba85f6524ce13595827e41599e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/0*nAuxltgKlc3jHk4W."/></div></figure><p id="20b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了限制单个(请求和)响应的大小，我决定在9个块中搜索每种类型的会话，例如CON1、CON2、CON3等。搜索字符串用通配符填充，因此CON1将返回标识符以CON1开头的所有会话。</p><p id="e209" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了善待OOW 2017服务器，并防止被任何过滤器和保护措施阻挡，我将间隔发射请求(每个请求之间有500毫秒的延迟)。</p><p id="a0e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为这段代码仅供一次性使用，并且不受时间限制，所以我没有在并行化工作、创建世界上最优雅的代码等方面投入太多精力。简直不值得。这就够了——一次——这就是我所需要的。(虽然我想扩展代码来帮助我以自动化的方式下载演示文稿的幻灯片；每次会议，我都要花几个小时手动下载幻灯片，以便在回家的飞机上带走——结果每年我都发现自己太累了，无法浏览这些演示文稿。</p><p id="494e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于构建包含所有OOW 2017会话的本地文件的节点代码:</p><p id="cb1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://gist.github.com/061993cfaee25ffbf8e311c88dbc84b0.git" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/061993 cfae 25 ffbf 8 e 311 c 88 DBC 84 b 0 . git</a></p><p id="4ead" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lc">原载于2017年8月10日</em><a class="ae jc" href="https://technology.amis.nl/2017/08/10/when-screen-scraping-became-api-calling-gathering-oracle-openworld-2017-session-catalog-with-node/" rel="noopener ugc nofollow" target="_blank"><em class="lc">technology . amis . nl</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>