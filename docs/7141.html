<html>
<head>
<title>Ziggurat iOS App Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">金字形神塔iOS应用架构</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/ziggurat-ios-app-architecture-b54b3f7132f0?source=collection_archive---------1-----------------------#2015-12-18">https://medium.com/square-corner-blog/ziggurat-ios-app-architecture-b54b3f7132f0?source=collection_archive---------1-----------------------#2015-12-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5ecd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">超越模型视图控制器的几个步骤</h2></div><p id="7a9a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">作者</em> <a class="jt ju ge" href="https://medium.com/u/6710389d9d0?source=post_page-----b54b3f7132f0--------------------------------" rel="noopener" target="_blank"> <em class="js">艾伦·芬伯格</em> </a> <em class="js">。</em></p><blockquote class="jv"><p id="006a" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="59f7" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated">早在六月份，我就发表了一篇关于<a class="ae kf" href="https://www.youtube.com/watch?v=dgOdsh1Bq10" rel="noopener ugc nofollow" target="_blank">防止大规模视图控制器</a>的演讲，并描述了一个在Swift中具有单向数据流的应用架构。当时，该架构没有附带的博客帖子，甚至没有名称。现在，两者兼而有之。我想介绍一下<strong class="iy hi"> Ziggurat </strong>:一种分层的、可测试的架构模式，包含了不可变的视图模型和单向数据流。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/84d7353639381497df6dd75bae53b8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-_fH7mAJV7DaFfOF.png"/></div></div></figure><p id="858d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种建筑以阶梯式金字塔命名，被称为“金字形神塔”。就像这个金字塔的阶梯一样，随着数据在应用程序的各个层中单向流动，数据复杂性也随之降低。这种单向的、不可改变的数据流减少了认知负荷，并导致了更小的班级。与金字形神塔相比，典型的模型-视图-控制器架构提供的指导更少，并且数据和状态可能从许多地方变异，包括视图控制器。</p><p id="5c64" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">金字形神融合了各种演讲和文章的概念，我会在<strong class="iy hi">进一步阅读/观看部分</strong>列出。(剧透:它的灵感直接来自早期关于脸书的<a class="ae kf" href="https://www.youtube.com/watch?v=mLSeEoC6GjU" rel="noopener ugc nofollow" target="_blank"> React Native </a>的讨论，与<a class="ae kf" href="https://facebook.github.io/flux/docs/overview.html" rel="noopener ugc nofollow" target="_blank"> Flux </a>类似)。在这里引用的可选架构中，任何一个都是比模型-视图-控制器更好的选择。</p><p id="f80b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我将介绍金字形神塔，描述它的背景，对比它的利弊，定义它的组成部分，并用一个<a class="ae kf" href="https://github.com/alanf/ziggurat" rel="noopener ugc nofollow" target="_blank">示例应用</a>展示它的作用。</p><h1 id="6b33" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">MVC的问题</h1><p id="611c" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">金字形神塔是<a class="ae kf" href="https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" rel="noopener ugc nofollow" target="_blank">模型-视图-控制器</a> (MVC)的替代模式。MVC是在应用程序中划分职责的一种基本方式，但是它没有充分地将角色和职责分开。以下是MVC应用程序中遇到的一些常见问题:</p><p id="23e5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">海量视图控制器</strong></p><ul class=""><li id="59bc" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">视图控制器可以修改数据、管理I/O、从API获取数据、包含模型对象的真实来源，或者超出它们的用途:管理视图和UI事件。</li></ul><p id="83a9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">来自共享数据的棘手Bugs】</strong></p><ul class=""><li id="9bb8" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">谁在修改这些数据，何时修改？如果没有精心的设计，答案可能是几乎任何人，几乎在任何时候，都有未知的、连锁的副作用。</li></ul><p id="8ac2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">承担太多责任，难以测试代码</strong></p><ul class=""><li id="dcfb" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">当无视<a class="ae kf" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>时，界定和隔离行为的界限变得模糊或缺失。</li></ul><p id="0019" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实际上，MVC缺乏分离性导致应用程序没有清晰的设计，变得难以测试和调试。为了在代码库中有效地工作，工程师不需要对应用的设计和数据模型进行逆向工程。</p><h1 id="9e1e" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">组件和单向数据流的描述</h1><p id="e1f7" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">我将介绍金字形神塔模式的基础知识，但要获得更详细的描述，请参阅下面列出的参考资料:</p><ul class=""><li id="659e" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">一个用代码记录的所有组件实现该模式的示例应用程序是这里的<a class="ae kf" href="https://github.com/alanf/ziggurat" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="40c5" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">示例应用程序还在文本<a class="ae kf" href="https://github.com/alanf/ziggurat/blob/master/README.md#components-in-more-depth" rel="noopener ugc nofollow" target="_blank">文件</a>中记录组件。</li><li id="6320" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">我关于<a class="ae kf" href="https://www.youtube.com/watch?v=dgOdsh1Bq10" rel="noopener ugc nofollow" target="_blank">防止大规模视图控制器</a>的演讲</li><li id="0b26" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">Square工程师Kat Hawthorne的<a class="ae kf" href="https://www.youtube.com/watch?v=4cP1p5VOrSI" rel="noopener ugc nofollow" target="_blank">演讲</a>和<a class="ae kf" href="https://speakerdeck.com/kathryneh/one-way-flow-of-data" rel="noopener ugc nofollow" target="_blank">幻灯片</a>是关于单向数据流的，下面这张幻灯片是我从哪里借来的:</li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es mi"><img src="../Images/9751cc5a867a7cb1ec43f2ed37e6d9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LX4msajy-LLXrfeQ.png"/></div></div></figure><p id="8cf5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">金字形神塔的单向数据流如上图所示(并在此处的动作<a class="ae kf" href="https://github.com/alanf/ziggurat" rel="noopener ugc nofollow" target="_blank">中演示):</a></p><ul class=""><li id="5870" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">外部触发(例如用户输入)发生。</li><li id="c150" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">一个<em class="js">视图</em> <em class="js">控制器</em>通知一个<em class="js">服务</em>它收到了用户输入。</li><li id="d1d9" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">一个<em class="js">服务</em>解析/验证这个输入，并且可能改变状态(只有<em class="js">服务</em>改变状态)。然后<em class="js">服务</em>调用<em class="js">信号()</em>。</li><li id="cc2a" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><em class="js"> signal() </em>向渲染器指示该更新了。</li><li id="cbb4" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><em class="js">呈现器</em>调用<em class="js">呈现器</em>，产生<em class="js">视图模型</em>(在呈现循环期间<em class="js">服务</em>不会被写入)。</li><li id="c843" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">然后<em class="js">渲染器</em>将<em class="js">视图</em> <em class="js">模型</em>推入<em class="js">视图</em> <em class="js">控制器</em>。</li><li id="3006" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">渲染循环处于空闲状态，直到另一个外部触发器出现。</li></ul><h1 id="6016" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">权衡</h1><p id="39de" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">Ziggurat架构解决了MVC应用程序的常见问题:</p><ul class=""><li id="8e1c" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated"><strong class="iy hi">海量视图控制器</strong></li><li id="5dbf" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">多层架构为功能提供了一个清晰的归宿，避免了大量的视图控制器。</li><li id="d98a" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><strong class="iy hi">来自共享数据的棘手bug</strong></li><li id="cb2a" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">减少了有状态性和可变性:服务层封装了可变性(将其限制到主线程)，呈现者和渲染是无状态和单向的。依赖注入而不是共享状态和全局单例。</li><li id="a642" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><strong class="iy hi">难以测试责任过大的代码</strong></li><li id="8e2b" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">更少、更薄的应用程序层平均分配责任。</li></ul><h1 id="71b2" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">丰富</h1><p id="1a2b" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">金字形神塔在几个方面让生活变得更好，并且让我们这个拥有iOS经验(从没有到几年)的小团队能够在一个雄心勃勃的期限内完成任务。</p><p id="019c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，它通过为不熟悉代码库的工程师提供指南和护栏，明确定义了应用程序中的层和角色。对于新工程师来说，启动时间很短，因为每个组件的角色都是明确定义的，并且符合明确定义的心理模型。其次，金字形神塔模式使得添加测试变得容易。例如，我们使用视图模型层来比较作为预期输出的结构。这在MVC中是不可行的。</p><p id="ff98" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单向数据流阻止了MVC意大利面条，并大幅缩小了视图控制器。不可变类型、更小的对象(最好是结构)和更多的层减少了精神负担。由于视图层缺乏业务逻辑，现在以“无头”模式运行应用程序也更容易了；没有视图层，所有的业务逻辑都是可测试的；可以使用时间点视图模型快照重新创建视图状态。最后，我们发现这个应用程序是可移植的。由于有了层和依赖注入，从一个应用程序过渡到包含在另一个应用程序中的小程序变得很简单。</p><h1 id="9405" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">困难</h1><p id="b1c1" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">金字形神塔让一些事情变得更加困难，比如动画。我们建议在少用动画的应用中使用金字形神塔。视图控制器动画可能会被incomingupdate()调用中断，除非小心管理，否则这可能会导致闪烁。有了<a class="ae kf" href="https://youtu.be/i__969noyAM?t=1096" rel="noopener ugc nofollow" target="_blank"> Flux </a>，这个问题通过和React Native一起使用就解决了。</p><p id="d333" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，尽管它提供了额外的编译时检查，但一些样板代码是通过额外的层推送数据而产生的。单一数据更新管道还有一个潜在的瓶颈。与React不同，属性不是键值观察；相反，更新以视图模型结构的形式一点一点地出现。可能需要一些优化，比如丢弃无关的渲染调用或者用diffing修剪视图模型。</p><p id="d62b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">依赖注入需要仔细的设计。我们最初的方法产生了一个大的对象图。我们有循环依赖，这导致了重构。</p><h1 id="77f5" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">结论</h1><p id="e350" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">新项目提供了尝试新想法的机会。MVC有许多明显的弱点，并且已经声名狼藉。与此同时，关于Flux、React Native以及在Swift中更广泛地使用值类型等主题的许多讨论已经获得了势头。</p><p id="8d99" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们构建了一个完整的Swift应用，其架构融合了这些想法。我们对使用单向数据流、可测试性、依赖注入、轻量级视图控制器和值类型视图模型的结果感到满意。</p><p id="e722" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">金字形神塔也有利弊，但是到目前为止，它为我们提供了很好的服务。我希望你能考虑采纳一些(或者全部！)的想法，尤其是在决定采用MVC架构之前。</p><h1 id="9cec" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">进一步阅读/观看</h1><p id="eefa" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">我看过早期与React相关的视频，它们是金字形神塔的直接灵感。<a class="ae kf" href="https://youtu.be/i__969noyAM?t=1096" rel="noopener ugc nofollow" target="_blank"> Flux </a>和<a class="ae kf" href="https://www.youtube.com/watch?v=mLSeEoC6GjU" rel="noopener ugc nofollow" target="_blank"> React Native </a>使用类似的概念，都是用JavaScript实现的。</p><p id="c8d9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flux是一个健壮的、以动作为中心的模式，与React Native很好地匹配。Ziggurat很容易用在动画最少的应用程序中，但不能为复杂的动画提供解决方案，这些动画可能会被不可预测的重新渲染打断。(Flux也有这个问题，它对本地地址作出反应。)</p><p id="2efc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们希望你发现Ziggurat模式是有帮助的，并且/或者发现下面文章中涉及的MVC的许多更好的替代方案之一:</p><ul class=""><li id="7a02" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated"><a class="ae kf" rel="noopener" href="/ios-os-x-development/ios-architecture-patterns-ecba4c38de52"> OS架构模式</a></li><li id="8f0c" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="http://khanlou.com/2015/12/mvvm-is-not-very-good/" rel="noopener ugc nofollow" target="_blank"> MVVM不太好</a></li><li id="ce51" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://www.objc.io/issues/13-architecture/mvvm" rel="noopener ugc nofollow" target="_blank">Swift中的MVVM </a>和MVVM<a class="ae kf" href="http://artsy.github.io/blog/2015/09/24/mvvm-in-swift/" rel="noopener ugc nofollow" target="_blank">介绍</a></li><li id="5fbd" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://realm.io/news/andy-matuschak-controlling-complexity/" rel="noopener ugc nofollow" target="_blank">在Swift中控制复杂性</a></li><li id="169b" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://www.youtube.com/watch?v=KVZ-P-ZI6W4" rel="noopener ugc nofollow" target="_blank">介绍React Native </a></li><li id="262a" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://facebook.github.io/flux/docs/overview.html" rel="noopener ugc nofollow" target="_blank">通</a>(和<a class="ae kf" href="https://youtu.be/i__969noyAM?t=1096" rel="noopener ugc nofollow" target="_blank">通话</a>)</li><li id="88a2" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://www.objc.io/issues/13-architecture/viper/" rel="noopener ugc nofollow" target="_blank">使用VIPER构建iOS应用</a></li><li id="f2ca" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated"><a class="ae kf" href="https://github.com/venmo/Static" rel="noopener ugc nofollow" target="_blank">Swift中iOS的简单静态表格视图</a></li></ul><p id="c482" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢Ruby Chen的插图。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><div class="km kn ko kp fd mq"><a rel="noopener follow" target="_blank" href="/@dunbar151"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hi fi z dy mv ea eb mw ed ef hg bi translated">艾伦·芬伯格-简介</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">债务:最初的5000年给我留下了深刻的印象，所以我急切地阅读了大卫·格雷伯的《规则的乌托邦》。它…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kv mq"/></div></div></a></div></div></div>    
</body>
</html>