<html>
<head>
<title>Running Node.js Applications from GitHub in a Generic Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在通用Docker容器中从GitHub运行Node.js应用程序</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/running-node-js-applications-from-github-in-generic-docker-container-950f7dbcef0e?source=collection_archive---------4-----------------------#2017-05-21">https://medium.com/oracledevs/running-node-js-applications-from-github-in-generic-docker-container-950f7dbcef0e?source=collection_archive---------4-----------------------#2017-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5f99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文展示了我如何创建一个通用Docker容器映像来运行任何节点。JS应用程序基于GitHub上该应用程序的源代码。此Docker图像的用法如下图所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/3e265d03e4e5f9018f71ab58b848287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WKSg_kW-72Tzw53D."/></div></div></figure><p id="20ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何节点。任何公共GitHub repo中的JS应用程序都可以使用这个Docker容器映像运行。当从这个映像运行一个容器时，GitHub Repo的url作为环境变量传入——以及(可选)Repo中运行应用程序的目录、要运行的文件名和要使用的节点运行时的特定版本。要使用的命令行示例:</p><blockquote class="jo jp jq"><p id="a086" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated">docker run-e " GIT _ URL = https://github . com/lucasjellema/micro services-choreography-kubernetes-workshop-June 2017 "-e " APP _ PORT = 8080 "-p 8005:8080-e " APP _ HOME = part 1 "-e " APP _ STARTUP = request counter . js " lucasjellema/node-APP-runner</p></blockquote><p id="f070" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该命令将在指定URL的GitHub中找到的repo的part1目录中运行脚本requestCounter.js。它将一个额外的环境变量APP_PORT传递给运行时，以便在节点应用程序(process.env.APP_PORT)中使用。它以标准的Docker方式将容器内部的端口8080映射到主机上的端口8005。</p><p id="8149" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要运行完全不同的Node.js应用程序，我可以使用以下命令:</p><blockquote class="jo jp jq"><p id="6b48" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated">docker run-e " GIT _ URL =<a class="ae jv" href="https://github.com/lucasjellema/nodejs-serversentevents-quickstart%22" rel="noopener ugc nofollow" target="_blank">https://github . com/lucasjellema/nodejs-serversentevents-quick start "</a>-p 8010:8888-e " PORT = 8888 "- e " APP _ HOME =。"-e " APP _ STARTUP = APP . js " lucasjellema/node-APP-runner</p></blockquote><p id="3a08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">启动同一个映像，传递不同的GIT_URL和关于目录和要运行的脚本的不同指令，以及一个不同的环境变量PORT。</p><p id="df65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注:本作品基于jakubknejzlik创建的Docker镜像——参见【https://hub.docker.com/r/jakubknejzlik/docker-git-node-app/】的和<a class="ae jv" href="https://github.com/jakubknejzlik/docker-git-node-app/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">的https://github . com/jakubknejzlik/Docker-git-node-app/blob/master/Docker file</a>。</p><p id="dd17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我自己的来源是位于<a class="ae jv" href="https://github.com/lucasjellema/microservices-choreography-kubernetes-workshop-june2017" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/micro services-choreography-kubernetes-workshop-June 2017</a>的GitHub知识库的一部分，其中包含关于微服务、Choreography、Docker、Kubernetes、Node.jS、Kafka等的研讨会资源。</p><p id="110c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文中描述的步骤:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jw"><img src="../Images/d7c916c7748841ac456cef9230b0c99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/0*yffImPrUKnkif5p0."/></div></figure><p id="5692" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.Docker文件来构建容器</p><p id="845a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.启动容器时要运行的bootstrap.sh文件</p><p id="d21b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.从容器创建图像</p><p id="d8c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.将图像推送到公共Docker Hub注册表(<a class="ae jv" href="https://hub.docker.com/r/lucasjellema/node-app-runner/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/lucasjellema/node-app-runner/</a>)</p><p id="c505" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(5.创建Node.js应用并推送到GitHub)</p><p id="4abc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.通过从前面步骤中创建的映像启动Docker容器，从GitHub存储库中运行Node.js应用程序</p><h1 id="ca09" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">1.Docker文件来构建容器</h1><p id="d7f0" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这里显示了Docker文件</p><pre class="jd je jf jg fd la lb lc ld aw le bi"><span id="ea99" class="lf jy hh lb b fi lg lh l li lj">FROM node <br/>ENV NODE_VERSION stable <br/>ENV NPM_SCRIPT start <br/>ENV GIT_URL <a class="ae jv" href="https://github.com/heroku/node-js-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/heroku/node-js-sample</a> <br/>ENV APP_PORT 3000 <br/>ENV APP_HOME . <br/>ENV APP_STARTUP "" <br/># JUST_RUN specifies whether node should be installed and git should be cloned <br/>ENV JUST_RUN N <br/>COPY ./docker-work /code WORKDIR /code <br/>#RUN chown -R app:app /code/* <br/>RUN chmod +x /code/bootstrap.sh <br/>RUN npm install -g n --silent <br/>RUN n stable ENTRYPOINT ["/code/bootstrap.sh"]</span></pre><p id="15d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它始于Docker图像节点——官方基础图像(详见https://hub.docker.com/_/node/<a class="ae jv" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank">)。脚本定义了许多具有(默认)值的环境变量；当容器运行时，这些值可以被覆盖。目录<em class="jr"> docker-work </em>(当前工作目录下)的内容被复制到docker镜像内的目录/代码中。文件bootstrap . sh——位于docker-work目录中——成为可执行文件。安装了NPM包n(</a><a class="ae jv" href="https://www.npmjs.com/package/n" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/n</a>)来进行Node.js的版本管理，并且安装了Node.js的当前<em class="jr">稳定</em>版本——除了Node Docker映像中提供的Node.js版本之外。最后，入口点被设置为bootstrap . sh——这意味着当一个容器基于映像启动时，这个文件将被执行。</p><h1 id="de27" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">2.启动容器时要运行的bootstrap.sh文件</h1><p id="b93d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">启动容器时会执行bootstrap.sh文件。这个文件负责</p><p id="942d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*如果需要，安装Node.js运行时的特殊版本</p><p id="616c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*克隆Git存储库——将应用程序源代码放入容器</p><p id="8e0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*通过运行npm install安装所有必需的节点模块</p><p id="8a1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*运行Node.js应用程序</p><p id="3220" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该文件为这些操作使用了许多环境变量:</p><p id="508e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">–NODE _ VERSION—如果需要特定版本的节点运行时</p><p id="fd63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">–GIT _ URL—包含应用程序源代码的GIT存储库的URL</p><p id="d7d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">–APP _ HOME—存储库中包含package.json和应用程序运行的启动脚本的目录</p><p id="a5be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">–APP _ STARTUP—应该执行的文件(节点$ APP _ STARTUP)；如果没有传递该参数，应用程序将根据package.json中的启动脚本使用npm start启动</p><p id="681b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">–JUST _ RUN—当此变量的值为Y时，容器将不会尝试安装新版本的Node.js，也不会(再次)克隆Git repo</p><pre class="jd je jf jg fd la lb lc ld aw le bi"><span id="45a7" class="lf jy hh lb b fi lg lh l li lj">#!/bin/bash <br/>if [ "$JUST_RUN" = "N" ]; then <br/>  echo switching node to version $NODE_VERSION <br/>  n $NODE_VERSION --quiet <br/>fi </span><span id="22a2" class="lf jy hh lb b fi lk lh l li lj">echo node version: `node --version` </span><span id="d8dc" class="lf jy hh lb b fi lk lh l li lj">if [ "$JUST_RUN" = "N" ]; then <br/>  git clone $GIT_URL app <br/>fi </span><span id="0411" class="lf jy hh lb b fi lk lh l li lj">cd app cd $APP_HOME <br/>echo Application Home: $APP_HOME </span><span id="7846" class="lf jy hh lb b fi lk lh l li lj">if [ "$JUST_RUN" = "N" ]; then <br/>  if [ "$YARN_INSTALL" = "1" ]; then <br/>    yarn install --production --silent <br/>  else <br/>    npm install --production --silent <br/>  fi <br/>fi </span><span id="2412" class="lf jy hh lb b fi lk lh l li lj">if [ "$APP_STARTUP" = "" ]; then <br/>  npm run $NPM_SCRIPT <br/>else <br/>  node $APP_STARTUP <br/>fi</span></pre><h1 id="4bae" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">3.构建容器映像</h1><p id="4a6d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在我的环境中，我使用的是Windows7笔记本电脑。在这台笔记本电脑上，我安装了Docker工具。我在Docker Tools Quickstart终端(fka boot2docker)上运行——Docker机器在Linux客户机上运行一个小型的Oracle VirtualBox VM。</p><p id="e856" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用这个命令从Dockerfile文件构建容器映像:</p><blockquote class="jo jp jq"><p id="1ce3" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated">docker build-t lucasjellema/node-app-runner。</p></blockquote><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ll"><img src="../Images/4582efc6d4ccb2214e9b04b0a6117b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*hEDrGEuWzLxElax9."/></div></figure><p id="4cfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了检查映像是否包含设置，我可以运行映像并启动一个Bash shell——只需检查文件系统的内容:</p><blockquote class="jo jp jq"><p id="ef63" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker run-it–entry point/bin/bash lucasjellema/node-app-runner</em></p></blockquote><p id="27f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我现在可以使用这样的命令来试验这个图像:</p><blockquote class="jo jp jq"><p id="42e8" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker run-e " GIT _ URL =</em><a class="ae jv" href="https://github.com/lucasjellema/microservices-choreography-kubernetes-workshop-june2017%22" rel="noopener ugc nofollow" target="_blank"><em class="hh">https://github . com/lucasjellema/micro services-choreography-kubernetes-workshop-June 2017"</em></a><em class="hh">-e " APP _ PORT = 8080 "-p 8004:8080-e " APP _ HOME = part 1 "-e " APP _ STARTUP = request counter . js " lucasjellema/node-APP-runner</em></p></blockquote><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lm"><img src="../Images/fbdea61fbe3be7d0db897d8be33e7705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*C9rMJGbTBL7qdpt1."/></div></figure><p id="c68e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将运行一个容器，在指向目录/code/app的指定URL处克隆Git repo，导航到目录/code/app/part1，执行npm安装以获取所需的模块，并使用Node.js运行requestCounter.js，在端口8004侦听主机上转发到容器内端口8080的http请求。</p><p id="8ea5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了访问我的Windows主机上的应用程序，我需要知道Docker机器的IP地址——在VirtualBox中运行Docker服务器的Linux VM实例。这是通过使用</p><blockquote class="jo jp jq"><p id="84bc" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh"> docker-machine ip默认</em></p></blockquote><p id="7882" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将返回分配给虚拟机的IP地址。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ln"><img src="../Images/0919d8e71e9b10e88ed57682786953b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/0*Pn56wrAKA5Je5N6l."/></div></figure><p id="7d68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我可以在<a class="ae jv" href="http://ip_address:8004/" rel="noopener ugc nofollow" target="_blank"> http://IP_ADDRESS:8004 </a>访问Node.js应用程序。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ln"><img src="../Images/ff0a124c9fcb3e091ca77148a6880aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/0*nnrv77-loVu7IEuN."/></div></figure><p id="0c58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.(可选)将图像推送到公共Docker Hub注册表(<a class="ae jv" href="https://hub.docker.com/r/lucasjellema/node-app-runner/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/lucasjellema/node-app-runner/</a>)</p><p id="e150" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像已经证明了自己，我们现在可以把它推到一个公共或私人注册。要推送至Docker Hub:</p><blockquote class="jo jp jq"><p id="d779" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh"> docker登录</em></p><p id="54e1" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker push lucasjellema/node-app-runner</em></p></blockquote><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lo"><img src="../Images/de3f57c83071ce6a575818fb98e728b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*TeZVfrIc60j2dcGC."/></div></figure><p id="ce15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.创建Node.js应用程序并推送到GitHub</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/2028e20021295af090e0b8f8320981b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LGxiQIPRUGOeAXv_."/></div></div></figure><p id="74c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.通过从前面步骤中创建的映像启动Docker容器，从GitHub存储库中运行Node.js应用程序</p><p id="7ecb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我有几个想要运行的Node.js应用程序——每个都在自己的容器中，在自己的端口监听。这现在非常简单明了——使用几个对docker run的调用，每个调用都有不同的GIT_URL、APP_HOME和APP_STARTUP以及APP_PORT或PORT值。</p><p id="dc0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，并行运行三个容器:</p><blockquote class="jo jp jq"><p id="6519" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker run-e " GIT _ URL =</em><a class="ae jv" href="https://github.com/lucasjellema/microservices-choreography-kubernetes-workshop-june2017%22" rel="noopener ugc nofollow" target="_blank"><em class="hh">https://github . com/lucasjellema/micro services-choreography-kubernetes-workshop-June 2017"</em></a><em class="hh">-e " APP _ PORT = 8080 "-p 8001:8080-e " APP _ HOME = part 1 "-e " APP _ STARTUP = request counter . js " lucasjellema/node-APP-runner</em></p><p id="05ad" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker run-e " GIT _ URL =</em><a class="ae jv" href="https://github.com/lucasjellema/microservices-choreography-kubernetes-workshop-june2017%22" rel="noopener ugc nofollow" target="_blank"><em class="hh">https://github . com/lucasjellema/micro services-choreography-kubernetes-workshop-June 2017"</em></a><em class="hh">-e " APP _ PORT = 8080 "-p 8005:8080-e " APP _ HOME = part 1 "-e " APP _ STARTUP = request counter-2 . js " lucasjellema/node-APP-runner</em></p><p id="0f25" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker run-e " GIT _ URL =</em><a class="ae jv" href="https://github.com/lucasjellema/nodejs-serversentevents-quickstart%22" rel="noopener ugc nofollow" target="_blank"><em class="hh">https://github . com/lucasjellema/nodejs-serversentevents-quick start "</em></a><em class="hh">-p 8010:8888-e " PORT = 8888 "- e " APP _ HOME =。"-e " APP _ STARTUP = APP . js " lucasjellema/node-APP-runner</em></p></blockquote><p id="67f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以从一个容器中查看日志:</p><blockquote class="jo jp jq"><p id="d260" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">码头工人日志&lt;集装箱id&gt;T17】</em></p></blockquote><p id="f31f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以停止每个容器:</p><blockquote class="jo jp jq"><p id="987c" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">码头工人停止&lt;集装箱id&gt;T19】</em></p></blockquote><p id="255d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">列出所有正在运行和已停止的容器:</p><blockquote class="jo jp jq"><p id="e433" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">码头集装箱ls -all </em></p></blockquote><p id="199a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重启一个容器(现在重启的时间很短):</p><blockquote class="jo jp jq"><p id="1fe4" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">码头工人开始&lt;集装箱id&gt;T23】</em></p></blockquote><h1 id="8b24" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">7.将容器变成图像</h1><p id="44b0" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">注意:很容易将运行特定Node.js应用程序本身的这些容器之一转换成一个映像，从该映像中可以运行后续的容器。这个映像将包含Node.js的正确版本以及应用程序及其所有依赖模块，从而允许更快的启动时间。步骤:</p><blockquote class="jo jp jq"><p id="b5ec" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker commit CONTAINER _ ID NAME _ OF _ IMAGE</em></p></blockquote><p id="0c4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如:</p><blockquote class="jo jp jq"><p id="dcc3" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh"> docker提交a771请求计数器</em></p></blockquote><p id="1f75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随后，我们可以基于这个映像运行一个容器；注意，这一次我们没有指定GIT _ URL——因为应用程序和所有node_modules都被放入了映像中。bootstrap.sh和应用程序中使用的环境变量仍然可以传递。该容器的启动时间应该非常短，因为几乎不需要执行任何准备工作:</p><blockquote class="jo jp jq"><p id="e38c" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker RUN-e " APP _ PORT = 8080 "-p 8004:8080-e " APP _ HOME = part 1 "-e " JUST _ RUN = Y "-e " APP _ STARTUP = request counter . js "请求计数器</em></p></blockquote><h1 id="4d83" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">笔记</h1><p id="be23" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">注意:移除旧容器</p><p id="dffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">列出退出的容器:</p><blockquote class="jo jp jq"><p id="b5c2" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh"> docker ps -aq -f状态=已退出</em></p></blockquote><p id="f5ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">移除它们(<a class="ae jv" href="http://blog.yohanliyanage.com/2015/05/docker-clean-up-after-yourself/)" rel="noopener ugc nofollow" target="_blank">http://blog . yohan liyanage . com/2015/05/docker-clean-up-after-yourself/)</a></p><blockquote class="jo jp jq"><p id="d11e" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh"> docker rm -v $(docker ps -a -q -f状态=已退出)</em></p></blockquote><p id="c024" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">移除悬挂图像</p><p id="2b9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">列出它们:</p><blockquote class="jo jp jq"><p id="ebaa" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker images-f " dangling = true "-q</em></p></blockquote><p id="9dc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">移除它们:</p><blockquote class="jo jp jq"><p id="da79" class="ie if jr ig b ih ii ij ik il im in io js iq ir is jt iu iv iw ju iy iz ja jb ha bi translated"><em class="hh">docker RMI $(docker images-f " dangling = true "-q)</em></p></blockquote><p id="db6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jr">原载于2017年5月21日</em><a class="ae jv" href="https://technology.amis.nl/2017/05/21/running-node-js-applications-from-github-in-generic-docker-container/" rel="noopener ugc nofollow" target="_blank"><em class="jr">technology . amis . nl</em></a><em class="jr">。</em></p></div></div>    
</body>
</html>