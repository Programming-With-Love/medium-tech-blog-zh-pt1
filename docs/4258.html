<html>
<head>
<title>Using Git Hooks to improve your development workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git挂钩改进您的开发工作流程</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/using-git-hooks-to-improve-your-development-workflow-8f5a1fb81ec7?source=collection_archive---------1-----------------------#2019-08-31">https://medium.com/google-developer-experts/using-git-hooks-to-improve-your-development-workflow-8f5a1fb81ec7?source=collection_archive---------1-----------------------#2019-08-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6e2be3d9595b3c0b0df3ad80a5202c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTCtCxdbYd6cjSU4sZwXlQ.jpeg"/></div></div></figure><div class=""/><p id="c00f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最近，我第一次为一个新的代码库做贡献。我扩展并实现了一些我需要的功能。在我的机器上进行彻底的测试后，我检查了功能是否正常工作，我提交了我的贡献。几分钟后，我们的CI环境传达了一条信息:</p><blockquote class="jn jo jp"><p id="29ba" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">4项测试失败</p></blockquote><p id="4060" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种情况经常发生，甚至在我们习惯使用的代码库上也是如此。我们倾向于专注于开发新的特性，而忘记了有一个覆盖它们的测试。或者需要进行新的测试来覆盖新的特性。这一事实本身并不是一个悲剧，但在这种情况下，工作流程肯定可以改进。我们可以使用Git挂钩来改善它们。</p><p id="e540" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae ju" href="https://githooks.com/" rel="noopener ugc nofollow" target="_blank"> Git挂钩</a>是在不同的Git事件之前或之后执行的脚本。例如:提交、推送和接收。它们是一个内置的解决方案(不需要下载任何第三方插件),它们在你的机器上本地执行。我们可以应用它们的各种场景是相当大的。</p><p id="15c0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们考虑前面的场景。现代技术世界倾向于在开发的早期阶段解决问题。例如，整个可空性承诺是关于在编译过程中传递错误，而不是在运行时。这对高质量的产出有着决定性的积极影响。类似地，如果我们可以在我们的机器上测试失败，我们肯定会改进我们的工作流，而不是在CI环境中测试失败，以及所有的副作用(在我们的机器上修复测试，测试，重新推送，运行CI)。</p><p id="c9ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们假设我们有一个运行Gradle的Android应用程序——尽管任何运行在Gradle上的应用程序都可以工作。当我们运行测试时，我们基本上是在运行一个类似于下面的命令:</p><blockquote class="jn jo jp"><p id="d93b" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">。/gradlew清洁测试</p></blockquote><p id="3c2e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望在实际推送代码之前执行这个命令。为了做到这一点，我们需要做到以下几点:</p><ol class=""><li id="8934" class="jv jw hs ir b is it iw ix ja jx je jy ji jz jm ka kb kc kd bi translated">去看<em class="jq">。存储库的git/hooks </em>文件夹。</li><li id="6739" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated">创建一个名为<em class="jq">的预推送文件</em></li><li id="3158" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated">复制以下代码片段:</li></ol><figure class="kj kk kl km fd hj"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="c19d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在你推送代码之前的任何时候，测试都将在本地运行。如果有任何错误，将不会有推送(当脚本返回1时)。</p><p id="5c0b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，您可以决定在每次提交时这样做，而不是在每次推送时这样做。如果是这种情况，您将需要在提交前修改文件<em class="jq"/>。我相信在推送之前运行测试比在提交之前运行测试更有效，但是您可能需要看看这如何适合您的工作流。</p><p id="27e5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有一些有趣的想法，我们可以使用Git挂钩来自动化一些方面。例如，我们可能想要运行的任务之一是使用诸如<a class="ae ju" href="https://en.wikipedia.org/wiki/Lint_(software)" rel="noopener ugc nofollow" target="_blank"> lint </a>或<a class="ae ju" href="https://github.com/arturbosch/detekt" rel="noopener ugc nofollow" target="_blank"> detekt </a>之类的工具进行静态分析。对于这个例子，让我们使用前者，并把它存储在一个<em class="jq">预提交</em>文件中。</p><figure class="kj kk kl km fd hj"><div class="bz dy l di"><div class="kn ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Full gist: <a class="ae ju" href="https://gist.github.com/kikoso/a46e6a2efd07ab66ed049b5f7b76ace5" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/kikoso/a46e6a2efd07ab66ed049b5f7b76ace5</a></figcaption></figure><p id="1952" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们想在一个<em class="jq">预推</em>钩子上一起执行它们，我们实际上可以将它们结合起来:</p><figure class="kj kk kl km fd hj"><div class="bz dy l di"><div class="kn ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Full gist: <a class="ae ju" href="https://gist.github.com/kikoso/0a79740c7cde9174ffbafe19caa39306" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/kikoso/0a79740c7cde9174ffbafe19caa39306</a></figcaption></figure><p id="1e59" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在任何过程中，都有一些我们需要执行的手动任务，并且很容易忘记。Git挂钩可以确保(或者至少提醒用户)这些tak应该在提交被实际推送之前执行:</p><figure class="kj kk kl km fd hj"><div class="bz dy l di"><div class="kn ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Full gist: <a class="ae ju" href="https://gist.github.com/kikoso/d6024e455c733fb91798621ae487a375" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/kikoso/d6024e455c733fb91798621ae487a375</a></figcaption></figure><p id="fc97" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有几个想法我们可以应用。例如，根据您的流程，您可能希望在将开发分支合并到主分支之后立即创建一个发布标记。使用Git挂钩很容易实现这一点:</p><figure class="kj kk kl km fd hj"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="937e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这实际上可以进一步自动化(代替在控制台上键入标签，你可以从你的Gradle文件中读取，或者从你存储它的环境变量中读取。</p><p id="cead" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是可用的git挂钩的完整列表。我们不会对它们中的每一个做进一步的阐述，因为它们的名字是不言自明的。</p><ul class=""><li id="4879" class="jv jw hs ir b is it iw ix ja jx je jy ji jz jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--applypatch-msg.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> applypatch-msg </strong> </a></li><li id="1ff5" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--pre-applypatch.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预申请补丁</strong> </a></li><li id="ee98" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_post_applypatch" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">应用后补丁</strong> </a></li><li id="c815" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--pre-commit.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预提交</strong> </a></li><li id="cacf" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--prepare-commit-msg.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">准备-提交-消息</strong> </a></li><li id="a23c" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--commit-msg.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">提交-消息</strong> </a></li><li id="f55c" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_post_commit" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">提交后</strong> </a></li><li id="00ce" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--pre-rebase.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预还原</strong> </a></li><li id="175c" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_post_checkout" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">结账后</strong> </a></li><li id="7969" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_post_merge" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">后合并</strong> </a></li><li id="9b55" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#pre-receive" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预接收</strong> </a></li><li id="601f" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--update.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">更新</strong> </a></li><li id="0b30" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#post-receive" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">后期接收</strong> </a></li><li id="6629" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://github.com/git/git/blob/master/templates/hooks--post-update.sample" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">后期更新</strong> </a></li><li id="8b37" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_pre_auto_gc" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预自动气相色谱</strong> </a></li><li id="770c" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_post_rewrite" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">后期改写</strong> </a></li><li id="2d9f" class="jv jw hs ir b is ke iw kf ja kg je kh ji ki jm kt kb kc kd bi translated"><a class="ae ju" href="https://www.git-scm.com/docs/githooks#_pre_push" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">预推</strong> </a></li></ul><h2 id="ab1a" class="ku kv hs bd kw kx ky kz la lb lc ld le ja lf lg lh je li lj lk ji ll lm ln lo bi translated">最后的笔记</h2><p id="d58e" class="pw-post-body-paragraph ip iq hs ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">Git挂钩是一种非常有效和灵活的机制，可以改善我们的工作流程。因为它们是基于shell脚本的，所以几乎没有限制。我们几乎可以完成任何用其他工具不容易完成的任务。</p><p id="ef95" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，Git挂钩需要手动安装，它们不是为所有用户存储在存储库中的。我建议您在您的Git存储库上创建一个<em class="jq"> githooks/ </em>文件夹，并将githooks存储在那里。您甚至可以创建一个脚本，在第一次下载存储库时安装它们(甚至包括一个Git挂钩，在存储库更新后安装该文件夹中包含的所有挂钩)。</p><p id="81bb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的<a class="ae ju" href="https://twitter.com/eenriquelopez" rel="noopener ugc nofollow" target="_blank"> Twitter账户</a>上写下我对软件工程和金融的想法。如果你喜欢这篇文章或者它确实帮助了你，请随意分享它，♥它和/或留下评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>