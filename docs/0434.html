<html>
<head>
<title>Fighting regressions with Benchmarks in CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CI中的基准来对抗衰退</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/fighting-regressions-with-benchmarks-in-ci-6ea9a14b5c71?source=collection_archive---------2-----------------------#2019-10-17">https://medium.com/androiddevelopers/fighting-regressions-with-benchmarks-in-ci-6ea9a14b5c71?source=collection_archive---------2-----------------------#2019-10-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="48a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在<a class="ae jc" href="https://www.youtube.com/watch?v=ZffMCJdA5Qc" rel="noopener ugc nofollow" target="_blank"> I/O 2019 </a>发布了第一个基准库alpha，并一直在改进它，以帮助您在优化Android代码的同时准确测量性能。Jetpack基准测试是在Android设备上运行的标准JUnit工具测试，使用库提供的规则来执行测量和报告:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Sample project on Github at <a class="ae jc" href="https://github.com/googlesamples/android-performance/tree/master/BenchmarkSample" rel="noopener ugc nofollow" target="_blank">android/performance-samples</a>.</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jo"><img src="../Images/8bf0bd351ced152fa500c89eb631c192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAeeKy_p7MFSy7oAtWnwUg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Sample Android Studio output, running multiple benchmarks.</figcaption></figure><p id="696a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该库通过其<a class="ae jc" href="https://developer.android.com/reference/kotlin/androidx/benchmark/junit4/BenchmarkRule.html" rel="noopener ugc nofollow" target="_blank"> JUnit规则API </a>处理预热、检测配置问题，并测量代码的性能。</p><p id="0ce0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这对于在您的办公桌上进行基准测试来说非常好，但是基准测试的大部分价值来自于检测持续集成中的回归。你如何处理CI中的基准数据？</p><h1 id="ea00" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">基准测试与正确性测试</h1><p id="ae99" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">即使您有成千上万个正确性测试，也很容易通过折叠信息将其放在仪表板上。下面是我们用于喷气背包的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es ky"><img src="../Images/a4c10dc2d712114abf6c36308b6425db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sswFIKrs_PuyZHLvAyg4zw.png"/></div></div></figure><p id="4f3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没什么特别的，但是它用了两个常用的技巧来减少视觉负荷。首先，它按包和类折叠成千上万个测试的列表。然后，默认情况下，它隐藏其中没有失败的包。几十个库的测试结果，总共将近2万个测试，很容易在几行文本中显示出来。正确性测试仪表板的伸缩性非常好！</p><p id="6bab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是基准呢？基准测试不会输出简单的通过/失败，它是每个测试的标量值。这意味着我们不能简单地折叠pass结果。让我们看看数据的图表，也许我们可以直观地辨别模式。毕竟，你可能拥有的<strong class="ig hi">比正确性测试少得多</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kz"><img src="../Images/611f0bc211279e81a0f6e666c35b6757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*gn31LgjHuK-vXKIg4RywGw.png"/></div></figure><p id="6ff2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是大量的视觉噪音。即使只有数百个而不是数千个结果，这也不是查看数据的有用方式。没有改变的基准测试占用了和真实回归一样多的可见空间，所以我们真的需要过滤掉它。</p><h1 id="655a" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">回归检测的简单方法</h1><p id="02a0" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我们可以从简单的事情开始，试着回到正确性测试的通过/失败的世界。我们可以将失败定义为在两次运行之间下降了某个百分比阈值的任何基准。然而，由于差异，这在实践中会失败。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es la"><img src="../Images/81b33cd41330fd66f0e345025b7b2bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qxZ19Coi1uuTBXiRqneSw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Benchmarks with View inflation are prone to higher variance, but still provide useful data.</figcaption></figure><p id="c6aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管我们试图在基准测试中产生稳定、一致的数字，但差异仍然可能很大，这取决于工作负载和您运行的设备。例如，我们发现膨胀视图的测试远不如其他CPU工作负载基准测试稳定。一个百分比阈值并不适用于每个测试，但是我们不希望将分配阈值(或基线)的负担放在基准作者身上，因为随着时间的推移维护起来很麻烦，并且不能随着基准数量的增加而很好地扩展。</p><p id="d73e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">差异也可能以不频繁的套件范围峰值的形式出现，在这种情况下，正在测试的设备的某些条件在连续几个基准测试中产生异常缓慢的结果。虽然我们可以解决其中的一些问题(例如，当内核由于低电量而被禁用时，防止运行)，但很难完全防止这些问题。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lb"><img src="../Images/8f5ef990655802b706b727e0a23b9623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*zie1taDQPxuEfzjQGGD-qg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">recyclerview, ads-identifier, and room benchmarks, all spiking during one run — we DO NOT want to report this as a regression</figcaption></figure><h2 id="e7d9" class="lc jw hh bd jx ld le lf kb lg lh li kf ip lj lk kj it ll lm kn ix ln lo kr lp bi translated">要点是，我们不能只看Build N与N-1的结果来寻找回归——我们需要更多的上下文来做决定。</h2><h1 id="39c7" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">逐步拟合，可扩展的解决方案</h1><p id="9c32" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我们在Jetpack CI中使用的方法是分步拟合，由<a class="ae jc" href="https://skia.org/dev/testing/skiaperf" rel="noopener ugc nofollow" target="_blank"> Skia Perf应用</a>提供。</p><p id="6767" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个想法是我们在基准数据中寻找阶跃函数。如果我们检查每个基准测试的结果序列，我们可以寻找向上或向下的“台阶”，作为特定构建改变基准测试性能的信号。我们想看看几个数据点，以确保我们看到的是多个结果的一致模式，而不是侥幸:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lq"><img src="../Images/b6605b3e65fe081e6abaa2612be78b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0W8_c5WbUdBCU-YzqSoYgA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Context reveals a large regression to actually be an unstable benchmark</figcaption></figure><p id="7807" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们如何检查这样一个步骤？我们查看了变更前后的多项结果:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lr"><img src="../Images/81b555cdd6d76cd64c49e21719a967a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*9xZpGuGYSy2zKUaD"/></div></div></figure><p id="ddfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们使用以下代码片段计算回归的显著性:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls jj l"/></div></figure><p id="d677" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其工作原理是检测变更前后的误差，并基于该误差衡量平均值的差异。基准的方差越小，我们在检测小的回归时就越有信心。这让我们可以在同一个系统中运行纳秒级精度的微基准测试，同时运行大型(移动)数据库基准测试，具有更高的<strong class="ig hi">方差。</strong></p><p id="ce84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你也可以自己试试！点击run按钮，根据在我们的CI中运行的WorkManager基准测试的数据来尝试该算法。它将输出到一个带有<a class="ae jc" href="https://ci.android.com/builds/branches/aosp-androidx-master-dev/grid?head=5783944&amp;tail=5783944" rel="noopener ugc nofollow" target="_blank">回归</a>的构建的链接，以及到它的<a class="ae jc" href="https://ci.android.com/builds/branches/aosp-androidx-master-dev/grid?head=5787972&amp;tail=5787972" rel="noopener ugc nofollow" target="_blank">后续修复</a>的链接(点击‘View Changes’查看里面的提交)。当数据被绘制成图表时，这些数据与人们看到的倒退和进步相匹配:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lt"><img src="../Images/fd8a31748eec7ccc7146242b47fa76cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGyjx_JYLq8jfOo32_gutQ.png"/></div></div></figure><p id="2b55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于我们的算法配置，图中所有的小噪声都被忽略。您可以使用上面的两个参数来控制它的触发时间:</p><ol class=""><li id="3fbb" class="lu lv hh ig b ih ii il im ip lw it lx ix ly jb lz ma mb mc bi translated"><code class="du md me mf mg b">WIDTH</code> —提交前后要考虑多少结果</li><li id="1e8c" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb lz ma mb mc bi translated"><code class="du md me mf mg b">THRESHOLD</code> —回归必须有多严重才会出现在你的仪表盘上。</li></ol><p id="7b39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">较高的宽度增加了对不一致性的抵抗力，但是会使在频繁变化的结果中找到回归变得更加困难——我们目前使用的宽度是5。阈值是一个通用的灵敏度控制，我们目前使用25。降低它以找到更多的回归，但您也可能会看到更多的假阳性。</p><p id="d8d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要在CI中为自己设置此功能:</p><ol class=""><li id="8b49" class="lu lv hh ig b ih ii il im ip lw it lx ix ly jb lz ma mb mc bi translated"><a class="ae jc" href="http://d.android.com/benchmark" rel="noopener ugc nofollow" target="_blank">写一些基准！</a></li><li id="e391" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb lz ma mb mc bi translated">在真实设备上运行CI，最好有<a class="ae jc" href="https://developer.android.com/studio/profile/benchmark#sustained-perf" rel="noopener ugc nofollow" target="_blank">持续性能</a>支持</li><li id="cbf6" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb lz ma mb mc bi translated"><a class="ae jc" href="https://developer.android.com/studio/profile/run-benchmarks-in-ci" rel="noopener ugc nofollow" target="_blank">从JSON收集输出指标</a></li><li id="f676" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb lz ma mb mc bi translated">每次一个结果准备好，看最后的<code class="du md me mf mg b">2 * WIDTH</code>结果</li></ol><p id="dbde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果有倒退或改进，发出警报(电子邮件、问题或任何对你有用的东西)来调查以前构建的<code class="du md me mf mg b">WIDTH</code>的性能。</p><h1 id="1537" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">预提交</h1><p id="2cc3" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">那么presubmit呢？如果你不让回归进入构建，那么捕捉回归就容易多了！</p><p id="a9ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在presubmit中运行基准测试是完全防止回归的一个很好的方法，但是首先要记住:基准测试就像flakey测试，它需要像上面的算法这样的基础设施来解决不稳定性。</p><p id="7d8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于presubmit测试，它会中断提交补丁的工作流程，您需要对您使用的回归检测有特别高的信心。</p><p id="ef74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的分步拟合算法是需要的，因为单次运行基准测试本身并不能给我们足够的信心。不过，我们可以捕获更多的数据来获得这种信心——只需在有和没有更改的情况下运行多次，以检查补丁是否引入了回归。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/8bb24a70aee2cef7e10baf4018e90336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*EUTOwB4SMmFTl6pZ"/></div></figure><p id="7a28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只要您对每次测试更改都要运行几次基准测试以增加信心所增加的资源成本感到满意，那么presubmit就能很好地工作！</p><p id="a931" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完全公开—我们目前在Jetpack的presubmit中没有使用基准测试，但是如果你想的话，下面是我的建议:</p><ul class=""><li id="a2ea" class="lu lv hh ig b ih ii il im ip lw it lx ix ly jb mn ma mb mc bi translated">运行基准测试5次以上，无论有没有补丁(后者通常可以被缓存，或者从postsubmit结果中获取)</li><li id="3570" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb mn ma mb mc bi translated">考虑跳过特别慢的基准测试</li><li id="be56" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb mn ma mb mc bi translated">不要基于结果阻止提交补丁——只要在代码审查期间考虑结果。回归有时是改进代码库的一部分！</li><li id="1ae6" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb mn ma mb mc bi translated">考虑到之前的结果可能不存在。在presubmit中无法检查正在添加的基准！</li></ul><h1 id="dbfb" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="5ae9" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">Jetpack Benchmark提供了一种简单的方法来获得Android设备的准确性能指标。结合上面的step fit算法，您可以在不稳定性影响用户之前检测到性能退化——就像我们在CI的Jetpack中所做的那样。</p><p id="5dea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于从哪里开始的注意事项:</p><ul class=""><li id="16f0" class="lu lv hh ig b ih ii il im ip lw it lx ix ly jb mn ma mb mc bi translated">在基准测试中捕捉你的关键滚动界面</li><li id="62a5" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb mn ma mb mc bi translated">添加关键库交互的性能测试，以及昂贵的CPU工作</li><li id="c986" class="lu lv hh ig b ih mh il mi ip mj it mk ix ml jb mn ma mb mc bi translated">像对待退步一样对待进步——它们值得研究！</li></ul><h1 id="d727" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">附加阅读</h1><p id="42c3" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">如果你想了解更多，我在2019年Android开发者峰会上与<a class="ae jc" href="http://twitter.com/itsdustinlam" rel="noopener ugc nofollow" target="_blank">@ itdustinlam</a>一起做了一个关于CI 中基准的<a class="ae jc" href="https://www.youtube.com/watch?v=ynBPcFs6OOk" rel="noopener ugc nofollow" target="_blank">演讲。</a></p><p id="724f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要了解更多关于Jetpack Benchmark的工作原理，请查看我们的<a class="ae jc" href="https://www.youtube.com/watch?v=ZffMCJdA5Qc" rel="noopener ugc nofollow" target="_blank"> Google I/O talk </a>。来自Jetpack库的基准测试结果在<a class="ae jc" href="http://androidx-perf.skia.org/" rel="noopener ugc nofollow" target="_blank">androidx-perf.skia.org</a>发布。</p><p id="6a22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<a class="ae jc" href="https://skia.org/dev/testing/skiaperf" rel="noopener ugc nofollow" target="_blank"> Skia Perf应用程序</a>来跟踪我们的AndroidX库的性能。您可以看到<a class="ae jc" href="https://github.com/google/skia-buildbot/blob/master/perf/go/stepfit/stepfit.go" rel="noopener ugc nofollow" target="_blank">这里描述的步长适配算法的实际源代码</a>，因为它在我们的CI中运行。如果你有兴趣了解更多，Joe Gregorio已经写了另一篇关于他们更高级的K-means聚类检测算法的博文<a class="ae jc" href="https://bitworking.org/news/2014/11/detecting-benchmark-regressions" rel="noopener ugc nofollow" target="_blank">解释了Skia项目开发的具体问题和解决方案，专门设计用于扩展许多配置(操作系统和操作系统版本、CPU/GPU芯片/驱动程序变体、编译器等)。).</a></p></div></div>    
</body>
</html>