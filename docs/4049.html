<html>
<head>
<title>Talking about Front-end and Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谈论前端和性能</h1>
<blockquote>原文：<a href="https://medium.com/globant/talking-about-front-end-and-performance-bf6a634fcaca?source=collection_archive---------0-----------------------#2022-12-16">https://medium.com/globant/talking-about-front-end-and-performance-bf6a634fcaca?source=collection_archive---------0-----------------------#2022-12-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d94fbfb4bbcb6d48b55163703f757456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k76a3Bw26MqzDuND"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/es/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc-Olivier Jodoin</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4937" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我们将深入探讨与Web UI相关的性能主题。作为前端(FE)开发人员，有时我们没有像应该的那样考虑性能，所以当我们写下一些代码时，必须记住这些主题。尽管我们将讨论普通的JS，但是暴露的概念适用于每一个JS框架，因为JS是我们现在使用的最流行的框架的核心。</p><h1 id="5d16" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">计算机图形渲染过程</h1><p id="839f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">首先，我们必须了解内容是如何被处理出现在我们的屏幕上的。为了使本文尽可能简单，我们假设内容在屏幕上的绘制方式遵循计算机图形管道，如下所示:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/6863388a2c9dfc3dd90ef49da39b2f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2h6dEZP3r2bN50VT"/></div></div></figure><p id="cef2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个过程我不会深究太多，但是把概念记在心里是必不可少的；现在这可能没有太大的意义，但是随着文章的深入，它会变得有意义。在一个简单的世界中，这个过程的大部分是由我们的GPU管理的。本质上，计算机首先以三角形的形式制作点(顶点)，然后程序用线连接那些点，在这之后，它将内部区域光栅化；一旦完成，它就可以画出每个像素，当这个过程完成时，我们最终得到在屏幕上呈现的输出。</p><h1 id="aa9f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">web渲染过程</h1><p id="1553" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们刚刚看到了我们如何在屏幕上获得图形，以及大多数渲染引擎是如何工作的，但是现在我们需要了解渲染过程如何在web上工作。我们的网站总是包含HTML、CSS和JS文件。这个过程看起来是这样的:</p><ul class=""><li id="b724" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">加载网页时，服务器将所需的文件(以字节形式)发送到web客户端。</li><li id="f270" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">浏览器引擎根据文件的指定编码将这些字节转换为字符。这些单独的字符被转换成记号、节点，最后是对象模型。</li><li id="76b5" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">浏览器将节点转换成树形结构；我们知道这是一个DOM。DOM是文档对象模型，是一棵逻辑树，当我们想从JS操作我们的web时，它使我们的生活变得更容易。</li><li id="32f4" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">浏览器还将CSS代码解析为CSSOM (CSS对象模型)。</li></ul><p id="439b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可能已经看到了DOM结构，但这是CSSOM的样子:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/cac4fe027fde9b6662e4e31918759cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*Y0gMZkCsp-LFBQPwjnO-LQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Image by <a class="ae it" href="https://web.dev/authors/ilyagrigorik/" rel="noopener ugc nofollow" target="_blank">Ilya Grigorik</a> from <a class="ae it" href="https://web.dev/" rel="noopener ugc nofollow" target="_blank">web.dev</a></figcaption></figure><p id="70c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上图显示了我们的CSS代码是如何与一个节点相关联的；这种结构非常类似于DOM树。本质上，CSSOM是一棵树，其中每个节点都有我们的CSS属性。在这一点上，特殊性也是必不可少的，因为在这一点上，我们的CSS中的所有覆盖也被认为是在我们的节点内部。</p><p id="beb2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们有了更好的想法，我们可以进入下一个话题。</p><h1 id="01c4" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">自然渲染像素流水线</h1><p id="e391" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我写这篇文章的主要目的是让读者理解<strong class="iw hi">就性能而言，这是FE开发人员最重要的概念</strong>。如果你作为一名开发人员采用这些概念，你将永远知道你何时打破了自然渲染像素管道。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/03a6417b5ea8e260ca3a4eaaa39e6a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MtK66blAL3m426Sy"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The natural render pixel pipeline in action</figcaption></figure><p id="7901" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在图像中，我们可以看到五个不同的阶段。在每个阶段，我们都可能无意中在渲染过程中引入瓶颈。还有我想再提一下<a class="ae it" href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">栅格化</strong> </a>。首先，让我们打开测试页面上的DevTools，转到<strong class="iw hi">性能</strong>选项卡，激活<strong class="iw hi">截图选项</strong>，如下所示:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/378064f06e3c9151f50cd1d4f957b11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BOVFjcHhk-53ial6pKbOA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Obtaining a technical performance report for a website</figcaption></figure><p id="43f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上图中，您可以看到您可以通过单击“reload”箭头开始分析。这将开始你的网站的性能记录。一个业绩记录基本上就是一个网站的业绩简介；它将包含主线程中正在进行的所有事情、截图、web workers、FPS和其他有趣的事情。</p><p id="ae8d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当你在页面上看到paint <strong class="iw hi"> </strong>(见下图右上角截图<strong class="iw hi">)</strong><strong class="iw hi"/>你应该记得栅格化<strong class="iw hi"> </strong>正在发生。这是因为要在屏幕上绘制内容(正如我们在计算机图形管道中看到的)，引擎必须创建一个绘制任务，然后填充像素。</p><p id="c5ca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下图显示了一个网站的完整性能报告(你可以在这里了解更多<a class="ae it" href="https://developer.chrome.com/docs/devtools/evaluate-performance/" rel="noopener ugc nofollow" target="_blank">)，包括FPS信息、网络请求、内存泄漏和一个大<em class="lq">等等</em>。</a></p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/0cce11c9f15b69f371222e82bd106a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhQpNeAWJ7GiQAzNytEtmA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">A complete performance report of a website, here you can observe scripting and painting times and other information.</figcaption></figure><h1 id="1f5b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">使用自然渲染像素管道</h1><p id="9baa" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我解释一下。当使用JavaScript代码操作DOM或一些CSS转换时，可能会导致页面上的回流。每当您更改与元素的几何图形相关的内容时，您将再次触发自然渲染管道。</p><p id="80f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们假设你改变了一个元素的宽度:那么你正在改变几何图形。浏览器引擎将重新计算并检查其他元素是否受其影响，这将导致回流。</p><p id="d6e8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有受影响的元素都需要重新绘制；之后，它们将再次经历复合阶段。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/f9896e21e40809caa08d071a5219eca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eW6z1n9FdIrYNety"/></div></div></figure><p id="aa84" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你<strong class="iw hi">改变了一些与绘画过程相关的属性</strong>，比如一个元素的<strong class="iw hi">背景颜色</strong>，那么你只是触发了<strong class="iw hi">绘画阶段</strong>而跳过了布局阶段。</p><p id="33ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，如果你改变图层的组成，那么你只会触发那个阶段。您可以通过用JS或CSS更改<code class="du ls lt lu lv b"><strong class="iw hi">z-index</strong></code>来触发复合层。此外，您可以通过在transform属性中使用<code class="du ls lt lu lv b"><strong class="iw hi">translateZ </strong></code>来更改图层的合成。</p><p id="1065" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是最轻的渲染工作，但这并不意味着不可能有问题；有时候，你可以造成一个“<a class="ae it" href="https://www.alibabacloud.com/blog/front-end-performance-optimization-with-accelerated-compositing-part-1_594194" rel="noopener ugc nofollow" target="_blank">层爆炸</a>”(如果你不断堆叠层)，没有人希望这样。</p><p id="0c18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得一提的是，导致层爆炸是非常罕见的，因为浏览器的“层挤压”(阅读层爆炸参考)过程试图避免这一点。但是让我们把它留到下一篇关于性能的文章中。</p><p id="d62f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">改变覆盖(并不断更新)其他样式的类<strong class="iw hi">会</strong>导致你的网站回流，也会<a class="ae it" href="https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/" rel="noopener ugc nofollow" target="_blank">布局垃圾化</a>。另外，在修改子树节点时要小心。</p><p id="9880" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一个需要注意的重要事情是，触发浏览器同步计算元素的样式和布局通常会导致布局垃圾化，因此当我们计算或更改元素大小时，可能会引入一些性能瓶颈。</p><h1 id="36ad" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="ae2a" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们将在下面的文章中更多地讨论回流，但现在，我将列出一些可能导致网站回流的因素:</p><ul class=""><li id="7694" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">添加或移除类、元素或样式</li><li id="2c44" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">更改视口的方向</li><li id="6588" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">计算或改变大小或位置(小心使用<strong class="iw hi"> </strong> <code class="du ls lt lu lv b"><strong class="iw hi">getBoundingClientRect</strong></code>,因为这个本地API同步计算元素的大小)</li></ul><p id="d9ae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您想使用JS向DOM添加一些节点时，请记住本文中讨论的概念。您可能在想所有这些在代码上看起来是什么样子，事实是，当我们谈论性能时，事情很简单，但这并不意味着“容易”。但是不用担心；我计划在下面的文章中回顾与前端性能相关的所有内容。在以后的章节中，我们将讨论以下内容:</p><ul class=""><li id="4aa3" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">DevTools、性能分析器和JavaScript分析器</li><li id="da22" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">网络进程</li><li id="1787" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">特性试验</li><li id="b395" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">布局抖动(真实示例)</li><li id="bed2" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">内存和CPU泄漏</li></ul><p id="9a2a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想深入到暴露的话题，那么你可以看看这些链接:</p><ul class=""><li id="6c74" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated"><a class="ae it" href="https://www.youtube.com/watch?v=0PTBOX1HHIo&amp;ab_channel=OscarChavez" rel="noopener ugc nofollow" target="_blank">了解图形管道</a></li><li id="8fac" class="la lb hh iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated"><a class="ae it" rel="noopener" href="/@matthew.costello/frontend-web-performance-the-essentials-0-61fea500b180">前端web性能优化的基本要素</a></li></ul></div></div>    
</body>
</html>