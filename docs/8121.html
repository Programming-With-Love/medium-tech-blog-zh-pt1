<html>
<head>
<title>Optimizing API Performance with ZSTD Compression and Protocol Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用ZSTD压缩和协议缓冲区优化API性能</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/optimizing-api-performance-with-zstd-compression-and-protocol-buffers-571ad30f4893?source=collection_archive---------3-----------------------#2022-05-18">https://medium.com/walmartglobaltech/optimizing-api-performance-with-zstd-compression-and-protocol-buffers-571ad30f4893?source=collection_archive---------3-----------------------#2022-05-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dfcda25dbd6073acd133f8f3abe0db16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pteA7ClYUnTNy9JjNndZgA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo credit: <a class="ae it" href="https://pixabay.com/photos/binary-binary-code-binary-system-2910663/" rel="noopener ugc nofollow" target="_blank">geralt</a></figcaption></figure><p id="d875" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为大型有效负载构建高性能REST APIs绝非易事。随着公司越来越关注以最少的资源使用实现更快的服务级别协议(SLA ),在过去几十年中开发了几种新的数据压缩和序列化算法。</p><p id="f4f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在沃尔玛的Rollups团队中，我们从各种来源收集数据，并为沃尔玛的搜索和商品页面提供巨大的JSON负载。对于有时几兆字节(MB)大的有效负载，有效的串行化机制对于减少网络往返时间是至关重要的。</p><h1 id="d2c9" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">上卷系统概述</strong></h1><ul class=""><li id="9086" class="kq kr hh iw b ix ks jb kt jf ku jj kv jn kw jr kx ky kz la bi translated">Rollups是一个Kafka消费应用程序，它监听各种Kafka主题，并聚合关于沃尔玛销售的商品的不同信息。</li><li id="ef07" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">项目负载离线聚合为一个大的JSON字符串，并使用ZSTD算法进行压缩。压缩后的字节存储在Cassandra数据库中。</li><li id="ce8f" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">当客户在Walmart.com上执行搜索时，会实时调用搜索后端服务，该服务会通过一个编排器从汇总读取服务中获取压缩的字节。</li><li id="660b" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">orchestrator(我们的客户机)使用Rollups库在本地解压缩和反序列化有效负载。</li></ul><p id="5f72" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">来自搜索后端的请求是批量项目请求，可能导致总负载大小高达3 MB。反序列化这些大的有效负载会造成巨大的瓶颈，从而导致大量项目请求的延迟增加。本地Rollups库使用Jackson的fasterxml mapper来反序列化有效负载。尽管我们通过Jackson加力模块和一些定制的Jackson属性实现了5%的改进，但我们需要一种方法来减少整体延迟，以满足服务调用的SLA。JSON不是一个可行的选择，所以我们开始探索替代的序列化格式。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/d057e9d2fe8ffa52d4d8c3e21de2a7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Lu_2r4QjVJPeG9QKgdv7g.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><em class="ll">Architecture and bottlenecks</em></figcaption></figure><p id="17ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文评估了三种流行的序列化格式的优缺点:JSON、协议缓冲区(Protobuf)和Flatbuffers。我们运行了几个基准测试，并根据代码复杂性、易维护性、语义、解压缩时间、反序列化时间、网络时间和CPU以及内存使用情况对三种格式进行了比较。</p><p id="067d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下表显示了基于不同因素的获胜算法。这些结果特定于我们的模式定义，不能推广到其他用例。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1dac9b81628da761ab8a55ebfff2f377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZKL9QLkiau0s7_gaK8aWA.png"/></div></div></figure></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><h1 id="6a87" class="js jt hh bd ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl lx kn ko kp bi translated"><strong class="ak">模式</strong></h1><p id="f091" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">让我们比较一下Protobuf和Flatbuffers的模式定义。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/5a65f6affd5731dd3883f1f5986e0d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnbT-xTTiyAVLf3wU4M0Jg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><em class="ll">Protobuf vs. Flatbuffer Schema</em></figcaption></figure><p id="7b5f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Protobuf模式中，每个属性都有一个数据类型和字段编号。支持大多数标准数据类型，包括地图、列表和时间戳。有一些很棒的在线工具可以生成原型模式，这将加速开发。虽然这些工具不能实现完美的转换，但是它们提供了一个很好的基线。</p><p id="812e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Protobuf还提供了一些特殊的类型，比如oneof、Any和wrappers。需要注意的是，所有未设置的字段都被赋予了默认值。在客户端需要区分空值和默认值的情况下，这可能会导致问题。可以考虑使用包装器类型(wrappers.proto)来解决这个问题。</p><p id="43ae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flatbuffer模式也由一组包含在“表”中的属性组成。与Protobuf不同，它没有字段编号。因此，需要保留模式中属性的顺序。新字段应该总是添加在末尾。该模式还支持大多数标准数据类型。Flatbuffers允许不占用任何线路空间的可选类型，如果没有设置，也没有默认值。</p><h1 id="c63c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">序列化</strong></h1><p id="6bb9" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Protobuf使用“protoc”编译器为给定的模式生成代码，然后这些代码可以用来构建protobuf对象。Varint编码用于数据类型、字段编号和分隔字段长度。使用varint编码时，较小的整数在线路上占用较少的空间。例如，数字“11”在varint编码中会占用一个字节，但在JSON字符串中会占用两个字节。为模式中的属性确定正确的数据类型非常重要。较大的整数使用固定长度编码可能会更好。对于字符串，使用标准的UTF-8编码。如果模式结构简单并且主要包含字符串，JSON可能比Protobuf性能更好。</p><p id="9eb1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flatbuffers展平整个有效负载对象，以便每个属性都存储在相对于缓冲区开始的特定偏移位置。Flatbuffer对象有三个部分:vtable、pivot和数据块。考虑上面的平面缓冲器的模式图。</p><p id="aa64" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的示例中，有效负载是“Person”的一个实例该实例将有一个轴心点。在轴心点的左侧，存储了一个偏移列表。这被称为“虚拟表”“Person”的vtable有三个偏移值，表中的三个属性各有一个。它们将以与模式文件中定义的字段相同的顺序存储。在轴心点的右侧，将存储实际值。如果属性值是另一个复杂对象类型，则子对象的轴心点将存储在该偏移位置。例如，Person的vtable的第一个位置的偏移量“1”表示第一个字段值存储在轴心点右侧的一个位置。</p><p id="5329" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下表是序列化Flatbuffer在内存中的抽象表示。可以把表想象成一个一维结构，每一行都是前一行的延续。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/8a477154f5a1dfb8c73813d62b31d30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7uGmu4ASy3VO05zrKmwXw.png"/></div></div></figure><h2 id="7f74" class="md jt hh bd ju me mf mg jy mh mi mj kc jf mk ml kg jj mm mn kk jn mo mp ko mq bi translated"><strong class="ak">使用Protobuf/Flatbuffers时，我们还需要ZSTD压缩吗？</strong></h2><p id="38b2" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Protobuf通过varint编码实现了良好的压缩比。在大多数情况下，可能没有必要增加额外的压缩层。然而，为了达到与压缩的JSON有效负载大小相等的有效负载大小，我们对Protobuf对象应用了ZSTD压缩。</p><p id="27e9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有趣的是，ZSTD在Flatbuffer对象上工作得并不好。这可能是因为序列化对象中的偏移量很大，很难压缩。压缩后的Flatbuffer比压缩后的JSON大63%。在我们运行基准测试之前，我们希望反序列化时间的节省能够弥补增加的大小。</p><h1 id="6264" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">基准测试结果</strong></h1><p id="58b2" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">一个包含20个产品的样本集用于对生产中的所有三种数据格式进行负载测试。沃尔玛的Omniperf平台被用来进行大规模测试。测试持续了10分钟，每种格式总共收到了41，000个请求。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/69378b4b4c5b1216cbaa1bdfe68641b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5-vNFJp8QMvIpBaSa0aiA.png"/></div></div></figure><p id="c18d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些结果表明，随着有效负载大小的增加，flatbuf的性能略好于Protobuf。然而，只有一小部分沃尔玛客户流量包含超过几MB的大量请求。因此，对于一般用例来说，Protobuf似乎稍有优势。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/7dec3ffa6b20404258b40f3e9e9b33da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCSvCLnIUtvoN5PlovXLuw.png"/></div></div></figure><p id="0765" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更有趣的是检查每种格式的解压缩和反序列化时间。对于较小的负载(最大为230 KB)，Protobuf在反序列化时间上提供了高达56%的改进，然后性能逐渐开始下降，如上图所示。然而，对于大负载用例，它仍然比JSON好32%。另一方面，Flatbuffer对象不需要进行任何反序列化。它们只需要一个小小的解包步骤来确保有效载荷准备好进行遍历。在大多数情况下，这需要不到1毫秒的时间。</p><p id="441e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就解压缩时间而言，Protobuf和Flatbuffers都比JSON有了很大的改进。</p><p id="ccc8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flatbuffers比Protobuf使用更少的CPU和内存。由于其零拷贝序列化格式，这是意料之中的。对于对CPU和内存敏感的应用程序，Flatbuffers可能是更好的选择。</p><h1 id="b61c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">相关工作</strong></h1><p id="cda8" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Protobuf在与REST一起使用HTTP 1时提供了很大的好处，但它更广泛地与Google Remote Procedure Call (gRPC)一起被采用，后者使用带有头压缩和传输控制协议(TCP)连接重用的HTTP 2。我们计划在不久的将来用gRPC和Protobuf进行一些测试。</p><h1 id="dde8" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">结论</strong></h1><p id="4706" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Flatbuffers和Protobuf在整个P95处理时间上产生了相似的结果，所以我们的决定完全基于编码的复杂性和维护的方便性。</p><p id="49dd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flatbuffers要求在代码中显式创建偏移量。这很难维护，而且很容易出错。Protobuf具有与普通旧Java对象(POJOs)相同的getter/setter语义，从长远来看，似乎是一个更安全、更容易使用的选项。它还拥有更好的社区支持和可以无缝插入的开源库。因此，采用ZSTD压缩的Protobuf成为了我们的最终选择。</p></div></div>    
</body>
</html>