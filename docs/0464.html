<html>
<head>
<title>Android Styling: themes overlay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android风格:主题覆盖</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-styling-themes-overlay-1ffd57745207?source=collection_archive---------0-----------------------#2020-02-26">https://medium.com/androiddevelopers/android-styling-themes-overlay-1ffd57745207?source=collection_archive---------0-----------------------#2020-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0794f6a350f1423438d82a81e381d297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_oRkdiiwzxsiEKUW-KSRXg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="4eec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列关于Android样式的前几篇文章中，我们已经看到了样式和主题之间的<a class="ae hu" rel="noopener" href="/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578">差异</a>，讨论了使用主题和主题属性的<a class="ae hu" rel="noopener" href="/androiddevelopers/android-styling-prefer-theme-attributes-412caa748774">好处</a>，并强调了一些要使用的<a class="ae hu" rel="noopener" href="/androiddevelopers/android-styling-common-theme-attributes-8f7c50c9eaba">常见属性</a>。</p><p id="253f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">今天我们将关注实际上使用主题的<em class="js">，它们如何应用到你的应用程序中，以及对你如何构建它们的影响。</em></p><h1 id="dd1b" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">范围</h1><p id="9d51" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">在之前的一篇文章中，我们<a class="ae hu" rel="noopener" href="/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578#0d0e">提到了</a>:</p><blockquote class="kw kx ky"><p id="7af6" class="iu iv js iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated">一个<code class="du lc ld le lf b"><a class="ae hu" href="https://developer.android.com/reference/android/content/res/Resources.Theme.html" rel="noopener ugc nofollow" target="_blank">Theme</a></code>作为一个<code class="du lc ld le lf b"><a class="ae hu" href="https://developer.android.com/reference/android/content/Context" rel="noopener ugc nofollow" target="_blank">Context</a></code>的属性被访问，并且可以从任何有上下文的对象中获得，例如<code class="du lc ld le lf b">Activity</code>、<code class="du lc ld le lf b">View</code>或<code class="du lc ld le lf b"> ViewGroup</code>。这些对象存在于一棵树中，其中一个<code class="du lc ld le lf b">Activity</code>包含<code class="du lc ld le lf b">ViewGroup</code> s，后者包含<code class="du lc ld le lf b">View</code> s等等。在这个树的任何一层指定一个主题会级联到后代节点，例如在一个<code class="du lc ld le lf b">ViewGroup</code>上设置一个主题会应用到其中所有的<code class="du lc ld le lf b">View</code>(与只应用到单个视图的样式形成对比)。</p></blockquote><p id="c29f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个树的任何一层设置一个主题都不会取代当前有效的主题，它会覆盖当前有效的主题。考虑下面的<code class="du lc ld le lf b">Button</code>哪个物种有一个主题，但是谁的父代也指定了一个主题:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7007" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果在两个主题中都指定了一个属性，那么最局部的“胜利”，即那些在<code class="du lc ld le lf b">Bar</code>中的胜利，将被应用到按钮上。主题<code class="du lc ld le lf b">Foo</code>中指定的属性，但主题<code class="du lc ld le lf b">Bar</code>中未指定的属性<strong class="iw hy">也将应用于按钮。</strong></p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lm"><img src="../Images/fb4113c28ab3a7ee9cd12f78277d906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hhaMiDxkaBW5eKra"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Themes overlay each other</figcaption></figure><p id="d378" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这看起来像是一个人为的例子，但这种技术对于用不同的外观设计应用程序的子部分非常有用，例如在一个明亮的屏幕上有一个黑色的工具栏，或者这个屏幕(来自<a class="ae hu" href="https://github.com/material-components/material-components-android-examples/tree/develop/Owl" rel="noopener ugc nofollow" target="_blank"> Owl示例应用程序</a>)有一个很大的粉红色主题，但显示相关内容的底部有一个蓝色主题:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/96423f0476d8a07df1e54da221c939a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*TZS5oUILbC_c7edp"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">A blue sub-section within a pink themed screen.</figcaption></figure><p id="cddd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这可以通过在蓝色区域的根部设置一个主题来实现，它会级联到其中的所有视图。</p><h1 id="3259" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">过度覆盖</h1><p id="7fcb" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">当主题覆盖树中任何更高的主题时，重要的是要考虑<em class="js">你的主题指定了什么</em>以确保它不会意外地<em class="js">替换</em>你想要保留的属性。例如，你可能想改变一个视图的背景颜色(通常由<code class="du lc ld le lf b">colorSurface</code>控制),但不想改变其他，也就是说，你想保留当前主题的其余部分。为此我们可以使用一种叫做<strong class="iw hy">主题叠加</strong>的技术。</p><p id="af7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些主题被设计成覆盖另一个主题。它们的范围尽可能窄，即它们只定义(或继承)尽可能少的属性。事实上，主题叠加通常(但不总是)没有父级，例如:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="kw kx ky"><p id="a725" class="iu iv js iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated">主题覆盖是范围很窄的主题，定义尽可能少的属性，旨在覆盖另一个主题</p></blockquote><p id="bd49" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按照惯例，我们以“ThemeOverlay”开头命名这些。MDC (和<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/appcompat/src/main/res/values/themes.xml#76" rel="noopener ugc nofollow" target="_blank"> AppCompat </a>)提供了许多方便的主题覆盖图<a class="ae hu" href="https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/theme/res/values/themes_overlay.xml" rel="noopener ugc nofollow" target="_blank">，你可以用它们将你的应用程序的一个部分的颜色从亮变暗:</a></p><ul class=""><li id="c191" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr lt lu lv lw bi translated"><code class="du lc ld le lf b"><a class="ae hu" href="https://github.com/material-components/material-components-android/blob/3fba0eeade07f2915056f539047cce40fb31274b/lib/java/com/google/android/material/theme/res/values/themes_overlay.xml#L34-L45" rel="noopener ugc nofollow" target="_blank">ThemeOverlay.MaterialComponents.Dark</a></code></li><li id="e8c0" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr lt lu lv lw bi translated"><code class="du lc ld le lf b"><a class="ae hu" href="https://github.com/material-components/material-components-android/blob/3fba0eeade07f2915056f539047cce40fb31274b/lib/java/com/google/android/material/theme/res/values/themes_overlay.xml#L21-L32" rel="noopener ugc nofollow" target="_blank">ThemeOverlay.MaterialComponents.Light</a></code></li></ul><p id="88af" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据定义，主题叠加图并不指定许多东西，也不应该孤立使用，例如作为你活动的主题。事实上，你可以想出两种可以在应用中使用的主题:</p><ol class=""><li id="f423" class="lo lp hx iw b ix iy jb jc jf lq jj lr jn ls jr mc lu lv lw bi translated"><strong class="iw hy">“充实”的主题</strong>。这些详细说明了你在屏幕上需要的一切。它们继承了另一个“完整”主题，如<code class="du lc ld le lf b">Theme.MaterialComponents</code>，应该用于主题化一个<code class="du lc ld le lf b">Activity</code>。</li><li id="b3fd" class="lo lp hx iw b ix lx jb ly jf lz jj ma jn mb jr mc lu lv lw bi translated"><strong class="iw hy">主题叠加</strong>。仅适用于<em class="js">整个主题，即不应孤立使用，因为可能不会指定重要和必要的内容。</em></li></ol><h1 id="13b1" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">无处不在</h1><p id="606c" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">总有一个主题在起作用，即使你没有在你的应用程序中指定一个主题，你也会继承一个默认的主题。因此，上面的例子是一个简化，你不应该在<code class="du lc ld le lf b">View</code>中使用完整的主题，而应该使用主题叠加:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="acbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些覆盖物不会孤立存在，但它们本身会覆盖在外围<code class="du lc ld le lf b">Activity</code>的主题上。</p><h1 id="a95c" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">成本:收益</h1><p id="aa58" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">使用主题有运行时成本；每次你声明一个<code class="du lc ld le lf b">android:theme</code>，你就创建了一个新的<code class="du lc ld le lf b"><a class="ae hu" href="https://developer.android.com/reference/android/view/ContextThemeWrapper" rel="noopener ugc nofollow" target="_blank">ContextThemeWrapper</a></code>，它分配了新的<code class="du lc ld le lf b">Theme</code>和<code class="du lc ld le lf b">Resources</code>实例。它还引入了更多要解决的间接样式级别。小心不要过度使用主题<em class="js">或</em>，尤其是在重复出现的情况下，如<code class="du lc ld le lf b">RecyclerView</code>项目布局或个人资料，以监控它们的影响。</p><h1 id="8ba7" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在上下文中使用</h1><p id="f18e" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们说过一个<code class="du lc ld le lf b">Theme</code>与一个<code class="du lc ld le lf b">Context</code>相关联——这意味着如果你在代码中使用一个<code class="du lc ld le lf b">Context</code>来检索一个资源，那么要小心使用正确的<code class="du lc ld le lf b">Context</code><em class="js">。例如，您可以在代码中的某个地方检索一个<code class="du lc ld le lf b">Drawable</code>:</em></p><pre class="lg lh li lj fd md lf me mf aw mg bi"><span id="2912" class="mh ju hx lf b fi mi mj l mk ml">someView.background = AppCompatResources.getDrawable(<strong class="lf hy">requireContext()</strong>, R.drawable.foo)</span></pre><p id="ff3b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果drawable引用了一个主题属性(所有drawable都可以从API 21+中执行，而<code class="du lc ld le lf b">VectorDrawable</code> s <a class="ae hu" rel="noopener" href="/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf#0a52">可以通过Jetpack从API 14+中执行</a>)，那么你应该确保使用正确的<code class="du lc ld le lf b">Context</code>来加载<code class="du lc ld le lf b">Drawable</code>。如果你不这样做，当你试图将一个主题应用到一个子层次结构时，你可能会感到沮丧，并想知道为什么你的<code class="du lc ld le lf b">Drawable</code>不尊重它。例如，如果你使用一个<code class="du lc ld le lf b">Fragment</code>或<code class="du lc ld le lf b">Activity</code>的<code class="du lc ld le lf b">Context</code>来加载<code class="du lc ld le lf b">Drawable</code>，这将不考虑应用在树中较低位置的主题。取而代之的是使用最接近资源使用位置的<code class="du lc ld le lf b">Context</code> <em class="js">:</em></p><pre class="lg lh li lj fd md lf me mf aw mg bi"><span id="85f8" class="mh ju hx lf b fi mi mj l mk ml">someView.background = AppCompatResources.getDrawable(<strong class="lf hy">someView.context</strong>, R.drawable.foo)</span></pre><h1 id="1b04" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">错误应用</h1><p id="6633" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们已经讨论了存在于树中的主题和上下文:<code class="du lc ld le lf b">Activity</code> &gt; <code class="du lc ld le lf b">ViewGroup</code> &gt; <code class="du lc ld le lf b">View</code>等等。扩展这个心智模型来包含<code class="du lc ld le lf b">Application</code>类可能很有诱惑力，毕竟您可以在清单中的<code class="du lc ld le lf b">&lt;application&gt;</code>标签上指定一个主题。<strong class="iw hy">不要被这个</strong>骗了！！</p><p id="afde" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lc ld le lf b">Application</code><code class="du lc ld le lf b">Context</code><strong class="iw hy">不</strong>保留任何主题信息，你可以在你的清单中设置的主题仅仅是作为任何没有明确设置主题的<code class="du lc ld le lf b">Activity</code>的后备。因此，你不应该使用<code class="du lc ld le lf b">Application</code> <code class="du lc ld le lf b">Context</code>到<a class="ae hu" href="https://riggaroo.co.za/dark-mode-musings-beware-of-the-context/" rel="noopener ugc nofollow" target="_blank">加载资源</a>，这些资源可能会因主题(如可绘制性或颜色)而异，或者解析主题属性。</p><blockquote class="kw kx ky"><p id="995f" class="iu iv js iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated"><em class="hx">千万不要使用</em> <code class="du lc ld le lf b"><em class="hx">Application</em></code> <em class="hx"> </em> <code class="du lc ld le lf b"><em class="hx">Context</em></code> <em class="hx">来加载主题资源</em></p></blockquote><p id="1e1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这也是为什么我们为一个<code class="du lc ld le lf b">Activity</code>指定了一个“完整的”主题，并把它们构造成从任何应用程序范围的主题扩展而来——一个<code class="du lc ld le lf b">&lt;activity&gt;</code>的主题不会覆盖在<code class="du lc ld le lf b">&lt;application&gt;</code>的主题上</p><h1 id="3f61" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">建立</h1><p id="7379" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">希望这篇文章已经解释了主题如何覆盖树中的祖先，以及这种行为如何在设计我们的应用程序时有用。使用<code class="du lc ld le lf b">android:theme</code>标签来主题化布局的各个部分，并使用主题叠加来调整您需要的属性。请注意使用正确的主题和上下文来加载资源，并注意应用程序上下文！</p></div></div>    
</body>
</html>