<html>
<head>
<title>Characteristics of a Poor Software Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">糟糕的软件设计的特征</h1>
<blockquote>原文：<a href="https://medium.com/globant/characteristics-of-a-poor-software-design-de71e7b7a73c?source=collection_archive---------1-----------------------#2020-11-25">https://medium.com/globant/characteristics-of-a-poor-software-design-de71e7b7a73c?source=collection_archive---------1-----------------------#2020-11-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="7b56" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">成为一名神盾局程序员:(第1部分)</h2><div class=""/><figure class="ev ex io ip iq ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es in"><img src="../Images/8a4512ba53c01368b9865c35ae0b6e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w75AaW2Uo0eCmQ3zxSPgWA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx">Image<strong class="bd jc"> </strong><em class="jd">Courtesy</em><strong class="bd jc"> </strong>: <a class="ae je" href="https://www.joetheitguy.com/tag/user-error/" rel="noopener ugc nofollow" target="_blank">https://www.joetheitguy.com/tag/user-error/</a></figcaption></figure><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="d012" class="jo jp hh jk b fi jq jr l js jt">In this 2 part series, I talk about SOLID principle, definition and its usage to avoid bad programming design.</span></pre><p id="710e" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">阅读博客的标题，你一定会想，当有大量的材料谈论好的软件设计实践时，这个世界上谁会愿意谈论坏的设计呢？我听我的朋友们谈论了很多软件设计的最佳实践。但是你不知道糟糕的设计是什么样子，怎么知道什么是好的；)</p><p id="870f" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在我作为软件开发人员的职业生涯中，我遇到过一些设计糟糕的模块。在处理这些模块、修复错误和尝试添加新功能时，我意识到了这些设计原则的重要性。我更重视它们，因为遵循它们帮助我解决了开发过程中面临的挑战。</p><p id="5df6" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">就像我说的，当你意识到设计很差时，最常见的情况是维护别人已经写好的代码。</p><p id="3133" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">我在这种情况下遇到的常见挑战有</p><ul class=""><li id="8aa9" class="ks kt hh jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">在开发一个功能的过程中破坏另一个功能。</li><li id="e900" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">现有代码不支持未来的增强。</li><li id="1f19" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">理解和维护代码的复杂性。</li><li id="0611" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">难以孤立地测试功能</li><li id="218e" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">难以添加新功能</li></ul><p id="53ba" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">听起来很熟悉？如果是的话，有没有想过“如何避免它们？”。嗯，了解这些的根本原因很重要。</p><p id="9d7d" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">避免错误的最简单的方法是理解和识别坏的编程习惯，并采用好的编程习惯来更好地开发应用程序。</p><p id="51f7" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">根据公认的开发软件设计原则的Robert C. Martin所说，一个糟糕的设计有4个重要的特征。这些是:</p><ul class=""><li id="5ee3" class="ks kt hh jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jw hr"><em class="lg"/></strong></li><li id="5ff7" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jw hr"> <em class="lg">不动</em> </strong></li><li id="7a38" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jw hr"> <em class="lg">脆弱性</em> </strong></li><li id="ac08" class="ks kt hh jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jw hr"> <em class="lg">粘度</em> </strong></li></ul><p id="3ab9" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi lh translated"><span class="l li lr bm di ls"><img alt="R" class="iw lt lu lv lw lx ds n gv dh bf" src="../Images/014bdf87541820768dedb41ed7caca7d.png" width="64" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:128/1*8oxi_VG49j9gWvHAMQKyCA.png"/><span class="l li lj lk bm ll lm ln lo lp di lq">R</span></span><strong class="jw hr">igidity:<em class="lg">如果一个类中的每一个小变化都转化为其他依赖类中的级联变化，那么代码中就存在耦合。这使得代码僵化。让我们通过下面的例子来理解这一点，在这个例子中，类名被显式地使用，而不是抽象。</em></strong></p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="b4dd" class="jo jp hh jk b fi jq jr l js jt">public class ReportClient {</span><span id="e6bb" class="jo jp hh jk b fi ly jr l js jt">public void reportType(String reportType, Map filterParams) {<br/>      // for saving few lines let us assume reportType is already <br/>      set to one of "CSV","PDF", "XML"        <br/>      ReportGenerator rg = new ReportGenerator();<br/>      if (reportType == "CSV") {<br/>      rg.downloadCSVReport(filterParams);<br/>      } else if (reportType == "PDF") {<br/>      rg.downloadPDFReport(filterParams);<br/>      } else if (reportType == "XML") {<br/>      rg.downloadXMLReport(filterParams);<br/>      }<br/>   }<br/>}</span><span id="87e5" class="jo jp hh jk b fi ly jr l js jt">public class ReportGenerator {<br/>     // constructor<br/>     public ReportGenerator() {<br/>     }<br/>     // common method to fetch data from database<br/>     protected ReportData extractData(Map filterParams) {<br/>     ReportData reportData;<br/>     // logic to fetch data and return it to calling method<br/>     return reportData;<br/>     }</span><span id="a6b6" class="jo jp hh jk b fi ly jr l js jt">     public void downloadCSVReport(Map filterParams) {<br/>     // Step 1. extract data from DB<br/>     // write data in CSV format<br/>     // download the report with content type as MS Excel sheet<br/>     }</span><span id="3c1e" class="jo jp hh jk b fi ly jr l js jt">     public void downloadPDFReport(Map filterParams) {<br/>     // Step 1. extract data from DB<br/>     // write data in PDF format<br/>     // download the report with content type as PDF<br/>     }</span><span id="9375" class="jo jp hh jk b fi ly jr l js jt">     public void downloadXMLReport(Map filterParams) {<br/>     // Step 1. extract data from DB<br/>     // write data in XML format<br/>     // download the report with content type as XML<br/>     }<br/> }</span></pre><p id="edfb" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">上面的例子是一个以各种格式导出数据的工具，比如银行对账单。例如，pdf、csv和xml。extractData()方法常用于导出所有格式的报告。</p><p id="0c37" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">一切进展顺利，直到客户要求在报告的PDF格式中添加一些特定字段。现在，因为extract方法对于所有格式都是通用的，所以所有格式的查询都会发生变化，因此ReportData DTO也会发生变化。现在，作为一名开发人员，如果我编写一个if语句并为PDF报告创建一个单独的提取逻辑，会出现问题吗？但是这并不容易改变，因为ReportGenerator类没有关于reportType的信息。嗯，我可以将reportType传递给ReportGenerator类的构造函数，修复这个问题。但是这会导致两个类中都存在多余的if语句。</p><p id="a4b5" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">嗯，太复杂了！！很难仅仅为了在报表中添加几个字段而修改代码。这叫做设计的<strong class="jw hr">刚性</strong>。具有紧密耦合的系统可能会导致这种僵化，并使得在产品中实现增强和添加新功能变得困难。</p><p id="b278" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated"><strong class="jw hr">设计刚性的弊端</strong> : <br/> 1。很难给出变化<br/> 2的近似值。会导致测试比预期更多的组件<br/> 3。会让经理们害怕允许微小的改变，并因此而忍受应用程序中的缺陷</p><p id="8981" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi lh translated"><span class="l li lr bm di lz"><img alt="I" class="iw lt lu lv lw lx ds n gv dh bf" src="../Images/42a639b2bf45105277a7a1bcdb31cd15.png" width="35" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:70/1*FfZYi82Sa9i99xOzp5DdIw.png"/><span class="l li lj lk bm ll lm ln lo lp di lq">I</span></span><strong class="jw hr">m移动性</strong> : <strong class="jw hr"> </strong>在上面的例子中，我们有一些方法可以提取数据并以特定的格式导出，比如CSV格式。不管内容和列是什么，编写CSV的逻辑几乎是相同的。因此，假设产品中的其他模块想要重用以CSV格式写入数据的逻辑。但是，由于我们这样做的代码与这个特定的报告生成代码紧密相关，因此它不能在其他模块中重用。此外，提取该逻辑并将其提供给其他模块也需要大量的工作。(请记住，不要将可重用性与在项目中制作相同代码的多个副本相混淆。)</p><p id="03c3" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">当组件紧密耦合或高度依赖彼此，并且不能在另一个地方重用时，代码被称为不可移动的。在上面的例子中，虽然生成CSV的实现是可用的，但它既不能作为实用方法访问，也不能作为可分发的实现访问。</p><p id="15d5" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated"><strong class="jw hr">设计不灵活的弊端</strong> : <br/> 1。难以重用最常见的功能。</p><p id="caf5" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">2.如果需要重用该模块，那么将其从原始设计中分离出来的努力和风险将会很高</p><p id="734c" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">3.导致在项目的多个地方创建相同代码的副本，这也意味着原始代码中的错误被复制。在原始代码中修复这个bug并不会在其他地方自动修复。需要单独努力来解决这些问题</p><p id="01bf" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi lh translated"><span class="l li lr bm di ma"> <img alt="F" class="iw lt lu lv lw lx ds n gv dh bf" src="../Images/a01b33e9057ab7863124b59bd639192d.png" width="56" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:112/1*xm4kEZSFsCMgnQz3_sTamA.png"/> <span class="l li lj lk bm ll lm ln lo lp di lq"> F </span> </span> <strong class="jw hr">脆弱性</strong> : <strong class="jw hr"> <em class="lg">当代码中的任何新变化破坏了系统中意想不到的部分时，设计就是脆弱的。这种软件很难维护，因为一个补丁引入的问题比解决的问题还多，从而使情况变得更糟。</em></strong></p><p id="8841" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">脆弱的代码会以你无法预测的怪异方式崩溃。脆弱性可以通过构建高度模块化、高度内聚和松散耦合的软件来避免<em class="lg">。</em></p><p id="f138" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated"><strong class="jw hr">设计脆弱的缺点</strong> : <br/> 1。一些模块会持续出现在错误列表中。更多的时间被花费在修正错误上，而不是修正实际的问题。<br/> 3。程序员不愿意对代码进行修改，因为由于他们在修复错误时遇到的问题，他们对这样一段代码的信心非常低。</p><figure class="jf jg jh ji fd ir er es paragraph-image"><div class="er es mb"><img src="../Images/7d4275838a1c5972ad5813f0b6db4a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*N0fSiABopmcUgckcv31Tjg.jpeg"/></div></figure><p id="d47a" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi lh translated"><span class="l li lr bm di mc"> <img alt="V" class="iw lt lu lv lw lx ds n gv dh bf" src="../Images/0271374a29826bd1ace6379fadd570dd.png" width="52" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:104/1*GwJbwNElhqo92LPtbOr6Vg.png"/> <span class="l li lj lk bm ll lm ln lo lp di lq"> V </span> </span> <strong class="jw hr">粘滞度</strong>:在实施任何变更时，可以有两种方式来实施修复。一个是保留设计，另一个是破坏设计的捷径。<strong class="jw hr"> <em class="lg">粘性指的是开发者可以将保留设计的代码添加到系统中的难易程度。</em> </strong>如果添加hack比设计保留代码更容易，那么系统具有高粘性。</p><p id="2851" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">随着时间的推移，越粘的代码变得不可维护，因为它充满了漏洞(使用漏洞比采用正确的设计方法更容易修复)。因此，需要重新设计代码。但是重新设计和重构这种代码在时间和金钱上是昂贵的，而不是用正确的设计编写一个新工具。</p><p id="e0b2" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated"><strong class="jw hr">粘度在设计上的缺点</strong> : <br/> 1。开发环境缓慢低效<br/> 2。导致编译时间长，测试反馈时间长，集成困难</p><p id="7019" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">如果设计有以上提到的一个或多个特征，一个糟糕的软件设计可以被识别出来。</p><p id="8d47" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">如果我们知道一个糟糕的设计是什么样子，如果我们知道避免这些特征的指导原则，那么想出一个好的软件设计并不困难:)。</p><p id="bf2d" class="pw-post-body-paragraph ju jv hh jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">这些指导方针通常被称为坚实的原则。是的固体！S.O.L.I.D .是软件设计原则，它使程序员能够做出重要的决定，并提供有效处理设计过程复杂性的方法，同时保持事情简单。要详细了解神盾局的原则，请阅读我的下一篇文章！</p></div></div>    
</body>
</html>