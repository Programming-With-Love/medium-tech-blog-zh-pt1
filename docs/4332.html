<html>
<head>
<title>Advanced FP for the Enterprise Bee: Typeclasses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业Bee的高级FP:type classes</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-typeclasses-2addc232ae23?source=collection_archive---------0-----------------------#2021-02-05">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-typeclasses-2addc232ae23?source=collection_archive---------0-----------------------#2021-02-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/42013cc511cb741e4d12c0ae25a15d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oOFUf_kkNWyHzS8Q.jpg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Separate Frames from a Beehive</figcaption></figure><h1 id="bbd8" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">介绍</h1><p id="bd91" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">到目前为止，在我们的系列中，我们已经看到了FP库(像<a class="ae kp" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank"> Arrow </a>和<a class="ae kp" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank"> Cats </a>)向现有类型添加了额外的操作。这是通过<strong class="jt hi">类型类</strong>完成的。Typeclass(如果您愿意，也可以称为Type Class)是将一组函数与一组字段关联起来的另一种方式。</p><p id="a8dc" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">Typeclasses <a class="ae kp" href="http://learnyouahaskell.com/types-and-typeclasses" rel="noopener ugc nofollow" target="_blank">是Haskell </a>的组成部分，Swift为<a class="ae kp" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank">提供了一个类似的特性，称为协议</a>。它们在Kotlin或Scala中并不直接可用，但这些语言为我们提供了模拟它们所需的工具。</p><p id="ce91" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">本文将解释什么是Typeclasses，为什么它们有用，以及如何用Kotlin和Scala编写它们。然后我们将回顾来自Arrow库的一个Typeclasses的实际例子。</p><h1 id="6471" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">普通班有什么不好？</h1><p id="a024" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">在我们开始之前，让我们花一分钟来检查一下传统课程有什么问题。我们将回顾编写传统C++/Java/C#风格的类的标准理由，然后看看我们能否反驳它们。如果你已经确信了类型类的价值，可以跳过这一节。</p><p id="48e6" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated"><strong class="jt hi">类协同定位数据和函数</strong>。这个论点似乎是无可辩驳的。为什么不想把数据和使用这些数据的函数放在同一个地方呢？毕竟，任何被诅咒维护写得很差的C代码的人都知道当情况并非如此时的悲惨结果。</p><p id="bb85" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">然而，正如我第一次从阅读Effective C++中学到的，一个类的<a class="ae kp" href="https://www.fluentcpp.com/2017/06/20/interface-principle-cpp/" rel="noopener ugc nofollow" target="_blank">接口超出了类型</a>的定义。您总是会有助手函数，它们接受该类型的一个实例并执行额外的工作。即使你的类是完美的，你仍然需要帮助函数来实现可选的和/或上下文相关的功能。</p><p id="b96b" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这就是为什么微软在设计LINQ查询语法的时候给C# 增加了扩展方法。其他类型语言，<a class="ae kp" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">包括Kotlin </a>，也是这么做的。</p><p id="74c8" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated"><strong class="jt hi">类防止状态</strong>的意外变化。这又是一个非常有力的论点。对对象中的字段进行不受控制的访问使得管理状态变得不切实际，维护也成了一场噩梦。然而，在纯FP中，我们要求我们的数据是不可变的，所以不受控制的变化不会成为问题。</p><p id="276d" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated"><strong class="jt hi">类抽象数据的格式</strong>。这里的论点是，您想要自由地更改字段中使用的数据类型。例如，如果一个数字需要从<em class="kv"> int </em>改为<em class="kv"> long </em>或<em class="kv"> float </em>，你可以这样做，而不会影响到你的代码库。</p><p id="4414" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这是非常可取的，但不需要OO。您所需要的只是一组函数，它们组成了底层数据的接口。例如，您可以使用一组PL/SQL存储过程来隐藏Oracle中数据库表的底层格式。</p><p id="74a4" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated"><strong class="jt hi">类支持继承和多态</strong>。当我学习编码时，继承和多态非常流行。它们是面向对象的杀手级特性。不幸的是，现实世界几十年的使用表明，实现继承往往比它的价值更麻烦。多态仍然非常有用，尤其是通过接口。但是，正如我们将看到的，Typeclasses至少也可以提供多态性。</p><h1 id="223b" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是类型类？</h1><p id="c7e5" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">Typeclassses的一个简单用例是支持到外部格式的转换。假设我们有时希望封送和反封送实体对象的内容。根据使用实体对象的上下文，格式可以是XML或JSON。</p><p id="02e0" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这里有一个接口来表示我们需要的功能:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="94bc" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们在类型参数t上定义了两个扩展方法。<em class="kv">编组</em>方法将把对象状态转换成某种文本格式，而<em class="kv">解组</em>方法将做相反的事情。</p><p id="69ab" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated"><em class="kv"> unmarshal </em>方法在类的层次上声明更合适，但是出于示例的目的，我们将使它成为一个实例方法。</p><p id="5c22" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">接下来，我们创建一些简单的实体类型:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="1e95" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">定义了接口和实体类型之后，我们可以为每种类型创建一个实现。下面是一些简单的<em class="kv">编组器</em>对象，用于将实例与JSON相互转换的<em class="kv">人员</em>和<em class="kv">实体</em>类型:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="2e05" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">通过周围的<em class="kv"> JsonMarshalling </em>对象和用于Person 和Order 的访问器函数<em class="kv">，实现的细节被封装。</em></p><p id="68c4" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们重复通过XML进行编组的过程。正如您所料，代码的结构是相同的:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="efc1" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们现在需要的一切都准备好了。在下面的演示中，我们导入了<em class="kv"> JsonMarshalling </em>类型，并使用访问器函数来获得我们的<em class="kv">编组器</em>接口的实现。当我们转换样本<em class="kv"> Person </em>和<em class="kv"> Order </em>对象中的数据时，我们需要扩展方法在范围内。由于内置的<em class="kv"> run </em>方法，这很容易做到。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="5b53" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这是产生的输出。如您所见，我们已经成功地在JSON之间进行了封送:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="3370" class="lh iu hh ld b fi li lj l lk ll">{ “person”: Jane }<br/>Person called Dave<br/>{ “order”: 123.45 }<br/>Order of value 456.78</span></pre><p id="04f2" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">鉴于Typeclasses都是关于可选功能的，切换到<em class="kv"> XmlMarshalling </em>实现应该很容易:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f60b" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">现在，我们可以在XML之间来回编组:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="3aeb" class="lh iu hh ld b fi li lj l lk ll">&lt;person&gt;Jane&lt;/person&gt;<br/>Person called Dave<br/>&lt;order&gt;123.45&lt;/order&gt;<br/>Order of value 456.78</span></pre><p id="1712" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">使用简单的扩展函数也可以获得相同的结果。但是编译器不能检测一个类型是否在没有<code class="du lm ln lo ld b">unmarshal</code>的情况下实现了<code class="du lm ln lo ld b">marshal</code>，反之亦然。Typeclasses为我们提供了一种将相关扩展捆绑到单一抽象中的方法。这提高了我们设计的质量和最终代码的可维护性。</p><h1 id="a148" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">Scala比较</h1><p id="2153" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们已经看到，我们可以通过添加扩展方法集来成功地增强现有类型。但是有相当多的管道工程要做。在Scala中，这还会更简单吗？让我们移植示例并找出…</p><p id="75eb" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这是我们原始接口的Scala版本:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="af2c" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">以及相应的实体类型:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="0ac6" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">当我们实现接口时，差异就出现了:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="bb80" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们已经将这些实例标记为<em class="kv">隐式</em>。当客户端代码请求时，这允许编译器代表我们使用它们。隐式声明是Scala的一个“链锯特性”,在版本3中被重新设计。</p><p id="1deb" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">另一个主要区别是Scala 2不直接支持扩展方法。相反，隐式声明为我们做了所有繁重的工作。</p><p id="133a" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们定义了一个名为<em class="kv"> JsonMarshallingOps </em>的隐式类型，它接受一个T并提供<em class="kv">编组</em>和<em class="kv">解组</em>方法。这些将工作委托给<em class="kv">编组器</em>实例，因为它们本身被声明为<em class="kv">隐式</em>，所以将被编译器发现:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ca43" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">当我们在Person对象上调用<em class="kv"> marshal </em>时，编译器将:</p><ul class=""><li id="7d7d" class="lp lq hh jt b ju kq jy kr kc lr kg ls kk lt ko lu lv lw lx bi translated">创建一个<em class="kv"> JsonMarshallingOps </em>对象<em class="kv">，</em>通过<em class="kv">值</em>传入人员</li><li id="6551" class="lp lq hh jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">找到<em class="kv">编组器【T】</em>的实例，以满足隐式参数列表</li><li id="055b" class="lp lq hh jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">插入对<em class="kv"> JsonMarshallingOps </em>的<em class="kv"> marshal </em>方法的调用</li></ul><p id="f144" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这似乎非常复杂。但是当我们检查客户端代码时，我们只需要执行导入:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="38aa" class="lh iu hh ld b fi li lj l lk ll">{ "person": Jane }<br/>Person called Dave<br/>{ "order": 123.45 }<br/>Order of value 456.78</span></pre><p id="0480" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">总之，Scala实现比Kotlin更复杂。然而，这种复杂性可以更容易地抽象成一个库。</p><h1 id="d82b" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">箭头中的Typeclasses示例</h1><p id="cc56" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">已经了解了两种语言中Typeclass模式的本质，让我们来看一个来自Arrow源代码的实际例子。我们可以从我们的第一篇文章中获取<em class="kv">遍历</em>操作符<a class="ae kp" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4">，并尝试理解它是如何工作的。</a></p><p id="851b" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这是我们遇到的第一个声明(包名简化):</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="35bb" class="lh iu hh ld b fi li lj l lk ll">fun &lt;G, A, B&gt; List&lt;A&gt;.traverse(<br/>    arg1: Applicative&lt;G&gt;, <br/>    arg2: Function1&lt;A, Kind&lt;G, B&gt;&gt;): Kind&lt;G,Kind&lt;ForListK, B&gt;&gt; = </span><span id="516c" class="lh iu hh ld b fi md lj l lk ll">  arrow.<strong class="ld hi">[omitted]</strong>.List.traverse().<em class="kv">run </em>{<strong class="ld hi"><br/>    </strong>arrow.<strong class="ld hi">[omitted]</strong>.ListK(this@traverse)<br/>                   .<em class="kv">traverse</em>&lt;G, A, B&gt;(arg1, arg2) <br/>                        as Kind&lt;G,Kind&lt;ForListK, B&gt;&gt;<br/>  }</span></pre><p id="b0f5" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们知道，<em class="kv">遍历</em>的第一个参数是一个<em class="kv">适用的</em>，第二个是一个函数。<em class="kv">应用</em>的类型参数对应函数返回的类型。</p><p id="415c" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">从之前的文章中我们还知道，<em class="kv">类</em>类型在Kotlin中被用来模拟更高级的类型。所以当我们看到<code class="du lm ln lo ld b">Kind&lt;G, B&gt;</code>时，我们知道G是容器类型，B是内容。在函数返回一个<code class="du lm ln lo ld b">Option&lt;Person&gt;</code>的情况下，G就是<code class="du lm ln lo ld b">Option</code>，B就是<code class="du lm ln lo ld b">Person</code>。</p><p id="c2c8" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">Typeclass功能从调用<code class="du lm ln lo ld b">List.traverse()</code>开始。如果我们深入下去，我们会看到这个函数总是返回一个<code class="du lm ln lo ld b">ListKTraverse</code>的实例。</p><p id="24e9" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这个类型为列表声明了一组扩展函数:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="1383" class="lh iu hh ld b fi li lj l lk ll">interface ListKTraverse : Traverse&lt;ForListK&gt; {<br/><br/>  override fun &lt;G, A, B&gt; Kind&lt;ForListK, A&gt;.traverse(<br/>    AP: Applicative&lt;G&gt;, <br/>    f: (A) -&gt; Kind&lt;G, B&gt;): Kind&lt;G, ListK&lt;B&gt;&gt; = <em class="kv">fix</em>().traverse(AP, f)<br/><br/>  <strong class="ld hi">//other declarations omitted</strong><br/>}</span></pre><p id="09d4" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">针对这种类型的实例调用了<em class="kv"> run </em>实用函数，该实例又被传递给新创建的<code class="du lm ln lo ld b">ListK</code>实例。正是在这里，我们最终找到了遍历的实现:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="4067" class="lh iu hh ld b fi li lj l lk ll">fun &lt;G, B&gt; traverse(<br/>    GA: Applicative&lt;G&gt;, <br/>    f: (A) -&gt; Kind&lt;G, B&gt;): Kind&lt;G, ListK&lt;B&gt;&gt; =</span><span id="d815" class="lh iu hh ld b fi md lj l lk ll">    foldRight(Eval.now(GA.just(<em class="kv">emptyList</em>&lt;B&gt;().<em class="kv">k</em>()))) { a, eval -&gt;<br/>        GA.<em class="kv">run </em>{ <br/>            f(a).<em class="kv">apEval</em>(eval.map { <br/>                it.<em class="kv">map </em>{ xs -&gt; { a: B -&gt; (<em class="kv">listOf</em>(a) + xs).<em class="kv">k</em>() } } <br/>            }) <br/>        }<br/>    }.value()</span></pre><p id="f203" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这肯定是一个很大的管道让我们的头转来转去。但是如果我们后退一步，整体结构与我们最初的(简单的)例子相似，只是增加了一个额外的扩展方法来避免客户端代码调用<em class="kv"> run </em>。</p><h1 id="7334" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">用箭头组合我们自己的类型类</h1><p id="b4e1" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">为了巩固我们到目前为止所学的知识，让我们从HKT的文章中拿一个竞赛的例子，并将其扩展到使用一个类型类。</p><p id="b323" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">正如我们所知，第一步是定义一个接口:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7e5a" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们声明两个扩展函数，<em class="kv">判断公平</em>和<em class="kv">判断不公平</em>。因为我们希望它们适用于任何带有两个类型参数的类型，所以我们使用<em class="kv"> Kind2 </em>类型来模拟一个更高级的Kind类型。</p><p id="824a" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">下一步是声明一些箭头类型的实现:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="3fd3" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">完成这些后，我们可以对一些示例对象运行我们的扩展函数:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ea89" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这给了我们预期的输出:</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="cbb6" class="lh iu hh ld b fi li lj l lk ll">winner<br/>loser<br/>loser<br/>winner<br/>winner<br/>loser<br/>loser</span></pre><h1 id="22d8" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">类型类和表达式问题</h1><p id="4bfe" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们已经看到，Typeclasses提供了一种在现有类型上“添加”额外功能的方法。因此，类型类是表达式问题的一种可能的解决方案。这个问题源于以下观察结果:</p><ul class=""><li id="3aa6" class="lp lq hh jt b ju kq jy kr kc lr kg ls kk lt ko lu lv lw lx bi translated">面向对象的语言使得扩展现有的类型层次变得容易。他们通过子类化和(常规)多态来实现这一点。</li><li id="a653" class="lp lq hh jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">函数式语言使得向现有的一组类型添加额外的操作变得容易。它们通过模式匹配来实现这一点，即优雅而有效地切换参数的实际类型。</li><li id="0f7f" class="lp lq hh jt b ju ly jy lz kc ma kg mb kk mc ko lu lv lw lx bi translated">没有一种方法可以两全其美。OO不能很好地处理向已建立的接口添加新操作的问题。FP不能处理将新类型添加到已建立的层次结构中。</li></ul><p id="ccb4" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">Typeclasses代表了一个中间地带，我们可以用最少的重构来扩展层次和操作。当然，如果接口是稳定的，那么额外的努力就是开销。所以，就像大多数“A或B”问题一样，我们发现常规类和类型类都更好。</p><h1 id="e020" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="898f" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">Typeclasses为我们提供了关联函数和数据的另一种方法。它们提供了普通课程的许多优点，但也允许我们有选择地包含我们需要的内容。当我们增强现有类型，或者需要在实现之间切换时，这是非常好的。Kotlin和Scala都提供了足够的功能来构造作为“二等公民”的类型类，但是这项工作更适合库作者。</p><h1 id="62ef" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">谢谢</h1><p id="d31e" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">感谢<a class="ae kp" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kp" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。所有的错误当然是我自己的。</p></div></div>    
</body>
</html>