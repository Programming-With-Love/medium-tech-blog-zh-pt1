<html>
<head>
<title>Purescript II: Typeclasses and Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Purescript II:类型类和单子</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/purescript-ii-typeclasses-and-monads-6d7b1e085627?source=collection_archive---------0-----------------------#2018-12-03">https://medium.com/quick-code/purescript-ii-typeclasses-and-monads-6d7b1e085627?source=collection_archive---------0-----------------------#2018-12-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/8215aaf3b71fb436b16f39ae69f0f9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*3lryw9JGBL1M1Q9IhR4wsg.png"/></div></figure><p id="bdf0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上周，我们开始探索Purescript。Purescript试图将Haskell的一些神奇之处带到web开发的世界中。它的语法看起来很像Haskell，但是它编译成Javascript。这使得它非常容易用于web应用程序。它不仅仅看起来像哈斯克尔。它使用了该语言的许多重要特性，比如强大的系统和功能的纯洁性。</p><p id="d800" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您需要重温Purescript的基础知识，请务必再次阅读第一篇文章。本周，我们将探索Purescript有所不同的几个其他领域。我们将看到Purescript是如何处理类型类的，我们还将看到一元代码。我们还将快速看一下操作符的其他一些小细节。下周，我们将看看如何使用Purescript编写一些前端代码。</p><p id="db58" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">关于功能web开发的另一个观点，请查看我们的<a class="ae jj" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>。您也可以下载我们的<a class="ae jj" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>以获得更多创意！你也可以看看我们的<a class="ae jj" href="https://www.mmhaskell.com/elm" rel="noopener ugc nofollow" target="_blank"> Elm系列</a>寻找另一个前端语言选项！</p><h1 id="2384" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">类型类别</h1><p id="c880" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">从Haskell到Purescript，类型类的概念仍然非常一致。但是仍然有一些问题。让我们记住上周的<code class="du kn ko kp kq b">Triple</code>类型。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="2941" class="kz jl hh kq b fi la lb l lc ld">data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  }</span></pre><p id="e4f2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们为它编写一个简单的<code class="du kn ko kp kq b">Eq</code>实例。首先，Purescript <strong class="in hi">中的实例必须有名字</strong>。所以我们将把名字<code class="du kn ko kp kq b">tripleEq</code>分配给我们的实例:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="3338" class="kz jl hh kq b fi la lb l lc ld">instance tripleEq :: Eq Triple where<br/>  eq (Triple t1) (Triple t2) = t1 == t2</span></pre><p id="e648" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">同样，我们只为我们的类型打开一个字段。这对应于记录，而不是单个字段。事实上，我们可以互相比较记录。我们提供的名称有助于Purescript生成可读性更好的Javascript。注意:命名我们的实例不允许我们拥有相同类型和类的多个实例。如果我们试图创建另一个实例，我们会得到一个编译错误，如下所示:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="e954" class="kz jl hh kq b fi la lb l lc ld">instance otherTripleEq :: Eq Triple where<br/>  ...</span></pre><p id="97e6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当对类使用显式导入时，还有另一个小变化。我们必须在导入列表中使用<code class="du kn ko kp kq b">class</code>关键字:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="01ff" class="kz jl hh kq b fi la lb l lc ld">import Data.Eq (class Eq)</span></pre><p id="28aa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可能希望我们可以为我们的<code class="du kn ko kp kq b">Triple</code>类型派生出<code class="du kn ko kp kq b">Eq</code>类型类，我们可以做到。因为我们的实例需要一个名字，所以普通的Haskell语法不起作用。以下操作将失败:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="48b2" class="kz jl hh kq b fi la lb l lc ld">-- DOES NOT WORK<br/>data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  } deriving (Eq)</span></pre><p id="857f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是对于简单的类型类，我们可以使用独立派生。这允许我们为实例提供一个名称:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="f125" class="kz jl hh kq b fi la lb l lc ld">derive instance eqTriple :: Eq Triple</span></pre><p id="bb93" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后一点，Purescript不允许孤儿实例。孤立实例是指在不同于类型定义和类定义的文件中定义typeclass实例。在Haskell中你可以逃脱这些，尽管GHC会警告你。但是Purescript不那么宽容。解决这个问题的方法是围绕你的类型定义一个新的类型包装器。然后，您可以在该包装器上定义实例。</p><h1 id="1800" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">效果</h1><p id="dc53" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">在第1部分中，我们看了一小段一元代码。看起来像是:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="d94d" class="kz jl hh kq b fi la lb l lc ld">main :: Effect Unit<br/>main = do<br/>  log ("The answer is " &lt;&gt; show answer)</span></pre><p id="3c3c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们试图与Haskell进行比较，似乎<code class="du kn ko kp kq b">Effect</code>是与<code class="du kn ko kp kq b">IO</code>相当的单子。事实也的确如此。但是比这要复杂一点。在Purescript中，我们可以使用<code class="du kn ko kp kq b">Effect</code>来表示“原生”效果。在我们深入了解这意味着什么以及如何做到这一点之前，让我们先来考虑一下“非本土”效应。</p><p id="f717" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">非原生效果是指那些像<code class="du kn ko kp kq b">Maybe</code>或<code class="du kn ko kp kq b">List</code>一样可以独立存在的单子。事实上，在本系列的第1部分中我们有一个<code class="du kn ko kp kq b">List</code>单子的例子。下面是<code class="du kn ko kp kq b">Maybe</code>可能的样子。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="68ac" class="kz jl hh kq b fi la lb l lc ld">maybeFunc :: Int -&gt; Maybe Int</span><span id="b7ca" class="kz jl hh kq b fi le lb l lc ld">mightFail :: Int -&gt; Maybe Int<br/>mightFail x = do<br/>  y &lt;- maybeFunc x<br/>  z &lt;- maybeFunc y<br/>  maybeFunc z</span></pre><p id="b538" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">原生效果使用<code class="du kn ko kp kq b">Effect</code>单子。这些包括很多我们传统上在Haskell中与<code class="du kn ko kp kq b">IO</code>联系在一起的东西。例如，随机数生成和控制台输出使用<code class="du kn ko kp kq b">Effect</code>单子:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="0be2" class="kz jl hh kq b fi la lb l lc ld">randomInt :: Int -&gt; Int -&gt; Effect Int</span><span id="7fb9" class="kz jl hh kq b fi le lb l lc ld">log :: String -&gt; Effect Unit</span></pre><p id="ffa7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是还有其他与web开发相关的“原生效应”。其中最重要的是在我们的Javascript应用程序中写入DOM的任何东西。下周，我们将使用<code class="du kn ko kp kq b">purescript-react</code>库创建一个基本的网页。它的大部分主要功能都在<code class="du kn ko kp kq b">Effect</code>单子里。同样，我们可以想象这种效果会在Haskell中使用<code class="du kn ko kp kq b">IO</code>。所以如果你想把Purescript的<code class="du kn ko kp kq b">Effect</code>看作是<code class="du kn ko kp kq b">IO</code>的一个类似物，这是一个不错的起点。</p><p id="fc80" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有趣的是，Purescript过去更多的是基于自由单子的系统。每一种不同类型的自然效果都建立在先前效果的基础上。最酷的是Purescript使用自己的记录语法来跟踪播放中的效果。你可以在Purescript书的第8章中读到更多关于这如何工作的内容。然而，在我们的例子中，我们不需要它。我们可以坚持使用<code class="du kn ko kp kq b">Effect</code>。</p><p id="ba21" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">除了免费的单子，Purescript还有<code class="du kn ko kp kq b">purescript-transformers</code>库。如果您更熟悉Haskell，这可能是一个更好的起点。它允许您使用MTL风格的方法，这种方法在Haskell中比自由单子更常见。</p><h1 id="7062" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">特殊操作员</h1><p id="97e9" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">值得注意的是其他一些小差异。Haskell和Purescript之间关于操作符的一些规则略有不同。由于Purescript使用句点操作符<code class="du kn ko kp kq b">.</code>进行记录访问，它不再引用函数组合。相反，我们将使用<code class="du kn ko kp kq b">&lt;&lt;&lt;</code>data-preserve-html-node = " true "操作符:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="0489" class="kz jl hh kq b fi la lb l lc ld">odds :: List Int -&gt; List Int<br/>odds myList = filter (not &lt;&lt;&lt; isEven) myList<br/>  where<br/>    isEven :: Int -&gt; Boolean<br/>    isEven x = mod x 2 == 0</span></pre><p id="84b0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">此外，我们不能以中缀的方式定义运算符。我们必须首先为它们定义一个正常的名称。以下将不起作用:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="4527" class="kz jl hh kq b fi la lb l lc ld">(=%=) :: Int -&gt; Int -&gt; Int<br/>(=%=) a b = 2 * a - b</span></pre><p id="bd86" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">相反，我们需要定义一个像<code class="du kn ko kp kq b">addTwiceAndSubtract</code>这样的名字。然后我们可以告诉Purescript将它作为中缀运算符应用:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="d27d" class="kz jl hh kq b fi la lb l lc ld">addTwiceAndSubtract :: Int -&gt; Int -&gt; Int<br/>addTwiceAndSubtract a b = 2 * a - b</span><span id="91be" class="kz jl hh kq b fi le lb l lc ld">infixrl 6 addTwiceAndSubtract as =%=</span></pre><p id="d64e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，使用运算符作为部分函数看起来有点不同。这在Haskell中有效，但在Purescript中无效:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="3ea1" class="kz jl hh kq b fi la lb l lc ld">doubleAll :: List Int -&gt; List Int<br/>doubleAll myList = map (* 2) myList</span></pre><p id="6c50" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">相反，我们需要这样的语法:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="983d" class="kz jl hh kq b fi la lb l lc ld">doubleAll :: List Int -&gt; List Int<br/>doubleAll myList = map (_ * 2) myList</span></pre><h1 id="05cc" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="9283" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">这总结了我们对Haskell和Purescript之间的关键区别的看法。现在我们已经了解了类型类和单子，是时候深入了解Purescript最擅长什么了。下周回来，我们将看看如何用Purescript编写真正的前端代码！</p><p id="40e2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">想了解更多关于使用Haskell实现一些很酷的功能的想法，请下载我们的<a class="ae jj" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>！对于函数前端开发的另一个视角，请查看我们最近的<a class="ae jj" href="https://www.mmhaskell.com/elm" rel="noopener ugc nofollow" target="_blank"> Elm系列</a>！</p></div></div>    
</body>
</html>