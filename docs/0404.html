<html>
<head>
<title>Patterns for accessing code from Dynamic Feature Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从动态特性模块访问代码的模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/patterns-for-accessing-code-from-dynamic-feature-modules-7e5dca6f9123?source=collection_archive---------3-----------------------#2019-06-04">https://medium.com/androiddevelopers/patterns-for-accessing-code-from-dynamic-feature-modules-7e5dca6f9123?source=collection_archive---------3-----------------------#2019-06-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="943e" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi">更新</strong>:删除了使用ServiceLoader的内容，因为R8不再支持将它用于动态特性，并且由于性能问题，不建议在没有R8优化的情况下使用它。</p></blockquote><p id="fd64" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在这篇文章中，我将向你展示如何解决在你的项目中使用动态特性模块时出现的一个常见问题:在编译期间，你的基本应用程序无法访问它们内部定义的代码…除非你使用反射😱。</p><p id="f7fc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">仅仅提到反射就足以吓跑一些开发人员，但是有几个优雅的解决方案可以安全地访问您需要的东西，最多使用一个反射调用…以及一个聪明的优化技术来将这个数字降到零！</p><p id="23e6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">继续阅读，了解你可以采取的两种不同的方法:简单反射，以及它如何在一个示例模块化应用程序中与Dagger2一起工作，可在<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="4120" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么是动态功能模块？</h1><p id="f84f" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">去年，我们推出了Android应用捆绑包和Google Play的动态交付，以帮助开发人员减少应用大小并简化发布流程。了解更多关于<a class="ae jj" href="https://developer.android.com/guide/app-bundle/" rel="noopener ugc nofollow" target="_blank">应用捆绑包</a>的优势。</p><p id="fb8e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">但改用应用捆绑包只是第一步。新的格式为模块化您的代码库提供了新的可能性，从而为用户提供更加定制化的体验。</p><p id="a253" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在Google I/O 2019上，我们<a class="ae jj" href="https://android-developers.googleblog.com/2019/05/whats-new-in-play.html" rel="noopener ugc nofollow" target="_blank">宣布</a>按需和<a class="ae jj" href="https://developer.android.com/studio/preview/features#conditional-delivery" rel="noopener ugc nofollow" target="_blank">有条件</a>模块的<a class="ae jj" href="https://developer.android.com/studio/projects/dynamic-delivery/on-demand-delivery" rel="noopener ugc nofollow" target="_blank">全面上市，让你决定何时安装应用的某些部分。</a></p><p id="8b1a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">对于按需模块，当用户导航到你的应用程序中的一个可选功能时，你使用Play Core API来安装新的代码和资源；对于条件模块，它们的可用性将在安装时由用户的设备配置决定，例如硬件和软件功能、用户的国家或Android OS版本。</p><p id="8578" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">这些新的、可定制的模块类型的共同点是，它们都使用<code class="du kn ko kp kq b">com.android.dynamic-feature</code> Gradle插件。我们将称它们为<strong class="ik hi">动态特征模块</strong>，或<strong class="ik hi"> DFMs </strong>。当您将应用作为Android应用捆绑包分发时，Play Store会在适当的时候将这些模块作为单独的apk发送到用户的设备。</p><h1 id="3645" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">从库到动态功能模块</h1><p id="ffae" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">将一些库模块迁移到DFM需要对项目结构进行重要的改变，也就是反转基本特性和任何动态特性之间的依赖关系。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/c1047a95d66a28e03384249005572638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*stlGOM45FGjBLZXy"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">Dynamic feature modules (top) depend on base application. Application depends on regular libraries.</figcaption></figure><p id="d538" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在使用库的标准项目结构中，基<code class="du kn ko kp kq b">com.android.application</code>模块<strong class="ik hi">依赖于</strong> <code class="du kn ko kp kq b">com.android.library</code>模块，这意味着你可以自由使用基模块库中定义的任何类。</p><p id="e42e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">然而，对于DFM，基本<code class="du kn ko kp kq b">com.android.application </code> <strong class="ik hi">是对</strong> <code class="du kn ko kp kq b">com.android.dynamic-feature</code>模块的依赖，这意味着你可以在DFM中使用基本模块及其库中定义的任何类，但是<strong class="ik hi">你不能在编译时从基本应用程序引用DFM中定义的任何代码</strong>。</p><p id="d341" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">一旦DFM生成的apk安装到您的应用程序中(不管交付机制:安装时、按需或有条件)，它们的代码在运行时就可供类加载器使用。</p><blockquote class="ie if ig"><p id="ef61" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">当您拥有点播模块时，请记住始终使用Play Core库中的<a class="ae jj" href="https://developer.android.com/guide/app-bundle/playcore#access_downloaded_modules" rel="noopener ugc nofollow" target="_blank"> SplitCompat </a>。</p></blockquote><p id="ac97" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">根据您的使用情况，这个问题有几个显而易见的解决方案。如果您需要从DFM获得的只是启动一个活动，您可以简单地传递它的名称(作为一个<code class="du kn ko kp kq b">String</code>；您不能使用<code class="du kn ko kp kq b">.class</code>符号，因为该类在编译时不可访问)到<code class="du kn ko kp kq b">startActivity</code>:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4192" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">这是我们在<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-features" rel="noopener ugc nofollow" target="_blank">动态特征示例</a>中使用的方法。如果你想了解如何使用Play Core库安装点播模块，也可以去看看。</p><div class="lj lk ez fb ll lm"><a href="https://github.com/googlesamples/android-dynamic-features" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">Google samples/Android-动态-功能</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">通过在GitHub上创建一个帐户，为Google samples/Android-dynamic-features开发做出贡献。</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma lb lm"/></div></div></a></div><p id="336d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在接下来的部分中，我将向您展示如何从DFM加载一个定制类(在它被安装之后)并在基本模块中访问它。您可以在<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading" rel="noopener ugc nofollow" target="_blank">动态代码加载示例</a>中找到本文所用示例的完整代码。</p><div class="lj lk ez fb ll lm"><a href="https://github.com/googlesamples/android-dynamic-code-loading" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">Google samples/Android-动态代码加载</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">动态功能模块的Android动态代码加载示例。-Google samples/Android-动态代码加载</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="mb l lx ly lz lv ma lb lm"/></div></div></a></div><h1 id="9441" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">项目设置</h1><p id="e92f" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">在我们将要看到的示例代码中，应用程序包含一个简单的计数器，用户可以通过按一个按钮来递增。每次重新启动应用程序时，计数器都会重置，除非用户安装了一个按需模块，其中包含让应用程序将计数器状态保存到存储中的代码。</p><p id="c468" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">当然，这不是你在真正的应用程序中会做的事情，但它给了我们一个简化的工作场景，你可以适应自己的动态加载代码。</p><p id="2570" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">示例代码的组织方式是在主源代码集中找到共同的部分，但是每种动态访问代码的方法都是以自己的变体实现的。</p><p id="5b62" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">基本模块“app”包含这些共享类:</p><ul class=""><li id="623f" class="mc md hh ik b il im ip iq jg me jh mf ji mg jf mh mi mj mk bi translated"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/main/java/com/google/android/samples/dynamiccodeloading/MainActivity.kt" rel="noopener ugc nofollow" target="_blank"> MainActivity </a>包含UI、</li><li id="e946" class="mc md hh ik b il ml ip mm jg mn jh mo ji mp jf mh mi mj mk bi translated"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/main/java/com/google/android/samples/dynamiccodeloading/AbstractMainViewModel.kt" rel="noopener ugc nofollow" target="_blank"> AbstractMainViewModel </a>包含逻辑，但是需要在每个构建变体中被子类化以提供<code class="du kn ko kp kq b">abstract fun initializeStorageFeature()</code></li></ul><p id="106f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">您可以使用Android Studio中的构建变体切换器在这两种方法之间切换:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es mq"><img src="../Images/1a38bfd4ad6bcc54c131058f3f053962.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*AmWH9xp370lxeHG8"/></div></figure><p id="62d3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><code class="du kn ko kp kq b">storage</code>模块是为按需交付而配置的动态特征模块。在本文中，我们将讨论如何从基本的<code class="du kn ko kp kq b">app</code>模块中访问位于<code class="du kn ko kp kq b">storage</code>模块中的类。</p><h1 id="91fc" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">从实现中分离出接口</h1><p id="6a25" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">首先，我们需要为我们的动态特性代码创建一个接口。我们在<code class="du kn ko kp kq b">app</code>模块中定义了它，这样它就可以用来直接调用特性实现的任何函数。</p><p id="c08a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">我的存储特性的接口很简单:它需要能够存储和检索一个整数。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="94e9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">因为我们将该接口的实现留在DFM模块中定义，所以实现者可以自由选择他们的构造函数是什么样子。我们的存储特性将需要一个<code class="du kn ko kp kq b">Context</code>，甚至可能请求一些其他的依赖项(比如一个<code class="du kn ko kp kq b">Logger</code>)，实现可能如下所示:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="42d3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">为了使获取这个具体的<code class="du kn ko kp kq b">StorageFeature</code>实现的实例变得简单，并将实例化留给实现者，我们还将使用单个<code class="du kn ko kp kq b">get()</code>方法定义一个存储特性<code class="du kn ko kp kq b">Provider</code>接口，在给定必要的依赖关系的情况下，该方法将返回一个准备使用的<code class="du kn ko kp kq b">StorageFeature</code>:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="fb5e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">同样，我们将把接口放在基本模块中，而DFM将包含实现。</p><p id="e7e2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">您可以在这里查看接口定义<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/main/java/com/google/android/samples/dynamiccodeloading/StorageFeature.kt" rel="noopener ugc nofollow" target="_blank">，有一点小小的不同:我使用了另一个接口来保存特性的<code class="du kn ko kp kq b"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/main/java/com/google/android/samples/dynamiccodeloading/StorageFeature.kt#L43" rel="noopener ugc nofollow" target="_blank">Dependencies</a></code>，这将对我稍后的Dagger设置有用，但在其他情况下并不真正需要。</a></p></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><h1 id="90e1" class="jk jl hh bd jm jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh bi translated">方法1:直接反射调用</h1><p id="0b30" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">在我们的基础应用程序模块中获得<code class="du kn ko kp kq b">StorageFeature</code>实例的最直接的方法是一个反射调用。如果您在阅读本文时正在检查示例，请切换到<code class="du kn ko kp kq b">reflectDebug</code>构建变体。</p><p id="75a8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">看看<code class="du kn ko kp kq b">reflect</code>源集中的第一个<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/reflect/java/com/google/android/samples/dynamiccodeloading/MainViewModel.kt" rel="noopener ugc nofollow" target="_blank"> MainViewModel实现</a>:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0f8d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">注意，我使用标准的<code class="du kn ko kp kq b">Class.forName()</code>来获得<code class="du kn ko kp kq b">Provider</code>的类句柄，但是Kotlin给了我们一个非常好的方法来获得它的单例实例——object instance。这是因为我的<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/storage/src/reflect/java/com/google/android/samples/storage/StorageFeatureImpl.kt#L43" rel="noopener ugc nofollow" target="_blank">提供者被声明为kot Lin</a>T10:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="7658" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">如果你没有使用Kotlin或者不想使用<code class="du kn ko kp kq b">object</code>，你可以回复到常规的<code class="du kn ko kp kq b"><a class="ae jj" href="https://developer.android.com/reference/java/lang/Class.html#newInstance()" rel="noopener ugc nofollow" target="_blank">Class#newInstance(</a>)</code>呼叫。</p><p id="3756" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">一旦有了对<code class="du kn ko kp kq b">Provider</code>的引用，就不再需要任何反射调用，只需调用<code class="du kn ko kp kq b">get()</code>，继续通过<code class="du kn ko kp kq b">StorageFeature</code>接口调用特性代码，具有编译时安全性。</p><h1 id="7a48" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">与Dagger2集成</h1><p id="f954" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">还可以与Dagger 2集成，帮助在DFM端实例化对象图。在<code class="du kn ko kp kq b">daggerDebug</code>构建版本中检查它。</p><p id="12fd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">到目前为止，我们已经处理了一个非常简单的情况，其中功能代码只需要一个<code class="du kn ko kp kq b">Context</code>，然后就能够创建并返回一个<code class="du kn ko kp kq b">StorageFeature</code>对象。</p><p id="f7ed" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">实际上，您的依赖项可能要复杂得多，使用依赖项注入框架(如Dagger2)可以帮助您确保正确的依赖项被实例化并传递给DFM。</p><p id="47dc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">由于Gradle模块依赖关系的设置方式，我们不能在DFM中使用基础Dagger组件的子组件。然而，我们可以使用另一种叫做<a class="ae jj" href="https://dagger.dev/api/latest/dagger/Component.html#dependencies--" rel="noopener ugc nofollow" target="_blank">组件依赖</a>的机制来从父组件获得所需的依赖。您在<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L32" rel="noopener ugc nofollow" target="_blank">特征组件</a>中声明依赖关系:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="20bc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">我们将使用<code class="du kn ko kp kq b"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/storage/src/dagger/java/com/google/android/samples/storage/StorageFeatureImpl.kt#L48" rel="noopener ugc nofollow" target="_blank">StorageFeature.Provider</a></code>实现来实例化特性组件并返回<code class="du kn ko kp kq b">StorageFeature</code>:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="1908" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">剩下的就是传递所需依赖项的方法。因为我们希望Dagger也能做到这一点，所以我们实际上可以让我们的<a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L33" rel="noopener ugc nofollow" target="_blank">基础组件实现</a> <code class="du kn ko kp kq b"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L33" rel="noopener ugc nofollow" target="_blank">Dependencies</a></code> <a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L33" rel="noopener ugc nofollow" target="_blank">接口</a>:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="b55a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">现在每当你试图编译你的应用程序，Dagger会告诉你是否有任何依赖项丢失。例如，我确保基础组件绑定了一个<code class="du kn ko kp kq b">Logger</code>对象，这样它就可以将它作为<code class="du kn ko kp kq b">StorageFeature.Dependencies</code>的一部分传递给特性组件</p><p id="801c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">最后，我们在基础模块中有一个自定义的<code class="du kn ko kp kq b"><a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L54" rel="noopener ugc nofollow" target="_blank">@Provides</a></code> <a class="ae jj" href="https://github.com/googlesamples/android-dynamic-code-loading/blob/master/app/src/dagger/java/com/google/android/samples/dynamiccodeloading/di/BaseDagger.kt#L54" rel="noopener ugc nofollow" target="_blank">方法</a>，它将负责通过反射获取<code class="du kn ko kp kq b">StorageFeature.Provider</code>，传入所需的依赖项并缓存结果:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="b4d2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">这当然是让Dagger与你的应用程序中的动态特性模块一起工作的一种方式，但是这很大程度上取决于你当前的Dagger设置。您可以随意从这个示例中获取想法，或者使用适合您当前架构的任何内容。</p><p id="109c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">例如，您可以尝试在注入位置使用<code class="du kn ko kp kq b"><a class="ae jj" href="https://dagger.dev/api/2.0/dagger/Lazy.html" rel="noopener ugc nofollow" target="_blank">dagger.Lazy</a>&lt;StorageFeature&gt;</code>，而不是在模块中缓存结果。</p><blockquote class="ie if ig"><p id="84a4" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi"> <em class="hh">无论您选择哪种方法，您都必须确保仅在DFM APK安装到您的应用程序后实例化StorageFeature对象图。</em>T15】</strong></p><p id="fcc8" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi"> <em class="hh">如果您的DFM是有条件或按需交付的，记得先用</em> </strong> <code class="du kn ko kp kq b"><a class="ae jj" href="https://developer.android.com/guide/app-bundle/playcore#manage_installed_modules" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="hh">SplitInstallManager.installedModules</em></strong></a></code> <strong class="ik hi"> <em class="hh">确认。</em> </strong></p></blockquote><h1 id="1d7e" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">额外学习</h1><p id="aaf9" class="pw-post-body-paragraph ih ii hh ik b il ki in io ip kj ir is jg kk iv iw jh kl iz ja ji km jd je jf ha bi translated">模块化是一个非常广泛的话题，它的含义远不止简单的类加载，比如应用程序的整体架构，甚至最终用户将看到的最终UX。在本文中，我重点解决了一个特定的问题:通过反射从DFM加载代码。</p><p id="516b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">如果你想了解更多关于应用模块化和寻找合适架构的知识，看看<a class="nd ne ge" href="https://medium.com/u/4ee17deb0f17?source=post_page-----7e5dca6f9123--------------------------------" rel="noopener" target="_blank">伊吉特·博雅</a>和<a class="nd ne ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----7e5dca6f9123--------------------------------" rel="noopener" target="_blank">弗洛里纳·芒特内斯库</a>在谷歌I/O’19上的演讲:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="nf li l"/></div></figure><p id="7ce8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">您还可以在一个真实的应用程序中应用与本文中描述的技术类似的技术时，查看所做的代码更改:</p><div class="lj lk ez fb ll lm"><a href="https://github.com/android/plaid/pull/680" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">通过florina-muntenescu拉取请求#680在不同的模块中分割数据源进行搜索…</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">📢类型更改错误修复新功能增强重构📜描述中断数据源。现在每个模块…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="ng l lx ly lz lv ma lb lm"/></div></div></a></div><p id="55ba" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">此外，<a class="nd ne ge" href="https://medium.com/u/65fe4f480b1c?source=post_page-----7e5dca6f9123--------------------------------" rel="noopener" target="_blank"> Ben Weiss </a>不久前发表了一篇更一般的文章，是关于模块化格子的案例研究:</p><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/androiddevelopers/a-patchwork-plaid-monolith-to-modularized-app-60235d9f212e"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">拼布格子——从整体到模块化应用</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">我们如何和为什么模块化格子布和未来</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="nh l lx ly lz lv ma lb lm"/></div></div></a></div><p id="1485" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">本文所基于的动态代码加载示例使用了<a class="ae jj" href="https://developer.android.com/guide/app-bundle/playcore" rel="noopener ugc nofollow" target="_blank"> Play核心库</a>。为了从Play中启用按需模块交付，您应该熟悉API并按照链接的文档页面中的说明正确地实现它。</p><p id="f1ca" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">记得订阅我们的<a class="ae jj" href="https://medium.com/androiddevelopers" rel="noopener"> Android开发者出版物</a>，了解更多关于Android、Play、Kotlin等的故事！</p><div class="lj lk ez fb ll lm"><a href="https://medium.com/androiddevelopers" rel="noopener follow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">安卓开发者</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">Android开发者在Medium上的官方出版物</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="ni l lx ly lz lv ma lb lm"/></div></div></a></div></div></div>    
</body>
</html>