<html>
<head>
<title>Docker Containerisation world (Basics) Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头集装箱化世界(基础)第1部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/docker-containerisation-world-basics-part-1-f5abc0b7390b?source=collection_archive---------0-----------------------#2022-05-17">https://medium.com/globant/docker-containerisation-world-basics-part-1-f5abc0b7390b?source=collection_archive---------0-----------------------#2022-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/61f74b35506a134de5bc5349737af350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZLrVlMV9_yCf4_TK2sAAQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Docker Containerisation</figcaption></figure><h1 id="df76" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是Docker</h1><p id="576d" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">Docker是一个围绕创建和运行容器的平台或生态系统。它使安装和运行软件变得简单，而不用担心安装或依赖性。</p><p id="6862" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">它是一个允许用户在容器中轻松打包、分发和管理应用程序的平台。换句话说，它是一个开源项目，可以在软件容器中自动部署应用程序。</p><p id="3e2a" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">Docker通过使用容器使创建、部署和运行应用程序变得更加容易。容器允许开发人员将应用程序与它需要的所有部分打包在一起，比如库和其他依赖项，然后作为一个包发送出去。通过这样做，开发人员可以确信应用程序可以在任何其他Linux机器上运行。</p><blockquote class="ku kv kw"><p id="faf3" class="jr js kx jt b ju kp jw jx jy kq ka kb ky kr ke kf kz ks ki kj la kt km kn ko ha bi translated"><strong class="jt hi">要继续使用docker，让我们在您的系统中安装Docker。一旦你成功安装了docker，然后在你的终端上运行命令</strong> <code class="du lb lc ld le b">docker version</code> <strong class="jt hi">来验证你系统中的docker。</strong></p></blockquote><h1 id="2d5e" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">码头内</h1><p id="e2c7" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">Docker包带有两个工具，即Docker客户端和Docker服务器。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/85d6a9ec41c56de5f77281772ccc2b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*nKMc0PnR5maQLds46q9t-w.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Docker Ecosystem</figcaption></figure><p id="5a73" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">Docker客户端:Docker客户端也称为Docker CLI，它发出命令与另一个名为Docker服务器工具进行交互。这发生在幕后。</p><p id="b144" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">Docker Server:</strong>Docker Server是负责创建图片、运行容器、上传图片等的第二个工具。我们永远不会到达Docker服务器，因为它在后台运行。我们只处理Docker CLI来运行命令。</p><h1 id="7df5" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">使用Docker客户端</h1><p id="0c0c" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">首先，在您的终端上运行该命令。命令是<code class="du lb lc ld le b">docker run hello-world</code>。一旦运行这个命令，您可能会注意到终端上打印的一些信息。参考下面的截图和命令。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/9232e90d6b65dbd4103f12de4534f5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yie3Oh-SAIU6Vl-6-HjqyA.png"/></div></div></figure><ul class=""><li id="4b5b" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">在上图中，您可以看到我们试图从docker hub安装hello-world映像。所以在这里你可以把图像看作软件。</li><li id="70b4" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">当您运行该命令时，我们得到的第一条语句是“无法在本地找到图像hello-world: latest”。</li><li id="18df" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">除了“码头工人你好！”。这是图像返回的默认消息，也可以说这是图像的输出。</li><li id="c81b" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">现在你可能会问这里发生了什么？。让我们进入它的幕后内部工作。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/30b2c1e8e2ac5bdae7901ab2465c1907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_BgtMRptTNwp6xjg-xEeQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">working of docker client</figcaption></figure><ul class=""><li id="225d" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">在上面的图像中，当我们对任何图像运行docker命令时，事情是如何在幕后运行的。</li><li id="9f44" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">在这里，我们已经安装了hello-world映像，一旦您在终端上点击它，docker客户端就会进入画面，它发出命令并与后台的Docker服务器进行交互。</li><li id="1a87" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">一旦docker服务器从Docker客户端获得请求，它将检查图像缓存下的图像。如果找到，docker服务器将从图像缓存中提取图像，否则它将在Docker hub或注册表中查找图像。</li><li id="dbd4" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">一旦图像缓存有了最初下载的图像的副本，下一次当我们对同一图像运行docker时，docker服务器将从图像缓存中提取图像。</li><li id="16a2" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">现在你第二次看不到“找不到图片hello-world: latest”的消息了，因为图片已经在你机器的图片缓存下了。</li></ul><h1 id="a6ea" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是容器(深入)</h1><p id="73ba" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">容器是一个程序，它有自己独立的一组硬件和资源。所以它可以有自己的内存空间，也可以有自己的硬盘空间。映像是一个文件，包含运行程序所需的所有依赖项和配置。容器是图像的实例。意思是它运行那个程序。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/5170fa8321318992b3c78ddfd3579118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PBfdywX59P-tOdAlcahC4A.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Flow of container</figcaption></figure><h1 id="1d29" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">图像与容器的关系</h1><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/49e57f0eb7bca30ef6080c68299637f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eh-9HIZhAiO5G72TSWz0FA.png"/></div></div></figure><ul class=""><li id="bf70" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">上图说明了我们在创建容器时使用的每个关键字的含义。让我们运行命令<code class="du lb lc ld le b">docker run hello-world</code> <strong class="jt hi">。</strong></li><li id="ddb4" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">让我们来理解当您运行上面的命令时，幕后到底发生了什么。</li><li id="71ff" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">映像只不过是一个文件系统，其中包含了我们需要在系统上安装的所有程序。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/f94ed112b6c2ee6b92d80e45dab3f140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0jQzLrzLj-FjEiScaMWVg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">before running the command</figcaption></figure><ul class=""><li id="cc34" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">在上图中，我们可以看到，在硬盘的某个地方，我们有映像，它有一个文件系统，其中有hello-world程序。</li><li id="6c69" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">当我们运行该命令时，我们获取了该文件系统的快照，并将其粘贴到容器的硬盘驱动器中。因为每个容器都是一个独立的进程，有自己的一组资源。</li><li id="6704" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">然后我们执行了命令<code class="du lb lc ld le b">run hello-world</code> <strong class="jt hi">。</strong>因此，运行的进程是hello-world，它通过在终端上给出输出来立即运行和退出。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/7f485129c09768466523be326da909bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o-Ht1YlalXq2-zdlhs3CQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">After running the command</figcaption></figure><h1 id="add8" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">容器的生命周期</h1><ul class=""><li id="b553" class="ll lm hh jt b ju jv jy jz kc me kg mf kk mg ko lq lr ls lt bi translated">到目前为止，我们已经看到了使用<code class="du lb lc ld le b">docker run </code>命令创建容器，但是我们也可以使用<code class="du lb lc ld le b">docker create</code>命令创建容器。那么这两个主题有什么区别呢？我们来了解一下。</li><li id="7188" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">当你使用<code class="du lb lc ld le b">docker create &lt;image-name&gt;</code>时，它将从提供的图片中创建一个容器，并给你一个启动它的id。比方说，我正在使用hello-world映像执行docker create命令。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/fe8772c4202b4de8e77478a40196a0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*LnEVB1FK4l-gY7qlHIs74Q.png"/></div></div></figure><ul class=""><li id="a408" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">您可以在上面的图像中看到，我们已经创建了集装箱，它在终端上有一个打印的集装箱id。使用这个id，我们可以启动容器。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/b7379eb580495e63ba369db038d7df58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQqdUWmlKKNFys-aFzT5kQ.png"/></div></div></figure><ul class=""><li id="2e59" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated"><code class="du lb lc ld le b">-a</code>该命令用于显示来自容器的输出。</li><li id="133e" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">这里我们必须使用两个命令来创建和运行容器。如果有一个命令可以单独完成这两项任务呢？于是<code class="du lb lc ld le b">docker run</code>来了<strong class="jt hi">。</strong></li><li id="3047" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated"><code class="du lb lc ld le b">docker run =&gt; docker create + docker start</code></li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/1420d9c6cddcd9e23b2d1ade3db88cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eRWElhJW_dH39QpZl1E7w.png"/></div></div></figure><ul class=""><li id="8f5c" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">在上面的图像中，您可以看到docker run命令正在创建容器、启动容器，并且如果系统上不存在的话，从docker存储库中提取图像。</li><li id="ecf9" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">我们可以用<code class="du lb lc ld le b">docker ps</code>命令列出正在运行的容器。还有一个命令<code class="du lb lc ld le b">docker ps -a</code>显示了创建和退出的容器。</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/8a10420ffd4dcd7983252e5f55a20089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYw0ljgJWCgvzmiLwLLalw.png"/></div></div></figure><ul class=""><li id="76bd" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">在上图中，您可以看到容器id、图像、命令、名称、状态、端口等标题。</li><li id="175b" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">我们可以使用运行<code class="du lb lc ld le b">docker ps -a</code>命令后显示的容器id再次启动创建的容器。</li><li id="6b6f" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated"><strong class="jt hi">命令头</strong>就是我们在创建容器时发出的命令。现在你可能对上图中的/ <code class="du lb lc ld le b">hello</code>命令有疑问。</li><li id="fcde" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">这是hello-world图像的默认命令。当我们运行docker run hello-world时，容器和默认的启动命令<code class="du lb lc ld le b">/hello</code> <strong class="jt hi">一起被创建。</strong></li><li id="b7e9" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">这些默认命令被添加到创建的容器的启动命令中。但是我们也可以在运行过程中为容器提供其他启动命令。让我们用下面的例子来理解。</li><li id="06c3" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">运行<code class="du lb lc ld le b">docker run busybox echo hi there</code> <strong class="jt hi">。</strong></li><li id="71a0" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">这里的busybox是docker hub存储库中的官方映像。</li><li id="a1eb" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">上面的命令是用echo hi作为启动命令执行的。该命令已经为<strong class="jt hi"> busybox映像预先编程。</strong></li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/50d4858fb028fa80cf09b98be479492a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*_gJajbOZNG-C-JjCR77Qyg.png"/></div></figure><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/f7624d78c90c8192a003b55d02e6638e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5HzqBv_-nN1JpugV0AetQ.png"/></div></div></figure><ul class=""><li id="455a" class="ll lm hh jt b ju kp jy kq kc ln kg lo kk lp ko lq lr ls lt bi translated">这是它在幕后的工作方式。它在映像busybox之外创建容器，并将映像的文件系统放在容器的硬盘驱动器中。并使用提供的启动命令<code class="du lb lc ld le b">echo hi there</code> <strong class="jt hi">启动容器。</strong></li><li id="3d72" class="ll lm hh jt b ju lu jy lv kc lw kg lx kk ly ko lq lr ls lt bi translated">我们可以用<code class="du lb lc ld le b">docker stop &lt;container-id&gt; </code>命令停止容器。</li></ul><h1 id="6e56" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="0997" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们已经介绍了docker的基本概念和深入知识，以及它在我们系统中的工作方式。</p><p id="f2ca" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在接下来的博客中，我们将学习如何在我们的项目中使用docker文件来实现这一点。如果你有任何疑问，请在评论区随意添加。</p></div></div>    
</body>
</html>