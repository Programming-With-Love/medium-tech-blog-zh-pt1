<html>
<head>
<title>Fibonacci sequence JavaScript interview question. Iterative and Recursive solutions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斐波那契数列JavaScript面试问题。迭代和递归解决方案。</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053?source=collection_archive---------0-----------------------#2018-03-26">https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053?source=collection_archive---------0-----------------------#2018-03-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ed9f7234edc139100143dcb0fc9efc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D82ZwA1Z4Gsh9PN-KHJWzg.jpeg"/></div></div></figure><p id="3c37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">“写一个函数返回斐波那契数列中的一个n元素”</strong>是你在编码挑战面试部分最常听到的问题之一。在这篇博文中，我将介绍这个问题的两个最典型的解决方案，还将涉及一个可怕的(对于大多数新手开发者来说)时间复杂性的话题。</p><p id="307b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么什么是斐波那契数列呢？据<a class="ae jn" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">百科</a>T4:</p><blockquote class="jp jq jr"><p id="97e3" class="ip iq jo ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated">在数学中，<strong class="ir hi">斐波纳契数列</strong>是以下整数序列中的数字，称为<strong class="ir hi">斐波纳契数列</strong>，其特征是前两个数字之后的每个数字都是前两个数字之和</p></blockquote><p id="6028" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据所选的序列起点(0或1)，序列如下所示:</p><p id="949e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p><p id="85cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者这个:</p><p id="b162" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p><p id="1399" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">趣闻:</strong>斐波那契数列，又称黄金分割比，在自然界中出现很多。贝壳的螺旋形、波浪的曲线、种子的头部、松果和树枝等图案都可以用这个数学序列来描述。大到星系螺旋，小到DNA分子都遵循黄金比例法则，这一事实表明斐波那契数列是宇宙最基本的特征之一。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es jv"><img src="../Images/03d16dd056bd8adf4783f161e5f19b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*_pGj3DixmBImxcAl_HWWdA.gif"/></div></figure><p id="15c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，现在回到地球和我们的斐波纳契数列编码挑战。让我们快速描述一下我们的<strong class="ir hi"> fib() </strong>函数的测试用例。如果我们取一个短的Fibonacci序列:[0，1，1，2，3，5，8，13，21]和fib(4)，结果将等于3，所以基本上我们需要从我们的Fibonacci序列数组中返回一个索引为4的元素。</p><p id="d9e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里想到的一个可能也是最容易的解决方案是迭代。让我们看看它会是什么样子:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="e6d3" class="kf kg hh kb b fi kh ki l kj kk">function <strong class="kb hi">fib(n)</strong>{<br/>  let arr = [0, 1];<br/>  <strong class="kb hi">for</strong> (let i = 2; i &lt; n + 1; i++){<br/>    arr.push(arr[i - 2] + arr[i -1])<br/>  }<br/> return arr[n]<br/>}</span></pre><p id="8119" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以请注意，for循环实际上无法有效地生成两个第一个数字，因为我们的循环将涉及两个数字相加，所以我们没有创建空数组，而是将变量<strong class="ir hi"> arr </strong>赋给[0，1],因为我们知道它将始终存在。之后，我们创建一个循环，从<strong class="ir hi"> i = 2 </strong>开始迭代，并将数字添加到数组中，直到数组的长度等于<strong class="ir hi"> n + 1 </strong>。<strong class="ir hi"> </strong>最后，我们返回编号为<strong class="ir hi"> n </strong>的数组的索引。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="722d" class="kf kg hh kb b fi kh ki l kj kk">fib(4)<br/>=&gt; 3</span></pre><p id="4210" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">太好了，看起来这行得通。现在，如果你的面试官认为这还不够，并要求你实现一个递归的解决方案呢？</p><p id="1837" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管递归解决方案看起来很简单，但如果你以前从未遇到过，那么要实现它是相当棘手的:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="85cd" class="kf kg hh kb b fi kh ki l kj kk">function <strong class="kb hi">fib(n)</strong> {<br/>  if (n &lt; 2){<br/>    return n<br/>  }<br/>  return <strong class="kb hi">fib(n - 1) + fib (n - 2)</strong><br/>}</span></pre><p id="ac79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们这里的基本情况是，如果它的值小于2，则返回<strong class="ir hi"> n </strong>。让我们看一下图表，它将帮助您理解我们代码的其余部分发生了什么。函数<strong class="ir hi"> fib </strong>被参数<strong class="ir hi"> 5 </strong>调用:</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/f6d47820eef83f1fb4099707833d5a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNBBacuaBFOVZXUV6VgEEg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">(Diagram from Stephen Grider’s “The Coding Interview Bootcamp“ course on Udemy.com)</figcaption></figure><p id="1339" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基本上，我们的fib函数将继续递归调用自己，创建树的越来越多的分支，直到它遇到基本情况，从基本情况开始，它将自下而上地对每个分支的返回值求和，直到它最终将它们求和并返回一个等于5的整数。这可能需要一点时间来理解，所以花点时间看看这棵树，你就会明白那里发生了什么。</p><p id="88a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于斐波那契数列，强烈推荐<a class="ae jn" href="https://blog.coursesity.com/popular-javascript-frameworks/" rel="noopener ugc nofollow" target="_blank">学习JavaScript </a>。既然我们已经讨论了这个问题的两种常见解决方案，那么让我们来讨论一下时间复杂性。</p><p id="aae0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一些测试环境，比如Jest，会以毫秒为单位显示你的函数运行需要多长时间。假设我们已经为这个挑战预先写好了一些测试，结果会是这样的:</p><p id="3179" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">迭代求解:</strong></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/cbe5f8a6edf9ed5ccaa886d2b51e0b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*FcgU-uWWPEqMtWUM0cwMig.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx">(from Stephen Grider’s “The Coding Interview Bootcamp“ course on Udemy.com)</figcaption></figure><p id="17e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">递归求解:</strong></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es kr"><img src="../Images/eb051b1a49fbfb9de84c24f974590d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*-GYN_e-UBIyYzK5pdCDjCQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx">(from Stephen Grider’s “The Coding Interview Bootcamp“ course on Udemy.com)</figcaption></figure><p id="ddd9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在看看我们用<strong class="ir hi"> n=15调用<strong class="ir hi"> fib() </strong>的情况。</strong>迭代解4ms，递归解1328ms才能完成同样的动作。这是为什么呢？</p><p id="d443" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们迭代求解中的一个算法需要<a class="ae jn" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">线性时间</strong> </a>来完成任务。基本上我们迭代循环<strong class="ir hi"> n-2 </strong>次，所以在这种情况下，大O(用来描述我们最坏情况的符号)将简单地等于<strong class="ir hi"> n </strong>。</p><p id="ecb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在递归的情况下，解需要<a class="ae jn" href="https://en.wikipedia.org/wiki/Time_complexity#Exponential_time" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">的指数时间</strong> </a> <strong class="ir hi">，</strong>，这可以通过当n增加时树的大小指数增长的事实来解释。因此，斐波纳契数列中每增加一个元素，函数调用就会增加。大o在这种情况下等于<strong class="ir hi"> 2^n </strong>。</p><p id="c490" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望现在你已经征服了斐波纳契数列编码挑战，你已经增加了成功通过面试的机会。在下一篇博文中，我将介绍使用记忆化实现递归解决方案的可能改进。敬请期待！</p></div></div>    
</body>
</html>