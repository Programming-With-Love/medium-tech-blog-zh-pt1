<html>
<head>
<title>Immutable models and data consistency in our iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们的iOS应用中的不可变模型和数据一致性</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/immutable-models-and-data-consistency-in-our-ios-app-d10e248bfef8?source=collection_archive---------0-----------------------#2016-08-19">https://medium.com/pinterest-engineering/immutable-models-and-data-consistency-in-our-ios-app-d10e248bfef8?source=collection_archive---------0-----------------------#2016-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="29e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Wendy Lu | Pinterest工程师，核心经验</p><p id="7948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今年早些时候，我们重新设计了我们的<a class="ae jc" href="https://engineering.pinterest.com/blog/re-architecting-pinterests-ios-app" rel="noopener ugc nofollow" target="_blank"> iOS应用</a>,以获得更快、更干净的体验，特别是对于大多数在美国以外使用该应用的Pinners来说。重新设计的目标之一是将我们的应用移动到一个完全不可变的模型层。在这篇文章中，我将讨论这背后的动机，并探索我们的新系统如何处理更新模型，从API加载新信息和数据一致性。</p><h2 id="1214" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">为什么是不可变的模型？</h2><p id="1788" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">“不可变模型”是我们最近经常听到的一个术语，因为许多应用程序已经转化为不变性。不变性意味着模型在初始化后不能被修改。我们为什么要使用它们？嗯，可变性的主要问题在于共享状态。</p><p id="5169" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以这样想:在一个可变模型系统中，A和B都保留一个对c的引用。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/526e61b26de914356fbce523868701aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*osKlNTidk1z6YwUz.png"/></div></figure><p id="4348" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果A修改了C，A和B都会看到一个变化的值。这可能没问题，但是如果B没有预料到这一点，就会发生非常糟糕的事情。</p><p id="8504" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，假设我正在与另外两个用户进行消息对话。我有一个带有“用户”属性的消息对象。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kl"><img src="../Images/8f06cf9f63af2fe587a52d616da52859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/0*_ttGLqBQmggA_TYE.png"/></div></figure><p id="5584" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我在这个视图上时，应用程序的另一部分决定从对话中删除Devin(也许它得到了更新的服务器响应并继续改变模型)。当点击第二行时，我在message.users数组中检索第二个对象。现在返回的是斯蒂芬妮而不是Devin，我最终阻止了错误的人。</p><p id="ed56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不可变模型本质上也是线程安全的。以前，我们不得不担心一个线程可能正在写入模型，而另一个线程正在试图读取它。在我们的新系统中，对象在初始化后不能改变，所以我们可以安全地让多个线程并发读取，而不用担心读取不安全的值。随着我们的iOS应用变得越来越并发和多线程，这让我们的生活变得更加轻松。</p><h2 id="dce8" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">更新模型</h2><p id="9cfb" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">由于我们的模型在创建后是完全不可变的，更新或更改模型的唯一方法是创建一个全新的模型对象。我们有两种方法可以做到这一点:</p><ul class=""><li id="52a0" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">使用字典初始化模型(通常来自JSON响应)</li></ul><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="6bf0" class="jd je hh kw b fi la lb l lc ld">User *user = [[User alloc] initWithDictionary:dictionary];</span></pre><ul class=""><li id="17dc" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">使用一个“builder”对象，它基本上只是一个模型的可变表示，具有模型的所有属性。您可以从现有的模型创建一个构建器，修改您想要的属性，然后调用initWithBuilder返回新的模型(在以后的文章中会有更多的介绍)。</li></ul><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="3fcc" class="jd je hh kw b fi la lb l lc ld">// Change the current user's username to “taylorswift”<br/>UserBuilder *userBuilder = [[UserBuilder alloc] initWithModel:self.currentUser];<br/>userBuilder.username = @"taylorswift";<br/>self.currentUser = [[User alloc] initWithBuilder:userBuilder];</span></pre><h2 id="3839" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">加载和缓存API数据</h2><p id="899d" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们的API允许我们从服务器请求部分JSON模型，包括模型字段的子集。例如，在Pin feed视图中，我们需要像图像URL和描述这样的字段，但是我们不需要请求完整的信息，比如食谱成分，直到用户导航到Pin特写视图。这有助于我们减少通过网络发送的数据量，以及后端处理时间。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es le"><img src="../Images/65e0e1edb7567ff2849d0c2307344e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/0*j0lh6SJ-B7WuJoCD.png"/></div></figure><p id="3db3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们保留了一个建立在<a class="ae jc" href="https://github.com/pinterest/PINCache" rel="noopener ugc nofollow" target="_blank"> PINCache </a>上的中央模型缓存，一个我们建立的对象缓存和用于iOS的<a class="ae jc" href="https://engineering.pinterest.com/tags/pincache" rel="noopener ugc nofollow" target="_blank">开源</a>。这个缓存的键是模型的惟一的、服务器指定的id。当我们得到新的服务器响应时，我们检查现有模型的缓存。如果找到了现有的模型，我们将把服务器响应的字段和现有模型的属性合并到一个全新的模型对象中。这个新模型替换了缓存中的现有模型。这样，缓存的模型总是包含我们收到的所有字段的最新超集。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lf"><img src="../Images/a76ce68f232d10bd6f9717115f787f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*p9e5Ff4MQvG579Ua.png"/></div></figure><h2 id="261e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">数据一致性</h2><p id="5d97" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在模型被更新后(即，一个新的模型对象被创建)，变化应该被反映在显示模型的视图中。我们之前为此使用了<a class="ae jc" href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" rel="noopener ugc nofollow" target="_blank">键值观察</a>，但是KVO不处理不可变的对象——它只观察模型的一个实例的变化。我们现在使用一个基于NSNotificationCenter的系统来通知对象他们关心的模型已经被更新。</p><h2 id="8b5e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">观察变化</h2><p id="b023" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">视图或视图控制器可以注册模型的更新通知。在本例中，消息视图控制器注册其消息模型的更新。它希望知道新的消息模型是何时创建的，因为这个新模型可能已经更新了属性。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lg"><img src="../Images/fb462d6db13347aed46ef7a74485d6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*5xWba9PyHbU54Oas.png"/></div></figure><p id="2223" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码创建了一个观察器，它使用消息模型的名称+唯一标识符来侦听更新的模型。在这种方法的基础上，我们使用了基于块的NSNotificationCenter API ，这样我们可以更好地控制观察器的生命周期。</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="597b" class="jd je hh kw b fi la lb l lc ld">[self.notificationManager addObserverForUpdatedModel:self.message block:^(NSNotification *notification) {<br/>    // Update message view here!<br/>}];</span></pre><p id="1e3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">notificationManager只是一个NSObject，它持有对已注册观察者的强引用。因为它是我们的视图控制器的一个属性，它的dealloc应该在我们的视图控制器的dealloc之后被调用，我们可以确保所有的观察者在那里都是未注册的。</p><h2 id="0b43" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">发布更改</h2><p id="eaad" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">更新消息模型时，将发布更新通知:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="6ddc" class="jd je hh kw b fi la lb l lc ld">Message *newMessage = [[Message alloc] initWithBuilder:newBuilder];<br/>[NotificationManager postModelUpdatedNotificationWithObject:newMessage];</span></pre><p id="9d18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">postModelUpdatedNotificationWithObject将检查模型缓存中相同类+服务器标识符的最新模型，并发布缓存的模型实例。</p><h2 id="2e89" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">进行用户界面更新</h2><p id="a016" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">当一个通知被触发时，新的模型被传递到NSNotification的“object”字段中。然后，视图控制器可以使用更新后的模型进行任何需要的更新！</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="da41" class="jd je hh kw b fi la lb l lc ld">__weak __typeof__(self) weakSelf = self;<br/>[self.notificationManager addObserverForUpdatedModel:self.message block:^(NSNotification *notification) {<br/>    __typeof__(self) strongSelf = weakSelf;<br/>    Message *newMessage = (Message *)notification.object;<br/>    strongSelf.usersInMessageThread = newMessage.users;<br/>    [strongSelf.tableView reloadData];<br/>}];</span></pre><h2 id="b9f7" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">接下来</h2><p id="f49a" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">切换出一个相当大的应用程序的整个模型层不是一件容易的事情，我们创建了一些非常酷的工具来帮助我们。期待我们的下一篇文章，在那里我们将解释如何自动生成我们所有的模型类等等。</p><p id="afc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lh">致谢:感谢我们所有的iOS开发者使用新模型层并给出反馈，特别是我的队友Rahul Malik、Chris Danford、Garrett Moon、Ricky Cancro和Scott Goodson，以及Bella You、Rocir Santiago和Andrew Chun对本文的反馈。</em></p></div></div>    
</body>
</html>