<html>
<head>
<title>Programmer dictionary: Event listener vs event handler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员词典:事件侦听器与事件处理程序</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c?source=collection_archive---------4-----------------------#2018-01-25">https://blog.kotlin-academy.com/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c?source=collection_archive---------4-----------------------#2018-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9624" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件侦听器和事件处理程序是两个容易引起混淆的术语。尤其是在科特林，他们之间的界限很模糊。在这里，我试图使它变得简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5cd3501a661bac746898a5da30f1e343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2ogK9ZqrscmKnN8Z.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Instance of <code class="fe ky kz la lb b">DogListener</code></figcaption></figure><p id="af34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">侦听器和处理程序的一般定义比它在Android中的使用要广泛得多。以下是流行的定义:</p><blockquote class="lc ld le"><p id="9a5b" class="jk jl lf jm b jn jo jp jq jr js jt ju lg jw jx jy lh ka kb kc li ke kf kg kh ig bi translated">一个<strong class="jm io">监听器</strong>监听一个将要被触发的事件。</p><p id="1632" class="jk jl lf jm b jn jo jp jq jr js jt ju lg jw jx jy lh ka kb kc li ke kf kg kh ig bi translated"><strong class="jm io">处理程序</strong>负责处理事件。</p></blockquote><p id="13b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能会令人困惑，因为通常是同一个对象监听事件并处理它们。虽然通常假设当我们将匿名类设置为侦听器时，它的方法是实际的处理程序:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="4f4a" class="ln lo in lb b gy lp lq l lr ls">cancelImage.setOnClickListener(<strong class="lb io">object </strong>: View.OnClickListener { //1<br/>    <strong class="lb io">override fun </strong>onClick(v: View?) { // 2<br/>        dismiss()<br/>    }<br/>})</span></pre><ol class=""><li id="e187" class="lt lu in jm b jn jo jr js jv lv jz lw kd lx kh ly lz ma mb bi translated">匿名类在这里被用作<strong class="jm io">监听器</strong></li><li id="850b" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ly lz ma mb bi translated">方法<code class="fe ky kz la lb b">onClick</code>在这里是事件<strong class="jm io">处理程序</strong></li></ol><p id="4780" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用命名类作为监听器:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="3a0d" class="ln lo in lb b gy lp lq l lr ls"><strong class="lb io">class </strong>OnCancelSnackListener(<br/>    <strong class="lb io">val snackbar</strong>: Snackbar<br/>): View.OnClickListener {<br/>    <strong class="lb io">override fun </strong>onClick(v: View?) {<br/>        <strong class="lb io">snackbar</strong>.dismiss()<br/>    }<br/>}</span></pre><p id="2773" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用法:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="2021" class="ln lo in lb b gy lp lq l lr ls">cancelImage.setOnClickListener(OnCancelSnackListener(<strong class="lb io">this</strong>))</span></pre><p id="9ec7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">侦听器通常是对象，所以它们通常以<code class="fe ky kz la lb b">Listener</code>为后缀。处理程序通常没有后缀，但是它们通常以<code class="fe ky kz la lb b">on</code>作为前缀(<code class="fe ky kz la lb b">onClick</code>、<code class="fe ky kz la lb b">onSwipe</code>等)。).请注意，当我们使用lambda表达式设置监听器时，问题会更大:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="2485" class="ln lo in lb b gy lp lq l lr ls">cancelImage.setOnClickListener <strong class="lb io">{ </strong>dismiss() <strong class="lb io">}</strong></span></pre><p id="d57e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个lambda表达式是什么？倾听者还是处理者？从形式上来说，它指定了事件应该如何处理。侦听器对象是由Kotlin在幕后生成的。这是否意味着当我们命名接受处理程序的函数时，我们应该使用<code class="fe ky kz la lb b">Handler</code>后缀(比如<code class="fe ky kz la lb b">setOnClickHandler</code>)来命名它？一点也不。虽然您可以在一些JS库中找到这样的方法，比如ExJS:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="a6ad" class="ln lo in lb b gy lp lq l lr ls">handler: function() {<br/>}</span><span id="5557" class="ln lo in lb b gy mh lq l lr ls">listeners: {<br/>   'click': function() {<br/>   }<br/>}</span></pre><p id="3789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于历史原因，Java中的惯例，我相信大多数其他语言，是使用<code class="fe ky kz la lb b">Listener</code>后缀！您可以在Kotlin stdlib和JetBrains Kotlin代码中找到Kotlin也采用了该约定。因此，您可以放心地定义以下功能:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="4bc1" class="ln lo in lb b gy lp lq l lr ls">fun setOnLoadedListener(handler: ()-&gt;Unit) {<br/>   // Code<br/>}</span><span id="a47e" class="ln lo in lb b gy mh lq l lr ls">fun addOnFlingListener(handler: ()-&gt;Unit) {<br/>   // Code<br/>}</span></pre><p id="4246" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以定义以下功能:</p><pre class="kj kk kl km gt lj lb lk ll aw lm bi"><span id="f5b3" class="ln lo in lb b gy lp lq l lr ls">fun setOnLoadedListener(listener: ()-&gt;Unit) {<br/>   // Code<br/>}</span><span id="b6ad" class="ln lo in lb b gy mh lq l lr ls">fun addOnFlingListener(listener: ()-&gt;Unit) {<br/>   // Code<br/>}</span></pre><p id="aa27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，为项目陈述一个约定并尊重它是一个很好的实践。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi mi"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="64f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个帖子是<a class="ae mq" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第十五部分。要了解最新的新部件，只需关注此媒体或<a class="ae mq" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，记住我随时准备接受咨询。</p><p id="3aae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mr"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="lt lu in jm b jn jo jr js jv lv jz lw kd lx kh ms lz ma mb bi translated"><a class="ae mq" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">实参vs形参，类型实参vs类型形参</a></li><li id="5a40" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表情</a></li><li id="13fb" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数vs方法vs过程</a></li><li id="7623" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">字段对属性</a></li><li id="15f8" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4d02" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="515c" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="21ae" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收者类型与接收者对象</a></li><li id="f3f7" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="0ad6" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="304d" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="ae5e" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="507e" class="lt lu in jm b jn mc jr md jv me jz mf kd mg kh ms lz ma mb bi translated"><a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组合</a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>