<html>
<head>
<title>Create and Use Custom Angular Directives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建和使用自定义角度指令</h1>
<blockquote>原文：<a href="https://medium.com/edureka/angular-directive-tutorial-3b203de7948a?source=collection_archive---------1-----------------------#2017-07-10">https://medium.com/edureka/angular-directive-tutorial-3b203de7948a?source=collection_archive---------1-----------------------#2017-07-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/57aa3cb6619ee296c7e6cea940f65458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*G6-wF9ae7HiusRoTIoCs-Q.png"/></div><figcaption class="il im et er es in io bd b be z dx">Angular Directive — Edureka</figcaption></figure><p id="2f3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将通过示例代码来理解什么是角度方向，以便更好地理解。稍后继续，我们将了解<em class="jn">属性</em> &amp; <em class="jn">结构</em>指令。我们还将着重于用Angular编写自定义指令。以下是我们讨论所有主题的顺序:</p><ul class=""><li id="d384" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">角度指令</li><li id="8e63" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">属性指令</li><li id="2e79" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">结构指令</li></ul><p id="b7a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们继续这篇文章，首先了解什么是角度方向？</p><h1 id="c8f1" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度方向</h1><p id="35d5" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">你可能想知道为什么我们需要角度方向。现在看看下面的图片，如果你想在所有组件中得到相似的功能，比如淡入淡出功能，你可以采取两种方法。常见的方法是，您可以为所需的行为在所有组件中显式地编写代码，但这将是乏味和复杂的。或者，就像编程语言中的函数一样，您可以编写代码，以后您可以随时调用它，只要您想要该函数的行为。同样，您可以创建一个指令，并在其中编写行为。然后，只要需要该行为，就可以导入该指令。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lf"><img src="../Images/df7ebb010dac9064a66d51f37e3640cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQ4MsR_I8gbKDdmqN_Rr6w.png"/></div></div></figure><p id="6d1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> Angular </em> <em class="jn"> Directive </em>基本上就是一个带有<em class="jn"> @Directive </em> decorator的类。你可能想知道什么是装修工？<strong class="ir hi"><em class="jn">decorator</em></strong><em class="jn"/>是修改JavaScript类的函数。Decorators用于将元数据附加到类上，它知道这些类的配置以及它们应该如何工作。</p><p id="2bc6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可能会惊讶地发现，组件也是一个带有模板的指令。一个<em class="jn">@组件装饰器</em>实际上是一个用面向模板的特性扩展的<em class="jn">@指令装饰器</em>。每当Angular呈现一个指令时，它都会根据该指令给出的指令更改DOM。指令出现在类似于属性的元素标记中。</p><p id="f5d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">角度指令可以分为两种:<strong class="ir hi"> <em class="jn">结构</em> </strong>和<strong class="ir hi"> <em class="jn">属性</em> </strong>指令。</p><p id="0bd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">结构指令</em>通过添加、删除和替换DOM中的元素来改变布局。</p><p id="98df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们简要了解两个主要使用的内置结构指令:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="b1c5" class="lt kd hh lp b fi lu lv l lw lx">&lt;li *ngFor="let movie of movies"&gt;&lt;/li&gt; <br/>&lt;movie-detail *ngIf="selectedMovie"&gt;&lt;/movie-detail&gt;</span></pre><ul class=""><li id="e383" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">*ngFor是一个循环变量，它告诉Angular从电影列表中为每部电影取一个<li>。</li></li><li id="84c1" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">*ngIf只有在选择了电影时才会包含MovieDetail组件，否则会将其从DOM中删除。</li></ul><p id="5ae9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">属性指令改变现有元素的外观或行为。当您在模板中包含属性指令时，它们看起来就像常规的HTML属性。实现双向数据绑定的<em class="jn"> ngModel </em>指令是属性指令的一个例子。<em class="jn"> ngModel </em>通过设置现有元素的显示属性并响应变化的事件来修改现有元素的行为。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="5b45" class="lt kd hh lp b fi lu lv l lw lx">&lt;input [(ngModel)]="movie.name"&gt;</span></pre><p id="0143" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular还有一些指令，它们或者改变布局结构(例如，ngSwitch ),或者修改DOM元素和组件的某些方面(例如，ngStyle和ngClass ),我将会谈到这些。您也可以编写自己的指令，即自定义角度指令。</p><p id="30e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在继续，我们将首先讨论属性指令，然后讨论结构指令，以清楚地了解它们如何工作以及如何实现它们。</p><h1 id="1b76" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度指令:属性指令</h1><p id="0452" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">属性指令主要用于修改或改变元素的外观和行为。</p><p id="40a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选择器是标识属性的特性。它被用作一个HTML标记来定位&amp;在找到该标记的地方插入一个指令类的实例。directive类实现所需的指令行为。</p><p id="82db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们将创建一个<em class="jn"> myHighlight </em>属性指令来设置当您将鼠标悬停在某个元素上时该元素的背景颜色。</p><p id="b822" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用下面的代码，它可以应用于任何地方:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="1fa6" class="lt kd hh lp b fi lu lv l lw lx">Highlight me!</span></pre><p id="8e66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建突出显示指令类型脚本文件，即src/app/highlight.directive.ts，并嵌入以下代码:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="264e" class="lt kd hh lp b fi lu lv l lw lx">import { Directive, ElementRef, HostListener, Input } from '<a class="ae ly" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/> <br/><a class="ae ly" href="http://twitter.com/Directive" rel="noopener ugc nofollow" target="_blank">@Directive</a>({<br/>selector: '[myHighlight]'<br/>})<br/> <br/>export class HighlightDirective {<br/> <br/>constructor(private el: ElementRef) { }<br/><a class="ae ly" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>() defaultColor: string;<br/><a class="ae ly" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>('myHighlight') highlightColor: string;<br/> <br/><a class="ae ly" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a>('mouseenter') onMouseEnter() {<br/>  this.highlight(this.highlightColor || this.defaultColor || 'red');<br/>}<br/> <br/><a class="ae ly" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a>('mouseleave') onMouseLeave() {<br/>  this.highlight(null);<br/>}<br/> <br/>private highlight(color: string) {<br/>  this.el.nativeElement.style.backgroundColor = color;<br/>}<br/> <br/>}</span></pre><p id="53b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">导入</em>语句指定了角形核心所使用的必要依赖关系:</p><ul class=""><li id="1bd2" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn">指令</em>提供了@指令装饰器的功能。</li><li id="cd3e" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn"> ElementRef </em>注入到指令的构造函数中，这样代码就可以访问DOM元素。</li><li id="7783" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn">输入</em>允许数据从绑定表达式流入指令。</li></ul><p id="b123" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，<em class="jn"> @Directive </em> decorator函数包含配置对象中的指令元数据作为参数。</p><p id="bc65" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">@指令</em>需要一个选择器来标识模板中的HTML与指令相关联。这里，指令的选择器是[myHighlight]。Angular定位模板中的所有元素，该模板具有名为<em class="jn"> myHighlight </em>的属性。</p><p id="5ffa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在@Directive元数据之后，上面代码中的下一部分是指令的类，称为HighlightDirective，它包含指令的逻辑。导出HighlightDirective使其他组件可以访问它。</p><p id="7869" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular为每个匹配的元素创建指令的类的新实例，将Angular ElementRef注入到构造函数中。ElementRef是一种服务，它通过DOM元素的nativeElement属性授予对DOM元素的直接访问权限。使用新的myHighlight，在模板内将指令作为属性应用于段落(<p>)元素。</p><p>元素是属性主机。</p></p><p id="9b5f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将模板放在应用程序组件文件中，或者您也可以创建一个新的HTML文件，并在templateURL中提供其路径:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="563e" class="lt kd hh lp b fi lu lv l lw lx">import { Component } from '<a class="ae ly" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/><a class="ae ly" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector: 'my-app',<br/>template: `<br/> <br/>&lt;h1&gt;My First Attribute Directive&lt;/h1&gt;<br/> <br/> <br/>&lt;h4&gt;Pick a highlight color&lt;/h4&gt;<br/> <br/> <br/>&lt;div&gt;<br/>  &lt;input type="radio" name="colors" (click)="color='lightgreen'"&gt;Green<br/>  &lt;input type="radio" name="colors" (click)="color='yellow'"&gt;Yellow<br/>  &lt;input type="radio" name="colors" (click)="color='cyan'"&gt;Cyan<br/>&lt;/div&gt;<br/> <br/> <br/> <br/> Highlight me! <br/> <br/> <br/> <br/> Highlight me too! <br/> <br/>` <br/>}) <br/> <br/>export class AppComponent { }</span></pre><p id="f0f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，添加一个import语句来获取Highlight指令，并将该类添加到声明NgModule元数据中。这样Angular在遇到模板中的myHighlight时就能识别指令。在下面的代码中，您可以看到如何在主模块中导入指令。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="28ed" class="lt kd hh lp b fi lu lv l lw lx">import { NgModule } from '<a class="ae ly" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { BrowserModule } from '<a class="ae ly" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>';<br/>import { HighlightDirective } from './highlight.directive';<br/>import { AppComponent } from './app.component';<br/> <br/><a class="ae ly" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>imports: [ BrowserModule ],<br/>declarations: [ AppComponent, HighlightDirective ],<br/>bootstrap: [ AppComponent ]<br/>})<br/> <br/>export class AppModule { }</span></pre><p id="d78f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当应用程序运行时，<em class="jn"> myHighlight </em>指令高亮显示段落文本，angular检测到您试图绑定到某个东西，并在模块的声明数组中找到该指令。在声明数组中指定了<em class="jn"> HighlightDirective </em>之后，Angular知道它可以将该指令应用于在该模块中声明的组件。</p><p id="5178" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总而言之，Angular在&lt; p &gt;元素上找到了<em class="jn"> myHighlight </em>属性。它创建了一个<em class="jn"> HighlightDirective </em>类的实例，并将对&lt; p &gt;元素的引用注入到该指令的构造函数中，该构造函数设置了&lt; p &gt;元素的背景样式。</p><p id="e406" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">再一次，回头看看指令代码，我们添加了两个事件处理程序，当鼠标进入或离开时它们会做出响应，每个事件处理程序都由<em class="jn"> HostListener </em> decorator修饰。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="8714" class="lt kd hh lp b fi lu lv l lw lx">import { Directive, ElementRef, HostListener, Input } from '<a class="ae ly" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/><a class="ae ly" href="http://twitter.com/Directive" rel="noopener ugc nofollow" target="_blank">@Directive</a>({selector: '[myHighlight]' })<br/> <br/>export class HighlightDirective {<br/> <br/>constructor(private el: ElementRef) { }<br/><a class="ae ly" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>() defaultColor: string;<br/><a class="ae ly" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>('myHighlight') highlightColor: string;<br/> <br/><a class="ae ly" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a>('mouseenter') onMouseEnter() {<br/>  this.highlight(this.highlightColor || this.defaultColor || 'red');<br/>}<br/><a class="ae ly" href="http://twitter.com/HostListener" rel="noopener ugc nofollow" target="_blank">@HostListener</a>('mouseleave') onMouseLeave() {<br/>  this.highlight(null);<br/>}<br/>private highlight(color: string) {<br/>  this.el.nativeElement.style.backgroundColor = color;<br/>}<br/>}</span></pre><p id="8c05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">@ host listener</em>decorator允许您订阅托管属性指令的DOM元素的事件。</p><p id="f2d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">处理程序委托给一个helper方法，该方法设置DOM元素的颜色，<em class="jn"> el </em>，您在构造函数中声明并初始化该元素。</p><p id="12d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意<em class="jn"> @Input </em> decorator。它将元数据添加到类中，使指令的highlightColor属性可用于绑定。它被称为<em class="jn">输入</em>属性，因为数据从绑定表达式流入指令。如果没有输入元数据，Angular将拒绝绑定。</p><p id="5883" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">【my highlight】</em>属性绑定将高亮指示应用于&lt; p &gt;元素，并使用属性绑定设置指示的高亮颜色。我们将重用该指令的属性选择器([myHighlight])来完成这两项工作。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="5bcd" class="lt kd hh lp b fi lu lv l lw lx">@Input('myHighlight') highlightColor: string;</span></pre><p id="286d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在指令中，该属性称为highlightColor。在指令之外，您绑定到它的地方，它被称为myHighlight。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="5a0a" class="lt kd hh lp b fi lu lv l lw lx">&lt;h1&gt;My First Attribute Directive&lt;/h1&gt;<br/> <br/> <br/>&lt;h4&gt;Pick a highlight color&lt;/h4&gt;<br/> <br/> <br/>&lt;div&gt;<br/>&lt;input type="radio" name="colors" (click)="color='lightgreen'"&gt;Green<br/>&lt;input type="radio" name="colors" (click)="color='yellow'"&gt;Yellow<br/>&lt;input type="radio" name="colors" (click)="color='cyan'"&gt;Cyan<br/>&lt;/div&gt;<br/> <br/> <br/> <br/> Highlight me! <br/> <br/> <br/> <br/> Highlight me too!</span></pre><p id="7175" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码部分中，您将把<em class="jn"> AppComponent </em>变成一个线束，让您用单选按钮选择高亮颜色，并将您的颜色选择绑定到指令。Angular知道defaultColor绑定属于HighlightDirective，因为您用@ <em class="jn"> Input </em> decorator公开了它。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="26f8" class="lt kd hh lp b fi lu lv l lw lx">@Input('myHighlight') highlightColor: string;</span></pre><p id="6a23" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不管怎样，<em class="jn"> @Input </em> decorator告诉Angular这个属性是公共的，可以被父组件绑定。没有<em class="jn"> @Input </em>，Angular拒绝绑定属性。</p><p id="a704" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">组件和它的模板相互隐式信任。因此，无论有没有<em class="jn"> @Input </em>装饰器，组件自己的模板都可以绑定到该组件的任何属性。但是一个组件或指令不应该盲目地信任其他组件和指令。默认情况下，组件或指令的属性对绑定是隐藏的。从角度绑定的角度来看，它们是私有的。当用<em class="jn"> @Input </em>装饰器装饰时，从角度绑定的角度来看，属性变成了公共的。只有这样，它才能被其他组件或指令绑定。</p><p id="c2a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个属性出现在模板表达式中等号(=)的右边时，它属于模板的组件，不需要<em class="jn"> @Input </em>装饰器。当它出现在等号(=)左边的方括号([ ])中时，该属性属于某个其他组件或指令；该属性必须用<em class="jn"> @Input </em>装饰器来装饰。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="f290" class="lt kd hh lp b fi lu lv l lw lx">&lt;span style="color: #ff0000;"&gt;&lt;/pre&gt;<br/> <br/>&lt;/span&gt;<br/> <br/> Highlight me!</span></pre><p id="4240" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在看看上面的代码，你可以很容易地推断出:</p><p id="33f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">右边表达式中的color属性属于模板的组件。模板及其组件相互信任。颜色属性不需要<em class="jn">@输入</em></p><p id="763d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">左边的<em class="jn"> myHighlight </em>属性引用了HighlightDirective的别名属性，而不是模板组件的属性。还有信任问题。因此，directive属性必须携带<em class="jn"> @Input </em> decorator。</p><p id="2177" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在讨论了本文中的属性指令之后，我们应该继续讨论结构指令。</p><h1 id="a1df" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度方向:结构方向</h1><p id="a649" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">结构指令负责塑造或重新塑造DOM的<em class="jn">结构</em>，通常是通过添加、删除或操作元素。与其他指令类似，您将一个结构化指令应用于一个<em class="jn">主机元素</em>。然后，该指令会对该宿主元素执行任何它设计的操作。结构指令很容易识别。星号(*)位于指令属性名之前。它不像属性指令那样需要括号或圆括号。</p><p id="df98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">三种常见的内置结构指令是NgIf、NgFor和NgSwitch。让我们看看它们在模板中的样子:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="4c94" class="lt kd hh lp b fi lu lv l lw lx">div *ngIf="movie" &gt;{{movie.name}}&lt;/div&gt;<br/> <br/> <br/>&lt;ul&gt;    <br/>   <br/>&lt;li *ngFor="let movie of movies"&gt;{{movie.name}}&lt;/li&gt;<br/> <br/>&lt;/ul&gt;<br/> <br/> <br/>&lt;div [ngSwitch]="movie?.genre"&gt;  <br/>  &lt;action-movie *ngSwitchCase="'action'" [movie]=" movie "&gt;&lt;/action-movie&gt;  <br/>  &lt;horror-movie *ngSwitchCase="'horror'" [movie]=" movie "&gt;&lt;/horror-movie&gt;  <br/>  &lt;thriller-movie *ngSwitchCase="'thriller'" [movie]=" movie "&gt;&lt;/thriller-movie&gt;  <br/>  &lt;unknown-movie *ngSwitchDefault [movie]=" movie "&gt;&lt;/unknown-movie&gt;<br/>&lt;/div&gt;</span></pre><p id="39c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">指令可以用大写<em class="jn">和小写</em>两种字体<em class="jn">写</em>。这是因为NgIf引用指令<em class="jn">类</em>T30】NgIf引用指令的<em class="jn">属性名</em>。当我们谈论它的属性和指令做什么时，我们将参考指令<em class="jn">类</em>。而在描述如何将指令应用到HTML模板中的元素时，我们将引用属性名。</p><h2 id="9cc1" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">NgIf</h2><p id="1427" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">NgIf是最简单的结构化指令，也是最容易理解的。它采用一个布尔表达式，使整个DOM块出现或消失。您可以假设它类似于编程语言中的if语句</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="b1c6" class="lt kd hh lp b fi lu lv l lw lx">Expression is true and ngIf is true. <br/>  This paragraph will be included in the DOM.     <br/> <br/>  Expression is false and ngIf is false. <br/>  This paragraph will not be included in the DOM.</span></pre><p id="1af0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ngIf指令不隐藏元素。它从DOM中物理地添加和删除它们。您可以通过使用浏览器开发工具检查DOM来确认这一点。当条件为假时，NgIf从DOM中删除其主体元素，将组件从角度变化检测中分离出来，并销毁它。</p><p id="d551" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不要混淆<em class="jn">移除</em>和<em class="jn">隐藏。对于一个简单的段落来说，隐藏和删除的区别并不重要。但是，当宿主元素附加到资源密集型组件时，这就很重要了。该组件仍然附加在它的DOM元素上。它一直在监听事件。Angular不断检查可能影响数据绑定的更改。</em></p><p id="2320" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然元素是不可见的，但是组件监听DOM。性能和内存负担可能非常大，响应能力可能会下降，用户什么也看不到。从积极的一面来看，再次显示元素很快。组件的先前状态被保留并准备好显示。组件不会重新初始化—这是一个代价很高的操作。所以隐藏和展示有时是正确的做法。</p><p id="80e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，如果你想删除用户看不到的DOM元素，并恢复未使用的资源，在这种情况下，你可以使用NgIf这样的结构指令。</p><h2 id="7060" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">为什么我们使用星号(*)？</h2><p id="569d" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">您一定注意到了指令名前面的星号(*)，并想知道它为什么重要？这里*ngIf显示英雄的名字，如果英雄存在的话。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="1279" class="lt kd hh lp b fi lu lv l lw lx">&lt;div *ngIf="movie"&gt;{{movie.name}}&lt;/div&gt;</span></pre><p id="ba42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在内部，角度分两个阶段对其进行解耦。首先，它将*ngIf="…"翻译成一个模板属性，template = "ngIf …"，然后它变成:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="12cb" class="lt kd hh lp b fi lu lv l lw lx">&lt;div template="ngIf movie"&gt;{{movie.name}}&lt;/div&gt;</span></pre><p id="618f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，它将模板<em class="jn">属性</em>转换成一个&lt; ng-template &gt; <em class="jn">元素</em>，包装在主机元素周围，如下所示。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="583c" class="lt kd hh lp b fi lu lv l lw lx">&lt;ng-template [ngIf]="movie"&gt;<br/> <br/>&lt;div&gt;<br/>    {{movie.name}} <br/>&lt;/div&gt;<br/> <br/>&lt;/ng-template&gt;</span></pre><ul class=""><li id="9a08" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">*ngIf指令移到了<ng-template>元素，在那里它变成了一个属性绑定[ngIf]。</ng-template></li><li id="5d42" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><div>的其余部分，包括它的class属性，被移到了<ng-template>中</ng-template></div></li></ul><p id="552b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些表单实际上都没有呈现。只有完成的产品才会进入DOM。</p><p id="a695" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">NgFor和NgSwitch指令遵循相同的模式。</p><h2 id="ddef" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">*ngFor</h2><p id="c090" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular以类似的方式将*ngFor从星号(*)语法通过模板<em class="jn">属性</em>转换为&lt;ng-模板&gt; <em class="jn">元素</em>。</p><p id="cdcd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来是这样的:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="dded" class="lt kd hh lp b fi lu lv l lw lx">&lt;div *ngFor="let movie of movies"&gt;{{movie.name}}&lt;/div&gt;<br/> <br/> <br/>&lt;div template="ngFor let movie of movies"&gt;{{movie.name}}&lt;/div&gt;<br/> <br/> <br/>&lt;ng-template ngFor let-movie [ngForOf]="movies"&gt;{{movie.name}}<br/>&lt;/ng-template&gt;</span></pre><p id="5c26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ngFor需要一个循环变量(let movie)和一个列表(movies)。ngFor字符串在之外的一切<em class="jn">随着它在&lt; ng-template &gt;之内移动而与主机元素(&lt; div &gt;)保持在一起。</em></p><p id="9f61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular microsyntax允许您以紧凑、友好的字符串形式配置指令。microsyntax解析器将该字符串翻译成<ng-template>上的属性:</ng-template></p><ul class=""><li id="7492" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn"> let </em>关键字声明了一个您在模板中引用的模板输入变量。本例中的输入变量是电影。解析器将let movie翻译成名为let-movie的变量。</li><li id="22aa" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">当theNgFor指令遍历列表时，它设置和重置自己的<em class="jn">上下文</em>的属性</li></ul><h2 id="e896" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">模板输入变量</h2><p id="a207" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一个<em class="jn">模板输入变量</em>是一个变量，它的值可以在模板的单个实例中引用<em class="jn">。所有的前面都有关键字<em class="jn"> let </em>。</em></p><p id="bcdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用let关键字(let hero)声明一个模板<em class="jn">输入</em>变量。该变量的范围限于重复模板的一个<em class="jn">单实例</em>。您可以在其他结构化指令的定义中再次使用相同的变量名。</p><p id="d50a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个主体元素只能应用一个结构指令。举个例子，如果你想重复一个HTML块，但是只有在特定的条件为真的时候。您将<em class="jn">尝试</em>将一个*ngFor和一个*ngIf放在同一个主机元素上。棱角不会放过你的。一个元素只能应用一个<em class="jn">结构</em>指令。</p><p id="2dc7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">原因就是简单。结构指令可以对宿主元素做复杂的事情。当两个指令声明同一个主机元素时，哪一个优先？NgIf和NgFor哪个应该先走？</p><p id="7ae7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很难回答这些问题。这个用例有一个简单的解决方案:将*ngIf放在一个容器元素上，该容器元素包装了*ngFor元素。一个或两个元素可以是一个<em class="jn"> ng容器</em>。所以如果你不必引入额外的HTML级别，你可以在这样的条件下使用NgSwitch。</p><h2 id="8125" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">NgSwitch指令</h2><p id="6344" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">角度<em class="jn"> NgSwitch </em>实际上是一组配合指令:<em class="jn"> NgSwitch </em>、<em class="jn"> NgSwitchCase </em>和<em class="jn"> NgSwitchDefault </em>。</p><p id="fd79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个例子。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="d4de" class="lt kd hh lp b fi lu lv l lw lx">&lt;div [ngSwitch]="movie?.genre"&gt;  <br/>  &lt;action-movie *ngSwitchCase="'action'" [movie]=" movie "&gt;&lt;/action-movie&gt;  <br/>  &lt;horror-movie *ngSwitchCase="'horror'" [movie]=" movie "&gt;&lt;/horror-movie&gt;  <br/>  &lt;thriller-movie *ngSwitchCase="'thriller'" [movie]=" movie "&gt;&lt;/thriller-movie&gt;  <br/>  &lt;unknown-movive *ngSwitchDefault [movie]=" movie "&gt;&lt;/unknown-movie&gt;<br/>&lt;/div&gt;</span></pre><p id="5a34" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">分配给NgSwitch (movie.genre)的开关值决定显示哪些开关情况。</p><p id="89fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> NgSwitchCase </em>和<em class="jn"> NgSwitchDefault是</em>结构指令。您可以使用星号(*)前缀符号将它们附加到元素。当<em class="jn"> NgSwitchCase </em>的值与开关值匹配时，显示其主机元素。当没有兄弟<em class="jn"> NgSwitchCase </em>匹配开关值时，<em class="jn"> NgSwitchDefault </em>显示其主机元素。</p><p id="8832" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您应用指令的元素是它的<em class="jn">主机</em>元素。动作片&lt;是欢乐* <em class="jn"> ngSwitchCase </em>的主机元素。&lt;未知电影&gt;是* <em class="jn">开关默认</em>的主机元素。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="b8d4" class="lt kd hh lp b fi lu lv l lw lx">&lt;div [ngSwitch]="movie?.genre"&gt;  <br/>  &lt;action-movie *ngSwitchCase="'action'" [movie]=" movie "&gt;&lt;/action-movie&gt;  <br/>  &lt;horror-movie *ngSwitchCase="'horror'" [movie]=" movie "&gt;&lt;/horror-movie&gt;  <br/>  &lt;thriller-movie *ngSwitchCase="'thriller'" [movie]=" movie "&gt;&lt;/thriller-movie&gt;  <br/>  &lt;unknown-movive *ngSwitchDefault [movie]=" movie "&gt;&lt;/unknown-movie&gt;<br/>&lt;/div&gt;</span></pre><p id="ba04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在内部，它也被转换成<ng-template>元素形式。那么看起来是这样的:</ng-template></p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="6d86" class="lt kd hh lp b fi lu lv l lw lx">&lt;div [ngSwitch]="movie?.genre"&gt;  <br/>&lt;ng-template [ngSwitchCase]="'action'"&gt;    <br/>  &lt;action-movie [movie]="movie"&gt;&lt;/ action-movie &gt;  <br/>&lt;/ng-template&gt;  <br/>&lt;ng-template [ngSwitchCase]="'sad'"&gt;    <br/>  &lt;horror-movie [movie]="movie"&gt;&lt;/horror-movie&gt;  <br/>&lt;/ng-template&gt;  <br/>&lt;ng-template [ngSwitchCase]="'confused'"&gt;    <br/>  &lt;thriller-movie [movie]="movie"&gt;&lt;/thriller-movie&gt;  <br/>&lt;/ng-template &gt;  <br/>&lt;ng-template ngSwitchDefault&gt;    <br/>  &lt;unknown-movie [movie]="movie"&gt;&lt;/unknown-movie&gt;<br/>&lt;/ng-template&gt;<br/>&lt;/div&gt;</span></pre><p id="d45d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> &lt; ng-template &gt; </em>是一个用于渲染HTML的角度元素。它从不直接显示。事实上，在渲染视图之前，Angular <em class="jn">用一个注释替换了<em class="jn"> &lt; ng-template &gt; </em>及其内容</em>。</p><p id="6ce3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在本文中，让我们看看如何编写一个定制的结构化指令。</p><h2 id="9a60" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">自定义结构指令</h2><p id="32e1" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">要编写自定义结构指令:</p><ul class=""><li id="ddfa" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">导入指令装饰器(而不是组件装饰器)。</li><li id="87b4" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">导入Input、TemplateRef和ViewContainerRef符号。任何结构指令都需要它们。</li><li id="34f0" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">将装饰器应用于指令类。</li><li id="a88a" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">设置CSS <em class="jn">属性选择器</em>，当应用于模板中的元素时，该属性选择器标识该指令。</li></ul><p id="63fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是开始创建指令的方式:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="619a" class="lt kd hh lp b fi lu lv l lw lx">import{Directive, Input, TemplateRef, ViewContainerRef} from '<a class="ae ly" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>'; <br/> <br/><a class="ae ly" href="http://twitter.com/Directive" rel="noopener ugc nofollow" target="_blank">@Directive</a>({<br/>selector: '[myCustom]'<br/>})<br/> <br/>export class myCustomDirective {}</span></pre><p id="d592" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">指令的<em class="jn">选择器</em>通常是方括号中的指令的<strong class="ir hi">属性名</strong>，【myCustom】。指令<em class="jn">属性名</em>应该用<em class="jn">小写字母</em>拼写，并以前缀开头。不要用ng。那个前缀是Angular的。指令<em class="jn">类</em>名称以指令结尾</p><h2 id="6757" class="lt kd hh bd ke lz ma mb ki mc md me km ja mf mg kq je mh mi ku ji mj mk ky ml bi translated">TemplateRef和ViewContainerRef</h2><p id="b993" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一个简单的结构角度指令从角度生成的<ng-template>创建一个嵌入式视图，并将该视图插入到一个视图容器中，该容器与指令的原始<p>主机元素相邻。您将使用TemplateRef获取<ng-template>内容，并通过ViewContainerRef访问<em class="jn">视图容器</em>。将这两者作为类的私有变量注入到指令构造函数中。</ng-template></p></ng-template></p><p id="0348" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这篇文章能给你带来信息和附加值。现在，您必须清楚角度方向，并准备好使用角度应用程序。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Web开发的各个方面。</p><blockquote class="mm mn mo"><p id="57e3" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">1.<a class="ae ly" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> ReactJS教程</a></p><p id="93c3" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">2.<a class="ae ly" rel="noopener" href="/edureka/react-components-65dc1d753af5">反应组分</a></p><p id="44b2" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">3.<a class="ae ly" rel="noopener" href="/edureka/react-router-2aab4e781736"> React路由器v4教程</a></p><p id="e22a" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">4.<a class="ae ly" rel="noopener" href="/edureka/react-redux-tutorial-2b3d81cfd3f7"> React Redux教程</a></p><p id="cf45" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">5.<a class="ae ly" rel="noopener" href="/edureka/angular-tutorial-for-beginners-4738ce387b03">角度教程</a></p><p id="da12" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">6.<a class="ae ly" rel="noopener" href="/edureka/animating-angularjs-apps-with-nganimate-directive-510500755b76">用ngAnimate指令制作AngularJS应用程序动画</a></p><p id="f188" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">7.<a class="ae ly" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> NodeJS教程</a></p><p id="550f" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">8.<a class="ae ly" rel="noopener" href="/edureka/php-tutorial-beginners-guide-to-php-f78a189de6f"> PHP教程</a></p><p id="a9e6" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">9.<a class="ae ly" rel="noopener" href="/edureka/jquery-tutorial-for-beginners-679021d74ab4"> JQuery教程</a></p><p id="8188" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">10.<a class="ae ly" rel="noopener" href="/edureka/top-10-javascript-frameworks-3179f1b5bd41">十大JavaScript框架</a></p><p id="823e" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">11.<a class="ae ly" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762">使用Node.js和MySQL构建CRUD应用</a></p><p id="b4e1" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">12.<a class="ae ly" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c">使用节点构建CRUD应用程序。JS和MongoDB </a></p><p id="39fb" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">13.<a class="ae ly" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">用Node.js构建REST API</a></p><p id="7db1" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">14.<a class="ae ly" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="10ff" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">15.<a class="ae ly" rel="noopener" href="/edureka/html-vs-html5-83302f95652e"> HTML vs HTML5 </a></p><p id="53f1" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">16.<a class="ae ly" rel="noopener" href="/edureka/what-is-rest-api-d26ea9000ee6">什么是REST API？</a></p><p id="7b35" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">17.<a class="ae ly" rel="noopener" href="/edureka/flutter-vs-react-native-58133fbf9f33">颤振vs反应原生</a></p><p id="ea4d" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">18.<a class="ae ly" rel="noopener" href="/edureka/node-js-docker-tutorial-72e7542d69d8">如何对Node.js App进行Dockerize？</a></p><p id="ea44" class="ip iq jn ir b is it iu iv iw ix iy iz mp jb jc jd mq jf jg jh mr jj jk jl jm ha bi translated">19.<a class="ae ly" rel="noopener" href="/edureka/javascript-calculator-47778c7596f3">如何搭建一个JavaScript计算器？</a></p></blockquote></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="9f7c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2017年7月10日</em><a class="ae ly" href="https://www.edureka.co/blog/angular-directive/" rel="noopener ugc nofollow" target="_blank"><em class="jn">www.edureka.co</em></a><em class="jn">。</em></p></div></div>    
</body>
</html>