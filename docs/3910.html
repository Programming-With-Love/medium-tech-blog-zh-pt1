<html>
<head>
<title>Docker The Containerization World -Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集装箱化世界-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/docker-the-containerization-world-part-2-cd2bdb48bf61?source=collection_archive---------2-----------------------#2022-07-05">https://medium.com/globant/docker-the-containerization-world-part-2-cd2bdb48bf61?source=collection_archive---------2-----------------------#2022-07-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/61f74b35506a134de5bc5349737af350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZLrVlMV9_yCf4_TK2sAAQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Docker Containerization</figcaption></figure><p id="80fa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在之前的博客中，我们学习了关于docker的基本概念。这是第一部分<a class="ae jr" rel="noopener" href="/globant/docker-containerisation-world-basics-part-1-f5abc0b7390b">的链接https://medium . com/globant/docker-container isation-world-basics-PART-1-F5 ABC 0 b 7390 b</a></p><p id="dc5f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">到目前为止，我们一直使用由第三方构建和开发的docker映像(busybox，hello-world)。在这个博客中，我们将学习如何自己创建自定义的Docker图像。为了实现这一点，我们利用docker文件。</p><p id="1fbb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们将使用docker创建一个简单的node js web应用程序，并通过浏览器访问它。参考下图。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/1ed84764a77130c6c95593429ac91486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AerGcXZSXFD7aT5JurYHmA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Web application</figcaption></figure><p id="5edf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们按照以下步骤使用docker创建node js web应用程序。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jx"><img src="../Images/c232d66444a610473fdc8bbcaeb00845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*qcYhDxGGJooKoRxwm6yStQ.png"/></div></figure><ul class=""><li id="9354" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">首先，我们创建Node JS服务器端应用程序。为此，我们创建目录，然后在该目录中创建package.json文件，并添加下面的内容。</li></ul><pre class="jt ju jv jw fd kh ki kj kk aw kl bi"><span id="2942" class="km kn hh ki b fi ko kp l kq kr">{<br/>"name": "simple-web",<br/>"main": "index.js",<br/>"scripts": {<br/>"start": "node index.js"<br/>},<br/>"dependencies": {<br/>"express": "^4.18.1"<br/>}<br/>}</span></pre><ul class=""><li id="f6ae" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">然后在同一目录下创建一个index.js文件。这个文件是监听传入请求的入口点。添加以下内容。</li></ul><pre class="jt ju jv jw fd kh ki kj kk aw kl bi"><span id="93ca" class="km kn hh ki b fi ko kp l kq kr">const express = require('express');<br/>const app = express();<br/>app.get('/', (req, res) =&gt; {<br/>res.send('Hello World!');<br/>});<br/>app.listen(5000, ()=&gt; {<br/>console.log("listening on port 5000");<br/>});</span></pre><ul class=""><li id="021b" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">在上图中，我们已经导入了express库，该库已经作为依赖项添加到package.json文件中。我们使用这个库创建服务器。将要处理get请求，像这样我们也可以使用其他的HTTP方法。<code class="du ks kt ku ki b">app.listen</code>监听端口5000。</li><li id="7b25" class="jy jz hh iv b iw kv ja kw je kx ji ky jm kz jq kd ke kf kg bi translated">我们已经创建了节点js应用程序。现在是时候创建Dockerfile了，它负责将这个nodejs应用程序作为一个单独的容器来运行。因此，让我们将以下内容添加到docker文件中。</li></ul><pre class="jt ju jv jw fd kh ki kj kk aw kl bi"><span id="d584" class="km kn hh ki b fi ko kp l kq kr"># Specify a base image<br/>FROM node:alpine</span><span id="1bfb" class="km kn hh ki b fi la kp l kq kr">#Create a dicrectory inside the container<br/>WORKDIR usr/app</span><span id="f78c" class="km kn hh ki b fi la kp l kq kr">#Copy package.json file to container<br/>COPY ./package.json ./</span><span id="3e01" class="km kn hh ki b fi la kp l kq kr"># Install some dependencies<br/>RUN npm install</span><span id="cca6" class="km kn hh ki b fi la kp l kq kr"># COPY rest of the files to container<br/>COPY ./ ./</span><span id="f4ac" class="km kn hh ki b fi la kp l kq kr"># Default command to the container startup<br/>CMD ["npm", "start"]</span></pre><p id="274b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们理解Dockerfile的每一行</p><p id="3e54" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">指定一个基础图像</strong></p><ul class=""><li id="9fca" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">我们在Dockerfile的开头使用来自关键字的<strong class="iv hi">来提到图像名，所以这里图像名是一个<strong class="iv hi">节点。之后，我们用分号(:)来定义版本。这里我们使用一个<strong class="iv hi"> alpine </strong>版本的node。阿尔卑斯版本本质上是紧凑的，大小是5MB。我们使用alpine版本的图像，因为我们希望我们的容器有一个更小的尺寸。您也可以在docker hub上使用<strong class="iv hi">其他节点版本</strong>。但是与阿尔卑斯山相比，这些版本的尺寸可能会更大。</strong></strong></li></ul><p id="4b9a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">在容器内创建一个目录</strong></p><ul class=""><li id="31bc" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated"><strong class="iv hi"> WORKDIR </strong>关键字我们用来在容器内创建工作目录。这里的<strong class="iv hi"> usr </strong>目录是文件系统的一部分。在这个目录下，我们创建了<strong class="iv hi"> app </strong>目录。</li></ul><p id="270f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">将package.json文件复制到容器</strong></p><ul class=""><li id="8bb7" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">在这里，我们将<strong class="iv hi"> package.json文件</strong>从当前工作目录复制到容器的目录，这是我们在步骤2中创建的一个<strong class="iv hi">应用程序</strong>。</li></ul><p id="2712" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">安装一些依赖关系</strong></p><ul class=""><li id="ea24" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">这里我们使用<code class="du ks kt ku ki b">npm install</code>命令在容器下安装依赖项。以便它将在同一目录中生成node_modules。</li></ul><p id="8a9e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">将剩余的文件复制到容器</strong></p><ul class=""><li id="5938" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">现在，我们将剩余的文件复制到容器中。在我们的例子中，我们只有作为服务器的<strong class="iv hi"> index.js文件</strong>。这里第一个<strong class="iv hi">。/ </strong>表示源目录，第二个<strong class="iv hi">。/ </strong>指目的地目录。</li></ul><p id="fe34" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">容器启动的默认命令</strong></p><ul class=""><li id="4996" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">因为我们已经在前一篇博客中学习了启动命令。所以我们在这里添加了带有关键字<strong class="iv hi"> CMD </strong>的<code class="du ks kt ku ki b">["npm", "start"]</code>命令。</li></ul><h1 id="6e09" class="lb kn hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最后，我们的项目架构应该是这样的</h1><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/25741ea421f1fe60fd414d12b804fe55.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*SmT89MDn6QO-03X4oTYGRw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">VS code editor</figcaption></figure><h1 id="117b" class="lb kn hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建docker映像</h1><ul class=""><li id="1438" class="jy jz hh iv b iw lz ja ma je mb ji mc jm md jq kd ke kf kg bi translated">为了使用Dockerfile构建docker映像，我们使用了命令<code class="du ks kt ku ki b">docker build .</code>，请注意<strong class="iv hi"> build </strong>关键字后的<strong class="iv hi">点句点</strong>。圆点基本上告诉docker，必须使用的Dockerfile在当前目录中。我们需要使用名为<strong class="iv hi"> -t. </strong>的标志为我们的图像添加一些名称</li><li id="1dc4" class="jy jz hh iv b iw kv ja kw je kx ji ky jm kz jq kd ke kf kg bi translated">在根级别运行的最后一个命令将是<code class="du ks kt ku ki b">docker build -t simple-web .</code></li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es me"><img src="../Images/33dd8dd6879518d5c1f6d843ca9598de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*f88A3bCr2Lx08jx_Wb_hzA.png"/></div></figure><ul class=""><li id="e8b8" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">我们已经成功地创建了图像。现在是运行图像的时候了。使用<code class="du ks kt ku ki b">docker run &lt;image-name&gt;</code>。在我们的例子中，我们使用<code class="du ks kt ku ki b">docker run simple-web</code>。当我们这样做时，图像simple-web的文件系统将被复制到一个单独的容器中。在之前的博客中，我们已经了解了它的内部工作原理。下图显示了我们运行命令<code class="du ks kt ku ki b">docker run simple-web</code>后这个容器的样子。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/fe8c5c2354d471233fdf02aefcb5577d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6X5LyZ6U-ytMhpV6uKxWRQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">simple-web image and container</figcaption></figure><ul class=""><li id="7ef0" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">在上图中，我们可以看到我们定制的简单web图像及其文件系统。此外，我们运行图像<code class="du ks kt ku ki b">docker run simple-web</code>时创建的容器。这将在终端上显示以下输出。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/fc98076ef15e6f2d2edc52acd1334a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*msgWXyGbqjsN2SJGyfr08g.png"/></div></figure><ul class=""><li id="fd6d" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">现在服务器运行在端口5000上。打开浏览器，输入网址<strong class="iv hi"> localhost:5000 </strong>。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/e250e1826cb932c25c495427ff8e7db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trTvCIYoDuJnpEoupGLoiw.png"/></div></div></figure><ul class=""><li id="194e" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">它无法到达端口5000。因为我们的node js应用程序是在容器下运行的。因此它无法在浏览器上加载应用程序。现在，我们将通过下图了解为什么应用程序不可达。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/08d365a5b1db823b9c3d50033149c5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55aKuxO7a80bVmsCeSNcLQ.png"/></div></div></figure><ul class=""><li id="9594" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">浏览器向端口5000上的本地主机发出请求。因此，无论请求到达localhost 5000的哪里，它都会被路由到容器。该容器有自己的一组隔离端口，可以接收来自外部世界的流量。因此，现在默认情况下，没有来自您的机器localhost到容器网络的请求。</li><li id="4e48" class="jy jz hh iv b iw kv ja kw je kx ji ky jm kz jq kd ke kf kg bi translated">下面是我们将应用程序从容器中暴露给外界的方式。为了实现这一点，我们必须使用-p标志显式地进行端口映射。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/fb8dae2cf89ace8796916d2c5d344f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygqeP4BYEc27AcNFpeO0rg.png"/></div></div></figure><ul class=""><li id="2b39" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">再次运行命令<code class="du ks kt ku ki b">docker run -p 5000:5000 simple-web</code>。一旦你在终端上点击这个命令，你可以在屏幕上再次看到同样的输出。然后转到浏览器，再次键入localhost:5000。现在，您可以向容器发出请求了。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/4c71cf968e52e5d9dac66d46bc5d526d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53K13L9lU8ZAIwume7tnWw.png"/></div></div></figure><ul class=""><li id="1e58" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">下图显示了映射到容器的端口。</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/ea966b496ec6718ab20bdb786808c4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_vxL2JOfwExGAFWy9oT2w.png"/></div></div></figure><h1 id="0b32" class="lb kn hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="1393" class="pw-post-body-paragraph it iu hh iv b iw lz iy iz ja ma jc jd je mm jg jh ji mn jk jl jm mo jo jp jq ha bi translated">我们已经成功地用Dockerfile完成了基本的node js应用。这被称为单容器应用程序。在接下来的博客中，我们将学习如何用docker实现多容器。</p><p id="7025" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你有任何疑问，请在评论区随意添加。</p></div></div>    
</body>
</html>