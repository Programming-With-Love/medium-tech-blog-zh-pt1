<html>
<head>
<title>Unified PubSub Client at Pinterest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pinterest的统一PubSub客户端</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/unified-pubsub-client-at-pinterest-397ccfaf508e?source=collection_archive---------1-----------------------#2022-03-15">https://medium.com/pinterest-engineering/unified-pubsub-client-at-pinterest-397ccfaf508e?source=collection_archive---------1-----------------------#2022-03-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6ac6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">瓦希德·哈什米安|软件工程师，测井平台<br/>杰夫祥|软件工程师，测井平台</p><p id="c1a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，日志平台团队管理PubSub层，并为与之交互的客户端提供支持。在PubSub层的核心，有两个主要的系统负责数据的进出:</p><ol class=""><li id="b202" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><a class="ae jl" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>(以下简称卡夫卡)</li><li id="283c" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><a class="ae jl" rel="noopener" href="/pinterest-engineering/memq-an-efficient-scalable-cloud-native-pubsub-system-4402695dd4e7"> MemQ </a></li></ol><p id="db65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在过去的几年里，我们从运营经验中了解到，我们的客户和业务需要降低KTLO成本，他们希望平台团队不仅拥有服务器/服务，还拥有客户端/ SDK以及与客户端-服务器连接产生的任何问题相关的随叫随到，这样他们就可以专注于应用程序逻辑。</p><p id="0752" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为一个平台团队，我们希望提高我们平台的可扩展性和效率(例如，通过改进PubSub系统)，这反过来可能需要对客户机/ SDK进行快速更改。</p><p id="bbd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现我们提高日志平台服务质量(QoS)的目标，我们决定投资并拥有PubSub客户端/ SDK。使用本地客户端并在此基础上添加一些增值功能(尽管是一项艰巨的任务)，将有助于解决我们的可扩展性、稳定性和开发速度目标。这就是为什么我们决定实现一个统一的PubSub客户端库，称为PubSub客户端(PSC)。</p><h1 id="edff" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为什么是另一个客户？</h1><p id="a32a" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">直到大约两年前，卡夫卡还是Pinterest的单一PubSub系统，大部分数据管道仍然运行在卡夫卡上。客户端应用程序使用卡夫卡客户端库连接到卡夫卡集群，并产生或使用数据。这种对卡夫卡客户的直接依赖带来了自身的挑战:</p><p id="8e85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。降低开发速度<br/> </strong>由于客户端应用程序和卡夫卡式经纪人之间的直接依赖关系，它们没有被充分隔离。一方面，客户端应用程序(PubSub平台的用户)很容易受到代理端变化的影响。例如，根据使用的客户端库的版本，它们可能会受到代理升级的影响。</p><p id="15d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一方面，PubSub平台团队也有自己的挑战。他们不能简单地升级卡夫卡经纪人，因为对客户端应用程序的潜在影响是未知的，因为不了解正在使用的客户端库版本(参见我们之前的文章<a class="ae jl" href="https://www.confluent.io/blog/running-kafka-at-scale-at-pinterest/#kafka-upgrade" rel="noopener ugc nofollow" target="_blank">)是什么。</a></p><p id="75b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">底线:在PubSub层和客户端应用程序之间缺乏明确的所有权界限，这是由于应用程序对PubSub客户端库的紧密依赖。</p><p id="47f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。服务的可靠性<br/> </strong>任何PubSub客户端库都带有一套全面的配置，一般的应用程序开发人员可能并不完全熟悉。如果没有适当的客户端跟踪手段，平台团队就无法了解哪个应用程序正在使用什么配置。这不仅会因为潜在的错误配置而影响应用程序的性能，还会对PubSub平台产生负面影响，导致依赖该平台的其他应用程序出现级联问题。</p><p id="2544" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为PubSub平台团队，我们面临的另一个可靠性问题是客户端应用程序对Kafka集群“端点”(即种子代理)的紧密依赖。尽管动态发现集群端点的方法是可用的，但我们不能简单地强制执行它们，并且我们最终会在集群维护或代理退役/替换期间中断使用硬编码端点的客户端应用程序。</p><p id="8854" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。服务的可伸缩性<br/> </strong>我们的策略是让底层PubSub实现的细微差别对客户端应用程序透明。这种透明性意味着PubSub层的平台团队有更多的自由:</p><ul class=""><li id="4e9a" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb ku ji jj jk bi translated">诸如代理维护、重新配置、扩大/缩小或扩大/缩小，或者将工作负载从一个PubSub无缝转移到另一个pub sub(例如Kafka到MemQ，Kafka到Pulsar，反之亦然)之类的事情可以在更少担心对客户端应用程序的负面影响的情况下完成。</li><li id="ceed" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated">客户端应用程序将不再严格受限于发布订阅系统或对其采取的操作。</li></ul><p id="e774" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有这种透明性，可伸缩性就会受到严重威胁。只需要一个对某些PubSub维护操作敏感的应用程序，就可以严重限制平台团队完全自动化维护操作。这种敏感性的原因可能是应用程序架构/逻辑、PubSub客户端库的特定用法或客户端库中的潜在边缘情况(例如，生产者的静态分区)。迁移到统一的客户端库将统一所有客户端应用程序的期望，并有助于减少这些不希望出现的情况。</p><p id="54b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">统一的PubSub客户端库减少了客户端应用程序和PubSub层之间的相互依赖，并提供:</p><ul class=""><li id="bb35" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb ku ji jj jk bi translated"><strong class="ig hi">一致的指标和警报:</strong>指标/警报模板提供了对发布订阅层的一致视图。</li><li id="0056" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated"><strong class="ig hi">服务发现:</strong>开箱即用，而不是每个客户端应用程序都必须处理它。</li><li id="12f1" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated"><strong class="ig hi">优化配置:</strong>某些配置(如默认值)可以自动实施，冲突的配置可以自动纠正。</li><li id="746e" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated"><strong class="ig hi">拦截优势:</strong>众多功能，如计费和成本计算、审计、损坏消息检测和删除、自动错误处理等。可以添加到这个中间层。</li><li id="8e8c" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated"><strong class="ig hi">PubSub切换的简易性:</strong>由于客户端应用程序依赖于一组统一的PubSub APIs，因此从一个PubSub切换到另一个PubSub就像更改主题引用一样简单。该库可以在切换前后在内部处理和同步状态(例如，消耗偏移)。</li></ul><p id="5c9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们选择实现100%客户端解决方案而不是代理服务有几个原因:</p><ol class=""><li id="4501" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">代理服务会带来额外的基础架构开销(对我们来说是10%-20%)，因为在创建数据副本时会有额外的一跳。</li><li id="31fb" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated">代理服务将增加从发布订阅者到消费者的端到端延迟，这对于我们的一些客户端用例来说是不可接受的。</li><li id="f068" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated">由于代理服务更复杂的性质(特别是与Pinterest的联盟状态相比)，生产一个完全客户端的库比代理服务更快。</li></ol><p id="32a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管有上述原因，但由于PSC的内部实现对客户端应用程序是透明的，因此在将来切换到或添加代理服务时没有障碍。</p><h1 id="50c9" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">PSC架构</h1><p id="759e" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">PSC的架构如图1所示。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/35fc13587b6ef7b08c7e447423e11b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mz8HDvHtAieWkGMG"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 1. PSC Architecture</figcaption></figure><p id="1531" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主要的PSC接口是PSC生产者和PSC消费者。每个PSC生产者和消费者可以管理一个或多个后端(Kafka、MemQ等。)生产者和消费者。图中的每个后端消费者都是一个PSC构造，直接使用后端PubSub的客户端库。例如，PSC Kafka消费者使用Kafka消费者库。</p><p id="c835" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PSC生产者和消费者都利用公共功能，如指标收集和报告、服务发现、环境感知、服务/设计、拦截器等。</p><h1 id="8ec8" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">突出</h1><p id="426f" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们必须做出几个设计决策来定义PSC应该如何工作。我们在本节中回顾其中的一些。</p><h2 id="38f8" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">话题URI</h2><p id="fdf6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">如前所述，我们希望用PSC解决的一个挑战是让应用程序开发人员不必解决集群发现和分配问题。出于这个原因，我们提出了主题URI的概念，作为每个PubSub主题的唯一标识符。它可以是UUID的形式或任何其他商定的格式。这是资源名称约定的一个示例:</p><pre class="kw kx ky kz fd lz ma mb mc aw md bi"><span id="6e9e" class="ll js hh ma b fi me mf l mg mh">protocol:/rn:service:environment:cloud_region:cluster:topic. </span></pre><p id="3f4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如:</p><pre class="kw kx ky kz fd lz ma mb mc aw md bi"><span id="5107" class="ll js hh ma b fi me mf l mg mh">plaintext:/rn:kafka:prod:aws_us-west-1:shopping:transaction</span></pre><p id="d559" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">必要时，PSC生产者和消费者使用PSC的发现模块将该主题URI转换为适当的PubSub端点。请注意，用于消息消费/生产的安全协议也包含在URI中—这消除了在每个应用程序的基础上重复配置特定于协议的配置(例如SSL配置)的需要，从而简化了客户端登录过程并防止了错误配置。</p><h2 id="6b34" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">发布订阅覆盖范围</h2><p id="b264" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">根据设计，PSC生产者或消费者在创建时不会绑定到任何特定的PubSub实现或集群。例如，这与在创建时用引导服务器配置Kafka生产者或消费者的方式不同。这意味着一个PSC生产者或消费者可以连接到潜在不同类型的多个PubSub集群。</p><h2 id="fb14" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">配置</h2><p id="d485" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">PSC配置涵盖了来自不同PubSub系统的常见配置，同时提供了一个传递选项来注入与特定PubSub客户端相关的配置。</p><p id="b2cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PSC自带一套专用的配置。这些配置不需要任何翻译，因为它们与任何后端PubSub行为无关。例如，度量报告、启用/禁用自动解析等的配置。</p><h2 id="e8e7" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">蜜蜂</h2><p id="f46c" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">由于Kafka是Pinterest的主要PubSub技术，并且应用程序开发人员已经熟悉了它的客户端库，我们决定尽可能接近Kafka APIs signature。</p><h2 id="9e79" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">可插拔性</h2><p id="1a2b" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">假设PSC是一个通用的客户端库，那么提供可插拔性作为第一类特性是很重要的，在这里可以加载额外的PubSub客户端库或额外的特性。PSC中的可插拔模块包括:</p><ul class=""><li id="7d7f" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb ku ji jj jk bi translated">PubSub生产者/ PubSub消费者装载新的PubSub客户端库。</li><li id="4781" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated">集群端点发现到发布订阅端点的板载自定义发现方法。</li><li id="6820" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated">环境提供商到板载自定义环境规范实施(例如AWS EC2)。这有助于自动配置客户端功能的不同方面(例如，基于位置、实例大小等)。)</li><li id="790b" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb ku ji jj jk bi translated">拦截器装载定制模块，在发送/接收消息时起作用。</li></ul><h2 id="d731" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">交易生产者</h2><p id="bd22" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">假设PSC客户端到PubSub集群的连接不是在创建时实现的，而是在实际需要连接到PubSub集群时实现的(例如，当发送消息或轮询消息时)，事务性PSC生产者的状态转换与诸如Kafka的PubSub系统的事务性生产者的状态转换不完全匹配，在Kafka中，客户端在初始化时立即连接到单个Kafka集群。</p><p id="842d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PSC客户端作为PubSub客户端库的包装器工作(例如Kafka生产者/消费者)。虽然PSC客户端在创建时并不直接绑定到PubSub集群，但后端客户端是这样的。因为后端生产者是直接依赖于PubSub生产者的实体(例如Kafka生产者)，所以它的事务状态需要与PubSub生产者的事务状态同步。因此，当涉及事务API时，我们必须为PSC生产者和后端生产者实现状态图，以便与PubSub生产者(例如Kafka生产者)保持一致。</p><h2 id="aba3" class="ll js hh bd jt lm ln lo jx lp lq lr kb ip ls lt kf it lu lv kj ix lw lx kn ly bi translated">Apache Flink集成</h2><p id="cd47" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><a class="ae jl" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink ️ </a>是Pinterest的流媒体平台，支持越来越多的用例。为了确保PSC的广泛采用，我们实现了一个Flink PSC连接器(基于Flink Kafka连接器实现)。由于该连接器使用主题URIs来引用PubSub主题，因此我们实现了一种转换机制，以便Flink PSC生产者和消费者可以从Flink Kafka生产者和消费者生成的快照(检查点、保存点)中恢复。</p><h1 id="6ff3" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">未来的工作</h1><p id="96be" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">随着PSC的采用，我们已经开始看到我们之前描述的好处。然而，我们仍然需要完成路线图中的其他几个里程碑。我们和应用程序所有者从PSC获得的一个主要好处是，我们可以轻松地对PSC的内部进行更改，以开发新功能，并使用简单的依赖关系更新来推广这些新功能。即将推出的PSC功能包括:</p><ol class=""><li id="4c9c" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">自动错误处理和配置更新:PSC可以在需要时自动更新相关配置。例如，当启用Kafka producer的幂等性时，需要相应地设置一些其他配置。此外，当后端客户端抛出某些错误时，PSC会提供一个额外的层，可以在其中实现自动解决此类错误的逻辑。例如，有时客户端可能无法正确轮换其SSL证书(我们已经看到Flink客户端观察到这个问题)。在这种情况下，重置客户端是一个破坏性远远小于向应用程序冒泡异常的选项。PSC提供了错误处理框架，将异常与适当的处理策略(跳过、抛出、重试、重置等)联系起来。).</li><li id="bfb4" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated">消息审计和损坏处理:使用PSC体系结构，可以使用生产者/消费者拦截器来跟踪数据流的沿袭和沿途损坏的位置，从而实现这一可选特性。</li><li id="cdeb" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated">动态客户端重新配置:可以优化某些客户端配置和设置，例如，通过分析吞吐量(例如，可以持续监控消费者的轮询超时或生产者的批处理大小或批处理持续时间，并根据流量模式的变化进行更新，以优化PubSub管道的健康状况)。我们还计划使用一个集中的配置模型来动态地推动全局和特定的配置变更。</li><li id="3d45" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated">无缝后端切换:当一个PubSub主题从一种PubSub类型转移到另一种PubSub类型时，PSC也应该能够迁移状态，比如消费者偏移量。</li></ol><p id="f320" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还计划用C++、Python和Go等其他语言实现PSC。我们还开始了开源项目的进程，以吸引更广泛的社区参与。</p><h1 id="4585" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">确认</h1><p id="3a53" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">如果没有Ambud Sharma的持续和重要的设计和技术支持，PSC的现状是不可能的。平-林敏也为项目的设计和实施做出了重大贡献。特别感谢测井平台和Xenon平台团队、王春燕和戴夫·伯吉斯的持续指导、反馈和支持。</p><p id="e979" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">免责声明</strong></p><p id="fd45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">阿帕奇️、阿帕奇卡夫卡、卡夫卡、阿帕奇Flink和Flink是阿帕奇软件基金会的商标。</p><p id="17ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mi">要在Pinterest了解更多关于工程的知识，请查看我们的</em> <a class="ae jl" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="mi">工程博客</em> </a> <em class="mi">，并访问我们的</em><a class="ae jl" href="https://www.pinterestlabs.com/?utm_source=medium&amp;utm_medium=blog-link&amp;utm_campaign=hashemian-xiang-march-15-2022" rel="noopener ugc nofollow" target="_blank"><em class="mi">Pinterest Labs</em></a><em class="mi">网站。要查看和申请空缺职位，请访问我们的</em> <a class="ae jl" href="https://www.pinterestcareers.com/?utm_source=medium&amp;utm_medium=blog-link&amp;utm_campaign=hashemian-xiang-march-15-2022" rel="noopener ugc nofollow" target="_blank"> <em class="mi">职业</em> </a> <em class="mi">页面。</em></p></div></div>    
</body>
</html>