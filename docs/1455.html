<html>
<head>
<title>Buffered Channels In Go — What Are They Good For?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的缓冲通道——它们有什么用？</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/buffered-channels-in-go-what-are-they-good-for-43703871828?source=collection_archive---------2-----------------------#2017-07-10">https://medium.com/capital-one-tech/buffered-channels-in-go-what-are-they-good-for-43703871828?source=collection_archive---------2-----------------------#2017-07-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6ac9" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">绝对有的东西！</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/c23132f2ead2a5a9ee721d72b006c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeIY9mI3XAtyMayV7YGwKw.png"/></div></div></figure><p id="4d52" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" rel="noopener" href="/@jon_43067"> <strong class="jk hi"> <em class="kf">连载三上围棋</em> </strong> </a></p><p id="00c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在之前的一篇博客文章中，我们讨论了如何构建一个无界的通道，在这个通道中写入数据永远不会阻塞。它建立在两个无缓冲通道、一个goroutine、一个slice和几个闭包之上。</p><p id="0bb7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">值得注意的是缺少一个缓冲通道。缓冲通道永远不会有无限的缓冲区。正确使用缓冲通道意味着您必须处理这样的情况，即缓冲区已满，并且您的写例程阻塞等待读例程。那么，缓冲通道的正确用法是什么呢？为什么在Go的设计中包含了它们？</p><p id="7fd2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">缓冲通道的情况很微妙。用一句话来概括:</p><p id="38b5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">当您知道您已经启动了多少个go routine，想要限制您将要启动的go routine的数量，或者想要限制正在排队的工作量时，缓冲通道非常有用。</strong></p><p id="0ac2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当您希望从已经启动的一组goroutines中收集数据或者希望限制并发使用时，缓冲通道非常有用。它们还有助于管理系统排队等待的工作量，防止您的服务落后和不堪重负。这里有几个例子来说明如何使用它们。</p><h2 id="971a" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">并行处理</strong></h2><p id="ca8d" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">goroutines的一个常见模式是扇出。当您想要将相同的数据应用于多个算法时，您可以为每个子任务启动一个goroutine，然后在它们完成时将数据收集回来。例如，您可能希望通过多种评分算法处理相同的数据，并返回所有的分数，或者从多个微服务中提取数据以组成一个页面。缓冲通道是从子任务收集数据的理想方式。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/08e25592b23c6ba4c7c4d99fba4d863e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LH06ybIjB6xI5e9oLcuP1g.png"/></div></div></figure><p id="d493" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如前一篇博文所述，Go没有泛型，所以我们将使用<strong class="jk hi"> <em class="kf">接口{} </em> </strong>作为占位符类型。</p><p id="6a3f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">代码很简单。首先我们定义一个新的类型，<strong class="jk hi"> <em class="kf"> Evaluator </em> </strong>，它是一个函数，接受一个值，返回一个值和一个错误。这不是必需的，但它使理解代码变得更容易。</p><p id="a65f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的函数<strong class="jk hi"><em class="kf">DivideAndConquer</em></strong>接收一部分<strong class="jk hi"> <em class="kf">评估者</em> </strong>以及将要发送给他们每个人的数据。我们创建了两个缓冲通道，一个用来保存有效响应，另一个用来保存错误。接下来，我们为每个<strong class="jk hi"> <em class="kf">评估器启动一个新的goroutine。</em> </strong></p><p id="263a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">(注意，我们将</em> <strong class="jk hi"> <em class="kf"> v </em> </strong> <em class="kf">传递给goroutine，以便每个goroutine都引用不同的</em> <strong class="jk hi"> <em class="kf">评估器</em></strong><em class="kf">；在</em><strong class="jk hi"><em class="kf">a for</em></strong><em class="kf">循环中启动goroutines时的一个常见问题是在goroutines内部使用for声明中的键或值；这将导致相同的值被传递给所有的goroutines！)</em></p><p id="db87" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在goroutine中，我们执行<strong class="jk hi"> <em class="kf">评估器</em> </strong>并将输出或错误写入适当的通道。</p><p id="8466" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦启动了所有的goroutine，我们就设置<strong class="jk hi"> <em class="kf"> out </em> </strong>和<strong class="jk hi"> <em class="kf"> errs </em> </strong>片来保存结果，循环<strong class="jk hi"> <em class="kf"> len(赋值器)</em> </strong>次来从每个go routine拉回结果或错误，然后在完成时返回<strong class="jk hi"> <em class="kf"> out </em> </strong>和<strong class="jk hi"> <em class="kf"> errs </em> </strong>。</p><p id="4fd9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通过使用缓冲通道返回值和错误，我们确保没有任何goroutines在等待主任务读取它们的输出时被暂停。缓冲区允许goroutines写然后退出。有趣的是，使用缓冲通道不再需要任何同步工具。我们知道，我们将在两个通道上准确地获得<strong class="jk hi"><em class="kf">len(evaluator)</em></strong>写操作，因此我们的主要任务就是等待一个值被写入任一通道，并将其放在适当的片上。当所有赋值器都完成后，函数返回。</p><p id="98ce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个简单的测试案例演示了我们如何使用<strong class="jk hi"><em class="kf">DivideAndConquer</em></strong>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/85992d7d565461ce4e17cdc6a1d073d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZo_fi1CJtK-YAsRlekZvw.png"/></div></div></figure><p id="d4cb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">结果以随机顺序返回，这是您并行运行它们时所期望的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lh"><img src="../Images/baaafb2fb9722ed5e92f7a542ed802f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRdx8mJDgDdwlM9eFu2QXw.png"/></div></div></figure><h2 id="922a" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">时间去了哪里？</h2><p id="edd7" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">我们的并行处理器做了它应该做的事情，但是它有一个明显的限制。如果你不想永远等待所有的子任务完成，该怎么办？让我们考虑一下从多个微服务中聚合数据的情况。如果一个微服务很慢，或者(更糟糕)挂起，我们不想冻结前端等待它的响应。即使我们只是运行评分算法，其中一个可能会有一个错误，触发缓慢的行为或无限循环。最好将每个子任务限制在一定的时间内，对于花费太长时间的子任务，返回一个错误。</p><p id="662f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了实现这个新特性，我们将使我们的赋值器类型变得更复杂一些。而不仅仅是作为<strong class="jk hi"><em class="kf">afunc(interface { })(interface { }，error) </em> </strong>的一个名字，现在是一个有两个方法的接口，<strong class="jk hi"> <em class="kf"> Evaluate </em> </strong>和<strong class="jk hi"> <em class="kf"> Name </em> </strong>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/efbca000854cafc6195f80bfed53749f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3TuuGlyJAXZNRAKIX-g1g.png"/></div></div></figure><p id="46d9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们已经将该函数移到了不同的类型中，<strong class="jk hi"><em class="kf">Evaluator func</em></strong>，它实现了<strong class="jk hi"> <em class="kf"> Evaluator </em> </strong>接口。我们希望将<strong class="jk hi"> <em class="kf">命名为</em> </strong>方法，这样我们就可以报告哪个子任务没有完成。<strong class="jk hi"><em class="kf">evaluator func</em></strong>利用Go中的一个技巧，在给定一个引用函数的变量的情况下，获取该函数的名称。如果名字返回使用r<strong class="jk hi">T29】untime。Func.Name()  </strong>不合您的口味，您可以在struct中嵌入<strong class="jk hi"><em class="kf">evaluator func</em></strong>进行自定义:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/c35151110a6e07e3b89a3eded262097b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4ldicnO_9GniRWbY98UcA.png"/></div></div></figure><p id="3eef" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是我们更新后的<strong class="jk hi"><em class="kf">DivideAndConquer</em></strong>函数:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lk"><img src="../Images/b7f8976bd75347921c9d536f2c8972b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hT5ROFC6cNXUzMij64qnbg.png"/></div></div></figure><p id="20fd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然收集结果的代码保持不变，但是goroutine逻辑变得更加复杂。每个goroutine现在创建两个大小为1的缓冲通道，<strong class="jk hi"> <em class="kf"> ch </em> </strong>和<strong class="jk hi"> <em class="kf"> ech </em> </strong>，并启动第二个goroutine。第二个goroutine运行<strong class="jk hi">评估器<em class="kf">。评估</em> </strong>并写入<strong class="jk hi"> <em class="kf"> ch </em> </strong>(如果成功)或<strong class="jk hi"> <em class="kf"> ech </em> </strong>(如果返回错误)。</p><p id="21fb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">周围的goroutine有一个<strong class="jk hi"> <em class="kf"> select </em> </strong>语句，用于检查先返回什么——结果、错误或超时。如果结果或错误先到达，我们把它们分别写到<strong class="jk hi"><em class="kf"/></strong>或<strong class="jk hi"> <em class="kf">错误</em> </strong>通道。如果超时，我们会创建一个新的错误来指示超时，并在<strong class="jk hi"> <em class="kf">错误</em> </strong>通道上返回。</p><p id="b864" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了利用<strong class="jk hi"> <em class="kf">的时间。在</em> </strong>之后，我们需要启动第二个goroutine，并通过渠道与它沟通。但是不明显的是为什么<strong class="jk hi"> <em class="kf"> ch </em> </strong>和<strong class="jk hi"> <em class="kf"> ech </em> </strong>通道被缓冲。为什么不使用无缓冲通道呢？答案是我们不想泄露任何goroutines。虽然Go runtime能够一次处理成千上万个goroutine，但是每个Go routine确实会使用一些资源，所以在不必要的时候，您不希望让它们闲置。如果你这样做，一个长时间运行的围棋程序将开始表现不佳。</p><p id="d7be" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">请记住，非缓冲通道会暂停写入goro routine，直到另一个goro routine进行读取。如果超时在<strong class="jk hi"> <em class="kf">评估器</em> </strong>完成执行之前触发，读取将永远不会发生，因为读取这些通道的唯一位置是在外部goroutine的select语句中，并且外部goroutine在超时触发后退出。这意味着使用非缓冲通道将导致内部goroutine在超时时永远等待，从而泄漏goroutine。同样，缓冲通道证明是有用的，因为我们确切地知道我们可以预期多少次写入。</p><p id="5b93" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个显示超时的简单测试:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ll"><img src="../Images/dcbae3a16de2282a5378dc65725cf737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4dnE_BEMDsOfcPuZ8ZQgA.png"/></div></div></figure><p id="310b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将返回输出:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lh"><img src="../Images/eb8b3163aec7df655730d07c5d39189c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsR5yLUCgoSJaqpUPvELKg.png"/></div></div></figure><h2 id="db2c" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">创建池</strong></h2><p id="1013" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">缓冲通道有用的另一种情况是在创建对象池时。当您有创建成本很高的对象时(比如大型内存缓冲区)，或者当您希望限制同时执行时(比如不要让太多的请求淹没一个服务)，应该使用池。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/a2600f1362f7f62675d9f65ff7ab707f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lU2K7vqXrjip5iWxf9gm8w.png"/></div></div></figure><p id="5195" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里的想法是使用缓冲通道作为池。<strong class="jk hi"> <em class="kf"> NewPool </em> </strong>函数接受一个<strong class="jk hi"> <em class="kf"> Factory </em> </strong>用计数相同的项填充池(如果这些项在功能上不相同，那么池的客户机的行为将取决于它们得到哪个项，这是一个坏主意)。当调用<strong class="jk hi"> <em class="kf">借用</em> </strong>方法时，从通道中读取一个值并返回。如果池中的所有项目都已被使用，通道读取将阻塞，直到通过<strong class="jk hi"> <em class="kf"> Return </em> </strong>方法将一个值放回池中。</p><p id="2f54" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你不想永远等待(在生产代码中，你可能永远也不想永远等待某事发生)，<strong class="jk hi"><em class="kf">BorrowWithTimeout</em></strong>允许你指定一个时间。等待项目返回池中的持续时间。通过不要永远等待，您向您的客户端进程提供了有价值的信息，即您当前的进程做了太多的工作。这被称为<em class="kf">背压</em>，在构建可扩展系统时，这是一个非常重要的工具。背压让您知道系统的某个部分负载过重，或者调用过于频繁。当你看到负载增加时，防止彻底崩溃的最好方法之一就是拒绝将你无法在合理时间内处理的工作排队。</p><p id="b349" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">泳池如你所料:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lm"><img src="../Images/3d677b6f048e75c08e0818730425ea5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7JWcPxBhiXv3yB-jX9Yjw.png"/></div></div></figure><p id="66fe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当您观察输出时，您会看到三个条目被快速打印出来，然后当数字被返回到池中并被另一个goroutine获取时会有停顿。</p><h2 id="6954" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">堵住水池的漏洞</strong></h2><p id="3bf7" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">虽然这个简单的池可以工作，但它需要很多信任。它的功能就像一个公共图书馆。虽然大多数借出书籍的人做了正确的事情，并及时归还，但有些人却忘记归还。写得不好的池客户机也是如此。它们将通过不调用<strong class="jk hi"> <em class="kf"> Return </em> </strong>从池中泄漏项目。最终，这个池将会是空的，没有值可以借用。</p><p id="5004" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">另一种可能是错误的值被放回池中。这将破坏预期的契约，并导致不确定的问题。这就像你在图书馆归还的书与你借出的不一样，希望图书管理员不会注意到。</p><p id="b5a0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以扭转这个模式。我们可以像对待特殊收藏一样对待我们的馆藏项目，而不是成为一个借阅图书馆；人们只能在图书馆内访问这些项目。</p><p id="1c2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">翻译一下，我们不打算通过<strong class="jk hi"> <em class="kf">从池中返回值，借用</em> </strong>并希望它们在<strong class="jk hi"> <em class="kf">返回</em> </strong>时返回；我们将接受一个闭包并运行它。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/86ac9cb870ffa8bbcfe7651d3b202592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2PQSxgQfVh34dF7G34Ljg.png"/></div></div></figure><p id="9e03" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通过以这种方式构建池，我们不仅使池更难损坏，还使编写客户端更容易，因为他们不再需要为池记账:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/86679db67cea473fe19462bfe8abe0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXZtHgoeQiZSkQGFkrGC3A.png"/></div></div></figure><p id="bd4c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如您所见，缓冲通道在设计用于智能处理负载的系统中确实有一席之地。它们可以帮助您管理系统中的负载，进而帮助您保持服务正常运行。</p><p id="5890" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="kf">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em>T3】</strong></p><h1 id="043b" class="lp kh hh bd ki lq lr ls km lt lu lv kq in lw io kt iq lx ir kw it ly iu kz lz bi translated">附加链接</h1><ul class=""><li id="66c3" class="ma mb hh jk b jl lb jo lc jr mc jv md jz me kd mf mg mh mi bi translated"><a class="ae ke" rel="noopener" href="/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5">闭包是Go的泛型</a></li><li id="4af1" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><a class="ae ke" rel="noopener" href="/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd">在Go中构建无界通道</a></li><li id="e8c2" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><a class="ae ke" href="https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中构建REST API</a></li></ul></div></div>    
</body>
</html>