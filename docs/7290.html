<html>
<head>
<title>Ruby’s New JIT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby的新JIT</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/rubys-new-jit-91a5c864dd10?source=collection_archive---------0-----------------------#2018-02-14">https://medium.com/square-corner-blog/rubys-new-jit-91a5c864dd10?source=collection_archive---------0-----------------------#2018-02-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="eb4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">克鲁比刚吃了JIT！</em></p><blockquote class="jd"><p id="5fef" class="je jf hh bd jg jh ji jj jk jl jm jb dx translated">注意，我们已经行动了！这篇文章现在位于<a class="ae jn" href="https://developer.squareup.com/blog/rubys-new-jit" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="4f8d" class="pw-post-body-paragraph ie if hh ig b ih jo ij ik il jp in io ip jq ir is it jr iv iw ix js iz ja jb ha bi translated">已经有很多为CRuby实现JIT的尝试，cru by是Ruby的参考实现。到目前为止，还没有合并。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9bb6" class="kc kd hh jy b fi ke kf l kg kh">                   ,---.    ,---.     .-./`)  .-./`) ,---------. <br/>  .     '     ,    |    \  /    |     \ '_ .')\ .-.')\          \ <br/>    _________      |  ,  \/  ,  |    (_ (_) _)/ `-' \ `--.  ,---' <br/>   /_\/_ _ \/_\    |  |\_   /|  |      / .  \  `-'`"`    |   \     <br/>    \ \    / /     |  _( )_/ |  | ___  | '`|   .---.     :   :    <br/>  ,   \\  //   .   | (_ J _) |  ||   | |   '   |   |     |   |    <br/>        \/         |  (_,_)  |  ||   `-'  /    |   |     |   | <br/>     ,      .      |  |      |  | \      /     |   |     |   |  <br/>                   '--'      '--'  `-..-'      '---'     '---'</span></pre><p id="519a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">TL；DR </strong> : Ruby 2.6将有一个可选的<code class="du ki kj kk jy b">--jit</code>标志，它将增加启动时间并占用更多内存，以换取一旦预热后的极快速度。</p><h1 id="de4b" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">以前的Ruby JIT尝试</h1><p id="2f33" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">以前一些针对Ruby的JIT尝试，如<a class="ae jn" href="https://github.com/imasahiro/rujit#readme" rel="noopener ugc nofollow" target="_blank"> rujit </a>，已经成功地加速了Ruby，但代价是内存的过度使用。其他尝试，如<a class="ae jn" href="https://github.com/rubyomr-preview/rubyomr-preview#readme" rel="noopener ugc nofollow" target="_blank"> OMR + Ruby </a>，使用现有的JIT库，如<a class="ae jn" href="https://github.com/eclipse/omr#readme" rel="noopener ugc nofollow" target="_blank"> Eclipse OMR </a>。另一个例子，<a class="ae jn" href="https://github.com/k0kubun/llrb#readme" rel="noopener ugc nofollow" target="_blank"> llrb </a>，使用了<a class="ae jn" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM </a>附带的JIT库。这些实现的最大问题是JIT库是移动的目标，并将Ruby的生存与这些底层JIT项目的未知未来联系在一起。</p><h1 id="4e50" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">巨大的飞跃:RTL·米吉特</h1><p id="a015" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">马卡罗夫对Ruby性能并不陌生。他在Ruby 2.4中对哈希表的重新实现大大加快了哈希的速度。</p><p id="2b01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2017年，马卡罗夫承担了一个新的重大项目，名为<a class="ae jn" href="https://github.com/vnmakarov/ruby/tree/rtl_mjit_branch#readme" rel="noopener ugc nofollow" target="_blank"> RTL MJIT </a>，重写了Ruby的中间表示(IR)的工作方式，同时增加了一个JIT。在这个令人难以置信的雄心勃勃的项目中，现有的YARV指令被一个全新的寄存器传输语言(RTL)指令集完全取代。马卡罗夫还创建了一个名为MJIT的JIT，它从RTL指令中产生C代码，然后用现有的编译器将C代码编译成本机代码。</p><p id="26ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">马卡洛夫实现的问题在于，全新的RTL指令意味着Ruby内部的重大重写。可能需要几年的时间来完善这项工作，使其稳定，并准备好与Ruby合并。Ruby 3甚至可能会发布新的RTL指令，但还没有决定(可能要几年后)。</p><h1 id="3e87" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">JIT合并成了Ruby: YARV MJIT</h1><p id="2280" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">Takashi Kokubun对JIT和Ruby性能也不陌生。他是llrb JIT的作者，并在Ruby 2.5中将Ruby的ERB和RDoc加速了好几倍。</p><p id="6075" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kokubun继承了Makarov在RTL MJIT上的工作，并提取了JIT部分，同时保持了Ruby现有的YARV字节码。他还把MJIT精简到最小形式，没有高级优化，所以它的引入不会对Ruby的其他部分造成大的破坏。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="450d" class="kc kd hh jy b fi ke kf l kg kh">       __  __              _            ___            _____  <br/>      |  \/  |          _ | |          |_ _|          |_   _| <br/>      | |\/| |         | || |           | |             | |   <br/>      |_|__|_| _____   _\__/   _____   |___|   _____   _|_|_  <br/>     _|"""""|_|"""""|_|"""""|_|"""""|_|"""""|_|"""""|_|"""""|<a class="ae jn" href="https://en.wiktionary.org/wiki/%E5%80%AD" rel="noopener ugc nofollow" target="_blank">倭</a><br/>     "`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'</span></pre><p id="eeb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kokubun的作品被<a class="ae jn" href="https://github.com/ruby/ruby/commit/ed935aa5be0e5e6b8d53c3e7d76a9ce395dfa18b" rel="noopener ugc nofollow" target="_blank">合并到Ruby </a>中，将于2018年圣诞节与Ruby 2.6一同发布。如果你现在想尝试JIT，你可以用Ruby的每夜构建来做。目前性能的提升相当有限，但是在Ruby 2.6发布之前还有足够的时间来添加优化。Kokubun的安全、渐进改善策略奏效了。露比有JIT！</p><h1 id="662a" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">它是如何工作的</h1><h2 id="60ee" class="kc kd hh bd km ln lo lp kq lq lr ls ku ip lt lu ky it lv lw lc ix lx ly lg lz bi translated">获得YARV说明</h2><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ma"><img src="../Images/cd7e665228197539cce4807c9f02ee5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qCr7d1gsFoQUU-S299MkA.png"/></div></div></figure><p id="0eb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ruby必须经过几个步骤才能运行你的代码。首先，代码被标记化、解析并编译成YARV指令。这部分过程大约占Ruby程序总时间的30%。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mi"><img src="../Images/8693e18d7b43a9be9dac14898d50e38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HTWzAkN2oBsHeUAucjT6-Q.gif"/></div></div></figure><p id="9a77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以从stdlib中使用RubyVM::InstructionSequence和Ripper来查看这些步骤。</p><figure class="jt ju jv jw fd mb"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="5764" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像<a class="ae jn" href="https://github.com/ko1/yomikomu#readme" rel="noopener ugc nofollow" target="_blank"> yomikomu </a>和<a class="ae jn" href="https://github.com/Shopify/bootsnap#readme" rel="noopener ugc nofollow" target="_blank">bootssnap</a>这样的项目展示了如何通过将YARV指令缓存到磁盘来加速Ruby。这样做的话，在第一次运行Ruby脚本之后，指令就不必被解析和编译成YARV指令，除非代码发生了变化。这并没有在第一次运行时提高Ruby的速度，但是在没有代码更改的情况下，后续的执行将会快30%左右——因为它们可以跳过解析和编译成YARV指令。</p><p id="f7cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种缓存编译后的YARV指令的策略实际上与JIT无关，但是这种策略将会在Rails 5.2中使用(通过bootsnap)，并且很可能在Ruby的未来版本中使用。JIT只有在YARV指令存在后才发挥作用。</p><h2 id="76c7" class="kc kd hh bd km ln lo lp kq lq lr ls ku ip lt lu ky it lv lw lc ix lx ly lg lz bi translated">JIT编译YARV指令</h2><p id="6a10" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">一旦YARV指令存在，RubyVM就有责任在运行时将这些指令转换成适合您所使用的操作系统和CPU的本机代码。这个过程消耗了运行一个Ruby程序大约70%的时间，所以它是运行时的主体。</p><p id="56e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是JIT发挥作用的地方。不需要每次遇到YARV指令时都进行评估，某些调用可以转换成本机代码，所以当RubyVM第二次或以后看到它时，可以直接使用本机代码。</p><blockquote class="ml mm mn"><p id="1c67" class="ie if jc ig b ih ii ij ik il im in io mo iq ir is mp iu iv iw mq iy iz ja jb ha bi translated">"这是一个ERB模板，生成Ruby代码，生成C代码，生成JIT-ed C代码."~ <a class="ae jn" href="https://github.com/ruby/ruby/blob/trunk/tool/ruby_vm/views/mjit_compile.inc.erb" rel="noopener ugc nofollow" target="_blank"> mjit_compile.inc.erb </a></p></blockquote><p id="48a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用MJIT，某些Ruby YARV指令被转换成C代码，放入一个<code class="du ki kj kk jy b">.c</code>文件，由GCC或Clang编译成一个<code class="du ki kj kk jy b">.so</code>动态库文件。RubyVM可以在下一次看到相同的YARV指令时使用来自动态库的缓存的、预编译的本机代码。</p><h2 id="71b9" class="kc kd hh bd km ln lo lp kq lq lr ls ku ip lt lu ky it lv lw lc ix lx ly lg lz bi translated">去优化</h2><p id="3f39" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">然而，Ruby是一种动态语言，甚至核心类方法也可以在运行时重新定义。需要有某种机制来检查缓存在本机代码中的调用是否已被重新定义。如果调用已经被重新定义，则需要刷新缓存，并且需要解释指令，就好像没有JIT一样。当发生变化时，这种退回到评估指令的过程称为<a class="ae jn" href="http://chrisseaton.com/rubytruffle/deoptimizing/" rel="noopener ugc nofollow" target="_blank">去优化</a>。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="96f0" class="kc kd hh jy b fi ke kf l kg kh">##<br/># YARV instructions for `3 + 3`:</span><span id="9970" class="kc kd hh jy b fi mr kf l kg kh">RubyVM::InstructionSequence.compile('3 + 3').to_a.last<br/>#=&gt; [1,<br/> :RUBY_EVENT_LINE,<br/> [:putobject, 3],<br/> [:putobject, 3],<br/> [:opt_plus, {:mid=&gt;:+, :flag=&gt;16, :orig_argc=&gt;1}, false],<br/> [:leave]]</span><span id="6aab" class="kc kd hh jy b fi mr kf l kg kh">##<br/># MJIT C code created from the `:opt_plus` instruction above:</span><span id="9813" class="kc kd hh jy b fi mr kf l kg kh">VALUE opt_plus(a, b) {<br/>  if (not_redefined(int_plus)) {<br/>    return a + b;<br/>  } else {<br/>    return vm_exec();<br/>  }<br/>}</span></pre><p id="c322" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，在上面的例子中，如果调用被重新定义，MJIT产生的C代码将会去优化和重新评估指令。这利用了这样一个事实，即大多数时候我们没有重新定义加法，所以我们可以使用编译好的本机代码和JIT。每次评估C代码时，它都会确保它所优化的操作没有改变。如果有变化，它会被去优化，指令会被RubyVM重新评估。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ms"><img src="../Images/ff9e007cba9e7e9b8071f16ff4e5544b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P6upRIGW1QFIKyKcCVCnPg.gif"/></div></div></figure><h1 id="25ae" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用JIT</h1><p id="e915" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">您可以通过添加<code class="du ki kj kk jy b">--jit</code>标志来使用JIT。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="35ea" class="kc kd hh jy b fi ke kf l kg kh">$ ruby --jit -e "puts RubyVM::MJIT.enabled?"<br/>true</span></pre><p id="b58b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有许多与JIT相关的试验性标志选项:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="02b5" class="kc kd hh jy b fi ke kf l kg kh">MJIT options (experimental):<br/>  --jit-warnings  Enable printing MJIT warnings<br/>  --jit-debug     Enable MJIT debugging (very slow)<br/>  --jit-wait      Wait until JIT compilation is finished everytime (for testing)<br/>  --jit-save-temps<br/>                  Save MJIT temporary files in $TMP or /tmp (for testing)<br/>  --jit-verbose=num<br/>                  Print MJIT logs of level num or less to stderr (default: 0)<br/>  --jit-max-cache=num<br/>                  Max number of methods to be JIT-ed in a cache (default: 1000)<br/>  --jit-min-calls=num<br/>                  Number of calls to trigger JIT (for testing, default: 5)</span></pre><p id="fa91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以在IRB中交互地尝试JIT。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8717" class="kc kd hh jy b fi ke kf l kg kh">$ ruby --jit -S irb<br/>irb(main):001:0&gt; RubyVM::MJIT.enabled?<br/>=&gt; true</span></pre><p id="0a01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这在早期似乎有点问题，但是JIT也可以和Pry一起工作。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="069e" class="kc kd hh jy b fi ke kf l kg kh">$ ruby --jit -S pry<br/>pry(main)&gt; RubyVM::MJIT.enabled?<br/>=&gt; true</span></pre><h1 id="341c" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">启动时间</h1><p id="5050" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">在考虑使用新的JIT时，启动时间是需要考虑的一个因素。用JIT启动Ruby要多花六倍的时间。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mt"><img src="../Images/0234c1d90e4b8190f9e2de9ea7db04a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wUhkaGWaHUz8xswNfzj1g.png"/></div></div></figure><p id="c61b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你用<a class="ae jn" href="https://gcc.gnu.org/" rel="noopener ugc nofollow" target="_blank"> GCC </a>还是<a class="ae jn" href="https://clang.llvm.org/" rel="noopener ugc nofollow" target="_blank"> Clang </a>也会影响启动时间。目前，GCC比Clang快得多，但在没有JIT的情况下，它仍然比Ruby慢三倍多。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mt"><img src="../Images/52944e3cf7ef82a9f20059e445113d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBOJTO6jiHn4B9-DK4kRfw.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx">Note: The --jit-cc flag may have to be removed for compatibility with the precompiled MJIT header.</figcaption></figure><p id="aef0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，您可能不想将JIT用于寿命非常短的程序。JIT不仅需要启动，而且要有效，还需要时间预热。长时间运行的程序是JIT的亮点——它可以预热并有机会使用缓存的本地代码。</p><h1 id="969e" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">表演</h1><p id="17c9" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">2015年，Matz宣布了3x3 initiate，使Ruby 3.0比Ruby 2.0快三倍(3倍)。Ruby 3x3的官方基准是<a class="ae jn" href="https://github.com/mame/optcarrot#readme" rel="noopener ugc nofollow" target="_blank">opt胡萝卜</a>，这是一个用纯Ruby编写的任天堂模拟器。</p><p id="c693" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">真正的任天堂运行速度是60 FPS。<a class="ae jn" href="https://github.com/ruby/ruby/commit/ed935aa5be0e5e6b8d53c3e7d76a9ce395dfa18b" rel="noopener ugc nofollow" target="_blank"> Kokubun在一个4.0 GHz i7–4790k的8核处理器上进行的opt胡萝卜</a>基准测试显示，Ruby 2.0的速度为35 FPS。Ruby 2.5在46 FPS时性能提升了30%。启用JIT后，Ruby 2.6在63 FPS时比Ruby 2.0快80%。这是opt carrot(<em class="jc">opt</em>imization<em class="jc">胡萝卜</em>)的胡萝卜部分，这是一款可以以60+ FPS玩的NES游戏。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es my"><img src="../Images/39f49a497a57a8456bc26e365449163a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFb518ZaCH16BEKNdhrBOQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx">optcarrot FPS comparison</figcaption></figure><p id="d3ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个很大的进步！给Ruby添加JIT已经让Ruby 2.6朝着3x3的目标前进了一大步。最初的JIT改进是相当适度的，因为MJIT的引入没有许多在最初的RTL MJIT中发现的优化。即使没有这些优化，也有显著的性能改进。随着更多优化的加入，这些改进将变得更加深远。</p><p id="a0e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的基准测试显示了optro在各种Ruby实现中前180个视频帧的性能。Ruby 2.0和2.5表现相当平淡。<a class="ae jn" href="https://github.com/oracle/truffleruby#readme" rel="noopener ugc nofollow" target="_blank"> TruffleRuby </a>、<a class="ae jn" href="http://jruby.org/" rel="noopener ugc nofollow" target="_blank"> JRuby </a>和<a class="ae jn" href="https://github.com/topazproject/topaz" rel="noopener ugc nofollow" target="_blank"> Topaz </a>是已经有JIT的Ruby实现。您可以看到JIT实现(下面的绿色、红色和紫色线)启动缓慢，然后需要几帧时间开始预热。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div class="er es mz"><img src="../Images/63128a2d676d6b1c97435069f9ec586c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*zP1-IryyP57BBU_6K4i_OA.png"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Image by Yusuke Endoh, distributed under MIT license.</figcaption></figure><p id="9a04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预热之后，<a class="ae jn" href="https://github.com/oracle/truffleruby#readme" rel="noopener ugc nofollow" target="_blank"> TruffleRuby </a>凭借其高度优化的<a class="ae jn" href="http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html" rel="noopener ugc nofollow" target="_blank"> GraalVM </a> JIT遥遥领先。(另见<a class="ae jn" href="https://github.com/oracle/truffleruby/blob/master/doc/user/svm.md" rel="noopener ugc nofollow" target="_blank">truffle ruby with substrate VM</a>，它显著改善了启动时间，预热后速度略有下降。)</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div class="er es na"><img src="../Images/08d5254ac354fee22d35c79a2fb32545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*PS6hYj6EonBiZWQnpKRIxA.png"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Image by Yusuke Endoh, distributed under MIT license.</figcaption></figure><p id="4fee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">官方optroub基准测试还没有包括启用了JIT的Ruby 2.6-dev，但是在这一点上它还无法与TruffleRuby竞争。TruffleRuby远远领先于其他产品，但还没有准备好投入生产。</p><p id="3427" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">修改optcarrot基准以显示启用了基于GCC的JIT的Ruby 2.6-dev，我们可以看到它需要几帧来预热。在预热JIT之后，即使当前大多数优化都没有启用，它还是领先了。请注意绿线开始时很慢，但随后逐渐上升，并保持领先。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div class="er es nb"><img src="../Images/6f60e7ae91a7d39295b53ccd70dc12a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*cTqiC5-mUJtFuyzT8cmLYA.png"/></div></figure><p id="2de8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们放大，我们可以看到带有GCC JIT的Ruby 2.6-dev在大约80帧之后达到了转折点，领先于Ruby 2.5仅仅是基准测试的几秒钟。</p><figure class="jt ju jv jw fd mb er es paragraph-image"><div class="er es nc"><img src="../Images/7fad2966c573bb58065cd2feff58e97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*5ikTyjV4X0rN5MNRu3pnQg.png"/></div></figure><p id="a709" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你的Ruby程序是短命的，几秒钟后就退出了，那么你可能不想启用新的JIT。如果您的程序运行时间较长，并且您有一点内存空间，那么JIT可能会带来显著的性能优势。</p><h1 id="b7c0" class="kl kd hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">未来</h1><p id="b4df" class="pw-post-body-paragraph ie if hh ig b ih li ij ik il lj in io ip lk ir is it ll iv iw ix lm iz ja jb ha bi translated">在Square，我们在内部广泛使用Ruby，我们维护着<a class="ae jn" href="https://github.com/square?language=ruby" rel="noopener ugc nofollow" target="_blank">几十个开源Ruby项目</a>，包括<a class="ae jn" href="https://github.com/square/connect-ruby-sdk#readme" rel="noopener ugc nofollow" target="_blank">Square Connect Ruby SDK</a>。所以对我们来说，克鲁比的新JIT是令人兴奋的。在今年圣诞节发布之前，仍然有许多问题需要解决，还有许多低悬的优化需要利用。请在Ruby trunk或夜间快照上试用JIT now，并<a class="ae jn" href="https://bugs.ruby-lang.org/projects/ruby-trunk/issues" rel="noopener ugc nofollow" target="_blank">报告您遇到的任何问题</a>。</p><p id="17cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">马卡罗夫和<a class="ae jn" href="https://github.com/k0kubun" rel="noopener ugc nofollow" target="_blank"> Takashi Kokubun </a>应该为推动Ruby前进而受到高度赞扬，他们加入了JIT，这将在未来几年继续带来新的速度改进！</p><p id="d59d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">想要更多？</em> <a class="ae jn" href="https://www.workwithsquare.com/developer-newsletter.html?channel=Online%20Social&amp;sqmethod=Blog" rel="noopener ugc nofollow" target="_blank"> <em class="jc">注册</em> </a> <em class="jc">获取我们每月的开发者简讯。</em></p></div></div>    
</body>
</html>