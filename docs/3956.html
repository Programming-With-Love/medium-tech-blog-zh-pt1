<html>
<head>
<title>Web Communication Frameworks Over the Years</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多年来的Web通信框架</h1>
<blockquote>原文：<a href="https://medium.com/globant/web-communication-frameworks-over-the-years-ececd4ae8061?source=collection_archive---------2-----------------------#2022-08-25">https://medium.com/globant/web-communication-frameworks-over-the-years-ececd4ae8061?source=collection_archive---------2-----------------------#2022-08-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="0a81" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">合著者:<a class="ae jg" rel="noopener" href="/@abhinesh.gour_55961"> </a> <a class="jh ji ge" href="https://medium.com/u/b6431df99193?source=post_page-----ececd4ae8061--------------------------------" rel="noopener" target="_blank">阿比涅什·古尔</a><a class="jh ji ge" href="https://medium.com/u/10e2f33714e9?source=post_page-----ececd4ae8061--------------------------------" rel="noopener" target="_blank">尼萨尔·纳达夫</a><a class="jh ji ge" href="https://medium.com/u/8ac331c88250?source=post_page-----ececd4ae8061--------------------------------" rel="noopener" target="_blank">尼泰什·凯萨卡尔</a>和<a class="jh ji ge" href="https://medium.com/u/61ea19f31ff6?source=post_page-----ececd4ae8061--------------------------------" rel="noopener" target="_blank">拉贾旺特·普拉贾帕蒂</a></p></blockquote><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jj"><img src="../Images/6b31e8df70d8e3ee1c1adb69563c5076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxBRUnHoGIwt6jAHc4-lqw.jpeg"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx">Photo by <a class="ae jg" href="https://unsplash.com/@tvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Taylor Vick</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ef16" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="6c71" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated">远程过程调用作为网络操作模型的实际实现可以追溯到20世纪80年代早期。多年来，我们已经看到了相当多的框架演变。在本文中，我们将回顾这些框架的发展，它们的特性，以及导致新框架发展的一些限制。当我们浏览这些框架时，我们的重点是gRPC，一个Google的RPC框架，以及它的优点。</p><h1 id="b951" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak"> Unix RPC — SUN RPC </strong></h1><p id="e4cc" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="aa2e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">Unix RPC首先由Sun RPC实现，或者至少是第一个众所周知的实现。网络文件系统的整个生态系统都围绕着它。由Sun公司开发，目前被称为开放网络计算(ONC)。多年来，越来越多的组织提出了他们的RPC版本，例如，微软开发的MSRPC和Apache Avro。</p><p id="d448" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="2815" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">这最初是在20世纪80年代开发的，最后一次更新版本发布于2009年。尽管RPC作为一个框架仍然被广泛用于网络通信。</p><p id="0937" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">主要特点</strong></p><p id="58fd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">Unix RPC有一个名为rpcgen的RPC编译器，用于自动生成客户机和服务器存根。然后，它使用外部数据表示(通常称为XDR)来表示客户机和服务器存根之间共享的数据。</p><p id="b014" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它本质上支持基本的数据类型，如int、float、char等。，并提供了用于指定其他复杂数据类型的声明性语言。</p><p id="23cb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它可以在UDP或TCP上工作，UDP的参数大小限制为8192字节。如果使用UDP协议，并且客户端对其计时，那么如果出现错误，它将重新发送请求。如果使用TCP并且出现错误，则不会重新发送请求。</p><p id="939d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="7fac" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它允许在分布式环境中使用应用程序，并且不将其使用限制在单个机器/环境中。此外，这些分布式系统的开发非常简单，因为Unix RPC使用简单的语义。过程调用确保始终保留适用于应用程序的业务逻辑。由于其简单性，重新开发/重新编写代码只需要很少的工作。</p><p id="e00f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="a4b9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">虽然Unix RPC提供了许多优势，如使用分布式系统，但它也有一些限制。它产生了更多的开销，并且不能解决大多数由发行版产生的问题。它在硬件架构方面没有提供任何灵活性。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lf"><img src="../Images/42239705e480d8acfea4a2ff80b0903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vwMKOE-mIoNu3rR3qXgeQ.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="114c" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated"><strong class="ak"> Java — RMI </strong></h1><p id="6b65" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="e88d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">RMI是RPC的面向对象等价物。使用RMI，我们可以从一台机器调用或访问另一台机器的方法/对象。在分布式计算的早期，它被广泛使用。</p><p id="6af7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">JAVA RMI是用于RMI的JAVA实现API，它允许托管在两个分布式系统上的两个JVM之间的通信，它支持序列化JAVA类的传输。</p><p id="077f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="56a4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">Java RMI在1997年与Java JDK 1.1一起发布。尽管EJB仍在使用RMI，但自2014年Java 8发布以来，Java RMI API已被弃用。</p><p id="d611" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">关键特性</strong></p><p id="9558" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">RMI使用两个对象Stub和Skeleton提供应用程序之间的远程通信。存根是客户机在其上构建信息块并将该信息发送给服务器的对象。另一方面，骨架对象将请求从存根传递到远程对象。使用这些存根和骨架RMI允许一个对象从一个JVM调用方法到另一个JVM中运行的对象。</p><p id="0f7a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="892a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">Java RMI的一个主要优点是它是面向对象的，使用它可以传递完整的对象作为参数和返回值，而不仅仅是预定义的数据类型。<br/>此外，由于它在Java生态系统中，它可以作为RMI/JDBC系统移植到任何Java虚拟机，这使得它只需编写一次，就可以在任何地方执行。此外，它节省了开发人员的精力，因为所有与网络相关的功能都由Java RMI API处理。</p><p id="5fd1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="af04" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">Java RMI最大的缺点是它需要用Java编写客户机和服务器。此外，它还需要许多额外的配置，包括对象注册和遵从rmic以支持远程方法调用。由于安全限制，它提供的功能有限。此外，使用RMI处理本地和远程对象时，很难区分哪些对象是本地的，哪些是远程的。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es ls"><img src="../Images/7f4359029321dbb1b66d1acbec68a294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cq__2S2g3iB5xe7yNV4kew.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="43cf" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">CORBA- <strong class="ak">公共对象请求代理架构</strong></h1><p id="c269" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="06ca" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">公共对象请求代理体系结构是由对象管理组织(OMG)定义的标准，旨在促进部署在不同平台上的系统之间的通信。它支持不同操作系统、编程语言和计算硬件上的系统之间的协作。它使用面向对象的模型，尽管使用CORBA的系统不一定是面向对象的。CORBA是分布式对象范例的一个例子。</p><p id="b65e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它使用接口定义语言(IDL)来指定对象呈现给外部世界的接口。然后，CORBA指定了从IDL到特定实现语言(如C++或Java)的映射。</p><p id="792b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="b530" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">CORBA标准是由对象管理小组在1991年定义的。最新版本发布于2021年2月。CORBA仍然在遗留系统中使用。</p><p id="2783" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">主要特点</strong></p><p id="e157" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">CORBA使分布式系统上用不同语言编写的程序之间能够通信。它规范了本地空间(同一应用程序中)或远程空间(网络托管应用程序)中对象之间的语义。它使用接口定义语言(IDL)来指定对象的接口。它支持面向对象语言如C++、Java等的标准映射。它还支持Perl和Erlang等脚本语言的非标准映射。</p><p id="a487" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="e0e8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">CORBA的最大优点是它还允许在分布于几个系统的单个应用程序中使用不同的语言，这为不同的语言提供了全面的支持。除此之外，CORBA标准的使用也为开发者提供了一定程度的可移植性，这使得移植任何给定的API变得非常容易。</p><p id="8c99" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">这也实现了更高程度的互操作性。它确保了构建在CORBA产品之上的不同分布式应用程序可以在没有太多配置或转换的情况下进行通信。</p><p id="8cb0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="f870" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">CORBA最大的缺点之一是它对防火墙不友好。它基于IIOP，使用原始的TCP/IP连接来传输数据。</p><p id="b113" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">此外，它是当时最复杂的学习和实现框架之一。没有标准来获取命名服务的初始引用，这使得理解和维护变得更加复杂。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lt"><img src="../Images/6b28c7ba9454bef38d056ca51893a898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FvGio2b_qM2OKh-mpxidgA.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="3831" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">DCOM分布式组件对象模型</h1><p id="bd57" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="9e79" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">DCOM——分布式组件对象模型由微软开发，主要目的是允许分布式系统上的软件对象相互通信。</p><p id="7f6b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">第一个字母“D”表示DCE/RPC(分布式计算环境/远程过程调用),更具体地说是微软的增强版本，即MSRPC。</p><p id="792f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="8879" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">DCOM于1996年面向Windows 95公开推出。原生支持Windows NT 4.0、Windows 2000、XP、Server 2003，以及Windows 7、8、10、Windows Server 2008、2008 R2、2012、2012 R2、2016 DCOM仍在使用。</p><p id="a9bc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">主要特征</strong></p><p id="67cc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">DCOM是CORBA的主要替代产品，它提供了一些流动的关键功能，如封送处理(通过网络和分布式垃圾收集对方法调用的参数和返回值进行序列化和反序列化),确保接口的客户端持有的引用在不使用时被释放。</p><p id="b12b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优势</strong></p><p id="12bc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">DCOM非常适合客户端-服务器应用程序开发。如果整个分布式应用程序都在微软平台下运行，DCOM是一个不错的选择。<br/>它为分布式组件提供了在分布式内存上共享的接口。<br/>也可以配合CORBA使用。</p><p id="6763" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="9012" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">尽管它与CORBA竞争，但没有一个被证明是足够安全或可扩展的，足以成为高容量web流量的标准。DCOM和CORBA都不能很好地与防火墙一起工作。</p><p id="c405" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">此外，由于它是Windows自带的，DCOM可以在其他计算机上运行程序，黑客可以利用它通过网络进行横向移动攻击，获得更多数据。DCOM的一个最大缺点是它依赖于平台，只能与微软技术一起使用。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lu"><img src="../Images/42ee8ff964dfd8d391bcbcecbf485150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Id8bXouTZpb50P5247S-w.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="40b9" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">EJB</h1><p id="ca6e" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="c5a7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">企业Java bean(EJB)是用于创建企业软件的Java APIs之一。它是一个服务器端软件元素，解释了应用程序的业务逻辑。</p><p id="0700" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">EJB构建在RMI之上，用于客户机/服务器通信。EJB用于开发可伸缩、健壮、安全的企业应用程序。</p><p id="a31e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="761c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">EJB(企业Java Bean)由IBM于1997年发布，后来被Sun Microsystems采用为EJB 1.0。</p><p id="dcb9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">主要特性</strong></p><p id="109d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">到1996年，Java在开发人员中变得非常流行，但是在标准功能的需求方面存在一些主要问题，比如持久性、事务完整性和大多数系统的并发控制。这导致了许多自定义实现，开发人员不得不反复重新实现这些问题的解决方案。</p><p id="74f1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">EJB自动解决了这些常见的问题，并提供了一种标准的方法来实现企业应用程序，以便开发人员可以专注于主要的业务逻辑。</p><p id="4bd0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它提供了方便的抽象，因此不需要开发人员编写:多线程、多路访问代码或网络通信代码(即它使用RMI)来进行客户端/服务器通信。</p><p id="fe26" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="e771" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">因为EJB是一个API，所以构建在EJB上的应用程序也可以在Java EE web应用服务器上运行。此外，EJB容器有助于为企业Java beans提供系统级服务。它包含业务逻辑，因此开发人员可以专注于客户端界面的呈现。这为开发人员提供了一种简单的方法来开发和访问web服务，而不用担心web服务描述格式和基于XML的有线协议的复杂细节。EJB容器提供的工具管理到web服务标准的映射。</p><p id="917e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="e770" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">EJB规范非常复杂和庞大。此外，规范会不断修订，因此理解和开发EJB应用程序很复杂。使用EJB开发的应用程序利用了大量的资源，并且拥有大量的工件。它只适用于Java客户端。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lv"><img src="../Images/7355a8f3ae78c707290f32b4d6eb4fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIFisFD0E3udqZqf7Es5zw.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="a8f3" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">简单对象访问协议</h1><p id="3b6e" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="7c36" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">SOAP是基于XML的消息传递协议。它的设计使得用不同语言编写的应用程序和在不同平台上构建的应用程序可以相互通信。它定义了一组用于构造消息的规则，这些规则可用于简单的单向消息传递，但对于执行RPC风格(远程过程调用)的请求-响应对话尤其有用。</p><p id="e061" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">常见的web服务规范包括:</p><ul class=""><li id="fa9b" class="lw lx hh ik b il im ip iq kz ly lb lz ld ma jf mb mc md me bi translated">Web服务安全性(WS-security):通过称为令牌的唯一标识符来标准化消息的安全和传输。</li><li id="3c1a" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">WS-Reliable Messaging:标准化跨不可靠的IT基础设施传输的消息之间的错误处理。</li><li id="a980" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">Web服务寻址(WS-addressing):将路由信息打包为SOAP头中的元数据，而不是在网络中更深层次地维护这些信息。</li><li id="180b" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">Web服务描述语言(WSDL):描述web服务做什么，以及该服务在哪里开始和结束。</li></ul><p id="6d11" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="0c52" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">1998年6月，Dave Winer、Don Box、Bob Atkinson和Mohsen Al-Ghosein为微软发布了XML-RPC SOAP。SOAP有不同的版本，比如1.0、1.1和1.2</p><p id="da14" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">关键特性</strong></p><p id="c295" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">浏览器不能缓存SOAP API响应。SOAP内置了对安全性、原子性、一致性、隔离性和持久性(ACID)的支持，这是一组用于确保可靠数据库事务的属性。这使得它适用于企业场景。SOAP通常与HTTP一起工作，但它不依赖于任何特定的传输层协议，如SMTP、FTP、TCP和UDP。它既不依赖于任何特定的操作系统，也不依赖于编程语言。所以客户端和服务器可以用任何语言编写，可以在不同的平台上运行就可以了。只要他们能够表达和理解SOAP消息。这是开发分布式应用程序的基本构造块，这些应用程序通过内部网或互联网公开发布为服务的功能。</p><p id="1baf" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优势</strong></p><p id="16c2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">SOAP的优势包括它可以用于任何传输协议。它拥有XML的所有功能，比如国际化和XML名称空间的可扩展性。它支持有状态和无状态。</p><p id="2b8b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">劣势</strong></p><p id="fa8f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">SOAP有一些缺点，比如它只支持XML数据格式，并且由于XML文件较大，它需要较大的带宽。由于它支持如此多的协议，它有一个很大的学习曲线。SOAP API充当客户端和服务器之间的严格契约。因此模式中的任何变化都会导致服务器端和客户端的修改。这是额外的努力。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es mk"><img src="../Images/d2c3bdfb28bd897ac43d00d6eec537dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQUt9B7TYGpR48bSTM4Eqg.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><h1 id="a86a" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">静止表示状态转移</h1><p id="ca1a" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="3638" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">在REST中，向资源URI发出请求，以获得带有HTML、XML、JSON或任何其他指定格式的有效负载的响应。它使用HTTP作为所有这些请求和响应的基本协议。REST提供了一些操作，也称为HTTP方法，比如GET、POST、PUT、PATCH、DELETE、OPTIONS和HEAD。REST是无状态的，这意味着它不存储应用程序或先前请求的状态。每个请求都包含处理请求所需的所有必要信息。有了这些信息，服务器就知道该对给定的请求执行什么操作。</p><p id="e697" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="4130" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">直到1999年，开发人员不得不在SOAP的帮助下集成API。他们必须编写带有RPC调用的XML文件来发出请求。在2000年，Roy Fielding和他的团队引入了表述性状态转移(REST)作为一种软件架构风格。它的创建是为了指导万维网(WWW)体系结构的设计和开发。</p><p id="ae0e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">关键特性</strong></p><p id="5b11" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">RESTful系统的目标是快速的性能、可靠性和通过重用组件来增长的能力。即使系统正在运行，也可以在不影响系统整体的情况下管理和更新这些组件。这是通过遵循REST原则实现的，如客户机-服务器架构、无状态、可缓存性、分层系统、支持按需编码和统一接口。应该遵循这些原则，这样系统才能被称为RESTful。REST是独立于语言的。客户端和服务器可以用不同的语言编写。REST支持不同的数据格式。</p><p id="90bb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="8a47" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">REST有很多优点，比如它支持各种数据格式，比如JSON、XML和HTML。由于JSON数据格式，它为浏览器客户端提供了更好的支持。它速度更快，使用的带宽更少。它可以很容易地集成到现有的网站，没有基础设施的变化。REST通过缓存静态内容或信息提供了卓越的性能。</p><p id="bead" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="4953" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">休息有几个缺点。它是无状态的，所以客户端必须自己完成。它没有SOAP那样的安全性。为了更加安全，我们需要手动添加。流功能不是内置的，所以我们需要集成一个第三方库。REST请求(尤其是GET)不适合大量数据。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es ml"><img src="../Images/2e78c86453226b63916f929477ca59ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nUAeXn_aHW_XcTyxGDVcw.png"/></div></div></figure><h1 id="aaba" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">gRPC</h1><p id="d9f9" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is kz la iv iw lb lc iz ja ld le jd je jf ha bi translated"><strong class="ik hi">简介</strong></p><p id="0dba" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">gRPC (Google的远程过程调用框架)的开发高度重视速度。它允许客户端和服务器之间的透明通信。它基于HTTP/2协议，提供最大的API安全性、性能和可伸缩性。gRPC框架的一些关键组件是Protobuf文件、RPC方法和消息。</p><p id="57d0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">protobuf文件充当客户机和服务器之间的契约。基于这个protobuf文件，客户机和服务器生成存根，这些存根向客户机和服务器公开RPC方法和消息。然后，这些客户机和服务器直接调用RPC方法相互通信。</p><p id="ff2f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它支持四种不同类型的通信。</p><ul class=""><li id="6fed" class="lw lx hh ik b il im ip iq kz ly lb lz ld ma jf mb mc md me bi translated">一元通信:这是客户端和服务器之间一对一的通信，客户端发送请求，服务器响应请求。</li><li id="be7b" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">客户端流:在客户端流中，客户端持续保持与服务器的通信通道打开，并发送请求流。服务器等待客户端完成流式传输，然后响应来自客户端的请求。</li><li id="f186" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">服务器流:在这里，客户机向服务器发送一个请求，服务器用一个流来响应。</li><li id="82cf" class="lw lx hh ik b il mf ip mg kz mh lb mi ld mj jf mb mc md me bi translated">双向流:在这种类型中，客户机和服务器都发送请求和响应流。支持所有不同的流组合，如客户端先完成其流，然后服务器用其流进行响应，或者客户端和服务器同时发送其流。</li></ul><p id="6021" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">历史</strong></p><p id="2b33" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它是由谷歌在2015年开发的，被谷歌、IBM、思科和网飞等不同公司积极用于提供一系列服务，如流媒体应用等。由于它越来越受欢迎，它成为了云本地计算基金会(CNCF)的孵化项目。</p><p id="6dfd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">主要特点</strong></p><p id="702a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它提供了对流媒体服务的内置支持，不需要任何额外的协议，如web sockets、webRTC或FTL等。它提供轻量级消息传递，在物联网应用中非常有用。它使用protoc compiler插件来生成gRPC，作为一个独立的框架，可以无缝地与web和移动应用程序一起工作。它支持广泛的语言，如C、C++、Javascript、PHP、GO、Java等。</p><p id="4282" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">优点</strong></p><p id="87fa" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">gRPC提供的最大优势之一就是速度。因为它完全使用HTTP/2协议，所以与使用HTTP/1.1的Rest相比，它具有巨大的速度优势。基于不同的实验，发现gRPC呼叫平均比传统的REST呼叫快7到10倍。除了使用HTTP/2协议之外，使用protobufs代替JSON进行通信是提供这种速度优势的重要因素之一。压缩的protobuf总是比压缩的JSON对象快。对多路复用的支持是gRPC提供速度优势的另一个原因。gRPC的另一大优势是内置的流支持，无需依赖任何附加协议。gRPC负责客户端和服务器存根的序列化和反序列化，开发人员不必担心底层机制，因此在易于开发方面具有优势。客户端和服务器端都直接调用RPC方法，从而让开发人员不必担心GET、POST、PUT等REST术语。</p><p id="87b5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">互操作性是gRPC提供的另一大优势。使用gRPC的主要目的之一是用于微服务间的通信。当使用gRPC时，其中一个微服务可以在GO中，而另一个可以在Java中，从而使gRPC完全独立于语言。</p><p id="9f10" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它使用HTTP/2 over TLS加密来确保API安全性，并内置了对加密、身份验证、负载平衡等的支持。</p><p id="13fd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated"><strong class="ik hi">缺点</strong></p><p id="bbbb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">广泛采用gRPC的最大瓶颈之一是有限的浏览器支持。由于gRPC完全与HTTP/2一起工作，所以使用gRPC框架在服务器端实现的RPC方法不能被浏览器直接调用，因为目前没有一个浏览器具有对HTTP/2帧的细粒度控制。因此它需要中间件。该中间件的目的是将从浏览器接收的HTTP/1.1请求转换成gRPC可读的格式。这稍微削弱了在web上使用gRPC的速度优势。</p><p id="f5e0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kz iu iv iw lb iy iz ja ld jc jd je jf ha bi translated">它不支持边缘缓存。虽然HTTP作为一个协议支持边缘缓存的中介，但是gRPC作为一个框架缺乏这种支持。此外，开发人员需要像gRPC命令行工具这样的工具来分析protobuf有效负载、编写手动请求和执行调试。</p><figure class="jk jl jm jn fd jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es mm"><img src="../Images/655d471f8527750040831d49d6ae4c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRRaDELgRVtsxtJyk2P-sA.png"/></div></div></figure></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><blockquote class="ie if ig"><p id="4baf" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">特别感谢<a class="jh ji ge" href="https://medium.com/u/733fa45e5564?source=post_page-----ececd4ae8061--------------------------------" rel="noopener" target="_blank"> Mukund </a>的指导。</p></blockquote></div></div>    
</body>
</html>