<html>
<head>
<title>Tasks and the Back Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">任务和后台堆栈</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4?source=collection_archive---------1-----------------------#2016-05-12">https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4?source=collection_archive---------1-----------------------#2016-05-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="497e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你点击应用程序的启动器图标时，实际上会发生什么？如果你说“我的应用启动了”，你在技术上是正确的，最好的一种正确。为了更深入一点，理解什么是<strong class="ig hi">任务</strong>以及它如何与一个叫做后退按钮的小东西交互是有帮助的。</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div></figure><h1 id="2f4f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">任务</h1><p id="e956" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">任务是围绕一堆活动的<strong class="ig hi">的元数据和信息的集合(通过查看<a class="ae km" href="http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="kn"> RecentTaskInfo </em> </a>类，您可以看到确切的数据类型)。</strong></p><p id="d4e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，当你点击应用程序的启动器图标时，系统实际上正在做的是寻找一个先前存在的任务(由它指向的意图和活动决定)来恢复——让你回到你刚才所在的位置。如果没有找到现有的任务，那么创建一个新的任务，使用您新启动的活动作为任务的<strong class="ig hi">后台堆栈</strong>上的基本活动。</p><h1 id="73a4" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">背面堆栈</h1><p id="b49d" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">正如您可能想象的那样，任务的back stack与back按钮绑定在一起，但是它是双向的。当您使用<a class="ae km" href="http://developer.android.com/reference/android/content/Context.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#startActivity(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"><em class="kn">start Activity()</em></a>开始一个新的活动时，也就是(默认情况下)将新的活动推送到您的任务上，导致前一个活动暂停(如果新的活动完全掩盖了前一个活动，则停止)。</p><figure class="jc jd je jf fd jg er es paragraph-image"><div class="er es ko"><img src="../Images/fca9886e52231d1c8e05ba9714fcf623.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*zItbFvFydIR63z_37ya1Iw.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx">A simple back stack</figcaption></figure><p id="4d66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“后退”按钮(默认情况下)然后“弹出”堆栈，在最顶层的活动上调用<a class="ae km" href="http://developer.android.com/reference/android/app/Activity.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#finish()" rel="noopener ugc nofollow" target="_blank"><em class="kn">【finish()</em></a>，销毁它并将其从后面的堆栈中移除，然后返回到上一个活动。重复这个过程，直到后面的堆栈里什么都没有了，你又回到了发射器。</p><h1 id="d83e" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">后面的堆栈和片段</h1><p id="3a76" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">后台堆栈不仅适用于活动:它也适用于<a class="ae km" href="http://developer.android.com/guide/components/fragments.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">片段</a>。当您提供一个<a class="ae km" href="http://developer.android.com/guide/components/fragments.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#Transactions" rel="noopener ugc nofollow" target="_blank">片段事务</a>来添加、替换或删除UI中的片段时，您可以使用<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#addToBackStack(java.lang.String)" rel="noopener ugc nofollow" target="_blank"> addToBackStack() </a>来有效地将<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">片段事务</a>添加到后台堆栈中。</p><p id="5b1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样，当点击back按钮时，FragmentTransaction被反转(删除添加的片段，恢复替换的片段，或者重新添加删除的片段)。添加到后台堆栈的每个事务都被依次反转，直到它们都被删除，这时默认的活动结束行为再次生效。</p><h1 id="78c2" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">后退不是唯一的导航按钮</h1><p id="b660" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">当然，后退按钮并不是现代Android设备上唯一的导航按钮(不，我们不再谈论<a class="ae km" href="http://android-developers.blogspot.com/2012/01/say-goodbye-to-menu-button.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">菜单按钮</a>)。</p><p id="17af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">home<strong class="ig hi">按钮可能是最简单的，因为它只有一个焦点:它把当前的任务放到后台，带你回到你的启动器。</strong></p><blockquote class="kv kw kx"><p id="c053" class="ie if kn ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>将您的任务移到后台不会<strong class="ig hi">而</strong>杀死您的任务(尽管最顶层的活动肯定是暂停+停止的):它将继续存在，直到<strong class="ig hi">进程</strong>被杀死。在<a class="ae km" rel="noopener" href="/google-developers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog"> <strong class="ig hi">“谁生谁死？”中了解更多关于流程优先级以及何时可以终止您的应用的信息</strong>博文</a>。</p></blockquote><p id="8e3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所想，<strong class="ig hi">总览</strong>按钮(以前的recents)将你带到<a class="ae km" href="http://developer.android.com/guide/components/recents.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">总览屏幕</a>。这是Android世界的“应用切换器”——在这里，你可以看到你最近的任务，并能够选择一个将其带回前台。</p><h1 id="ee21" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">好吧，就这样。没什么可看的了。</h1><p id="21b4" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">整洁，<em class="kn">、startActivity() </em>或<em class="kn"> addToBackStack() </em>以及默认的后退按钮行为。这里没有什么特别的，但也没有什么令人困惑的——这些对称的、一致的行为作为缺省值。在大多数情况下，<strong class="ig hi">你应该使用这个默认行为</strong>。</p><p id="0287" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在您运行并直接覆盖<a class="ae km" href="http://developer.android.com/reference/android/app/Activity.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#onBackPressed()" rel="noopener ugc nofollow" target="_blank"><em class="kn">on back pressed()</em></a>之前，您可能需要考虑一些特定的情况:</p><h2 id="953e" class="lb jk hh bd jl lc ld le jp lf lg lh jt ip li lj jx it lk ll kb ix lm ln kf lo bi translated">防止后退按钮疲劳</h2><p id="a950" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">当然，当你需要按10次以上才能离开你所在的位置时，后退按钮就失去了一些光彩。很容易避免这种情况的一种情况是，当您正在启动与当前相同的活动时。</p><p id="af3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您的活动可以在Android清单中使用<strong class="ig hi"><em class="kn">launch mode = " single top "</em></strong>或者您可以添加<a class="ae km" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#FLAG_ACTIVITY_SINGLE_TOP" rel="noopener ugc nofollow" target="_blank"> <em class="kn"> Intent，而不是创建同一活动的多个副本的堆栈(从内存压力和后退按钮疲劳的角度来看，这都不太有趣)。</em></a>FLAG _ ACTIVITY _ SINGLE _ TOP达到你的意图。</p><p id="6f4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可以防止在后台堆栈的顶部出现同一活动的多个副本。相反，您将得到一个对<a class="ae km" href="http://developer.android.com/reference/android/app/Activity.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#onNewIntent(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"><em class="kn">onNewIntent()</em></a>的回调，带有新的<em class="kn">意图</em>和任何附加内容。</p><blockquote class="kv kw kx"><p id="17b5" class="ie if kn ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong>:仔细阅读<em class="hh"> onNewIntent() </em>上的文档:<a class="ae km" href="http://developer.android.com/reference/android/app/Activity.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#getIntent()" rel="noopener ugc nofollow" target="_blank"><em class="hh">getIntent()</em></a><em class="hh"/>仍然会返回原来的意图，除非你用<a class="ae km" href="http://developer.android.com/reference/android/app/Activity.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#setIntent(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"> <em class="hh"> setIntent() </em> </a>覆盖它。</p></blockquote><h2 id="d163" class="lb jk hh bd jl lc ld le jp lf lg lh jt ip li lj jx it lk ll kb ix lm ln kf lo bi translated">后台堆栈和通知</h2><p id="27ba" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">如果你正在创建一个指向应用程序内部某个活动的通知，有一种情况你应该避免:点击返回按钮直接退出到启动程序。当您提供的<em class="kn">pending content</em>启动一个只有一个活动的新任务时，就会出现这种情况。除非你的通知是打开你的启动器活动，那不是你想要的。<strong class="ig hi">用户应该在他们应该在的确切位置，就像他们自己导航到应用程序的那个部分一样。</strong>你的通知正好给他们省了中间步骤。</p><p id="580c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于如此重要的事情，有一个为你做所有工作的类是很好的。进入<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/TaskStackBuilder.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="kn">TaskStackBuilder</em></a>:一个专门为你处理标志和回栈的类，正是这种情况；</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="c83e" class="lb jk hh lq b fi lu lv l lw lx">// Construct the Intent you want to end up at<br/>Intent detailActivity = new Intent(this, DetailActivity.this);<br/>// Construct the PendingIntent for your Notification<br/>TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);<br/>// This uses android:parentActivityName and<br/>// android.support.PARENT_ACTIVITY meta-data by default<br/>stackBuilder.addNextIntentWithParentStack(detailActivity);</span><span id="160c" class="lb jk hh lq b fi ly lv l lw lx">PendingIntent pendingIntent = stackBuilder<br/>  .getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);</span></pre><p id="f6f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到使用了<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/TaskStackBuilder.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#addNextIntentWithParentStack(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"><em class="kn">addNextIntentWithParentStack()</em></a>方法——这是构建整个任务堆栈的捷径，只需传入您已经从中创建了<em class="kn"> PendingIntent </em>的正常意图。但是它有一个要求:每个活动都需要在Android清单中声明其父活动(参见文档中的<a class="ae km" href="http://developer.android.com/training/notify-user/navigation.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#DirectEntry" rel="noopener ugc nofollow" target="_blank">示例)。</a></p><p id="4080" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果默认设置在您的情况下不起作用，您也不需要扔掉<em class="kn">TaskStackBuilder</em>:<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/TaskStackBuilder.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#editIntentAt(int)" rel="noopener ugc nofollow" target="_blank">edit intentat()</a>允许您检索特定的意图并设置动作、设置数据URI或添加额外内容。如果您需要更多的定制，您可以完全放弃使用<em class="kn"> *ParentStack() </em>方法，而使用<a class="ae km" href="http://developer.android.com/reference/android/support/v4/app/TaskStackBuilder.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#addNextIntent(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"> <em class="kn"> addNextIntent() </em> </a>来直接添加您特定情况下所需的确切意图。</p><blockquote class="kv kw kx"><p id="348c" class="ie if kn ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>如<a class="ae km" href="http://developer.android.com/training/notify-user/navigation.html?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog#ExtendedNotification" rel="noopener ugc nofollow" target="_blank">文档</a>中所述，您可以从通知中启动的另一种类型的活动是特定于通知的活动(即，不是您的正常应用程序流中的活动)。这方面的一个例子可能是Hangout在Android N之前使用的类似直接回复的活动。这些活动通常是半透明的——你可以在你的活动下面看到其他应用程序——通常没有任何合成的后台堆栈或新任务与之相关联。</p></blockquote><h1 id="5bd3" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">任务和后台堆栈一起工作</h1><p id="f5fe" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">记住这里最重要的部分是可预测的。如果你在搞乱你的back stack，确保非常彻底地测试<em class="kn"/>以确保最好的用户体验。</p><p id="7ba6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"># BuildBetterApps</p><p id="ef92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关注<a class="ae km" href="https://plus.google.com/collection/sLR0p?utm_campaign=android_series_tasks_back_stack_051216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集</a>了解更多！</p><figure class="jc jd je jf fd jg er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>