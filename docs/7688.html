<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/flex-your-code-with-chain-of-responsibility-d3f13c97478f?source=collection_archive---------4-----------------------#2017-10-03">https://medium.com/walmartglobaltech/flex-your-code-with-chain-of-responsibility-d3f13c97478f?source=collection_archive---------4-----------------------#2017-10-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/465a8f8321cfc9a76763ab287a1bb046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3eVHTHRZ9wJQnd4AXF_6Q.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo credit: <a class="ae hu" href="https://pixabay.com/en/tiger-lazy-sleeping-white-animal-1285229/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="8837" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated"><strong class="hy iu">用责任链灵活处理你的代码</strong></p><p id="766a" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">作为<a class="ae hu" rel="noopener" href="/@WalmartLabs"> @WalmartLabs </a> A/B测试团队的一员，我们正在构建一个内部A/B测试解决方案，我主要在后端服务部门工作。这些年来，随着更多功能的加入，代码库也在增长，不幸的是，一些API的业务逻辑也在增长，我们的一个主要API变得非常庞大、混乱和难以维护。当代码进入这种状态时，引入新错误的可能性导致开发人员避免修改它。许多开发人员只试图做最小的代码修改，希望它不会崩溃(我对此感到内疚)。对我来说，这是一个需要重构和彻底检查的主要功能。我想分享我使用责任链模式，通过一个干净、简单、灵活的解决方案来解决这个问题的过程。</p><p id="15b8" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">责任链模式已经存在很长时间了。如果您使用ServletFilter，您可能熟悉FilterChain，它使用责任链模式。基本思想是将代码抽象成执行路径(我称之为action ),然后以串行方式将每个动作链接在一起(类似于链表),这样链中的下一个动作就可以被当前动作或可以自动执行链中每个动作的处理程序调用。回到ServletFilter，执行下一个连锁动作的控制权在当前动作本身中(取决于开发人员)。在我的实现中，我选择了后者，处理程序将自动执行每个动作。我不希望开发人员不得不手动调用下一个动作，如果以后需要向链中添加新动作的话。责任链非常适合将异常堆栈向上冒泡到所有之前的操作，这样他们就可以处理错误情况，比如撤销每个操作之前所做的事情。还要注意，每个动作不需要执行任何操作。很多时候，您的操作将依赖于输入元数据或先前操作设置的上下文数据来执行操作。显然，这种技术并不适用于所有情况。如果您的代码很长，很难理解，并且正在执行许多不同的事情，就像我的情况一样，您应该考虑使用这种模式进行重构。</p><p id="6aee" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">在我的例子中，就像我之前说过的，我们的一个主要API方法多年来变得如此庞大，并且有条件地执行如此多的事情，以至于添加新的特性变得过于复杂，并且容易引入新的bug。为了解决这个问题，我需要重构这段代码。我希望以一种灵活、干净的方式对它进行彻底检查，并且当调用堆栈中的任何一点出现错误时，它都能够处理回滚(如果必要的话)。这就是责任链有意义的地方，并且符合我上面陈述的所有要求。我开始查看代码，看看我能抽象出哪些动作。下面是一个抽象出的操作示例:</p><p id="600c" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">1.业务规则验证<br/> 2。保持基于实体的if状态变化<br/> 3。如果某些状态<br/> 4，则与内容管理系统接口。如果某个状态<br/> 5，则与配置管理系统接口。进入云存储系统的界面，如果确定状态<br/> 6。持续到另一个实体，如果某个状态<br/> 7。执行变更审计</p><p id="e429" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">基于上面我确定的动作，我创建了一个简单的类图来开始责任链模式。</p><figure class="iw ix iy iz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es iv"><img src="../Images/1dba02601120cdf017d224249daad0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE-xuaOKWuUGh1Sg8FXTqA.png"/></div></div></figure><p id="542d" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">上图遵循了我抽象出来的动作。显然，每个动作都接受输入，并可能产生一些输出。Output (context)是可选的，如果链中的任何动作需要链中先前执行的动作的输出，那么您可以有一个输出上下文(holder对象)来保存链中先前动作的任何结果以进行处理。在我的例子中，我有一个抽象类，它将作为我的处理程序自动调用链中的下一个动作(如果有的话)。当有异常时，它会捕捉它并调用实现可撤销接口的动作(不在图中)。可撤销的接口基本上有一个undo()方法。在图中的例子中，PersistEntityAction、PersistOtherEntityAction和InterfaceCloudStorageAction将实现可撤销的接口。抽象类可以像这样简单:</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="fb6a" class="jf jg hx jb b fi jh ji l jj jk">public abstract class AbstractChainAction implements Action {<br/>    protected Action nextAction = null;<br/>    <br/>    public void execute(Input in, Output out) throws Exception {<br/>        try {<br/>            doExecute(in, out);<br/>            if (nextAction != null){<br/>                nextAction.execute(in, out);<br/>            }<br/>        } catch(Throwable e) {<br/>            if (this instanceof Undoable) {<br/>                ((Undoable)this).rollback(in, out);<br/>            }<br/>            throw e;<br/>        }<br/>        <br/>    }<br/><br/>    protected abstract void doExecute(Input in, Output out) throws Exception;<br/>    <br/>    public Action getNextAction() {<br/>        return nextAction;<br/>    }<br/><br/>    public void setNextAction(Action nextAction) {<br/>        this.nextAction = nextAction;<br/>    }<br/><br/>}</span></pre><p id="3781" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">从这个抽象类派生的任何类只需要实现doExecute()方法，这个抽象类将自动调用它并调用链中的下一个动作(如果有的话)。我将向您展示PersistEntityAction的一个示例:</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="9018" class="jf jg hx jb b fi jh ji l jj jk">public class PersistEntityAction extends AbstractChainAction implements Undoable {<br/><br/>    public void rollback(Input in, Output out) throws Exception {<br/>        // put in your undo logic<br/>    }<br/><br/>    protected void doExecute(Input in, Output out) throws Exception {<br/>        // do your logic here to persist the entity that<br/>        // come in from the input<br/>        // if you want to set the new entity to the output, you<br/>        // can set it to the out context and any actions in the<br/>        // chain after can use the persisted object</span><span id="ada8" class="jf jg hx jb b fi jl ji l jj jk">    }<br/><br/>}</span></pre><p id="fbae" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">注意，PersistEntityAction还实现了Undoable接口，因此如果链中的任何地方发生错误，基类可以自动调用undo()方法。如果您的操作不需要撤销任何事情，那么您就不需要实现可撤销的接口。既然您已经定义了所有的操作，那么您需要决定如何将它们链接在一起以及以什么样的顺序。您可以为每个操作创建一个实例，并按照您想要的顺序调用setNextAction()。</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="55db" class="jf jg hx jb b fi jh ji l jj jk">ValidateAction start = new ValidateAction();<br/>PersistEntityAction persistEntityAction = new PersistEntityAction();<br/>InterfaceCMSAction interfaceCMSAction = new InterfaceCMSAction();<br/>InterfaceCloudConfigurationAction confAction = new InterfaceCloudConfigurationAction();<br/>InterfaceCloudStorageAction storageAction = new InterfaceCloudStorageAction();<br/>PersistOtherEntityAction persistOtherEntityAction = new PersistOtherEntityAction();<br/>PerformAuditAction auditAction = new PerformAuditAction();</span><span id="614e" class="jf jg hx jb b fi jl ji l jj jk">// link them<br/>start.setNextAction(persistEntityAction);<br/>persistEntityAction.setNextAction(interfaceCMSAction);<br/>interfaceCMSAction.setNextAction(confAction);<br/>confAction.setNextAction(storageAction);<br/>storageAction.setNextAction(persistOtherEntityAction);<br/>persistOtherEntityAction.setNextAction(auditAction);</span><span id="ce07" class="jf jg hx jb b fi jl ji l jj jk">// start the chain<br/>start.execute(ctx, out);</span></pre><p id="bb90" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">在我的例子中，我创建了一个简单的ChainInvoker接口，然后有一个工厂来构建ChainInvoker，然后调用者将调用call()方法来开始执行动作链。</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="81ee" class="jf jg hx jb b fi jh ji l jj jk">public interface ChainInvoker {<br/>    public void call() throws Exception;<br/>}</span><span id="3a95" class="jf jg hx jb b fi jl ji l jj jk">public class ChainInvokerFactory {<br/><br/>    public ChainInvoker createInvoker(Input ctx, Output out) {<br/>        ChainInvoker invoker = new Builder()<br/>                .chain(new ValidateAction())<br/>                .chain(new PersistEntityAction())<br/>                .chain(new InterfaceCMSAction())<br/>                .chain(new InterfaceCloudConfigurationAction())<br/>                .chain(new InterfaceCloudStorageAction())<br/>                .chain(new PersistOtherEntityAction())<br/>                .chain(new PerformAuditAction())<br/>                .build(ctx, out);<br/><br/>        return invoker;<br/>    }<br/>    <br/>    class Builder {<br/>        private LinkedList&lt;AbstractChainAction&gt; list = new LinkedList&lt;&gt;();<br/>        <br/>        public Builder chain(AbstractChainAction action) {<br/>            list.add(action);<br/>            return this;<br/>        }<br/>        <br/>        public ChainInvoker build(Input ctx, Output out) {<br/>            return new ChainInvoker() {<br/><br/>                public void call() throws Exception {<br/>                    AbstractChainAction prev = null;<br/>                    for (AbstractChainAction current : list){<br/>                        if (prev == null){<br/>                            prev = current;<br/>                            continue;<br/>                        }<br/>                        prev.setNextAction(current);<br/>                        prev = current;<br/>                    }<br/>                    list.getFirst().execute(ctx, out);<br/>                }<br/>                <br/>            };<br/>        }<br/>    }<br/><br/>}</span></pre><p id="e24a" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">现在，您所要做的就是调用工厂对象来创建调用者，然后启动动作链。请注意，工厂可以是单例的。对于我的代码，我使用了Spring IoC，这样工厂就可以作为一个单独的bean被注入。以下代码仅用于说明目的。</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="56ca" class="jf jg hx jb b fi jh ji l jj jk">Input ctx = new Input();<br/>Output out = new Output();<br/>ChainInvoker invoker = new ChainInvokerFactory().createInvoker(ctx, out);<br/>invoker.call();</span></pre><p id="1306" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">一个很常见的问题是，为什么你甚至需要创建一个行动链？为什么不收集一些动作，遍历它们，然后执行每个动作呢？迭代和执行每个动作的问题是干净的错误处理。动作链将使用链调用堆栈来冒泡所有先前执行的动作的异常，并且可以在每个动作中正确地处理错误。此外，现在添加或删除功能将非常容易。移除功能将是最简单的，就好像当我的API被调用时，我不再需要持久化到另一个实体，我只需简单地去工厂并移除PersistOtherEntityAction的链。如果我想添加一个新的动作，我会创建一个新的动作，并决定该动作需要放在链中的什么位置并附加它。仅此而已。</p><p id="5062" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">最后，我希望我已经帮助您解决了像我一样的许多开发人员面临的一个非常普遍的问题。如果你发现你可以让一段代码更干净、更灵活，那就去做吧。这会让其他工程师的生活更轻松。最终结果:<strong class="hy iu">质量更好</strong>。</p></div></div>    
</body>
</html>