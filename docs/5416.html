<html>
<head>
<title>Application Container Cloud Service (ACCS): Using the Application Cache from a Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序容器云服务(ACCS):使用Spring Boot应用程序的应用程序缓存</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/application-container-cloud-service-accs-using-the-application-cache-from-a-spring-boot-6d3ec795b9e3?source=collection_archive---------0-----------------------#2018-03-14">https://medium.com/oracledevs/application-container-cloud-service-accs-using-the-application-cache-from-a-spring-boot-6d3ec795b9e3?source=collection_archive---------0-----------------------#2018-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d80b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://technology.amis.nl/2018/01/24/getting-started-with-spring-boot-microservices-why-and-how/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>让你快速开发微服务。应用程序容器云服务(ACCS)允许您轻松托管Spring Boot应用程序。<a class="ae jc" href="https://blogs.oracle.com/developers/caching-with-oracle-application-container-cloud" rel="noopener ugc nofollow" target="_blank"> Oracle提供了基于Coherence的应用缓存</a>，您可以从部署到ACCS的应用中使用。为了使用来自Spring Boot的应用程序缓存，Oracle为T4提供了一个开源的Java SDK T5。在这篇博文中，我将给出一个例子，说明如何通过这个SDK使用Spring Boot的应用程序缓存。你可以在这里找到示例代码<a class="ae jc" href="https://github.com/MaartenSmeets/springboot/tree/master/accs-cache-sample" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/f99a72920407955fecc0b5dde13da33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*_HbHj1SmkiKLcxKk.png"/></div></figure><h1 id="86a7" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">使用应用程序缓存Java SDK</h1><p id="7a6d" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated"><strong class="ig hi">创建应用缓存</strong></p><p id="5fba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以使用web界面轻松创建应用程序缓存的新实例。一个实例可以包含多个缓存。一个应用程序可以使用多个缓存，但只能使用一个缓存实例。多个应用程序可以使用相同的缓存实例和缓存。请注意，应用程序和应用程序缓存部署在同一个区域，以便实现连接。另外，不要在缓存名称中使用“-”字符，因为LBaaS配置将会失败。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/d8d8fdfaa6874c9080d24965c7bfde4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*7aG21aobEL700GLC.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a7727d57f3df042d699001238789384a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*fRgj0o2k5fvWLiFZ.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/5d6a3a8f456400638e338b4d21c77689.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*Wcxa3ID8ECKl-_tI.png"/></div></figure><p id="e07f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Java SDK Spring Boot应用程序通常使用定义抽象层的架构。外部资源通过控制器公开。控制器使用服务。这些服务提供执行特定任务的操作。服务使用存储库作为它们的连接/数据访问对象。实体是POJO，例如作为控制器中的REST进行交换/持久化和公开。为了连接到缓存，存储库似乎是一个不错的位置。使用哪个存储库(像数据库或应用程序缓存存储库这样的持久后端)可以由服务来处理。每个操作都可能不同。例如，Get操作可能会直接使用缓存存储库(如果它找不到自己的数据，可以使用其他来源)，而您可能希望在持久后端和缓存中都执行Put操作。参见<a class="ae jc" href="https://github.com/MaartenSmeets/springboot/blob/master/accs-cache-sample/src/main/java/nl/amis/smeetsm/springboot/person/PersonService.java" rel="noopener ugc nofollow" target="_blank">中的示例</a>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b4a36906adccc4ded3488a7e0d450821.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*z0MuQFoU0tSl-P-E.png"/></div></figure><p id="bc6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了访问缓存，首先需要建立一个会话。会话可以从会话提供者处获得。会话提供者可以是本地会话提供者或远程会话提供者。本地会话提供程序可用于本地开发。它可以用指示高速缓存中项目的有效期的期满来创建。当开发/测试时，你可以试着将它设置为“永不过期”,否则你可能找不到你想要的条目。我没有进一步研究这个问题，也没有为它创建服务请求。我也不知道这是否只是本地会话提供者的问题。样本代码<a class="ae jc" href="https://github.com/MaartenSmeets/springboot/blob/master/accs-cache-sample/src/main/java/nl/amis/smeetsm/springboot/person/PersonCacheRepositoryImpl.java" rel="noopener ugc nofollow" target="_blank">见此</a>或<a class="ae jc" href="https://github.com/abhirockzz/app-container-cloud-cache-example/blob/master/src/main/java/com/oracle/cloud/acc/cache/dcs/CacheREST.java" rel="noopener ugc nofollow" target="_blank">见此</a>。</p><p id="aa9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建会话时，您还需要指定要使用的协议。当使用Java SDK时，你可以(目前)从<a class="ae jc" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae jc" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>中选择。例如，在Node.js代码中没有SDK的情况下，GRPC可能更难实现，但是我没有尝试过。我没有比较这两种协议的性能。另一个区别是应用程序使用不同的端口和URL连接到缓存。你可以在这里看到如何从ACCS环境变量<a class="ae jc" href="https://github.com/abhirockzz/app-container-cloud-cache-example/blob/master/src/main/java/com/oracle/cloud/acc/cache/dcs/CacheREST.java" rel="noopener ugc nofollow" target="_blank">中确定正确的URL /协议。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/48c063207cf5b671737e22df99fee7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*kLBfj1ej2ENNaVQp.png"/></div></figure><p id="50b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ACCS应用程序缓存Java SDK允许您在创建缓存对象时添加加载程序和序列化程序类。当在缓存中找不到值时，将调用Loader类。这允许您获取不在缓存中的对象。序列化程序是必需的，因此对象可以通过REST或GRPC进行传输。你可以做如下的事情。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fb165b1601681d9458990288decf04f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*6paP3eqMkUJFiBhk.png"/></div></figure><p id="3403" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注射</strong></p><p id="3221" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，在使用Spring Boot时，您不希望通过直接执行以下操作来创建对象的实例:Class bla = new Class()。您希望让Spring通过使用@Autowired注释来处理这个问题。</p><p id="ae9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是请注意，在实例的构造函数执行之后，@Autowired注释会将实例分配给变量。如果希望在构造函数之后、执行其他方法之前使用@Autowired变量，应该将它们放在@PostConstruct注释方法中。参见<a class="ae jc" href="https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/" rel="noopener ugc nofollow" target="_blank">这里的</a>。具体实现样本<a class="ae jc" href="https://github.com/MaartenSmeets/springboot/blob/master/accs-cache-sample/src/main/java/nl/amis/smeetsm/springboot/person/PersonCacheRepositoryImpl.java" rel="noopener ugc nofollow" target="_blank">见此</a>。</p><p id="9620" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">连通性</strong></p><p id="d9a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序缓存可以在特定时间重启(例如修补、扩展等维护)，并且可能会由于其他原因出现连接问题。为了解决这个问题，一个好的做法是通过实现重试来使连接处理更加健壮。例如，参见此处的<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/cache/handling-connection-exceptions-retries.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="35d3" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">将Spring Boot应用程序部署到ACCS</h1><p id="613a" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated"><strong class="ig hi">创建可部署的</strong></p><p id="0a72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将应用程序部署到ACCS，您需要创建一个特定格式的ZIP文件。在这个ZIP文件中，至少应该有一个manifest.json文件，它描述了如何启动应用程序。这里可以阅读更多<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/dvcjv/creating-meta-data-files.html" rel="noopener ugc nofollow" target="_blank">。如果您有特定于环境的属性、绑定信息(比如使用哪个缓存)和环境变量，那么您可以创建一个deployment.json文件。除了这些元数据文件，当然还需要应用程序本身。对于Spring Boot，这是一个包含所有依赖项的大JAR文件。你可以用spring-boot-maven-plugin创建这个文件。ZIP本身最容易用maven-assembly-plugin编写。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/200a68f765947fc4428c79967e2c7afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*U5yxtdN8c9cmWZJE.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a7a21b1c715f158a9c720ef3f9ec0572.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*KRJDk556aB_UXD5x.png"/></div></figure><p id="53c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">部署到ACCS </strong></p><p id="7541" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有两种主要的方法(除了直接使用API，比如CURL)可以部署到ACCS。可以手动完成，也可以使用开发者云服务。这里的描述了开发者云服务的流程<a class="ae jc" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/cloud/apaas/deploy-app-dcs/deploy-app-dcs.html" rel="noopener ugc nofollow" target="_blank">。这更快(例如，允许在Git提交时重新部署)并且更灵活。下面全面描述了手动程序。需要记住的一件重要事情是，如果您多次以相同的名称部署相同的应用程序，您可能会遇到应用程序没有被新版本替换的问题。在这种情况下，你可以做两件事。每次都用不同的名字部署。但是，应用程序的名称反映在URL中，这可能会给应用程序的用户带来问题。另一种方法是在重新部署之前从存储云服务中删除文件，这样您就可以确保可部署的是ACCS的最新版本。</a></p><p id="2d58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">手动</strong></p><p id="37d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建新的Java SE应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/22f0655c0f6f0dd04ff6c56fac83bf80.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*XIhxA6kHDdkqitmh.png"/></div></figure><p id="d302" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上传之前创建的ZIP文件</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/1fd33c1f9402690bf7c91efcbd08623e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*xJEo4vksTSXXUxHq.png"/></div></figure><h1 id="4acd" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">参考</h1><p id="6029" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">Oracle云应用缓存客户端Java SDK简介</p><ul class=""><li id="ef28" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><a class="ae jc" href="https://blogs.oracle.com/developers/introducing-application-cache-client-java-sdk-for-oracle-cloud" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/developers/introducing-application-cache-client-Java-SDK-for-Oracle-cloud</a></li></ul><p id="3a30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Oracle应用容器云进行缓存</p><ul class=""><li id="b45f" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><a class="ae jc" href="https://blogs.oracle.com/developers/caching-with-oracle-application-container-cloud" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/developers/caching-with-Oracle-application-container-cloud</a></li></ul><p id="9fa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用应用程序缓存在ACCS上完成工作示例Spring Boot(一旦解决服务请求)</p><ul class=""><li id="656a" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><a class="ae jc" href="https://github.com/MaartenSmeets/springboot/tree/master/accs-cache-sample" rel="noopener ugc nofollow" target="_blank">https://github . com/MaartenSmeets/spring boot/tree/master/accs-cache-sample</a></li></ul><p id="458a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用应用程序缓存Java SDK的示例。申请是基于球衣</p><ul class=""><li id="806f" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><a class="ae jc" href="https://github.com/abhirockzz/app-container-cloud-cache-example" rel="noopener ugc nofollow" target="_blank">https://github . com/abhirockzz/app-container-cloud-cache-example</a></li></ul></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="7f99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="le">原载于2018年3月14日</em><a class="ae jc" href="http://javaoraclesoa.blogspot.nl/2018/03/application-container-cloud-service.html" rel="noopener ugc nofollow" target="_blank"><em class="le">javaoraclesoa.blogspot.com</em></a><em class="le">。</em></p></div></div>    
</body>
</html>