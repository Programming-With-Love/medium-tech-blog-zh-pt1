<html>
<head>
<title>Master the JavaScript Interview: What is Function Composition?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript面试:什么是函数合成？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0?source=collection_archive---------0-----------------------#2016-09-06">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0?source=collection_archive---------0-----------------------#2016-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5d7da2f65a2c5b62b559f457abc0cd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4trMikhKRHhSUlI2D6h_mA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Google Datacenter Pipes — Jorge Jorquera — (CC-BY-NC-ND-2.0)</figcaption></figure><blockquote class="it iu iv"><p id="9c55" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“掌握JavaScript面试”是一系列的帖子，旨在帮助候选人准备在申请中高级JavaScript职位时可能遇到的常见问题。这些是我在真实面试中经常用到的问题。</p></blockquote><p id="aa6e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">函数式编程正在接管JavaScript世界。就在几年前，很少有JavaScript程序员知道什么是函数式编程，但是我在过去3年中看到的每个大型应用程序代码库都大量使用了函数式编程思想。</p><p id="bd9d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated"><strong class="iz hi">功能组合</strong>是将两个或两个以上的功能组合起来产生一个新功能的过程。将函数组合在一起就像将一系列管道连接在一起，让我们的数据流过。</p><p id="4430" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">简单地说，函数`<em class="iy"> f` </em>和`<em class="iy"> g` </em>的组合可以定义为<em class="iy"> `f(g(x))`，</em>从内到外(从右到左)求值。换句话说，评估顺序是:</p><ol class=""><li id="f288" class="jy jz hh iz b ja jb je jf jv ka jw kb jx kc ju kd ke kf kg bi translated"><em class="iy"> `x` </em></li><li id="b8f1" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju kd ke kf kg bi translated"><em class="iy"> `g` </em></li><li id="7bb0" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju kd ke kf kg bi translated"><em class="iy"> `f` </em></li></ol><p id="4751" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">让我们在代码中更仔细地看看这一点。假设您想要将用户的全名转换为URL slugs，以便为每个用户提供一个个人资料页面。为此，您需要完成一系列步骤:</p><ol class=""><li id="9a1c" class="jy jz hh iz b ja jb je jf jv ka jw kb jx kc ju kd ke kf kg bi translated">将名称拆分成空格数组</li><li id="8648" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju kd ke kf kg bi translated">将名称映射为小写</li><li id="51d3" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju kd ke kf kg bi translated">用破折号连接</li><li id="8538" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju kd ke kf kg bi translated">编码URI分量</li></ol><p id="314d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">下面是一个简单的实现:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="f19f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">不错…但是如果我告诉你它可以更具可读性呢？</p><p id="4043" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">想象一下，这些操作中的每一个都有相应的可组合函数。这可以写成:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="331b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">这看起来比我们的第一次尝试更难理解，但是坚持住，这是有意义的。</p><p id="cec9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">为了实现这一点，我们使用了常见实用程序的可组合形式，如<em class="iy"> `split()` </em>、<em class="iy"> `join()` </em>和<em class="iy"> `map()` </em>。以下是实现方式:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="e595" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">除了<em class="iy"> `toLowerCase()`，</em>所有这些函数的生产测试版本都可以从Lodash/fp获得。您可以像这样导入它们:</p><pre class="km kn ko kp fd ks kt ku kv aw kw bi"><span id="6f36" class="kx ky hh kt b fi kz la l lb lc">import { curry, map, join, split } from 'lodash/fp';</span></pre><p id="8299" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">或者像这样:</p><pre class="km kn ko kp fd ks kt ku kv aw kw bi"><span id="50a5" class="kx ky hh kt b fi kz la l lb lc">const curry = require('lodash/fp/curry');<br/>const map = require('lodash/fp/map');<br/>//...</span></pre><p id="17ac" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">我有点懒了。注意，这个咖喱从技术上讲并不是真正的咖喱，它总是产生一元函数。相反，它是一个简单的局部应用程序。见<a class="ae ld" rel="noopener" href="/javascript-scene/curry-or-partial-application-8150044c78b8#.13tj19278">“库里和局部应用有什么区别？”</a>，但是为了<em class="iy">这个演示的目的</em>，它将与一个真正的curry函数互换工作。</p><p id="47eb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">回到我们的<em class="iy"> `toSlug()` </em>实现，有一些事情真的让我很困扰:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="b843" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">对我来说，这看起来像很多嵌套，读起来有点混乱。我们可以用一个自动组合这些函数的函数来简化嵌套，这意味着它将从一个函数获取输出，并自动将其修补到下一个函数的输入，直到它吐出最终值。</p><p id="f1b0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">仔细想想，我们有一个array extras实用程序，听起来像是做类似的事情。它接受一个值列表，并对每个值应用一个函数，累积一个结果。这些值本身可以是函数。这个函数叫做<em class="iy"> `reduce()`，</em>但是为了匹配上面的合成行为，我们需要它从右向左减少，而不是从左向右。</p><p id="46d4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">好在有一个<em class="iy"> `reduceRight()` </em>正是我们要找的:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="687b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">和<em class="iy"> `.reduce()` </em>一样，数组<em class="iy"> `.reduceRight()` </em>方法采用一个reducer函数和一个初始值(`<em class="iy"> x` </em> ) <em class="iy">。</em>我们迭代数组函数(从右到左)，依次将每个函数应用于累积值(<em class="iy"> `v` </em>)。</p><p id="ecd7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">有了compose，我们可以在没有嵌套的情况下重写上面的合成:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="8a6c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">当然，<em class="iy"> `compose()` </em>也附带了lodash/fp:</p><pre class="km kn ko kp fd ks kt ku kv aw kw bi"><span id="b05e" class="kx ky hh kt b fi kz la l lb lc">import { compose } from 'lodash/fp';</span></pre><p id="276a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">或者:</p><pre class="km kn ko kp fd ks kt ku kv aw kw bi"><span id="a6ed" class="kx ky hh kt b fi kz la l lb lc">const compose = require('lodash/fp/compose');</span></pre><p id="f5b2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">当你从里到外从数学形式的角度思考写作时，写作是很棒的…但是如果你想从左到右的顺序来思考呢？</p><p id="1b5d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">还有一种形式俗称<em class="iy"> `pipe()` </em>。Lodash称之为<em class="iy"> `flow()`: </em></p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="de24" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">注意实现与<em class="iy"> `compose()` </em>完全相同，除了我们使用<em class="iy"> `.reduce()` </em>而不是<em class="iy"> `.reduceRight()`，</em>从左到右而不是从右到左减少。</p><p id="845a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">让我们看看我们用<em class="iy"> `pipe()`: </em>实现的<em class="iy"> `toSlug()` </em>函数</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="e4b3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">对我来说，这更容易阅读。</p><p id="99f0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">核心函数式程序员根据函数组合来定义他们的整个应用程序。我经常使用它来消除对临时变量的需求。仔细看看<em class="iy"> `pipe()` </em>版本的<em class="iy"> `toSlug()` </em>，你可能会注意到一些特别的地方。</p><p id="9313" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">在命令式编程中，当您对某个变量执行转换时，您会在转换的每一步中找到对该变量的引用。上面的<em class="iy"> `pipe()` </em>实现是以<strong class="iz hi">无点</strong>风格编写的，这意味着它根本不识别它所操作的参数。</p><p id="434a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">我经常在单元测试和Redux状态减少器中使用管道，以消除对中间变量的需要，这些变量只用于保存一个操作和下一个操作之间的瞬态值。</p><p id="874d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">起初这听起来可能很奇怪，但是随着您对它的实践，您会发现在函数式编程中，您正在处理非常抽象、一般化的函数，其中事物的名称并不那么重要。名字只会碍事。你可能开始认为变量是不必要的样板文件。</p><p id="f911" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">也就是说，我认为免分的风格可能走得太远了。它可能会变得过于密集，难以理解，但如果你感到困惑，这里有一个小提示…你可以进入流来跟踪发生了什么:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="b099" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">你可以这样使用它:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="8628" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated"><em class="iy"> `trace()` </em>只是更一般的<em class="iy"> `tap()` </em>的一种特殊形式，它让您对流经管道的每个值执行一些操作。明白了吗？烟斗？踢踏舞？你可以这样写<em class="iy"> `tap()` </em>:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="e80e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">现在你可以看到<em class="iy"> `trace()` </em>只是一个特例<em class="iy"> `tap()` </em>:</p><figure class="km kn ko kp fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="5404" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">你应该开始了解函数式编程是什么样子，以及<strong class="iz hi">局部应用</strong> &amp; <strong class="iz hi">如何与</strong>函数组合<strong class="iz hi">协作</strong>来帮助你用更少的样板文件编写更具可读性的程序。</p><h2 id="de30" class="kx ky hh bd le lf lg lh li lj lk ll lm jv ln lo lp jw lq lr ls jx lt lu lv lw bi translated">探索该系列</h2><ul class=""><li id="b3c2" class="jy jz hh iz b ja lx je ly jv lz jw ma jx mb ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.ecfskj935">什么是闭包？</a></li><li id="a716" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1">类和原型继承有什么区别？</a></li><li id="5846" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.4256pjcfq">什么是纯函数？</a></li><li id="9469" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0#.i84zm53fb">什么是函数构成？</a></li><li id="e45a" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#.jddz30xy3">什么是函数式编程？</a></li><li id="415f" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated">什么是承诺？</li><li id="d010" class="jy jz hh iz b ja kh je ki jv kj jw kk jx kl ju mc ke kf kg bi translated"><a class="ae ld" rel="noopener" href="/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466">软技能</a></li></ul><h1 id="4e54" class="md ky hh bd le me mf mg li mh mi mj lm mk ml mm lp mn mo mp ls mq mr ms lv mt bi translated">提升你的技能</h1><p id="d412" class="pw-post-body-paragraph iw ix hh iz b ja lx jc jd je ly jg jh jv mu jk jl jw mv jo jp jx mw js jt ju ha bi translated"><a class="ae ld" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟着Eric Elliott </a>学习JavaScript。如果你不是会员，你就错过了！</p><figure class="km kn ko kp fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es mx"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="2db8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">著有《编程JavaScript应用程序》</em>  <em class="iy">(奥赖利)，以及《高级JavaScript与开发领导力课程》。他为Adobe Systems</em><strong class="iz hi"><em class="iy"/></strong><em class="iy"/><strong class="iz hi"><em class="iy">Zumba Fitness</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【华尔街日报】</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC</em></strong><em class="iy">等顶级录音师贡献了软件经验</em></p><p id="61a2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jv jj jk jl jw jn jo jp jx jr js jt ju ha bi translated">他和世界上最美丽的女人一起在任何他想去的地方工作。</p></div></div>    
</body>
</html>