<html>
<head>
<title>Top Git Interview Questions You Need To Prepare In 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年你需要准备的顶级Git面试问题</h1>
<blockquote>原文：<a href="https://medium.com/edureka/git-interview-questions-32fb0f618565?source=collection_archive---------3-----------------------#2019-09-12">https://medium.com/edureka/git-interview-questions-32fb0f618565?source=collection_archive---------3-----------------------#2019-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/f2caf895857bab95096e2e36fb27596f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*XqsRwm8824HkduMzmks0hA.png"/></div></figure><p id="4f3c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我真的很喜欢和Git一起工作。Git在许多组织中扮演着实现DevOps的重要角色，是一项必须了解的技术。这个原因驱使我为你准备最常被问到的Git面试问题。</p><p id="110a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">经过大量的研究和与许多专家的讨论，这些专家在他们的领域有超过10年的经验，也经常接受采访，我收集了以下一组问题。好奇想多了解一下Git。</p><p id="2590" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我们讨论了大约50个问题，并将它们分为3类</p><ul class=""><li id="acb5" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">基本问题</li><li id="d05f" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">中级问题</li><li id="2b27" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">高级问题</li></ul><h1 id="130d" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">基本问题</h1><h2 id="d10b" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">1.Git和SVN有什么区别？</h2><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lj"><img src="../Images/4b9c929a9a4594b402d1fde12ce8dc83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjY2qsxCNKgQZM0XILm-pw.png"/></div></div></figure><h2 id="5775" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">2.Git是什么？</h2><p id="b1d7" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">我建议你尝试这个问题，首先讲述git的架构，如下图所示，试着解释一下这个图:</p><ul class=""><li id="02e0" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">Git是一个分布式版本控制系统(DVCS)。它让您跟踪对文件所做的更改，并允许您恢复到您希望的任何特定更改。</li><li id="c7d2" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">它是一个分布式架构，提供了许多优于其他版本控制系统(VCS)如SVN的优势。一个主要的优点是它不依赖于中央服务器来存储项目文件的所有版本。</li><li id="f6f0" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">相反，每个开发人员“克隆”一个我在图中用“本地存储库”显示的存储库的副本，并且在他的硬盘上有项目的全部历史。因此，当出现服务器故障时，您需要做的只是恢复您队友的本地Git存储库。</li><li id="1a45" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">有一个中央云存储库，开发人员可以在那里提交更改并与其他队友共享。</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lx"><img src="../Images/17f24989c27cf120359a283a5b3b5136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqWrO2ZtO_gLvtbURsH7Sw.jpeg"/></div></div></figure><h2 id="63a8" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">3.什么是分布式VCS？</h2><ul class=""><li id="2b46" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">这些系统不依赖中央服务器来存储项目文件及其所有版本。</li><li id="a980" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">在分布式VCS中，每个贡献者都可以获得主存储库的本地副本或“克隆”。</li><li id="17a1" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">每个程序员都可以维护一个本地存储库，它实际上是存在于他们硬盘上的中央存储库的拷贝或克隆。他们可以毫无困难地提交和更新他们的本地存储库。</li><li id="5a96" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">通过称为“拉”的操作，他们可以用来自中央服务器的新数据更新他们的本地存储库，并且“拉”操作从他们的本地存储库影响对主存储库的改变。</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/30d2fba61a5db92e9fe7761b6a9412f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*hGpTYeSLgZQ8BZIZ1yEF-Q.png"/></div></figure><h2 id="ceae" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">4.Git和Github有什么区别？</h2><p id="9fe8" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git是一个分布式的版本控制系统，用于在软件开发过程中跟踪源代码的变化。它有助于协调程序员之间的工作，但也可以用来跟踪任何文件集的变化。Git的主要目标是速度、数据完整性和对分布式非线性工作流的支持。</p><p id="274f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">GitHub是一个Git存储库托管服务，另外它增加了许多自己的特性。GitHub提供了一个基于网络的图形界面。它还为每个项目提供了访问控制和几个协作功能、基本任务管理工具。</p><h2 id="ac1d" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">5.使用版本控制系统有什么好处？</h2><ul class=""><li id="7713" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">有了版本控制系统(VCS)，所有的团队成员都可以在任何时候自由地处理任何文件。VCS让你可以灵活地将所有的修改合并成一个通用版本。</li><li id="2618" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">所有以前的版本和变体都整齐地打包在VCS内。您可以根据自己的需求随时请求任何版本，并且您将立即获得整个项目的快照。</li><li id="0d32" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">每当您存储项目的新版本时，您的VCS都会要求您提供所做更改的简短描述。此外，您还可以看到文件内容发生了哪些变化。这有助于您了解项目中做了哪些更改以及由谁做的更改。</li><li id="c7e8" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">像Git这样的分布式VCS允许所有团队成员拥有项目的完整历史，因此如果中央服务器出现故障，您可以使用任何队友的本地Git存储库。</li></ul><h2 id="b036" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">6.Git用的是什么语言？</h2><p id="29ce" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">除了说出语言的名称，你还需要说出使用它的原因。我建议你这样回答:</p><p id="5dd8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="mc"> Git使用的是‘C’语言。GIT很快，而C语言通过减少与高级语言相关的运行时间开销使这成为可能。</em></p><h2 id="7450" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">7.提及各种Git存储库托管函数。</h2><ul class=""><li id="f017" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">开源代码库</li><li id="05ab" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">Gitlab</li><li id="efdf" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">比特桶</li><li id="26c1" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">一套合作式软件开发管理系统</li><li id="dc50" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">吉特企业</li></ul><h2 id="7152" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">8.什么是提交消息？</h2><p id="4441" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">用于写入提交消息的命令是“<code class="du md me mf mg b"><strong class="in hi">git commit -a</strong></code>”。<br/>现在解释一下-a标志，在命令行上说-a指示git提交所有被修改的跟踪文件的新内容。另外，如果第一次需要提交新文件，可以在git commit -a之前使用“<code class="du md me mf mg b"><strong class="in hi">git add &lt;file&gt;</strong></code>”。</p><h2 id="d94b" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">9.如何修复中断的提交？</h2><p id="52e1" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">为了修复任何损坏的提交，使用命令“<code class="du md me mf mg b">git commit --amend</code>”。运行此命令时，可以在编辑器中修复损坏的提交消息。</p><h2 id="6216" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">10.Git中的存储库是什么？</h2><p id="a594" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git中的存储库是Git存储所有文件的地方。Git可以将文件存储在本地存储库或远程存储库中。</p><h2 id="3f76" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">11.如何在Git中创建存储库？</h2><p id="1d72" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">这可能是最常被问到的问题，答案也很简单。</p><p id="97e0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要创建一个存储库，为项目创建一个目录(如果它不存在)，然后运行命令“<code class="du md me mf mg b"><strong class="in hi">git init</strong></code>”。通过运行这个命令。git目录将在项目目录中创建。</p><h2 id="f187" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">12.Git中的‘裸存储库’是什么？</h2><p id="9ac6" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git中的“空”存储库包含关于版本控制的信息，没有工作文件(没有树),也不包含特殊的。git子目录。相反，它包含。git子目录直接位于主目录中，而工作目录包含:</p><ol class=""><li id="9f5e" class="jj jk hh in b io ip is it iw jl ja jm je jn ji mh jp jq jr bi translated">答。git子目录，包含您的存储库的所有与Git相关的修订历史。</li><li id="aa25" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">工作树，或者签出项目文件的副本。</li></ol><h2 id="2c88" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">13.git中的“冲突”是什么？</h2><p id="f386" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git可以通过使用它的自动合并特性自己处理大多数合并。当两个独立的分支对文件中的同一行进行了编辑时，或者当一个文件在一个分支中被删除而在另一个分支中被编辑时，就会产生冲突。在团队环境中工作最容易发生冲突。</p><h2 id="15f3" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">14.git instaweb是怎么用的？</h2><p id="ac10" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><code class="du md me mf mg b">git instaweb'</code>用于自动引导网络浏览器，并通过一个接口运行网络服务器到您的本地存储库。</p><h2 id="50e8" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">15.什么是git is-tree？</h2><p id="64e1" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><code class="du md me mf mg b">git is-tree</code>表示树对象，包括每个项目的模式和名称以及斑点或树的SHA-1值。</p><h2 id="3e9f" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">16.列举几个Git命令并解释它们的用法。</h2><p id="d52c" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">下面是一些基本的Git命令:</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lj"><img src="../Images/d61c6395d6369138b8b63b58472145fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ3H3fM_nCHSzxbYkygCpQ.png"/></div></div></figure><h1 id="0c96" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">中级问题</h1><h2 id="213a" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">17.如何解决Git中的冲突？</h2><p id="7e54" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">以下步骤将解决Git中的冲突-</p><ol class=""><li id="b173" class="jj jk hh in b io ip is it iw jl ja jm je jn ji mh jp jq jr bi translated">确定导致冲突的文件。</li><li id="36c3" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">对文件进行必要的更改，以免再次发生冲突。</li><li id="c7c9" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">通过命令git add添加这些文件。</li><li id="5c81" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">最后，使用git commit命令提交更改后的文件</li></ol><h2 id="1522" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">18.在Git中，如何恢复一个已经提交并公开的提交？</h2><p id="6b06" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">有两种方法可以解决这个问题，并确保您包括这两种方法，因为根据具体情况，可以使用以下任何一种方法:</p><ul class=""><li id="8d94" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">在新的提交中删除或修复坏文件，然后将其推送到远程存储库。这是修复错误最明显的方法。一旦对文件进行了必要的修改，就使用命令git commit -m "commit message "将它提交给远程存储库</li><li id="4097" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">此外，您可以创建一个新的提交来撤消在错误提交中所做的所有更改。为此，请使用以下命令</li></ul><p id="ed25" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git revert&lt;name of bad commit&gt;</code></p><h2 id="048a" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">19.什么是SubGit？</h2><p id="7c0c" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">SubGit是SVN向Git迁移的工具。它可以创建本地或远程Subversion存储库的可写Git镜像，并且只要您愿意，就可以同时使用Subversion和Git。</p><p id="c1b6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，您还可以包括一些优势，比如您可以从Subversion到Git进行快速的一次性导入，或者在Atlassian Bitbucket Server中使用SubGit。我们可以使用SubGit来创建现有Subversion存储库的双向Git-SVN镜像。您可以根据自己的方便选择Git或Subversion。同步将由SubGit完成。</p><h2 id="a12a" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">20.git pull和git fetch有什么区别？</h2><p id="badc" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git pull命令从中央存储库中的特定分支获取新的变更或提交，并更新本地存储库中的目标分支。</p><p id="1b2a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Git fetch也用于同样的目的，但是它的工作方式略有不同。当您执行git获取时，它从所需的分支中提取所有新的提交，并将其存储在本地存储库中的一个新分支中。如果您想在目标分支中反映这些变化，git fetch之后必须有一个git merge。只有在合并目标分支和提取的分支后，才会更新目标分支。为了方便起见，请记住下面的等式:</p><blockquote class="mi mj mk"><p id="d1b2" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><strong class="in hi">Git pull = Git fetch+Git merge</strong></p></blockquote><h2 id="212a" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">21.Git中的‘staging area’或‘index’是什么？</h2><p id="8d9a" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">在完成提交之前，可以在称为“暂存区”或“索引”的中间区域对其进行格式化和检查。从图中可以明显看出，每个变更首先在我称之为“阶段文件”的阶段区域中被验证，然后该变更被提交到存储库。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/d10f42ca8e49c582f24319b1d9e5514c.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*jAhE9Zisnt_VF51EmY9eXg.png"/></div></figure><h2 id="d411" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">22.恢复删除的分支时，恢复了哪些工作？</h2><p id="98be" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">隐藏并保存在隐藏索引列表中的文件将被恢复回来。任何未被跟踪的文件都将丢失。此外，这是一个好主意，总是阶段和提交您的工作或隐藏它们。</p><p id="d836" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想要获取特定分支或标记的日志引用，那么运行命令—“<code class="du md me mf mg b">git reflog &lt;ref_name&gt;</code>”。</p><h2 id="d2d8" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">23.什么是git stash？</h2><p id="1a27" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">通常，当你一直在做项目的一部分时，事情处于一种混乱的状态，你想切换分支一段时间来做其他的事情。问题是，你不想提交一个完成了一半的工作，这样你就可以在以后回到这个点。这个问题的答案是Git stash。</p><p id="513e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Stashing获取您的工作目录，即您修改的跟踪文件和暂存的更改，并将其保存在一个未完成的更改堆栈中，您可以随时重新应用它。</p><h2 id="3a41" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">24.“git stash apply”的功能是什么？</h2><p id="c9b8" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">如果您想继续工作，那么使用'【T1]'命令将保存的更改恢复到您当前的工作目录。</p><h2 id="a98e" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">25.“git差异”和“git状态”之间有什么区别？</h2><p id="a62a" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><code class="du md me mf mg b">git diff</code>描绘了提交、提交和工作树之间的变化等。尽管'【T3]'向您展示了工作目录和索引之间的区别，但它有助于更全面地理解git。“git diff”类似于“git status”，唯一的区别是它显示了不同提交之间以及工作目录和索引之间的差异。</p><h2 id="0b44" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">26.“git远程”和“git克隆”有什么区别？</h2><p id="fa9b" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">“git remote add”在您的git配置中创建一个条目，指定一个特定URL的名称，而“git clone”通过复制位于该URL的现有存储库来创建一个新的git存储库</p><h2 id="ed86" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">27.什么是git stash drop？</h2><p id="fe56" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git 'stash drop '命令用于移除隐藏的项目。默认情况下，它将删除最后添加的隐藏项目，如果您将某个特定项目作为参数包含在内，它也可以删除该项目。</p><p id="0bf0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在举个例子。</p><p id="7aef" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想从隐藏项目列表中删除特定的隐藏项目，您可以使用以下命令:</p><p id="7d38" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> git stash list: </strong>它将显示隐藏项目的列表，如:<br/>stash @ { 0 }:WIP on master:049 d078添加了索引文件<br/>stash @ { 1 }:WIP on master:c 264051 Revert " added file _ size "<br/>stash @ { 2 }:WIP on master:21d 80 a5添加了编号到日志中</p><p id="4b25" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想要移除名为stash@{0}的项目，请使用命令<strong class="in hi"> git stash drop stash@{0} </strong>。</p><h2 id="8fed" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">28.如何找到在特定提交中发生更改的文件列表？</h2><p id="aaae" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">对于这个答案，不仅仅是告诉命令，而是解释这个命令到底要做什么。</p><p id="6d76" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要获取在特定提交中已更改的列表文件，请使用以下命令:</p><p id="956a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git diff-tree -r {hash}</code></p><p id="207f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">给定提交散列，这将列出在该提交中更改或添加的所有文件。-r标志使该命令列出单个文件，而不是仅将它们折叠成根目录名。</p><p id="7acf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你也可以包括下面提到的一点，虽然这是完全可选的，但会有助于给面试官留下深刻印象。</p><p id="96f7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">输出还将包含一些额外的信息，通过包含两个标志可以很容易地抑制这些信息:</p><p id="7a64" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git diff-tree --no-commit-id --name-only -r {hash}</code></p><p id="2b06" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Here -no-commit-id将禁止提交散列出现在输出中，而-name-only将只打印文件名，而不是它们的路径。</p><h2 id="eddc" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">29.“git config”的作用是什么？</h2><p id="15ae" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Git使用您的用户名将提交与身份相关联。git config命令可用于更改您的git配置，包括您的用户名。</p><p id="2e48" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在举例说明。</p><p id="9d8a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设您想要给出一个用户名和电子邮件id来将一个提交与一个身份相关联，这样您就可以知道谁进行了特定的提交。为此，我将使用:</p><p id="60c7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b"><strong class="in hi">git config -global user.name "Your Name"</strong></code> <strong class="in hi"> : </strong>该命令将添加一个用户名。<br/> <code class="du md me mf mg b"><strong class="in hi">git config -global user.email "Your E-mail Address"</strong></code> <strong class="in hi"> : </strong>该命令将添加一个电子邮件id。</p><h2 id="f097" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">30.提交对象包含什么？</h2><p id="999d" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">Commit对象包含以下组件，您应该提到下面介绍的所有三点:</p><ul class=""><li id="5834" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">一组文件，代表项目在给定时间点的状态</li><li id="7789" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">引用父提交对象</li><li id="f016" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">SHA-1名称，40个字符的字符串，唯一标识提交对象</li></ul><h2 id="9980" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">31.描述你用过的分支策略。</h2><ul class=""><li id="35b6" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated"><strong class="in hi">特征分支</strong> —特征分支模型将特定特征的所有变更保留在分支内。当这个特性被自动化测试充分测试和验证后，这个分支就被合并到主模块中。</li><li id="23c6" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">任务分支</strong> —在这个模型中，每个任务都在自己的分支上实现，任务关键字包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。</li><li id="235c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">发布分支</strong>——一旦开发分支为一个发布获得了足够的特性，您就可以克隆那个分支来形成一个发布分支。创建这个分支将开始下一个发布周期，因此在这之后不能添加新的特性，只有错误修复、文档生成和其他面向发布的任务应该放在这个分支中。一旦准备好发布，这个版本就会被合并到主版本中，并被加上一个版本号。此外，它应该被合并回开发分支，这个分支可能从发布开始就已经有进展了。</li><li id="d0a4" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">最后，告诉他们分支策略因组织而异，所以我知道基本的分支操作，如删除、合并、检出分支等。</li></ul><h2 id="80af" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">32.解释分叉工作流的优势</h2><ul class=""><li id="8f37" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">分叉工作流和其他流行的git工作流有一个基本的区别。它不是使用单一的服务器端作为“中央”代码库，而是为每个开发人员提供了他们自己的服务器端存储库。分叉工作流在公共开源项目中很常见。</li><li id="7705" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">分叉工作流的一个至关重要的优势是，贡献可以被集成，甚至不需要每个人都推到一个单一的中央存储库，这导致了干净的项目历史。开发人员可以推送到自己的服务器端资源库，但只有项目维护人员可以推送到官方资源库。</li><li id="c670" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">如果开发人员准备发布本地提交，那么他们会将提交推送到他们自己的公共存储库，而不是官方存储库。在这之后，他们向主存储库发出一个pull请求，让项目维护人员知道一个更新已经准备好被集成了。</li></ul><h2 id="c81e" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">33.如何在Git中知道一个分支是否已经被合并到master中？</h2><p id="ff41" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">答案很直接。</p><p id="5793" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要知道一个分支是否已经合并到主节点中，可以使用以下命令:</p><p id="9464" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b"><strong class="in hi">git branch --merged</strong></code> <strong class="in hi"> </strong> -列出已经合并到当前分支的分支。<br/> <strong class="in hi"> </strong> <code class="du md me mf mg b"><strong class="in hi">git branch --no-merged</strong></code> -列出未合并的分支。</p><h2 id="40ed" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">34.为什么创建额外的提交比修改现有的提交更可取？</h2><p id="3bc0" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">这有几个原因-</p><ol class=""><li id="14eb" class="jj jk hh in b io ip is it iw jl ja jm je jn ji mh jp jq jr bi translated">修改操作会破坏之前在提交中保存的状态。如果只是提交消息被更改，那就不是问题。但是如果内容被修改了，那么删除一些重要内容的机会就更大了。</li><li id="3fb5" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">滥用“git commit- amend”会导致小型提交的增长，并获得不相关的更改。</li></ol><h2 id="0892" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">35.Git中的“钩子”由什么组成？</h2><p id="bc53" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">该目录由shell脚本组成，如果运行相应的Git命令，就会激活这些脚本。例如，git将在您运行提交之后尝试执行提交后脚本。</p><h2 id="fc4d" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">36.在Git中，如何返回一个刚刚被推送并打开的提交？</h2><p id="d30f" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">可以通过使用git revert来恢复一个或多个提交。这个命令实际上创建了一个新的提交，其中的补丁抵消了特定提交中引入的更改。如果需要恢复的提交已经发布，或者不能更改存储库历史，那么在这种情况下，可以使用git revert来恢复提交。如果您运行以下命令，它将恢复最后两次提交:</p><p id="ab51" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git revert HEAD~2..HEAD</code></p><p id="4092" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或者，总是有一个选项可以从过去检查特定提交的状态，然后重新提交。</p><h2 id="3467" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">37.如何从git中删除一个文件而不从你的文件系统中删除它？</h2><p id="8ef8" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">在git添加过程中必须小心，否则您可能会添加不想提交的文件。但是，git rm会将它从您的临时区域(索引)和文件系统(工作树)中删除，这可能不是您想要的。</p><p id="90da" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">相反，使用git reset:</p><p id="60de" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git reset filename</code> #或</p><p id="e425" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">echo filename &gt;&gt; .gitingore</code> #添加到。gitignore以避免重新添加它</p><p id="dd4f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这意味着git重置<paths>与git添加<paths>完全相反。</paths></paths></p><h2 id="1191" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">38.能解释一下Gitflow的工作流程吗？</h2><p id="1dd6" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">为了记录项目的历史，Gitflow工作流采用了两个并行的长期运行的分支—主和开发:</p><ul class=""><li id="fef8" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">master——这个分支总是准备好发布上线，所有的东西都经过了充分的测试和批准(生产就绪)。</li><li id="d183" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">热修复程序—这些分支用于快速修补生产版本。这些分支很像发布分支和特性分支，除了它们是基于master而不是developing。</li><li id="6333" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">开发-这是所有功能分支合并到的分支，也是执行所有测试的地方。只有当一切都被彻底检查和修复后，它才能被合并到主文件中。</li><li id="aca4" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">feature——每个新特性应该驻留在它自己的分支中，可以作为它们的父特性推送到develop分支。</li></ul><h2 id="9d7e" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">39.告诉我HEAD，working tree和index的区别，用Git表示。</h2><ul class=""><li id="ca39" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">工作树/工作目录/工作区是您可以查看和编辑的(源)文件的目录树。</li><li id="c9b9" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">索引/暂存区是<baseofrepo> /中的一个大型二进制文件。git/index，它列出了当前分支中的所有文件、它们的SHA-1校验和、时间戳以及文件名——它不是另一个包含文件副本的目录。</baseofrepo></li><li id="a166" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">HEAD用于引用当前签出分支中的最后一次提交。</li></ul><h2 id="a00f" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">40.Git fork是什么？分叉、分支和克隆的区别是什么？</h2><ul class=""><li id="c95f" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">分支是存储库的副本。通常情况下，您会派生一个存储库，这样您就可以在不影响原始项目的情况下自由地试验变更。最常见的是，forks要么被用来对其他人的项目提出修改建议，要么被用来将其他人的项目作为自己想法的起点。</li><li id="dc02" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">git克隆意味着指向一个现有的存储库，并在一个新的目录中的某个其他位置制作该存储库的副本。原始存储库可以位于本地文件系统或远程机器可访问的支持协议上。git clone命令用于创建现有git存储库的副本。</li><li id="3070" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">简单地说，git分支是git存储库中的单个项目。一个存储库中的不同分支可以有完全不同的文件和文件夹，或者除了一个文件中的一些代码行之外，它可以有所有相同的内容。</li></ul><h2 id="25c9" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">41.有哪些不同的方式可以引用提交？</h2><ul class=""><li id="125b" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">在Git中，每次提交都有一个惟一的散列。这些哈希用于在各种场景中标识相应的提交，例如，在尝试使用git checkout {hash}命令检查代码的特定状态时。</li><li id="4712" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">除此之外，Git还维护了一些特定提交的别名，称为refs。此外，在存储库中创建的每个标记实际上都变成了一个ref，这就是为什么您可以在各种git命令中使用标记而不是提交散列的原因。Git还维护许多特殊的别名，这些别名根据存储库的状态而改变，比如HEAD、FETCH_HEAD、MERGE_HEAD等。</li><li id="3d00" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">在Git中，提交被允许相对于彼此引用。在合并提交的情况下，提交有两个父级，^可用于选择两个父级中的一个，例如，HEAD可用于跟随第二个父级。</li><li id="94aa" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">最后，refspecs用于将本地和远程分支映射在一起。然而，这些也可以用来引用驻留在远程分支上的提交，允许从本地git环境控制和操作它们。</li></ul><h2 id="2aa4" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">42.Git中的rebasing和merge有什么区别？</h2><ul class=""><li id="22cc" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">在Git中，rebase命令用于将一个分支的更改集成到另一个分支中。它是“合并”命令的替代选项。rebase和merge之间的区别在于rebase重写了提交历史，以便产生一个直接的、线性的提交序列。</li><li id="0b78" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">合并是Git将分叉的历史重新组合在一起的方式。git merge命令帮助您将git branch创建的独立开发线集成到一个分支中。</li></ul><h2 id="8a54" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">43.解释恢复和重置之间的区别。</h2><ul class=""><li id="cefe" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">Git reset是一个强大的命令，用于撤销对Git存储库状态的本地更改。Git重置在“Git的三棵树”上操作，这三棵树是提交历史(HEAD)、暂存索引和工作目录。</li><li id="7928" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">Git中的Revert命令创建了一个新的提交，该提交撤销了上一次提交的更改。此命令向项目添加新的历史记录。它不会修改现有的历史记录。</li></ul><h2 id="6de7" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">44.什么是git cherry-pick？</h2><p id="a70d" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">git cherry-pick命令通常用于将特定的提交从存储库中的一个分支引入到另一个分支。另一个常见的用途是将提交从维护分支向前或向后转移到开发分支。这与其他方式形成对比，例如合并和rebase，它们通常将许多提交应用到另一个分支上。</p><p id="3223" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">考虑:</p><p id="e64e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git cherry-pick &lt;commit-hash&gt;</code></p><h2 id="7a99" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">45.如何找到在特定提交中发生更改的文件列表？</h2><p id="db4f" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><code class="du md me mf mg b">git diff-tree -r {hash}</code></p><p id="5629" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">给定提交散列，这将列出在该提交中更改或添加的所有文件。<em class="mc"> -r </em>标志使命令列出单个文件，而不是将它们折叠成根目录名。</p><p id="054d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">输出还将包含一些额外的信息，通过包含几个标志可以很容易地抑制这些信息:</p><p id="6f9f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du md me mf mg b">git diff-tree --no-commit-id --name-only -r {hash}</code></p><p id="16bb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里<em class="mc"> -no-commit-id </em>将禁止提交散列出现在输出中，而<em class="mc"> -name-only </em>将只打印文件名，而不是它们的路径。</p><h1 id="3b90" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">高级问题</h1><h2 id="3615" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">46.如何将最后N次提交压缩成一次提交？</h2><p id="ee1f" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">有两个选项可以将最后N次提交压缩到一次提交中。在您的答案中包括下面提到的两个选项</p><p id="6096" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想从头开始编写新的提交消息，请使用以下命令<br/> <code class="du md me mf mg b">git reset -soft HEAD~N &amp;&amp;git commit</code></p><p id="fbf5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果你想用现有提交消息的连接来编辑新的提交消息，那么你需要提取这些消息并将它们传递给Git commit，为此我将使用<br/> <code class="du md me mf mg b">git reset -soft HEAD~N &amp;&amp;git commit -edit -m"$(git log -format=%B -reverse <a class="ae mp" href="mailto:HEAD..HEAD@%7b1%7d" rel="noopener ugc nofollow" target="_blank">.HEAD@{N}</a>)<strong class="in hi">"</strong></code></p><h2 id="f177" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">47.Git平分是什么？如何使用它来确定(回归)错误的来源？</h2><ul class=""><li id="1f30" class="jj jk hh in b io ls is lt iw ly ja lz je ma ji jo jp jq jr bi translated">Git二等分用于通过使用二分搜索法找到引入错误的提交。Git等分的命令是<br/> <code class="du md me mf mg b"><strong class="in hi">git bisect &lt;subcommand&gt; &lt;options&gt;</strong></code></li><li id="3c5d" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">现在，既然您提到了上面的命令，请向他们解释这个命令将会做什么。</li><li id="d365" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">该命令使用二分搜索法算法来查找项目历史中哪个提交引入了bug。首先告诉它一个已知包含bug的“坏”提交，以及一个已知在引入bug之前的“好”提交。然后Git二等分在这两个端点之间选择一个提交，并询问您所选择的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。</li></ul><h2 id="0540" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">48.如何配置Git存储库在提交之前运行代码完整性检查工具，并在测试失败时阻止它们？</h2><p id="1149" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">我建议你先简单介绍一下健全检查。</p><p id="31ea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">健全性或冒烟测试确定继续测试是否可能和合理。</p><p id="b7a5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在解释如何实现这一点。</p><p id="8b8b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这可以通过一个与存储库的预提交挂钩相关的简单脚本来完成。在提交之前，甚至在要求您输入提交消息之前，就会触发预提交挂钩。在这个脚本中，可以运行其他工具，比如linters，并对提交到存储库中的变更执行健全性检查。</p><p id="4e9a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，举一个例子，你可以参考下面的脚本:</p><pre class="lk ll lm ln fd mq mg mr ms aw mt bi"><span id="11e5" class="kv jy hh mg b fi mu mv l mw mx">#!/bin/sh<br/>files=$(git diff –cached –name-only –diff-filter=ACM | grep ‘.go$’)<br/>if [ -z files ]; then<br/>exit 0<br/>fi<br/>unfmtd=$(gofmt -l $files)<br/>if [ -z unfmtd ]; then<br/>exit 0<br/>fi<br/>echo “Some .go files are not fmt’d”<br/>exit 1</span></pre><p id="088f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个脚本检查是否有。将要提交的go文件需要通过标准的Go源代码格式化工具gofmt。通过以非零状态退出，脚本有效地防止了提交被应用到存储库。</p><h2 id="90d0" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">49.如何将Git与Jenkins集成在一起？</h2><p id="2773" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><strong class="in hi">第一步</strong>。单击jenkins仪表板上的“管理jenkins”按钮。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es my"><img src="../Images/c35177f83d16f63c9a6cc0e33b1def36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sw3qXVkkt1CyxqT1cl6LEA.png"/></div></div></figure><p id="53c3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">第二步</strong>。点击管理詹金斯插件。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es mz"><img src="../Images/6104f0060cd444c9d1c39f59a969955c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*e533NwMb5ltuS8VR1K-fVg.png"/></div></figure><p id="f827" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">第三步:</strong>在插件页面</p><ol class=""><li id="5e6a" class="jj jk hh in b io ip is it iw jl ja jm je jn ji mh jp jq jr bi translated">选择GIT插件</li><li id="283d" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">点击<strong class="in hi">安装，无需重启。</strong>根据您的互联网连接，该插件将需要一些时间来完成下载，并将自动安装。</li><li id="7730" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">您也可以选择选项<strong class="in hi">立即下载并在重启后安装</strong>，在重启后安装插件</li><li id="0cf2" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mh jp jq jr bi translated">如果你已经安装了Git插件，你将会看到一个“没有更新可用”的消息。</li></ol><p id="9a52" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">步骤4 </strong>:插件安装完成后，在Jenkins仪表盘上进入<strong class="in hi">管理Jenkins </strong>。你会看到你的插件列在其他插件中。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es na"><img src="../Images/109f86043520696b425028c2e83b68d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wj_qDWw_iWcwuCqoeHAWQg.png"/></div></div></figure><h2 id="e022" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">50.什么是git reflog？</h2><p id="dcc2" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated">“reflog”命令保持对存储库的引用(分支或标签)中的 <strong class="in hi">的每一个变化的<strong class="in hi">跟踪，并保持本地创建或检出的分支和标签的日志历史。引用日志，例如分支何时被创建或克隆、检出、重命名的提交快照，或者在分支上进行的任何提交都由<a class="ae mp" href="https://www.edureka.co/blog/what-is-git/" rel="noopener ugc nofollow" target="_blank"> Git </a>维护，并由“reflog”命令列出。</strong></strong></p><p id="8c5b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="mc">只有当分支曾经存在于您的本地存储库中时，才可以从您的工作目录中恢复该分支，也就是说，该分支要么是在本地创建的，要么是从您的本地存储库中的远程存储库中检出的，以便Git存储其引用历史日志。</em></p><p id="1940" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该命令必须在具有丢失分支的存储库中执行。如果您考虑远程存储库的情况，那么您必须在拥有分支的开发人员的机器上执行reflog命令。</p><h2 id="d295" class="kv jy hh bd jz kw kx ky kd kz la lb kh iw lc ld kl ja le lf kp je lg lh kt li bi translated">51.如何使用git reflog恢复删除的分支？</h2><p id="74cc" class="pw-post-body-paragraph il im hh in b io ls iq ir is lt iu iv iw lu iy iz ja lv jc jd je lw jg jh ji ha bi translated"><strong class="in hi">第一步</strong> : <strong class="in hi">所有引用的历史日志</strong></p><p id="a722" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">获取此存储库中所有引用的所有本地记录历史日志的列表(“master”、“uat”和“prepod”)。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/a7c93f0e384f9d82c3c0b151c37409f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*ExyHsMe_lA5J3f9-7CPbCQ.png"/></div></figure><p id="0eef" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">第二步:识别历史印记</strong></p><p id="baa0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从上面的快照可以看出，突出显示的提交id: e2225bb和头指针索引:4是从指向您最新工作的当前头指针创建“预编程”分支时的提交id。</p><p id="2dd0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">第三步</strong> : <strong class="in hi">恢复</strong></p><p id="1e9b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想要恢复回“preprod”分支，则使用命令“git checkout”传递带有索引id-4的头指针引用。这是创建“预编程”分支时的指针引用，长提交id在输出屏幕截图中突出显示。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es nc"><img src="../Images/936e560bafed0f8288c0d0eb9a648b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1k0E5JxkRReYrCVSUKdwA.png"/></div></div></figure><p id="9e03" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我已经包括了常见的Git面试问题。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考<a class="ae mp" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=git-interview-questions" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="f3be" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请留意本系列中的其他文章，它们将解释DevOps的各个方面。</p><blockquote class="mi mj mk"><p id="c4f0" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 1。</em>T22<em class="hh">devo PS教程</em>T25】</p><p id="400c" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 2。</em> <a class="ae mp" rel="noopener" href="/edureka/git-tutorial-da652b566ece"> <em class="hh"> Git教程</em> </a></p><p id="e900" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 3。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-tutorial-68110a2b4bb3"> <em class="hh">詹金斯教程</em> </a></p><p id="7324" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 4。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-tutorial-9a6a6140d917"> <em class="hh">码头工人教程</em> </a></p><p id="0110" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 5。</em> <a class="ae mp" rel="noopener" href="/edureka/ansible-tutorial-9a6794a49b23"> <em class="hh"> Ansible教程</em> </a></p><p id="4b6e" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 6。</em> <a class="ae mp" rel="noopener" href="/edureka/puppet-tutorial-848861e45cc2"> <em class="hh">木偶教程</em> </a></p><p id="4327" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 7。</em> <a class="ae mp" rel="noopener" href="/edureka/chef-tutorial-8205607f4564"> <em class="hh">厨师教程</em> </a></p><p id="7abb" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">8。 <a class="ae mp" rel="noopener" href="/edureka/nagios-tutorial-e63e2a744cc8"> <em class="hh"> Nagios教程</em> </a></p><p id="f389" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 9。</em> <a class="ae mp" rel="noopener" href="/edureka/devops-tools-56e7d68994af"> <em class="hh">如何编排DevOps工具？</em> </a></p><p id="019b" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 10。</em> <a class="ae mp" rel="noopener" href="/edureka/continuous-delivery-5ca2358aedd8"> <em class="hh">连续交货</em> </a></p><p id="3453" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 11。</em> <a class="ae mp" rel="noopener" href="/edureka/continuous-integration-615325cfeeac"> <em class="hh">持续集成</em> </a></p><p id="6c24" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 12。</em> <a class="ae mp" rel="noopener" href="/edureka/continuous-deployment-b03df3e3c44c"> <em class="hh">连续部署</em> </a></p><p id="727d" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 13。</em> <a class="ae mp" rel="noopener" href="/edureka/continuous-delivery-vs-continuous-deployment-5375642865a"> <em class="hh">持续交付vs持续部署</em> </a></p><p id="ec0d" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 14。</em> <a class="ae mp" rel="noopener" href="/edureka/ci-cd-pipeline-5508227b19ca"> <em class="hh"> CI CD管道</em> </a></p><p id="970c" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 15。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-compose-containerizing-mean-stack-application-e4516a3c8c89"> <em class="hh"> Docker作曲</em> </a></p><p id="9770" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 16。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-swarm-cluster-of-docker-engines-for-high-availability-40d9662a8df1"> <em class="hh">码头工人群</em> </a></p><p id="b191" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 17。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-networking-1a7d65e89013"> <em class="hh"> Docker联网</em> </a></p><p id="e2d2" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 18。</em><a class="ae mp" rel="noopener" href="/edureka/ansible-vault-secure-secrets-f5c322779c77"><em class="hh"/></a></p><p id="c09b" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 19。</em><a class="ae mp" rel="noopener" href="/edureka/ansible-roles-78d48578aca1"><em class="hh"/></a></p><p id="c8d3" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 20。</em> <a class="ae mp" rel="noopener" href="/edureka/ansible-for-aws-provision-ec2-instance-9308b49daed9"> <em class="hh">适用于AWS </em> </a></p><p id="342e" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 21。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-pipeline-tutorial-continuous-delivery-75a86936bc92"> <em class="hh">詹金斯管道</em> </a></p><p id="8b42" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 22。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-commands-29f7551498a8"> <em class="hh">顶级Docker命令</em> </a></p><p id="0280" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 23。</em> <a class="ae mp" rel="noopener" href="/edureka/git-vs-github-67c511d09d3e"> <em class="hh"> Git vs GitHub </em> </a></p><p id="2e26" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">24。 <a class="ae mp" rel="noopener" href="/edureka/git-commands-with-example-7c5a555d14c"> <em class="hh">顶级Git命令</em> </a></p><p id="18db" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 25。</em> <a class="ae mp" rel="noopener" href="/edureka/devops-interview-questions-e91a4e6ecbf3"> <em class="hh"> DevOps面试问题</em> </a></p><p id="0e91" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 26。</em> <a class="ae mp" rel="noopener" href="/edureka/devops-engineer-role-481567822e06"> <em class="hh">谁是DevOps工程师？</em> </a></p><p id="d282" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">27。 <a class="ae mp" rel="noopener" href="/edureka/devops-lifecycle-8412a213a654"> <em class="hh"> DevOps生命周期</em> </a></p><p id="f2e4" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh">二十八。</em><a class="ae mp" rel="noopener" href="/edureka/git-reflog-dc05158c1217"><em class="hh">Git ref log</em></a></p><p id="fa2b" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 29。</em><a class="ae mp" rel="noopener" href="/edureka/ansible-provisioning-setting-up-lamp-stack-d8549b38dc59"><em class="hh"/></a></p><p id="04ea" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 30。</em> <a class="ae mp" rel="noopener" href="/edureka/devops-skills-f6a7614ac1c7"> <em class="hh">组织正在寻找的顶尖DevOps技能</em> </a></p><p id="6165" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">30。 <a class="ae mp" rel="noopener" href="/edureka/waterfall-vs-agile-991b14509fe8"> <em class="hh">瀑布vs敏捷</em> </a></p><p id="bb80" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 31。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-cheat-sheet-e0f7e25558a3"> <em class="hh">詹金斯小抄</em> </a></p><p id="24e4" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 32。</em> <a class="ae mp" rel="noopener" href="/edureka/ansible-cheat-sheet-guide-5fe615ad65c0"> <em class="hh"> Ansible备忘单</em> </a></p><p id="07df" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 33。</em> <a class="ae mp" rel="noopener" href="/edureka/ansible-interview-questions-adf8750be54"> <em class="hh"> Ansible面试问答</em> </a></p><p id="f770" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 34。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-interview-questions-da0010bedb75"> <em class="hh"> 50码头工人面试问题</em> </a></p><p id="ce66" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 35。</em> <a class="ae mp" rel="noopener" href="/edureka/what-is-agile-methodology-fe8ad9f0da2f"> <em class="hh">敏捷方法论</em> </a></p><p id="ae5a" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 36。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-interview-questions-7bb54bc8c679"> <em class="hh">詹金斯面试问题</em> </a></p><p id="b64e" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 37。</em> <a class="ae mp" rel="noopener" href="/edureka/maven-tutorial-2e87a4669faf"> <em class="hh"> Maven用于构建Java应用</em> </a></p><p id="80a8" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 38。</em> <a class="ae mp" rel="noopener" href="/edureka/docker-architecture-be79628e076e"> <em class="hh"> Docker架构</em> </a></p><p id="85e5" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 39。</em><a class="ae mp" rel="noopener" href="/edureka/linux-commands-in-devops-73b5a2bcd007"><em class="hh">devo PS中使用的Linux命令</em> </a></p><p id="9c02" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 40。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯vs竹子</em> </a></p><p id="467c" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">41。 <a class="ae mp" rel="noopener" href="/edureka/nagios-tutorial-e63e2a744cc8"> <em class="hh"> Nagios教程</em> </a></p><p id="48e5" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">42。 <a class="ae mp" rel="noopener" href="/edureka/nagios-interview-questions-f3719926cc67"> <em class="hh"> Nagios面试问题</em> </a></p><p id="5597" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 43。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-x-d87c0271af57"> <em class="hh"> DevOps实时场景</em> </a></p><p id="fd0b" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated"><em class="hh"> 44。</em> <a class="ae mp" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯和詹金斯X的区别</em> </a></p><p id="04a1" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">45。<a class="ae mp" rel="noopener" href="/edureka/docker-for-windows-ed971362c1ec"><em class="hh">Windows Docker</em></a></p><p id="4741" class="il im mc in b io ip iq ir is it iu iv ml ix iy iz mm jb jc jd mn jf jg jh ji ha bi translated">46。<a class="ae mp" href="http://git%20vs%20github/" rel="noopener ugc nofollow" target="_blank"><em class="hh">Git vs Github</em></a></p></blockquote></div><div class="ab cl nd ne go nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ha hb hc hd he"><p id="12bb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="mc">原载于2019年8月29日</em><a class="ae mp" href="https://www.edureka.co/blog/interview-questions/git-interview-questions/" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://www.edureka.co</em></a><em class="mc"/></p></div></div>    
</body>
</html>