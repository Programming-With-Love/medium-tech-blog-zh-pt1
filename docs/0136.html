<html>
<head>
<title>Better Android Testing at Airbnb — Part 6: Consistent Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb更好的Android测试——第6部分:一致的嘲笑</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f?source=collection_archive---------4-----------------------#2019-12-27">https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f?source=collection_archive---------4-----------------------#2019-12-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c41f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Airbnb Android测试系列的第六部分，我们来看看剥落的常见来源以及如何减轻它们。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ef73738e28faaac4749f6787d18c8c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ph_0TfXeEiE1rh9keSmKQ.jpeg"/></div></div></figure><p id="e827" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">的上一篇文章</a>中，我们详述了我们的测试框架实现。这是对我们运行测试所采取的方法的一个高层次的审视。然而，为了使框架尽可能的稳定，我们在框架中加入了许多小细节。本文详细介绍了其中最重要的几个。</p><h1 id="6b9d" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">持续嘲笑的障碍</h1><p id="e6a5" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">与我们的测试框架的一场持久的战斗是最小化剥落的来源。这些可以以多种不同的方式表现出来，并导致诸如轻微的屏幕截图差异、不同的片段状态或虚假的崩溃。</p><p id="140f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我们使用了Flank，这个问题变得更加复杂，它动态地将测试分配到碎片中。这意味着测试顺序是不断变化的。一次测试可能会使应用程序处于某种状态，这种状态会影响后面的测试，但由于测试顺序的不可预测性，这不会是一致的。</p><p id="b78d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Android的Test Orchestrator可以帮助防止这些问题，但不幸的是，我们目前不能使用它，因为它使我们的测试时间延长了七倍。相反，我们采取手动清除测试之间共享状态的方法，并尽力防止内存泄漏，这可能会导致许多测试运行后崩溃。</p><p id="330b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面我们介绍一些我们遇到的片状剥落问题，以及我们如何解决它们。总的来说，我们发现有必要让所有的产品特性都使用相同的模式和架构，这样就可以在底层工具中一次修复缺陷，从而实现可扩展的解决方案。这可能需要在普通API周围提供一个包装器，以加强它们是如何被使用或模仿的。</p><h2 id="a789" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">异步代码</h2><p id="bb9c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">有许多异步执行代码的方法，工程师可能会选择做一些他们特性中不可预知的事情。例如，异步代码的常用工具有RxJava、Kotlin协同例程、AsyncTasks、Executors，甚至手动创建和管理线程。任何定制的方法都不可能被测试框架所控制。通常这是可以的，因为片段UI应该被冻结到不可更改的模仿状态，但是偶尔异步代码会导致意想不到的副作用。</p><p id="9def" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将意外副作用的可能性降至最低，我们提供了自己的函数作为执行异步代码的访问点，并鼓励工程师使用这些函数。这允许测试框架阻止代码运行，或者检测代码何时完成。</p><p id="d16a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，MvRx使用名为“<strong class="ig hi"> <em class="jc"> execute </em> </strong>”的扩展函数来订阅RxJava Observables。MvRx嘲讽系统允许“<strong class="ig hi"> <em class="jc">执行</em> </strong>”的行为被改变，使得可观察对象永远不会被订阅。</p><p id="a38a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们使用依赖注入将测试协程范围注入到我们的视图模型中，这样协程就不会实际运行。</p><p id="d5a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这两种情况下，我们都可以报告一个可观察的或协同程序被执行以响应点击，因此相应的细节显示在最终的交互报告中。</p><h2 id="5be0" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">视图中的缓存状态</h2><p id="240a" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Android View类经常缓存数据以提高性能。例如，如果视图不认为自己是“脏的”，则draw调用可能什么也不做，并且度量细节可以被缓存，以便如果视图没有改变，后续的度量过程不必重新计算任何东西。当我们需要强制布局活动以显示整个RecyclerView，然后将所有内容绘制到自定义画布上时，这些缓存在屏幕截图测试中可能会有问题。例如，ConstraintLayout有一个测量缓存，导致我们的强制屏幕截图布局无法按预期显示。</p><p id="cd33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的解决方案是遍历视图层次结构，并在所有视图上调用<strong class="ig hi"><em class="jc">【invalidate()</em></strong>和<strong class="ig hi"><em class="jc">request layout()</em></strong>。这保证了它们为我们的屏幕截图正确布局，并且它们完全将自己绘制到我们的自定义画布上。</p><h2 id="2dc8" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">共享偏好</h2><p id="44eb" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如果一个模仿改变了共享的偏好，它会影响后面的模仿。Android Test Orchestrator也不能解决这个问题，因为我们的框架在一次测试中运行多个模拟。解决方案很简单，在每次模拟之后，让测试框架明确共享的偏好。这可以扩展到任何其他类型的存储，如缓存、本地文件或数据库。</p><h2 id="1fe2" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">日期</h2><p id="161b" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">充分模仿日期对于减少测试的白点是至关重要的。日期本来就不可靠，因为UI代码通常引用当前时间。由于测试以不断变化的日期值重新运行，屏幕截图可以显示不断更新的文本，如果任何参数包含日期，交互报告也会受到影响。</p><p id="2409" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里唯一的解决方案是能够模拟Date框架，以便获取当前日期和时间的调用返回一致的模拟值。在Airbnb，我们使用JodaTime，包装在一个自定义的内部API中，隐藏了JodaTime的实现细节。这允许我们拦截和模拟任何对今天的<strong class="ig hi"><em class="jc">()</em></strong>)或<strong class="ig hi"><em class="jc">()</em></strong>的调用。</p><h2 id="42d1" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">抽屉</h2><p id="7cb0" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">对我们来说，一个反复出现的问题是屏幕截图的差异，这是由于从drawable resources加载的图标中存在细微的像素差异。出于性能原因，Android维护了一个从资源加载的drawables缓存，底层位图可以在多个位置共享。由于我们不断变化的测试顺序，我们在测试中遇到的已经缓存的位图并不一致，缓存的版本可能会有所不同。</p><p id="b337" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一个案例中，问题是由修改drawable位图的代码引起的——将其更改为对drawable调用mutate首先防止缓存版本被更改并修复了剥落。由于这个原因，您应该小心地在共享位图上调用mutate，但是我们无法使用这种方法来解决所有的可绘制性剥落问题。</p><p id="429f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们能够通过在每次截图后强制清除缓存来解决剥落问题。没有明确公开的API来实现这一点，所以我们使用一种方法，这种方法利用了缓存在不兼容的配置更改时被清除的事实，我们可以像这样强制:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a775" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，这种方法并不理想，它使用了受限制和不推荐使用的API，并且依赖于对这些函数的实现细节的理解。我们现在只在API 28上测试，目前它很好地满足了我们的需求，但可能需要在未来进行调整。</p><h2 id="35bb" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">内存不足异常</h2><p id="7c87" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这些崩溃有两个潜在的原因:</p><ol class=""><li id="bb95" class="lj lk hh ig b ih ii il im ip ll it lm ix ln jb lo lp lq lr bi translated">被测代码中的内存泄漏</li><li id="6969" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">截屏过程中位图的低效管理。</li></ol><p id="4f9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了最小化内存泄漏，我们将每个测试片段的目标持续时间保持在三分钟，以最小化在单个过程中运行的测试数量。此外，我们运行泄漏金丝雀来检测和报告泄漏。</p><p id="a3b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在截图库中，我们可能需要捕捉长达40，000像素的位图。为了做到这一点，我们在所有截图中重复使用相同的位图，如果需要的话，回收并创建一个新的更大的位图。我们还在清单中启用了大堆的情况下运行应用程序。</p><h2 id="a8e2" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">延迟运行</h2><p id="b33e" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们发现特性偶尔会用<strong class="ig hi"> <em class="jc">处理程序#postDelay </em> </strong>执行可运行的回调。一个常见的用例是强调一些UI动画，比如在确认消息显示后等待完成一个活动。虽然我们能够检测到主线程何时空闲(如前所述)，但是这种空闲检测不能应用于稍后提交运行的Runnables，所以我们没有办法解释延迟的代码。</p><p id="3d8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们让功能代码在需要延迟回调时调用包装函数。当测试框架处于活动状态时，这个包装器立即执行runnable。这种包装方法的另一个好处是，我们提供了一个更符合Kotlin习惯的函数，比如<strong class="ig hi"><em class="jc">fragment . post(delay ms:Number = 0，callback: () - &gt; Unit) </em> </strong>。</p><p id="f2d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，在我们基于状态的架构中，理想情况下，UI不会执行状态中没有跟踪的任意动作。然而，有时动画需要这样做，这是实现基本UI行为的最简单的方法。只要UI足够健壮，能够从可能中断已发布回调的配置更改中恢复，这就没问题。</p><h2 id="2db7" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">非嘲笑状态</h2><p id="8867" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">为了使屏幕行为具有确定性和可控性，屏幕应该只使用来自ViewModel状态的数据。乍一看，这似乎很简单，但我们偶尔会遇到违反的情况。如果该片段引用了任何注入的依赖项、可能访问单例的静态方法调用或可变的操作系统级调用(如获取设备区域设置),就会发生这种情况。</p><p id="92f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的应用程序中，我们仍然有一些遗留系统是通过静态方法而不是依赖注入来访问的，这些系统通常被错误地访问。除了增加测试碎片的可能性，像这样滥用状态模式也意味着测试框架没有测试丢失数据的变化。Lint规则有助于防止像这样的反模式用法，而带有依赖注入的良好项目架构可以强制实施最佳实践。</p><h2 id="bb06" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">图像加载</h2><p id="e704" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">显示图像的UI必须异步加载这些位图，这对测试来说是个问题。虽然加载图像是理想的，因为它充分测试了图像加载代码和行为，但它很麻烦，原因有几个:</p><ul class=""><li id="de76" class="lj lk hh ig b ih ii il im ip ll it lm ix ln jb lx lp lq lr bi translated">测试框架必须能够检测所有图像何时加载。</li><li id="f5d4" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">图像加载可以有几种状态，如加载占位符、增量缩略图、失败资源和最终成功状态。我们不能简单地分别测试所有这些，或者简单地区分它们。</li><li id="63e7" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">如果图像是从网络加载的，那么有可能由于网络问题而出现零星故障，从而导致碎片。</li><li id="9f53" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">等待图像加载会增加测试时间。</li><li id="a0cc" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">即使我们允许加载图像，当截屏时，我们的测试框架会同步显示完整的活动，包括所有RecyclerView项目，这些项目可能最初没有显示。在这种情况下，我们不能等待新布局视图中的图像被加载，因为截图过程是同步发生的。</li></ul><p id="c7a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的应用程序中，我们通过覆盖任何图像加载请求，而不是强制插入同步加载的本地可绘制资源来进行妥协。这有以下好处:</p><ul class=""><li id="7239" class="lj lk hh ig b ih ii il im ip ll it lm ix ln jb lx lp lq lr bi translated">在截图中显示实际图像，而不是空白点</li><li id="f1bf" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">介绍一些图像加载行为，如ImageView scaleType</li><li id="4c67" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lx lp lq lr bi translated">同步工作，因此不需要等待图像加载的复杂性</li></ul><p id="ce7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然这个解决方案并不完美，但对我们来说是一个很好的妥协。此外，我们仍然允许屏幕通过一组映射到不同本地测试资产的测试URL来加载模拟中的不同图像。Mock state可以选择使用哪些图像URL来改变截图中加载的图像类型，这有助于提高截图的质量。</p><p id="1af0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法是可行的，因为我们有一个所有功能都使用的集中式自定义ImageView体系结构。这使得嘲弄发生在我们的图像基础设施内的单一位置，对产品工程师来说完全不透明。</p><p id="3b27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们的JSON报告捕获了在ImageView上设置的url，所以即使我们没有截屏结果图片，我们仍然测试片段加载了预期的url。</p><h2 id="88fd" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">Webview嘲讽</h2><p id="6aa7" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">网络视图面临着与图像视图相似的问题。加载内容的网络请求不稳定，很难准确等待。此外，加载的内容不受我们的控制，可能会随时更改截图位图。</p><p id="0e48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在我们的测试中，我们禁止所有的网页浏览者加载内容。这是通过将Android WebView包装在我们自己的自定义视图中来实现的，这样我们就可以在一个中心位置模拟它。</p><p id="2c18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，像ImageViews一样，我们的JSON报告捕获要加载的url，以及其他数据，如用户代理、标题和请求类型。这有助于验证比截图更多的数据。</p><h2 id="19c5" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">RecyclerView预取</h2><p id="e597" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">默认情况下，当UI线程在帧之间空闲时，RecyclerView的LinearLayoutManager会预取其视口之外的屏幕视图。我们发现这可能会导致片状剥落，因为如果一个视图是由系统完全布局的，那么它的行为可能会不同于由我们的截屏系统同步布局的情况。值得注意的是，在第一种情况下，动画将100%完成，但在第二种情况下，动画将仅处于开始状态。</p><p id="5ae2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，一般来说，我们发现最好禁用那些行为不一致的系统。在这种情况下，预取可能会发生，也可能不会发生，这取决于我们在截图之前空闲了多长时间。</p><p id="2c28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，我们禁用这种行为；在测试活动布局一个片段后，它遍历RecyclerView实例的视图层次结构，并通过<strong class="ig hi"><em class="jc">setitempeffetchenabled(false)</em></strong>禁用所有LayoutManagers上的预取。</p><h1 id="699c" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步:CI设置</h1><p id="af91" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">本文展示了一系列常见的缺陷来源，以及我们如何在测试框架中从根本上消除它们。</p><p id="da44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f">在我们的最后一篇文章</a>中，我们将介绍当工程师修改代码时，我们的测试是如何在CI上自动生成和运行的。</p><h2 id="8cc4" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">系列索引</h2><p id="18cd" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这是关于Airbnb测试的七篇系列文章。</p><p id="c733" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第1部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a">测试原理和模拟系统</a></p><p id="1e87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第2部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab">使用MvRx和Happo进行截图测试</a></p><p id="84b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第3部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4">自动化交互测试</a></p><p id="2c2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第4部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8">单元测试框架视图模型</a></p><p id="82e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第5部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">我们自动化测试框架的架构</a></p><p id="c6c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第六部分(本文)</strong> — <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f">一致嘲讽的障碍</a></p><p id="461f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第7部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f">测试生成和CI配置</a></p><h2 id="a56a" class="kt jr hh bd js ku kv kw jw kx ky kz ka ip la lb ke it lc ld ki ix le lf km lg bi translated">我们在招人！</h2><p id="e896" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">想和我们一起在这些和其他大规模的Android项目上合作吗？Airbnb正在全公司招聘几个Android工程师职位！有关当前空缺，请参见<a class="ae jp" href="https://careers.airbnb.com/" rel="noopener ugc nofollow" target="_blank">https://careers.airbnb.com</a>。</p></div></div>    
</body>
</html>