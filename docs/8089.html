<html>
<head>
<title>React Hooks: Concept of Virtualisation!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks:虚拟化概念！</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/react-hooks-concept-of-virtualisation-ea3c1515f14c?source=collection_archive---------2-----------------------#2022-01-04">https://medium.com/walmartglobaltech/react-hooks-concept-of-virtualisation-ea3c1515f14c?source=collection_archive---------2-----------------------#2022-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="12f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你是一个前端开发人员，你肯定在渲染一个巨大的菜单列表时遇到过这个问题。只是渲染和更新太花时间了。我们可以实现很多解决方案来解决无限滚动和分页这样的问题。但是今天，我们将探讨虚拟化的概念。</p><p id="2077" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虚拟化是什么概念？<br/> 简单来说，这是一种技术，其中我们在任何给定的时间仅呈现项目/行的小子集，这将在窗口中对用户实际可见。一旦用户开始滚动，我们就呈现下一组项目，并删除那些看不到的项目。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/738e49ceb738aa04e634f22c64562e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lywe5xkucDSI0eQrw0nuw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">React Virtualisation</figcaption></figure><p id="4521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经知道了我们想要达到的目标，让我们深入探讨如何在这个概念上创造一些简单的挂钩。<br/>但在我们开始React虚拟化之前，让我们看看如何使用IntersectionObserver观察渲染的项目并跟踪它们在窗口中的可见性。</p><p id="023b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么是IntersectionObserver？<br/></strong><em class="js">intersection observer API提供了一种异步观察目标元素与祖先元素或顶级文档视窗的交集变化的方法。</em></p><p id="ac47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，我们有一个观察器，它将观察目标相对于某个父元素的情况，并且每当某个阈值被匹配时，它将调用一个回调方法。</p><p id="2ebf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用IntersectionObserver钩子的实现</strong></p><pre class="jd je jf jg fd jt ju jv jw aw jx bi"><span id="f150" class="jy jz hh ju b fi ka kb l kc kd">import { useEffect, useRef, useState, useCallback } from "react";<br/><br/>const useIntersectionObserver = (elementRef, observerOptions, callback) =&gt; {<br/><br/>  const [intersectionState, setIntersectionState] = useState({});<br/>  const observerCallback = useRef();<br/>  observerCallback.current = callback;<br/><br/>  const overallCallback = useCallback(([newIntersectionState]) =&gt; {<br/>    setIntersectionState(newIntersectionState);<br/>    if(observerCallback.current) observerCallback.current(newIntersectionState);<br/>  }, [setIntersectionState]);<br/><br/>  useEffect(() =&gt; {<br/>    const element = elementRef &amp;&amp; elementRef.current;<br/>    const hasSupport = !!window.IntersectionObserver;<br/><br/>    if (!element || !hasSupport) return;<br/>    <br/>    const {<br/>      root = null,<br/>      rootMargin = "0%",<br/>      threshold = 0,<br/>      ...restOptions<br/>    } = observerOptions;<br/><br/>    const observer = new IntersectionObserver(<br/>      overallCallback,<br/>      {<br/>        root,<br/>        rootMargin,<br/>        threshold,<br/>        ...restOptions<br/>      }<br/>    );<br/><br/>    observer.observe(element);<br/><br/>    return () =&gt; observer.disconnect();<br/>  }, [elementRef, observerOptions, overallCallback])<br/><br/>  return {<br/>    intersectionState<br/>  }<br/>};<br/><br/>export default useIntersectionObserver;</span></pre><p id="65c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们开始实现我们的虚拟化挂钩</p><p id="4ea2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">use virtualization hook的实现</strong></p><pre class="jd je jf jg fd jt ju jv jw aw jx bi"><span id="f59a" class="jy jz hh ju b fi ka kb l kc kd">import { useLayoutEffect, useState, useMemo, useCallback, useRef } from "react";<br/>import { useIntersectionObserver } from "./useIntersectionObserver";<br/>import { useSyncStateRef } from "./useSyncStateRef";<br/><br/>const INITIAL_VIRTUAL_STATE = {<br/>  virtualBucketStart: 0,<br/>  virtualBucketMiddle: 0,<br/>  virtualBucketEnd: 1,<br/>  calculatedStartIndex: 0,<br/>  calculatedEndIndex: 1<br/>};<br/><br/>export const useVirtualisation = ({ childrensCount = 0, parentRef }) =&gt; {<br/>  const [syncParentRef] = useSyncStateRef({ ref: parentRef });<br/>  const [virtualState, setVirtualState] = useState({ ...INITIAL_VIRTUAL_STATE });<br/>  const middleChildRef = useRef();<br/><br/>  const boundVirtualIndex = useCallback(<br/>    (nextStepIndex) =&gt; {<br/>      return Math.min(Math.max(nextStepIndex, 0), childrensCount);<br/>    },<br/>    [childrensCount]<br/>  );<br/><br/>  const getExtraPaddedIndexes = useCallback(<br/>    (startIndex, endIndex) =&gt; {<br/>      const boundedStartIndex = boundVirtualIndex(startIndex);<br/>      const boundedEndIndex = Math.max(boundedStartIndex, boundVirtualIndex(endIndex));<br/>      const totalRootWidthInElements = boundedEndIndex - boundedStartIndex;<br/>      const nextStartIndex = boundVirtualIndex(boundedStartIndex - totalRootWidthInElements);<br/>      const nextEndIndex = boundVirtualIndex(boundedEndIndex + totalRootWidthInElements);<br/>      const nextMiddleIndex = Math.ceil((boundedStartIndex + boundedEndIndex) / 2);<br/><br/>      return {<br/>        virtualBucketStart: nextStartIndex,<br/>        virtualBucketEnd: nextEndIndex,<br/>        virtualBucketMiddle: nextMiddleIndex,<br/>        calculatedStartIndex: startIndex,<br/>        calculatedEndIndex: endIndex<br/>      };<br/>    },<br/>    [boundVirtualIndex]<br/>  );<br/><br/>  const safelyGetVirtualisedState = useCallback(<br/>    (startIndex, endIndex) =&gt; {<br/>      return getExtraPaddedIndexes(startIndex, endIndex);<br/>    },<br/>    [getExtraPaddedIndexes]<br/>  );<br/><br/>  const hasStateChangedForCallback = (asyncVirtualState, syncVirtualState) =&gt; {<br/>    const {<br/>      virtualBucketStart: asyncVirtualBucketStart,<br/>      virtualBucketMiddle: asyncVirtualBucketMiddle,<br/>      virtualBucketEnd: asyncVirtualBucketEnd,<br/>      childRef: asyncChildRef<br/>    } = asyncVirtualState;<br/>    const {<br/>      virtualBucketStart: syncVirtualBucketStart,<br/>      virtualBucketMiddle: syncVirtualBucketMiddle,<br/>      virtualBucketEnd: syncVirtualBucketEnd,<br/>      childRef: syncChildRef<br/>    } = syncVirtualState;<br/>    return !(<br/>      asyncVirtualBucketStart === syncVirtualBucketStart &amp;&amp;<br/>      asyncVirtualBucketMiddle === syncVirtualBucketMiddle &amp;&amp;<br/>      asyncVirtualBucketEnd === syncVirtualBucketEnd &amp;&amp;<br/>      asyncChildRef === syncChildRef<br/>    );<br/>  };<br/><br/>  const getBodyRemainingTopHeight = () =&gt; {<br/>    const element = middleChildRef?.current;<br/>    if (!element) return 50;<br/>    const { virtualBucketStart } = virtualState;<br/>    return virtualBucketStart * (element.clientHeight || 50);<br/>  };<br/><br/>  const getBodyRemainingBottomHeight = () =&gt; {<br/>    const element = middleChildRef?.current;<br/>    if (!element) return 50;<br/>    const { virtualBucketEnd } = virtualState;<br/>    return (childrensCount - virtualBucketEnd) * (element.clientHeight || 50);<br/>  };<br/><br/>  const shouldUpdate = (virtualBucketStart, virtualBucketEnd, startIndex, endIndex) =&gt; {<br/>    return startIndex !== virtualBucketStart || endIndex !== virtualBucketEnd;<br/>  };<br/><br/>  const getRoughClientHeightEstimate = (intersectionState) =&gt; {<br/>    const boundingClientRect = intersectionState?.boundingClientRect;<br/>    return boundingClientRect?.height || 50;<br/>  };<br/><br/>  const getSlideEstimateForScroll = (intersectionState) =&gt; {<br/>    const rootBounds = intersectionState?.rootBounds;<br/>    const boundingClientRect = intersectionState?.boundingClientRect;<br/>    if (!rootBounds || !boundingClientRect) return [0, 1];<br/>    const height = getRoughClientHeightEstimate(intersectionState);<br/>    const { bottom: rootBottom, top: rootTop } = rootBounds;<br/>    const { bottom: clientBottom, top: clientTop } = boundingClientRect;<br/>    const topElementsDifference = Math.ceil(Math.abs(rootTop - clientTop) / height);<br/>    const bottomElementsDifference = Math.ceil(Math.abs(rootBottom - clientBottom) / height);<br/>    const startIndexSteps = rootTop &lt;= clientTop<br/>      ? topElementsDifference + 1<br/>      : -(topElementsDifference - 1);<br/>    const endIndexSteps =<br/>      clientBottom &lt;= rootBottom ? bottomElementsDifference + 1 : -(bottomElementsDifference - 1);<br/>    return [-startIndexSteps, endIndexSteps];<br/>  };<br/><br/>  const getNextScrollStep = (intersectionState, targetRefIndex) =&gt; {<br/>    const [nextStartIndex, nextEndIndex] = getSlideEstimateForScroll(intersectionState);<br/>    return [<br/>      boundVirtualIndex(targetRefIndex + nextStartIndex),<br/>      boundVirtualIndex(targetRefIndex + nextEndIndex)<br/>    ];<br/>  };<br/><br/>  const generateSetScrollState = (targetRef, targetRefIndex) =&gt; {<br/>    const asyncVirtualState = { ...virtualState, childRef: targetRef?.current };<br/>    const setScrollState = (newIntersectionState) =&gt; {<br/>      const [intersectionState] = newIntersectionState;<br/>      setVirtualState((syncVirtualState) =&gt; {<br/>        const { calculatedStartIndex, calculatedEndIndex } = syncVirtualState;<br/>        const syncChildRef = intersectionState?.target;<br/>        if (<br/>          hasStateChangedForCallback(<br/>            asyncVirtualState,<br/>            { ...syncVirtualState, childRef: syncChildRef }<br/>          )<br/>        ) return syncVirtualState;<br/>        const [startIndex, endIndex] = getNextScrollStep(intersectionState, targetRefIndex);<br/>        return shouldUpdate(calculatedStartIndex, calculatedEndIndex, startIndex, endIndex)<br/>          ? safelyGetVirtualisedState(startIndex, endIndex)<br/>          : syncVirtualState;<br/>      });<br/>    };<br/><br/>    return setScrollState;<br/>  };<br/><br/>  const observerOptions = useMemo(() =&gt; {<br/>    const rootRef = syncParentRef?.current;<br/>    return {<br/>      threshold: 1,<br/>      rootMargin: "10px",<br/>      root: rootRef<br/>    };<br/>  }, [syncParentRef]);<br/><br/>  useIntersectionObserver({<br/>    elementRef: middleChildRef,<br/>    observerOptions,<br/>    callback: generateSetScrollState(middleChildRef, virtualState.virtualBucketMiddle)<br/>  });<br/><br/>  useLayoutEffect(() =&gt; {<br/>    setVirtualState((oldVirtualState) =&gt; {<br/>      const { calculatedStartIndex, calculatedEndIndex } = {<br/>        ...INITIAL_VIRTUAL_STATE,<br/>        ...oldVirtualState<br/>      };<br/>      return safelyGetVirtualisedState(calculatedStartIndex, calculatedEndIndex);<br/>    });<br/>  }, [parentRef, safelyGetVirtualisedState]);<br/><br/>  return {<br/>    virtualState,<br/>    middleChildRef,<br/>    topHeight: getBodyRemainingTopHeight(),<br/>    bottomHeight: getBodyRemainingBottomHeight(),<br/>    element: { type: middleChildRef?.current?.localName }<br/>  };<br/>};</span></pre><p id="c5f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">要使用的助手组件使用虚拟化挂钩</strong></p><pre class="jd je jf jg fd jt ju jv jw aw jx bi"><span id="c490" class="jy jz hh ju b fi ka kb l kc kd">import { useVirtualisation } from "../utility";<br/>import React, { Fragment } from "react";<br/><br/><br/>export const Virtualisation = ({<br/>  childrensCount = 0,<br/>  completeRowsProp,<br/>  childRenderer,<br/>  parentRef,<br/>}) =&gt; {<br/>  const { topHeight, bottomHeight, element, middleChildRef, virtualState } = useVirtualisation({<br/>    childrensCount,<br/>    parentRef<br/>  });<br/>  const { virtualBucketStart, virtualBucketEnd, virtualBucketMiddle } = virtualState;<br/>  const renderPaddingElement = (elementHeight) =&gt; {<br/>    const sampleElement = element;<br/>    return !!elementHeight &amp;&amp; element?.type &amp;&amp; &lt;sampleElement.type style={{ height: elementHeight }} /&gt;;<br/>  };<br/><br/>  const setRef = (node) =&gt; {<br/>    if (node) middleChildRef.current = node;<br/>    return node;<br/>  };<br/><br/>  const renderVirtualisedChildren = () =&gt; {<br/>    return (<br/>      Array.isArray(completeRowsProp) &amp;&amp;<br/>      completeRowsProp<br/>        .slice(virtualBucketStart, virtualBucketEnd)<br/>        .map((row, index) =&gt;<br/>          childRenderer(row, index + virtualBucketStart === virtualBucketMiddle &amp;&amp; ((node) =&gt; setRef(node)))<br/>        )<br/>    );<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      {renderPaddingElement(topHeight)}<br/>      {renderVirtualisedChildren()}<br/>      {renderPaddingElement(bottomHeight)}<br/>    &lt;/Fragment&gt;<br/>  );<br/>};</span></pre><p id="124a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">到底是怎么回事？<br/> </strong>让我们一个一个的过代码。</p><ol class=""><li id="ffcb" class="ke kf hh ig b ih ii il im ip kg it kh ix ki jb kj kk kl km bi translated">首先，我们将一个ref附加到父元素和列表中呈现的中间元素(最初是第一个元素)。</li><li id="7246" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">然后，我们使用IntersectionObserver计算实际的可见区域，然后是应该呈现的第一个元素和最后一个元素。</li><li id="698d" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">现在，利用这些信息，我们可以得到下一个中间元素，并开始观察这个元素。一旦这个元素移出窗口范围，我们就计算下一组应该呈现的元素。</li></ol><p id="bea8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">还有最后的结局！<br/> </strong>观察几件事:</p><ol class=""><li id="e97b" class="ke kf hh ig b ih ii il im ip kg it kh ix ki jb kj kk kl km bi translated">仅呈现那些对用户可见的元素。</li><li id="e48c" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">当用户开始滚动时，我们添加下一个元素。之前可见但不可见的元素也被移除。</li></ol><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ks"><img src="../Images/6b6288a5684ebdfb4282a7231ff270b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZBdXJdYAsVG91ZIT1-U8mg.gif"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Demo: React Virtualisation</figcaption></figure><h1 id="c3b9" class="kt jz hh bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">推荐人和证明人:</h1><div class="lq lr ez fb ls lt"><a href="https://reactjs.org/docs/optimizing-performance.html#virtualize-long-lists" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab dw"><div class="lv ab lw cl cj lx"><h2 class="bd hi fi z dy ly ea eb lz ed ef hg bi translated">优化性能-反应</h2><div class="ma l"><h3 class="bd b fi z dy ly ea eb lz ed ef dx translated">在内部，React使用了几种巧妙的技术来最小化更新…</h3></div><div class="mb l"><p class="bd b fp z dy ly ea eb lz ed ef dx translated">reactjs.org</p></div></div><div class="mc l"><div class="md l me mf mg mc mh jm lt"/></div></div></a></div><div class="lq lr ez fb ls lt"><a href="https://addyosmani.com/blog/react-window/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab dw"><div class="lv ab lw cl cj lx"><h2 class="bd hi fi z dy ly ea eb lz ed ef hg bi translated">用react-window渲染大型列表</h2><div class="ma l"><h3 class="bd b fi z dy ly ea eb lz ed ef dx translated">如果您使用React并需要高效地显示大型数据列表，您可能对react-virtualized比较熟悉。这是…</h3></div><div class="mb l"><p class="bd b fp z dy ly ea eb lz ed ef dx translated">addyosmani.com</p></div></div><div class="mc l"><div class="mi l me mf mg mc mh jm lt"/></div></div></a></div><div class="lq lr ez fb ls lt"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab dw"><div class="lv ab lw cl cj lx"><h2 class="bd hi fi z dy ly ea eb lz ed ef hg bi translated">intersect observer API-Web API | MDN</h2><div class="ma l"><h3 class="bd b fi z dy ly ea eb lz ed ef dx translated">IntersectionObserver API提供了一种异步观察目标元素交集变化的方法…</h3></div><div class="mb l"><p class="bd b fp z dy ly ea eb lz ed ef dx translated">developer.mozilla.org</p></div></div><div class="mc l"><div class="mj l me mf mg mc mh jm lt"/></div></div></a></div></div></div>    
</body>
</html>