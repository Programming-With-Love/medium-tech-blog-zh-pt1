<html>
<head>
<title>Android Data Binding: Custom Setters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:自定义设置器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-custom-setters-55a25a7aea47?source=collection_archive---------0-----------------------#2016-08-26">https://medium.com/androiddevelopers/android-data-binding-custom-setters-55a25a7aea47?source=collection_archive---------0-----------------------#2016-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4f5d0f7eb05b7415969fc0928287006f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUZUVog_MUeoBOCpWmd15w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="8508" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">让数据绑定做你想做的</h2></div><p id="9257" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我希望那些读过我以前关于Android数据绑定的文章的人一直在玩它。您可能已经将android:text绑定到TextViews，将android:checked绑定到复选框，甚至可能尝试过在EditText上使用android:text进行双向数据绑定。内置属性被很好地覆盖了，并且合成了新的标签来绑定到事件。然而，这对自定义视图没有帮助。还有，怎么自定义设置逻辑？</p><h2 id="0e53" class="kd ke hs bd kf kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx bi translated">绑定到Setters</h2><p id="a7fb" class="pw-post-body-paragraph jh ji hs jj b jk ky it jm jn kz iw jp jq la js jt ju lb jw jx jy lc ka kb kc ha bi translated">我的应用程序有一个自定义视图，颜色选择器:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="47a9" class="kd ke hs li b fi lm ln l lo lp"><strong class="li ht">public class </strong>ColorPicker <strong class="li ht">extends </strong>View {<br/>    <strong class="li ht">private int color</strong>;<br/><br/>    <strong class="li ht">public void </strong>setColor(<strong class="li ht">int </strong>color) {<br/>        <strong class="li ht">this</strong>.<strong class="li ht">color </strong>= color;<br/>        invalidate();<br/>    }<br/><br/>    <strong class="li ht">public int </strong>getColor() {<br/>        <strong class="li ht">return color</strong>;<br/>    }</span><span id="fd1a" class="kd ke hs li b fi lq ln l lo lp">    <strong class="li ht">public void </strong>addListener(OnColorChangeListener listener) {<br/>        //...<br/>    }</span><span id="b902" class="kd ke hs li b fi lq ln l lo lp"><strong class="li ht">    public void </strong>removeListener(OnColorChangeListener listener) {<br/>        //...<br/>    }</span><span id="09f0" class="kd ke hs li b fi lq ln l lo lp">    //...<br/>}</span></pre><p id="87ad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我想用数据绑定来设置颜色。事实证明，这种类型的设置器不需要任何代码。数据绑定系统自动寻找与数据绑定属性同名的setter。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="3e3c" class="kd ke hs li b fi lm ln l lo lp">&lt;<strong class="li ht">com.example.myapp.ColorPicker<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <em class="lr">app:color="@{color}"</em></strong>/&gt;</span></pre><h2 id="02f6" class="kd ke hs bd kf kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx bi translated">绑定适配器</h2><p id="4806" class="pw-post-body-paragraph jh ji hs jj b jk ky it jm jn kz iw jp jq la js jt ju lb jw jx jy lc ka kb kc ha bi translated">有时我们想做一些比简单地在视图上调用setter更复杂的事情。我最喜欢的例子是从UI线程中加载图像。首先，我需要选择一个自定义属性来将图像分配给ImageView。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="587f" class="kd ke hs li b fi lm ln l lo lp">&lt;<strong class="li ht">ImageView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <em class="lr">app:imageUrl="@{product.imageUrl}"</em></strong>/&gt;</span></pre><p id="c430" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果我什么都不做，数据绑定系统会在ImageView上寻找一个“setImageUrl(String)”而找不到。我必须创建一种方法来设置“app:imageUrl”属性。绑定适配器是任何类中用来做这件事的带注释的方法。通常，您会根据目标视图类型将适配器组织到一个类中。</p><p id="a340" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我不打算推广任何特定的图像库，所以让我们为我们的绑定适配器假设一个通用的图像库:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="f0e8" class="kd ke hs li b fi lm ln l lo lp">@BindingAdapter(<strong class="li ht">"imageUrl"</strong>)<br/><strong class="li ht">public static void </strong>setImageUrl(ImageView imageView, String url) {<br/>    <strong class="li ht">if </strong>(url == <strong class="li ht">null</strong>) {<br/>        imageView.setImageDrawable(<strong class="li ht">null</strong>);<br/>    } <strong class="li ht">else </strong>{<br/>        MyImageLoader.loadInto(imageView, url);<br/>    }<br/>}</span></pre><p id="f7d7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">BindingAdapter注释将属性名作为其参数。应用程序名称空间中的任何内容都不需要参数中的任何名称空间，但是对于android名称空间中的属性，您必须给出完整的属性名称，包括“android”</p><p id="7000" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">第一个方法参数是目标视图的类型。第二个是设置给属性的值。</p><p id="302c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">MyImageLoader库将从UI线程中加载图像，并在完成后将其设置到ImageView中。虽然UI线程在图像加载时不再挂起，但是ImageView在加载期间仍然是空的，我真的希望在那里有一个占位符。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="dacc" class="kd ke hs li b fi lm ln l lo lp">&lt;<strong class="li ht">ImageView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <em class="lr">app:imageUrl="@{product.imageUrl}"</em><br/>    <em class="lr">app:placeholder="@{@drawable/shadowAvatar}"</em></strong>/&gt;</span></pre><p id="6e02" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，这两种属性相互作用。如果已经加载了产品图像，我不希望显示占位符图像。当图像加载时，我希望加载程序能够交叉淡入淡出图像。因此，我们的绑定适配器必须处理多个属性:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="44d0" class="kd ke hs li b fi lm ln l lo lp">@BindingAdapter(value={<strong class="li ht">"imageUrl", "placeholder"}, </strong>requireAll=<strong class="li ht">false</strong>)<br/><strong class="li ht">public static void </strong>setImageUrl(ImageView imageView, String url,<br/>        Drawable placeHolder) {<br/>    <strong class="li ht">if </strong>(url == <strong class="li ht">null</strong>) {<br/>        imageView.setImageDrawable(placeholder);<br/>    } <strong class="li ht">else </strong>{<br/>        MyImageLoader.loadInto(imageView, url, placeholder);<br/>    }<br/>}</span></pre><p id="dff9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当处理多个属性时，属性必须放在一个列表中。该方法的参数与<em class="lr">值</em>的顺序相同。我还将<em class="lr"> requireAll </em>设置为false。如果我将其保留为默认值true，那么绑定适配器将要求调用URL和占位符。当<em class="lr"> requireAll </em>设置为false时，如果没有设置URL或占位符值，仍然可以使用未设置属性的默认值(在本例中为null)调用绑定适配器。</p><p id="1549" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个绑定适配器中，MyImageLoader可以完成它需要的所有功能，使用URL和占位符图像对ImageView进行操作。</p><h2 id="4aa0" class="kd ke hs bd kf kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx bi translated">设置事件处理程序</h2><p id="beed" class="pw-post-body-paragraph jh ji hs jj b jk ky it jm jn kz iw jp jq la js jt ju lb jw jx jy lc ka kb kc ha bi translated">在设置事件处理程序时，简单的setter非常简单——只需使用与setter方法相同的属性名称。通常，您希望能够添加任意数量的侦听器。在这种情况下，您有“添加”和“移除”方法，而不是“设置”方法。</p><p id="f255" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我的ColorPicker就有这种用于“onColorChange”事件的监听器。最简单的方法是删除旧的侦听器，然后添加新的侦听器。幸运的是，数据绑定为我们提供了确切的功能。为了检索旧值，绑定适配器方法应该为每个属性采用两个参数，首先是所有旧值，然后是所有新值:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="909f" class="kd ke hs li b fi lm ln l lo lp">@BindingAdapter(<strong class="li ht">"onColorChange"</strong>)<br/><strong class="li ht">public static void </strong>setColorChangeListener(ColorPicker view, <br/>        OnColorChangeListener oldListener, <br/>        OnColorChangeListener newListener) {<br/>   <strong class="li ht">if </strong>(oldListener != <strong class="li ht">null</strong>) {<br/>        view.removeListener(oldListener);<br/>   }</span><span id="f0c9" class="kd ke hs li b fi lq ln l lo lp">   <strong class="li ht">if</strong> (newListener != <strong class="li ht">null</strong>) {<br/>       view.addListener(newListener);<br/>   }<br/>}</span></pre><p id="f00c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您会看到旧值对于这个绑定适配器是多么有用。旧值不仅适用于事件侦听器，这是最常见的用法。任何时候您不能从视图中检索旧值并且需要它，只需为旧值添加参数。</p><p id="4f56" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们的监听器是这样声明的:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="b635" class="kd ke hs li b fi lm ln l lo lp"><strong class="li ht">public interface </strong>OnColorChangeListener {<br/>    <strong class="li ht">void </strong>onColorChange(ColorPicker colorPicker, <strong class="li ht">int </strong>newColor);<br/>}</span></pre><p id="f35f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为OnColorChangeListener只有一个抽象方法，所以数据绑定框架可以知道如何处理lambda方法和方法引用:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2eb7" class="kd ke hs li b fi lm ln l lo lp">&lt;<strong class="li ht">com.example.myapp.ColorPicker<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <em class="lr">app:onColorChange="@{(v, color)-&gt;handler.colorChanged(color)}"<br/></em>    app:color="@{color}"</strong>/&gt;</span></pre><p id="9cf7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它自动将抽象方法(在本例中是onColorChange)与声明的lambda表达式关联起来。这都是在编译时完成的，所以在应用程序中没有任何反射。</p><p id="0821" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">将事件属性命名为与方法名称相同的名称，以防止开发人员混淆。</p><h2 id="f25e" class="kd ke hs bd kf kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx bi translated">结论</h2><p id="6876" class="pw-post-body-paragraph jh ji hs jj b jk ky it jm jn kz iw jp jq la js jt ju lb jw jx jy lc ka kb kc ha bi translated">Android数据绑定在大多数情况下不需要任何代码就能完成您想要的工作——只需调用视图上的setter。当您想要更复杂的东西时，您还可以使用绑定适配器根据需要进行调整。</p><p id="c92c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">人们已经提出了绑定适配器的一些伟大而有趣的用途。例如，<a class="ae ls" href="https://plus.google.com/+LisaWrayZeitouni/posts/LTr5tX5M9mb" rel="noopener ugc nofollow" target="_blank"> Lisa Wray使用绑定适配器来设置自定义字体</a>。您还可以将值从一种状态变为另一种状态。也许你能想出一些很棒的用途。如果你想到一些聪明的东西，请张贴出来，让我们知道。</p></div></div>    
</body>
</html>