# 掌握 JavaScript 面试:什么是纯函数？

> 原文：<https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976?source=collection_archive---------0----------------------->

![](img/82fd66bc123b608ee333e16fc4349a47.png)

Image: Pure — carnagenyc (CC-BY-NC 2.0)

纯函数对于各种目的都是必不可少的，包括函数式编程、可靠并发和 React+Redux 应用。但是“纯函数”是什么意思呢？

一个**纯函数**是这样一个函数:

*   给定相同的输入，总是返回相同的输出。
*   不会产生副作用。

我们将通过[“跟随 Eric Elliott 学习 JavaScript”](http://ericelliottjs.com/product/lifetime-access-pass/)的一堂免费课来回答这个问题:

在我们讨论什么是纯函数之前，最好仔细研究一下函数。可能有一种不同的方式来看待它们，这将使函数式编程更容易理解。

## 什么是函数？

一个**函数**是一个过程，它接受一些输入，称为**自变量**，并产生一些输出，称为**返回值**。功能可用于以下目的:

*   **映射:**根据给定的输入产生一些输出。函数**将**输入值映射到输出值。
*   **程序:**可以调用一个函数来执行一系列步骤。该序列称为程序，这种方式的编程称为**程序编程**。
*   **I/O:** 一些功能用于与系统的其他部分通信，如屏幕、存储器、系统日志或网络。

## 绘图

纯函数都是关于映射的。函数将输入参数映射到返回值，这意味着对于每组输入，都存在一个输出。一个函数将接受输入并返回相应的输出。

*`Math.max()`* 以数字为参数，返回最大的数字:

```
Math.max(2, 8, 5); // 8
```

在本例中，2、8 和 5 是*参数*。它们是传递给函数的值。

*`Math.max()`* 是一个接受任意数量的参数并返回最大参数值的函数。在这种情况下，我们传入的最大数字是 8，这是返回的数字。

函数在计算和数学中非常重要。它们帮助我们以有用的方式处理数据。优秀的程序员给函数起描述性的名字，这样当我们看到代码的时候，我们就能看到函数的名字并理解函数的作用。

数学也有函数，它们的工作方式很像 JavaScript 中的函数。你可能在代数中见过函数。它们看起来像这样:

*f*(*x*)= 2*x*

这意味着我们声明了一个函数 f，它有一个参数 x，然后把 x 乘以 2。

要使用这个函数，我们只需为 x 提供一个值:

*f* (2)

在代数中，这和写作的意思完全一样:

4

所以任何你看到 *f* (2)的地方都可以代入 4。

现在让我们将该函数转换成 JavaScript:

```
const double = x => x * 2;
```

您可以使用 *`console.log()`* 检查函数的输出:

```
console.log( double(5) ); // 10
```

记得我说过在数学函数中，你可以用 *`4`* 代替 *`f(2)`* ？在这种情况下，JavaScript 引擎用答案 *`10`* 替换 *`double(5)`* 。

## 纯函数

一个**纯函数**是这样一个函数:

*   给定相同的输入，将总是返回相同的输出。
*   不会产生副作用。

So，*` console . log(double(5))；`*同*` console . log(10)；`*

这是真的，因为 *`double()`* 是一个纯函数，但是如果 *`double()`* 有副作用，比如将值保存到磁盘或记录到控制台，你不能简单地将 *`double(5)`* 替换为 10 而不改变其含义。

如果你想要引用透明，你需要使用纯函数。

> 一个函数不纯的确凿证据是，如果不使用它的返回值调用它是有意义的。对于纯函数，那是一个 noop。

我建议你偏爱纯函数。也就是说，如果使用纯函数来实现一个程序需求是可行的，那么你应该优先使用它们。纯函数接受一些输入，并基于该输入返回一些输出。它们是程序中最简单的可重用代码块。也许计算机科学中最重要的设计原则是 KISS(保持简单，笨蛋)。我更喜欢简单明了。纯函数以最好的方式变得愚蠢而简单。

纯函数有许多有益的性质，并且形成了**函数式编程**的基础。纯函数完全独立于外部状态，因此，它们不受与共享可变状态有关的整类错误的影响。它们的独立性也使它们成为跨多个 CPU 和整个分布式计算集群进行并行处理的绝佳候选，这使得它们对于许多类型的科学和资源密集型计算任务来说是必不可少的。

纯函数也非常独立——易于在代码中移动、重构和重组，使您的程序更加灵活，更能适应未来的变化。

## 共享状态的问题是

几年前，我开发了一个应用程序，允许用户在数据库中搜索音乐艺术家，并将艺术家的音乐播放列表加载到网络播放器中。这大约是 Google Instant 登陆的时间，当你输入搜索查询时，它会显示即时搜索结果。AJAX 驱动的自动完成突然风靡一时。

唯一的问题是用户输入的速度经常比 API 自动完成搜索响应返回的速度快，这导致了一些奇怪的错误。这将触发竞争条件，新的建议将被过时的建议所取代。

为什么会这样？因为每个 AJAX 成功处理程序都有权直接更新显示给用户的建议列表。最慢的 AJAX 请求总是通过盲目替换结果来赢得用户的注意，即使那些被替换的结果可能是更新的。

为了解决这个问题，我创建了一个建议管理器——管理查询建议状态的单一数据源。它知道当前有一个挂起的 AJAX 请求，当用户输入新内容时，挂起的 AJAX 请求会在新请求发出之前被取消，因此每次只有一个响应处理程序能够触发 UI 状态更新。

任何种类的异步操作或并发都可能导致类似的竞争情况。如果输出依赖于不可控事件的序列(如网络、设备延迟、用户输入、随机性等)，就会发生竞争情况。事实上，如果你使用共享状态，并且该状态依赖于根据不确定因素而变化的序列，对于所有意图和目的，输出是不可能预测的，这意味着不可能正确地测试或完全理解。正如 Martin oder sky(Scala 的创始人)所说:

> *不确定性=并行处理+可变状态*

程序确定性通常是计算中的一个理想属性。也许您认为自己没问题，因为 JS 在单线程中运行，因此不受并行处理问题的影响，但是正如 AJAX 示例所展示的，单线程 JS 引擎并不意味着没有并发性。相反，JavaScript 中有很多并发的来源。API I/O、事件监听器、web workers、iframes 和超时都可能在程序中引入不确定性。将这一点与共享状态结合起来，你就有了解决 bug 的方法。

纯函数可以帮助你避免这些错误。

## 给定相同的输入，总是返回相同的输出

使用我们的 *`double()`* 函数，您可以用结果替换函数调用，并且程序将表示相同的内容— *`double(5)`* 将始终表示与您的程序中的 *`10`* 相同的内容，无论上下文如何，无论您调用它多少次或何时。

但是你不能说所有的功能都是一样的。有些函数依赖于传递的参数以外的信息来产生结果。

考虑这个例子:

```
Math.random(); // => 0.4011148700956255
Math.random(); // => 0.8533405303023756
Math.random(); // => 0.3550692005082965
```

即使我们没有向任何函数调用传递任何参数，它们都产生了不同的输出，这意味着 *`Math.random()`* 是**而不是纯粹的**。

*`Math.random()`* 每次运行它时都会产生一个介于 0 和 1 之间的新随机数，所以很明显，你不能在不改变程序含义的情况下用 0.4011148700956255 来替换它。

那每次都会产生相同的结果。当我们向计算机请求一个随机数时，通常意味着我们想要一个与上次不同的结果。一对骰子每一面都印着相同的数字有什么意义？

有时我们不得不向计算机询问当前时间。我们不会深入时间函数如何工作的细节。现在，只需复制以下代码:

```
const time = () => new Date().toLocaleTimeString();time(); // => "5:15:45 PM"
```

如果用当前时间替换 *`time()`* 函数调用会发生什么？

它总是说是同一个时间:函数调用被替换的时间。换句话说，它每天只能产生一次正确的输出，而且只有在函数被替换的时候运行程序。

所以很明显， *`time()`* 并不像我们的 *`double()`* 函数。

一个函数只有在给定相同的输入，它总是产生相同的输出时才是纯的。您可能还记得代数课上的这条规则:相同的输入值总是映射到相同的输出值。但是，许多输入值可能映射到同一个输出值。比如下面的函数**就是纯**:

```
const highpass = (cutoff, value) => value >= cutoff;
```

相同的输入值将始终映射到相同的输出值:

```
highpass(5, 5); // => true
highpass(5, 5); // => true
highpass(5, 5); // => true
```

许多输入值可能映射到同一个输出值:

```
highpass(5, 123); // true
highpass(5, 6);   // true
highpass(5, 18);  // truehighpass(5, 1);   // false
highpass(5, 3);   // false
highpass(5, 4);   // false
```

一个纯函数不能依赖于任何外部可变状态，因为它不再是确定性的或透明的。

# 纯函数不会产生副作用

一个纯粹的功能不会产生副作用，这意味着它不能改变任何外部状态。

# 不变

JavaScript 的对象参数是引用，这意味着如果一个函数要改变一个对象或数组参数的属性，这将改变该函数外部可访问的状态。纯函数不能改变外部状态。

考虑一下这个突变，**不纯** *`addToCart()`* 函数:

它通过传入一个购物车、要添加到购物车中的商品以及商品数量来工作。然后，该函数返回相同的购物车，其中添加了商品。

问题是，我们只是改变了一些共享状态。其他函数可能依赖于 cart 对象状态，这是调用该函数之前的状态，现在我们已经改变了共享状态，我们必须担心如果我们改变调用函数的顺序，会对程序逻辑产生什么影响。重构代码可能会导致错误出现，这可能会破坏订单，并导致客户不满。

现在考虑这个版本:

在这个例子中，我们有一个嵌套在对象中的数组，这就是为什么我要进行深度克隆。这是比你通常要处理的更复杂的状态。对于大多数事情，你可以把它分解成更小的块。

例如，Redux 允许您编写 reducer，而不是处理每个 reducer 中的整个应用程序状态。结果是，每次您想更新应用程序状态的一小部分时，您不必创建整个应用程序状态的深度克隆。相反，您可以使用非破坏性数组方法，或 *`Object.assign()`* 来更新应用程序状态的一小部分。

轮到你了。[叉这支笔](http://codepen.io/ericelliott/pen/MyojLq?editors=0010)，把不纯的函数改成纯函数。在不改变测试的情况下通过单元测试。

## 探索该系列

*   [什么是闭包？](/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.ecfskj935)
*   [类和原型继承有什么区别？](/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1)
*   [什么是纯函数？](/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.4256pjcfq)
*   [什么是函数构成？](/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0#.i84zm53fb)
*   [什么是函数式编程？](/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#.jddz30xy3)
*   [什么是承诺？](/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#.aa7ubggsy)
*   [软技能](/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466)

> 这篇帖子被收录在《作曲软件》一书中。 [*买书*](https://leanpub.com/composingsoftware) *|* [*索引*](/javascript-scene/composing-software-the-book-f31c77fc3ddc)*|*[*<上一张*](/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257) *|* [*下一张>*](/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0)

# 在 EricElliottJS.com 了解更多信息

EricElliottJS.com 会员可以参加互动代码挑战视频课程。如果你还不是会员，今天就注册吧。

***埃里克·艾略特*** *是一位科技产品和平台顾问，《 [*【作曲软件】*](https://leanpub.com/composingsoftware)*[*【EricElliottJS.com】*](https://ericelliottjs.com)*[*devanywhere . io*](https://devanywhere.io)*的联合创始人，以及 dev 团队导师。他曾为 Adobe Systems、* ***、Zumba Fitness、*** ***【华尔街日报、*******【ESPN、*******【BBC】****等顶级录音艺人和包括* ***Usher、【Metallica】********

*他和世界上最美丽的女人享受着与世隔绝的生活方式。*