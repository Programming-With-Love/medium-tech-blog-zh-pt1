<html>
<head>
<title>Introduction to RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ简介</h1>
<blockquote>原文：<a href="https://medium.com/globant/introduction-to-rabbitmq-5af1a58b942e?source=collection_archive---------1-----------------------#2022-06-29">https://medium.com/globant/introduction-to-rabbitmq-5af1a58b942e?source=collection_archive---------1-----------------------#2022-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9ea44eee0fbe8d32531ed94c144aa872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OF4OOD3B8Yb3Fn8X"/></div></div></figure><p id="84e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗨，朋友们，在这篇文章中，我们将简要介绍什么是RabbitMQ，以及它如何帮助扩展我们的微服务，</p><p id="3c66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">RabbitMQ遵循发布-订阅模式进行通信，因此在进入RabbitMQ之前，让我们了解一下这种发布-订阅机制到底是什么，</p><h2 id="b4c2" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">发布-订阅模型</h2><p id="4edf" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">在分布式应用程序中，当事件发生时，系统的组件通常需要向其他组件提供信息。为此，消息传递应运而生，它是一种有效的方法，可以将发送者从消费者中分离出来，并避免阻止发送者等待响应。</p><p id="35d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，这也带来了一些问题，</p><p id="f34d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">可伸缩性</strong>:为每个消费者使用一个专用的消息队列并不能最终扩展到许多消费者。</p><p id="0e07" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">抽象</strong>:一些消费者可能只对队列中可用信息的子集感兴趣。</p><p id="2f60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">耦合</strong>:有时，发送者想要向所有感兴趣的团体广播事件，而不知道他们的位置/地址。如果发送方存储位置映射，那么它将导致一个紧密耦合的系统。</p><p id="f41c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用包含以下内容的异步消息传递机制来解决这些问题:</p><p id="0915" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发送方使用输入消息传递通道。发送方使用预定义的消息格式将事件相关数据编译成消息，并通过传输通道发送这些消息。这种机制中的发送者也被称为<strong class="ir hi">发布者</strong>。</p><p id="3352" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，这些信息可以被消费者接收。消费者被称为<strong class="ir hi">用户</strong>。</p><p id="9500" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用于将每个消息从输入通道复制到输出通道以供对该消息感兴趣的所有订户使用的通信介质被称为<strong class="ir hi">消息代理</strong>或<strong class="ir hi">事件总线</strong>。</p><p id="9cbe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了该机制的逻辑组件:</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/19a4177d049421b956e9f2b68c6fd40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHZJ9ez3Xv7jLXOE"/></div></div></figure><p id="f772" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发布-订阅的优点:</p><ul class=""><li id="dc82" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi">解耦/松散耦合的组件:</strong>通过发布-订阅机制，子系统得到解耦，并且可以通过独立的异步通信轻松管理。它将仍然需要通信的子系统解耦。</li><li id="01bc" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">可扩展且高度负责:</strong>消息的发送者(发布者)能够快速将消息发送到通信通道，并立即返回其核心处理职责。它不必担心消息的传递。消息传递基础设施将负责向相关方传递消息。</li><li id="bb82" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">路由、延迟/预定处理:</strong>用户可以等到非高峰时间再取消息，或者可以根据特定的时间表路由或处理消息。</li><li id="a01e" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">容错</strong>:使系统在增加的负载下平稳运行，更有效地处理间歇性故障，使系统更加可靠和容错。</li><li id="de38" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">工作流兼容性:</strong>它提供了跨分布式应用程序的异步工作流编排。</li><li id="07b5" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">关注点分离:</strong>每个应用程序可以专注于其核心功能，而消息传递基础设施处理将消息可靠地路由到多个消费者所需的一切。</li></ul><p id="6263" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种发布者-订阅者机制广泛用于n/w操作、自动化、数据中心和其他需要实时计算的行业。对于无服务器计算和基于云的分布式系统来说，这也是一个非常有用的模式。RabbutMQ是内部实现这种模式的技术之一，让我们更详细地研究rabbitmq。</p><h2 id="7f9a" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">兔子q</h2><p id="1051" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">RabbitMQ是一款使用<a class="ae lg" href="https://www.amqp.org/about/what" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="lh"> AMQP </em> </strong> </a>协议传输数据的消息代理软件。也就是说，RabbitMQ接受来自生产者的消息，并将它们传递给消费者。它之所以被广泛使用，是因为它是开源的，不像它的竞争对手——<a class="ae lg" href="https://aws.amazon.com/amazon-mq/pricing/" rel="noopener ugc nofollow" target="_blank">Amazon MQ</a>或<a class="ae lg" href="https://cloud.google.com/pubsub/pricing" rel="noopener ugc nofollow" target="_blank"> GC Pub/Sub </a>。</p><p id="2b5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">RabbitMQ充当中间人的角色，用于减少交付时间和应用服务器的负载。它为您的应用程序提供了一个发送和接收消息的通用接口，并为您的消息提供了一个安全的存放位置(即队列),直到消息被接收为止。</p><p id="3122" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lh">关于AMQP </em></p><p id="2a94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AMQP是高级消息队列协议，它是一种消息协议，使客户端应用程序能够与消息中间件代理进行通信。</p><p id="91c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">消息传递代理接收来自发布者的消息，并将它们发送给消费者。</p><p id="9dfa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AMQP有队列、交换和绑定，统称为它的实体。这些实体帮助我们将消息从生产者传递给消费者。</p><h2 id="fe61" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">RabbitMQ组件</h2><p id="39ba" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">RabbitMQ包含以下4个基本组件:</p><p id="7688" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–生产商</p><p id="54d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–交换</p><p id="2641" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–排队</p><p id="a50f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–消费者</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/04eb8945f8865bb5002877b79e5bdc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pxw7YEmT2CHktAQA"/></div></div></figure><p id="cf2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">制片人</strong></p><p id="3c88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生产者是发布消息的用户应用程序。我们从出版商那里发送信息。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p><p id="f0c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发布消息时，发布者可以指定各种<em class="lh">消息属性</em>(消息元数据)。其中一些属性可以被RabbitMQ (broker)使用，但是许多属性只能被接收者使用。</p><p id="1338" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">交换</strong></p><p id="95ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">来自发布-订阅机制的代理被称为交换。它还有一个队列来存储消息。</p><p id="210b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">交换从生产者那里获取消息，并将其路由到零个或多个队列中。使用的路由算法取决于交换类型和称为绑定的规则。该算法还有一个与之关联的路由关键字。它只是由生产者添加到消息头的一个消息属性。我们可以把路由键想象成一个“地址”,交换使用它来决定如何路由消息。消息进入队列时，其绑定键与消息的路由键完全匹配。</p><p id="06ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有以下几种交换类型:</p><p id="e260" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–<em class="lh">直接交换</em>:当我们必须发送消息到队列时，只有当它们之间的特定键(路由键)值匹配时。</p><p id="1da2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–<em class="lh">扇出交换</em>:当我们想要广播我们的消息，以便任何队列都可以接收消息时。</p><p id="be0d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–<em class="lh">话题交换</em>:与直接交换不同，他们匹配模式而不是一个确切的键。</p><p id="9962" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">–<em class="lh">报头交换</em>:报头的值等于路由键上指定的值。</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/84af9f0a345b08f76363ff4e026da771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_M0adipuqJ0vEH3l"/></div></div></figure><p id="5365" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">队列</strong></p><p id="b13d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<em class="lh">队列</em>是RabbitMQ的消息存储/缓冲区。当消息流经RabbitMQ组件时，它们只能存储在一个<em class="lh">队列</em>中。</p><p id="8c31" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">许多<em class="lh">生产者</em>可以向一个队列发送消息，许多<em class="lh">消费者</em>可以尝试从一个<em class="lh">队列</em>接收数据。它本质上只受主机内存&amp;磁盘限制的约束。</p><p id="da6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在使用队列之前，必须对其进行声明。如果队列尚不存在，声明队列将导致创建队列。如果队列已经存在，并且其属性与声明中的属性相同，则重新声明将无效。</p><p id="d89f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">接收器</strong></p><p id="dec7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lh">消费者</em>是主要等待接收消息(即订阅消息)的程序。消费者根据附加的不同策略监听来自RabbitMQ队列的消息。每当队列中有接收者正在监听的新消息时，它将能够按照消息插入队列的顺序从队列中取出这些消息。</p><p id="6d86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，当添加一个新的消费者时，假设队列中已经有准备好的消息，传递将立即开始。</p><h2 id="ca7a" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">RabbitMQ优势</h2><ul class=""><li id="6f7c" class="ks kt hh ir b is ki iw kj ja lk je ll ji lm jm kx ky kz la bi translated"><strong class="ir hi">异步消息传递:</strong> <br/>支持多种消息传递协议、消息队列、送达确认、灵活的队列路由和多种交换类型。</li><li id="4a3b" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">企业&amp;云兼容:</strong> <br/>授权，支持TLS和LDAP，可插拔认证。轻量级，易于在公共云和私有云部署。</li><li id="cf00" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">开发经验:<br/> </strong>与码头工人、木偶等一起部署。用喜欢的编程语言开发，比如Java、PHP、Python、JavaScript等等。</li><li id="9c76" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">分布式部署:<br/> </strong>跨越多个可用地带和地区的邦联；还可以部署为集群，以实现高吞吐量和高可用性。</li><li id="4ac5" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">工具&amp;插件:</strong>用于扩展RabbitMQ功能的灵活插件方法。</li><li id="0cab" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">易于管理&amp;监控:</strong> <br/> UI、命令行工具和用于管理和监控RabbitMQ的HTTP-API</li></ul><p id="bd04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总的来说，发布-订阅机制使应用程序能够异步地向多个感兴趣的消费者宣布事件，而无需将发送者耦合到接收者。RabbitMQ提供了一个使用发布-订阅机制的接口，为分布式应用程序联合高度可伸缩和可用的组件。</p><p id="a5a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lh">参考文献</em>:</p><ol class=""><li id="074c" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ln ky kz la bi translated"><a class="ae lg" href="https://www.amqp.org/about/what" rel="noopener ugc nofollow" target="_blank">https://www.amqp.org/about/what</a></li><li id="c928" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ln ky kz la bi translated"><a class="ae lg" href="https://www.cloudamqp.com/blog/part2-2-rabbitmq-for-beginners_example-and-sample-code-node-js.html" rel="noopener ugc nofollow" target="_blank">https://www . cloudamqp . com/blog/part 2-2-rabbit MQ-for-初学者_ example-and-sample-code-node-js . html</a></li><li id="49a8" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ln ky kz la bi translated"><a class="ae lg" href="https://blog.knoldus.com/introduction-to-rabbitmq/" rel="noopener ugc nofollow" target="_blank">https://blog.knoldus.com/introduction-to-rabbitmq/</a></li><li id="dee7" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ln ky kz la bi translated"><a class="ae lg" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/architecture/patterns/publisher-subscriber</a></li><li id="81b4" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ln ky kz la bi translated"><a class="ae lg" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Publish % E2 % 80% 93 subscribe _ pattern</a></li></ol></div></div>    
</body>
</html>