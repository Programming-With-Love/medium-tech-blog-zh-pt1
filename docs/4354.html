<html>
<head>
<title>From Java to Kotlin and back (III): Calling Java from Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Java到Kotlin并返回(III):从Kotlin调用Java</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-iii-calling-java-from-kotlin-f33f5c246d69?source=collection_archive---------8-----------------------#2021-03-14">https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-iii-calling-java-from-kotlin-f33f5c246d69?source=collection_archive---------8-----------------------#2021-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7769aa8cef057eb59eadbe240e1038b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64ZHGwroVJgbBDbC2X_gSQ.jpeg"/></div></div></figure><div class=""/><p id="a2b8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是系列文章的一部分。您可以在这里找到本系列的其余文章:</p><p id="dce7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/google-developer-experts/from-java-to-kotlin-and-back-i-java-calling-kotlin-9abfc6496b04">从Java到Kotlin并返回(I) —从Java调用kot Lin</a></p><p id="dd23" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/google-developer-experts/from-java-to-kotlin-and-back-ii-calling-kotlin-from-java-3bdf72da6e52">从Java到Kotlin并返回(II):从Java调用kot Lin</a></p><p id="2e48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本系列的最后一章中，我们将评估从Kotlin调用Java代码时的注意事项。</p><p id="7139" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有人可能会说，即使这种情况经常发生，记住一些可能遗留下来的代码也是不实际的。Kotlin在设计时也考虑到了互操作性，因此Kotlin的Java代码比其他代码更“可调用”，因为这种设计从一开始就已经考虑在内了。但是，在编写Java代码时，有几点需要记住，我们将在本文中解释这些要点。</p><h1 id="86f1" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">释文</h1><p id="f961" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">由于Java缺少一些我们在Kotlin上已经拥有的强大特性，我们将非常依赖一些注释来准备我们的Java代码与Kotlin接口。</p><h2 id="40e8" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">可空性</h2><p id="d85d" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">尽管可空性是Kotlin的核心特性之一，但Java并没有提供现成的支持。Java中的每个参数都应该有一个可空性注释。否则，它们被理解为“<a class="ae jn" href="https://p5v.medium.com/platform-types-in-kotlin-5caceeb556ad" rel="noopener">平台类型</a>”，这种平台类型有一种模糊的方式来确定可空性，并可能触发运行时错误，这正是Kotlin nullability想要避免的。例如，考虑下面这段代码:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="e081" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们试图用false调用函数<em class="ll"> doNotUseAnnotation </em>，代码将触发一个异常。因为我们没有添加任何注释，Kotlin暗示该函数不可为空。在Java中，我们将如下设置可空性:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0e01" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最常见的是@Nullable和@NotNull，它们出现在包<em class="ll"> org.jetbrains.annotation </em>中，也出现在<em class="ll"> com.android.annotation </em>和其他包中，比如Lombok。</p><p id="d2ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，没有正确注释的Java代码会导致不可预测的行为。如果你在Android领域有一些经验，框架是用Java编写的，你会不断地依赖注释，而注释并不总是在它们应该在的地方。</p><p id="ab5e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您正在处理可能会暴露给Kotlin的Java代码，请记住使用可空性注释来促进栅栏另一边的生活。</p><h2 id="c39d" class="kr jp hs bd jq ks kt ku ju kv kw kx jy ja ky kz kc je la lb kg ji lc ld kk le bi translated">@欠迁移注释</h2><p id="34b9" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">@UnderMigration注释在我们维护一些Java代码时非常有用，我们希望通知我们的潜在客户它的当前状态(请注意，注释可以在一个单独的工件中找到，<em class="ll"> kotlin-annotations-jvm </em></p><p id="ff5d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">@UnderMigration status可以有三个不同的值，类似于Kotlin 1.4中引入的<a class="ae jn" href="https://blog.jetbrains.com/kotlin/2020/06/kotlin-1-4-m2-released/#explicit-api-mode" rel="noopener ugc nofollow" target="_blank">显式API模式</a>:</p><ul class=""><li id="264a" class="lm ln hs ir b is it iw ix ja lo je lp ji lq jm lr ls lt lu bi translated"><code class="du lv lw lx ly b">MigrationStatus.STRICT</code>会在错误使用注释时产生编译错误，导致代码失败。</li><li id="7019" class="lm ln hs ir b is lz iw ma ja mb je mc ji md jm lr ls lt lu bi translated"><code class="du lv lw lx ly b">MigrationStatus.WARN</code>:与上一个类似，但只是删除一个警告</li><li id="98ec" class="lm ln hs ir b is lz iw ma ja mb je mc ji md jm lr ls lt lu bi translated"><code class="du lv lw lx ly b">MigrationStatus.IGNORE</code>完全忽略注释的用法。</li></ul><h1 id="0623" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Java中的Getters和setters</h1><p id="d76b" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">Kotlin使用属性访问，而不是像Java一样使用getters和setters。getter的定义是一个名称以<em class="ll"> get </em>开头的no参数，setter的定义是一个名称以<em class="ll"> set </em>开头的单参数方法。布尔getters以is开始，所以我们可以使用更自然的人类语言来询问属性的值(<em class="ll"> isClosed </em>，is <em class="ll"> Finished </em>等等)。在设计Java类时要记住这一点，尽管这是非常标准的。有趣的是，如果你的属性只提供了一个setter，那么它将不会作为一个属性可见，因为Kotlin不支持set-only属性(这通常是一个<a class="ae jn" href="https://softwareengineering.stackexchange.com/questions/50554/why-it-is-not-recommended-to-have-set-only-property" rel="noopener ugc nofollow" target="_blank">反模式</a>)。</p><p id="4e59" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的Java类:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4e30" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将像Kotlin中的以下块一样被访问:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="72dd" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">科特林关键词</h1><p id="94bc" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">Kotlin有几个硬关键字，我们不应该在我们的Java代码中使用，因为Kotlin的对应部分需要反勾号来调用它们。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="b7e5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Protip:在Kotlin中命名方法和变量时，可以到处使用这些反勾号，而不仅仅是在硬关键字或测试的情况下。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="c30f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="adfe" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">这最后一篇文章介绍了设计和处理我们的Java代码的技巧，稍后将在Kotlin中使用这些代码。Java代码可以用比其他方式更少的努力向Kotlin公开代码，但是所探讨的要点将能够帮助您实现更有效的互操作代码。</p><p id="75f8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的推特账户上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它对你有帮助，请随意分享，👏和/或发表评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>