<html>
<head>
<title>DataStore and dependency injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据存储和依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3?source=collection_archive---------0-----------------------#2022-02-08">https://medium.com/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3?source=collection_archive---------0-----------------------#2022-02-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/2299991abb14db357c1c152c75cb62f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8lWMtxkqO0QNOmu8L6R5Pg.png"/></div></div></figure><div class=""/><p id="24bb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"> <strong class="ir ht"> Jetpack数据存储系列</strong> </a>的以下帖子中，我们将涵盖几个额外的概念，以了解数据存储如何与其他API交互，以便您可以在<strong class="ir ht">生产环境</strong>中使用一切。在这篇文章中，我们将重点关注<strong class="ir ht">对</strong> <a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">柄</strong> </a>的依赖注入。在这篇文章中，我们将参考<strong class="ir ht">数据存储库</strong> <a class="ae jn" href="https://developer.android.com/codelabs/android-preferences-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">首选项</strong> </a>和<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore#0" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto</strong></a>codelabs获取代码示例。</p><h1 id="7cd3" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">带句柄的依赖注入</h1><p id="17a6" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在这些codelabs中，我们在Kotlin文件的顶层通过<strong class="ir ht">首选项</strong>和<strong class="ir ht"> Proto </strong> <strong class="ir ht">委托构造</strong>与我们的数据存储实例进行了一次交互。然后，我们将在整个应用程序中使用同一个实例，作为<strong class="ir ht">单例</strong>:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="d3be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要单例，因为为一个给定文件<strong class="ir ht">创建多个数据存储实例</strong>会破坏所有数据存储功能。然而，在生产环境中，我们通常会通过<strong class="ir ht">依赖注入</strong>来获得数据存储实例。因此，让我们来看看DataStore如何与<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">柄</strong> </a>一起工作，这是一个依赖注入库，它将帮助我们<strong class="ir ht">减少进行手动依赖管理的样板文件</strong>。如果您不熟悉Hilt，我们鼓励您首先在您的Android应用程序  codelab中通过<a class="ae jn" href="https://developer.android.com/codelabs/android-hilt#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">使用Hilt来学习<code class="du kx ky kz la b">Components</code><code class="du kx ky kz la b">Modules</code>等基本概念。</strong></a></p><h2 id="b103" class="lb jp hs bd jq lc ld le ju lf lg lh jy ja li lj kc je lk ll kg ji lm ln kk lo bi translated">刀柄设置</h2><p id="86d3" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">首先，确保您已经添加了所有必要的设置步骤来启用Hilt:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2e69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有使用Hilt的应用程序都必须包含一个用<code class="du kx ky kz la b">@HiltAndroidApp</code>注释的<code class="du kx ky kz la b">Application</code>类来触发Hilt的代码生成，包括一个作为应用程序级依赖容器的应用程序基类。在我们的例子中，我们将创建一个简单的<code class="du kx ky kz la b">TasksApp</code>，并将其添加到我们的<code class="du kx ky kz la b">AndroidManifest.xml</code>:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><h2 id="c0c0" class="lb jp hs bd jq lc ld le ju lf lg lh jy ja li lj kc je lk ll kg ji lm ln kk lo bi translated">注入首选项数据存储</h2><p id="386f" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了通过注入获得一个<strong class="ir ht"> Preferences DataStore实例</strong>，我们需要告诉Hilt如何正确地创建它。我们使用<code class="du kx ky kz la b">PreferenceDataStoreFactory</code>并将其添加到一个<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules" rel="noopener ugc nofollow" target="_blank">刀柄模块</a>:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="bfbd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们之前在本系列中提到过这些参数，但让我们快速回顾一下:</p><ul class=""><li id="a651" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated"><code class="du kx ky kz la b">corruptionHandler</code>(可选)—当数据无法反序列化时，如果序列化程序抛出<code class="du kx ky kz la b">CorruptionException</code>，指示数据存储如何替换损坏的数据，则调用此函数</li><li id="b142" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du kx ky kz la b">migrations</code>(可选)—用于将以前的数据移入数据存储的<code class="du kx ky kz la b">DataMigration</code>列表</li><li id="65cf" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du kx ky kz la b">scope</code>(可选)—IO操作和转换功能将执行的范围；在这种情况下，我们重用了与数据存储API默认作用域相同的作用域</li><li id="6a06" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated"><code class="du kx ky kz la b">produceFile</code> —根据提供的<code class="du kx ky kz la b">Context</code>和<code class="du kx ky kz la b">name</code>为首选项数据存储生成<code class="du kx ky kz la b">File</code>对象，存储在<code class="du kx ky kz la b">this.applicationContext.filesDir</code> + <code class="du kx ky kz la b">datastore/</code>子目录中</li></ul><p id="9b11" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了一个模块来指导Hilt如何创建我们的数据存储，我们需要再做一些调整来成功构建。</p><p id="8e50" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Hilt可以提供对其他具有<code class="du kx ky kz la b">@AndroidEntryPoint</code>注释的Android类的依赖，以及对<code class="du kx ky kz la b">Application</code>的<code class="du kx ky kz la b">@HiltAndroidApp</code>和对<code class="du kx ky kz la b">ViewModel</code>类的<code class="du kx ky kz la b">@HiltViewModel</code>。如果你用<code class="du kx ky kz la b">@AndroidEntryPoint</code>注释一个Android类，那么你也必须注释依赖于它的其他Android类。例如，如果您注释了一个<code class="du kx ky kz la b">Fragment</code>，那么您也必须注释您使用那个<code class="du kx ky kz la b">Fragment</code>的任何活动。</p><p id="8a6d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着我们需要添加以下内容:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="7f8f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个示例中，我们没有任何其他的<strong class="ir ht">复杂注入</strong>，比如定制构建器、工厂或接口实现。所以我们可以依赖于句柄和构造函数注入来获得我们需要传递的任何其他依赖项。我们将在一个类的构造函数中使用<code class="du kx ky kz la b">@Inject</code>注释来指示Hilt如何提供它的实例:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="74a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，让我们将<code class="du kx ky kz la b">preferencesDataStore</code>委托从<code class="du kx ky kz la b">TasksActivity</code>顶部完全移除，因为我们不再需要它了。我们还将改变我们的<code class="du kx ky kz la b">viewModel</code>在<code class="du kx ky kz la b">TaskActivity</code> <code class="du kx ky kz la b">onCreate</code>中的提供方式，因为它的依赖项现在将被注入:</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><h2 id="1ebd" class="lb jp hs bd jq lc ld le ju lf lg lh jy ja li lj kc je lk ll kg ji lm ln kk lo bi translated">注入原始数据存储</h2><p id="3423" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><strong class="ir ht"> Proto DataStore </strong>将遵循非常相似的模式——您还需要提供一个<code class="du kx ky kz la b">UserPreferencesSerializer</code>和一个关于如何从<code class="du kx ky kz la b">SharedPreferences</code>迁移的精确指令，我们已经在<a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879"><strong class="ir ht">Proto DataStore post</strong></a><strong class="ir ht">:</strong>中对此进行了更详细的介绍</p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="f0f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！现在，您将能够运行应用程序，并验证所有的依赖项现在都被正确地注入了。</p><h1 id="3c64" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">待续</h1><p id="dfe3" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们已经讲述了<strong class="ir ht">如何使用Hilt </strong>注入数据存储以实现更好的依赖管理的步骤，设置Hilt，使用<code class="du kx ky kz la b">DataStoreModule</code>中的<code class="du kx ky kz la b">PreferenceDataStoreFactory</code>来指导Hilt如何正确地提供我们的数据存储实例，最后，将它提供给需要它的类。</p><p id="1252" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">加入我们系列的下一篇文章，我们将研究如何将<strong class="ir ht">数据存储与Kotlin序列化</strong>一起使用。</p><p id="efeb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在这里找到我们Jetpack DataStore系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack DataStore简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项DataStore </a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型DataStore</a><br/><a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">DataStore和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c"> DataStore和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c"> DataStore和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa"> DataStore和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8"> DataStore和测试</a></p></div></div>    
</body>
</html>