<html>
<head>
<title>Making Sense of Intent Filters in Android 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Android 13中的意图过滤器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/making-sense-of-intent-filters-in-android-13-8f6656903dde?source=collection_archive---------0-----------------------#2022-07-06">https://medium.com/androiddevelopers/making-sense-of-intent-filters-in-android-13-8f6656903dde?source=collection_archive---------0-----------------------#2022-07-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/30c32f6dddac1010289daca7c1a7860a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PX8VuYcLzaC-AvOtSPgMRw.png"/></div></div></figure><div class=""/><p id="326d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android 13之前，当一个应用程序在其清单中注册一个导出的组件并添加一个<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>时，该组件可以由任何显式的意图启动——甚至是那些不匹配意图过滤器的意图。在某些情况下，这可能允许其他应用程序触发仅供内部使用的功能。</p><p id="3217" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种行为在Android 13中得到了更新。现在，当且仅当指定动作的意图与其声明的<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>元素匹配时，来自外部应用程序的意图才被交付给导出的组件。</p><h1 id="b3f4" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">违反直觉</strong></h1><p id="401e" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">在现有的Android版本中，当意图<strong class="ir ht">与组件声明的<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>元素</strong>不匹配时，有两种方式将意图传递给组件(如<code class="du jn jo jp jq b"><strong class="ir ht">&lt;activity&gt;</strong></code>):</p><ol class=""><li id="43bc" class="ku kv hs ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated"><a class="ae ld" href="https://developer.android.com/guide/components/intents-filters#ExampleExplicit" rel="noopener ugc nofollow" target="_blank">显式意图</a>:只要发送者有权限，带有组件名称集的意图将总是被交付给组件。</li><li id="e314" class="ku kv hs ir b is le iw lf ja lg je lh ji li jm kz la lb lc bi translated"><a class="ae ld" href="https://developer.android.com/reference/android/content/Intent#setSelector(android.content.Intent)" rel="noopener ugc nofollow" target="_blank">意图选择器</a>:将匹配意图设置为主意图的选择器时，主意图总是被传递。</li></ol><p id="b501" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开发者期望意图过滤器会影响所有意图，而不仅仅是一个子集。事实上，我们已经看到了很多关于意图过滤器的混乱。</p><h1 id="5d12" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">一次回顾</strong></h1><p id="8af1" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">对于以下每个问题，您将看到以下内容:</p><ul class=""><li id="d021" class="ku kv hs ir b is it iw ix ja kw je kx ji ky jm lj la lb lc bi translated">创建一个意向对象，该对象被传递给<code class="du jn jo jp jq b"><strong class="ir ht">startActivity()</strong></code>或<code class="du jn jo jp jq b"><strong class="ir ht">sendBroadcast()</strong></code>。</li><li id="c8fe" class="ku kv hs ir b is le iw lf ja lg je lh ji li jm lj la lb lc bi translated">一个<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>元素。</li></ul><p id="64fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你的工作是回答这个问题:<strong class="ir ht">意向会和意向过滤器匹配吗？</strong></p><p id="39a4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，意图:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3c0d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">和意图过滤器:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8402" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不要！</p><p id="04d6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果一个意图不包含任何类别，Android将把它视为<code class="du jn jo jp jq b"><strong class="ir ht">CATEGORY_DEFAULT</strong></code>传递给<code class="du jn jo jp jq b"><strong class="ir ht">startActivity</strong>()</code>和<code class="du jn jo jp jq b"><strong class="ir ht">startActivityForResult</strong>()</code>的所有隐含意图。请注意，当且仅当意图用于启动活动时，才定义此行为。意图过滤器必须包括<code class="du jn jo jp jq b"><strong class="ir ht">CATEGORY_DEFAULT</strong></code>，以便接收隐含的活动意图(<a class="ae ld" href="https://developer.android.com/guide/topics/manifest/category-element" rel="noopener ugc nofollow" target="_blank">文档</a>)。<strong class="ir ht">请注意，这仅适用于开始活动时。</strong>它们不适用于启动服务或发送广播。</p><p id="c043" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了正确匹配此示例，意图过滤器应实现如下:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="09ce" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">再来一个怎么样？</p><p id="e89f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">意图:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ea05" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">过滤器:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9485" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">又不行！</p><p id="d17a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">意图过滤器必须指定一个<code class="du jn jo jp jq b">&lt;data&gt;</code>元素来接受带有数据的意图(<a class="ae ld" href="https://developer.android.com/guide/components/intents-filters#DataTest" rel="noopener ugc nofollow" target="_blank">文档</a>)。与之匹配的应该是这样的:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="a1ca" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">一项风险得到改善</strong></h1><p id="5a08" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">在过去的一年中，我们发现了一个特殊的陷阱，我们认为我们可以帮助解决，让意图过滤器以更直观的方式工作。</p><p id="c908" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看一个例子:</p><p id="ca4f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">意图:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="1054" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">过滤器:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="bf6e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在现有的Android版本中，是的——意图确实与过滤器相匹配！这是因为显式意图不需要匹配声明的意图过滤器。当一个应用程序在其清单中声明一个导出的组件并添加一个<code class="du jn jo jp jq b">&lt;intent-filter&gt;</code>时，该组件可以由任何意图启动——甚至是那些不匹配意图过滤器的意图！这可能会导致许多应用程序出现漏洞。</p><p id="47f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是我们在野外发现的一个例子:</p><p id="78df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">易受攻击的应用代码:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ecf5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">受害者清单中声明的组件:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="7190" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">动作<code class="du jn jo jp jq b"><strong class="ir ht">com.example.PRIVATE_INTERNAL_ACTION</strong></code>不应该在应用程序之外被访问，因为处理它的接收者(<code class="du jn jo jp jq b"><strong class="ir ht">InternalReceiver</strong></code>)没有被导出。然而，由于<code class="du jn jo jp jq b"><strong class="ir ht">ExternalReceiver</strong></code>不检查和保护传入的动作，恶意参与者可以通过以下方式触发内部功能:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="e83f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于以Android 13+为目标的应用程序，这一点现在已经改变了。下一节将描述这些变化。</p><h1 id="fde0" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">有什么变化？</strong></h1><p id="0ef0" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">从面向Android 13+的应用程序(意向接收方)开始，当且仅当意向与其声明的<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>元素匹配时，源自外部应用程序的所有意向才会被传递到导出的组件。</p><p id="d9f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">一个大的警告:</strong>如果一个意图没有指定一个动作，只要过滤器包含至少一个动作，它就通过了意图匹配测试。这意味着，如果传入的意图没有动作(当意图。<code class="du jn jo jp jq b"><strong class="ir ht">getAction</strong>() </code>回报<code class="du jn jo jp jq b"><strong class="ir ht">null</strong></code>)！</p><p id="baeb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不匹配的意图被阻止。不实施意图匹配的情况包括以下几种:</p><ul class=""><li id="0ee4" class="ku kv hs ir b is it iw ix ja kw je kx ji ky jm lj la lb lc bi translated">交付给未声明任何意图过滤器的组件的意图</li><li id="b167" class="ku kv hs ir b is le iw lf ja lg je lh ji li jm lj la lb lc bi translated">源自同一应用程序的意图</li><li id="0045" class="ku kv hs ir b is le iw lf ja lg je lh ji li jm lj la lb lc bi translated">源自系统和根的意图。</li></ul><p id="dbdf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然出于安全原因，这一变化很大——如果你依赖这一行为通过显式意图使你的应用程序与另一个应用程序交互，你可能会看到你的应用程序中的行为变化，即使你没有更新到目标Android 13。</p><p id="bb89" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这些变化，假设受害者应用程序更新到目标Android 13，我们前面示例中的恶意参与者不再能够触发我们在Android 13上的受害者应用程序的内部功能。但是，仍然<strong class="ir ht">强烈建议</strong>更新所有导出的组件，以检查并仅接受在旧版本Android上运行时允许保护您的应用程序的操作。我们更新后的示例如下:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="d362" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">我该怎么办？</strong></h1><p id="ac94" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">首先，我们应该注意到，只有当<strong class="ir ht">意向接收应用程序针对Android 13+ </strong>时，才会启用强制执行。它不会影响内部传递给同一应用程序的意图。</p><h1 id="0977" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">意向发送方</h1><p id="3e30" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">如果您正在向另一个应用程序的<strong class="ir ht">发送显式意图(带有显式组件名称集的意图)，请确保意图与组件的<code class="du jn jo jp jq b">&lt;<strong class="ir ht">intent-filter</strong>&gt;</code>元素相匹配。匹配逻辑与<a class="ae ld" href="https://developer.android.com/guide/components/intents-filters#ExampleFilters" rel="noopener ugc nofollow" target="_blank">解析隐含意图完全相同。</a></strong></p><p id="2bc1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当试图开始一个带有不匹配的明确意图的活动时，您将立即得到一个带有消息的<code class="du jn jo jp jq b"><strong class="ir ht">ActivityNotFoundException</strong></code>:</p><blockquote class="lq lr ls"><p id="b5c7" class="ip iq lt ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">找不到显式活动类{组件名称}；您是否在AndroidManifest.xml中声明了此活动，或者您的意图是否与其声明的<intent-filter>不匹配？</intent-filter></p></blockquote><p id="c59e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于广播接收机和服务，除了标签“<code class="du jn jo jp jq b">PackageManager</code>”中的警告日志消息外，没有明显的故障信号:</p><blockquote class="lq lr ls"><p id="59b5" class="ip iq lt ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">意图与组件的意图过滤器不匹配:<intent description=""/></p><p id="a0c1" class="ip iq lt ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">访问被阻止:<component name=""/></p></blockquote><h1 id="d56c" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">意向接收方</h1><p id="7707" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">确保在<code class="du jn jo jp jq b"><strong class="ir ht">AndroidManifest.xml</strong>.</code>中声明您的组件期望并接受的所有可能的意图过滤器</p><p id="4d6c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除此之外，如果一个组件只需要显式的意图，如果不需要过滤，可以考虑移除所有的<code class="du jn jo jp jq b"><strong class="ir ht">&lt;intent-filter&gt;</strong></code>元素。没有意图过滤器的组件将接受任何明确的意图。</p><h1 id="68e4" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">测试</h1><p id="2ffb" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">从开发者预览版1开始，这个变化已经在Android 13版本中启用了。</p><p id="6c5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用开发者选项中的<a class="ae ld" href="https://developer.android.com/guide/app-compatibility/test-debug" rel="noopener ugc nofollow" target="_blank">兼容性框架</a> UI，或者通过在终端窗口中输入以下ADB命令来切换此更改:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9c06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，这适用于应用程序<em class="lt">接收</em>意图；您不能禁用您的应用程序<em class="lt">发送给其他应用程序</em>的意图更改。</p><h1 id="31df" class="jr js hs bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">前进</h1><p id="3816" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">因为这种变化甚至会在开发者瞄准13之前影响他们，所以如果你使用意图与外部应用交互，调查这种变化并<strong class="ir ht">尽快协调更新是很重要的。有关更多信息，请查看我们描述意图和意图过滤器的<a class="ae ld" href="https://developer.android.com/guide/components/intents-filters" rel="noopener ugc nofollow" target="_blank">文档。</a></strong></p></div></div>    
</body>
</html>