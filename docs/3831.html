<html>
<head>
<title>Understanding how the Python garbage collector works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python垃圾收集器的工作原理</h1>
<blockquote>原文：<a href="https://medium.com/globant/understanding-how-the-python-garbage-collector-works-614f6b5723ba?source=collection_archive---------9-----------------------#2022-02-25">https://medium.com/globant/understanding-how-the-python-garbage-collector-works-614f6b5723ba?source=collection_archive---------9-----------------------#2022-02-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cebf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如大多数人可能知道的那样，Python是一种具有不同实现的动态编程语言。CPython实现使用引用计数和分代垃圾收集器的实现来管理内存。值得一提的是，Python的其他实现，如PyPy、IronPython……可以使用不同的策略。</p><p id="e8b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你知道这些策略是用于内存分配的吗？你知道是否有可能禁用垃圾收集器吗？</p></div><div class="ab cl jc jd go je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="ha hb hc hd he"><p id="c569" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从版本2开始，Python开始使用两种不同的策略来进行内存分配引用计数和代垃圾收集。在此之前，唯一使用的策略是引用计数。</p><h1 id="da2a" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">引用计数</h1><p id="9e20" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">在这种技术中，它保持对对象引用的计数。当创建一个新的引用时，计数器加1，当删除一个引用时，计数器减1。</p><p id="d6d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，Python中创建的每个对象都需要保持计数器持续更新。在引用计数器为0的情况下，该对象有资格被垃圾收集。</p><p id="c8bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建对对象“my object”的三个引用，并检查该对象的引用计数。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="127b" class="kv jk hh kr b fi kw kx l ky kz"><strong class="kr hi">&gt;&gt;&gt; import sys <br/>&gt;&gt;&gt; a = "my object" <br/>&gt;&gt;&gt; b = a <br/>&gt;&gt;&gt; c = a <br/>&gt;&gt;&gt; id(a)</strong> <br/>4377801904<br/><strong class="kr hi">&gt;&gt;&gt; id(b) <br/></strong>4377801904<br/><strong class="kr hi">&gt;&gt;&gt; id(c) <br/></strong>4377801904<br/><strong class="kr hi">&gt;&gt;&gt; sys.getrefcount(a) <br/></strong>4</span></pre><p id="5a88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> id(…) </strong>显示代表引用对象的唯一整数。而<strong class="ig hi"> sys.getrefcount(a) </strong>返回对象的引用计数(“我的对象”)。返回的计数通常比我们预期的要高一，因为它包含了临时引用作为getrefcount()的参数。</p><p id="5af5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是上面代码的表示。</p><figure class="km kn ko kp fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es la"><img src="../Images/cf85e71ed315ead914095ef67616f16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gsPOcm6d1wYvTAY6.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">Three references are linked to the object</figcaption></figure><p id="ad13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们删除一个引用，计数器就减1。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="b24c" class="kv jk hh kr b fi kw kx l ky kz"><strong class="kr hi">&gt;&gt;&gt; del(c) <br/>&gt;&gt;&gt; sys.getrefcount(a)</strong> <br/>3</span></pre><figure class="km kn ko kp fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lm"><img src="../Images/b167a92934a90b7726d21fd5c2d7fae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4wnlEY_dFpzS_DJp.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">One reference removed</figcaption></figure><p id="f3ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们移除所有引用，计数器将为0，对象将有资格被垃圾收集器擦除。</p><figure class="km kn ko kp fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es ln"><img src="../Images/f5fcb7a36eb98fe3114b8928846ad18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7H9I427eldrykVMn.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">No more references exist</figcaption></figure><p id="06ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">奇怪的是，公共值的引用数比我预期的要多。这是因为其他人在解释器启动时引用了它们。例如，我创建了一个对<strong class="ig hi"> 1 </strong>的引用，发现这个对象有几百个引用。我的建议是创建一个特殊的数字或字符串，这将帮助您理解<strong class="ig hi"> getrefcount(…) </strong>方法的用法。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="64fd" class="kv jk hh kr b fi kw kx l ky kz"><strong class="kr hi">&gt;&gt;&gt; h = 1 <br/>&gt;&gt;&gt; sys.getrefcount(h) <br/></strong>601<br/><strong class="kr hi">&gt;&gt;&gt; h = 3.14151692 <br/>&gt;&gt;&gt; sys.getrefcount(h) <br/></strong>2</span></pre><p id="b6f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，如果您创建两个具有相同值的对象，它们不会获得相同的ID，因为它们不是同一个对象。您可以检查它们的唯一id和对象的引用计数。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="b072" class="kv jk hh kr b fi kw kx l ky kz"><strong class="kr hi">&gt;&gt;&gt; a = 1234 <br/>&gt;&gt;&gt; b = 1234 <br/>&gt;&gt;&gt; id(a) <br/></strong>4484904240<br/><strong class="kr hi">&gt;&gt;&gt; id(b) <br/></strong>4484904080<br/><strong class="kr hi">&gt;&gt;&gt; sys.getrefcount(b) <br/></strong>2<br/><strong class="kr hi">&gt;&gt;&gt; sys.getrefcount(a) <br/></strong>2</span></pre><p id="c2dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用引用计数的一个好处是，一旦对象没有引用，就可以从内存中删除它。</p><p id="7080" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它也有一些缺点。这可能非常低效，尤其是在简单的多线程实现中。并且它不能处理具有循环引用的对象。对于这些情况，Python应用了第二种算法，称为分代垃圾收集。</p><h1 id="a92f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">分代垃圾收集</h1><p id="1888" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">该算法基于时间分配将对象分成不同的代。它可以对每一代人采用不同的政策。</p><p id="c29e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python在应用程序启动时创建了三代。新对象进入第一代，如果它们在回忆中幸存，算法将它们移到第二代。同样的事情也会发生在这一代，这些物品被收集或转移到第三代。在这一代中，对象将一直存在，直到程序结束。</p><p id="bd4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每一代都有一个阈值，当对象列表超过阈值时，Python运行垃圾收集过程。</p><figure class="km kn ko kp fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es ln"><img src="../Images/51977fcf50c53ca2ad9f7a8ce8a39353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dbn-BRyaYCpmZrLc.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">Generational Garbage Collection in three steps</figcaption></figure><p id="3771" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种技术的一个缺点是通常无法删除长期存在的垃圾，尽管它们对最新的对象处理得很好。</p><h2 id="9cfb" class="kv jk hh bd jl lo lp lq jp lr ls lt jt ip lu lv jx it lw lx kb ix ly lz kf ma bi translated">Python中有没有可能禁用垃圾收集器？</h2><p id="7aa2" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">可以禁用第二种算法，即分代式垃圾收集器，但不能禁用引用计数算法。</p><p id="97bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是gc模块中的一些方法，可以帮助你。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="b80b" class="kv jk hh kr b fi kw kx l ky kz"><strong class="kr hi">&gt;&gt;&gt; import gc <br/>&gt;&gt;&gt; gc.isenabled() <br/></strong>True<br/><strong class="kr hi">&gt;&gt;&gt; gc.disable() <br/>&gt;&gt;&gt; gc.isenabled() <br/></strong>False</span></pre><p id="348f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">禁用Python分代式垃圾收集器不会减少应用程序中的内存使用，因为Python通常不会将内存释放回底层操作系统。</p><p id="df24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想深入禁用垃圾收集器，我建议你看一下<a class="ae mb" href="https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172" rel="noopener ugc nofollow" target="_blank"> Instagram工程团队</a>的帖子，他们正在用垃圾收集器做一些实验，并发现了一些第三方库的<strong class="ig hi"> disable() </strong>方法的一些副作用。</p><h1 id="1c5b" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">结论</h1><p id="04b2" class="pw-post-body-paragraph ie if hh ig b ih kh ij ik il ki in io ip kj ir is it kk iv iw ix kl iz ja jb ha bi translated">Python使用两种策略进行内存管理，引用计数和针对循环依赖的分代垃圾收集器。第二个是可选的垃圾收集器，可以禁用。可以查看对象的引用计数，更改代的阈值，以及其他一些事情。我推荐你看一下<a class="ae mb" href="https://docs.python.org/3/library/gc.html" rel="noopener ugc nofollow" target="_blank"> gc模块</a>、<a class="ae mb" href="https://docs.python.org/3/library/sys.html" rel="noopener ugc nofollow" target="_blank"> sys模块</a>，或者垃圾收集器<a class="ae mb" href="https://devguide.python.org/garbage_collector/" rel="noopener ugc nofollow" target="_blank">设计文档</a>。</p></div><div class="ab cl jc jd go je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="ha hb hc hd he"><p id="1be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mc">原载于2022年2月25日https://jenaiz.com</em><a class="ae mb" href="https://jenaiz.com/2022/02/understanding-how-the-python-garbage-collector-works/" rel="noopener ugc nofollow" target="_blank"><em class="mc"/></a><em class="mc">。</em></p></div></div>    
</body>
</html>