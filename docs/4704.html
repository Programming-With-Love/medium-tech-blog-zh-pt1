<html>
<head>
<title>A Functional Programmer’s Introduction to JavaScript (Composing Software)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个函数式程序员对JavaScript(编写软件)的介绍</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30?source=collection_archive---------0-----------------------#2017-02-25">https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30?source=collection_archive---------0-----------------------#2017-02-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="e87b" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列的一部分<strong class="iz hi"> s </strong> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">(现在一本书！)</strong> </a>关于从基础开始学习JavaScript 6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<em class="hh"> <br/> </em> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="hh">买书</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc"> <em class="hh">索引</em></a><em class="hh">|</em><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"><em class="hh">&lt;上一篇</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99"> <em class="hh">下一篇&gt; </em> </a></p></blockquote><p id="9709" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对于那些不熟悉JavaScript或ES6+的人来说，这只是一个简单的介绍。无论您是初学者还是有经验的JavaScript开发人员，您都可能会学到一些新东西。下面的内容仅仅是皮毛，让你兴奋起来。如果你想知道更多，你只能更深入地探索。前面还有很多。</p><p id="ef3a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">学习编码的最好方法是编码。我建议你使用交互式JavaScript编程环境，如<a class="ae jv" href="https://codepen.io/" rel="noopener ugc nofollow" target="_blank"> CodePen </a>或<a class="ae jv" href="https://babeljs.io/repl/" rel="noopener ugc nofollow" target="_blank"> Babel REPL </a>。</p><p id="50de" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">或者，您可以不使用节点或浏览器控制台副本。</p><h1 id="903a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">表达式和值</h1><p id="21b6" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">表达式是计算结果为值的一段代码。</p><p id="f28a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">以下是JavaScript中所有有效的表达式:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ce39" class="ll ka hh lh b fi lm ln l lo lp">7;</span><span id="6f42" class="ll ka hh lh b fi lq ln l lo lp">7 + 1; // 8</span><span id="3d67" class="ll ka hh lh b fi lq ln l lo lp">7 * 2; // 14</span><span id="a03b" class="ll ka hh lh b fi lq ln l lo lp">'Hello'; // Hello</span></pre><p id="5a69" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">表达式的值可以给定一个名称。这样做时，首先计算表达式，并将结果值赋给名称。为此，我们将使用<code class="du lr ls lt lh b">const</code>关键字。这不是唯一的方法，但却是您最常用的方法，所以我们现在还是坚持使用<code class="du lr ls lt lh b">const</code>:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="bb06" class="ll ka hh lh b fi lm ln l lo lp">const hello = 'Hello';<br/>hello; // Hello</span></pre><h1 id="6974" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">var、let和const</h1><p id="3114" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">JavaScript支持另外两个变量声明关键字:<code class="du lr ls lt lh b">var</code>和<code class="du lr ls lt lh b">let</code>。我喜欢按照选择的顺序来考虑它们。默认情况下，我选择最严格的声明:<code class="du lr ls lt lh b">const</code>。用<code class="du lr ls lt lh b">const</code>关键字声明的变量不能被重新赋值。最终值必须在声明时赋值。这听起来可能有些僵硬，但这种限制是一件好事。这是一个信号，告诉你，“赋予这个名字的值不会改变”。它可以帮助你马上完全理解名字的含义，而不需要阅读整个函数或块范围。</p><p id="db52" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">有时重新分配变量很有用。例如，如果您正在使用手动的、命令式的迭代，而不是功能性更强的方法，那么您可以迭代一个用<code class="du lr ls lt lh b">let</code>赋值的计数器。</p><p id="ebd5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">因为<code class="du lr ls lt lh b">var</code>告诉你的变量最少，所以是最弱的信号。自从我开始使用ES6以来，我从来没有在一个真正的软件项目中故意声明过一个<code class="du lr ls lt lh b">var</code>。</p><p id="0944" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">请注意，一旦用<code class="du lr ls lt lh b">let</code>或<code class="du lr ls lt lh b">const</code>声明了一个变量，任何再次声明它的尝试都将导致错误。如果您喜欢在REPL(读取、评估、打印循环)环境中有更多的实验灵活性，您可以使用<code class="du lr ls lt lh b">var</code>而不是<code class="du lr ls lt lh b">const</code>来声明变量。允许重新声明<code class="du lr ls lt lh b">var</code>。</p><p id="81b6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">本文将使用<code class="du lr ls lt lh b">const</code>,以便让您养成在实际程序中默认使用<code class="du lr ls lt lh b">const</code>的习惯，但是出于交互实验的目的，您可以随意替换<code class="du lr ls lt lh b">var</code>。</p><h1 id="381b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">类型</h1><p id="8129" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">到目前为止，我们已经看到了两种类型:数字和字符串。JavaScript还有布尔值(<code class="du lr ls lt lh b">true</code>或<code class="du lr ls lt lh b">false</code>)、数组、对象等等。我们稍后将讨论其他类型。</p><p id="974a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">数组是有序的值列表。把它想象成一个可以装很多物品的盒子。下面是数组文字符号:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3906" class="ll ka hh lh b fi lm ln l lo lp">[1, 2, 3];</span></pre><p id="56b8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当然，这是一个可以命名的表达式:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="60a6" class="ll ka hh lh b fi lm ln l lo lp">const arr = [1, 2, 3];</span></pre><p id="b9cf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript中的对象是键:值对的集合。它还有一个文字符号:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="de42" class="ll ka hh lh b fi lm ln l lo lp">{<br/>  key: 'value'<br/>}</span></pre><p id="0322" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当然，您可以给一个对象指定一个名称:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a191" class="ll ka hh lh b fi lm ln l lo lp">const foo = {<br/>  bar: 'bar'<br/>}</span></pre><p id="ff64" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您想将现有变量分配给同名的对象属性键，有一个快捷方式。您可以只键入变量名，而不是同时提供键和值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d1ef" class="ll ka hh lh b fi lm ln l lo lp">const a = 'a';<br/>const oldA = { a: a }; // long, redundant way<br/>const oA = { a }; // short an sweet!</span></pre><p id="b3f4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">为了好玩，我们再来一次:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1351" class="ll ka hh lh b fi lm ln l lo lp">const b = 'b';<br/>const oB = { b };</span></pre><p id="c46b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对象可以很容易地组合成新对象:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="17c8" class="ll ka hh lh b fi lm ln l lo lp">const c = {...oA, ...oB}; // { a: 'a', b: 'b' }</span></pre><p id="13c9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些点是对象扩展操作符。它遍历<code class="du lr ls lt lh b">oA</code>中的属性并将它们分配给新对象，然后对<code class="du lr ls lt lh b">oB</code>做同样的事情，覆盖新对象上已经存在的任何键。在撰写本文时，对象扩散是一个新的实验性功能，可能还不能在所有流行的浏览器中使用，但如果它对您不起作用，有一个替代品:<code class="du lr ls lt lh b">Object.assign()</code>:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7fcd" class="ll ka hh lh b fi lm ln l lo lp">const d = Object.assign({}, oA, oB); // { a: 'a', b: 'b' }</span></pre><p id="1c45" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在<code class="du lr ls lt lh b">Object.assign()</code>的例子中只需要多输入一点点，如果你正在编写大量的对象，它甚至可以节省你一些输入。注意，当你使用<code class="du lr ls lt lh b">Object.assign()</code>时，你必须传递一个目标对象作为第一个参数。它是属性将被复制到的对象。如果您忘记并忽略了目标对象，那么您在第一个参数中传递的对象将会发生变异。</p><p id="8031" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">根据我的经验，改变现有对象而不是创建新对象通常是一个错误。最起码是容易出错的。小心<code class="du lr ls lt lh b">Object.assign()</code>。</p><h1 id="4274" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">解构</h1><p id="d8dc" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">对象和数组都支持析构，这意味着您可以从它们中提取值并将它们赋给命名变量:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d059" class="ll ka hh lh b fi lm ln l lo lp">const [t, u] = ['a', 'b'];<br/>t; // 'a'<br/>u; // 'b'</span><span id="f929" class="ll ka hh lh b fi lq ln l lo lp">const blep = {<br/>  blop: 'blop'<br/>};<br/><br/>// The following is equivalent to:<br/>// const blop = blep.blop;<br/>const { blop } = blep;<br/>blop; // 'blop'</span></pre><p id="0d89" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">和上面的数组例子一样，你可以一次析构多个赋值。这里有一行你会在很多Redux项目中看到:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7b25" class="ll ka hh lh b fi lm ln l lo lp">const { type, payload } = action;</span></pre><p id="b788" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">下面是它在一个reducer环境中的用法(后面会有更多关于这个主题的内容):</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="144f" class="ll ka hh lh b fi lm ln l lo lp">const myReducer = (state = {}, action = {}) =&gt; {<br/>  const { type, payload } = action;<br/>  switch (type) {<br/>    case 'FOO': return Object.assign({}, state, payload);<br/>    default: return state;<br/>  }<br/>};</span></pre><p id="7ed4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果您不想为新绑定使用不同的名称，可以分配一个新名称:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="af41" class="ll ka hh lh b fi lm ln l lo lp">const { blop: bloop } = blep;<br/>bloop; // 'blop'</span></pre><p id="743e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">阅读:将<code class="du lr ls lt lh b">blep.blop</code>指定为<code class="du lr ls lt lh b">bloop</code>。</p><h1 id="4af9" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">比较和术语</h1><p id="c278" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">您可以使用严格相等运算符(有时称为“三重等于”)来比较值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8e7f" class="ll ka hh lh b fi lm ln l lo lp">3 + 1 === 4; // true</span></pre><p id="a0b7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">还有一个草率的等式运算符。它的正式名称是“相等”运算符。非正式地说，“双倍相等”。Double equals有一两个有效的用例，但是默认使用<code class="du lr ls lt lh b">===</code>操作符几乎总是更好。</p><p id="9667" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">其他比较运算符包括:</p><ul class=""><li id="e2f5" class="lu lv hh iz b ja jb je jf jw lw jx lx jy ly ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">&gt;</code>大于</li><li id="8f01" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">&lt;</code>小于</li><li id="de5d" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">&gt;=</code>大于或等于</li><li id="46b1" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">&lt;=</code>小于或等于</li><li id="07a7" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">!=</code>不相等</li><li id="6882" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">!==</code>不严格相等</li><li id="f840" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">&amp;&amp;</code>逻辑与</li><li id="ee46" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju lz ma mb mc bi translated"><code class="du lr ls lt lh b">||</code>逻辑或</li></ul><p id="798c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">三元表达式是一种允许您使用比较器提问的表达式，它根据表达式是否为真来计算不同的答案:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="17ee" class="ll ka hh lh b fi lm ln l lo lp">14 - 7 === 7 ? 'Yep!' : 'Nope.'; // Yep!</span></pre><h1 id="3bce" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">功能</h1><p id="ab02" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">JavaScript有函数表达式，可以分配给名称:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5b63" class="ll ka hh lh b fi lm ln l lo lp">const double = x =&gt; x * 2;</span></pre><p id="a668" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这与数学函数<code class="du lr ls lt lh b">f(x) = 2x</code>的意思相同。大声说出来，这个函数读作<code class="du lr ls lt lh b">x</code>的<code class="du lr ls lt lh b">f</code>等于<code class="du lr ls lt lh b">2x</code>。这个函数只有当你把它应用到一个特定的<code class="du lr ls lt lh b">x</code>值时才有意思。要在其他方程中使用这个函数，你可以写<code class="du lr ls lt lh b">f(2)</code>，它和<code class="du lr ls lt lh b">4</code>有相同的意思。</p><p id="5f63" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">换句话说，<code class="du lr ls lt lh b">f(2) = 4</code>。您可以将数学函数视为从输入到输出的映射。<code class="du lr ls lt lh b">f(x)</code>在这种情况下是<code class="du lr ls lt lh b">x</code>的输入值到相应输出值的映射，该输出值等于输入值和<code class="du lr ls lt lh b">2</code>的乘积。</p><p id="cb24" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在JavaScript中，函数表达式的值就是函数本身:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="03b3" class="ll ka hh lh b fi lm ln l lo lp">double; // [Function: double]</span></pre><p id="c805" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以使用<code class="du lr ls lt lh b">.toString()</code>方法查看函数定义:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="77b0" class="ll ka hh lh b fi lm ln l lo lp">double.toString(); // 'x =&gt; x * 2'</span></pre><p id="b853" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你想将一个函数应用于一些参数，你必须用一个函数调用来调用它。函数调用将函数应用于其参数，并计算返回值。</p><p id="86e3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以使用<code class="du lr ls lt lh b">&lt;functionName&gt;(argument1, argument2, ...rest)</code>调用功能。例如，要调用我们的double函数，只需添加括号并向double传递一个值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7f77" class="ll ka hh lh b fi lm ln l lo lp">double(2); // 4</span></pre><p id="25ec" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">与一些函数式语言不同，这些括号是有意义的。没有它们，函数就不会被调用:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0b65" class="ll ka hh lh b fi lm ln l lo lp">double 4; // SyntaxError: Unexpected number</span></pre><h1 id="144b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">签名</h1><p id="cecf" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">函数有签名，签名包括:</p><ol class=""><li id="74e0" class="lu lv hh iz b ja jb je jf jw lw jx lx jy ly ju mi ma mb mc bi translated">一个<em class="iy">可选的</em>函数名。</li><li id="5e32" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju mi ma mb mc bi translated">括号中的参数类型列表。参数可以选择命名。</li><li id="12b1" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju mi ma mb mc bi translated">返回值的类型。</li></ol><p id="1bd4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript中不需要指定类型签名。JavaScript引擎会在运行时计算出类型。如果你提供足够的线索，签名也可以通过IDEs(集成开发环境)和<a class="ae jv" href="http://ternjs.net/" rel="noopener ugc nofollow" target="_blank"> Tern.js </a>等开发工具使用数据流分析推断出来。</p><p id="fcef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript缺乏自己的函数签名符号，因此有一些竞争标准:JSDoc在历史上非常受欢迎，但它非常冗长，而且没有人愿意让文档注释与代码保持同步，因此许多JS开发人员已经停止使用它。</p><p id="69a6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">TypeScript和Flow是目前最大的竞争者。我不确定如何用这两种语言表达我需要的一切，所以我使用<a class="ae jv" href="https://github.com/ericelliott/rtype" rel="noopener ugc nofollow" target="_blank"> Rtype </a>，这只是为了便于记录。有些人选择了哈斯克尔的纯咖喱食品<a class="ae jv" href="http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf" rel="noopener ugc nofollow" target="_blank">欣德利-米尔纳型</a>。我希望看到一个好的JavaScript标准化符号系统，即使只是为了文档的目的，但是我不认为目前的任何解决方案能够胜任这项任务。现在，眯着眼睛，尽最大努力跟上奇怪的类型签名，它们可能看起来与您正在使用的略有不同。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b159" class="ll ka hh lh b fi lm ln l lo lp">functionName(param1: Type, param2: Type) =&gt; Type</span></pre><p id="d2af" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">double的签名是:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f986" class="ll ka hh lh b fi lm ln l lo lp">double(x: n) =&gt; Number</span></pre><p id="e9d3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">尽管事实上JavaScript并不要求对签名进行注释，但是了解什么是签名<em class="iy"/>以及它们的含义<em class="iy"/>对于有效地交流如何使用函数以及如何组成函数仍然很重要。</p><h1 id="b44a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">默认参数值</h1><p id="a262" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">JavaScript支持默认参数值。以下函数的工作方式类似于identity函数(返回与您传入的值相同的值的函数)，除非您用<code class="du lr ls lt lh b">undefined</code>调用它，或者根本不传递任何参数，否则它将返回零:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b5fd" class="ll ka hh lh b fi lm ln l lo lp">const orZero = (n = 0) =&gt; n;</span></pre><p id="2c2b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">要设置默认值，只需在函数签名中用<code class="du lr ls lt lh b">=</code>操作符将其赋给参数，如上面的<code class="du lr ls lt lh b">n = 0</code>所示。当您以这种方式分配默认值时，类型推断工具(如<a class="ae jv" href="http://ternjs.net/" rel="noopener ugc nofollow" target="_blank"> Tern.js </a>、Flow或TypeScript)可以自动推断您的函数的类型签名，即使您没有显式声明类型注释。</p><p id="b81e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">结果是，通过在编辑器或IDE中安装正确的插件，您将能够在键入函数调用时看到内嵌显示的函数签名。您还将能够根据函数的调用签名一眼就明白如何使用函数。在任何有意义的地方使用默认赋值可以帮助您编写更多自文档化的代码。</p><blockquote class="it iu iv"><p id="3b2c" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:带默认值的参数不计入函数的<code class="du lr ls lt lh b">.length</code>属性，这将丢弃依赖于<code class="du lr ls lt lh b">.length</code>值的实用程序，如autocurry。一些curry实用程序(如<code class="du lr ls lt lh b">lodash/curry</code>)允许您传递一个自定义arity来解决这个限制。</p></blockquote><h1 id="aa36" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">命名参数</h1><p id="2255" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">JavaScript函数可以将对象文字作为参数，并在参数签名中使用析构赋值，以实现命名参数的等效。请注意，您也可以使用默认参数功能为参数分配默认值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="beae" class="ll ka hh lh b fi lm ln l lo lp">const createUser = ({<br/>  name = 'Anonymous',<br/>  avatarThumbnail = '/avatars/anonymous.png'<br/>}) =&gt; ({<br/>  name,<br/>  avatarThumbnail<br/>});</span><span id="64bb" class="ll ka hh lh b fi lq ln l lo lp">const george = createUser({<br/>  name: 'George',<br/>  avatarThumbnail: 'avatars/shades-emoji.png'<br/>});</span><span id="ceaf" class="ll ka hh lh b fi lq ln l lo lp">george;<br/>/*<br/>{<br/>  name: 'George',<br/>  avatarThumbnail: 'avatars/shades-emoji.png'<br/>}<br/>*/</span></pre><h1 id="b409" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">休息和传播</h1><p id="4bd2" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">JavaScript中函数的一个常见特性是能够使用rest操作符收集函数签名中的一组剩余参数:<code class="du lr ls lt lh b">...</code></p><p id="cf0f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">例如，以下函数只丢弃第一个参数，并将其余参数作为数组返回:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0296" class="ll ka hh lh b fi lm ln l lo lp">const aTail = (head, ...tail) =&gt; tail;<br/>aTail(1, 2, 3); // [2, 3]</span></pre><p id="a932" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Rest将单个元素聚集到一个数组中。Spread的作用正好相反:它将数组中的元素分散到各个元素中。考虑一下这个:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="931d" class="ll ka hh lh b fi lm ln l lo lp">const shiftToLast = (head, ...tail) =&gt; [...tail, head];<br/>shiftToLast(1, 2, 3); // [2, 3, 1]</span></pre><p id="141e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript中的数组有一个迭代器，使用spread操作符时会调用这个迭代器。对于数组中的每一项，迭代器都会传递一个值。在表达式<code class="du lr ls lt lh b">[...tail, head]</code>中，迭代器将每个元素按顺序从<code class="du lr ls lt lh b">tail</code>数组复制到由周围的文字符号创建的新数组中。因为head已经是一个单独的元素了，我们只要把它放到数组的末尾就完成了。</p><h1 id="0355" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Currying</h1><p id="afeb" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">curried函数是一个一次接受多个参数的函数:它接受一个参数，然后返回一个接受下一个参数的函数，依此类推，直到提供了所有参数，此时，应用程序完成，并返回最终值。</p><p id="c220" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">可以通过返回另一个函数来启用Curry和部分应用程序:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2809" class="ll ka hh lh b fi lm ln l lo lp">const highpass = cutoff =&gt; n =&gt; n &gt;= cutoff;<br/>const gt4 = highpass(4); // highpass() returns a new function</span></pre><p id="d339" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">你不必使用箭头函数。JavaScript还有一个<code class="du lr ls lt lh b">function</code>关键字。我们使用箭头函数是因为<code class="du lr ls lt lh b">function</code>关键字需要更多的输入。这相当于上面的<code class="du lr ls lt lh b">highPass()</code>定义:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5325" class="ll ka hh lh b fi lm ln l lo lp">const highpass = function highpass(cutoff) {<br/>  return function (n) {<br/>    return n &gt;= cutoff;<br/>  };<br/>};</span></pre><p id="1399" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">JavaScript中的箭头大致意思是“函数”。根据您使用的函数类型，函数行为有一些重要的差异(<code class="du lr ls lt lh b">=&gt;</code>没有自己的<code class="du lr ls lt lh b">this</code>，不能用作构造函数)，但是我们将在后面讨论这些差异。现在，当你看到<code class="du lr ls lt lh b">x =&gt; x</code>时，想想“一个接受<code class="du lr ls lt lh b">x</code>并返回<code class="du lr ls lt lh b">x</code>的函数”。所以你可以把<code class="du lr ls lt lh b">const highpass = cutoff =&gt; n =&gt; n &gt;= cutoff;</code>读作:</p><p id="b4d0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><code class="du lr ls lt lh b">“highpass</code>是一个取<code class="du lr ls lt lh b">cutoff</code>并返回一个取<code class="du lr ls lt lh b">n</code>并返回<code class="du lr ls lt lh b">n &gt;= cutoff</code>结果的函数。</p><p id="c2e6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">由于<code class="du lr ls lt lh b">highpass()</code>返回一个函数，您可以用它来创建一个更专门化的函数:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9ff4" class="ll ka hh lh b fi lm ln l lo lp">const gt4 = highpass(4);</span><span id="9f82" class="ll ka hh lh b fi lq ln l lo lp">gt4(6); // true<br/>gt4(3); // false</span></pre><p id="c05d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">Autocurry让你自动搜索功能，以获得最大的灵活性。假设你有一个函数<code class="du lr ls lt lh b">add3()</code>:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3727" class="ll ka hh lh b fi lm ln l lo lp">const add3 = curry((a, b, c) =&gt; a + b + c);</span></pre><p id="fbbf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">有了autocurry，您可以以几种不同的方式使用它，它将根据您传入的参数数量返回正确的结果:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fb9a" class="ll ka hh lh b fi lm ln l lo lp">add3(1, 2, 3); // 6<br/>add3(1, 2)(3); // 6<br/>add3(1)(2, 3); // 6<br/>add3(1)(2)(3); // 6</span></pre><p id="7f76" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">抱歉，Haskell的粉丝们，JavaScript缺少内置的autocurry机制，但是你可以从Lodash导入一个:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d9c3" class="ll ka hh lh b fi lm ln l lo lp">$ npm install --save lodash</span></pre><p id="f59c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">然后，在您的模块中:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="38bf" class="ll ka hh lh b fi lm ln l lo lp">import curry from 'lodash/curry';</span></pre><p id="a6cf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">或者，你可以使用下面的魔法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0089" class="ll ka hh lh b fi lm ln l lo lp">// Tiny, recursive autocurry<br/>const curry = (<br/>  f, arr = []<br/>) =&gt; (...args) =&gt; (<br/>  a =&gt; a.length === f.length ?<br/>    f(...a) :<br/>    curry(f, a)<br/>)([...arr, ...args]);</span></pre><h1 id="c92c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">功能组成</h1><p id="156d" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">你当然可以构造函数。函数组合是将一个函数的返回值作为参数传递给另一个函数的过程。在数学符号中:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="379b" class="ll ka hh lh b fi lm ln l lo lp">f . g</span></pre><p id="8678" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">用JavaScript翻译过来就是:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="85ef" class="ll ka hh lh b fi lm ln l lo lp">f(g(x))</span></pre><p id="308d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">它由内而外进行评估:</p><ol class=""><li id="756f" class="lu lv hh iz b ja jb je jf jw lw jx lx jy ly ju mi ma mb mc bi translated"><code class="du lr ls lt lh b">x</code>被评估</li><li id="e969" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju mi ma mb mc bi translated"><code class="du lr ls lt lh b">g()</code>适用于<code class="du lr ls lt lh b">x</code></li><li id="511a" class="lu lv hh iz b ja md je me jw mf jx mg jy mh ju mi ma mb mc bi translated"><code class="du lr ls lt lh b">f()</code>应用于<code class="du lr ls lt lh b">g(x)</code>的返回值</li></ol><p id="fe75" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">例如:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="df73" class="ll ka hh lh b fi lm ln l lo lp">const inc = n =&gt; n + 1;<br/>inc(double(2)); // 5</span></pre><p id="30c4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">值<code class="du lr ls lt lh b">2</code>被传入<code class="du lr ls lt lh b">double()</code>，产生<code class="du lr ls lt lh b">4</code>。<code class="du lr ls lt lh b">4</code>被传入<code class="du lr ls lt lh b">inc()</code>，后者评估为<code class="du lr ls lt lh b">5</code>。</p><p id="834c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可以将任何表达式作为参数传递给函数。在应用函数之前，将对表达式求值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7bea" class="ll ka hh lh b fi lm ln l lo lp">inc(double(2) * double(2)); // 17</span></pre><p id="4f1d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">由于<code class="du lr ls lt lh b">double(2)</code>评估为<code class="du lr ls lt lh b">4</code>，您可以将其理解为<code class="du lr ls lt lh b">inc(4 * 4)</code>评估为<code class="du lr ls lt lh b">inc(16)</code>，然后<code class="du lr ls lt lh b">inc(16)</code>评估为<code class="du lr ls lt lh b">17</code>。</p><p id="e94c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">函数组合是函数式编程的核心。稍后我们会有更多的内容。</p><h1 id="c939" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">数组</h1><p id="7921" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">数组有一些内置的方法。方法是与对象关联的函数；通常是关联对象的属性；</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1188" class="ll ka hh lh b fi lm ln l lo lp">const arr = [1, 2, 3];<br/>arr.map(double); // [2, 4, 6]</span></pre><p id="a189" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这种情况下，<code class="du lr ls lt lh b">arr</code>是对象，<code class="du lr ls lt lh b">.map()</code>是对象的属性，具有用于值的函数。当您调用它时，函数被应用到实参，以及一个名为<code class="du lr ls lt lh b">this</code>的特殊参数，该参数在方法被调用时自动设置。<code class="du lr ls lt lh b">this</code>值是<code class="du lr ls lt lh b">.map()</code>访问数组内容的方式。</p><p id="7fca" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">注意，我们将<code class="du lr ls lt lh b">double</code>函数作为一个值传递给<code class="du lr ls lt lh b">map</code>，而不是调用它。这是因为<code class="du lr ls lt lh b">map</code>将一个函数作为参数，并将其应用于数组中的每一项。它返回一个包含由<code class="du lr ls lt lh b">double()</code>返回的值的新数组。</p><p id="6c2f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">注意原来的<code class="du lr ls lt lh b">arr</code>值不变:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0b94" class="ll ka hh lh b fi lm ln l lo lp">arr; // [1, 2, 3]</span></pre><h1 id="71f7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法链接</h1><p id="4b86" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">你也可以链接方法调用。方法链接是对函数的返回值直接调用方法的过程，而不需要通过名称引用返回值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="568f" class="ll ka hh lh b fi lm ln l lo lp">const arr = [1, 2, 3];<br/>arr.map(double).map(double); // [4, 8, 12]</span></pre><p id="4c2f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">一个<strong class="iz hi">谓词</strong>是一个返回布尔值(<code class="du lr ls lt lh b">true</code>或<code class="du lr ls lt lh b">false</code>)的函数。<code class="du lr ls lt lh b">.filter()</code>方法接受一个谓词并返回一个新列表，只选择通过谓词的项目(返回<code class="du lr ls lt lh b">true</code>)包含在新列表中:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4219" class="ll ka hh lh b fi lm ln l lo lp">[2, 4, 6].filter(gt4); // [4, 6]</span></pre><p id="05ac" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">通常，您会想要从列表中选择项目，然后将这些项目映射到新列表:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="17d4" class="ll ka hh lh b fi lm ln l lo lp">[2, 4, 6].filter(gt4).map(double); [8, 12]</span></pre><p id="3317" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">注意:在本文的后面，您将看到一种更有效的方法，使用一种叫做<em class="iy">转换器</em>的东西来同时选择和映射，但是首先还有其他的东西要探索。</p><h1 id="3326" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="efc8" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">如果你现在头晕，不要担心。我们仅仅触及了许多值得更多探索和思考的事物的表面。我们很快会回头更深入地探讨这些话题。</p><blockquote class="it iu iv"><p id="be12" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="hh">买书</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc"> <em class="hh">索引</em></a><em class="hh">|</em><a class="ae jv" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"><em class="hh">&lt;上一篇</em> </a> <em class="hh"> | </em> <a class="ae jv" rel="noopener" href="/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99"> <em class="hh">下一篇&gt; </em> </a></p></blockquote><h1 id="5e7e" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">在EricElliottJS.com<a class="ae jv" href="http://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">了解更多信息</a></h1><p id="5484" class="pw-post-body-paragraph iw ix hh iz b ja kx jc jd je ky jg jh jw kz jk jl jx la jo jp jy lb js jt ju ha bi translated">EricElliottJS.com会员可以参加互动代码挑战视频课程。如果你还不是会员，今天就注册吧。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="5fe0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy"> Eric Elliott </em> </strong> <em class="iy">是一位分布式系统专家，著有以下书籍:</em> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【排版软件】</em></a><em class="iy"/><a class="ae jv" href="https://ericelliottjs.com/product/programming-javascript-applications-ebook/" rel="noopener ugc nofollow" target="_blank"><em class="iy">【编程JavaScript应用】</em> </a> <em class="iy">。作为</em><a class="ae jv" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="iz hi"> <em class="iy">、Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">、华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC、</em> </strong> <em class="iy">以及包括</em> <strong class="iz hi"> <em class="iy">亚瑟、弗兰克·奥申、金属乐队在内的顶级录音艺术家提供软件体验</em></strong></p><p id="3135" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>