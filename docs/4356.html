<html>
<head>
<title>Prime Table Generator in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack编写中的主表生成器</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/prime-table-generator-in-jetpack-compose-21a87c1b78c0?source=collection_archive---------7-----------------------#2021-03-25">https://medium.com/google-developer-experts/prime-table-generator-in-jetpack-compose-21a87c1b78c0?source=collection_archive---------7-----------------------#2021-03-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3a64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">最初发表于</em><a class="ae jd" href="https://zsmb.co/prime-table-generator-jetpack-compose/" rel="noopener ugc nofollow" target="_blank"><em class="jc"/></a><em class="jc">。</em></p><p id="b20f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">距离我写这个素数表生成器的原始版本已经过去6年多了。那是在我编程生涯的最开始，在大学第一学期学习了C和SDL之后。这个原始项目的存档版本<a class="ae jd" href="https://zsmbprogsite.netlify.app/projects/primetable/" rel="noopener ugc nofollow" target="_blank">在这里</a>可以找到，包括源代码、<a class="ae jd" href="https://zsmbprogsite.netlify.app/projects/primetable/primetable.c" rel="noopener ugc nofollow" target="_blank"> 120行优秀的C代码</a>。</p><h1 id="33d4" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">前提</strong></h1><p id="4b7c" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">从上面链接的文章中简单概括一下:这个项目的重点是创建一个视觉上令人愉快和简洁的质数表示。最初的纸质版本包含4000以内的质数，看起来像这样:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/adb0e79e2290c6d490ba8284124ce206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EppWJ5SNlnHudQOhj7ot0w.jpeg"/></div></div></figure><p id="2c9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它是如何工作的？每个方块代表一组十个数字。因为素数(大于2)可能只以数字1、3、7或9结尾，所以正方形的每个角可以指示给定结尾数字在10数字宽的块内是否是素数。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kt"><img src="../Images/ae94bec00775c6d3c3d6505e0116e983.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*PZ7RfI2l9MiMAVXyjQBNcg.png"/></div></figure><p id="a2c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，表中的第三个块对应于数字21-30，两个相连的角表示只有23和29是这个范围内的素数。</p><p id="d023" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们开始为Android编写代码！</p><p id="fd61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">你可以在GitHub </em>  <em class="jc">上找到已完成项目</em> <a class="ae jd" href="https://github.com/zsmb13/PrimeTableGenerator" rel="noopener ugc nofollow" target="_blank"> <em class="jc">的代码。</em></a></p><h1 id="23bb" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">创建网格</strong></h1><p id="8cde" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">在之前的Jetpack Compose文章中，我们用自底向上的方法创建了一个动画时钟。这一次，我们将自顶向下进行设计，并从在Compose中渲染网格开始。为此，我们将使用实验性的<code class="du ku kv kw kx b"><a class="ae jd" href="https://developer.android.com/jetpack/compose/lists#grids" rel="noopener ugc nofollow" target="_blank">LazyVerticalGrid</a></code>API。</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="4678" class="lc jf hh kx b fi ld le l lf lg">@OptIn(ExperimentalFoundationApi::class)<br/>@Composable<br/>fun Primes() {<br/>    LazyVerticalGrid(<br/>        modifier = Modifier // 1<br/>            .fillMaxSize()<br/>            .background(Color(0xFFE53935))<br/>            .padding(8.dp),<br/>        cells = GridCells.Fixed(10), // 2<br/>    ) {<br/>        items(count = 100) { // 3<br/>            Box( <br/>                Modifier // 4<br/>                    .aspectRatio(1f)<br/>                    .padding(1.dp)<br/>                    .background(Color.DarkGray)<br/>            )<br/>        }<br/>    }<br/>}</span></pre><p id="1b26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分解上面的代码:</p><p id="293a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.<code class="du ku kv kw kx b">LazyVerticalGrid</code> composable填充了整个屏幕，有一个红色背景和一点点填充。</p><p id="c70d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.它显示一个固定列数的网格。</p><p id="e299" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.该网格包含100个项目。</p><p id="f088" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.一开始，每件物品都是一个简单的<code class="du ku kv kw kx b">Box</code>,被限定为一个正方形，有一点填充，有一个深色的背景色。</p><p id="e507" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">注意我们如何选择使用带有</em> <code class="du ku kv kw kx b"><em class="jc">@OptIn</em></code> <em class="jc">注释的实验API，这也需要一些额外的项目级配置来启用它。你可以在Kotlin </em>  <em class="jc">中的</em> <a class="ae jd" href="https://zsmb.co/mastering-api-visibility-in-kotlin/#opt-in-apis" rel="noopener ugc nofollow" target="_blank"> <em class="jc">掌握API可见性中了解更多关于这个语言特性的内容。</em></a></p><p id="f986" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行上面的代码会呈现(可滚动的)正方形网格:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lh"><img src="../Images/cf050cb993d93ba07cd6393cc102fc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xLqHd2kX4o7UXsNyzSpJg.png"/></div></div></figure><h1 id="d541" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">一个单一的正方形</strong></h1><p id="c6d6" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">让我们稍微重构一下，为网格的每一项创建一个<code class="du ku kv kw kx b">PrimeSquare</code> composable。这将接收它应该呈现素数的当前偏移量。</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="0194" class="lc jf hh kx b fi ld le l lf lg">@OptIn(ExperimentalFoundationApi::class)<br/>@Composable<br/>fun Primes() {<br/>    LazyVerticalGrid(...) {<br/>        items(count = 100) { index -&gt;<br/>            PrimeSquare(offset = index * 10)<br/>        }<br/>    }<br/>}</span><span id="2920" class="lc jf hh kx b fi li le l lf lg">@Composable<br/>fun PrimeSquare(offset: Int) {<br/>    Box(<br/>        Modifier<br/>            .aspectRatio(1f)<br/>            .padding(1.dp)<br/>            .background(Color.DarkGray)<br/>    ) {<br/>        CornerLine()<br/>    }<br/>}</span></pre><p id="7de7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于单个<code class="du ku kv kw kx b">PrimeSquare</code>的内容，我们将只渲染从左上角到中心的一行，使用我们自己的<code class="du ku kv kw kx b">CornerLine</code> composable。我们可以使用<code class="du ku kv kw kx b">Canvas</code> API在Compose中实现这一点:</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="2682" class="lc jf hh kx b fi ld le l lf lg">@Composable<br/>fun CornerLine() {<br/>    Canvas(Modifier.fillMaxSize()) {<br/>        drawLine(<br/>            color = Color.White,<br/>            start = Offset.Zero,<br/>            end = Offset(size.width / 2, size.height / 2),<br/>            strokeWidth = 2.dp.toPx(),<br/>        )<br/>    }<br/>}</span></pre><p id="774b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这给了我们下面的样子——一个好的开始！</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lj"><img src="../Images/1d76ccb1eb468723ec4f715432d9ea1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*Kj8C1xFD_XTpVPqGJ5xcSw.png"/></div></figure><h1 id="9d34" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">旋转和堆叠方块</strong></h1><p id="ac9f" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">为了让这条线进入正确的角落，我们可以在画布上画画的同时旋转画布。一个简单的<code class="du ku kv kw kx b">rotate</code>函数调用为我们解决了这个问题。我们将旋转量作为参数传递给<code class="du ku kv kw kx b">CornerLine</code>。</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="1c2a" class="lc jf hh kx b fi ld le l lf lg">@Composable<br/>fun CornerLine(degrees: Float) {<br/>    Canvas(Modifier.fillMaxSize()) {<br/>        rotate(degrees) {<br/>            drawLine(<br/>                color = Color.White,<br/>                start = Offset.Zero,<br/>                end = Offset(size.width / 2, size.height / 2),<br/>                strokeWidth = 2.dp.toPx(),<br/>            )<br/>        }<br/>    }<br/>}</span></pre><p id="992d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使事情变得非常简单，我们将为每个角创建一个命名的可组合对象，并进行适当的旋转:</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="742e" class="lc jf hh kx b fi ld le l lf lg">@Composable fun One() = CornerLine(degrees = 0f)<br/>@Composable fun Three() = CornerLine(degrees = -90f)<br/>@Composable fun Seven() = CornerLine(degrees = -180f)<br/>@Composable fun Nine() = CornerLine(degrees = -270f)</span></pre><p id="4fb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们必须知道哪个数是质数，为此我们将使用一个非常基本的实现。</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="a27c" class="lc jf hh kx b fi ld le l lf lg">fun Int.isPrime(): Boolean {<br/>    if (this &lt; 2) return false<br/>    return (2 until this).none { this % it == 0 }<br/>}</span></pre><p id="4088" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有没有一个更短的实现，至少和检查素数一样正确？ <a class="ae jd" href="https://twitter.com/zsmb13" rel="noopener ugc nofollow" target="_blank"> <em class="jc">朝我推特吧！</em> </a></p><p id="c53a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们可以检查一个数是否是质数，并且可以在每个角上画线，我们可以简单地实现<code class="du ku kv kw kx b">PrimeSquare</code>:</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="22e9" class="lc jf hh kx b fi ld le l lf lg">@Composable<br/>fun PrimeSquare(offset: Int) {<br/>    Box(<br/>        Modifier<br/>            .aspectRatio(1f)<br/>            .padding(1.dp)<br/>            .background(Color.DarkGray)<br/>    ) {<br/>        if ((offset + 1).isPrime()) One()<br/>        if ((offset + 3).isPrime()) Three()<br/>        if ((offset + 7).isPrime()) Seven()<br/>        if ((offset + 9).isPrime()) Nine()<br/>    }<br/>}</span></pre><p id="c1b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，我们在这里堆叠画布的方式并不完全是最佳的，但是它很好地展示了一个<code class="du ku kv kw kx b">Box</code>如何作为一个容器工作。如果我们把质数计算移得更低一级，我们可以在一张画布上画出所有的线以获得更好的性能——试着把这作为练习。</p><p id="a190" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管如此，我们的非最佳实现工作得很好:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lk"><img src="../Images/00731469c983c30887c350c50ee7b103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*_EaxJZ-vqk222hCW9WoZVw.png"/></div></figure><h1 id="01d2" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">最后的润色</strong></h1><p id="2ccf" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">在我们的渲染中有两个问题，如果你仔细看上面的图像，你会发现。</p><ul class=""><li id="4018" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lq lr ls lt bi translated">所画线条的端点超出了灰色方框。</li><li id="04c0" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated">中间相交的线没有像预期的那样相交。</li></ul><p id="27cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于第一个问题，我们可以使<code class="du ku kv kw kx b">PrimeSquare</code>中的<code class="du ku kv kw kx b">Box</code>可组合<em class="jc">剪辑</em>到其边界:</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="2a25" class="lc jf hh kx b fi ld le l lf lg">Box(<br/>    Modifier<br/>        .aspectRatio(1f)<br/>        .padding(1.dp)<br/>        .background(Color.DarkGray)<br/>        .clipToBounds()<br/>) { ... }</span></pre><p id="c7d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让线条在中间重叠得更多，我们可以把它们画得稍微长一点— <code class="du ku kv kw kx b">2f</code>似乎就是这么做的:</p><pre class="ki kj kk kl fd ky kx kz la aw lb bi"><span id="9b59" class="lc jf hh kx b fi ld le l lf lg">end = Offset(size.width / 2 + 2f, size.height / 2 + 2f),</span></pre><p id="8234" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">再次运行应用程序会给出我们的最终结果。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lz"><img src="../Images/42dcadecb32f1d33ffd4ec57dd946415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*PIrlEiGiotEHwdie08LN_Q.png"/></div></figure><h1 id="24be" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">结论</strong></h1><p id="45bc" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">同样，这个项目的完整源代码可以在GitHub 的<a class="ae jd" href="https://github.com/zsmb13/PrimeTableGenerator" rel="noopener ugc nofollow" target="_blank">上找到。</a></p><p id="3eb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您正在寻找更多类似的撰写内容，请查看以下文章:</p><ul class=""><li id="df35" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lq lr ls lt bi translated"><a class="ae jd" href="https://proandroiddev.com/android-chat-app-jetpack-compose-dec472140ff1" rel="noopener ugc nofollow" target="_blank">使用Jetpack Compose构建Android聊天应用</a></li><li id="f7dd" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><a class="ae jd" href="https://zsmb.co/compose-o-clock/" rel="noopener ugc nofollow" target="_blank">构成时钟</a></li><li id="d015" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><a class="ae jd" href="https://blog.kotlin-academy.com/jetpack-compose-first-impressions-and-learning-resources-4101bff9f04" rel="noopener ugc nofollow" target="_blank"> Jetpack撰写:第一印象和学习资源</a></li></ul></div></div>    
</body>
</html>