<html>
<head>
<title>Build Progressive Web Apps — Chapter 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建渐进式Web应用程序—第3章</h1>
<blockquote>原文：<a href="https://medium.easyread.co/build-progressive-web-apps-chapter-3-a73269d627b2?source=collection_archive---------0-----------------------#2019-11-24">https://medium.easyread.co/build-progressive-web-apps-chapter-3-a73269d627b2?source=collection_archive---------0-----------------------#2019-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d548" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">准备和工具</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8134532384dcd7f520a33914c6a5085c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HXw-XpZRosBJd_Lp"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@yer_a_wizard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fleur</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d731" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">构建渐进式Web应用程序-列表</h1><p id="0fc5" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://medium.com/easyread/build-progressive-web-apps-6248a7152730" rel="noopener"> <strong class="ln io">第0章—PWA</strong></a><br/><a class="ae ks" href="https://medium.com/easyread/build-progressive-web-apps-chapter-1-d3d2b449ab42" rel="noopener"><strong class="ln io">介绍及案例分析第1章—PWA</strong></a><strong class="ln io"><br/></strong><a class="ae ks" href="https://medium.com/easyread/build-progressive-web-apps-chapter-2-pwa-components-428295c2d524" rel="noopener"><strong class="ln io">第2章—PWA的组件&amp;架构模式</strong> </a> <strong class="ln io"> <br/>第3章—准备及工具(你在这里)<br/> </strong> <a class="ae ks" href="https://medium.com/easyread/build-progressive-web-apps-chapter-4-b85ef6e6d465" rel="noopener"> <strong class="ln io">第4章—创建简单的SPA(单页应用)</strong> </a></p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h2 id="4fd9" class="mo ku in bd kv mp mq dn kz mr ms dp ld lu mt mu lf ly mv mw lh mc mx my lj mz bi translated">要制作PWA，我们需要:</h2><ol class=""><li id="649d" class="na nb in ln b lo lp lr ls lu nc ly nd mc ne mg nf ng nh ni bi translated">Chrome浏览器版本52或以上。</li><li id="01af" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nf ng nh ni bi translated">Chrome的网络服务器，或者你选择的网络服务器</li><li id="cbfc" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nf ng nh ni bi translated">一个文本编辑器(Sublime Text，Visual Studio代码，Atom，Notepad ++等。)</li><li id="1f85" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nf ng nh ni bi translated">HTML，CSS，JavaScript和Chrome DevTools的基础知识。</li></ol><p id="1ec0" class="pw-post-body-paragraph ll lm in ln b lo no jo lq lr np jr lt lu nq lw lx ly nr ma mb mc ns me mf mg ig bi translated">我们将更侧重于讨论PWA中的技术。对于它之外的其他东西，如界面设计，将只在需要时讨论，读者只是简单地复制和粘贴。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="52c9" class="pw-post-body-paragraph ll lm in ln b lo no jo lq lr np jr lt lu nq lw lx ly nr ma mb mc ns me mf mg ig bi translated">当使用传统的web界面时，每个页面都有自己的HTML文件。因此，当从一个页面转到另一个页面时，会有一个时间延迟，用户必须等待页面加载并显示某些内容。这不同于一般的原始应用程序。例如，在没有连接的移动设备上使用Twitter应用程序时，我们无法看到时间线内容，因为没有互联网连接来下载数据，但我们仍然可以看到一些UI组件。这说明原来的应用程序只是从服务器安装它的数据，而其他的UI组件从一开始就已经安装好了，在应用程序打开的时候会立刻出现。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/85f776612cd92272abb08b3d92365e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8HF5AomSa-s76bdN.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Twitter application on mobile devices without connection</figcaption></figure><p id="966d" class="pw-post-body-paragraph ll lm in ln b lo no jo lq lr np jr lt lu nq lw lx ly nr ma mb mc ns me mf mg ig bi translated">在介绍性模块中，我们了解到PWA的目标之一是使用本机应用程序提供尽可能相似的体验。如果我们的PWA仍然必须在向用户显示之前加载每个页面，这意味着我们还没有提供类似于本机应用程序的体验。通过使用PWA技术，我们可以将应用程序UI组件存储在设备上，因此应用程序可以在显示来自服务器的数据之前直接显示界面。这种技术被称为应用程序外壳。</p><h1 id="8a56" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">什么是应用外壳？</h1><p id="a00f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">应用程序外壳或缩写的应用程序外壳是渐进式Web应用程序中的一种技术，用于创建无需等待服务器响应即可立即加载的界面。shell应用程序仅由存储在缓存中的极简HTML、CSS和JavaScript文件组成，因此应用程序可以离线工作。由于存储在缓存中，用户无需在每次打开应用时反复向服务器请求shell app。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/1db92be0ee0d90659159434c6ebd0da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vts-0OcdfBJo6SJy.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><em class="nv">single-page app</em> (SPA)</figcaption></figure><p id="a190" class="pw-post-body-paragraph ll lm in ln b lo no jo lq lr np jr lt lu nq lw lx ly nr ma mb mc ns me mf mg ig bi translated">果壳app只是一种技术，而不是一个库或框架。如果读者已经构建了一个单页应用程序(SPA)，那么读者实际上已经实现了与shell应用程序非常相似的东西。我们可以创建一个有框架或没有框架的shell应用程序(与框架无关)。</p><h1 id="c0c3" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">使用Shell应用程序的优势</h1><p id="fbc9" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在构建网站时，使用shell应用程序有许多优势。其中一些如下:</p><ul class=""><li id="5e31" class="na nb in ln b lo no lr np lu nw ly nx mc ny mg nz ng nh ni bi translated">它具有可靠和非常快的性能。因为界面的静态资产(HTML、CSS、JavaScript和图像)在第一次访问时被缓存，所以在下一次会话中返回的用户可以立即加载它们。</li><li id="ad1c" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nz ng nh ni bi translated"><strong class="ln io">体验如原生应用。</strong>通过应用shell app技术，我们可以为web应用提供与本地应用非常相似的界面、导航系统和离线支持。</li><li id="8039" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nz ng nh ni bi translated"><strong class="ln io">更有效率。</strong>虽然总的来说，互联网套餐的价格相当实惠，但仍然有一些地区的互联网套餐仍然很贵，但速度很慢。通过使用shell应用程序，我们可以帮助用户节省数据使用量，因为并非所有数据都必须重复下载。</li></ul><h1 id="ffc0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">何时使用果壳App </strong></h1><p id="5e5c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">app shell适用于制作网站或基于web的应用程序的几乎所有场景。一般来说，网站的每个页面都必须有相同的组件，比如页眉、页脚或侧边栏。这些重复的组件可以存储在浏览器缓存中，以便当用户访问另一个页面时，浏览器只需要响应与该页面相关联的内容。</p><p id="d398" class="pw-post-body-paragraph ll lm in ln b lo no jo lq lr np jr lt lu nq lw lx ly nr ma mb mc ns me mf mg ig bi translated">只是要实现App Shell，你需要稍微改变一下web应用开发的范式。从我们通常以每页页数或多页app (MPA)形式制作的东西来看，它是单页或单页app (SPA)的基础。页面内容数据请求是异步完成的，也称为AJAX(异步JavaScript和XMLHTTP)。通过使用AJAX技术，改变页面内容不再需要重新加载整个页面。</p><h1 id="ff62" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">使用Shell应用程序的条款</h1><p id="8d05" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">使用App Shell技术必须满足的一些条件包括:</p><ul class=""><li id="16e5" class="na nb in ln b lo no lr np lu nw ly nx mc ny mg nz ng nh ni bi translated"><strong class="ln io">使用服务人员绕过请求路径。</strong>在标准的web应用程序中，每个资产请求都将被浏览器直接定向到互联网。通过使用Service Worker，我们可以挑选出哪些请求需要被定向到网络，以及哪些请求可以使用存储在浏览器缓存中的资产来充分满足。您可以在模块3中找到更多关于服务人员的信息。</li><li id="2cff" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nz ng nh ni bi translated"><strong class="ln io">将shell应用程序的主要资产保存在缓存中。</strong>为了让应用程序不再需要发送对相同资产的请求，尤其是在shell应用程序中使用时，我们需要使用缓存API将它们存储在浏览器缓存中。您可以在模块4中找到有关缓存API的更多信息。</li><li id="c28c" class="na nb in ln b lo nj lr nk lu nl ly nm mc nn mg nz ng nh ni bi translated"><strong class="ln io">使用AJAX请求检索数据。</strong>如前所述，我们需要使用AJAX发送数据请求，并使用JavaScript将响应结果安装在我们准备用来存储动态内容的元素上。您可以使用Fetch API、XMLHttpRequest方法或使用默认的ajax JavaScript库方法，如<strong class="ln io"> $。jQuery中的ajax () </strong>。</li></ul></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="cc90" class="kt ku in bd kv kw oa ky kz la ob lc ld jt oc ju lf jw od jx lh jz oe ka lj lk bi translated">参考</h1><p id="a5ed" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://www.dicoding.com/academies/74" rel="noopener ugc nofollow" target="_blank"> Membangun渐进式网络应用</a></p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div></figure></div></div>    
</body>
</html>