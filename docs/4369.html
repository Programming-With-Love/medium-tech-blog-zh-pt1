<html>
<head>
<title>Why Backend Javaer Should Try Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么后端Javaer应该尝试Kotlin</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/why-backend-javaer-should-try-kotlin-c4003b5edb74?source=collection_archive---------3-----------------------#2021-06-02">https://medium.com/google-developer-experts/why-backend-javaer-should-try-kotlin-c4003b5edb74?source=collection_archive---------3-----------------------#2021-06-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/238a335f40e6bb0c9cc401fe07b02305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w9QgpIYoI44sCKF1"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@elventhorncreations?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elisabeth Wales</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f13b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我以前是一名专注于后端的Java开发人员。Spring是我最熟悉的框架。因为Spring Framework 5高度支持Kotlin。是时候用Kotlin试试Spring框架了。</p><p id="0504" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你用谷歌搜索为什么是科特林，为什么是科特林，为什么是T2。&amp;缺点。、<strong class="iw hi">科特林vs爪哇</strong>、<strong class="iw hi"> </strong>等。有很多很棒的文章可以互相解释和比较。所以我就不再重复了。但即使我们知道Kotlin有许多令人敬畏的部分，为什么许多Java开发人员倾向于继续使用Java而不是Kotlin？</p><p id="eeb5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯，说来话长。但这部分不是我今天要重点讲的重点。但是如果我们从商业角度考虑，继续使用Java是一个合理的选择。因为连写Kotlin代码都比Java舒服。我认为最有力的原因是Java已经有了一个大的生态系统来支持大多数的产品案例。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6d26" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以今天我想展示一个后端服务器端的场景来解释这个标题。我将使用<strong class="iw hi">协程</strong>并发发送或处理请求，并与我们过去使用的其他代码风格进行比较。</p><p id="392d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在前端，并发发送请求是常见的场景。但是在过去，在Java后端并发地发送或处理请求并不流行。我觉得有以下几点原因。</p><ol class=""><li id="076e" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">Servlet(每个线程每个请求)和阻塞请求的模型非常容易学习和使用。如果您的服务器不需要处理巨大的流量，垂直扩展是一个简单而有用的想法。</li><li id="35ff" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">并发请求风格比顺序阻塞请求风格更复杂。</li><li id="ff2e" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">生态系统最近增加了支持。例如，Spring 5反对RestTemplate(阻塞的),建议我们改用WebClient(非阻塞的)</li></ol></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><blockquote class="kn ko kp"><p id="68b3" class="iu iv kq iw b ix iy iz ja jb jc jd je kr jg jh ji ks jk jl jm kt jo jp jq jr ha bi translated">空谈不值钱。给我看看代码。</p></blockquote><p id="2a57" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我为2–1–2个请求设计了一个案例，这在我们真实的项目场景中非常常见。这意味着我们可以同时发送前两个请求。第三个请求需要前两个请求的结果。最后两个请求也需要第三个请求的结果，我们可以同时发送它。</p><p id="2d1a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">原始阻塞请求示例如下所示。</p><figure class="ku kv kw kx fd ii"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="202b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从代码中可以看出我们是否顺序调用了请求。花费了100+200+300+400+500=1500ms。但是我们之前解释的2–1–2情况意味着一些请求可以并发发送。</p><p id="abf7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们检查一下协程版本！</p><figure class="ku kv kw kx fd ii"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="e77d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们同时发送前两个请求，所以只需要200毫秒。第三个请求需要前两个的结果，我们发送它，花费300毫秒。最后两个请求也需要第三个请求的结果。我们同时发送这两个，所以要花500毫秒。</p><p id="9690" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，与原始样本相比，成本为(200+300+500 = 1000毫秒)&lt; (100+200+300+400+500=1500ms).</p><p id="0e06" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">This Coroutine sample shows a very important point that Java can not replace it. <strong class="iw hi">协程可以以顺序阻塞代码的方式编写并发代码。</strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="a92b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为什么这个简单的想法是有价值的？如果我们考虑其他解决方案，如手动处理线程池、CompletableFuture、反应式编程等。这些技术和协程是基于后台线程池之上的。但是其他解决方案很难写得简单易读。我在下面展示了CompletableFuture和Reactive编程案例，如果你有更好的版本，请反馈给我。</p><figure class="ku kv kw kx fd ii"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Servlet 3 Async feature support to return a Future</figcaption></figure><figure class="ku kv kw kx fd ii"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Spring WebFlux support to return a Mono or Flux</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="9c7c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">显然，协同程序代码风格比其他代码风格更简单，可读性更好。但我认为最重要的一点是在正确的场景下用正确的库和编码风格编码。例如，如果你的团队熟悉反应式编程或CompletableFuture。呆在上面完全没问题。但是如果我们只比较这些技术，显然协程更容易学习和编写。</p><p id="9aa3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在值得尝试Coroutine，来和我一起用Kotlin的Spring框架吧！</p></div></div>    
</body>
</html>