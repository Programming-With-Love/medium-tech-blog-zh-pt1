<html>
<head>
<title>How to use BigDecimal in Java accurately</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中准确使用BigDecimal</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-use-bigdecimal-in-java-accurately-f71ae959f9da?source=collection_archive---------0-----------------------#2022-08-18">https://medium.com/quick-code/how-to-use-bigdecimal-in-java-accurately-f71ae959f9da?source=collection_archive---------0-----------------------#2022-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8dd63a592863deb1413c7ce83271463f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vO7MsQbFHSXMDc5M.jpg"/></div></div></figure><p id="c67d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想知道为什么float和double数据类型不应该用于浮点计算吗？查看这个快速概述，了解更多关于使用BigDecimal执行精确运算的信息。</p><h1 id="8569" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="1fbc" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">大多数企业应用程序都使用浮点值。金融科技、电子商务、金融和其他应用每天都要处理浮点运算，需要对所有计算进行完全精确的控制。<br/>开发人员需要知道什么样的Java数据类型适合表示浮点值，尤其是货币值。<br/>让我们试着弄清楚。</p><h1 id="10db" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么double不准确</h1><p id="aa02" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">首先想到的是使用float和double数据类型。<br/>但是，如果需要精确的值，不建议使用这些数据类型。事实上，float和double类型主要用于科学和工程计算。<br/>他们实现了精心设计的二进制浮点运算，以快速获得大范围数值的正确近似值。<br/>不幸的是，这些类型不能给出准确的结果，因此不适合货币计算:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="5e7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了更深入地理解浮点数是如何表示的，请看一下IEEE浮点运算标准。</p><h1 id="ccbd" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">BigDecimal如何保证准确性</h1><p id="3f82" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">回到引言，让我们看看BigDecimal是如何表示一个数的，以及它是如何保证精度的。<br/>查看BigDecimal的源代码，我们可以发现，BigDecimal是由一个未按比例缩放的值和一个比例表示的数字:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="d009" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">scale字段表示BigDecimal的小数位数。<br/>未缩放值使用稍微复杂一点的表示法。<br/>当未缩放值超过阈值时(默认为Long。MAX_VALUE)，intVal字段用于存储值，intCompact字段存储Long。MIN_VALUE，用于指示有效位信息仅可从intVal获得。<br/>否则，未缩放的值被紧凑地存储在long类型intCompact字段中，用于后续计算，并且intVal为空。</p><p id="6cb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">BigDecimal还提供了一个scale方法来返回BigDecimal的小数位数:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="1de3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该方法的注释详细描述了如何使用比例值:</p><blockquote class="kx ky kz"><p id="1444" class="ip iq la ir b is it iu iv iw ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl jm ha bi translated"><em class="hh">返回此BigDecimal的小数位数。如果为零或正数，则小数位数是小数点右边的位数。如果为负，则数字的未缩放值乘以10的小数位数的负幂。例如，比例-3表示未缩放的值乘以1000。</em></p></blockquote><p id="f9d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到上面的示例，无法用二进制精确表示的数字0.61可以用BigDecimal表示，其值为61，小数位数为2。</p><h1 id="d979" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何正确创建BigDecimal</h1><p id="e630" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">查看BigDecimal的源代码，我们可以找出四个重要的构造函数:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="754d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以上四个构造函数创建的BigDecimal的小数位数是不一样的。<code class="du le lf lg lh b">BigDecimal(int)</code>和<code class="du le lf lg lh b">BigDecimal(long)</code>更直接，取整数输入参数，所以它们的小数位数都是0。<br/> <code class="du le lf lg lh b">BigDecimal(double)</code>和<code class="du le lf lg lh b">BigDecimal(String)</code>尺度需要更细致的考虑。</p><h1 id="ae36" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">BigDecimal(double)怎么了</h1><p id="2745" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">BigDecimal提供了一种从double创建BigDecimal的方法，但不推荐使用这种方法，因为结果可能有些不可预测。使用双精度值0.61创建的BigDecimal不完全等于0.61，因为0.61不能精确地表示为有限长度的二进制数。实际表现为:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="78c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，使用BigDecimal(double ),尤其是对于涉及金融交易的计算，是极其危险的，因为它可能会失去精度。</p><h1 id="8e93" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用BigDecimal(字符串)创建</h1><p id="5b57" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><code class="du le lf lg lh b">BigDecimal(String)</code>构造函数是完全可预测的。第<code class="du le lf lg lh b">new BigDecimal("0.61")</code>行创建一个BigDecimal，它正好等于0.61:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="c888" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不过必须注意的是<code class="du le lf lg lh b">new BigDecimal("0.610000")</code>和新<code class="du le lf lg lh b">BigDecimal("0.61")</code>的刻度分别是6和2。这些大小数的equals方法比较结果为假。</p><p id="0dbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相应地，有两种方法可以创建能准确表示0.61的BigDecimal:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="95e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">方法<code class="du le lf lg lh b">BigDecimal.valueOf(double)</code>使用两步过程，通过调用<code class="du le lf lg lh b">Double.toString(double)</code>方法实现。第一步是将Double转换为String。第二步是将String转换为BigDecimal:</p><figure class="kq kr ks kt fd ii"><div class="bz dy l di"><div class="ku kv l"/></div></figure><h1 id="edf5" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="92e1" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">由于计算机使用二进制代码来存储和处理数据，许多浮点数不能精确地表示为任何有限长度的二进制分数。<br/>因此，通过近似，采用了一种在计算机中表示浮点数的方式，比如单精度浮点和双精度浮点格式。<br/>不幸的是，这些类型不能给出准确的结果，不适合精确计算，尤其是影响金融交易。<br/>因此，使用<code class="du le lf lg lh b">BigDecimal(double)</code>是极其危险的，因为它可能会失去精度和不可预测的结果。<br/>因此，创建BigDecimal的普遍首选和强烈推荐的方法是使用<code class="du le lf lg lh b">BigDecimal(String)</code>和<code class="du le lf lg lh b">BigDecimal.valueOf(double)</code>方法。</p><h1 id="470e" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">参考</h1><p id="87fd" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">[1]链接到用于浮点运算的IEEE标准<a class="ae kw" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl li lj go lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ha hb hc hd he"><p id="e185" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="la">原载于2022年8月18日</em><a class="ae kw" href="https://argen666.github.io/java/2022/08/18/how-to-use-bigdecimal-in-java-accurately.html" rel="noopener ugc nofollow" target="_blank"><em class="la">http://argen 666 . github . io</em></a><em class="la">。</em></p></div></div>    
</body>
</html>