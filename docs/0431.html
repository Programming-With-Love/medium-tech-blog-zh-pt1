<html>
<head>
<title>Testing two consecutive LiveData emissions in Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在协程中测试两次连续的LiveData发射</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/testing-two-consecutive-livedata-emissions-in-coroutines-5680b693cbf8?source=collection_archive---------1-----------------------#2019-10-15">https://medium.com/androiddevelopers/testing-two-consecutive-livedata-emissions-in-coroutines-5680b693cbf8?source=collection_archive---------1-----------------------#2019-10-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/769e68b9f4278ed822bf44d65714a12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwtZfGUPlkMizuz9v3yp5w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="hu">Illustration by </em><a class="ae hv" href="https://twitter.com/_kiranpuri" rel="noopener ugc nofollow" target="_blank"><em class="hu">Kiran Puri</em></a></figcaption></figure><div class=""/><p id="0e07" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这篇文章是关于我们如何在开源<a class="ae hv" href="https://github.com/android/plaid" rel="noopener ugc nofollow" target="_blank">格子应用</a>中通过暂停和恢复协程的<code class="du jt ju jv jw b">CoroutineDispatcher</code>来单元测试两个连续的LiveData发射。</p><p id="8c99" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">不要忘记查看文章末尾的良好实践部分，以使您的测试准确、快速和可靠。</p><h1 id="cee4" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">问题是</h1><p id="9df1" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">我们想要测试两个连续的LiveData发射(其中一个是在一个协程中执行的)，但是这是不可能的，因为我们曾经使用<a class="ae hv" href="https://github.com/android/plaid/pull/695/files#diff-0c645491d198785a12b5fa5afd6598f5" rel="noopener ugc nofollow" target="_blank">注入</a> <code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.Unconfined</a></code>来立即执行所有的协程。因此，当我们可以断言单元测试中的排放时，第一个LiveData排放被遗漏了，我们只能检查第二个排放。更多详情如下:</p><figure class="lb lc ld le fd hj er es paragraph-image"><div class="er es la"><img src="../Images/cd75c5bb296b9382f0c43f3efb928bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*u3d1A7VacltlJyRa4AGqYA.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="hu">Dribbble Shot details screen in Plaid</em></figcaption></figure><p id="bb41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在<a class="ae hv" href="http://www.dribbble.com" rel="noopener ugc nofollow" target="_blank">Dribbble</a>(Plaid的数据源之一)详细信息屏幕上，我们希望尽可能快地显示屏幕，但是有些元素在显示之前可能需要一些时间来处理(由于延迟地将markdown格式化为<code class="du jt ju jv jw b">Spannables</code>)。为了解决这个问题，我们决定快速发出UI状态的简化版本，然后启动一个后台操作来产生处理后的版本，然后发出它。</p><p id="ae5f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">为此，我们使用LiveData和协同例程:LiveData用于UI通信，协同例程用于执行主线程之外的操作。当ViewModel启动时，我们向UI观察的LiveData发出一个基本的UI模型。然后，我们调用<code class="du jt ju jv jw b"><a class="ae hv" href="https://github.com/android/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/domain/CreateShotUiModelUseCase.kt" rel="noopener ugc nofollow" target="_blank">CreateShotUiModel</a></code> <a class="ae hv" href="https://github.com/android/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/domain/CreateShotUiModelUseCase.kt" rel="noopener ugc nofollow" target="_blank">用例</a>，它将执行移到后台并创建完整的UI模型。当用例完成时，ViewModel像以前一样将完整的UI模型发送到相同的LiveData。这可以在下面的代码中看到:</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f719" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><a class="ae hv" href="https://github.com/android/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/ui/shot/ShotViewModel.kt" rel="noopener ugc nofollow" target="_blank"> <em class="lh">参见此处</em> </a>的完整代码</p><p id="cee0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们想要测试两种UI状态都被发送到UI。但是，我们无法验证第一次发射，因为两个UI状态是连续发射的，而LiveData实例只包含第二次发射。发生这种情况是因为在我们的测试中，由于<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.Unconfined</a></code>被注入，协同程序在<code class="du jt ju jv jw b">processUiModel</code>中启动并同步执行。</p><p id="76a6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Plaid使用一个名为<code class="du jt ju jv jw b"><a class="ae hv" href="https://github.com/android/plaid/blob/master/core/src/main/java/io/plaidapp/core/data/CoroutinesDispatcherProvider.kt" rel="noopener ugc nofollow" target="_blank">CoroutinesDispatcherProvider</a></code>的类将协程调度程序注入到使用协程的类中。</p><blockquote class="li lj lk"><p id="9c83" class="iv iw lh ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js ha bi translated">LiveData只保存它收到的最后一个值。为了在测试中测试LiveData的内容，我们使用了<code class="du jt ju jv jw b"><a class="ae hv" href="https://github.com/android/architecture-components-samples/blob/master/LiveDataSample/app/src/test/java/com/android/example/livedatabuilder/util/LiveDataTestUtil.kt" rel="noopener ugc nofollow" target="_blank">LiveData.getOrAwaitValue()</a></code>扩展函数。</p></blockquote><p id="0ce5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们要求的以下单元测试失败了:</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b033" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们如何测试这种行为？</p><h1 id="563e" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">解决方案</h1><p id="3410" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">我们使用来自协程库(<code class="du jt ju jv jw b">kotlinx.coroutines.test</code>包)的新<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">TestCoroutineDispatcher</a></code>来暂停和恢复由<code class="du jt ju jv jw b">ViewModel</code>创建的协程的<code class="du jt ju jv jw b">CoroutineDispatcher</code>。</p><blockquote class="li lj lk"><p id="7442" class="iv iw lh ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js ha bi translated"><em class="hy">免责声明</em> : TestCoroutineDispatcher还是一个实验性的API。</p></blockquote><p id="3995" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">使用注入的<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>实例，我们可以控制协程何时开始执行。测试逻辑如下:</p><ol class=""><li id="1963" class="lo lp hy ix b iy iz jc jd jg lq jk lr jo ls js lt lu lv lw bi translated">在测试开始之前，暂停调度程序并检查在ViewModel init期间是否发出了fast结果。</li><li id="4334" class="lo lp hy ix b iy lx jc ly jg lz jk ma jo mb js lt lu lv lw bi translated">恢复启动视图模型中<code class="du jt ju jv jw b">processUiModel</code>方法的协程的测试调度程序。</li><li id="78da" class="lo lp hy ix b iy lx jc ly jg lz jk ma jo mb js lt lu lv lw bi translated">验证是否发出了慢速结果。</li></ol><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="195b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><a class="ae hv" href="https://github.com/android/plaid/blob/master/dribbble/src/test/java/io/plaidapp/dribbble/ui/shot/ShotViewModelTest.kt#L159" rel="noopener ugc nofollow" target="_blank"> <em class="lh">完整代码见此处</em> </a></p><p id="6a58" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在此处查看测试<a class="ae hv" href="https://github.com/android/plaid/pull/695/files#diff-0c645491d198785a12b5fa5afd6598f5" rel="noopener ugc nofollow" target="_blank">中注入<code class="du jt ju jv jw b"><a class="ae hv" href="https://github.com/android/plaid/blob/master/core/src/main/java/io/plaidapp/core/data/CoroutinesDispatcherProvider.kt" rel="noopener ugc nofollow" target="_blank">CoroutinesDispatcherProvider</a></code>的差异。</a></p><p id="8b24" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们在<code class="du jt ju jv jw b">testCoroutineDispatcher.<a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html" rel="noopener ugc nofollow" target="_blank">runBlockingTest</a></code> body lambda中包含测试体和断言，因为与<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" rel="noopener ugc nofollow" target="_blank">runBlocking</a></code>类似，它将同步执行使用<code class="du jt ju jv jw b">testCoroutineDispatcher</code>的协程。</p><blockquote class="li lj lk"><p id="0fd0" class="iv iw lh ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js ha bi translated"><em class="hy">免责声明2 </em>:为了避免每次测试都必须建立和拆除一个<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>，您可以像在其他<a class="ae hv" href="https://github.com/android/plaid/blob/master/search/src/test/java/io/plaidapp/search/ui/SearchViewModelTest.kt" rel="noopener ugc nofollow" target="_blank">测试</a>中一样使用这个<a class="ae hv" href="https://github.com/android/plaid/blob/master/test_shared/src/main/java/io/plaidapp/test/shared/MainCoroutineRule.kt" rel="noopener ugc nofollow" target="_blank"> JUnit测试规则</a>。</p></blockquote><h2 id="267c" class="mc jy hy bd jz md me mf kd mg mh mi kh jg mj mk kl jk ml mm kp jo mn mo kt mp bi translated">另一种方法</h2><p id="16ff" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">你可以选择其他方法来解决这个问题。当我们面临这个问题时，我们选择了我们认为最好的一个，因为它不需要更改应用程序代码。</p><p id="d6f2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">另一种实现方式是在ViewModel中使用新的<a class="ae hv" href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener ugc nofollow" target="_blank">liveData coroutines builder</a>来发出这两个项目，在测试中，使用<code class="du jt ju jv jw b"><a class="ae hv" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/lifecycle/lifecycle-livedata-ktx/src/main/java/androidx/lifecycle/FlowLiveData.kt?source=post_page---------------------------%2F%2F%2F%2F%2F&amp;autodive=0%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F#86" rel="noopener ugc nofollow" target="_blank">LiveData.asFlow()</a></code>扩展函数来断言这些元素，正如您在<a class="ae hv" href="https://github.com/android/plaid/pull/770" rel="noopener ugc nofollow" target="_blank">这个PR </a>中看到的。这种方法避免了在测试中停止调度程序，并有助于将测试从实现中分离出来，但需要更改ViewModel实现以使用生命周期协程扩展中可用的最新API。</p><h1 id="dbb3" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">以及良好的实践</h1><p id="98a4" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">为了使您的测试准确、快速和可靠，您应该:</p><h2 id="c21c" class="mc jy hy bd jz md me mf kd mg mh mi kh jg mj mk kl jk ml mm kp jo mn mo kt mp bi translated">始终注入调度器！</h2><p id="53ab" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">如果调度程序没有被注入到允许我们在测试中使用<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>的ViewModel中，我们不可能解决这个问题。</p><p id="cb1b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">作为一个好的实践，<strong class="ix hz">总是将调度程序注入到那些使用它们的类中</strong>。你不应该在你的类中直接使用coroutines库附带的预定义调度程序(例如<code class="du jt ju jv jw b">Dispatchers.IO</code>)，因为这会增加测试的难度，把它们作为依赖项传递。</p><p id="5edb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">看到这些在任何类中被直接使用都是一种代码味道，如下面的代码所示:</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="e2e9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">具体说一下<a class="ae hv" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank"> AAC ViewModels </a>以及默认为<code class="du jt ju jv jw b">Dispatchers.Main</code>的<code class="du jt ju jv jw b">viewModelScope</code>的用法，由于<code class="du jt ju jv jw b">viewModelScope</code>代码不能更改，所以不是注入，而是需要覆盖。我们通过将这个JUnit规则与注入到其他类中的同一个<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>实例一起使用<a class="ae hv" href="https://github.com/android/plaid/blob/master/test_shared/src/main/java/io/plaidapp/test/shared/MainCoroutineRule.kt" rel="noopener ugc nofollow" target="_blank">来做到这一点，参见</a><a class="ae hv" href="https://github.com/android/plaid/blob/master/search/src/test/java/io/plaidapp/search/ui/SearchViewModelTest.kt#L72" rel="noopener ugc nofollow" target="_blank">这里的一个例子</a>。要了解更多，请阅读这篇关于 <code class="du jt ju jv jw b"><a class="ae hv" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">viewModelScope</a></code>的<a class="ae hv" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">文章。</a></p><h2 id="159f" class="mc jy hy bd jz md me mf kd mg mh mi kh jg mj mk kl jk ml mm kp jo mn mo kt mp bi translated">注入TestCoroutineDispatcher而不是Dispatchers。自由的</h2><p id="588c" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">将一个<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">TestCoroutineDispatcher</a></code>实例注入到您的类中，并使用<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html" rel="noopener ugc nofollow" target="_blank">runBlockingTest</a></code>方法在您的测试中同步运行使用该调度程序的协同程序。您也可以使用<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>来恢复和暂停协程。</p><p id="fd27" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">作为一般规则，在三个预定义的调度程序中注入相同的<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>实例(即<code class="du jt ju jv jw b">Main</code>、<code class="du jt ju jv jw b">Default</code>、<code class="du jt ju jv jw b">IO</code>)。如果您需要验证多线程场景中任务的计时(例如，您想要测试同时运行的协程的排列)，那么为每个预定义的调度程序创建并注入一个不同的<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>实例。</p><h2 id="023e" class="mc jy hy bd jz md me mf kd mg mh mi kh jg mj mk kl jk ml mm kp jo mn mo kt mp bi translated"><strong class="ak">调度员呢。无约束？</strong></h2><p id="d011" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">如果希望同步执行协程内部的代码，也可以注入<code class="du jt ju jv jw b">Dispatchers.Unconfined</code>进行测试(<code class="du jt ju jv jw b">kotlinx-coroutines</code>目前使用它进行测试)。然而，<code class="du jt ju jv jw b">Unconfined</code>给你的灵活性比<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>小:你不能暂停<code class="du jt ju jv jw b">Unconfined</code>，而且它仅限于立即派遣。</p><p id="8f90" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">它还将打破使用不同调度程序的代码的假设和计时。这在测试并行计算时更加明显，例如，它们将在编写它们的另一个程序中执行，你不能测试那些在不同时间完成的计算的不同排列。</p><p id="f828" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><code class="du jt ju jv jw b">Unconfined</code>和<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>都明确避免并行执行。然而，<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>让您对暂停模式下并发执行的顺序有了更多的控制，但是它本身不足以测试每一种排列。常规的测试建议在这里适用，如果你在做复杂的并发行为，你需要在设计代码时考虑到可测试性。</p><h2 id="8564" class="mc jy hy bd jz md me mf kd mg mh mi kh jg mj mk kl jk ml mm kp jo mn mo kt mp bi translated">测试LiveData</h2><p id="a900" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">有关测试LiveData的更多最佳实践，请查看<a class="ae hv" href="https://twitter.com/ppvi" rel="noopener ugc nofollow" target="_blank"> Jose Alcerreca </a>关于这个的<a class="ae hv" rel="noopener" href="/androiddevelopers/unit-testing-livedata-and-other-common-observability-problems-bb477262eb04">帖子。</a></p></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="bc24" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><em class="lh">此处</em>  <em class="lh">见全格子PR</em><a class="ae hv" href="https://github.com/android/plaid/pull/695" rel="noopener ugc nofollow" target="_blank"><em class="lh">。</em></a></p></div></div>    
</body>
</html>