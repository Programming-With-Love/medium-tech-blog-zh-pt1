# 使用 Keywhiz 保护基础设施机密

> 原文：<https://medium.com/square-corner-blog/protecting-infrastructure-secrets-with-keywhiz-af674410832f?source=collection_archive---------0----------------------->

## 我们新开放的秘密管理和分发服务

> 注意，我们已经行动了！如果您想继续了解 Square 的最新技术内容，请访问我们的新家[https://developer.squareup.com/blog](https://developer.squareup.com/blog)

*[*贾斯汀*](https://twitter.com/justincummins) *撰写。**

*在 Square，我们的首要任务是安全。我们需要一些东西来保护秘密，特别是当我们采用面向服务的微服务架构时，秘密的数量增加了。虽然保护基础设施的秘密是一种普遍的需要，但是我们无法找到一个合适的秘密管理系统。(更多信息请参见[“现有实践”。)](https://corner.squareup.com/2015/04/keywhiz.html#existing-practices))所以，我们打造了 Keywhiz。*

*Keywhiz 是一个秘密管理和分发服务，现在每个人都可以使用。Keywhiz 帮助我们了解基础设施秘密，包括 TLS 证书和密钥、GPG 密匙环、对称密钥、数据库凭证、API 令牌和用于外部服务的 SSH 密钥——甚至包括一些非秘密，如 TLS 信任存储。Keywhiz 的自动化允许我们无缝地为我们的服务分发和生成必要的秘密，这提供了一个一致和安全的环境，并最终帮助我们更快地发货。*

# *关于秘密的假设*

*为了更好地理解我们的秘密管理解决方案，阐述我们对系统的要求是有帮助的。*

*   **秘密内容不应该被广泛访问*——无论是在开发系统上还是签入公共 GitHub 库。*
*   **服务需要对秘密的原始访问。*我们的观点是服务应该能够访问它们所使用的秘密。例如，内部正方形系统广泛使用 TLS。运行 web 服务器的内部服务应该直接协商 TLS，而不是使用众多的代理服务器。直接秘密访问的替代方法是帮助代理代表服务使用秘密——但是为每个用例、平台和语言编写代理既不可行也不简单。*
*   *在一些情况下，我们的服务没有直接的秘密访问权限。例如，认证机构使用硬件安全模块(即为此目的设计的外部硬件)。在这种情况下，Keywhiz 仍然向证书颁发机构服务提供使用硬件安全模块所需的秘密。*
*   **集中管理是防止*[](https://33.media.tumblr.com/tumblr_lgb02mCfLm1qe0eclo1_r5_500.gif)**过多秘密的必要手段*微服务架构迅速增加秘密的数量。如果没有一个集中的系统，秘密文件可能会随着时间的推移被放错地方、复制和/或遗忘，这使得这些文件更容易被泄露。一个集中的系统也让我们更容易分析秘密。例如，我们可以监控弱密钥和即将到来的证书过期。**
*   ***对秘密的访问应该是可审计的。可能有必要追查秘密是何时被谁获取的。秘密管理系统应该提供每次访问的日志，以及在什么上下文中访问了秘密。将机密作为文件放在服务器上不提供审计功能。( [Auditd](https://people.redhat.com/sgrubb/audit/) 可以有所帮助，但是需要额外的工程工作。)***
*   ***系统需要支持多种服务。*自成立以来，Keywhiz 已经为 Square 的众多服务和工具提供了秘密。仅举几个例子:Rails、Jetty、Netty、Nginx、GPG、curl 和 MySQL。**
*   ***系统必须可靠。我们最重要的服务离不开它们的秘密。传递机密的系统必须可靠且高度可用。***
*   **该系统应该便于消费者使用。管理秘密的系统必须易于使用；否则，人们会被诱惑去寻找捷径。**
*   ***密钥轮换必须与软件部署分离。*密钥轮换是加密系统的一项要求，但没有通用的解决方案。例如，一些密钥必须在到期前轮换，这可能不适合软件部署的时间或频率。我们需要将自动密钥轮换从软件部署中分离出来的能力。**

# **现有做法**

**我们发现存储基础设施机密有一些常见的模式，包括在源代码中存储机密、手动部署到服务器以及使用配置管理。**

**在源代码中存储秘密是一种流行的安全反模式。源代码必须在开发、修订控制、测试和持续集成系统上可访问——这些系统都不是为了安全地存储或分发机密信息而设计的。此外，更新秘密内容不应该与修改代码联系在一起；仅仅转动钥匙不会引起系统变化。**

**在小范围内，手动将机密部署到服务器是一种合理的方法。然而，如果没有秘密管理系统，这种方法很快就会变得难以处理，因为不可避免地会有更多的秘密在更多的系统中被创建、替换和复制。这种方法容易将秘密留在主目录、临时文件夹和备份副本中。一些秘密不可避免地没有被更新或以不正确的权限存储。审计对秘密的访问或对它们进行全面的推理，就像确定即将到来的证书过期时间一样，变得很困难。如果从加密存储进行部署，可能需要一个主密钥来解密所有内容，或者需要一个复杂的映射来确定应该在哪里部署什么。旧的、放错位置的或不正确擦除的磁盘会导致机密泄露。**

**基于配置管理系统的秘密管理方案具有与将秘密存储在源代码中和服务器磁盘上相同的缺点。尽管配置管理系统具有能够将秘密变更从代码变更中分离出来的优势，但是它们应该是广泛可见和可复制的，并且保留变更历史——所有这些都与秘密管理相反。许多[项目](https://docs.ansible.com/playbooks_vault.html) [已经](https://puppetlabs.com/blog/encrypt-your-data-using-hiera-eyaml) [被](https://github.com/Nordstrom/chef-vault) [制作](https://github.com/StackExchange/blackbox)以在将秘密放入配置管理系统之前对其进行加密，通常使用 GPG 或自行开发的 AES。然后，受信任的个人在部署时输入密钥，明文秘密被部署到服务器磁盘上。决定性地删除一个秘密是困难的(几乎不可能)。配置管理系统中的密钥轮换必须具有对配置进行更改的自主权限，并且有时必须能够访问解密密钥。此外，将秘密管理和配置管理结合起来使得将来很难迁移到另一个系统。**

# **键盘高手**

**Keywhiz 系统主要由 Keywhiz 服务器和一个名为 [KeywhizFs](https://github.com/square/keywhiz-fs) 的 [FUSE](http://fuse.sourceforge.net/) 文件系统客户端组成。FUSE 使程序能够公开一个虚拟文件系统，而无需在磁盘上实际存储任何东西。Keywhiz 服务器的管理是通过 web app、CLI 或 automation REST API 来完成的。服务器、KeywhizFs 和自动化客户端之间的通信使用 TLS 的相互身份验证来保护。**

**在 Keywhiz 中，访问控制是根据客户机、组和秘密来定义的。每个验证机密的证书称为客户端。客户端被分配到任意数量的组的成员资格。要允许客户端访问机密，必须至少将机密授予客户端所在的一个组。在实践中，我们为特定服务器上的每项服务创建一个组，为每项服务创建一个组，并为每个人创建一个组。这三组涵盖了大多数用例。**

**为了保护存储在服务器端的机密，每个机密在存储到数据库之前都用唯一的密钥进行 AES-GCM 加密。这个唯一的密钥是使用 HKDF 生成的。Square 使用硬件安全模块来包含派生密钥。**

**服务通过 KeywhizFs 获取秘密。在 Square，每台主机上的每个服务都有一个目录，其中安装了 KeywhizFs 文件系统。服务只需打开该目录中的一个只读“文件”就可以访问机密。执行目录列表显示哪些秘密是可访问的。本地访问控制很简单；传统的 Unix 文件权限用于机密“文件”基于文件表示的优势在于**几乎所有的软件都兼容从文件**中读取秘密。**

**KeywhizFs 使用 UNIX 权限来提供本地访问控制和分离。KeywhizFs 客户端证书、进程和虚拟目录由一个特殊的 KeywhizFs 用户拥有，该用户不同于服务使用的用户。假设服务用户没有特权，KeywhizFs 挂载点(由 KeywhizFs 用户拥有)是唯一的接口。为了使服务可以访问机密，KeywhizFs 挂载点被分配给服务用户组，并且所有机密都是组可读的。这在大多数情况下是可行的，但是偶尔会有软件包对文件所有权或许可有严格的要求。在这种情况下，额外的元数据与秘密一起存储在 keywhizs 服务器上，并指示 keywhizs 提供特殊的所有权或权限。**

**KeywhizFs 实际上不是将文件复制到远程服务器，而是向 KeywhizFs 服务器查询信息，并将数据缓存在 KeywhizFs 进程内存中。在网络中断或 Keywhiz 服务器故障的情况下，KeywhizFs 将继续提供以前访问过的授权机密。机密永远不会写入磁盘，而是缓存在内存中。这是在群集 Keywhiz 服务器之上的一个额外的安全机制，以确保不会出现根本性的中断。如果服务器关机，则不会有数据保存到磁盘。**

**KeywhizFs 比实际文件有更多的好处。例如，每个秘密访问都会被记录，包括其背后的用户。其他想法——如客户端加密和揭露旧版本的秘密——正在考虑中。**

# **广场部署**

**Keywhiz 使用许多 TLS 证书，每个服务器和每个 KeywhizFs 挂载点一个。这是部署到每台服务器上的每项服务的证书。这假定了一个用于创建可信证书的 PKI 系统和一个确定软件应该在哪里运行的部署系统。**

**公司设计了各种 PKI 系统——从特殊硬件上的内部认证机构到使用公共认证机构的门户。Keywhiz 只需要带有特定公共名称字段的 TLS 证书，因此它与大多数 PKI 系统兼容。如果您没有现有的 PKI，那么 [certstrap](https://github.com/square/certstrap) 是一个简单的起点。**

**Square 的部署系统对于什么软件在哪里运行是权威的。当一个服务第一次被部署到服务器上时，部署系统将通过 Keywhiz 的自动化 API 插入秘密并授权一个新的客户机。我们的证书颁发机构为 KeywhizFs 生成一个新的证书，编写一个 fstab 条目，KeywhizFs 安装在一个标准目录中，供服务读取。在随后的部署中，一些秘密会自动更新，包括 KeywhizFs 使用的证书。当服务退役时，相关的访问被移除，机密被删除。**

**Keywhiz 对 Square 非常有用。它支持内部广泛使用的加密技术和动态微服务架构。最初，Keywhiz use 将许多配置合并从秘密内容中分离出来，这使得秘密更安全，配置更容易访问。随着时间的推移，改进导致工程师们甚至没有意识到 Keywhiz 的存在。它只是工作。[请检查一下。](https://square.github.io/keywhiz)**

**[](https://twitter.com/justincummins) [## 贾斯汀·卡明斯(@justincummins) |推特

### 贾斯汀·康明斯的最新推文(@justincummins)。信息安全与马戏团。加利福尼亚州旧金山

twitter.com](https://twitter.com/justincummins)**