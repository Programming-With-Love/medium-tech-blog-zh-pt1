<html>
<head>
<title>Handling Concurrent Request dengan Database Locking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Handling Concurrent Request dengan Database Locking</h1>
<blockquote>原文：<a href="https://medium.easyread.co/meng-handle-concurrent-request-dengan-database-row-locking-transaction-1ea5387aa7c1?source=collection_archive---------0-----------------------#2020-05-27">https://medium.easyread.co/meng-handle-concurrent-request-dengan-database-row-locking-transaction-1ea5387aa7c1?source=collection_archive---------0-----------------------#2020-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c181" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc"> Handling Concurrent Request with Database Locking </em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/da6a896b0a0595849c238c7aed2c8d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIlY8gW3BjhleSeiDaWGwA.jpeg"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Credits: <a class="ae kt" href="https://www.bbc.co.uk/cbbc/findoutmore/help-me-out-staying-safe-online" rel="noopener ugc nofollow" target="_blank">BBC</a></figcaption></figure><p id="5409" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Kali ini saya akan membagikan pengalaman saya lagi-lagi tentang <em class="lq"> how to deal with a concurrent request </em> . Dulu, saya sempat menulis bagaimana cara meng- <em class="lq"> handle </em> <em class="lq"> concurrent request </em> dengan <em class="lq"> queue </em> di tulisan ini, <a class="ae kt" href="https://medium.com/easyread/manajemen-queue-antrian-untuk-menghandle-concurrent-request-dengan-kue-di-node-js-94e87cc3eea6" rel="noopener"> <strong class="kw io"> Manajemen Queue untuk Menghandle Concurrent Request dengan Kue.js </strong> </a> <strong class="kw io"> . </strong></p><p id="87fe" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq"> Nah </em> , sedikit <em class="lq"> flashback </em> , akan saya jelaskan mengapa kita perlu meng- <em class="lq"> handle </em> <em class="lq"> concurrent reques </em> t. Pada skenario artikel sebelumnya, dicontohkan kita memiliki <em class="lq"> table </em> <code class="fe lr ls lt lu b"><strong class="kw io">products</strong></code> yang memiliki atribut <code class="fe lr ls lt lu b"><strong class="kw io">stocks</strong></code> . Dimana setiap ada pembelian, stok produk yang dibeli harus berkurang sesuai dengan jumlah yang dibeli dan me-reject order jika stok barang tidak cukup.</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/13d8d6f2cf58e8ee9a93fdd976bf503f.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*PSRk2eI7KIV0C1yZdidC1A.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Struktur table products</figcaption></figure><p id="1f88" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Masalah muncul ketika ada lebih dari satu pengguna ingin melakukan pembelian pada waktu yang bersamaan. Di-ceritakan <code class="fe lr ls lt lu b"><strong class="kw io">User 1</strong></code> melakukan pembelian produk <code class="fe lr ls lt lu b"><strong class="kw io">ID 1</strong></code> sejumlah <code class="fe lr ls lt lu b"><strong class="kw io">1 pcs</strong></code> . Di waktu yang berdekatan, <code class="fe lr ls lt lu b"><strong class="kw io">User 2</strong></code> juga melakukan pembelian produk <code class="fe lr ls lt lu b"><strong class="kw io">ID 1</strong></code> sejumlah <code class="fe lr ls lt lu b"><strong class="kw io">3 pcs</strong></code> . Maka akan didapatkan <em class="lq"> timeline </em> seperti dibawah.</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/d80f96113a8254313b8b4e431b4655e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*NCsTF4Do8Y6M3cqqo2ptnA.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Ilustrasi timeline transaksi concurrent request tanpa Queue dan Row Locking Transaction</figcaption></figure><p id="9819" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq"> Hasil akhirnya? <br/> </em> Tentu saja jumlah stok produk <code class="fe lr ls lt lu b"><strong class="kw io">ID 1</strong></code> adalah <code class="fe lr ls lt lu b"><strong class="kw io">7</strong></code> , padahal seharusnya berjumlah <code class="fe lr ls lt lu b"><strong class="kw io">6</strong></code> karena dikurangi <code class="fe lr ls lt lu b"><strong class="kw io">1 + 3</strong></code> . Fenomena diatas disebut <a class="ae kt" href="https://www.geeksforgeeks.org/dbms-dirty-read-in-sql/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> Dirty Read </strong> </a> , yakni salah satu dari tiga masalah (secara umum) yang ditemui pada <em class="lq"> concurrency </em> <em class="lq"> control </em> pada database. Di antara fenomena yang lain adalah <a class="ae kt" href="https://logicalread.com/sql-server-concurrency-nonrepeatable-reads-w01/#.XtCJcp4za3I" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> Non Repeatable Read </strong> </a> <strong class="kw io"> </strong> dan <strong class="kw io"> </strong> <a class="ae kt" href="https://dotnettutorials.net/lesson/phantom-read-concurrency-problem-sql-server/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> Phantom Read </strong> </a> . <strong class="kw io"> </strong> Untuk lebih lengkapnya mengenai ketiga fenomena tersebut, dapat dilihat <a class="ae kt" href="https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/" rel="noopener ugc nofollow" target="_blank"> disini </a> .</p><p id="da63" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Sekarang bagaimana kita menyelesaikan permasalahan ini?</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h1 id="bd09" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">Menggunakan Queue</h1><p id="be90" class="pw-post-body-paragraph ku kv in kw b kx mw jo kz la mx jr lc ld my lf lg lh mz lj lk ll na ln lo lp ig bi translated">Untuk mengatasi hal ini, solusi sebelumnya kita dapat menggunakan <em class="lq"> queue </em> . Penjelasan mengenai <em class="lq"> queue </em> tidak saya jelaskan disini supaya artikel ini tidak bertele-tele. Teman-teman dapat membacanya <a class="ae kt" href="https://medium.com/easyread/manajemen-queue-antrian-untuk-menghandle-concurrent-request-dengan-kue-di-node-js-94e87cc3eea6" rel="noopener"> disini </a> . Dengan teknik <em class="lq"> queue </em> , kita sudah berhasil menyelesaikan 1 masalah. Namun, apakah cara ini efektif?</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ed59ecee7f4e6b8ad7fb811e58b8b75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*fNkPjioKc80roFnTfNta7Q.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Ilustrasi timeline transaksi dengan Queue. Process queue ditandai dengan warna biru, query database warna hitam</figcaption></figure><p id="7e73" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Masalah lain muncul saat trafik transaksi meningkat. Jika dalam satu waktu yang sama (selisih sepersekian detik) ada 5 transaksi bersamaan, maka dengan konsep <em class="lq"> queue </em> , User yang melakukan order pertama kali akan dilayani terlebih dahulu, kemudian User ke-dua, dan seterusnya urut satu persatu hingga User terakhir. Jika hanya ada 5 transaksi bersamaan, tentu tidak akan menjadi masalah. Mungkin sedikit ketidaknyamanan hanya akan dirasakan User urutan ke-empat atau ke-lima yang menunggu sedikit lebih lama daripada yang lain. Namun, bila ada 100 transaksi dalam waktu yang sama, tentu akan menjadi masalah. Pengguna terakhir akan menunggu proses <em class="lq"> queue </em> berjalan satu persatu hingga gilirannya tiba. Bahkan dengan ID produk yang berbeda sekalipun. Tentu saja menunggu 100 transaksi membutuhkan waktu yang tidak sebentar dan bisa menimbulkan <em class="lq"> scalability issue </em> .</p><blockquote class="nc"><p id="ea5e" class="nd ne in bd nf ng nh ni nj nk nl lp dk translated">Lalu, bagaimana cara yang efektif? Bagaimana cara menghindari kesalahan membaca data sekaligus mempercepat prosesnya?</p></blockquote><h1 id="a7cd" class="me mf in bd mg mh nm mj mk ml nn mn mo jt no ju mq jw np jx ms jz nq ka mu mv bi translated">Menggunakan Database Row Locking Transaction</h1><p id="4282" class="pw-post-body-paragraph ku kv in kw b kx mw jo kz la mx jr lc ld my lf lg lh mz lj lk ll na ln lo lp ig bi translated">Sebelum masuk ke dalam konsep, saya anggap teman-teman sudah mengetahui bagaimana <em class="lq"> Database Transaction </em> pada SQL bekerja. Selanjutnya, saat saya menyebut “antar transaction”, berarti 1 <em class="lq"> request </em> (order) adalah 1 <em class="lq"> transaction </em> sehingga terjadi <em class="lq"> concurrency </em> . <em class="lq"> Locking </em> berarti mencegah eksekusi <em class="lq"> query </em> <code class="fe lr ls lt lu b"><strong class="kw io">SELECT</strong></code> , <code class="fe lr ls lt lu b"><strong class="kw io">UPDATE</strong></code> , <code class="fe lr ls lt lu b"><strong class="kw io">DELETE</strong></code> .</p><p id="efee" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Kita perlu memahami bagaimana <strong class="kw io"> <em class="lq"> Isolation Levels </em> </strong> bekerja. Ada 4 <em class="lq"> isolation levels </em> pada SQL yang akan saya jelaskan dengan ringkas. Untuk pembahasan lebih detil, dapat dilihat <a class="ae kt" href="https://blog.gojekengineering.com/on-concurrency-control-in-databases-1e34c95d396e" rel="noopener ugc nofollow" target="_blank"> disini </a> atau <a class="ae kt" href="https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/" rel="noopener ugc nofollow" target="_blank"> disini </a> .</p><ol class=""><li id="419d" class="nr ns in kw b kx ky la lb ld nt lh nu ll nv lp nw nx ny nz bi translated"><strong class="kw io"> <em class="lq"> Read Uncommitted </em> </strong> : <strong class="kw io"> </strong> Tidak ada isolasi antar <em class="lq"> transaction </em> . Membaca seluruh data, baik sesudah maupun sebelum di- <em class="lq"> commit </em> antar <em class="lq"> transaction. </em> Tidak ada <em class="lq"> locking </em> apapun.</li><li id="4a86" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><strong class="kw io"> <em class="lq"> Read Commited </em> </strong> : <strong class="kw io"> </strong> Hanya membaca data yang sudah di- <em class="lq"> commit </em> sebelum <em class="lq"> query begin transaction </em> dan data yang terisolasi pada <em class="lq"> transaction </em> -nya sendiri. Tidak membaca data yang belum di- <em class="lq"> commit </em> pada <em class="lq"> transaction </em> lain dan data yang sudah di- <em class="lq"> commit </em> setelah <em class="lq"> query begin transaction </em> . <em class="lq"> Locking </em> pada 1 <em class="lq"> row record </em> .</li><li id="f2e0" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><strong class="kw io"> <em class="lq"> Repeatable Read </em> </strong> : Mirip seperti <strong class="kw io"> <em class="lq"> Read Commited </em> </strong> . Namun melakukan <em class="lq"> locking </em> pada level seluruh <em class="lq"> row records </em> yang tereferensi dalam <em class="lq"> query. </em> Mudahnya, jika kita melakukan query <code class="fe lr ls lt lu b"><strong class="kw io">SELECT *</strong></code> , maka seluruh <em class="lq"> table </em> akan di- <em class="lq"> lock </em> . Jika ada <em class="lq"> concurrency </em> pada data yang di- <em class="lq"> lock </em> , maka akan mengembalikan <em class="lq"> error </em> pada <em class="lq"> transaction </em> kedua dan seterusnya.</li><li id="0bb9" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><strong class="kw io"> <em class="lq"> Serializable </em> </strong> : Hanya memperbolehkan sebuah <em class="lq"> transaction </em> yang berjalan pada satu waktu. Jika ada <em class="lq"> concurrency </em> , maka akan mengembalikan <em class="lq"> error </em> . <em class="lq"> Locking </em> pada seluruh database.</li></ol><p id="9f90" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Daftar isolasi diatas terurut mulai dari level paling rendah hingga paling tinggi. Hubungan mitigasi fenomena <em class="lq"> concurrency </em> <em class="lq"> transaction </em> dan <em class="lq"> isolation </em> dapat dilihat pada gambar dibawah.</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi of"><img src="../Images/7a7e6e5d9c8718bf2c0edf0166047b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uTIk_Xq6EXU2wexI.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Credit: <a class="ae kt" href="https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/" rel="noopener ugc nofollow" target="_blank">Geeks for geeks</a></figcaption></figure><p id="214b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Setelah memahami mengenai <em class="lq"> isolation </em> level, diketahui bahwa masalah yang kita hadapi adalah fenomena <strong class="kw io"> <em class="lq"> Dirty Read </em> </strong> . Oleh karena itu, kita perlu set <em class="lq"> isolation level </em> pada database menjadi <strong class="kw io"> <em class="lq"> Read Committed </em> </strong> . Kita bisa <em class="lq"> set isolation </em> level secara <em class="lq"> global </em> , <em class="lq"> session </em> , atau hanya per <em class="lq"> transaction </em> . Lebih lengkapnya bisa dibaca <a class="ae kt" href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html" rel="noopener ugc nofollow" target="_blank"> disini </a> .</p><blockquote class="nc"><p id="c74b" class="nd ne in bd nf ng nh ni nj nk nl lp dk translated">Lalu, mengapa kita tidak set saja ke Repeatable Read atau Serializable sekalian? Kan semakin tinggi tingkat isolasinya, semakin baik?</p></blockquote><blockquote class="og oh oi"><p id="ace2" class="ku kv lq kw b kx oj jo kz la ok jr lc ol om lf lg on oo lj lk op oq ln lo lp ig bi translated"><strong class="kw io"> <em class="in"> Jawabannya: <br/> </em> </strong> <em class="in"> Kita tidak memerlukan isolasi yang terlalu tinggi karena </em> <strong class="kw io"> Repeatable Read </strong> <em class="in"> dan </em> <strong class="kw io"> Serializable <em class="in"> </em> </strong> <em class="in"> tidak mengizinkan adanya </em> concurrent <em class="in"> </em> transaction <em class="in"> . Terlebih, semakin tinggi tingkat isolasi, semakin lambat performanya. Oleh karena itu, sesuaikan tingkat isolasi dengan kebutuhan pada sistem yang dibangun. </em></p></blockquote></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="4ac2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">OKE! Kita sudah berhasil men-set isolation level. Apakah sudah selesai? BELUM! Kita hanya baru melakukan setup <em class="lq"> isolation levels </em> . Selanjutnya, kita perlu melakukan <em class="lq"> locking </em> pada <em class="lq"> row </em> yang digunakan untuk bertransaksi dengan cara melakukan sedikit perubahan pada <em class="lq"> query </em> kita. Kita perlu menambah keyword <code class="fe lr ls lt lu b"><strong class="kw io">FOR UPDATE</strong></code> pada akhir query <code class="fe lr ls lt lu b"><strong class="kw io">SELECT</strong></code> .</p><pre class="ke kf kg kh gt or lu os ot aw ou bi"><span id="1d92" class="ov mf in lu b gy ow ox l oy oz"><strong class="lu io">SELECT stocks FROM products WHERE id=1 FOR UPDATE</strong></span></pre><p id="9375" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Penggunaan <em class="lq"> query </em> <code class="fe lr ls lt lu b"><strong class="kw io">SELECT … FOR UPDATE</strong></code> digunakan untuk melakukan <em class="lq"> blocking </em> <em class="lq"> query </em> <code class="fe lr ls lt lu b"><strong class="kw io">SELECT</strong></code> pada <em class="lq"> transaction </em> lain jika terjadi <em class="lq"> concurrency </em> . <br/> <code class="fe lr ls lt lu b"><strong class="kw io">FOR UPDATE</strong></code> memberitahukan bahwa ada <em class="lq"> transaction </em> yang sedang berlangsung sehingga <em class="lq"> transaction </em> lain harus menunggu hingga proses <em class="lq"> locking </em> di- <em class="lq"> release </em> . <em class="lq"> Locking </em> di- <em class="lq"> release </em> saat <em class="lq"> transaction </em> selesai dan <em class="lq"> transaction </em> berikutnya dapat dilanjutkan. Berikut ilustrasi timeline menggunakan <em class="lq"> Row Locking Transaction </em> .</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/1c2d1eee7b735fc29aaf20a5bfb4297e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*XLkb-mSTYKaAEhqGiJF2Kg.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Ilustrasi timeline transaksi dengan Row Locking Transaction</figcaption></figure><p id="19f4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Bandingkan dengan timeline transaksi dengan <em class="lq"> queue </em> diatas, terlihat perbedaannya bukan?</p><p id="7fd3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Selain <code class="fe lr ls lt lu b"><strong class="kw io">FOR UPDATE</strong></code> , juga terdapat keyword yang lain seperti <code class="fe lr ls lt lu b"><strong class="kw io">FOR SHARE</strong></code> dan keyword khusus seperti <code class="fe lr ls lt lu b"><strong class="kw io">SELECT FOR NO KEY UPDATE</strong></code> dan <code class="fe lr ls lt lu b"><strong class="kw io">SELECT FOR KEY SHARE</strong></code> pada Postgres. Untuk penggunaan dan penjelasan lebih lengkapnya, dapat dibaca <a class="ae kt" href="http://shiroyasha.io/selecting-for-share-and-update-in-postgresql.html" rel="noopener ugc nofollow" target="_blank"> disini </a> .</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="9256" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Demikian pengalaman yang dapat saya bagikan. Jika teman-teman mengalami masalah yang sama, semoga sedikit pengalaman saya diatas bisa membantu teman-teman. Apabila terdapat kesalahan dalam penulisan atau teori saya, mohon dibenarkan di kolom komentar.</p><p id="fb18" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Terima kasih!</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h1 id="ba42" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">References</h1><ol class=""><li id="31ce" class="nr ns in kw b kx mw la mx ld pb lh pc ll pd lp nw nx ny nz bi translated"><a class="ae kt" href="https://medium.com/easyread/manajemen-queue-antrian-untuk-menghandle-concurrent-request-dengan-kue-di-node-js-94e87cc3eea6" rel="noopener"> Manajemen Queue untuk Menghandle Concurrent Request dengan Kue.js </a></li><li id="5b0a" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://www.geeksforgeeks.org/dbms-dirty-read-in-sql/" rel="noopener ugc nofollow" target="_blank"> Dirty read in SQL </a></li><li id="7696" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://logicalread.com/sql-server-concurrency-nonrepeatable-reads-w01/#.XtCL2J4za3J" rel="noopener ugc nofollow" target="_blank"> SQL Server Concurrency–Non-repeatable Reads </a></li><li id="e7b0" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://dotnettutorials.net/lesson/phantom-read-concurrency-problem-sql-server/" rel="noopener ugc nofollow" target="_blank"> Phantom Read Concurrency Problem </a></li><li id="64ac" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/" rel="noopener ugc nofollow" target="_blank"> Transaction Isolation Levels in DBMS </a></li><li id="15b5" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://blog.gojekengineering.com/on-concurrency-control-in-databases-1e34c95d396e" rel="noopener ugc nofollow" target="_blank"> On Concurrency Control in Databases </a></li><li id="b27e" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html" rel="noopener ugc nofollow" target="_blank"> 13.3.7 SET TRANSACTION Statement </a></li><li id="de91" class="nr ns in kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae kt" href="http://shiroyasha.io/selecting-for-share-and-update-in-postgresql.html" rel="noopener ugc nofollow" target="_blank"> Selecting for Share and Update in PostgreSQL </a></li></ol></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="pe pf l"/></div></figure></div></div>    
</body>
</html>