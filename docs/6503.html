<html>
<head>
<title>Creating Custom Directives in Akka HTTP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Akka HTTP中创建自定义指令</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/creating-custom-directives-in-akka-http-f179755ef60?source=collection_archive---------0-----------------------#2018-08-23">https://medium.com/quick-code/creating-custom-directives-in-akka-http-f179755ef60?source=collection_archive---------0-----------------------#2018-08-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4099" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">整理好你的路线。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5d72fc7ff78e5d82e6e57f5b8a29bd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL-kNNC1XPUbMU_p4GVpHQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/photos/U0tBTn8UR8I?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Fabian Grohs</a> on <a class="ae jt" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5473" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您曾经用Akka HTTP编写过比Hello World API更复杂的东西，您可能会发现路由DSL可能会很快失控。</p><p id="745d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在你的路线中有很深的嵌套层，甚至可能有一些代码重复。</p><p id="0b02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是指令的作用。但是什么是指令呢？</p><p id="b52f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jt" href="https://doc.akka.io/docs/akka-http/current/routing-dsl/directives/index.html" rel="noopener ugc nofollow" target="_blank">指令是小的、可组合的构建块</a>，允许你一点一点地创建你的路线。</p><p id="4621" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">典型的路线如下所示:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6f46" class="jz ka hh jv b fi kb kc l kd ke">pathPrefix("todos") {<br/>  pathEndOrSingleSlash {<br/>    get {<br/>      onComplete(todoRepository.all()) {<br/>        <strong class="jv hi">case </strong><em class="jc">Success</em>(todos) =&gt;<br/>          complete(todos)<br/>        <strong class="jv hi">case </strong><em class="jc">Failure</em>(exception) =&gt;<br/>          <em class="jc">println</em>(exception.getMessage)<br/>          complete(ApiError.<em class="jc">generic</em>.statusCode, ApiError.<em class="jc">generic</em>.message)<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1dbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的路由接受路径<code class="du kf kg kh jv b">/todos</code>或<code class="du kf kg kh jv b">/todos/</code>中的GET请求。当<code class="du kf kg kh jv b">todoRepository.all()</code>返回的未来完成时，它也做一些错误处理。</p><p id="a3c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，在我们的大多数(如果不是全部)路由中，我们将需要这种错误处理。就像现在这样，我们不得不到处复制粘贴。</p><p id="e22d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这只是错误处理，我们可能还想在路由中处理其他问题，比如身份验证。</p><p id="a6e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，我们如何重用这些错误处理位呢？</p><p id="34b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以创建自己的自定义指令。</p><h2 id="9c77" class="jz ka hh bd ki kj kk kl km kn ko kp kq ip kr ks kt it ku kv kw ix kx ky kz la bi translated">设置项目</h2><p id="2fb1" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">我们将使用一个<a class="ae jt" href="http://link.codemunity.io/m-custom-directives-repo" rel="noopener ugc nofollow" target="_blank">基础项目</a>，确保克隆它并检查<code class="du kf kg kh jv b">6.3-api-errors</code>分支以跟进。</p><p id="1769" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在创建自定义指令之前，让我们对项目做一个快速的概述。</p><p id="6370" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该项目使用Scala <code class="du kf kg kh jv b">2.12.6</code>和SBT <code class="du kf kg kh jv b">1.1.6</code>，您可以分别在<code class="du kf kg kh jv b">build.sbt</code>和<code class="du kf kg kh jv b">build.properties</code>文件中确认版本。</p><p id="75cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该项目是todo应用程序的API。在项目的根级别运行<code class="du kf kg kh jv b">tree src</code>会给我们带来以下结果:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7ba2" class="jz ka hh jv b fi kb kc l kd ke">src<br/>├── main<br/>│   └── scala<br/>│       ├── ApiError.scala<br/>│       ├── Main.scala<br/>│       ├── Router.scala<br/>│       ├── Server.scala<br/>│       ├── Todo.scala<br/>│       └── TodoRepository.scala<br/>└── test<br/>    └── scala<br/>        ├── TodoMocks.scala<br/>        └── TodoRouterListSpec.scala</span><span id="c984" class="jz ka hh jv b fi lg kc l kd ke">4 directories, 8 files</span></pre><p id="5bd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，这些班级的职责是:</p><ul class=""><li id="bfd9" class="lh li hh ig b ih ii il im ip lj it lk ix ll jb lm ln lo lp bi translated"><strong class="ig hi"> ApiError: </strong>模型错误。</li><li id="4abe" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><strong class="ig hi">主:</strong>申请入口点。</li><li id="737f" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><strong class="ig hi">路由器:</strong>我们的路由住的地方。</li><li id="c077" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><strong class="ig hi">服务器:</strong>取一个路由器，绑定到主机和端口。</li><li id="9fcb" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><strong class="ig hi">待办事项:</strong>应用模型。</li><li id="03de" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><strong class="ig hi"> TodoRepository: </strong>为todos处理CRUD。</li></ul><p id="d528" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du kf kg kh jv b">TodoRouter</code>实现中，你可以看到我们上面讨论过的路由，我们正在做一些手动错误处理，我们希望在其他路由中做同样的事情。</p><p id="f2db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你看一下<code class="du kf kg kh jv b">build.sbt</code>文件，你可以看到我们需要的依赖关系，<a class="ae jt" href="https://akka.io/docs/" rel="noopener ugc nofollow" target="_blank"> Akka </a> actors，streams和HTTP模块，<a class="ae jt" href="https://circe.github.io/circe/" rel="noopener ugc nofollow" target="_blank">喀尔刻</a>用于JSON，以及一个额外的库用于Akka HTTP。</p><h2 id="45cb" class="jz ka hh bd ki kj kk kl km kn ko kp kq ip kr ks kt it ku kv kw ix kx ky kz la bi translated">创建自定义指令</h2><p id="67b4" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">有多种方法可以创建自定义指令，但是我们将转换现有的指令来创建新的指令。</p><p id="ed94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在名为<code class="du kf kg kh jv b">TodoDirectives</code>的<code class="du kf kg kh jv b">src/main/scala</code>下创建一个新的<code class="du kf kg kh jv b">trait</code>，它将扩展特征<code class="du kf kg kh jv b">Directives</code>，我们还需要导入喀尔刻及其支持库，我们正在使用它们进行JSON序列化。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="1987" class="jz ka hh jv b fi kb kc l kd ke"><strong class="jv hi">import </strong>akka.http.scaladsl.server.Directives<br/><br/><strong class="jv hi">trait </strong>TodoDirectives <strong class="jv hi">extends </strong>Directives {<br/>  <strong class="jv hi">import </strong>de.heikoseeberger.akkahttpcirce.FailFastCirceSupport._<br/>  <strong class="jv hi">import </strong>io.circe.generic.auto._<br/><br/>}</span></pre><p id="f032" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建一个通用函数，它将处理未来的失败，给定一个函数，它决定当意外发生时应该返回哪个<code class="du kf kg kh jv b">ApiError</code>:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="4333" class="jz ka hh jv b fi kb kc l kd ke"><strong class="jv hi">def </strong>handle[T](f: Future[T])(e: Throwable =&gt; ApiError): Directive1[T] =<br/>  onComplete(f) flatMap {<br/>    <strong class="jv hi">case </strong><em class="jc">Success</em>(t) =&gt;<br/>      provide(t)<br/>    <strong class="jv hi">case </strong><em class="jc">Failure</em>(error) =&gt;<br/>      <strong class="jv hi">val </strong>apiError = e(error)<br/>      complete(apiError.statusCode, apiError.message)<br/>  }</span></pre><p id="f0a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这与我们路由中的错误处理逻辑非常相似，但是让我们来看看不同之处。</p><p id="1388" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们接收一个接收一个<code class="du kf kg kh jv b">Throwable</code>并返回一个<code class="du kf kg kh jv b">ApiError</code>的函数，这将允许我们在外部处理这个问题，并使指令更加通用。</p><p id="3b4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们使用<code class="du kf kg kh jv b">flatMap</code>是因为我们正在转换指令以创建新的指令，而不是应用它们。</p><p id="2c25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果未来成功，我们<code class="du kf kg kh jv b">provide</code>该值，这就是为什么我们的返回类型是一个<code class="du kf kg kh jv b">Directive1[T]</code>，我们的指令将返回或提供一个值，这是包含在未来的值。</p><p id="af1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，如果future失败了，我们从函数中得到<code class="du kf kg kh jv b">ApiError</code>,然后我们将带有相应状态代码和消息的响应发送回客户端。</p><p id="647c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您查看<code class="du kf kg kh jv b">ApiError.scala</code>文件，我们只有一个一般性错误。现在我们的存储库在很多方面都不会失败，因为我们只列出了待办事项。</p><p id="51d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建另一个指令，无论异常是什么，它总是用一般的<code class="du kf kg kh jv b">ApiError</code>进行回复:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="5d9c" class="jz ka hh jv b fi kb kc l kd ke"><strong class="jv hi">def </strong>handleWithGeneric[T](f: Future[T]): Directive1[T] =<br/>  handle[T](f)(_ =&gt; ApiError.<em class="jc">generic</em>)</span></pre><p id="52ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用它来整理我们的<code class="du kf kg kh jv b">TodoRouter</code>中的错误处理。首先，我们需要扩展我们的<code class="du kf kg kh jv b">TodoDirective</code>特征来访问我们的自定义指令。</p><p id="f170" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们可以更新路线，它将看起来像:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="c72c" class="jz ka hh jv b fi kb kc l kd ke">pathPrefix("todos") {<br/>  pathEndOrSingleSlash {<br/>    get {<br/>      handleWithGeneric(todoRepository.all()) { todos =&gt;<br/>        complete(todos)<br/>      }<br/>    }<br/>  } ~ ...</span></pre><p id="b389" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它比最初的更干净，更重要的是，我们现在可以用更少的样板文件更新其他路由。我们的<code class="du kf kg kh jv b">TodoRouter</code>最终看起来像:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="845b" class="jz ka hh jv b fi kb kc l kd ke"><strong class="jv hi">import </strong>akka.http.scaladsl.server.{Directives, Route}<br/><br/><strong class="jv hi">trait </strong>Router {<br/>  <strong class="jv hi">def </strong>route: Route<br/>}<br/><br/><strong class="jv hi">class </strong>TodoRouter(todoRepository: TodoRepository) <strong class="jv hi">extends </strong>Router <strong class="jv hi">with </strong>Directives <strong class="jv hi">with </strong>TodoDirectives {<br/>  <strong class="jv hi">import </strong>de.heikoseeberger.akkahttpcirce.FailFastCirceSupport._<br/>  <strong class="jv hi">import </strong>io.circe.generic.auto._<br/><br/>  <strong class="jv hi">override def </strong>route: Route = pathPrefix("todos") {<br/>    pathEndOrSingleSlash {<br/>      get {<br/>        handleWithGeneric(todoRepository.all()) { todos =&gt;<br/>          complete(todos)<br/>        }<br/>      }<br/>    } ~ path("done") {<br/>      get {<br/>        handleWithGeneric(todoRepository.done()) { todos =&gt;<br/>          complete(todos)<br/>        }<br/>      }<br/>    } ~ path("pending") {<br/>      get {<br/>        handleWithGeneric(todoRepository.pending()) { todos =&gt;<br/>          complete(todos)<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f738" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以通过运行<code class="du kf kg kh jv b">TodoRouterListSpec</code>测试，或者从项目根目录下的命令行运行<code class="du kf kg kh jv b">sbt test</code>,来确保(或许应该)我们的路由仍然按照预期工作。</p><p id="d321" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行<code class="du kf kg kh jv b">sbt test</code>应该会得到类似如下的输出:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="be80" class="jz ka hh jv b fi kb kc l kd ke">[info] TodoRouterListSpec:<br/>[info] A TodoRouter<br/>[info] - should return all the todos<br/>[info] - should return all the done todos<br/>[info] - should return all the pending todos<br/>[info] - should handle repository failure in the todos route<br/>[info] - should handle repository failure in the done todos route<br/>[info] - should handle repository failure in the pending todos route<br/>[info] Run completed in 1 second, 859 milliseconds.<br/>[info] Total number of tests run: 6<br/>[info] Suites: completed 1, aborted 0<br/>[info] Tests: succeeded 6, failed 0, canceled 0, ignored 0, pending 0<br/>[info] All tests passed.<br/>[success] Total time: 13 s, completed 20-Aug-2018 23:21:12</span></pre><p id="d30b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说所有的测试都通过了。厉害！👏🏽</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="eae2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢这个教程，我们有一个免费的Akka HTTP课程，你可以从头开始构建我们在这里使用的Todo项目，一步一步地解释。里面见！👇🏽</p><div class="mc md ez fb me mf"><a href="http://link.codemunity.io/cd-akka-http-quickstart-course" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">Akka HTTP快速入门</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">了解如何创建这个免费的课程与Akka HTTP的web应用程序和API！</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">link . code community . io</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jn mf"/></div></div></a></div></div></div>    
</body>
</html>