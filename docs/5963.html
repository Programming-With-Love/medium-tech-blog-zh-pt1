<html>
<head>
<title>Launching JupyterLab (Jupyter) on OCI Using Your Web Browser!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用您的网络浏览器在OCI启动JupyterLab (Jupyter )!</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/launching-jupyterlab-jupyter-on-oci-using-your-web-browser-dddbb01f4a0e?source=collection_archive---------0-----------------------#2022-09-13">https://medium.com/oracledevs/launching-jupyterlab-jupyter-on-oci-using-your-web-browser-dddbb01f4a0e?source=collection_archive---------0-----------------------#2022-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/559b0340d4466b2ecdcdf093ef8b42b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*hWUNZF7AlWHeSec374I_Cg.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx"><em class="ip">Photo by Pavel Danilyuk: </em><a class="ae iq" href="https://www.pexels.com/photo/person-using-silver-and-black-laptop-computer-5496464/" rel="noopener ugc nofollow" target="_blank"><em class="ip">https://www.pexels.com/photo/person-using-silver-and-black-laptop-computer-5496464/</em></a></figcaption></figure><p id="d5ea" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">Jupyter是一个流行的基于web的数据科学应用程序，允许用户运行许多不同语言的代码并与之交互。Jupyter使用的web界面被称为<a class="ae iq" href="https://jupyterlab.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> JupyterLab </a>，它提供了一种用户友好和直观的方式来与代码和执行的代码的计算结果进行交互。本文将指导您使用web浏览器在Oracle云基础设施(OCI)上部署Jupyter。是的，你的网络浏览器。</p><p id="7b72" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">我们将使用一些巧妙的OCI工具和资源来实现这一点(比如<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/API/Concepts/cloudshellintro.htm" rel="noopener ugc nofollow" target="_blank"> OCI云壳</a>和<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/API/Concepts/code_editor_intro.htm" rel="noopener ugc nofollow" target="_blank"> OCI代码编辑器</a>)。再加上OCI A1 (arm)实例的强大功能，您可以快速利用大量功能来快速处理数据！</p><p id="e71a" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">下面是我们在本文中要做的事情的简要概述:</p><ol class=""><li id="e3e2" class="jp jq hh it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">使用OCI代码编辑器(在您的浏览器中)创建一个容器定义(Docker和相关文件)</li><li id="2297" class="jp jq hh it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">使用OCI云外壳(在您的浏览器中)构建并上传容器映像(多架构，即arm64和amd64)</li><li id="d990" class="jp jq hh it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">在您的OCI计算实例上部署容器(通过SSH)</li></ol><p id="cf5d" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">我们构建的容器将基于Oracle Linux 8 (OL8)并支持x86_64(又名amd64)和aarch64(又名arm64)架构。</p><h1 id="c195" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">重要的事情先来</h1><p id="9164" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">您应该有一个OCI帐户和一个OCI实例(最好是一个虚拟机。Standard.A1.Flex shape)，您可以访问它(通过SSH连接到它)。访问<a class="ae iq" href="https://cloud.oracle.com/" rel="noopener ugc nofollow" target="_blank">https://cloud.oracle.com</a>注册一个免费账户(如果你还没有的话)。如果您没有配置OCI实例，请查看OCI文档<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/launchinginstance.htm#linux__linux-create" rel="noopener ugc nofollow" target="_blank">以了解配置计算映像的步骤。本文旨在使用一个A1计算实例(一个<em class="lg"> VM。Standard.A1.Flex </em> shape)运行Oracle Linux 8。</a></p><h1 id="550a" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">将它扩展到朱庇特之外</h1><p id="e4e3" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">本文特别关注Jupyter，但是由于这些都是在构建/运行容器的上下文中完成的，因此它可以很容易地适应许多其他容器化的应用程序工作负载。您可以将它用于描述其他应用程序的other文件，并遵循大致相同的步骤来构建您的映像并将其推送到OCI集装箱注册中心(OCIR)。</p><p id="f721" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">这不是构建/发布容器映像的生产级解决方案！这只是为了做一些实验。应设置适当的管道，最好使用<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/devops/using/home.htm" rel="noopener ugc nofollow" target="_blank"> OCI DevOps </a>。这超出了本文的范围，但是要知道这并不是一个终极解决方案。这不是为了生产！</p><h1 id="9eea" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">创建容器定义</h1><p id="ad13" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">登录到您的OCI租赁，并打开OCI代码编辑器。如果你以前没有这样做过，参见<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/API/Concepts/code_editor_using.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>以获得指导。</p><p id="c24b" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">代码编辑器加载后，在文件编辑器视图中，右击您的名字下方的空白区域，弹出上下文菜单，点击<em class="lg">新建文件夹</em>:</p><figure class="li lj lk ll fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/562dd7f6a1223edf918341dc2b23e6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*wXAeaxayDqTAqtIT6z5Isw.png"/></div><figcaption class="il im et er es in io bd b be z dx">Creating a new folder in OCI Code Editor</figcaption></figure><p id="2e70" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">将其命名为<em class="lg"> jupyterlab </em>并点击OK按钮:</p><figure class="li lj lk ll fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/dc95bf61d86bf270b85f251601b37bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*3qIBw5EHlVbYfxIvVmk17Q.png"/></div><figcaption class="il im et er es in io bd b be z dx">New folder name</figcaption></figure><p id="9e88" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">右键点击新建的<em class="lg"> jupyterlab </em>文件夹，点击<em class="lg">新建文件</em>:</p><figure class="li lj lk ll fd ii er es paragraph-image"><div class="er es ln"><img src="../Images/504602c9b077607e1499c4c80159a7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*L_9-UPLCGCSKdBfdwEHBJw.png"/></div><figcaption class="il im et er es in io bd b be z dx">New file in OCI Code Editor</figcaption></figure><p id="d49b" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">输入文件名，然后单击确定。您需要这样做两次，创建两个新文件:</p><ul class=""><li id="b627" class="jp jq hh it b iu iv iy iz jc jr jg js jk jt jo lo jv jw jx bi translated">jupyter _ generate _ passwd _ hash . py</li><li id="82db" class="jp jq hh it b iu jy iy jz jc ka jg kb jk kc jo lo jv jw jx bi translated">Dockerfile文件</li></ul><p id="e157" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">请注意，您可能会在代码编辑器中看到一些弹出窗口，围绕着不同的插件。就像许多流行的编辑器一样，根据你的需要调整(和/或忽略)它！</p><figure class="li lj lk ll fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/868d6c440bda21b6d843bee10f02ba9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*N-hjabdKAY8wSHFMTOairQ.png"/></div><figcaption class="il im et er es in io bd b be z dx">Sample dialog to ignore</figcaption></figure><p id="5103" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">点击<em class="lg">jupyter _ generate _ passwd _ hash . py</em>文件并将以下内容粘贴到其中:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="2257" class="lv ke hh lr b fi lw lx l ly lz">#!/usr/bin/python3</span><span id="d8b3" class="lv ke hh lr b fi ma lx l ly lz">from jupyter_server.auth import passwd<br/>import os<br/>print(passwd(os.environ['JUPYTER_PASSWORD']))</span></pre><p id="472e" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">(值得表扬的是，以上内容改编自<a class="ae iq" href="https://jupyter-server.readthedocs.io/en/stable/operators/public-server.html" rel="noopener ugc nofollow" target="_blank">https://jupyter-server . readthedocs . io/en/stable/operators/public-server . html</a>)</p><p id="11fd" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">上面的脚本用于生成一个Jupyter可以在其配置文件中使用的密码格式(您将在下面的Dockerfile文件中看到它的使用)。如果您想使用基于令牌或其他身份验证方法，请根据需要随意修改。</p><p id="7385" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">默认情况下，OCI代码编辑器会在运行时保存文件。可以在您的首选项中关闭此自动保存功能。如果您禁用了自动保存，请确保保存文件，否则享受自动保存功能。点击<em class="lg"> Dockerfile </em>文件，并将以下内容放入其中:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="7b2e" class="lv ke hh lr b fi lw lx l ly lz">FROM container-registry.oracle.com/os/oraclelinux:8-slim<br/>ARG JUPYTER_PASSWORD<br/>RUN microdnf install oraclelinux-developer-release-el8 &amp;&amp; dnf install -y python39 python39-pip python39-devel gcc libffi libffi-devel &amp;&amp; dnf clean all<br/>RUN pip3 install packaging jupyterlab matplotlib<br/>RUN mkdir /jupyter<br/>RUN mkdir /root/.jupyter<br/>COPY jupyter_generate_passwd_hash.py /root/.<br/>RUN if [ -z "$JUPYTER_PASSWORD" ]; then echo 'Jupyter password not set.'; else printf " \<br/>{\n\<br/>  \"ServerApp\": {\n\<br/>    \"password\": \"$(python3 /root/jupyter_generate_passwd_hash.py)\"\n\<br/>  }\n\<br/>}\n" &gt; /root/.jupyter/jupyter_server_config.json; fi<br/>EXPOSE 8888/tcp<br/>CMD jupyter lab --allow-root --notebook-dir /jupyter --no-browser --autoreload --ip=0.0.0.0</span></pre><p id="6a47" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">保存这两个文件(这是由OCI代码编辑器自动完成的，除非您关闭了这个特性)。</p><h1 id="3cef" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">构建和上传容器图像</h1><p id="57c9" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">在OCI代码编辑器窗口中，通过点击<em class="lg">视图</em>(屏幕左上角)启动云壳，然后<em class="lg">打开云壳</em>:</p><figure class="li lj lk ll fd ii er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/ab0b86e4649ea7cb4f9aeec11b2e3ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*CvgNFYpcWM41JaQOTMFJsw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Opening up OCI Cloud Shell from inside OCI Code Editor</figcaption></figure><p id="5d87" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">在云Shell会话中，切换到<em class="lg"> jupyterlab </em>目录并启用Python脚本(<em class="lg">jupyter _ generate _ passwd _ hash . py</em>)的执行:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="8bdc" class="lv ke hh lr b fi lw lx l ly lz">cd jupyterlab<br/>chmod +x jupyter_generate_passwd_hash.py</span></pre><p id="1b8c" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">接下来启用arm仿真(本例中使用<a class="ae iq" href="https://github.com/multiarch/qemu-user-static" rel="noopener ugc nofollow" target="_blank">QEMU-用户静态</a>):</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="06c4" class="lv ke hh lr b fi lw lx l ly lz">docker run --rm --privileged multiarch/qemu-user-static --reset -p yes</span></pre><p id="957f" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">(参见<a class="ae iq" rel="noopener" href="/@timclegg/emulating-arm-architecture-in-oci-cloud-shell-d5774d2b95cb">这篇文章</a>了解更多关于OCI云壳中arm仿真的信息)</p><p id="d32f" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">是时候构建arm64容器映像了:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="a9aa" class="lv ke hh lr b fi lw lx l ly lz">JUPYTER_PASSWORD=&lt;your clear-text password&gt; docker build --pull --build-arg JUPYTER_PASSWORD --platform arm64 -t jupyterlab:v1.0.0-ol8-arm64 .</span></pre><p id="1de3" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">注意:这可能需要几分钟时间。为了防止OCI云Shell实例超时，每隔几分钟按一下<space>键，以保持其活动状态。如果您的云Shell会话不活动，只需重新打开云Shell并运行最后一个未完成的命令(Docker通常从最后一个完成的检查点恢复)。</space></p><p id="059c" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">现在构建amd64容器映像:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="ea01" class="lv ke hh lr b fi lw lx l ly lz">JUPYTER_PASSWORD=&lt;your clear-text password&gt; docker build --pull --build-arg JUPYTER_PASSWORD --platform amd64 -t jupyterlab:v1.0.0-ol8-amd64 .</span></pre><p id="e48a" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">注意:与arm64映像构建一样，您可能会不时地输入一两个空格，以防止OCI云Shell会话超时。</p><p id="c52c" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">给刚创建的集装箱贴上标签，并上传到OCI集装箱注册处(OCIR):</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="54e0" class="lv ke hh lr b fi lw lx l ly lz">docker image tag jupyterlab:v1.0.0-ol8-arm64 &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-arm64<br/>docker image tag jupyterlab:v1.0.0-ol8-amd64 &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-amd64<br/>docker image push &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-arm64<br/>docker image push &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-amd64</span></pre><p id="d7bb" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">必须创建一个清单，将两个特定于体系结构的容器映像联系在一起:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="e24c" class="lv ke hh lr b fi lw lx l ly lz">docker manifest create &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8 \<br/>  --amend &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-arm64 \<br/>  --amend &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8-amd64</span></pre><p id="0302" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">将清单推送到OCIR，并将其从云外壳会话中移除(清理):</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="9224" class="lv ke hh lr b fi lw lx l ly lz">docker manifest push &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8</span></pre><p id="1382" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">通过使用OCI云壳，我们已经登录到OCI集装箱注册(OCIR)和其他OCI服务，使它成为与OCI互动时使用的完美资源！</p><p id="d0f2" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">此时，我们已经为amd64和arm64构建了容器映像，还有一个清单，它给出了一个较短的名称(别名),我们可以用它来部署到arm64或amd64实例！为了验证已经构建了映像，在Cloud Shell中，运行<em class="lg"> docker image ls </em>。您应该看到我们刚刚在那里生成的两个图像(&lt;region&gt;. ocir . io/&lt;namespace&gt;/jupyterlab:v 1 . 0 . 0-ol8-arm 64和&lt;region&gt;. ocir . io/&lt;namespace&gt;/jupyterlab:v 1 . 0 . 0-ol8-arm 64)。还要通过在<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registryviewingimagedetails.htm" rel="noopener ugc nofollow" target="_blank"> OCI容器注册表</a>中查找这两个映像来验证它们是否存在。</p><p id="2452" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">现在只需要运行容器映像。</p><h1 id="9854" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">运行容器</h1><p id="bd5d" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">SSH到您创建的OCI A1计算实例。假设OCI实例(一个新实例)上没有安装容器运行时，我们需要安装一个。我们可以安装Docker，但由于Podman在OL8 dnf repos中，我们将安装Podman(步骤更少):</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="4a9f" class="lv ke hh lr b fi lw lx l ly lz">sudo dnf install -y podman</span></pre><p id="f6ef" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">我们需要登录到OCIR，然后我们可以访问我们之前推送的容器:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="3660" class="lv ke hh lr b fi lw lx l ly lz">podman login &lt;region&gt;.ocir.io</span></pre><p id="3d62" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">确保使用正确的用户名格式(参见本文了解更多信息)。OCI云壳太棒了，为我们消除了所有的登录欺骗。使用您的AuthToken作为密码(但是您已经通过阅读<a class="ae iq" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registrypushingimagesusingthedockercli.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>知道了，对吗？！).</p><p id="eeb5" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">是时候运行容器了:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="8114" class="lv ke hh lr b fi lw lx l ly lz">podman run -it --rm --name jupyterlab -p 8888:8888 &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8</span></pre><p id="8aba" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">我们将看到大量文本输出到屏幕上(因为我们现在运行在交互模式下)。我们可以将它部署为一个守护进程(<em class="lg"> -d </em>而不是<em class="lg"> -it </em>)，但目前这是可行的。这个命令做了什么？我们要求podman以交互模式(<em class="lg"> -it </em>)运行容器，当它完成执行时移除容器(<em class="lg">-RM</em>)，为正在运行的容器指定一个名称<em class="lg"> jupyterlab </em>，并将容器的端口8888暴露给主机系统。</p><p id="3213" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">通常，除非需要，否则不公开资源是一种安全最佳实践(遵循最低访问级别/需要知道的原则)。正因为如此，我故意<em class="lg">而不是</em>提到向互联网暴露任何端口。我们可以使用SSH端口转发来访问Jupyter应用程序。</p><p id="0f49" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">打开另一个SSH会话，这次使用端口转发设置:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="ef4b" class="lv ke hh lr b fi lw lx l ly lz">ssh -L 8888:127.0.0.1:8888 -i &lt;priv_key&gt; opc@&lt;instance_pub_ip&gt;</span></pre><p id="cc5e" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">在SSH会话处于活动状态(端口转发设置和工作)的情况下，打开web浏览器并转到<a class="ae iq" href="http://127.0.0.1:8888/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8888 </a>查看Jupyter登录页面:</p><figure class="li lj lk ll fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/580510f8e4ea587162c6de516412c7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*MUnF1oejWPV0o5zJIvgbjA.png"/></div><figcaption class="il im et er es in io bd b be z dx">Sample Jupyter login screen</figcaption></figure><p id="4984" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">输入您在构建容器映像时使用的密码，您应该能够使用Jupyter。</p><h1 id="49da" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关掉它</h1><p id="4df9" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">现在我们正在进行两个SSH会话:一个运行容器，另一个是到OCI实例的端口转发。注销，关闭浏览器，关闭第二个SSH会话(带端口转发)，然后在第一个SSH会话上按CTRL+C(中断容器执行)并告诉它关闭(<em class="lg"> y </em>):</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="1bde" class="lv ke hh lr b fi lw lx l ly lz">[opc@a1-ol8 ~]$ podman run -it --rm --name jupyterlab -p 8888:8888 &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8<br/>[I 2022-08-15 20:30:50.693 ServerApp] jupyterlab | extension was successfully linked.<br/>[I 2022-08-15 20:30:50.702 ServerApp] nbclassic | extension was successfully linked.<br/>[I 2022-08-15 20:30:50.704 ServerApp] Writing Jupyter server cookie secret to /root/.local/share/jupyter/runtime/jupyter_cookie_secret<br/>[I 2022-08-15 20:30:50.944 ServerApp] notebook_shim | extension was successfully linked.<br/>[I 2022-08-15 20:30:50.970 ServerApp] notebook_shim | extension was successfully loaded.<br/>[I 2022-08-15 20:30:50.971 LabApp] JupyterLab extension loaded from /usr/local/lib/python3.9/site-packages/jupyterlab<br/>[I 2022-08-15 20:30:50.972 LabApp] JupyterLab application directory is /usr/local/share/jupyter/lab<br/>[I 2022-08-15 20:30:50.975 ServerApp] jupyterlab | extension was successfully loaded.<br/>[I 2022-08-15 20:30:50.979 ServerApp] nbclassic | extension was successfully loaded.<br/>[I 2022-08-15 20:30:50.980 ServerApp] Serving notebooks from local directory: /jupyter<br/>[I 2022-08-15 20:30:50.980 ServerApp] Jupyter Server 1.18.1 is running at:<br/>[I 2022-08-15 20:30:50.980 ServerApp] <a class="ae iq" href="http://abc123:8888/lab" rel="noopener ugc nofollow" target="_blank">http://abc123:8888/lab</a><br/>[I 2022-08-15 20:30:50.981 ServerApp]  or <a class="ae iq" href="http://127.0.0.1:8888/lab" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8888/lab</a><br/>[I 2022-08-15 20:30:50.981 ServerApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).<br/>[I 2022-08-15 20:30:56.511 ServerApp] 302 GET / (10.0.2.100) 0.84ms<br/>[W 2022-08-15 20:30:56.554 ServerApp] Clearing invalid/expired login cookie username-127-0-0-1-8888<br/>[W 2022-08-15 20:30:56.554 LabApp] Clearing invalid/expired login cookie username-127-0-0-1-8888<br/>[I 2022-08-15 20:30:56.555 LabApp] 302 GET /lab? (10.0.2.100) 2.25ms<br/>^C[I 2022-08-15 20:35:42.568 ServerApp] interrupted<br/>Serving notebooks from local directory: /jupyter<br/>0 active kernels<br/>Jupyter Server 1.18.1 is running at:<br/><a class="ae iq" href="http://abc123:8888/lab" rel="noopener ugc nofollow" target="_blank">http://abc123:8888/lab</a><br/> or <a class="ae iq" href="http://127.0.0.1:8888/lab" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8888/lab</a><br/>Shutdown this Jupyter server (y/[n])? y<br/>[C 2022-08-15 20:35:44.701 ServerApp] Shutdown confirmed<br/>[I 2022-08-15 20:35:44.702 ServerApp] Shutting down 3 extensions<br/>[I 2022-08-15 20:35:44.703 ServerApp] Shutting down 0 terminals<br/>[opc@a1-ol8 ~]$</span></pre><p id="0acf" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">此时，您可以关闭第一个(剩下的最后一个)SSH会话。如果愿意，您甚至可以销毁您的OCI计算实例(记住，容器映像仍然在OCIR，所以如果您真的想清理它，请从OCIR删除它们)。</p><h1 id="241e" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">其他考虑</h1><p id="d719" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">这不是一个生产就绪的Jupyter设置。它没有使用TLS(实际上应该使用),也没有持久存储设置(所以当你停止容器时，你会丢失你的工作)。这并不理想。可以通过挂载一个本地目录(在运行容器的OCI实例上)来轻松添加存储，如下所示:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="0a9f" class="lv ke hh lr b fi lw lx l ly lz">docker run -d --rm -p 8888:8888 --name jupyterlab --mount type=bind,source="$(pwd)",target=/jupyter &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8</span></pre><p id="06e5" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">上面的代码将在运行容器的OCI实例上运行。当使用Podman(而不是docker)时，可以做类似的事情。对于任何非实验性的Jupyter部署，您可能需要进行其他优化和更改。</p><h1 id="c5ce" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">但是OCI集装箱发动机(OKE)怎么样呢？</h1><p id="796f" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">是的，这可以很容易地部署到OKE。下面是一个实现这一点的方法示例:</p><pre class="li lj lk ll fd lq lr ls lt aw lu bi"><span id="535c" class="lv ke hh lr b fi lw lx l ly lz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: jupyterlab<br/>  namespace: default<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: jupyterlab<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: jupyterlab<br/>        ver: v1.0.0-ol8<br/>    spec:<br/>      containers:<br/>        - name: jupyterlab<br/>          image: &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyterlab:v1.0.0-ol8<br/>          imagePullPolicy: Always<br/>          ports:<br/>            - containerPort: 8888<br/>              protocol: TCP<br/>      imagePullSecrets:<br/>        - name: &lt;your name here&gt;<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: jupyterlab<br/>  namespace: default<br/>  labels:<br/>    app: jupyterlab<br/>  annotations:<br/>    oci.oraclecloud.com/load-balancer-type: "lb"<br/>    service.beta.kubernetes.io/oci-load-balancer-internal: "true"<br/>    service.beta.kubernetes.io/oci-load-balancer-shape: "flexible"<br/>    service.beta.kubernetes.io/oci-load-balancer-shape-flex-min: "10"<br/>    service.beta.kubernetes.io/oci-load-balancer-shape-flex-max: "10"<br/>    service.beta.kubernetes.io/oci-load-balancer-security-list-management-mode: "None"<br/>    service.beta.kubernetes.io/oci-load-balancer-subnet1: "&lt;subnet OCID here&gt;"<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>    - port: 8888<br/>      protocol: TCP<br/>      targetPort: 8888<br/>  selector:<br/>    app: jupyterlab</span></pre><p id="f507" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">将上述内容保存到一个文件中(下面命令中的<em class="lg"> &lt; name.yml &gt; </em>)用典型的<em class="lg">ku bectl Apply-f&lt;name . yml&gt;</em>应用。这部署了一个容器和一个位于其前面的OCI负载平衡器(LB)。</p><h1 id="b86e" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="75b7" class="pw-post-body-paragraph ir is hh it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo ha bi translated">除了启动和连接到容器，我们还能够使用web浏览器定义和构建多架构Jupyter容器映像(适用于arm64和amd64)。OCI代码编辑器和OCI云壳让这一切变得简单！希望您能体会到在OCI从浏览器内部编码、构建和部署是多么容易。试一试吧，因为我们在这篇文章中只是触及了皮毛。</p><p id="7f8b" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">直到下一次，保持位流…</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><p id="f57e" class="pw-post-body-paragraph ir is hh it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo ha bi translated">在我们的<a class="ae iq" href="https://bit.ly/odevrel_slack" rel="noopener ugc nofollow" target="_blank">开发者公共松弛</a>上继续讨论吧！</p></div></div>    
</body>
</html>