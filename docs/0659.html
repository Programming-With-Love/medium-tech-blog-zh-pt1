<html>
<head>
<title>Unbundling the WindowManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开窗口管理器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/unbundling-the-windowmanager-fa060adb3ce9?source=collection_archive---------0-----------------------#2021-08-19">https://medium.com/androiddevelopers/unbundling-the-windowmanager-fa060adb3ce9?source=collection_archive---------0-----------------------#2021-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f4be76c8265969a44ed7d99ecb2f5bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWg6uZkqSakAb5vW6uc-gg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Ocupop</figcaption></figure><div class=""/><p id="1011" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="jr">优化可折叠设备和大屏幕设备的应用</em></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><blockquote class="jz ka kb"><p id="a346" class="it iu jr iv b iw ix iy iz ja jb jc jd kc jf jg jh kd jj jk jl ke jn jo jp jq ha bi translated">你可以在后续文章中阅读关于stable 1.0 Jetpack WindowManager库的内容:<a class="ae kf" rel="noopener" href="/androiddevelopers/unbundling-the-stable-windowmanager-a5471ff2907"> <strong class="iv hx">解开stable WindowManager </strong> </a>。</p></blockquote></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="709e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Android中的屏幕尺寸正在快速变化，随着平板电脑和可折叠设备的日益普及，了解应用程序的窗口大小和状态对于开发响应迅速的UI至关重要。<a class="ae kf" href="https://developer.android.com/jetpack/androidx/releases/window" rel="noopener ugc nofollow" target="_blank"> Jetpack WindowManager </a>，现在处于测试阶段，是一个库和API，提供类似于Android框架<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/android/view/WindowManager" rel="noopener ugc nofollow" target="_blank">WindowManager</a></code>的功能，包括支持响应ui、检测屏幕变化的回调适配器和窗口测试API。但是Jetpack WindowManager也支持新类型的设备，比如foldables和窗口环境，比如Chrome OS。</p><p id="860e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">新的WindowManager APIs包括以下内容:</p><ul class=""><li id="800c" class="kk kl hw iv b iw ix ja jb je km ji kn jm ko jq kp kq kr ks bi translated"><code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowLayoutInfo" rel="noopener ugc nofollow" target="_blank">WindowLayoutInfo</a></code>:包含窗口的显示特征，如窗口是否包含折叠或铰链</li><li id="f931" class="kk kl hw iv b iw kt ja ku je kv ji kw jm kx jq kp kq kr ks bi translated"><code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature" rel="noopener ugc nofollow" target="_blank">FoldingFeature</a></code>:使您能够监控可折叠设备的折叠状态，以确定设备姿态</li><li id="6ae4" class="kk kl hw iv b iw kt ja ku je kv ji kw jm kx jq kp kq kr ks bi translated"><code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowMetrics" rel="noopener ugc nofollow" target="_blank">WindowMetrics</a></code>:提供当前窗口指标或整体显示指标</li></ul><p id="093a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Jetpack WindowManager从Android中分离出来，允许在API上进行更快的迭代，以快速支持快速发展的设备市场，并使应用程序开发人员能够采用库的更新，而不必等待最新的Android版本。</p><p id="6210" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在该库处于测试阶段，我们鼓励所有开发者采用Jetpack WindowManager及其设备无关的API，测试API，并引入<code class="du kg kh ki kj b">WindowMetrics</code>以允许您轻松响应窗口大小的变化。升级到测试版意味着您可以对您正在采用的API充满信心，让您能够专注于在这些设备上构建激动人心的体验。Jetpack WindowManager支持低至API 14的功能检测。</p><h1 id="00a4" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图书馆</h1><p id="ae43" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">Jetpack WindowManager是一个现代的、Kotlin优先的库，它支持新的设备外形，并提供“类似AppCompat”的功能来构建具有响应性UI的应用程序。</p><h1 id="3a0b" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">折叠状态</h1><p id="29b6" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">这个库提供的最明显的特性是对可折叠设备的支持。当设备的折叠状态发生变化时，应用程序可以接收事件，允许更新UI以支持新的用户交互。</p><figure class="mc md me mf fd hj er es paragraph-image"><div class="er es mb"><img src="../Images/400008f4a5c066d0777d26fb6f53cfc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*CKo-vecRI3HhNGeFBZDsbA.gif"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mg">Google Duo on the Samsung Galaxy Z Fold2</em></figcaption></figure><p id="151d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">看看<a class="ae kf" href="https://developer.android.com/stories/apps/google-duo?hl=en" rel="noopener ugc nofollow" target="_blank">这个Google Duo案例研究</a>，展示了如何增加对可折叠设备的支持。</p><p id="7c48" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有两种可能的折叠状态，<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature.State.Companion#FLAT()" rel="noopener ugc nofollow" target="_blank">FLAT</a></code>和<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature.State.Companion#HALF_OPENED()" rel="noopener ugc nofollow" target="_blank">HALF_OPENED</a></code>。对于<code class="du kg kh ki kj b">FLAT</code>,你可以认为表面是完全打开的，尽管在某些情况下它可能会被铰链分开。对于<code class="du kg kh ki kj b">HALF_OPENED</code>，窗口至少有两个逻辑区域。下面，我们用图片展示了每种状态的可能性:</p><figure class="mc md me mf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/c66425b22f57337fe6572abf573f169b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_GvOxYSMXcZwkTIg-SeLg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fold state: FLAT and HALF-OPENED</figcaption></figure><p id="5c95" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当应用程序处于活动状态时，通过从Kotlin流中收集事件，应用程序可以接收有关折叠状态变化的信息。</p><p id="17c8" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要开始和停止事件收集，我们可以使用生命周期范围，如<code class="du kg kh ki kj b"><a class="ae kf" rel="noopener" href="/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333">repeatOnLifeCycle</a></code> <a class="ae kf" rel="noopener" href="/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333"> API设计故事</a>博客文章和以下代码示例中所述:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="5d48" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后，应用程序可以使用接收到的<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowLayoutInfo" rel="noopener ugc nofollow" target="_blank">WindowLayoutInfo</a></code>对象中的可用信息来更新其布局，同时应用程序对用户可见。</p><p id="04ec" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature" rel="noopener ugc nofollow" target="_blank">FoldingFeature</a></code>包括像铰链<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature#orientation()" rel="noopener ugc nofollow" target="_blank">orientation</a></code>和折叠功能是否创建两个逻辑屏幕区域(<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature#isSeparating()" rel="noopener ugc nofollow" target="_blank">isSeparating</a></code>属性)这样的信息。我们可以使用这些值来检查设备是否处于桌面模式(半开，铰链水平):</p><figure class="mc md me mf fd hj er es paragraph-image"><div class="er es mk"><img src="../Images/cb87c3b52662a70d98c0270ecf502edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*Sc72nvipM7-Naz8tHfbxjA.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Device in TableTop mode</figcaption></figure><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2dd3" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">或者在书本模式下(半开，铰链垂直):</p><figure class="mc md me mf fd hj er es paragraph-image"><div class="er es ml"><img src="../Images/17dcca9252482d96d1ad8b2ef723c4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*iuNXQ9emhuORR_AbOFUHsg.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Device in Book mode</figcaption></figure><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="dd2d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以在<a class="ae kf" rel="noopener" href="/androiddevelopers/tabletop-mode-on-foldable-devices-d091b3c500b1">可折叠设备的桌面模式</a>文章中看到一个如何为媒体播放器应用程序做这件事的例子。</p><blockquote class="jz ka kb"><p id="ac01" class="it iu jr iv b iw ix iy iz ja jb jc jd kc jf jg jh kd jj jk jl ke jn jo jp jq ha bi translated"><strong class="iv hx">注意:</strong>在main/UI线程上收集这些事件很重要，这样可以避免UI和这些事件处理之间的同步问题。</p></blockquote><h1 id="751e" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">支持响应性用户界面</h1><p id="260b" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">由于Android的屏幕尺寸经常变化，开始设计完全自适应和响应的用户界面是很重要的。WindowManager库中包含的另一个特性是检索当前和最大窗口度量信息的能力。这类似于API 30 中包含的<a class="ae kf" href="https://developer.android.com/reference/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank">框架</a> <code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank">WindowMetrics</a></code> <a class="ae kf" href="https://developer.android.com/reference/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank"> API提供的信息，但它向下兼容API 14。</a></p><p id="0da2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Jetpack WindowManager提供了两种检索<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowMetrics" rel="noopener ugc nofollow" target="_blank">WindowMetrics</a></code>信息的方式，一种是流事件流，另一种是通过<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowMetricsCalculator" rel="noopener ugc nofollow" target="_blank">WindowMetricsCalculator</a></code>类同步进行。</p><p id="8db4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在异步API难以处理的视图中编写代码时使用<code class="du kg kh ki kj b">WindowMetricsCalculator</code>(比如<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/android/view/View#onMeasure(int,%20int)" rel="noopener ugc nofollow" target="_blank">onMeasure</a></code>):</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="773e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一个用例可以是在测试中(参见下面的测试)。</p><p id="fdbe" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于应用程序UI的高级处理，使用<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/layout/WindowInfoRepository#currentWindowMetrics()" rel="noopener ugc nofollow" target="_blank">WindowInfoRepository#currentWindowMetrics</a></code>在窗口大小发生变化时得到库的通知，而不管这种变化是否触发了配置变化。</p><p id="c68c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是如何根据可用区域的大小来切换布局的示例:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="42fa" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">回拨适配器</h1><p id="0d61" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">要在Java编程语言中使用这个库或使用回调接口，请在您的应用程序中包含<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/jetpack/androidx/releases/window#declaring_dependencies" rel="noopener ugc nofollow" target="_blank">androidx.window:window-java</a></code>依赖项。该构件提供了<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/java/layout/WindowInfoRepositoryCallbackAdapter" rel="noopener ugc nofollow" target="_blank">WindowInfoRepositoryCallbackAdapter</a></code>，您可以使用它来注册(和取消注册)一个回调，以接收关于设备状态和窗口度量信息的更新。</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="c511" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试</h1><p id="ec7b" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">我们从开发人员那里听说，更健壮的测试API对于保持长期支持至关重要。让我们来谈谈如何在普通设备上测试可折叠姿势。</p><p id="cd82" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">到目前为止，我们已经看到，当设备姿态发生变化时，Jetpack WindowManager库会通知您的应用程序，以便您可以修改应用程序的布局。</p><p id="f5d2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">该库在<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/jetpack/androidx/releases/window#declaring_dependencies" rel="noopener ugc nofollow" target="_blank">androidx.window:window-testing</a></code>、<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/testing/layout/WindowLayoutInfoPublisherRule" rel="noopener ugc nofollow" target="_blank">WindowLayoutInfoPublisherRule</a></code>中提供了，这使您能够在测试文件夹功能的支持下发布<code class="du kg kh ki kj b">WindowInfoLayout</code>:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="bb6b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们可以用它来创建一个假的<code class="du kg kh ki kj b"><a class="ae kf" href="https://developer.android.com/reference/androidx/window/testing/layout/DisplayFeatureTesting" rel="noopener ugc nofollow" target="_blank">FoldingFeature</a></code>用于我们的测试:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="13a2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后使用<code class="du kg kh ki kj b">WindowLayoutInfoPublisherRule</code>来发布它:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="39e1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最后一步是使用可用的<a class="ae kf" href="https://d.android.com/training/testing/espresso/cheat-sheet" rel="noopener ugc nofollow" target="_blank"> Espresso matchers </a>，检查我们正在测试的活动布局是否如预期的那样运行。</p><p id="9f3b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是一个测试发布FoldingFeature的例子，在屏幕中央有一个<code class="du kg kh ki kj b">HALF_OPENED</code>垂直铰链:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="2562" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">查看它的运行情况:代码示例</h1><p id="b15f" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">GitHub上最新的<a class="ae kf" href="https://github.com/android/user-interface-samples/tree/main/WindowManager" rel="noopener ugc nofollow" target="_blank">示例</a>展示了如何使用Jetpack WindowManager库来检索显示姿态信息，从<code class="du kg kh ki kj b">WindowLayoutInfo</code>流收集信息或通过<code class="du kg kh ki kj b">WindowInfoRepositoryCallbackAdapter</code>注册回调。</p><p id="e8cd" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">该示例还包括一些可以在任何设备或模拟器上运行的测试。</p><h1 id="af79" class="ky kz hw bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在你的应用中采用WindowManager</h1><p id="bba1" class="pw-post-body-paragraph it iu hw iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">可折叠和双屏设备不再是实验性或未来性的——大显示区域和额外的姿势已经证明了用户价值，现在有更多的设备可供用户使用。可折叠和双屏设备代表了智能手机的自然发展。对于Android开发者来说，它们提供了进入一个正在增长的高端市场的机会，这也要归功于设备制造商重新燃起的兴趣。</p><p id="5165" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们去年推出了Jetpack WindowManager alpha01。从那时起，这个库已经有了稳定的发展，并针对早期的反馈做了一些很大的改进。该库现在已经接受了Android的Kotlin-first哲学，从回调驱动模型过渡到协程和流程。WindowManager现在处于测试阶段，API是稳定的，我们强烈建议采用。</p><p id="047f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">更新还不止于此。我们计划向该库添加更多功能，并在一个针对系统UI的非捆绑AppCompat中对其进行改进，使开发人员能够在所有Android设备上轻松实现现代、响应迅速的UI。</p><p id="abb7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><a class="ae kf" href="https://issuetracker.google.com/issues/new?component=840395&amp;template=1412556" rel="noopener ugc nofollow" target="_blank">保持反馈畅通</a>！</p><p id="035a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您想查看更多关于优化可折叠设备和其他大屏幕设备的资源，请访问<a class="ae kf" href="https://developer.android.com/large-screens" rel="noopener ugc nofollow" target="_blank">本页</a>。</p></div></div>    
</body>
</html>