<html>
<head>
<title>Kotlin for Competitive Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">竞争编程的科特林</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-for-competitive-programming-803ef03e8683?source=collection_archive---------0-----------------------#2020-06-21">https://blog.kotlin-academy.com/kotlin-for-competitive-programming-803ef03e8683?source=collection_archive---------0-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6086" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">选择的新语言</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b1083f1c6cdd9de5793255e5068822b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QeCKCxXrxUNsj8hzEvq1Ng.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Speed and Elegance — Photo by <a class="ae ks" href="https://unsplash.com/@sarahbedu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sarah Bedu</a> on <a class="ae ks" href="/s/photos/racing-animals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c149" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">几个月前，我开始使用Kotlin进行竞争性编程。我终于能够享受解决问题的过程，而不会迷失在语法或设置中。我写这篇文章是希望能激励你也尝试Kotlin进行竞争性编程。</p><p id="f1fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你已经有了灵感，你应该看看这篇文章:</p><div class="lp lq gp gr lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/setting-up-your-workflow-for-competitive-programming-in-kotlin-b1e84e6a6670"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">在Kotlin中设置竞争性编程的工作流程</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">几分钟内开始！</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div><p id="c116" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JetBrains的人确实有一个讨论Kotlin的竞争性编程的页面。但是我感觉那个页面的内容有点超前，特别是对于刚入门的人来说。希望这篇文章可以作为一个温和的介绍。</p><p id="0f1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将这篇文章分成了两个部分:</p><ol class=""><li id="d493" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">首先，我将分享一些我用Kotlin编写的示例解决方案。我选择了这些例子来介绍一些我认为非常有用的不同的Kotlin特性。</li><li id="5fbf" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">在第二篇文章中，我将详细讨论Kotlin如何与竞争性编程中使用的其他流行语言进行比较。</li></ol><h1 id="297b" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">例子</h1><p id="24fb" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">让我们开始吧！</p><h2 id="238e" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">例子1:糖果数量最多的孩子</h2><p id="646f" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">如果您需要参考原始问题陈述，以下是链接:</p><div class="lp lq gp gr lr ls"><a href="https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">拥有最多糖果的孩子- LeetCode</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">给定糖果数组和整数extraCandies，其中candies[i]表示孩子得到的糖果数量…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">leetcode.com</p></div></div><div class="mb l"><div class="oe l md me mf mb mg km ls"/></div></div></a></div><p id="95e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个测试用例的输入是:</p><ol class=""><li id="1157" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">表示每个孩子拥有的糖果数量的整数数组</li><li id="8dc9" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">表示额外糖果数量的整数。</li></ol><p id="3ed1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">问题归结为:对于每个孩子，你需要确定给孩子所有额外的糖果是否会让他/她在小组中拥有最多的糖果。我们需要输出一个布尔数组来表达这一点。函数签名是:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="f3ac" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>kidsWithCandies(candies: <strong class="og io">IntArray</strong>, extraCandies: <strong class="og io">Int</strong>): <strong class="og io">BooleanArray</strong></span></pre><p id="0c89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在科特林，我们可以用两行来解决这个问题:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="0a67" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>kidsWithCandies(candies: <strong class="og io">IntArray</strong>, extraCandies: <strong class="og io">Int</strong>): <strong class="og io">BooleanArray</strong> {</span><span id="9b61" class="ns mw in og b gy oo ol l om on">    <strong class="og io">val </strong>maxCandies = candies.<em class="op">max</em>()<br/><br/>    <strong class="og io">return </strong>BooleanArray(<br/>        candies.<strong class="og io">size</strong>,<br/>        <strong class="og io">{ index</strong> <strong class="og io">-&gt; </strong>candies[<strong class="og io">index</strong>] + extraCandies &gt;= maxCandies!! <strong class="og io">}<br/>    </strong>)</span><span id="e090" class="ns mw in og b gy oo ol l om on">}</span></pre><p id="97cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一行是所有奇迹发生的地方:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="4313" class="ns mw in og b gy ok ol l om on"><strong class="og io">return </strong>BooleanArray(<br/>    candies.size,<br/>    { <strong class="og io">index</strong> -&gt; candies[<strong class="og io">index</strong>] + extraCandies &gt;= maxCandies!! }<br/>)</span></pre><p id="db9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在其中，我们构造并返回一个<code class="fe oq or os og b">BooleanArray</code>。<code class="fe oq or os og b">BooleanArray</code>构造函数的签名如下:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="0388" class="ns mw in og b gy ok ol l om on">BooleanArray(size: <strong class="og io">Int</strong>, init: <strong class="og io">(Int) -&gt; Boolean</strong>)</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2fcdf2fbc10d858b7175bf7bc91ab8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*LOFCht_QpEXKcvyBTcVF1g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boolean Array constructor signature</figcaption></figure><p id="e670" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">构造函数的第一个参数是数组的大小——在本例中是<code class="fe oq or os og b">candies.<strong class="kv io">size</strong></code>。第二个参数是一个<code class="fe oq or os og b">init</code>函数，类型为<code class="fe oq or os og b">(Int) -&gt; Boolean</code> —它接受一个<code class="fe oq or os og b">Int</code>(索引)，并输出一个<code class="fe oq or os og b">Boolean</code>(在该索引处填充的值)。我们可以在第二个参数中封装任何我们想要的初始化逻辑。</p><p id="c757" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意这是多么的方便…Kotlin给了我们一种方法，只用一行代码就可以优雅地构造<em class="op">和</em>初始化任何数组！</p><p id="89b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了进一步简化这一点，我们可以利用Kotlin的两个语法规则:</p><blockquote class="ou ov ow"><p id="e355" class="kt ku op kv b kw kx jo ky kz la jr lb ox ld le lf oy lh li lj oz ll lm ln lo ig bi translated"><a class="ae ks" href="https://kotlinlang.org/docs/reference/lambdas.html#passing-a-lambda-to-the-last-parameter" rel="noopener ugc nofollow" target="_blank">传递尾随lambdas</a>—“…如果函数的最后一个参数是函数，那么作为相应参数传递的lambda表达式可以放在括号外。”</p></blockquote><p id="078c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我们可以简化成这样:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="a656" class="ns mw in og b gy ok ol l om on"><strong class="og io">return </strong>BooleanArray(candies.size) { <strong class="og io">index</strong> -&gt;<br/>    candies[<strong class="og io">index</strong>] + extraCandies &gt;= maxCandies!!<br/>}</span></pre><blockquote class="ou ov ow"><p id="ea17" class="kt ku op kv b kw kx jo ky kz la jr lb ox ld le lf oy lh li lj oz ll lm ln lo ig bi translated"><a class="ae ks" href="https://kotlinlang.org/docs/reference/lambdas.html#it-implicit-name-of-a-single-parameter" rel="noopener ugc nofollow" target="_blank">单个参数的隐式名称</a>——“lambda表达式只有一个参数是很常见的……该参数将以名称<code class="fe oq or os og b">it</code>隐式声明。”</p></blockquote><p id="0406" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们可以进一步简化为:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="2d59" class="ns mw in og b gy ok ol l om on"><strong class="og io">return </strong>BooleanArray(candies.size) {<br/>    candies[<strong class="og io">it</strong>] + extraCandies &gt;= maxCandies!!<br/>}</span></pre><p id="826b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是最终代码。花几秒钟去理解和消化语法。</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="7a13" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>kidsWithCandies(<strong class="og io">candies</strong>: IntArray, <strong class="og io">extraCandies</strong>: Int): <strong class="og io">BooleanArray</strong> {</span><span id="f92b" class="ns mw in og b gy oo ol l om on">    <strong class="og io">val </strong>maxCandies = candies.<em class="op">max</em>()<br/><br/>    <strong class="og io">return </strong>BooleanArray(candies.<strong class="og io">size</strong>) <strong class="og io">{<br/>        </strong>candies[<strong class="og io">it</strong>] + extraCandies &gt;= maxCandies!!<br/>    <strong class="og io">}</strong></span><span id="8ce4" class="ns mw in og b gy oo ol l om on">}</span></pre><h2 id="4acb" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">示例2:厨师和价格控制</h2><p id="60f2" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">以下是问题的链接:</p><div class="lp lq gp gr lr ls"><a href="https://www.codechef.com/problems/PRICECON" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">竞赛页面| CodeChef</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">CodeChef -一个为有抱负的程序员提供的平台CodeChef是一个帮助程序员在…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">www.codechef.com</p></div></div></div></a></div><p id="19ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输入是:</p><ol class=""><li id="4691" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">表示一组商品的原始销售价格的整数数组</li><li id="b767" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">一个整数，表示必须应用于所有商品的新价格上限。</li></ol><p id="3279" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要计算由于引入价格上限而造成的总损失。问题归结为:对于每件商品，如果上限低于原价，我们需要计算原价和价格上限之间的差额，然后输出这些值的总和:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="0ee8" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>solve(<strong class="og io">prices</strong>: IntArray, <strong class="og io">priceCeiling</strong>: Int): Int</span></pre><p id="896d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一行解决方案:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="fed0" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>solve(<strong class="og io">prices</strong>: IntArray, <strong class="og io">priceCeiling</strong>: Int): Int {</span><span id="9a5d" class="ns mw in og b gy oo ol l om on">    <strong class="og io">return </strong>prices.<em class="op">fold</em>(0) <strong class="og io">{ agg</strong>, <strong class="og io">e -&gt;<br/>        agg </strong>+ (<strong class="og io">e</strong>- minOf(priceCeiling, <strong class="og io">e</strong>))<br/>    <strong class="og io">}</strong></span><span id="5ae5" class="ns mw in og b gy oo ol l om on">}</span></pre><p id="ae23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe oq or os og b">fold</code>函数允许你聚集数组中的值；<code class="fe oq or os og b">fold</code>遍历数组，并将提供的函数应用于聚合值<code class="fe oq or os og b">agg</code>和下一个元素<code class="fe oq or os og b">e</code>。<code class="fe oq or os og b">fold</code>的第一个参数是用来初始化聚合值的——在本例中是<code class="fe oq or os og b">0</code>。</p><p id="df3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，这用一行代码优雅地解决了问题。从聚合值<code class="fe oq or os og b">0</code>开始，然后不断将<code class="fe oq or os og b">e-minOf(priceCeiling,e)</code>加到聚合值上。如果价格上限没有导致商品价格下降，该表达式将为<code class="fe oq or os og b">0</code>，否则，它将等于该商品发生的损失。</p><h2 id="174d" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">示例3:链表的中间</h2><p id="d0c8" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">空值在许多数据结构中扮演着重要的角色。例如，在二叉树中，当一个节点没有左/右子节点时，<code class="fe oq or os og b">node</code>的<code class="fe oq or os og b">left</code> / <code class="fe oq or os og b">right</code>属性的值被设置为null。类似地，当下一个节点为空值时，您知道已经到达了链表的最后一个节点。</p><p id="67c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时人们会认为科特林中没有空值。但这不是真的。Kotlin只要求你明确程序中的空值。<a class="ae ks" href="https://kotlinlang.org/docs/reference/null-safety.html" rel="noopener ugc nofollow" target="_blank">kot Lin关于零安全的官方文件</a>指出:</p><blockquote class="ou ov ow"><p id="adc5" class="kt ku op kv b kw kx jo ky kz la jr lb ox ld le lf oy lh li lj oz ll lm ln lo ig bi translated">Kotlin的类型系统旨在消除代码中空引用的危险</p></blockquote><p id="cebe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每当您将变量赋给可能为空的表达式时，变量的类型必须是<em class="op">可空的</em>:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="3601" class="ns mw in og b gy ok ol l om on">&gt;&gt;&gt; <strong class="og io">val</strong> x = 3</span><span id="8e23" class="ns mw in og b gy oo ol l om on">&gt;&gt;&gt; <strong class="og io">var </strong>y: <strong class="og io">Int </strong>= <strong class="og io">if </strong>(x&gt;2) x <strong class="og io">else</strong> null<strong class="og io"><br/></strong>error: null can not be a value of a non-null type Int</span><span id="ccc9" class="ns mw in og b gy oo ol l om on">&gt;&gt;&gt; <strong class="og io">var </strong>y: <strong class="og io">Int? </strong>= <strong class="og io">if </strong>(x&gt;2) x <strong class="og io">else</strong> null</span><span id="bdd5" class="ns mw in og b gy oo ol l om on">&gt;&gt;&gt; <strong class="og io">print</strong>(y)<br/>3</span></pre><p id="19aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，<code class="fe oq or os og b">Int?</code>是<code class="fe oq or os og b">Int</code>的可空版本。</p><p id="0192" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有一些方法可以从程序中删除空值。其中一种方式是使用由<code class="fe oq or os og b">?:</code>表示的<a class="ae ks" href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator" rel="noopener ugc nofollow" target="_blank"> elvis操作器</a>:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="6f88" class="ns mw in og b gy ok ol l om on">&gt;&gt;&gt; <strong class="og io">var </strong>z: <strong class="og io">Int</strong> = y <strong class="og io">?:</strong> 0</span><span id="a684" class="ns mw in og b gy oo ol l om on">&gt;&gt;&gt; <strong class="og io">print</strong>(z)<br/>3</span></pre><p id="aa58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，尽管<code class="fe oq or os og b">y</code>是可空类型<code class="fe oq or os og b">Int?</code>，但是<code class="fe oq or os og b">z</code>是类型<code class="fe oq or os og b">Int</code>。正如文件中所解释的:</p><blockquote class="ou ov ow"><p id="b8fb" class="kt ku op kv b kw kx jo ky kz la jr lb ox ld le lf oy lh li lj oz ll lm ln lo ig bi translated"><a class="ae ks" href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator" rel="noopener ugc nofollow" target="_blank">猫王运算符</a>——“如果<code class="fe oq or os og b">?:</code>左边的表达式不为空，猫王运算符返回，否则返回右边的表达式。请注意，只有当左侧为空时，才会计算右侧的表达式。</p></blockquote><p id="e49b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实上，<code class="fe oq or os og b">?:</code>的右边不一定是表达式，你也不一定要给变量赋值:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="74e2" class="ns mw in og b gy ok ol l om on">&gt;&gt;&gt; y <strong class="og io">?:</strong> print("y is null")<br/>3</span><span id="33dd" class="ns mw in og b gy oo ol l om on">&gt;&gt;&gt; y = null<br/>&gt;&gt;&gt; y <strong class="og io">?:</strong> print("y is null")<br/>y is null</span></pre><p id="4838" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个基本的理解，让我们来看看最后一个示例问题:</p><div class="lp lq gp gr lr ls"><a href="https://leetcode.com/problems/middle-of-the-linked-list/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">链表的中间- LeetCode</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">leetcode.com</p></div></div><div class="mb l"><div class="pa l md me mf mb mg km ls"/></div></div></a></div><p id="e72d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要返回给定头部的单链表的中间节点。我们还获得了这个起始代码:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="33a0" class="ns mw in og b gy ok ol l om on"><strong class="og io">class </strong>ListNode(<strong class="og io">var value</strong>: Int) {<br/>    <strong class="og io">var next</strong>: ListNode? = <strong class="og io">null<br/></strong>}</span></pre><p id="2bb0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe oq or os og b">next</code>属性具有可为空的类型。这是因为对于最后一个节点，<code class="fe oq or os og b">next</code>必须为空。</p><p id="2bf6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将使用双指针方法来解决这个问题。一个指针遍历列表的速度是另一个指针的两倍。当较快的指针到达列表末尾时，较慢的指针将位于中间。</p><p id="b4d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将在第一个节点初始化慢速指针，在第二个节点初始化快速指针:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="484b" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>middleNode(<strong class="og io">head</strong>: ListNode?): ListNode? {</span><span id="b789" class="ns mw in og b gy oo ol l om on">    <strong class="og io">var </strong>slow = head<br/>    <strong class="og io">var </strong>fast = head?.<strong class="og io">next </strong>?: <strong class="og io">return </strong>head</span><span id="3ab1" class="ns mw in og b gy oo ol l om on">    <em class="op">// </em><strong class="og io"><em class="op">TODO...</em></strong></span><span id="27f1" class="ns mw in og b gy oo ol l om on">}</span></pre><p id="071d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们必须用<code class="fe oq or os og b">head?.next</code>而不是仅仅用<code class="fe oq or os og b">head.next</code>进行“安全调用”，因为<code class="fe oq or os og b">head</code>可能为空(它属于可空类型)；但是不要太担心这个——智能感知会告诉您自动进行更改。需要注意的重要事情是我们如何使用elvis操作符。万一在<code class="fe oq or os og b">head</code>之后没有节点，我们知道我们有一个大小为1的链表，我们可以只返回<code class="fe oq or os og b">head</code>。</p><p id="bebc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于所有其他非拐角情况，我们有<code class="fe oq or os og b">while</code>循环:</p><pre class="kd ke kf kg gt of og oh oi aw oj bi"><span id="b99b" class="ns mw in og b gy ok ol l om on"><strong class="og io">fun </strong>middleNode(<strong class="og io">head</strong>: ListNode?): ListNode? {</span><span id="b174" class="ns mw in og b gy oo ol l om on">    <strong class="og io">var </strong>slow = head<br/>    <strong class="og io">var </strong>fast = head?.next<strong class="og io"> ?:</strong> <strong class="og io">return </strong>head</span><span id="fe5a" class="ns mw in og b gy oo ol l om on">    <strong class="og io">while</strong>(<strong class="og io">true</strong>) {<br/>        slow = slow?.next<strong class="og io"><br/>        </strong>fast = fast.next?.next<strong class="og io"> ?:</strong> <strong class="og io">return </strong>slow<br/>    }</span><span id="eb05" class="ns mw in og b gy oo ol l om on">}</span></pre><p id="37c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们每次都将快速指针向前移动两个节点，将慢速指针向前移动一个节点。如果快速指针变为空，这意味着它已经到达了链表的末尾，我们可以返回中间的节点。</p><p id="94e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">花一分钟去理解和消化上面的语法。</p><h1 id="c7fb" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">科特林与其他语言</h1><p id="aaba" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">现在我们已经看到了一些例子，让我们更深入地讨论一下Kotlin与竞争编程中常用的其他语言相比如何。</p><h2 id="80f4" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">科特林vs Java</h2><p id="15b4" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">Kotlin本质上是Java的改进。它像Java一样在JVM上运行，但是它扩展了许多Java类——尤其是Java集合库——并且它消除了对大量样板代码的需求。</p><p id="9341" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以Java <code class="fe oq or os og b">ArrayList&lt;Integer&gt;</code>为例。每次你想给<code class="fe oq or os og b">ArrayList</code>添加一个int，你首先要把它转换成一个<code class="fe oq or os og b">Integer</code>对象。当你在比赛中时，这尤其令人沮丧。</p><p id="2ad1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一方面，Kotlin有一个非常容易使用的阵列系统。每个原始类型数组都有一个内置的类，还有一个参数化的<code class="fe oq or os og b">Array&lt;T&gt;</code>类型，它们都带有<a class="ae ks" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/" rel="noopener ugc nofollow" target="_blank">完全加载的</a>便利和扩展功能，正如我们在示例中看到的。</p><p id="b401" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更详尽的对比，可以参考官网<a class="ae ks" href="https://kotlinlang.org/docs/reference/comparison-to-java.html" rel="noopener ugc nofollow" target="_blank">本页</a>。</p><h2 id="b497" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">科特林vs Python</h2><p id="b56f" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">我们都知道使用Python进行竞争性编程的根本问题——它非常慢。因为它没有被编译成可执行文件，所以它是逐行运行的(这就是人们所说的Python是一种“解释型”语言的意思)。这导致了非常大的性能开销。Kotlin代码是在JVM中编译和运行的，因此速度要快得多。</p><p id="622f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们不用Python，因为它速度快；我们用它是因为它容易写。“基本都是英语！”我们说。嗯，我希望这些例子能让你相信Kotlin语法非常直观，也很像英语。更重要的是，Kotlin设法做到了这一点，同时又是类型安全的(不像Python，在Python中，您经常会绞尽脑汁想知道您编写的函数是否接受列表或元组作为参数)。</p><h2 id="8e58" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">Kotlin vs C++</h2><p id="13a2" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">我知道C++近年来发展了很多，语法变得更有表现力。尽管如此，我认为Kotlin至少比C++有两个明显的优势:</p><ol class=""><li id="294f" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">Kotlin的函数语法非常优雅。从我在网上找到的东西来看，它远远优于C++。</li><li id="b197" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">科特林有一个REPL(像Python控制台)！您可以使用它来快速测试代码片段。在C++中，如果不创建可执行文件或启动调试器，这是不可能的。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/98f0f88e4ee8384631575d5a4ce9d2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*N0p7FOZd17chLUN1VHO_lw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The Kotlin REPL in action</figcaption></figure><h2 id="5833" class="ns mw in bd mx nt nu dn nb nv nw dp nf lc nx ny nh lg nz oa nj lk ob oc nl od bi translated">Kotlin与C++:性能</h2><p id="238f" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">可以肯定地说，如果你正在寻找原始速度，现在没有比C++更好的选择了。一旦你超越了最初的学习曲线，并在竞赛中争夺前几名，你将<em class="op">有</em>切换到C++。</p><p id="215e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">C++如此之快的主要原因是它可以编译成系统“本地”的可执行文件。因此，如果你的在线法官在Linux服务器上运行你的C++代码，这些代码会被编译，然后由Linux自己运行(这就是为什么Windows和Linux有不同的C++编译器——分别是MSVC和g++)。另一方面，Kotlin将代码编译到JVM级别(运行在操作系统之上)。JVM引入了抽象，使得相同的Java代码可以在任何操作系统上运行；不幸的是，这些抽象导致了性能开销。</p><p id="8509" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但这在未来可能会改变。有<em class="op">有</em>一组<a class="ae ks" href="https://kotlinlang.org/docs/reference/native-overview.html#why-kotlinnative" rel="noopener ugc nofollow" target="_blank">‘Kotlin/Native’编译器</a>，它们将kot Lin代码编译成操作系统可执行文件。目前，针对Windows、Mac <em class="op">和</em> Linux的Kotlin/Native编译器已经存在！不幸的是，几乎所有在线法官都在JVM中运行Kotlin代码。如果这种情况在未来发生变化，Kotlin将成为真正可以与C++相媲美的竞争性编程工具……甚至对于专业人士来说也是如此！</p><h1 id="6aa0" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">结论</h1><p id="308b" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">我希望这篇文章已经让你开始在Kotlin中进行竞争性编程。要立即开始，我建议您通读这篇文章:</p><div class="lp lq gp gr lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/setting-up-your-workflow-for-competitive-programming-in-kotlin-b1e84e6a6670"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">在Kotlin中设置竞争性编程的工作流程</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">几分钟内开始！</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div></div></div>    
</body>
</html>