<html>
<head>
<title>PinalyticsDB: A Time Series Database on top of Hbase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PinalyticsDB:基于Hbase的时间序列数据库</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/pinalyticsdb-a-time-series-database-on-top-of-hbase-946f236bb29a?source=collection_archive---------1-----------------------#2019-09-26">https://medium.com/pinterest-engineering/pinalyticsdb-a-time-series-database-on-top-of-hbase-946f236bb29a?source=collection_archive---------1-----------------------#2019-09-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="1227" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">软件工程师，数据工程</p><p id="684d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PinalyticsDB是Pinterest专有的时间序列数据库。在Pinterest，我们依靠PinalyticsDB作为后端来存储和可视化成千上万的时间序列报告，例如下面的示例案例，按国家进行了划分。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/b2472c38c7c8247509dfc18823908001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Cr_5905BjidhMk2"/></div></div></figure><p id="ef50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PinalyticsDB是几年前在Hbase之上构建的。它利用实时map-reduce架构，通过Hbase协处理器进行聚合。然而，随着Pinterest的发展和报告数量的增长，以及报告中数据的使用和数量，它暴露了一些可扩展性挑战。</p><p id="1caa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在过去的几个月里，我们已经重新构建了PinalyticsDB，使它成为一个性能更高、更可靠的服务。继续阅读，了解我们面临的性能和可伸缩性挑战，以及我们如何重新设计服务以构建更好的PinalyticsDB。</p><h1 id="fbf8" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">h基本区域服务器Hotspotting</h1><p id="58a3" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">随着Pinterest内部对我们平台的使用增加，Hotspotting逐渐成为PinalyticsDB区域服务器的一个问题。在以前的设计中，为每个报告创建一个新的Hbase表。</p><h1 id="021c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">旧模式设计</h1><p id="8ca1" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">行键以前的设计是:</p><p id="734d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">前一行-关键字</strong> =前缀|日期|后缀<br/>前缀=公制名称作为字符串<br/>日期= YYYY-MM-DD格式，再作为字符串<br/>后缀=由段号组成</p><p id="1de4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行键由ascii字符组成。“|”用作分隔符。</p><p id="01bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法有几个问题:</p><ul class=""><li id="7c62" class="kr ks hh ig b ih ii il im ip kt it ku ix kv jb kw kx ky kz bi translated">因为为每个报告都创建了一个新表，所以有些报告比其他报告更受欢迎，所以托管这些报告的区域服务器获得了更多的流量。</li><li id="ab62" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">我们有数千份报告，因此对于Hbase管理员来说，监控报告表并根据观察到的热点拆分这些表是不切实际的。</li><li id="876f" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">在一个报告中，一些指标更受欢迎。由于metric-name是行键的第一部分，这导致了更多的热点。</li><li id="58b4" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">最近的数据往往被更频繁地访问，在指标之后，日期是行键的一部分，这导致更多的热点。</li></ul><p id="ed85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此热备盘用于读取，但是对于写入也观察到了类似的热备盘，较重报告的表具有较高的写入次数，并且指标的数据始终写入到最后一个日期—导致写入热备盘写入到托管每个指标最后一个日期的区域。</p><h1 id="c61d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">新模式设计</h1><p id="db62" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我们通过改进行键模式和HBase表设计来解决这个问题。我们为所有报告创建了一个单一的表，具有以下行键设计。</p><p id="1c67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">新建行-关键字</strong> = SALT | &lt;报表-id &gt; | &lt;公制-id &gt; | &lt;日期-时间&gt; | &lt;段&gt;</p><p id="b3cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行键由字节数组(byte[])表示，而不是字符串。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lf"><img src="../Images/e9ca353bf0b623b9ab8643b320f2dc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TairqQkvAeK4kiHkeu__qg.png"/></div></div></figure><ul class=""><li id="175a" class="kr ks hh ig b ih ii il im ip kt it ku ix kv jb kw kx ky kz bi translated">密钥的每个部分都有固定的长度。这是为行键定义一个固定的结构。这也是为了支持模糊行过滤器。</li><li id="58b8" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">由于结构固定，我们取消了“|”分隔符，这也是为了节省空间。</li></ul><h1 id="7921" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">对读取和写入的影响</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/1c82ef02e89c3cede6a85f5c2a460629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I4P3a9lRU2w5alCi"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Pinalytics DB V2 Read Architecture</em></figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ll"><img src="../Images/740a4249da4084a6f2e33bb1fb7f3d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwM7dD_F7Iwq9-8e4aJ8LQ.png"/></div></div></figure><p id="2192" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您所看到的，由于salting逻辑，读取在整个集群中分布良好。但是这种模式设计也使得写操作得到了很好的分布。</p><h1 id="c7f4" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">提高协处理器性能</h1><p id="c925" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我们还希望通过修改协处理器的请求结构和扫描行为来优化PinalyticsDB协处理器的性能。我们的优化改进了区域服务器CPU利用率、RPC延迟和JVM阻塞线程。</p><p id="dc6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们最初的设计为发送给Pinalytics的每个指标、段请求创建了一个HBase扫描。PinalyticsDB会收到许多这样的请求，从而导致大量的扫描。我们减少了HBase扫描的数量，方法是将与同一报告和指标相关联的聚合请求合并到单个扫描中，该扫描包含所请求段的所有相关模糊行过滤器。</p><p id="77ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当使用Pinalytics时，用户通常会在不同的细分市场中生成大量包含少量指标的请求。下面的图表举例说明了这一点，要求提供一个跨美国多个州段的样本指标。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c1b37c14d22be5ba6372b8c4799956d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D80iGB8funXMvm0c"/></div></div></figure><p id="7c78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这其实是一个很常见的用例。许多用户的仪表板上有几个这样的图表。</p><p id="0051" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个用例启发了我们的<em class="lm">“多段优化”</em>，其中协处理器对PinalyticsRequest中与相同指标相关的所有段执行单次扫描(按区域salt)。</p><p id="8017" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PinalyticsDB V2协处理器设计</p><ul class=""><li id="4dcd" class="kr ks hh ig b ih ii il im ip kt it ku ix kv jb kw kx ky kz bi translated">Pinalytics Thrift服务器根据指标对它从Pinalytics收到的所有请求进行分组。然后，对于每个度量，协处理器接收包含与该度量所请求的片段组合相关联的所有模糊行过滤器的请求。</li><li id="8a11" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">对于协处理器区域中的每个salt，协处理器创建一个MUST_PASS_ONE扫描，该扫描包含过滤器列表中聚合请求中的所有模糊行过滤器。</li><li id="a5ae" class="kr ks hh ig b ih la il lb ip lc it ld ix le jb kw kx ky kz bi translated">然后，协处理器根据日期和模糊行过滤器汇总所有扫描的结果，并将该响应发送回节俭服务器。</li></ul><p id="6d0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于同一个指标，只需要一个聚合请求，而不管该指标需要多少个不同的段组合。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ln"><img src="../Images/a9cd7dbb8515422cda2f157b9ef36614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4fSYF0G-C8iXRvp"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">PinalyticsDB V2 Coprocessor Design: For every salt, a single scan is created for all segments corresponding to the same metric.</em></figcaption></figure><p id="241e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的新协处理器设计显著改善了区域服务器CPU利用率、RPC延迟和JVM线程阻塞。</p><p id="2622" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lm">注意:</em> </strong> <em class="lm">以下图表是在我们的多段优化部署后几个小时捕获的，因此它们不能准确反映系统的当前性能。不过，它们有助于捕捉我们改进的协处理器设计的影响。</em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lo"><img src="../Images/bbe26a14c98e0caebb8d81868082fca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H1DryN0MxVgwmNhg"/></div></div></figure><p id="7980" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lm">部署新协处理器后区域服务器CPU利用率的提高</em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lp"><img src="../Images/c94ec1a79be583fb4ce02387266327fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xPMxWMd7oKeVhXpa"/></div></div></figure><p id="0270" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lm">改进了新协处理器部署后阻塞的区域服务器JVM线程</em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lq"><img src="../Images/10eae18d68d439f688f067fe395b5ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_jYRi1-6MsmL-A-P"/></div></div></figure><p id="d793" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lm">部署新协处理器后区域服务器RPC延迟的改进</em></p><h1 id="3fc6" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">庞大的报表元数据和节省服务器空间</h1><p id="254a" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我们的节俭服务器也面临频繁的OOM崩溃，当用户试图加载图表时，会以webapp超时的形式注意到这一点。这是因为节俭服务器的jvm没有设置-XX:+ExitOnOutOfMemoryError，所以节俭服务器没有在OOM上退出，对它的所有调用都超时了。一个快速的解决方法是添加这个标志，以便节约服务器在OOM的生产中自动重启。</p><p id="0f59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了调试这个问题，将一个jconsole指向一个生产节俭服务器，它能够捕获一个节俭服务器崩溃。下面是总堆、老一代堆和新一代堆的图表。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/40219b2741e9a61dee184fadf3ce46fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oGaPMrhsoF2g6v5u"/></div></div></figure><p id="be55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lm">8G内存的节俭服务器的总堆内存</em></p><p id="042b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意从4G以下到8g以上的突然峰值，这导致了OOM。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/595bb98af0c43bc4612c29491b7a68ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DoCsiPV72eAWI9T3"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">CMS Old Generation for the Pinalytics DB Thrift Server</em></figcaption></figure><p id="5ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，老一代从非常低的值飙升到4G以上，超过了老一代的限制。没有时间让CMS收集器发挥作用，甚至没有时间让完整的GC发挥作用——峰值是如此之快。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/924b7f53c5093eea251fe7d3b279ebe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1s30dQcsZD2uOSN7"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Eden Space for the Pinalytics DB Thrift Server</em></figcaption></figure><p id="7bad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们能够在开发环境中通过负载测试重现这个问题，并确定这个问题与我们读取和存储报表元数据的方式有关。对于我们的大多数报告，元数据只有几千字节。但是，对于某些报表，元数据是60+，甚至120+ MB。这主要是因为一个报告可以有大量的指标。</p><h1 id="e599" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">报告元数据结构</h1><p id="951f" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">这是单个报告的报告元数据。报表元数据存储在一个特殊的二级索引表中。</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="c541" class="lw jp hh ls b fi lx ly l lz ma">#!/usr/bin/python<br/># -*- coding: utf-8 -*-<br/>ReportInfo(<br/>   tableName=u’growth_ResurrectionSegmentedReport’,<br/>   reportName=u’growth_ResurrectionSegmentedReport’,<br/>   segInfo={<br/>       u’segKey2': u’gender’,<br/>       u’segKey1': u’country’,<br/>       u’segKeyNum’: u’2',<br/>       },<br/>   metrics={u’resurrection’: MetricMetadata(name=u’resurrection’,<br/>       valueNames=None),<br/>       u’5min_resurrection’:MetricMetadata(name=u’5min_resurrection’<br/>       , valueNames=None)},<br/>   segKeys={<br/>       1: {<br/>         u’1': u’US’,<br/>         u’2': u’UK’,<br/>         u’3': u’CA’,<br/>…<br/>       }<br/>   )</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/00c788f10ad83d2dac1c137fc303fcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sk3KDCPUWAjaNLriAKfZig.png"/></div></div></figure><h1 id="f879" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">优化报告元数据的存储和检索使用</h1><p id="3031" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">报表元数据以序列化blob的形式存储在hbase二级索引表中。因此，问题的根本原因是报告元数据的巨大大小，以及我们正在加载整个元数据而不仅仅是我们想要的部分。在高负载的情况下，jvm堆完全有可能很快填满，以至于jvm甚至无法停止全局满垃圾收集。</p><p id="0446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题的根本原因，我们决定将报告元数据的内容分布到报告的行键下的几个列族和限定符中。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/71a6574b1d3ad8e7d1e88810671f9d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9-gJTr-HZjJ5PLgSSc2FQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Enhanced PinalyticsDB V2 Report Row-Key structure, which is distributed among multiple column families and qualifiers</em></figcaption></figure><p id="61a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行键的更新是原子性的。因此，所有列族都将通过一个PUT操作自动更新。</p><p id="6752" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们创建了一个新的方法来获取报告信息。</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="f514" class="lw jp hh ls b fi lx ly l lz ma">getReportInfo(final String siTableName, final String reportName, List&lt;String&gt; metrics)</span></pre><p id="1522" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将返回所有seg-info和seg-keys数据，但仅返回“metrics”列族中的相关指标数据。由于报告的大部分大小是由指标数据决定的，我们将只返回几kb的数据，而不是潜在的100mb以上的数据。</p><h1 id="1611" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">节俭服务器循环池</h1><p id="109b" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我们对节俭服务器做的另一个改变有助于提高可伸缩性。每个节俭服务器都有一个<strong class="ig hi">h base org . Apache . Hadoop . h base . client . connection .</strong>的单一实例</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="6617" class="lw jp hh ls b fi lx ly l lz ma">hbase.client.ipc.pool.size=5<br/>hbase.client.ipc.pool.type=RoundRobinPool</span></pre><p id="a1fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">默认情况下，每个区域服务器有1个连接。该设置增加了并发连接数，这有助于我们扩展每台服务器的请求数量。</p><h1 id="0ad7" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">缺点和局限性</h1><p id="95ae" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">尽管这种设计对我们来说效果不错，但我们也承认它有一些局限性。</p><p id="3f7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然横向扩展体系结构可以实现均匀分布的读取和写入，但它会影响可用性。任何区域服务器或任何zookeeper问题都会影响所有的读写请求。我们正在设置一个具有双向复制功能的备份群集，并且我们将在主群集出现任何问题的情况下为读取和写入设置自动故障转移。</p><p id="c775" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为段是行键的一部分，所以包含许多段的报表将消耗更多的磁盘空间。创建报告后，不能添加或删除报告段。此外，尽管有FuzzyRowFilter快进，但基数非常高且有大量数据的报告可能会很慢。这可以通过在协处理器中添加并行性来抵消，以便并行执行对每个salt的扫描(或者甚至是按日期的分区扫描)。</p><p id="089c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种体系结构使用协处理器进行读取，并且不支持协处理器的复制读取。我们可以通过构建一个汇总缓存层来部分弥补协处理器复制支持的不足，在该缓存层中，结果存储在一个高可用性表中，如果从主区域获取数据失败，我们将执行复制读取(使用常规hbase扫描，而不是协处理器)。</p><p id="cec7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们计划在下一次迭代中解决这些限制。我们还计划增加对Top-N，percentiles，group-by和min，max等函数的支持。</p><p id="c9ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lm">鸣谢:</em> </strong>非常感谢Rob Claire、、Justin Mejorada-Pier和Bryant Xiao在Pinterest上对PinalyticsDB的支持。此外，还要感谢分析平台和存储&amp;缓存团队，他们分别帮助支持Pinalytics webapp和HBase集群。</p><blockquote class="mc"><p id="bb3e" class="md me hh bd mf mg mh mi mj mk ml jb dx translated">我们正在建造世界上第一个视觉发现引擎。全世界有超过2.5亿人使用Pinterest来梦想、计划和准备他们在生活中想做的事情。<a class="ae mm" href="https://careers.pinterest.com/careers" rel="noopener ugc nofollow" target="_blank">来加入我们吧！</a></p></blockquote></div></div>    
</body>
</html>