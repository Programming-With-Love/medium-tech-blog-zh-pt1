<html>
<head>
<title>Smash your Adapter Monolith with the Connect pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用连接模式粉碎您的适配器整体</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/smash-your-adapter-monolith-with-the-connect-pattern-fd4854a18e61?source=collection_archive---------0-----------------------#2021-02-08">https://medium.com/google-developer-experts/smash-your-adapter-monolith-with-the-connect-pattern-fd4854a18e61?source=collection_archive---------0-----------------------#2021-02-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="61eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我描述了一种以模块化和可扩展的方式编写第三方适配器的模式，希望它足够新颖，我可以将其命名为。🙃</p><h1 id="79cf" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">TL；速度三角形定位法(dead reckoning)</h1><blockquote class="ka kb kc"><p id="ee2c" class="ie if kd ig b ih ii ij ik il im in io ke iq ir is kf iu iv iw kg iy iz ja jb ha bi translated"><strong class="ig hi">T5】</strong></p></blockquote><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/6f99bcb15f4f678f6110f07cec8a0302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPUhCPEIcxw5aYHaQpNrhg.jpeg"/></div></div></figure><p id="1575" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kd">读者注意:虽然这篇文章是关于一个不特定于Kotlin的模式，但是它使用Kotlin编写的代码演示了这个模式。这使用了各种语言特性如</em> <a class="ae kt" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="kd">数据类</em> </strong> </a> <em class="kd">，</em> <a class="ae kt" href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="kd">伴侣对象</em> </strong> </a> <em class="kd">，运算符重载和</em> <a class="ae kt" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="kd">扩展函数</em> </strong> </a> <em class="kd">。它还使用了</em><a class="ae kt" href="https://http4k.org" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kd">http4k</em></strong></a><em class="kd">HTTP工具包的基础知识，如果不熟悉的话，可能值得参考一下。</em></p><p id="613b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一个现代的基于服务器的HTTP微服务中，大部分非操作性的应用程序代码可以分成几个大的区域:</p><ol class=""><li id="aba5" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">入站服务器端API，路由和解组传入的请求</li><li id="74b4" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">业务逻辑功能</li><li id="e8f4" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">数据访问查询和变异</li><li id="158b" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">出站远程API通信的适配器代码</li></ol><h2 id="9ded" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">构建我们的入站API</h2><p id="8c3d" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">对于<strong class="ig hi">1)</strong>——服务器端——我们倾向于将应用程序建模为一组独立的HTTP入口点类/函数，它们组合成一个整体来表示传入的HTTP API，或者显式地，或者通过一些元编程(如注释)来表示。例如，使用http4k，我们可以创建并启动我们的服务器:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="e995" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，将服务器端API分割成独立的函数，使我们能够从整体上保持对应用程序的良好控制，并且能够独立于其他部分轻松测试应用程序中的各种端点——例如，如果我们能够直接测试<code class="du md me mf mg b">echo()</code>和<code class="du md me mf mg b">health()</code>，我们就不需要提供一个无记名令牌来访问我们的API调用。</p><p id="6c43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，因为我们以这种方式模块化了代码，所以它也可以在其他上下文中重用——我们可以将通用端点代码(如<code class="du md me mf mg b">health()</code>)放入共享位置，并在我们的微服务群中重用它们。</p><h2 id="e313" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">构建我们的出站API</h2><p id="906e" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">当谈到上面列表中的<strong class="ig hi">4)</strong>——其他远程API的适配器代码——我们通常没有合适的模式来使用相同的结构。远程系统的HTTP适配器通常被构造为具有许多方法的整体类，所有这些都是围绕一个单独配置的HTTP适配器构建的。假设我们想要与GitHub API对话，我们通常会构建一个API适配器，如下所示:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="fbf6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是非常明智的——有一个共享的HTTP客户端，它被配置为使用正确的<code class="du md me mf mg b">Accept</code>头向API发送请求。然而不幸的是，随着我们对API使用的增长，<code class="du md me mf mg b">GitHubApi</code>类的规模也会增长——它可能会获得许多(几十个甚至上百个)函数，所有这些函数通常都提供对单个API调用的单一访问。如果不检查的话，我们最终会得到一个长达数千行的巨大物体。</p><p id="deaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于这些函数之间通常没有交互——以模块化、易于测试和可重用的方式，以类似于我们构建入站API的方式构建代码是可取的。即便如此，我们也想找到一种方法来构建结合一个或多个API调用的函数。</p><p id="3ae0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是连接模式将帮助我们的地方。本质上，Connect允许将一个适配器整体拆分成单独的动作和一个共享的协议对象，该对象集中了与API的通信。</p><h2 id="c8a9" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">介绍连接模式</h2><p id="bf70" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">模式本身是围绕Kotlin语言中可用的特性创建的——最显著的是接口和扩展函数的使用。其他语言可能没有这些完全相同的功能，但是Connect应该是可适应的(或多或少)。让我们把它分解开来，通过重新实现上面的例子来看一看。</p><p id="aedf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的解释基于简化版本的<a class="ae kt" href="https://github.com/http4k/http4k-connect" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> http4k-connect </strong> </a>库，我们将它用作模式的规范实现。顾名思义，http4k-connect本身构建在用于核心http抽象的<a class="ae kt" href="https://http4k.org" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">http4k</strong></a>http toolkit之上，尽管模式中没有任何东西将它绑定到这个库(甚至HTTP协议)。</p><h2 id="d989" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">行动</h2><p id="cd93" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">Connect模式中的基本工作单元是<code class="du md me mf mg b">Action</code>接口，它代表与远程系统的单一交互，由返回对象<code class="du md me mf mg b">R</code>的类型来概括。每个动作都包含需要传输的数据的状态，以及如何将动作中的数据封送到底层HTTP API和从底层HTTP API封送数据。</p><p id="9905" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于我们的<code class="du md me mf mg b">GitHubApi</code>适配器，我们创建了超接口和一个动作的实现，以从API获取用户和结果类型。请注意，动作和结果类型被建模为Kotlin数据类——这将给我们带来优势，我们将在后面介绍:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h2 id="ac6c" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">适配器</h2><p id="a577" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">适配器接口代表了与远程API交互的公共基础协议——它将处理服务器主机位置、授权和其他报头，并执行实际的HTTP交互。每个适配器都被建模为一个简单的接口，带有一个接受通用动作类型的通用方法。</p><p id="6c0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意这里Kotlin <code class="du md me mf mg b">companion object</code>的存在——它应该是空的，正好给我们一个点，让我们在一会儿把其他代码挂在上面。这是为了让API用户的生活更轻松。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="ba21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对companion对象的第一次使用是将我们之前的版本重写为<code class="du md me mf mg b">GitHubApi</code>的匿名实现，并将其附加到我们的适配器，由<code class="du md me mf mg b">Http()</code>工厂函数返回。适配器所需的所有依赖项都在这里传递并关闭。注意，我们显式地传入HTTP客户端，而不是在函数内部构造它——如果我们希望能够用调用日志记录或其他操作问题来修饰客户端适配器，对它的访问是至关重要的:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h2 id="090a" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">使用适配器</h2><p id="ca24" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">除了使用Companion对象作为钩子之外，我们的适配器的构造看起来与以前的版本相似——我们没有公开任何更多的具体类型(仍然只有<code class="du md me mf mg b">GitHubApi</code>)。然而，调用API看起来确实有所不同——由于操作符函数<code class="du md me mf mg b">invoke()</code>，我们现在将服务器视为一个简单的函数，它接受动作实例:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="9091" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种变化可能会留下一点不好的印象，因为API不再容易被发现。幸运的是，科特林还有另一个锦囊妙计，这将帮助我们…</p><h2 id="dd69" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">扩展功能</h2><p id="4086" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">通过为每个动作创建另一个扩展函数，模仿动作本身的签名并委托给客户端中的<code class="du md me mf mg b">invoke()</code>调用，我们可以非常简单地恢复我们的旧API:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="30ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更好的是，对于包含不止一个API调用的动作，比如下面的<code class="du md me mf mg b">getLatestUser()</code>,我们可以创建更多的扩展函数，将它们委托给单独的动作。这些函数可以在全局级别添加到<code class="du md me mf mg b">GitHubApi</code>实例中，或者只添加到有意义的上下文或模块中。扩展功能有效地允许我们从我们感兴趣的单个动作部件中组合出我们自己的定制<code class="du md me mf mg b">GitHubApi</code>适配器:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h1 id="3be2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">测试连接模式</h1><p id="08d7" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">适配器和各种动作类的模块化都使得为使用Connect模式创建的动作代码编写单元测试变得非常容易，但是考虑API设计将如何影响客户端代码的测试也很重要。</p><p id="e414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，单个arity函数适配器接口的简单性与作为Kotlin数据类实现的动作(很容易比较)使得作为Connect APIs客户端的测试在多个层面上变得微不足道。例如，如果我们打算模拟一个函数，它有七个我们不关心的参数——在前面的实现中，我们必须模拟出每个带值的参数(或一个<code class="du md me mf mg b">any()</code>匹配器),而不是一个覆盖连接版本的<code class="du md me mf mg b">any&lt;Action&gt;()</code>:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="a3a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Action对象是<code class="du md me mf mg b">invoke()</code>方法的一个参数，这也让我们能够轻松地修饰我们的适配器实例以用于测试或其他目的，例如，我们可以为任何目的记录所有的来电:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="ebda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编写适配器的存根实现也非常简单，并且Connect模式还鼓励与真实适配器相同类型的分解结构——通过创建扩展函数，这些函数作用于我们的内存状态以创建它们的响应。同样，这有助于控制适配器代码的大小。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h2 id="6913" class="li jd hh bd je lj lk ll ji lm ln lo jm ip lp lq jq it lr ls ju ix lt lu jy lv bi translated">改变编程模型</h2><p id="d824" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">根据团队的风格，有几种不同的流行编程模型，它们可能在野外很常见，这将影响为Action类实现的<code class="du md me mf mg b">R</code>类型的值。</p><p id="a340" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们上面的例子，使用支持抛出异常的语言的传统OO风格团队将把<code class="du md me mf mg b">R</code>表示为方法返回的直接结果类型，但是采用更函数式编程方法的团队将倾向于使用更一元的返回类型，例如<a class="ae kt" href="https://github.com/fork-handles/forkhandles/tree/trunk/result4k" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Result4k </strong> </a> <strong class="ig hi">的</strong> <code class="du md me mf mg b">Result</code>、<a class="ae kt" href="https://arrow-kt.io/docs/apidocs/arrow-core-data/arrow.core/-either/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">箭头</strong> </a> <strong class="ig hi">的</strong> <code class="du md me mf mg b">Either</code>，或者(当它普遍可用时)Kotlin的内置<a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/" rel="noopener ugc nofollow" target="_blank"/></p><p id="aad0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好消息是，由于Connect抽象的解耦，这些模型中的任何一个都可以简单地通过以相关的风格编写动作来支持。下面是使用Result4k单子的<code class="du md me mf mg b">GetUser</code>动作的另一个例子:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h1 id="6af3" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">摘要</h1><p id="a7a5" class="pw-post-body-paragraph ie if hh ig b ih lw ij ik il lx in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">Connect模式结合了简单的抽象来提供一个模型，该模型允许我们将整体出站API适配器的常见问题分解成容易理解的部分。这种模块化提供了我们在构建入站服务器端接口时所期望的可组合性的镜像，这进一步导致了更易测试和可扩展的代码库。对于这样一个小例子，这种方法可能看起来有些矫枉过正，但是经验告诉我们，通常来说，改进一个组合设计比从一开始就推广它要困难得多。</p><p id="e0ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模式最初是围绕HTTP设计的，适合任何请求/响应协议，并且可以很容易地适应不同的编程模型，包括结果单子和未来类型。</p><p id="6b04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，尽管对Connect模式的实现并不重要，但具有扩展函数等特性的更高级的编程语言(如Kotlin)为使用Connect提供了一个理想的平台。在静态类型语言中，足够高级的泛型功能是唯一需要的语言特性。</p><p id="b514" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注:</strong>本帖显示的代码在<a class="ae kt" href="https://github.com/http4k/http4k-connect-examples/tree/master/connect-pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> GitHub </strong> </a>中有。</p><h1 id="2967" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">模式的http4k-connect实现的脚注</h1><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mh"><img src="../Images/33c42029be4afaf21ca147c21ae3dcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynrSvWRqYMnPj442w_-_SA.png"/></div></div></figure><p id="abb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开源的<a class="ae kt" href="https://github.com/http4k/http4k-connect" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">http4k-Connect</strong></a><strong class="ig hi"/>kot Lin库既提供了实现连接模式适配器的基本框架，也提供了一组预构建的API适配器，用于与AWS等流行的云服务进行通信。此外，http4k-connect提供了一组协议兼容的内存/可运行的伪服务器，可以用作各种服务的测试替身，以及一组存储后端(如内存、S3和Redis ),用于存放测试数据。</p><p id="e66a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些库被设计为尽可能的轻量级，这意味着它们是无服务器部署的完美用例，它们使用编译时代码生成为每个使用Kapt实现的操作自动编写扩展函数，并且通过使用<a class="ae kt" href="https://github.com/ansman/kotshi" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Kotshi </strong> </a>插件为<a class="ae kt" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Moshi </strong> </a> JSON框架生成消息适配器，不需要JSON消息解析中的反射。</p></div><div class="ab cl mi mj go mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ha hb hc hd he"><p id="16a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kd">喜欢这篇文章吗？你可以在</em><a class="ae kt" href="https://dentondav.id/writing" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kd">https://dentondav.id/writing</em></strong></a><em class="kd">阅读我所有的科技文章，或者了解更多关于</em><strong class="ig hi"><em class="kd"/></strong><a class="ae kt" href="https://http4k.org" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kd">http4k</em></strong></a><em class="kd">的信息。</em></p></div></div>    
</body>
</html>