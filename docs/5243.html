<html>
<head>
<title>Sequential Asynchronous Calls in Node.JS — Callbacks, Async and ES6 Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点中的顺序异步调用。JS —回调、异步和ES6承诺</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/sequential-asynchronous-calls-in-node-js-using-callbacks-async-and-es6-promises-e92cc849de46?source=collection_archive---------3-----------------------#2017-05-18">https://medium.com/oracledevs/sequential-asynchronous-calls-in-node-js-using-callbacks-async-and-es6-promises-e92cc849de46?source=collection_archive---------3-----------------------#2017-05-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ed4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般来说，用JavaScript (ECMA脚本)和Node编程的挑战之一。JS尤其需要处理异步操作。每当调用一个异步处理请求的函数时，都必须小心准备以异步方式接收函数的结果。此外，我们必须确保程序流不会过早地继续——只有那些可以在没有函数调用结果的情况下执行的步骤才能继续。编排多个异步调用——其中一些是顺序的或链式的，其他的可能是并行的——并以适当的方式从这些调用中收集结果并不容易。</p><p id="703c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">传统上，我们使用回调函数对异步交互进行编程:调用者将一个函数的引用传递给异步操作，当异步操作完成时，被调用的函数将调用这个回调函数来传递结果。回调函数将接管并继续程序流程。每当使用setTimeout()计划执行一个动作时，就会看到一个回调函数的简单示例:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="f6fd" class="jl jm hh jh b fi jn jo l jp jq">setTimeout(function () { <br/>  console.log("Now I am doing my thing "); <br/>}<br/>, 1000);</span></pre><p id="4245" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者更明确地说:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="af86" class="jl jm hh jh b fi jn jo l jp jq">function cb() { console.log("Now I am doing my thing "); } </span><span id="fd77" class="jl jm hh jh b fi jr jo l jp jq">setTimeout(cb, 1000);</span></pre><h1 id="abb0" class="js jm hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">异步动作链</h1><p id="97f6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">对于多个相互依赖的(链式)调用，使用回调函数会导致嵌套的程序逻辑，很快变得难以阅读、调试和维护。这里显示了一个示例:</p><figure class="jc jd je jf fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ku"><img src="../Images/ed1ddb54acbbab98e4ce527b7f02bd90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jf6KqJqTaT8-Cqrg."/></div></div></figure><p id="032f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数readElementFromJsonFile顾名思义:它从输入参数指定的文件中读取特定元素的值。它异步地这样做，并在获得结果时调用回调函数返回结果。使用这个函数，我们得到最终值。从文件step1.json开始，我们读取nextfile元素的名称，该名称指示要读取的下一个文件，在本例中为step2.json。显然，我们有一个异步动作链的例子，其中每个动作的输出为下一个动作提供输入。</p><p id="f3e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在经典的面向回调的JavaScript中，调用链的代码看起来像这样——我们期望使用回调函数来处理异步情况的嵌套结构:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="6f7e" class="jl jm hh jh b fi jn jo l jp jq">// the classic approach with nested callbacks var fs = require('fs'); <br/>var step1 = "/step1.json"; <br/>function readElementFromJsonFile(fileName, elementToRead, cb) { <br/>  var elementToRetrieve = 'nextfile'; <br/>  if (elementToRead) { <br/>    elementToRetrieve = elementToRead; <br/>  } <br/>  console.log('file to read from ' + fileName); <br/>  fs.readFile(__dirname + '/' + fileName, "utf8"<br/>             , function (err, data) { <br/>     var element = ""; <br/>     if (err) return cb(err); <br/>     try { <br/>       element = JSON.parse(data)[elementToRetrieve];<br/>     } catch (e) { return cb(e); } <br/>     console.log('value of element read = ' + element); <br/>     cb(null, element); <br/>  }); //readFile <br/>}//readElementFromJsonFile </span><span id="4802" class="jl jm hh jh b fi jr jo l jp jq">readElementFromJsonFile(step1, null, function (err, data) { <br/>   if (err) return err; <br/>   readElementFromJsonFile(data, null, function (err, data) { <br/>     if (err) return err; <br/>     readElementFromJsonFile(data, null, function (err, data) { <br/>       if (err) return err; <br/>       readElementFromJsonFile(data, null, function (err, data) { <br/>         if (err) return err; <br/>         readElementFromJsonFile(data, 'actualValue', function (err, data) { <br/>           if (err) return err; <br/>           console.log("Final value = " + data); <br/>         }); <br/>      }); <br/>    }); <br/>  }); <br/>});</span></pre><p id="4b59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ES6承诺的到来——一种本机语言机制，因此在Node的最新版本中可用。JS——让事情变得有点不同，更有组织性、可读性和可维护性。函数readElementFromJsonFile()现在将返回一个承诺—异步操作最终结果的占位符。即使结果将在稍后通过Promise对象提供，我们也可以像Promise代表现在的结果一样进行编程——并且我们可以在代码中预测当函数实现其承诺时要做什么(通过调用Promise中的内置函数<em class="lc"> resolve </em>)。</p><p id="9cec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">承诺解析的结果是一个值——在函数<em class="lc"> readElementFromJsonFile </em>的情况下，它是从文件中读取的值。用该值解析承诺时执行的then()操作调用作为参数给出的函数。承诺的结果(解决结果)作为输入传递给该函数。在下面的代码示例中，我们看到<em class="lc">如何读取ElementFromJsonFile(参数)</em>。然后使用(<em class="lc"> readElementFromJsonFile </em>)。这意味着:当第一次调用函数返回的承诺被解析时，再次调用函数，这次使用第一次调用的结果作为第二次调用的输入。对于第四个<em class="lc">，然后是</em>，这一点更加明确:因为在对函数<em class="lc">readElementFromJsonFile</em>的最后一次调用中，我们不仅需要将前一次调用的结果作为输入参数传递给函数，还需要传递要从文件中读取的元素的名称。因此，我们使用一个匿名函数，该函数将解析结果作为输入，并调用带有附加参数的函数。类似的事情发生在最后的<em class="lc">然后是</em>——之前调用的结果被简单地打印到输出中。</p><p id="51cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们随后异步读取文件的示例代码变为:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="06a5" class="jl jm hh jh b fi jn jo l jp jq">var fs = require('fs'); <br/>var step1 = "step1.json"; </span><span id="610f" class="jl jm hh jh b fi jr jo l jp jq">function readElementFromJsonFile(fileName, elementToRead) { <br/>  return new Promise((resolve, reject) =&gt; { <br/>     var elementToRetrieve = 'nextfile'; <br/>     if (elementToRead) { elementToRetrieve = elementToRead; }     <br/>     console.log('file to read from ' + fileName);<br/>     fs.readFile(__dirname + '/' + fileName, "utf8"<br/>                , function (err, data) { <br/>       var element = ""; <br/>       if (err) return reject(err); <br/>       try { <br/>         element = JSON.parse(data)[elementToRetrieve]; <br/>       } catch (e) { reject(e); } <br/>       console.log('element read = ' + element); <br/>       resolve(element); <br/>     }); //readFile<br/>})// promise } </span><span id="ecfe" class="jl jm hh jh b fi jr jo l jp jq">readElementFromJsonFile(step1) <br/>.then(readElementFromJsonFile) <br/>.then(readElementFromJsonFile) <br/>.then(readElementFromJsonFile) <br/>.then(function (filename) { <br/>   return readElementFromJsonFile(filename, 'actualValue') }) <br/>.then(function (value) { <br/>   console.log('Value read after processing five files = ' + value); })</span></pre><h1 id="48e7" class="js jm hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">作为承诺的预定操作或如何承诺设置超时</h1><p id="e719" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">内置的setTimeout()需要回调函数。它目前不返回承诺。类似于:</p><blockquote class="ld le lf"><p id="51d2" class="ie if lc ig b ih ii ij ik il im in io lg iq ir is lh iu iv iw li iy iz ja jb ha bi translated">setTimeout(1000)。然后(myFunc)</p></blockquote><p id="abfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">会很好但是不存在。</p><p id="8aa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Stackoverflow 上的这个<a class="ae lj" href="http://stackoverflow.com/questions/39538473/using-settimeout-on-promise-chain" rel="noopener ugc nofollow" target="_blank">条目有一个很好的解决方案，可以使用一个定制的通用delay()函数来处理setTimeout Promise样式:</a></p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="8898" class="jl jm hh jh b fi jn jo l jp jq">function delay(t) { <br/>  return new Promise( function(resolve) { setTimeout(resolve, t) }); } </span><span id="ea27" class="jl jm hh jh b fi jr jo l jp jq">function myFunc() { console.log('At last I can work my magic!'); } </span><span id="a726" class="jl jm hh jh b fi jr jo l jp jq">delay(1000).then(myFunc);</span></pre><p id="f0ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lc">原载于2017年5月18日</em><a class="ae lj" href="https://technology.amis.nl/2017/05/18/sequential-asynchronous-calls-in-node-js-using-callbacks-async-and-es6-promises/" rel="noopener ugc nofollow" target="_blank"><em class="lc">technology . amis . nl</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>