<html>
<head>
<title>The Android Lifecycle cheat sheet — part I: Single Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android生命周期备忘单——第一部分:单一活动</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-i-single-activities-e49fd3d202ab?source=collection_archive---------1-----------------------#2017-12-05">https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-i-single-activities-e49fd3d202ab?source=collection_archive---------1-----------------------#2017-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c767" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android旨在赋予用户权力，让他们以直观的方式使用应用程序。例如，应用程序的用户可能会旋转屏幕，响应通知，或切换到另一个任务，并且他们应该能够在这样的事件后无缝地继续使用应用程序。</p><p id="830c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了提供这种用户体验，您应该知道如何管理组件的生命周期。组件可以是活动、片段、服务、应用程序本身，甚至是底层流程。组件有一个生命周期，在这个生命周期中，它会经历各种状态。每当转换发生时，系统会通过生命周期回调方法通知您。</p><p id="84ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了帮助我们解释生命周期是如何工作的，我们定义了一系列场景，这些场景根据存在的组件进行分组:</p><p id="8ce6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一部分:活动</strong> —单个活动生命周期(本帖)</p><p id="3c4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@JoseAlcerreca/the-android-lifecycle-cheat-sheet-part-ii-multiple-activities-a411fd139f24"> <strong class="ig hi">第二部分:多活动</strong> —导航和回栈</a></p><p id="4ffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@JoseAlcerreca/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd"> <strong class="ig hi">第三部分:片段</strong> —活动和片段生命周期</a></p><p id="ef10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094"> <strong class="ig hi">第四部分:视图模型、半透明活动和启动模式</strong> </a></p><p id="58b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些图表还可以作为PDF格式的<a class="ae jc" href="https://github.com/JoseAlcerreca/android-lifecycles" rel="noopener ugc nofollow" target="_blank">备忘单</a>快速参考。</p><blockquote class="jd je jf"><p id="d599" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">注意:这些图表适用于<strong class="ig hi"> Android P / Jetpack 1.0 </strong>行为。</p></blockquote></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><p id="e767" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除非另有说明，否则以下方案展示了组件的默认行为。</p><p id="4b83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你发现错误或者你认为遗漏了什么重要的东西，请在评论中报告。</p><h1 id="689b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">第一部分:活动</strong></h1><h2 id="615c" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">单个活动—场景1:应用程序完成并重启</h2><p id="8d14" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">触发者:</p><ul class=""><li id="bb24" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">用户按下<strong class="ig hi">后退按钮</strong>，或者</li><li id="7556" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">调用了<code class="du lw lx ly lz b">Activity.finish()</code>方法</li></ul><p id="b877" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最简单的场景显示了当用户启动、完成和重启单活动应用程序时会发生什么:</p><figure class="mb mc md me fd mf er es paragraph-image"><div class="er es ma"><img src="../Images/181dfb3486209c72e79037454c0fce02.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*U_j3OP74jrPFoNvO2i7XzQ.png"/></div><figcaption class="mi mj et er es mk ml bd b be z dx"><strong class="bd jt">Scenario 1: App is finished and restarted</strong></figcaption></figure><p id="779b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">管理状态</strong></p><ul class=""><li id="36cf" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated"><code class="du lw lx ly lz b"><a class="ae jc" href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">onSaveInstanceState</a></code>未被调用(由于活动已经完成，不需要保存状态)</li><li id="a6b7" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated"><code class="du lw lx ly lz b"><a class="ae jc" href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">onCreate</a></code>重新打开应用程序时没有捆绑包，因为活动已完成，状态不需要恢复。</li></ul></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><h2 id="0303" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated"><strong class="ak">单个活动—场景2:用户导航离开</strong></h2><p id="6c73" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">触发者:</p><ul class=""><li id="cc4f" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">用户按下<strong class="ig hi">主页按钮</strong></li><li id="b0ca" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">用户切换到另一个应用程序(通过概览菜单、从通知、接受呼叫等。)</li></ul><figure class="mb mc md me fd mf er es paragraph-image"><div class="er es mm"><img src="../Images/343d717bc7ba4596ea1d9ddba2c395d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*3qxYnT2vRwrQVORi9mfUhw.png"/></div><figcaption class="mi mj et er es mk ml bd b be z dx"><strong class="bd jt">Scenario 2: User navigates away</strong></figcaption></figure><p id="29bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，系统将<a class="ae jc" href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#onstop" rel="noopener ugc nofollow" target="_blank">停止</a>活动，但不会立即完成它。</p><p id="9f59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">管理状态</strong></p><p id="a71d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您的活动进入停止状态时，<strong class="ig hi">系统使用onSaveInstanceState保存应用程序状态，以防系统稍后在</strong>(见下文)<strong class="ig hi">终止应用程序的进程。</strong></p><p id="4975" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设流程没有被终止，活动实例将驻留在内存中，保留所有状态。当活动回到前台时，活动会调用这些信息。您不需要重新初始化之前创建的组件。</p></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><h2 id="3326" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated"><strong class="ak">单一活动—场景3:配置变更</strong></h2><p id="c768" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">触发者:</p><ul class=""><li id="d06a" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">配置变化，如<strong class="ig hi">旋转</strong></li><li id="ccc2" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">用户在多窗口模式下调整窗口大小</li></ul><figure class="mb mc md me fd mf er es paragraph-image"><div class="er es mn"><img src="../Images/6df20e47df69e2bc85d6802af3ab53e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*DCo7awxJ3KhnW88h365vhA.png"/></div><figcaption class="mi mj et er es mk ml bd b be z dx"><strong class="bd jt">Scenario 3: Rotation and other configuration changes</strong></figcaption></figure><p id="cde5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">管理状态</strong></p><p id="3051" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像旋转或调整窗口大小这样的配置变化应该让用户从他们离开的地方继续。</p><ul class=""><li id="55df" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">活动被完全销毁，但是状态被保存并为新实例恢复。</li><li id="e009" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated"><code class="du lw lx ly lz b">onCreate</code>和<code class="du lw lx ly lz b">onRestoreInstanceState</code>中的捆绑是相同的。</li></ul></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><h2 id="22df" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated"><strong class="ak">单个活动——场景4: App被系统暂停</strong></h2><p id="05d6" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">触发者:</p><ul class=""><li id="624b" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">启用多窗口模式(API 24+)并失去焦点</li><li id="034d" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">另一个应用程序部分覆盖了正在运行的应用程序(购买对话框、运行时许可对话框、第三方登录对话框……)</li><li id="f161" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">出现一个意图选择器，如共享对话框</li></ul><figure class="mb mc md me fd mf er es paragraph-image"><div class="er es mo"><img src="../Images/64307b560cc2d84b44830347596b24db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*j3blnCW082yMbQe5fkjMMg.png"/></div><figcaption class="mi mj et er es mk ml bd b be z dx"><strong class="bd jt">Scenario 4: App is paused by the system</strong></figcaption></figure><p id="a101" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个场景<em class="jg">不适用于:</em></p><ul class=""><li id="6737" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">同一个应用程序中的对话框。显示一个<code class="du lw lx ly lz b">AlertDialog</code>或一个<code class="du lw lx ly lz b">DialogFragment</code>不会暂停潜在的活动。</li><li id="adc9" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">通知。用户收到新通知或下拉通知栏不会暂停底层活动。</li></ul><h1 id="e97e" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">继续阅读</h1><ul class=""><li id="1a3f" class="li lj hh ig b ih ld il le ip mp it mq ix mr jb ln lo lp lq bi translated"><a class="ae jc" rel="noopener" href="/@JoseAlcerreca/the-android-lifecycle-cheat-sheet-part-ii-multiple-activities-a411fd139f24">Android生命周期备忘单第二部分——多项活动</a></li></ul></div></div>    
</body>
</html>