<html>
<head>
<title>Integration Test With Database in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang数据库集成测试</h1>
<blockquote>原文：<a href="https://medium.easyread.co/integration-test-with-database-in-golang-355dc123fdc9?source=collection_archive---------1-----------------------#2019-01-24">https://medium.easyread.co/integration-test-with-database-in-golang-355dc123fdc9?source=collection_archive---------1-----------------------#2019-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="76d9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在Go项目中使用真实的实时数据库/服务制作测试套件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/be7f55ee82edfae1e013a3e085c399f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-UTDr5YKx5Buxr-v"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sharegrid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ShareGrid</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e37c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">软件测试是一个用来识别开发的计算机软件的正确性、完整性和质量的过程。软件测试有很多种。从单元测试、负载测试、压力测试、集成测试、UI测试、e2e测试等等开始。</p><p id="561f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每一种测试都有不同的目的，单元测试的目的是测试单一的功能单元。负载测试的目的是测量我们的系统在巨大的请求下有多可靠。集成测试的目的是确保我们的系统可以毫无问题地与外部服务集成。</p><h2 id="2006" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">Go中的集成测试</h2><p id="7f3f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在本文中，除了集成测试之外，我不会告诉任何其他测试。正如我前面所说，这种测试是为了确保我们的系统可以毫无问题地集成到外部服务中。</p><p id="58d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，通过这个测试，我们希望在将我们的应用程序部署到服务器时，无论其环境如何(试运行、生产)，我们都可以避免任何不必要的错误或缺陷</p><p id="9d49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，在移动Golang如何做之前，在我解释下面的许多事情之前，让我澄清几件事情。事实上，我不知道这种测试对很多人来说是否是好的，但这就是我们如何在我们的公司<a class="ae ks" href="https://kurio.co.id" rel="noopener ugc nofollow" target="_blank"> Kurio </a>(写这篇文章时我现在的公司)进行集成测试的。如果你有任何更好的想法，请在下面的评论中告诉我们。</p><h2 id="18d0" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">准备工作和工具</h2><p id="b1a5" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在这篇文章中，为了清楚起见，我列出并准备了一些东西作为我的工具和助手。</p><ul class=""><li id="59c1" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">安装了Docker(特别是docker-compose)</li><li id="d624" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">github.com/stretchr/testify</code>用于测试包工具</li><li id="1a56" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">github.com/go-redis/redis</code>对于Redis驱动程序</li><li id="caab" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">github.com/golang-migrate/migrate</code>办理移民包</li><li id="770f" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">go.mod中列出的etc</li></ul><p id="a0b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我将使用两种数据库，我的简单应用程序将连接到这个数据库。我要解释的是，如何对我的两个数据库进行集成测试。</p><p id="5617" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我会使用MySQL和Redis，技术上我们也可以说Redis是一个数据库，但是NoSQL，如果不是，我们就假设它是一个数据库</p><h2 id="6a27" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">测试套</h2><p id="4782" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">假设我有一个依赖于这两个数据库的项目，你可以在这里查看我的整个简单项目:<a class="ae ks" href="https://github.com/bxcodec/integration-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/integration-testing</a></p><p id="94e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你查看包<code class="fe nb nc nd ne b">mysql</code>和<code class="fe nb nc nd ne b">redis</code>，你会发现我的函数处理程序连接到每个数据库本身和它的文件测试。每个测试都是一个套件测试。将测试我的处理程序的捆绑测试。做一个套件测试很容易，多亏了<code class="fe nb nc nd ne b">github.com/stretchr/testify</code>，我可以轻松地完成它。</p><p id="ab6d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">比如你可以看看我的<code class="fe nb nc nd ne b">redis</code>套餐。在<code class="fe nb nc nd ne b">suite_test.go</code>,我定义了一个可被任何测试文件重用的可重分解结构。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="9991" class="lp lq in ne b gy nj nk l nl nm">package redis_test</span><span id="429f" class="lp lq in ne b gy nn nk l nl nm">import (<br/> "github.com/go-redis/redis"<br/> "github.com/stretchr/testify/suite"<br/>)</span><span id="bf47" class="lp lq in ne b gy nn nk l nl nm">type RedisSuite struct {<br/> suite.Suite<br/> Host     string<br/> Password string<br/> DB       int<br/> Client   *redis.Client<br/>}</span><span id="b54f" class="lp lq in ne b gy nn nk l nl nm">func (r *RedisSuite) SetupSuite() {<br/> r.Client = redis.NewClient(&amp;redis.Options{<br/>  Addr:     r.Host,<br/>  Password: r.Password,<br/>  DB:       r.DB,<br/> })<br/>}</span><span id="c1f7" class="lp lq in ne b gy nn nk l nl nm">func (r *RedisSuite) TearDownSuite() {<br/> r.Client.Close()<br/>}</span></pre><p id="812d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢<code class="fe nb nc nd ne b">testify</code>包，它真的有助于创建一个套件测试。后来有了这个结构，我可以很容易地把它嵌入到我的测试文件中。你可以在我的<code class="fe nb nc nd ne b">cache_test.go</code>看到</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="592b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你看一下cache_test.go文件，它与普通的file-test有点不同。如果在正常的测试文件中，我们通常有这样的模式:</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="4d95" class="lp lq in ne b gy nj nk l nl nm">func TestXXXX (<strong class="ne io">t *testing.T</strong>){} // with testing param</span></pre><p id="f1e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它在每次测试中都有测试参数。这是必须的。但是在这种情况下，因为我使用了<code class="fe nb nc nd ne b">testify</code>包，所以测试方式有点不同。这真的很重要。要添加一个测试用例，我们必须遵循这个模式:</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="3695" class="lp lq in ne b gy nj nk l nl nm">func (s TestSuite) TestXXXX(){} //without testing param</span></pre><p id="256b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，在我的redis测试文件(cache_test.go)中，您可以看到我有两个测试，它们是:<code class="fe nb nc nd ne b">TestSet</code>和<code class="fe nb nc nd ne b">TestGet</code>。</p><h2 id="3c03" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">运行测试</h2><p id="d501" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">运行测试，它仍然和往常一样。用:<code class="fe nb nc nd ne b">go test</code>运行。但是，因为这个测试需要实时数据库(MySQL和Redis)，所以首先，我们需要在我们的测试环境中运行一个实时数据库。</p><p id="af61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们在本地运行测试，那么确保我们需要的数据库是活动的，并且可以从我们的本地pc访问。如果我们在CI/CD服务器上运行测试，那么我们必须提供一个实时数据库来完成测试。</p><p id="f789" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，在这个现代软件工程时代，有一个像Docker这样的工具存在。我们可以在docker容器中运行我们的数据库，所以我们不必为了测试需要而拥有一个真实的数据库。</p><p id="a392" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了简单起见，我将使用<code class="fe nb nc nd ne b">docker-compose</code>功能，看看我的<code class="fe nb nc nd ne b">docker-compose.yaml</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3c81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只需使用命令<code class="fe nb nc nd ne b">docker-compose up -d</code>，我就可以在docker-container中运行一个2数据库，这样我就可以用它直接测试了。</p><p id="f8cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了减轻我，我只是把它做成一个Makefile。所以在运行我的集成测试之前，我需要我的数据库已经存在于容器中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="939d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，为了进行测试，我只需要一个命令:</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="ddaa" class="lp lq in ne b gy nj nk l nl nm">$ make integration-test //for integration test<br/>$ make unittest // just for unit-testing</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/240bebf078d21f3f2a3536eb2d299642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*LAR6wxvcezXOpwqS75RESQ.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">demo integration testing command with make file</figcaption></figure></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="09ff" class="ny lq in bd lr nz oa ob lu oc od oe lx jt of ju ma jw og jx md jz oh ka mg oi bi translated">与CI/CD一起使用(Travis)</h1><p id="e7a6" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">每个配置项/CD可能有不同功能。实际上，在我目前的公司(<a class="ae ks" href="https://kurio.co.id" rel="noopener ugc nofollow" target="_blank"> Kurio </a>)我们使用BuddyWorks作为我们的CI/CD工具，但是如果我在这里使用BuddyWorks，这看起来非常容易做到，因为，在BuddyWorks中，我们只是拖放没有脚本:d。</p><p id="ec57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，为了使它更有趣，更“hacky”和“geeky ”,看起来非常终端为基础，因为许多人看到我们的工程师，只与终端和爱黑屏:D，所以我决定使用特拉维斯CI/CD这篇文章:D</p><h2 id="c5b5" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">设置travis.yml脚本</h2><p id="6cc3" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在继续之前，首先，我们需要将我们的项目添加到travis-ci.com，并在那里启用CI/CD管道。</p><p id="fc37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">稍后，我们只需要在我们的项目中添加我们的<code class="fe nb nc nd ne b">.travis.yml</code>。对于我的项目，你可以在我的资源库中查看<code class="fe nb nc nd ne b">.travis.yml</code>的所有完整脚本。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3694" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，在Travis中启用它，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/0fe78bacac1f4196f5886ffb47015879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwfpsiR2NXvbfSBMw538Nw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">find and enable our repo in Travis</figcaption></figure><p id="eb74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有人都将在特拉维斯进行测试。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="fbac" class="ny lq in bd lr nz oa ob lu oc od oe lx jt of ju ma jw og jx md jz oh ka mg oi bi translated">样板！！！</h1><p id="c324" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们只是将基于数据库提供者和驱动库的测试套件样板文件添加到单独的包中:你可以在这里查看:<a class="ae ks" href="https://github.com/golangid/testada" rel="noopener ugc nofollow" target="_blank">https://github.com/golangid/testada</a></p><p id="a51f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用这个包，比如你想做一个MySQL集成测试，可以直接导入testada/mysql包。并直接嵌入MySQL套件结构。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="3d2c" class="lp lq in ne b gy nj nk l nl nm">import "github.com/golangid/testada/mysql"</span><span id="9b31" class="lp lq in ne b gy nn nk l nl nm">type youItemMysqlTestSuite struct {<br/> mysql.MysqlSuite <strong class="ne io">//embed from testada/mysql</strong><br/>}</span><span id="ef8e" class="lp lq in ne b gy nn nk l nl nm">func TestYourItemMysqlSuite(t *testing.T) {<br/> if testing.Short() {<br/>  t.Skip("Skip you item mysql repository test")<br/> }<br/> dsn := os.Getenv("MYSQL_TEST_URL")<br/> if dsn == "" {<br/>  dsn = "root:root-pass@tcp(localhost:3306)/testing?parseTime=1&amp;loc=Asia%2FJakarta&amp;charset=utf8mb4&amp;collation=utf8mb4_unicode_ci"<br/> }<br/> yourItemSuite := &amp;youItemMysqlTestSuite{<br/>  MysqlSuite{<br/>   DSN:                     dsn,<br/>   MigrationLocationFolder: "migrations",<br/>  },<br/> }</span><span id="7c1f" class="lp lq in ne b gy nn nk l nl nm">suite.Run(t, yourItemSuite)<br/>}</span></pre><p id="0747" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">至少，这个包已经做了样板文件，比如设置迁移(如果使用迁移的话)或者处理测试套件设置，这将帮助您更快地工作。:D</p><p id="42f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，在像我们一样实现您自己的集成测试之前，需要理解<code class="fe nb nc nd ne b">testify/suite</code>是如何工作的。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="b9b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再一次，正如我在本文开始时所说的，这是我们如何在我们的公司<a class="ae ks" href="https://kurio.co.id" rel="noopener ugc nofollow" target="_blank"> Kurio </a>(写这篇文章时我现在的公司)进行集成测试的。如果你有任何更好的想法，如果你能在下面的评论中告诉我，我会很高兴的。但是如果你发现这非常有用，请与任何可能需要它的人分享。^_^</p></div></div>    
</body>
</html>