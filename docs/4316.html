<html>
<head>
<title>Enforcing Team Rules with Lint: Detectors 🕵️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Lint执行团队规则:🕵️探测器</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/enforcing-team-rules-with-lint-detectors-%EF%B8%8F-ccd30739229?source=collection_archive---------2-----------------------#2020-11-19">https://medium.com/google-developer-experts/enforcing-team-rules-with-lint-detectors-%EF%B8%8F-ccd30739229?source=collection_archive---------2-----------------------#2020-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/08aa938cb4542d01dde54c4a8e9f15ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2bkjCzDklPH04Ip"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@f7photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Longmire</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bfd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">几个月前，我的团队达成了一项协议，当在代码中的任何地方留下一个TODO时，我们需要始终提供几样东西:</p><ul class=""><li id="afb2" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">应该处理待办事项的人</li><li id="5dc0" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">离开待办事项的日期</li><li id="6818" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">关于需要做什么的评论或解释</li></ul><p id="4adf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我创建了一个<a class="ae it" href="https://zarah.dev/2020/03/06/live-templates.html" rel="noopener ugc nofollow" target="_blank">实时模板</a>来支持遵守这条规则，但是为什么不更进一步，将这条规则集成到我们的日常工作流程中呢？</p><p id="3797" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我们建立在我们已经开始的的<a class="ae it" href="https://zarah.dev/2020/11/18/todo-lint.html" rel="noopener ugc nofollow" target="_blank">基础之上。</a></p><p id="90cf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经设置好了模块，我们可以开始编写检测器了。</p><p id="25f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如<a class="ae it" href="https://zarah.dev/2020/11/18/todo-lint.html" rel="noopener ugc nofollow" target="_blank">之前提到的</a>，探测器为我们的定制规则做了大量的工作。为此，它必须发挥几个作用:</p><ul class=""><li id="f9f6" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">寻找相关的位置</li><li id="bbe7" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">在这些位置查找问题(如果有)</li><li id="343c" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">向用户报告任何发现的问题</li><li id="b1dd" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">如果可能，建议问题的修复方法</li></ul><p id="675b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将依次了解这些角色。</p><h1 id="ba29" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接受皮棉🏛</h1><p id="3f48" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在我们深入研究检测器之前，理解一点Lint术语是有用的。我花了很长时间才明白，这真的很令人沮丧。说根本没有文档不是骗人的，没有一个地方我可以链接到。这里的很多信息都是我从所有关于Lint的演讲、帖子和数小时的研究中拼凑出来的。</p><p id="ad52" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在处理探测器时，大多数事情都涉及到称为UAST或PSI的东西。为了便于说明，让我们从弗洛里纳·芒特内斯库的要点中选取这个样本文件:</p><h2 id="bc23" class="lj kh hh bd ki lk ll lm km ln lo lp kq jf lq lr ku jj ls lt ky jn lu lv lc lw bi translated">磅/平方英寸(pounds per square inch)</h2><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="2a29" class="lj kh hh mc b fi mg mh l mi mj">package com.zdominguez.sdksandbox<br/><br/>/*<br/> * Copyright (C) 2018 The Android Open Source Project<br/> *<br/> * Licensed under the Apache License, Version 2.0 (the "License");<br/> * you may not use this file except in compliance with the License.<br/> * You may obtain a copy of the License at<br/> *<br/> *      http://www.apache.org/licenses/LICENSE-2.0<br/> *<br/> * Unless required by applicable law or agreed to in writing, software<br/> * distributed under the License is distributed on an "AS IS" BASIS,<br/> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/> * See the License for the specific language governing permissions and<br/> * limitations under the License.<br/> */<br/><br/>import android.graphics.Typeface<br/>import android.text.TextPaint<br/>import android.text.style.MetricAffectingSpan<br/><br/>/**<br/> * Span that changes the typeface of the text used to the one provided. The style set before will<br/> * be kept.<br/> */<br/>open class CustomTypefaceSpan(private val font: Typeface?) : MetricAffectingSpan() {<br/><br/>    override fun updateMeasureState(textPaint: TextPaint) = update(textPaint)<br/><br/>    override fun updateDrawState(textPaint: TextPaint) = update(textPaint)<br/><br/>    private fun update(textPaint: TextPaint) {<br/>        textPaint.apply {<br/>            val old = typeface<br/>            val oldStyle = old?.style ?: 0<br/><br/>            // keep the style set before<br/>            val font = Typeface.create(font, oldStyle)<br/>            typeface = font<br/>        }<br/>    }<br/>}</span></pre><p id="80ee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">PSI或<strong class="iw hi">P</strong>program<strong class="iw hi">S</strong>structure<strong class="iw hi">I</strong>interface,<a class="ae it" href="https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi.html" rel="noopener ugc nofollow" target="_blank">传统上由IntelliJ </a>用来通过<em class="mk">元素</em>对源文件进行建模。PsiViewer插件在帮助你形象化这意味着什么方面非常有用。</p><p id="f348" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我喜欢把PSI看作文件的蓝图。它显示了每一个元素，包括空格和括号(它甚至可以告诉你是左括号还是右括号！)</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/e5e158039a154aeee6be3da99ce0af67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1v6L9aRkhuz29PZP.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">PSI for the `CustomTypefaceSpan` Kotlin file</figcaption></figure><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/62b8fc5219c47a15c6ef79886f925422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8h7B1WL4X0ylyNqS.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">PSI for an XML file</figcaption></figure><h2 id="6270" class="lj kh hh bd ki lk ll lm km ln lo lp kq jf lq lr ku jj ls lt ky jn lu lv lc lw bi translated">UAST</h2><p id="204f" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">UAST是由Jetbrains创建的，用来描述Java和Kotlin语法树。一个<a class="ae it" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">语法树</a>显示了我们代码的层次结构，说明了代码将通过<em class="mk">节点</em>遵循的所有规则和构造。</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/12629b3f0dc79ea63e860b261617c576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Of80cnb3dl4ZBNs.jpg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Partial UAST for the `CustomTypefaceSpan` Kotlin file</figcaption></figure><p id="5a04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在处理UAST时，我们并不真的关心我们看到的是Java文件还是Kotlin文件。相反，我们在代码中看到了逻辑分支。</p><h2 id="f774" class="lj kh hh bd ki lk ll lm km ln lo lp kq jf lq lr ku jj ls lt ky jn lu lv lc lw bi translated">PSI vs UAST</h2><p id="84a2" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我花了一段时间来理解这些概念，最后我用宜家的比喻来理解它。UAST就像你在目录上看到的照片。它描述了家具是什么——一个带白色拉钮的抽屉柜，一个搁板，还有一种特殊的门。另一方面，PSI就像是家具的组装说明。拿这块木板，在这里装一个螺丝，在那里装一个螺栓。</p><h1 id="7cbe" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">继续吧，扎拉</h1><p id="053c" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">让我们继续制作我们的探测器:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="b274" class="lj kh hh mc b fi mg mh l mi mj">import com.android.tools.lint.detector.api.Detector<br/><br/>@Suppress("UnstableApiUsage")<br/>class TodoDetector : Detector() {<br/>}</span></pre><p id="d1f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du mo mp mq mc b">Detector</code>是所有检测器的基类。它被标记为<code class="du mo mp mq mc b">@Beta</code>，所以我在那里添加了<code class="du mo mp mq mc b">@Suppress</code>注释来确认，是的，我知道这可能会中断。</p><p id="d6c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du mo mp mq mc b">Detector</code>非常通用(除了<code class="du mo mp mq mc b"><a class="ae it" href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-api/src/main/java/com/android/tools/lint/detector/api/ResourceXmlDetector.java" rel="noopener ugc nofollow" target="_blank">ResourceXmlDetector</a></code>)，如果我们能够指出我们需要什么特定的检测器，我们可以从Lint中得到更多。根据我们需要在什么类型的事物上运行我们的规则，我们可以使用一些专门的接口:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="7e44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">出于TODO检测器的目的，我们需要实现<code class="du mo mp mq mc b">SourceCodeScanner</code>接口，因为我们想查看Java和Kotlin文件:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="d3a8" class="lj kh hh mc b fi mg mh l mi mj">@Suppress("UnstableApiUsage")<br/>class TodoDetector : Detector(), SourceCodeScanner {<br/><br/>}</span></pre><h1 id="d251" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">具体来说</h1><p id="da2c" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">还有一个术语，大多数关于Lint的演讲都提到了很多，那就是“访问”。我还没有看到这个术语的确切定义，但据我所知，这就是我们所说的Lint到达特定UAST节点或PSI元素的行为。</p><p id="f0d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着，如果我们想要查看某个方法的用法，我们需要“访问”方法并弄清楚那里是否存在问题。如果我们想编写一个规则来检查布局文件中的约束，那么我们可能需要“访问”XML属性和值。</p><p id="70f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，在Lint中有一种适当的方式来具体说明我们希望访问哪些位置。为此，提供了几种方法。请注意，大多数<strong class="iw hi">和</strong>都以<code class="du mo mp mq mc b">get</code>开头，但并不是所有的都以<code class="du mo mp mq mc b">get</code>开头。😅</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/94664c571f72f0d490cb3b01bf5a5941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_odtamYZQ3i5gqXn.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Available getApplicable* methods</figcaption></figure><p id="4b3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不管我们的检测器实现哪种类型的<code class="du mo mp mq mc b">*Scanner</code>接口，所有这些方法都是可用的，因为它们都在基类<code class="du mo mp mq mc b">Detector()</code>中。我们需要确保至少实现这些方法中的一个，以向Lint发出信号，表明我们关心这些位置。</p><p id="4655" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们想看看评论，最适合我们用例的是<code class="du mo mp mq mc b">getApplicableUastTypes()</code>。</p><p id="55ae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们需要指定我们要寻找哪种特定的UAST节点。有一种UAST型，听起来正是我们需要的类型。</p><p id="f396" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是有一点需要注意——如果我们查看样本文件生成的UAST，<code class="du mo mp mq mc b">UComment</code>根本就没有出现！然而，我们<em class="mk">确实</em>通过PsiViewer看到了一个<code class="du mo mp mq mc b"><a class="ae it" href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-4682003011bb42ffdb872d081e79d300bb393d17/platform/core-api/src/com/intellij/psi/PsiComment.java" rel="noopener ugc nofollow" target="_blank">PsiComment</a></code>存在。</p><p id="16ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们向后(向上)穿越UAST？)，我们最终到达了<code class="du mo mp mq mc b">UFile</code>，它包含了一个注释可能存在的所有地方。太好了，让我们继续使用它作为我们关心的UAST类型。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="e9cb" class="lj kh hh mc b fi mg mh l mi mj">@Suppress("UnstableApiUsage")<br/>class TodoDetector : Detector(), SourceCodeScanner {<br/>    override fun getApplicableUastTypes(): List&lt;Class&lt;out UElement&gt;&gt; {<br/>        return listOf(UFile::class.java)<br/>    }<br/>}</span></pre><h1 id="86cb" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接收回调</h1><p id="aeb2" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">既然我们已经告诉Lint我们关心什么样的位置，我们需要告诉它让我们知道它是否遇到那个位置。</p><p id="01c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，我们有许多选择。注意<strong class="iw hi">他们中的大部分</strong>都是以<code class="du mo mp mq mc b">visit</code>开头，但不是所有的都是。😅 😅</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/3b773592178f92b503a376e9b80c266f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vFmGB1CxerGwFFTE.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Available visit*** methods</figcaption></figure><p id="7e5a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，从名字来看，这些都不符合我们的需求。既然我们选择了我们关心的UAST类型，我们需要的实际上叫做<code class="du mo mp mq mc b"><a class="ae it" href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-api/src/main/java/com/android/tools/lint/detector/api/Detector.kt;l=543;drc=7465b820deacf7e7acc4e93d5f73a73633b7bfcb" rel="noopener ugc nofollow" target="_blank">createUastHandler()</a></code>。我们的下一个任务是创建这个处理程序:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="2f06" class="lj kh hh mc b fi mg mh l mi mj">override fun createUastHandler(context: JavaContext): UElementHandler {<br/>    return TodoScanner(context)<br/>}</span></pre><h2 id="96b9" class="lj kh hh bd ki lk ll lm km ln lo lp kq jf lq lr ku jj ls lt ky jn lu lv lc lw bi translated">一个非常重要的旁注🛑</h2><p id="66d3" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">记住每个<code class="du mo mp mq mc b">getApplicable*</code>方法映射到一个相应的<code class="du mo mp mq mc b">visit*</code>方法是很重要的。</p><p id="9852" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们以Lint 上的<a class="ae it" href="https://youtu.be/jCmJWOkjbM0?t=734" rel="noopener ugc nofollow" target="_blank"> ADS 2019演讲为例。我们想创建一个规则，防止用户在应用程序的任何地方调用<code class="du mo mp mq mc b">Log.wtf()</code>。在其中，它们覆盖了<code class="du mo mp mq mc b">getApplicableMethodNames()</code>，因此要覆盖的相应回调方法是<code class="du mo mp mq mc b">visitMethodCall()</code>。</a></p><p id="a2b7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类似地，如果我们想查看XML属性，我们可以覆盖<code class="du mo mp mq mc b">getApplicableAttributes()</code>和相应的<code class="du mo mp mq mc b">visitAttribute()</code>回调。亚历克斯·洛克伍德在这个样本项目中展示了这一点。</p><p id="b7cf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">再次检查你是否使用了正确的组合是非常重要的，因为Lint不会告诉你是否使用了错误的组合(也就是说，一切仍然可以编译)。我没有找到任何关于<code class="du mo mp mq mc b">getApplicable*</code>对<code class="du mo mp mq mc b">visit*</code>的映射的文档，但这是我从实验中收集到的:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h1 id="70db" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实现扫描仪</h1><p id="c349" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我觉得理解<code class="du mo mp mq mc b">get*</code>和<code class="du mo mp mq mc b">visit*</code>方法之间的关系是值得的，因为在实现我们的处理程序时，同样的原则也适用。</p><p id="e01c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们定义我们的检测器时，我们告诉Lint我们想要观察UAST类型的<code class="du mo mp mq mc b">UFile</code>，因此我们必须在我们的扫描器中实现适当的回调:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="13e5" class="lj kh hh mc b fi mg mh l mi mj">class TodoScanner(private val context: JavaContext) : UElementHandler() {<br/><br/>    override fun visitFile(node: UFile) {<br/>        <br/>    }<br/>}</span></pre><p id="dc39" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们在<code class="du mo mp mq mc b">getApplicableUastTypes()</code>中提供的每个UAST类型，我们也应该有相应的<code class="du mo mp mq mc b">visit*</code>实现。我不会在这里列举它们，因为✨有很多✨，但是这次Lint实际上帮助了你！</p><p id="98b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，如果我们说:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="2456" class="lj kh hh mc b fi mg mh l mi mj">override fun getApplicableUastTypes(): List&lt;Class&lt;out UElement&gt;&gt; {<br/>    return listOf(UMethod::class.java, UClass::class.java, UFile::class.java)<br/>}</span></pre><p id="c69f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要在扫描仪中实现<code class="du mo mp mq mc b">visitMethod</code>、<code class="du mo mp mq mc b">visitClass</code>和<code class="du mo mp mq mc b">visitFile</code>。如果Lint遇到了特定的UAST类型，但找不到合适的回调，它会在运行时告诉您。</p><p id="944c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你和我一样不知道可能的U值是多少或者文件的UAST是什么样子，那么在这一点上想出该怎么做是很有挑战性的。不幸的是，据我所知没有UastViewer，探索这个领域的唯一方法是通过传统的方式。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="f2c7" class="lj kh hh mc b fi mg mh l mi mj">override fun visitFile(node: UFile) {<br/>    val nodesString = node.asRecursiveLogString()<br/>    println(nodesString)<br/>}</span></pre><p id="5f8b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将为您提供一个字符串，其中包含正在分析的文件的完整UAST结构。</p><h1 id="40d9" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">找茬</h1><p id="8782" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">现在，我们对正在发生的事情有了更好的理解，让我们继续实现我们的扫描器的灵魂:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="38a8" class="lj kh hh mc b fi mg mh l mi mj">override fun visitFile(node: UFile) {<br/><br/>    val allComments = node.allCommentsInFile<br/>    allComments.forEach { comment -&gt;<br/>        val commentText = comment.text<br/><br/>        // Ignore regular comments that are not TODOs<br/>        // If we find a TODO that does not follow the convention, show an error<br/>        if (commentText.contains("TODO", ignoreCase = true) &amp;&amp; !isValidComment(<br/>                commentText)) {<br/>            reportUsage(context, comment)<br/>        }<br/>    }<br/>}</span></pre><p id="d604" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du mo mp mq mc b">isValid</code>方法检查评论是否遵循我们的团队规则:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="537d" class="lj kh hh mc b fi mg mh l mi mj">private fun isValidComment(commentText: String): Boolean {<br/>    val regex = Regex("//\\s+TODO-\\w*\\s+\\(\\d{8}\\):.*")<br/>    return commentText.matches(regex)<br/>}</span></pre><p id="b697" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果没有，请将此报告为问题。</p><h1 id="0cd9" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">负责任的报道📢</h1><p id="dd89" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">当我们发现一个违反合同的评论时，我们希望给用户一个清晰的定义，告诉他们哪里出了问题，如何解决问题。</p><p id="b54c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还记得我们在上一篇文章中谈到的<a class="ae it" href="https://zarah.dev/2020/11/18/todo-lint.html" rel="noopener ugc nofollow" target="_blank">的剖析吗？让我们用这些知识来定义我们的问题:</a></p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="ea22" class="lj kh hh mc b fi mg mh l mi mj">val ISSUE: Issue = Issue.create(<br/>    id = "UnassignedTodo",<br/>    briefDescription = "TODO with no assignee",<br/>    explanation =<br/>    """<br/>        This check makes sure that each TODO is assigned to somebody.<br/>    """.trimIndent(),<br/>    category = Category.CORRECTNESS,<br/>    priority = 3,<br/>    severity = Severity.ERROR,<br/>    implementation = IMPLEMENTATION<br/>)</span></pre><p id="62ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du mo mp mq mc b">Issue.create()</code>需要的最后一个参数是<code class="du mo mp mq mc b"><a class="ae it" href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-api/src/main/java/com/android/tools/lint/detector/api/Implementation.java" rel="noopener ugc nofollow" target="_blank">Implementation</a></code>，它将报告的问题与负责发现该问题的检测器进行映射。</p><p id="e852" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个<code class="du mo mp mq mc b">Implementation</code>需要一个——它告诉Lint我们的实现对什么类型的文件感兴趣。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="6c1f" class="lj kh hh mc b fi mg mh l mi mj">private val IMPLEMENTATION = Implementation(<br/>    TodoDetector::class.java,<br/>    Scope.JAVA_FILE_SCOPE<br/>)</span></pre><p id="9a75" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个命名确实有误导性，但是<code class="du mo mp mq mc b">JAVA_FILE_SCOPE</code>意味着在运行Lint时，Java和Kotlin文件都将被考虑到我们的规则中。</p><p id="faa0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着在我们实施的这个阶段，这些信息需要兼容是绝对关键的:</p><p id="dc99" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✔️:我们为探测器实现的接口</p><p id="8753" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✔️被覆盖的<code class="du mo mp mq mc b">getApplicable*</code>方法</p><p id="215f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✔️被覆盖的<code class="du mo mp mq mc b">visit*</code>方法</p><p id="10cf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✔️(因为我们使用UAST类型)在我们的<code class="du mo mp mq mc b">UElementHandler</code>中覆盖了<code class="du mo mp mq mc b">visit*</code>方法</p><p id="fcfc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✔️<code class="du mo mp mq mc b">Scope</code>问题的落实</p><h1 id="49ae" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">我朋友的一点帮助</h1><p id="202b" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">通过帮助用户解决问题，我们可以帮助他们从我们的自定义Lint规则中获得更多价值。Lint允许我们提供一个quickfix选项，用户可以按SHIFT+ALT+ENTER(或者ALT+ENTER然后ENTER)并应用我们提出的更改。</p><p id="101e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们的检测器，我们希望正确格式化注释。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="60af" class="lj kh hh mc b fi mg mh l mi mj">// TODO This is an improperly formatted comment</span></pre><p id="6a78" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">像上面这样的注释会被我们的检测器标记为格式不正确(记住我们寻找的是<code class="du mo mp mq mc b">TODO</code>字符串)。要修复它，我们需要添加用户名和今天的日期。幸运的是，这让我们很容易做到:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="d583" class="lj kh hh mc b fi mg mh l mi mj">// Look for the instance of the "TODO" literal<br/>val oldPattern = Regex("TODO|todo")<br/><br/>// Our proposed fix concatenates the user's name<br/>// and today's date in the correct format<br/>val replacementText = "TODO-${System.getProperty("user.name")} " +<br/>    "(${<br/>        LocalDate.now()<br/>            .format(DateTimeFormatter.ofPattern("yyyyMMdd"))<br/>    }):"<br/><br/>val quickfixData = LintFix.create()<br/>    .name("Assign this TODO")<br/>    .replace()<br/>    .pattern(oldPattern.pattern)<br/>    .with(replacementText)<br/>    .robot(true) // Can be applied automatically.<br/>    .independent(true) // Does not conflict with other auto-fixes.<br/>    .build()</span></pre><p id="7ae4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经创建了问题、实现和quickfix，剩下的惟一事情就是告诉Lint在哪里指出遇到了问题。提供准确的位置很重要，因为这将告诉ide在哪里显示错误:</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/1f3558169db00f4b8024188924010302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dNJS_DUVkKI_o_Hm.png"/></div></div></figure><p id="383a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以及在Lint报告中的何处放置红色曲线:</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/a384d25f6afc4434e8ec353aa7570ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4QfyCbYfpjT6gCq2.png"/></div></div></figure><p id="5d12" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于这条规则，我可以突出显示完整的注释。我们现在可以完成我们的<code class="du mo mp mq mc b">reportUsage</code>方法了:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="d993" class="lj kh hh mc b fi mg mh l mi mj">private fun reportUsage(<br/>    context: JavaContext,<br/>    comment: UComment<br/>) {<br/>    context.report(<br/>        issue = Companion.ISSUE,<br/>        location = context.getLocation(comment),<br/>        message = "Please make sure to assign the TODO, include today's date in YYYYMMDD format, and the comment is properly formatted.",<br/>        quickfixData = quickfixData<br/>    )<br/>}</span></pre><p id="3449" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们终于完成了我们的探测器！💪</p><p id="2ea1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这真是一场彻头彻尾的头脑风暴。编写我的第一个Lint规则确实是一个挑战，有一段时间我确实盯着屏幕周期性地对着任何人大喊大叫。好在我们都在家工作。😅</p><p id="9110" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列的下一篇文章中，我们将编写一些测试，如果一切顺利，我们将实际使用我们的检测器！敬请期待！</p></div><div class="ab cl mw mx go my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ha hb hc hd he"><p id="e3a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mk">原载于2020年11月19日</em><a class="ae it" href="https://zarah.dev/2020/11/19/todo-detector.html" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://zarah . dev</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>