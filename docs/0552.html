<html>
<head>
<title>Structural Class Redefinition and Apply Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">结构类重定义和应用更改</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/structural-class-redefinition-and-apply-changes-30f96f1962e6?source=collection_archive---------0-----------------------#2020-09-01">https://medium.com/androiddevelopers/structural-class-redefinition-and-apply-changes-30f96f1962e6?source=collection_archive---------0-----------------------#2020-09-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/9831dc74d3995e1e89eefd2526678c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoG3UDdyctBPR6vMFhHMag.png"/></div></div></figure><div class=""/><h1 id="84b3" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">简介</strong></h1><p id="3d6b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">应用更改是Android Studio中的一个功能，<a class="ae kl" rel="noopener" href="/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd">我们在Android Studio 3.5 </a>中引入了该功能，以帮助您快速迭代您对应用程序所做的更改。应用变更依赖于<a class="ae kl" href="https://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html" rel="noopener ugc nofollow" target="_blank"> JVMTI API </a>来指导以这种方式可以应用什么变更。在Android 11中，Android运行时(ART)向JVMTI API引入了一个名为<a class="ae kl" rel="noopener" href="/androiddevelopers/structural-class-redefinition-6fc0cbab9161">的结构类重定义</a>的扩展。这个扩展为在开发中利用Android 11设备应用更改开辟了一个用例类别。更复杂的编辑现在可以在应用程序仍在运行时通过应用更改快速部署。这包括:</p><ul class=""><li id="0ddd" class="km kn hs jp b jq ko ju kp jy kq kc kr kg ks kk kt ku kv kw bi translated">添加方法(Android Studio 4.1)</li><li id="871b" class="km kn hs jp b jq kx ju ky jy kz kc la kg lb kk kt ku kv kw bi translated">添加资源文件(Android Studio 4.2)</li><li id="7d22" class="km kn hs jp b jq kx ju ky jy kz kc la kg lb kk kt ku kv kw bi translated">添加静态字段(Android Studio 4.2)</li></ul><p id="c504" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">这使您可以减少开发期间的周转时间，并最大限度地提高生产率。在本帖中，我们将探索我们如何在Android Studio中实现这一点。</p><h1 id="2b42" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak"> Android Studio实现</strong></h1><p id="b09e" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">通过自动利用新的特性和功能，Apply Changes从一开始就被设计为随着Android运行时的每次新迭代而不断发展。</p><p id="5403" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">在结构化类重定义的情况下，添加了方法的类被发送到ART，这与之前的Android版本没有什么不同。添加了一个新的API入口点，因此您需要将Android Studio升级到4.1版或更高版本，以便动态地利用静态和虚拟的添加方法。</p><p id="d4fd" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">然而，添加变量需要在Android Studio中进行新的分析。当一个新的变量被添加时，ART并不试图决定应该赋予它什么值。(敬请关注未来关于ART的结构类重定义实现细节的Medium博客)。相反，添加的变量将只被初始化为默认的原始值或null，这将由Android Studio来决定它应该如何初始化。</p><p id="48ee" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">这个过程是不平凡的。考虑这样一种情况，向一个类添加一个静态long y，初始赋值发生在类加载期间。考虑一下这个:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="f541" class="lo iq hs lk b fi lp lq l lr ls">public class example {</span><span id="5dde" class="lo iq hs lk b fi lt lq l lr ls">   public final static long x = System.currentTimeMillis();</span><span id="8292" class="lo iq hs lk b fi lt lq l lr ls">   public final static long y = System.currentTimeMillis();</span><span id="df9b" class="lo iq hs lk b fi lt lq l lr ls">}</span></pre><p id="7766" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">如果加载这个类，<code class="du lu lv lw lk b">x</code>和<code class="du lu lv lw lk b">y</code>的值应该非常接近。在添加<code class="du lu lv lw lk b">y</code>作为应用代码变更调用的情况下，<code class="du lu lv lw lk b">y</code>的正确值不容易计算。事实上，<code class="du lu lv lw lk b">y</code>的值应该分配给什么是有争议的，因为它最接近地模仿了<code class="du lu lv lw lk b">y</code>被初始化的程序，在那里类被加载。由于两个<code class="du lu lv lw lk b">currentTimeMillis()</code>都是在静态初始化(<code class="du lu lv lw lk b">&lt;clinit&gt;</code>方法)期间被调用的，应用更改将继续遵循不重新运行<code class="du lu lv lw lk b">&lt;clinit&gt;</code>方法的任何部分的策略。因此，增加值y将获得值0。</p><p id="7402" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">幸运的是，Apply Changes <a class="ae kl" rel="noopener" href="/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd">已经使用D8进行DEX文件分析</a>，作为该过程的一部分，在最新版本的Android Studio中，Apply Changes能够利用D8新引入的<a class="ae kl" href="https://r8.googlesource.com/r8/+/refs/heads/master/src/main/java/com/android/tools/r8/inspector/" rel="noopener ugc nofollow" target="_blank"> Inspector </a> API。这个轻量级检查API能够计算一些额外的信息，作为DEX比较过程的一部分，只增加很少的开销(只检查更改的Java类)。关于新添加的变量的一组元信息被附加到将改变应用到设备的请求ProtoBuf。</p><p id="5070" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">在设备上，在Android Studio将我们的更改传达给VM之前，Java代理会检查当前加载的要替换的类。通过比较即将被替换的类和新编译的类的字段，计算新添加的字段列表和它们各自的初始值。然后，代理会暂时挂起所有其他线程，以防止线程在执行交换之前访问任何新添加的未初始化字段。如果交换请求成功，它将使用适当的变量初始化新添加的字段。</p><h1 id="64a5" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">限制和即将推出的功能</strong></h1><p id="9ce9" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">截至Android Studio 4.2 Canary 3，该特性仅在添加了新的静态原语的情况下可用。作为副产品，这有助于在R.class中添加值，使Apply Changes能够添加新资源。</p><p id="490b" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">有一点要记住，那就是应用更改的所有用法都是正确的:程序的语义永远不会与您重新构建和重新启动程序的语义相同。想想构造函数被改变的情况；用旧构造函数构造的对象不会被重新构造。这也适用于静态变量，因为<code class="du lu lv lw lk b">&lt;clinits&gt;</code>不会被重新调用。</p><p id="bfc6" class="pw-post-body-paragraph jn jo hs jp b jq ko js jt ju kp jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">我们希望每个人都能够利用Android Studio的这一新功能来提高工作效率。一如既往，我们欢迎每个人在我们的<a class="ae kl" href="https://issuetracker.google.com/issues/new?component=192708" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>中为我们提供关于应用更改的反馈，并让我们知道您希望看到哪些改进。</p></div></div>    
</body>
</html>