<html>
<head>
<title>Don’t argue with default arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要争论默认的论点</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/dont-argue-with-default-arguments-2245b2c752c?source=collection_archive---------0-----------------------#2020-10-08">https://medium.com/androiddevelopers/dont-argue-with-default-arguments-2245b2c752c?source=collection_archive---------0-----------------------#2020-10-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1f064469350b2336414178de85f7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0QJqxE7mPdvAWzGCdat6g.png"/></div></div></figure><div class=""/><p id="06ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">科特林词汇</em></p><p id="4a22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简短易用的默认参数允许你在没有样板文件的情况下实现函数重载。像许多Kotlin功能一样，这感觉像是魔术。你想知道它的秘密吗？请继续阅读，了解默认参数是如何工作的。</p><h1 id="27ec" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">基本用法</h1><p id="ccf9" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">如果需要重载一个函数，可以使用默认参数，而不是多次实现同一个函数:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="608e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认参数也可以应用于构造函数:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="3ee7" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Java互操作</h1><p id="c64d" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">缺省情况下，Java不识别缺省值重载:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="08dd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要指示编译器生成重载方法，请在Kotlin函数上使用<code class="du ky kz la lb b"><a class="ae jo" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/" rel="noopener ugc nofollow" target="_blank">@JvmOverloads</a></code>注释:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="045d" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在后台</h1><p id="c562" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">让我们看看Java反编译的代码，看看编译器为我们生成了什么:<code class="du ky kz la lb b">Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode</code>然后按下<code class="du ky kz la lb b">Decompile</code>按钮。</p><h2 id="e60c" class="lc jq hs bd jr ld le lf jv lg lh li jz ja lj lk kd je ll lm kh ji ln lo kl lp bi translated">功能</h2><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="99e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到编译器生成了两个函数:</p><ul class=""><li id="bc0a" class="lq lr hs ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><code class="du ky kz la lb b">play</code> —有1个参数:<code class="du ky kz la lb b">Toy</code>，在不使用默认参数时调用</li><li id="76d4" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">合成方法<code class="du ky kz la lb b">play$default</code>——有3个参数:<code class="du ky kz la lb b">Toy</code>、一个<code class="du ky kz la lb b">int</code>和一个<code class="du ky kz la lb b">Object</code>；每当使用默认参数时都会调用它。<code class="du ky kz la lb b">Object</code>参数总是<code class="du ky kz la lb b">null</code>，但是int的值不同。让我们看看如何！</li></ul><h2 id="e552" class="lc jq hs bd jr ld le lf jv lg lh li jz ja lj lk kd je ll lm kh ji ln lo kl lp bi translated">int参数</h2><p id="0dea" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated"><code class="du ky kz la lb b">play$default</code>的int参数的值是根据传入了默认参数的参数的编号和索引来计算的。根据这个参数的值，Kotlin编译器知道用哪个参数来调用play函数。</p><p id="f2dd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的<code class="du ky kz la lb b">play()</code>示例调用中，索引0处的参数使用默认参数。因此，<code class="du ky kz la lb b">play$default</code>用<code class="du ky kz la lb b">int var1 = 2⁰</code>来称呼:</p><pre class="ks kt ku kv fd me lb mf mg aw mh bi"><span id="9c95" class="lc jq hs lb b fi mi mj l mk ml">play$default((Toy)null, 1, (Object)null);</span></pre><p id="5aa6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ky kz la lb b">play$default</code>实现知道<code class="du ky kz la lb b">var0</code>的值应该被替换为默认值。</p><p id="b17f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们举一个更复杂的例子来看看int参数的行为。让我们扩展我们的<code class="du ky kz la lb b">play</code>函数，在调用点，使用<code class="du ky kz la lb b">doggo</code>和<code class="du ky kz la lb b">toy</code>的默认参数:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="fd06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看反编译代码中发生了什么:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="fc1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在看到，我们的int参数是5。这是如何计算的:位置0和2处的参数使用默认参数so <code class="du ky kz la lb b">var3 = 2⁰ + 2² = 5</code>。在<a class="ae jo" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" rel="noopener ugc nofollow" target="_blank">按位</a> <code class="du ky kz la lb b"><a class="ae jo" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" rel="noopener ugc nofollow" target="_blank">&amp;</a></code> <a class="ae jo" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" rel="noopener ugc nofollow" target="_blank">运算</a>中，参数的计算如下:</p><ul class=""><li id="fc29" class="lq lr hs ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><code class="du ky kz la lb b">var3 &amp; 1 != 0</code>是<code class="du ky kz la lb b">true</code>所以<code class="du ky kz la lb b">var0 = goodDoggo</code></li><li id="0394" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><code class="du ky kz la lb b">var3 &amp; 2 != 0</code>是<code class="du ky kz la lb b">false</code>，所以<code class="du ky kz la lb b">var1</code>不被替换</li><li id="0892" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><code class="du ky kz la lb b">var3 &amp; 4 != 0</code>是<code class="du ky kz la lb b">true</code>所以<code class="du ky kz la lb b">var2 = SqueakyToy</code></li></ul><p id="4229" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据应用于<code class="du ky kz la lb b">var3</code>的位掩码，编译器可以计算哪些参数应该替换为默认值。</p><h1 id="cb13" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">对象参数</h1><p id="3397" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在上面的例子中，你可能已经注意到<code class="du ky kz la lb b">Object</code>参数的值总是空的，并且它实际上从来没有在<code class="du ky kz la lb b">play$default</code>函数中使用过。此参数与支持覆盖函数中的默认值有关。</p><h1 id="7289" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">默认参数和继承</h1><p id="55a6" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">当我们想用默认参数覆盖一个函数时会发生什么？</p><p id="2dd6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们改变上面的例子:</p><ul class=""><li id="8e67" class="lq lr hs ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated">使<code class="du ky kz la lb b">play</code>成为<code class="du ky kz la lb b">Doggo</code>的<code class="du ky kz la lb b">open</code>函数，使<code class="du ky kz la lb b">Doggo</code>成为<code class="du ky kz la lb b">open</code>类。</li><li id="ef0b" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">创建一个新的<code class="du ky kz la lb b">PlayfulDoggo</code>类，扩展<code class="du ky kz la lb b">Doggo</code>并覆盖<code class="du ky kz la lb b">play</code></li></ul><p id="26e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们想在PlayfulDoggo.play中设置一个默认值时，我们看到我们不被允许:<strong class="ir ht">一个覆盖函数不被允许为它的参数指定默认值</strong></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8018" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们删除<code class="du ky kz la lb b">override</code>并检查反编译的代码，<code class="du ky kz la lb b">PlayfulDoggo.play()</code>看起来像这样:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="7cb1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是否意味着未来将支持带有默认参数的超级调用？我们只能等着瞧了。</p><h1 id="029a" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构造器</h1><p id="1efc" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">对于构造函数来说，反编译的Java代码只有一个区别。让我们来看看:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1c43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构造函数也创建一个合成方法，但是构造函数使用一个用<code class="du ky kz la lb b">null</code>调用的<code class="du ky kz la lb b"><a class="ae jo" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/DefaultConstructorMarker.java" rel="noopener ugc nofollow" target="_blank">DefaultConstructorMarker</a></code>，而不是函数中使用的<code class="du ky kz la lb b">Object</code>:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="aa97" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与主构造函数一样，带有默认参数的次构造函数也将使用<code class="du ky kz la lb b">DefaultConstructorMarker</code>生成另一个合成方法:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><h1 id="daed" class="jp jq hs bd jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki mx kk kl km bi translated">结论</h1><p id="5bdf" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">简单而有趣的是，默认参数减少了我们在处理重载方法时需要编写的样板代码的数量，允许我们为参数设置默认值。正如许多Kotlin关键字的情况一样，when可以通过查看它为我们编写的代码来了解它们的魔力。查看我们的其他Kotlin词汇帖子了解更多。</p></div></div>    
</body>
</html>