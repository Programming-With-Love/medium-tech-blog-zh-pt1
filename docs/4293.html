<html>
<head>
<title>Android MVI architecture with Jetpack &amp; Coroutines/Flow — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Jetpack和协程/流的Android MVI架构—第3部分</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-3-5ef0c0960ce9?source=collection_archive---------4-----------------------#2020-05-02">https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-3-5ef0c0960ce9?source=collection_archive---------4-----------------------#2020-05-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="a5b4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建协同程序/流授权用例</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c5a43b23e3dcc86567e2e2a362a99274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STrvjUFZAADmmxfcYMTb8g.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae js" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jt ju jv"><p id="c139" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">如果您没有读过这些系列的前几篇文章，您可以在这里找到它们:</p><p id="a844" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated"><a class="ae js" rel="noopener" href="/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-1-recyclerview-adapter-w-83a10134207f">第1部分—具有ViewBinding的RecyclerView适配器</a></p><p id="cf7d" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated"><a class="ae js" rel="noopener" href="/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-2-bc1f3cb1dd2d">第2部分—在MVI架构中创建视图模型</a></p></blockquote><blockquote class="kv"><p id="dab4" class="kw kx hh bd ky kz la lb lc ld le ku dx translated">在本文中，我们将看到如何创建将在我们的视图模型中使用的不同类型的用例。</p></blockquote></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h1 id="566f" class="ie if hh bd ig ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb bi translated">什么是用例？</h1><blockquote class="jt ju jv"><p id="2b93" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">一个<strong class="jz hi">用例</strong>是通常定义角色(在<a class="ae js" href="https://en.wikipedia.org/wiki/Unified_Modeling_Language" rel="noopener ugc nofollow" target="_blank">统一建模语言</a> (UML)中称为<a class="ae js" href="https://en.wikipedia.org/wiki/Actor_(UML)" rel="noopener ugc nofollow" target="_blank"> <em class="hh">参与者</em> </a>)和系统之间交互的动作或事件步骤列表，以实现一个目标。参与者可以是人或其他外部系统。在系统工程中，用例在比<a class="ae js" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a>更高的层次上使用，通常代表使命或<a class="ae js" href="https://en.wikipedia.org/wiki/Project_stakeholder" rel="noopener ugc nofollow" target="_blank">利益相关者</a>的目标。然后，详细的需求可能被捕获在<a class="ae js" href="https://en.wikipedia.org/wiki/Systems_Modeling_Language" rel="noopener ugc nofollow" target="_blank">系统建模语言</a> (SysML)中，或者作为契约声明。</p></blockquote><p id="685c" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">这是维基百科<a class="ae js" href="https://en.wikipedia.org/wiki/Use_case" rel="noopener ugc nofollow" target="_blank">这里</a>提供的定义。</p><blockquote class="kv"><p id="911b" class="kw kx hh bd ky kz lu lv lw lx ly ku dx translated">但是在我们的项目中，什么是真正的用例呢？</p></blockquote><p id="1953" class="pw-post-body-paragraph jw jx hh jz b ka lz kc kd ke ma kg kh lr mb kk kl ls mc ko kp lt md ks kt ku ha bi translated">在许多应用程序中，我们的业务逻辑的某些部分涉及到几个本地或远程资源的协调，以便实现一个目标。</p><p id="2414" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">例如，每当我们进行API调用来获取Github存储库的信息时，我们也希望存储这些信息或者更新这些信息，以防我们已经存储了这个Github存储库的信息。这是一个可以从应用程序中的几个地方触发的业务流。</p><p id="7bea" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">由于这种需要，我们只需编写一次，并单独测试该组件:)</p><h1 id="8656" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">输入用例</h1><p id="d734" class="pw-post-body-paragraph jw jx hh jz b ka me kc kd ke mf kg kh lr mg kk kl ls mh ko kp lt mi ks kt ku ha bi translated">我们的<strong class="jz hi">用例</strong>例子深受克里斯·班斯的《TIVI <a class="ae js" href="https://github.com/chrisbanes/tivi" rel="noopener ugc nofollow" target="_blank">回购</a>的影响。</p><h2 id="44e8" class="mj if hh bd ig mk ml mm ik mn mo mp io lr mq mr is ls ms mt iw lt mu mv ja mw bi translated">FlowUseCase</h2><p id="31e3" class="pw-post-body-paragraph jw jx hh jz b ka me kc kd ke mf kg kh lr mg kk kl ls mh ko kp lt mi ks kt ku ha bi translated">每当我们有可观察的/可流动的结果(例如:数据库变化)时，我们都希望以<code class="du mx my mz na b">Flow&lt;T&gt;</code>的形式扩展<strong class="jz hi"> FlowUseCase </strong>。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="5a5f" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">我们这里的抽象类实现了定义属性和方法的<code class="du mx my mz na b">ObservableUseCase&lt;T&gt;</code>。</p><ul class=""><li id="7cd3" class="nd ne hh jz b ka kb ke kf lr nf ls ng lt nh ku ni nj nk nl bi translated"><code class="du mx my mz na b">dispatcher</code>是Kotlin协程调度程序，我们将使用它来执行用例的工作。通常，对于网络或数据库操作，这可以是<code class="du mx my mz na b">Dispatchers.IO</code>,或者如果我们想要执行CPU密集型任务，这可以是<code class="du mx my mz na b">Dispatchers.Default</code>。</li><li id="2cdd" class="nd ne hh jz b ka nm ke nn lr no ls np lt nq ku ni nj nk nl bi translated"><code class="du mx my mz na b">observe</code>是将返回一个包含用例操作结果的<code class="du mx my mz na b">Flow&lt;T&gt;</code>的方法。</li></ul><p id="2891" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated"><code class="du mx my mz na b">FlowUseCase&lt;Params: Any, Type : Any&gt;</code>抽象类包含一个接受<code class="du mx my mz na b">Params</code>类型的通道。<code class="du mx my mz na b">Params</code>可以是我们的用例需要的任何类型的数据，以便执行它的动作并产生结果。</p><p id="9db2" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">正如我们在这里看到的，<code class="du mx my mz na b">invoke</code>操作符被覆盖，以便将<code class="du mx my mz na b">Params</code>输入发送到我们的内部通道。</p><p id="4a45" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">然后，通道被转换为<code class="du mx my mz na b">Flow</code>并被<code class="du mx my mz na b">flatMap</code>d，以便执行产生<code class="du mx my mz na b">Flow&lt;T&gt;</code>结果的方法，该结果为<code class="du mx my mz na b">doWork(Params)</code>。</p></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h2 id="7a1f" class="mj if hh bd ig mk ml mm ik mn mo mp io lr mq mr is ls ms mt iw lt mu mv ja mw bi translated">NoResultUseCase</h2><p id="fc55" class="pw-post-body-paragraph jw jx hh jz b ka me kc kd ke mf kg kh lr mg kk kl ls mh ko kp lt mi ks kt ku ha bi translated">每当我们想执行一个动作而不关心任务的实际成功或失败时，我们都想扩展<strong class="jz hi"> NoResultUseCase </strong>，因为它可能对我们的业务逻辑不重要，或者不会影响我们的用户。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="1405" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">在这个<strong class="jz hi">用例</strong>中，我们需要做的就是根据我们之前的解释，提供最适合我们需求的<code class="du mx my mz na b">Dispatcher</code>。然后，它将把协程上下文切换到那个<code class="du mx my mz na b">Dispatcher</code>并执行在<code class="du mx my mz na b">run</code>方法中给出的任何动作。</p></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h2 id="f020" class="mj if hh bd ig mk ml mm ik mn mo mp io lr mq mr is ls ms mt iw lt mu mv ja mw bi translated">结果用例</h2><p id="0d96" class="pw-post-body-paragraph jw jx hh jz b ka me kc kd ke mf kg kh lr mg kk kl ls mh ko kp lt mi ks kt ku ha bi translated">每当我们有一个想要执行的动作时，我们都想要扩展<strong class="jz hi"> ResultUseCase </strong>，但是我们实际上关心它的结果。这可能是因为我们的产品还需要进行错误处理，或者通知用户操作没有成功完成。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="e7b8" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">如前所述，我们需要指出我们希望用例使用的<code class="du mx my mz na b">Dispatcher</code>。这里我们的<code class="du mx my mz na b">run</code>方法有一个返回类型。在我们的例子中，这种类型是<code class="du mx my mz na b">Result</code>，它可以有两种不同的形式。可以是<code class="du mx my mz na b">Success</code>也可以是<code class="du mx my mz na b">Failure</code>。通常我们可以用一个密封的类创建一个非常简单的<code class="du mx my mz na b">Result</code>类，但是通常这是基于项目的需要。</p><h1 id="a0d7" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="ffe4" class="pw-post-body-paragraph jw jx hh jz b ka me kc kd ke mf kg kh lr mg kk kl ls mh ko kp lt mi ks kt ku ha bi translated">上面的基本用例类通常足以满足我们的项目需求，但是就像我常说的“视情况而定”。在后面的文章中，我们还将探索孤立地测试我们的用例是多么容易。</p><p id="905c" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lr kj kk kl ls kn ko kp lt kr ks kt ku ha bi translated">您可以在下面的repo中找到上面的所有代码以及它们的用法示例，这也是我们将在这一系列文章中讨论的内容！</p><div class="nr ns ez fb nt nu"><a href="https://github.com/pavlospt/refactored-umbrella" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hi fi z dy nz ea eb oa ed ef hg bi translated">pavlospt/重构-雨伞</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">重构的保护伞是一个附带项目，以检查与科特林协同程序和流量，MVVM和Koin现代Android开发…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jm nu"/></div></div></a></div></div></div>    
</body>
</html>