<html>
<head>
<title>A Deep Dive into Airbnb’s Server-Driven UI System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Airbnb的服务器驱动的用户界面系统</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/a-deep-dive-into-airbnbs-server-driven-ui-system-842244c5f5?source=collection_archive---------0-----------------------#2021-06-29">https://medium.com/airbnb-engineering/a-deep-dive-into-airbnbs-server-driven-ui-system-842244c5f5?source=collection_archive---------0-----------------------#2021-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="08af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Airbnb如何使用名为Ghost Platform的服务器驱动的用户界面系统在web、iOS和Android之间更快地发布功能👻。</p><p id="6840" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">瑞安·布鲁克斯</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f52f17f394c963137f7512a33f8e0e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CedYKpSYMIGEiX7m"/></div></div></figure><h2 id="f7ab" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">背景:服务器驱动的用户界面</h2><p id="ab11" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">在我们深入研究Airbnb的服务器驱动UI (SDUI)实现之前，理解SDUI的总体思想以及它如何提供优于传统客户端驱动UI的优势是很重要的。</p><p id="879f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在传统世界中，数据由后端驱动，UI由每个客户端(web、iOS和Android)驱动。以Airbnb的房源页面为例。为了向用户显示列表，我们可能会从后端请求列表数据。收到这个列表数据后，客户机将该数据转换成UI。</p><p id="e8d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这带来了一些问题。首先，在每个客户机上构建了特定于列表的逻辑来转换和呈现列表数据。如果我们改变列表的显示方式，这种逻辑会很快变得复杂并且不灵活。</p><p id="7ae8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二，每个客户必须保持对等。如前所述，这个屏幕的逻辑很快变得复杂，每个客户端都有自己的复杂性和处理状态、显示UI等的特定实现。客户之间很容易迅速产生分歧。</p><p id="7fbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，移动有一个版本问题。每次我们需要向列表页面添加新功能时，我们都需要发布新版本的移动应用程序，以便用户获得最新的体验。在用户更新之前，我们几乎没有办法确定用户是否在使用这些新功能，或者对这些新功能的反应是否良好。</p><h2 id="77f6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">SDUI的案例</h2><p id="0f6a" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">如果客户不需要知道他们正在展示一个列表，那会怎么样？如果我们可以将UI直接传递给客户端，完全跳过列出数据的想法，会怎么样？这基本上就是SDUI所做的——我们一起传递UI和数据，客户端显示它所包含的数据。</p><p id="edc4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Airbnb的特定SDUI实现使我们的后端能够控制数据以及这些数据如何同时在所有客户端上显示。从屏幕布局、各部分在布局中的排列方式、每个部分中显示的数据，甚至用户与各部分交互时采取的行动，都由我们的web、iOS和Android应用程序的单一后端响应控制。</p><h1 id="159d" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">Airbnb的SDUI:幽灵平台👻</h1><p id="990c" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">Ghost Platform (GP)是一个统一的、自以为是的、服务器驱动的UI系统，使我们能够快速迭代，并在web、iOS和Android上安全地推出功能。它之所以被称为Ghost，是因为我们的主要关注点是围绕'<strong class="ig hi"> G </strong> uest '和'<strong class="ig hi"> Host </strong>的功能，这是我们Airbnb应用程序的两个方面。</p><p id="9dee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP以每个客户端的本地语言(分别是Typescript、Swift和Kotlin)提供web、iOS和Android框架，使开发人员能够以最少的设置创建服务器驱动的功能。</p><p id="24d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP的核心特性是特性可以共享一个通用部分、布局和动作的库，许多是向后兼容的，使团队能够更快地将复杂的业务逻辑转移到后端的一个中心位置。</p><h2 id="0067" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">标准化的模式</h2><p id="b484" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">Ghost平台的主干是一个标准化的数据模型，客户端可以使用它来呈现UI。为了使这成为可能，GP利用一个统一的数据服务网格，在后端服务之间使用一个共享数据层，这个网格被称为<a class="ae jc" rel="noopener" href="/airbnb-engineering/taming-service-oriented-architecture-using-a-data-oriented-service-mesh-da771a841344">高架桥</a>。</p><p id="9d70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">帮助我们使我们的服务器驱动的UI系统可伸缩的关键决策是为Web、iOS和Android应用程序使用单个共享的GraphQL模式——也就是说，我们在所有平台上使用相同的模式来处理响应和生成强类型数据模型。</p><p id="b5ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们花时间归纳了不同功能的共同方面，并以一致、周到的方式考虑了每个页面的特性。结果是一个通用模式，能够在Airbnb上呈现所有功能。这个模式足够强大，可以考虑可重用的部分、动态布局、子页面、动作等等，我们的客户端应用程序中相应的GP框架利用这个通用模式来标准化UI呈现。</p><h1 id="ec8b" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">全科医生的反应</h1><p id="23c5" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">政府采购的第一个基本方面是总体反应的结构。有两个主要概念用于描述GP响应中的UI:sections和screens。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/f86c43f20d38ea985f5a297d492364b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qx23_meafmhc7-xQ"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 1. <em class="ll">How users see Airbnb features on GP vs. how GP sees those same features as screens and sections.</em></figcaption></figure><ul class=""><li id="2b17" class="lm ln hh ig b ih ii il im ip lo it lp ix lq jb lr ls lt lu bi translated"><strong class="ig hi">切片:</strong>切片是GP最原始的积木。一个部分描述一组内聚的UI组件的数据，包含要显示的确切数据—已经翻译、本地化和格式化。每个客户端获取部分数据，并将其直接转换为UI。</li><li id="c921" class="lm ln hh ig b ih lv il lw ip lx it ly ix lz jb lr ls lt lu bi translated"><strong class="ig hi">屏幕:</strong>任何GP响应都可以有任意数量的屏幕。每个屏幕描述了屏幕的布局，并依次描述了来自<code class="du ma mb mc md b">sections</code>数组的部分将出现的位置(称为位置)。它还定义了其他元数据，例如如何呈现部分(例如，作为弹出窗口、模式或全屏)以及记录数据。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 2. A sample of the GP Response GraphQL schema.</figcaption></figure><p id="3e9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用GP构建的特性后端将实现这个<code class="du ma mb mc md b">GPResponse</code>(图2)，并根据它们的用例填充屏幕和部分。web、iOS和Android上的GP客户端框架为开发人员提供了获取<code class="du ma mb mc md b">GPResponse</code>实现并将其转化为UI的标准处理方式，他们只需做最少的工作。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><h1 id="7940" class="kp jq hh bd jr kq mn ks jv kt mo kv jz kw mp ky kc kz mq lb kf lc mr le ki lf bi translated">部分</h1><p id="8416" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">节是GP的最基本的构件。GP部分的关键特征是它们完全独立于其他部分和显示它们的屏幕。</p><p id="79eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过将部分从它们周围的上下文中分离出来，我们获得了重用和重用部分的能力，而不用担心业务逻辑与任何特定功能之间的紧密耦合。</p><h2 id="2396" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">区段模式</h2><p id="138f" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">在GraphQL模式中，GP节是所有可能的节类型的联合。每个部分类型指定它们提供的要呈现的字段。在一个带有一些元数据的<code class="du ma mb mc md b">GPResponse</code>实现中接收节，并通过一个<code class="du ma mb mc md b">SectionContainer</code>包装器提供，该包装器包含关于节的状态、日志数据和实际节数据模型的细节。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Figure 3. A snippet of what our section GraphQL schema</em></figcaption></figure><p id="70c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个需要触及的重要概念是<code class="du ma mb mc md b">SectionComponentType</code>。<code class="du ma mb mc md b">SectionComponentType</code>控制<em class="ms">如何呈现</em>一个部分的数据模型。这使得一个数据模型可以根据需要以多种不同的方式呈现。</p><p id="82be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，两个<code class="du ma mb mc md b">SectionComponentType</code>的<code class="du ma mb mc md b">TITLE</code>和<code class="du ma mb mc md b">PLUS_TITLE</code>可能使用相同的后台<code class="du ma mb mc md b">TitleSection</code>数据模型，但是<code class="du ma mb mc md b">PLUS_TITLE</code>实现将使用Airbnb的特定于Plus的徽标和标题样式来呈现<code class="du ma mb mc md b">TitleSection</code>。这为使用GP的特性提供了灵活性，同时还提高了模式和数据的可重用性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/d9b410a2b960bdd60da0880e6fe8b26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i-Mi5mngBjWXQkFk"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 4. <em class="ll">Example of rendering a TitleSection data model differently using SectionComponentType.</em></figcaption></figure><h2 id="07cc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">截面组件</h2><p id="f8d0" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">截面数据通过“截面组件”转化为UI。每个section组件负责将一个数据模型和一个<code class="du ma mb mc md b">SectionComponentType</code>转换成UI组件。抽象节组件由GP在每个平台上以其本地语言(即Typescript、Swift、Kotlin)提供，并且可以由开发者扩展以创建新的节。</p><p id="4b04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">截面组件将截面数据模型映射到<strong class="ig hi">一个</strong>唯一的渲染，因此只属于一个<code class="du ma mb mc md b">SectionComponentType</code>。如前所述，部分是在没有它们所在的屏幕或它们周围的部分的任何上下文的情况下呈现的，因此每个部分组件都没有提供特定于功能的业务逻辑。</p><p id="1d84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我是一名Android开发人员，所以让我们举一个Android的例子(因为Kotlin很棒😄).为了构建标题部分，我们有如下所示的代码片段(图5)。Web和iOS有类似的实现——分别在Typescript和Swift中——用于构建section组件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 5. A Kotlin example of a section component.</figcaption></figure><p id="8805" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP提供了许多“核心”部分组件，比如我们上面的例子<code class="du ma mb mc md b">TitleSectionComponent</code>(图5)，它是可配置的、可样式化的，并且从后端向后兼容，因此我们可以适应任何特性的用例。然而，在GP上构建新特性的开发人员可以根据需要添加新的section组件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/3ecf68abbdfe9657684152c10f4e2fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8jjmsp_zOQfl0-Q8"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 6. <em class="ll">GP takes section data, uses a section component to turn it into UI (TitleSectionComponent from fig. 5), and presents the built section UI to the user.</em></figcaption></figure></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><h1 id="c3ce" class="kp jq hh bd jr kq mn ks jv kt mo kv jz kw mp ky kc kz mq lb kf lc mr le ki lf bi translated">屏幕</h1><p id="c926" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">屏幕是GP的另一个构建块，但与部分不同，屏幕主要由GP客户端框架处理，并且在使用中更加固执己见。GP屏幕负责各部分的布局和组织。</p><h2 id="5bb3" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">屏幕模式</h2><p id="d7bf" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">屏幕作为<code class="du ma mb mc md b">ScreenContainer</code>类型接收。根据<code class="du ma mb mc md b">screenProperties</code>字段中包含的值，屏幕可以以模式(弹出)、底部表单或全屏方式启动。</p><p id="7219" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">屏幕支持屏幕布局的动态配置，进而通过<code class="du ma mb mc md b">LayoutsPerFormFactor</code>类型安排各部分。<code class="du ma mb mc md b">LayoutsPerFormFactor</code>使用名为<code class="du ma mb mc md b">ILayout</code>的接口指定紧凑和宽断点的布局，这将在下面详述。然后，每个客户端上的GP框架使用屏幕密度、旋转和其他因素来确定从<code class="du ma mb mc md b">LayoutsPerFormFactor</code>中呈现哪个<code class="du ma mb mc md b">ILayout</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 7. A sample of the GP screens schema.</figcaption></figure><h2 id="d9ee" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">ILayouts</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/43ddd2f752d65d54620968e75b366203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSJJB0hlGHrzSlu6"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 8. <em class="ll">A few examples of ILayout implementations, which are used to specify various placements.</em></figcaption></figure><p id="4ce6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使屏幕能够根据响应改变布局。在schema中，<code class="du ma mb mc md b">ILayout</code>是一个接口，每个<code class="du ma mb mc md b">ILayout</code>实现指定不同的位置。位置包含一个或多个<code class="du ma mb mc md b">SectionDetail</code>类型，指向响应的最外层<code class="du ma mb mc md b">sections</code>数组中的部分。我们指向部分数据模型，而不是内联包含它们。这通过跨布局配置重用部分来缩小响应大小(图7中的<code class="du ma mb mc md b">LayoutsPerFormFactor</code>)。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 9. <em class="ll">A sample of GP’s ILayout schema.</em></figcaption></figure><p id="21a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP客户端框架为开发人员膨胀了<code class="du ma mb mc md b">ILayout</code> s，因为<code class="du ma mb mc md b">ILayout</code>类型比部分更固执己见。每个<code class="du ma mb mc md b">ILayout</code>在每个客户端的GP框架中都有一个唯一的渲染器。布局呈现器从每个布局中提取每个<code class="du ma mb mc md b">SectionDetail</code>，找到适当的部分组件来呈现该部分，使用该部分组件构建该部分的UI，最后将构建的UI放置到布局中。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><h1 id="f2f7" class="kp jq hh bd jr kq mn ks jv kt mo kv jz kw mp ky kc kz mq lb kf lc mr le ki lf bi translated">行动</h1><p id="165f" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">GP的最后一个概念是我们的动作和事件处理基础设施。GP最能改变游戏规则的一个方面是，除了从网络响应中定义屏幕的部分和布局，我们还可以定义用户在屏幕上与UI交互时采取的动作，比如点击按钮或刷卡。我们通过模式中的一个<code class="du ma mb mc md b">IAction</code>接口来实现这一点。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Figure 10. A sample of the GP IAction schema:</em></figcaption></figure><p id="e48d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回想一下前面的内容(图6 ), section组件是在每个客户端上将我们的<code class="du ma mb mc md b">TitleSection</code>转换为UI的组件。让我们看看同一个Android例子，一个动态的<code class="du ma mb mc md b">IAction</code>在点击字幕文本时被触发。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 11. An example section component with an IAction fired on the click of a subtitle.</figcaption></figure><p id="094a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当用户点击这个部分的副标题时，它触发为<code class="du ma mb mc md b">TitleSection</code>中的<code class="du ma mb mc md b">onSubtitleClickAction</code>字段传递的<code class="du ma mb mc md b">IAction</code>。GP负责将这个动作传递给为该特性定义的事件处理程序，它将处理被触发的<code class="du ma mb mc md b">IAction</code>。</p><p id="3fb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP有一套通用的标准动作，比如导航到一个屏幕或者滚动到一个部分。特性可以添加自己的<code class="du ma mb mc md b">IAction</code>类型，并使用它们来处理特性的独特动作。由于特定于功能的事件处理程序的作用范围仅限于该功能，因此它们可以包含任意多的特定于功能的业务逻辑，从而在出现特定用例时可以自由地使用自定义操作和业务逻辑。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><h1 id="7fde" class="kp jq hh bd jr kq mn ks jv kt mo kv jz kw mp ky kc kz mq lb kf lc mr le ki lf bi translated">将这一切结合在一起</h1><p id="1800" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">我们已经讨论了几个概念，所以让我们来看一个完整的GP响应，看看它是如何将所有内容联系在一起的。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 12. An example JSON of a valid GP response.</figcaption></figure><h2 id="3c2f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">创建剖面组件</h2><p id="421f" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">使用GP的特性将需要获取实现上述<code class="du ma mb mc md b">GPResponse </code>的响应(图2)。在接收到<code class="du ma mb mc md b">GPResponse</code>之后，GP infra处理解析这个响应并为开发人员构建部分。</p><p id="5146" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回想一下，我们的<code class="du ma mb mc md b">sections</code>数组中的每个部分都有一个<code class="du ma mb mc md b">SectionComponentType</code>和一个<code class="du ma mb mc md b">section</code>数据模型。从事GP工作的开发人员添加截面组件，使用<code class="du ma mb mc md b">SectionComponentType</code>作为如何呈现截面数据模型的关键。</p><p id="12f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GP找到每个section组件，并将相应的数据模型传递给它。每个section组件为section创建UI组件，GP会将这些组件插入到下面布局中的适当位置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/172841142fff15376821dc3a4ec1b3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2SLVYciGoKNbdau6"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 13. <em class="ll">Transforming section data to UI.</em></figcaption></figure><h2 id="2e18" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">处理行动</h2><p id="efaf" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">既然已经设置了每个部分组件的UI元素，我们需要处理用户与部分的交互。例如，如果他们点击一个按钮，我们需要处理点击时的动作。</p><p id="90f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回想一下，GP将路由事件处理到适当的处理程序。上面的示例响应(图12)包含两个可以触发动作的部分，<code class="du ma mb mc md b">toolbar_section</code>和<code class="du ma mb mc md b">book_bar_footer</code>。构建这两个部分的部分组件只需要获取<code class="du ma mb mc md b">IAction</code>并指定何时触发它，在这两种情况下都是在单击按钮时。</p><p id="8d63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以通过每个客户端上的点击处理程序来实现这一点，它将使用GP infra来路由点击事件。</p><pre class="je jf jg jh fd mt md mu mv aw mw bi"><span id="85c3" class="jp jq hh md b fi mx my l mz na">button(<br/>  onClickListener = {<br/>    GPActionHandler.handleIAction(section.button.onClickAction)<br/>  }<br/>)</span></pre><h2 id="8e1f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">设置屏幕和布局</h2><p id="cf4e" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">为了给我们的用户安排一个完全交互式的屏幕，GP通过屏幕数组寻找一个带有<code class="du ma mb mc md b">“ROOT”</code> id (GP的默认屏幕id)的屏幕。GP将根据断点和其他与用户使用的特定设备相关的因素找到合适的<code class="du ma mb mc md b">ILayout</code>类型。为了简单起见，我们将使用来自<code class="du ma mb mc md b">compact</code>字段的布局，即<code class="du ma mb mc md b">SingleColumnLayout</code>。</p><p id="ae53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后GP将为<code class="du ma mb mc md b">SingleColumnLayout</code>找到一个布局渲染器，在这里它将膨胀一个带有顶部容器(<code class="du ma mb mc md b">nav</code>位置)、可滚动列表(<code class="du ma mb mc md b">main</code>位置)和浮动页脚(<code class="du ma mb mc md b">footer</code>位置)的布局。</p><p id="234c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该布局渲染器将获取包含<code class="du ma mb mc md b">SectionDetail</code>对象的放置模型。这些<code class="du ma mb mc md b">SectionDetail</code>包含一些样式信息以及要膨胀部分的<code class="du ma mb mc md b">sectionId</code>。GP将遍历这些<code class="du ma mb mc md b">SectionDetail</code>对象，并使用我们之前构建的section组件将section膨胀到它们各自的位置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/172ccfaa11e6bf5c507a072002b13b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8mJWV_F1FPq0U5eI"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Figure 14. <em class="ll">GP Infra takes built sections with action handlers added, adds sections to ILayout placements.</em></figcaption></figure></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><h1 id="0f12" class="kp jq hh bd jr kq mn ks jv kt mo kv jz kw mp ky kc kz mq lb kf lc mr le ki lf bi translated">GP的下一步是什么？</h1><p id="b041" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">GP只存在了一年左右，但Airbnb大多数最常用的功能(例如，搜索、列表页面、结账)都是基于GP的。尽管有大量的应用，GP仍处于起步阶段，还有很多工作要做。</p><p id="e247" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们计划通过“嵌套部分”实现更具可组合性的UI，通过我们的设计工具(如Figma和部分和位置的WYSIWYG编辑)提高已经存在的元素的可发现性，从而实现无代码功能更改。</p><p id="c24c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你热衷于服务器驱动的UI或者构建可扩展的UI系统，那么还有很多事情要做。我们鼓励您申请我们工程团队的<a class="ae jc" href="https://careers.airbnb.com/" rel="noopener ugc nofollow" target="_blank">空缺职位</a>。</p><h2 id="d4dd" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">再造旅游科技讲座</h2><p id="9604" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">服务器驱动的用户界面很复杂。无数的时间投入到创建一个健壮的模式、客户机框架和开发人员文档中，使得GP能够成功。</p><p id="b5ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想对SDUI和GP有一个更高层次的概述，我最近有机会在Airbnb举办的<a class="ae jc" href="https://www.facebook.com/AirbnbTech/videos/1445539065813160/" rel="noopener ugc nofollow" target="_blank">再造旅行技术讲座</a>上发言。我鼓励你去看看它，对服务器驱动的UI和GP有一个总体的了解(如果你时间不够，可以跳到31分钟)。</p><h2 id="3233" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">特别感谢</h2><p id="eeb2" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">特别感谢<a class="ae jc" href="https://www.linkedin.com/in/abhinavvohra/" rel="noopener ugc nofollow" target="_blank">阿布希·沃赫拉</a>、<a class="ae jc" href="https://www.linkedin.com/in/wensheng-mao-76ab7142/" rel="noopener ugc nofollow" target="_blank">文圣·毛</a>、<a class="ae jc" href="https://www.linkedin.com/in/jnvollmer/" rel="noopener ugc nofollow" target="_blank">让-尼古拉斯·沃尔默</a>、<a class="ae jc" href="https://www.linkedin.com/in/pranayairan/" rel="noopener ugc nofollow" target="_blank">普拉内·艾兰</a>、<a class="ae jc" href="https://www.linkedin.com/in/stephen-herring-00381a6a/" rel="noopener ugc nofollow" target="_blank">斯蒂芬·赫林</a>、<a class="ae jc" href="https://www.linkedin.com/in/jsperl/" rel="noopener ugc nofollow" target="_blank">刘以豪</a>、<a class="ae jc" href="https://www.linkedin.com/in/kevinchrisweber/" rel="noopener ugc nofollow" target="_blank">凯文·韦伯</a>、<a class="ae jc" href="https://www.linkedin.com/in/rodolphe-courtier-97b32610/" rel="noopener ugc nofollow" target="_blank">鲁道夫·库蒂</a>、<a class="ae jc" href="https://www.linkedin.com/in/danielgarciacarrillo/" rel="noopener ugc nofollow" target="_blank">丹尼尔·加西亚-卡里略</a>、<a class="ae jc" href="https://www.linkedin.com/in/fidelsosa/" rel="noopener ugc nofollow" target="_blank">菲德尔·索萨</a>、<a class="ae jc" href="https://www.linkedin.com/in/roshan-goli-03977a25/" rel="noopener ugc nofollow" target="_blank"> </a><a class="ae jc" href="https://www.linkedin.com/in/rsusandang/" rel="noopener ugc nofollow" target="_blank"> Susan Dang </a>和<a class="ae jc" href="https://www.linkedin.com/in/amitywang/" rel="noopener ugc nofollow" target="_blank"> Amity Wang </a>以及更多幕后工作人员，感谢他们不知疲倦地建设和支持GP。</p></div></div>    
</body>
</html>