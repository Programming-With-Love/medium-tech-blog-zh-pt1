# Terraform 代码质量

> 原文：<https://medium.com/version-1/terraform-code-quality-87872892d7bb?source=collection_archive---------0----------------------->

![](img/d137848d57193b941b8fd0ad782ce121.png)

Terraform 就像任何其他的编码语言一样，你应该为你的产品有代码质量和自豪感。在这篇文章中，我想描述为什么你应该有代码质量，并详细说明你每次编写代码时应该坚持做的一些方面。

代码质量就像你在学开车一样。你不为自己指明，你为别人指明，所以他们知道你在做什么，你要去哪里。你的代码也是一样，因为它应该很容易理解，其他开发人员也能理解产生了什么。将基础设施作为代码，这不仅将质量扩展到您的代码，而且它将产生的资源将具有连续性和一致性，产品的管理员也可以理解它。

这不是你应该只为生产准备工作做的事情，你应该在你的概念证明甚至学习项目中包含代码质量，它创造习惯和惯例，所以它们成为第二天性。

以下是我在编写代码时采用的一些格式和组织方法，你可能会发现在编写 Terraform 代码时采用这些方法是有益的。

# 文件

虽然有了 Terraform，你可以随意命名文件，但是你应该有一个命名文件的结构和模式。它可以让每个读者了解他们需要去哪里找到他们需要的东西，而不必在文件中搜寻。以下是我经常使用的标准文件，它可以确保你始终保持基本的一致性。除了这些文件之外，您创建什么文件通常取决于您的公司/团队标准。

## 主要的

“main.tf”文件是一个标准的命名文件，即使是 Hashicorp 在他们的例子中也使用它，所以作为代码之旅的起点是很好的。有了这个文件作为起点，所有其他开发人员自然会转到这个文件来查看资源从哪里开始。我没有像你在小项目中做的那样把所有东西都放在这个文件中，相反，它通常包含模板化的“局部”变量。这些可以是资源前缀、环境名操作或者将变量转换成布尔值。我可能还会有一些共享的数据资源，甚至还有一个资源组(这对于 Azure 是行得通的，因为所有的资源都倾向于存在于一个资源组中)。基本上，所有的人工制品将跨其他文件使用，并为读者提供他们需要的基本信息。

## 提供者

罐头上写着“providers.tf”。它包含了所有的提供者，他们的版本和他们定制的特性。在这个文件中，这些应该只被引用一次，这样版本控制就可以顺流而下，而不会导致与其他提供者的依赖问题。

## 变量

“variables.tf”应该只包含 variables 属性，而不包含局部变量或模块。这保持了它的干净和文件的单一目的。

## 输出

对于您想要输出的资源属性，可能有一个“output.tf”文件，但是您应该只输出数据，即使在必要时它并不敏感。您输出的信息越少，资源就越安全，因此您可以将该文件视为可选文件。

## Tfvars

我喜欢将这些文件放在一个名为“environments”的文件夹中(下面会详细介绍)，然后用环境名来调用每个文件，例如“dev.tfvars”。然后，您还可以拥有一个用于本地测试和工作的“local.tfvars”文件。

## 推翻

“override.tf”文件是您将从 git 存储库中排除的东西(通过。gitignore)来避免签入敏感数据。这可以是您配置远程状态以进行计划测试的地方，而不需要将值添加到签入的文件中或通过 CLI。

# 文件夹和文件模式

这些往往是由你的项目、公司的规模和公司内部的限制决定的。对于有很多独立项目的大公司，标准的方法是在他们自己的存储库中有一个共享模块的集合。这使得灵活和可配置的模块在整个公司保持一定的标准。你应该确保模块有足够大的用途，否则你可能会创建很多模块而影响很小。我举的一个例子是一个数据库，你要为它创建服务器、用户、安全、网络，可能还有数据库本身，拥有一个模块是有意义的。

对于较小的公司或项目，创建模块可能没有意义，因为为了最小的影响需要太多的维护工作。例如，对于一个小型的单一产品公司，这意味着对数据库的一个更改将导致多个存储库的更改。但是，您可以通过将模块放在本地来保持这种可维护的灵活模式。为此，我建议有一个名为“模块”的父文件夹，然后如果你有多个像 Azure 和 AWS 这样的提供商，为他们每个人创建一个文件夹。如果您没有像这样的多个不同的提供者，那么只需将它保持在模块文件夹级别。在这里，您可以为每个模块添加一个文件夹，并根据用途对其进行命名，其中包含 Terraform 文件，如下所示。

示例:

```
> modules 
>> azure 
>>> postgresSql 
>>>> main.tf 
>>>> output.tf 
>>>> variables.tf
```

有些人更喜欢不使用模块，然后让根目录中的所有东西都是平面的。这并不是一件坏事，但是你仍然需要给读者一个旅程，使查找资源更容易，并且在文件中没有非常大的地形内容。一贯的做法是将您的资源分成多个文件，这样每个文件都有自己的用途。取决于文件中的内容有多大，取决于你把它分成多少部分。例如，如果您刚刚创建了 2 个存储帐户，那么您可以将它们保存在一个文件中，但是如果您有一个虚拟网络和多个子网，那么您可能希望将它们拆分到更多文件中。

标准的做法是将这些文件放入根目录，并根据它们的资源进行命名，但是我觉得这种做法没有对文件进行排序，因为它会将它们按字母顺序排列，导致文件处于随机顺序。为了解决这个问题，我看到人们在文件名前加上数字，所以他们创建了一个顺序。

示例:

```
00-main.tf 
01-variables.tf 
02-storage-account.tf
```

这样做的一个挑战是，如果您现在想在 00 和 01 之间添加一个文件，您需要重命名所有下面的文件，这会导致大量的工作和痛苦。

我的首选方法是使用一种模式，通过在所有资源文件前加上“tf”前缀，将所有资源放在一个组中。然后，我在它后面加上资源的首字母缩略词和资源根文件的“main ”,例如密钥库的“tf-kv-main.tf”。如果我想为证书生成添加另一个文件，我会将其命名为“tf-kv-cert.tf”。这导致所有的资源文件保存在一起，随后将每个相关的资源保存在一起，并指示每个文件做什么。

示例:

```
main.tf 
tf-kv-main.tf 
tf-kv-cert.tf
```

**变量**

我经常觉得变量被忽略了，因为写代码的人知道它们是什么，它们有什么用，Terraform 会为它们处理很多事情。但是你需要确保的是，当其他人来看你的变量时，他们能够理解它们。

命名是关键，变量应该有一个描述性的名字，这样如果你在文件中看到它们，你就知道它是什么和它的用途。他们应该是小写，使用下划线，并有一个名称模式。我更喜欢在名称前面加上资源类型，然后是变量名。例如，存储帐户名称可以是“存储帐户名称”，或者更简洁地说是“sa 名称”。

资源类型是一种被忽略的类型，因为 Terraform 可以并且将会解释您推入的数据，但是有必要对此进行描述，以便读者知道它是什么类型以及如何扩展它，特别是如果它是一个对象或对象列表的话。我见过没有添加类型的变量，然后与我可以传递它的类型进行斗争，然后将对数据使用不同的函数进行下游工作，如 count vs for_each。

描述不必是战争与和平，但它们需要给出一个简单的、人类可读的文本来说明资源的用途，此外，您还可以添加对资源有帮助的信息，比如有限的值。如果与 TerraDoc 之类的工具一起使用，效果会更好，TerraDoc 将使用这些描述为您的项目生成一个自述文件。

条件需要做一些工作，但它们也可以使以后的生活变得更容易，因为它们可以确保用户不会输入不工作的值，或者你不想让他们使用的值。这方面的一个很好的例子是 Azure 中的 SKU 资源价值。您不仅可能希望将字符串类型限制为与有效 SKU 匹配的特定值，还可能希望限制可以使用哪些 SKU。这可以验证用户只使用了您想要的 SKU，而无需他们不断尝试失败或为管理员创建资源来告诉他们重新构建它。

```
variable "mysql_sku_name" { 
   type = string 
   description = "MySQL Server SKU. Limited Values are B_Gen4_1, B_Gen4_2, B_Gen5_1, B_Gen5_2" 
   default = "B_Gen4_1" 
   validation { 
      condition = contains(["B_Gen4_1", "B_Gen4_2", "B_Gen5_1", "B_Gen5_2"], var.mysql_sku_name) 
      error_message = "MySQL Server SKU are limited to B_Gen4_1, B_Gen4_2, B_Gen5_1, B_Gen5_2." 
   } 
}
```

# 资源

这是关于每个文件中的一般资源。每个文件都应该有一个模式，以及每个资源如何连接的流程。

我总是把局部变量放在最上面，这样它们很容易归档，而且大多数时候当你使用这些变量时，它们是在为下面的资源设置数据。接下来应该是你的资源，从父母开始，一直到孩子。例如，您从储物账户开始，然后进入储物容器，这样就有了一个流程，从大盒子开始，向下到适合它们的盒子。

Terraform 资源和部署的资源的命名应该与变量相同。应该有一个模式，有一致性和惯例。Terraform 资源应该是小写的，使用下划线作为分隔符，并且它们的名称有目的。资源名称已经由提供程序和资源组成，因此您不应该在自定义名称中重复它。您应该给它一个描述它是什么的别名，或者只使用一个缩写，例如:

Azure Storage Account for exports 我将命名为“exports”，因此全名将使用“Azure RM _ Storage _ Account . exports”，然后对于类似单个 Azure 资源组的内容，我将命名为“rg”以生成“azurerm_resource_group.rg”。

然后，您应该对部署的资源也有一个模式，这样它们也有一个命名约定可以遵循。对此没有严格的规定，因为这可能取决于公司政策和资源限制。一般来说，我会给所有东西加上项目前缀，然后是环境前缀，最后是资源类型前缀。例如，开发环境中的 CMP 项目和资源组将是“cmp-dev-rg”。这样可以很容易地对资源进行分组，并保持所有资源之间的一致性，但是，有些资源有最大字符数限制。因此，您需要考虑您输入了多少个字符，这样就不会达到限制，一些资源可能最终看起来像“cmpdevsa”。

```
locals { 
   resource_prefix = "cmp-${var.env}" 
   resource_prefix_no_dash = replace(local.resource_prefix,"-","") 
} resource "azurerm_resource_group" "rg" { 
    name     = "${local.resource_prefix}-rg" 
    location = var.location 
} resource "azurerm_storage_account" "exports" {
   name                     = "${local.resource_prefix_no_dash}sa"
   resource_group_name      = azurerm_resource_group.rg.name
   location                 = azurerm_resource_group.rg.location
   account_tier             = "Standard"
   account_replication_type = "GRS" 
}
```

# 结束语

这些都是编写一个好的 Terraform 项目的指导方针，但是它们会根据你的设置而变化。关键是要有一致性、命名约定和一个旅程，使其更容易阅读、编写和开发。

最后，我总是建议在签入代码之前使用 Terraform 命令“fmt ”,以保持风格一致。

作者简介
Christopher Pateman 是 Version 1 的高级 Azure DevOps 工程师。