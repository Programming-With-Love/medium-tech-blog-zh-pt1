<html>
<head>
<title>Confidence Splitting Criterions Can Improve Precision And Recall in Random Forest Classifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">置信度分裂准则可以提高随机森林分类器的精度和召回率</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/confidence-splitting-criterions-can-improve-precision-and-recall-in-random-forest-classifiers-ad2d4ba696a4?source=collection_archive---------1-----------------------#2015-10-20">https://medium.com/airbnb-engineering/confidence-splitting-criterions-can-improve-precision-and-recall-in-random-forest-classifiers-ad2d4ba696a4?source=collection_archive---------1-----------------------#2015-10-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4828" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作者:阿洛克·古普塔</p><p id="49fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.airbnb.com/trust" rel="noopener ugc nofollow" target="_blank">信任和安全团队</a>维护着许多用于预测和检测在线和离线欺诈行为的模型。我们面临的一个常见挑战是在识别欺诈行为时获得高度信心。包括将欺诈行为归类为欺诈行为(召回)和不将良好行为归类为欺诈行为(精确)。</p><p id="9f66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们经常使用的分类模型是随机森林分类器(RFC)。然而，通过稍微调整该算法的逻辑，以便我们寻找分类的高置信度区域，我们可以显著提高分类器预测的召回率和精确度。为了做到这一点，我们引入了一个新的分裂标准(解释如下),并通过实验表明，它可以实现更准确的欺诈检测。</p><h2 id="b63a" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">传统的节点分裂准则</h2><p id="479f" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">RFC是随机生成的“决策树”的集合。决策树是一种将多维空间划分为具有相似行为的区域的方法。在欺诈检测的情况下，将事件标识为‘0’表示非欺诈，而‘1’表示欺诈，决策树是二进制的，并试图在信号空间中找到主要是0或主要是1的区域。然后，当我们看到一个新事件时，我们可以看看它属于哪个区域，并决定它是0s区域还是1s区域。</p><p id="b414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，决策树是从整个空间开始生长的，并迭代地将其分成越来越小的区域，直到一个区域只包含0或只包含1。每个最终的均匀区域被称为“叶子”。将父区域划分成两个子区域的方法通常被称为“分裂标准”。评估每个候选分区，并且使用优化分裂标准的分区来划分区域。被分割的父区域被称为“节点”。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/f2295ef1260a38350146833797c068e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEJzbA9MSBawYcMF4buqkg.png"/></div></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kp"><img src="../Images/ca077691dc5ad7d8e4d3e7a3c357a21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LYRbUJjnK4ynCRJ-.png"/></div></div></figure><h1 id="d501" class="kq je hh bd jf kr ks kt jj ku kv kw jn kx ky kz jq la lb lc jt ld le lf jw lg bi translated">置信分裂准则</h1><h2 id="9faf" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">理论</strong></h2><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lh"><img src="../Images/47e5435e52189bdf90c2bfcd8ebb03bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRDfz4Hyirodjn_oyZoI6Q.png"/></div></div></figure><h2 id="961c" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">履行</h2><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es li"><img src="../Images/c03af1e343ca35ed2a7142773a593943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*36SihvMZBRVBDr8PRTC3Yg.png"/></div></figure><p id="1139" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在对算法进行这些调整之后，我们发现Scikit-Learn例程的运行时发生了一个无关紧要的变化。具有新标准的Python代码如下所示:</p><pre class="ke kf kg kh fd lj lk ll lm aw ln bi"><span id="c3ae" class="jd je hh lk b fi lo lp l lq lr">from sklearn.ensemble import RandomForestClassifier<br/># using [C_0,C_1] = [0.95,0.95]<br/>rfc = RandomForestClassifier(n_estimators=1000,criterion='conf',conf=[0.95,0.95])<br/>rfc.fit(x_train,y_train)<br/>pred = rfc.predict_proba(x_test)</span></pre><p id="e3a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于Airbnb机器学习模型构建过程的更多细节，你可以阅读以前的帖子，如<a class="ae jc" href="http://nerds.airbnb.com/designing-machine-learning-models/" rel="noopener ugc nofollow" target="_blank">设计机器学习模型:精确和回忆的故事</a>和<a class="ae jc" href="http://nerds.airbnb.com/host-preferences/" rel="noopener ugc nofollow" target="_blank">Airbnb如何使用机器学习来检测主人偏好</a>。有关我们检测风险的架构的详细信息，您可以在<a class="ae jc" href="http://nerds.airbnb.com/architecting-machine-learning-system-risk/" rel="noopener ugc nofollow" target="_blank">为风险构建机器学习系统</a>了解更多。</p><h1 id="7a12" class="kq je hh bd jf kr ks kt jj ku kv kw jn kx ky kz jq la lb lc jt ld le lf jw lg bi translated">估价</h1><h2 id="b659" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">数据</strong></h2><p id="e7a9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">为了测试置信分裂标准可以提供的改进，我们使用了我们在之前的文章<a class="ae jc" href="http://nerds.airbnb.com/overcoming-missing-values-in-a-rfc/" rel="noopener ugc nofollow" target="_blank">中使用的相同数据集克服随机森林分类器</a>中的缺失值，即来自<a class="ae jc" href="http://archive.ics.uci.edu/ml/" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>的<em class="ls">成人</em>数据集。与之前一样，我们的目标是使用提供的14个特征预测成年人的年收入水平是高于还是低于$50k。</p><p id="e333" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们尝试了6种不同的[C0，C1]组合来对抗带有基尼系数杂质的基准RFC，并观察了精确召回曲线的变化。像往常一样，我们保持一个训练集，并对未使用的测试集进行评估。我们在7个场景中的每一个场景中都构建了1000棵树的RFC。</p><p id="efee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结果</strong></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lt"><img src="../Images/0f901f2acb7ca1ee82ce01ff5f961df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xa3_ECOYsY530808.png"/></div></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lu"><img src="../Images/fec8f21c5501de07d33a95da2c871ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*unocMwGph9sQWk_K.png"/></div></div></figure><p id="5d63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">观察到C0=0.5(黄线和蓝线)相对于基线RFC提供了非常小的改进，在95%的精确度水平上，适度的绝对召回改进为5%。然而，对于C0=0.9(绿色和紫色线)，我们看到召回率从45%的精确水平开始稳步上升。在80%及以上的准确率下，C0=0.9提高了10%的绝对召回率，在95%的准确率水平下达到13%。对于C0=0.9，C1=0.9(绿线)和C1=0.99(紫线)之间几乎没有变化，尽管[C1 C0]=[0.9，0.9](绿线)看起来确实更好。对于C0=0.9(浅蓝色和粉色线条)，改善并不显著或一致。</p><h1 id="7b02" class="kq je hh bd jf kr ks kt jj ku kv kw jn kx ky kz jq la lb lc jt ld le lf jw lg bi translated">最后的想法</h1><p id="7414" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">将分析扩展到比较新的分裂标准和优化现有的超参数将是有用的。在RFC的Scikit-Learn实现中，我们可以使用<em class="ls"> min_samples_split </em>或<em class="ls"> min_samples_leaf </em>来克服缩放问题。我们还可以测试不同的class_weight值，以捕捉由不相等的C0和C1引入的不对称性。</p><p id="af1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种方法的实现上可以做更多的工作，并且仍然有一些关于置信度阈值Cj如何与召回率或精确度的提高相关联的未完成的分析研究。然而注意，该方法已经推广到非二元分类器，即j=0，1，2，3，…。将这个新标准实现到Apache Spark RandomForest <a class="ae jc" href="https://github.com/apache/spark/blob/master/mllib/src/main/scala/org/apache/spark/mllib/tree/RandomForest.scala" rel="noopener ugc nofollow" target="_blank">库</a>中也是有用的。</p><h1 id="5e8f" class="kq je hh bd jf kr ks kt jj ku kv kw jn kx ky kz jq la lb lc jt ld le lf jw lg bi translated">业务影响</h1><p id="9af3" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">对于检查的数据集，新的分裂标准似乎能够更好地识别0或1的较高密度区域。此外，通过考虑分区的大小和在零假设下观察值的这种分布的概率，我们可以更好地检测1。在信任和安全方面，这意味着能够更准确地检测欺诈行为。</p><p id="ac0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将接收器操作特性向外移动(相当于将精确度-召回曲线向外移动)的商业含义已经在以前的帖子中讨论过了。正如<a class="ae jc" href="http://nerds.airbnb.com/overcoming-missing-values-in-a-rfc/" rel="noopener ugc nofollow" target="_blank">克服随机森林分类器</a>帖子中的“效率影响”部分所述，即使在召回率或精确度方面节省十进制百分点，也可以分别在欺诈缓解和效率方面节省大量资金。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lv"><img src="../Images/3913f6470a7657e02386189e67b4eb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:108/format:webp/1*YsUOrWx3mRxZZljtc9xZyw.png"/></div></figure><h2 id="888d" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">在<a class="ae jc" href="http://airbnb.io" rel="noopener ugc nofollow" target="_blank"> airbnb.io </a>查看我们所有的开源项目，并在Twitter上关注我们:<a class="ae jc" href="https://twitter.com/AirbnbEng" rel="noopener ugc nofollow" target="_blank">@ Airbnb eng</a>+<a class="ae jc" href="https://twitter.com/AirbnbData" rel="noopener ugc nofollow" target="_blank">@ Airbnb data</a></h2></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><p id="fedc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ls">原载于2015年10月20日nerds.airbnb.com</em><a class="ae jc" href="http://nerds.airbnb.com/large-scale-payments-systems-ruby-rails/" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p></div></div>    
</body>
</html>