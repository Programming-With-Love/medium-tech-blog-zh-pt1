# 伴侣物品:科特林最谦逊的功能

> 原文：<https://medium.com/google-developer-experts/companion-objects-kotlins-most-unassuming-power-feature-fb5c0451fbd0?source=collection_archive---------1----------------------->

在这篇文章中，我认为 Kotlin 的伙伴对象是语言特性的克拉克·肯特，看起来非常强大，我们可以如何使用它们来创建增强 API 设计的方法。

# TL；速度三角形定位法(dead reckoning)

> ***“伴随对象不仅仅是常数和其他静态的占位符；它们允许新的策略来帮助组织我们的代码，或者提供可重用的工厂和验证功能。”***

![](img/ced41929d2524f65ac148c2bd90af775.png)

Image by Colin Behrens from Pixabay

在 Kotlin 世界中开发人员热衷的所有特性中，你听说最少的一个是不起眼的[伴侣对象](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects)。从表面上看，它们只是一个方便的替代品，可以用来放置静态状态。但是，就这样放弃它们是过早地将它们一笔勾销——我们已经为它们发现了几个非常有趣的用例。

不相信我？如果你做了，我会失望的😉。让我们看几个简单的例子，都是基于 Java 的可信的`LocalDate`类。

## API 扩展点

伴随对象给我们的一个基本(也可能是最无聊的)能力是作为不断增长的相似主题函数或值集合的扩展点。如果你定义了一个简单的概念或抽象，它将在你的系统中被使用和重用，我鼓励在类/接口定义中增加一个伴随对象。这提供了一个地方来附加与所有场景中的核心概念都不相关的扩展，并避免把水搅浑…想象一下这对一个开发人员(或者你自己写的)来说有多可怕！)遇到一个有二十个功能而不是两个的界面！

这还允许开发人员在您自己的其他部分或另一个代码模块中定义所述抽象的新实现，以便有一个地方来收集/组织它们 IDE 将选取所有这些扩展并通过自动完成提供给您，而不是将它们分散在代码中。

我们可以从下面的例子中看到这一点——我们定义了一个简单的`Validation`谓词，并为它附加了各种扩展函数/实现/属性。注意下面的`fun interface` 是 Kotlin 的一个特性，它将单个函数接口转换成一个 [Java SAM 类型](https://www.baeldung.com/java-8-functional-interfaces)，并允许我们创建一个没有完整声明的接口:

## 解析器/工厂

我们还可以使用伴生对象来提供一个地方，以确保从其他格式中正确构造微类型(如上所述，这些也可以适当地位于基类的外部)。在下面的例子中，我们有一个简单的`LocalDate`值包装器。但是我们也希望能够正确解析、验证和显示来自我们奇怪的 ISO 兼容格式(YYYY-DDD)的值:

## 改变你的编程模式！

上述方法的一个问题是，当验证错误发生时，传统的 parse/require 模式会出现异常——标准对象构造技术没有给我们机会将更多的函数式编程模型(如 Result/要么 monads)应用到我们的领域。

在这些模型中，我们积极地试图避免异常——为了帮助我们，我们可以将`BirthDate`构造函数私有化，并编写一个函数来将错误捕获到一个 [Result4k](https://github.com/fork-handles/forkhandles/tree/trunk/result4k) 类型中，然后我们可以`map/flatMap()`该类型:

如果我们想要插入一个不同的结果单子(比如 Arrow 的`Either`)或者在失败时返回`null`，添加扩展函数来覆盖这些类型是微不足道的。伴随物体给了我们选择...

## 提取再利用！

许多开发人员没有意识到的是，该伴侣具有与任何其他 Kotlin 对象完全相同的功能——这包括从类或接口的传统继承。

回到更简单的基于异常的解析示例，我们可以将公共代码提取到可以重用的超类或委托中。进一步考虑这一点，我们意识到任何添加到超类/接口的扩展函数也将自动添加到我们的伙伴对象中！

这里我们为所有“日期包装器”类提取了一个公共超类`DateValueFactory`——这个类中的每个函数现在都由`OrderDate`和`DeliveryDate`继承(通过它们的同伴)。如前所述，我们还为 Result4k 构造案例的所有`DateValueFactory`实例添加了一个扩展函数:

# 摘要

我只介绍了过去几年使用 Kotlin 时遇到的几个用例，但这肯定只是冰山一角，还会有更多的用例等着我去发现。这些能力的实现增强了我的信念，那就是我们应该在科特林特征的表面下抓挠，看看有什么可能。

与许多发明一样，甚至 JetBrains 也可能没有真正意识到通过添加这样一个不起眼的功能所能释放的深度——我很想了解 Kotlin 标准库中任何这种类型的使用。

# PS。

对于如何在现实世界中使用这些类型创建技术的实际例子，您可以看看基础的 [Values4k](https://github.com/fork-handles/forkhandles/tree/trunk/values4k) 库，该库使用它们来提供不可变值类型的实例化、验证、解析和打印。

*喜欢这篇文章吗？你可以在 https://dentondav.id/writing*[](https://dentondav.id/writing)**阅读我所有的科技文章。**