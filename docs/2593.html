<html>
<head>
<title>How I do dbt (data build tools)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何做dbt(数据构建工具)</h1>
<blockquote>原文：<a href="https://medium.easyread.co/how-i-do-dbt-data-build-tools-3324807d9ff2?source=collection_archive---------0-----------------------#2021-09-08">https://medium.easyread.co/how-i-do-dbt-data-build-tools-3324807d9ff2?source=collection_archive---------0-----------------------#2021-09-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d2cc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从我目前设置dbt的经验来看…</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/519233989e7803634b19f8e81f4cebe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6E1J64DHVIvF4dVz"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@publicpowerorg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">American Public Power Association</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="602a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将讨论我在为我的团队建立<strong class="kv io"> dbt </strong>项目时从我的经验中学到的东西(关于如何做的技巧),我认为这些东西在尝试这些新的伟大工具时对其他数据工程团队是有价值的。</p><p id="c674" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于那些刚刚接触<strong class="kv io"> dbt </strong>的人来说，它基本上是一个遵循软件工程最佳实践的数据转换工具。<strong class="kv io"> dbt </strong>位于ELT(提取、转换、加载)过程的T部分。</p><p id="f2f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然(显然，从字面上来看)<strong class="kv io"> dbt </strong>是一个<strong class="kv io">易于使用的数据转换工具</strong>，它需要最小的努力来设置，特别是对于那些使用云版本(cloud <strong class="kv io"> dbt </strong>)的人来说，云版本已经包括了所有的“数据工程基本功能”，如CICD、松弛警报、调度程序和文档，但是在我们的工程人员中，总是有改进的空间。</p><blockquote class="lp lq lr"><p id="8244" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">改进是指增加日常使用<strong class="kv io"> dbt </strong>的数据团队(BI和DA)的易用性和便利性。</p></blockquote><h1 id="d01d" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><strong class="ak">用dbt_project.yml组织一切</strong></h1><p id="363e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">首先第一件事，组织好一切我用dbt_project.yml来做，这是定义<strong class="kv io"> dbt </strong>项目结构的主要配置文件，像如何构造文件，定义变量。</p><ul class=""><li id="11e2" class="mt mu in kv b kw kx kz la lc mv lg mw lk mx lo my mz na nb bi translated"><strong class="kv io">在</strong>这里调用你需要的前挂钩和后挂钩和<strong class="kv io">。例如通过在模型组件中添加<strong class="kv io"> <em class="ls"> start_log() </em> </strong>和<strong class="kv io"> <em class="ls"> end_log() </em> </strong>宏作为钩子，它会将每个SQL模型的执行记录到表日志中。我还添加了<strong class="kv io"><em class="ls">grant _ table()</em></strong>作为后挂钩，在成功创建每个模型后，将表授予默认或特定的用户模式。</strong></li><li id="5719" class="mt mu in kv b kw nc kz nd lc ne lg nf lk ng lo my mz na nb bi translated"><strong class="kv io">定义全局变量和设置</strong>，除了hook之外，我还定义了全局变量和默认设置，在本例中，我为模式别名定义了全局变量，为表和persist_docs启用了默认的物化设置。</li><li id="b1c2" class="mt mu in kv b kw nc kz nd lc ne lg nf lk ng lo my mz na nb bi translated"><strong class="kv io">结构化数据层</strong>，最后一个是按目录结构组织数据层，在这个例子中，我尝试按dir名称组织SQL模型作为数据层(<em class="ls"> data_mart </em>目录用于<em class="ls"> data_mart </em>层)，所以当有在<em class="ls"> data_mart </em>层创建表的请求时，只需要将SQL文件放在<em class="ls"> data_mart </em>目录中即可。你可以用其他方式来组织，比如业务单位或服务。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="5f4c" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><strong class="ak">最大化宏用法</strong></h1><p id="8b99" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">宏是给你的<strong class="kv io">项目</strong>添加功能的好方法。注意，在前面一点中，我使用了<strong class="kv io"> <em class="ls"> grant_table() </em> </strong>宏作为钩子，自动将一个新创建的表授予用户。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="47c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我使用的另一个宏的例子是:<strong class="kv io"> <em class="ls"> source() </em> </strong>，<strong class="kv io"><em class="ls">generate _ schema _ name()</em></strong>，<strong class="kv io"><em class="ls">primary _ key()</em></strong>，<strong class="kv io"><em class="ls">time zone _ default()</em></strong>。除了将宏定义为函数，还可以作为模板<strong class="kv io">替代重复查询</strong>(例如:<strong class="kv io"><em class="ls">index()</em></strong><strong class="kv io"><em class="ls">partition()</em></strong>)。</p><p id="a61b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用宏的SQL模型</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="lp lq lr"><p id="e1c1" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">宏的用法取决于您使用的数据仓库(PG、Snowflake、Bigquery等)，在我的例子中，我使用宏<strong class="kv io"> partition() </strong>对Postgres中的表进行分区，但是在BigQuery中这个宏不可用，因为<strong class="kv io"> dbt </strong>有一个内置的宏来处理这个表分区(<strong class="kv io"> partition_by() </strong>和<strong class="kv io"> cluster_by() </strong>宏)</p></blockquote><h1 id="2452" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">定义模型模板</h1><p id="b6ba" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">模型模板允许您使用预定义的每个团队的模板和设置开始开发SQL模型。这对使用<strong class="kv io"> dbt </strong>的用户/团队的<strong class="kv io">统一SQL模型和表格</strong>非常有用。在我们的例子中，我定义了模型template.sql和template_incremental.sql(用于增量模型),这样用户就可以根据需要使用和更改模板模型。</p><blockquote class="lp lq lr"><p id="dd19" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">模板模型也可以用作如何使用宏或任何dbt配置属性的指南</p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="af5f" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">利用schema.yml</h1><blockquote class="lp lq lr"><p id="02ff" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">“文档是你写给未来自己的情书”<br/> ~达米安·康威</p></blockquote><p id="937e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实证明，这不仅是为了你未来的自己，也是为了你未来的剧本。schema.yml的主要用途是<strong class="kv io">为你的<strong class="kv io"> dbt </strong>项目提供文档</strong>，它的另一个用途是存储模型元数据。稍后，当执行SQL模型时，此元数据将与调用日志/指标聚合在一起，并作为<strong class="kv io"> dbt </strong>工件文件(<em class="ls"> target/run_result.json，target/manifest.json) </em>，这些文件稍后可用于您的数据监控和警报平台<strong class="kv io">，在我们的案例中，元数据模型所有权将用于slack警报/通知以及其他用于管道报告/日志记录的元数据。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="94a6" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">Cloud <strong class="ak"> dbt </strong>作为协作工具</h1><p id="22e7" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">Cloud <strong class="kv io"> dbt </strong>非常适合协作和开发SQL模型，但只适合作为生产环境，所以我们不把它用作生产环境。而且…我们数据团队基本上有一个集中的编排平台(如airflow、rundeck等)来跨多个数据平台组织我们的数据管道。在我们的案例中，我们<strong class="kv io">分别托管dbt环境</strong>，云上的开发环境<strong class="kv io"> dbt </strong>，以及使用<strong class="kv io"> dbt-cli的内部生产环境。</strong> <strong class="kv io"> dbt </strong>通过使用profiles.yml中的目标，可以很容易地维护独立的生产和开发环境</p><blockquote class="lp lq lr"><p id="fa2e" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">那些在一个BigQuery项目(或类似项目)上使用<strong class="kv io"> dbt </strong>的人只需要指定目标并覆盖这两个内置宏(<strong class="kv io"> <em class="in"> source() </em> </strong>和<strong class="kv io"><em class="in">generate _ schema _ name()</em></strong>)就可以根据目标属性自动更改环境和模式。在<strong class="kv io"> dbt </strong>下使用宏<strong class="kv io"> <em class="in"> source() </em> </strong>从表源中查询数据，而<strong class="kv io"><em class="in">generate _ schema _ name()</em></strong>在创建表时引用目标模式</p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d016" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想现在就这样吧…</p><p id="c66c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于如何为您的团队建立<strong class="kv io"> dbt </strong>项目，您可能有不同的意见或偏好，所以请随意记下一些关于如何建立<strong class="kv io"> dbt </strong>项目的想法/建议。</p><p id="e55f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你觉得这篇博文有帮助吗？如果是这样，那么把这篇文章带到你的下一次DE团队周会上，或者…你可以只是分享它，这样人们也可以找到这篇文章。谢谢你。</p></div></div>    
</body>
</html>