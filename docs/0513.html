<html>
<head>
<title>Hilt — Adding components to the hierarchy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">柄-将组件添加到层次结构中</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/hilt-adding-components-to-the-hierarchy-96f207d6d92d?source=collection_archive---------0-----------------------#2020-07-09">https://medium.com/androiddevelopers/hilt-adding-components-to-the-hierarchy-96f207d6d92d?source=collection_archive---------0-----------------------#2020-07-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/859499c14f0c0376a98497b2190e4e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqsETASsCZHY2m0XyEYTMQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="0307" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在刀柄组件层次的中间插入一个组件是不可能的。但是，您可以创建一个以Hilt组件为父级的自定义组件，并使用入口点访问其作用域类型。在本文中，我们将了解所有这些意味着什么，以及如何在<em class="js"> Dagger 2 codelab </em>代码中添加自定义组件。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="fe84" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dagger 2 codelab 将Dagger添加到一个多活动应用程序中。由于用户可以登录和退出应用程序，用户信息在Dagger组件中处理，其寿命比activity组件长。</p><figure class="kb kc kd ke fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ka"><img src="../Images/6ca6f1844ab2ee39d896db4bc28e259b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knyinR_MhcjpyGlWb0UV6w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kf">Dagger components in the Dagger codelab app</em></figcaption></figure><p id="3a65" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上图中，注意<code class="du kg kh ki kj b">MainActivity</code>和<code class="du kg kh ki kj b">SettingsActivity</code>是如何访问范围为<code class="du kg kh ki kj b">UserDataRepository</code>的<code class="du kg kh ki kj b">UserComponent</code>的。内存中的<code class="du kg kh ki kj b">UserDataRepository</code>处理与登录用户相关的信息。当用户注销时，我们希望从内存中删除信息。</p><p id="09c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在《剑柄和匕首》中，每个组件都必须由一个知道何时需要创建或销毁该组件的对象(您可以将其视为生命周期所有者)持有。在我们的例子中，这个类是<code class="du kg kh ki kj b">UserManager</code>，它跟踪登录和注销。当用户登录时，创建一个新组件，当用户注销时，销毁该组件。通过这种方式，<code class="du kg kh ki kj b">MainActivity</code>和<code class="du kg kh ki kj b">SettingsActivity</code>可以访问组件的同一个实例，并被它注入。</p><p id="9032" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该app <em class="js">除</em> <code class="du kg kh ki kj b">UserComponent</code>外的所有组件都可以映射到刀柄的标准组件:<code class="du kg kh ki kj b">AppComponent</code>映射到刀柄的<code class="du kg kh ki kj b">ApplicationComponent</code>，而<code class="du kg kh ki kj b">RegistrationComponent</code>和<code class="du kg kh ki kj b">LoginComponent</code>映射到<code class="du kg kh ki kj b">ActivityComponent</code>。</p><p id="1f40" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们能做些什么来使<code class="du kg kh ki kj b">UserComponent</code>对剑柄更友好？我们有不同的可能性:</p><ul class=""><li id="7708" class="kk kl hx iw b ix iy jb jc jf km jj kn jn ko jr kp kq kr ks bi translated">将<code class="du kg kh ki kj b">UserDataRepository</code>扩展到<code class="du kg kh ki kj b">ApplicationComponent</code>，并在用户注销时处理可空性。这就是<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt/#0" rel="noopener ugc nofollow" target="_blank">将你的Dagger应用程序移植到刀柄代码实验室</a>所做的事情。不理想，但可以在这种情况下工作。然而，它可能会在用户交换机上增加一些棘手的竞争条件。</li><li id="9542" class="kk kl hx iw b ix kt jb ku jf kv jj kw jn kx jr kp kq kr ks bi translated">制作<code class="du kg kh ki kj b">MainActivity</code>和<code class="du kg kh ki kj b">SettingsActivity</code>片段，并将<code class="du kg kh ki kj b">UserDataRepository</code>限定在使用这些片段的活动(句柄的<code class="du kg kh ki kj b">ActivityRetainedComponent</code>)范围内。这是一种“做适合框架的事情，而不是框架适合用例”的解决方案。这甚至不适用于所有情况，因为您可能需要在其他地方访问用户信息，而这些地方与广播接收器之类的活动没有联系。</li><li id="4dee" class="kk kl hx iw b ix kt jb ku jf kv jj kw jn kx jr kp kq kr ks bi translated">保持导航结构不变，增加刀柄使用的<code class="du kg kh ki kj b">UserComponent</code>。</li></ul><p id="3765" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为一个练习来学习更多关于Hilt的灵活性，让我们在这篇文章中讨论选项3:添加一个组件到Hilt组件层次结构中。</p><h1 id="df90" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">刀柄设计决策</h1><p id="0ef2" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">Hilt坚持自己的组件层次结构，因为它包含了Android应用程序通常使用的最常见的组件。由于兼容性问题和不知道如何创建你的组件(例如使用什么<code class="du kg kh ki kj b">userId</code>)，不可能<em class="js">而</em>在层之间<em class="js">插入</em>一个组件(例如定制一个<code class="du kg kh ki kj b">ApplicationComponent</code>的组件X子组件，和<code class="du kg kh ki kj b">ActivityRetainedComponent</code>的父组件)。</p><p id="6773" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可能的是<em class="js">将</em>一个组件作为叶组件添加到层次结构中。在我们的例子中，我们可以让我们的定制组件<code class="du kg kh ki kj b">UserComponent</code>成为<code class="du kg kh ki kj b">ApplicationComponent</code>的子组件，如图所示。</p><figure class="kb kc kd ke fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/7e44b61b1b02435a33df1cc0cec2e632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KuKTd9M_aink-M2P"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kf">Adding a subcomponent of ApplicationComponent to the Hilt hierarchy</em></figcaption></figure><blockquote class="mc md me"><p id="df08" class="iu iv js iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">本文中的用例包括向父级为<code class="du kg kh ki kj b">ApplicationComponent</code>的层次结构中添加一个定制组件(即<code class="du kg kh ki kj b">UserComponent</code>)。然而，正如我们将在后面看到的，你可以让你的定制组件扩展你想要的任何组件，要么是一个预定义的手柄组件，要么是你自己的其他定制组件。</p></blockquote><p id="644f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">插入</em>和<em class="js">添加</em>一个组件之间的主要区别在于，如果你<em class="js">在层次结构中插入</em>一个组件，它的作用域绑定在它的子组件(层次结构中下面的组件)中是可用的，而如果你<em class="js">添加</em>一个组件，它们就不可用。如果您创建自己的<em class="js">层次结构，并与Hilt的层次结构平行，那么您可以让这些限定范围的绑定在层次结构中向下流动(或可用)。然而，那会使你失去<code class="du kg kh ki kj b">@AndroidEntryPoint</code>功能，你必须使用入口点来获得Android框架类中的依赖项。</em></p><p id="8c6a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的例子中，由于我们将<em class="js">添加</em>一个组件到层次结构中，我们将不会有<code class="du kg kh ki kj b">UserDataRepository</code> ( <code class="du kg kh ki kj b">UserComponent</code>的作用域类型)作为<code class="du kg kh ki kj b">@AndroidEntryPoint</code>类中的绑定可用，所以我们不能将它作为任何其他作用域类型注入:</p><figure class="kb kc kd ke fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="20a4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稍后我们将看到在我们的类中有哪些不同的选项来获取<code class="du kg kh ki kj b">UserDataRepository</code>的作用域实例。</p><h1 id="e5a7" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">向层次结构中添加组件</h1><p id="0e9c" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">如<a class="ae hu" href="https://dagger.dev/hilt/custom-components" rel="noopener ugc nofollow" target="_blank">自定义组件文档</a>所示，您可以使用<code class="du kg kh ki kj b">@DefineComponent</code>注释声明一个组件。</p><figure class="kb kc kd ke fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="cf89" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将<code class="du kg kh ki kj b">UserComponent</code>作为<code class="du kg kh ki kj b">ApplicationComponent</code>的子组件，正如在<code class="du kg kh ki kj b">@DefineComponent</code>注释的父参数中所指定的。此外，我们创建了<code class="du kg kh ki kj b">@LoggedUserScope</code>来将类型的范围扩展到<code class="du kg kh ki kj b">UserComponent</code>。使用标注了<code class="du kg kh ki kj b">@DefineComponent.Builder</code>的构建器来创建<code class="du kg kh ki kj b">UserComponent</code>的实例，稍后您会看到，这就是<code class="du kg kh ki kj b">UserManager</code>将要使用的。</p><blockquote class="mc md me"><p id="158e" class="iu iv js iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">使用<code class="du kg kh ki kj b">@DefineComponent</code>定义一个可在应用中使用的新自定义组件。它接受父组件作为参数。新组件将扩展父组件，这意味着所有父绑定都将在新组件中可用。因为我们这篇博文的具体用例，我们使用了Hilt的ApplicationComponent，但是，你可以让它扩展你想要的任何组件:它可以是一个Hilt组件，也可以是你已经定义的任何其他定制组件。</p></blockquote><p id="1054" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这样，我们就可以将类型的范围扩展到这个组件了:</p><pre class="kb kc kd ke fd mk kj ml mm aw mn bi"><span id="5252" class="mo kz hx kj b fi mp mq l mr ms"><strong class="kj hy">@LoggedUserScope</strong><br/>class UserDataRepository <strong class="kj hy">@Inject</strong> constructor(...) { ... }</span></pre><h1 id="a97c" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">管理组件的生命周期</h1><p id="153c" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">组件层次结构中范围更高的类应该负责该组件的生命周期。在我们的例子中，这个类是<code class="du kg kh ki kj b">UserManager</code>，它的作用域是<code class="du kg kh ki kj b">ApplicationComponent</code>。</p><p id="de05" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于<code class="du kg kh ki kj b">UserManager</code>需要知道如何创建<code class="du kg kh ki kj b">UserComponent</code>的实例，它应该在构造函数中接收它的构建器。因为<code class="du kg kh ki kj b">UserComponent</code>是<code class="du kg kh ki kj b">ApplicationComponent</code>的子组件，所以构建器可以作为绑定在那里使用。</p><figure class="kb kc kd ke fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="5a1d" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">访问作用域绑定</h1><p id="90ba" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">您可以使用入口点访问<code class="du kg kh ki kj b">UserComponent</code>的作用域绑定。对于我们的例子，我们可以创建一个公开<code class="du kg kh ki kj b">UserDataRepository</code>的入口点:</p><pre class="kb kc kd ke fd mk kj ml mm aw mn bi"><span id="fb06" class="mo kz hx kj b fi mp mq l mr ms"><strong class="kj hy">@InstallIn(UserComponent::class)<br/></strong>@EntryPoint<br/>interface UserComponentEntryPoint {<br/>  fun userDataRepository(): UserDataRepository<br/>}</span></pre><p id="8702" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以通过使用<code class="du kg kh ki kj b">UserComponent</code>的实例来访问这个入口点:</p><figure class="kb kc kd ke fd hj"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h1 id="a66a" class="ky kz hx bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">警告</h1><p id="a266" class="pw-post-body-paragraph iu iv hx iw b ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr ha bi translated">到目前为止，我们看到的代码有一些注意事项:</p><ul class=""><li id="30a9" class="kk kl hx iw b ix iy jb jc jf km jj kn jn ko jr kp kq kr ks bi translated">定制组件中的作用域类型并不沿着Hilt组件层次结构向下流动。这就是为什么你需要使用入口点，并且你不能把它作为另一个类的依赖，除非你使用<a class="ae hu" href="https://github.com/square/AssistedInject" rel="noopener ugc nofollow" target="_blank"> AssistedInject </a>，如这个<a class="ae hu" href="https://github.com/manuelvicnt/android-dagger-to-hilt/pull/1" rel="noopener ugc nofollow" target="_blank">例子</a>所示。</li><li id="3c05" class="kk kl hx iw b ix kt jb ku jf kv jj kw jn kx jr kp kq kr ks bi translated">这不是一个完整的登录/用户解决方案，因为这种设置在用户显式登录和注销应用程序时有效。如果你的应用程序允许在同一个屏幕上切换账户，那么当这种情况发生时，你需要手动重启活动/片段。或者，您可以给<code class="du kg kh ki kj b">UserManager</code>添加一个回调函数，以了解帐户何时发生了变化，从而相应地更新屏幕上的信息。</li></ul></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="57f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管不可能在Hilt组件层次结构的中间插入组件，但是您可以创建一个以Hilt组件为父组件的组件，并使用入口点访问它的作用域类型。</p></div></div>    
</body>
</html>