<html>
<head>
<title>Authenticating on Android with the AppAuth Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AppAuth库在Android上进行身份验证</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/authenticating-on-android-with-the-appauth-library-7bea226555d5?source=collection_archive---------1-----------------------#2022-01-19">https://medium.com/androiddevelopers/authenticating-on-android-with-the-appauth-library-7bea226555d5?source=collection_archive---------1-----------------------#2022-01-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/41bd91578792af5c40fb8c20c41cf70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pB4hs3p_jwGSHhtOYEq8Zg.png"/></div></div></figure><div class=""/><p id="f600" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然谷歌自己的Android认证平台<a class="ae jn" href="https://developers.googleblog.com/2021/06/upcoming-security-changes-to-googles-oauth-2.0-authorization-endpoint.html" rel="noopener ugc nofollow" target="_blank">不支持WebViews </a>，但Android团队<a class="ae jn" href="https://blog.google/products/android-enterprise/art-of-control/" rel="noopener ugc nofollow" target="_blank">最近宣布</a>他们正在与多个身份提供商(IDP)合作伙伴合作，包括ForgeRock、微软、Okta和Ping Identity，以通过拥抱和更广泛地支持定制标签来超越WebViews的使用。定制标签已经成为一种选择有一段时间了，我们发现编写一份指南非常重要，它可以指导您如何使用<a class="ae jn" href="https://github.com/openid/AppAuth-Android" rel="noopener ugc nofollow" target="_blank"> AppAuth库</a>(在其实现中使用定制标签)来更新您的应用程序，以便对您的Android用户进行认证和授权。</p><p id="986c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文将介绍用于代码交换 (PKCE)实现的<a class="ae jn" href="https://datatracker.ietf.org/doc/html/rfc7636" rel="noopener ugc nofollow" target="_blank">证明密钥，这是在移动设备上使用身份验证的推荐方式，使用带有Google OAuth的AppAuth库作为身份提供者。在本文结束时，您将了解到:</a></p><ul class=""><li id="afd4" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">如何通过您的身份提供商让用户登录</li><li id="c708" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">如何通过OpenID检索该用户的配置文件信息</li><li id="d2be" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">如何将您的用户从您的应用中注销</li><li id="7e35" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">以及如何在IDP授权后为该用户进行API调用。</li></ul><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es kc"><img src="../Images/b9dd38c943f50209d9d2b15d0cf2a85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/1*cnhWrO2GJFva0r3U6LkzxA.gif"/></div><figcaption class="kh ki et er es kj kk bd b be z dx">Example app flow using third-party authorization</figcaption></figure><p id="968b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然我使用Google作为IDP的例子，但是同样的逻辑也适用于其他提供商。我还打算尽可能保持代码片段的架构无关性，这样你就可以更容易地将本指南应用到你自己的应用程序中，使用它们现有的架构和模式。</p><h1 id="4773" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">认证流程</h1><p id="14ba" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">在深入研究代码之前，理解传统的OAuth 2.0身份验证代码流是如何工作的很重要。一旦你理解了传统的方法，我们将看看推荐给移动开发的PKCE实现，你会看到它是传统授权代码流的一个变种。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/b5025035f5f730b6387a5ac5592311c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FvBXLCWDGr5o45lIvL6Og.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Authorization code grant flow</figcaption></figure><ol class=""><li id="2ff9" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm lp ju jv jw bi translated"><em class="lq">用户采取的第一个行动是点击按钮或通过其他方式重定向到IDP进行身份验证。</em></li><li id="380f" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm lp ju jv jw bi translated"><em class="lq">一旦用户登录并且IDP确认了他们的账户，授权码连同客户端ID、潜在的客户端秘密和其他可选项目一起返回给用户。</em></li><li id="3fbb" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm lp ju jv jw bi translated">这个授权码、客户端ID和可选的秘密可以被发送到IDP的令牌端点，以请求将用于所有后续API调用的访问令牌。该步骤还可以返回刷新令牌，一旦访问令牌过期并且不能再使用，该刷新令牌可以用于更新访问令牌。</li><li id="d850" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm lp ju jv jw bi translated"><em class="lq">当用户客户端拥有访问令牌时，它可以在进行调用时作为授权头的一部分发送给API。如果它仍然有效并且被API接受，那么预期的数据将被返回给用户。</em></li><li id="e484" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm lp ju jv jw bi translated"><em class="lq">在访问令牌过期且无法再与API一起使用后，用户可以将其刷新令牌和客户端ID发送回IDP的令牌端点，以请求一对新的访问和刷新令牌，或者他们可以从头开始重复授权流程，以允许他们继续使用其服务。</em></li></ol><p id="8414" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您已经了解了验证码流背后的一般概念，是时候来看看PKCE流了:</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/8ff8dc5b9ad6fa29e8ee966790483f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSGkiysq9_XRZGwTa7ZjZA.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">PKCE authentication flow diagram</figcaption></figure><p id="2224" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这个流程是类似的，但主要的区别是应用程序现在将生成一个代码验证器和代码质询，用于授权用户，而不是直接将授权代码发送给应用程序。移动应用程序还将明确请求用户同意继续身份验证过程，而不是在身份验证时自动发回授权码。</p><p id="a8a3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">定义了这个模式之后，是时候进入本教程的核心了！</p><h1 id="6e4f" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Android应用程序设置</h1><p id="f53a" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">对于本教程，你需要做的第一件事是设置一个Android应用程序。你可能已经有一个准备好了，你打算与它一起工作，这是非常好的。如果没有，请现在创建一个。在下一节中设置Google OAuth时，您的包名是必需的，但是在我的例子中，我将使用包名com.ptruiz.authtest。</p><p id="6195" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦你的应用被创建，你需要在本教程的应用级<strong class="ir ht"> build.gradle </strong>文件中添加一些依赖项。这是来自Auth0的JSON Web Token (JWT)解码器库(稍后将更详细地解释)和OpenID AppAuth库。</p><p id="1ece" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我的应用程序还使用了其他一些依赖项，比如用于图像加载的<a class="ae jn" href="https://square.github.io/picasso/" rel="noopener ugc nofollow" target="_blank"> Picasso </a>，用于网络调用的<a class="ae jn" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OkHttp </a>，以及用于异步操作的Kotlin <a class="ae jn" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> coroutines </a>，但是你现在可以忽略这些，因为你可能已经有了自己的偏好或工具。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="3b60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仍然在您的<strong class="ir ht"> build.gradle </strong>文件中，进入<code class="du lt lu lv lw b">android</code>节点中的<code class="du lt lu lv lw b">defaultConfig</code>节点，并使用您的应用程序包名称添加一个清单占位符。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a85b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦完成，你就为你的<strong class="ir ht"> build.gradle </strong>文件做好了准备。接下来的步骤将在您的<strong class="ir ht"> AndroidManifest.xml </strong>文件中进行。</p><p id="ab0a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与大多数应用程序一样，你需要在你的清单中添加<code class="du lt lu lv lw b">INTERNET</code>权限，除非你是被动攻击性消息传递的粉丝，我们已经见过太多次了。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4c31" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，您需要将一个<code class="du lt lu lv lw b">intent-filter</code>添加到一个处理授权响应的活动中。对于这个例子，我只是使用我的<strong class="ir ht">主活动</strong>，尽管你可能有你自己的首选位置。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="fdd4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，您需要专门为<strong class="ir ht">net . OpenID . app auth . redirecturireceiveractivity</strong>类添加一个活动节点。这将有一系列的<code class="du lt lu lv lw b">intent-filter</code>节点支持重定向回你的应用程序。所使用的方案应该是专门针对您的应用程序的唯一标识符，因此您的应用程序的包名是一个完美的候选(并且在Google OAuth的情况下是必需的)。<code class="du lt lu lv lw b">path</code>属性是一个额外的标识符，在你的应用程序监听多种类型的<code class="du lt lu lv lw b">Intent</code>的情况下，你可以使用它。这个部分存在的主要原因是定制标签是<em class="lq">而不是</em>可由你的应用程序以编程方式关闭，但是这个<code class="du lt lu lv lw b">Activity</code>可以在弹出back stack以从屏幕上移除定制标签之前接受重定向，为你的用户提供更无缝的体验。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b9c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里值得注意的一点是，你<em class="lq">不会在本教程中使用注销重定向<code class="du lt lu lv lw b">intent-filter</code>，但是我想把它包括进来，以便提供一个更完整的例子。虽然Google OAuth不支持注销时的重定向，但其他IDP(如Ping Identity)支持，所以我将在本教程的稍后部分解决这种差异。</em></p><p id="04b7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，您的应用程序应该准备好通过AppAuth添加身份验证功能。下一步是设置Google OAuth，然后你将返回到你的Android应用程序来完成这个过程。</p><h1 id="db71" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置Google OAuth</h1><p id="ff0c" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">既然您已经有了一个预先存在的或全新的Android应用程序，那么是时候为您的项目设置一个身份提供者了。虽然Google建议为我们的身份提供者服务使用Google登录库，但我将介绍如何在没有该库的情况下将Google OAuth设置为示例IDP，以便展示一个类似于您如何使用不是来自Google的<em class="lq">的联合登录环境的过程。鉴于此，我们非常欢迎您使用另一个最符合您需求的提供商，例如<a class="ae jn" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>或<a class="ae jn" href="https://www.pingidentity.com/en.html" rel="noopener ugc nofollow" target="_blank"> Ping Identity </a>。如果您确实使用了另一个IDP，请随意浏览这一部分，了解如何设置Google OAuth，或者直接进入下一部分。</em></p><p id="7f07" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要开始使用Google OAuth，你需要首先进入<a class="ae jn" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google云平台控制台</a>。如果您之前没有设置Google Cloud项目，系统会提示您一个服务条款屏幕，您可以查看并必须同意才能继续。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lx"><img src="../Images/7db73061ba51ecc2c0e9419d230a65c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pujmOZZ97GiqJVSPkzQI9w.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Initial Google Cloud Platform project creation dialog for Terms of Service</figcaption></figure><p id="bcec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，您需要创建一个新项目，方法是转到屏幕顶部，点击<strong class="ir ht">选择一个项目</strong>下拉菜单。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/2e5c4e7e6ac204709f5e60969d8bd594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiL3RVUH8u0TPMQO4bQZ1w.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Google Cloud Platform’s Select a Project dropdown</figcaption></figure><p id="8c49" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，从弹出窗口中选择<strong class="ir ht">新项目</strong>，进入新项目屏幕。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/7e84e55cb0f9d9a039bc16190b83aeae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VqVgTgjfTPpCnQ5bbmuRA.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Project selection screen showing that no projects are currently available</figcaption></figure><p id="5d42" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个新屏幕上，您可以输入一个新的项目名称，也可以使用为您提供的自动生成的名称。选择项目名称后，点击蓝色的<strong class="ir ht">创建</strong>按钮。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/f600475857817a398d96c742013abc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AB-DXFPHFFniNfFnJLzomg.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Dialog window for creating a new Google Cloud Platform project</figcaption></figure><p id="a8bb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦创建了项目，您应该会收到通知。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/c322104386c5a7308284160cbe76ba93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgVqHldTk7fZY47s7uSvOw.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Notification announcing that a Google Cloud Platform project has finished being created</figcaption></figure><p id="dd48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">返回到页面顶部，选择项目下拉列表，并确保从对话框窗口中选择您的项目。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/ee5974a086fb009ae95ccb44671ce26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kU43JN6mxXLsxOQ3pvf_w.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx">Project selection screen showing the currently selected project</figcaption></figure><p id="675c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，转到控制台屏幕左侧的导航栏，选择<strong class="ir ht">API&amp;服务- &gt; OAuth同意屏幕</strong>。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/65e2d74ac5f8bf04308f97e724536bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cg6JDJ3T-rfRokUBZ3d0OA.png"/></div></div></figure><p id="1d38" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下一个屏幕上，点击<strong class="ir ht">外部</strong>旁边的单选按钮，然后点击蓝色的<strong class="ir ht">创建</strong>按钮。这会将您带到另一个屏幕，要求您填写一些关于您的应用程序的项目(主要是联系信息)。输入完数据后，点击<strong class="ir ht">保存并继续</strong>进入下一个屏幕。</p><p id="2007" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来的屏幕有点复杂。这是您将进入您的应用程序将支持的<em class="lq">范围</em>的地方。作用域是一种限制用户访问权限的方式，以此来提供更高的安全性。继续点击白色的<strong class="ir ht">添加和删除示波器</strong>按钮，调出示波器选择器窗口。您将为本教程添加<strong class="ir ht"> userinfo.email </strong>、<strong class="ir ht"> userinfo.profile </strong>和<strong class="ir ht"> openid </strong>范围，因为它们都不被视为<em class="lq">敏感</em>。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/6f47f87fa3351ec88a39f023425eeed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo6TToTmtlXeZYorR-wVmA.png"/></div></div></figure><p id="3456" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦您选择了这三个项目，点击<strong class="ir ht">更新</strong>按钮保存您的选择。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mf"><img src="../Images/12936436c997ec231dbee564ab866070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNVFrNgY9BzUQsotgCDbwQ.png"/></div></div></figure><p id="558f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在您可以滚动到页面底部，点击<strong class="ir ht">保存并继续</strong>按钮。您可以继续阅读本部分的剩余页面。</p><p id="4ee7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，返回OAuth同意主屏幕，点击<strong class="ir ht">发布应用</strong>按钮，向非预定义测试人员公开您的应用。如果你现在更喜欢保持你的应用程序私有，那么请随意返回到应用程序配置屏幕来添加测试电子邮件帐户。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/dc97d3ea2bedb3913c7baffd9a906153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJzi4HmWqUgQybNqfhnpFA.png"/></div></div></figure><p id="8c28" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于您没有请求任何敏感范围，此应用程序不需要通过审查过程即可使用。完成OAuth同意屏幕后，在左侧导航窗格中选择凭据选项。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es mh"><img src="../Images/119e65791b6bfcf88aa9d76999220df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*cuiNrNfyOSkiGm3NND64uw.png"/></div></figure><p id="a04e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从这里，您可以单击屏幕顶部的蓝色<strong class="ir ht"> + CREATE CREDENTIALS </strong>按钮，正如您可能已经猜到的那样，创建一些新的凭证。对于这个用例，您需要从下拉列表中选择<strong class="ir ht"> OAuth客户端ID </strong>选项。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es mi"><img src="../Images/3713d5eccd34c6799eac9624798220b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*T9tyVnwX3vPsDxz9D3OZ1w.png"/></div></figure><p id="a22d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出现的下一个屏幕将要求您识别您正在使用的应用程序的类型。选择<strong class="ir ht"> Android </strong>调出剩余的选项栏。您还有两个数据需要填写:您的应用程序包名称和SHA-1证书指纹。</p><p id="8b46" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">软件包名称是与您的认证应用程序相关联的名称，因此在我的示例中它是<strong class="ir ht"> com.ptruiz.authtest </strong>。SHA-1变得有点复杂，因为指令会根据您的计算机操作系统而有所不同。在我的例子中，我使用的是Macbook，所以我可以运行下面的终端命令从我的调试键中获取SHA-1。您可能想要检查<a class="ae jn" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>以获取关于如何为您的特定机器获取密钥的信息。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/e9b94b59bc7a984905ef58fc6bdde9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcWsdAWL6Oa5z8jDf8asSg.png"/></div></div></figure><p id="4684" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦获得这些信息，将其添加到<strong class="ir ht">创建OAuth客户端ID </strong>屏幕，并单击蓝色的<strong class="ir ht">创建</strong>按钮。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/013d54c3ef72393192c78a95e6e5970c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz0ium5JmPVPGx7OvNKIPA.png"/></div></div></figure><p id="90f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建完凭证后，您应该会收到一个弹出对话框，其中包含您的新<em class="lq">客户端ID </em>。把这个复制下来，存放在某个地方，因为你很快就会需要它。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ml"><img src="../Images/373ab717dd6ee282d257bbeb2304260d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-y_zKmsnOv9hLm2vB7uF7w.png"/></div></div></figure><p id="389c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，您已经准备好开始编写一些代码来利用<strong class="ir ht"> Google OAuth API </strong>。</p><h1 id="fd7c" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">启动授权请求</h1><p id="e628" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">在深入我们的认证和授权流程之前，我想指出我的应用程序中保存了一系列常量，我将在本指南中使用它们。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="bfe6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">需要注意的主要事情是，<code class="du lt lu lv lw b">CLIENT_ID</code>应该与您的IDP提供的您自己的客户端ID相匹配，重定向URL应该反映您自己的包名，如果您没有使用Google OAuth，那么您还需要更新<code class="du lt lu lv lw b">URL_AUTHORIZATION</code>、<code class="du lt lu lv lw b">URL_TOKEN_EXCHANGE</code>和<code class="du lt lu lv lw b">URL_API_CALL</code>来满足您的需求。</p><p id="aa93" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">解决了这个问题之后，是时候看看如何最终实现身份验证了。对于我的实现，我在类的顶部包含了四个值，它们将在整个示例中使用。<code class="du lt lu lv lw b">authState</code>如你所料，存储了我们应用的授权状态。这包括ID、访问和刷新令牌。<code class="du lt lu lv lw b">jwt</code>将为您的认证用户存储身份信息。最后，<code class="du lt lu lv lw b">authorizationService</code>和<code class="du lt lu lv lw b">authServiceConfig</code>都是用来管理你的应用中的授权流的。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="1d40" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在您已经有了<code class="du lt lu lv lw b">AuthState</code>对象，如果用户之前已经通过了身份验证，您可能还想在应用程序启动时恢复它(比如在<code class="du lt lu lv lw b">onCreate()</code>或<strong class="ir ht">视图模型</strong>的<code class="du lt lu lv lw b">init</code>)。使用<code class="du lt lu lv lw b">AuthState</code>对象的推荐方法是将其序列化并存储在某种形式的永久存储器中。在这个例子中，我将使用一个<code class="du lt lu lv lw b">SharedPreference</code>。如果<code class="du lt lu lv lw b">AuthState</code>对象包含一个ID标记，那么您也可以初始化您的<code class="du lt lu lv lw b">JWT</code>对象。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="89ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您现在有了一个<code class="du lt lu lv lw b">restoreState()</code>函数，您还会希望有另一个持久化<code class="du lt lu lv lw b">AuthState</code>的函数。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="888a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与<code class="du lt lu lv lw b">AuthState</code>一起，前面您定义了一个<code class="du lt lu lv lw b">AuthorizationServiceConfiguration</code>对象和一个<code class="du lt lu lv lw b">AuthorizationService</code>对象。您可以在启动时初始化<code class="du lt lu lv lw b">AuthorizationServiceConfiguration</code>对象，方法是传入您的应用程序需要的各种端点。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="6478" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">至于将用于所有auth调用的对象<code class="du lt lu lv lw b">AuthorizationService</code>，您可以通过创建一个新的<code class="du lt lu lv lw b">AppAuthConfiguration</code>对象来初始化它，然后将它传递给构造函数。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="834d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里值得注意的是，我为<em class="lq">添加了一个<code class="du lt lu lv lw b">BrowserAllowList</code>，我的应用程序将支持这些自定义标签</em> <strong class="ir ht"> </strong>。虽然这不是<em class="lq">必须的，但</em>在设置你的应用程序时，这是一个有趣的功能，我强烈建议你通过<code class="du lt lu lv lw b">AppAuthConfiguration</code>查看可用的选项。</p><p id="232c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，是时候开始我们的认证请求了！这是事情变得有点复杂的地方，但它肯定是可管理的。首先创建一个新函数，我称之为我的<code class="du lt lu lv lw b">attemptAuthorization</code>，当用户点击登录按钮或执行其他需要授权的动作时，您可以调用这个函数。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="fd2a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为您是按照PKCE身份验证流程进行的，所以您需要创建一个代码验证器和一个代码质询来处理您的请求。您可以从代码验证器开始，从一个<code class="du lt lu lv lw b">SecureRandom()</code>对象生成一个字节数组，然后用Base64标志<code class="du lt lu lv lw b">URL_SAFE</code>、<code class="du lt lu lv lw b">NO_PADDING</code>和<code class="du lt lu lv lw b">NO_WRAP</code>对其进行编码，以准备发送给Google OAuth。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="891f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">代码挑战稍微有点微妙，但仍然不可怕。这是Google文档目前提供的示例:</p><pre class="kd ke kf kg fd mm lw mn mo aw mp bi"><span id="cf96" class="mq km hs lw b fi mr ms l mt mu">code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))</span></pre><p id="72b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有点帮助，但不完美，对吧？这意味着<code class="du lt lu lv lw b">code_verifier</code>应该使用SHA256算法散列，然后再次编码为Base64。您可以用这三行代码来实现:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="86b9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这两部分数据，您就可以开始使用AppAuth库提供的<code class="du lt lu lv lw b">Builder</code>来创建您的<code class="du lt lu lv lw b">AuthorizationRequest</code>。这将需要您之前创建的<code class="du lt lu lv lw b">AuthorizationServiceConfiguration</code>对象、您的客户端ID、响应类型(对于本例，您可以只使用<code class="du lt lu lv lw b">ResponseTypeValues.CODE</code>)、您的重定向URI以及您刚刚创建的代码验证器和代码质询(您<em class="lq">可以只使用代码验证器并在将代码验证器/质询与您的<code class="du lt lu lv lw b">AuthorizationRequest</code>相关联时使用<code class="du lt lu lv lw b">“plain”</code>质询方法，但不推荐)。这也是您将范围与用户相关联的地方。</em></p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="cdee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您有IDP需要的任何其他参数，您可以通过创建一个新的<code class="du lt lu lv lw b">HashMap&lt;String, String&gt;</code>对象并通过一个<code class="du lt lu lv lw b">setAdditionalParameters()</code>调用将其添加到请求构建器来将它们添加到这个请求中。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a48f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦你设置好了，你就可以调用构建器上的<code class="du lt lu lv lw b">build()</code>，从<code class="du lt lu lv lw b">authorizationService</code>对象中检索一个意图，然后为一个<code class="du lt lu lv lw b">Result</code>启动这个意图。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9dcb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了给你一个我如何发射和接收这个<code class="du lt lu lv lw b">Intent</code>的例子，我创建了一个新的发射器来发射<code class="du lt lu lv lw b">Intent</code>，然后监听<code class="du lt lu lv lw b">Result</code>。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4b8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一点上，你应该希望能够点击一个登录按钮来调用<code class="du lt lu lv lw b">attemptAuthorization()</code>，然后看到谷歌认证屏幕</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es kc"><img src="../Images/19d1337fc2a7d0915fdfeb1c4cb55048.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*yTkUKWLzsZ1TrMwfFobfiA.png"/></div></figure><p id="4a1a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">和驱动器范围批准屏幕，因为该范围要求用户提供额外的权限。这里需要注意的一点是，请求的驱动器权限可以访问<em class="lq">所有用户的驱动器文件</em>，因此有一个额外的警告，因为应用程序本身尚未验证，尽管这是目前为止您所能获得的。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mv"><img src="../Images/723f577998ea045b5ae444ebf904ccc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wu4pDElJ63KZA4-lC_zWeQ.png"/></div></div></figure><p id="b2ef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下一节中，您将了解收到的响应以及如何使用它们来更新您的应用的身份验证状态。</p><h1 id="bdfd" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">处理授权响应和令牌交换</h1><p id="edde" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">在您的IDP收到您的<code class="du lt lu lv lw b">AuthorizationRequest</code>后，它将被处理，一个响应将被发送到您的应用程序，该响应将被重定向回您指定的与<code class="du lt lu lv lw b">Intent</code>关联的<code class="du lt lu lv lw b">Activity</code>。这个响应(如下所示的例子)将包含一个可以用来交换令牌的代码。</p><pre class="kd ke kf kg fd mm lw mn mo aw mp bi"><span id="598f" class="mq km hs lw b fi mr ms l mt mu">com.ptruiz.authtest:/oauth2redirect?state=nZGBhSGUj7r8eCy4y3EGfA<br/><strong class="lw ht">&amp;code=4/0AX4XfWi8xQr5DkoSPSXEKftoY050pLdRn1aKeavmHMjatxlUeaYxTVLPjjXLb4hmHLOZKw</strong><br/>&amp;scope=email%20profile%20https://<a class="ae jn" href="http://www.googleapis.com/auth/userinfo.profile%20https://www.googleapis.com/auth/userinfo.email%20openid%20https://www.googleapis.com/auth/drive.file" rel="noopener ugc nofollow" target="_blank">www.googleapis.com/auth/userinfo.profile%20https://www.googleapis.com/auth/userinfo.email%20openid%20https://www.googleapis.com/auth/drive.file</a><br/>&amp;authuser=0&amp;prompt=consent</span></pre><p id="6629" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您对这个响应要做的第一件事是将相关信息提取到<code class="du lt lu lv lw b">AuthorizationResponse</code>和<code class="du lt lu lv lw b">AuthorizationException</code>对象中。此外，由于这个响应包含一个<strong class="ir ht">状态</strong>参数，您可以用它来更新<code class="du lt lu lv lw b">AuthState</code>对象。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a51c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设<code class="du lt lu lv lw b">authorizationResponse</code>不是<code class="du lt lu lv lw b">null</code>，你可以用它创建一个新的<code class="du lt lu lv lw b">TokenExchangeRequest</code>。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="fdcb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当这个请求被转换成序列化的JSON字符串时，它包含在整个身份验证过程中使用的各种数据。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="5126" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，要发送这个请求，你只需要调用你的<code class="du lt lu lv lw b">AuthorizationService</code>上的<code class="du lt lu lv lw b">performTokenRequest</code>函数，然后监听<code class="du lt lu lv lw b">response</code>。如果没有出现异常，那么您可以更新您的<code class="du lt lu lv lw b">AuthState</code>并将接收到的ID令牌转换为<code class="du lt lu lv lw b">JWT</code>来提取用户的标识信息。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="ccfd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在继续之前，有必要更详细地讨论一下这些回答。这是您的应用程序收到令牌交换响应时的样子:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="616d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里特别有趣的是<code class="du lt lu lv lw b">id_token</code>属性，因为它目前是一个长字符串，在被解码成<code class="du lt lu lv lw b">JWT</code>对象之前没有什么意义。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="124d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，一旦您能够通过前面导入的Auth0 JWT库解码这个令牌，您就可以获得下面的JSON，它可以用于显示用户概要信息。对于我的示例应用程序，我基于AuthState更新了一个<code class="du lt lu lv lw b">LiveData</code>对象，但是一旦<code class="du lt lu lv lw b">JWT</code>对象可用，您可以以任何适合您项目的方式更新您的UI。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es kc"><img src="../Images/6fa75c7fa0f4bef1187a04f0c933ae07.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*EDGbKP90w9ptS-lmiI2HYg.png"/></div></figure><h1 id="705d" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">进行API调用</h1><p id="0efa" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">既然您已经能够对用户进行身份验证，那么是时候让他们做点什么了。返回谷歌云控制台，打开<strong class="ir ht"> API库</strong>部分。在那里，搜索<strong class="ir ht"> Google Drive API </strong>，选择它，然后点击蓝色的<strong class="ir ht">启用</strong>按钮。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mw"><img src="../Images/8b24a597e536d45f71bdcbf9272722b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtpzTNoEVNF9JD87cPPXDQ.png"/></div></div></figure><p id="1bed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然您已经请求了必要的驱动器范围，但是仍然需要启用API来查看文件并与之交互。一旦你完成启用API，返回到你的应用程序。</p><p id="1863" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用来自<code class="du lt lu lv lw b">AuthState</code>对象的<code class="du lt lu lv lw b">performActionWithFreshTokens</code>调用来进行API调用。这种方法的好处在于，如果令牌已经过期，它会尝试使用存储的刷新令牌自动刷新令牌，为您节省一点时间和精力。举个简单的例子，这就是在点击按钮后，如何使用coroutines和OkHttp使用这个方法发出网络请求。此请求将尝试为用户检索驱动器文件列表。这里需要注意的一件重要事情是，访问令牌被用在了一个<code class="du lt lu lv lw b">Authorization</code>头中。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="179f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到，响应作为另一个JSON对象返回，其中充满了这个几乎为空的帐户的数据，尽管Google也提供了其他API，并且可以以类似的方式进行交互。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="dc79" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">注销</h1><p id="007c" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">最后，你需要为你的用户提供一种退出应用程序的方式。您可能记得之前您在<strong class="ir ht"> AndroidManifest.xml </strong>文件中添加了注销重定向，尽管我提到Google OAuth <em class="lq">不支持注销重定向。如果您正在使用一个IDP，而<em class="lq">支持这个功能(例如，Ping Identity)，那么您可以使用AppAuth库中的<code class="du lt lu lv lw b">EndSessionRequest</code>对象，如下所示:</em></em></p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="3766" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有这些都需要访问令牌和注销重定向路径，因为您的注销URL是在设置<code class="du lt lu lv lw b">authServiceConfig</code>对象时添加的。</p><p id="7551" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你正在使用Google OAuth，或者任何其他不支持注销重定向的服务，那么你仍然可以使用他们的撤销或注销URL，同时在本地清除你的应用状态。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="771e" class="kl km hs bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">包扎</h1><p id="198c" class="pw-post-body-paragraph ip iq hs ir b is lj iu iv iw lk iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">在本教程中，您已经了解了一些OAuth 2的PKCE认证流程，以及如何通过AppAuth库在您的Android应用程序中实现它。本教程还介绍了Google的OAuth服务，以及如何使用它来访问Google APIs，尽管同样的逻辑可以应用于大量的IDP。希望这将有助于简化向您的应用程序添加身份验证和授权的过程，以便您可以制作更好、更安全的应用程序。</p></div></div>    
</body>
</html>