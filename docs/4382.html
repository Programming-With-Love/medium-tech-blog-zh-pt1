<html>
<head>
<title>Kotlin Native. Multithreading without Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林本地人。无协程的多线程</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/kotlin-native-multithreading-without-coroutines-56599ea33620?source=collection_archive---------1-----------------------#2021-09-24">https://medium.com/google-developer-experts/kotlin-native-multithreading-without-coroutines-56599ea33620?source=collection_archive---------1-----------------------#2021-09-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/9982e95287268f37c04f2aa5884cbc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tUyPsjM8mctWV9pIrbZKkw.png"/></div></figure><p id="b8f2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在之前的故事中，我们讨论了如何在Kotlin Native中使用协程进行简单的多线程处理。这次我们将讨论使用Kotlin native的Native机制来处理异步工作。</p><p id="ab93" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们在Kotlin多平台应用程序中使用Ktor库时，我们知道所有异步工作都是在Kotlin本机机制的帮助下实现的。我们来看看，试着在自己的网络客户端中应用一下。</p><p id="fbf8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，我们将为我们的iOS和Android Http客户端制作一个通用接口。我们将以不同方式实现它们，但没有预期/实际的机制:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="e053" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以使用OkHttp来提供androidMain中的所有逻辑。对于iOS，我们将在通用模块的iOSMain部分使用NSUrlSession。在iOSMain中，所有的原生框架(如网络)都是可用的和可访问的。</p><p id="8632" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将使用标准的NSUrlSession方法和一些代表来接收响应:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="9ec0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，在这一点上，我们需要提供一些机制来从后台调用我们的任务。为此科特林本地有工人。Worker是一个作业队列，您可以在其上调度作业在不同的线程上运行。每个工作线程都在自己的线程中执行工作:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="2976" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有几个细节:<br/> 1。我们需要使用TransferMode。对于线程安全的工作是安全的。</p><p id="df6c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.我们需要冻结一段代码，以便在不同的线程中执行它。在我的例子中，我使用share()扩展来封装冻结。</p><p id="6e7d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">作为执行的结果，我们得到了一些未来。为了处理它的完成和结果值，我们可以使用consume:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="3fa5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们也可以将完成发送到另一个线程中。例如，它可以是主线程和主队列:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="2aa3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这可以用我们以前创建自己的MainDispatcher的方法来完成。<br/>让我们将它应用到我们的示例中。此外，我们需要冻结我们将在客户端中使用的所有参数和块:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="f41e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们用委托方法实现自己的网络客户机时，我们可以将所有数据作为独立的部分接收。所以我们需要使用字节数组将所有的数据保存在一起:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="3e83" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而且还有一个很大的问题。当冻结我们客户的所有东西时，我们甚至冻结了var变量。现在，我们无法在不崩溃的情况下更改数据。<br/>为了处理它，我们需要使用AtomicReference API。AtomicReferences保存冻结变量的链接，但允许更改它们的值:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="c052" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用AtomicReferences时存在潜在的泄漏风险。所以我们需要在工作结束后清除它们:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="2207" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">完成了。让我们从我们的iOSMain端调用:</p><figure class="jk jl jm jn fd ii"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="2d10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">并且不需要任何协程就可以工作:<br/><a class="ae jj" href="https://github.com/anioutkazharkova/kotlin_native_network_client" rel="noopener ugc nofollow" target="_blank">https://github . com/anioutkazharkova/kot Lin _ native _ network _ client</a></p></div></div>    
</body>
</html>