<html>
<head>
<title>PL/SQL Code Coverage: 12 Things Developers Will Love About Oracle Database 12c Release 2 Part 12</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PL/SQL代码覆盖率:开发人员会喜欢的关于Oracle Database 12c第2版第12部分的12件事</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/pl-sql-code-coverage-12-things-developers-will-love-about-oracle-database-12c-release-2-part-12-1efeddb2c22b?source=collection_archive---------0-----------------------#2017-10-25">https://medium.com/oracledevs/pl-sql-code-coverage-12-things-developers-will-love-about-oracle-database-12c-release-2-part-12-1efeddb2c22b?source=collection_archive---------0-----------------------#2017-10-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d846" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列中，我们已经介绍了许多新功能。如果有的话，你可以马上使用。其他部分你要等一会儿。</p><p id="d811" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在任何情况下，当您升级到12.2时，您都需要测试所有代码，以确保它能按预期工作。这就带来了一个问题:</p><p id="075a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">"测试实际上运行了我多少代码？"</p><p id="24a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">覆盖度量将对此有很大帮助。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/2b7a617449e414237c7da8175495990a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Y8F4XzsNWnyJhgdJ.png"/></div></figure><p id="e049" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对测试进行简单的行级分析是不够的。要了解原因，请考虑以下代码:</p><p id="7c76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有一个返回参数并调用dbms_output的基本函数。</p><p id="b8ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该过程在一条if语句中调用该函数两次:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="6d88" class="jp jq hh jl b fi jr js l jt ju">create or replace function f (p int) <br/>  return int as <br/>begin <br/>  dbms_output.put_line('Executed: ' || p); <br/>  return p; <br/>end; <br/>/ </span><span id="3a7f" class="jp jq hh jl b fi jv js l jt ju">create or replace procedure p is <br/>begin <br/>  if f(1) = 1 or f(2) = 2 then <br/>    dbms_output.put_line('this'); <br/>  else <br/>    dbms_output.put_line('that'); <br/>  end if; <br/>end p; <br/>/</span></pre><p id="10c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于短路求值，f(2)永远不会执行！您可以从输出中看到这一点:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="4e84" class="jp jq hh jl b fi jr js l jt ju">SQL&gt; exec p; Executed: 1 this</span></pre><p id="c6c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在生产线上工作的任何人都会错误地将此报告为完全覆盖。</p><p id="3438" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了克服这一点，你需要“基本块”执行的细节。</p><p id="39ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么什么是“基本块”呢？</p><p id="58f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一段你要么完全运行要么根本不运行的代码。代码总是恰好属于一个基本块。例如:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="f22a" class="jp jq hh jl b fi jr js l jt ju">if f(1) = 1 or f(2) = 2 then <br/>  dbms_output.put_line('this'); <br/>else <br/>  dbms_output.put_line('that'); <br/>end if;</span></pre><p id="6d64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有四个基本块。一个用于对f的每次调用，两个用于对dbms_output.put_line的调用。</p><p id="ae86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新的代码覆盖率功能对这些基本块进行测量和报告。</p><p id="57db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用它很容易。首先，您需要创建覆盖率表来存储指标:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="f719" class="jp jq hh jl b fi jr js l jt ju">exec dbms_plsql_code_coverage.create_coverage_tables;</span></pre><p id="8dc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后在测试之前调用start_coverage，在测试之后调用stop_coverage:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="7436" class="jp jq hh jl b fi jr js l jt ju">declare <br/>  run_id pls_integer; <br/>begin <br/>  run_id := dbms_plsql_code_coverage.start_coverage('TEST'); <br/>  p; <br/>  dbms_plsql_code_coverage.stop_coverage; <br/>end; <br/>/</span></pre><p id="e8ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，您可以通过查询保存这些详细信息的dbmspcc*表来获取指标:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="b880" class="jp jq hh jl b fi jr js l jt ju">select owner, name, type, <br/>       round( ( sum(covered)/count(*) * 100), 2) pct_covered <br/>from   dbmspcc_runs r <br/>join   dbmspcc_units u <br/>on     r.run_id = u.run_id <br/>join   dbmspcc_blocks b <br/>on     r.run_id = b.run_id <br/>and    u.object_id = b.object_id <br/>where  r.run_comment = 'TEST' <br/>group by owner, name, type; </span><span id="055f" class="jp jq hh jl b fi jv js l jt ju">OWNER NAME  TYPE       PCT_COVERED <br/>----- ----- ---------- ----------- <br/>CHRIS P     PROCEDURE           50 <br/>CHRIS F     FUNCTION           100</span></pre><p id="d38a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一切都很好。但是总有一些你的测试没有覆盖到的代码。可能是弃用了，所以不需要测试。或者是“以防万一”的代码，以涵盖理论上可能但实际上不可能的情况。比如臭名昭著的“when others”异常处理程序。</p><p id="dd03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您希望从报告中排除这些部分。幸运的是，您可以使用coverage pragma。通过将行标记为“不可行”,您可以从报告中过滤掉这些行:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="f070" class="jp jq hh jl b fi jr js l jt ju">create or replace procedure p is <br/>begin <br/>  if f(1) = 1 or f(2) = 2 then <br/>    dbms_output.put_line('this'); <br/>  else <br/>    pragma coverage ('NOT_FEASIBLE'); <br/>    dbms_output.put_line('that'); <br/>  end if; <br/>end p; <br/>/</span></pre><p id="744e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重新运行测试，您可以在报告中隐藏不可测试的部分！</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="6e65" class="jp jq hh jl b fi jr js l jt ju">select owner, name, type, <br/>       round( ( sum(covered)/count(*) * 100), 2) pct_covered <br/>from   dbmspcc_runs r <br/>join   dbmspcc_units u <br/>on     r.run_id = u.run_id <br/>join   dbmspcc_blocks b <br/>on     r.run_id = b.run_id <br/>and    u.object_id = b.object_id <br/>where  r.run_comment = 'TEST' <br/>and    b.not_feasible = 0 <br/>group  by owner, name, type; </span><span id="bdd4" class="jp jq hh jl b fi jv js l jt ju">OWNER NAME TYPE      PCT_COVERAGE <br/>----- ---- --------- ------------ <br/>CHRIS P    PROCEDURE        66.67 <br/>CHRIS F    FUNCTION           100</span></pre><p id="07e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你真的想的话，你可以通过将代码封装在两个覆盖pragmas中来排除整个代码段。第一个起始不可行开始，第二个不可行结束:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="feb8" class="jp jq hh jl b fi jr js l jt ju">begin S<br/>  pragma coverage ('NOT_FEASIBLE_START'); <br/>  a_section(); <br/>  of_untestable_code(); <br/>  pragma coverage ('NOT_FEASIBLE_END'); <br/>end; <br/>/</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="96d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kd">全文原载于2016年11月10日</em><a class="ae ke" href="https://blogs.oracle.com/sql/12-things-developers-will-love-about-oracle-database-12c-release-2" rel="noopener ugc nofollow" target="_blank"><em class="kd">【blogs.oracle.com】</em></a><em class="kd">。</em></p></div></div>    
</body>
</html>