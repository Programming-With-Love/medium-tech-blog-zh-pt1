# 5 个有用的 RxJS 解决方案

> 原文：<https://medium.com/compendium/5-helpful-rxjs-solutions-d34f7c2f1cd9?source=collection_archive---------0----------------------->

## 日常问题

![](img/42396532f6982e9d08e2c8d98e8e4f8e.png)

RxJS 是一个 javascript 库，允许我们使用可观察的流进行反应式编码。利用 RxJS 提供的观察值和函数，我们可以编写可读的异步代码。

如果你正在使用 Angular，你已经在使用它了，因为框架是建立在它之上的。尽管如此，许多开发人员除了在 http 请求上调用 subscribe 之外，并没有更多地使用它。

# 开始使用带有管道操作符的 RxJS！

RxJS 背后的许多力量来自它的管道运营商。你问的是什么？这些基本上是可以在管道中按照执行顺序“堆叠”以组成新流的函数。“这将创建更好的解决方案，可读性更强，代码通常更少。

有许多关于最佳实践的文章，并解释了这些操作符的作用。

> 你绝对应该读一读这几本书！

但是，尽管它们中的许多可能很棒，我发现它们包含的例子经常不能反映我们在日常编码中发现的问题。所以我决定采取另一种方法，给你 5 个解决日常问题的方法。

# 1.简化多个 HTTP 请求的处理。

让我们从 web 程序员日常生活中最常见的场景之一开始，即:处理多个 http 请求。许多人可能已经知道这一点，但由于这是我经常看到的事情，我决定把它包括进来。

## 场景 1:顺序请求。在下一个请求中使用以前请求中的数据。

我们经常需要根据早期请求的响应来提出请求。在下面的场景中确实如此。

*   我们首先基于 id 检索帖子。
*   使用第一次调用的 post 响应，我们希望检索 post 的用户。
*   在我们得到用户之后，我们希望得到被检索用户的所有帖子。

正如我们所看到的，这导致了嵌套混乱。想象一下其他场景，我们可能希望在将响应传递给下一个请求之前对其进行一些操作。这可能会使筑巢变得更糟。

## 解决方案:开关图

这可以用操作符 [*switchMap*](https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap) 轻松简化。 *switchMap* 的功能在于它的名字。在第一个可观察对象发出后，它订阅一个内部可观察对象。

这非常适合我们的场景。我们希望使用我们的第一个帖子的可观察对象，并将结果映射到一个加载用户的新的可观察对象。

操作员将获取帖子的外部可观察值，当帖子发出时，*将*切换到“用户”的内部可观察值，并且*将*外部可观察值的结果映射到我们的内部可观察值。

> **注意:**值得注意的 switchMap 的其他特性是，如果一个新的可观察值在前一个值完成之前发出，则能够取消前一个可观察值。这在创建[自动完成](https://en.wikipedia.org/wiki/Autocomplete)特性时非常有用。

## 场景 2:发出并行请求。

有时候我们并不关心多个请求完成的顺序。我们可能只是想在它们全部完成后收集它们。假设我们只有一个用户标识。我们希望获得用户发布的所有帖子和关于同一用户的元数据。

由于这两个请求相互独立，它们完成的顺序并不重要。然而，我们确实想等到我们从两者都得到数据。通常在加载数据时，我们也想显示某种加载指示器。

下面是一个简单的解决方案，我们修补一个对象来表明我们有数据。

你可以同意这似乎不是一个好的解决方案。想象一下，如果我们需要发出更多的并行请求。代码会很快变得冗长而不可读。

## 解决方案:forkJoin

使用 RxJs，只需几行代码就可以用操作符 [forkJoin](https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin) 解决这个问题。对于那些习惯于承诺的人来说，这个操作符的工作方式和承诺差不多..]).在操作符内部，所有请求并行执行，并将在所有请求都解决后发出。

> **注意**:请注意，如果任何一个请求抛出错误，您将丢失其他请求的值，即使它们已经完成。如果你关心他们，你就必须抓住他们。

# 2.将多个流合并为一个流以实现搜索功能

在我的一个项目中，我们实现了智能搜索。我们的搜索请求由多个来源组成，例如

*   来自输入字段的搜索词$ term
*   一组 metadataFilters$(范围，复选框)
*   可以画在地图上的一组多边形
*   currentResultPage$来自带有分页按钮的结果页

源数据来自不同的组件，因此我们需要一种易于阅读的方式将它们组合成一个方便的流。

## 解决方案:组合测试

[combineLatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest) 函数将一个流数组合并成一个流数组，并在其中一个流发生变化时发出所有流。

现在我们有了进行搜索所需的所有资源。每次这些来源发生变化时，我们都会进行新的搜索。这意味着每次我们点击 next 按钮或在输入框中输入内容时，我们都会发出一个新的请求。但这是我们想要的吗？这将意味着对后端的大量请求。

我们可以用一个新的操作符[去抖时间](https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime)和我们第一个场景中的朋友[切换图](https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap)来进一步改进我们的解决方案。请记住，之前 *switchMap* 的另一个特性是，如果在当前请求完成之前提出了新的请求，它会取消之前的请求。这意味着我们总是从最后一个请求中得到结果。

**改进我们的解决方案:取消快速请求**

新操作符 *debounceTime* 也具有取消功能，但是这个操作符取消了在所提供的 dueTime 内发出的任何新值。假设我们将 dueTime 设置为 1000 毫秒。这意味着，如果我们单击分页中的 next 按钮，并在 1 秒钟之前再次单击它，将不会发出新的请求。

当我们一前一后使用这两个操作符时，我们可以在*反跳时间*的帮助下，取消在所提供的 dueTime 内做出的任何新请求。我们熟悉的 *switchMap* 会取消之前的请求，如果它还没有完成，给我们最后的结果。

**改进我们的解决方案:取消平等请求**

我们现在已经减少了不必要的请求，只在交互*稳定*时发出请求。但这意味着新的问题出现了。假设我们在过滤器中选中一个复选框，然后立即再次将其取消选中。这将触发一个具有与我们刚才相同响应的请求。

输入 [distinctUntilChanged](https://www.learnrxjs.io/learn-rxjs/operators/filtering/distinctuntilchanged) 运算符！这将停止当前值与先前值相同的任何发射。厉害！

或者是？我们将看到 *distinctUntilChanged* 在我们的例子中不起作用。尽管我们的请求是相同的，它仍然会产生一个新的请求事件。为什么会这样！？

这是因为 *distinctUntilChanged* 默认使用' === '比较。这意味着当使用对象和数组时，如果它们有相同的引用，它们就被认为是相同的。为了让它工作，我们需要提供一个比较函数来比较一些独特的东西，比如一个 id。

**更多问题？！我的信号源没有发射**

重要的是要注意到*combine test*函数不会发出，直到它的每个源可观测量至少发出一次。

有时你可能会发现*组合测试*不发射。如果任何源是类型[主题](https://www.learnrxjs.io/learn-rxjs/subjects)或[重放主题](https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject)，则可能出现这种情况。这些可观察值不需要初始值，因此*combine test*不会发出任何东西，直到您对它们至少调用了一次 next。

通常，在创建可观测量时，最好使用[行为主体](https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject)，但是如果它们不适合您的用例，可以使用 [startWith](https://www.learnrxjs.io/learn-rxjs/operators/combination/startwith) 操作符来缓解问题。

假设我们的搜索术语$ observable 是一个 ReplaySubject。它没有被提供一个起始值，并且 *combineLatest* 不会发出一个值，直到你输入一些东西。然后，您可以轻松地用管道连接 *startWith* ，并提供一个空字符串作为它的起始值。

# 3.单击一个按钮，使用流中的数据作为参数进行 http 请求

假设您有一个按钮，单击该按钮将下载一个包含用户所有帖子的 excel 表格。该请求需要当前选定用户的用户标识。但是用户对象被存储为可观察对象。

一个简单的解决方案可能是这样的。

这有什么错呢？这里最大的问题是，我们没有在调用 click 函数的同时获取 userId。这意味着极有可能出现竞态条件。此外，下载所涉及的代码是分散的，并不包含在一个函数中。

**解决方案:使用 LatestFrom、fromEvent 和 switchMap**

我们首先用函数 [fromEvent](https://www.learnrxjs.io/learn-rxjs/operators/creation/fromevent) 将点击事件提升为一个流。您可能还记得上一个例子中的*组合测试*。我们能这样做吗？

我们可以，但是记住 *combineLatest* 会在 observables 发出的任何时候发出，所以每次按下下载按钮时都会下载，而且每次用户改变时也会下载。

[withLatestFrom](https://www.learnrxjs.io/learn-rxjs/operators/combination/withlatestfrom) 只会在源可观测值发出时添加可观测值的最后一个值。

> **注意:**注意，传递给 withLatestFrom 的可观察对象需要在源可观察对象发出之前发出一次。

这样，我们可以添加 user$ stream 的值，但是只有当 click 事件被触发时才会发出。然后，我们使用熟悉的 switchMap 将流切换到下载调用。

# 4.使用筛选运算符而不是 if/else

在我们作为程序员的日常生活中，当处理条件语句时，我们经常会用到 if/else 语句。当用流编码时，处理条件的需要没有什么不同。但是有一种更为 T2 反应式的方法来处理条件句。

**场景:根据类型提出不同的请求**

假设我们有两种不同类型的用户。一个读者和作家。读者只能看帖子，不能写帖子。作者当然被允许读和写帖子。现在想象一下，当点击 UI 中的用户时，我们希望为读者和作者加载不同的内容。对于读者，我们可能希望加载用户已经阅读的所有文章，对于作者，我们可能希望加载用户已经创建的所有文章。解决方案可能看起来像这样。

正如我们所见，这很快变得不可读。然后图像添加更多的条件。

**解决方案:过滤器**

[过滤器](https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter)操作符将只允许通过所提供条件的值通过。

> **注意:**RxJs 过滤器不要与数组使用的过滤器函数混淆。这个过滤水流。如果发出的值是要过滤的数组，则使用 map 运算符返回过滤后的数组:*map(array =>array . filter(…)*

使用 filter 操作符，我们可以将流分成每种类型。这比在流中执行条件要好得多。

# 5.使两个不同的可观测量共享同一个订阅。

有时你可能有两个观察值，它们发出相同类型的值，但调用相同的函数。它可能是这样的。

编程的一个好习惯就是保持“干爽”(不要重复自己)。所以订阅两个相等的流感觉非常没有必要。

**解决方案:合并**

为了避免订阅每个单独的可观察对象并在它们的 subscribe 块中调用相同的函数，这可以通过使用 [*merge*](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge) 函数来简化。这将把多个可观测性变成一个可观测性。

# 包扎

那都是 peeps！今天我们学习了 5 个 RxJS 食谱，它们改善了常见问题的解决方案。我希望你能找到有用的。

你知道其他有用的解决方法吗？请在下面的评论中告诉我。

现在出去用 RxJS 做出更好更清洁的解决方案吧！

> 特别感谢 Jan Greger Hemb 和 Erik Tallang 审阅了这篇博文，并提出了宝贵的意见以使它变得更好！