<html>
<head>
<title>Why would I want to fitsSystemWindows?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我为什么要安装系统窗口？</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec?source=collection_archive---------0-----------------------#2015-12-17">https://medium.com/androiddevelopers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec?source=collection_archive---------0-----------------------#2015-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure><div class=""/><p id="03a2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">系统窗口是屏幕的一部分，系统在其中绘制非交互(对于状态栏)或交互(对于导航栏)内容。</p><p id="75ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数情况下，你的应用程序不需要在状态栏或导航栏下绘制，但是如果你这样做了:你需要确保交互元素(如按钮)不会隐藏在它们下面。这就是<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/view/View.html#attr_android:fitsSystemWindows" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">android:fitsSystemWindows</strong></a><strong class="ir ht">="true"</strong></code>属性的默认行为:它设置视图的填充以确保内容不会覆盖系统窗口。</p><p id="f464" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有几件事要记住:</p><ul class=""><li id="84c8" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jn jo jp jq b"><strong class="ir ht">fitsSystemWindows</strong></code></li><li id="38b8" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><strong class="ir ht">插入总是相对于整个窗口</strong> —插入甚至可以在布局发生之前应用，所以不要假设默认行为在应用填充时知道视图的位置</li><li id="e5e6" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><strong class="ir ht">您设置的任何其他填充将被覆盖</strong> —您会注意到，如果您在同一视图上使用<code class="du jn jo jp jq b">android:fitsSystemWindows="true"</code>，则<code class="du jn jo jp jq b">paddingLeft</code> / <code class="du jn jo jp jq b">paddingTop</code> /etc无效</li></ul><p id="e0b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而且，在很多情况下，比如全屏视频播放，这就足够了。你会有一个没有属性的全出血视图和另一个带有<code class="du jn jo jp jq b">android:fitsSystemWindows="true"</code>的全屏<code class="du jn jo jp jq b">ViewGroup</code>来显示你想要嵌入的控件。</p><p id="7f87" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者你可能想让你的<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code>在一个透明的导航条下面滚动——通过结合使用<code class="du jn jo jp jq b">android:fitsSystemWindows="true"</code>和<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipToPadding" rel="noopener ugc nofollow" target="_blank">android:clipToPadding</a>="false"</code>，你的滚动内容将在控件后面，但是当滚动到底部时，最后一个项目仍将被填充到导航条上面(而不是隐藏在下面！).</p><h1 id="d69b" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">定制<em class="le"> fitsSystemWindows </em></h1><p id="d514" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">但是这种默认行为仅仅是:默认。在<a class="ae jr" href="http://developer.android.com/about/versions/kitkat.html" rel="noopener ugc nofollow" target="_blank"> KitKat </a>和更低版本中，你的自定义视图可以覆盖<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/view/View.html#fitSystemWindows(android.graphics.Rect)" rel="noopener ugc nofollow" target="_blank">fitSystemWindows()</a></code>并提供你想要的任何功能——如果你已经使用了insets，只需返回<code class="du jn jo jp jq b">true</code>或者如果你想给其他视图一个机会，返回false。</p><p id="ba3a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，在<a class="ae jr" href="http://developer.android.com/about/versions/lollipop.html" rel="noopener ugc nofollow" target="_blank"> Lollipop </a>和更高版本的设备上，我们提供了一些新的API，使得定制这种行为更加容易，并且与视图的其他行为保持一致。取而代之的是覆盖<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/view/View.html#onApplyWindowInsets(android.view.WindowInsets)" rel="noopener ugc nofollow" target="_blank">onApplyWindowInsets()</a></code>，它允许视图根据需要消耗尽可能多或尽可能少的insets，并且能够根据需要在子视图上调用<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/view/View.html#dispatchApplyWindowInsets(android.view.WindowInsets)" rel="noopener ugc nofollow" target="_blank">dispatchApplyWindowInsets()</a></code>。</p><p id="4dec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更好的是，<strong class="ir ht">如果你只需要Lollipop和更高的</strong> — <strong class="ir ht"> </strong>上的自定义行为，你甚至不需要子类化你的视图，你可以使用<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html#setOnApplyWindowInsetsListener(android.view.View,%20android.support.v4.view.OnApplyWindowInsetsListener)" rel="noopener ugc nofollow" target="_blank">ViewCompat.setOnApplyWindowInsetsListener()</a></code>，它将比视图的<code class="du jn jo jp jq b">onApplyWindowInsets()</code>优先。<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html" rel="noopener ugc nofollow" target="_blank">ViewCompat</a></code>还提供了不进行版本检查调用<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html#onApplyWindowInsets(android.view.View, android.support.v4.view.WindowInsetsCompat)" rel="noopener ugc nofollow" target="_blank">onApplyWindowInsets(</a></code><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html#onApplyWindowInsets(android.view.View, android.support.v4.view.WindowInsetsCompat)" rel="noopener ugc nofollow" target="_blank"><em class="lk">)</em></a><code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/view/ViewCompat.html#dispatchApplyWindowInsets(android.view.View, android.support.v4.view.WindowInsetsCompat)" rel="noopener ugc nofollow" target="_blank">dispatchApplyWindowInsets()</a></code>的helper方法。</p><h1 id="5201" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">自定义fitsSystemWindows的示例</h1><p id="49f4" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">虽然基本布局(<code class="du jn jo jp jq b">FrameLayout</code>、<code class="du jn jo jp jq b">LinearLayout</code>等)使用默认行为，但是有许多布局<strong class="ir ht">已经</strong>定制了它们对<code class="du jn jo jp jq b">fitsSystemWindows</code>的反应，以适应特定的用例。</p><p id="1a57" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个例子是<a class="ae jr" href="http://www.google.com/design/spec/patterns/navigation-drawer.html" rel="noopener ugc nofollow" target="_blank">导航抽屉</a>，它需要跨越整个屏幕，出现在透明的状态栏下。</p><figure class="lm ln lo lp fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/085cd731c72a7c34058a30967753b4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hPTqjUnIXVhm7gYQ.png"/></div></div></figure><p id="229b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" rel="noopener ugc nofollow" target="_blank">DrawerLayout</a></code>使用<code class="du jn jo jp jq b">fitsSystemWindows</code>作为它需要插入其子元素的标志(比如主内容视图——就像默认行为一样),但是仍然按照材质设计规范在那个空间中绘制状态栏背景(默认为你的主题的<code class="du jn jo jp jq b">colorPrimaryDark</code>)。</p><p id="9a04" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你会注意到<code class="du jn jo jp jq b">DrawerLayout</code>为Lollipop和更高版本上的每个孩子调用<code class="du jn jo jp jq b">dispatchApplyWindowInsets()</code>以允许孩子视图<strong class="ir ht">也</strong>接收<code class="du jn jo jp jq b">fitsSystemWindows</code>，这与默认设置不同(正常情况下，它只会消耗insets，而孩子永远不会接收到<code class="du jn jo jp jq b">fitsSystemWindows</code>)。</p><p id="58be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html" rel="noopener ugc nofollow" target="_blank">CoordinatorLayout</a></code>还利用了覆盖它处理窗口插入的方式，允许在每个子视图上调用<code class="du jn jo jp jq b">dispatchApplyWindowInsets()</code>之前，在子视图上设置<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" rel="noopener ugc nofollow" target="_blank">Behavior</a></code>来拦截和改变视图对窗口插入的反应。它还使用<code class="du jn jo jp jq b">fitsSystemWindows</code>标志来知道是否需要绘制状态栏背景。</p><p id="34ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，<code class="du jn jo jp jq b"><a class="ae jr" href="http://developer.android.com/reference/android/support/design/widget/CollapsingToolbarLayout.html" rel="noopener ugc nofollow" target="_blank">CollapsingToolbarLayout</a></code>寻找<code class="du jn jo jp jq b">fitsSystemWindows</code>来确定何时何地绘制内容稀松布——当<code class="du jn jo jp jq b">CollapsingToolbarLayout</code>充分滚动离开屏幕时，一个全出血稀松布覆盖状态栏区域。</p><p id="ff7f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你有兴趣看一些伴随<a class="ae jr" href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html" rel="noopener ugc nofollow" target="_blank">设计库</a>的常见案例，请查看<a class="ae jr" href="https://github.com/chrisbanes/cheesesquare" rel="noopener ugc nofollow" target="_blank"> cheesesquare示例应用</a>。</p><h1 id="ff5d" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">利用系统，不要对抗它</h1><p id="ca12" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">需要记住的一点是，它不叫<code class="du jn jo jp jq b">fitsStatusBar</code>或<code class="du jn jo jp jq b">fitsNavigationBar</code>。系统窗口的构成、尺寸和位置肯定会随着平台版本的不同而变化——一个完美的例子，看看蜂巢和冰淇淋三明治之间的区别。</p><p id="a5e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请放心，您从<code class="du jn jo jp jq b">fitsSystemWindows</code> <strong class="ir ht">获得的插入内容将</strong>在所有平台版本上都是正确的，以确保您的内容不会与系统提供的UI组件重叠——如果您自定义行为，请确保避免对它们的可用性或大小做出任何假设。</p><p id="87f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"># BuildBetterApps</p><p id="50ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">评论<a class="ae jr" href="https://plus.google.com/+AndroidDevelopers/posts/ZrHY4b6YKNF" rel="noopener ugc nofollow" target="_blank"> Google+帖子</a>并关注<a class="ae jr" href="https://plus.google.com/collection/sLR0p" rel="noopener ugc nofollow" target="_blank"> Android开发模式集合</a>了解更多！</p></div></div>    
</body>
</html>