<html>
<head>
<title>Evaluating and improving the performance of your ingress controller on Oracle Kubernetes Engine with Locust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Locust评估和改进Oracle Kubernetes引擎上的ingress控制器的性能</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/evaluating-and-improving-the-performance-of-your-ingress-controller-on-oracle-kubernetes-engine-86c8b44c98c9?source=collection_archive---------1-----------------------#2022-08-25">https://medium.com/oracledevs/evaluating-and-improving-the-performance-of-your-ingress-controller-on-oracle-kubernetes-engine-86c8b44c98c9?source=collection_archive---------1-----------------------#2022-08-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cbe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我以前写过关于<a class="ae jc" rel="noopener" href="/oracledevs/experimenting-with-ingress-controllers-on-oracle-container-engine-oke-part-1-5af51e6cdb85">使用不同的入口控制器</a>和OKE。我还写过在同一个集群中同时使用多个的<a class="ae jc" rel="noopener" href="/oracledevs/experimenting-with-ingress-controllers-on-oracle-container-engine-oke-part-2-96063927d2e6">。在本文中，我们将探讨如何评估和提高入口控制器的性能。</a></p><h2 id="1ad8" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">建立</h2><p id="e1aa" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">让我们先设置我们的集群。下面是创建集群的Terraform代码:</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="9ca7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到一点:我们有四个节点池:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="1a58" class="kp je hh kl b be kq kr l ks kt">node_pools = {<br/>  np1 = { shape = "VM.Standard.E4.Flex", ocpus = 2, memory = 32, node_pool_size = 1, label = { app = "nginx"} }<br/>  np2 = { shape = "VM.Standard.E4.Flex", ocpus = 2, memory = 32, node_pool_size = 1, label = { app = "monitoring"} }<br/>  np3 = { shape = "VM.Standard.E4.Flex", ocpus = 2, memory = 32, node_pool_size = 3, label = { app = "acme"} }<br/>  np4 = { shape = "VM.Standard.E4.Flex", ocpus = 2, memory = 32, node_pool_size = 5, label = { app = "roadrunner"} }<br/>}</span></pre><p id="7790" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">节点池<strong class="ig hi"> np1 </strong>将是我们运行入口控制器的地方，<strong class="ig hi"> np2 </strong>将运行我们的监控基础设施，如Grafana和Prometheus，<strong class="ig hi"> np3 </strong>将运行我们的服务，在这种情况下，是Acme Corp的一个简单网站，最后，<strong class="ig hi"> np4 </strong>将运行<a class="ae jc" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>并生成负载。</p><h2 id="2b6f" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><em class="ku">为什么要使用四个节点池？</em></h2><p id="7d91" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">入口控制器也作为pod运行，也就是说，它们将在某个工作节点上运行。如果我们想研究性能并随后改进它，我们需要确保我们将它和它的流量与我们在这个测试中运行的其他东西隔离开来，比如监控堆栈和负载生成器。这意味着确保只有入口控制器单元位于我们选择的工作节点(以及节点池)上，同时将Prometheus、Grafana和Locust等其他单元排除在外。为了实现这一点，我们将使用OKE的功能让您在每个节点池上配置初始节点标签。我的同事<a class="ae jc" href="https://www.linkedin.com/in/a-tim-graves/" rel="noopener ugc nofollow" target="_blank"> Tim Graves </a>是Road Runner的粉丝，因为我们将访问ACME Corp .的网站作为我们的示例应用程序，他非常有帮助地建议我使用<em class="kv"> roadrunner </em>作为标签，而不是locust。那就这样吧。</p><h2 id="8eaf" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">安装监控堆栈</h2><p id="f95d" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">为kube-prometheus-stack添加舵手报告并生成舵手清单:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="c8e7" class="kp je hh kl b be kq kr l ks kt">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts<br/>helm show values prometheus-community/kube-prometheus-stack &gt; kps.yaml</span></pre><p id="4b9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用生成的清单定位节点选择器，并添加以下内容:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="0130" class="kp je hh kl b be kq kr l ks kt">app: monitoring</span></pre><p id="b407" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并将以下内容更改为false:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="6de4" class="kp je hh kl b be kq kr l ks kt">serviceMonitorSelectorNilUsesHelmValues: false</span></pre><p id="8c77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您现在可以安装kube-prometheus-stack:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="b875" class="kp je hh kl b be kq kr l ks kt">helm install kps --namespace monitoring prometheus-community/kube-prometheus-stack -f kps.yaml --create-namespace</span></pre><p id="c392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了了解入口控制器的情况，让我们连接到Grafana:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="53bc" class="kp je hh kl b be kq kr l ks kt">kubectl --namespace monitoring port-forward svc/kps-grafana 3000:80</span></pre><p id="e18d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并导入几个具有以下id的仪表板:<a class="ae jc" href="https://grafana.com/grafana/dashboards/9614-nginx-ingress-controller/" rel="noopener ugc nofollow" target="_blank"> 9614 </a>和<a class="ae jc" href="https://grafana.com/grafana/dashboards/14314-kubernetes-nginx-ingress-controller-nextgen-devops-nirvana/" rel="noopener ugc nofollow" target="_blank"> 14314 </a>。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kw"><img src="../Images/4e93745286990050856a07c6cc64e061.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*X9N6gABirJP-DCbPLgdnAQ.png"/></div></figure><h2 id="e188" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">安装入口控制器</h2><p id="8aa9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">出于这个练习的目的，我们将使用社区<a class="ae jc" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器</a>，但是您可以使用您选择的任何其他控制器。添加舵repo并生成舵清单:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="fa32" class="kp je hh kl b be kq kr l ks kt">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx<br/>helm show values ingress-nginx/ingress-nginx &gt; nginx.yaml</span></pre><p id="9ac1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">配置以下参数:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="6b6d" class="kp je hh kl b be kq kr l ks kt">controller:<br/>  nodeSelector:<br/>    app: nginx<br/>  admissionWebhooks:<br/>    patch:<br/>      nodeSelector:<br/>        app: nginx<br/>  metrics:<br/>    enabled: true<br/>    serviceMonitor:<br/>      enabled: true<br/>defaultBackend:<br/>  nodeSelector:<br/>    app: monitoring</span></pre><p id="7ce2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设置<a class="ae jc" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/" rel="noopener ugc nofollow" target="_blank">节点选择器</a>将确保您的nginx pod会以匹配的标签落在worker节点上，在本例中是<em class="kv"> nginx </em>。您现在可以安装入口控制器:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="0fc7" class="kp je hh kl b be kq kr l ks kt">helm install nginx ingress-nginx/ingress-nginx --namespace nginx -f nginx.yaml --create-namespace</span></pre><p id="4340" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并通过首先用正确的标签标识节点来验证入口控制器盒是否已到达您选择的工作节点:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="5519" class="kp je hh kl b be kq kr l ks kt">kubectl get nodes --show-labels | grep nginx<br/>10.0.109.8    Ready    node    23h   v1.24.1   app=nginx,beta.kubernetes.io/arch=amd64,beta.kubernetes.io/instance-type=VM.Standard.E4.Flex</span></pre><p id="6b1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，如果我们描述吊舱:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="81e8" class="kp je hh kl b be kq kr l ks kt">kubectl --namespace nginx get pod nginx-ingress-nginx-controller-b8d7d4dd9-86pn4 -o json | jq '.status.hostIP'<br/>"10.0.109.8"</span></pre><h2 id="9623" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">安装Acme应用程序</h2><p id="3039" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">接下来，我们将安装示例Acme公司的网站:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="c56d" class="kp je hh kl b be kq kr l ks kt">wget https://raw.githubusercontent.com/hyder/okesamples/master/ingresscontrollers/acme/acme-website.yaml<br/>wget https://raw.githubusercontent.com/hyder/okesamples/master/ingresscontrollers/nginx/acme-website-ingress.yaml</span></pre><p id="f5d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">修改部署以添加节点选择器:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="68d7" class="kp je hh kl b be kq kr l ks kt">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: acme-website<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: acme-website<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: acme-website<br/>    spec:<br/>      nodeSelector:<br/>        app: acme<br/>      containers:<br/>      - name: acme-website<br/>        image: lmukadam/acmewebsite:latest<br/>        ports:<br/>        - containerPort: 80<br/>        resources:<br/>          limits:<br/>            memory: "128Mi"<br/>            cpu: "500m"</span></pre><p id="450f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更改入口清单中的主机参数，以放置您可以控制的FQDN。如果你没有，你可以随时使用<a class="ae jc" href="https://nip.io/" rel="noopener ugc nofollow" target="_blank"> nip.io </a>。例如，我的负载平衡器的公共IP地址是192.9.171.147。为了使用nip.io，您可以使用“192.9.171.147.nip.io”作为入口中的主机参数。创建部署和入口:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="673d" class="kp je hh kl b be kq kr l ks kt">kubectl --namespace nginx apply -f acme-website.yaml<br/>kubectl --namespace nginx apply -f acme-website-ingress.yaml</span></pre><p id="d70f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">验证您现在可以使用FQDN访问Acme Corp .的网站:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/05866dd43a5566ac4d3523d4d9d0f316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnPLpJFMdpw4fvBaybrsjA.png"/></div></div></figure><h2 id="2906" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">安装蝗虫</h2><p id="f3f6" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">最后，让我们安装蝗虫。首先，创建一个locustfile:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="becf" class="kp je hh kl b be kq kr l ks kt">import time<br/>from locust import FastHttpUser, task, between<br/>class AcmeUser(FastHttpUser):<br/>    wait_time = between(1, 3)<br/>    host = "replace.me"<br/>@task<br/>    def hello_world(self):<br/>        self.client.get("/")</span></pre><p id="40c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，我们使用的是FastHttpUser，而不是缺省值。这应该会给我们<a class="ae jc" href="https://docs.locust.io/en/stable/increase-performance.html#" rel="noopener ugc nofollow" target="_blank"> 5到6倍的请求</a>。接下来，为locustfile创建一个配置映射:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="1991" class="kp je hh kl b be kq kr l ks kt">kubectl create namespace locust<br/>kubectl --namespace locust create configmap acme-locust --from-file ./locustfile.py</span></pre><p id="b880" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并获得蝗虫的yaml清单:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="9d20" class="kp je hh kl b be kq kr l ks kt">helm repo add deliveryhero https://charts.deliveryhero.io/<br/>helm show values deliveryhero/locust &gt; locust.yaml</span></pre><p id="adf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编辑蝗虫. yaml:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="f2d7" class="kp je hh kl b be kq kr l ks kt">locust_locustfile_configmap: "acme-locust"<br/># worker<br/>worker:<br/>  replicas: 200<br/>nodeSelector:<br/>  app: roadrunner</span></pre><p id="3cb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您现在可以安装locust:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="8b2a" class="kp je hh kl b be kq kr l ks kt">helm --namespace locust install locust deliveryhero/locust -f locust.yaml</span></pre><p id="31db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您在locust名称空间中列出pod，您应该能够看到其中的101个(100个workers +1个master)。下面是蒂姆·格雷夫斯和朱利安·西尔维斯顿提供的计算蝗虫豆荚数量的有用命令:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="cdf2" class="kp je hh kl b be kq kr l ks kt">expr `k -n locust get pods --no-headers | wc -l` - 1</span></pre><p id="eed1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从终端端口转发到locust服务:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="b9f2" class="kp je hh kl b be kq kr l ks kt">kubectl -n locust port-forward svc/locust 8089:8089</span></pre><p id="f048" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开始新的测试:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lg"><img src="../Images/e3ea8c4a15a0db489878b95265c5519e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*rTZRQDyDOtoKaCI0J_NPbw.png"/></div></figure><p id="1930" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击“开始蜂拥”，点击“图表”。您应该会看到负载测试的进度。让测试运行大约五分钟，然后点击“停止”。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lh"><img src="../Images/9616ae6b10f40d61e8788ede8b031a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHoVC78nl7Qv2jkGWqX9sQ.png"/></div></div></figure><p id="219a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Grafana NGINX入口控制器仪表板上，您应该能够看到入口音量、延迟、内存和CPU使用率的变化。让我们试着了解发生了什么，看看是否有改进的余地。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es li"><img src="../Images/0d9255c67a05b964738c62565a10d0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4e0wV9nd_aqAMbzTYxrGQ.png"/></div></div></figure><p id="dc82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，在Ingress NextGen控制面板上，我们可以检查延迟面板，我们看到第90个百分点的平均延迟为276毫秒。我们能改善这一点吗？</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lj"><img src="../Images/f4da11c4d85596cbedd5a75ea602595d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsNwxzXQwrvCrxwbIJsoNg.png"/></div></div></figure><p id="1f8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们尝试启用TCP-BBR。好消息是这已经在Linux内核中了！</p><blockquote class="lk ll lm"><p id="f2bd" class="ie if kv ig b ih ii ij ik il im in io ln iq ir is lo iu iv iw lp iy iz ja jb ha bi translated"><strong class="ig hi"> TCP-BBR </strong>是一项功能，可用于为互联网流量实现更高的带宽和更低的延迟，并可为基于互联网的应用程序提供显著的性能提升。BBR(瓶颈带宽和往返时间)是一种调度算法，有助于控制TCP协议的传输速率，通过监控带宽瓶颈的往返时间来减少缓冲，从而减少TCP拥塞。</p></blockquote><p id="3b8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编辑/etc/sysctl.conf并添加以下内容:</p><pre class="kd ke kf kg fd kk kl lq lr aw ls bi"><span id="3ceb" class="jd je hh kl b fi lt lu l lv kt">net.core.default_qdisc=fq<br/>net.ipv4.tcp_congestion_control=bbr</span></pre><p id="18f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后重新加载它:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="7e35" class="kp je hh kl b be kq kr l ks kt">sysctl -p</span></pre><p id="2468" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并检查它是否有效:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="f494" class="kp je hh kl b be kq kr l ks kt">sysctl net.ipv4.tcp_congestion_control</span></pre><p id="505d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这应该会给我们:</p><pre class="kd ke kf kg fd kk kl km bn kn ko bi"><span id="0829" class="kp je hh kl b be kq kr l ks kt">sysctl net.ipv4.tcp_congestion_control</span></pre><p id="b516" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用相同的参数再次运行locust，看看对延迟的影响。与第一次尝试相比，我们立即看到了更稳定的响应时间图:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lw"><img src="../Images/a829de1395423d89be83e7d51f2b453e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmEdBuJ6ivXYIYNVAJCNdw.png"/></div></div></figure><p id="5ed5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，在Grafana上，我们看到所有百分位数的延迟都要慢得多:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lx"><img src="../Images/d3792b5dd46bc0a9e8fc89ed4c30e273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAzxyJ_wnIIBoldWZrFiog.png"/></div></div></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/8f2913c1791bfa655925ad522c5158fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsgmvyAxzmCcBrgAqwV3WQ.png"/></div></div></figure><p id="e9a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于第90个百分点，平均延迟现在是82.6毫秒，也就是说，提高了3.3倍。同样，在第95百分位，延迟的改善几乎是两倍。只有在第99百分位时，改善才可以忽略不计。这是一个相对简单的变化，但使用这种方法，我们可以测试系统，收集指标，并使用它们通过数据驱动的方法定位设置、架构或技术选择中可能存在的问题。当然，您所做的更改取决于您的用例以及许多其他变量。</p><h2 id="da85" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">结论</h2><p id="c0f6" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在本文中，我们将nginx-ingress部署为入口控制器，使用locust生成负载并捕获生成的指标。然后，我们使用Grafana对它们进行了分析，发现了一个潜在的延迟问题，我们使用TCP-BBR解决了这个问题。最后，我们再次测试，看看这是否带来了更好的性能，或者我们是否需要重新审视我们的技术堆栈。</p><p id="33b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显然，还有很多东西需要探索，您可以从许多不同的方向着手，例如测试您的应用程序、存储、集群大小等等。如果你想入门演奏技巧，我强烈建议你阅读<a class="ae jc" href="https://is.muni.cz/th/jfpm7/dp.pdf" rel="noopener ugc nofollow" target="_blank">这篇论文</a>。它提供了不同演奏技巧的简明概述，在你进行更复杂的练习之前对你有很大帮助。</p><p id="4092" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望你喜欢这篇文章。</p><h2 id="b76b" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">参考</h2><p id="8a3a" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><a class="ae jc" href="https://danielfm.me/post/painless-nginx-ingress/" rel="noopener ugc nofollow" target="_blank">痛苦(少？)NGINX入口</a></p><p id="8723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.nginx.com/blog/tuning-nginx/" rel="noopener ugc nofollow" target="_blank">针对性能调整NGINX】</a></p><p id="1593" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://dropbox.tech/infrastructure/optimizing-web-servers-for-high-throughput-and-low-latency" rel="noopener ugc nofollow" target="_blank">优化网络服务器以实现高吞吐量和低延迟</a></p><p id="c084" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://blog.cloudflare.com/http-2-prioritization-with-nginx/" rel="noopener ugc nofollow" target="_blank">使用BBR和tcp_notsent_lowat优化HTTP/2优先级</a></p><p id="3409" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">BBR，街区里的新成员</p></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="7890" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jc" href="https://bit.ly/devrel_slack" rel="noopener ugc nofollow" target="_blank">开发者懈怠</a>上聊一聊吧！</p></div></div>    
</body>
</html>