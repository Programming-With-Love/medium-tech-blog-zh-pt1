<html>
<head>
<title>Thinking Framework Agnostic — UI Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">思维框架不可知——UI工程</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/thinking-framework-agnostic-ui-engineering-fdb7892ed51b?source=collection_archive---------2-----------------------#2022-04-04">https://medium.com/walmartglobaltech/thinking-framework-agnostic-ui-engineering-fdb7892ed51b?source=collection_archive---------2-----------------------#2022-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7915" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为UI技术的传播者，我们已经看到了UI领域的指数轨迹，一方面是新框架的不断引入，另一方面是TC39社区不断关注如何增强Javascript语言，以及我们如何继续关注内存占用较少的设备的性能。另一方面，Chrome浏览器的V8引擎不断发布，以增强网络体验。</p><p id="b0c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着新框架的引入，UI专家继续思考和解决的问题是</p><blockquote class="jc jd je"><p id="f46a" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated">我们能做一些更通用的东西吗？我们可以开始思考框架不可知论吗？T3】</p></blockquote><p id="a69a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然，当争论的时候，我同意UI框架已经使得成为主流成为可能，并且web现在已经成为对各种框架的依赖，比如React，Angular，Vue等等。整个前端社区都在不断升级，以学习各种框架的细节，并获得特定框架的专业知识。</p><p id="5af7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然一个框架比另一个框架有一些优势，但是绝对没有一个框架在所有方面都是最好的。因此，没有这样明确的赢家，核心原因是敏捷性和业务需求以及几乎每小时都在开发的持续模块。这就是框架继续发展的速度！</p><p id="ea96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们认为Angular中的双向数据绑定性能不是很好，我们还认为React的协调算法带来了一些性能成本。</p><p id="41ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">核心思想是考虑我们如何继续支持使用各种框架开发的应用程序，并使用本地浏览器功能托管它们。</p><p id="b3e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jf">纳闷这有什么了不起的？</em> </strong> <em class="jf"> </em>正确打包到web组件中的应用程序或实用程序组件可以轻松地以声明的方式嵌入到您的HTML中，web组件将负责实例化自身。宿主应用程序的实现细节并不重要。重要的是，您的目标浏览器支持运行web组件所需的所有特性。这使得web组件与框架无关。</p><p id="95bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果开发人员使用Angular或Vue创建一个组件，您可以轻松地在React应用程序中使用该组件，而无需任何特殊的逻辑。这在微前端的环境中变得很有趣，在微前端中，用户界面的各个部分可以由不同的团队开发，甚至可以使用不同的库或框架，但最终所有部分都被顺利地组合在一起，形成一个界面。</p><blockquote class="jc jd je"><p id="dc8c" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">那么我们怎么能走向框架不可知论呢？</em>T13】</strong></p></blockquote><p id="f360" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个shell，它能够托管由不同团队构建的组件，使用不同的技术栈并利用DOM API。值得一提的是“微前端正在席卷网络”。</p><p id="9db4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们是继续用反应方式，角度方式，还是Vue JS方式？相反，拥有一个提供更通用的方法并将框架特性包装在组件中的架构怎么样？</p><p id="8d0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">增长代码绝对不是框架的问题，而是你的大脑的问题。你的大脑在概念和抽象中思考。因此，我们实际上应该从后向前构建我们的应用程序。</p><blockquote class="jc jd je"><p id="858d" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">你会看到什么好处？</em>T3】</strong></p></blockquote><ul class=""><li id="9e1f" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb jo jp jq jr bi translated"><strong class="ig hi">重用</strong>:一个组件只需制作一次，就可以跨不同的页面、应用或框架重用。</li><li id="e247" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">支持:一旦完全标准化，它可以在任何浏览器上工作，不需要额外的库。</li><li id="b65d" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">维护</strong>:由于设计是模块化的，组件是独立的，所以更容易维护。</li><li id="aae0" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">封装</strong>:同一个页面上的每个组件可能有不同的样式。我们不必担心元素身份的冲突。这是由于所谓的<em class="jf">阴影DOM </em>。</li><li id="2168" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">可靠性</strong>:代码不会跨HTML和JS文件传播，从而避免不一致。</li><li id="e5dc" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">灵活性</strong>:组件可以内联编写、导入甚至编译。</li><li id="2311" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">可组合性</strong>:组件可以使用或与其他组件接口。</li><li id="16c6" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">增加可测试性:</strong>由于组件设计是模块化的，并且封装到一个单元中，所以组件代码的可测试性可以增加</li><li id="f551" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">掌握特定框架</strong>:不再需要不同框架中的特定专业领域，从而节省了就业市场中的入职专业技能。</li><li id="0132" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">所有权:组件开发人员将拥有架构部分</li><li id="96a0" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated"><strong class="ig hi">支持组件的集成，内置于各种框架:</strong>用特定框架编写的组件可以合并到你的应用中，而不必从头开始重新编写。</li></ul><blockquote class="jc jd je"><p id="f980" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">关于网页组件</em> </strong></p></blockquote><p id="e306" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您还不熟悉web组件，Mozilla Developer Network上关于该主题的文章可能是开始了解它们的好地方。简而言之，Web组件允许开发人员封装HTML、JavaScript和CSS，将它们与宿主HTML文档隔离开来，并通过定制的脚本标签使其在DOM中易于重用。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/8e4342db9539e990c94a207e03033cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYjEx5YVS_P7B1EzmhH4zg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Ten Thousand Feet High View of Web Components</figcaption></figure><p id="32fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们举一个简单的例子来详细理解底层概念，其中应用程序加载并嵌入了三个内容相同的web组件，但使用Vue、React和普通JavaScript实现。</p><p id="0a7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们把这个例子分成如下三个部分:</p><ol class=""><li id="a1dc" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb kn jp jq jr bi translated"><strong class="ig hi">定义Web组件</strong></li><li id="127a" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb kn jp jq jr bi translated"><strong class="ig hi">加载Web组件</strong></li><li id="5f96" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb kn jp jq jr bi translated"><strong class="ig hi">使用Web组件</strong></li></ol><h1 id="b271" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">定义Web组件</h1><p id="a189" class="pw-post-body-paragraph ie if hh ig b ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">创建web组件只需要几个步骤:</p><ul class=""><li id="8ae9" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb jo jp jq jr bi translated">创建自定义HTML元素。</li><li id="0f5b" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">对于作用域样式，使用<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">Shadow DOM</a>——这是web组件封装背后的驱动力</li><li id="020a" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">在浏览器的自定义元素注册表中注册以前创建的元素，通过自定义HTML标记使其可用。</li></ul><p id="6e75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个自定义元素就像创建一个扩展任何现有HTML元素的类一样简单。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="ab91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的基本web组件中，我们定义了两个属性:</p><ul class=""><li id="2ca1" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb jo jp jq jr bi translated">connectedCallback —当我们在这里创建的定制元素被插入到DOM中时，这个函数被调用。我们使用该函数实例化元素的实际内容，在本例中为“欢迎使用WEB组件”。</li><li id="9870" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">disconnectedCallback —当自定义元素从DOM中删除时，调用此函数。我们使用这个函数来执行任何必要的清理操作，否则我们可能会以内存泄漏而告终。</li></ul><p id="f68f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们制作一个更通用的包装器来封装React、Vue或Vanilla JS组件，这允许我们做更多的事情。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="0f9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们深入理解上面几行代码中发生了什么。</p><p id="296b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该函数接受一个具有三个属性的对象——mount、unmount和styles——并返回一个扩展浏览器HTMLElement的类</p><p id="d082" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记住，我们讨论过创建一个定制的web组件，仅仅是通过扩展HTMLElement类，所以在我们更通用的包装器中，我们有一个函数返回一个扩展了<em class="jf"> HTMLELement </em>的类。</p><p id="3197" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参数列表的mount属性定义了当组件连接到DOM时应该发生什么。</p><p id="bd39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"><em class="jf">connectedCallback</em></strong>函数中我们使用了<strong class="ig hi">this . attach shadow({ mode:" open " })；</strong>将阴影DOM树附加到元素，以启用该元素的范围样式。如果您不想在自定义元素和宿主文档之间有冲突的样式规则，这一步很重要，这样可以避免CSS溢出到组件之外。或者，您可以编写仅应用于自定义元素的命名空间样式。使用Shadow DOM来实现这一点，使得元素可以在任何地方使用，而不必考虑冲突或覆盖CSS规则。</p><p id="f1e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们创建一个包含样式标签中的样式和DOM节点的模板，DOM节点是这个元素将要呈现的内容的挂载点。最后，模板被克隆并附加到元素shadowRoot节点，mount函数用我们的挂载点元素调用。</p><p id="68dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样地，<strong class="ig hi"> <em class="jf"> disconnectedCallback或unmount属性</em> </strong>决定了组件在DOM上的断开状态。当组件从DOM断开连接/卸载时，可以执行所有清理活动。这是我们的包装器避免浏览器内存泄漏的一个重要方面。</p><p id="01d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过接受mount和unmount函数，上述实现完全是框架无关的，可以用来创建呈现任何东西的定制元素。这就是我们之前的示例应用程序创建呈现React、Vue和普通JavaScript代码的web组件所用的全部内容。</p><p id="4d51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要创建呈现React应用程序的web组件，我们可以使用上面定义的函数，如下所示:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="4cfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码片段中，我们调用createCustomElementWrapper并定义mount和unmount函数来呈现和清理React应用程序。此外，当我们使用Webpack作为捆绑器时，我们使用Webpack的<a class="ae lr" href="https://webpack.js.org/loaders/raw-loader/" rel="noopener ugc nofollow" target="_blank"> raw-loader </a>将我们的样式加载到一个字符串中，并将其传递给我们的函数。然后，我们在customElement的注册表中注册该元素，如下所示:</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="4c1f" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">正在加载Web组件</h1><p id="0f1c" class="pw-post-body-paragraph ie if hh ig b ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">Web开发人员可以在他们的应用程序代码中直接创建和使用他们的web组件。然而，我们通常通过scriptTags静态或动态地加载这些通用组件。</p><p id="7e5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们再深入一层，在应用程序中按需动态加载web组件。当处理延迟加载的模块时，这可能是一种有趣的方法，特别是当您希望根据用户动作动态显示组件时。</p><p id="18cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想象一下这样一种情况，多个团队处理多个小部件，比如仪表板，它们需要按需加载，每个都托管在不同的服务器上。</p><p id="d732" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码片段，可以帮助你动态加载资产/风格和脚本。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="5ad2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来解开上面的代码片段是怎么回事。因为我们需要保证我们只加载一次资产、脚本和样式资源，所以我们需要做一些检查。</p><p id="c7b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑到这一点，一旦我们缝合了用户界面组合，我们将需要确保用户界面上的交互不会与布局中的其他视图发生冲突。</p><ul class=""><li id="ae6c" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb jo jp jq jr bi translated">脚本以前加载过还是当前正在加载？这是通过检查DOM中是否已经存在与我们试图加载的脚本具有相同源的脚本标签来完成的。如果是，这意味着脚本要么正在加载，要么已经完成加载并已被执行。</li><li id="57c8" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">为了确定脚本(如果存在于DOM中)是否已经完成加载，我们在脚本加载时在脚本元素上设置了一个自定义数据属性data-script-loaded。每次我们试图加载一个脚本时，我们都会在脚本标签load事件上附加一个新的事件监听器，以了解它何时完成加载。这样，如果我们尝试加载同一个脚本两次，通过调用loadAssets两次创建的承诺将同时解析。</li></ul><p id="0600" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按照下面的代码片段，我们在示例应用程序中通过React挂钩使用loadAssets函数，以便在嵌入或使用web组件的地方提供关于加载或错误状态的信息。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="7737" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的钩子还负责在失败的情况下重新尝试加载资产。</p><h1 id="e441" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用Web组件</h1><p id="09ee" class="pw-post-body-paragraph ie if hh ig b ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">现在让我们实际使用动态加载的web组件。为了达到预期的效果，我们假设对于加载到应用程序中的每个web组件，我们都知道相应资产的HTML标签和位置。这些信息可以由服务于我们的定制web组件的应用程序提供。在这里，我们可以利用后端服务的服务发现。</p><p id="494a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例应用程序的以下实现使用React，但也可以使用Vue或普通JavaScript重写。</p><p id="1ba4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们利用上面的useStaticAssets钩子将ui组件嵌入到复合用户界面中。</p><figure class="jy jz ka kb fd kc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="af31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有四点需要注意:</p><ul class=""><li id="58ef" class="jj jk hh ig b ih ii il im ip jl it jm ix jn jb jo jp jq jr bi translated">该组件接收HTML标签、资产路径和附加信息，作为我们的自定义元素的属性，这是与框架无关的。</li><li id="cf38" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">它将资产路径传递给我们之前定义的钩子useStaticAssets。</li><li id="6a60" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">根据加载和错误状态，它呈现不同的内容。</li><li id="0fb8" class="jj jk hh ig b ih js il jt ip ju it jv ix jw jb jo jp jq jr bi translated">它使用定制的HTML标记将web组件呈现给DOM。</li></ul><p id="3bb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如在<a class="ae lr" href="https://micro-frontends.org" rel="noopener ugc nofollow" target="_blank">https://micro-frontends.org</a>中所描述的，你可以使用skeleton UIs来显示web组件或spinner的加载状态，就像在示例应用程序中一样。浏览器缓存web组件的资产，因此加载时间只是第一次加载或缓存失效后的问题。</p><h1 id="6c44" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结束语</h1><p id="0b0b" class="pw-post-body-paragraph ie if hh ig b ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">希望这篇文章有助于理解“思维框架不可知”的核心功能。这肯定不是使用包装器编写高阶组件的唯一方法，也不是框架不可知的唯一方法，但这是一个一步一步构建模块的良好起点。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es lu"><img src="../Images/8e4928ad6963edde54f53a99f6c5fd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-fDj62HOE7-acI5hioaNRg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Composition of components built using <em class="lv">react, vue &amp; vanilla js</em> into a single interface.</figcaption></figure></div></div>    
</body>
</html>