<html>
<head>
<title>LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图模型之外的实时数据—使用转换和中介的反应模式实时数据</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7?source=collection_archive---------0-----------------------#2018-07-16">https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7?source=collection_archive---------0-----------------------#2018-07-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c708" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">反应式架构多年来一直是Android的热门话题。这一直是Android会议的主题，通常用RxJava例子来说明(见底部的Rx部分)。反应式编程是一种关注数据如何流动和变化传播的范式，它可以简化构建应用程序和显示来自异步操作的数据。</p><p id="2822" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现一些反应概念的一个工具是<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>。这是一个简单的观察，它知道观察者的生命周期。从您的数据源或存储库中公开LiveData是使您的架构更具反应性的一种简单方法，但是存在一些潜在的陷阱。</p><p id="6e1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博文将帮助您避免陷阱，并使用一些模式来帮助您使用LiveData构建一个更具反应性的架构。</p><h1 id="bda2" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">LiveData的目的</h1><p id="0ac2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在Android中，活动、片段和视图几乎可以在任何时候被销毁，因此对这些组件之一的任何引用都可能导致泄漏或<code class="du kg kh ki kj b">NullPointerException</code>。</p><p id="aa2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">LiveData旨在实现观察者模式，允许视图控制器(活动、片段等)之间的通信。)和UI数据的来源(通常是ViewModel)。使用LiveData，这种通信更加安全:由于它的生命周期意识，只有在视图处于活动状态时，它才会接收数据。</p><p id="9881" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，这样做的好处是不需要手动取消View和ViewModel之间的订阅。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/ac44cc8a12f8446631c369690b336358.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*aMu72YHtOdLMG3jc4qSoCQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">View-ViewModel interactions</em></figcaption></figure><h1 id="4bd6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">视图模型之外的LiveData</h1><p id="65eb" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">可观察范式在视图控制器和视图模型之间工作得非常好，因此您可以使用它来观察应用程序的其他组件，并利用生命周期意识。例如:</p><ul class=""><li id="2a77" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">观察<a class="ae jc" href="https://developer.android.com/reference/android/content/SharedPreferences.OnSharedPreferenceChangeListener" rel="noopener ugc nofollow" target="_blank">共享优先级</a>的变化</li><li id="10fa" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">观察<a class="ae jc" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank"> Firestore </a>中的文档或收藏</li><li id="978f" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">使用类似<a class="ae jc" href="https://firebase.google.com/docs/auth/" rel="noopener ugc nofollow" target="_blank"> FirebaseAuth </a>的身份验证SDK观察当前用户</li><li id="1d8d" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">观察<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank">房间</a>中的一个查询(它支持开箱即用的LiveData)</li></ul><p id="c68b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种模式的优点是，因为所有东西都连接在一起，所以当数据发生变化时，UI会自动更新。</p><p id="dd36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缺点是LiveData不像Rx那样有一个组合数据流或管理线程的工具包。</p><p id="f09e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在典型应用程序的每一层中使用LiveData看起来像这样:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/a90590427f0b3cf278ce2607c4f072ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXXiuXmzRTTqdaEEojyIcQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">Typical app architecture using LiveData</em></figcaption></figure><p id="b452" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在组件之间传递数据，我们需要一种映射和组合的方式。MediatorLiveData与Transformations类中的帮助器一起用于此目的:</p><ul class=""><li id="79aa" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E)" rel="noopener ugc nofollow" target="_blank">转换.地图</a></li><li id="e362" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E)" rel="noopener ugc nofollow" target="_blank">transformations . switch map</a></li></ul><blockquote class="lq lr ls"><p id="acd2" class="ie if lt ig b ih ii ij ik il im in io lu iq ir is lv iu iv iw lw iy iz ja jb ha bi translated">请注意，当您的视图被销毁时，您不需要拆除这些订阅，因为视图的生命周期会向下游传播到后续的订阅。</p></blockquote><h1 id="e2ac" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">图案</strong></h1><h2 id="7ac7" class="lx je hh bd jf ly lz ma jj mb mc md jn ip me mf jr it mg mh jv ix mi mj jz mk bi translated"><strong class="ak">一对一静态转换—映射</strong></h2><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ml"><img src="../Images/22ee83b91a06214e6f5d0966d22288e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FkrCCJEhV5dW6kJU9AUog.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">The ViewModel observes one type of data and exposes a different one</em></figcaption></figure><p id="f005" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，ViewModel只是将数据从存储库转发到视图中，并将其转换为UI模型。每当存储库有新数据时，ViewModel只需<code class="du kg kh ki kj b">map</code>它:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="73cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个转化很简单。但是，如果用户会发生变化，您需要switchMap:</p><h2 id="86c2" class="lx je hh bd jf ly lz ma jj mb mc md jn ip me mf jr it mg mh jv ix mi mj jz mk bi translated">一对一动态转换—切换图</h2><p id="0e1b" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">考虑这个例子:您正在观察一个公开用户的用户管理器，您需要等待他们的ID，然后才能开始观察存储库。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mo"><img src="../Images/0553c3809651a2ec4dd62b216ba496b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMHVwTGSFSSR9ooHL8TxFg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">The user manager provides the user ID which the repository needs before exposing a result</em></figcaption></figure><p id="692e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您不能在ViewModel初始化时连接它，因为用户ID不会立即可用。</p><p id="097e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以用一个<code class="du kg kh ki kj b">switchMap</code>来实现它。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c354" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kg kh ki kj b">switchMap</code>在内部使用MediatorLiveData，所以熟悉它很重要，因为当您想要组合多个LiveData源时需要使用它:</p><h2 id="2e26" class="lx je hh bd jf ly lz ma jj mb mc md jn ip me mf jr it mg mh jv ix mi mj jz mk bi translated">一对多依赖关系— MediatorLiveData</h2><p id="979c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">MediatorLiveData允许您将一个或多个数据源添加到单个LiveData可观察对象中。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="9960" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个来自<a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData" rel="noopener ugc nofollow" target="_blank">文档</a>的例子，当任何源改变时更新结果。<strong class="ig hi">注意数据不是为你组合的</strong>。MediatorLiveData只负责通知。</p><p id="3b44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在我们的示例应用程序中实现转换，我们需要将两个不同的LiveDatas合并为一个:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mp"><img src="../Images/5d11798baa27970c0142aaeb66fed808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ymwmo3w4gLoc__pfAGc2g.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">MediatorLiveData is used to combine two data sources</em></figcaption></figure><p id="6132" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用MediatorLiveData组合数据的一种方法是添加源并以不同的方法设置值:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="76af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据的实际组合在<code class="du kg kh ki kj b">combineLatestData</code>方法中完成。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="8e15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它检查数值是否准备好或正确，并发出结果(<em class="lt">加载</em>、<em class="lt">错误</em>或<em class="lt">成功</em>)</p><p id="df3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参见下面的奖励部分，了解如何用Kotlin的扩展函数来清理这个问题。</p><h1 id="fdd8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">何时不使用LiveData</h1><p id="ec82" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">即使你想“变得被动”,你也需要在到处添加LiveData之前了解其优势。如果你的应用程序的一个组件没有连接到用户界面，它可能不需要LiveData。</p><p id="562f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，您的应用程序中的用户管理器监听您的身份验证提供者(如Firebase Auth)中的更改，并将唯一的令牌上传到您的服务器。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mq"><img src="../Images/81bc052852e348a119180421c0f1c053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*w-XMAsDiCgpjUBEFi8SHvA.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">Should the interaction between the token uploader and user manager be reactive?</em></figcaption></figure><p id="57b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">令牌上传者可以观察用户管理器，但是使用谁的生命周期？该操作与视图完全无关。此外，如果视图被破坏，用户令牌可能永远不会被上传。</p><p id="1362" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一种选择是使用令牌上传器中的<a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData#observeforever" rel="noopener ugc nofollow" target="_blank">observer forever</a>()并以某种方式挂钩到用户管理器的生命周期中，以便在完成后删除订阅。</p><p id="0160" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，你不需要让一切都是可观察的。让用户管理器直接调用令牌上传器(或者在您的架构中有意义的任何东西)。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mq"><img src="../Images/52cba4e2c2212a4199cea31bb677ea61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*u2dKCA0uWtS2k7zNGgBumw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx"><em class="kw">An action that is not UI-related doesn’t need to use LiveData</em></figcaption></figure><blockquote class="lq lr ls"><p id="945e" class="ie if lt ig b ih ii ij ik il im in io lu iq ir is lv iu iv iw lw iy iz ja jb ha bi translated">如果你的应用程序的一部分不影响用户界面，你可能不需要LiveData。</p></blockquote><h1 id="0846" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">反模式:共享LiveData的实例</h1><p id="93ef" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">当一个类向其他类公开一个LiveData时，要仔细考虑是要公开同一个LiveData实例还是不同的实例。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="9a2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果这个类在你的应用程序中是单例的(只有一个实例)，你总是可以返回相同的LiveData，对吗？不一定:这个类可能有多个消费者。</p><p id="c599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，考虑这个:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="dab6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个消费者也使用它:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4fde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个消费者将收到属于用户“2”的数据的更新。</p><p id="8b56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使您认为您只是在使用一个消费者的这个类，您也可能会在使用这个模式时遇到错误。例如，当从活动的一个实例导航到另一个实例时，<strong class="ig hi">新实例可能会暂时接收来自前一个实例的数据</strong>。请记住，LiveData会将最新的值发送给新的观察者。此外，Lollipop中引入了活动转换，它们带来了一个有趣的边缘情况:<strong class="ig hi">两个活动处于活动状态</strong>。这意味着LiveData的唯一消费者可能有两个实例，其中一个可能会显示错误的数据。</p><p id="0851" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题的解决方案就是为每个消费者返回一个新的LiveData。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><blockquote class="mr"><p id="48d8" class="ms mt hh bd mu mv mw mx my mz na jb dx translated">在消费者之间共享LiveData实例之前，请仔细考虑。</p></blockquote><h1 id="a803" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo nb jq jr js nc ju jv jw nd jy jz ka bi translated">MediatorLiveData气味:在初始化之外添加源</h1><p id="ac27" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">使用观察者模式比持有对视图的引用(在MVP架构中通常会这样做)更安全。然而，这并不意味着您可以忘记泄漏！</p><p id="1ad9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑以下数据源:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="478c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它只是在500毫秒后返回一个带有随机值的新LiveData。没什么不好。</p><p id="61b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在ViewModel中，我们需要公开一个从生成器获取数字的<code class="du kg kh ki kj b">randomNumber</code>属性。为此使用MediatorLiveData并不理想，因为每次需要新的数字时都需要添加源:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="ebc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果每次用户点击按钮时，我们都向MediatorLiveData添加一个源，应用程序就会按预期工作。然而，我们正在泄漏所有以前的LiveDatas，这些live datas将不再发送更新，所以这是一种浪费。</p><p id="801b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以存储对源的引用，然后在添加新的引用之前删除它。(剧透:这就是<code class="du kg kh ki kj b">Transformations.switchMap</code>的作用！参见下面的解决方案。)</p><p id="aafe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要使用MediatorLiveData，让我们尝试用<code class="du kg kh ki kj b">Transformation.map</code>来解决这个问题(但失败了):</p><h1 id="efd8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">转换气味:初始化之外的转换</h1><p id="cb46" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">使用前面的示例，这是行不通的:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3090" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一个需要理解的重要问题:转换在被调用时会创建一个新的LiveData(包括<code class="du kg kh ki kj b">map</code>和<code class="du kg kh ki kj b">switchMap</code>)。在这个例子中,<code class="du kg kh ki kj b">randomNumber</code>暴露在视图中，但是每次用户点击按钮时它都会被重新分配。很容易忽略的一点是<strong class="ig hi">观察者只会在订阅时收到分配给var的LiveData的更新</strong>。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4f7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个订阅发生在<code class="du kg kh ki kj b">onCreate()</code>中，所以如果<code class="du kg kh ki kj b">viewmodel.randomNumber</code> LiveData实例后来发生了变化，那么观察者将永远不会被再次调用。</p><p id="b532" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说:</p><blockquote class="mr"><p id="62dd" class="ms mt hh bd mu mv ne nf ng nh ni jb dx translated">不要在var中使用Livedata。初始化时的连线转换。</p></blockquote><h1 id="af73" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo nb jq jr js nc ju jv jw nd jy jz ka bi translated">解决方案:初始化期间的线变换</h1><p id="5205" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">将公开的LiveData初始化为转换:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c1f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用LiveData中的<a class="ae jc" rel="noopener" href="/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">事件</a>来指示何时请求新号码:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6eab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你不熟悉这种模式，请看<a class="ae jc" rel="noopener" href="/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">这篇关于事件</a>的文章。</p></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><h1 id="9051" class="jd je hh bd jf jg nq ji jj jk nr jm jn jo ns jq jr js nt ju jv jw nu jy jz ka bi translated">奖金部分</h1><h2 id="a7a8" class="lx je hh bd jf ly lz ma jj mb mc md jn ip me mf jr it mg mh jv ix mi mj jz mk bi translated">和科特林一起整理</h2><p id="e18f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">上面的MediatorLiveData示例显示了一些代码重复，因此我们可以利用Kotlin的扩展函数:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="73d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">存储库现在看起来干净多了:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="c93b" class="lx je hh bd jf ly lz ma jj mb mc md jn ip me mf jr it mg mh jv ix mi mj jz mk bi translated">LiveData和RxJava</h2><p id="5ac9" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">最后，让我们解决房间里的大象。LiveData旨在允许视图观察视图模型。绝对用这个！即使您已经使用Rx，您也可以使用<a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/LiveDataReactiveStreams" rel="noopener ugc nofollow" target="_blank">livedatareact vestreams</a>*与二者进行通信。</p><p id="95e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您想在表示层之外使用LiveData，您可能会发现MediatorLiveData没有像RxJava提供的工具包来组合和操作数据流。然而，Rx有一个陡峭的学习曲线。LiveData转换(和Kotlin magic)的组合可能对您的情况足够了，但是如果您(和您的团队)已经投资学习RxJava，您可能不需要LiveData。</p><p id="00aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*如果使用<a class="ae jc" href="https://github.com/uber/AutoDispose" rel="noopener ugc nofollow" target="_blank">自动处置</a>，使用LiveData将是多余的。</p></div></div>    
</body>
</html>