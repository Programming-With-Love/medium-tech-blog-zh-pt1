<html>
<head>
<title>Partitioning Pinlater for Fun(?) and Profit(!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Partitioning Pinlater为了好玩(？)和利润(！)</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/partitioning-pinlater-for-fun-and-profit-f83c98aa6e67?source=collection_archive---------3-----------------------#2020-08-27">https://medium.com/pinterest-engineering/partitioning-pinlater-for-fun-and-profit-f83c98aa6e67?source=collection_archive---------3-----------------------#2020-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="566c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ernie Souhrada |数据库工程师和钻头维护者</p><p id="36d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2015年11月，我们的异步作业执行系统pinlate的<a class="ae jc" rel="noopener" href="/pinterest-engineering/open-sourcing-pinlater-an-asynchronous-job-execution-system-d8ec4e39859a">开源声明中包含了自【2014年最初的博文</a>描述其创建以来对该系统所做的一些改进。其中值得注意的是从Redis到MySQL/InnoDB作为后端数据存储的转换，因为它增强了耐用性和高效处理比系统内存大得多的数据集的能力。在过去的几年中，这种新的、改进的Pinlater的使用有了突飞猛进的发展，超过了最初每秒100，000个作业的总处理速率许多倍，可靠性更好，成本也比基于Redis的解决方案低得多。然而，正如您所料，更大的规模通常会带来新的挑战。</p><p id="7b37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">询问任何有经验的MySQL工程师，他们是否认为InnoDB是一个很好的队列系统的后备存储，该系统将处理即使是适度高的查询量，您可能会收到从极度厌恶到无法控制的笑声的各种反应。是的，它相对容易实现，在自动递增主键和用于并发控制的行级锁定之间，在排队系统中可能需要的许多基本元素在默认情况下都存在，但是没有免费的小狗这样的东西。一开始你可能觉得它很可爱，想抱抱，但最终它会饿，开始叫，让你晚上睡不着，或者如果你不经常带它出去锻炼，它会毁了你的鞋子，在你的地毯上撒尿。减轻使用MySQL作为排队系统的负面影响，就像小狗维护一样，是一项艰巨的任务。</p><h1 id="f28c" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">第一步:找到丢失的磁盘空间</strong></h1><p id="3966" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">对不推荐将MySQL用作队列存储的所有原因的完整解释超出了这篇博文的范围；相反，我将重点介绍我们最近如何解决一个具体问题，这是Pinlater中大量运营开销和资源利用效率低下的根源:磁盘浪费。</p><p id="df43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">InnoDB数据文件的一个显著特性是它们不会自行收缩。从一个空表开始，向其中写入一百万行，然后在MySQL数据目录中查看该文件占用了多少磁盘空间。然后，一个接一个地开始删除行，直到只剩下一行。即使您最终删除了最后一行，文件的大小也会和表满时一样。这样做足够多次，最终你的服务器将耗尽磁盘空间，即使它几乎没有任何数据。对于一个排队系统来说，它不断地向任意给定的MySQL服务器上的数十甚至数百个不同的表中写入新的作业，然后在旧作业完成或不再需要时删除它们，不难看出臃肿的数据文件会造成怎样的问题。</p><p id="2463" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对此问题的早期解决方案简单明了，但也不是最理想的，而且是不必要的劳动密集型:要么重建具有大量空闲空间的表(可能会影响以后的Pinlater成功率，因为对表的写入会被阻止)，要么设置警报集群以停止新作业的排队并提供新集群来替换它们。</p><h1 id="577c" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">第二步:？？？？</strong></h1><p id="c33c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">快进到2018年。作为一个更大的Pinlater效率项目的一部分，我开始查看前面提到的InnoDB行为实际上浪费了多少磁盘空间，这些数字令人吃惊。总体而言，所有至少具有5GB可回收空间的Pinlater表占用了100TB的磁盘空间，但它们仅包含3.5TB的实际数据。当然，这可以通过自动化我上面描述的一些回收任务来解决，但是我建议我们尝试一些不同的东西:MySQL分区。</p><p id="58db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了说明这一点，下面是分区前Pinlater表的一个简化模式定义。</p><p id="24a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建表作业(<br/>local _ id BIGINT NOT NULL AUTO _ INCREMENT主键，<br/> state TINYINT NOT NULL，<br/>…<br/>updated _ at TIMESTAMP NOT NULL，<br/> created_at TIMESTAMP NOT NULL，<br/> run_after TIMESTAMP NOT NULL，<br/> INDEX (state，run_after) <br/>)</p><p id="b653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinlater中的基本作业流是，每个作业从状态0(新)开始，然后一旦被一个工作线程请求，就转换到状态1 (IPR =进行中)，最终以状态2(正常)或状态3(失败)结束。成功或失败的作业会定期从表中清除。在最初的设计中，这是通过一个简单的删除查询来完成的，这通常会导致不希望的锁争用或CPU高峰，并且如前所述，没有采取任何措施来回收未使用的磁盘空间。</p><p id="1894" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我提出的解决方案的一个简化方案。</p><p id="a669" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建表作业(<br/>local_id BIGINT NOT NULL AUTO _ INCREMENT，<br/> state TINYINT NOT NULL，<br/>…<br/>updated_at DATETIME NOT NULL，<br/> created_at TIMESTAMP NOT NULL，<br/> run_after TIMESTAMP NOT NULL，<br/>主键(local _ id，state，updated _ at)，<br/> INDEX (run_after)，<br/>按范围列分区(state，updated_at) ( <br/>分区pNEW _ 2020051200 _ 120) <br/>分区pIPR_2020050800_24值小于(1，' 2020–05–08 00:00:00 ')，<br/>分区pIPR_2020050900_24值小于(1，' 2020–05–09 00:00:00 ')，<br/>分区pIPR_FUTURE值小于(1，MAXVALUE)，<br/>分区pOK_2020050</p><p id="eba9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用修改后的设计，所有相同的状态更改都会在作业的整个生命周期中发生，但不是Pinlater仅仅更新行中的值，而是随着状态转换的发生，行本身会从一个分区移动到下一个分区。当需要清除旧的/过期的作业时，我们只需运行一系列ALTER TABLE foo DROP PARTITION bar查询。作为这个维护cron的一部分，我们还对每个未来的分区进行重新分区，以创建新的空分区来替换被删除的非空分区。没有更多有争议的删除，因为分区的数据文件实际上是从文件系统中删除的，否则会被浪费的宝贵磁盘空间可以被回收用于其他作业队列。额外的好处是，因为即使是新任务也有一个有限的TTL，如果有人创建了一个队列，然后忘记了它，维护脚本会自动清理它。</p><h1 id="0b46" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">第三步:盈利！</strong></h1><p id="6ef4" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">成功了吗？比我想象的要好。我们推出了这一新模式，更新了SQL(因为为了利用MySQL的分区修剪，它可以快速缩小搜索范围，只搜索满足查询所需的分区，您需要在查询中使用分区键的每个组件)，以及2019年上半年的新维护工作。在这个项目的开始，235个MySQL集群被用于Pinlater。在最后？不到这个数字的一半:113。不仅如此，备份速度也得到了提高，现在我们针对这些服务器的磁盘利用率指标实际上非常有用，因为我们不再计算长期删除的行。还不错！</p><h1 id="eb23" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">承认</h1><p id="23b2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">感谢来自核心服务团队的Isabel Tallam和Purajit Malalur，感谢他们对Pinlater进行必要的代码更改以及后续的测试和部署。</p></div></div>    
</body>
</html>