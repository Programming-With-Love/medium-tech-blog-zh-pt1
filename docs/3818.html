<html>
<head>
<title>ExpressJS routing with Decorators, Dependency Injection and reflect-metadata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有装饰器、依赖注入和反射元数据的ExpressJS路由</h1>
<blockquote>原文：<a href="https://medium.com/globant/expressjs-routing-with-decorators-dependency-injection-and-reflect-metadata-945f92e15a06?source=collection_archive---------0-----------------------#2022-01-21">https://medium.com/globant/expressjs-routing-with-decorators-dependency-injection-and-reflect-metadata-945f92e15a06?source=collection_archive---------0-----------------------#2022-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/cbe85266e544aa393b43dfa2ff3a2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*nWcmoRDOcx93LgR1YJAsLg.png"/></div></figure><blockquote class="il im in"><p id="f8f6" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> TypeScript </strong>是一种强类型编程语言，它构建在JavaScript之上，在任何规模下都能为您提供更好的工具——<a class="ae jn" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a></p></blockquote><p id="7d27" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">本文的目标是帮助使用Node.js，TS构建开箱即用的解决方案，在传统的路由注册上使用decorators定义路由。</p><p id="2b71" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">这个故事的目标是展示如何在express服务器上定义、注册和使用路由装饰器。</p><h2 id="6858" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">背景</strong></h2><p id="db17" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated"><a class="ae jn" href="https://www.typescriptlang.org/docs/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是JavaScript的类型化超集。当谈到用JavaScript进行面向对象编程时，TypeScript确实很出色。它支持OOPS支柱，如类、继承、多态和封装。</p><p id="8cab" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated"><strong class="ir hi">依赖注入</strong>是将依赖传递给其他对象或框架(依赖注入器)。</p><p id="cb43" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">随着TS和ES6的引入，在某些方面需要一些额外的特性来支持注释和修改类和类成员。油漆工为我们工作。</p><blockquote class="il im in"><p id="ac01" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">装饰器是JavaScript的第二阶段提案，是TypeScript的一个实验性特性。— <a class="ae jn" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a></p></blockquote><p id="1c36" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="iq">先决条件</em> </strong></p><ol class=""><li id="176f" class="kr ks hh ir b is it iw ix jo kt jp ku jq kv jm kw kx ky kz bi translated">确保您已经安装了Node.js</li><li id="7f94" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">JavaScript、TypeScript、Node.js、ExpressJS和decorators的基础知识</li><li id="a8e5" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">代码编辑器(VSCode)</li></ol><h2 id="dc99" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">什么是依赖注入？</strong></h2><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/f311faaaa3975ada7bb8f04a562e1ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*x8LiIN12K-S0GgulGajQXg.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Dependency Injection</figcaption></figure><p id="df2d" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">在深入研究依赖注入之前，我们需要了解第一个<strong class="ir hi"> IoC </strong> <strong class="ir hi">容器</strong>。</p><p id="4a2a" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated"><strong class="ir hi">控制反转</strong>是反转整个程序流程，所以程序管理所有的程序依赖。这个容器负责构造每个对象。当一个类需要一个对象来实例化时，IoC容器提供所需的依赖。</p><p id="40a4" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">在依赖注入中，我们需要理解四种不同类型的角色:</p><ul class=""><li id="ab48" class="kr ks hh ir b is it iw ix jo kt jp ku jq kv jm lo kx ky kz bi translated">服务:服务是我们公开的东西。这些类被IoC容器实例化和使用。</li><li id="46fa" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">客户端:通过IoC容器使用这些服务。</li><li id="231d" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">接口:确保客户端和服务保持一致。</li><li id="9330" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">注入器:提供实例化服务。</li></ul><p id="17ce" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">例子:这个例子演示了使用typescript的依赖注入。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/ac516e36fde2f4d9f487df86f9f23c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*G6gNIjZaXYct4lQB8GUC-g.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Example of Dependency Injection and IoC Container</figcaption></figure><blockquote class="il im in"><p id="8dcc" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使服务可注入，我们使用了来自<a class="ae jn" href="https://www.npmjs.com/package/typedi" rel="noopener ugc nofollow" target="_blank">的<strong class="ir hi">@服务</strong>装饰器<strong class="ir hi">TypeDI</strong>T7】</a></p></blockquote><h2 id="b8dc" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><a class="ae jn" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank">简介<strong class="ak">反映-元数据</strong>简介</a></h2><blockquote class="il im in"><p id="236d" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://rbuckton.github.io/reflect-metadata/#introduction" rel="noopener ugc nofollow" target="_blank">向ECMAScript添加元数据的提案</a></p></blockquote><p id="a378" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">我们将使用reflect-metadata包进行元数据反射，以定义与每个控制器相关联的访问路由。TypeScript已经扩展了<a class="ae jn" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> reflect-metadata </a>，这允许我们与<a class="ae jn" href="https://www.typescriptlang.org/tsconfig/emitDecoratorMetadata.html" rel="noopener ugc nofollow" target="_blank">emitedecoratormetadata</a>同时获取函数、参数和返回类型。</p><blockquote class="il im in"><p id="7bd3" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>只有当类上有装饰器时，才会为服务或组件发出元数据。哪个装修工不重要。任何装饰器都会导致元数据被发出。</p></blockquote><p id="1722" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">让我们看看如何让它与TypeScript一起工作。我们需要在tsconfig.json中启用它</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/ee01d7230b555b9c2a6dfc434e7a92de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*kbLEUrs4LHo3vmnOIWfjnQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">tsconfig.json changes to support relection</figcaption></figure><pre class="lg lh li lj fd lv lw lx ly aw lz bi"><span id="7ecf" class="jr js hh lw b fi ma mb l mc md"><em class="iq">// define metadata on an object or property</em> Reflect.defineMetadata(metadataKey, metadataValue, target); Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><span id="097f" class="jr js hh lw b fi me mb l mc md"><em class="iq">// check for presence of a metadata key on the prototype chain of an object or property</em> <br/><strong class="lw hi">let</strong> result = Reflect.hasMetadata(metadataKey, target); <br/><strong class="lw hi">let</strong> result = Reflect.hasMetadata(metadataKey, target, propertyKey);</span><span id="3432" class="jr js hh lw b fi me mb l mc md"><em class="iq">// get metadata value of a metadata key on the prototype chain of an object or property</em> <br/><strong class="lw hi">let</strong> result = Reflect.getMetadata(metadataKey, target); <br/><strong class="lw hi">let</strong> result = Reflect.getMetadata(metadataKey, target, propertyKey);</span></pre><h1 id="f84f" class="mf js hh bd jt mg mh mi jx mj mk ml kb mm mn mo ke mp mq mr kh ms mt mu kk mv bi translated"><strong class="ak">装修工</strong></h1><p id="1ca9" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated">在开始装修之前，请记住一些事情，</p><blockquote class="il im in"><p id="17f5" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">decorator是在声明类时调用的，所以在使用decorator时，我们只有类声明而没有实例化。</p></blockquote><p id="2d1d" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">装饰器是一种设计模式，它允许动态地将行为添加到一个单独的对象中，而不会影响同一个类中其他对象的行为。它只是一个函数的包装器，用于增强功能而不修改底层函数。</p><p id="2ecf" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">装饰器已经在Python、C#等语言中使用，现在也在JS和TS中使用。</p><p id="59bc" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">示例:这实现了日志装饰器。</p><pre class="lg lh li lj fd lv lw lx ly aw lz bi"><span id="48ac" class="jr js hh lw b fi ma mb l mc md">function Log() {<br/>  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {<br/>    console.log("Log called")<br/>  };<br/>}</span><span id="9f5f" class="jr js hh lw b fi me mb l mc md">class Logger {<br/> <a class="ae jn" href="http://twitter.com/Log" rel="noopener ugc nofollow" target="_blank">@Log</a><br/> info(){}<br/>}</span></pre><p id="7dd7" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">参见<a class="ae jn" href="https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-evaluation" rel="noopener ugc nofollow" target="_blank">此处</a>了解装饰工评估订单的详细信息。</p><h1 id="2ef3" class="mf js hh bd jt mg mh mi jx mj mk ml kb mm mn mo ke mp mq mr kh ms mt mu kk mv bi translated">用装饰者创建路线</h1><p id="08e8" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated"><strong class="ir hi">路线定义</strong></p><p id="6f92" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">这是一个定义我们路线形状的界面</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mw"><img src="../Images/4b3e2a7c51eced96ae472a1a9db08f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*ghkywQhwBc05LlcaUvLIEA.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">RouteDefinition interface</figcaption></figure><h2 id="01d8" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">路线装饰者</strong></h2><p id="7605" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated">每个HTTP方法都有一个装饰器会很方便，为了简单起见，我们在这里只看到<code class="du mx my mz lw b">@Get</code>。重要的是设置目标<code class="du mx my mz lw b">target.constructor</code>而不仅仅是<code class="du mx my mz lw b">target</code>来正确处理元数据。</p><ol class=""><li id="8c5b" class="kr ks hh ir b is it iw ix jo kt jp ku jq kv jm kw kx ky kz bi translated">这里，目标是拥有其参数已被修饰的方法的对象。在本例中，它是UserController。</li><li id="8028" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">propertyKey:它是签名已被修饰的方法名。下例中的propertyKey是来自UserController的<code class="du mx my mz lw b">get</code>。</li></ol><blockquote class="il im in"><p id="0f23" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们正在使用来自TypeDI的<code class="du mx my mz lw b">@Service</code>装饰器，使服务可注入控制器</p></blockquote><p id="5065" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">下面的例子演示了Get decorator的定义和一个使用Get修饰的路由。</p><div class="lg lh li lj fd ab cb"><figure class="na ii nb nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/2d6c0fd06989a0cb63feb363c1cbc865.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*PIN0Ar-UcPQMOS5RR46e9w.png"/></div></figure><figure class="na ii ng nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/58a82c26af803921ab2dc9f1f484a732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*Ai2UAX_EVYOkuEC8iEVoQw.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx nh di ni nj">@Get decorator</figcaption></figure></div><p id="ef69" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">执行<code class="du mx my mz lw b">/api/user</code>应该会返回所有用户的列表。但是在这完全起作用之前，我们需要注册路由。</p><p id="1006" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">按照下一节关于<strong class="ir hi">控制器装饰器</strong>的内容查看路由注册。</p><h1 id="55d3" class="mf js hh bd jt mg mh mi jx mj mk ml kb mm mn mo ke mp mq mr kh ms mt mu kk mv bi translated"><strong class="ak">创建控制器装饰器</strong></h1><p id="fe6d" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated">我们的控制器将用这个装饰器来装饰，并包含这个控制器的前缀。</p><p id="0a4b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">下面的例子演示了控制器装饰器的定义，其中我们使用reflect-metadata来定义前缀和带有控制器元数据的路由。除了我们的控制器没有修饰过的方法之外，路由几乎不应该是未定义的。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es nk"><img src="../Images/7b44cdcf6c5beb283ba37f9aa907257a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*0th0-6nfCLX45ijPcQOa2A.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Controller Decorator</figcaption></figure><h2 id="3593" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated">使用控制器和路由装饰器定义路由</h2><p id="8643" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated"><strong class="ir hi">步骤:</strong></p><ol class=""><li id="fd0e" class="kr ks hh ir b is it iw ix jo kt jp ku jq kv jm kw kx ky kz bi translated">定义快速路由器</li><li id="9e1f" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">访问前缀和反射路由。</li><li id="4194" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">对于路由中的每个路由定义，向快速路由器注册路径和处理程序。</li><li id="4302" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm kw kx ky kz bi translated">导出路由器以向index/app.ts中的应用程序注册</li></ol><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es nl"><img src="../Images/88cce7bbf66ae0bb3cbb5a7477377492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjjocG-9zLnqW2yA092-eg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Controller Decorator</figcaption></figure><p id="8911" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">在上面的例子中，我们可以看到以下内容</p><ul class=""><li id="21b7" class="kr ks hh ir b is it iw ix jo kt jp ku jq kv jm lo kx ky kz bi translated">控制器装饰定义</li><li id="8814" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">反射以保存前缀的元数据，如果不存在，则初始化路由(路由几乎不应该是未定义的，除非我们的控制器没有修饰的方法)</li><li id="a293" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">IoC容器用于获取<strong class="ir hi">控制器</strong>实例</li><li id="e0b1" class="kr ks hh ir b is la iw lb jo lc jp ld jq le jm lo kx ky kz bi translated">快速路由器的路由注册</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es nm"><img src="../Images/ddc4d0e3ea9e5168be47e371986d2c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*8NLd2ojbgOPeYcebNjot4w.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Use router</figcaption></figure><blockquote class="il im in"><p id="7f25" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>使用index.js中控制器装饰器导出的路由器作为<code class="du mx my mz lw b">app.use(router)</code></p></blockquote><h2 id="0bf8" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">结论</strong></h2><p id="4113" class="pw-post-body-paragraph io ip hh ir b is km iu iv iw kn iy iz jo ko jc jd jp kp jg jh jq kq jk jl jm ha bi translated">正如您所看到的，通过TypeScript Decorators管理快速路由非常容易。reflect-metadata是TypeScript的扩展，有助于维护与装饰器相关的元数据。因此，这个元数据用于存储路由，因为在声明类时会调用decorator。</p><p id="5920" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">完整的代码可以在<a class="ae jn" href="https://codesandbox.io/s/expressjs-routing-with-decoratos-1l723" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>中找到。</p></div></div>    
</body>
</html>