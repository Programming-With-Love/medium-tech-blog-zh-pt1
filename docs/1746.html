<html>
<head>
<title>Putting More Buzz in Your Python Fizz</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你的Python Fizz注入更多活力</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/putting-more-buzz-in-your-python-fizz-f93f5ca7584c?source=collection_archive---------5-----------------------#2020-07-07">https://medium.com/capital-one-tech/putting-more-buzz-in-your-python-fizz-f93f5ca7584c?source=collection_archive---------5-----------------------#2020-07-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="7431" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">关于类型提示如何改进代码的四个过度设计的例子</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/4609d836f891f58df67bf71a62c912a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wkYS7lbE3jUOPSi2.jpg"/></div></div></figure><p id="6341" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">类型提示分析，就像单元测试和静态代码分析一样，都是为了给人们一个适当的信心级别，让他们相信代码会像预期的那样工作。它们可以是Python程序的有用部分，也是我们用来建立代码整体质量的众多工具之一。</p><p id="3dfc" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在这篇文章中，我想探索类型注释帮助编写更好的软件的不同方式。为了做到这一点，我需要解决一个问题。你可能从标题中猜到我要解决的问题:<a class="ae km" href="https://en.wikipedia.org/wiki/Fizz_buzz" rel="noopener ugc nofollow" target="_blank">嘶嘶作响的问题</a>。好几次。准确地说是四次。方法不同，因此类型提示的种类也不同。</p><h1 id="06fe" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么是嘶嘶作响？</h1><p id="8e3e" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">如果你没有听说过嘶嘶作响的问题，这是基于一个派对游戏。人们围坐成一圈。他们从“一”开始报数然后下一个人说，“两个。”到目前为止，一切顺利，对吧？现在是该规则的第一个例外。没有人说三的倍数，他们说“嘶嘶”。所以下一个人说“嘶嘶”，他们后面的人说“四”下一个例外是:没有人说5的倍数。相反，他们说“嗡嗡”所以下一个人说“嗡嗡”而不是“五”然后是“嘶嘶”接着是欢声笑语，因为没人记得嗡嗡声和嘶嘶声之后是哪个数字。最终有人发现是“七”然后是“八”，然后是“嘶嘶”和“嗡嗡”</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ks"><img src="../Images/bcb7a0821f5651264c9ab693cc6ada30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aMPvwNlC5gTPMfEVjWP4A.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx">The fizz-buzz game played with real people</figcaption></figure><p id="c3d3" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">关于为什么我们要过度设计这个问题的一些背景故事。有几年，我住在一艘帆船上。海上有很多可能出错的地方，失败的后果可能是可怕的。因此，许多水手都会同意，任何值得工程的东西都值得<strong class="jq hi">过度工程</strong>。</p><p id="c43c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">因此，在这篇文章中，我想把嘶嘶作响的问题重复四遍。这相对简单，因此，我们可以从多个角度来看待它。但是在我们开始过度设计这个问题之前，让我们先来谈谈工具。</p><p id="efd4" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在船上，我们使用绞盘把手来给我们杠杆作用，使我们越过带有重帆的绳索或带有重锚的链条。一个锚可能重25公斤，链条每米重2.3公斤。在10米深的地方抛锚，几乎是要提升的两倍；用手尝试是不安全的。在这种情况下，绞车是必不可少的，长绞车手柄非常重要。</p><p id="7548" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">现在回到编码。按照设计，Python类型提示对我们代码的运行时行为几乎没有影响。它们大多被像<a class="ae km" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> mypy </a>这样的工具使用。mypy工具对代码和注释进行静态分析，以确认代码符合提示。</p><p id="aa27" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">如果你还没有得到它，你会想要添加它。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="0bdd" class="lc if hh ky b fi ld le l lf lg">python -m pip install mypy</span></pre><p id="03a6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我还将建议Python项目文件和文件夹的安排。不是每个人都喜欢这种安排，但我认为它对大多数项目来说效果很好。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="877c" class="lc if hh ky b fi ld le l lf lg">Project<br/>+-- src<br/>    +-- fizzbuzz.py<br/>+-- tests<br/>    +-- test_fizzbuzz.py<br/>+-- tox.ini</span></pre><p id="92f5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我将专注于使用mypy来检查源代码，所以我将悄悄地忽略这些测试。我将把这些留给读者作为练习。</p><p id="ad19" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在安装了mypy并设置了两个文件夹之后，这里是<code class="du lh li lj ky b">fizzbuzz.py</code>的第一轮实现</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="ce5a" class="lc if hh ky b fi ld le l lf lg">print("1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz")</span></pre><p id="8a1b" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">是的，那个剧本感觉像是作弊。而不是一步一步的游戏算法，它有一个九轮游戏的硬连线结果。它做类似于<em class="lk">的工作。测试是非常痛苦的，因为没有一个测试用例可以导入和测试的函数或类。没有自动化测试意味着它可能不工作。</em></p><p id="2bb0" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">设置好之后，我们应该能够输入mypy src来检查这个小文件的类型注释。没有显式类型批注。这一行代码匹配内置<code class="du lh li lj ky b">print()</code>函数的定义。因此，这一行代码对mypy来说看起来不错。</p><p id="545f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这是为fizz-buzz写你自己的解决方案的好时机。称之为  <code class="du lh li lj ky b"><strong class="jq hi"><em class="lk">fizzbuzz1.py</em></strong></code> <strong class="jq hi"> <em class="lk">以区别于我最初不太好的例子。</em> </strong></p><h1 id="ee4f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">基本类型提示—低/无工程解决方案</h1><p id="e628" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">为了有可测试的东西，将嘶嘶作响的问题分解成函数是有帮助的。这里有一个分解，似乎可以解决问题。<strong class="jq hi">剧透预警</strong> : <em class="lk">它有bug</em>。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="7225" class="lc if hh ky b fi ld le l lf lg">def fizz_buzz(n):<br/>    if n % 3 == 0: return "Fizz"<br/>    elif n % 5 == 0: return "Buzz"<br/>    else: return n</span><span id="73bd" class="lc if hh ky b fi ll le l lf lg">if __name__ == "__main__":<br/>    for i in range(10):<br/>        print(fizz_buzz(i))</span></pre><p id="572c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这似乎适用于从1到10的数字。尽管有逻辑问题，让我们添加类型提示。如果你以前没见过它们，它们看起来像这样:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="035e" class="lc if hh ky b fi ld le l lf lg">def fizz_buzz(n: int) -&gt; str:<br/>    if n % 3 == 0: return "Fizz"<br/>    elif n % 5 == 0: return "Buzz"<br/>    else: return n</span></pre><p id="2f6a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">注释预期类型的代码有两处更改:</p><ul class=""><li id="a810" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated">在参数<code class="du lh li lj ky b">n</code>后，有一个<code class="du lh li lj ky b">: int</code>标注；提示是<code class="du lh li lj ky b">n</code>应该是<code class="du lh li lj ky b">int</code>类型的一个实例。</li><li id="f3ef" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">在函数参数列表后面，有一个<code class="du lh li lj ky b">-&gt; str</code>注释；提示是这个函数的返回值应该是一个<code class="du lh li lj ky b">str</code>类型的实例。</li></ul><p id="d5e6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">虽然类型提示的某些方面可能更复杂，但这是使用注释的基本模型。为函数或方法的每个参数提供提示，以及每个函数或方法的结果。这似乎很好地涵盖了大量案例。</p><p id="a0be" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">如上所述，该算法有一个缺陷。类型提示也有问题。</p><p id="dda3" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">让我们先处理这些暗示。我们可以在<code class="du lh li lj ky b">src</code>目录下运行<code class="du lh li lj ky b">mypy</code>，并看到以下内容:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="3090" class="lc if hh ky b fi ld le l lf lg">% mypy src<br/>src/fizzbuzz2.py:4: error: Incompatible return value type (got "int", expected "str")<br/>Found 1 error in 1 file (checked 2 source files)</span></pre><p id="24d8" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">一些人马上发现了这场冲突。类型注释说<code class="du lh li lj ky b">fizz_buzz()</code>函数返回了一个<code class="du lh li lj ky b">str</code>。酪其中一个<code class="du lh li lj ky b">return</code>语句返回了一个整数值。</p><p id="3cc8" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这导致了一个有趣的困境。我们可以问“哪个是对的？”当代码和注释发生冲突时，我们有两条路可以走，这取决于我们作为软件设计者的意图:</p><ol class=""><li id="cad0" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl ma ls lt lu bi translated"><strong class="jq hi">标注正确:</strong>修复代码匹配标注。</li><li id="4519" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl ma ls lt lu bi translated"><strong class="jq hi">代码正确:</strong>修复标注，使其与代码匹配。</li></ol><p id="c15a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这种困境经常发生。真的很多。根据我的经验，差不多总是这样。</p><p id="9bfa" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">让我们看看选项1 —注释是正确的:修改代码以匹配注释。</strong> <br/>注释一直是正确的，但是代码并没有完全正确地实现它。下面是代码<em class="lk">应该是什么:</em></p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="afbd" class="lc if hh ky b fi ld le l lf lg">def fizz_buzz(n: int) -&gt; str:<br/>    if n % 3 == 0:<br/>        return "Fizz"<br/>    elif n % 5 == 0: <br/>       return "Buzz"<br/>    else: <br/>        return f"{n}"</span></pre><p id="1b36" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们已经修复了return语句，以创建与注释一致的字符串。我偏爱这条路，但它并不总是正确的。</p><p id="d3b5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">让我们看看选项2 —代码是正确的:修复注释以匹配代码。</strong> <br/>注释没有正确反映代码。下面是注释<em class="lk">应该是</em>的样子:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="b8fe" class="lc if hh ky b fi ld le l lf lg">from typing import Union</span><span id="9ddc" class="lc if hh ky b fi ll le l lf lg">def fizz_buzz(n: int) -&gt; Union[str, int]:<br/>    if n % 3 == 0:<br/>        return "Fizz"<br/>    elif n % 5 == 0:<br/>        return "Buzz"<br/>    else:<br/>        return n</span></pre><p id="d943" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这引入了一个新的类型构造函数<code class="du lh li lj ky b">Union</code>。这将构建一个复合类型，其中的对象可以是字符串或整数。这描述了该函数实现的结果。</p><p id="7411" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">Python依赖<a class="ae km" href="https://docs.python.org/3/glossary.html?highlight=duck%20typing" rel="noopener ugc nofollow" target="_blank">鸭子打字</a>::<em class="lk">如果它长得像鸭子，游起来像鸭子，叫起来像鸭子，那么它很可能就是鸭子。”这意味着大多数Python代码在类型方面是通用的，许多函数可以被描述为使用大量类型的联合。</em></p><p id="4cb5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">实际上，我们的应用程序代码倾向于一种或几种类型。为了阐明我们的意图，我们通常希望缩小可能类型的范围，并专注于真正重要的类型。在某种程度上，我们使用类型注释有意地将Python处理大量类型的能力放在一边，以便我们可以专注于与我们的应用程序相关的少数类型。</p><p id="577a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">当我们把手放在船周围的各种绳索上时，水手们会做出许多细微的区别。我们区分床单，升降索，收帆索，码头线和地面滑车。是的，它们或多或少都是各种尺寸和颜色的绳索。在地面滑车的情况下，锚线也可能有一层泥。每一行都有特定的、通常是固定的应用。例如，在翻船时，我们可能需要放松床单。转弯时放松升降索会造成大混乱。放松码头线毫无意义。</p><p id="a9c5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">同样，我们经常希望在应用程序中仔细区分函数允许的数据类型。出于这个原因，我建议避免<code class="du lh li lj ky b">Union</code>定义的复杂性，并使用更窄的定义<code class="du lh li lj ky b">def fizz_buzz(n: int) -&gt; str:.</code>来固定函数</p><p id="99f9" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这并没有揭示算法问题。它不能，真的，因为我们没有考虑到数字15。它既是“嘶嘶”又是“嗡嗡”我认为只有通过单元测试才能发现的bug和mypy发现的潜在bug之间的区别是非常重要的。为了解决这个问题，我们需要一些工具，包括mypy。</p><h1 id="f163" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Python的内置数据结构——一个过度设计的解决方案</h1><p id="fc62" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">让我们做一些过度工程，好吗？</p><p id="dac4" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们希望积累数字和一组字符串之间的映射，而不是简单地打印数字、嘶嘶声或嗡嗡声。我们正在寻找创造如下的东西:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="e12e" class="lc if hh ky b fi ld le l lf lg">{1: set(), 2: set(), 3: {"Fizz"}, 4: set(), 5: {"Buzz"}, ...}</span></pre><p id="a363" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">理想情况下，我们还会修复算法错误，并在结果中加入<code class="du lh li lj ky b">15: {“Fizz”, “Buzz”}</code>。</p><p id="a59a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这需要一些额外的类型构造函数。打字模块包括我们可以使用的<code class="du lh li lj ky b">List, Set,</code>和<code class="du lh li lj ky b">Dict</code>定义。总的来说，这是一个将整数映射到集合的字典。</p><p id="a8fc" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们可以从<code class="du lh li lj ky b">Dict[int, Set]</code>开始描述这个。实际上，它实际上是<code class="du lh li lj ky b">Set[str]</code>，因为集合将只包含字符串(或者为空。).这将我们引向一个如下所示的函数签名:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="ae2d" class="lc if hh ky b fi ld le l lf lg">def fizz_buzz(n: int) -&gt; Set[str]...</span></pre><p id="16a9" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">然后我们可以使用这个函数来构建映射，<code class="du lh li lj ky b">Dict[int, Set[str]].</code></p><h2 id="30b3" class="lc if hh bd ig mb mc md ik me mf mg io jz mh mi is kd mj mk iw kh ml mm ja mn bi translated">在继续航行之前，请随意停下来写下你自己的想法。</h2><p id="450b" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">这是我的解决方案:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="b01f" class="lc if hh ky b fi ld le l lf lg">def fizzy(n: int) -&gt; Set[str]:<br/>    if n % 3 == 0: <br/>        return {"Fizz"}<br/>    return set()<br/>def buzzy(n: int) -&gt; Set[str]:<br/>    if n % 5 == 0: <br/>        return {"Buzz"}<br/>    return set()<br/>def fizz_buzz(n: int) -&gt; Set[str]:<br/>    return fizzy(n) | buzzy(n)<br/>if __name__ == "__main__":<br/>    fb_map = {n: fizz_buzz(n) for n in range(10)}<br/>    for n in fb_map:<br/>        print(fb_map[n])</span></pre><p id="8b5a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">各功能一致。它们都接受一个整数参数，并创建一个正确的结果<code class="du lh li lj ky b">Set[str]</code>。最终的映射使用字典理解来创建从整数到<code class="du lh li lj ky b">fizz_buzz(n)</code>函数结果的映射。</p><p id="bc41" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">当我们在这个文件上运行mypy时，我们会发现mypy有一个关于<code class="du lh li lj ky b">fb_map</code>赋值的问题。虽然我们——作为代码的作者——非常确定这个映射可以被描述为<code class="du lh li lj ky b">Dict[int, Set[str]]</code>,但是mypy并不乐意匆忙得出这个结论。</p><p id="83f5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们需要另一种类型注释机制。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="dcc6" class="lc if hh ky b fi ld le l lf lg">fb_map: Dict[int, Set[str]] = {<br/>    n: fizz_buzz(n) for n in range(10)}</span></pre><p id="df00" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们在变量和<code class="du lh li lj ky b">=</code>之间的赋值语句中加入了一个<code class="du lh li lj ky b">: Dict[int, Set[str]]</code>。</p><p id="cf25" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这澄清了词典理解的意图。它给了mypy足够的优势来判断所有函数是否一致。</p><h1 id="b43e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">这不是有点复杂吗？</h1><p id="aab2" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated"><code class="du lh li lj ky b">fb_map: Dict[int, Set[str]]</code>赋值语句有点复杂，类型注释隐藏在已经很复杂的语句中。我们能简化这个吗？</p><p id="9368" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">剧透预警:</strong> <em class="lk">是。</em></p><p id="0b04" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们可以做的一件事是使用类型构造将复杂的定义分解成更简单的部分。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="5334" class="lc if hh ky b fi ld le l lf lg">FBMap = Dict[int, Set[str]]<br/>fb_map: FBMap = {n: fizz_buzz(n) for n in range(10)}</span></pre><p id="6317" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这展示了我们如何构建一个新的类型注释，并给它命名为<code class="du lh li lj ky b">FBMap</code>。这个名字让我们简化了赋值语句，只使用了<code class="du lh li lj ky b">FBMap</code>类型名而不是长类型表达式。</p><p id="c746" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">虽然这更简单，但这里有一些重复，这是不可取的。我们重复<code class="du lh li lj ky b">Set[str]</code>很多次。我们需要吗？</p><p id="24c5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">剧透预警:</strong> <em class="lk">号</em></p><p id="11bb" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">考虑映射类型的分解。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="d7bb" class="lc if hh ky b fi ld le l lf lg">FzBzState = Set[str]<br/>FBMap = Dict[int, FzBzState]</span></pre><p id="68b2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们已经将复杂系统<code class="du lh li lj ky b">Set[str]</code>指定为一个名字<code class="du lh li lj ky b">FzBzState</code>。在这种情况下，这不是一个巨大的简化。但是，Python让我们可以构建非常复杂的结构，我们可能想要简化这些结构。想想字符串元组和整数元组的列表，或者其他同样令人困惑的东西。因为Python允许大量的复杂性，它可以帮助将这些复杂、令人困惑的东西分解成一些单独的定义。</p><p id="cc23" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这引发了进一步的反思。我不会提供所有的代码，而是总结如下:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="e78e" class="lc if hh ky b fi ld le l lf lg">FzBzState = Set[str]<br/>def fizzy(n: int) -&gt; FzBzState: ...<br/>def buzzy(n: int) -&gt; FzBzState: ...<br/>def fizz_buzz(n: int) -&gt; FzBzState: ...<br/>FBMap = Dict[int, FzBzState]</span></pre><p id="7e2f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这里的目的是确保所有的函数都创建了一个<code class="du lh li lj ky b">FzBzState</code>对象，并且最终的映射对象将包括一个整数和一个<code class="du lh li lj ky b">FzBzState</code>对象。我们可以看到—对于这个具体的实现— <code class="du lh li lj ky b"><strong class="jq hi">FzBzState</strong></code> <strong class="jq hi"> </strong>是一个<code class="du lh li lj ky b">Set[str]</code>。有了这个一致的名称，就有可能考虑改变底层类型，以提高性能或提供更具表达性的对象定义。</p><p id="dcc0" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">将复杂类型分解成简单类型的想法非常吸引人。当我们面临船只维护的复杂问题时，将复杂的问题分解成我们可以独立解决的简单问题会有所帮助。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/81338ab2855846546ba7ab924f5da63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*w_k7e_oHBUwEC9F1TPQHVQ.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx">Over-engineered boat plumbing</figcaption></figure><p id="2740" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">例如，这是一张过于复杂的管道图片。还不清楚，但是五个独立的软管通过一个复杂的配件集合在一起。这需要简化，因为如果某处出现故障，这可能很难处理。</p><h1 id="2d45" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">正向引用和循环——真正过度设计的解决方案</h1><p id="6d7e" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">让我们通过引入类定义来真正解决这个问题。而不仅仅是旧的类定义。让我们介绍一下<em class="lk">相互依赖的</em>类定义。</p><p id="f6d6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们将把一组数字的嘶嘶声或嗡嗡声分成两部分:</p><ul class=""><li id="a1e3" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated">定义给定数字属性的类。</li><li id="b43d" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">这些单个数字属性定义的集合。</li></ul><p id="09ae" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">剧透预警:</strong> <em class="lk">以下代码存在问题。</em></p><p id="343e" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi"> FBStatus </strong>类定义描述了一个数字，并以如下方式开始:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="8e3c" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: FBMap) -&gt; None:<br/>        self.n = n<br/>        self.parent = parent<br/>        self.fb = str()</span></pre><p id="7db2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">如果你没怎么用过类型注释，<code class="du lh li lj ky b">__init__()</code>方法必须返回<code class="du lh li lj ky b">None</code>。我们提供整体地图作为每个单独号码状态的一部分。我没有一个很好的理由来解释为什么这种关系是必不可少的，但是这种循环是复杂数据结构中的一种常见模式，在这种结构中，图的导航可以“向上”也可以“向下”工作。</p><p id="c620" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">需要更多的代码来正确地将值加载到<code class="du lh li lj ky b">self.fb</code>集合中。一旦我们理清了基本的类定义，我们稍后将回到这个问题上来。</p><p id="7880" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><code class="du lh li lj ky b">FBMap</code>类定义描述了一组数字，如下所示:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="2a1a" class="lc if hh ky b fi ld le l lf lg">class FBMap:<br/>    def __init__(self. limit: int) -&gt; None:<br/>        self.domain = {<br/>            n: FBStatus(n, self)<br/>            for n in range(limit)<br/>        }</span></pre><p id="502a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">映射的初始化创建了一个字典来将整数映射到<code class="du lh li lj ky b">FBStatus</code>实例。</p><p id="0f51" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这有一个微妙的问题。以及其他一些不那么微妙的问题。</p><ul class=""><li id="687e" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated"><strong class="jq hi">在方法体内部</strong>我们可以引用任何将成为局部或全局命名空间一部分的对象。方法体评估发生在所有的函数和类被定义之后。这意味着Python函数和类的定义通常可以是任意顺序的。我们经常选择一个顺序来帮助解释代码。</li><li id="9c74" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated"><strong class="jq hi">在方法体之外(即在定义中)</strong>在定义行中，我们只能引用先前在模块中定义的名字。这限制了定义的顺序，因此函数或方法定义只能引用以前定义的类或函数。</li></ul><p id="ab8f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">然而，Mypy给了我们一种打破这种定义顺序规则的方法。我们可以提供一个字符串来代替类名。Mypy将解析字符串，这将允许我们包含前向引用。这里有一个小变化，让我们先用对<code class="du lh li lj ky b">FBMap</code>的前向引用来定义<code class="du lh li lj ky b">FBStatus</code>。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="3707" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: "FBMap") -&gt; None:<br/>        self.n = n<br/>        self.parent = parent<br/>        self.fb = set()</span></pre><p id="fcde" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">变化很小。我们用字符串<code class="du lh li lj ky b">“FBMap”</code>替换了<code class="du lh li lj ky b">FBMap</code>。然而，这还不是全部。一旦我们解决了这个问题，我们就可以继续这里的另外两个问题。</p><h2 id="62ab" class="lc if hh bd ig mb mc md ik me mf mg io jz mh mi is kd mj mk iw kh ml mm ja mn bi translated">第一个问题——自我父母</h2><p id="5027" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated"><code class="du lh li lj ky b">__init__()</code>方法的第一个问题是self.parent确实需要成为一个<code class="du lh li lj ky b">weakref</code>。这超出了类型提示主题的范围，但是使用<code class="du lh li lj ky b">weakref.ref(parent)</code>很有帮助。</p><h2 id="d625" class="lc if hh bd ig mb mc md ik me mf mg io jz mh mi is kd mj mk iw kh ml mm ja mn bi translated">第二个问题—设置self.fb集合元素</h2><p id="0b33" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated"><strong class="jq hi"> </strong> <code class="du lh li lj ky b">__init__()</code>方法中的第二个问题是我们从未将<code class="du lh li lj ky b">self.fb</code>的值设置为任何有用的值。我们想创造一套嘶嘶或嗡嗡声的属性。</p><p id="539e" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">让我们解决这两个问题，完成<code class="du lh li lj ky b">self.fb</code>的初始化:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="db1e" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: "FBMap") -&gt; None:<br/>        self.n = n<br/>        self.parent = weakref.ref(parent)<br/>        self.fb = set()<br/>        if n % 3 == 0: self.fb |= {"Fizz"}<br/>        if n % 5 == 0: self.fb |= {"Buzz"}</span></pre><p id="9d82" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这显示了我们如何将<code class="du lh li lj ky b">self.fb</code>集合构建为几个可能值的并集。我们可以把“嘶嘶”加到布景中，或者把“嗡嗡”加到布景中，或者两者都加，或者不加。</p><h2 id="8d00" class="lc if hh bd ig mb mc md ik me mf mg io jz mh mi is kd mj mk iw kh ml mm ja mn bi translated">第三，不是真正的问题——显示状态</h2><p id="3ef2" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">虽然我们的类非常简单，但通常使用属性或方法来公开对象的当前状态。让我们再添加一个特性:从这个类的每个实例中提取有用摘要的属性。以下是完整的定义:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="8464" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: "FBMap") -&gt; None:<br/>        self.n = n<br/>        self.parent = weakref.ref(parent)<br/>        self.fb = set()<br/>        if n % 3 == 0: self.fb |= {"Fizz"}<br/>        if n % 5 == 0: self.fb |= {"Buzz"}</span><span id="ae23" class="lc if hh ky b fi ll le l lf lg">    @property<br/>    def fizz_buzz(self) -&gt; Tuple[int, Set[str]]:<br/>        return self.n, self.fb</span></pre><p id="b509" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这一特性将使我的py适合。为什么？我们有矛盾:</p><ul class=""><li id="df8a" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated"><code class="du lh li lj ky b">fizz_buzz</code> <strong class="jq hi"> </strong>产权界定主张<code class="du lh li lj ky b">self.fb</code>为<code class="du lh li lj ky b">Set[str]</code>。</li><li id="5da0" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated"><code class="du lh li lj ky b">__init__()</code>方法权利要求<code class="du lh li lj ky b">self.fb</code>为<code class="du lh li lj ky b">Set[Any]</code>。</li></ul><p id="6eeb" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">正如我们上面提到的，我们已经暴露了代码和提示之间的冲突。通常代码是错误的，但有时提示是错误的。在这种情况下，一点额外的注释就可以解决问题。</p><p id="06a9" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">最后看一下<code class="du lh li lj ky b">FBStatus</code>的类定义。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="ea07" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: "FBMap") -&gt; None:<br/>        self.n = n<br/>        self.parent = weakref.ref(parent)<br/>        self.fb: Set[str] = set()<br/>        if n % 3 == 0: self.fb |= {"Fizz"}<br/>        if n % 5 == 0: self.fb |= {"Buzz"}</span><span id="449b" class="lc if hh ky b fi ll le l lf lg">    @property<br/>    def fizz_buzz(self) -&gt; Tuple[int, Set[str]]:<br/>        return self.n, self.fb</span></pre><p id="073d" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这个<code class="du lh li lj ky b">FBStatus</code>类的定义为mypy提供了一个重要的线索:集合将只包含字符串。这个额外的定义解决了mypy看到的最初如何创建<code class="du lh li lj ky b">self.fb</code>和如何在<code class="du lh li lj ky b">fizz_buzz</code>属性中使用它之间的冲突。</p><p id="4e6b" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">“<code class="du lh li lj ky b">FBMap</code>”字符串作为对<code class="du lh li lj ky b">FBMap</code>类型的正向引用注释，让我想起了在船上使用“吊线”的方式。将新的升降索穿入50英尺长的桅杆是很棘手的。桅杆里面还有其他线路和电线。这是一根长长的铝管，所以我们看不到我们在做什么。然而，水手们对此有一个解决办法。我们从在旧升降索的末端系上一根轻绳开始。当我们拉下升降索时，那根轻的绳索跟着它绕过各种滑轮，穿过桅杆的黑暗凹处。我们把这个信使留在原地标记道路。当需要用一根新的、不那么磨损的绳索来替换升降索时，我们把新的升降索弯向传令兵，用它来拉着沉重的升降索穿过桅杆的黑暗凹处。</p><p id="6b12" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">使用字符串作为类型提示类似于信使行。真正的类型最终会被定义。目前，有一个轻量级的占位符。</p><h1 id="6770" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">你怎么知道的？</h1><p id="95c0" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">有时，来自mypy的错误可能会令人困惑。对我来说，造成困惑的最常见原因是mypy错误与我对正在处理的代码的一个严格假设相冲突。我以为我知道我的意思。为什么我的py也看不到？</p><p id="ded3" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">澄清假设错误程度的主要工具是<code class="du lh li lj ky b">reveal_type()</code>“函数”。这有函数的语法，但不是真正的函数。mypy用它来显示细节。</p><p id="98e5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们可以这样使用它:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="ccf5" class="lc if hh ky b fi ld le l lf lg">class FBStatus:<br/>    def __init__(self, n: int, parent: "FBMap") -&gt; None:<br/>        self.n = n<br/>        self.parent = weakref.ref(parent)<br/>        self.fb = set()<br/>        reveal_type(self.fb)<br/>        if n % 3 == 0: self.fb |= {"Fizz"}<br/>        if n % 5 == 0: self.fb |= {"Buzz"}</span><span id="74d3" class="lc if hh ky b fi ll le l lf lg">    @property<br/>    def fizz_buzz(self) -&gt; Tuple[int, Set[str]]:<br/>        return self.n, self.fb</span></pre><p id="1aa2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我在这个例子中加入了一个<code class="du lh li lj ky b">reveal_type(self.fb)</code>来展示它的样子。这是在运行mypy之前要做的事情。它必须被移除，因为有了它，你甚至不能运行单元测试。它可以帮助我们了解mypy对我们的代码有什么看法。</p><p id="c7c4" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这就像在棘手的河流入口处发现一个浮标。全球定位系统很有趣，而且认为你知道自己在哪里也很好。没有什么比看到一个大的绿色旧罐头浮标漂浮在水中，或多或少在你希望的地方更好的了。一个有形的地标给我们提供了很多信心，让我们相信我们正在安全的深水中航行。</p><h1 id="15d9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">命名元组——另一个真正过度设计的解决方案</h1><p id="f6b4" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">我想看看另一个可能的过度设计的解决方案来解决嘶嘶作响的问题。我们将从使用<code class="du lh li lj ky b">typing.NamedTuple</code>实例来跟踪一个数字的活跃程度开始。它们可以内置类型提示，对于创建具有相当完整注释的应用程序非常有用。</p><p id="1039" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">首先是比老款<code class="du lh li lj ky b">collections.namedtuple</code>酷多了的新款<code class="du lh li lj ky b">typing.NamedTuple</code>。这里有一个例子:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="b6fc" class="lc if hh ky b fi ld le l lf lg">from typing import NamedTuple, Optional, Set</span><span id="2776" class="lc if hh ky b fi ll le l lf lg">class FB(NamedTuple):<br/>    n: int<br/>    fizz: Optional[str]<br/>    buzz: Optional[str]</span></pre><p id="e442" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这是一个Python三元组，属性名为n、fizz和buzz，用于元组中的项目和——奖金！—为每个项目键入注释。这比Tuple[int，Optional[str]，Optional[str]]的未命名元组好一点，因为每个条目都有一个适当的属性名。最大的好处是提供了提示，这样mypy可以仔细检查代码。</p><p id="8aa2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><code class="du lh li lj ky b">Optional[str]</code>是描述两种类型的并集的简便方法。这相当于<code class="du lh li lj ky b">Union[str, None]</code>，反映了一种非常常见的Python编程实践。这说明了当没有有用的值时，None通常被用作占位符。</p><p id="7ec2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们可以使用这样的代码<code class="du lh li lj ky b">fb6 = FB(6, “Fizz”, None)</code>来定义一个给定数字的属性。我们可以使用<code class="du lh li lj ky b">fb6[0]</code>或<code class="du lh li lj ky b">fb6.n</code>来获得数值，使用<code class="du lh li lj ky b">fb6[1]</code>或<code class="du lh li lj ky b">fb6.fizz</code>来获得数字的嘶嘶声。我喜欢命名属性而不是位置属性。</p><p id="fb81" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我们如何创建这些对象？我们需要某种工厂。这里有一个合适的函数:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="d59e" class="lc if hh ky b fi ld le l lf lg">def fizz_buzz(n: int) -&gt; FB:<br/>    return FB(<br/>        n,<br/>        "Fizz" if n % 3 == 0 else None,<br/>        "Buzz" if n % 5 == 0 else None<br/>    )</span></pre><p id="4ab6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这将用一个数字和适当的属性构建<code class="du lh li lj ky b">FB</code>元组。我喜欢这种解决方案，我们可以使用应用于不可变对象的函数。</p><p id="f902" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">然而，这与之前的定义并不完全一致。它在任何地方都没有使用<code class="du lh li lj ky b">Set[str]</code>。我们可以把它作为一种属性添加进去:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="95a3" class="lc if hh ky b fi ld le l lf lg">class FB(NamedTuple):<br/>    n: int<br/>    fizz: Optional[str]<br/>    buzz: Optional[str]</span><span id="2d75" class="lc if hh ky b fi ll le l lf lg">    @property<br/>    def as_set(self) -&gt; Set[str]:<br/>        return {self.fizz, self.buzz} - {None}</span></pre><p id="1de1" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我添加了一个<code class="du lh li lj ky b">as_set</code>属性，将fizz和buzz值转换成一组字符串。注意<code class="du lh li lj ky b">self.fizz</code>和<code class="du lh li lj ky b">self.buzz</code>的值是<code class="du lh li lj ky b">Optional[str]</code>。<code class="du lh li lj ky b">str</code>和<code class="du lh li lj ky b">None</code>的并集意味着它们可能有一个<code class="du lh li lj ky b">None</code>值。我们真的不想在结果集中看到None对象，所以我们用集合减法显式地删除它。</p><p id="97e6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">然而，这导致了mypy的问题。集合的内容似乎是<code class="du lh li lj ky b">Set[Optional[str]]</code>，与<strong class="jq hi"> </strong> <code class="du lh li lj ky b">Set[str]</code>的返回类型不匹配。这里的问题是mypy搞不清楚我们移除<code class="du lh li lj ky b">None</code>对象的算法。一个人可以确信在结果集中不会有<code class="du lh li lj ky b">None</code>对象，但是mypy没有这么聪明。</p><p id="1989" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在某些地方，mypy可以(并且确实)检测到从<code class="du lh li lj ky b">Optional[str]</code>到<code class="du lh li lj ky b">str</code>的转换。这些地方几乎总是包含一个明确的<code class="du lh li lj ky b">if</code>陈述，很容易察觉和推理。</p><p id="ddaa" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">缺少一个明显的<code class="du lh li lj ky b">if</code>语句，我们被迫用我们确信我们的算法产生的类型来标记结果。为此，我们需要<code class="du lh li lj ky b">typing.cast()</code>函数:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="140c" class="lc if hh ky b fi ld le l lf lg">class FB2(NamedTuple):<br/>    n: int<br/>    fizz: Optional[str]<br/>    buzz: Optional[str]</span><span id="9150" class="lc if hh ky b fi ll le l lf lg">    @property<br/>    def as_set(self) -&gt; Set[str]:<br/>        return cast(Set[str], {self.fizz, self.buzz} - {None})</span></pre><p id="ade7" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">使用<code class="du lh li lj ky b"><strong class="jq hi">cast(Set[str], …) </strong></code>告诉mypy，表达式确实删除了<code class="du lh li lj ky b">None</code>值，从看起来是<code class="du lh li lj ky b">Set[Optional[str]]</code>的地方构建了一个<code class="du lh li lj ky b">Set[str]</code>。</p><p id="2a99" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><code class="du lh li lj ky b">cast()</code>函数本质上是一个没有运行时结果的注释。它可以帮助我澄清对我的py来说不太明显的表达。</p><p id="d829" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">对我来说，命名元组就像是用彩色编码的床单来控制船帆。与其让客人扔掉右舷的帆索，不如让他们捡起更薄的绿色绳索。更胖的绿色绳索是右舷扬基床单，现在还没被使用。这两个红色的绳子是左舷的，我们在抛锚后会用到它们。</p><p id="2a1c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我的船很复杂，这意味着我们不是在真正航行，除非我们在驾驶舱里堆了六张不同的纸。与命名元组的属性一样，每个属性都有清晰的名称是很重要的。</p><h1 id="03fe" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">使用数据类——也真的，真的过度设计了</h1><p id="b9dc" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">过度工程的最后一个例子是创建数据类的实例。这里有很大的灵活性，我将只举一个不太复杂的例子。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="e914" class="lc if hh ky b fi ld le l lf lg">from dataclasses import dataclass, field<br/>from typing import Set</span><span id="8812" class="lc if hh ky b fi ll le l lf lg">@dataclass<br/>class FB:<br/>    n: int<br/>    fizz_buzz: Set[str] = field(init=False)<br/>    <br/>    def __post_init__(self) -&gt; None:<br/>        self.fizz_buzz = set()<br/>        self.fizz_buzz |= {"Fizz"} if self.n % 3 == 0 else set()<br/>        self.fizz_buzz |= {"Buzz"} if self.n % 5 == 0 else set()</span></pre><p id="3a67" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这个<code class="du lh li lj ky b">FB</code>类让我们使用类似<code class="du lh li lj ky b">[FB(i) for i in range(15)]</code>的代码创建对象。我们设置了这个来展示数据类可用的多种初始化方法中的一些:</p><ul class=""><li id="597b" class="lm ln hh jq b jr js jv jw jz lo kd lp kh lq kl lr ls lt lu bi translated">默认情况由<code class="du lh li lj ky b">self.n</code>属性显示。核心<code class="du lh li lj ky b">__init__()</code>加工是为我们打造的；当我们使用<code class="du lh li lj ky b">FB(i)</code>时，这将设置<code class="du lh li lj ky b">self.n</code>属性的值。</li><li id="00b2" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">一种常见的替代情况是提供默认值。<code class="du lh li lj ky b">self.fizz_buzz</code>属性不是<code class="du lh li lj ky b">__init__()</code>参数的一部分，因为我们使用了赋值语句来提供默认值。<code class="du lh li lj ky b">field(init=False)</code>是一种非常特殊的缺省值，不设置这个属性。一种无违约的违约。</li><li id="b391" class="lm ln hh jq b jr lv jv lw jz lx kd ly kh lz kl lr ls lt lu bi translated">在<code class="du lh li lj ky b"> __init__()</code>设置了<code class="du lh li lj ky b">self.n</code>属性值之后，我们提供了一个<code class="du lh li lj ky b">__post_init__()</code>方法来设置<code class="du lh li lj ky b">self.fizz_buzz</code>属性的值。</li></ul><p id="294f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><code class="du lh li lj ky b"> __post_init__()</code>方法用于在类定义中提供Fizz Buzz规则的整洁封装。dataclass让我们为类的属性提供类型提示。它让我们可以用多种方式初始化这些属性。</p><p id="ecbf" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">与用<code class="du lh li lj ky b">typing.NamedTuple</code>创建的版本不同，<code class="du lh li lj ky b">FB</code>类创建的对象是可变的，因此对n属性的更改会导致无效的对象。一些病态的东西，比如:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="7d8e" class="lc if hh ky b fi ld le l lf lg">&gt;&gt;&gt; fzbz = FB(6)<br/>&gt;&gt;&gt; fzbz.n = 7</span></pre><p id="bc4a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">是道德败坏，但有效的Python。如果我们希望能够设置<code class="du lh li lj ky b">n</code>属性，并且让<code class="du lh li lj ky b">fizz_buzz</code>属性的值也发生变化，我们将需要创建可设置的属性。我将把这作为一个练习留给读者。</p><p id="348d" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">灵活的初始化选择使得数据类非常便于创建有状态对象。我们可以提供类型提示来反映属性值的域。对我来说，数据类的灵活性就像一艘船上有两个桅杆和五个帆:无论什么条件，都有一个帆的组合来提供安全、可控的航行。配置船帆需要一些工作，但可用的选择数量意味着结果通常会令人愉快。</p><h1 id="4aae" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="2a30" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">用打字提示给你的汽水注入更多的活力。</p><p id="44cc" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">软件开发有很多可能出错的地方。我们会误解用户和他们的问题。我们可能会误解数据或适当的算法。我们可能有不太符合我们意图的代码，或者，我们的意图有点模糊。</p><p id="6211" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我喜欢思考类型提示，并用它来通知代码和单元测试。我认为在试图编写构建或使用这些数据结构的代码之前，清楚地阐明需要什么样的结构是有帮助的。</p><p id="3e8c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我曾经和一些人交谈过，他们怀疑类型提示是否是多余的；由于单元测试确认了软件的工作，类型提示并没有告诉我们任何新的东西。我拒绝认为冗余是一个问题。</p><p id="a7d7" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">我认为类型提示确实告诉了我们一些新的东西。Python的duck typing灵活性意味着许多错误可以通过一系列单元测试，而这些单元测试无法测试所有模糊的边缘情况。像<code class="du lh li lj ky b">a+b</code> <strong class="jq hi"> </strong>这样的表达式适用于浮点、整数、字符串、列表、元组甚至字节。虽然测试预期类型很常见，但我们很少测试意外类型。mypy的静态分析可以帮助缩小所考虑的类型的范围，并保证测试覆盖所有可能的情况。</p><p id="13e5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">对于同一项工作使用多种工具，我不能说有什么不好。我的船有四个独立的泵从舱底排水——两个电动的，两个手动的。当问题的后果很严重时，拥有多种工具似乎是明智的，每种工具都有不同的侧重点。如果我要编写高质量的软件，我希望使用尽可能多的工具来确保事情按我预期的方式运行。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mo"><img src="../Images/e6e57a3241f6e05ff7a0f637209bdae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*HTlKzhUYi-lqAwsmHmDSag.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx">A beautiful sunrise over the Atlantic Ocean</figcaption></figure><p id="c487" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><em class="lk">最初发表于</em><a class="ae km" href="https://www.capitalone.com/tech/software-engineering/fizz-buzz-python-type-hints/" rel="noopener ugc nofollow" target="_blank"><em class="lk"/></a><em class="lk">。</em></p></div><div class="ab cl mp mq go mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ha hb hc hd he"><p id="6fe8" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><em class="lk">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>