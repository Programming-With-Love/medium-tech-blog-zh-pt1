<html>
<head>
<title>Jetpack Compose: Debugging Recomposition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack合成:调试重组</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-compose-debugging-recomposition-bfcf4a6f8d37?source=collection_archive---------0-----------------------#2022-09-07">https://medium.com/androiddevelopers/jetpack-compose-debugging-recomposition-bfcf4a6f8d37?source=collection_archive---------0-----------------------#2022-09-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/345a42ec2bb3cd8e19601c17b03e91a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwdtRcu1bo_PoH8rwh5E4A.png"/></div></div></figure><div class=""/><p id="523b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我想向你展示我是如何在<a class="ae jn" href="https://github.com/android/compose-samples/tree/main/Jetsnack" rel="noopener ugc nofollow" target="_blank"> Jetsnack </a>中发现一个性能问题的，以及我是如何在Jetpack Compose中调试和修复它的。如果你愿意的话，这篇文章也可以以视频的形式发布。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Jetpack Compose: Debugging Recomposition</figcaption></figure><p id="9430" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从查看Jetsnack示例开始。</p><p id="2d55" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">详细信息屏幕有一个奇特的折叠工具栏效果，当我们向上滚动时，内容会向上移动并调整大小，当我们向下滚动时，内容会返回到开始时的状态。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/0c0a31ddde82d08f8e80f06c445bbe7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1YSy0aL4lM-6BVZq"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Jetsnack details screen — Collapsing toolbar</figcaption></figure><p id="e247" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有报告称，在低端设备上，当它滚动时会显得很笨拙。所以，让我们来看看为什么会这样。</p><h1 id="5aba" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">撰写阶段摘要</h1><p id="8774" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在我们开始调试之前，让我们快速回顾一下调试这个问题所需的一些知识。记住作曲有3个<a class="ae jn" href="https://developer.android.com/jetpack/compose/phases" rel="noopener ugc nofollow" target="_blank">阶段</a>:</p><ol class=""><li id="b2b2" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated"><strong class="ir ht">构图</strong>通过构建一棵可组合的树来决定要显示什么。</li><li id="4ff8" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">布局获取那棵树，并计算出它们将在屏幕上显示的位置。</li><li id="b68c" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><strong class="ir ht">绘图</strong>然后将组件绘制到屏幕上。</li></ol><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/724dbe29cbc6149c1050cd391d91f1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VECWwv_yaf-19My8"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">The three phases of Compose</figcaption></figure><p id="6db6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是最酷的部分:如果一个阶段中没有状态改变，Compose可以完全跳过这个阶段。所以不需要仅仅为了重新布局屏幕而重新排版。如果我们可以避免改变我们的合成树，Compose将完全跳过合成阶段，这将导致性能的提高。</p><p id="af7b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是为什么我们的performance <a class="ae jn" href="https://developer.android.com/jetpack/compose/performance#defer-reads" rel="noopener ugc nofollow" target="_blank">文档</a>声明，“在使用频繁变化的状态 时，<strong class="ir ht"> <em class="lq">更喜欢lambda修饰符”。使用lambdas可以将工作推迟到以后的阶段，并且可以跳过合成。</em></strong></p><h1 id="2024" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用lambda修改器</h1><p id="2966" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">为什么使用lambda修改器意味着我们可以跳过合成？让我们回到合成树看看。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/4fc5bfcefef2eb1131e2e303822df009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7_MBI5UOgCCznk-6"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Lambdas changing the composition tree</figcaption></figure><p id="498d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">组合树也是由应用于组合的任何修饰符构建的。</p><p id="ff77" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">修饰符实际上是不可变的对象。当翻译随着用户向上滚动而改变时，修饰符被重建，旧的被移除，新的被添加到合成树。每次失调改变时都会发生这种情况。因为合成树已经改变，所以发生了重组。</p><p id="c577" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以请记住，<strong class="ir ht">你不应该仅仅为了重新布局一个屏幕而重新构图</strong>，尤其是在滚动的时候，这将导致抖动的画面。每当你看到不必要的重组，想想如何将工作转移到后面的阶段。</p><h1 id="0f56" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">修复Jetsnack的滚动性能问题</h1><p id="50eb" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">现在我们已经讨论了理论，我们可以深入到Jetsnack中的实际问题。</p><p id="d750" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Android Studio中的布局检查器，我们可以看到可组合函数的<a class="ae jn" href="https://developer.android.com/jetpack/compose/tooling#recomposition-counts" rel="noopener ugc nofollow" target="_blank">重组和跳过计数</a>。如果我们去Jetsnack的详情页，上下滚动，可以看到标题composable正在大量重新合成。很可能在每一帧上😨</p><p id="0aca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lq">注意:如果你升级到Android Studio Electric Eel，你还可以在布局检查器中看到可组合重新组合时的高亮显示。</em></p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/f0adcc3579b4cd87e8bf20f14ffdb4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AS7se26rm-gJAmEw"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Layout inspector showing recomposition happening</figcaption></figure><p id="4813" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们看一下<a class="ae jn" href="https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/ui/snackdetail/SnackDetail.kt#L95" rel="noopener ugc nofollow" target="_blank"> SnackDetail </a> composable:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ls jt l"/></div></figure><p id="1738" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到标题读取当前滚动值。这意味着每当滚动改变时，这个可组合的将不得不被重新组合。</p><p id="8656" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在看标题composable。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ls jt l"/></div></figure><p id="1bef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它获取滚动值并计算一个偏移量，然后在<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier).graphicsLayer(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,androidx.compose.ui.graphics.TransformOrigin,androidx.compose.ui.graphics.Shape,kotlin.Boolean,androidx.compose.ui.graphics.RenderEffect,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color)" rel="noopener ugc nofollow" target="_blank"> graphicsLayer </a>修改器中使用该偏移量来实现屏幕上的平移。</p><p id="58f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以采取的第一步是推迟将滚动值读入标题composable。我们可以通过将滚动参数转换为lambda来实现这一点。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ls jt l"/></div></figure><p id="9a1d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将推迟状态的读取，并且至少将重组的范围限制在标题composable上。这很好，但我们可以做得更好！</p><p id="90cf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们现在所知道的，当在一个频繁变化的状态中传递时，我们应该首选lambda修饰符。我们的滚动值绝对算经常变化！</p><p id="aa99" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lt lu lv lw b">graphicsLayer</code>有一个<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier).graphicsLayer(kotlin.Function1)" rel="noopener ugc nofollow" target="_blank"> lambda版本</a>我们可以切换到。如果我们使用它，我们可以将状态的读取推迟到绘制阶段，这意味着可以完全跳过合成。但是仅仅切换到lambda修改器是不够的。由于滚动状态仍然在lambda之外读取以计算偏移量，我们仍然需要重新组合。</p><p id="da9a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了将读取完全推迟到绘制阶段，我们还需要将读取移动到graphicsLayer {}修改器中。我们将把偏移量的计算移到lambda内部，如下所示。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ls jt l"/></div></figure><p id="7460" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们的合成状态只在graphicsLayer修饰符内部被读取，我们已经推迟了在合成之外的读取，可以跳过合成。</p><p id="c625" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们重新运行应用程序并打开布局检查器，我们可以看到构图已被完全跳过。没有对单个组件的重新组合甚至跳过。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/6d0e003cfe43f3ef80331e8e05fcc6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PskGLdZNY_aNgGaK"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Layout inspector showing no recomposition</figcaption></figure><p id="e5f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！这个问题现在解决了，我们已经实现了相同的折叠工具栏效果，而没有使用重组。</p><p id="8f3f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有关更多Jetpack Compose性能提示，请参见我们的<a class="ae jn" href="http://goo.gle/compose-performance" rel="noopener ugc nofollow" target="_blank">性能文档</a>。</p></div></div>    
</body>
</html>