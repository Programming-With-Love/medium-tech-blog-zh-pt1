<html>
<head>
<title>Linked lists: A Beginner’s Guide For Creating a Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表:创建堆栈的初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/implementing-stacks-using-linked-lists-in-typescript-b39bd6540be1?source=collection_archive---------0-----------------------#2021-08-18">https://medium.com/quick-code/implementing-stacks-using-linked-lists-in-typescript-b39bd6540be1?source=collection_archive---------0-----------------------#2021-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7509d9e871b0d0e065f9431aef09066b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqHSA4wjCUPq31fT1lNH3g.jpeg"/></div></div></figure><p id="085d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据结构用于表示和管理数据。无论数据结构是数组、链表、堆栈、队列、树还是其他，它都提供了一种有效存储和检索数据的方法。</p><p id="d9da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">链表是一个非常重要和基本的数据结构，它在编程中被广泛使用，它们是一个简单的概念，但却是程序员工具箱中一个非常强大的工具。</p><h1 id="6107" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是堆栈、队列和链表？</h1><p id="0f6a" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">堆栈是一种数据结构，提供对其元素的后进先出(LIFO)访问。也就是说，访问或修改堆栈元素的操作通常以元素插入堆栈的相反顺序进行</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/5cb2ef09b09837b85eece2f529d17fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNTFAW7aaCKrl652U1gQ5A.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Stack example — Figure by Josué Caro</figcaption></figure><p id="f3ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">解释堆栈概念的一个非常好的、众所周知的例子是餐馆里的盘子。当一个新的盘子被添加到堆叠中时，它被放置在先前盘子的顶部。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="7332" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<strong class="ir hi">队列</strong>是项目的线性集合，其中第一个项目总是下一个要处理的，先进先出(FIFO)。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/ba6f4bf0f1baf9bdbf044c47c91d58b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3rkYS-f4Yow9mb3QnfzhQ.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Queue example — Figure by Josué Caro</figcaption></figure><p id="5f61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">把队列想象成银行或邮局的一排人，第一个到达的人是第一个被服务的人。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="531e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">链表</strong>是一种以连续有序的方式存储数据的方式。它由一组“节点”组成。列表的每个节点都包含一段数据和对序列中下一个节点的引用(指针)。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/521b93a95e512b8d2a9b29ec15864471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kONHBMfwYVUODm0jBtoAww.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Simple Linked List Concept — Figure by Josué Caro</figcaption></figure><p id="4e0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，每个节点可能包含有关其在序列中的位置、大小或其他有用信息(例如，时间戳)的信息。</p><h2 id="d20d" class="li jo hh bd jp lj lk ll jt lm ln lo jx ja lp lq kb je lr ls kf ji lt lu kj lv bi translated">如何用链表实现栈？</h2><p id="ca23" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我将使用<strong class="ir hi"> Typescript </strong>进行解释，但是很容易将其翻译成其他语言。</p><p id="b09c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们开始用链表实现堆栈。</p><p id="3d5e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将创建我们的节点类，这将允许我们链接到其他节点。为了方便起见，我们将使该类成为泛型，这将允许我们使用我们想要存储的任何类型的数据。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="f6d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，节点有两个基本属性，信息(数据、元数据)和引用。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/9e2538c6f1902fab38b4cbaa24573f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IC4KCj5VuPQe9MmPxcMczQ.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Simple Linked List Concept — Figure by Josué Caro</figcaption></figure><p id="9ea2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在引用中有两种可能性，如果没有链接的节点，它将为空，如果有另一个节点，引用将指向该节点。</p><p id="515f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们向节点类添加必要的属性。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="64df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们添加_data和_next，并在构造函数中初始化它们。我们只需要添加setters和getters就可以访问这些属性。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="794b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将继续创建我们的堆栈类。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/1ca848f44a204ef7d121138fbde3228f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Irlf2iKlyCFXstHR2NqS1w.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Stack Concept — Figure by Josué Caro</figcaption></figure><p id="3e07" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们以餐馆为例，每个盘子将是一个“节点”，它将有一个对下一个盘子的引用，直到我们到达最后一个盘子，其中，由于没有其他后续盘子，它是空的。</p><p id="e6c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在堆栈数据结构中，除了对我们有用的其他信息，如堆栈的大小，我们总是对知道哪个节点是“头”中的节点感兴趣。</p><p id="759e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加必要的属性，在这个例子中，除了头部，我们将只包括大小。</p><blockquote class="ly lz ma"><p id="1f99" class="ip iq mb ir b is it iu iv iw ix iy iz mc jb jc jd md jf jg jh me jj jk jl jm ha bi translated">如果节点和堆栈类在不同的文件中，记得导入它们。</p></blockquote><pre class="kr ks kt ku fd mf mg mh mi aw mj bi"><span id="67ae" class="li jo hh mg b fi mk ml l mm mn">#example<br/>import { Node } from '{{your_path}}';</span></pre><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e006" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将节点“head”初始化为null，因为我们没有初始元素。我们还将大小设置为0。</p><p id="bf1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们不要忘记创建大小的吸气剂。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e8c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们将创建类的重要方法，它将允许我们在列表中添加和删除节点。</p><p id="dc86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从添加到我们的列表开始。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/9369d03e9b17417792c1177c81173944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9czGUM5yKnCa5N_hNyCAg.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Stack Push Concept — Figure by Josué Caro</figcaption></figure><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="db75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们通过检查属性“head”的值来验证我们的列表是否为空。如果为空，则表示列表中没有元素，否则，有一个或多个元素。(也可以使用size属性来确定元素的数量)。</p><p id="eb8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果条件中没有其他元素，我们将我们的新节点指定为列表的<strong class="ir hi">头。如果有更多的元素，我们必须访问新节点的属性“next ”,我们将<strong class="ir hi">引用</strong>分配给列表的头，然后我们将我们的新节点分配为列表的头。</strong></p><p id="337e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不管条件如何，我们增加我们的尺寸<strong class="ir hi">计数器</strong>。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/4a75712caab653f34acc197da262cbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rm5l3czIhCqSBzHC0Uq_EQ.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Stack Pop Concept — Figure by Josué Caro</figcaption></figure><p id="5345" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">最后</strong>我们添加了从列表中移除节点的方法，并返回它们的数据。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="ac72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们创建“pop”方法，在这里我们验证列表中有元素，否则我们返回空值，因为我们不能返回一个不存在的节点的值。</p><p id="4cb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们至少有一个元素，我们创建一个临时变量，在那里我们将分配节点“head ”,稍后我们必须分配下一个节点的引用作为“head ”,或者如果没有更多的元素，将它分配为null。</p><p id="495e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们递减计数器的大小，并返回数据。</p><p id="8bcb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们只需要测试我们的堆栈类。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="394e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就这样，我们希望您喜欢这篇关于在Typescript中使用链表实现堆栈的文章。如果你对这篇文章有任何疑问，请在评论中告诉我们。谢谢！。</p></div></div>    
</body>
</html>