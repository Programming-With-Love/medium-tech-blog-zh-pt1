<html>
<head>
<title>Handle Android State Changes in Inherited Custom View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在继承的自定义视图中处理Android状态更改</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/handle-android-state-changes-in-inherited-custom-view-60c77a121abf?source=collection_archive---------1-----------------------#2020-08-14">https://medium.com/google-developer-experts/handle-android-state-changes-in-inherited-custom-view-60c77a121abf?source=collection_archive---------1-----------------------#2020-08-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8305" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用非继承和继承的自定义视图</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a2d13c95b21e36d829b6618965825358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OkoBMUL5B0TzZ6uc"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e4c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Android中，有一些我们称之为“状态变化”的行为，它们可能在许多情况下发生。平台是否会终止应用程序，以便为当前活动的应用程序或配置更改回收内存，这些配置更改会使用新配置重新创建运行活动的上下文。为了防止应用程序中的数据发生这些变化，我们必须处理每个活动、片段和视图中的状态。</p><p id="96ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用来自Android框架或第三方库(正确处理状态更改)的现有视图，状态更改将由它自己处理。但是，当您创建自己的视图(称为“自定义视图”)时，您必须在自定义视图中添加额外的代码来处理状态更改。</p><p id="72d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">比如我的<code class="du jt ju jv jw b">PostView</code>里面包含了3个状态(<code class="du jt ju jv jw b">title</code>、<code class="du jt ju jv jw b">description</code>、<code class="du jt ju jv jw b">dividerColorResId</code>)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="56fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了支持状态变化，我必须实现<code class="du jt ju jv jw b">onSaveInstanceState</code>和<code class="du jt ju jv jw b">onRestoreInstanceState</code>，并处理其中的所有状态。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="62a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，处理状态变化，您需要从<code class="du jt ju jv jw b">BaseSavedState</code>扩展而来的<code class="du jt ju jv jw b">SavedState</code>，以便在<code class="du jt ju jv jw b">onSaveInstanceState</code>被调用时将数据转换到Parcelable，并从Parcelable恢复数据。</p><p id="4842" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是当状态直接改变时，Android系统不持有Parcelable。Parcelable将被转换为Parcelable并保存在系统中，并在状态恢复时转换回Parcelable。这就是为什么我们必须声明从<code class="du jt ju jv jw b">Parcelable.Creator</code>创建的<code class="du jt ju jv jw b">CREATOR</code>，以便通过<code class="du jt ju jv jw b">createFromParcel</code>将包裹转换回<code class="du jt ju jv jw b">SavedState</code> (Parcelable)</p><p id="61c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这段代码是在自定义视图中处理状态更改的一个常见示例。</p><p id="9c54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，它与<strong class="ig hi">继承的自定义视图</strong>不兼容。</p><h1 id="4fba" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">继承自定义视图，如何？</h1><p id="00dd" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">取代单一(非继承)自定义视图，将代码分为基类和派生类。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lc"><img src="../Images/9cf883187916c21518f019c992bd7187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiK4jeybTfnqXEw_8R68nw.jpeg"/></div></div></figure><p id="8492" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">BasePostView</code>中的代码将是</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="0f9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">而<code class="du jt ju jv jw b">RegularPostView</code>将会是</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="aeab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个类通过一个定制视图以相同的方式处理状态变化。<code class="du jt ju jv jw b">title</code>和<code class="du jt ju jv jw b">description</code>由<code class="du jt ju jv jw b">BasePostView</code>处理<code class="du jt ju jv jw b">dividerColorResId</code>由<code class="du jt ju jv jw b">RegularPostView</code>处理。</p><p id="4b05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一切似乎都很好，直到应用程序崩溃，同时应用程序进程改变状态。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lc"><img src="../Images/eb578d3d58b22469a049584a61d29385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lfvn6W4_At0RSRe3faV56A.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">BasePostView.SavedState not found in RegularPostView when restoring from state change by the application process</figcaption></figure><h1 id="cbf9" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">这是怎么回事？</h1><p id="1147" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">在继承的自定义视图中，使用<code class="du jt ju jv jw b">BaseSavedState</code>表示<code class="du jt ju jv jw b">SavedState</code>，使用<code class="du jt ju jv jw b">Parcelable.Creator</code>表示<code class="du jt ju jv jw b">CREATOR</code>只有在状态因配置变化而变化时才有效，而不是应用程序进程的状态变化。</p><p id="418d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Android中，当用户长时间将你的应用程序放在后台时，Android系统可能会通过杀死你的应用程序的进程来回收内存。而且能够在用户再次打开你的应用时恢复数据。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="11b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当应用程序进程从状态更改中恢复时，需要使用<code class="du jt ju jv jw b">CREATOR</code>中的类加载器进行宗地到可打包宗地的转换。但是在上面的例子中没有类加载器。所以<code class="du jt ju jv jw b">RegularPostView</code>不能恢复<code class="du jt ju jv jw b">BasePostView</code>中的状态(从<code class="du jt ju jv jw b">super</code>开始)。</p><p id="77f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从应用程序进程的状态更改中恢复，需要<code class="du jt ju jv jw b">CREATOR</code>中的类加载器进行宗地到可打包宗地的转换。但是在上面的例子中没有类加载器。所以<code class="du jt ju jv jw b">RegularPostView</code>无法恢复<code class="du jt ju jv jw b">BasePostView</code>中的状态(来自<code class="du jt ju jv jw b">super</code>)。</p><p id="f3ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要以这种方式测试你的应用，只需将你的应用放入后台，在Android Studio的Logcat中点击<code class="du jt ju jv jw b">Terminates selected Android Application</code>，然后再次重新打开你的应用。</p><p id="41ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在谈如何解决这个问题之前。我们来谈谈…</p><h1 id="5b87" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">为什么我使用继承的自定义视图而不是一个单独的自定义视图？</h1><p id="972a" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">根据前面的示例代码，您可能会说“只需将所有代码保存在一个类中，因为它是自定义视图，仅此而已”。</p><p id="8750" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用继承的定制视图的原因是定制进度条的<a class="ae js" href="https://github.com/akexorcist/RoundCornerProgressBar" rel="noopener ugc nofollow" target="_blank"> RoundCornerProgressBar库</a>。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lc"><img src="../Images/8052bb3f3d5b1a1350417c8d73ba8268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MEYiGrZaUgG_2_JFLon-A.jpeg"/></div></div></figure><p id="a1eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个库中，我创建了6种具有共同逻辑的进度条。所以使用继承的自定义视图更适合将来维护它。(可重复使用+可维护=👍👍👍)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lc"><img src="../Images/a2a32197acb07cd27a6fedbcc9ce38fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2ozugXjlFgGtf8HQs1jSA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">How I designed the class structure in RoundCornerProgressBar library</figcaption></figure><p id="de6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有的类都有自己的状态要处理。所以<code class="du jt ju jv jw b">BaseSavedState</code>和<code class="du jt ju jv jw b">Parcelable.Creator</code>不再为我的库工作了。</p><p id="b3ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，让我们回到前面的代码。</p><h1 id="ccbd" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">要在继承的自定义视图中解决这个问题</h1><p id="c850" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated"><strong class="ig hi">首先是</strong>，将<code class="du jt ju jv jw b">BaseSavedState</code>替换为<code class="du jt ju jv jw b">AbsSavedState</code>(这允许您确保保存层次结构中所有类的状态)到自定义视图的层次结构中的所有类。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="677a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">AbsSavedState</code>还有一个支持类加载器的<code class="du jt ju jv jw b">constructor(source: Parcel, loader: ClassLoader?)</code>。为了向后兼容，必须是来自<code class="du jt ju jv jw b">androidx.customview.view.AbsSavedState</code>的<code class="du jt ju jv jw b">AbsSavedState</code>,因为<code class="du jt ju jv jw b">android.view.AbsSavedState</code>的构造函数在API级别24或更高的版本中可用。</p><p id="5f21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">androidx.customview.view.AbsSavedState</code>在Android Jetpack库的CustomView库中，也包含在AppCompat库中。</p><p id="cee5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二个</strong>，用<code class="du jt ju jv jw b">Parcelable.ClassLoader</code>替换<code class="du jt ju jv jw b">Parcelable.Creator</code>(允许创建者接收创建对象的类加载器)到自定义视图的层次结构中的所有类。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="9a64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，再次测试自定义视图在每个状态下的变化行为。终于成功了！🎉🎉🎉</p><h1 id="7036" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="c26e" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">使用<code class="du jt ju jv jw b">AbsSavedState</code>和<code class="du jt ju jv jw b">Parcelable.ClassLoaderCreator</code>来处理继承的自定义视图中的状态变化，这允许我们保存/恢复层次结构中所有类的状态。</p><p id="01e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使是单个定制视图，如果你的项目包含两个定制视图，在它们中使用<code class="du jt ju jv jw b">AbsSavedState</code>和<code class="du jt ju jv jw b">Parcelable.ClassLoaderCreator</code>比在非继承和继承之间分离代码风格要好。</p><p id="e86f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">您的项目中没有继承的自定义视图？不要担心。<code class="du jt ju jv jw b">BaseSavedState</code>和<code class="du jt ju jv jw b">Parcelable.Creator</code>仍然适用于您的自定义视图，无需替换。</strong></p><p id="a3d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后是本文的示例代码。请参见下面的链接</p><div class="ld le ez fb lf lg"><a href="https://github.com/akexorcist/HandleStateChangesInCustomView" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hi fi z dy ll ea eb lm ed ef hg bi translated">akexorcist/HandleStateChangesInCustomView</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">在自定义视图和继承的自定义视图中处理Android状态更改—akexorcist/HandleStateChangesInCustomView</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">github.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jm lg"/></div></div></a></div><h1 id="d88b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><ul class=""><li id="efb5" class="lv lw hh ig b ih kx il ky ip lx it ly ix lz jb ma mb mc md bi translated"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/customview/view/AbsSavedState" rel="noopener ugc nofollow" target="_blank">ABS saved state—Android Jetpack中的CustomView库【API引用】</a></li><li id="c782" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">可包装的。ClassLoaderCreator [API引用] </li></ul></div></div>    
</body>
</html>