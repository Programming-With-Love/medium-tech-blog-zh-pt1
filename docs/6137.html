<html>
<head>
<title>Upgrading Pinterest to HBase 1.2 from 0.94</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Pinterest从0.94升级到HBase 1.2</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/upgrading-pinterest-to-hbase-1-2-from-0-94-e6e34c157783?source=collection_archive---------4-----------------------#2017-06-12">https://medium.com/pinterest-engineering/upgrading-pinterest-to-hbase-1-2-from-0-94-e6e34c157783?source=collection_archive---------4-----------------------#2017-06-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8d5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">张天英| Pinterest技术主管，存储和缓存</p><p id="4f03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HBase是Pinterest几项关键服务的支柱。它以10M+ QPS的速度提供超过10pb的数据。大部分流量来自要求低延迟的实时在线请求，因此集群的高性能和高可用性至关重要。为了充分利用HBase并确保Pinners的最佳体验，我们将分支机构从0.94.26升级到1.2版。然而，我们发现升级过程至少需要几个小时。由于我们无法在每次升级HBase集群时关闭Pinterest，因此我们构建了一个系统来支持零宕机的升级和回滚。</p><h2 id="4c56" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">历史</h2><p id="f78a" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在升级之前，我们运行的是基于HBase 0.94.26的私有分支，但该版本已于2015年初正式弃用。HBase 1.2拥有超过0.94.26的5，000个已完成的JIRA案例，其中包括重要的错误修复和新功能，可提高健壮性、可扩展性、性能、MTTR(平均恢复时间)等。如果我们升级到1.2版，我们将实现重大的长期利益。</p><p id="cbd2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，不支持从0.94.x版升级到0.96.x或更高版本，因为有许多不兼容的更改，包括API和wire格式。这意味着0.94.x集群必须完全关闭，如果启用了复制，则包括从属集群，并且由于不兼容的API更改，客户端必须同时关闭和升级。整个过程需要几个小时甚至更长时间。如果需要回滚，集群和客户端将不得不再次完全关闭，因此我们构建了一个支持升级和回滚且不停机的系统。</p><h2 id="ab07" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">设计</h2><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/f88117e67ac28ed555edd1b09004d570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/0*BbKKs3nYYbc06IkL."/></div></figure><p id="0334" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终目标是在升级时，客户端只需从连接到0.94集群切换到1.2集群，并且事先做好所有准备。到0.94的连接被启用为只读。一旦验证数据在0.94和1.2之间完全同步，客户端将被指示通过配置更改动态连接到1.2。整个过程对于读写集群的服务应该是透明的。回滚应遵循相同的过程，但方向相反，将客户端连接从1.2集群切换回0.94集群。</p><p id="47d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这需要0.94和1.2集群之间的双向异构复制，其中源数据以接收器可以识别的格式编码，并解码为其版本的本机格式。这允许数据在两个集群之间实时同步。接下来，双客户端会自动检测所连接集群的版本，并相应地以该版本固有的格式对请求进行编码，对响应进行解码。</p><h2 id="fd75" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">分身术</h2><p id="9278" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">我们采用了来自雅虎的基于节约的复制补丁。以及Flurry，它添加了将特定主从对之间的复制协议设置为Thrift的选项。然后，使用基于节约的复制RPC来代替0.94和更高版本之间不兼容的本机复制RPC。原来的补丁是针对0.94.26和0.98.10的。我们做了一些改变，使它在我们的私有1.2分支中工作。</p><p id="0f7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">验证复制集群之间的数据正确性是非常重要的。我们构建了一个工具(称为checkr ),它扫描主集群中的每一行，验证从集群中是否存在匹配的行，检查两行中所有具有相同数据的单元，反之亦然。如果在验证期间没有对群集的写入，该过程非常简单，否则数据可能会有所不同，因为HBase复制是异步的。一个典型的情况是，由于复制延迟，当checkr读取主服务器中的数据时，主服务器中的数据更改可能不会应用到从服务器。因此，checkr从主服务器获得最新的数据副本，但从服务器获得过期的副本。为了解决这个问题，checkr将只比较其数据最近没有被修改的HBase单元，例如在最后N秒内，其中N是可配置的。我们在不同的时间点运行了几次checkr。如果在所有运行中没有发现数据不一致，复制延迟少于N秒，并且每N秒钟没有单元被更新，我们确信通过复制集群之间的数据是一致的。</p><h2 id="3101" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">客户</h2><p id="819e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated"><a class="ae kc" href="http://opentsdb.github.io/asynchbase/" rel="noopener ugc nofollow" target="_blank">async base</a>是一个完全异步的高性能hbase客户端。最重要的是，它兼容HBase从0.92到0.94和0.96到1.0的版本。我们一直在使用Asyncbase，并用内部API和其他变化保持一个私有分支。它经过全面测试，以验证:</p><ul class=""><li id="7ded" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated">它适用于0.94和1.2集群，包括我们的私有特性，如批量获取、小型扫描等。</li><li id="e78c" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">在0.94和1.2之间切换后端没有问题</li><li id="23a7" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">没有性能下降。</li></ul><p id="6b9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，Asynchbase不是HTable client的简单插件。除了API上的差异，每个调用的异步本质意味着要么在收到响应时附加一个回调来处理它，要么只是等待它。</p><h2 id="8c37" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">性能调整</h2><p id="f595" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">HBase性能，尤其是低延迟，对Pinterest来说非常重要，因为我们为多个关键服务的实时在线请求提供服务。我们必须确保1.2集群的性能至少与0.94一样好。理想情况下，0.94集群和它的测试1.2集群拥有相同的数据并接收相同的请求，这样我们就可以比较它们应用于apple的性能。</p><p id="5b76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们设置了一个黑暗的写/读环境，其中应用程序向test 1.2集群发送相同的请求，但不处理响应就立即返回(此外还向0.94生产集群发送请求并处理响应)。我们从最大的集群开始测试，包括数据大小和QPS。假设是，如果我们没有看到性能下降，其他较小的集群也不会有问题。</p><p id="6628" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了降低延迟，我们投入了大量时间来调整垃圾收集(GC)。在我们的环境中，CMS仍然比G1有更好的延迟。下面是运行在AWS I2 . 2x大型实例上的区域服务器的相关JVM选项列表。</p><pre class="ke kf kg kh fd kz la lb lc aw ld bi"><span id="1dad" class="jc jd hh la b fi le lf l lg lh"><strong class="la hi">-Xms20480m</strong></span><span id="3d55" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-Xmx20480m</strong></span><span id="5a19" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+PerfDisableSharedMem</strong></span><span id="2539" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+UseParNewGC</strong></span><span id="87c5" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+UseConcMarkSweepGC</strong></span><span id="6b6b" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+UseCompressedOops</strong></span><span id="398a" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+CMSParallelRemarkEnabled</strong></span><span id="4d98" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+UseCMSInitiatingOccupancyOnly</strong></span><span id="a4cc" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+PreserveFramePointer</strong></span><span id="868c" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:NewSize=512m</strong></span><span id="772b" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:MaxNewSize=512m</strong></span><span id="a256" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:ParGCCardsPerStrideChunk=32768</strong></span><span id="d50a" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:CMSInitiatingOccupancyFraction=70</strong></span><span id="bd4c" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:ParallelGCThreads=4</strong></span><span id="984a" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:PretenureSizeThreshold=2097088</strong></span><span id="dd29" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+ParallelRefProcEnabled</strong></span><span id="ceb5" class="jc jd hh la b fi li lf l lg lh"><strong class="la hi">-XX:+AlwaysPreTouch</strong></span></pre><p id="4f60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HBase的特性和配置也得到了尝试和调整。例如，默认情况下启用的存储桶缓存会导致更差的读取延迟，因为1.x中的存储桶缓存涉及额外的拷贝和内存垃圾。我们不得不禁用它，并且无法在I 2.2x大型实例中充分利用60GB内存(但它仍然给了我们比0.94更好的读取延迟)。我们目前正在考虑从2.0 中反向移植<a class="ae kc" href="https://blogs.apache.org/hbase/entry/offheap-read-path-in-production" rel="noopener ugc nofollow" target="_blank">堆外读取路径，这可能会显著改善读取延迟。</a></p><p id="e0ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起初，我们在1.2中看到了更好的写入延迟。在两个新的繁重使用情形添加到群集后，写入QPS显著增加，1.2中的写入延迟变得比0.94更差。经过一些调试后，我们发现延迟增加来自WAL sync。sync代码被重构为1.x。我们发现它不能很好地进行批处理，这导致了更频繁的WAL sync操作。我们将<code class="du lj lk ll la b">hbase.regionserver.hlog.syncer.count</code>的值从五(默认)降低到一。这增加了批量大小，减少了WAL同步操作，并提供了比0.94更好的写入延迟。</p><h2 id="31a9" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">监控和工具</h2><p id="4d1e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">HBase 1.2引入了许多新指标。0.94中的一些指标在1.2中被重命名，因此为1.2构建了一个新的监控仪表板和警报系统。所有集群升级后，以前的0.94系统将逐步淘汰。</p><p id="48dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管理API在0.94.26和1.2之间经历了巨大的变化。我们的内部工具，包括区域平衡和部分压缩，也升级到了1.2版本。0.94.26和1.2之间的文件结构还有其他变化。数据备份和恢复工具必须进行相应的升级和全面的测试。</p><h2 id="8c7e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">结果</h2><p id="ae55" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">升级按计划进行，客户端被指向1.2集群，就像故障转移一样。对于构建在HBase之上的服务来说，它是完全透明的。我们测量了服务API的延迟，性能提升非常大，提高了124–800%。最终，1.2集群比0.94集群更健壮，操作问题更少。</p><p id="657f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lm">鸣谢:非常感谢Jeremy Carrol和Liang在这个项目中的工作，以及提供的宝贵的性能调整建议。</em></p></div></div>    
</body>
</html>