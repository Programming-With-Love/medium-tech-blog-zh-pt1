<html>
<head>
<title>Keeping API Errors Clean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持API错误整洁</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/keeping-api-errors-clean-8f265ec3e1bc?source=collection_archive---------6-----------------------#2018-06-25">https://medium.com/square-corner-blog/keeping-api-errors-clean-8f265ec3e1bc?source=collection_archive---------6-----------------------#2018-06-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7ffde420e5c9f6cf6efec7791b78b132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjIrJlRGsa4ObRiCxNuxyQ.png"/></div></div></figure><blockquote class="ip iq ir"><p id="d22a" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="8e93" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在Caviar，我们制造了大量的原料药。我们为我们内部的服务到服务通信构建API，为我们的移动应用构建API，为我们的web应用构建API，为外部合作伙伴构建API，可能还有几个我都忘记了的API。在过去的几年中，我们学到并付诸实践的一件事是结构良好的错误，这使我们能够在客户端对有意义的错误保持一致的行为。</p><p id="81b9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们从按照模式将错误定义为结构化散列的惯例开始</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="6c6c" class="ke kf hh ka b fi kg kh l ki kj">{ "type": "SomeError", "message": "Something went wrong!" }</span></pre><p id="647b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">然后，我们会在Rails控制器中以JSON的形式呈现这些错误。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="863f" class="ke kf hh ka b fi kg kh l ki kj"><strong class="ka hi">class</strong> <strong class="ka hi">CartsController</strong> &lt; ApplicationController<br/>  <strong class="ka hi">def</strong> <strong class="ka hi">show</strong><br/>    errors, cart = CartRepository.new.fetch_cart(params.<strong class="ka hi">require</strong>(:id))<br/>    <strong class="ka hi">if</strong> errors.none?<br/>      render json: { content: cart }<br/>    <strong class="ka hi">else</strong><br/>      render json: { errors: errors }, status: 422<br/>    <strong class="ka hi">end</strong><br/>  <strong class="ka hi">end</strong><br/><strong class="ka hi">end</strong></span></pre><p id="498f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">虽然这种结构很好，但我们应用它时不一致，经常只是返回一个字符串数组作为错误，而不是这些结构化的错误。因此，为了提高采用率并让错误感觉良好，我们开始使用Ruby 2.5新的keyword_init参数将这些对象定义为结构。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="fd3c" class="ke kf hh ka b fi kg kh l ki kj">ValidationError = Struct.new(:type, :message, keyword_init: <strong class="ka hi">true</strong>)</span></pre><p id="9ace" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">然后，我们将使用这个新的结构内联，使错误的创建和读取变得干净。需要注意的一件重要事情是，activesupport/json gem使json结构的序列化完全按照您的期望执行，因此它将输出上面的结构。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="fc3f" class="ke kf hh ka b fi kg kh l ki kj"><strong class="ka hi">def</strong> <strong class="ka hi">fetch_cart</strong>(id)<br/>  cart = Cart.find_by(id: id)<br/>  <strong class="ka hi">return</strong> [[ValidationError.new(type: 'ResourceNotFound', message: 'Cart not found')], <strong class="ka hi">nil</strong>] <strong class="ka hi">if</strong> cart.<strong class="ka hi">nil</strong>?<br/>  [[], cart]<br/><strong class="ka hi">end</strong></span></pre><p id="d0fc" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如你所见，这会使错误定义行变得很长，这些错误总是相同的，所以我们可以将它们提取为常量。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="32e5" class="ke kf hh ka b fi kg kh l ki kj">CART_NOT_FOUND_ERROR = ValidationError.new(type: 'ResourceNotFound', message: 'Cart not found')</span><span id="7954" class="ke kf hh ka b fi kk kh l ki kj"><strong class="ka hi">def</strong> <strong class="ka hi">fetch_cart</strong>(id)<br/>  cart = Cart.find_by(id: id)<br/>  <strong class="ka hi">return</strong> [[CART_NOT_FOUND_ERROR], <strong class="ka hi">nil</strong>] <strong class="ka hi">if</strong> cart.<strong class="ka hi">nil</strong>?<br/>  [<strong class="ka hi">nil</strong>, cart]<br/><strong class="ka hi">end</strong></span></pre><p id="a098" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在我们的错误结构良好，易于定义，而且——额外收获！—超级容易测试。下面是这种情况的一个说明:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="3a1e" class="ke kf hh ka b fi kg kh l ki kj">RSpec.define CartsController <strong class="ka hi">do</strong><br/>  it 'should return resource not found error when id does not exist' <strong class="ka hi">do</strong><br/>    get :show, id: -1<br/>    expected_value = {<br/>      errors: [CartRepository::CART_NOT_FOUND_ERROR]<br/>    }<br/>    expect(response.body).to eq(expected_value.to_json)<br/>  <strong class="ka hi">end</strong><br/><strong class="ka hi">end</strong></span></pre><p id="b722" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在，我们可以快速编写这些测试，而不用在消息体上浪费时间。它使我们的测试不那么脆弱，并提高了开发人员的生产率，同时强制执行标准化的错误格式。</p><p id="970d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">到目前为止，我们采取的最后一步是将其提取到一个实用程序中，并添加一些额外的功能。这个宝石叫做<a class="ae jr" href="https://www.github.com/square/clean_errors" rel="noopener ugc nofollow" target="_blank"> clean_errors </a>，我们今天公开发布它。这是它的样子:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="67a8" class="ke kf hh ka b fi kg kh l ki kj"># No need to define ValidationError anymore, its in the gem<br/># ValidationError = Struct.new(:type, :message, keyword_init: true)<br/>CART_NOT_FOUND_ERROR = CleanErrors::ValidationError('ResourceNotFound')</span></pre><p id="82f0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">你会立刻注意到一些事情。没有关键词论证，没有<code class="du kl km kn ka b">.new</code>(我是不是打错字了？！)，而且没有留言！</p><p id="dd43" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">首先，在缺乏. new的情况下，我们使用了一种<a class="ae jr" href="http://www.virtuouscode.com/2012/05/07/a-ruby-conversion-idiom/" rel="noopener ugc nofollow" target="_blank">转换方法</a>来缩短你的使用时间，去掉一些样板文件。更少的代码意味着更少的错误，转换函数让我们做了另一件漂亮的事情。</p><p id="0a1a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">没有消息！有，但是转换方法现在将使用i18n本地化来查找消息。我们这样做是因为:</p><ol class=""><li id="a1f6" class="ko kp hh iv b iw ix ja jb js kq jt kr ju ks jq kt ku kv kw bi translated">在我们的源代码中有很多字符串感觉是错误的，而且</li><li id="ce50" class="ko kp hh iv b iw kx ja ky js kz jt la ju lb jq kt ku kv kw bi translated">我们希望为国际观众提供经得起未来考验的服务。</li></ol><p id="2078" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对这样的字符串使用i18n通常是一个好的实践，但是错误消息是我们疏忽的地方。现在我们强制执行。但是，关键是什么呢？这是一个简单的“<code class="du kl km kn ka b">errors.#{type}”</code>”，其“错误”名称空间是可配置的。</p><p id="fed5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">最后，我们缩短了关键字参数。通常我喜欢像Ruby这样的动态语言中关键字参数冗长、明确的特性，但是在这种情况下，我们要简洁一些。在整个代码库中对这些的一致使用应该作为它自己的文档，API是如此的干净，我认为牺牲一点安全性是值得的。</p><p id="78a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">就是这样！我们在Caviar使用clean_errors作为一个简单的工具来产生巨大的影响。我们的API中一致的错误格式意味着客户可以预期特定格式的错误，这些实用程序使开发人员更容易产生那些一致的错误。</p></div></div>    
</body>
</html>