<html>
<head>
<title>Selenium Waits Tutorial — Everything You Need to Know About Waits in Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Selenium等待教程——关于Selenium中的等待，您需要了解的一切</h1>
<blockquote>原文：<a href="https://medium.com/edureka/waits-in-selenium-5b57b56f5e5a?source=collection_archive---------0-----------------------#2019-02-08">https://medium.com/edureka/waits-in-selenium-5b57b56f5e5a?source=collection_archive---------0-----------------------#2019-02-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/2cc1a20a8906c85f6f1f090f21a14f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*xoXbv9D1JWnHlvXNkzDSxQ.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Waits in Selenium — Edureka</figcaption></figure><p id="0f77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在编写第一个selenium程序时，您可能遇到过wait命令。但是，你知道硒等待到底是什么吗？嗯，selenium中的等待是执行测试用例所需的一段重要代码。在本文中，我将简要介绍实践中广泛使用的不同类型的等待命令。</p><p id="1a7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是本文将要涉及的主题:</p><ul class=""><li id="20dd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">什么是硒等？</li><li id="6ecc" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">为什么我们在Selenium中需要等待？</li><li id="654a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">等待类型</strong></li></ul><ol class=""><li id="c213" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">隐式等待</li><li id="a1fb" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">显式等待</li></ol><ul class=""><li id="c09a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">隐式与显式等待</li></ul><h1 id="aed9" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是硒等？</h1><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/09139fe95cab54fdb4c954311a228d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*j3hS5SzLet7G_zLql2i-1A.png"/></div></figure><p id="64fc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">等待帮助用户在重定向到不同的网页时解决问题。这是通过刷新整个网页并重新加载新的web元素来实现的。有时，也可能有Ajax调用。因此，在重新加载网页和反映网页元素时，可以看到时间延迟。</p><p id="2a34" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用户经常被发现来回浏览各种网页。因此，由web驱动程序提供的navigate()命令/方法通过参考web浏览器的历史在网页之间导航来帮助用户模拟实时场景。</p><h1 id="e656" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么在Selenium中需要等待？</h1><p id="247e" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">大多数web应用程序都是使用Ajax和JavaScript开发的。当浏览器加载页面时，我们想要与之交互的元素可能会在不同的时间间隔加载。这样，不仅识别元素变得困难，而且如果元素没有被定位，它将抛出一个“<strong class="ir hi">ElementNotVisibleException</strong>异常。通过使用等待，我们可以解决这个问题。</p><p id="163e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们进一步了解不同类型的等待。</p><h1 id="cfcd" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">等待的类型</h1><p id="fa52" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">Selenium支持两种类型的等待，如下所示</p><ol class=""><li id="ddcd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">隐式等待</li><li id="e345" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">显式等待</li></ol><p id="4de8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong> <em class="lk">最广泛使用的等待是隐式和显式等待，流畅等待对于实时项目并不可取。</em></p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/3a0cc6463420cd0180efff8a1895c220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jBlI8d7AWcqo9IYskG64g.png"/></div></div></figure><p id="f715" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，让我们了解一下Selenium中有哪些隐式等待。</p><h2 id="303e" class="lq kd hh bd ke lr ls lt ki lu lv lw km ja lx ly kq je lz ma ku ji mb mc ky md bi translated">隐式等待</h2><p id="5c59" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">隐式等待将告诉web驱动程序在抛出“没有这样的元素异常”之前等待一段时间。隐式等待的默认设置为零。一旦设置了时间，web驱动程序将在抛出异常之前等待特定的时间。</p><pre class="lb lc ld le fd me mf mg mh aw mi bi"><span id="e963" class="lq kd hh mf b fi mj mk l ml mm"><strong class="mf hi"><em class="lk">Syntax:</em></strong> driver.manage().timeouts().implicitlyWait(TimeOut, TimeUnit.SECONDS);</span></pre><p id="7d2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们以隐式等待为例，了解它是如何工作的。</p><pre class="lb lc ld le fd me mf mg mh aw mi bi"><span id="9d79" class="lq kd hh mf b fi mj mk l ml mm">package Edureka;<br/>import java.util.concurrent.TimeUnit;<br/>import org.openqa.selenium.By;<br/>import org.openqa.selenium.WebDriver;<br/>import org.openqa.selenium.WebElement;<br/>import org.openqa.selenium.chrome.ChromeDriver;<br/>import org.openqa.selenium.support.ui.ExpectedConditions;<br/>import org.openqa.selenium.support.ui.WebDriverWait;<br/> <br/>public class ImplicitWait{<br/>public static void main(String[] args) throws InterruptedException{<br/>System.setProperty("webdriver.chrome.driver", "C:\\Selenium-java-edureka\\chromedriver_win32\\chromedriver.exe");<br/>WebDriver driver = new ChromeDriver();<br/>driver.manage().window().maximize();<br/>driver.manage().deleteAllCookies();<br/>driver.manage().timeouts().pageLoadTimeout(40, TimeUnit.SECONDS); // pageload timeout<br/>driver.manage().timeouts().implicitlyWait(20, TimeUnit.SECONDS);    // Implicit Wait for 20 seconds<br/>driver.get("<a class="ae mn" href="https://login.yahoo.com/" rel="noopener ugc nofollow" target="_blank">https://login.yahoo.com/</a>");<br/>driver.findElement(By.xpath("//input[<a class="ae mn" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>='login-username']")).sendKeys("<a class="ae mn" href="mailto:edureka@yahoo.com" rel="noopener ugc nofollow" target="_blank">edureka@yahoo.com</a>"); //Finding element and sending values<br/>Thread.sleep(1000);<br/>driver.findElement(By.xpath("//input[<a class="ae mn" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>='login-signin']")).click(); //Clicking on the next button if element is located<br/>}<br/>}</span></pre><p id="c444" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码中，我将隐式等待时间设为20秒，这意味着特定元素加载或到达输出的最大等待时间是20秒。</p><p id="a7c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong> <em class="lk">隐式等待是全局应用的，这意味着它始终可用于整个驱动程序实例中的所有web元素。这意味着如果驱动程序与100个元素交互，那么隐式等待适用于所有100个元素。</em></p><p id="1022" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这都是关于隐式等待的。现在深入研究等待，理解什么是显式等待。</p><h2 id="0bf0" class="lq kd hh bd ke lr ls lt ki lu lv lw km ja lx ly kq je lz ma ku ji mb mc ky md bi translated">显式等待</h2><p id="dc61" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">这是动态等待特定条件的动态等待的概念。可以通过<strong class="ir hi"> <em class="lk"> WebDriverWait </em> </strong>类实现。要理解Selenium Webdriver中的显式等待，您应该知道我们为什么在程序中使用等待语句的要求。我将给出几个例子，在这些例子中，您将完全理解为什么等待在selenium中很重要。</p><p id="f1d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lk">在selenium web驱动中显式等待的条件</em> </strong></p><p id="00e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">这个页面是动态的，这意味着有时需要10秒来加载主页，有时需要15秒，以此类推。在这种情况下，显式等待有助于我们一直等到特定页面不存在。</strong></p><p id="807b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lk">条件2 — </em> </strong>您正在处理一个旅行申请，您已经填写了一个web表单，并点击了提交按钮。现在你要等到具体数据没有显示出来。在这种情况下，您可以再次使用显式等待，在这种情况下，您可以让<em class="lk">等待</em>，直到不显示特定的或一组元素。</p><pre class="lb lc ld le fd me mf mg mh aw mi bi"><span id="a602" class="lq kd hh mf b fi mj mk l ml mm"><strong class="mf hi"><em class="lk">Syntax:</em></strong> WebDriverWait wait=new WebDriverWait(WebDriveReference,TimeOut);</span></pre><p id="405c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的语法中，我创建了一个WebDriver wait的对象，并将驱动程序引用和超时作为参数传递。这就是您需要编写显式等待的方式。现在让我们举一个例子来理解显式等待是如何工作的。让我们看看下面的代码。</p><pre class="lb lc ld le fd me mf mg mh aw mi bi"><span id="4972" class="lq kd hh mf b fi mj mk l ml mm">package Edureka;<br/>import java.util.concurrent.TimeUnit;<br/>import org.openqa.selenium.By;<br/>import org.openqa.selenium.WebDriver;<br/>import org.openqa.selenium.WebElement;<br/>import org.openqa.selenium.chrome.ChromeDriver;<br/>import org.openqa.selenium.support.ui.ExpectedConditions;<br/>import org.openqa.selenium.support.ui.WebDriverWait;<br/> <br/>public class Locators {<br/>public static void main(String[] args) throws InterruptedException {<br/>System.setProperty("webdriver.chrome.driver", "C:\\Selenium-java-edureka\\chromedriver_win32\\chromedriver.exe");<br/>WebDriver driver = new ChromeDriver();<br/>driver.manage().window().maximize();<br/>driver.manage().deleteAllCookies();<br/>driver.manage().timeouts().pageLoadTimeout(40, TimeUnit.SECONDS);<br/>driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);<br/>driver.get("<a class="ae mn" href="https://www.facebook.com/" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/</a>");<br/>WebElement firstname= driver.findElement(By.name("firstname"));<br/>WebElement lastname= driver.findElement(By.name("lastname"));<br/>sendKeys(driver, firstname, 10, "Edureka");<br/>sendKeys(driver, lastname, 20, "Edureka");<br/>WebElement forgotAccount= driver.findElement(By.linkText("Forgotten account?"));<br/>clickOn(driver,forgotAccount, 10);<br/>driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);<br/>}<br/>public static void sendKeys(WebDriver driver1, WebElement element, int timeout, String value){<br/>new WebDriverWait(driver1, timeout).until(ExpectedConditions.visibilityOf(element));<br/>element.sendKeys(value);<br/>}<br/>public static void clickOn(WebDriver driver1, WebElement element, int timeout){<br/>new WebDriverWait(driver1, timeout).until(ExpectedConditions.elementToBeClickable(element));<br/>element.click();<br/>}<br/>}</span></pre><p id="007f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，我使用了facebook注册凭证，并使用名称定位器定位它们。此外，我还创建了一个实用程序或一个通用函数，所有元素都可以使用它来提供显式等待。在上面的例子中，我编写了自己的<em class="lk"> sendKeys() </em>方法。该方法将在特定的文本字段中输入值，但是在内部它也将显式地提供wait。在<em class="lk"> sendKeys() </em>方法中，我已经给出了元素可见性的预期条件。也就是说，我要求驾驶员等待20秒，直到该元件的预期条件可见。此外，如果条件得到满足，那么您可以将<em class="lk"> sendKeys() </em>应用于该方法。现在，假设我想输入我的名和姓。我要做的是，我将使用这个<em class="lk"> sendKeys() </em>方法，并将驱动程序、名字、超时(即10秒)和值作为edureka传递。姓氏也是如此。</p><p id="2e4a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你执行该程序时，chrome驱动程序将启动谷歌Chrome浏览器，在facebook.com导航，并输入代码中提到的值。不强制显式设置等待特定值的超时，基于您的需求，您可以更改它。这是使用显式等待的主要优势，但对于隐式等待，一旦你定义了10秒，它将适用于网页上的所有元素，并且不能修改。<em class="lk"> clickOn() </em>方法也是如此。但是，这种方法只对网页上的链接有用。<strong class="ir hi"> </strong>这就是你如何使用显式等待。</p><p id="2584" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注:</strong> <em class="lk">含蓄、外显、流畅的内侍，都是动态内侍。</em> <strong class="ir hi"> <em class="lk">什么是动态等待？</em> </strong> <em class="lk">考虑一个你给定超时值为20秒的情况。如果元素在5秒内被加载，那么剩余的15秒将被忽略。它不会等到超时值完成，即20秒。这就是为什么所有的等待都被认为是动态等待。</em></p><p id="a88e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们进一步区分隐式和显式等待。</p><h1 id="6516" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">隐式与显式等待</h1><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mo"><img src="../Images/6c58f182c3f20c7ee4e68795d7795a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUFeACcxdQFKCAAqPz5aqg.png"/></div></div></figure><p id="ffa2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望您理解隐式和显式等待的区别。这就把我们带到了关于Selenium中的等待的文章的结尾。</p><p id="cfd1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae mn" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=waits-in-selenium" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释硒的各个方面。</p><blockquote class="mp mq mr"><p id="0461" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">1.<a class="ae mn" rel="noopener" href="/edureka/selenium-tutorial-77879a1d9af1">硒教程</a></p><p id="b3c0" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">2.<a class="ae mn" rel="noopener" href="/edureka/selenium-webdriver-tutorial-e3e6219f21ad">Selenium web driver:TestNG For Test Case Management&amp;报告生成</a></p><p id="5a10" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">3.<a class="ae mn" rel="noopener" href="/edureka/selenium-framework-data-keyword-hybrid-frameworks-ea8d4f4ce99f">构建数据驱动、关键字驱动的&amp;混合Selenium框架</a></p><p id="e36e" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">4.<a class="ae mn" rel="noopener" href="/edureka/locators-in-selenium-f6e6b282aed8">硒中的定位器</a></p><p id="07c4" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">5.<a class="ae mn" rel="noopener" href="/edureka/xpath-in-selenium-cd659373e01a"> XPath教程</a></p><p id="c455" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">6.<a class="ae mn" rel="noopener" href="/edureka/selenium-grid-tutorial-ef342799c484">为分布式硒测试设置硒网格</a></p><p id="a14b" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">7.<a class="ae mn" rel="noopener" href="/edureka/selenium-using-python-edc22a44f819">硒使用Python </a></p><p id="3c91" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">8.<a class="ae mn" rel="noopener" href="/edureka/cross-browser-testing-9299b04ce277">使用LambdaTest进行跨浏览器测试</a></p><p id="81e4" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">9.<a class="ae mn" rel="noopener" href="/edureka/cross-browser-testing-using-selenium-90b1911c6d60">使用Selenium进行跨浏览器测试</a></p><p id="587a" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">10.<a class="ae mn" rel="noopener" href="/edureka/handle-multiple-windows-in-selenium-727ba5f8f6a7">在Selenium中处理多个窗口</a></p><p id="d832" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">11.<a class="ae mn" rel="noopener" href="/edureka/page-object-model-in-selenium-bc4d7c8c4203">硒中页面对象模型</a></p><p id="4dfd" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">12.<a class="ae mn" rel="noopener" href="/edureka/selenium-projects-b2df15d35fe2">硒项目</a></p><p id="d88a" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">13.<a class="ae mn" rel="noopener" href="/edureka/qtp-vs-selenium-338f3d3bbfa7"> QTP vs硒</a></p><p id="7324" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">14.<a class="ae mn" rel="noopener" href="/edureka/selenium-vs-rpa-84159dbcd0f2">硒vs RPA </a></p><p id="66e7" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">15.<a class="ae mn" rel="noopener" href="/edureka/selenium-webdriver-architecture-565e2db26dd5"> Selenium WebDriver架构</a></p><p id="ce70" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">16.<a class="ae mn" rel="noopener" href="/edureka/exceptions-in-selenium-369c38155e7d">在Selenium中处理异常</a></p><p id="88d8" class="ip iq lk ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">17.<a class="ae mn" rel="noopener" href="/edureka/cucumber-selenium-tutorial-aefec05f4733">使用黄瓜&amp;硒</a>进行网站测试</p></blockquote></div><div class="ab cl mv mw go mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ha hb hc hd he"><p id="b4e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lk">原载于2019年2月8日www.edureka.co</em><em class="lk">T21</em><a class="ae mn" href="https://www.edureka.co/blog/waits-in-selenium/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>