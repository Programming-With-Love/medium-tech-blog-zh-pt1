<html>
<head>
<title>React Components — Props and States in ReactJS with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件React组件中的属性和状态以及示例</h1>
<blockquote>原文：<a href="https://medium.com/edureka/react-components-65dc1d753af5?source=collection_archive---------1-----------------------#2017-09-03">https://medium.com/edureka/react-components-65dc1d753af5?source=collection_archive---------1-----------------------#2017-09-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/2cdd6d2a1fc2afbf5c001fbf3f559034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9hGQnm-g0X1KQpaQiGgykQ.png"/></div><figcaption class="il im et er es in io bd b be z dx">React Components — Edureka</figcaption></figure><blockquote class="ip"><p id="9846" class="iq ir hh bd is it iu iv iw ix iy iz dx translated">“在React中，一切都是组件”</p></blockquote><p id="fac3" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw iz ha bi translated">如果你熟悉React，那么你一定听过或读过这个短语很多次。但是你知道它到底是什么意思，怎么用的吗？如果你不知道，那么阅读这篇博客，了解React组件及其生命周期中的不同阶段。我相信当你读完这篇博客时，你会对React组件及其相关概念有一个完整的理解。但在继续之前，请快速浏览一下我将讨论的主题:</p><ul class=""><li id="b9b8" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz ke kf kg kh bi translated">什么是React组件？</li><li id="2636" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz ke kf kg kh bi translated">React组件的优势</li><li id="f779" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz ke kf kg kh bi translated">小道具</li><li id="023d" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz ke kf kg kh bi translated">州</li><li id="259e" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz ke kf kg kh bi translated">状态vs道具</li><li id="f841" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz ke kf kg kh bi translated">反应组件生命周期</li></ul><h1 id="9669" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">什么是React组件？</h1><p id="1382" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">早期，开发人员必须编写1000行代码来开发一个简单的单页应用程序。这些应用程序中的大多数都遵循传统的DOM结构，对它们进行更改对开发人员来说是非常具有挑战性和乏味的任务。他们必须手动搜索需要更改的元素，并相应地更新它。即使是一个小错误也会导致应用程序失败。此外，更新DOM非常昂贵。因此，引入了基于组件的方法。在这种方法中，整个应用程序被分成称为组件的逻辑块。React是选择这种方法的框架之一。</p><p id="1c2d" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">现在让我们了解一下这些组件是什么。</p><p id="85e5" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">React组件被视为用户界面的构建块。这些组件中的每一个都存在于相同的空间中，但是彼此独立地执行。React组件有自己的结构、方法和API。它们是可重用的，可以根据需要注入到接口中。为了更好地理解，可以将整个UI看作一棵树。在这里，起始组件成为根，每个独立的部分成为分支，分支又被进一步划分为子分支。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lt"><img src="../Images/b345501babdd2702fc42ea4ce1c68a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn28hd7gB_r96qwfJoycpQ.png"/></div></div></figure><p id="f600" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">这使我们的UI保持有序，并允许数据和状态变化从根逻辑地流向分支，然后流向子分支。组件直接从客户端调用服务器，这允许DOM在不刷新页面的情况下动态更新。这是因为react组件是基于AJAX请求的概念构建的。每个组件都有自己的接口，可以调用服务器并更新它们。由于这些组件彼此独立，每个组件都可以刷新，而不会影响其他组件或整个UI。</p><p id="cd67" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">我们使用<strong class="jc hi"> React.createClass() </strong>方法创建一个组件。必须向该方法传递一个将定义React组件的对象参数。每个组件必须恰好包含一个<strong class="jc hi"> render() </strong>方法。它是负责在JavaScript，JSX中解析HTML的组件的最重要的属性。这个<strong class="jc hi"> render() </strong>将组件的HTML表示作为一个DOM节点返回。因此，所有的HTML标签必须包含在<strong class="jc hi"> render() </strong>内部的封闭标签中。</p><p id="8ce1" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">下面是创建组件的示例代码。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="d101" class="mh ko hh md b fi mi mj l mk ml">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/> <br/>class MyComponent extends React.Component{<br/>    render(){<br/>        return(       <br/>              &lt;div&gt;           <br/>                &lt;h1&gt;Hello&lt;/h1&gt;<br/>                &lt;h1&gt;This is a Component&lt;/h1&gt;<br/>              &lt;/div&gt;<br/>        );<br/>    }<br/>}<br/>ReactDOM.render(<br/>    &lt;MyComponent/&gt;, document.getElementById('content')<br/>);</span></pre><h1 id="04d7" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">React组件的优点</strong></h1><ol class=""><li id="e17d" class="jx jy hh jc b jd ll jh lm jl mm jp mn jt mo iz mp kf kg kh bi translated"><strong class="jc hi">代码可重用性</strong> —基于组件的方法使您的应用程序开发更加简单快捷。如果你想在你的代码中使用一个预先存在的功能，你可以把它放在你的代码中，而不是从头开始构建。它还允许您的应用程序架构随着时间的推移保持最新，因为您可以更新需要升级的特定区域。</li><li id="0bb3" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi">快速开发</strong> —基于组件的UI方法导致迭代和敏捷的应用程序开发。这些组件托管在一个库中，不同的软件开发团队可以在整个开发过程中访问、集成和修改它们。</li><li id="f3af" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi">一致性</strong> —实现这些可重用的组件有助于保持设计的一致性，并且可以在整个应用程序中清晰地组织代码。</li><li id="69a5" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi">可维护性</strong> —具有一组组织良好的组件的应用程序可以快速更新，您可以确信哪些区域会受到影响，哪些不会。</li><li id="711a" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi">可伸缩性</strong> —有了一个组织良好的现成组件库，开发变得更加容易。确保组件有正确的命名空间有助于避免样式和功能随着项目的扩大而泄漏或重叠到错误的位置。</li><li id="3825" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi">容易集成</strong> —组件代码存储在像GitHub这样的库中，并对公众开放使用。应用程序开发团队精通使用源代码库，因此他们能够根据需要提取代码并将其注入到应用程序中。</li></ol><p id="9110" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">既然您已经理解了什么是组件以及它的优点是什么，现在让我们看看如何向这些组件提供数据。</p><p id="d2d2" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">组件接收数据有两种方式:</p><ol class=""><li id="ca21" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated">小道具</li><li id="9dd4" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated">州</li></ol><h1 id="00ab" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">小道具</h1><p id="45e4" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">道具代表属性。它们是只读组件，工作方式类似于HTML属性。Prop是一种将数据从父组件传递到子组件的方法。我们用一个例子来理解这个。</p><p id="652a" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">正如我们已经知道的，react组件以树的形式排列UI，其中父组件成为根，子组件成为分支和子分支。现在假设父组件想要发送数据到它的一个嵌套很深的组件。假设您需要从组件1向组件6发送一个属性。你会怎么做？</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/4cd564b3dfc8c23dbf27501024563ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*9zKBY7mXWvbs_xE_7rUk5Q.png"/></div></figure><p id="45cc" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">您不能将属性直接传递给目标组件。这是因为React遵循这样一条规则，即属性必须从父组件向下流到一个<em class="mr">直接</em>子组件。这意味着在发送属性时不能跳过子组件层，子组件也不能将属性发送回父组件。如果父组件没有传递属性，您可以使用默认属性，以便它们仍然被设置。这就是React具有单向数据绑定的原因。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/0562fdfd8636b7945cd18f2f37c6d8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*5_uIRmagwIeRdnJpagxDzw.png"/></div></figure><p id="85d7" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">因此，在这种情况下，我们需要一层一层地发送数据，直到它到达目标子组件。该路径中的每个组件都必须从其父组件接收属性，然后将该属性重新发送给其子组件。这个过程重复进行，直到您的属性到达其目标组件。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/aae2e4d1bead0ed5813b97a9624a1fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*LfPBlJ4EHp0TW2QTET2CWw.png"/></div></figure><p id="eaff" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">下面是一个传递道具的例子。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="684f" class="mh ko hh md b fi mi mj l mk ml">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/> <br/>class MyComponent extends React.Component{<br/>        render(){<br/>        return(   <br/>              &lt;div&gt;<br/>               &lt;h1&gt;Hello&lt;/h1&gt;<br/>               &lt;Header name="maxx" id="101"/&gt;<br/>           &lt;/div&gt;<br/>        );<br/>    }<br/>}<br/> <br/>function Header(props) {<br/>    return (              <br/>           &lt;div&gt;<br/>            &lt;Footer name = {props.name} id = {props.id}/&gt;<br/>           &lt;/div&gt;<br/>    );<br/>}<br/>function Footer(props) {<br/>    return (             <br/>           &lt;div&gt;             <br/>            &lt;h1&gt; Welcome : {props.name}&lt;/h1&gt;             <br/>            &lt;h1&gt; Id is : {props.id}&lt;/h1&gt;<br/>           &lt;/div&gt;<br/>  );<br/>}<br/>ReactDOM.render(<br/>   &lt;MyComponent/&gt;, document.getElementById('content')<br/>);</span></pre><p id="c6a4" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">由于属性只能从父组件传递，因此不能更改。这使它们变得不可改变和愚蠢。这带来了巨大的挑战，因为现代应用程序在页面加载时并没有准备好所有的状态。Ajax或事件可能在数据返回时发生，因此需要有人负责处理更新。这就是反应状态发挥作用的地方。</p><h1 id="0df3" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">州</h1><p id="247a" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">一般是组件取道具，渲染。这些被称为无状态组件。但是它们也可以提供用于存储关于组件的数据或信息的状态，这些数据或信息可以随时间而改变。这样的组件被称为有状态组件。状态的改变可以作为对用户事件或系统事件的响应而发生。换句话说，<strong class="jc hi">状态</strong>是每个react组件的核心，它决定了组件的行为和呈现方式。他们还负责使组件具有动态性和交互性。因此，它们必须尽可能简单。</p><p id="218d" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">可以通过<strong class="jc hi"> this </strong>引用来访问状态，例如<strong class="jc hi"> this.state </strong>。您可以使用花括号<strong class="jc hi"> {} </strong>在JSX中访问和打印变量。同样，你可以在<strong class="jc hi"> render() </strong>里面渲染<strong class="jc hi"> this.state </strong>。您必须为组件设置默认状态，否则它将设置为空。</p><p id="2d86" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">现在让我们看看一个<strong class="jc hi">状态</strong>是如何分配给一个组件的。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="dd55" class="mh ko hh md b fi mi mj l mk ml">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/> <br/>class MyComponent extends React.Component {<br/>    constructor() {<br/>        super();<br/>        this.state = {<br/>            name: 'Maxx',<br/>            id: '101'<br/>        }<br/>    }<br/>    render()<br/>        {<br/>            setTimeout(()=&gt;;{this.setState({name:'Jaeha', id:'222'})},2000)<br/>            return (             <br/>                   &lt;div&gt;                     <br/>                     &lt;h1&gt;Hello {this.state.name}&lt;/h1&gt;<br/>                     &lt;h2&gt;Your Id is {this.state.id}&lt;/h2&gt;<br/>                   &lt;/div&gt;<br/>             );<br/>        }<br/>    }<br/>ReactDOM.render(<br/>    &lt;MyComponent/&gt;, document.getElementById('content')<br/>);</span></pre><h1 id="a125" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">状态vs道具</h1><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mt"><img src="../Images/fd4cffc3a4489562aa78f0fae33f20a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwGqTmS5NTFBJGuQg9_k3A.png"/></div></div></figure><h1 id="e598" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">反应组件生命周期</h1><p id="6f5d" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">React提供了各种方法来通知组件生命周期中的某个阶段何时发生。这些方法被称为生命周期方法。这些生命周期方法并不复杂。您可以将这些方法视为在组件生命周期的不同时间点调用的专用事件处理程序。您甚至可以向这些方法添加自己的代码来执行各种任务。谈到组件的生命周期，生命周期分为4个阶段。它们是:</p><ol class=""><li id="3c94" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated">初始相位</li><li id="9534" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated">更新阶段</li><li id="8318" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated">道具变化阶段</li><li id="e6aa" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated">卸载阶段</li></ol><p id="17d4" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">每个阶段都包含一些特定于它们的生命周期方法。现在让我们来看看每个阶段都发生了什么。</p><h2 id="2c26" class="mh ko hh bd kp mu mv mw kt mx my mz kx jl na nb lb jp nc nd lf jt ne nf lj ng bi translated"><strong class="ak">初始阶段</strong></h2><p id="a65e" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">React组件生命周期的第一个阶段是初始阶段或初始呈现阶段。在这个阶段，组件将开始它的旅程，并向DOM前进。这个阶段由以下方法组成，这些方法按预定义的顺序调用。</p><ol class=""><li id="0754" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">getDefaultProps():</em></strong>该方法用于指定<strong class="jc hi"> this.props </strong>的默认值。它甚至在你的组件被创建或者父组件的任何属性被传递给它之前就被调用了。</li><li id="5b2e" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"> getInitialState(): </strong>该方法用于在创建组件之前指定<strong class="jc hi"> this.state </strong>的默认值。</li><li id="242d" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentWillMount():</em></strong><em class="mr"/>这是组件呈现到DOM之前可以调用的最后一个方法。但是如果你在这个方法中调用<strong class="jc hi"> setState() </strong>，你的组件将不会重新呈现。</li><li id="0b1c" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"> <em class="mr"> render(): </em> </strong>该方法负责返回单个根HTML节点，必须在每个组件中定义。如果不想渲染任何东西，可以返回<strong class="jc hi"> null </strong>或<strong class="jc hi"> false </strong>。</li><li id="fe06" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentDidMount():</em></strong>一旦组件被渲染并放置在DOM上，就调用这个方法。在这里，您可以执行任何DOM查询操作。</li></ol><h2 id="4ee0" class="mh ko hh bd kp mu mv mw kt mx my mz kx jl na nb lb jp nc nd lf jt ne nf lj ng bi translated"><strong class="ak">更新阶段</strong></h2><p id="d39e" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">一旦组件被添加到DOM中，只有当状态发生变化时，它们才能更新和重新呈现。每当状态改变时，组件再次调用它的<strong class="jc hi"> render() </strong>。任何依赖于该组件输出的组件也会再次调用其<strong class="jc hi"> render() </strong>。这样做是为了确保我们的组件显示自己的最新版本。因此，为了成功地更新组件状态，按照给定的顺序调用以下方法:</p><ol class=""><li id="53d9" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">【shouldcomponentdupdate():</em></strong>使用这个方法你可以控制你的组件更新自身的行为。如果从此方法返回true，组件将会更新。否则，如果该方法返回false，组件将跳过更新。</li><li id="7317" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentWillUpdate():</em></strong>这个方法在组件即将更新之前被称为<strong class="jc hi"> </strong>。在这个方法中，你不能通过调用<strong class="jc hi"> this.setState </strong>来改变你的组件状态。</li><li id="238e" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"> <em class="mr"> render(): </em> </strong>如果您通过<strong class="jc hi">shouldComponentUpdate()</strong>返回false，那么<strong class="jc hi"> render() </strong>内部的代码将被再次调用，以确保您的组件正确显示自身。</li><li id="7aa5" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentDidUpdate():</em></strong>一旦组件被更新和渲染，那么这个方法就被调用。您可以将任何代码放入该方法中，以便在组件更新后执行。</li></ol><h2 id="425b" class="mh ko hh bd kp mu mv mw kt mx my mz kx jl na nb lb jp nc nd lf jt ne nf lj ng bi translated"><strong class="ak">道具变化阶段</strong></h2><p id="25bb" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">在组件被呈现到DOM中之后，除了状态改变之外，组件唯一更新的时间是它的属性值改变的时候。实际上，这一阶段的工作与前一阶段类似，但是它处理的不是状态，而是道具。因此，这个阶段只有一个来自更新阶段的附加方法。</p><ol class=""><li id="6bb2" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentWillReceiveProps():</em></strong>该方法返回一个参数，该参数包含将要分配给组件的新属性值。其余的生命周期方法的行为与我们在上一阶段看到的方法相同。</li><li id="1e08" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">【shouldcomponentdupdate()】</em></strong></li><li id="9e05" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentWillUpdate()</em></strong></li><li id="4bbc" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"> <em class="mr">渲染()</em> </strong></li><li id="86fa" class="jx jy hh jc b jd ki jh kj jl kk jp kl jt km iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentDidUpdate()</em></strong></li></ol><h2 id="76bd" class="mh ko hh bd kp mu mv mw kt mx my mz kx jl na nb lb jp nc nd lf jt ne nf lj ng bi translated"><strong class="ak">卸载阶段</strong></h2><p id="c135" class="pw-post-body-paragraph ja jb hh jc b jd ll jf jg jh lm jj jk jl ln jn jo jp lo jr js jt lp jv jw iz ha bi translated">这是组件生命周期的最后一个阶段，在这个阶段，组件被销毁并从DOM中完全删除。它只包含一种方法:</p><ol class=""><li id="d351" class="jx jy hh jc b jd jz jh ka jl kb jp kc jt kd iz mp kf kg kh bi translated"><strong class="jc hi"><em class="mr">componentWillUnmount():</em></strong>一旦这个方法被调用，你的组件就从DOM中永久删除了。在这个方法中，<strong class="jc hi"> <em class="mr"> </em> </strong>你可以执行任何清理相关的任务，比如删除事件监听器，停止定时器等等。</li></ol><p id="0dcc" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">以下是整个生命周期图:</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es nh"><img src="../Images/bdaabc2fcfdab2fcc8cf53291599551d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mvki4TLBL85f093_68aRGA.png"/></div></div></figure><p id="f47f" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">这就把我们带到了React组件博客的结尾。我希望在这篇文章中，我能够清楚地解释什么是React组件，它们是如何使用的。</p><p id="8140" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated">请留意本系列中的其他文章，它们将解释Web开发的各个方面。</p><blockquote class="nj nk nl"><p id="93c3" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">1.<a class="ae ni" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> ReactJS教程</a></p><p id="44b2" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">2.<a class="ae ni" rel="noopener" href="/edureka/react-router-2aab4e781736"> React路由器v4教程</a></p><p id="8ba8" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">3.<a class="ae ni" rel="noopener" href="/edureka/react-redux-tutorial-2b3d81cfd3f7"> React Redux教程</a></p><p id="10ff" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">4.<a class="ae ni" rel="noopener" href="/edureka/html-vs-html5-83302f95652e"> HTML vs HTML5 </a></p><p id="53f1" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">5.<a class="ae ni" rel="noopener" href="/edureka/what-is-rest-api-d26ea9000ee6">什么是REST API？</a></p><p id="7b35" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">6.<a class="ae ni" rel="noopener" href="/edureka/flutter-vs-react-native-58133fbf9f33">颤振vs反作用自然</a></p><p id="359c" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">7.<a class="ae ni" rel="noopener" href="/edureka/front-end-developer-skills-ebb32d19f488">前端开发者技能</a></p><p id="dd97" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">8.<a class="ae ni" rel="noopener" href="/edureka/front-end-developer-resume-c3d443f98296">前端开发人员简历</a></p><p id="c6a6" class="ja jb mr jc b jd jz jf jg jh ka jj jk nm lq jn jo nn lr jr js no ls jv jw iz ha bi translated">9.<a class="ae ni" rel="noopener" href="/edureka/web-development-projects-b01f0fe85d3f">网络开发项目</a></p></blockquote></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><p id="b7e1" class="pw-post-body-paragraph ja jb hh jc b jd jz jf jg jh ka jj jk jl lq jn jo jp lr jr js jt ls jv jw iz ha bi translated"><em class="mr">原载于2017年9月3日www.edureka.co</em><em class="mr">的</em> <a class="ae ni" href="https://www.edureka.co/blog/react-components/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">。</em></a></p></div></div>    
</body>
</html>