<html>
<head>
<title>Efficient Resource Management at Pinterest’s Batch Processing Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pinterest批处理平台的高效资源管理</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/efficient-resource-management-at-pinterests-batch-processing-platform-61512ad98a95?source=collection_archive---------0-----------------------#2021-10-14">https://medium.com/pinterest-engineering/efficient-resource-management-at-pinterests-batch-processing-platform-61512ad98a95?source=collection_archive---------0-----------------------#2021-10-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6e00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">张永军|软件工程师；张昂|工程经理；王绍文|软件工程师，批处理平台团队</p><p id="4083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本文于2021年12月3日更新。</em></p><p id="5e8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest的批处理平台monitor运行着该公司的大部分批处理工作流。在表1所示的规模下，重要的是管理平台资源以提供<a class="ae jd" href="https://en.wikipedia.org/wiki/Quality_of_service" rel="noopener ugc nofollow" target="_blank">服务质量</a> (QoS)，同时实现成本效益。本文将分享我们如何做到这一点以及未来的工作。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ad6758a64e345e161fc2be052397c0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvYk3tgC5UxUA62I1JNy6g.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Table 1: Scale of Monarch Batch Processing Platform</figcaption></figure><h1 id="667c" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">君主简介</h1><p id="00cc" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">图1从高层次上展示了Pinterest的数据系统。当用户在他们的移动或桌面设备上使用Pinterest应用程序时，他们会生成各种日志，并通过<a class="ae jd" href="https://github.com/pinterest/singer" rel="noopener ugc nofollow" target="_blank"> Singer </a> + Kafka(参见<a class="ae jd" rel="noopener" href="/pinterest-engineering/scalable-and-reliable-data-ingestion-at-pinterest-b921c2ee8754">Pinterest</a>的可伸缩且可靠的数据摄取)将这些日志摄取到我们的系统中，并将结果数据存储到S3。然后，通过各种工作流(如清理、分析和机器学习数据准备)对数据进行处理和分析。工作流的结果通常会存储回S3。基本上有两种类型的处理平台:批处理和流。这个博客是关于名为monitor的批处理平台的。更多关于流媒体平台的信息，请参见本<a class="ae jd" rel="noopener" href="/pinterest-engineering/unified-flink-source-at-pinterest-streaming-data-processing-c9d4e89f2ed6">博客</a>。</p><p id="96dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为内部大数据平台，monitor提供基础设施、服务和工具，帮助用户大规模开发、构建、部署批处理应用程序并进行故障诊断(主要以工作流的形式)。monitor由20多个完全利用<a class="ae jd" href="https://aws.amazon.com/ec2/?ec2-whats-new.sort-by=item.additionalFields.postDateTime&amp;ec2-whats-new.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS EC2 </a>构建在云中的<a class="ae jd" href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html" rel="noopener ugc nofollow" target="_blank"> Hadoop纱线</a>集群组成，我们使用EC2提供的许多不同的实例类型。我们在集群中使用的实际EC2实例类型取决于其工作负载；一些群集在计算方面更优化，而另一些群集则有更多的内存或磁盘容量。</p><p id="0436" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用户工作流可以通过作业提交服务(Job Submission Service，或JSS)从Spinner(基于Airflow构建的内部工作流平台)和其他基于UI的工作流编排工具提交给Monarch(参见图2)。用户工作流源代码通常指定工作流应该在其中运行的集群和队列。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/a6cf296f52f0549e084d0236b6325421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*waukQlIKfPnZt12d"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 1. Pinterest Data System and the Batch Processing Platform (Monarch).</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/28d58cd9f20357f051c947576f40b44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dJNd2PKEYH4JSTy8"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 2. Pinterest Job Submission Service. See more description in the text.</figcaption></figure><h1 id="691b" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">资源管理挑战</h1><p id="72ea" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">Hadoop YARN用于管理集群资源和任务调度。集群资源表示为队列树。集群的所有资源，或者集群拥有的所有EC2实例，被表示为树的“根”,树的叶节点是应用程序运行的地方。队列的权重配置决定了分配给它的资源量。同一父节点的子节点共享分配给父节点的资源。子节点获得多少资源取决于该子节点的权重与所有同级节点的权重之和的比值。通过设置节点权重，我们可以控制分配给任何给定队列的EC2实例的数量。YARN支持多个调度器，Monarch中使用的是公平调度器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/d80c85b14a9b65d663accf8468f91cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EE9-KDT4UMwB3b_U"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 3. YARN’s resource allocation: Tree of Queues of Ad hoc Structure.</figcaption></figure><p id="e132" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用队列树来表示资源分配的目的是实现在不同队列中运行的工作流之间的资源隔离。然而，Monarch最初没有一致的队列结构，如图3所示。一些队列被分配给特定的项目，一些队列被分配给组织，还有一些队列被分配给特定优先级的工作流。因此，在同一队列中运行的不同工作流之间存在严重的干扰，更关键的工作流通常会受到非关键工作流的影响。</p><p id="68a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">干扰主要有两个原因:</p><ol class=""><li id="36cf" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">在同一队列中运行的工作流被同等对待。由于没有优先级的概念，调度程序无法将更多的资源分配给更关键的工作流。</li><li id="a923" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">有一个参数maxRunningApps来控制在一个给定的队列中可以同时运行多少个应用程序。这防止了太多的应用程序竞争资源，在这种情况下，没有应用程序可以取得良好的进展。但是，如果先提交优先级较低的工作流，并使maxRunningApps达到饱和，那么随后提交的关键工作流可能会在很长一段时间内无法调度。</li></ol><p id="7fab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这些问题，我们引入了工作流分层，并相应地更改了要分层的资源分配队列。</p><h1 id="2495" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">工作流分层和分层队列结构</h1><p id="ef54" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">Monarch上的工作负载通常以工作流的形式出现。工作流被表示为多个作业的有向无环图(<a class="ae jd" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html" rel="noopener ugc nofollow" target="_blank"> DAG </a>)来处理输入数据并生成输出。同一工作流中的作业并行或顺序运行，具体取决于它们之间是否存在依赖关系。我们采取了两个主要步骤来为工作流提供QoS，同时实现成本效益。</p><p id="2b2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们添加了分层来区分关键工作流和非关键工作流。关键工作流通常对完成时间有更高的要求。我们决定将工作流分为三层:第1层、第2层和第3层(第1层的重要性最高)。然后，我们与用户团队合作，定义在Monarch平台上运行的所有工作流的分层和运行时<a class="ae jd" href="https://en.wikipedia.org/wiki/Service-level_objective" rel="noopener ugc nofollow" target="_blank">服务级别目标</a> (SLO)。</p><p id="dd5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其次，我们改变了所有集群的资源队列结构，使其具有分层、项目和组织的概念。假设每个工作流都与一个项目相关联，每个项目都属于一个团队，而每个团队都属于一个更大的组织，我们决定创建一个三级的队列结构:组织、项目和层。参见图4中的示例(出于历史原因，使用“default”代替tier3)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/44a835bd840776b5663f1aab9ae4a33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JHLH2R9spnadhDwV"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 4. Hierarchical Queues with Organization, Project and Tiering.</figcaption></figure><p id="74a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一些最重要的队列配置是:</p><ul class=""><li id="98ba" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb lm le lf lg bi translated">权重:队列的权重决定了分配给它的资源量。同一父节点的子节点基于其权重的相对比率来共享父节点的资源。</li><li id="8da1" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb lm le lf lg bi translated">MaxRunningApps:队列中可以并发运行的应用程序的最大数量。这可以防止在有限资源的同一个队列中运行太多的应用程序，这意味着没有应用程序可以取得很好的进展。</li><li id="ac34" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb lm le lf lg bi translated">抢占:</li></ul><ol class=""><li id="9417" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated"><strong class="ig hi">抢占:</strong>是否启用抢占</li><li id="d2ed" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated"><strong class="ig hi">fairsharepoemptiontimeout</strong>:在尝试抢占容器以从其他队列获取资源之前，队列低于其公平份额阈值的秒数。</li><li id="c580" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated"><strong class="ig hi">fairsharepointionthreshold</strong>:队列的公平份额抢占阈值。如果队列等待fairSharePreemptionTimeout而没有接收到fairsharepoemptionthreshold * fair share资源，则允许抢占容器以从其他队列获取资源。</li><li id="9554" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated"><strong class="ig hi"> allowPreemptionFrom </strong>:决定是否允许调度程序从队列中抢占资源。</li></ol><p id="1ac5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将第1层队列配置为不允许抢占，并将fairSharePreemptionTimeout参数配置为比第2层和第3层队列更小的值，将fairSharePreemptionThreshold参数配置为更大的值。这允许第1层队列在没有获得公平的资源份额时更快地获得资源。</p><p id="8620" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为Monarch有许多集群，并且在不同集群上运行的工作流可能会随时改变，所以手动创建队列结构是不实际的，也是没有效率的。我们开发了一个工具，可以分析集群上工作流的历史数据，生成队列结构，并自动和定期更新设置。</p><p id="1c64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了上面描述的抢占配置之外，两个最重要的配置是队列权重和maxRunningApps。在下一节中，我们将分享关于我们用来生成这些设置的算法的更多细节。</p><h1 id="df1c" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">资源分配算法</h1><p id="793d" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">队列中运行的工作流在不同的时间有不同的要求。为了保证关键工作流的服务质量，我们设计了一种基于历史运行数据的队列权重分配算法，即百分位数算法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/e89891e5d48d8f28235f690bc2d92eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qo0ykrNuJY2Aw8A8"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 5. The Percentile Resource Allocation Algorithm.</figcaption></figure><p id="4484" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该算法查看最近时间窗口(如30天)内的历史运行数据，以了解给定队列需要多少资源。下面是它的功能:</p><ul class=""><li id="51d0" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb lm le lf lg bi translated">步骤1:队列可能在某些时候被使用，而在其他时候可能是空的。使用队列时，有时会使用X个EC2实例，有时会使用Y个EC2实例。该算法将时间窗分成<strong class="ig hi">个时间单位</strong>；每个单元是一个时间跨度，其中使用了<em class="jc">相同</em>数量的EC2实例。时间单位表示为&lt;时间长度，实例化为&gt;。(参见图5的左侧)</li><li id="6b4b" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb lm le lf lg bi translated">第2步:排除队列空闲的时间单元，按照时间单元中使用的实例数量(见图5的右侧)从最小到最大对时间单元进行排序。</li><li id="64d8" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb lm le lf lg bi translated">步骤3:确定分配给队列的最小实例数，以确保满足预先指定的时间长度百分比阈值。这个阈值意味着，给定队列正在使用的总时间单位长度(TTIU ),分配的资源需要足以满足TTIU的百分比。例如，对于在30天的窗口内总共使用了240小时(其他时间空闲)的第1层队列，我们希望保证95%的时间都有资源，因此是228小时。该算法找出在步骤2的排序结果中使用的实例数。例如，tu0 + tu4 + tu7 + tu2大约占整个使用时间长度的95%,那么tu2中使用的实例数就是要分配给该队列的实例数。如果我们要分配tu5中使用的实例数量，它比tu2中使用的多，这可能会造成浪费，因为tu5只占队列总使用时间的5%。</li></ul><p id="5ef5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的95%阈值只是一个例子。我们评估了不同层的资源使用情况，并根据这些工作流使用的群集和资源的大小提出了不同的阈值。当不同层使用的资源百分比发生变化时，阈值也会不时地进行调整。</p><p id="d5ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几个原因使我们不必保证给定的tier1/tier2队列在高峰使用时间所需的100%的资源，从而避免浪费。</p><ol class=""><li id="3682" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">工作流分层大致分布如下:约10%的工作流属于第1层，20–30%属于第2层，60–70%属于第3层。</li><li id="b108" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">并非所有队列同时都很忙，并且纱线调度器允许工作流使用其他队列中的可用资源。</li><li id="c0bc" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">更高层的队列可以更快地抢占资源。</li></ol><p id="9937" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们通过一个称为使用率/容量比的指标来衡量队列的资源余量。队列的容量是分配给队列的实例数乘以测量的时间窗口长度。使用量以纱线为例-小时来衡量。例如，如果队列在Y小时内使用X个实例，则资源使用量为X * Y实例-小时。此外，我们还以类似的方式测量vcore-hours和内存-小时使用率/容量比，以了解vcore和内存资源使用率的平衡程度。请注意，纱报告了vcore-小时和内存-小时，我们在这里使用优势资源(DR)方法来计算实例-小时。</p><p id="ce3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该算法确保从第1层到第3层队列的百分比阈值按降序设置，同时还确保使用率/容量比率按升序设置。这意味着第1层的头房最大，第2层次之，第3层最小。</p><p id="b877" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">资源分配算法还会查看历史运行数据，以确定maxRunningApps设置，并为每个队列设置一些余量的配置。</p><h1 id="b1e3" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">与自动缩放相比</h1><p id="915d" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">自动扩展是另一种在云中节省成本的常见方法，在需要时扩展集群，在高峰需求过去时缩减。因为云提供商通常对按需容量收取比<a class="ae jd" href="https://aws.amazon.com/ec2/pricing/reserved-instances/" rel="noopener ugc nofollow" target="_blank">保留实例</a>高得多的费用，用户通常保留总是需要的容量，并使用按需实例进行自动缩放。</p><p id="df5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动缩放在Pinterest的在线服务中效果很好，但我们发现它在批处理中不太经济，原因如下:</p><ol class=""><li id="8c25" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">来自大规模批处理的任务可能会运行数小时，这两种缩小集群的方案都是浪费。适度地缩减规模并等待正在运行的任务完成(即在终止实例之前清空它们)可能会浪费大量的资源，因为实例可能没有得到充分利用。即使任务仍在实例上运行，通过强制终止实例进行缩减也意味着浪费未完成的计算(以及相关作业更长的运行时间),并且需要额外的资源来重新运行终止的任务。</li><li id="285c" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">为了使使用按需实例的自动扩展在与保留实例相比时具有经济意义，我们估计对于某些实例类型，使用按需实例的集群的峰值消耗时间百分比将需要小于30%。考虑到缩小规模所需的时间，这个比例会小得多。然而，很难控制这个百分比，如果百分比越高，资源就越容易被浪费。</li><li id="1f59" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">在Pinterest的大数据处理规模下，使用自动缩放将需要在高峰时段获取数百个或更多所需实例类型的实例，这并不总是可能的。无法获得足够的资源来运行关键工作流可能会对业务造成重大影响。</li></ol><p id="ae03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过利用上述资源分配算法和工作流分层，我们能够利用良好的保留实例定价，同时仍然保证在需要时为关键工作流提供足够的资源。</p><p id="9192" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，在本博客中，我们关注的是生产工作流，而不是临时工作负载，例如来自<a class="ae jd" rel="noopener" href="/pinterest-engineering/open-sourcing-querybook-pinterests-collaborative-big-data-hub-ba2605558883"> Querybook </a>的Spark SQL查询或来自Jupyter笔记本的PySpark作业。在临时集群中，我们确实利用了带有<a class="ae jd" href="https://aws.amazon.com/ec2/spot/?cards.sort-by=item.additionalFields.startDateTime&amp;cards.sort-order=asc" rel="noopener ugc nofollow" target="_blank"> Spot实例</a>的自动缩放，因为高峰使用在工作日只持续2-3个小时。</p><h1 id="d009" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">工作流性能监控</h1><p id="f2f5" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">为工作流分配资源时，运行时SLO是一个需要考虑的重要因素。例如，如果工作流使用X个实例-小时资源，并且运行时SLO是12小时，那么运行此工作流所需的实例数是X / 12。</p><p id="5537" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着资源分配的生效，我们需要一种方法来监控整个工作流运行时的性能。我们开发了一个仪表板来显示各层工作流在不同集群中的表现。</p><p id="e3a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一定大小的时间窗口内，对于任何给定的工作流，如果它运行X次，并且Y次运行符合SLO，则其SLO成功率被定义为Y/X。对于任何给定的工作流，如果这个比率是100%是理想的，但是由于许多原因，这是不可行的。作为折衷方案，我们将工作流定义为SLO成功，如果其SLO成功率不低于90%。</p><p id="5413" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，我们将工作流分为三个级别。对于每一层的工作流，我们都要衡量在SLO获得成功的工作流的百分比。我们的目标是使这一比例高于90%。</p><p id="ef6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图6是衡量30天时间窗口性能的仪表板快照。在项目之前，tier1工作流的成功率在70%左右。目前，该比例已提高至并稳定在90%左右。虽然我们试图让大多数第1层工作流取得成功，但其他层的相同指标并没有被牺牲太多，因为它们没有那么严格的SLO要求。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/9a734dc21522f051047d290f9dbf1979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OXaQXqZpJwINyzTf"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 6. Workflow performance monitoring: runtime SLO success ratio of each tier.</figcaption></figure><h1 id="6a91" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">群集资源使用情况监控</h1><p id="5ac4" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">工作流要求不是静态的，可能会不时发生变化。根据以下指标为每个群集完成每日报告:</p><ol class=""><li id="13e3" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">总计、第1层、第2层和第3层的使用率/容量比(包括实例、vcore、内存)</li><li id="607c" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">群集中运行的所有第1层、第2层和第3层工作流的数量(可能会有新的工作流加入，或者对现有工作流进行重新分层和SLO更改)</li></ol><p id="47d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据这些指标，我们可以确定群集是被过度利用还是利用不足，并采取措施向群集添加更多资源(自然增长)、缩小群集以节省成本或保持不变。</p><h1 id="7ecf" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">跨集群路由和负载平衡</h1><p id="6b3e" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">如前所述，不同的工作流有不同的资源需求，有些需要更多的内存，有些需要更多的CPU，有些需要更多的磁盘IO或存储。他们的需求可能会随着时间而改变。此外，随着时间的推移，一些群集可能会变满，而另一些群集可能会利用不足。通过监控资源消耗，我们可以为工作流找到比当前更好的主集群。要求用户更改他们的源代码来移动工作流是一个繁琐的过程，因为当我们移动工作流时，我们还必须调整资源分配。</p><p id="4286" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们开发了跨集群路由(CCR)功能，无需用户更改设置即可更改工作流的目标集群。为了实现这一点，我们在JSS组件中添加了工具逻辑，可以根据需要将作业重定向到另一个集群。</p><p id="b376" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还开发了一个工作流来定期分析集群使用情况，并选择候选工作流移动到其他集群，以不断提高负载平衡和成本效率。</p><p id="aa89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要启用重定向作业，我们需要使用上述算法在目标集群上进行资源分配更改。为了实现这一点，我们自动化了资源分配流程，只需单击一个按钮(触发工作流)，即可在一个步骤中完成资源分配和配置作业重定向。</p><h1 id="931f" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">当前和未来的工作</h1><p id="03ba" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">在撰写本文时，我们的指标表明一个相当大的集群的vcore和内存使用不平衡，因此浪费了大量vcore。我们正在努力将这个集群分成两个具有CCR支持的不同实例类型的集群，并将在原始集群上运行的工作流迁移到其中一个集群中。我们希望通过这一改变，我们不仅能够更可靠地运行应用程序，还能节省大量成本。</p><p id="eb9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的集群位于不同的<a class="ae jd" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones" rel="noopener ugc nofollow" target="_blank">可用性区域</a>。当一个区域出现问题时，我们可以利用CCR功能将关键工作流转移到不同区域中的另一个集群。我们正在努力使这一过程更加顺利。</p><p id="062a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还在考虑当目标集群上的当前负载满时，在运行时动态地将作业路由到不同的集群。</p><h1 id="f0c7" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">确认</h1><p id="3d12" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">感谢批处理平台团队的郭恒哲、波格丹一世·皮西卡和桑迪普·库马尔，他们帮助我们进一步改进了实施。感谢Soam Acharya、Jooseong Kim和Hannah Chen推动工作流分层。感谢朱成金、威廉·汤姆、索姆·阿查里亚、王春燕一路上的讨论和支持。感谢工作流团队、我们的平台用户团队的反馈和支持。</p><p id="45e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">要在Pinterest了解更多工程知识，请查看我们的</em> <a class="ae jd" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="jc">工程博客</em> </a> <em class="jc">，并访问我们的</em><a class="ae jd" href="https://www.pinterestlabs.com?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=zhang-et-al-october-14-2021" rel="noopener ugc nofollow" target="_blank"><em class="jc">Pinterest Labs</em></a><em class="jc">网站。要查看和申请空缺职位，请访问我们的</em> <a class="ae jd" href="https://www.pinterestcareers.com?utm_source=medium&amp;utm_medium=blog-article&amp;utm_campaign=zhang-et-al-october-14-2021" rel="noopener ugc nofollow" target="_blank"> <em class="jc">职业</em> </a> <em class="jc">页面。</em></p></div></div>    
</body>
</html>