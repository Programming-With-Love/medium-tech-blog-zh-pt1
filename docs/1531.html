<html>
<head>
<title>Unit Testing Behavior of React Components with Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试驱动开发中React组件的单元测试行为</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/unit-testing-behavior-of-react-components-with-test-driven-development-ae15b03a3689?source=collection_archive---------0-----------------------#2018-03-14">https://medium.com/capital-one-tech/unit-testing-behavior-of-react-components-with-test-driven-development-ae15b03a3689?source=collection_archive---------0-----------------------#2018-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7d3cd2e2ab4a1bce936639127abb9ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iG9LqyUxvWcFVr_v_qWEA.png"/></div></div></figure><p id="0c1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">互联网上充满了如何对纯粹关注表示的组件进行单元测试<a class="ae jn" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>的优秀例子。使用<a class="ae jn" href="https://facebook.github.io/jest/docs/en/snapshot-testing.html" rel="noopener ugc nofollow" target="_blank"> Jest的快照测试</a>很容易做到这一点。但是如何测试利用生命周期方法的React组件呢？维持内部状态？有副作用，比如叫<code class="du jo jp jq jr b">setTimeout()</code>或者<code class="du jo jp jq jr b">setInterval()</code>？</p><p id="325e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">测试不是纯功能性的并且负责<strong class="ir hi">行为</strong>的组件并不困难，但是网上并没有太多描述如何做的资源。本文将展示如何对这些更复杂的React组件进行单元测试。我们将使用测试驱动开发(TDD)方法，首先编写我们的测试。</p><h1 id="7dc1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">示例使用案例</h1><p id="cdcd" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">假设我们有一个装载指示器组件，我们希望在请求数据时显示它。如果数据加载非常快，我们希望避免加载指示器短暂闪烁。我们的产品经理告诉我们，如果用户在数据加载前的那一瞬间什么也看不到，将会提供更流畅的用户体验。因此，我们希望装载指示器组件在实际呈现装载指示器之前等待200毫秒。如果过去的时间少于200毫秒，我们不想渲染任何东西。</p><h1 id="8c09" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">工具</h1><p id="e5ec" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">对于本文，我们将使用<a class="ae jn" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>测试平台。<a class="ae jn" href="http://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>是React的一个JavaScript测试工具，它提供了一种在我们的单元测试中呈现React组件并断言其输出和行为的方法。在React中使用Enzyme时，我们需要一个与我们正在运行的React版本相对应的适配器。在我们的例子中，我们将使用<a class="ae jn" href="https://github.com/airbnb/enzyme/tree/master/packages/enzyme-adapter-react-16" rel="noopener ugc nofollow" target="_blank">酶-接头-反应-16 </a></p><h1 id="99eb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设置</h1><p id="fe8e" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">本文的示例代码可在<a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example" rel="noopener ugc nofollow" target="_blank">本报告</a>中找到。repo中的每个提交都映射到本文中的一个步骤。repo使用的<a class="ae jn" href="https://github.com/facebookincubator/create-react-app/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>已经配备了Jest测试运行程序。您可以复制示例repo并遵循这里的步骤。</p><p id="8a64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的第一步是让一个测试运行并失败。然后我们将实现代码来通过测试。</p><p id="5cab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的项目还没有使用这些包，请使用<a class="ae jn" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank"> npm </a>或<a class="ae jn" href="https://yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>来安装它们。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="c997" class="ld jt hh jr b fi le lf l lg lh">npm install — save-dev jest enzyme enzyme-adapter-react-16</span></pre><p id="dba9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">按照<a class="ae jn" href="https://github.com/airbnb/enzyme/tree/master/packages/enzyme-adapter-react-16#installation" rel="noopener ugc nofollow" target="_blank">这些步骤</a>来配置Enzyme，以便在您的项目中使用相关的React适配器。该步骤在示例repo中的<a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/c58ddd4e96ffe8327c793bafcf39914c72914620" rel="noopener ugc nofollow" target="_blank"> this commit </a>中实现。</p><p id="5e9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在示例repo中以交互监视模式运行测试，您需要安装<a class="ae jn" href="https://facebook.github.io/watchman/" rel="noopener ugc nofollow" target="_blank"> Watchman </a></p><p id="49e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行测试观察器:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="3ca9" class="ld jt hh jr b fi le lf l lg lh">npm test</span></pre><p id="549d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您喜欢在没有监视的情况下手动运行测试，那么Watchman就没有必要了。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="bebb" class="ld jt hh jr b fi le lf l lg lh">CI<strong class="jr hi">=</strong>true npm test</span></pre><p id="71de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还没有添加任何测试，但是create-react-app提供了一个基本的测试。此时，当您运行测试时，您应该会看到类似这样的内容:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="577e" class="ld jt hh jr b fi le lf l lg lh">PASS  src/App.test.js<br/>  ✓ renders without crashing (24ms)</span><span id="a193" class="ld jt hh jr b fi li lf l lg lh">Test Suites: 1 passed, 1 total<br/>Tests:       1 passed, 1 total<br/>Snapshots:   0 total<br/>Time:        0.612s<br/>Ran all test suites.</span></pre><h1 id="31fb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">要求</h1><p id="fd23" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们的组件将接受一个布尔属性:<code class="du jo jp jq jr b">isLoading</code>。</p><p id="9fbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当<code class="du jo jp jq jr b">isLoading</code>为假时，我们将渲染组件的<code class="du jo jp jq jr b">children</code>。</p><p id="045a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当<code class="du jo jp jq jr b">isLoading</code>为真时…</p><ul class=""><li id="bf4b" class="lj lk hh ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">如果已经过了200毫秒，我们将显示文本，表明我们正在“加载”。</li><li id="cd3b" class="lj lk hh ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">如果没有超过200毫秒，我们将不会显示任何内容。</li></ul><h1 id="c1cc" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">实施步骤</h1><p id="a3e7" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">让我们开始我们的TDD循环。</p><h2 id="7e48" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">创建组件和初始失败单元测试</h2><p id="a008" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们的下一步是创建一个文件，导出一个组件和它的单元测试。一旦我们有一个失败的单元测试，我们可以将目标行为添加到我们的组件中，并使它通过。该步骤在示例repo中的<a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/46ff6b4b417d91583dda3f1b0c565ba80732ff17" rel="noopener ugc nofollow" target="_blank"> this commit </a>中实现。</p><p id="c502" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从当<code class="du jo jp jq jr b">isLoading</code>为假时呈现<code class="du jo jp jq jr b">children</code>的简单例子开始。我们将为组件创建一个文件，从一个不呈现任何内容的基于类的组件开始:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b9c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们为单元测试创建一个文件。我们将添加一个测试来验证当<code class="du jo jp jq jr b">isLoading</code>为假时<code class="du jo jp jq jr b">children</code>被渲染。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="cdaf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们不需要关心生命周期方法或孩子时，Enzyme的<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/shallow.html" rel="noopener ugc nofollow" target="_blank">shallow</a>()</code>函数允许我们隔离想要测试的组件，确保孩子不会出现在我们的单元测试中。因为我们想验证组件的子组件是否被渲染，所以我们使用Enzyme的<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/mount.html" rel="noopener ugc nofollow" target="_blank">mount()</a></code>函数在测试运行环境中的DOM中挂载组件，这样我们就可以对它进行断言。</p><p id="5159" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们不想让我们的测试组件安装在测试环境的DOM中，所以我们调用<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/ShallowWrapper/unmount.html" rel="noopener ugc nofollow" target="_blank">unmount()</a></code>来清理我们的断言。</p><p id="d01f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试运行程序现在应该显示一个失败的测试，如下所示:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="3d6b" class="ld jt hh jr b fi le lf l lg lh">PASS  src/components/LoadingIndicator.test.js<br/>FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › when isLoading is false › should render children</span><span id="6137" class="ld jt hh jr b fi li lf l lg lh">expect(received).toEqual(expected)<br/>    <br/>    Expected value to equal:<br/>      "&lt;div&gt;ahoy!&lt;/div&gt;"<br/>    Received:<br/>      null<br/>    <br/>    Difference:<br/>    <br/>      Comparing two different types of values. Expected string but received null.<br/>      <br/>      at Object.it (src/components/LoadingIndicator.test.js:13:30)<br/>          at Promise (&lt;anonymous&gt;)<br/>      at Promise.resolve.then.el (node_modules/p-map/index.js:46:16)<br/>          at &lt;anonymous&gt;</span><span id="29c8" class="ld jt hh jr b fi li lf l lg lh">Test Suites: 1 failed, 1 passed, 2 total<br/>Tests:       1 failed, 1 passed, 2 total<br/>Snapshots:   0 total<br/>Time:        0.556s, estimated 1s<br/>Ran all test suites.</span></pre><p id="6008" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你在你的项目中看到一个看起来不相似的测试失败，确保你已经<a class="ae jn" href="https://github.com/airbnb/enzyme/tree/master/packages/enzyme-adapter-react-16#installation" rel="noopener ugc nofollow" target="_blank">正确配置了酶</a>，并且你的<a class="ae jn" href="http://facebook.github.io/jest/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank"> Jest </a> <code class="du jo jp jq jr b"><a class="ae jn" href="http://facebook.github.io/jest/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank">testEnvironment </a></code> <a class="ae jn" href="http://facebook.github.io/jest/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank">是默认的</a> <code class="du jo jp jq jr b"><a class="ae jn" href="http://facebook.github.io/jest/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank"> jsdom</a></code> <a class="ae jn" href="http://facebook.github.io/jest/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="a97e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">让孩子通过失败的测试</h1><p id="c1fa" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/f673f0527ebd5e228cfb6926cb8b9a22daf5638f" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中的</em> </a> <em class="mm">提交回购。</em></p><p id="da59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让这个测试通过是超级容易的；我们简单地改变我们的渲染方法来返回<code class="du jo jp jq jr b">this.props.children</code>而不是<code class="du jo jp jq jr b">null</code>。根据我们的其他需求，这显然不是正确的实现，但是本着TDD的精神，我们编写最少的代码来通过测试。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="a5b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还将在示例应用程序中向<code class="du jo jp jq jr b">App.js</code>添加代码，这样我们就可以在浏览器中看到我们的组件。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="1011" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jo jp jq jr b">npm start</code>运行示例应用程序——这将在端口3000上运行一个本地web服务器，并打开一个指向它的浏览器窗口。</p><h2 id="3da0" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">增加200毫秒后不显示任何内容的测试</h2><p id="dfa3" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">本步骤在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/dad3332ab55413223977b6eb286f2c6bcb59c608" rel="noopener ugc nofollow" target="_blank"> <em class="mm">本例回购中的</em> </a> <em class="mm">提交中实现。</em></p><p id="8988" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们转到规范中下一个最简单的部分。当<code class="du jo jp jq jr b">isLoading</code>为真时，如果200毫秒还没有过去，我们应该什么也不显示。</p><p id="080a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加以下测试:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="42c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在应该看到测试失败了:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="7645" class="ld jt hh jr b fi le lf l lg lh">FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › when isLoading is true › given 200ms have not yet elapsed › should render nothing</span><span id="d26f" class="ld jt hh jr b fi li lf l lg lh">expect(received).toBe(expected)<br/>    <br/>    Expected value to be (using ===):<br/>      null<br/>    Received:<br/>      "&lt;div&gt;ahoy!&lt;/div&gt;"<br/>    <br/>    Difference:<br/>    <br/>      Comparing two different types of values. Expected null but received string.<br/>      <br/>      at Object.it (src/components/LoadingIndicator.test.js:26:32)<br/>          at Promise (&lt;anonymous&gt;)<br/>      at Promise.resolve.then.el (node_modules/p-map/index.js:46:16)<br/>          at &lt;anonymous&gt;<br/>      at process._tickCallback (internal/process/next_tick.js:188:7)</span><span id="87e1" class="ld jt hh jr b fi li lf l lg lh">PASS  src/App.test.js</span><span id="6226" class="ld jt hh jr b fi li lf l lg lh">Test Suites: 1 failed, 1 passed, 2 total<br/>Tests:       1 failed, 2 passed, 3 total<br/>Snapshots:   0 total<br/>Time:        1.495s<br/>Ran all test suites.</span></pre><h2 id="40d7" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">呈现Null以通过测试</h2><p id="8434" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/15c12daab65202d86d3ffe2e79a2f59fad801534" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中的</em> </a> <em class="mm">提交回购。</em></p><p id="c5cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了通过这个测试，当<code class="du jo jp jq jr b">isLoading</code>为真时，我们返回null。</p><p id="529f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的<code class="du jo jp jq jr b">render()</code>方法现在看起来是这样的:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="0773" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试应该会再次通过。</p><h1 id="5215" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如果isLoading为真并且已经过了200毫秒，增加显示负载指示器的测试</h1><p id="eef7" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/706f34fbf0a10262eea6a5452ccc9fd7dcb63a69" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中的</em> </a> <em class="mm">提交回购中实现的。</em></p><p id="41e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是事情变得更有趣的地方。我们需要跟踪组件内部状态的延迟时间是否已经过去。我们将使用<code class="du jo jp jq jr b">setTimeout()</code>来安排状态更新，以表明我们的延迟时间已经过去。我们需要使用组件生命周期方法来触发何时设置和清除超时。</p><p id="aac0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们需要完整的组件生命周期和环境运行时方法<code class="du jo jp jq jr b">setTimeout()</code>和<code class="du jo jp jq jr b">clearTimeout()</code>，我们将使用Enzyme的<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/mount.html" rel="noopener ugc nofollow" target="_blank">mount()</a> </code>函数，就像我们到目前为止所做的那样。我们不想在测试中实际等待200毫秒，所以我们将使用Jest的<a class="ae jn" href="https://facebook.github.io/jest/docs/en/timer-mocks.html" rel="noopener ugc nofollow" target="_blank">定时器模拟</a>来模拟<code class="du jo jp jq jr b">setTimeout()</code>和<code class="du jo jp jq jr b">clearTimeout()</code>。</p><p id="08e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加以下测试:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="9965" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意Jest的<a class="ae jn" href="https://facebook.github.io/jest/docs/en/timer-mocks.html" rel="noopener ugc nofollow" target="_blank">定时器模拟</a>方法的用法。</p><ul class=""><li id="f650" class="lj lk hh ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">我们调用<code class="du jo jp jq jr b"> jest.useFakeTimers()</code>来告诉Jest模拟时间函数。</li><li id="2bc6" class="lj lk hh ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">我们称<code class="du jo jp jq jr b">jest.runAllTimers()</code>为<code class="du jo jp jq jr b">setTimeout()</code>期过去后的快进时间。</li></ul><p id="9daf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的简化示例中，我们的加载指示器标记很简单:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="fe08" class="ld jt hh jr b fi le lf l lg lh">&lt;div&gt;loading…&lt;/div&gt;</span></pre><p id="bbf3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在应该看到这个测试失败了:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="b841" class="ld jt hh jr b fi le lf l lg lh">FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › when isLoading is true › given 200ms have elapsed › should render loading indicator</span><span id="6be8" class="ld jt hh jr b fi li lf l lg lh">expect(received).toBe(expected)<br/>    <br/>    Expected value to be (using ===):<br/>      &lt;div&gt;loading...&lt;/div&gt;<br/>    Received:<br/>      null<br/>    <br/>    Difference:<br/>    <br/>      Comparing two different types of values. Expected object but received null.</span></pre><h1 id="1d7f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">实现调度状态更新以使测试通过</h1><p id="5903" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">本步骤在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/8a75ba599a6145735de4f5a8a4ca5046124c7956" rel="noopener ugc nofollow" target="_blank"> <em class="mm">本例回购中的</em> </a> <em class="mm">提交中实现。</em></p><p id="ba7c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用类属性向组件添加默认状态。当组件第一次挂载时，我们没有超过延迟时间，所以默认值为false。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="528f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加一个<code class="du jo jp jq jr b"> componentDidMount()</code>生命周期方法，这样我们就可以在组件挂载时安排状态更新。200毫秒的延迟时间过去后，我们更新状态以表明<code class="du jo jp jq jr b"> isPastDelay</code>为真。我们保留由<code class="du jo jp jq jr b">this._delayTimer</code>中的<code class="du jo jp jq jr b">setTimeout()</code>返回的值，以便我们稍后能够清除超时。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="7701" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还需要用逻辑更新我们的<code class="du jo jp jq jr b">render()</code>方法，以便:</p><ul class=""><li id="f39f" class="lj lk hh ir b is it iw ix ja ll je lm ji ln jm lo lp lq lr bi translated">仅当我们没有超过延迟时间时才显示任何内容。</li><li id="d2b8" class="lj lk hh ir b is ls iw lt ja lu je lv ji lw jm lo lp lq lr bi translated">如果我们过了延迟期，显示装载指示器。</li></ul><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="15ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完整的组件类如下所示，我们的测试都再次通过。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="027d" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">添加测试以验证延迟时间</h2><p id="f780" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/f689a897b8778a78bddcf059f34d3d71ba5306b7" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中实现了</em> </a> <em class="mm">的提交回购。</em></p><p id="ff4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们目前的实施中，我们不能确保我们有正确的延迟时间。为了说明这一点，如果我们将超时值改为100，我们的测试仍然通过。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="3702" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用<a class="ae jn" href="https://facebook.github.io/jest/docs/en/mock-function-api.html#content" rel="noopener ugc nofollow" target="_blank"> Jest的模拟函数</a>来确保用正确的值调用<code class="du jo jp jq jr b">setTimeout()</code>。让我们更新我们的测试，添加关于通过<code class="du jo jp jq jr b">setTimeout.mock.calls</code>调用<code class="du jo jp jq jr b">setTimeout()</code>的断言。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="6729" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试现在应该失败了。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="0a00" class="ld jt hh jr b fi le lf l lg lh">FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › when isLoading is true › given 200ms have elapsed › should render loading indicator</span><span id="f385" class="ld jt hh jr b fi li lf l lg lh">expect(received).toEqual(expected)<br/>    <br/>    Expected value to equal:<br/>      200<br/>    Received:<br/>      100</span></pre><h1 id="0247" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">修正延迟时间以使测试通过</h1><p id="2de6" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">此步骤在示例repo中的</em><a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/3b44540a5af5c86a6501f80da98fbac0ee866178" rel="noopener ugc nofollow" target="_blank"><em class="mm">This commit</em></a><em class="mm">中实现。</em></p><p id="fd39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，将超时时间更新回200会使我们的测试通过。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="88cd" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">添加测试以确保我们正在清除超时</h1><p id="795a" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">本步骤在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/47dfd911483716f64e17de006970f383fb19b9ff" rel="noopener ugc nofollow" target="_blank"> <em class="mm">本例回购中的</em> </a> <em class="mm">提交中实现。</em></p><p id="bd4a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的组件现在实现了我们定义的所有功能需求。有了<code class="du jo jp jq jr b">setTimeout()</code>，一旦定时器超时，我们的处理函数以及它关闭的所有东西都将被垃圾收集。如果我们的组件使用了<code class="du jo jp jq jr b">setInterval()</code>，那么在我们清除超时之前，处理函数及其闭包不会被垃圾收集。在这种情况下，如果我们不自己清理，就会导致内存泄漏。虽然这在我们的例子中并不是绝对必要的，但是确保我们清理我们设置的任何计时器是一个很好的实践。</p><p id="580a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们添加一个测试来确保我们正在清除超时:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="8327" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试现在应该失败了:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="9e54" class="ld jt hh jr b fi le lf l lg lh">FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › on unmount › should clear timeout</span><span id="e10b" class="ld jt hh jr b fi li lf l lg lh">expect(received).toEqual(expected)<br/>    <br/>    Expected value to equal:<br/>      1<br/>    Received:<br/>      0</span></pre><h1 id="7cef" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">清除超时以使测试通过</h1><p id="967d" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/da278c6d6b6958e27df25d14c5823379c269214d" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中实现了</em> </a> <em class="mm">的提交回购。</em></p><p id="c679" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们添加一个<code class="du jo jp jq jr b">componentWillUnmount()</code>生命周期方法并清除那里的超时。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="4949" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试又通过了。</p><h1 id="a061" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">添加测试以确保我们清除了正确的超时</h1><p id="e0b1" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这个步骤是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/e8e4dcaa3334924c8a77a63c476da9247aa0a6e3" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中的</em> </a> <em class="mm">这个提交回购中实现的。</em></p><p id="e9d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们当前的测试没有验证我们是否将正确的参数传递给了<code class="du jo jp jq jr b">clearTimeout()</code>。为了说明这一点，去掉传递给<code class="du jo jp jq jr b">componentWillUnmount()</code>的参数。我们的测试仍然错误地通过，即使我们实际上没有清除超时。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d802" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望断言传递给<code class="du jo jp jq jr b">clearTimeout()</code>的参数与我们在<code class="du jo jp jq jr b">componentDidMount()</code>方法中调用<code class="du jo jp jq jr b">setTimeout()</code>返回的值相同。为了做到这一点，我们需要知道<code class="du jo jp jq jr b">setTimeout()</code>返回的值。由于我们在测试中使用了Jest的假计时器，<code class="du jo jp jq jr b">setTimeout() </code>实际上是一个模拟函数。我们可以使用Jest的<code class="du jo jp jq jr b"><a class="ae jn" href="https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreturnvaluevalue" rel="noopener ugc nofollow" target="_blank">mockFn.mockReturnValue()</a></code>指令mock <code class="du jo jp jq jr b">setTimeout()</code>函数返回一个预定值。现在我们知道了期望传递给<code class="du jo jp jq jr b">clearTimeout()</code>的值。然后我们可以断言这个值— <code class="du jo jp jq jr b">clearTimeout.mock.calls[0][0]</code>是第一次调用<code class="du jo jp jq jr b">clearTimeout()</code>的第一个参数。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="b643" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的测试现在应该失败了:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="01e4" class="ld jt hh jr b fi le lf l lg lh">FAIL  src/components/LoadingIndicator.test.js<br/>  ● LoadingIndicator › on unmount › should clear timeout</span><span id="3e0f" class="ld jt hh jr b fi li lf l lg lh">expect(received).toEqual(expected)<br/>    <br/>    Expected value to equal:<br/>      2<br/>    Received:<br/>      undefined<br/>    <br/>    Difference:<br/>    <br/>      Comparing two different types of values. Expected number but received undefined.</span></pre><h2 id="6d12" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">修正<code class="du jo jp jq jr b">clearTimeout</code>参数以使测试通过</h2><p id="582c" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><em class="mm">这一步是在</em> <a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/113608db51e40a0da6c9ccd8cb08eca920f91260" rel="noopener ugc nofollow" target="_blank"> <em class="mm">这个例子中的</em> </a> <em class="mm">提交回购。</em></p><p id="04e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将我们的<code class="du jo jp jq jr b">componentWillUnmount()</code>方法改回传递计时器参数会使我们的测试再次通过。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="92d5" class="ld jt hh bd ju lx ly lz jy ma mb mc kc ja md me kg je mf mg kk ji mh mi ko mj bi translated">在浏览器行为中</h2><p id="8792" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们的组件现在已经过很好的测试，但是我们仍然想探索它在浏览器中的行为。</p><p id="4dc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" href="https://github.com/bruceharris/react-unit-testing-example/commit/cb524caca0e51823b67a27a26613a5262e5fefee" rel="noopener ugc nofollow" target="_blank">提交</a>中，我们更新<code class="du jo jp jq jr b">App.js</code>来演示我们的组件在浏览器中的行为。如果运行示例应用程序，请注意当您刷新页面时，<code class="du jo jp jq jr b">isLoading</code>被设置为<code class="du jo jp jq jr b">true</code>，并且加载指示器直到一秒钟后才显示。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="76cf" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">摘要</h1><p id="e214" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们使用<a class="ae jn" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>测试平台和<a class="ae jn" href="http://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>在我们的单元测试中呈现React组件，并断言它们的输出和行为。</p><p id="4655" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们不需要关心生命周期方法或孩子时，Enzyme的<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/shallow.html" rel="noopener ugc nofollow" target="_blank">shallow</a>()</code>函数允许我们隔离想要测试的组件，确保孩子不会出现在我们的单元测试中。</p><p id="c374" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们想要验证组件的子组件是否被渲染，或者如果我们需要完整的组件生命周期和环境运行时方法，我们使用Enzyme的<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/mount.html" rel="noopener ugc nofollow" target="_blank">mount()</a></code>函数在我们的测试运行环境中的DOM中挂载组件，这样我们就可以对它进行断言。</p><p id="e439" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当使用<code class="du jo jp jq jr b">mount()</code>时，一定要在断言之后调用<code class="du jo jp jq jr b"><a class="ae jn" href="http://airbnb.io/enzyme/docs/api/ShallowWrapper/unmount.html" rel="noopener ugc nofollow" target="_blank">unmount()</a></code>来清理我们的测试环境的DOM。</p><p id="2347" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用Jest的<a class="ae jn" href="https://facebook.github.io/jest/docs/en/timer-mocks.html" rel="noopener ugc nofollow" target="_blank">定时器模拟</a>方法来模拟<code class="du jo jp jq jr b">setTimeout()</code>和<code class="du jo jp jq jr b">clearTimeout()</code>，并在我们的测试中模拟时间的变化。</p><p id="38ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用<a class="ae jn" href="https://facebook.github.io/jest/docs/en/mock-function-api.html#content" rel="noopener ugc nofollow" target="_blank"> Jest的模拟函数</a>来确保使用正确的值来调用<code class="du jo jp jq jr b">setTimeout()</code>，并使用模拟函数<code class="du jo jp jq jr b">setTimeout()</code>来返回预定的值。</p><h1 id="33e7" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">感谢</h1><p id="b147" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">感谢Drew Bourne在这篇文章的同行评论中提出的优秀建议。</p><p id="4ac5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="mm">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em> </strong></p></div></div>    
</body>
</html>