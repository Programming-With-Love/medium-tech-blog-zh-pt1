<html>
<head>
<title>StrictMode for Runtime Analysis on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上运行时分析的严格模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/strictmode-for-runtime-analysis-on-android-f8d0a2c5667e?source=collection_archive---------7-----------------------#2016-01-21">https://medium.com/androiddevelopers/strictmode-for-runtime-analysis-on-android-f8d0a2c5667e?source=collection_archive---------7-----------------------#2016-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/5763e5a4793b024f962b85ed34a2ec0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wmf5cRG2hOTcODtX5aLLYg.png"/></div></figure><p id="e9d6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让你的Android应用程序编译只是第一步:仅仅因为它能编译并不意味着当你运行你的应用程序时它也能工作。令人欣慰的是，Android已经投资建立分析工具来捕捉一些常见的Android特有的问题，这些问题弥合了编译错误和运行时崩溃之间的差距。其中<a class="ae jj" href="http://developer.android.com/tools/debugging/improving-w-lint.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> lint </a>提供静态代码分析，<a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> StrictMode </em> </a>相当于运行时:在线程或虚拟机级别分析你的应用，并提醒你潜在的问题。</p><p id="6ef3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">尽管传统上用于与性能相关的检查，但也有许多检查专门围绕共享文件和访问网络的一些最佳实践。</p><figure class="jl jm jn jo fd ii"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="a045" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">严格模式基础</h1><p id="daae" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">要了解<em class="jk"> StrictMode </em>的功能以及如何在您的应用中使用它，我强烈建议观看我们之前在<em class="jk"> StrictMode </em> 上的<a class="ae jj" href="https://www.youtube.com/watch?v=oGrXdxpWgyY?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">视频。在这里，我们讨论了<em class="jk"> StrictMode </em>的多个</a><a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ThreadPolicy </em> </a>和<a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.VmPolicy.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> VmPolicy </em> </a>配置选项，归结起来就是在运行时检测某些条件，然后以惩罚的方式对这些条件做出反应——无论是记录日志、闪烁屏幕还是完全关闭您的应用程序。</p><h1 id="b6db" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">VmPolicy的detectFileUriExposure()</h1><p id="b043" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">当向其他应用程序发送文件时，其他应用程序能够真正读取您的文件<strong class="in hi">非常重要</strong>。事实证明，<em class="jk">file://</em>uri实际上是一种非常糟糕的方式。正如我们在<a class="ae jj" rel="noopener" href="/@ianhlake/2e6db9d1368b">分享内容帖子</a>中解释的，使用<em class="jk"> file:// </em> Uri意味着存储权限，它们实际上永远不会跨用户工作(比如Android for Work)。</p><p id="b8ce" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog#detectFileUriExposure()" rel="noopener ugc nofollow" target="_blank"><em class="jk">detectFileUriExposure()</em></a>strict mode检查(在API 18 — Jellybean MR2中添加)试图捕捉这些情况:在应用发出的任何<em class="jk">意图</em>中寻找<em class="jk">file://</em>uri，然后应用您为<em class="jk"> VmPolicy </em>选择的惩罚。要记住的一点是，这是对<em class="jk">file://</em>uri的全面禁止——尽管在你自己的应用程序的组件之间发送<em class="jk">file://</em>uri在技术上是安全的，但这种检查还不能区分谁在接收<em class="jk">意图</em>。</p><h1 id="ce6c" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">VmPolicy的detectCleartextNetwork()</h1><p id="6d3f" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">安全性，尤其是用户数据的安全性，并不仅仅止于你的应用程序——保护与服务器的通信同样重要，坦率地说，保护你的应用程序建立的每个连接也同样重要——仅仅因为你信任你的无线接入点和网络，并不意味着对所有用户都是如此。</p><p id="2e97" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Android 6.0 Marshmallow以<a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog#detectCleartextNetwork()" rel="noopener ugc nofollow" target="_blank"><em class="jk">detectCleartextNetwork()</em></a>的形式添加了一个新的StrictMode检查——一个StrictMode检查，它可以确保来自你的应用程序的所有网络流量都是加密的。甚至还有一个单独的<a class="ae jj" href="http://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog#penaltyDeathOnCleartextNetwork()" rel="noopener ugc nofollow" target="_blank"><em class="jk">penaltyDeathOnCleartextNetwork()</em></a>，它将确保一旦检测到明文网络操作，你的应用就会被杀死(防止任何用户数据泄露，即使你不希望你的应用因为其他严格模式检查而被杀死)。</p><p id="4aa8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">虽然这种检查对IPv4和IPv6流量都有效，无论是TCP还是UDP，但是根据文档有一个警告:</p><blockquote class="ku"><p id="c7a4" class="kv kw hh bd kx ky kz la lb lc ld ji dx translated">它可能会出现误报，例如当使用STARTTLS协议或HTTP代理时。</p></blockquote><p id="435a" class="pw-post-body-paragraph il im hh in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">因此，如果你的应用程序使用这些技术来处理网络流量，请记住这一点。</p><h1 id="be78" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">简单分析？我不这么认为</h1><p id="ba17" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">由于StrictMode在线程或VM级别上工作，它比大多数运行时分析处于更低的级别。虽然这有它的优点和缺点——它确实非常彻底，但是可用的惩罚是硬编码的和不灵活的。唉，目前的API中没有StrictMode的自定义处理程序。</p><p id="da22" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是不要把这种不灵活性当成丧钟——只要仔细考虑您使用的严格模式检查，并确保您只在调试版本上启用它们—<em class="jk">build config。调试</em>标志对这些情况很有帮助:</p><pre class="jl jm jn jo fd lj lk ll lm aw ln bi"><span id="a7c1" class="lo js hh lk b fi lp lq l lr ls">if (BuildConfig.DEBUG) {<br/>  // Enable StrictMode<br/>  StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()<br/>    .detectFileUriExposure()<br/>    .detectCleartextNetwork()<br/>    .penaltyLog()<br/>    .penaltyDeath()<br/>    .build());<br/>}</span></pre><p id="981d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"># BuildBetterApps</p><p id="6f15" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">关注<a class="ae jj" href="https://plus.google.com/collection/sLR0p?utm_campaign=android_series_strictmode_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集</a>了解更多！</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>