<html>
<head>
<title>Kubernetes — Microservices Discovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes —微服务发现</h1>
<blockquote>原文：<a href="https://medium.com/globant/kubernetes-microservices-discovery-2dd754712606?source=collection_archive---------0-----------------------#2022-12-01">https://medium.com/globant/kubernetes-microservices-discovery-2dd754712606?source=collection_archive---------0-----------------------#2022-12-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d0a2613638234551b003c8d6a00f1180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BNMVnPzuUJ54UeMs"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@ellladee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">N.</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3842" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在非基于Kubernetes的项目中，我们有一个发现服务器(像Eureka服务)来处理服务发现。所以我很好奇我们应该在Kubernetes中使用哪种组件。我在互联网上搜索，以检查是否有任何文章涉及上游微服务调用下游微服务的发现，但没有发现；于是想到写这篇文章。</p><p id="20c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是先决条件:</p><ul class=""><li id="902b" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">Spring Boot版本:2.7.3</li><li id="0073" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">Minikube版本:v1.25.1</li><li id="81d4" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">Kubectl: v1.22.5</li></ul><p id="631c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我将解释微服务如何在<a class="ae it" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a> (K8s)环境中发现彼此。我将使用基于SpringBoot的微服务来演示它(使用一个<a class="ae it" href="https://github.com/OpenFeign/feign" rel="noopener ugc nofollow" target="_blank">假客户端</a>上游调用下游)。</p><h2 id="b9e7" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">Kubernetes如何支持探索？</h2><p id="8b96" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated"><a class="ae it" href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>中的发现有两种支持方式。</p><h2 id="9d40" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">1.<strong class="ak">环境变量</strong></h2><p id="19e2" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">Kubernetes为集群中创建的每个pod添加了<code class="du lg lh li lj b">{SVCNAME}_SERVICE_HOST</code>和<code class="du lg lh li lj b">{SVCNAME}_SERVICE_PORT</code>环境变量。下面是一个例子。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="3e20" class="ls kh hh lj b be lt lu l lv lw">PAYMENT_SERVICE_SERVICE_HOST=10.108.155.131<br/>PAYMENT_SERVICE_SERVICE_PORT=8080<br/>TICKET_SERVICE_SERVICE_PORT=8080<br/>TICKET_SERVICE_SERVICE_HOST=10.108.155.131</span></pre><p id="655d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Feign Client中，使用这些变量来创建服务URL，如下所示。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="396d" class="ls kh hh lj b be lt lu l lx lw">url = ${PAYMENT_SERVICE_SERVICE_HOST}:${PAYMENT_SERVICE_SERVICE_PORT}</span></pre><p id="e90f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种方法并不常用，因为它有一个问题:如果客户机Pod是在服务之前创建的，那么服务环境变量就不可用。因此，您必须在客户端Pods出现之前创建服务。否则，这些客户机单元不会填充它们的环境变量。</p><h2 id="dfe4" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">2.<strong class="ak">使用CoreDNS进行发现</strong></h2><p id="7cdc" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">每个Kubernetes集群都有一个CoreDNS pod，它基本上充当DNS服务器。它监视新服务的Kubernetes API，并为每个服务创建DNS记录集。</p><p id="b916" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们实际看看这是如何发生的。通过查询，我们可以看到CoreDNS pod是现成可用的，如下所示。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="c7a4" class="ls kh hh lj b be lt lu l lx lw">kubectl get pods -n kube-system  </span></pre><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/4e8b81b70a601399212bd1bb604391f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nDhnBWKn265O23xq"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">CoreDNS POD</figcaption></figure><p id="8249" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要获得关于CoreDNS <strong class="iw hi">服务的数据，请使用下面的命令。</strong></p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="1d35" class="ls kh hh lj b be lt lu l lx lw">kubectl get service -n kube-system</span></pre><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/668ae2a9fb2c3481b1d041c362b9eb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h4TCGXw0vMqGShdn"/></div></div></figure><p id="6a3b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当一个微服务想要与其他微服务连接时，它们使用CoreDNS服务进行查找。</p><p id="c688" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了了解这是如何工作的，让我们创建<strong class="iw hi">两个</strong>简单的基于SpringBoot的项目。</p><p id="41d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">1.<code class="du lg lh li lj b">ticket-service</code>(上游)</p><p id="f082" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.<code class="du lg lh li lj b">payment-service</code>(下游)</p><p id="708b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du lg lh li lj b">pom.xml</code>中添加以下依赖项。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="9d93" class="ls kh hh lj b be lt lu l lv lw">  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-all&lt;/artifactId&gt;<br/>  &lt;/dependency&gt;</span></pre><ul class=""><li id="a97d" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hi">步骤1 </strong>:创建<code class="du lg lh li lj b">ticket-service</code>应用程序，添加以下代码:</li></ul><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="ff2f" class="ls kh hh lj b be lt lu l lv lw">@SpringBootApplication<br/>@RestController<br/>@EnableFeignClients<br/>@EnableDiscoveryClient<br/>@Slf4j<br/>public class TicketServiceApplication {<br/><br/>  @Autowired<br/>  IPayment iPayment;<br/><br/>  public static void main(String[] args) {<br/>     SpringApplication.run(TicketServiceApplication.class, args);<br/>  }<br/><br/>  @PostMapping("/ticket/pay")<br/>  public String pay(){<br/>     log.info("Calling payment service");<br/>     //wallet payment<br/>     String paymentResponse = iPayment.pay();<br/>     log.info("Payment done..");<br/>     return paymentResponse + ", Ticket confirmed!";<br/>  }<br/>} </span></pre><p id="8397" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将<code class="du lg lh li lj b">IPayment</code>客户端添加到<code class="du lg lh li lj b">ticket-service</code>项目中，如下所示:</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="d00b" class="ls kh hh lj b be lt lu l lv lw">@FeignClient(name="payment-service")<br/>public interface IPayment {<br/><br/>   @PostMapping("/pay")<br/>   public String pay();<br/>}</span></pre><ul class=""><li id="908a" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hi">第2步</strong>:创建一个<code class="du lg lh li lj b">payment-service</code>应用程序，并添加以下代码:</li></ul><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="7a1f" class="ls kh hh lj b be lt lu l lv lw">@SpringBootApplication<br/>@RestController<br/>@EnableDiscoveryClient<br/>public class PaymentServiceApplication {<br/><br/>  public static void main(String[] args) {<br/>     SpringApplication.run(PaymentServiceApplication.class, args);<br/>  }<br/><br/>  @GetMapping<br/>  public String status(){<br/>     return "success";<br/>  }<br/><br/>  @PostMapping("/pay")<br/>  public String pay(){<br/>     return "payment successful";<br/>  }<br/>}</span></pre><ul class=""><li id="b4c3" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hi">第三步</strong>:使用Postman调用票端点，如下图所示(内部调用下游— <code class="du lg lh li lj b">payment-service</code>)。</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/0a77b992b518d517363fa4b65653f104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gqM28BDL_5k6vgyw"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Test downstream call works</figcaption></figure><p id="f8ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到，票务微服务成功发现了支付微服务，并得到了支付服务的响应！！！我们现在可以发现并调用下游服务。</p><p id="ab22" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们深入内部，看看这是如何工作的。</p><p id="6ebc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，让我们列出并注意到如下所示的pod和服务的IP。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/643b80906195041cefa8005f49293841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D8_8ho-ZE60CZo7k"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">List IP's</figcaption></figure><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="5273" class="ls kh hh lj b be lt lu l lx lw">Note : #1 kube-dns IP is : 10.96.0.10 #2 payment-service IP is : 10.108.155.131</span></pre><p id="d946" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当创建一个新的pod时，Kubernetes都会在POD的<code class="du lg lh li lj b">resolv.conf</code>文件中添加一个DNS服务器条目。(Pod OS — Linux跟踪<code class="du lg lh li lj b">/etc/resolv.conf</code>文件中的网络信息)。看到这让<code class="du lg lh li lj b">sh</code>进入如下所示的一个吊舱。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="4067" class="ls kh hh lj b be lt lu l lv lw">kubectl exec &lt;PODName&gt; -it sh</span></pre><p id="20d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">示例:</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="7705" class="ls kh hh lj b be lt lu l lv lw"> kubectl exec ticket-service-84479b4b59-rqdjz -it sh</span></pre><p id="ad42" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在导航到<code class="du lg lh li lj b">/etc</code>并打开<code class="du lg lh li lj b">resolv.conf</code>，如下所示。</p><pre class="lk ll lm ln fd lo lj lp bn lq lr bi"><span id="c0e3" class="ls kh hh lj b be lt lu l lv lw"># cat /etc/resolv.conf</span></pre><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/36e701f1631f24f1d144829a17706881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MsvO1-FzUL7CfyZNljUSQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">DNS Name server entry</figcaption></figure><p id="77fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们在输出中看到的，DNS服务IP— 10.96.0.10是可用的(与上面#1提到的IP交叉检查)；因此，每个POD将能够联系DNS服务，以<strong class="iw hi">将服务名称解析为实际服务的IP地址</strong>，从而相互通信。</p><p id="abb4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们在票证窗格控制台上时，让我们使用<code class="du lg lh li lj b">nslookup</code>查询<code class="du lg lh li lj b">payment-service</code> IP，如下所示。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/05524044e66669b4b3b07c01fd284df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Wu9VOFBt7dc7qFA"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">payment-service name to IP</figcaption></figure><p id="4b1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们在上面的输出中看到的，ticket microservice pod可以根据名称查询<code class="du lg lh li lj b">payment-service</code>(它将请求委托给<code class="du lg lh li lj b">payment-pods</code>)，这将它解析为服务运行的实际IP。</p><h1 id="3207" class="mf kh hh bd ki mg mh mi km mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">结论</h1><p id="72f3" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">我们已经成功部署了一个SpringBoot微服务并调用了一个下游微服务，并看到了Kubernetes如何使用CoreDNS服务器发现服务。</p><p id="4370" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ly">感谢</em> <a class="mw mx ge" href="https://medium.com/u/cfab8f825ee8?source=post_page-----2dd754712606--------------------------------" rel="noopener" target="_blank"> <em class="ly">费德里科</em> </a> <em class="ly">对他的投入。</em></p></div></div>    
</body>
</html>