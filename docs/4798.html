<html>
<head>
<title>Lessons from my first multiplatform Kotlin project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从我的第一个多平台Kotlin项目中得到的教训</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/lessons-from-my-first-multiplatform-kotlin-project-d4e311f15874?source=collection_archive---------0-----------------------#2017-12-04">https://blog.kotlin-academy.com/lessons-from-my-first-multiplatform-kotlin-project-d4e311f15874?source=collection_archive---------0-----------------------#2017-12-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2d70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我刚刚完成了<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd"> good多平台架构</a>的<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp" rel="noopener ugc nofollow" target="_blank"> Kotlin多平台项目</a>，有三个不同的客户:</p><ul class=""><li id="1453" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><a class="ae ki" href="https://play.google.com/store/apps/details?id=org.kotlinacademy.mobile" rel="noopener ugc nofollow" target="_blank">安卓</a></li><li id="47ff" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae ki" href="https://github.com/JetBrains/create-react-kotlin-app" rel="noopener ugc nofollow" target="_blank"> Web in React </a></li><li id="943e" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae ki" href="https://github.com/edvin/tornadofx" rel="noopener ugc nofollow" target="_blank">中的桌面TornadoFX </a>(该零件由<a class="ae ki" href="https://twitter.com/edvinsyse" rel="noopener ugc nofollow" target="_blank"> Edvin Syse </a>制造)</li></ul><p id="b0ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个解决方案的美妙之处在于，所有这些客户端都共享业务逻辑！(查看<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd">这篇文章</a>描述了这是如何实现的)。在执行过程中，我不得不挑战自己很多。我开始有一些想法和理解，但我不得不在实施过程中更新它们。这些是我想与你们分享的宝贵经验。我相信它们很重要，因为Kotlin多平台开发将会很大。它提供了代码共享的巨大可能性，同时保持了所有平台的原生性。希望有一天你也会加入这个潮流。现在，享受我所学到的；)</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/eea18fc69cf1efbe11134f798d355142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*QCqRjzCc_QPux8C7.png"/></div></figure><h1 id="a98b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">预期声明背后的想法</h1><p id="a40e" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在Kotlin公共模块中，我们可以定义<code class="fe mi mj mk ml b">expected</code>声明，为此我们需要在每个平台模块中指定<code class="fe mi mj mk ml b">actual</code>声明(参见<a class="ae ki" href="https://kotlinlang.org/docs/reference/multiplatform.html" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec">本文</a>以了解公共、平台和常规模块)。这是非常重要和强大的机制，因为没有它，我们就不能在公共模块中使用特定于平台的类型。</p><p id="5374" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">项目的例子是<code class="fe mi mj mk ml b">DateTime</code> —代表具体时间点的对象。由于我<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/DateTime.kt" rel="noopener ugc nofollow" target="_blank">在</a> <code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/DateTime.kt" rel="noopener ugc nofollow" target="_blank">common</a></code> <a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/DateTime.kt" rel="noopener ugc nofollow" target="_blank">模块</a>中将其定义为 <code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/DateTime.kt" rel="noopener ugc nofollow" target="_blank">expected</a></code> <a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/DateTime.kt" rel="noopener ugc nofollow" target="_blank">声明，并且我在<code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common-jvm/src/main/kotlin/org/kotlinacademy/DateTimeJvm.kt" rel="noopener ugc nofollow" target="_blank">common-jvm</a></code>和<code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common-js/src/main/kotlin/org/kotlinacademy/DateTimeJs.kt" rel="noopener ugc nofollow" target="_blank">common-js</a></code>中提供了<code class="fe mi mj mk ml b">actual</code>声明，所以我可以在数据模型的<code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/data/News.kt" rel="noopener ugc nofollow" target="_blank">News</a></code>类中使用它。这听起来可能是无辜的，但是<code class="fe mi mj mk ml b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/master/common/src/main/kotlin/org/kotlinacademy/data/News.kt" rel="noopener ugc nofollow" target="_blank">News</a></code>在这个项目中几乎无处不在！它用于所有层中的所有客户端。我在API(我必须为此定义序列化)和后台逻辑中使用它。我可以自由地为这样的对象使用特定于平台的类型，这一点非常重要。它极大地提高了我们的数据模型的表达能力，如果没有它，我将被迫在每次使用之前序列化或反序列化这样的对象。</a></p><h1 id="9e09" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">平台模块是JS，JVM或者Native。不是安卓也不是iOS</h1><p id="1fc7" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">当我开始我的项目时，我设想我将省略<code class="fe mi mj mk ml b">common-js</code>模块，直接在<code class="fe mi mj mk ml b">web</code>模块中提供<code class="fe mi mj mk ml b">expected</code>声明。这可能是有利可图的，因为它目前是这个项目中唯一的Kotlin/JS模块。事情不是这样的。<code class="fe mi mj mk ml b">web</code>、<code class="fe mi mj mk ml b">android</code>、<code class="fe mi mj mk ml b">ios</code>、<code class="fe mi mj mk ml b">desktop</code>都是常规模块，不能是平台模块(没有<a class="ae ki" href="https://youtrack.jetbrains.com/issue/KT-18462" rel="noopener ugc nofollow" target="_blank">变通</a>)。</p><p id="d76c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初我把它当作一个问题——这迫使我提取额外的模块。当我将网络存储库定义为预期声明时，它迫使我在Android和桌面之间共享网络。我担心这会引起一些问题。它实际上没有，我发现这实际上是有益的！它迫使我们在平台模块中定义元素，而不是为每个客户定义它们。另一个好处是，我必须在单独的模块中提取Kotlin/JS库，现在我知道当我添加Firefox和Chrome扩展客户端时，我已经实现了联网。这种解决方案使整个结构稍微复杂了一点，但同时也为新平台带来了更好的代码可重用性和更好的可伸缩性。</p><h1 id="4ca9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">MVP与多平台设计完美结合</h1><p id="74c5" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我想知道<a class="ae ki" href="https://medium.com/@marcinmoskala/mvc-vs-mvp-vs-mvvm-vs-mvi-ce72907d330" rel="noopener"> MVP架构</a>是否适合这样的大型多平台项目。担忧是合理的——不同的平台代表了完全不同的思维方式。这就是为什么当我发现这种设计模式如此适合所有当前实现的客户端时，我感到震惊。几乎所有的演示者最初都是为Android编写的，然后很容易在所有客户端重用。</p><p id="e3bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在本文中找到更多关于它的内容，但是为了给你一些MVP如何适应不同模块的直觉，让我们看看在加载状态下我们是如何表达视图的。只有演示者可以决定视图是否处于这种状态，他们通过更改其<code class="fe mi mj mk ml b">view</code>属性来发出信号:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="8895" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">class </strong>NewsPresenter(<strong class="ml io">val view</strong>: NewsView) : BasePresenter() {<br/><br/>    <strong class="ml io">fun </strong>onRefresh() {<br/>        <strong class="ml io">view</strong>.<strong class="ml io">refresh </strong>= <strong class="ml io">true<br/>        ...<br/>    }<br/>  <br/>    ...<br/>}</strong></span></pre><p id="04d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使视图具有通用性和可测试性，它们被隐藏在接口后面。<code class="fe mi mj mk ml b">loading</code>在这里表示为<code class="fe mi mj mk ml b">Boolean</code>类型属性:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="29fa" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">interface </strong>NewsView: BaseView {<br/>    <strong class="ml io">var loading</strong>: Boolean<br/>    <strong class="ml io">...</strong><br/>}</span></pre><p id="558f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Android中，我使用<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAndroidViewBindings" rel="noopener ugc nofollow" target="_blank">KotlinAndroidViewBinding</a>将该属性与进度可见性绑定:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="4a0c" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">override var </strong>loading <strong class="ml io">by </strong>bindToVisibility(R.id.<em class="mv">progressView)</em></span></pre><p id="961f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://github.com/edvin/tornadofx" rel="noopener ugc nofollow" target="_blank"> TornadoFX </a>中，有称为属性的对象用于表示视图状态。我们可以很容易地将它们与科特林的财产捆绑在一起:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="1990" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">private val loadingProperty </strong>= SimpleBooleanProperty()<br/><strong class="ml io">override var loading by loadingProperty</strong></span></pre><p id="763a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进度栏可见性绑定到此属性:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="3d8c" class="mq lg in ml b gy mr ms l mt mu"><em class="mv">progressbar </em><strong class="ml io">{<br/>    </strong><em class="mv">removeWhen</em>(<strong class="ml io">loadingProperty</strong>.not())<br/><strong class="ml io">}</strong></span></pre><p id="39a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React中，视图状态由每个组件的单个对象表示(这就是我们如何调用React视图)。每次在该对象中应用一些改变时，显示的视图也会改变(改变必须在<code class="fe mi mj mk ml b">setState</code>块中完成)。在这个架构中，我们可以使用<code class="fe mi mj mk ml b">observable</code> delegate在属性值改变时总是改变状态:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="49fc" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">override var loading</strong>: Boolean <strong class="ml io">by </strong>observable(<strong class="ml io">false</strong>) <strong class="ml io">{ </strong>_, _, n <strong class="ml io">-&gt;<br/>    </strong><em class="mv">setState </em><strong class="ml io">{ state</strong>.<strong class="ml io">loading </strong>= n <strong class="ml io">}<br/>}</strong></span></pre><p id="16c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当<code class="fe mi mj mk ml b">state</code>的<code class="fe mi mj mk ml b">loading</code>属性为<code class="fe mi mj mk ml b">true</code>时，我们显示加载视图:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="188c" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">override fun </strong>RBuilder.render(): ReactElement? = <strong class="ml io">when </strong>{<br/>    <strong class="ml io">state</strong>.<strong class="ml io">loading </strong>!= <strong class="ml io">false </strong>-&gt; <em class="mv">loadingView</em>()<br/>    <strong class="ml io">state</strong>.<strong class="ml io">error </strong>!= <strong class="ml io">null </strong>-&gt; <em class="mv">errorView</em>(<strong class="ml io">state</strong>.<strong class="ml io">error</strong>!!)<br/>    <strong class="ml io">state</strong>.<strong class="ml io">newsList </strong>!= <strong class="ml io">null </strong>-&gt; <em class="mv">newsListView</em>()<br/>    <strong class="ml io">else </strong>-&gt; <em class="mv">div </em><strong class="ml io">{ }<br/></strong>}</span></pre><p id="8b34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，MVP以完全不同的方式适合每一种架构，但是它实际上对所有的架构都很有效。</p><h1 id="c349" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">双向沟通的方式</h1><p id="7fda" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">不同类型的模块之间有不同的通信方式。有3种类型的模块:</p><ul class=""><li id="9536" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">通用模块(例如<code class="fe mi mj mk ml b">common</code>、<code class="fe mi mj mk ml b">common-client</code>)</li><li id="4edf" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">平台模块(例如<code class="fe mi mj mk ml b">common-js</code>、<code class="fe mi mj mk ml b">common-jvm</code>)</li><li id="1cfc" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">常规模块(例如<code class="fe mi mj mk ml b">android</code>、<code class="fe mi mj mk ml b">desktop</code>、<code class="fe mi mj mk ml b">web</code>)</li></ul><p id="5cb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个模块都可以使用更高层模块中的所有东西。在常规模块中，我们可以使用来自所有相关平台模块和所有相关公共模块的所有内容。类似地，平台模块可以使用它所依赖的公共模块中的任何东西。</p><p id="0586" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在其他方向上更难沟通。如果上层需要下层的东西怎么办？当公共模块需要平台模块的东西时，我们可以通过指定<code class="fe mi mj mk ml b">expected</code>声明来处理。语言将迫使我们为每个平台模块指定<code class="fe mi mj mk ml b">actual</code>声明。</p><p id="323d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我需要只能在常规模块中指定的公共和平台模块中的值时，我遇到了更大的问题:</p><ul class=""><li id="3fa5" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><code class="fe mi mj mk ml b">UI</code> —协程的用户界面上下文。</li><li id="3002" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><code class="fe mi mj mk ml b">BaseURL</code>—API的基本URL地址。它不同是因为在Android模拟器中不同的地址需要被用来指导计算机本地主机。</li></ul><p id="2fc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种方法可以解决这个问题:</p><ul class=""><li id="a3a9" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">所有上层元素都是由常规模块创建的，因此我们可以将这些值传递给所有需要它们的对象(在创建过程中，我们可以通过构造函数将<code class="fe mi mj mk ml b">UI</code>传递给所有演示者)。遗憾的是，这种解决方案不具备真正的可扩展性。</li><li id="a15f" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">我们可以用<code class="fe mi mj mk ml b">notNull</code> delegate定义公共顶级属性或对象声明属性，并在常规模块初始化时填充它们。</li></ul><p id="c308" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我在这种情况下的结局。我将<code class="fe mi mj mk ml b">UI</code>定义为顶级属性:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="77af" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">var </strong><em class="mv">UI</em>: CoroutineContext <strong class="ml io">by </strong>notNull()</span></pre><p id="2d0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在初始化过程中，它由特定于客户端的对象填充:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="61ef" class="mq lg in ml b gy mr ms l mt mu"><strong class="ml io">class </strong>App: Application() {<br/><br/>    <strong class="ml io">override fun </strong>onCreate() {<br/>        <strong class="ml io">super</strong>.onCreate()<br/>        <em class="mv">UI </em>= <em class="mv">AndroidUI<br/>        ...</em><br/>    }<br/>}</span></pre><p id="e040" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，可以很容易地为单元测试指定不同值:</p><pre class="ky kz la lb gt mm ml mn mo aw mp bi"><span id="57b8" class="mq lg in ml b gy mr ms l mt mu">@Before<br/><strong class="ml io">fun </strong>setUp() {<br/>    <em class="mv">UI </em>= Unconfined<br/>}</span></pre><p id="e893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管这种解决方案看起来不错，但不应该过于频繁地使用。以这种方式指定值并不直观，我们应该首先考虑将这样的对象作为参数传递。</p><h1 id="a34b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="ba14" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这些是关于多平台Kotlin编程的重要经验。我希望它能帮助每一个在这方面开始冒险的人。重要的一课——优化代码重用和项目可伸缩性和可测试性的架构——可以在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd">这篇文章</a>中找到。</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">Kotlin中多平台本机开发的有效架构</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我的导师经常说“如果你在一个项目中使用Ctrl-C Ctrl-V，你就做错了”。这个…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ld mz"/></div></div></a></div><h2 id="0ce3" class="mq lg in bd lh no np dn ll nq nr dp lp jv ns nt lt jz nu nv lx kd nw nx mb ny bi translated">学到了什么？单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="48bb" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">如果你认为这很重要，与他人分享。</p><p id="a4d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要Kotlin工作室吗？访问<a class="ae ki" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="b392" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在Twitter上提到我，请使用<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @marcinmoskala </a>。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nz"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="7584" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>