<html>
<head>
<title>Memory Management and Garbage Collection in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的内存管理和垃圾收集。网</h1>
<blockquote>原文：<a href="https://medium.com/globant/memory-management-and-garbage-collection-in-net-555e4bbdd08f?source=collection_archive---------0-----------------------#2021-03-22">https://medium.com/globant/memory-management-and-garbage-collection-in-net-555e4bbdd08f?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b468" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你知道怎么做吗？NET为我们管理内存？对象是如何在内存中存储和清除的？即使您不知道这个问题的答案，您也可以毫不费力地开发应用程序。但是理解如何分配和释放内存以优化框架的使用是很重要的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/cfd5435eb9118f1d4c0338e54dc61240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lj7la-A_Y34fFz1S"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@harrisonbroadbent?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Harrison Broadbent</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8aae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将讨论。NET运行库在您请求时分配内存，以及在不使用时如何释放内存。</p><p id="91cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何应用程序都由两部分组成:代码本身和数据。</p><p id="3859" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">。NET使用两种数据结构来管理. NET应用程序的内存:堆栈和堆。</p><h1 id="4f1e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">堆栈</strong></h1><p id="ac0a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">从数据结构类中我们知道，堆栈使用后进先出法。英寸堆栈可以存储原始数据类型(如Int，Double，Boolean，Struct等)。).。NET使用堆栈来跟踪方法数据。当调用方法时，NET创建一个容器(堆栈帧),其中包含完成调用所需的所有数据，包括参数、本地声明的变量以及方法完成后要执行的代码行的地址。当一个方法完成时，它的容器从栈顶移除，执行返回到调用方法中的下一行代码。我举个例子来演示一下。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="7300" class="lb ju hh kx b fi lc ld l le lf">1  void Method1()<br/>2  {<br/>3      Method2(100);<br/>4      Console.WriteLine(″End″);<br/>5  }</span><span id="bfe0" class="lb ju hh kx b fi lg ld l le lf">6  void Method2(int data)<br/>7  {<br/>8      int i = 10;<br/>9      Console.WriteLine(″Method 2 : ″ + data.ToString());<br/>10     Method3(data * i);<br/>11 }</span><span id="f989" class="lb ju hh kx b fi lg ld l le lf">12 void Method3(int data)<br/>13 {<br/>14     Console.WriteLine(″Method 3 : ″ + data.ToString());<br/>15 }</span><span id="5efe" class="lb ju hh kx b fi lg ld l le lf">16 static void Main(string[] args)<br/>17 {<br/>18     Method1();<br/>19 }</span></pre><p id="6789" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的代码片段简单地调用了“Method1”。“方法1”调用“方法2”，“方法2”调用“方法3”。下面是调用“Method1”时堆栈的样子。下面是堆栈帧的样子(注意，对控制台的调用。为了简洁起见，不考虑WriteLine()</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lh"><img src="../Images/c5c97cb7f9327f85b02c0ffadd17984d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wq_fXBA7Vz0RJq9EawEEw.png"/></div></div></figure><p id="f845" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，当调用“Method2”时，在“Method2”的堆栈框架上创建特定于方法“I”的参数，即“data”和实例变量。调用“方法3”时也是如此。现在让我们看看当方法执行完毕时会发生什么。这时，返回行(或返回地址)出现，执行返回到调用函数。</p><p id="7fbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果堆栈存储数据，堆是什么？</p><h1 id="282c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">许多</h1><p id="aee2" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">堆栈只能存储原始数据类型。原始数据类型是通用类型系统(CTS)的一部分。这些也称为值类型。除了这些类型，我们在代码中定义的任何东西，比如类、接口、字符串等等。是引用类型。引用类型的实例(使用new关键字创建)可以看作两件事:对象本身(及其所有属性)和指针或引用。引用告诉我们对象在内存中的位置。参考始终是32位或64位，具体取决于操作系统。当对象存储在堆中时，引用总是存储在堆栈中。考虑下面的代码片段。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="2fc0" class="lb ju hh kx b fi lc ld l le lf">public class Car<br/>{<br/>    public int id;<br/>    public double width;<br/>    public double height;<br/>}</span><span id="1177" class="lb ju hh kx b fi lg ld l le lf">void Method1()<br/>{<br/>    var car = new Car();<br/>    car.id = 1000;<br/>    car.width = 3000;<br/>    car.height = 2000;</span><span id="7376" class="lb ju hh kx b fi lg ld l le lf">    int number = 10;<br/>}</span></pre><p id="81d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是堆栈和堆的样子。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lh"><img src="../Images/556122fe3e23b3c8d271a8a34fee09a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RunTnHpjBCMmDe2neqprQA.png"/></div></div></figure><p id="1516" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意到引用类型在堆上被分配了内存。它的引用存储在“Method1”堆栈框架下。引用包含对象的内存地址。另外，请注意，引用类型下的基本类型(即id、width、height)是在堆上创建的。而对于“方法1”来说是本地的原始类型“数字”是在堆栈上创建的。</p><p id="fae2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值类型是在堆栈或堆上创建的(基于声明它们的位置)，引用类型总是在堆上创建。值类型的局部变量在堆栈上创建。</p><p id="f2a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只要“方法1”在运行，它就引用“汽车”对象。一旦它返回，它的堆栈框架就被销毁。这将释放本地分配的内存，即本例中的“number”。它还删除了堆栈框架上的“car”引用。这使得堆上的对象不可访问，因为我们丢失了它的地址。这给了我们一个提示。NET垃圾收集器知道哪些对象可用于收集。</p><h1 id="a8b0" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">碎片帐集</h1><p id="5e0f" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如上所述，当堆栈框架被销毁时，其中包含的对象引用也被销毁。现在，由于我们丢失了引用(或内存地址)，实际的对象是不可达的。这样的对象在下一个垃圾收集周期运行时可以自由收集。</p><p id="c163" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，“car”对象引用存在于堆栈中。这种引用称为根引用。现在，根引用指向实际的对象，该对象本身可以包含对属于该类的其他类型的引用。看看下面更新的“汽车”类。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="dbc9" class="lb ju hh kx b fi lc ld l le lf">public class Engine<br/>{<br/>    public double volume;<br/>    public int cylinders;<br/>    public double power;<br/>}</span><span id="6e33" class="lb ju hh kx b fi lg ld l le lf">public class Car<br/>{<br/>    public int id;<br/>    public double width;<br/>    public double height;<br/>    public Engine engine;<br/>}</span><span id="4134" class="lb ju hh kx b fi lg ld l le lf">void Method1()<br/>{<br/>    var car = new Car();<br/>    car.id = 1000;<br/>    car.width = 3000;<br/>    car.height = 2000;</span><span id="20cb" class="lb ju hh kx b fi lg ld l le lf">    int number = 10;<br/>}</span></pre><p id="fdee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是堆栈和框架的样子。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es li"><img src="../Images/41ee59212b45a5242a279a3eeeb60d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCZ8yfd72Rw2reJN94K5pw.png"/></div></div></figure><p id="ec49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，引擎是一个引用，指向实际的对象，该对象也位于堆中。在这里，车是“根参照物”，“发动机”不是。</p><p id="1a32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当垃圾回收开始时。NET framework需要做的是找到所有根引用，并将这些根引用(包括这些根引用所拥有的所有引用)标记为“正在使用”。如果一个对象最终没有根引用，那么它实际上不能被代码访问，所以它不再被使用，可以被移除。</p><h1 id="ccd8" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">堆的类型</h1><p id="4bfb" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">当。NET应用程序运行时，将创建以下四个内存部分(堆)用于存储。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lj"><img src="../Images/b62822d1121b22ab9125204eeeb48dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qWOSDM17fGSIxfLXC9T_Q.png"/></div></div></figure><p id="7100" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以集中讨论SOH和LOH。</p><h1 id="3234" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">小对象堆</h1><p id="a3a8" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这是一个大小小于85K的对象堆。SOH的垃圾收集涉及压缩。SOH是连续内存。压缩确保内存是连续的，即在垃圾收集期间，被标记为“使用中”的对象被移动到未被标记为“使用中”的对象的位置上。这样做的好处是内存碎片少。</p><p id="1a10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑以下SOH在垃圾收集前后的状态(红色的对象可用于收集)。观察SOH是如何被压缩以使分配连续的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lk"><img src="../Images/2ee4bc89e68ce0dac6043eaed6a3a35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yj9lR_i1u7xPzKCrVgo1yQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">SOH Compaction during garbage collection</figcaption></figure><h1 id="e8d5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">大型对象堆(LOH)</h1><p id="7531" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">超过85K的对象存储在这个堆中。由于性能影响，在垃圾收集期间不会压缩该堆。移动/复制大块内存需要大量的CPU时间。LOH跟踪表中的空闲和已用空间，并尝试将新对象分配到由收集的对象留下的最合适大小的空闲槽中。在下图中观察LOH中垃圾收集后内存中是如何出现漏洞的。释放的空间被记录在一个表中，并在分配下一个内存位置时使用。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ll"><img src="../Images/18e2d04920e60237d395bffbe964e106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svYnGwE3UIQDgu9tJOmhlg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">LOH garbage collection (no compaction)</figcaption></figure><h1 id="48fe" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分代垃圾收集</h1><p id="04bd" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们已经在垃圾收集中讨论过了。NET framework需要将所有必需的对象标记为“正在使用”，然后执行堆压缩。如果对象数量巨大，这可能会花费大量的处理时间。为了达到最佳效果。NET使用分代垃圾回收。</p><p id="9b81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数创建的对象都是短命的。通常，对象是在方法中创建的，一旦方法返回，这些对象就可供收集。这样的对象是短命的对象。此外，还有长寿命对象和中等寿命对象，它们是根据“使用中”的时间来分类的。。NET把他们分为三代。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lm"><img src="../Images/f1a387dcce6b43c6a5f00835756bdcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gd2ykp4DGv5Uw1bYNHLeg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">SOH (Gen 0, 1 and 2)</figcaption></figure><p id="be62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当发生以下任一情况时，GC会自动在单独的线程上运行</p><ul class=""><li id="b828" class="ln lo hh ig b ih ii il im ip lp it lq ix lr jb ls lt lu lv bi translated">第0代达到大约256 K(在这种情况下只进行第0代收集)</li><li id="8f1f" class="ln lo hh ig b ih lw il lx ip ly it lz ix ma jb ls lt lu lv bi translated">第1代达到大约2 MB(在这种情况下发生第0代和第1代收集)</li><li id="fb41" class="ln lo hh ig b ih lw il lx ip ly it lz ix ma jb ls lt lu lv bi translated">第2代达到大约10 MB(在这种情况下，会发生第0、1和2代收集)</li></ul><p id="a931" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意。NET会根据应用程序的行为修改上述阈值</p><h1 id="8634" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第0代</h1><p id="a0f0" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">当对象刚刚被创建时，它进入Gen 0。在每次GC操作之后，Gen 0被清空。因此，Gen 0中的对象总是新对象，不会被GC检查。当Gen 0的GC发生时，没有被使用的对象被释放，在收集中幸存的对象被移动到Gen 1。所以，最后，你在GC之后得到一个干净的Gen 0。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/f8ca042da0abb3b3d85ddc7b432e60c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CZGAGK7o-IYY8AKxYZ2Mg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Gen 0 garbage collection</figcaption></figure><p id="b923" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">观察使用中的对象(A、D和F)如何移动到Gen 1。Gen 0不干净，无法为新对象分配内存。</p><h1 id="8728" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第一代</h1><p id="9a45" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">第1代收集按顺序收集第1代和第0代。首先检查Gen 1，正在使用的对象被移动到Gen 2。然后，检查Gen 0，使用中的对象被移动到Gen 1。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/e47d24b4ea8fe85b255e9aa80d9b580f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmSp-Dfp1NKBitpqcWcq3A.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Gen 1 garbage collection</figcaption></figure><p id="098a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，G、J、D从第1代移到了第2代。n、Q、S从Gen 0移动到Gen 1。Gen 0是干净的。</p><h1 id="810b" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第二代</h1><p id="32b6" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">第2代收集被称为“完整收集”，因为它检查所有代。这是最贵的。太频繁的Gen 2收集会影响性能。</p><p id="8188" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意——值得指出的是，用于执行垃圾收集的实际算法只有。NET GC团队。</p><h1 id="8fd3" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="8dd0" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我试图对这些对象是如何存储、引用和清理的提出一些见解。我几乎不能触及表面，肯定还有很多要学的。我希望你喜欢它，它能帮助你写出更好的代码。</p><h1 id="30a8" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><p id="8a8b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">你可以在MSDN进一步了解内存管理。</p><p id="9d2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里还有一本克里斯·法雷尔<a class="ae js" href="https://www.red-gate.com/simple-talk/books/net-books/under-the-hood-of-net-memory-management/" rel="noopener ugc nofollow" target="_blank">写的精彩的书。网络内存管理</a></p></div></div>    
</body>
</html>