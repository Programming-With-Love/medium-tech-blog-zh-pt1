<html>
<head>
<title>Securing credentials in Fluentd configurations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Fluentd配置中保护凭据</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/securing-credentials-in-fluentd-configurations-c1971531d7e2?source=collection_archive---------0-----------------------#2022-06-07">https://medium.com/oracledevs/securing-credentials-in-fluentd-configurations-c1971531d7e2?source=collection_archive---------0-----------------------#2022-06-07</a></blockquote><div><div class="dt gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="19d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在配置<a class="ae jd" href="http://fluentd.org" rel="noopener ugc nofollow" target="_blank"> Fluentd </a>时，我们经常需要提供凭证来访问事件源、目标和相关服务，比如像<a class="ae jd" href="https://www.slack.com" rel="noopener ugc nofollow" target="_blank"> Slack </a>和<a class="ae jd" href="https://www.pagerduty.com/" rel="noopener ugc nofollow" target="_blank"> PagerDuty </a>这样的通知工具。挑战在于，我们不希望凭据在Fluentd配置中是明文形式。</p><p id="5049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么这可能与你有关？好吧，如果你正在使用K<a class="ae jd" href="https://www.oracle.com/uk/cloud/cloud-native/container-engine-kubernetes/" rel="noopener ugc nofollow" target="_blank">ubernetes Engine for Oracle(OKE)</a>，<a class="ae jd" href="https://www.oracle.com/uk/linux/verrazzano/" rel="noopener ugc nofollow" target="_blank"> Verrazano </a>，或者利用OCI非常适合更广泛地托管云原生解决方案这一事实，那么你很可能会遇到Fluentd(即使它提供了一种方法，将日志捕获作为边盘注入到容器中，并将日志泵送到OCI日志/日志分析)。</p><figure class="jf jg jh ji fe jj es et paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="es et je"><img src="../Images/bf26e1e2b340419dc19b8a4ae425037a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aZBtvIcFNSZZSfQi"/></div></div></figure><h1 id="4a11" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用环境变量</h1><p id="2dee" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在《使用Fluentd 登录操作》一书中，我们展示了如何从环境变量中获取敏感值，这样这些值就不会出现在配置文件中。然而，我们经常会遇到这样的问题，“这有多安全，环境变量不能被机器上的每个人看到吗？”</p><p id="0e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题的答案归结为对环境变量如何工作有更深的理解。这里有一个很好的解释<a class="ae jd" href="https://www.honeybadger.io/blog/ruby-guide-environment-variables/" rel="noopener ugc nofollow" target="_blank"/>。简而言之，环境变量只能被创建该变量的进程看到，任何子进程都会收到父进程变量的副本。</p><p id="c010" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，如果我们在一个shell中创建该变量，那么只有该shell和由该shell启动的任何进程可以看到该环境变量。因此，只要我们不将变量设置为系统级配置的一部分，我们就已经有了一定程度的安全性。因此，我们可以用一个设置所需环境变量的脚本来包装Fluentd的开始，然后一切都启动该脚本。</p><h1 id="b599" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">更好的方法？</h1><p id="25f1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">当然，脚本为环境变量设置了一个值，这个值是从哪里来的，这个脚本有多安全？对此有几种选择…</p><ul class=""><li id="141b" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">在由访问权限严格控制的配置文件中设置该值。因此，除非你作为一组特定的特权运行，否则你看不到这个变量。</li><li id="e170" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">注入来自外部世界的价值观——我们可以通过使用<a class="ae jd" href="https://kubernetes.io/docs/concepts/configuration/configmap/" rel="noopener ugc nofollow" target="_blank">配置图</a>与<a class="ae jd" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>合作来做到这一点。</li><li id="146f" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">通过访问存储敏感数据值(如凭据)的另一个源来创建间接层。通过使用能够禁止访问数据的秘密存储器。如果我们认为某个客户已经受到威胁，我们有办法更容易地切断访问。通过集中存储敏感细节，我们还可以更改凭据，应该能够获得凭据的每个人都可以从中受益。</li></ul><h1 id="3d33" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">合并金库</h1><p id="543c" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这后一种方法就是秘密管理者如<a class="ae jd" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp金库</a>、<a class="ae jd" href="https://www.conjur.org/" rel="noopener ugc nofollow" target="_blank">变戏法</a>或<a class="ae jd" href="https://docs.oracle.com/en-us/iaas/Content/KeyManagement/Concepts/keyoverview.htm" rel="noopener ugc nofollow" target="_blank"> OCI金库</a>等可以提供帮助的方法。你可以从Hashicorp <a class="ae jd" href="https://learn.hashicorp.com/tutorials/vault/getting-started-first-secret?in=vault/getting-started" rel="noopener ugc nofollow" target="_blank">这里</a>提供的一个简单例子中看出这一点。要了解这一点，第一步是安装Vault。为了方便起见(使用本书的演示示例)，我们将使用Hashicorp Vault的开源版本在本地运行设置的步骤。安装可以有多种不同的方式，我们已经使用<a class="ae jd" href="https://community.chocolatey.org/" rel="noopener ugc nofollow" target="_blank"> Chocolatey </a>进行了安装，但是也可以使用其他的包管理器。巧克力命令是<code class="dv lh li lj lk b">choco install vault</code>。</p><p id="37a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装好Vault后，我们用命令<code class="dv lh li lj lk b">vault server -dev</code>启动Vault。请注意，我们正在开发人员模式下运行Vault服务器。这样做简化了本练习的设置工作，不应该在生产用例中这样做。这将导致如下消息。请注意关于设置环境变量<strong class="ih hj"> VAULT_ADDR、</strong>的说明，我们需要设置第二个<strong class="ih hj"> VAULT_TOKEN </strong>来保存输出中包含的根令牌。</p><figure class="jf jg jh ji fe jj es et paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="es et ll"><img src="../Images/a5099c080a560d4b0c7f58f9dfe9beb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iMOwjfmkw4Xk6sjw"/></div></div></figure><p id="b62f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些变量需要在想要与Vault交互的每个shell中设置(回到我们关于小心使用环境变量和shell脚本的观点)。这些值是必需的，因为它们由Vault CLI和语言提供的SDK使用。值得注意的是，虽然这些值是“敏感的”,但您可能希望在客户机上运行的任何其他软件中重用它们。通过使Vault服务器中的令牌失效来切断客户端、以控制暴露内容的方式在服务器上配置机密以及与机密交互的权限，可以降低风险。</p><h1 id="4bf1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">储存秘密</h1><p id="37d0" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了演示这个过程，我们需要用一个秘密来初始化保险库——使用简单的KV(密钥值)存储机制，我们可以用命令<code class="dv lh li lj lk b">vault kv put secret/slack token=xoxb-735037803329-1110660446995-q6GrvjYukkzzYlBVJpzzigj7o</code>来完成这个操作。这个命令告诉保险库使用KV存储类型来创建一个名为<code class="dv lh li lj lk b">secret/slack</code>的名称空间，并添加一个密钥-值对，我的密钥名为<code class="dv lh li lj lk b">token</code>，在这种情况下，值就是本书第4章演示的Slack令牌。</p><p id="1384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用CLI来测试值的获取，使用命令<code class="dv lh li lj lk b"> vault kv get secret/creds</code>来检索结果。这将返回秘密和大量有用的元数据。幸运的是，我们可以添加一个额外的参数，通过包含<code class="dv lh li lj lk b">-field=token</code>来告诉CLI我们感兴趣的键，从而给出我们想要的值。完整的命令现在看起来像<code class="dv lh li lj lk b">vault kv get -field=passcode secret/creds</code>。</p><h1 id="551b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">如何将令牌检索纳入Fluentd</h1><p id="b184" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">要将该解决方案整合到我们的配置中，我们有几个选项:</p><ul class=""><li id="f7e4" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">使用Ruby SDK</li><li id="02cb" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">使用<a class="ae jd" href="https://curl.se/docs/manpage.html" rel="noopener ugc nofollow" target="_blank">curl</a>(CLI有一个很好的特性，可以将CLI指令翻译成最接近的curl等价物)</li><li id="e020" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">直接调用<a class="ae jd" href="https://www.vaultproject.io/docs/commands" rel="noopener ugc nofollow" target="_blank"> Vault CLI </a></li></ul><p id="95e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby代码可以在<a class="ae jd" href="https://github.com/hashicorp/vault-ruby" rel="noopener ugc nofollow" target="_blank">这里找到</a>——将代码合并到配置中是很混乱的，我们可以应用一些技巧使它变得更整洁。</p><p id="6ee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用命令行，比如<a class="ae jd" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank">curl</a>(CLI提供了一个方便的选项，可以显示相当于CLI调用的curl命令(将<code class="dv lh li lj lk b">-output-curl-string</code>添加到CLI中)。这有两个缺点，首先，CLI可以处理响应，为我们提取秘密的特定属性，CURL选项返回完整的响应。其次，HTTP头需要我们的认证令牌，这将把它放入配置文件的明文中。</p><p id="5e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，将CLI嵌入我们的Fluentd配置看起来是最干净的选择。这意味着我们可以从这样的配置开始:</p><pre class="jf jg jh ji fe lm lk ln lo aw lp bi"><span id="235c" class="lq jr hi lk b fj lr ls l lt lu">&lt;match *&gt; @type slack token xoxb-735037803329-1110660446995-q6GrvjYukkzzYlBVJpzzigj7o username unifiedfluent icon_emoji :ghost: # if you don't want to use icon_url, delete this param. channel demo message Node2 says - %s message_keys message title %s title_keys time flush_interval 1s time_key time &lt;/match&gt;</span></pre><p id="3777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于:</p><pre class="jf jg jh ji fe lm lk ln lo aw lp bi"><span id="197c" class="lq jr hi lk b fj lr ls l lt lu">&lt;match *&gt; @type slack token <strong class="lk hj"><em class="lv">"#{`vault kv get -field=token secret/slack`}"</em></strong> username unifiedfluent icon_emoji :ghost: # if you don't want to use icon_url, delete this param. channel demo message Node2 says - %s message_keys message title %s title_keys time flush_interval 1s time_key time &lt;/match&gt;</span></pre><p id="54e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面强调了最重要的变化，但让我们快速了解几个关键细节。首先，我们在这里要求Fluentd调用Ruby——用<code class="dv lh li lj lk b">"#{</code>表示，以<code class="dv lh li lj lk b"> }"</code>结尾。接下来，我们将利用这样一个事实，即当<a class="ae jd" href="https://docs.ruby-lang.org/en/2.0.0/Kernel.html#method-i-60" rel="noopener ugc nofollow" target="_blank"> Ruby </a>遇到一个反向滴答<code class="dv lh li lj lk b">` </code>时，它将使用一个子shell执行指令(重要的是，记住环境变量的关系)。CLI返回的字符串是所需的令牌。结果，Fluentd看到这条线路被解析为<code class="dv lh li lj lk b">token xoxb-735037803329-1110660446995-q6GrvjYukkzzYlBVJpzzigj7o</code>。</p><h1 id="19be" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为什么更好？</h1><p id="7a03" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这提供了一个很好的解决方案，因为我们在Fluentd的配置文件中没有任何凭证。如果我们怀疑值被劫持，我们可以指示服务器拒绝任何使用令牌的请求。我们有一个中央位置来管理我们的秘密，这使得处理密码轮换变得更加容易。客户机-服务器上保存的不同凭证的数量可以大大减少。虽然最后一步是特定于Fluentd的，但总体原则可以应用于许多场景。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="e42e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加入我们的<a class="ae jd" href="https://bit.ly/devrel_slack" rel="noopener ugc nofollow" target="_blank">公共开发者松弛频道</a>的讨论吧！</p></div></div>    
</body>
</html>