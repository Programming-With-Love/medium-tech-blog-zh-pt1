<html>
<head>
<title>Clasping the React Hooks — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">握紧反应钩—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/clasping-the-react-hooks-part-1-5d32af983d3a?source=collection_archive---------0-----------------------#2020-07-17">https://medium.com/globant/clasping-the-react-hooks-part-1-5d32af983d3a?source=collection_archive---------0-----------------------#2020-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c641a116731063d4c1efbe66122a9ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odUufQtKrwF_JTls"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">medium.com</figcaption></figure><p id="2b50" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我敢肯定，作为一名开发人员，到目前为止，你一定已经收藏了至少十几个网站来了解React Hooks。在您的项目中或作为POC实施。React钩子已经存在了很长时间了。所以，当然，你一定得了a！对吗？嗯，不完全是！事实上，大多数开发人员仍然对其实现感到困惑。</p><p id="93d8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在本文的多个部分，我已经尽了最大努力来解释和揭开React钩子的神秘面纱。所以，我从这里开始，保持沉迷！</p><h1 id="d755" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">但是为什么是钩子？</h1><figure class="kq kr ks kt fd ii er es paragraph-image"><div class="er es kp"><img src="../Images/2dfbabab9a543cc0e54f2cc16ccb85a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/0*C_XVzreU93BOLgQ3"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae ku" href="https://zbigatron.com/" rel="noopener ugc nofollow" target="_blank">https://zbigatron.com/</a></figcaption></figure><p id="9700" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">您是否曾经遇到过这样的情况:您正在使用功能组件，并且需要某种类型的行为更新，这可以通过组件状态轻松处理，但是由于功能组件内部的状态不可用，您最终将组件更新为类组件？</em></p><p id="12ec" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">你有没有经历过在不同的生命周期方法中重写类似的代码来实现道具或状态更新所需行为的痛苦？</em></p><p id="699e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">你经历过管理大量代码的痛苦和重用组件逻辑的困难吗？</em></p><p id="3602" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你是React开发人员，这些都是你每天必须面对的常见问题，不是吗？</p><p id="cb07" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">挺让人沮丧的吧？</em></p><p id="9173" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">如果我告诉你</em> <strong class="iv hi"> <em class="kv">钩子</em> </strong> <em class="kv">是把我们从所有这些问题中解救出来的东西。它让我们可以使用功能组件中的所有React特性，而不必将其更新为类组件。是不是很神奇？</em></p><h1 id="cc41" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">好吧，好吧，但是钩子是什么？😵</h1><figure class="kq kr ks kt fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/a8a2b9c9e81505442e601b0a5de45cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*bR2qpAOOTqgkpI5Iwd93Ag.jpeg"/></div></figure><p id="71a5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">根据React的官方文档:</p><blockquote class="kx ky kz"><p id="3e8f" class="it iu kv iv b iw ix iy iz ja jb jc jd la jf jg jh lb jj jk jl lc jn jo jp jq ha bi translated"><strong class="iv hi">钩子</strong>是React 16.8中新增的特性。它们允许您使用状态和其他React特性，而无需编写类。</p></blockquote><p id="f935" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，<strong class="iv hi"> React钩子</strong>是javascript函数，通过为我们提供使用React所有特性的特权，例如<strong class="iv hi">状态、副作用、可重用逻辑、生命周期、上下文、</strong>等，来解决我们在使用功能组件时遇到的各种问题。<strong class="iv hi">功能组件内部。</strong></p><p id="562b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">除此之外，钩子还让我们把所有相关的代码组织在一起，不像类组件，所有相关的代码通常保存在不同的生命周期方法中，很难理解。通过使用钩子，所有的生命周期方法都可以用一个钩子来代替，减少了代码的行数和复杂性，使我们的代码更具可读性。</p><p id="90a9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们稍后会更详细地了解这一点。</p><p id="0e89" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，由于钩子是常规的JavaScript函数，您可以将<strong class="iv hi">内置钩子</strong>与您自己的<strong class="iv hi">自定义钩子</strong>结合起来。</p><p id="221d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">定制钩子是我们可以创建来重用组件逻辑的东西。这使我们能够通过在应用程序中共享可重用的逻辑来降低复杂性。</p><h2 id="c32a" class="ld js hh bd jt le lf lg jx lh li lj kb je lk ll kf ji lm ln kj jm lo lp kn lq bi translated">引入钩子还有几个原因。其中一些列举如下:</h2><p id="01e5" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated"><strong class="iv hi"> <em class="kv">避免处理‘这个’关键词</em> </strong></p><p id="6e1a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要使用类，你必须理解<strong class="iv hi">‘this’</strong>关键字在javascript中的工作方式，这与它在其他语言中的工作方式非常不同。</p><p id="d0e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">人们可以在React中学习属性、状态和单向数据流，但很难实现类组件。</p><p id="0ace" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">功能组件中的<em class="kv">状态</em></strong></p><p id="6a74" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以前我们只能在<strong class="iv hi">类组件</strong>中使用状态。但是，有了<strong class="iv hi">钩子</strong>，我们现在可以使用<strong class="iv hi"> useState </strong>钩子在功能组件中使用状态。</p><p id="97a0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="kv">热重装带类</em> </strong></p><p id="3dc6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">还观察到<strong class="iv hi">类</strong>不能很好地缩小，使得<strong class="iv hi">热重装</strong>非常不可靠。因为你不再需要和类一起工作，所以你不会面临这些问题。</p><p id="eaa0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="kv">复用组件的逻辑</em> </strong></p><p id="3ba8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">定制钩子允许我们在不改变组件层次结构的情况下重用组件的逻辑。</p><p id="2346" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="kv">向后兼容</em> </strong></p><p id="e34d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">React钩子是100%向后兼容的，可以和我们现有的代码一起工作。如果您一直在使用React，并且一直在使用基于类的组件，那么不必急于转向钩子。钩子是可选的，在使用钩子时，你不必重写完整的代码，相反，你可以只对一些组件使用钩子。</p><blockquote class="kx ky kz"><p id="5616" class="it iu kv iv b iw ix iy iz ja jb jc jd la jf jg jh lb jj jk jl lc jn jo jp jq ha bi translated">但是，在开始使用钩子之前，有几件事情你应该记住——<strong class="iv hi">钩子不能用于类，你应该在处理功能组件的时候使用钩子。你应该在顶层调用钩子，这意味着不应该在循环、条件、嵌套函数等内部调用它</strong></p></blockquote><h1 id="c4d1" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">让我们从我们的第一个React钩子开始，试着用一些例子来理解它</h1><h1 id="6f25" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用状态挂钩</h1><p id="becd" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated">状态..！！好的，如果你已经处理过类组件，你必须熟悉<strong class="iv hi"> setState() </strong>，它安排组件状态的更新，当状态改变时，组件重新呈现。</p><p id="8313" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是我们不能在<strong class="iv hi">功能组件</strong>中有<strong class="iv hi">状态或setState() </strong>，这就是<strong class="iv hi"> useState </strong>钩子出现的地方。</p><p id="a954" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">❓❓怎么样</p><p id="9196" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">行..我们将看到一个使用<strong class="iv hi"> setState() </strong>的例子，然后我们将看到如何使用<strong class="iv hi"> useState </strong>钩子重写它。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/e96bd3c642dcdbad07fe0245afea6945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FPH7nPz7oVSChEkGSl-XYQ.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">cheezburger.com</figcaption></figure><p id="fac4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是一个计数器的例子，其中计数初始化为零，每次点击按钮，计数器的值增加1。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7b8948085d8be824c0a3ba9a01e57ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IihKHROqHm0d4Apy"/></div></div></figure><p id="0622" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的例子中，你可以看到，我们首先在构造函数中使用<strong class="iv hi"> this.state </strong>初始化了<strong class="iv hi"> count </strong>值，然后在单击按钮时我们调用了<strong class="iv hi"> setCount() </strong>方法来更新状态，并且在其中我们使用了<strong class="iv hi"> setState() </strong>方法来将计数值更新为<strong class="iv hi">current value+1</strong>；</p><p id="88b4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，我们可以使用<strong class="iv hi"> useState </strong>钩子重写上面的例子，如下所示</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e818618afa67cbb37c055ef417c5ada9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wb-tCy95C0gzT5zL"/></div></div></figure><p id="4afa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正如您在这里看到的，通过在功能组件中使用<strong class="iv hi"> useState </strong>函数，代码行已经减少了很多，现在可读性更好了。</p><p id="2711" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">同样在<strong class="iv hi">类</strong>中，状态总是一个对象，但是有了<strong class="iv hi">钩子</strong>，状态不一定是一个对象，它可以是任何类型。</p><p id="7008" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">语法:</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/c30feb77627c7a41caa6d69e7a8fb579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GtBrMCFmyb1dm0Yj"/></div></div></figure><blockquote class="kx ky kz"><p id="a12a" class="it iu kv iv b iw ix iy iz ja jb jc jd la jf jg jh lb jj jk jl lc jn jo jp jq ha bi translated">使用useState钩子<strong class="iv hi">状态的初始值，更新状态的方法，以及状态的当前值</strong>一切都可以写在一行代码中。<em class="hh"> <br/> </em>这种语法被称为<a class="ae ku" href="https://www.freecodecamp.org/news/array-destructuring-in-es6-30e398f21d10/" rel="noopener ugc nofollow" target="_blank"> <strong class="iv hi">数组析构</strong> </a>这是ES6的特性之一。</p></blockquote><h2 id="e4f4" class="ld js hh bd jt le lf lg jx lh li lj kb je lk ll kf ji lm ln kj jm lo lp kn lq bi translated">使用State的前一个值</h2><p id="d265" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated">有时我们需要访问状态的先前值来更新当前状态，这可以通过在先前的例子中向<strong class="iv hi"> useState </strong>传递一个函数来完成。这个函数将访问以前的值，并返回一个更新的值。</p><p id="4e3c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是一个计数器组件的例子，它使用useState钩子用状态的前一个值更新状态</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9fabd28235b3f5082b5b60b7eafe3a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMwDheQ-rcU8ZiIK"/></div></div></figure><h2 id="a75d" class="ld js hh bd jt le lf lg jx lh li lj kb je lk ll kf ji lm ln kj jm lo lp kn lq bi translated">对对象使用状态</h2><p id="ae59" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated">现在我们将看到另一个例子，当我们的状态是一个对象时，它使用了<strong class="iv hi"> useState钩子</strong>。让我们根据firstName和LastName字段中输入的值来打印一个人的全名。</p><p id="9829" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们将从状态中获取值，并在输入字段改变时更新它。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/91dbb23de73988b636d0f6df0f97dbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gW18XA7Rasi-ULtd"/></div></div></figure><p id="e3dc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的例子中，state对象包含firstName和lastName属性，一旦用户在输入字段中输入内容，这些值就会更新。</p><p id="71fb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，您可能已经注意到，我们在onChange函数中使用带有fullName的spread操作符来合并状态，即{…fullName}。这是因为与setState()不同，<strong class="iv hi"> useState钩子不会自动合并状态对象</strong>。因此，我们必须通过使用<strong class="iv hi">扩展操作符</strong>来进行<strong class="iv hi">手动合并</strong>，正如你在上面的例子中看到的。</p><blockquote class="kx ky kz"><p id="9353" class="it iu kv iv b iw ix iy iz ja jb jc jd la jf jg jh lb jj jk jl lc jn jo jp jq ha bi translated">当处理<strong class="iv hi">对象或数组</strong>时，一定要确保扩展你的状态变量，然后调用setter函数</p></blockquote><h1 id="7835" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用效果挂钩</h1><p id="dd10" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated"><strong class="iv hi"> useEffect </strong>钩子让我们在功能组件中执行副作用和生命周期方法的所有特性。</p><p id="5a3f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它还让我们将所有相关的代码组织在一起，不像类中所有相关的代码都保存在不同的生命周期方法中。</p><p id="1d46" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里有一个例子:</p><p id="b992" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">考虑将文档标题更新为当前的输入字段值，在初始渲染时，我们希望将标题设置为状态的初始值，所以这段代码放在<strong class="iv hi"> componentDidMount </strong>中，它将在组件生命周期中只执行一次，然后这个文档标题将在以后更新。</p><p id="f4ee" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为此，将在<strong class="iv hi"> componentDidUpdate中编写相同的代码。</strong>每次组件更新时都会调用这个生命周期方法，它非常适合更新文档标题。</p><p id="3a54" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，让我们看看计时器的另一个副作用，它在特定的时间间隔内记录一些字符串值，然后在卸载时清除它。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d832a42438ce68b1612c4484feb1bb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yPNXWBKd8wisAtq6"/></div></div></figure><p id="7139" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里你可以看到相同的代码在两个不同的生命周期方法中出现两次，不相关的代码也在一个生命周期方法中保存在一起。有点奇怪，对吧？</p><p id="257e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用<strong class="iv hi">使用效果挂钩</strong>可以解决这个问题。让我们看看怎么做。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/740d13d825bc23ea1c2e7d2de9d5b457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CAzkR9x7eAtpNYhC"/></div></div></figure><p id="364e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的例子中，你可以看到我们是如何用一个名为<strong class="iv hi"> useEffect </strong> Hook的函数取代了两个生命周期方法的使用。</p><p id="ba78" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在问题来了，是否可能在挂载期间只执行一次这个函数，如果我们想在只有特定属性/状态更新的情况下有条件地执行它呢？？答案是肯定的，有条件地执行是可能的。</p><p id="ee00" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了有条件地运行useEffect，我们需要传递一个额外的参数，它是一个数组。在这个数组中，我们指定需要监视的属性或状态。那么只有当这些状态或属性被更新时，这个函数才会被执行。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dd0df0502cf5d306ccf648bd1672606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XUh_pNfGRZlXnBaX"/></div></div></figure><p id="f356" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果只想在组件挂载上运行useEffect，可以传递一个空数组，而不是传递任何属性或状态。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/76c7c748a9047d70ddf185b9a647a173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Zta-Loe95LKrdfk"/></div></div></figure><p id="5266" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们已经看到如何用<strong class="iv hi"> useEffect </strong>钩子替换<strong class="iv hi">componentidmount()</strong>，<strong class="iv hi">componentiddupdate()</strong>。现在我们来看看如何使用<strong class="iv hi"> useEffect </strong>替换<strong class="iv hi"> componentWillUnmount() </strong>。</p><p id="a7b9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要使用useEffect钩子在组件卸载时执行任何操作，传递给useEffect的函数可以返回另一个函数，该函数将在组件卸载时执行。所以，我们返回的是一个清理函数。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d6710e8eab1818b755e17fce91e0f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sGBKrry4MeBBqSj5"/></div></div></figure><h2 id="44f4" class="ld js hh bd jt le lf lg jx lh li lj kb je lk ll kf ji lm ln kj jm lo lp kn lq bi translated">使用useEffect提取数据</h2><p id="78ef" class="pw-post-body-paragraph it iu hh iv b iw lr iy iz ja ls jc jd je lt jg jh ji lu jk jl jm lv jo jp jq ha bi translated">UseEffect挂钩也可以用于数据提取。下面是一个例子，其中useEffect函数使用Axios从API获取数据，在获取响应数据后，调用setData方法更新状态值。</p><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5504c2b407a555d03c8d9077de1b006b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FnK3-zMrI7qdW4xk"/></div></div></figure><blockquote class="kx ky kz"><p id="932e" class="it iu kv iv b iw ix iy iz ja jb jc jd la jf jg jh lb jj jk jl lc jn jo jp jq ha bi translated">到目前为止，在Effect Hook下，我们已经看到，我们实际上可以替换所有的生命周期方法，处理副作用并通过只使用<strong class="iv hi"> useEffect </strong>函数来执行数据获取。</p></blockquote><p id="9aad" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这几乎是React Hooks的第1部分！！</p><p id="297b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们总结一下到目前为止我们在这一部分看到的内容:</p><p id="226c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">- <em class="kv">什么是反应钩</em></p><p id="94d5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv">——为何推出</em></p><p id="3902" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv"> -我们如何使用钩子用功能组件替换类组件</em></p><p id="b478" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv"> -使用带有示例的状态挂钩</em></p><p id="e7b6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="kv"> -使用效果挂钩示例</em></p><p id="6fac" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我希望这篇文章能帮助你理解<strong class="iv hi"> React Hooks </strong>的一些基本概念。</p><p id="1090" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在接下来的部分中，我们将讨论:</p><ul class=""><li id="d4f2" class="lz ma hh iv b iw ix ja jb je mb ji mc jm md jq me mf mg mh bi translated">用户教育</li><li id="f1db" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">减速器与用户减速器</li><li id="2025" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">使用useReducer获取数据</li><li id="6b37" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">useRef</li><li id="5178" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">使用回调</li><li id="7ba8" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">使用备忘录</li><li id="e2e3" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">使用上下文</li><li id="a408" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">定制挂钩</li></ul><h1 id="e7d1" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">敬请关注即将推出的部分！！😌 👋</h1></div></div>    
</body>
</html>