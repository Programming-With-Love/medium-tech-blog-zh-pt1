<html>
<head>
<title>MAD Skills series: Hilt under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">疯狂技能系列:引擎盖下的剑柄</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/mad-skills-series-hilt-under-the-hood-9d89ee227059?source=collection_archive---------1-----------------------#2021-09-08">https://medium.com/androiddevelopers/mad-skills-series-hilt-under-the-hood-9d89ee227059?source=collection_archive---------1-----------------------#2021-09-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><div class=""><h2 id="5c5d" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">剑柄狂技能系列第三集</h2></div><p id="bb11" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是<a class="ae kd" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">剑柄</a>上的狂技能系列第三集！一定要看完<a class="ae kd" rel="noopener" href="/androiddevelopers/introduction-to-hilt-in-the-mad-skills-series-40f0908f2fc0">第1集</a>和<a class="ae kd" rel="noopener" href="/androiddevelopers/hilt-testing-best-practices-in-the-mad-skills-series-8186a57eee2c">第2集</a>。在这一集里，我们将深入探究希尔特是如何在引擎盖下工作的。</p><p id="382a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您喜欢以视频格式观看这些内容，请点击此处查看:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><h1 id="3518" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">涵盖的主题</h1><ul class=""><li id="ba51" class="lc ld hs jj b jk le jn lf jq lg ju lh jy li kc lj lk ll lm bi translated">各种刀柄注释如何一起工作来生成代码。</li><li id="53ee" class="lc ld hs jj b jk ln jn lo jq lp ju lq jy lr kc lj lk ll lm bi translated">Hilt Gradle插件如何在幕后工作，以提高使用Hilt和Gradle时的整体体验。</li></ul></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="c7aa" class="kk kl hs bd km kn lz kp kq kr ma kt ku iy mb iz kw jb mc jc ky je md jf la lb bi translated">各种刀柄注释如何一起工作来生成代码</h1><p id="0b60" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">Hilt使用注释处理器来生成代码。将源文件转换成java字节码时，注释处理发生在编译器内部。顾名思义，注释处理器是由源文件中的注释触发的。注释处理器通常检查注释和类型，以执行各种任务，如验证或生成新源。</p><p id="b912" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在《剑柄》中，三个最重要的注解是<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/AndroidEntryPoint.html" rel="noopener ugc nofollow" target="_blank">@AndroidEntryPoint</a></code>、<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/InstallIn.html" rel="noopener ugc nofollow" target="_blank">@InstallIn</a></code>和<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/HiltAndroidApp.html" rel="noopener ugc nofollow" target="_blank">@HiltAndroidApp</a></code>。</p><h1 id="7626" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">@ androdidentrypoint</h1><p id="e1db" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated"><code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/AndroidEntryPoint.html" rel="noopener ugc nofollow" target="_blank">AndroidEntryPoint</a></code>在您的Android类中启用字段注入，如活动、片段、视图和服务。</p><p id="fd25" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在下面的例子中，简单地用<code class="du mh mi mj mk b">AndroidEntryPoint</code>注释<code class="du mh mi mj mk b">PlayActivity</code>允许我们将音乐播放器注入到我们的活动中。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="c8b4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您正在使用Gradle，您可能熟悉上面显示的简化语法。然而，这个语法实际上只是由Hilt Gradle插件提供给你的语法糖。下面是关于Hilt Gradle插件的更多信息，但是现在让我们看看这个例子在没有语法糖的情况下会是什么样子。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="5d9e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在我们看到最初的基类<code class="du mh mi mj mk b"><a class="ae kd" href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatActivity" rel="noopener ugc nofollow" target="_blank">AppCompatActivity</a></code>实际上是<code class="du mh mi mj mk b">AndroidEntryPoint</code>注释的输入。这个<code class="du mh mi mj mk b">PlayActivity</code>本身实际上扩展了生成的类<code class="du mh mi mj mk b">Hilt_PlayActivity</code>。这个类是由Hilt的注释处理器生成的，包含了执行注入所需的所有逻辑。下面是生成的基类中代码的一个简化示例:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="5237" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个例子中，生成的类扩展了<code class="du mh mi mj mk b">AppCompatActivity</code>。然而，一般来说，它会扩展传递到<code class="du mh mi mj mk b">AndroidEntryPoint</code>注释中的任何类。这使得注入可以与您想要的任何基类一起工作。</p><p id="1b50" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个生成的类的主要目的是处理注入。重要的是尽早执行注射，以防止在注射前意外进入某个区域。因此，对于活动，注入发生在<code class="du mh mi mj mk b">onCreate</code>方法期间。</p><p id="8649" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在inject方法中，我们首先需要它的注入器的一个实例，<code class="du mh mi mj mk b">PlayActivity_Injector</code>。在Hilt中，活动的注入器是一个入口点，我们可以使用<code class="du mh mi mj mk b">EntryPoints</code>实用程序类获得注入器的实例。</p><p id="bf2f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可能已经猜到，<code class="du mh mi mj mk b">PlayActivity_Injector</code>也是由Hilt的注释处理器生成的。它将具有以下格式:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="e7b8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">生成的注入器是一个安装到<code class="du mh mi mj mk b">ActivityComponent</code>中的刀柄入口点。它包含一个方法，允许我们注入一个<code class="du mh mi mj mk b">PlayActivity</code>的实例。如果你曾经在Android应用程序中使用Dagger而没有使用Hilt，你很可能熟悉直接在组件上编写这些注入方法。</p><h1 id="4b03" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">@InstallIn</h1><p id="d36c" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated"><code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/InstallIn.html" rel="noopener ugc nofollow" target="_blank">InstallIn</a></code>用于指示模块或入口点应该安装到哪个组件中。在下面的例子中，我们已经将<code class="du mh mi mj mk b">MusicDataBaseModule</code>安装到了<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/components/SingletonComponent.html" rel="noopener ugc nofollow" target="_blank">SingletonComponent</a></code>中:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="e815" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用<code class="du mh mi mj mk b">InstallIn</code>，模块或入口点可以从应用程序的传递依赖关系中的任何地方贡献出来。然而，在某种程度上，我们需要收集所有的<code class="du mh mi mj mk b">InstallIn</code>贡献，以获得每个组件的全套模块和入口点。</p><p id="e6ad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Hilt在一个固定的包中生成一个元数据注释，使得收集和发现这些<code class="du mh mi mj mk b">InstallIn</code>贡献更加容易。生成的注释将具有以下格式:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="b1c8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过将元数据放入一个固定的包中，Hilt的处理器可以很容易地找到应用程序的所有可传递依赖项中生成的元数据。从那里，我们可以使用元数据注释中包含的信息来查找对<code class="du mh mi mj mk b">InstallIn</code>贡献本身的引用——在本例中是<code class="du mh mi mj mk b">MusicDatabaseModule</code>。</p><h1 id="77e6" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">HiltAndroidApp</h1><p id="7441" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">最后，<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/HiltAndroidApp.html" rel="noopener ugc nofollow" target="_blank">HiltAndroidApp</a></code>注释支持在您的Android应用程序类中注入。在这方面，你可以把它想成和<code class="du mh mi mj mk b">AndroidEntryPoint</code>注释一模一样。首先，用户只需要用<code class="du mh mi mj mk b">@HiltAndroidApp</code>注释他们的应用程序类。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="e7d3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">不过，<code class="du mh mi mj mk b">HiltAndroidApp</code>还有一个重要的功能——生成匕首组件。</p><p id="9288" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当Hilt注释处理器遇到<code class="du mh mi mj mk b">@HiltAndroidApp</code>时，它在一个包装类中生成一组组件，该包装类与应用程序类同名，前缀为<code class="du mh mi mj mk b">HiltComponents_</code>。如果您以前使用过Dagger，这些组件就是您通常会手工编写的<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/Component.html" rel="noopener ugc nofollow" target="_blank">@Component</a></code>和<code class="du mh mi mj mk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/Subcomponent.html" rel="noopener ugc nofollow" target="_blank">@Subcomponent</a></code>带注释的类。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/a9386aeb75c04a569e23a788aedec82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yRIvYb-fKOGFd_rm"/></div></div></figure><p id="4b95" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了生成这些组件，Hilt在上面描述的元数据包中查找所有带<code class="du mh mi mj mk b">@InstallIn</code>注释的类。<code class="du mh mi mj mk b">@InstallIn</code>模块放在相应组件声明的<code class="du mh mi mj mk b">modules</code>列表中。<code class="du mh mi mj mk b">@InstallIn</code>入口点作为相应组件声明的超类型放置。</p><p id="8fa0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从这里，Dagger处理器接管并从<code class="du mh mi mj mk b">@Component</code>和<code class="du mh mi mj mk b">@Subcomponent</code>注释生成组件实现。如果你曾经使用过无柄匕首，你可能会直接与这些职业互动。然而，Hilt向用户隐藏了这种复杂性。</p><p id="864d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为这篇博文是关于Hilt的，所以我们不会深入讨论Dagger生成的代码。然而，如果你感兴趣，你可以看看罗恩·夏皮罗和大卫·贝克的这个介绍，他们会带你了解细节。此外，你可以查看匕首代码101 的<a class="ae kd" href="http://goo.gle/dagger-codegen-cheatsheet" rel="noopener ugc nofollow" target="_blank">备忘单。</a></p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="931d" class="kk kl hs bd km kn lz kp kq kr ma kt ku iy mb iz kw jb mc jc ky je md jf la lb bi translated">刀柄梯度插件</h1><p id="fc38" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">既然你已经看到了代码生成在Hilt中是如何工作的，现在让我们来看看<a class="ae kd" href="https://dagger.dev/hilt/gradle-setup#hilt-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> Hilt Gradle插件</a>。Hilt Gradle插件执行许多有用的任务，包括字节码重写和类路径聚合。</p><h1 id="1155" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">字节码重写</h1><p id="a6cd" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">顾名思义，字节码重写就是重写字节码的过程。与只能生成新代码的注释处理不同，字节码重写可以重写现有的代码。如果谨慎使用，这个特性会非常强大。</p><p id="abd1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要了解我们为什么在Hilt中使用字节码重写，让我们回到<code class="du mh mi mj mk b">@AndroidEntryPoint</code>。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="3097" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然扩展<code class="du mh mi mj mk b">Hilt_PlayActivity</code>基类在实践中是可行的，但它会导致IDE出现问题。因为生成的类在成功编译代码之前是不存在的，所以您经常会在IDE中看到红色的曲线。此外，您将无法访问自动完成功能，例如重写方法，也无法访问基类中的方法。</p><p id="6d4d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些特征的丢失不仅会降低你的编码速度，而且所有这些红色的曲线也会使你很难集中注意力。</p><p id="905c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Hilt Android插件通过在你的<code class="du mh mi mj mk b">AndroidEntryPoint</code>类上启用字节码重写来拯救你。启用了Hilt Android插件，所有需要做的就是用<code class="du mh mi mj mk b">@AndroidEntryPoint</code>注释你的类，然后你就可以扩展你的普通基类了。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ml kj l"/></div></figure><p id="9f8a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为该语法不再引用生成的基类，所以IDE没有问题。在字节码重写过程中，Hilt Gradle插件会用生成的<code class="du mh mi mj mk b">Hilt_PlayActivity.</code>替换你的基类，因为这个过程直接发生在字节码中，对用户来说是不可见的。</p><p id="b1f5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，字节码重写也有一些缺点。</p><ul class=""><li id="2640" class="lc ld hs jj b jk jl jn jo jq mn ju mo jy mp kc lj lk ll lm bi translated">插件必须修改低级字节码，而不是源代码。这有点容易出错。</li><li id="2cba" class="lc ld hs jj b jk ln jn lo jq lp ju lq jy lr kc lj lk ll lm bi translated">因为字节码在重写发生时已经编译好了，所以任何问题通常都是在运行时而不是编译时出现的。</li><li id="1cd8" class="lc ld hs jj b jk ln jn lo jq lp ju lq jy lr kc lj lk ll lm bi translated">重写使调试变得复杂，因为当出错时，源文件可能不代表正在执行的字节码。</li></ul><p id="8b2e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">出于这些原因，Hilt尽量少依赖字节码重写。</p><h1 id="315a" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">类路径聚合</h1><p id="e9a1" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">最后，让我们看看Hilt Gradle插件的另一个有用的特性:类路径聚合。为了理解什么是类路径聚合以及为什么需要它，让我们看另一个例子。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/c9c086d00bce27458866011206fbabd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-fN79RB3HRY4Ikdl"/></div></div></figure><p id="0274" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个例子中，<code class="du mh mi mj mk b">:app</code>依赖于单个梯度模块<code class="du mh mi mj mk b">:database</code>，其中<code class="du mh mi mj mk b">:app</code>和<code class="du mh mi mj mk b">:database</code>都贡献了<code class="du mh mi mj mk b">InstallIn</code>模块。</p><p id="0355" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正如我们已经看到的，Hilt将在固定的<code class="du mh mi mj mk b">hilt_metadata</code>包中生成元数据，这些元数据将用于在生成组件时查找所有带<code class="du mh mi mj mk b">@InstallIn</code>注释的模块。</p><p id="aa45" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然这对于单级依赖关系很好，但是让我们看看当我们添加另一个Gradle模块<code class="du mh mi mj mk b">:cache</code>作为<code class="du mh mi mj mk b">:database</code>的依赖关系时会发生什么。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/0c20e6d5f68470dc34aa5e8d06ad4eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pv0wM_RlKMC5XdqA"/></div></div></figure><p id="b2e1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在编译<code class="du mh mi mj mk b">:cache</code>的时候，虽然会生成元数据，但是那个元数据在编译<code class="du mh mi mj mk b">:app</code>的时候是不可用的，因为它是一个可传递的依赖。因此，Hilt没有办法知道<code class="du mh mi mj mk b">CacheModule</code>，它会被意外地从生成的组件中排除。</p><p id="aac4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然您可以通过将<code class="du mh mi mj mk b">:cache</code>依赖项声明为<code class="du mh mi mj mk b">api</code>而不是<code class="du mh mi mj mk b">implementation</code>来从技术上解决这个问题，但是不推荐这样做。使用<code class="du mh mi mj mk b">api</code>不仅对于增量构建来说更糟糕，维护起来也是一场噩梦。</p><p id="4794" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就是柄Gradle插件来拯救。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/0819d0b285fb8f08f3551dc9c33282ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EYE8nLDGeiTJ9KgQ"/></div></div></figure><p id="eefb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">即使使用了<code class="du mh mi mj mk b">implementation</code>，Hilt Gradle插件也会自动聚集来自<code class="du mh mi mj mk b">:app</code>的可传递依赖的所有类。</p><p id="6d03" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此外，与直接使用<code class="du mh mi mj mk b">api</code>相比，Hilt Gradle插件也有很多好处。</p><p id="d991" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，与在整个应用程序中手动使用<code class="du mh mi mj mk b">api</code>进行依赖相比，类路径聚合更不容易出错，并且不需要维护。你可以像平常一样简单地使用<code class="du mh mi mj mk b">implementation</code>，剩下的就交给刀柄Gradle插件了。</p><p id="7810" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">第二，Hilt Gradle插件只在应用程序级别聚合类，所以与使用<code class="du mh mi mj mk b">api</code>不同，你的项目中库的编译不会受到影响。</p><p id="76a6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后，类路径聚合为依赖项提供了更好的封装，因为不可能在源文件中意外引用这些类，并且它们不会在代码完成中作为建议出现。</p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="7402" class="kk kl hs bd km kn lz kp kq kr ma kt ku iy mb iz kw jb mc jc ky je md jf la lb bi translated">结论</h1><p id="0cf3" class="pw-post-body-paragraph jh ji hs jj b jk le it jm jn lf iw jp jq me js jt ju mf jw jx jy mg ka kb kc ha bi translated">在这一集里，我们揭示了各种各样的刀柄注释是如何一起工作来生成代码的。我们还查看了Hilt Gradle插件，并了解了它如何使用字节码重写和类路径聚合来使使用Hilt更加安全和简单。</p><p id="8d22" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">感谢您的阅读，请关注更多疯狂技能集！</p></div></div>    
</body>
</html>