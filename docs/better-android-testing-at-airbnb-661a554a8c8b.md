# Airbnb 更好的 Android 测试——第 5 部分:测试架构

> 原文：<https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b?source=collection_archive---------3----------------------->

在我们 Airbnb Android 测试系列的第五部分，我们仔细看看我们的集成测试框架的架构。

![](img/b95103e169151c369915a766b4a3ee16.png)

在本系列的[前几期](/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8)中，我们展示了我们的状态模拟系统，以及我们如何在其上构建 UI 集成测试。在本文中，我们将深入探讨系统是如何构建的，如何进行空闲检测，以及如何优雅地处理错误。

这包括相当数量的实现深度，目标是提供足够的细节，以便其他人可以重新创建一个类似的系统，同时避免我们遇到的许多麻烦。

# 测试框架的架构

我们的集成测试是用 Espresso 运行的，但是在上面构建了一个相当复杂的测试工具。这是因为我们需要能够轻松地设置片段，操纵它们的视图，并拆除它们，这很难通过直接的 Espresso API 来完成。我们在测试中也没有使用普通的 JUnit 或 Espresso 断言，而是截取屏幕截图，以编程方式点击视图层次结构，并上传报告文件。

# 利用基础活动

我们使用一个自定义活动(名为***IntegrationTestActivity***)来运行测试，它位于我们应用程序的库模块中。这使得它可以在测试过程中直接操作片段。该模块作为一个测试依赖项包含在内，所以它不会交付到生产环境中。

在 JUnit 端，一个单独的测试启动了***IntegrationTestActivity***，其中一个片段名作为额外的字符串。活动使用片段名称来反射性地访问为该片段声明的模拟。然后，该活动运行所有的模拟，设置每个模拟，对其应用一些动作(比如截屏)，然后拆除它并继续下一个。处理完所有模拟后，活动会清理自己，并将其 IdlingResource 标记为空闲。

***IntegrationTestActivity***是一个抽象类，负责管理模拟。它还覆盖了所有的活动函数，以防止它们被测试中的片段调用(正如在[上一篇关于交互测试的文章](/p/1d1e91e489b4)中提到的)。子类简单地实现一个函数来在 mock 上运行验证，比如截图或者执行交互测试。

例如，我们获取每个片段模拟截图的活动就是下面的代码。

类似地，我们的交互测试活动是另一个简单的子类。

请注意，它们如何利用模拟框架来消费处于模拟状态的每个片段，而不必担心设置片段、等待视图稳定、拆除 UI 或集成测试中通常固有的任何其他繁琐工作。

此外，我们可以非常容易地创建新的子类来处理这些模拟以及我们可能想要进行的任何其他检查。

# 运行测试活动

当其中一个活动运行时，JUnit 测试等待并监听活动何时完成，以便 JUnit 可以完成测试。这是通过在 IntegrationTestActivity 的模块中声明的自定义 Espresso IdlingResource 实现的。JUnit 测试和活动就是通过这个空闲来进行通信的。

Idler 在定制的 JUnit TestRule 中注册了 Espresso，我们利用 Espresso 来等待它。通常这是通过调用视图断言来完成的，但是因为我们不使用 Espresso 断言，所以我们通过调用***Espresso . onidle()***来明确地告诉 Espresso 等待空闲者。

在 JUnit 端，我们的测试大致如下:

注意每个片段的测试声明是如何成为一行的。稍后您将看到我们如何为每个片段自动生成这个。

回顾一下，这种单一活动托管方法的优势在于:

*   直接操作截图和交互测试的片段和视图
*   阻塞对活动的函数调用，比如 ***结束*** ，这样被测试的片段就不会无意中影响测试框架
*   通过一个通用基类提供模拟的片段，该基类可以根据特定的测试需求而被子类化

然而，这种方法也存在一些挑战，需要一些复杂性来解决。

# 空闲检测

通常情况下，Espresso 会自动处理空闲检测。例如，Espresso ViewAssertion 调用会等到 UI 空闲时再进行断言。在我们的自定义测试活动中，我们没有通过 Espresso 进行断言，也没有访问 Espresso 的底层 API 来获得 idle 上的回调。

然而，***IntegrationTestActivity***需要显示一个片段，并可靠地知道它何时被完全布局，以便我们的测试可以在其上运行。这意味着我们需要构建自己的空闲检测实现。这很棘手，原因如下:

*   考虑异步运行代码的所有来源就像玩打地鼠游戏，如果一个特性运行测试工具不知道的定制异步代码，这甚至是不可能的
*   不考虑所有的异步代码会导致测试不完整
*   过度防御，等待太久，会不必要地延长测试时间，甚至让测试超时

幸运的是，我们的任务被简化了，因为我们的片段数据被完全模拟出来了。我们不需要担心等待网络请求或数据库查询。我们只需要确保等待任何可能影响 UI 的事情。

最重要的一点是等待主线程空闲，因为这是处理 UI 更新的过程。方便的是，Handler 公开了一个 API 来允许我们这样做！

***Handler()looper . queue . isidle***

我们可以简单地轮询这个函数，直到队列空闲。然而，这种方法有一个问题。当最后一个 Runnable 仍在运行时，处理程序的队列可能会报告空闲。也就是说，一个 runnable 被出队然后运行，所以我们可以知道队列什么时候是空的，但是不知道最后一个 Runnable 是否已经完成运行。

相反，我们将自己的 Runnable 发送给处理程序，当它运行时，我们检查队列是否为空。这让我们可以在检查队列状态之前刷新队列。一个基本的方法是这样的:

这传达了基本的想法，但是应该添加一些东西来使它为生产做好准备:

*   HandlerIdleDetector 内部的 post 循环必须在完成后取消，以避免它无限期地继续下去
*   当我们等待空闲时，可以使用回调系统和协程来优雅地休眠，而不是轮询
*   如果活套从不空闲，可以添加超时系统以提供更可靠的错误消息
*   这不能在一个循环中包含的线程上运行，因为它们会在同一线程上竞争运行
*   通常，仅仅等到所有线程都空闲是不够的。值得注意的是，一些视图更新，如动画，被提交到下一个动画帧。确保所有活套至少空闲一帧时间(约 16 毫秒)。

我们还在 UI 中广泛使用 Epoxy，它在后台线程上做一些处理。事实上，recycle view 设置使用异步线程来处理不同的 recycle view 更改是很常见的，因此这将是许多人的常见用例。我们构建了我们的空闲检测来获取一个要监视的循环列表，并在它们都空闲时返回。这使得向列表中添加新线程变得容易。

对这种方法的一个警告是，任何通过*发送到稍后时间的*都不被考虑(Espresso 也不能考虑这些)。为了防止这些碎片，我们不允许这些调用出现在我们的片段中。如果一个片段需要延迟一个 Runnable(主要是为了动画的目的),那么我们有一个实用函数来包装这个调用，在测试构建中强制延迟为零。**

# **错误处理**

**如果一个测试抛出了一个异常，我们的目标(作为测试框架的创建者)是尽可能简单明了地向最终开发人员展示这个异常。开发人员不应该去挖掘日志，理解测试框架中的代码，或者在理解崩溃的根本原因时处理任何开销。我们已经做了一些事情来让他们更容易。**

**首先，如果主线程发生崩溃，比如在某个异步任务中，那么测试运行程序通常会报告一条通用消息:**

> **测试未能运行完成。原因:“由于进程崩溃，检测运行失败。”。有关详细信息，请查看设备日志**

**这是没有帮助的，并且强迫开发者做额外的工作。相反，我们使用一个测试规则为所有线程注册一个默认的异常处理程序，包括 RxJava 和协程。该处理程序将异常传递给主线程，以便 Espresso 能够处理它，并正确地将错误显示为测试失败消息。**

**即使提供了正确的错误消息，如果没有抛出时发生了什么的上下文，工程师可能很难调试它。一个测试可以覆盖许多模拟，所以很难判断哪个模拟正在被测试。人们可以深入研究测试日志，但是我们想让这变得更容易。例如，我们可以提供关于片段上设置了哪个 mock 的信息，哪个视图被点击了，或者任何其他关于测试框架在抛出异常时正在做什么的相关信息。**

**为了实现这一点，我们维护了一个表示“测试上下文”的字符串堆栈。框架可以将任何字符串压入堆栈，并在该阶段结束时弹出。例如，堆栈可能有以下两个字符串:**

*   **为 BookingFragment 加载了“失败状态”**
*   **点击“book_button”视图**

**然后，由于我们已经有了一个捕捉抛出异常的系统，我们可以包装这些异常以向开发人员提供我们的上下文。**

**这些技术使得开发人员更容易解决代码中的错误，并且更加独立。作为测试框架的维护者，这对于减少我直接收到消息帮助某人调试测试失败的次数是很重要的。**

**我们的错误处理方法的最后一部分涉及到失败是如何出现在 Github 的 PR 上的。这将在后面关于 CI 的文章中详细讨论。**

# **接下来:持续嘲笑的障碍**

**本文详细介绍了我们的测试框架的实现、我们遇到的问题，以及我们为使系统健壮和可伸缩而做出的设计决策。**

**在下一篇文章中，我们将看看测试框架可能不可靠的常见原因，以及我们如何从根本上解决它们。**

## **系列索引**

**这是关于 Airbnb 测试的七篇系列文章。**

**第 1 部分— [测试理念和模拟系统](/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a)**

**第 2 部分— [使用 MvRx 和 Happo 进行截图测试](/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab)**

**第 3 部分— [自动化交互测试](/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4)**

**第 4 部分— [单元测试框架视图模型](/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8)**

****第 5 部分(本文)** — [我们的自动化测试框架的架构](/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b)**

**第 6 部分— [持续嘲讽的障碍](/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f)**

**第 7 部分— [测试生成和 CI 配置](/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f)**

## **我们在招人！**

**想和我们一起在这些和其他大规模的 Android 项目上合作吗？Airbnb 正在全公司招聘几个 Android 工程师职位！有关当前空缺，请参见[https://careers.airbnb.com](https://careers.airbnb.com/)。**