<html>
<head>
<title>Dependency Injection Implementation in Core Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心Java中的依赖注入实现</h1>
<blockquote>原文：<a href="https://medium.com/globant/dependency-injection-implementation-in-core-java-fe9729f8ae27?source=collection_archive---------1-----------------------#2021-01-12">https://medium.com/globant/dependency-injection-implementation-in-core-java-fe9729f8ae27?source=collection_archive---------1-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fcc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在不使用任何框架的情况下，在核心Java中实现自己的轻量级依赖注入</p><p id="bee8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">概述</strong></p><p id="f4ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文将指导您理解并使用自己的依赖注入实现构建一个轻量级Java应用程序。</p><p id="8ad4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">依赖注入……DI……控制反转……IoC，我想你可能在日常工作或特别的面试准备时间听到这些名字很多次了，以至于你想知道它到底是什么。</p><p id="b43b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是如果你真的想了解它内部是如何工作的，那么请继续阅读这里。</p><p id="90b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"/>这篇文章的“目的”只是根据我在springboot和java的经验，让你更容易理解DI如何在springboot内部工作，而不是和springboot中的DI进行比较。</p><p id="7942" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">那么，什么是依赖注入呢？</strong></p><p id="032e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">依赖注入是一种用于实现IoC的设计模式。依赖关系)由框架创建和分配。</p><p id="d582" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用DI特性，一个类及其实例变量只需要添加框架预定义的注释。</p><p id="56cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">依赖注入模式包括3种类型的类。</p><ul class=""><li id="4f29" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi">客户端类:</strong>客户端类(依赖类)依赖于服务类。</li><li id="f15c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi">服务类:</strong>为客户端类提供服务的服务类(依赖类)。</li><li id="c093" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi">注入器类:</strong>注入器类将服务类对象注入到客户端类中。</li></ul><p id="9750" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样，DI模式将创建服务类对象的责任从客户机类中分离出来。下面是DI中使用的几个术语。</p><ul class=""><li id="3700" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi">接口</strong>定义客户端如何使用服务。</li><li id="067d" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi">注入</strong>指的是将一个依赖(一个服务)传递到对象(一个客户端)，这也被称为自动连线。</li></ul><p id="a904" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">那么，什么是控制反转呢？</strong></p><p id="71fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，“不要打电话给我们，我们会打电话给你。”</p><ul class=""><li id="e157" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">控制反转(IoC)是一种设计原则。它用于反转不同种类的控件(即对象创建或依赖对象创建和绑定)来实现松耦合。</li><li id="6209" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">依赖注入是实现IoC的方法之一。</li><li id="5c97" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">IoC有助于将任务的执行与实现分离。</li><li id="bb50" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">IoC帮助它将一个模块集中在它被设计的任务上。</li><li id="1423" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">IoC可防止更换模块时出现副作用。</li></ul><p id="63a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">DI设计模式类图</strong></p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/ad0df26c05e536641a85e9538fd7ec82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVD9rTzyPPSbYfNXEp717g.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Class Diagram of Dependency Injection Design Pattern</figcaption></figure><p id="3aad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的类图中，需要UserService和AccountService对象的客户端类没有直接实例化UserServiceImpl和AccountServiceImpl类。</p><p id="69b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，注入器类创建对象并将它们注入客户端，这使得客户端独立于对象的创建方式。</p><p id="236b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">依赖注入的类型</strong></p><ul class=""><li id="7298" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi">构造器注入:</strong>注入器提供服务(依赖)</li><li id="dbc4" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">通过客户端类构造函数。在这种情况下，自动连线注释添加在构造函数上。</li><li id="f912" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi">属性注入:</strong>注入器通过客户端类的公共属性提供服务(依赖)。在这种情况下，在成员变量声明时添加了自动连线注释。</li><li id="a559" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi"> Setter方法注入:</strong>客户端类实现一个接口，该接口声明提供服务(依赖)的方法，注入器使用该接口向客户端类提供依赖。</li></ul><p id="2251" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，Autowired注释添加了while方法声明。</p><p id="a8f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">它是如何工作的？</strong></p><p id="602d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要理解依赖注入实现，请参考这里的代码片段。</p><p id="835b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">先决条件</strong></p><p id="9d1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更好地理解本教程，最好提前了解注释和反射的基本知识。</p><p id="f946" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">需要添加到类路径中的java库:</strong></p><p id="7a1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开始编码步骤之前，您可以在eclipse或其他IDE中创建新的“maven项目”,并将下面的配置复制到pom.xml</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="b6dd" class="kl km hh kh b fi kn ko l kp kq"><strong class="kh hi">Note: <br/>      </strong>to reflect below config below configuration please follow   <br/>      below steps.<br/>      <br/>      Right click on your project -&gt; Maven -&gt; Update Project</span></pre><p id="a588" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> pom.xml </strong></p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="b120" class="kl km hh kh b fi kn ko l kp kq">&lt;project  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><span id="2e29" class="kl km hh kh b fi kr ko l kp kq">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>    &lt;groupId&gt;temp&lt;/groupId&gt;<br/>    &lt;artifactId&gt;com.di&lt;/artifactId&gt;<br/>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><span id="73bc" class="kl km hh kh b fi kr ko l kp kq">     &lt;properties&gt;<br/>       &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    <br/>       &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br/>     &lt;/properties&gt;<br/>  <br/>     &lt;dependencies&gt;<br/>        &lt;dependency&gt;<br/>        &lt;groupId&gt;org.reflections&lt;/groupId&gt;<br/>        &lt;artifactId&gt;reflections&lt;/artifactId&gt;<br/>        &lt;version&gt;0.9.9-RC1&lt;/version&gt;<br/>        &lt;scope&gt;compile&lt;/scope&gt;<br/>     &lt;/dependency&gt;</span><span id="6f70" class="kl km hh kh b fi kr ko l kp kq">     &lt;!-- other dependencies --&gt;<br/>    &lt;/dependencies&gt;<br/>&lt;/project&gt;</span></pre><p id="bcfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，DI实现必须提供预定义的注释，这些注释可以在声明客户端类和客户端类中的服务变量时使用。</p><p id="c044" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们添加客户端和服务类可以使用的基本注释:</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="2b3e" class="kl km hh kh b fi kn ko l kp kq"><strong class="kh hi">CustomComponent.java</strong></span><span id="6bc6" class="kl km hh kh b fi kr ko l kp kq">import java.lang.annotation.*;</span><span id="37d0" class="kl km hh kh b fi kr ko l kp kq">/** Client class should use this annotation */</span><span id="c05e" class="kl km hh kh b fi kr ko l kp kq">@Retention(RetentionPolicy.RUNTIME)<br/>@Target(ElementType.TYPE)<br/>public @interface CustomComponent {<br/>}</span><span id="69c6" class="kl km hh kh b fi kr ko l kp kq"><strong class="kh hi">CustomAutowired.java</strong></span><span id="50cc" class="kl km hh kh b fi kr ko l kp kq">import java.lang.annotation.*;<br/>import static java.lang.annotation.ElementType.*;<br/>import static java.lang.annotation.RetentionPolicy.RUNTIME;</span><span id="2fe4" class="kl km hh kh b fi kr ko l kp kq">/** Service field variables should use this annotation */</span><span id="a600" class="kl km hh kh b fi kr ko l kp kq">@Target({ METHOD, CONSTRUCTOR, FIELD })<br/>@Retention(RUNTIME)<br/>@Documented<br/>public @interface CustomAutowired {<br/>}</span><span id="61cb" class="kl km hh kh b fi kr ko l kp kq"><strong class="kh hi">CustomQualifier.java</strong></span><span id="d553" class="kl km hh kh b fi kr ko l kp kq">import java.lang.annotation.*;</span><span id="1492" class="kl km hh kh b fi kr ko l kp kq">/**<br/> * Service field variables should use this annotation<br/> * This annotation Can be used to avoid conflict if there are     <br/> * multiple implementations of the same interface   <br/> */</span><span id="3851" class="kl km hh kh b fi kr ko l kp kq">@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE,<br/>  ElementType.ANNOTATION_TYPE })<br/>@Retention(RetentionPolicy.RUNTIME)<br/>@Inherited<br/>@Documented<br/>public @interface CustomQualifier {<br/>String value() default "";<br/>}</span><span id="47f4" class="kl km hh kh b fi kr ko l kp kq"><strong class="kh hi">CustomApplication.java</strong></span><span id="4d41" class="kl km hh kh b fi kr ko l kp kq">/**<br/>* Client class should use this annotation<br/>*/<br/>import java.lang.annotation.*;<br/>import java.lang.annotation.RetentionPolicy;</span><span id="3efc" class="kl km hh kh b fi kr ko l kp kq">@Retention(RetentionPolicy.RUNTIME)<br/>@Target(ElementType.TYPE)<br/>public @interface  CustomApplication {<br/>}</span></pre><h1 id="3624" class="ks km hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">服务接口</h1><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="d98f" class="kl km hh kh b fi kn ko l kp kq"><strong class="kh hi">UserService.java</strong></span><span id="56a1" class="kl km hh kh b fi kr ko l kp kq">public interface UserService {<br/>String getUserName();<br/>}</span><span id="4509" class="kl km hh kh b fi kr ko l kp kq"><strong class="kh hi">AccountService.java</strong></span><span id="19ad" class="kl km hh kh b fi kr ko l kp kq">public interface AccountService {<br/>     Long getAccountNumber(String userName);<br/>}</span></pre><p id="86de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">服务实现类:</strong></p><p id="38e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些类实现服务接口并使用DI注释。</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="a1fa" class="kl km hh kh b fi kn ko l kp kq"><strong class="kh hi">UserServiceImpl.java</strong></span><span id="8ab0" class="kl km hh kh b fi kr ko l kp kq">@CustomComponent<br/>public class UserServiceImpl implements UserService {<br/>   @Override<br/>   public String getUserName() {<br/>     return "shital.devalkar";<br/>   }<br/>}</span><span id="9537" class="kl km hh kh b fi kr ko l kp kq"><strong class="kh hi">AccountServiceImpl.java</strong></span><span id="1fab" class="kl km hh kh b fi kr ko l kp kq">@CustomComponent<br/>public class AccountServiceImpl implements AccountService {<br/>     @Override<br/>     public Long getAccountNumber(String userName) {<br/>       return 12345689L;<br/>     }<br/>}</span></pre><p id="6c05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">客户端类别:</strong></p><p id="7f05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用DI特性，客户端类必须使用DI框架为客户端和服务类提供的预定义注释。</p><p id="602a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">ClientApplication.java</strong></p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="a144" class="kl km hh kh b fi kn ko l kp kq">/** Client class, havin userService and accountService <br/> * expected to initialized by CustomInjector.java<br/> */</span><span id="9e7a" class="kl km hh kh b fi kr ko l kp kq">@CustomComponent<br/>public class ClientApplication {<br/>  @CustomAutowired<br/>  private UserService userService;<br/>    <br/>  @CustomAutowired<br/>  @CustomQualifier(value = "accountServiceImpl")<br/>  private AccountService accountService;</span><span id="8c5c" class="kl km hh kh b fi kr ko l kp kq">  public void displayUserAccount() {<br/>    String username = userService.getUserName();<br/>    Long accountNumber = accountService.getAccountNumber(username);<br/>    System.out.println("\nUser Name: " + username <br/>    + " Account Number: " + accountNumber);<br/>  }<br/>}</span></pre><p id="baef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">喷油器等级:</strong></p><p id="0311" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">CustomInjector类是DI框架中的主要角色。因为它负责创建所有客户端的实例和客户端类中每个服务的autowire实例。</p><p id="cbb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">该类创建实例和注入依赖关系的步骤</strong>:</p><ol class=""><li id="ef8f" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb lp ji jj jk bi translated">扫描根包和所有子包下的所有客户端</li><li id="7b0c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">创建客户端类的实例。</li><li id="1da3" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">扫描客户端类中使用的所有服务(成员变量、构造函数参数、方法参数)</li><li id="febb" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">递归地扫描服务本身内部声明的所有服务(嵌套依赖)</li><li id="7eee" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">为步骤3和步骤4返回的每个服务创建实例</li><li id="f9f3" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">Autowire:注入(即。初始化)具有在步骤5创建的实例的每个服务</li><li id="6ae4" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">创建映射所有客户端类的映射<class object=""/></li><li id="5ffc" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">公开API以获取get bean(Class clasz)/get service(Class classz)。</li><li id="127f" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">验证接口是有多个实现还是没有实现</li><li id="774a" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb lp ji jj jk bi translated">在多个实现的情况下，按类型处理服务或自动连线的限定符。</li></ol><p id="dc9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">喷射器类中需要的实用程序类:</strong></p><p id="8b45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类大量使用java.lang.reflect.Field提供的基本方法。</p><p id="121a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类中的autowire()方法是递归方法，因为它负责注入服务类中声明的依赖关系。(即。嵌套依赖关系)</p><p id="21a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【InjectionUtil.java T2】号</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="27a7" class="kl km hh kh b fi kn ko l kp kq">import java.util.*;<br/>import java.util.Map.Entry;<br/>import java.lang.reflect.Field;<br/>import java.util.stream.Collectors;<br/>import javax.management.RuntimeErrorException;</span><span id="eccd" class="kl km hh kh b fi kr ko l kp kq">public class InjectionUtil {<br/> /**<br/>  * Perform injection recursively, for each service inside <br/>  * the client class<br/>  */<br/> public static void autowire(Class&lt;?&gt; classz, <br/>   Object classInstance, Map&lt;Class&lt;?&gt;, Object&gt; applicationScope,<br/>   Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; diMap) <br/>    throws InstantiationException, IllegalAccessException {<br/>  Set&lt;Field&gt; fields = findFields(classz);</span><span id="024b" class="kl km hh kh b fi kr ko l kp kq">for (Field field : fields) {<br/>   String qualifier = <br/>      field.isAnnotationPresent(CustomQualifier.class)<br/>     ? field.getAnnotation(CustomQualifier.class).value() : null;</span><span id="0819" class="kl km hh kh b fi kr ko l kp kq">Object fieldInstance = getBeanInstance(field.getType(), diMap, <br/>       applicationScope, field.getName(), qualifier);<br/>   field.set(classInstance, fieldInstance);<br/>   <br/>   autowire(fieldInstance.getClass(), <br/>     fieldInstance, applicationScope, diMap);<br/>  }<br/> }</span><span id="c239" class="kl km hh kh b fi kr ko l kp kq">/**<br/>  * Overload getBeanInstance to handle qualifier and autowire <br/>  * by type<br/>  */<br/> public static &lt;T&gt; Object getBeanInstance(Class&lt;T&gt; interfaceClass, <br/>   Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; diMap,<br/>   Map&lt;Class&lt;?&gt;, Object&gt; applicationScope, String fieldName,<br/>   String qualifier)<br/>   throws InstantiationException, IllegalAccessException {<br/>  <br/>   Class&lt;?&gt; implementationClass = <br/>     getImplimentationClass(interfaceClass, diMap, <br/>     fieldName, qualifier);</span><span id="a0d4" class="kl km hh kh b fi kr ko l kp kq">if(applicationScope.containsKey(implementationClass)){<br/>    return applicationScope.get(implementationClass);<br/>   }<br/>  <br/>   Object service = implementationClass.newInstance();<br/>   applicationScope.put(implementationClass, service);<br/>   return service;<br/> }</span><span id="d9ef" class="kl km hh kh b fi kr ko l kp kq">/**<br/> * Get the name of the implimentation class for input<br/> * interface service<br/> */<br/> private static Class&lt;?&gt; getImplimentationClass(Class&lt;?&gt; <br/>   interfaceClass, Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; diMap,<br/>   String fieldName, String qualifier) {<br/>    Set&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; implementationClasses = <br/>      diMap.entrySet().stream()<br/>     .filter(entry -&gt; entry.getValue() == interfaceClass)      <br/>     .collect(Collectors.toSet());<br/>   <br/>    String errorMessage = "";<br/>    if(implementationClasses == null || <br/>     implementationClasses.isEmpty()) {<br/>      errorMessage = "no implementation found for interface " <br/>                    + interfaceClass.getName();<br/>    }else if(implementationClasses.size() == 1) {<br/>      Optional&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; optional = <br/>      implementationClasses.stream().findFirst(); <br/> <br/>      if(optional.isPresent()) {<br/>        return optional.get().getKey();<br/>      }<br/>    }else if(implementationClasses.size() &gt; 1) {  <br/>      final String findBy = (qualifier == null || <br/>      qualifier.trim().length() == 0) ? fieldName : qualifier;</span><span id="632d" class="kl km hh kh b fi kr ko l kp kq">      Optional&lt;Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;&gt; optional = <br/>        implementationClasses.stream().filter(entry -&gt; <br/>        entry.getKey().getSimpleName()<br/>       .equalsIgnoreCase(findBy)).findAny();<br/>   <br/>      if(optional.isPresent()) {<br/>        return optional.get().getKey();<br/>      }else{<br/>        errorMessage = "There are " + implementationClasses.size() <br/>         + " of interface " + interfaceClass.getName()<br/>         + " Expected single implementation or make use of " <br/>         + "<a class="ae lq" href="http://twitter.com/CustomQualifier" rel="noopener ugc nofollow" target="_blank">@CustomQualifier</a> to resolve conflict";<br/>      }<br/>    }<br/>    throw new RuntimeErrorException(new Error(errorMessage));<br/>  }</span><span id="1616" class="kl km hh kh b fi kr ko l kp kq">/**<br/>  * Get all the fields having CustomAutowired annotation used<br/>  * while declaration<br/> */<br/> private static Set&lt;Field&gt; findFields(Class&lt;?&gt; classz) {<br/>   Set&lt;Field&gt; set = new HashSet&lt;&gt;();<br/>   while (classz != null) {<br/>     for (Field field : classz.getDeclaredFields()) {<br/>       if(field.isAnnotationPresent(CustomAutowired.class)) {<br/>          field.setAccessible(true);<br/>          set.add(field);<br/>       }<br/>     }<br/>     classz = classz.getSuperclass();<br/>    }<br/>   return set;<br/> }<br/>}</span></pre><p id="0e11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【ClassLoaderUtil.java T4】</p><p id="3eca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类使用java.io.File获取输入包名称的根目录和子目录下的java文件，并使用java.lang.ClassLoader提供的基本方法获取所有类的列表。</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="8b9b" class="kl km hh kh b fi kn ko l kp kq">import java.io.*;<br/>import java.util.*;<br/>import java.net.URL;</span><span id="4671" class="kl km hh kh b fi kr ko l kp kq">public class ClassLoaderUtil {<br/> <br/> /** Get all the classes for the input package */<br/> public static Class&lt;?&gt;[] getClasses(String packageName) throws   <br/>    ClassNotFoundException, IOException {<br/>    ClassLoader classLoader =    <br/>    Thread.currentThread().getContextClassLoader();<br/>    assert classLoader != null;<br/>    String path = packageName.replace('.', '/');<br/>    Enumeration&lt;URL&gt; resources = classLoader.getResources(path);<br/>    List&lt;File&gt; dirs = new ArrayList&lt;&gt;();<br/>   <br/>    while(resources.hasMoreElements()){<br/>      URL resource = resources.nextElement();<br/>      dirs.add(new File(resource.getFile()));<br/>    }</span><span id="6259" class="kl km hh kh b fi kr ko l kp kq">    List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();<br/>    for(File directory : dirs) {<br/>      classes.addAll(findClasses(directory, packageName));<br/>    }<br/>    return classes.toArray(new Class[classes.size()]);<br/> }</span><span id="6579" class="kl km hh kh b fi kr ko l kp kq"> /** Get all the classes for the input package, inside the input    <br/>  * directory<br/>  */<br/> public static List&lt;Class&lt;?&gt;&gt; findClasses(File directory, <br/>   String packageName) throws ClassNotFoundException {<br/>   List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();<br/>   if (!directory.exists()) {<br/>      return classes;<br/>   }</span><span id="9c5c" class="kl km hh kh b fi kr ko l kp kq">    File[] files = directory.listFiles();<br/>    for (File file : files) {<br/>      if(file.isDirectory()) {<br/>        assert !file.getName().contains(".");<br/>        classes.addAll(findClasses(file, packageName + "." + <br/>        file.getName()));<br/>      }else if(file.getName().endsWith(".class")) {<br/>        String className = packageName + '.' +    <br/>        file.getName().substring(0, file.getName().length() - 6);<br/>        classes.add(Class.forName(className));<br/>      }<br/>    }<br/>    return classes;<br/>  }<br/>}</span></pre><p id="6bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">CustomInjector.java</strong></p><p id="514e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类大量使用java.lang.Class和org.reflections.Reflections提供的基本方法。</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="888d" class="kl km hh kh b fi kn ko l kp kq">import java.util.*;<br/>import java.io.IOException;<br/>import org.reflections.Reflections;</span><span id="7727" class="kl km hh kh b fi kr ko l kp kq">/**<br/> * Injector, to create objects for all <a class="ae lq" href="http://twitter.com/CustomService" rel="noopener ugc nofollow" target="_blank">@CustomService</a> classes<br/> *   autowire/inject all dependencies<br/> */<br/>public class CustomInjector {<br/>  private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; diMap;<br/>  private Map&lt;Class&lt;?&gt;, Object&gt; applicationScope;</span><span id="db57" class="kl km hh kh b fi kr ko l kp kq">  public CustomInjector() {<br/>    super();<br/>    diMap = new HashMap&lt;&gt;();<br/>    applicationScope = new HashMap&lt;&gt;();<br/>  }</span><span id="11a6" class="kl km hh kh b fi kr ko l kp kq">  public &lt;T&gt; T getService(Class&lt;T&gt; classz) {<br/>     try{<br/>       return this.getBeanInstance(classz);<br/>     }catch (Exception e) {<br/>       e.printStackTrace();<br/>     }<br/>    return null;<br/>  }</span><span id="7391" class="kl km hh kh b fi kr ko l kp kq">  /** initialize the injector framework */<br/>  public void initFramework(Class&lt;?&gt; mainClass)<br/>   throws InstantiationException, IllegalAccessException,    <br/>    ClassNotFoundException, IOException{<br/>  Class&lt;?&gt;[] classes = <br/>     ClassLoaderUtil.getClasses(mainClass.getPackage().getName());<br/>  Reflections reflections = new <br/>    Reflections(mainClass.getPackage().getName());</span><span id="374e" class="kl km hh kh b fi kr ko l kp kq">  Set&lt;Class&lt;?&gt;&gt; types = <br/>   reflections.getTypesAnnotatedWith(CustomComponent.class);<br/>  <br/> for (Class&lt;?&gt; implementationClass : types){<br/>   Class&lt;?&gt;[] interfaces = implementationClass.getInterfaces();</span><span id="5283" class="kl km hh kh b fi kr ko l kp kq">   if (interfaces.length == 0) {<br/>      diMap.put(implementationClass, implementationClass);<br/>   } else{<br/>     for (Class&lt;?&gt; iface : interfaces) {<br/>       diMap.put(implementationClass, iface);<br/>     }<br/>   }<br/> }</span><span id="94cd" class="kl km hh kh b fi kr ko l kp kq"> for (Class&lt;?&gt; classz : classes) {<br/>   if(classz.isAnnotationPresent(CustomComponent.class)) {<br/>      Object classInstance = classz.newInstance();<br/>      applicationScope.put(classz, classInstance);<br/>      InjectionUtil.autowire(classz, classInstance, <br/>      applicationScope, diMap);<br/>     }<br/>   }<br/> }</span><span id="e3a6" class="kl km hh kh b fi kr ko l kp kq">/**<br/>  * Create and Get the Object instance of the implementation <br/>  * class for input interface service<br/>  */<br/> <a class="ae lq" href="http://twitter.com/SuppressWarnings" rel="noopener ugc nofollow" target="_blank">@SuppressWarnings</a>("unchecked")<br/> private &lt;T&gt; T getBeanInstance(Class&lt;T&gt; interfaceClass) throws <br/>   InstantiationException, IllegalAccessException {<br/>   return (T) InjectionUtil.getBeanInstance(interfaceClass, <br/>     diMap, applicationScope, null, null);<br/>  }<br/>}</span></pre><p id="1fbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">DIApplication.java</strong></p><p id="81f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类扫描在主类上有@CustomApplication注释的主类，如果这个注释出现在主类上，那么就要注意依赖注入，否则主类将像常规的主java类一样工作</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="a978" class="kl km hh kh b fi kn ko l kp kq">public class DIApplication {<br/>  private final CustomInjector injector;<br/>  public DIApplication() {<br/>  super();<br/>  this.injector = new CustomInjector();<br/>}</span><span id="b2f5" class="kl km hh kh b fi kr ko l kp kq"> public void run(Class&lt;?&gt; mainClassz) {<br/>    boolean hasCustomApplicationAnnotation =<br/>      mainClassz.isAnnotationPresent(CustomApplication.class);</span><span id="7bfc" class="kl km hh kh b fi kr ko l kp kq">if(hasCustomApplicationAnnotation) {<br/>     System.out.println("Starting CustomDemoApplication...");<br/>     this.startApplication(mainClassz);<br/>     this.injector    <br/>      .getService(ClientApplication.class).displayUserAccount();<br/>     System.out.println("\nStopping CustomDemoApplication...");<br/>   }else{<br/>     System.out.println("\nRunning as regular java Application...");<br/>   }<br/> }</span><span id="fc0b" class="kl km hh kh b fi kr ko l kp kq"> /**<br/>  * Start application<br/>  * @param mainClass<br/>  */<br/>  public void startApplication(Class&lt;?&gt; mainClass) {<br/>    try {<br/>      synchronized (DIApplication.class) {<br/>       this.injector.initFramework(mainClass);<br/>        System.out.println("\nCustomDemoApplication Started....");<br/>      }<br/>    }catch (Exception ex) {<br/>      ex.printStackTrace();<br/>    }<br/>  }</span><span id="99c4" class="kl km hh kh b fi kr ko l kp kq">  public static void run(Class&lt;?&gt; mainClassz, String[] args){<br/>     new DIApplication().run(mainClassz);<br/>  }<br/>}</span></pre><p id="18ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">应用主类… </strong>最后但不是列表！！！</p><pre class="jr js jt ju fd kg kh ki kj aw kk bi"><span id="97e4" class="kl km hh kh b fi kn ko l kp kq"><strong class="kh hi">MainApplicationClass.java</strong></span><span id="320b" class="kl km hh kh b fi kr ko l kp kq">@CustomApplication<br/>public class MainApplicationClass {<br/>   public static void main(String[] args) {      <br/>      DIApplication<br/>     .run(MainApplicationClass.class, args);<br/>  }<br/>}</span></pre><p id="5a9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是与spring添加的依赖项的对比。</p><p id="c3a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.春季启动依赖项:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es lr"><img src="../Images/9491f2857d4433600617b6f776358583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CyvoqiaT59vKKC8p.png"/></div></div></figure><p id="022b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.此实现中的依赖关系:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ls"><img src="../Images/a67ef7b5e384e3d2bdc7570f851fe995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*15wotwa32tcXskok.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Create User-Defined Annotations:</figcaption></figure><p id="2a5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="7465" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文将清楚地介绍DI或autowire依赖项是如何工作的。</p><p id="415c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了你自己的DI框架的实现，你就不需要像Spring Boot那样笨重的框架了。如果你真的没有在你的应用程序中使用大部分的by Spring Boot或者任何DI框架特性，比如Bean生命周期管理方法执行和更多的东西。</p><p id="4b46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以做很多这里没有提到的事情，通过为各种目的添加更多的用户定义的注释，例如像bean作用域singleton、prototype、request、session、global-session，以及许多类似于Spring framework提供的特性。</p><p id="3d5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢您花时间阅读本文，我希望这能让您清楚地了解如何使用依赖注入及其内部工作。</p></div></div>    
</body>
</html>