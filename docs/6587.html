<html>
<head>
<title>When data access is the easiest part of a microservice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当数据访问是微服务中最简单的部分时</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/when-data-access-is-the-easiest-part-of-a-microservice-c7a90dee701a?source=collection_archive---------4-----------------------#2019-02-21">https://medium.com/quick-code/when-data-access-is-the-easiest-part-of-a-microservice-c7a90dee701a?source=collection_archive---------4-----------------------#2019-02-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6fa1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">角。KillrVideo Python项目系列之五</h2></div><p id="a1d8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列的前几篇文章中，我一直在分享我构建<a class="ae js" href="http://killrvideo.github.io" rel="noopener ugc nofollow" target="_blank"> KillrVideo </a>微服务层的Python实现的经验。在之前的帖子中，我分享了<a class="ae js" rel="noopener" href="/datadriveninvestor/killrvideo-python-pt-1-the-backstory-5c38191fb330">为什么我开始这个项目</a>，关于<a class="ae js" rel="noopener" href="/@jscarp/python-app-dev-with-protobuf-and-grpc-e5bff779783d">构建GRPC服务存根</a>，在<code class="du jt ju jv jw b">etcd</code>中公布端点，以及<a class="ae js" rel="noopener" href="/@jscarp/who-needs-unit-tests-im-building-microservices-4c8fe40d7095">设置集成测试</a>来测试服务API。</p><p id="965d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以在实现任何业务逻辑或数据访问代码之前，用了四篇文章来描述所有的设置！所有这些工作让我想知道，相比之下，其他工作是否会更容易。</p><p id="43a5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章是关于使用Cassandra查询语言(CQL)编写业务逻辑和读写数据到DataStax Enterprise (DSE)的。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es jx"><img src="../Images/031ee3ae1b4460f09266cb7488757021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*JVWEq-xpNw5LyIFZI6IH4A.png"/></div></figure><h1 id="9212" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">商业逻辑？什么商业逻辑？</h1><p id="eaae" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">事实证明，KillrVideo服务层中确实没有多少业务逻辑可言。该系统的早期版本允许通过上传服务上传真实的视频文件，当然有更有趣的业务逻辑。</p><p id="b17c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，在目前的情况下，大多数业务逻辑都是验证代码。有几个位置使用提供的输入完成少量工作，例如:</p><ul class=""><li id="5e09" class="lc ld hh iy b iz ja jc jd jf le jj lf jn lg jr lh li lj lk bi translated">视频目录服务中的<code class="du jt ju jv jw b">AddYouTubeVideo</code>操作从添加到系统的YouTube视频的URL推断出视频预览图像的位置。</li><li id="520a" class="lc ld hh iy b iz ll jc lm jf ln jj lo jn lp jr lh li lj lk bi translated">将密码转换为md5哈希值，并比较哈希密码字符串以支持用户登录，就像在用户管理服务中一样</li></ul><h1 id="776a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">数据访问代码—不费吹灰之力！(大部分)</h1><p id="f343" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">正如我在上一篇文章中提到的，我为Python服务遵循的过程是按照<a class="ae js" href="https://github.com/KillrVideo/killrvideo-integration-tests" rel="noopener ugc nofollow" target="_blank">killrvideo-integration-tests</a>暗示的顺序实现服务操作，从用户管理服务开始。我将带您了解用户管理服务是如何实现的，因为其他服务也遵循相同的基本模式。</p><h2 id="e3bd" class="lq kg hh bd kh lr ls lt kl lu lv lw kp jf lx ly kr jj lz ma kt jn mb mc kv md bi translated">安装驱动程序</h2><p id="6316" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">第一步是安装DataStax Enterprise Python驱动程序:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="39d1" class="lq kg hh jw b fi mi mj l mk ml">pip install dse-driver</span></pre><p id="2cc3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们为Cassandra(不是DSE)使用DataStax Python驱动程序，我们将安装<code class="du jt ju jv jw b">cassandra-driver</code>。然而，出于KillrVideo的目的，我们知道我们打算在几个服务中使用DSE功能，特别是搜索服务的DSE Search和建议视频服务的DSE Graph。KillrVideo文档网站上有一个<a class="ae js" href="https://killrvideo.github.io/docs/guides/feature-matrix/" rel="noopener ugc nofollow" target="_blank">特性矩阵，详细描述了DSE特性在实现语言中的用法。</a></p><h2 id="e09d" class="lq kg hh bd kh lr ls lt kl lu lv lw kp jf lx ly kr jj lz ma kt jn mb mc kv md bi translated">初始化群集和会话对象</h2><p id="efa2" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">为了向Cassandra (DSE)读写数据，我们需要初始化驱动程序，建立到集群的连接。我们通过驱动程序提供的<code class="du jt ju jv jw b">Cluster</code>和<code class="du jt ju jv jw b">Session</code>类来实现这一点，你可以在文档的<a class="ae js" href="https://datastax.github.io/python-driver/getting_started.html" rel="noopener ugc nofollow" target="_blank">入门页</a>中读到。</p><p id="ffd4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于我已经选择在单个应用程序中实现所有的KillrVideo服务，所以我将连接逻辑放在应用程序的<code class="du jt ju jv jw b"><a class="ae js" href="https://github.com/KillrVideo/killrvideo-python/blob/master/killrvideo/__init__.py" rel="noopener ugc nofollow" target="_blank">__init__.py</a></code>文件中:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="f4c6" class="lq kg hh jw b fi mi mj l mk ml"><strong class="jw hi">from </strong>dse.cluster <strong class="jw hi">import </strong>Cluster, ExecutionProfile, EXEC_PROFILE_DEFAULT<br/><strong class="jw hi">from </strong>dse <strong class="jw hi">import </strong>ConsistencyLevel<br/><strong class="jw hi">import </strong>dse.cqlengine.connection</span><span id="20c8" class="lq kg hh jw b fi mm mj l mk ml"><strong class="jw hi">def </strong>serve():<br/><br/>    file = open(<strong class="jw hi">'config.json'</strong>, <strong class="jw hi">'r'</strong>)<br/>    config = json.load(file)</span><span id="bfaa" class="lq kg hh jw b fi mm mj l mk ml">    contact_points = config[<strong class="jw hi">'CONTACT_POINTS'</strong>]<br/>    default_consistency_level = config[<strong class="jw hi">'DEFAULT_CONSISTENCY_LEVEL'</strong>]<br/><br/>    <em class="mn"># Wait for Cassandra (DSE) to be up, aka registered in etcd</em><br/><br/>    <em class="mn"># Initialize Cassandra Driver and Mapper<br/>    </em>profile = ExecutionProfile(consistency_level = <br/>        ConsistencyLevel.name_to_value[default_consistency_level])<br/>    cluster = Cluster(contact_points=contact_points, <br/>                execution_profiles={EXEC_PROFILE_DEFAULT: profile})<br/>    session = cluster.connect(<strong class="jw hi">"killrvideo"</strong>)<br/>    dse.cqlengine.connection.set_session(session)</span></pre><p id="993d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">(注意:为了简洁起见，省略了与初始化驱动程序没有直接关联的代码。)</p><p id="c60d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如您可能已经注意到的，我已经选择将与驱动程序相关的配置值放在一个JSON配置文件中(基于一篇关于用Python进行配置的各种方法的<a class="ae js" href="https://hackernoon.com/4-ways-to-manage-the-configuration-in-python-4623049e841b" rel="noopener ugc nofollow" target="_blank">有用文章</a>)。JSON配置文件非常简单，如下所示:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="cd1c" class="lq kg hh jw b fi mi mj l mk ml">{<br/>  <strong class="jw hi">"CONTACT_POINTS"</strong>: [<strong class="jw hi">"10.0.75.1"</strong>],<br/>  <strong class="jw hi">"DEFAULT_CONSISTENCY_LEVEL"</strong>: <strong class="jw hi">"LOCAL_QUORUM"<br/></strong>}</span></pre><p id="26f4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稍微解一下这个连接代码，第一条语句创建了一个<code class="du jt ju jv jw b"><a class="ae js" href="https://datastax.github.io/python-driver/execution_profiles.html" rel="noopener ugc nofollow" target="_blank">ExecutionProfile</a></code>,我们可以在其中配置设置，比如重试和负载平衡策略。这里我使用一个<code class="du jt ju jv jw b">ExecutionProfile</code>来设置KillrVideo应用程序中查询的默认一致性级别:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="68a5" class="lq kg hh jw b fi mi mj l mk ml">profile = ExecutionProfile(consistency_level = <br/>                ConsistencyLevel[default_consistency_level])</span></pre><p id="08dd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一步是使用<code class="du jt ju jv jw b">ExecutionProfile</code>创建一个<code class="du jt ju jv jw b"><a class="ae js" href="https://datastax.github.io/python-driver/api/cassandra/cluster.html" rel="noopener ugc nofollow" target="_blank">Cluster</a></code>对象:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="6e49" class="lq kg hh jw b fi mi mj l mk ml">cluster = Cluster(contact_points=contact_points, <br/>                execution_profiles={EXEC_PROFILE_DEFAULT: profile})</span></pre><p id="5fa1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们创建一个绑定到我们的<code class="du jt ju jv jw b">killrvideo</code>键空间的<code class="du jt ju jv jw b">Session</code>对象。这是因为KillrVideo服务使用的所有表都在同一个键空间中:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="2f11" class="lq kg hh jw b fi mi mj l mk ml">session = cluster.connect(<strong class="jw hi">"killrvideo"</strong>)</span></pre><p id="a8f9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们初始化<code class="du jt ju jv jw b">cqlengine</code>，它是作为DataStax Python驱动的一部分提供的映射器。正如我们将看到的，<code class="du jt ju jv jw b">cqlengine</code>并不适合我们应用程序中需要的每一种数据访问模式，但在许多情况下已经足够了，我尽可能使用它，因为它提供了简单性。</p><h2 id="474f" class="lq kg hh bd kh lr ls lt kl lu lv lw kp jf lx ly kr jj lz ma kt jn mb mc kv md bi translated">创建映射器类</h2><p id="8595" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">为了使用映射器，我们需要一些类来定义映射到Cassandra表的类型。为了与<a class="ae js" href="https://www.oreilly.com/ideas/cassandra-data-modeling" rel="noopener ugc nofollow" target="_blank">围绕我们的应用查询</a>建模Cassandra表的原则保持一致，有两个表用于存储数据，它们被设计为支持我们将在下面讨论的查询。</p><p id="b1cd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为我们的Cassandra表建模的实体类在文件<code class="du jt ju jv jw b"><a class="ae js" href="https://github.com/KillrVideo/killrvideo-python/blob/master/killrvideo/user_management/user_management_service.py" rel="noopener ugc nofollow" target="_blank">user_management_service.py</a></code>中定义:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="8bd1" class="lq kg hh jw b fi mi mj l mk ml">from dse.cqlengine import columns<br/>from dse.cqlengine.models import Model</span><span id="62d5" class="lq kg hh jw b fi mm mj l mk ml"><strong class="jw hi">class </strong>UserModel(Model):<br/>    <em class="mn">"""Model class that maps to the user table"""<br/>    </em>__table_name__ = <strong class="jw hi">'users'<br/>    </strong>user_id = columns.UUID(db_field=<strong class="jw hi">'userid'</strong>, primary_key=True)<br/>    first_name = columns.Text(db_field=<strong class="jw hi">'firstname'</strong>)<br/>    last_name = columns.Text(db_field=<strong class="jw hi">'lastname'</strong>)<br/>    email = columns.Text()<br/>    created_date = columns.Date()<br/><br/><br/><strong class="jw hi">class </strong>UserCredentialsModel(Model):<br/>    <em class="mn">"""Model class that maps to the user_credentials table"""<br/>    </em>__table_name__ = <strong class="jw hi">'user_credentials'<br/>    </strong>email = columns.Text(primary_key=True)<br/>    user_id = columns.UUID(db_field=<strong class="jw hi">'userid'</strong>)<br/>    password = columns.Text()</span></pre><p id="f665" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个实体类都扩展了<code class="du jt ju jv jw b">dse.cqlengine.models.Model</code>类。您会注意到使用了<code class="du jt ju jv jw b">__table_name__</code>属性来指定我们正在使用的Cassandra表(我们已经在上面指定了映射器正在使用的键空间)。我们通过引用来自<code class="du jt ju jv jw b">dse.cqlengine.columns</code>模块的适当类型，为每个表列定义一个类属性。注意使用<code class="du jt ju jv jw b">primary_key</code>标识来标识Cassandra主键列。这些表不涉及任何聚类键，但是<code class="du jt ju jv jw b">clustering_key</code>名称也可以用来描述这些键。最后要注意的一点是使用了<code class="du jt ju jv jw b">db_field</code>名称，它允许我们拥有一个符合Python命名约定但与CQL列名略有不同的属性名。</p><h2 id="49ba" class="lq kg hh bd kh lr ls lt kl lu lv lw kp jf lx ly kr jj lz ma kt jn mb mc kv md bi translated">使用映射器插入数据</h2><p id="9819" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">按照集成测试顺序，在用户管理服务中执行的第一个操作是<code class="du jt ju jv jw b">create_user</code>。注意，我们需要插入到两个不同的表中来支持我们的访问模式:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="0f39" class="lq kg hh jw b fi mi mj l mk ml"><em class="mn"># insert into user_credentials table first so we can ensure uniqueness with LWT<br/></em><strong class="jw hi">try</strong>:<br/>    UserCredentialsModel.if_not_exists().create(user_id=user_id, email=email, password=hashed_password)<br/><strong class="jw hi">except </strong>LWTException:<br/>    <em class="mn"># Exact string in this message is expected by integration test<br/>    </em><strong class="jw hi">raise </strong>ValueError(<strong class="jw hi">'Exception creating user because it already exists for ' </strong>+ email)<br/><br/><em class="mn"># insert into users table<br/></em>UserModel.create(user_id=user_id, first_name=first_name, last_name=last_name, email=email)</span></pre><p id="5f17" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">处理这种插入的一种方法是使用Cassandra的批处理特性。然而，这里有一个额外的关注点，即确保我们执行唯一性，不允许多个用户帐户使用同一个电子邮件。我们在这里使用的逻辑是首先尝试使用轻量级事务在<code class="du jt ju jv jw b">user_credentials</code>表中为用户创建一条记录——这就是<code class="du jt ju jv jw b">if_not_exists()</code>操作正在做的事情。如果帐户创建是针对一个新的电子邮件地址，插入将会成功，我们可以继续插入到<code class="du jt ju jv jw b">users</code>表中。否则，将引发一个错误。</p><p id="e7d8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个插入的实际符号非常简单，使用从<code class="du jt ju jv jw b">Model</code>类继承的<code class="du jt ju jv jw b">create()</code>操作，并通过名称为每个列指定一个值。</p><h2 id="ef10" class="lq kg hh bd kh lr ls lt kl lu lv lw kp jf lx ly kr jj lz ma kt jn mb mc kv md bi translated">使用映射器检索数据</h2><p id="4434" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">接下来是实现检索用户帐户数据的方法的时候了。我们的应用程序需要的第一个查询用于支持<code class="du jt ju jv jw b">verify_credentials</code>操作中的登录:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="706a" class="lq kg hh jw b fi mi mj l mk ml"><em class="mn"># retrieve the credentials for provided email from user_credentials table<br/></em>user_credentials = UserCredentialsModel.get(email=email)</span></pre><p id="ed0e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个非常简单的查询——我们根据表的分区键——电子邮件地址，从<code class="du jt ju jv jw b">user_credentials</code>表中检索一条记录。然后，我们可以散列所提供的密码，并将其与从数据库中检索到的散列密码进行比较，以实施安全登录。</p><p id="16fd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第二个查询用于获得关于一个或多个用户账户的信息。因为服务的API允许通过用户ID查找多个帐户，所以我们使用了<code class="du jt ju jv jw b">UserModel</code>类的<code class="du jt ju jv jw b"><a class="ae js" href="# see: https://datastax.github.io/python-driver/cqlengine/queryset.html#retrieving-objects-with-filters" rel="noopener ugc nofollow">filter()</a></code>操作，而不是<code class="du jt ju jv jw b">get()</code>:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="aad3" class="lq kg hh jw b fi mi mj l mk ml"><em class="mn"># filter().all() returns a ModelQuerySet, we iterate over the query set to get the Model instances<br/></em>user_results = UserModel.filter(user_id__in=user_ids).all()<br/>users = list()<br/><strong class="jw hi">for </strong>user <strong class="jw hi">in </strong>user_results:<br/>    users.append(user)<br/><strong class="jw hi">return </strong>users</span></pre><p id="702b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意追加到列名的符号<code class="du jt ju jv jw b">__in</code>的使用表明我们希望使用CQL <code class="du jt ju jv jw b">IN</code>子句。映射器会将其转换成如下所示的查询:</p><pre class="jy jz ka kb fd me jw mf mg aw mh bi"><span id="5717" class="lq kg hh jw b fi mi mj l mk ml">SELECT * FROM killrvideo.users WHERE user_id IN &lt;id1&gt;, &lt;id2&gt;...</span></pre><p id="aed6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们可以迭代结果，构建一个用户帐户信息列表返回给客户端。</p><p id="b456" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，我们也可以遍历提供的用户id并执行单个的<code class="du jt ju jv jw b">get()</code>操作，但是通过使用<code class="du jt ju jv jw b">in</code>操作，我们可以一次查询多个分区键。</p><p id="6915" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为KillrVideo应用程序没有配置为一次请求大量用户帐户，所以我们的方法应该执行得很好，比迭代和执行单个查询更快。然而，你肯定应该在<a class="ae js" href="https://lostechies.com/ryansvihla/2014/09/22/cassandra-query-patterns-not-using-the-in-query-for-multiple-partitions/" rel="noopener ugc nofollow" target="_blank">这篇经典的博客文章</a>中读到更多关于使用<code class="du jt ju jv jw b">in </code>进行涉及多个分区的查询的局限性，以及一个涉及异步编程的变通方法。</p><h1 id="1094" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">下一次:更复杂的数据访问案例</h1><p id="707e" class="pw-post-body-paragraph iw ix hh iy b iz kx ii jb jc ky il je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">所以，那很简单，对吧？如果你怀疑，你是对的，有些情况下“简单的方法”不起作用。</p><p id="25c3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一篇文章中，我将展示一些更复杂的例子，包括<code class="du jt ju jv jw b">cqlengine</code>不适合的情况，以及我发现的一些关于在搜索服务中使用DSE Search实现查询的有趣细节。</p><p id="ad70" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">本系列下一篇pos:</strong><a class="ae js" rel="noopener" href="/@jscarp/cassandra-with-python-simple-to-complex-44298391867d?source=your_stories_page---------------------------"><strong class="iy hi">Cassandra with Python:简单到复杂</strong> </a></p></div></div>    
</body>
</html>