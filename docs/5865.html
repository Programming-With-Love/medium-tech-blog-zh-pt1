<html>
<head>
<title>Analyze Bank Transaction Data using Graph (Part 3/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图表分析银行交易数据(第3/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-3-3-ab8ae1f68bd2?source=collection_archive---------0-----------------------#2022-01-17">https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-3-3-ab8ae1f68bd2?source=collection_archive---------0-----------------------#2022-01-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ab7d26b3dd8cfb688e303103392d2206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dpnw1KQL3Fmt4Bf2zn6sBA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@eduschadesoares?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Eduardo Soares</a> on <a class="ae it" href="https://unsplash.com/s/photos/atm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (edited)</figcaption></figure><p id="c618" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae it" rel="noopener" href="/oracledevs/analyze-bank-transaction-data-using-graph-part-1-3-2088c6024f81">第1部分</a>和<a class="ae it" href="https://ryotayamanaka.medium.com/analyze-bank-transaction-data-using-graph-part-2-3-155516bb6349" rel="noopener">第2部分</a>中，我们解释了我们可以使用Oracle数据库本身作为图形数据库来存储属性图数据集和执行PGQL查询。此外，为了无缝集成，<code class="du js jt ju jv b">CREATE PROPERTY GRAPH</code>语句提供了一个声明性的映射方法，将数据集从表格转换成图形。</p><p id="4df6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本系列的这一部分中，我将向您展示如何使用第2部分中定义的图，除了Oracle数据库之外，还使用了<strong class="iw hi">图形服务器</strong>。Graph Server由一个高性能的内存图形分析引擎和一个数据库集成组件组成。Graph Server可用于所有版本的Oracle数据库，无需额外许可。我们将这种结合了Graph Server和Oracle数据库的架构称为Oracle Graph的“三层部署”。</p><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jw"><img src="../Images/93eb35e930e990a72c756d8b9348201c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZLOqIeqmM8CvH-M-l3fFw.png"/></div></div></figure><p id="9036" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">将图形加载到图形服务器</strong></p><p id="9599" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一步是登录安装了图形服务器和客户端的操作系统控制台。例如，如果您正在使用本文中<a class="ae it" rel="noopener" href="/oracledevs/build-oracle-graph-on-docker-part-2-2-407827b0b93">描述的Docker容器，请登录图形服务器容器，如下所示。如果您在云环境中，请使用SSH进行连接。</a></p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="194a" class="kf kg hh jv b be kh ki l kj kk">$ docker exec -it graph-server /bin/bash</span></pre><p id="c130" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，启动已经安装的Python客户端(opg4py ),连接到运行在同一台主机上的Graph Server。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="6803" class="kf kg hh jv b be kh ki l kj kk">$ opg4py -b https://localhost:7007 -u graphuser<br/>password: (Welcome1)<br/><br/>&gt;&gt;&gt; setloglevel("ROOT", "WARN")</span></pre><p id="36da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">数据库中有一个名为GRAPH2的图(作为表数据集上的PG视图)，它是我们在第2部分中创建的，因此我们将加载这个图。它在Python中的变量名不需要相同，但是我们将使用<code class="du js jt ju jv b">graph2</code>来减少混淆。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="3557" class="kf kg hh jv b be kh ki l kj kk">&gt;&gt;&gt; graph2 = session.read_graph_by_name("GRAPH2", "pg_view")</span></pre><p id="5b0d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该操作读取数据库中的表数据集，根据定义的映射将其转换为图形，并在图形服务器的内存中展开它。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="c986" class="kf kg hh jv b be kh ki l kj kk">&gt;&gt;&gt; graph2<br/>PgxGraph(name: GRAPH2, v: 180, e: 3100, directed: True, memory(Mb): 0)p</span></pre><p id="c858" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们试着对这个图执行一个PGQL查询。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="3a2e" class="kf kg hh jv b be kh ki l kj kk">graph2.query_pgql("""<br/>  SELECT c.first_name, LABEL(e), a.acc_id<br/>  FROM MATCH (c:customer)-[e:owns]-&gt;(a:account)<br/>  WHERE c.cst_id = 10<br/>""").print()<br/><br/>+--------------------------------+<br/>| first_name | LABEL(e) | acc_id |<br/>+--------------------------------+<br/>| Laura      | OWNS     | 10     |<br/>| Laura      | OWNS     | 90     |<br/>+--------------------------------+</span></pre><p id="9bae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，您可以在图形服务器上执行PGQL查询，就像在数据库上一样。</p><p id="191d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">运行路径查找查询</strong></p><p id="a398" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然PGQL查询仍然可以在数据库中执行(通过被重写为SQL查询)，但是当图形被部署在Graph Server的内存中时，我们可以预期一些查询会变得更快。寻路就是一个例子。</p><p id="ad29" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下查询使用TOP K SHORTEST子句来检索两个帐户(一个带有<code class="du js jt ju jv b">acc_id = 10</code>，另一个带有<code class="du js jt ju jv b">accc_id = 50</code>)之间的最短K(在本例中为5)条路径。条件<code class="du js jt ju jv b">COUNT(a) = COUNT(DISTINCT a)</code>消除了经过同一个账户不止一次的路径。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="999c" class="kf kg hh jv b be kh ki l kj kk">graph2.query_pgql("""<br/>SELECT ARRAY_AGG(a.acc_id) AS acc_ids<br/>     , ARRAY_AGG(t.txn_id) AS txn_ids<br/>     , ARRAY_AGG(t.amount) AS amounts<br/>FROM MATCH TOP 5 SHORTEST ((a1) (-[t:transferred_to]-&gt;(a))+ (a2))<br/>WHERE a1.acc_id = 10 AND a2.acc_id = 50<br/>  AND COUNT(a) = COUNT(DISTINCT a)<br/>""").print()<br/>+------------------------------------------+<br/>| acc_ids  | txn_ids      | amounts        |<br/>+------------------------------------------+<br/>| [62, 50] | [1025, 6212] | [100.0, 900.0] |<br/>| [62, 50] | [1025, 6227] | [100.0, 500.0] |<br/>| [62, 50] | [1044, 6212] | [200.0, 900.0] |<br/>| [62, 50] | [1044, 6227] | [200.0, 500.0] |<br/>| [62, 50] | [1041, 6212] | [300.0, 900.0] |<br/>+------------------------------------------+</span></pre><p id="a859" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您还可以包含一个条件，即所有转账的金额必须大于500英镑。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="bb97" class="kf kg hh jv b be kh ki l kj kk">graph2.query_pgql("""<br/>SELECT ARRAY_AGG(a.acc_id) AS acc_ids<br/>     , ARRAY_AGG(t.txn_id) AS txn_ids<br/>     , ARRAY_AGG(t.amount) AS amounts<br/>FROM MATCH TOP 5 SHORTEST<br/>  ((a1) (-[t:transferred_to]-&gt;(a) WHERE t.amount &gt; 500)+ (a2))<br/>WHERE a1.acc_id = 10 AND a2.acc_id = 50<br/>  AND COUNT(a) = COUNT(DISTINCT a)<br/>""").print()<br/><br/>+-----------------------------------------------------------+<br/>| acc_ids      | txn_ids            | amounts               |<br/>+-----------------------------------------------------------+<br/>| [49, 58, 50] | [1022, 4900, 5805] | [800.0, 700.0, 900.0] |<br/>| [49, 58, 50] | [1018, 4900, 5805] | [800.0, 700.0, 900.0] |<br/>| [49, 58, 50] | [1021, 4900, 5805] | [700.0, 700.0, 900.0] |<br/>| [61, 62, 50] | [1007, 6111, 6212] | [700.0, 800.0, 900.0] |<br/>| [61, 62, 50] | [1047, 6111, 6212] | [900.0, 800.0, 900.0] |<br/>+-----------------------------------------------------------+</span></pre><p id="c06a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果路径的开始和结束节点是同一个节点<code class="du js jt ju jv b">(a1)</code>，我们可以找到循环路径。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="2131" class="kf kg hh jv b be kh ki l kj kk">graph2.query_pgql("""<br/>SELECT ARRAY_AGG(a.acc_id) AS acc_ids<br/>     , ARRAY_AGG(t.txn_id) AS txn_ids<br/>     , ARRAY_AGG(t.amount) AS amounts<br/>FROM MATCH TOP 5 SHORTEST<br/>  ((a1) (-[t:transferred_to]-&gt;(a) WHERE t.amount &gt; 500)+ (a1))<br/>WHERE a1.acc_id = 10<br/>  AND COUNT(a) = COUNT(DISTINCT a)<br/>""").print()<br/><br/>+------------------------------------------+<br/>| acc_ids  | txn_ids      | amounts        |<br/>+------------------------------------------+<br/>| &lt;null&gt;   | &lt;null&gt;       | &lt;null&gt;         |<br/>| [25, 10] | [1014, 2531] | [900.0, 700.0] |<br/>| [25, 10] | [1028, 2531] | [900.0, 700.0] |<br/>| [49, 10] | [1022, 4902] | [800.0, 600.0] |<br/>| [49, 10] | [1018, 4902] | [800.0, 600.0] |<br/>+------------------------------------------+</span></pre><p id="9b9e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">可视化路径</strong></p><p id="63df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">内置的图形可视化工具可以在图形服务器上可视化图形。让我们用这个来可视化找到的路径。由于图形服务器内存中的图形与用户会话相关联，我们将首先检查这个Python客户端会话的会话ID。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="c506" class="kf kg hh jv b be kh ki l kl kk">&gt;&gt;&gt; session<br/>PgxSession(id: bee563a9-7378-4ec2-a8a0-00dcdd69672e, name: OPGShell)</span></pre><p id="fac7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用此会话ID登录图形可视化。</p><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es km"><img src="../Images/75c62cf950c47abdb61438770f309d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm2LYDHimqYAgXkKWoL8KQ.png"/></div></div></figure><p id="1193" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">选择GRAPH2作为目标图，并执行前面的路径查找查询。返回的结果将显示在表格中，因为它们不能显示在图形中。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="9d80" class="kf kg hh jv b be kh ki l kj kk">SELECT ARRAY_AGG(a.acc_id) AS acc_ids<br/>     , ARRAY_AGG(t.txn_id) AS txn_ids<br/>     , ARRAY_AGG(t.amount) AS amounts<br/>FROM MATCH TOP 5 SHORTEST<br/>  ((a1) (-[t:transferred_to]-&gt;(a) WHERE t.amount &gt; 500)+ (a2))<br/>WHERE a1.acc_id = 10 AND a2.acc_id = 50<br/>  AND COUNT(a) = COUNT(DISTINCT a)</span></pre><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es km"><img src="../Images/8feb1b81c0d948571694e04337073297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw-YlPNNw4te2aAIPgXBQw.png"/></div></div></figure><p id="d84a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">选择一个结果路径，我们可以通过使用事务id列表来可视化它。这一系列查询和它们之间的逻辑将在真实系统的应用层中实现。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="33fd" class="kf kg hh jv b be kh ki l kj kk">SELECT *<br/>FROM MATCH (a1)-[t]-&gt;(a2)<br/>WHERE t.txn_id IN (1022, 4900, 5805)</span></pre><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/85aaf50bee2351bb81531748a2065a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybLPn8C1yICuR0xOFLY91Q.png"/></div></div></figure><p id="d883" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种可视化可以在下面的一个查询中完成。关键字<code class="du js jt ju jv b">OEN ROW PER STEP</code>检索路径中的步骤，并将它们映射到新的变量<code class="du js jt ju jv b">v1, e, v2</code>。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="fd62" class="kf kg hh jv b be kh ki l kj kk">SELECT v1, e, v2<br/>FROM MATCH SHORTEST<br/>  ((a1) (-[t:transferred_to]-&gt;(a) WHERE t.amount &gt; 500)+ (a2))<br/>  ONE ROW PER STEP (v1, e, v2)<br/>WHERE a1.acc_id = 10 AND a2.acc_id = 50<br/>AND COUNT(a) = COUNT(DISTINCT a)</span></pre><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/57da7b1667456a11f25c11d9f4cc5f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ekCOJ9ejRioRIA9Oe0RtQ.png"/></div></div></figure><p id="6b26" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">运行图形算法</strong></p><p id="009e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Graph Server内置了很多图算法，我们先来试试大家熟知的PageRank算法。PageRank根据传入边的数量及其源节点的重要性来计算图中节点的重要性。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="2011" class="kf kg hh jv b be kh ki l kj kk">&gt;&gt;&gt; analyst.pagerank(graph2)<br/>VertexProperty(name: pagerank, type: double, graph: GRAPH2)</span></pre><p id="300f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该算法将计算结果存储为新顶点属性<code class="du js jt ju jv b">pagerank</code>的值，其类型为double。</p><p id="4d0e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们也看看程度中心性。这个分数就是连接的边的总数。我们还将分别计算传入和传出边的总数。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="7e5e" class="kf kg hh jv b be kh ki l kj kk">analyst.degree_centrality(graph2)<br/>analyst.in_degree_centrality(graph2)<br/>analyst.out_degree_centrality(graph2)</span></pre><p id="2a1d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用PGQL查询可以很容易地检索到结果。从同一界面操作查询和算法的能力是Graph Server的一个优势。</p><pre class="jx jy jz ka fd kb jv kc bn kd ke bi"><span id="b267" class="kf kg hh jv b be kh ki l kj kk">graph2.query_pgql("""<br/>SELECT<br/>  a.acc_id<br/>, a.pagerank<br/>, a.degree<br/>, a.in_degree<br/>, a.out_degree<br/>FROM MATCH (a)<br/>ORDER BY a.pagerank DESC<br/>LIMIT 10<br/>""").print()<br/><br/>+-----------------------------------------------------------------+<br/>| acc_id | pagerank             | degree | in_degree | out_degree |<br/>+-----------------------------------------------------------------+<br/>| 41     | 0.019603664018674367 | 102    | 62        | 40         |<br/>| 33     | 0.015104950170843338 | 108    | 58        | 50         |<br/>| 5      | 0.014983680499273774 | 92     | 42        | 50         |<br/>| 24     | 0.014966074159304933 | 89     | 49        | 40         |<br/>| 36     | 0.014897989873184218 | 71     | 41        | 30         |<br/>| 40     | 0.014860174576443065 | 72     | 32        | 40         |<br/>| 23     | 0.014700205912993914 | 84     | 54        | 30         |<br/>| 73     | 0.0141410094293568   | 77     | 47        | 30         |<br/>| 30     | 0.013816617289907915 | 102    | 52        | 50         |<br/>| 32     | 0.013339752300665857 | 42     | 32        | 10         |<br/>+-----------------------------------------------------------------+</span></pre><p id="1b5f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">算法添加的新属性也可以在图形可视化中看到。例如，您可以根据PageRank分数更改顶点的大小。</p><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/d6934e470375be1266033e4ad01bf762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCNA3So-h1IKj6MVm_gt1w.png"/></div></div></figure><p id="3c28" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你仔细观察，你会发现有些顶点比其他的大。</p><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/b62b71073471710d1ef1a876badcb3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eycjETB4Dy4eKPVJR7UkiA.png"/></div></div></figure><p id="9fc9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">变换图形</strong></p><p id="8561" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上一节中，我们运行了算法来寻找顶点的重要性，但是我们实际上需要考虑一些关于目标图的事情。该图有客户顶点、账户顶点、所有权边和资金转移边。但是，如果我们想只关注转移关系的客户的重要性，我们<strong class="iw hi">不应该在计算中包括</strong>客户顶点和所有权边缘。此外，两个账户之间经常存在多条转移边，但一些算法在没有这种<strong class="iw hi">多条转移边</strong>的情况下会更有效或产生更有效的结果。本节将向您展示如何使用PGQL修改查询来转换图形。</p><p id="ef70" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，由于当前在内存中的图(<code class="du js jt ju jv b">graph2</code>)具有由算法添加的新属性，我们再次从数据库加载该图以恢复其初始状态。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="2430" class="kt kg hh jv b fi ku kv l kl kk">graph2 = session.read_graph_by_name("GRAPH2", "pg_view")</span></pre><p id="79f5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下查询删除客户顶点。当删除一个或两个端点顶点时，也会删除“悬空”边。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="5c29" class="kt kg hh jv b fi ku kv l kl kk">graph3 = graph2.clone_and_execute_pgql("""<br/><strong class="jv hi">DELETE c FROM MATCH (c:customer)</strong><br/>""")</span></pre><p id="e7ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从下面显示的图形大小，我们可以看到80个顶点和100条边被删除。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="a83f" class="kt kg hh jv b fi ku kv l kl kk">&gt;&gt;&gt; graph3<br/>PgxGraph(name: sub-graph_xx, v: 100, e: 3000, directed: True, memory(Mb): 0)</span></pre><p id="6db5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，当有多个转移边时，我们将它们合并为一个。在这里，我们想要保存账户之间已经进行了多少次转账的信息，所以我们添加了一个新的属性，<code class="du js jt ju jv b">cnt</code>。要存储的值应该是整数，但是我们将这个属性的类型设置为double，因为我们稍后运行的算法支持double。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="a228" class="kt kg hh jv b fi ku kv l kl kk">&gt;&gt;&gt; graph3.create_edge_property("double", "cnt")<br/>EdgeProperty(name: cnt, type: double, graph: sub-graph_xx)</span></pre><p id="2539" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，新属性<code class="du js jt ju jv b">cnt</code>的值都被设置为0。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="1dc1" class="kt kg hh jv b fi ku kv l kl kk">graph3.query_pgql("""<br/><strong class="jv hi">SELECT t.cnt, COUNT(t)<br/>FROM MATCH ()-[t:transferred_to]-&gt;()<br/>GROUP BY t.cnt<br/>ORDER BY t.cnt ASC</strong><br/>""").print()</span><span id="7150" class="kt kg hh jv b fi kw kv l kl kk">+----------------+<br/>| cnt | COUNT(t) |<br/>+----------------+<br/>| 0.0 | 3000     |<br/>+----------------+</span></pre><p id="4c59" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当有一个或多个转移边(考虑它们的方向)时，下一个查询将为每对帐户创建一个新边。在每个聚合中，原始传输边的数量存储在新边的<code class="du js jt ju jv b">cnt</code>属性中。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="b4f3" class="kt kg hh jv b fi ku kv l kl kk">graph4 = graph3.clone_and_execute_pgql("""<br/><strong class="jv hi">INSERT EDGE e BETWEEN a1 AND a2<br/>  LABELS ( transferred_to ) PROPERTIES ( e.cnt = COUNT(t) )<br/>FROM MATCH (a1)-[t:transferred_to]-&gt;(a2)<br/>GROUP BY a1, a2</strong><br/>""")</span></pre><p id="a6f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，带有<code class="du js jt ju jv b">cnt = 0</code>的边是原来的3000条转移边，其他的是新添加的边。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="89cf" class="kt kg hh jv b fi ku kv l kl kk">graph4.query_pgql("""<br/><strong class="jv hi">SELECT t.cnt, COUNT(t)<br/>FROM MATCH ()-[t:transferred_to]-&gt;()<br/>GROUP BY t.cnt<br/>ORDER BY t.cnt ASC</strong><br/>""").print()</span><span id="3e0b" class="kt kg hh jv b fi kw kv l kl kk">+----------------+<br/>| cnt | COUNT(t) |<br/>+----------------+<br/>| 0.0 | 3000     |<br/>| 1.0 | 682      |<br/>| 2.0 | 485      |<br/>| 3.0 | 328      |<br/>| 4.0 | 55       |<br/>| 5.0 | 17       |<br/>| 6.0 | 6        |<br/>| 7.0 | 2        |<br/>| 9.0 | 1        |<br/>+----------------+</span></pre><p id="af07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用条件<code class="du js jt ju jv b">cnt = 0</code>删除原来的边。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="f998" class="kt kg hh jv b fi ku kv l kl kk">graph5 = graph4.clone_and_execute_pgql("""<br/><strong class="jv hi">DELETE t<br/>FROM MATCH ()-[t:transferred_to]-&gt;()<br/>WHERE t.cnt = 0</strong><br/>""")</span></pre><p id="8920" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">仅保留新添加的转移边。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="220d" class="kt kg hh jv b fi ku kv l kl kk">graph5.query_pgql("""<br/><strong class="jv hi">SELECT t.cnt, COUNT(t)<br/>FROM MATCH ()-[t:transferred_to]-&gt;()<br/>GROUP BY t.cnt<br/>ORDER BY t.cnt ASC</strong><br/>""").print()</span><span id="2e26" class="kt kg hh jv b fi kw kv l kl kk">+----------------+<br/>| cnt | COUNT(t) |<br/>+----------------+<br/>| 1.0 | 682      |<br/>| 2.0 | 485      |<br/>| 3.0 | 328      |<br/>| 4.0 | 55       |<br/>| 5.0 | 17       |<br/>| 6.0 | 6        |<br/>| 7.0 | 2        |<br/>| 9.0 | 1        |<br/>+----------------+</span></pre><p id="c927" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">再次运行图形算法</strong></p><p id="970e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们将以与上述相同的方式使用转换后的图来计算中心性得分。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="eaaf" class="kt kg hh jv b fi ku kv l kl kk">analyst.<strong class="jv hi">pagerank</strong>(graph5)<br/>analyst.<strong class="jv hi">degree_centrality</strong>(graph5)<br/>analyst.<strong class="jv hi">in_degree_centrality</strong>(graph5)<br/>analyst.<strong class="jv hi">out_degree_centrality</strong>(graph5)</span></pre><p id="fa19" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在PGQL中获取结果。您应该会看到与之前不同的结果。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="c916" class="kt kg hh jv b fi ku kv l kl kk">graph5.query_pgql("""<br/><strong class="jv hi">SELECT<br/>  a.acc_id<br/>, a.pagerank<br/>, a.degree<br/>, a.in_degree<br/>, a.out_degree<br/>FROM MATCH (a)<br/>ORDER BY a.pagerank DESC<br/>LIMIT 10</strong><br/>""").print()</span><span id="4189" class="kt kg hh jv b fi kw kv l kl kk">+-----------------------------------------------------------------+<br/>| acc_id | pagerank             | degree | in_degree | out_degree |<br/>+-----------------------------------------------------------------+<br/>| 41     | 0.015927856082418812 | 52     | 27        | 25         |<br/>| 33     | 0.01572808354417436  | 55     | 28        | 27         |<br/>| 73     | 0.01467580042697759  | 44     | 22        | 22         |<br/>| 53     | 0.014544138405858852 | 45     | 21        | 24         |<br/>| 59     | 0.014241045755115847 | 41     | 24        | 17         |<br/>| 49     | 0.014199578954729926 | 29     | 21        | 8          |<br/>| 47     | 0.014141568475804285 | 43     | 22        | 21         |<br/>| 5      | 0.013433911533465633 | 46     | 21        | 25         |<br/>| 68     | 0.012841252743896187 | 43     | 20        | 23         |<br/>| 90     | 0.01278925469055179  | 38     | 22        | 16         |<br/>+-----------------------------------------------------------------+</span></pre><p id="319e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们还将尝试加权PageRank算法。由于每条边都有一个<code class="du js jt ju jv b">cnt</code>属性，我们将把它视为一个权重，因此<code class="du js jt ju jv b">cnt</code>越高，PageRank传播的就越强。我们将运行算法，将edge属性作为第二个参数。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="1e68" class="kt kg hh jv b fi ku kv l kl kk">cnt = graph5.get_edge_property("cnt")<br/>analyst.<strong class="jv hi">weighted_pagerank</strong>(graph5, cnt)</span></pre><p id="9ac8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到两种计算结果之间的排名差异。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="f7dd" class="kt kg hh jv b fi ku kv l kl kk">graph5.query_pgql("""<br/><strong class="jv hi">SELECT<br/>  a.acc_id<br/>, a.pagerank<br/>, a.weighted_pagerank<br/>FROM MATCH (a)<br/>ORDER BY a.pagerank DESC<br/>LIMIT 10</strong><br/>""").print()</span><span id="a3e3" class="kt kg hh jv b fi kw kv l kl kk">+------------------------------------------------------+<br/>| acc_id | pagerank             | weighted_pagerank    |<br/>+------------------------------------------------------+<br/>| 41     | 0.015927856082418812 | 0.02090853868414549  |<br/>| 33     | 0.01572808354417436  | 0.016067973689548414 |<br/>| 73     | 0.01467580042697759  | 0.015001994965949424 |<br/>| 53     | 0.014544138405858852 | 0.011917160588132424 |<br/>| 59     | 0.014241045755115847 | 0.01275290770633708  |<br/>| 49     | 0.014199578954729926 | 0.013315017840049879 |<br/>| 47     | 0.014141568475804285 | 0.01222283230220626  |<br/>| 5      | 0.013433911533465633 | 0.016221144544670288 |<br/>| 68     | 0.012841252743896187 | 0.011829108962126801 |<br/>| 90     | 0.01278925469055179  | 0.011897751825643397 |<br/>+------------------------------------------------------+</span></pre><p id="a5a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以从图形可视化中访问转换后的图形，所以让我们来可视化具有最高加权PageRank分数的顶点和连接的顶点。边缘的厚度现在代表重量。</p><pre class="jx jy jz ka fd kb jv kq kr aw ks bi"><span id="9c12" class="kt kg hh jv b fi ku kv l kl kk">SELECT *<br/>FROM MATCH (a)-[t]-()<br/>WHERE a.weighted_pagerank &gt; 0.020</span></pre><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es km"><img src="../Images/92df76e96ca1a316e6115c2290fb05e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jfCeWwadTVyJJAI72tcUA.png"/></div></div></figure><p id="5fee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文展示了我们可以将数据库中定义的图加载到Graph Server中，并对内存中的图运行路径查找查询和图算法。3层部署的独特设计实现了数据库上定义的图形与高性能内存图形分析的无缝集成。</p><p id="77a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我展示了如何使用PGQL修改查询来转换用于分析的图形。对于像这样的简单情况，数据库中的SQL聚合也可以实现相同的转换。不过，这种图转换技术有时非常强大，例如，在将多跳路径转换为单条边时。以后我会介绍这样复杂的用例。</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="153a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请从以下网址了解有关<strong class="iw hi"> Oracle Graph </strong>的更多信息:</p><ul class=""><li id="4c1b" class="le lf hh iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><a class="ae it" rel="noopener" href="/tag/oracle-graph">中</a> (=所有带有Oracle Graph标签的文章)</li><li id="2e8f" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><a class="ae it" href="https://stackoverflow.com/questions/tagged/oracle-graph" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a> (=带oracle-graph标签的问题)</li><li id="99d4" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><a class="ae it" href="https://join.slack.com/t/andouc/shared_invite/zt-1a2hmiz6f-vLlblcQyv0t9FMraMMP5uQ" rel="noopener ugc nofollow" target="_blank"> Slack AnDOUC </a> (=邀请链接，请访问#graph)</li><li id="3cf1" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><a class="ae it" href="https://join.slack.com/t/oracledevrel/shared_invite/zt-uffjmwh3-ksmv2ii9YxSkc6IpbokL1g" rel="noopener ugc nofollow" target="_blank"> Slack OracleDevRel </a> (=邀请链接，请访问#oracle-db-graph)</li></ul></div></div>    
</body>
</html>