<html>
<head>
<title>What are Javascript classes? A basic introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Javascript类？基本介绍</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/what-are-javascript-classes-a-basic-introduction-ad24914ec8f0?source=collection_archive---------5-----------------------#2019-09-09">https://medium.com/duomly-blockchain-online-courses/what-are-javascript-classes-a-basic-introduction-ad24914ec8f0?source=collection_archive---------5-----------------------#2019-09-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8a0b361d6547e669d0ce0f2e9522365a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDj8c44-c9YK1HO8lRq-JQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="5ac5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发布于:<a class="ae it" href="https://www.blog.duomly.com/what-are-javascript-classes-and-how-to-use-them/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/what-are-JavaScript-classes-and-how-to-use-them/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="5c2f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类是面向对象编程中的一个基本概念，在许多编程语言中都有使用，但在Javascript中却不是这样。在ecmascript 2015(ES6)之前，JS中不存在类。在2015年的更新中，引入了类作为现有原型继承模型的语法糖。类为对象和继承带来了更舒适、更易读的语法。</p><p id="e0d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Javascript中的Class是函数的一种类型，但不是用function关键字初始化，而是使用class关键字。</p><p id="380c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我将试着介绍什么是类以及我们如何使用它们。它将解释:</p><ul class=""><li id="1a90" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">定义类，</li><li id="5f14" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">构造函数方法，</li><li id="f651" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">定义方法，</li><li id="524f" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">扩展类和超级关键字，</li><li id="962f" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">getters和setters。</li></ul><p id="245b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">开始吧！</p><p id="c597" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kn"> *要检查代码执行情况，请在浏览器中打开控制台并尝试执行代码(如果您使用的是谷歌浏览器，请在页面上右键单击并选择调查)</em></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="4369" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">1.定义类别</h1><p id="7576" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">要定义一个类，我们必须从一个类关键字开始，然后是类名，然后是名字后面的花括号。接下来，在已定义的类中，我们设置一个分配了属性的构造函数，每当初始化一个类时都会调用它。让我们来看一个代码示例:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="927f" class="ma kp hh lw b fi mb mc l md me">class Person {<br/>    constructor(name,age){<br/>        this.name=name;<br/>        this.age=age;<br/>    }<br/>}</span></pre><p id="0754" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码示例中，使用构造函数定义了Person类，我们在其中设置了name和age属性。为了初始化这个类，我们必须使用一个带有类名的新关键字，像它这样的参数与对象一起工作。让我们看看代码示例:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="e6ea" class="ma kp hh lw b fi mb mc l md me">var person = new Person('Peter', 25);</span></pre><p id="40df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，我们用两个参数name= "Peter "和age= "25 "初始化了一个类，并将它赋给了变量person。</p><p id="e928" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得一提的是，虽然类是函数，但在这种情况下，提升不起作用。这意味着每个类都必须首先定义，然后初始化。否则会出现参考误差。此外，记住类中的代码处于“严格模式”是很好的。它将抛出更多的错误，并帮助我们避免键入错误或语法错误。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="3bcb" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">2.构造函数方法</h1><p id="6adb" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">在定义类时，我们使用了构造函数。现在我们来解释一下什么是Javascript类中的构造函数。当我们定义一个类时，它是一个必须包含在类中的方法，它是一个将属性分配给类的作用域的方法。构造函数需要新的关键字才能工作。这意味着如果我们像上面的例子那样初始化类，构造函数也将被初始化。此外，每个类只能使用一个构造函数。如果你没有在你的类中添加一个构造函数，Javascript会用一个空的来帮你做这个:<strong class="iw hi">构造函数(){} </strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="dc6a" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">3.定义方法</h1><p id="2022" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">在一个类中，我们可以定义不同于构造函数的方法。让我们看看它在代码中的样子:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="a3b1" class="ma kp hh lw b fi mb mc l md me">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="cd37" class="ma kp hh lw b fi mf mc l md me">  introduceYourself() {<br/>    return 'Hello, my name is ' + this.name;<br/>  }<br/>}</span><span id="3308" class="ma kp hh lw b fi mf mc l md me">var person = new Person('Mark', 30);<br/>person.introduceYourself(); // returns 'Hello, my name is Mark'</span></pre><p id="fc50" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，我在Person类中创建了一个新方法，名为<strong class="iw hi">自我介绍</strong>。此方法采用this.name并返回字符串。如您所见，创建方法类似于创建函数，但不使用函数关键字。在代码示例中，您可以看到如何调用方法。</p><p id="533a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也有可能在类中创建静态方法。区别在于静态方法只能从类中访问，而不能从类创建的对象中访问。让我们检查代码示例，了解如何定义静态方法:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="dac2" class="ma kp hh lw b fi mb mc l md me">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="164f" class="ma kp hh lw b fi mf mc l md me">  static howAreYou() {<br/>    return 'I am okey, and you?';<br/>  }<br/>}</span><span id="6ea4" class="ma kp hh lw b fi mf mc l md me">Person.howAreYou(); // returns 'I am okey, and you?';<br/>var person = new Person('Mark', 30);<br/>person.howAreYou(); // returns an error</span></pre><p id="25af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了让类知道我们定义的方法应该是静态的，我们必须在方法定义的开头添加一个static关键字。然后，你可以看到，如果你试图调用它来形成对象，它将返回一个错误，如果你直接从类中访问它，那么没问题，结果将是预期的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="55c2" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">4.扩展类和超级关键字</h1><p id="b4e1" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">有时我们想“复制”这个类，并给它添加一些新的方法或参数。在这种情况下，扩展类非常方便。我们可以访问父类的所有特性，还可以添加一些新的特性。为了从父类创建子类，我们使用extend关键字。让我们看看它在示例中是如何工作的:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="733e" class="ma kp hh lw b fi mb mc l md me">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="22a9" class="ma kp hh lw b fi mf mc l md me">  yourAge() {<br/>    return 'I am ' + this.age;<br/>  }<br/>}</span><span id="db79" class="ma kp hh lw b fi mf mc l md me">class Kid extends Person {<br/>  howOldAreYou() {<br/>    return super.yourAge() + '. I am a child';<br/>  }</span><span id="b1a0" class="ma kp hh lw b fi mf mc l md me">  isAdult() {<br/>    if (this.age &gt;= 18) {<br/>      return true;<br/>    } else {<br/>      return false;<br/>    }<br/>  }<br/>}</span><span id="af4f" class="ma kp hh lw b fi mf mc l md me">var child = new Kid('Mary', 12);<br/>child.howOldAreYou(); // returns 'I am 12. I am a child';<br/>child.isAdult(); // returns false;</span></pre><p id="b0e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，我们将Person类扩展为Kid类，并在Kid类howOldAreYou()中使用了yourAge()方法，该方法与一个super关键字一起使用，该关键字允许在child类中使用parent方法。this.age属性也用于检查isAdult()函数中的条件。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="9631" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">5.Getters和setters</h1><p id="3854" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">像类中的对象一样，我们也可以使用getters和setters。Getter是用get关键字创建的，setter是用set关键字创建的。当我们想在将值赋给对象之前检查或修改它时，使用getters和setters是个好主意。让我们检查一下代码，看看它是如何工作的:</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="080e" class="ma kp hh lw b fi mb mc l md me">class Person {<br/>  constructor(name) {<br/>    // setter is called<br/>    this._name = name;<br/>  }</span><span id="b399" class="ma kp hh lw b fi mf mc l md me">  get name() {<br/>    return this._name;<br/>  }</span><span id="e7c9" class="ma kp hh lw b fi mf mc l md me">  set name(value) {<br/>    this._name = value;<br/>  }<br/>}</span><span id="aa8a" class="ma kp hh lw b fi mf mc l md me">var newPerson = new Person('Mary');<br/>newPerson.name; // returns 'Mary'<br/>newPerson.name = 'Peter';<br/>newPerson.name; // returns 'Peter'</span></pre><p id="0b42" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，我们可以看到name属性的getter和setter。在构造函数中，当此。_name时，将调用setter来设置名称。Getter和setter不能与它们设置或获取的属性同名。此外，如果您想使用setter来设置新的属性值，请像属性一样使用不带括号的setter。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="c511" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="c4b4" class="pw-post-body-paragraph iu iv hh iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr ha bi translated">Javascript中的类特性相对较新，但是类的功能一直存在，比如原型继承模型和构造函数。现在，语法更加友好，创建清晰易读的代码也更加容易。在本文中，我介绍了关于Javascript类的最重要的信息，从定义类开始，经过构造函数和方法，扩展类，最后使用getters和setters。我希望这篇文章中的知识将阐明Javascript中类的用法，并帮助您使用类语法实现您的代码。我认为类的实现对开发人员来说非常方便，但是没有它也可以实现同样的功能。</p><p id="c13f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你认为在ES6中实现一个类特性是个好主意吗？</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/718e5cb2f686848b4835b7b17ee27edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ZYRqwfaor_wiNA1.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="4904" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="a3cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文由我们的队友安娜提供。</p></div></div>    
</body>
</html>