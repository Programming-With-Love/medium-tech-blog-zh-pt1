<html>
<head>
<title>Explore How To Dockerize a Node.js App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何对Node.js应用程序进行停靠</h1>
<blockquote>原文：<a href="https://medium.com/edureka/node-js-docker-tutorial-72e7542d69d8?source=collection_archive---------1-----------------------#2019-07-08">https://medium.com/edureka/node-js-docker-tutorial-72e7542d69d8?source=collection_archive---------1-----------------------#2019-07-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/26f099a45bdb4f4eb0580779ef8c0b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SNkpTFZBgrWot0NX8IVfDw.png"/></div><figcaption class="il im et er es in io bd b be z dx">Node.js Docker Tutorial — Edureka</figcaption></figure><p id="a955" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个Node.js开发人员总是尽最大努力让他的应用程序摆脱任何类型的环境依赖。但是，尽管他们采取了措施，但意外总是会发生，导致应用程序失败。好吧，这就是码头工人来救援的地方。在本文中，我将向您介绍如何从头开始对Node.js应用程序进行Dockerize。</p><p id="ffc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是我将在Node.js Docker文章中涉及的主题:</p><ul class=""><li id="a2e0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Docker是什么？</li><li id="38e8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Docker基础:docker文件、图像和容器</li><li id="a857" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">为什么要将Node.js与Docker一起使用？</li><li id="dc81" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">演示</li></ul><p id="9b74" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从这篇文章开始。</p><h1 id="fce2" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Docker是什么？</h1><p id="e6f9" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Docker是一个容器化平台，用于将应用程序及其依赖项一起打包到Docker容器中。这确保了无论环境如何变化，我们的应用程序都能轻松流畅地运行。</p><p id="3d5b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，您可以将Docker视为一种工具，它旨在使使用容器的应用程序的创建、部署和执行变得更加容易和高效。</p><p id="cf7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">说到Docker容器，它只不过是一个标准化的单元，用于部署特定的应用程序或环境，并且可以动态构建。可以有Ubuntu，CentOS等任何容器。基于您对操作系统的要求。此外，这些容器不仅限于操作系统，您还可以拥有面向应用的操作系统。这种容器的几个例子是CakePHP容器、Tomcat-Ubuntu容器等。</p><p id="9ade" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了更好地理解这一点，请参考下图:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es le"><img src="../Images/b5aec4a18c0efc9371615bd4f2f9f1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*vZS_ABqChH7ldsPgqNX6Eg.png"/></div></figure><p id="c1ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个图中，你可以看到每一个应用程序都运行在一个独立的容器上，有自己的依赖项和库。这确保了每个应用程序都独立于其他应用程序，使开发人员能够独立构建应用程序，而不受其他应用程序的任何干扰。因此，作为开发人员，您可以简单地构建一个安装了不同应用程序的容器，并将其交给QA团队。然后QA团队只需要执行容器来复制开发人员的环境。</p><p id="9676" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我来解释一下Docker的本质，这将有助于您更好地理解Docker化Node.js应用程序的过程。</p><h1 id="6432" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Docker基础:docker文件、图像和容器</h1><p id="4b6b" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在使用Docker之前，你必须知道的三个最重要的方面是:</p><ol class=""><li id="1b4c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lj jt ju jv bi translated">Dockerfile文件</li><li id="d3e3" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lj jt ju jv bi translated">Docker图像</li><li id="5b4e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lj jt ju jv bi translated">码头集装箱</li></ol><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/231c11016a8add8f0f06e73df08eb622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKKghoDK-bgiKkcRFhvijA.png"/></div></div></figure><p id="0f15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上图中，你可以看到当一个Docker文件被构建时，它给你一个Docker映像。此外，当您执行Docker映像时，它最终会给您一个Docker容器。</p><p id="534d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们来详细了解其中的每一项。</p><h2 id="a3e6" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated">Dockerfile文件</h2><p id="a81d" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Dockerfile基本上是一个包含命令列表的文本文档，用户可以使用命令行调用该列表来组合图像。因此，通过从这个Docker文件中读取指令，Docker自动构建图像。</p><p id="1252" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要连续执行多个命令行指令，您可以使用以下命令创建自动构建:</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="64fe" class="lp kc hh me b fi mi mj l mk ml">docker build</span></pre><h2 id="6e53" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated">Docker图像</h2><p id="d3d6" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Docker映像可以被视为类似于通常用于构建Docker容器的模板。换句话说，这些只读模板不过是Docker容器的构建块。为了执行映像并构建容器，您需要使用以下命令:</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="9f90" class="lp kc hh me b fi mi mj l mk ml">docker run</span></pre><p id="0468" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用此命令创建的Docker映像存储在Docker注册表中。它可以是用户的本地存储库，也可以是Docker Hub这样的公共存储库，它允许多个用户协作构建应用程序。</p><h2 id="f839" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated">码头集装箱</h2><p id="2930" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Docker容器是Docker映像的运行实例。这些容器包含执行应用程序所需的完整包。因此，这些基本上是随时可用的应用程序，这些应用程序是从Docker映像创建的，这是Docker的最终用途。</p><h1 id="2add" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为什么要用Docker搭配Node.js？</h1><p id="8d8d" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">下面我列出了一些在Node.js应用程序中使用Docker的最有趣的理由:</p><ul class=""><li id="00a6" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Docker有助于加快应用程序部署过程</li><li id="777b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">它使得跨其他机器的应用程序移植更加容易</li><li id="d2b7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">它使版本控制更容易，并促进组件重用</li><li id="daac" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用Docker，人们可以很容易地共享Docker图像和Docker文件</li><li id="839c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Docker占用的内存非常少，因此应用程序的开销很小</li><li id="0455" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">它的使用和维护简单易行</li></ul><p id="bbd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这能给你足够的理由马上开始使用Docker。</p><h1 id="e790" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">演示</h1><p id="ee32" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在Node.js中使用Docker之前，您需要确保Docker已经安装在您的系统中，并且您有使用它的权限。</p><p id="d30d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然安装过程已经完成，现在让我们集中精力对Node.js应用程序进行Dockerizing。我假设您的系统中已经安装了Node.js。</p><p id="4586" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了对接Node.js应用程序，您需要完成以下步骤:</p><ol class=""><li id="a16a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lj jt ju jv bi translated">创建Node.js应用程序</li><li id="0d3a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lj jt ju jv bi translated">创建Docker文件</li><li id="5283" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lj jt ju jv bi translated">构建Docker映像</li><li id="1d63" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lj jt ju jv bi translated">执行</li></ol><h2 id="1db1" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">创建Node.js应用程序</strong></h2><p id="b100" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">为了对Node.js应用程序进行Dockerize，首先需要的是Node.js应用程序。可以参考我的文章<a class="ae mm" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">用Node.js构建REST API。</a></p><p id="4b80" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦完成了应用程序的开发，您需要确保应用程序在分配的端口上正确执行。在我的例子中，我使用端口8080。如果应用程序按预期运行，您可以继续下一步。</p><h2 id="808b" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">创建一个Dockerfile </strong></h2><p id="2b3c" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在这一步中，我们将创建Dockerfile，这将使我们能够根据我们的需求重新创建和扩展Node.js应用程序。要完成这一步，您需要在项目的根目录下创建一个新文件，并将其命名为<strong class="ir hi"> <em class="mn"> Dockerfile。</em>T9】</strong></p><p id="c3f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我使用了一个轻量级的基于alpine的图像来构建我们的Docker图像。在创建Docker文件时，我们的主要目标应该是保持Docker图像尽可能小，同时利用成功运行我们的应用程序所需的一切。</p><p id="ec30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面我写下了需要添加到您的docker文件中的代码:</p><h2 id="f5e6" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak"> Dockerfile </strong></h2><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="ade9" class="lp kc hh me b fi mi mj l mk ml">FROM node:9-slim<br/> <br/># WORKDIR specifies the application directory<br/>WORKDIR /app<br/> <br/># Copying package.json file to the app directory<br/>COPY package.json /app<br/> <br/># Installing npm for DOCKER<br/>RUN npm install<br/> <br/># Copying rest of the application to app directory<br/>COPY . /app<br/> <br/># Starting the application using npm start<br/>CMD ["npm","start"]</span></pre><p id="12e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如您在上面的代码中看到的，我使用了两个不同的复制命令来减少应用程序的重建时间。由于Docker可以隐式缓存每个单独命令的结果，所以每次尝试创建Docker映像时，不需要从头开始执行所有命令。</p><p id="16cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然已经成功定义了Docker文件，下一步就是构建Docker映像。在本文的下一部分，我将演示如何轻松地构建Docker形象。</p><h2 id="5ad2" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">打造码头工人形象</strong></h2><p id="d951" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">构建Docker映像相当容易，可以使用一个简单的命令来完成。下面我写下了您需要在终端中键入并执行的命令:</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="3959" class="lp kc hh me b fi mi mj l mk ml">docker build -t &lt;docker-image-name&gt; &lt;file path&gt;</span></pre><p id="af77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦您执行这个命令，您将在您的终端中看到一个6步输出。我已经附上了我的输出截图。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mo"><img src="../Images/94fde2fac3edf38f9086f2a75c6eb7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsjS-I-n9NPXdu-FGkEAEg.png"/></div></div></figure><p id="7662" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您得到的输出类似于上面的截图，那么这意味着您的应用程序工作正常，docker映像已经成功创建。在这篇Node.js Docker文章的下一节中，我将向您展示如何执行这个Docker映像。</p><h2 id="b833" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">执行Docker图像</strong></h2><p id="aae6" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">既然您已经成功地创建了Docker映像，现在您可以使用下面给出的命令在这个映像上运行一个或多个Docker容器:</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="b5c8" class="lp kc hh me b fi mi mj l mk ml">docker run it -d -p &lt;HOST PORT&gt;:&lt;DOCKER PORT&gt; &lt;docker-image-name&gt;</span></pre><p id="7dc2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个命令将根据docker映像启动Docker容器，并在机器的指定端口上公开它。在上面的命令<strong class="ir hi"> <em class="mn"> -d标志</em> </strong>表示你想以分离模式执行你的Docker容器。换句话说，这将使您的Docker容器能够在主机的后台运行。而<strong class="ir hi"> <em class="mn"> -p标志</em> </strong>指定哪个主机端口将连接到对接端口。</p><p id="69fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要检查您的应用程序是否已经成功停靠，您可以尝试在您在上面的命令中为主机指定的端口上启动它。</p><p id="e3b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想查看系统中当前运行的映像列表，可以使用下面的命令:</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="b1ad" class="lp kc hh me b fi mi mj l mk ml">docker ps</span></pre><p id="c48a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以使用更多的<a class="ae mm" rel="noopener" href="/edureka/docker-commands-29f7551498a8"> Docker命令</a>。</p><p id="3ee3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了这篇Node.js Docker文章的结尾。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Node.js的各个方面</p><blockquote class="mp mq mr"><p id="57ad" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">1.<a class="ae mm" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> NodeJS教程</a></p><p id="6627" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">2.<a class="ae mm" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762">使用Node.js和MySQL构建一个CRUD应用程序</a></p><p id="234a" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">3.<a class="ae mm" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c">使用节点构建CRUD应用程序。JS和MongoDB </a></p><p id="f489" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">4.<a class="ae mm" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="4603" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">5.<a class="ae mm" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">从头开始构建Node.js】</a></p><p id="4bfc" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">6.<a class="ae mm" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">用Node.js构建REST API</a></p><p id="e07b" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">7.<a class="ae mm" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="25bc" class="ip iq mn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">8.<a class="ae mm" rel="noopener" href="/edureka/learn-node-js-b3a9c6fb632c"> Express.js基础</a></p></blockquote></div><div class="ab cl mv mw go mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ha hb hc hd he"><p id="2a45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="mn">原载于2019年7月8日https://www.edureka.co</em><em class="mn">T21</em><a class="ae mm" href="https://www.edureka.co/blog/node-js-docker-tutorial/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>