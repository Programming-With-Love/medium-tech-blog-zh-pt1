<html>
<head>
<title>Exploring the v28 Android Design Support Library Additions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索v28 Android设计支持库的新增功能</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-the-v28-android-design-support-library-2c96c6031ae8?source=collection_archive---------0-----------------------#2018-04-19">https://medium.com/google-developer-experts/exploring-the-v28-android-design-support-library-2c96c6031ae8?source=collection_archive---------0-----------------------#2018-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/068366299dd729c45243241e6fec98e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TkN2T01jDMhEqJFTtCfFw.png"/></div></div></figure><p id="67ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android支持库的第28版最近发布了——在当前的alpha版本中，有一系列令人兴奋的新组件，我们现在可以访问它们了。在本文中，我想看看以材料视图组件的形式添加到支持库中的内容。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><figure class="jv jw jx jy fd ii er es paragraph-image"><a href="http://eepurl.com/dIKgiT"><div class="er es ju"><img src="../Images/e8dd46ab2c119165e7a212299a73013e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-QbIIAzOjpz4kfDKWkgGg.png"/></div></a></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="75c8" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">材料按钮</h1><p id="86c1" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">材质按钮是一个小部件，可用于在应用程序用户界面中显示材质样式按钮。这个类是从你可能已经在你的项目中使用的AppCompatButton 类扩展而来的，但是这有什么不同呢？开箱后，该按钮将采用材质的外观和感觉进行设计，无需使用样式标志进行定制。我们可以直接使用MaterialButton类，在我们的视图中，它已经有了我们想要的材质外观——把它看作一个方便的类。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/6099de7e28d1bcb4f20abb6e58c0fd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTXKK9cO7fBW7zthNYdpvA.png"/></div></div></figure><p id="2231" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以将这个按钮添加到布局文件中，如下所示:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="6da2" class="li ka hh le b fi lj lk l ll lm">&lt;android.support.design.button.MaterialButton<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="MATERIAL BUTTON"<br/>    android:textSize="18sp"<br/>    app:icon="@drawable/ic_android_white_24dp" /&gt;</span></pre><p id="4ded" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，这个类将使用主题的强调色作为按钮填充的背景色，白色作为按钮文本的颜色。如果按钮没有被填充，那么你的主题的强调色将会和透明的背景一起作为按钮文本的颜色。</p><p id="774c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们希望自己添加一些样式，那么我们可以通过使用<strong class="ir hi"> MaterialButton </strong>样式的属性集合来实现。</p><ul class=""><li id="4fbc" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:图标</strong>——用于定义在按钮的<strong class="ir hi">开始</strong>处显示的可绘制</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/746c28ee1a85cd67f5c430897a408a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_kVv8hWcu-Uo7pRrrwhSSQ.png"/></div></div></figure><ul class=""><li id="0a72" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:iconTint </strong> —用于给<strong class="ir hi"> </strong> app:icon属性中正在使用的图标着色</li><li id="7e67" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi"> app:iconTintMode </strong> —定义用于图标着色的模式</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/354949219204242ef875bfea2e36e76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJhaV9sAovTdDD5hyLaJLw.png"/></div></div></figure><ul class=""><li id="faa2" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:iconPadding </strong> —应用于<strong class="ir hi"> </strong> app:icon属性中正在使用的图标的填充</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/839876dcf168abe87020185a5aa247dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBBRMPyvoqxjfb8fQT9VLg.png"/></div></div></figure><ul class=""><li id="0fdb" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi">app:additionalPaddingLeftForIcon</strong>—从<strong class="ir hi"> </strong> app:icon属性中定义要应用于正在使用的图标左侧的填充</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/e2244c76fa51c6214b3b46219544d030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aKHFx9FdS4v7-7alm9XJQ.png"/></div></div></figure><ul class=""><li id="1efe" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi">app:additionalPaddingRightForIcon</strong>—从<strong class="ir hi"> </strong> app:icon属性中定义要应用于正在使用的图标右侧的填充</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/c5b3d7d10edc61ed4707101e9575ab5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRwd2xRL7PaBgRGUotrSMw.png"/></div></div></figure><ul class=""><li id="2b90" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:rippleColor </strong></li><li id="c45a" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi"> app:backgroundTint </strong> —用于给按钮的背景应用色调。如果您希望更改按钮的背景颜色，请使用此属性而不是背景，以避免破坏按钮样式</li><li id="ac9f" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi">app:backgroundTintMode</strong><em class="mb">—</em>用于定义背景色调的模式</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/25750eaf8c78067afc373e6d2af03d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2CInMDFJrnbh-nSAtym2A.png"/></div></div></figure><ul class=""><li id="0c53" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:strokeColor </strong> —用于按钮笔划的颜色</li><li id="481e" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi"> app:strokeWidth </strong> —按钮笔画使用的宽度</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/0847ac0e16893860918612f78189f763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5xuMffU2PmN42Z-gfSDJA.png"/></div></div></figure><ul class=""><li id="03df" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:cornerRadius </strong> —用于定义按钮边角的半径</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/1158219fac1fa4458a8179890ff7e2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VtdQ_0WsFkEqGT9duV3BA.png"/></div></div></figure><h1 id="62ae" class="jz ka hh bd kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw bi translated">芯片</h1><p id="f252" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">芯片组件允许我们在布局中显示芯片视图。这实际上是一些给定了圆形背景的文本——其目的是向用户显示某种形式的文本集合，这些文本集合可能是可选的，也可能是不可选的。例如，这些可以用来根据应用程序中的当前上下文向用户显示可选建议的列表。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/da191772ffd5ed8c75bb6ade8416767d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnTy_64JX3KMtgxjick3Ig.png"/></div></div></figure><p id="1f1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以像这样向我们的布局添加一个芯片，使用<strong class="ir hi"> app:chipText </strong>属性来设置要在芯片上显示的文本:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="5e47" class="li ka hh le b fi lj lk l ll lm">&lt;android.support.design.chip.Chip<br/>    android:id="@+id/some_chip"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:chipText="This is a chip" /&gt;</span></pre><p id="caee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还有一组其他属性可用于进一步设计芯片:</p><ul class=""><li id="33e8" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:可勾选</strong> —用于声明芯片是否可以切换为选中/不选中。如果禁用，复选标记的行为与按钮相同</li><li id="2bc6" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi"> app:chipIcon </strong> —用于显示芯片内的图标</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/e11c3ed8a48755439b6c3ff05ed80b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaKdUrOoikE8GlfHaCaSGA.png"/></div></div></figure><ul class=""><li id="2fba" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:closeIcon </strong> —用于显示芯片内的关闭图标</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/91360a41b9c38c910fb67eb66c39540c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RF1mDIhq05DkuyUyl2gkA.png"/></div></div></figure><p id="2534" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还可以在我们的芯片实例上设置一些监听器，这对于监听用户的交互很有用。如果我们的芯片是可检查的，很可能我们想要监听这个检查状态何时被改变。我们可以使用<strong class="ir hi">setOnCheckedChangeListener</strong>监听器来实现:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="3443" class="li ka hh le b fi lj lk l ll lm">some_chip.setOnCheckedChangeListener <strong class="le hi">{ </strong>button, checked <strong class="le hi">-&gt;  }</strong></span></pre><p id="7907" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样的道理也适用于当关闭图标被使用时，我们想要监听它的交互。为此，我们可以利用<strong class="ir hi">setOnCloseIconClickListener</strong>函数来注册近距离交互事件:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="b7c7" class="li ka hh le b fi lj lk l ll lm">some_chip.setOnCloseIconClickListener <strong class="le hi">{  }</strong></span></pre><h1 id="908b" class="jz ka hh bd kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw bi translated">芯片组</h1><p id="c956" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">如果我们向用户显示一组芯片，我们希望确保它们在我们的视图中被正确地分组在一起。为此，我们可以利用芯片组视图组件:</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/80e4adb583132c25f352483dccc7d9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRkop7NwPjsQuCubZv2U4Q.png"/></div></div></figure><p id="88a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们希望使用芯片组，我们只需要将我们的芯片视图包装在一个父芯片组组件中:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="3264" class="li ka hh le b fi lj lk l ll lm">&lt;android.support.design.chip.ChipGroup<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"&gt;<br/><br/>    &lt;android.support.design.chip.Chip<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        app:chipText="This" /&gt;<br/><br/>    &lt;android.support.design.chip.Chip<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        app:chipText="is" /&gt;<br/><br/>    // more chips...<br/><br/>&lt;/android.support.design.chip.ChipGroup&gt;</span></pre><p id="77e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，您的芯片视图可能会显得有点拥挤。如果是这样，您可以使用芯片组本身的以下属性为子视图增加一些间距:</p><ul class=""><li id="46dd" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:芯片间距</strong>-增加水平轴和垂直轴的间距</li><li id="ed3f" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi">app:chips pacing horizontal</strong>—增加水平轴的间距</li><li id="1ea1" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi">app:chips pacing vertical</strong>—增加垂直轴的间距</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/0e72531063620b5468c7b28022e5fd08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PX63ZCqWMA1zhfaZFgXbPw.png"/></div></div></figure><p id="674e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还可以声明我们的子芯片视图在我们的芯片组容器中的一行中显示。使用<strong class="ir hi"> app:单线</strong>属性:</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/78d9b6724e74908698dcc0b51454428b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45yvzHWZk96q08ZHLClpgw.png"/></div></div></figure><p id="85d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样做时，您需要在滚动视图(如HorizontalScrollView)中包装芯片组，以便您的用户可以滚动显示芯片:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="443f" class="li ka hh le b fi lj lk l ll lm">&lt;HorizontalScrollView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"&gt;<br/><br/>    &lt;android.support.design.chip.ChipGroup<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        app:singleLine="true"&gt;<br/><br/>        &lt;android.support.design.chip.Chip<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            app:chipText="Some chip" /&gt;<br/><br/>        // more chips...</span><span id="a49e" class="li ka hh le b fi mh lk l ll lm">    &lt;/android.support.design.chip.ChipGroup&gt;<br/><br/>&lt;/HorizontalScrollView&gt;</span></pre><h1 id="a6e3" class="jz ka hh bd kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw bi translated">材料卡片视图</h1><p id="8882" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在我们的应用程序中，我们可能在某个时候使用了CardView组件。支持库现在包含一个名为Material Card View的组件，它为我们提供了一个现成的Material风格的Card View实现。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/40572b434f3df4d86d9aee4438eee911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AV0qPqn8IJcRB8TvQfCVA.png"/></div></div></figure><p id="b304" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">cardview可以添加到您的布局中，如下所示:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="1f7b" class="li ka hh le b fi lj lk l ll lm">&lt;android.support.design.card.MaterialCardView<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:layout_margin="16dp"&gt;</span><span id="a412" class="li ka hh le b fi mh lk l ll lm">    ... child views ...</span><span id="ae6d" class="li ka hh le b fi mh lk l ll lm">&lt;/android.support.design.card.MaterialCardView&gt;</span></pre><p id="9a33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用附带的两个属性来进一步设计cardview的样式:</p><ul class=""><li id="4cde" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:strokeColor </strong> —用于给定笔画的颜色，必须设置该颜色以显示笔画</li><li id="8e90" class="ln lo hh ir b is lw iw lx ja ly je lz ji ma jm ls lt lu lv bi translated"><strong class="ir hi"> app:strokeWidth </strong> —应用于视图描边的宽度</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/1aef537cee810f930e21ab90f4737f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjiSntrfm6MBPRsudwpeFw.png"/></div></div></figure><p id="d8b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了这两个属性之外，您还可以使用原来可用的属性(如app:cardBackgroundColor等)来设置cardview的样式。</p><h1 id="de69" class="jz ka hh bd kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw bi translated">底部应用程序栏</h1><p id="af6c" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">底部的应用程序栏是一个新的组件，它允许我们在布局的底部显示一个类似工具栏的组件。这允许我们以一种比标准工具栏更容易交互的方式向用户显示组件。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/795312e314e46182a45dbafd1cd5910f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxUcbBvlYMOSOJ-CZVJu-g.png"/></div></div></figure><p id="8217" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以将BottomAppBar添加到布局文件中，如下所示:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="6949" class="li ka hh le b fi lj lk l ll lm">&lt;android.support.design.bottomappbar.BottomAppBar<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:layout_gravity="bottom"<br/>    app:backgroundTint="@color/colorPrimary"<br/>    app:popupTheme="@style/ThemeOverlay.AppCompat.Light"<br/>    app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt;</span></pre><p id="8b14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">似乎底部的应用程序栏<strong class="ir hi">必须</strong>分配有菜单才能在屏幕上显示。这可以通过编程实现，如下所示:</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="07b6" class="li ka hh le b fi lj lk l ll lm">bottom_app_bar.replaceMenu(R.menu.main)</span></pre><p id="6ba0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当设计底部应用程序栏的样式时，有几个属性可以利用。</p><ul class=""><li id="7a91" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:fabAttached </strong> —表示一个FAB是否已经连接到底部app栏。您可以通过使用底部应用程序栏的ID，在您想要连接的fab组件上使用<strong class="ir hi"> app:layout_anchor </strong>来连接FAB。如果连接了FAB，它将被插入到底部应用程序栏中，否则FAB将保持在底部应用程序栏上方。</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/c3075274a313029632e11e515d7945a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnZxheso-vWDTBmH8o4xIg.png"/></div></div></figure><ul class=""><li id="2bec" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:fabAlignmentMode </strong> —声明已经贴在底部app栏上的FAB的位置。这可以是<strong class="ir hi">结束</strong>:</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/879bc87f3748dbf52eda91ea23e8cbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmvZpuFBngyn6r1TRqO8YQ.png"/></div></div></figure><p id="82f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或<strong class="ir hi">居中</strong>:</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/795312e314e46182a45dbafd1cd5910f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxUcbBvlYMOSOJ-CZVJu-g.png"/></div></div></figure><ul class=""><li id="93d6" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi">app:fabscradleverticaloffset</strong>—声明用于附加fab的垂直偏移。默认情况下，这是0dp:</li></ul><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/ec158670f83c6c9dc54a2463476840b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*du591XX2cDBCgDFezZ14OA.png"/></div></div></figure><p id="f4fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，设置dp值将允许FAB垂直向上移动:</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/879bc87f3748dbf52eda91ea23e8cbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmvZpuFBngyn6r1TRqO8YQ.png"/></div></div></figure><ul class=""><li id="a73b" class="ln lo hh ir b is it iw ix ja lp je lq ji lr jm ls lt lu lv bi translated"><strong class="ir hi"> app:backgroundTint </strong> —用于对视图的背景应用色调。如果你想设置视图的背景颜色，那么应该在android:background属性上使用。这样做将确保视图的主题保持稳定。</li></ul><h1 id="6cde" class="jz ka hh bd kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw bi translated">结论</h1><p id="3ecb" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在我看来，这些是对支持库的一些巧妙的补充——我期待着能够使用开箱即用的材料主题组件。我也很高兴能找到底部应用程序栏的使用案例，但我相信在支持库版本稳定之前还有一段时间。像往常一样，我很乐意听到您对这些新组件的想法或评论！</p><div class="mi mj ez fb mk ml"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hi fi z dy mq ea eb mr ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead &amp;高级工程师@Buffer。谷歌开发专家…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">twitter.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz in ml"/></div></div></a></div></div></div>    
</body>
</html>