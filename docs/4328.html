<html>
<head>
<title>Advanced FP for the Enterprise Bee: Applicatives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业蜂的高级FP:应用程序</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c?source=collection_archive---------4-----------------------#2021-01-15">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c?source=collection_archive---------4-----------------------#2021-01-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/c81bb36e997155a21088b70293296fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*M1mKM3l9OCuW5bgC.png"/></div><figcaption class="il im et er es in io bd b be z dx">Containers of Honey</figcaption></figure><h1 id="a24a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="4fea" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在本系列的第一篇文章中，我们展示了<em class="km">遍历</em>操作符是多么有用。作为其中的一部分，我们使用了适用的而没有进一步的解释。在本文中，我们将从头开始解释<em class="km">应用程序</em>，然后回到最初的例子。这个系列的所有代码都可以在这个库中找到。</p><h1 id="0947" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">样本问题</h1><p id="c586" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就像上次一样，让我们说我们团队的常驻FP超级粉丝一直在努力工作。这一次他们转换了一个UI助手函数来返回一个<em class="km">或者</em>。</p><p id="5067" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如您所见，我们向用户提问，然后检查答案是否与模式匹配:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="be8b" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如果一切顺利，我们返回一个包含他们响应的<em class="km"> Right </em>。在出现错误的情况下，我们返回一个带有适当信息的<em class="km">左</em>。</p><p id="6598" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">假设你试试这个。但是因为FP不是你的东西，你很难处理不同的排列。特别是，如果一切顺利，你需要想出如何将两个右<em class="km">值的内容组合起来。这里有一个潜在的解决方案:</em></p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="67f9" class="ld iq hh kz b fi le lf l lg lh">What's your name?<br/>Lucy<br/>Where do you live?<br/>Melbourne<br/>Hello Lucy from Melbourne</span></pre><p id="a0c5" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">这确实给出了所需的输出，但是这太程序化了，而且感觉不对。肯定有更好的方法吧？</p><h1 id="a505" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍应用程序</h1><p id="f82a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这里有一个更好的方法来解决这个问题。它要求我们编写一个特殊的函数，我称之为<em class="km">动作</em>。</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="fe5c" class="ld iq hh kz b fi le lf l lg lh">val action = { name: String -&gt; { location: String -&gt; "Hello $name from $location" } }</span></pre><p id="9866" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如您所见，我们有:</p><ul class=""><li id="bae7" class="li lj hh jp b jq kn ju ko jy lk kc ll kg lm kk ln lo lp lq bi translated">一个lambda，它接受一个名为<em class="km"> name </em>的参数，并返回一个lambda</li><li id="7cac" class="li lj hh jp b jq lr ju ls jy lt kc lu kg lv kk ln lo lp lq bi translated">第二个lambda接受一个名为<em class="km"> location </em>的参数，并返回一个字符串</li><li id="5cb8" class="li lj hh jp b jq lr ju ls jy lt kc lu kg lv kk ln lo lp lq bi translated">该字符串包括<em class="km">名称</em>和<em class="km">位置</em>的值</li></ul><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="4dd9" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">然后我们在表达式<code class="du lw lx ly kz b">name.map(action)</code>中使用它——这本身就很奇怪。如你所知<em class="km"> map </em>应用了一个转换，但是通常我们在标准数据类型之间转换，比如<em class="km"> String </em>和<em class="km"> Int </em>。</p><p id="406f" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在这种情况下，将返回一个包含lambda的<em class="km">右</em>，并提供了<em class="km">名称</em>参数，但仍缺少<em class="km">位置</em>参数。这可以被称为“部分应用的功能”。</p><p id="d3cb" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">然后我们将这个表达式嵌套在对ap 的调用中，如下所示:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="cdb7" class="ld iq hh kz b fi le lf l lg lh">val result = location.ap(name.map(action))</span></pre><p id="827e" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><em class="km"> ap </em>操作符针对<em class="km">或</em>被调用，并期望包含部分应用功能的<em class="km">或</em>作为其输入。它通过提供当前<em class="km">或</em>中的值(如果可用)来完成函数的应用。</p><p id="3116" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在快乐路径上，来自<em class="km"> ap </em>的返回值是一个<em class="km">或者</em>包含来自内部lambda的返回值。在这种情况下，这是我们给用户的问候消息。成功！</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="dd25" class="ld iq hh kz b fi le lf l lg lh">What's your name?<br/>Jane<br/>Where do you live?<br/>Bristol<br/>Hello Jane from Bristol</span></pre><h1 id="2eef" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">解释适用的</h1><p id="25d7" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">本质上，<em class="km">应用程序</em>提供了一种方法来操作一个容器类型的两个或更多实例的内容，而不必求助于程序上的诡计。<em class="km"> ap </em>函数是最常用的，但是还有许多其他操作符用于创建和组合实例。</p><p id="11b3" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">要做到这一点，你的动作必须以上述方式书写。您必须提供一个接受单个输入的函数，然后返回一个期望额外输入的函数。幸运的是，Arrow提供了一个<em class="km"> curry </em>操作符，将一个带多个参数的lambda转换成这样一个链:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="5626" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如果我们看一下<em class="km"> ap </em>方法的实现，会感到困惑:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="5bb7" class="ld iq hh kz b fi le lf l lg lh">fun &lt;A, B, C&gt; EitherOf&lt;A, B&gt;.ap(ff: EitherOf&lt;A, (B) -&gt; C&gt;): Either&lt;A, C&gt; =<br/>  <em class="km">flatMap </em><strong class="kz hi">{ </strong>a <strong class="kz hi">-&gt; </strong>ff.<em class="km">fix</em>().map <strong class="kz hi">{ </strong>f <strong class="kz hi">-&gt; </strong>f(a) <strong class="kz hi">} }</strong></span></pre><p id="6ed7" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">正如你所看到的，上一篇文章中神秘的<em class="km">修复</em>方法再次被使用。另外，在我们期望看到<em class="km">的地方，</em>我们看到了<em class="km">或者</em>。现在我们不要担心这个，这将在下一篇关于更高级类型的文章中讨论。</p><h1 id="eda7" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">重访导线</h1><p id="d4e9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果你记得上次，这就是我们如何调用<em class="km">遍历</em>操作:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="c5ef" class="ld iq hh kz b fi le lf l lg lh">val result = input.traverse(Either.applicative(), ::propertyViaJVM)</span></pre><p id="70fc" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">现在你可以看到<em class="km">应用</em>是如何帮助我们建立最终结果的。但这是一种略有不同的用法。对<em class="km">应用型</em>的调用返回一个单例实例。这又包含了许多用于组合(在本例中)<em class="km">或</em>对象的辅助方法。</p><p id="b218" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">这是我们最初的例子，重写后使用了Singleton。当我们调用<em class="km"> tupledN </em>方法时，我们(在快乐路径上)得到一个包含用户输入的<em class="km"> Tuple2 </em>的<em class="km"> Right </em>。</p><p id="4c61" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我们可以像往常一样用<em class="km">映射</em>，并根据需要从<em class="km"> Tuple2 </em>中获取值。在元组的箭头实现中，属性被简单地称为“a”、“b”、“c”等等。</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="b69d" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如果你深究一下，你会发现箭头中的<a class="ae kl" href="https://arrow-kt.io/docs/apidocs/arrow-core-data/arrow.typeclasses/-applicative/index.html#applicative" rel="noopener ugc nofollow" target="_blank">应用类型是从</a><a class="ae kl" href="https://arrow-kt.io/docs/apidocs/arrow-core-data/arrow.typeclasses/-apply/index.html" rel="noopener ugc nofollow" target="_blank">扩展而来的一种叫做Apply </a>的类型，这也是<em class="km"> tupledN </em>方法被声明的地方。这是Arrow实现的一个细节，但仍然值得一提。</p><p id="4cca" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><em class="km"> Apply </em>类型还声明了一个<em class="km"> mapN </em>操作，其契约允许所提供的函数并行执行。下面是它的使用方法:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="8af8" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">适用并经过验证</h1><p id="1db2" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">正如在上一篇文章中，我们可以通过从<em class="km">或者</em>切换到<em class="km">验证的</em>来改进原始代码。<em class="km">验证的</em>类型增加了合并错误消息的额外功能。</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1a55" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我们需要告诉经过<em class="km">验证的</em>实例我们想要如何组合多个实例。我们通过提供一个<em class="km">半群</em>来做到这一点。这只是一个带有<em class="km">组合</em>方法的对象。Arrow为所有标准Kotlin类型提供了<em class="km">半群</em>:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="4f2f" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">字符串的默认半群<em class="km">将两个值连接起来。在多个错误的情况下，消息将一起运行:</em></p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="1394" class="ld iq hh kz b fi le lf l lg lh">What's your name?<br/>123<br/>Where do you live?<br/>456<br/>Sorry: 123 does not match [A-Z a-z]+456 does not match [A-Z a-z]+</span></pre><p id="488e" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我们可以通过指定我们自己的半群来避免这种情况，它通过用空格和逗号连接来组合字符串:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="dd35" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">现在，我们的错误消息将以逗号分隔:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="a50c" class="ld iq hh kz b fi le lf l lg lh">What's your name?<br/>123<br/>Where do you live?<br/>456<br/>Sorry: 123 does not match [A-Z a-z]+ , 456 does not match [A-Z a-z]+</span></pre><p id="b625" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">太棒了。直接调用<em class="km"> ap </em>操作符似乎比使用Singleton实例更简单，所以让我们用那个版本结束:</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="7cd9" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="186c" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在本文中，我们探讨了适用的类型和<em class="km"> ap </em>操作符。在这个过程中，我们也看到了什么是半群<em class="km">和</em>。下一轮我们将解决另一个悬而未决的问题，即<em class="km">修复</em>方法和<em class="km">高级类型</em>。敬请关注…</p><h1 id="76bc" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">谢谢</h1><p id="72b2" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">感谢<a class="ae kl" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kl" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。所有的错误当然是我自己的。</p></div></div>    
</body>
</html>