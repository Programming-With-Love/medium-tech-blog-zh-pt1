<html>
<head>
<title>Create an application CoroutineScope using Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hilt创建一个应用程序协同作用域</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/create-an-application-coroutinescope-using-hilt-dd444e721528?source=collection_archive---------1-----------------------#2021-06-10">https://medium.com/androiddevelopers/create-an-application-coroutinescope-using-hilt-dd444e721528?source=collection_archive---------1-----------------------#2021-06-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1f0df8d64c0e9ec9cdb2da020a7a7508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgDtM-AJmc2m2hg5chkflg.png"/></div></div></figure><div class=""/><p id="dcb1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">遵循<a class="ae jn" href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices" rel="noopener ugc nofollow" target="_blank">协程的最佳实践</a>，你可能需要在一些类中注入一个应用范围的<code class="du jo jp jq jr b">CoroutineScope</code>来<a class="ae jn" href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices#create-coroutines-data-layer" rel="noopener ugc nofollow" target="_blank">启动遵循应用生命周期的新协程，或者使某些工作超出调用者的范围</a>。</p><p id="dfe8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您将学习如何使用Hilt创建一个应用程序范围的<code class="du jo jp jq jr b">CoroutineScope</code>，以及如何将其作为一个依赖项注入。为了进一步改进我们使用协程的方式，我们将看看如何在测试中注入不同的<code class="du jo jp jq jr b">CoroutineDispatcher</code>并替换它们的实现。</p><h1 id="8ca9" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">手动依赖注入</h1><p id="be37" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">要创建一个<a class="ae jn" rel="noopener" href="/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0">应用程序范围的</a> <code class="du jo jp jq jr b">CoroutineScope</code>遵循依赖注入(DI)最佳实践<a class="ae jn" href="https://developer.android.com/training/dependency-injection/manual" rel="noopener ugc nofollow" target="_blank">手动</a>没有任何库，您通常会用一个<code class="du jo jp jq jr b">CoroutineScope</code>的实例向您的应用程序类添加一个新变量。创建其他对象时，将手动传递同一个实例。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="5ae3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于在Android中没有可靠的方法知道<code class="du jo jp jq jr b">Application</code>何时被销毁，所以您不需要手动调用<code class="du jo jp jq jr b">applicationScope.cancel()</code>，因为当应用程序进程结束时，作用域和所有正在进行的工作都将被销毁。</p><p id="3e43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">手动完成这项工作的一个更好的选择是创建一个保存应用程序范围类型的<code class="du jo jp jq jr b">ApplicationContainer</code>类。这有助于分离关注点，因为这些<em class="lb">容器</em>类负责:</p><ul class=""><li id="ac72" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">处理逻辑<em class="lb">如何</em>构建某些类型，</li><li id="94bc" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">保存容器范围的类型实例，以及</li><li id="9ee8" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">返回限定范围和未限定范围类型的实例。</li></ul><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><blockquote class="lq lr ls"><p id="32f0" class="ip iq lb ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:容器总是返回作用域类型的同一个实例，并且总是返回未作用域类型的<em class="hs">不同的</em>实例。将类型作用于容器的代价是很高的，因为作用域对象在组件被破坏之前一直留在内存中，所以只作用于真正需要的对象。</p></blockquote><p id="b643" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的<code class="du jo jp jq jr b">ApplicationDiContainer</code>例子中，所有类型都被限定了范围。如果不需要将MyRepository限定在应用程序的范围内，我们应该:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="4a79" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在你的应用程序中使用Hilt</h1><p id="4796" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">希尔特生成你能在<code class="du jo jp jq jr b">ApplicationDiContainer</code>里看到的东西(还有更多！)在编译时使用注释。此外，Hilt为大多数Android框架类提供容器，而不仅仅是T2类。</p><p id="3154" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在你的应用程序中设置Hilt并为<code class="du jo jp jq jr b">Application</code>类创建容器，用<code class="du jo jp jq jr b">@HiltAndroidApp</code>注释你的<code class="du jo jp jq jr b">Application</code>类。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="e66f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，应用程序DI容器就可以使用了。我们只需要让Hilt知道如何提供不同类型的实例。</p><blockquote class="lq lr ls"><p id="2cdd" class="ip iq lb ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><strong class="ir ht">注</strong>:在Hilt中，容器类被引用为<em class="hs">组件</em>。与<code class="du jo jp jq jr b">Application</code>类相关的容器被称为<code class="du jo jp jq jr b">SingletonComponent</code>。查看所有可用刀柄组件的<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#generated-components" rel="noopener ugc nofollow" target="_blank">列表。</a></p></blockquote><h1 id="22f2" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">建筑注射</h1><p id="a215" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">如果我们可以访问一个类的构造函数，构造注入是让Hilt知道如何提供一个类型的实例的最简单的方法，因为我们只需要用<code class="du jo jp jq jr b">@Inject</code>注释构造函数:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="700a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这让Hilt知道，为了提供一个<code class="du jo jp jq jr b">MyRepository</code>类的实例，需要将一个<code class="du jo jp jq jr b">CoroutineScope</code>的实例作为依赖项传递。Hilt在编译时生成代码，以确保在创建一个类型的实例时满足并传递依赖关系，或者在没有足够信息的情况下给出错误。<code class="du jo jp jq jr b">@Singleton</code>用于将该类的范围扩大到<code class="du jo jp jq jr b">SingletonContainer</code>。</p><p id="cba1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，Hilt不知道如何满足<code class="du jo jp jq jr b">CoroutineScope</code>依赖性，因为我们还没有告诉Hilt如何去做。下面几节将解释我们如何让Hilt知道传递什么作为依赖项。</p><blockquote class="lq lr ls"><p id="af91" class="ip iq lb ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><strong class="ir ht">注</strong>:对于不同的刀柄可用组件，刀柄提供了不同的作用域类型注释。查看所有可用组件范围的<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#component-scopes" rel="noopener ugc nofollow" target="_blank">列表</a>。</p></blockquote><h1 id="146f" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">粘合剂</h1><p id="5bb1" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">一个<em class="lb">绑定</em>是一个在Hilt中常用的术语，表示<strong class="ir ht">信息</strong> Hilt知道如何提供一个类型的实例作为依赖。我们可以说，我们用上面代码片段的<code class="du jo jp jq jr b">@Inject</code>注释添加了一个到Hilt的绑定。</p><p id="fd7b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">绑定流过<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy" rel="noopener ugc nofollow" target="_blank">刀柄的组件层次</a>。在<code class="du jo jp jq jr b">SingletonComponent</code>中可用的绑定在<code class="du jo jp jq jr b">ActivityComponent</code>中也可用。</p><p id="678c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">未分类类型的绑定(一个例子可能是上面的<code class="du jo jp jq jr b">MyRepository</code>代码，如果它没有用<code class="du jo jp jq jr b">@Singleton</code>注释的话)，在<em class="lb">所有</em>手柄组件中都可用。作用于组件的绑定，比如用<code class="du jo jp jq jr b">@Singleton</code>注释的<code class="du jo jp jq jr b">MyRepository</code>，对于作用域组件和层次结构中低于它的组件都是可用的。</p><h1 id="6a6b" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为类型提供模块</h1><p id="6693" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">如上所述，我们需要让Hilt知道如何满足<code class="du jo jp jq jr b">CoroutineScope</code>依赖。然而，<code class="du jo jp jq jr b">CoroutineScope</code>是一个来自外部库的接口类型，所以我们不能像以前使用<code class="du jo jp jq jr b">MyRepository</code>类那样使用构造函数注入。另一种方法是让Hilt知道在使用模块提供类型<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules" rel="noopener ugc nofollow" target="_blank">的实例时运行什么代码:</a></p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="1e64" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#inject-provides" rel="noopener ugc nofollow" target="_blank"/><code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#inject-provides" rel="noopener ugc nofollow" target="_blank">@Provides</a></code><a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#inject-provides" rel="noopener ugc nofollow" target="_blank">方法</a>用<code class="du jo jp jq jr b">@Singleton</code>注释，使句柄<em class="lb">总是</em>返回那个<code class="du jo jp jq jr b">CoroutineScope</code>的同一个实例。这是因为任何需要遵循应用程序生命周期的工作都应该使用遵循<code class="du jo jp jq jr b">Application</code>生命周期的<code class="du jo jp jq jr b">CoroutineScope</code>的同一个实例来创建。</p><p id="209c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">句柄模块用<code class="du jo jp jq jr b">@InstallIn</code>标注，表示绑定安装在哪个句柄组件(以及层次结构中的下一个组件)中。在我们的例子中，由于<code class="du jo jp jq jr b">MyRepository</code>需要应用程序<code class="du jo jp jq jr b">CoroutineScope</code>，而应用程序的作用域是<code class="du jo jp jq jr b">SingletonComponent</code>，所以这个绑定也需要安装在<code class="du jo jp jq jr b">SingletonComponent</code>中。</p><p id="c1e0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用Hilt术语来说，我们可以说我们添加了一个<code class="du jo jp jq jr b">CoroutineScope</code>绑定，因为现在，Hilt知道如何提供<code class="du jo jp jq jr b">CoroutineScope</code>的实例。</p><p id="cb95" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，上面的代码片段还可以改进。<a class="ae jn" href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices#inject-dispatchers" rel="noopener ugc nofollow" target="_blank">硬编码调度程序在协程</a>中是一种不好的做法，我们应该将它们注入<strong class="ir ht">中，使它们可配置并使测试更容易</strong>。按照前面的代码，我们可以创建一个新的Hilt模块，让它知道为每种情况注入哪个调度程序:main、default和IO。</p><h1 id="7b03" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为CoroutineDispatcher提供实现</h1><p id="bd1f" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们必须为同一类型提供不同的实现:<code class="du jo jp jq jr b">CoroutineDispatcher</code>。换句话说，我们需要相同类型的不同绑定。</p><p id="e61a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-android#multiple-bindings" rel="noopener ugc nofollow" target="_blank"> <em class="lb">限定词</em> </a>来让Hilt知道每次使用哪个绑定或实现。限定符只是您和Hilt用来标识特定绑定的注释。让我们为每个<code class="du jo jp jq jr b">CoroutineDispatcher</code>实现创建一个限定符:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="a61d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，这些限定符对不同的<code class="du jo jp jq jr b">@Provides</code>方法进行注释，以识别Hilt模块中的特定绑定。<code class="du jo jp jq jr b">@DefaultDispatcher</code>限定符注释了返回默认调度程序的方法，依此类推。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="a161" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，这些<code class="du jo jp jq jr b">CoroutineDispatchers</code>不需要限定在<code class="du jo jp jq jr b">SingletonComponent</code>的范围内。每次需要这些依赖时，Hilt调用<code class="du jo jp jq jr b">@Provides</code>方法，返回对应的<code class="du jo jp jq jr b">CoroutineDispatcher</code>。</p><h1 id="c128" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">提供应用程序范围的协同作用域</h1><p id="88da" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">为了从我们之前的应用程序范围的<code class="du jo jp jq jr b">CoroutineScope</code>代码中去掉硬编码的<code class="du jo jp jq jr b">CoroutineDispatcher</code>，我们需要注入Hilt提供的默认调度程序。为此，我们可以传递我们想要注入的类型<code class="du jo jp jq jr b">CoroutineDispatcher</code>，使用相应的限定符<code class="du jo jp jq jr b">@DefaultDispatcher</code>，作为提供应用程序<code class="du jo jp jq jr b">CoroutineScope</code>的方法中的依赖项。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="bef0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于Hilt对<code class="du jo jp jq jr b">CoroutineDispatcher</code>类型有多个绑定，当<code class="du jo jp jq jr b">CoroutineDispatcher</code>被用作依赖项时，我们使用<code class="du jo jp jq jr b">@DefaultDispatcher</code>注释来消除它的歧义。</p><h1 id="340b" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">应用范围的限定符</h1><p id="d9c4" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">尽管目前我们不需要对<code class="du jo jp jq jr b">CoroutineScope</code>进行多重绑定(如果我们需要像<code class="du jo jp jq jr b">UserCoroutineScope</code>这样的东西，这种情况可能会在将来发生变化)，但是在将应用程序<code class="du jo jp jq jr b">CoroutineScope</code>作为依赖项注入时，向它添加一个限定符有助于提高可读性。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="764c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为<code class="du jo jp jq jr b">MyRepository</code>依赖于这个作用域，所以使用哪个外部作用域作为实现是非常清楚的:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="e853" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为仪器测试更换调度程序</h1><p id="aed9" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们之前说过，我们应该注入调度程序，以使测试更容易，并完全控制发生的事情。对于仪器测试，我们想让Espresso等待协程完成。</p><p id="8f22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以利用<a class="ae jn" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank"> AsyncTask </a> API，而不是用一些<a class="ae jn" href="https://developer.android.com/training/testing/espresso/idling-resource" rel="noopener ugc nofollow" target="_blank"> Espresso空闲资源</a>创建一个定制<code class="du jo jp jq jr b">CoroutineDispatcher</code>来等待协程完成。即使AsyncTask在Android API 30中被弃用，Espresso也会挂钩到它的线程池来检查空闲。因此，任何应该在后台线程中执行的协程都可以在AsyncTask的线程池中执行。</p><p id="82b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Hilt的<code class="du jo jp jq jr b">TestInstallIn</code> API让Hilt在测试中提供一个类型的不同实现。类似于上面我们提供不同调度程序的方式，我们可以在<code class="du jo jp jq jr b">androidTest</code>包下创建一个新文件，为这些调度程序提供不同的实现。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="b175" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过上面的代码，我们在测试中让Hilt“忘记”生产代码中使用的<code class="du jo jp jq jr b">CoroutinesDispatchersModule</code>。该模块将被替换为<code class="du jo jp jq jr b">TestCoroutinesDispatchersModule</code>，它使用异步任务的线程池来处理需要在后台发生的工作，而<code class="du jo jp jq jr b">Dispatchers.Main</code>则处理需要在主线程上发生的工作，Espresso也在等待主线程。</p><blockquote class="lq lr ls"><p id="3181" class="ip iq lb ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><strong class="ir ht">警告</strong>:这个实现显然是一个我们并不引以为豪的黑客。然而，协程程序目前并没有很好地与Espresso集成，因为没有办法知道<code class="du jo jp jq jr b">CoroutineDispatcher</code>此刻是否空闲(链接到bug )。<code class="du jo jp jq jr b">AsyncTask.THREAD_POOL_EXECUTOR</code>是目前最好的选择，因为Espresso不使用空闲资源来检查这个执行器是否空闲，Espresso使用不同的启发式算法来考虑消息队列中的内容。这使得它比类似于<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/androidx/test/espresso/idling/concurrent/IdlingThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank">IdlingThreadPoolExecutor</a></code>的东西更好，不幸的是，由于协程如何被编译到状态机，当协程被挂起时，它认为线程池是空闲的。</p></blockquote><p id="f505" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有关测试的更多信息，请查看<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-testing" rel="noopener ugc nofollow" target="_blank">刀柄的测试指南</a>。</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><p id="abcd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您学习了如何使用Hilt创建一个应用程序范围的<code class="du jo jp jq jr b">CoroutineScope</code>，将其作为依赖注入，注入不同的<code class="du jo jp jq jr b">CoroutineDispatcher</code>实例，并在测试中替换它们的实现。</p></div></div>    
</body>
</html>