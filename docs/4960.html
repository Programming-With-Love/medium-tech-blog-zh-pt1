<html>
<head>
<title>How to Secure Secrets 🔑 in Android (In-Depth) — Android Security-02</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护机密🔑在Android中(深入)— Android安全-02</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/secure-secrets-in-android-using-jetpack-security-in-depth-android-security-02-4026b8e012f4?source=collection_archive---------0-----------------------#2021-10-15">https://blog.kotlin-academy.com/secure-secrets-in-android-using-jetpack-security-in-depth-android-security-02-4026b8e012f4?source=collection_archive---------0-----------------------#2021-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cdd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在google I/O 2019中，Android团队发布了名为<strong class="jm io"> Jetpack Security </strong>的安全加密库，以方便开发人员构建安全的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02cf3cefe4616da2d1d9783815a47632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYwn1aBp_N19RuWDJ1urMw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image from FreePik</figcaption></figure><p id="6fb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理隐私问题时，安全性起着至关重要的作用。在我们的Android安全主题中，我们必须了解过去的方法及其缺点。请阅读我在Android安全系列中的前一篇文章，以便更好地了解它们。</p><div class="ky kz gp gr la lb"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-secure-secrets-in-android-android-security-01-a345e97c82be"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">如何保护机密🔑在Android中— Android Security-01</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">在构建处理API、从服务器接收的令牌的应用程序时，安全性是一个关键要求…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp ks lb"/></div></div></a></div></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><blockquote class="lx ly lz"><p id="43e4" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">反射</p></blockquote><p id="131c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个世界上，我们有数以百万计的人们正在使用的Android设备。其中一些设备的操作系统使用AES加密，而其他操作系统已经实现了<a class="ae me" href="https://opensource.google/projects/adiantum" rel="noopener ugc nofollow" target="_blank"> Adiantum </a>加密。现在，您的设备数据是安全的，但我们应用程序的数据呢？例如，您的应用程序正在处理个人身份数据、财务记录等敏感信息，或者您的应用程序是否运行在*根*设备上。</p><p id="80e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们必须提供更多的额外保护来确保其安全，这可以通过Jetpack Security轻松实现。它使用<a class="ae me" href="https://github.com/google/tink" rel="noopener ugc nofollow" target="_blank"> TINK </a>(谷歌开源库)。Tink提供了多种功能，包括:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/4398b5bf07cdcc543beeb50e8fb63928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9L1v1U35Z4ro_sL2btQJ1Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image from <a class="ae me" href="https://www.youtube.com/watch?v=2y9Ol2N1I4k" rel="noopener ugc nofollow" target="_blank">Securing your app for work</a></figcaption></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><blockquote class="lx ly lz"><p id="8c25" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated"><em class="in">社区参与度</em></p></blockquote><div class="ky kz gp gr la lb"><a href="https://androidweekly.net/issues/issue-488" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">Android Weekly -免费的每周Android &amp; Kotlin开发简讯</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">Android Weekly是一份免费的时事通讯，帮助你保持Android开发的前沿</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">androidweekly.net</p></div></div><div class="lk l"><div class="mg l lm ln lo lk lp ks lb"/></div></div></a></div><div class="ky kz gp gr la lb"><a href="https://dormoshe.io/newsletters/ag/android/78?utm_source=twitter&amp;utm_campaign=twitter" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">Android趋势# 78-2021年10月19日- Dor Moshe的博客</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">订阅时事通讯，享受每周学习新知识的最新动态。</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">dormoshe.io</p></div></div><div class="lk l"><div class="mh l lm ln lo lk lp ks lb"/></div></div></a></div></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="7390" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的第一篇文章中，我们简要讨论了什么是Jetpack安全。所以，直接进入这个库提供的功能，但首先，看看我们主要使用的最重要的API，Android Jetpack Security也继承了它的功能。</p><h1 id="11f1" class="mi mj in bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">密钥库API</h1><p id="7aac" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated">我们知道，保护机密通常以两种方式实现，首先是<strong class="jm io">公钥，</strong>这意味着一个密钥用于加密数据，另一个密钥用于解密数据。第二种类型是<strong class="jm io">对称加密</strong>，在这种方法中，相同的密钥用于加密和解密数据。Android Keystore API的后端混合使用这两种类型来提供更高的安全性。</p><p id="9cc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Keystore API通过以下方式使保护机密易于实现:</p><ul class=""><li id="7e14" class="nl nm in jm b jn jo jr js jv nn jz no kd np kh nq nr ns nt bi translated">首先，在应用程序第一次运行时生成一个随机密钥，并将其保存在密钥库中。</li><li id="bd3a" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">然后，为了存储秘密，首先从密钥库中检索密钥，用密钥加密数据，然后将加密的数据存储在共享首选项中。</li><li id="ee07" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">然后，为了访问数据，首先从共享首选项中读取加密的数据，从KeyStore中获取密钥，然后使用这个密钥解密数据。</li></ul><p id="a2d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我们的密钥是随机生成的，并且由Keystore API管理，那么我们为什么需要Jetpack安全性呢？</p><p id="a5b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在这里引用<a class="nz oa ep" href="https://medium.com/u/676a20de80ad?source=post_page-----4026b8e012f4--------------------------------" rel="noopener" target="_blank"> <strong class="jm io">迪诺拉·托瓦尔</strong>T3:</a></p><blockquote class="lx ly lz"><p id="21bb" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">你可能会问，如果我们已经有了<strong class="jm io"> android.security.keystore，</strong>，这使我们有机会创建两种类型的密钥，一个<em class="in">非对称密钥对或对称密钥，</em>这个新的<em class="in"> </em>库使用keystore提供的构建器模式，但以不同的风格，为密钥的创建提供安全设置，考虑到我们需要具有良好性能的良好加密。</p></blockquote><p id="fe75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Jetpack安全性大放异彩😎</p><p id="ff89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Jetpack security或JetSec </strong>提供以下主要功能:</p><ul class=""><li id="a7e3" class="nl nm in jm b jn jo jr js jv nn jz no kd np kh nq nr ns nt bi translated">万能钥匙管理</li><li id="608e" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">数据加密</li></ul><p id="d860" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许用户以简单和安全的方式在本地存储包含令牌、API密钥和用户凭证的文件。从密钥管理开始:</p><h1 id="1807" class="mi mj in bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated"><strong class="ak">主密钥管理/密钥库系统</strong></h1><blockquote class="lx ly lz"><p id="eed6" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">根据Android Keystore系统的官方文档</p></blockquote><p id="d8ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae me" href="https://developer.android.com/training/articles/keystore#SecurityFeatures" rel="noopener ugc nofollow" target="_blank"> Android密钥库系统</a>允许你将<strong class="jm io">密钥</strong>存储在一个容器中，使得从设备中提取密钥更加困难。一旦<strong class="jm io">密钥</strong>在<strong class="jm io">密钥库</strong>中，它们就可以在密钥材料保持不可导出的情况下用于加密操作。此外，它还提供了<strong class="jm io">限制何时以及如何使用</strong>密钥的功能，例如要求<strong class="jm io">用户认证</strong>密钥的使用，或者限制密钥只能在某些加密模式下使用。</p><p id="05c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">比如</strong>我们大多把钱放在储物柜里，用钥匙锁上。这意味着如果有人能拿到我的钥匙，那么这个人就能轻易地拿到我的钱。同样的场景在这里，密钥用于加密和解密数据，密钥存储在安全的硬件中，即使在根设备上也无法提取。</p><p id="a087" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Android密钥库包含每个密钥的别名。它的工作方式完全像一张地图，意思是“关键部分”-&gt;“关键部分”-&gt;“价值部分”-&gt;关键的描述。此外，Jetpack安全提供两种类型的密钥:</p><p id="c2bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">SubKeys</code>:它用于加密和解密数据，并将自身存储在共享偏好设置中。</p><p id="f851" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">MasterKey</code>:对所有<code class="fe ob oc od oe b">subkeys</code>进行加密，增加安全层，并将自身存储在密钥库中，使入侵者更难提取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/aec0bb5615ad4e1d223e3db3ebcba62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9th6Z5IZzyXB0jYh23UkRA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image from <a class="ae me" href="https://www.youtube.com/watch?v=2y9Ol2N1I4k" rel="noopener ugc nofollow" target="_blank">Securing your app for work</a></figcaption></figure><p id="7783" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">MasterKey</code>类提供获取默认主密钥的权限，该默认主密钥通过AES加密<strong class="jm io"> (AES256-GCM) </strong>实现。这是一个对称密钥，在现代设备上运行速度很快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">GetMasterKey using Jetpack Security</figcaption></figure><blockquote class="lx ly lz"><p id="7889" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">默认的<strong class="jm io"> AES256-GCM </strong>将用于加密少量不需要任何填充或阻塞的数据。</p></blockquote><p id="cec4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">哪里可以使用分块和填充？</strong></p><p id="0909" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的数据长度超过了密钥长度，那么我们需要阻塞和填充，因为大多数攻击和挑战都是在这种情况下发生的。</p><blockquote class="lx ly lz"><p id="5df8" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">根据<a class="nz oa ep" href="https://medium.com/u/e680fcaf274b?source=post_page-----4026b8e012f4--------------------------------" rel="noopener" target="_blank"> <strong class="jm io">比尔·布坎南教授的OBE </strong> </a></p></blockquote><p id="cb6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">Blocking</code>:在现代AES中，使用128位<strong class="jm io">块</strong>大小，这意味着它将<strong class="jm io"> 16个字符(或16位值)读入一个块，然后加密那个</strong>。在AES中，我们创建一个4x4矩阵，然后交换行和列，然后将它们放入S盒和P盒。</p><p id="4963" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">Padding</code>:用于<strong class="jm io">分组密码</strong>中，我们<strong class="jm io">用<strong class="jm io">填充字节</strong>填充</strong>块。AES使用128位(16字节)，DES使用64位块(8字节)。</p><p id="da1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们解密数据时，填充使我们保持正直。如果你在邮件末尾发现奇怪的字符，可能是因为你的填充不太正常。</p><p id="7694" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:如果我们使用“hello ”,那么我们必须填充到16个字节，这意味着有11个填充字节(0xB)给<a class="ae me" href="https://asecuritysite.com/encryption/padding" rel="noopener ugc nofollow" target="_blank">给</a>:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="548c" class="om mj in oe b gy on oo l op oq">After padding (CMS): 68656c6c6f0b0b0b0b0b0b0b0b0b0b0b<br/>Cipher (ECB): 0a7ec77951291795bac6690c9e7f4c0d<br/>  decrypt: hello</span></pre><p id="16fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，Jetpack Security还提供了灵活性，用户可以使用<code class="fe ob oc od oe b">KeyGenParameterSpec</code>类定义自己的自定义密钥参数规范。为了增加更多的安全层，用户可以通过<code class="fe ob oc od oe b">authorization</code>、<code class="fe ob oc od oe b">strongbox</code>、<code class="fe ob oc od oe b">biometric</code>或<code class="fe ob oc od oe b">faceidentification</code>来实现。</p><p id="0fa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Jetpack security推荐使用<code class="fe ob oc od oe b">time-bound</code>密钥方法，该方法在有限时间内锁定和解锁密钥:</p><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="2e6e" class="om mj in oe b gy on oo l op oq">setUserAuthenticationValidityDurationSeconds(120)</span></pre><p id="94ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这主要用于处理非常敏感的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The master key with advanced specification in Jetpack Security</figcaption></figure><p id="f08f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在以后的文章中讨论生物识别和其他提示。</p><h1 id="b729" class="mi mj in bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">数据加密</h1><p id="055c" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated">它提供:</p><ul class=""><li id="0a4c" class="nl nm in jm b jn jo jr js jv nn jz no kd np kh nq nr ns nt bi translated">加密的共享首选项</li><li id="38e1" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">加密文件</li></ul><p id="3a74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种加密都提供AEAD(验证加密和验证数据),确保数据存储的保密性和数据完整性不会被破坏。</p><h2 id="7b23" class="om mj in bd mk or os dn mo ot ou dp ms jv ov ow mw jz ox oy na kd oz pa ne pb bi translated">加密的共享首选项</h2><p id="9aac" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated">当我们希望存储少量数据，如API_Token、用户凭证等时，我们通常使用SharedPreferences。SharedPreference提供了在首选项创建时间定义的<code class="fe ob oc od oe b"><a class="ae me" href="https://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE" rel="noopener ugc nofollow" target="_blank">MODE_PRIVATE</a></code>标志，因此它将只由当前应用程序访问。🧐这意味着你的数据将不会被其他应用程序访问，但入侵者可以很容易地在内部目录中找到这个共享的首选文件。</p><p id="fa3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">EncrptedSharedPreference</strong>类为共享偏好设置提供加密。它加密密钥和值的方式如下:</p><p id="9a05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">Key</code>:它是通过确定性加密算法加密的，这意味着每次我们加密一个密钥，它都会以相同的方式加密，因此，它会被正确地查找。它使用静态初始化向量<code class="fe ob oc od oe b">AES256_SIV </code>类型来确保提供的相同<code class="fe ob oc od oe b">key value</code>的密文是相同的。</p><p id="e750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">Value</code>:非确定性加密，使用<code class="fe ob oc od oe b">AES256</code>类型加密。</p><blockquote class="lx ly lz"><p id="c561" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">加密密钥特性是为那些将敏感信息放在密钥中的开发人员而引入的。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">How encryptedsharedpreference work</figcaption></figure><p id="10bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">mainKeyAlias</code>:是你的万能钥匙</p><p id="3f31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV</code>:是一种密钥加密算法。</p><p id="a08d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM</code>:是一种数值加密算法。</p><h2 id="f7a9" class="om mj in bd mk or os dn mo ot ou dp ms jv ov ow mw jz ox oy na kd oz pa ne pb bi translated">加密文件</h2><p id="f24d" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated"><code class="fe ob oc od oe b">EncryptedFile</code>由Jetpack security提供的类对整个文件数据进行加密。现在处理<code class="fe ob oc od oe b">File</code>有两个操作，即<code class="fe ob oc od oe b">Read</code>和<code class="fe ob oc od oe b">Write</code>，因为<code class="fe ob oc od oe b">FileInputStream</code>和<code class="fe ob oc od oe b">FileOutputStream</code>的自定义实现，所以也是安全的。此外，它使用<strong class="jm io">流式AES加密</strong>来处理大文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">How encryptedfile work</figcaption></figure><p id="24a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的万能钥匙是</p><p id="cd37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ob oc od oe b">FileEncryptionScheme.AES256_GCM_HKDF_4KB</code>:用于加密数据的方案(将字节写入文件)。</p><p id="8677" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ma">文件中的退税:</em> </strong></p><p id="878b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没有办法修改文件中的现有数据，因为数据被分成块并以不可能重新排序的方式加密。我们唯一能做的是再次重新加密整个文件并修改它，但它有其局限性。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="4622" class="mi mj in bd mk ml pc mn mo mp pd mr ms mt pe mv mw mx pf mz na nb pg nd ne nf bi translated">履行</h1><p id="15ac" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated">该库仅兼容运行<strong class="jm io"> Android 6.0 (API 23) </strong>及更新版本的设备。</p><blockquote class="lx ly lz"><p id="d2e9" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">在app.gradle中声明<a class="ae me" href="https://developer.android.com/jetpack/androidx/releases/security" rel="noopener ugc nofollow" target="_blank">依赖关系</a></p></blockquote><pre class="kj kk kl km gt oi oe oj ok aw ol bi"><span id="fc7f" class="om mj in oe b gy on oo l op oq">dependencies {<br/>    implementation("androidx.security:security-crypto:1.0.0")<br/><br/>    // For Identity Credential APIs<br/>    implementation("androidx.security:security-identity-credential:1.0.0-alpha03")<br/><br/>    // For App Authentication APIs<br/>    implementation("androidx.security:security-app-authenticator:1.0.0-alpha02")<br/><br/>    // For App Authentication API testing<br/>    androidTestImplementation("androidx.security:security-app-authenticator:1.0.0-alpha01")<br/><br/>}</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="c6e4" class="mi mj in bd mk ml pc mn mo mp pd mr ms mt pe mv mw mx pf mz na nb pg nd ne nf bi translated">下一篇文章:</h1><p id="e9ad" class="pw-post-body-paragraph jk jl in jm b jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh ig bi translated">在下一篇文章中，我将定义生物安全、维吉尔加密和密码加密。所以，请继续关注我的<a class="ae me" href="https://medium.com/@ali.azaz.alam" rel="noopener">中音</a>频道。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="41f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章有助于深入了解android jetpack的安全性。我们讨论了开发人员用几行代码实现安全方法是多么容易。在Twitter上关注我，<a class="ae me" href="https://github.com/aliazaz" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ma">Github</em></strong></a><strong class="jm io"><em class="ma">，</em> </strong>和<a class="ae me" href="https://linkedin.com/in/aliazazalam" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ma">LinkedIn</em></strong></a><strong class="jm io"><em class="ma"/></strong>获取更多更新。</p><div class="ky kz gp gr la lb"><a href="https://twitter.com/AliAzazAlam1" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">阿里·阿扎兹·阿拉姆</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">阿里·阿扎兹·阿拉姆的最新推文(@AliAzazAlam1)。🇵🇰.企业家👱🏻‍♂️安卓应用开发者📱开源…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">twitter.com</p></div></div><div class="lk l"><div class="ph l lm ln lo lk lp ks lb"/></div></div></a></div><p id="f74c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您花时间阅读这篇文章。如果你喜欢它，请分享！</p></div></div>    
</body>
</html>