<html>
<head>
<title>Facilitating dependency initialization with Dagger multibindings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dagger多绑定简化依赖项初始化</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/facilitating-dependency-initialization-with-dagger-multibindings-e31f3323338f?source=collection_archive---------0-----------------------#2019-02-13">https://medium.com/quick-code/facilitating-dependency-initialization-with-dagger-multibindings-e31f3323338f?source=collection_archive---------0-----------------------#2019-02-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8d2a7b6b6e2116d4affbcf874f29bccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SAQMeC9iVl_b85m0AWUSg.jpeg"/></div></div></figure><p id="5ee8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">【注:本文假设你已经掌握了</em> <a class="ae jo" href="https://google.github.io/dagger/" rel="noopener ugc nofollow" target="_blank"> <em class="jn">匕首2</em></a><em class="jn"/>的基本知识</p><p id="4b96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着Android应用程序规模的增长，其依赖的数量也会增加。一些依赖关系需要在应用程序启动时进行一次性初始化，分析和跟踪库通常是这种依赖关系的嫌疑人。这些通常会被扔进你的自定义<code class="du jp jq jr js b">Application</code>子类，结果是一大堆嘈杂的代码，除了分散开发人员的注意力和混淆潜在的错误之外，对开发人员没有任何意义。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="8ee7" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>SlipperySlopeApplication : Application() {<strong class="js hi"><br/><br/>    override fun </strong>onCreate() {<br/>        <strong class="js hi">super</strong>.onCreate()<br/><br/>        <strong class="js hi">if </strong>(BuildConfig.<em class="jn">DEBUG</em>) {<br/>            Timber.plant(Timber.DebugTree())<br/>        }<br/>        <br/>        Foo.initialize(<strong class="js hi">this</strong>)<br/><br/>        <em class="jn">// ...ten thousand other dependency initializations</em><br/>    }<br/>}</span></pre><p id="afb6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">软件开发中的变化是不可避免的，能够减轻其影响是非常重要的。每当一个需要初始化的新依赖项被添加到你的应用程序中时，上面例子中的类都必须经历改变。这使得类膨胀，并有引入bug的风险。更糟糕的是，在某些时候，开发人员甚至不想再看这个类，当被迫尝试并理解如何导航它时，他们会发出痛苦的呻吟。</p><p id="9d09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">dagger<a class="ae jo" href="https://google.github.io/dagger/multibindings.html" rel="noopener ugc nofollow" target="_blank">multi binding</a>提供了一种简洁的方式让类抵制变化，并恢复你的应用程序及其开发者的理智。本文将介绍如何清理您的应用程序初始化代码，以最终生成一个类似于以下内容的<code class="du jp jq jr js b">Application</code>子类:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="78d5" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>LessBadApplication : Application() {<br/><br/>    <strong class="js hi">private val appComponent</strong>: AppComponent = ...<strong class="js hi"><br/><br/>    override fun </strong>onCreate() {<br/>        <strong class="js hi">super</strong>.onCreate()<br/><br/>        <strong class="js hi">appComponent</strong>.appInitializer().initialize()<br/>    }<br/>}</span></pre><p id="52fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得上面代码的状态，我们将把每个依赖项的初始化算法包装到它自己的类中，向Dagger发送信号，告诉他我们想把它们绑定到一个集合中，然后遍历它，告诉每个依赖项执行它的初始化。这将在下面的代码示例中变得更加清晰。</p><p id="fb65" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们将从一个简单的接口开始，每个依赖项初始化包装器都将实现这个接口:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6ad9" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">interface </strong>Initializer {<br/>    <strong class="js hi">fun </strong>initialize()<br/>}</span></pre><p id="55d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们创建一个实现该接口的类，并提取本文第一个示例的<a class="ae jo" href="https://github.com/JakeWharton/timber" rel="noopener ugc nofollow" target="_blank"> Timber </a>初始化代码:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="70ec" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>TimberInitializer @Inject <strong class="js hi">constructor</strong>() : Initializer {<br/><br/>    <strong class="js hi">override fun </strong>initialize() {<br/>        <strong class="js hi">if </strong>(BuildConfig.<em class="jn">DEBUG</em>) {<br/>            Timber.plant(Timber.DebugTree())<br/>        }<br/>    }<br/>}</span></pre><p id="bfe4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不要忘记包含一个<code class="du jp jq jr js b">@Inject</code>构造函数。</p><p id="78ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们对组成的<code class="du jp jq jr js b">Foo</code>初始化做同样的事情:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6489" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>FooInitializer @Inject <strong class="js hi">constructor</strong>(<br/>    <strong class="js hi">private val context</strong>: Context<br/>) : Initializer {<br/><br/>    <strong class="js hi">override fun </strong>initialize() {<br/>        Foo.initialize(<strong class="js hi">context</strong>)<br/>    }<br/>}</span></pre><p id="6755" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，如果这些<code class="du jp jq jr js b">Initializer</code>有自己的依赖项，这不是问题。如果它在你的Dagger图中可用，那么它也可以在这些构造函数中。</p><p id="2469" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将定义多绑定魔法发生在哪里。像这样创建一个Dagger模块:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="4736" class="kb kc hh js b fi kd ke l kf kg">@Module<br/><strong class="js hi">abstract class </strong>InitializerModule {<br/><br/>    @Binds<br/>    @IntoSet<br/>    <strong class="js hi">abstract fun </strong>timberInitialize(<br/>        timberInitializer: TimberInitializer<br/>    ): Initializer<br/><br/>    @Binds<br/>    @IntoSet<br/>    <strong class="js hi">abstract fun </strong>fooInitializer(<br/>        fooInitializer: FooInitializer<br/>    ): Initializer<br/>}</span></pre><p id="1e3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jp jq jr js b">@IntoSet</code>注释，我们告诉Dagger，我们希望所有这些新<code class="du jp jq jr js b">Initializer</code>的实例都可以通过可注入的<code class="du jp jq jr js b">Set&lt;Initializer&gt;</code>来使用。让我们将这样一个<code class="du jp jq jr js b">Set</code>注入另一个定制类:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="5c37" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>AppInitializer @Inject <strong class="js hi">constructor</strong>(<br/>    <strong class="js hi">private val initializers</strong>: Set&lt;@JvmSuppressWildcards Initializer&gt;<br/>) : Initializer {<br/><br/>    <strong class="js hi">override fun </strong>initialize() {<br/>        <strong class="js hi">initializers</strong>.<em class="jn">forEach</em>(Initializer::initialize)<br/>    }<br/>}</span></pre><p id="f604" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后这个<code class="du jp jq jr js b">AppInitializer</code>类可以被注入或者暴露给你的定制<code class="du jp jq jr js b">Application</code>子类，并调用它的<code class="du jp jq jr js b">initialize()</code>方法——一劳永逸！注意，在Kotlin中，这个例子中的<code class="du jp jq jr js b">@JvmSuppressWildcards</code>注释是编译成功的必要条件。你可以在这里阅读更多关于为什么<a class="ae jo" href="http://adavis.info/2017/08/jvmsuppresswildcards-biggest-annoyance-kotlin.html" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="472c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，每当添加需要初始化的新依赖项时，只需将初始化算法封装到一个<code class="du jp jq jr js b">Initializer</code>具体化中，并将其添加到<code class="du jp jq jr js b">InitializerModule</code>绑定列表中。移除一个也同样简单。拥有<code class="du jp jq jr js b">AppInitializer</code>实例的类将永远不会因为这些原因而改变，所有应用程序的依赖项初始化将整齐地包含在它们各自的文件中。</p><p id="7a1e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在这里找到这个概念的完整例子:<a class="ae jo" href="https://github.com/nihk/DaggerMultibindingsFun" rel="noopener ugc nofollow" target="_blank">https://github.com/nihk/DaggerMultibindingsFun</a></p></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><h2 id="4cb4" class="kb kc hh bd ko kp kq kr ks kt ku kv kw ja kx ky kz je la lb lc ji ld le lf lg bi translated">2021/04/01 —更新</h2><p id="2c55" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">一个<a class="ae jo" href="https://proandroiddev.com/abusing-dagger-with-initializers-a1e742024ac8" rel="noopener ugc nofollow" target="_blank">对这篇文章的回复</a>提出了一个关于集合<code class="du jp jq jr js b">Initializer</code>的顺序不被保证的很好的观点。如果您的一个<code class="du jp jq jr js b">Initializer</code>依赖于另一个<code class="du jp jq jr js b">Initializer</code>在它自己初始化之前被初始化(仍然跟随？)，那么你的应用可能不会像你期望的那样运行。例如，如果<code class="du jp jq jr js b">FooInitializer</code>在其初始化期间记录到Timber，并且在<code class="du jp jq jr js b">TimberInitializer</code>之前被初始化，那么该日志将会丢失。</p><p id="b664" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Dagger的API无法控制<code class="du jp jq jr js b">@IntoSet</code>成员的顺序。然而，我不是那种把婴儿和洗澡水一起倒掉的人；我认为有一个现实的方法来解决这个问题，同时仍然使用匕首多绑定。</p><p id="3b26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们首先考虑一下，如果我们不使用这种多绑定模式，我们将如何设置我们的代码，因为我们想要定义一个初始化顺序。我们将回到我在本文前面描述的臃肿的状态，但是现在加入了订单管理。膨胀使顺序变得模糊，不清楚哪些初始化调用是故意排序的，哪些调用的顺序实际上并不重要。以下面的例子为例:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="cc50" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>SlipperierSlopeApplication : Application() {<strong class="js hi"><br/><br/>    override fun </strong>onCreate() {<br/>        <strong class="js hi">super</strong>.onCreate()<br/><br/>        <strong class="js hi">if </strong>(BuildConfig.<em class="jn">DEBUG</em>) {<br/>            Timber.plant(Timber.DebugTree())<br/>        }<br/>        <br/>        Foo.initialize(<strong class="js hi">this</strong>)<br/>        Bar.initialize(<strong class="js hi">this</strong>)<br/>        Baz.initialize()</span><span id="3d88" class="kb kc hh js b fi lm ke l kf kg">    }<br/>}</span></pre><p id="2c1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果<code class="du jp jq jr js b">Foo</code>的初始化记录了一些木材，那么木材种植需要在<code class="du jp jq jr js b">Foo</code>的调用之前被调用。但是<code class="du jp jq jr js b">Bar</code>和<code class="du jp jq jr js b">Baz</code>初始化呢:它们是顺序相关的吗？不清楚。</p><p id="570e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们坚持使用匕首多重捆绑，我们如何解决这个问题？回复文章中的一位评论者建议在<code class="du jp jq jr js b">Initializer</code>界面上添加一个抽象的<code class="du jp jq jr js b">sortOrder(): Int</code>函数来帮助指定顺序。我不喜欢这个想法，因为一个<code class="du jp jq jr js b">Initializer</code>不应该单独关心或知道它的依赖项或兄弟<code class="du jp jq jr js b">Initializer</code>的状态，而且不是每个<code class="du jp jq jr js b">Initializer</code>都关心它应该以什么顺序初始化。不得不管理分散在大型项目中的<code class="du jp jq jr js b">sortOrder</code>值也是站不住脚的。</p><p id="12bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我对这个问题提出的解决方案是简单地注入一种方法来告诉<code class="du jp jq jr js b">AppInitializer</code>(本文前面提到过)如何对它的一组<code class="du jp jq jr js b">Initializer</code>进行排序。一旦这个集合被排序，<code class="du jp jq jr js b">AppInitializer</code>就可以遍历它的集合，并以一种安全且有意的方式对每个集合调用initialize。自定义<code class="du jp jq jr js b">Comparator</code>可以对器械包进行排序:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="722b" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>AppInitializerComparator(<br/>    <strong class="js hi">private val priorities</strong>: List&lt;Class&lt;<strong class="js hi">out </strong>Initializer&gt;&gt;<br/>) : Comparator&lt;Initializer&gt; {<br/>    // ...<br/>}</span></pre><p id="a301" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像这样使用:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="040e" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>AppInitializer @Inject <strong class="js hi">constructor</strong>(<br/>    <strong class="js hi">private val initializers</strong>: Set&lt;@JvmSuppressWildcards Initializer&gt;,<br/>    <strong class="js hi">private val comparator</strong>: AppInitializerComparator<br/>) : Initializer {<br/><br/>    <strong class="js hi">override fun </strong>initialize() {<br/>        <strong class="js hi">initializers<br/>            </strong>.<em class="jn">sortedWith</em>(<strong class="js hi">comparator</strong>)<br/>            .<em class="jn">forEach</em>(Initializer::initialize)<br/>    }<br/>}</span></pre><p id="6bfd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">传入<code class="du jp jq jr js b">AppInitializerComparator</code>的<code class="du jp jq jr js b">priorities</code>值定义了<code class="du jp jq jr js b">Initializer</code>初始化的顺序。只有对订单感兴趣的人才需要成为该集合的一部分。对于我到目前为止一直在谈论的例子，<code class="du jp jq jr js b">priorities</code>只有一个元素:对<code class="du jp jq jr js b">TimberInitializer</code>的引用。Dagger模块是定义什么进入那个<code class="du jp jq jr js b">priorities</code>值的好地方，因为Dagger模块是负责配置的东西。对于这个例子，它看起来像这样:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="af43" class="kb kc hh js b fi kd ke l kf kg">@Provides<br/><strong class="js hi">fun </strong>appInitializerComparator(): AppInitializerComparator {<br/>    <strong class="js hi">val </strong>priorities = <em class="jn">listOf</em>&lt;Class&lt;<strong class="js hi">out </strong>Initializer&gt;&gt;(<br/>        TimberInitializer::<strong class="js hi">class</strong>.<em class="jn">java<br/>    </em>)<br/>    <strong class="js hi">return </strong>AppInitializerComparator(priorities)<br/>}</span></pre><p id="1a4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意缺少对<code class="du jp jq jr js b">Foo</code>或<code class="du jp jq jr js b">Bar</code>或<code class="du jp jq jr js b">Baz</code>初始化的引用。所有这些<code class="du jp jq jr js b">priorities</code>值都表示“首先初始化木材”其他的<code class="du jp jq jr js b">Initializer</code>我们就不用管了，现在<code class="du jp jq jr js b">TimberInitializer</code>保证会被<code class="du jp jq jr js b">AppInitializer</code>先调用。<code class="du jp jq jr js b">Foo</code>可以在以后安全地初始化并成功地登录到Timber。</p><p id="8235" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jp jq jr js b">AppInitializerComparator</code>的<code class="du jp jq jr js b">Comparator</code>实现可以以多种方式完成，但是它的要点是您想要比较每个元素的索引，就像这样:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6ce3" class="kb kc hh js b fi kd ke l kf kg"><strong class="js hi">class </strong>AppInitializersComparator(<br/>    <strong class="js hi">private val priorities</strong>: List&lt;Class&lt;<strong class="js hi">out </strong>Initializer&gt;&gt;<br/>) : Comparator&lt;Initializer&gt; {<br/>    <strong class="js hi">override fun </strong>compare(first: Initializer, second: Initializer): Int {<br/>        <strong class="js hi">val </strong>firstIndex = <strong class="js hi">priorities</strong>.indexOf(first::<strong class="js hi">class</strong>.<em class="jn">java</em>).<em class="jn">handleNotFound</em>()<br/>        <strong class="js hi">val </strong>secondIndex = <strong class="js hi">priorities</strong>.indexOf(second::<strong class="js hi">class</strong>.<em class="jn">java</em>).<em class="jn">handleNotFound</em>()<br/>        <strong class="js hi">return </strong>firstIndex.compareTo(secondIndex)<br/>    }<br/><br/>    <strong class="js hi">private fun </strong>Int.handleNotFound(): Int {<br/>        <strong class="js hi">return if </strong>(<strong class="js hi">this </strong>== -1) {<br/>            Int.<strong class="js hi">MAX_VALUE<br/>        </strong>} <strong class="js hi">else </strong>{<br/>            <strong class="js hi">this<br/>        </strong>}<br/>    }<br/>}</span></pre><p id="02cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">需要订单集的不仅仅是<code class="du jp jq jr js b">TimberInitializer</code>？然后简单地相应安排<code class="du jp jq jr js b">priorities</code>集合。这个过程并不比在没有Dagger的情况下在您的<code class="du jp jq jr js b">Application.onCreate</code>中设置它们的顺序更加手动，但是它更干净并且更容易管理。</p></div></div>    
</body>
</html>