<html>
<head>
<title>Common Misconceptions About Inheritance in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中关于继承的常见误解</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a?source=collection_archive---------0-----------------------#2015-04-17">https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a?source=collection_archive---------0-----------------------#2015-04-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="fd86" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi"> <em class="hh">窟？[ </em> </strong> <em class="hh">窟</em> <strong class="ik hi"> <em class="hh"> ] — </em> </strong>感叹词:<strong class="ik hi"> <em class="hh"> </em> </strong>程序员在某件事违反了最小惊奇原则，用反直觉的行为使其吃惊时发出的声音。</p></blockquote><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="5483" class="jp jq hh jl b fi jr js l jt ju">&gt; .1 + .2<br/>0.30000000000000004<br/>&gt; WAT? OMG! STFU! STUPID JAVASCRIPT!!!<br/>…</span></pre><p id="09d7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">还有，瓦特？这是我与许多经验丰富的JavaScript开发人员交谈时发出的声音，他们忽略了学习原型继承的基本机制:这是cs历史上最重要的创新之一，也是JavaScript的两大支柱之一。</p><p id="9ee7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">对我来说，这就像一个专业摄影师还没有学会曝光三角——控制照片大部分视觉风格的基本公式。简而言之:</p></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="785a" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">如果你不懂原型，<br/>你就不懂JavaScript。</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="5b94" class="kq jq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">古典继承和原型继承真的不是一回事吗，只是一种文体偏好？</h1><blockquote class="jz"><p id="a737" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="3db3" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">经典继承和原型继承在根本上和语义上是不同的。</p><p id="b561" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">经典遗传和原型遗传之间有一些<strong class="ik hi">定义特征</strong>。为了使本文有意义，您必须记住以下几点:</p><p id="9e70" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在<strong class="ik hi">类继承中，实例从蓝图</strong>(类)继承，<strong class="ik hi">创建子类关系</strong>。换句话说，你不能像使用实例一样使用类。你不能调用类定义本身的实例方法。您必须首先创建一个实例，然后调用该实例上的方法。</p><p id="007b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在原型继承中，<strong class="ik hi">实例从其他实例继承。</strong>使用<strong class="ik hi">委托原型</strong>(将一个实例的原型设置为引用一个<strong class="ik hi">示例对象</strong>)，它实际上是<strong class="ik hi">对象链接到其他对象</strong>，或者如凯尔·辛普森所说的<strong class="ik hi"> OLOO </strong>。使用<strong class="ik hi">串联继承</strong>，您只需<strong class="ik hi">将属性</strong>从<strong class="ik hi">样本对象</strong>复制到一个新实例。</p><p id="1588" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">理解这些差异真的很重要。类继承凭借其机制<strong class="ik hi">创建类层次，作为子类创建的副作用。</strong>那些层次导致<strong class="ik hi">关节炎代码</strong>(难以更改)和<strong class="ik hi">脆性</strong>(当您修改基类时，由于波动的副作用而容易损坏)。</p><p id="fdfd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">原型继承不一定会创建相似的层次结构。我建议你保持原型链尽可能的浅。很容易将许多原型拼合在一起，形成一个<strong class="ik hi">单一委托原型。</strong></p><p id="010c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">TL；博士:</p><ul class=""><li id="ea51" class="ls lt hh ik b il im ip iq jv lu jw lv jx lw jf lx ly lz ma bi translated">一个<strong class="ik hi">级</strong>就是一个<strong class="ik hi">蓝图</strong>。</li><li id="9b8b" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">一个<strong class="ik hi">原型</strong>是一个<strong class="ik hi">对象</strong>实例。</li></ul><h1 id="7dea" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">类难道不是JavaScript中创建对象的正确方式吗？</h1><blockquote class="jz"><p id="7676" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="308b" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">在JavaScript中创建对象有几种正确的方法。第一个也是最常见的是对象文字。看起来是这样的(在ES6中):</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a6f1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">当然，对象文字比ES6早得多，但是它们缺少上面看到的方法快捷方式，你必须使用<em class="ij"> `var` </em>而不是<em class="ij"> `let` </em>。哦，还有，<em class="ij"> `.describe()` </em>方法中的模板字符串也不能在ES5中工作。</p><p id="281b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">你可以用<em class="ij"> `Object.create()` </em>(一个ES5特性)附加委托原型:</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="779b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">让我们把这个分解一下。<em class="ij"> `animal` </em>是<strong class="ik hi">的代表原型</strong>。<em class="ij"> `mouse` </em>就是一个实例。当您试图访问<em class="ij"> `mouse` </em>上不存在的属性时，JavaScript运行时将查找<em class="ij"> `animal` </em>(委托)上的属性。</p><p id="3b5c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi"><em class="ij">` object . assign()`</em></strong>是Rick Waldron倡导的一项新的ES6特性，此前已在几十个库中实现。你可能知道它是<em class="ij"> `$。从jQuery或<em class="ij"> `_中扩展()`</em>。从下划线扩展()`</em>。Lodash有一个版本叫做<em class="ij"> `assign()`。</em>你传入一个目标对象，以及尽可能多的源对象，用逗号分隔。它将通过<em class="ij">赋值</em>将所有<strong class="ik hi">可枚举的自身属性</strong>从源对象复制到目标对象，其中<strong class="ik hi">优先级最后。</strong>如果有任何属性名冲突，则来自最后一个传入对象的版本会胜出。</p><p id="3182" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi"><em class="ij">` object . create()`</em></strong>是道格拉斯·克洛克福特倡导的一个ES5特性，这样我们就可以在不使用构造函数和<em class="ij"> `new` </em>关键字的情况下附加委托原型。</p><p id="1398" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我跳过构造函数的例子，因为我不能推荐它们。我见过他们被虐的很多，也见过他们造成<a class="ae jy" rel="noopener" href="/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf">很多麻烦</a>。值得注意的是，很多聪明人不同意我的观点。聪明人会为所欲为。</p><p id="6ab7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">聪明人会<strong class="ik hi">采纳道格拉斯·克洛克福特的建议:</strong></p><blockquote class="ie if ig"><p id="0516" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">如果某项功能有时很危险，并且有更好的选项，那么请始终使用更好的选项</p></blockquote><h1 id="1be0" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">不需要一个构造函数来指定对象实例化行为，处理对象初始化吗？</h1><blockquote class="jz"><p id="94ac" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="a551" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">任何函数都可以创建和返回对象。当它不是构造函数时，它被称为<strong class="ik hi">工厂函数。</strong></p><h2 id="020a" class="jp jq hh bd kr mo mp mq kv mr ms mt kz jv mu mv ld jw mw mx lh jx my mz ll na bi translated">更好的选择</h2><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="122a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我通常不把我的工厂命名为“工厂”——这只是为了举例说明。通常我会叫它<em class="ij"> `mouse()`。</em></p><h1 id="b76c" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">JavaScript中隐私不需要构造函数吗？</h1><blockquote class="jz"><p id="2e4b" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="239a" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">在JavaScript中，每当您导出一个函数时，该函数都可以访问外部函数的变量。当您使用它们时，JS引擎会创建一个<strong class="ik hi">闭包</strong>。闭包是JavaScript中的一种常见模式，通常用于保护数据隐私。</p><p id="0d1d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">闭包并不是构造函数所独有的。任何功能都可以为数据隐私创建一个封闭:</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jg jh ji jj fd ml er es paragraph-image"><div class="er es nb"><img src="../Images/c3f2be93b6633d6b6ec3478284d5512b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PZMdDrJu--I-WSKbrJL7Nw.jpeg"/></div></figure><h1 id="2969" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">“新”是否意味着代码正在使用经典继承？</h1><blockquote class="jz"><p id="7358" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="6db2" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">`<em class="ij"> new` </em>关键字用于调用构造函数。它实际上做的是:</p><ul class=""><li id="64cf" class="ls lt hh ik b il im ip iq jv lu jw lv jx lw jf lx ly lz ma bi translated">创建新实例</li><li id="bc9c" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">将`<em class="ij"> this` </em>绑定到新实例</li><li id="6b68" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">将新对象的委托[[Prototype]]引用到由构造函数的<em class="ij"> `prototype` </em>属性引用的对象。</li><li id="5762" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">将新对象的<code class="du ne nf ng jl b">.constructor</code>属性引用到被调用的构造函数。</li><li id="46ad" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">以构造函数命名对象类型，这在调试控制台中最常见。你会看到`<em class="ij"> [Object Foo]`，比如</em>，而不是`<em class="ij"> [Object object]`。</em></li><li id="06b5" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated">允许`<em class="ij"> instanceof` </em>检查对象的原型引用是否与<em class="ij">引用的对象相同。构造函数的原型</em>属性。</li></ul><h2 id="b7d3" class="jp jq hh bd kr mo mp mq kv mr ms mt kz jv mu mv ld jw mw mx lh jx my mz ll na bi translated">谎言</h2><p id="0484" class="pw-post-body-paragraph ih ii hh ik b il ni in io ip nj ir is jv nk iv iw jw nl iz ja jx nm jd je jf ha bi translated">让我们在这里暂停一下，重新考虑一下<em class="ij"> `instanceof` </em>的值。你可能会改变对它的有用性的看法。</p><p id="6f8c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">重要提示:</strong> ` <em class="ij"> instanceof` </em>不会像在强类型语言中那样进行类型检查。相反，它对原型对象进行身份检查，这很容易被愚弄。例如，它不能跨执行上下文工作(错误、挫折和不必要限制的常见来源)。作为参考，一个<a class="ae jy" href="https://github.com/baconjs/bacon.js/issues/296" rel="noopener ugc nofollow" target="_blank">野外的例子，来自bacon.js </a>。</p><p id="7565" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">它也很容易被其他来源的假阳性(更常见的是假阴性)欺骗。因为这是针对目标对象的`<em class="ij"> .prototype` </em>属性的身份检查，所以会导致奇怪的事情:</p><pre class="jg jh ji jj fd jk jl jm jn aw jo bi"><span id="597b" class="jp jq hh jl b fi jr js l jt ju">&gt; function foo() {}<br/>&gt; var bar = { a: ‘a’};<br/>&gt; foo.prototype = bar; // Object {a: “a”}<br/>&gt; baz = Object.create(bar); // Object {a: “a”}<br/>&gt; baz instanceof foo // true. oops.</span></pre><p id="b4e1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">最后一个结果完全符合JavaScript规范。没有什么是坏的——只是<em class="ij"> `instanceof` </em>不能保证类型安全。<strong class="ik hi">很容易欺骗</strong>报告<strong class="ik hi">误报</strong>，和<strong class="ik hi">漏报</strong>。</p><p id="3a80" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">除此之外，试图让你的JS代码表现得像强类型代码一样，会阻止你的函数被提升到泛型，泛型可重用性更高，也更有用。</p><p id="b6c7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi"> ` <em class="ij"> instanceof </em>`限制了你的代码的可重用性，并可能给使用你的代码的程序带来错误。</strong></p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="fea2" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">谎言的实例。</p><p id="b9a1" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">改为Ducktype。</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h2 id="a10b" class="jp jq hh bd kr mo mp mq kv mr ms mt kz jv mu mv ld jw mw mx lh jx my mz ll na bi translated">“新”很奇怪</h2><p id="ec06" class="pw-post-body-paragraph ih ii hh ik b il ni in io ip nj ir is jv nk iv iw jw nl iz ja jx nm jd je jf ha bi translated"><strong class="ik hi">窟？</strong> ` <em class="ij"> new </em>`也做一些<em class="ij">古怪的事情</em>来返回值。如果你试图返回一个原语，那是行不通的。如果你返回任何其他任意对象，那个<strong class="ik hi"> <em class="ij">做</em> </strong>工作，但是<em class="ij"> `this` </em>被丢弃，破坏对它的所有引用(包括`<em class="ij">)。调用()`</em>和`<em class="ij">。apply()` </em>)，并断开与构造函数的<em class="ij"> `.prototype` </em>引用的链接。</p><h1 id="68b2" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">经典继承和原型继承的性能差别大吗？</h1><blockquote class="jz"><p id="422f" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="febe" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">你可能听说过<strong class="ik hi">隐藏类，</strong>，并且认为构造函数明显优于用<em class="ij"> `Object.create()` </em>实例化的对象。这些性能差异被大大夸大了。</p><p id="e5e4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">您的应用程序的一小部分时间花在运行JavaScript上，其中很少一部分时间花在访问对象的属性上。事实上，今天生产的最慢的笔记本电脑每秒可以访问数百万个属性。</p><p id="4956" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">那不是你app的瓶颈</strong>。帮你自己一个忙，<a class="ae jy" href="http://www.paulirish.com/2015/advanced-performance-audits-with-devtools/" rel="noopener ugc nofollow" target="_blank">剖析你的应用</a>来<strong class="ik hi">发现你真正的性能瓶颈</strong>。我敢肯定，在你再花时间考虑微优化之前，有无数的事情需要解决。</p><p id="e51a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">不服气？</strong>为了让一个微优化对你的应用产生任何可感知的影响，你必须循环运行<strong class="ik hi">成百上千次</strong>，微优化中你应该关心的唯一差异是那些<strong class="ik hi">数量级的差异</strong>。</p><p id="6229" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">经验法则:</strong>剖析你的应用，尽可能多地消除加载、网络、文件I/O和渲染瓶颈。<strong class="ik hi">那时，也只有那时，你才应该开始考虑微优化。</strong></p><p id="fb32" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">你能说出<em class="ij"> .0000000001 </em>秒和<em class="ij"> .000000001 </em>秒的区别吗？我也不能，但我肯定能区分加载10个小图标和加载一个网络字体的区别。</p><p id="06a6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">如果你用<strong class="ik hi">剖析你的应用</strong>并且发现对象创建确实是一个瓶颈，最快的方法不是使用<em class="ij"> `new` </em>和传统的OO。<strong class="ik hi">最快的方法是使用对象文字</strong>。您可以在循环中这样做，并将对象添加到对象池中，以避免来自垃圾收集器的冲击。如果相对于perf而言，放弃原型OO是值得的，那么抛弃原型链和继承来产生对象文字也是值得的。</p><blockquote class="ie if ig"><p id="c3f4" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">但是谷歌说上课快…</p></blockquote><p id="c9c4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">窟？</strong>谷歌正在打造一个JavaScript引擎。您正在构建一个应用程序。显然他们关心的和你关心的应该是<strong class="ik hi">非常不同的事情</strong>。让谷歌来处理微优化。你担心你的应用程序的真正瓶颈。我保证，关注其他任何事情，你都会获得更好的投资回报。</p><h1 id="dec9" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">经典和原型的内存消耗差别大吗？</h1><blockquote class="jz"><p id="74f0" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="5898" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">两者都可以使用委托原型在许多对象实例之间共享方法。两者都可以使用或避免将一堆状态包装到闭包中。</p><p id="5884" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">事实上，如果您从工厂函数开始，切换到对象池会更容易，这样您可以更仔细地管理内存，避免被垃圾收集器周期性地阻塞。关于为什么构造函数会如此尴尬的更多信息，请看。注意<em class="ij">下的“‘新’是否意味着代码正在使用经典继承？”</em></p><p id="dba2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">换句话说，如果您想要内存管理的最大灵活性，请使用工厂函数而不是构造函数和经典继承。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="e3a3" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">“…如果您想要最灵活的内存管理，<br/>使用工厂函数…”</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="8ed9" class="kq jq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">本机API使用构造函数。他们不是比工厂更地道吗？</h1><blockquote class="jz"><p id="1d8b" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="74d0" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated"><strong class="ik hi">工厂在JavaScript中极其常见。</strong>例如，有史以来最流行的JavaScript库<strong class="ik hi"> jQuery </strong>向用户公开了一个工厂。John Resig写过关于选择使用工厂和原型扩展而不是类的文章。基本上，这可以归结为一个事实，即他不希望呼叫者每次做出选择时都必须键入<em class="ij"> `new` </em>。那会是什么样子呢？</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="bb8c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">还有什么曝光工厂的？</p><ul class=""><li id="b663" class="ls lt hh ik b il im ip iq jv lu jw lv jx lw jf lx ly lz ma bi translated"><strong class="ik hi">React</strong><em class="ij">` React . create class()`</em>是工厂。</li><li id="49ac" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated"><strong class="ik hi"> Angular </strong>使用类&amp;工厂，但是用依赖注入容器中的工厂包装它们。所有的提供者都是使用<em class="ij"> `.provider()` </em>工厂的糖。甚至还有一个`。<em class="ij"> factory()` </em> provider，甚至还有<em class="ij"> `.service()` </em> provider包装普通构造函数并公开……你猜对了:一个<strong class="ik hi"> factory </strong>给DI消费者。</li><li id="ce89" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated"><strong class="ik hi">Ember</strong>T16】` Ember . application . create()；`是生产app的工厂。与其创建构造函数来调用<em class="ij">` new`</em>,<em class="ij">`. extend()`</em>方法，不如扩充应用程序。</li><li id="69bc" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated"><strong class="ik hi">节点</strong>核心服务像<em class="ij"> `http.createServer()` </em>和<em class="ij"> `net.createServer()` </em>都是工厂函数。</li><li id="4854" class="ls lt hh ik b il mb ip mc jv md jw me jx mf jf lx ly lz ma bi translated"><strong class="ik hi">快递</strong>是创建快递app的工厂。</li></ul><p id="884a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">如您所见，几乎所有最流行的JavaScript库和框架都大量使用了工厂函数。JS中唯一比工厂更常见的对象实例化模式是对象文字。</p><p id="ada9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">JavaScript内置开始使用构造函数，因为Brendan Eich被告知要使它看起来像Java。JavaScript继续使用构造函数来实现自我一致性。现在试图把一切都改成工厂而贬低构造函数是很尴尬的。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="92cc" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">这并不意味着<strong class="ak">你的API</strong>必须很烂。</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="0eeb" class="kq jq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">经典继承不是比原型继承更惯用吗？</h1><blockquote class="jz"><p id="9405" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="6dd1" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">每次我听到这种误解，我都会忍不住说，“你会写JavaScript吗？”继续前进…但我会忍住冲动，澄清事实。</p><p id="6faf" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">如果这也是你的问题，不要难过。这不是你的错。<a class="ae jy" rel="noopener" href="/javascript-scene/javascript-training-sucks-284b53666245"> JavaScript培训烂透了！</a></p><p id="acc0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">这个问题的答案是一个巨大的</p><h1 id="1e55" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">不…(但是)</h1><p id="720c" class="pw-post-body-paragraph ih ii hh ik b il ni in io ip nj ir is jv nk iv iw jw nl iz ja jx nm jd je jf ha bi translated">原型是JS惯用的继承范式，<em class="ij"> `class` </em>是掠夺性的入侵物种。</p><h2 id="0be1" class="jp jq hh bd kr mo mp mq kv mr ms mt kz jv mu mv ld jw mw mx lh jx my mz ll na bi translated">流行JavaScript库简史:</h2><p id="b79c" class="pw-post-body-paragraph ih ii hh ik b il ni in io ip nj ir is jv nk iv iw jw nl iz ja jx nm jd je jf ha bi translated">一开始，每个人都写自己的库，开放共享并不是什么大事。然后<strong class="ik hi">原型</strong>出现了。(名字在这里是一个很大的暗示)。Prototype通过使用<strong class="ik hi">串联继承</strong>扩展内置<strong class="ik hi">委托原型</strong>发挥了它的魔力。</p><p id="caf3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">后来我们都意识到，当本地替代和冲突库破坏了互联网时，修改内置原型是一种反模式。但那是另一回事了。</p><p id="3e30" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">JS lib人气过山车上的下一个是<strong class="ik hi"> jQuery </strong>。jQuery最出名的是<strong class="ik hi"> jQuery插件</strong>。他们通过使用<strong class="ik hi">串联继承扩展jQuery的<strong class="ik hi">委托原型</strong>来工作。</strong></p><blockquote class="jz"><p id="8ac3" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">你开始感觉到一种模式了吗？</p></blockquote><p id="affe" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">jQuery仍然是有史以来最受欢迎的JavaScript库。以巨大的优势。巨大的。</p><p id="44c2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">这就是事情变得混乱的地方，类扩展开始潜入语言中…John Resig(jQuery的作者)在JavaScript 中写了关于<em class="ij">简单类继承的文章，人们开始<em class="ij">实际使用它，</em>即使John Resig自己并不认为它属于jQuery(因为<strong class="ik hi"> prototypal OO更好地完成了同样的工作</strong>)。</em></p><p id="717e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">像ExtJS这样的半流行的Java风格的框架出现了，带来了类在JavaScript中的第一次有点儿，有点儿，不是真正主流的使用。这是2007年。在一个有点流行的lib开始向JS用户展示经典继承之前，JavaScript已经有12年的历史了。</p><p id="cfb5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">三年后，Backbone <strong class="ik hi">爆发了</strong>并有了一个<em class="ij"> `.extend()` </em>方法，它模仿了类继承，包括所有最糟糕的特性，比如脆弱的对象层次。就在那时，天下大乱了。</p><blockquote class="ie if ig"><p id="0bd0" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">~100kloc app开始使用Backbone。几个月后，我调试了一个6级层次结构，试图找到一个bug。逐句通过“超级”链上的每一行构造函数代码。发现并修复了顶级基类中的错误。然后必须修复许多子类，因为它们依赖于基类的错误行为。<strong class="ik hi">几个小时的挫败</strong>使得<strong class="ik hi">本应是5分钟的修复</strong>。</p></blockquote><p id="6f2c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi"> <em class="ij">这不是JavaScript。</em> </strong>我突然又活在了<em class="ij">爪哇地狱</em>里。在那个孤独、黑暗、可怕的地方，任何快速的移动都可能导致整个等级制度在紧密结合的抽搐中颤抖和崩溃。</p><p id="fc83" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">这些是重写本的组成部分。</p><p id="346f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">但是，在主干文件中隐藏着一缕金色的阳光:</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="2b39" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我们的老朋友，<strong class="ik hi">串联传承</strong>力挽狂澜<em class="ij">` backbone . events `</em><strong class="ik hi">mixin</strong>。</p><p id="e153" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">事实证明，如果你足够仔细地观察<strong class="ik hi">任何非平凡的JavaScript库</strong>，<strong class="ik hi">你会发现串联和委托的例子</strong>。JavaScript开发人员做这些事情是如此普遍和自动，以至于<strong class="ik hi">他们甚至不认为这是继承</strong>，即使它<strong class="ik hi">完成了相同的目标。</strong></p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="93ef" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">JS中的继承是如此简单<br/>以至于让那些认为需要努力的人感到困惑。</p><p id="ab9a" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">为了使它变得更难，我们加上了“类”。</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="6ca2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我们是如何添加类的？当然，我们使用<strong class="ik hi">委托原型</strong>和<strong class="ik hi">对象连接</strong>在原型继承的基础上构建了它！</p><p id="5c3d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">这就像开着你的特斯拉Model S去汽车经销店，换一辆生锈的1983年福特Pinto。</p><h1 id="88ab" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">经典继承和原型继承之间的选择不是取决于用例吗？</h1><blockquote class="jz"><p id="be2b" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="e342" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">原型OO更简单、更灵活，并且不容易出错。多年来，我一直在提出这一主张，并鼓励人们想出一个令人信服的类用例<em class="ij">。成千上万的人听到了这个号召。我收到的几个答案取决于本文中提到的一个或多个误解。</em></p><p id="d72b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我曾经是古典传承迷。我完全相信了。我到处构建对象层次结构。我构建了visual OO快速应用程序开发工具来帮助软件架构师设计有意义的对象层次和关系。使用传统的继承分类法，需要一个可视化工具来真实地映射和图形化企业应用程序中的对象关系。</p><p id="c9c9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在我从C++和Java过渡到JavaScript后不久，我就停止了所有这些工作。不是因为我在构建不太复杂的应用程序(事实正好相反)，而是因为JavaScript简单多了，我不再需要那些OO设计工具了。</p><p id="d801" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我以前做应用程序设计咨询，经常推荐全面重写。为什么？因为<strong class="ik hi">对于新的用例来说，所有的对象层次最终都是错误的。</strong></p><p id="222b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">我不是一个人。在那些日子里，对于新的软件版本来说，完全重写是非常普遍的。这些重写中的大部分都是由因循守旧、脆弱的阶级阶层造成的。整本书都是关于面向对象设计错误以及如何避免它们或者从它们中重构出来。似乎每个开发人员的办公桌上都有一本<a class="ae jy" href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=QYF6ABRMZ4O6KML2" rel="noopener ugc nofollow" target="_blank">“设计模式”</a>。</p><p id="46f8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在这一点上，我建议你们采纳T21、“四人帮”的建议:</p><blockquote class="jz"><p id="317c" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">"优先选择对象组合而不是类继承."</p></blockquote><p id="480a" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">在Java中，这比类继承更难，因为你实际上必须使用类来实现它。</p><p id="aeba" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在JavaScript中，我们没有这样的借口。实际上，在JavaScript中，通过将各种<strong class="ik hi">原型</strong>组装在一起，简单地创建您需要的对象<strong class="ik hi">要比管理对象层次结构容易得多。</strong></p><p id="c987" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi">窟？</strong>认真。想要一个可以将任何日期输入转换成<em class="ij"> `megaCalendarWidget` </em>的jQuery对象吗？不用<em class="ij"> `extend` </em>一个<em class="ij"> `class` </em>。JavaScript有动态对象扩展，jQuery公开了自己的原型，所以您可以直接扩展它——不需要extend关键字！<strong class="ik hi">窟？:</strong></p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a856" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">下次调用jQuery工厂时，您将获得一个实例，它可以让您的数据输入变得非常棒。</p><p id="1a02" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">同样，您可以使用<em class="ij"> `Object.assign()` </em>将任意数量的对象与后进优先级组合在一起:</p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="26dd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">不，真的— <strong class="ik hi">任意数量的对象:</strong></p><figure class="jg jh ji jj fd ml"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="d949" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">这种技术被称为<strong class="ik hi">串联继承</strong>，你继承的原型有时被称为<strong class="ik hi">范例原型</strong>，它不同于委托原型，因为你<strong class="ik hi">从它们那里复制</strong>，而不是委托给它们。</p><h1 id="ed9d" class="kq jq hh bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">ES6有“class”关键字。这难道不意味着我们都应该使用它吗？</h1><blockquote class="jz"><p id="8a2b" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><strong class="ak">号</strong></p></blockquote><p id="3606" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jv lp iv iw jw lq iz ja jx lr jd je jf ha bi translated">有很多令人信服的理由让到<a class="ae jy" rel="noopener" href="/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf">避免使用ES6 <em class="ij"> `class` </em>关键字</a>，尤其是因为它不适合JavaScript。</p><p id="dd38" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">在JavaScript中，我们已经有了一个<strong class="ik hi">非常强大且富有表现力的对象系统</strong>。如今在JS中实现的类的概念更具限制性(以一种糟糕的方式，而不是以一种酷的类型正确性的方式)，并且掩盖了很久以前内置到语言中的非常酷的原型OO系统。</p><p id="b980" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">你知道什么对JavaScript真正有好处吗？从熟悉原型OO的程序员的角度来看，更好的糖和抽象建立在原型之上。</p><p id="d631" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">那可能是真的很酷。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><blockquote class="jz"><p id="87d3" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated">我正在用JavaScript在<br/>原型OO上创建一个完整的在线类。</p><p id="654b" class="ka kb hh bd kc kd ke kf kg kh ki jf dx translated"><a class="ae jy" href="https://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">现在就预订</a> <br/>终身访问所有<br/>我的JavaScript课程。</p></blockquote></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="e60d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated"><strong class="ik hi"> <em class="ij">埃里克·艾略特</em> </strong> <em class="ij">著有</em> <a class="ae jy" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="ij">【编程JavaScript应用】</em> </a> <em class="ij">(奥赖利)&amp;纪录片制作主持人，</em> <strong class="ik hi"> <em class="ij">【编程素养】</em> </strong> <em class="ij">。他为Adobe Systems</em><strong class="ik hi"><em class="ij"/></strong><em class="ij"/><strong class="ik hi"><em class="ij">尊巴健身</em></strong><em class="ij"/><strong class="ik hi"><em class="ij">华尔街日报</em></strong><em class="ij"/><strong class="ik hi"><em class="ij">【ESPN</em></strong><em class="ij"/><strong class="ik hi"><em class="ij">BBC</em></strong><em class="ij">等顶级录音师贡献了软件经验</em></p><p id="61a2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jv iu iv iw jw iy iz ja jx jc jd je jf ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>