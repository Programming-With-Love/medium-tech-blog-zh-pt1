<html>
<head>
<title>React Performance Fixes on Airbnb Listing Pages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb列表页面上的React性能修复</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/recent-web-performance-fixes-on-airbnb-listing-pages-6cd8d93df6f4?source=collection_archive---------0-----------------------#2017-12-05">https://medium.com/airbnb-engineering/recent-web-performance-fixes-on-airbnb-listing-pages-6cd8d93df6f4?source=collection_archive---------0-----------------------#2017-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="1933" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">可能会有很多唾手可得的果实🥝影响您可能没有密切跟踪的领域的性能…但仍然非常重要。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ed0e5bd9dfd12f795dc7f1bd5460c87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTEb_qIXJmWJcdj6k9-Wcw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Airbnb has some incredible listings in Cuba…and also a corner of the office inspired by Habana Vieja</figcaption></figure><p id="8dd2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们一直在努力工作，使用<a class="ae kj" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> React路由器</a>和<a class="ae kj" href="https://github.com/airbnb/hypernova" rel="noopener ugc nofollow" target="_blank"> Hypernova </a>将airbnb.com核心预订流程移植到一个单页面服务器渲染的应用程序中。今年年初，我们在登陆页面和搜索结果中推出了这一功能，并取得了良好的效果。我们的下一步是扩展单页应用程序，使其包含<a class="ae kj" href="https://www.airbnb.com/rooms/8357" rel="noopener ugc nofollow" target="_blank">列表详情页面</a>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/a368ce81d672152c41a98613e6628d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E__f8FixGkfXtq7tia8leg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">airbnb.com listing detail page: <a class="ae kj" href="https://www.airbnb.com/rooms/8357" rel="noopener ugc nofollow" target="_blank">https://www.airbnb.com/rooms/8357</a></figcaption></figure><p id="c509" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这是您在决定预订哪个列表时访问的页面。在整个搜索过程中，您可能会多次访问此页面以查看不同的列表。这是关于airbnb.com的访问量最大也是最重要的页面之一，所以我们抓住所有的细节是至关重要的！</p><p id="9c92" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">作为迁移到我们的单页面应用程序的一部分，我想调查影响列表页面交互的任何遗留的性能问题(例如，滚动、点击、键入)。这符合我们的目标，即让页面快速启动并保持快速运行，通常会让人们对使用这个网站感觉更好。</p><p id="d5ea" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">通过分析、修复和再次分析的过程，我们显著改善了这一关键页面的交互性能，使预订体验更加顺畅和令人满意。</strong>在这篇文章中，你将了解我用来分析这个页面的技术，我用来优化它的工具，并在我的分析产生的火焰图中看到这种影响的规模。</p><h1 id="b91b" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">方法学</h1><p id="592d" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">这些配置文件是由以下人员通过Chrome的性能工具记录的:</p><ol class=""><li id="f1c0" class="lj lk hh jp b jq jr jt ju jw ll ka lm ke ln ki lo lp lq lr bi translated">打开一个匿名窗口<em class="kl">(这样我的浏览器扩展就不会干扰我的分析)</em></li><li id="f003" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki lo lp lq lr bi translated">在本地开发中访问页面时，我想在查询字符串<em class="kl">中使用<code class="du lx ly lz ma b">?react_perf</code>进行分析(以启用React的用户计时注释，并禁用一些只会减慢页面速度的东西，如</em><a class="ae kj" href="https://www.axe-core.org/" rel="noopener ugc nofollow" target="_blank"><em class="kl">axe-core</em></a><em class="kl">)</em></li><li id="5065" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki lo lp lq lr bi translated">点击录制按钮⚫️</li><li id="f36a" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki lo lp lq lr bi translated">与页面互动<em class="kl">(例如滚动、点击、键入)</em></li><li id="0925" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki lo lp lq lr bi translated">点按“录制”按钮🔴再一次解释结果</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/9534422d5e3841ece422dc6133140ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w_bDwdT9s_d25W7qE-DZ1g.gif"/></div></div></figure><p id="ea38" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><em class="kl">通常，我主张在Moto C Plus或CPU节流设置为6倍减速的移动硬件上进行分析，以了解在较慢设备上的人会经历什么。然而，由于这些问题已经够糟糕了，所以即使没有节流，我的超高速笔记本电脑上的机会也是显而易见的。</em></p><h1 id="b744" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">初始渲染</h1><p id="9d4b" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">当我开始处理这个页面时，我注意到我的控制台中有一个警告:💀</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="b2c5" class="mg kn hh ma b fi mh mi l mj mk">webpack-internal:///36:36 Warning: React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:<br/> (client) ut-placeholder-label screen-reader-only"<br/> (server) ut-placeholder-label" data-reactid="628"</span></pre><p id="9c6a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这就是可怕的服务器/客户机不匹配，当服务器呈现的内容与客户机在初始挂载时呈现的内容不同时就会发生这种情况。当使用服务器渲染时，这会迫使你的浏览器做一些它不应该做的事情，所以无论何时发生，React都会给你这个方便的✋警告。</p><p id="1dda" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">不幸的是，错误消息并不十分清楚这种情况发生在哪里或者原因是什么，但是我们确实有一些线索。🔎我注意到一些看起来像CSS类的文本，所以我在终端上输入:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="3edd" class="mg kn hh ma b fi mh mi l mj mk">~/airbnb ❯❯❯ ag ut-placeholder-label<br/>app/assets/javascripts/components/o2/PlaceholderLabel.jsx<br/>85:        'input-placeholder-label': true,</span><span id="06ee" class="mg kn hh ma b fi ml mi l mj mk">app/assets/stylesheets/p1/search/_SearchForm.scss<br/>77:    .input-placeholder-label {<br/>321:.input-placeholder-label,</span><span id="1ba4" class="mg kn hh ma b fi ml mi l mj mk">spec/javascripts/components/o2/PlaceholderLabel_spec.jsx<br/>25:    const placeholderContainer = wrapper.find('.input-placeholder-label');</span></pre><p id="ef2d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这很快将我的搜索范围缩小到了一个叫做<code class="du lx ly lz ma b">o2/PlaceHolderLabel.jsx</code>的东西，它是显示在评论部分顶部的搜索组件。🔍</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/9cc7f79284e6e7d26f97305a321e41ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_D7Zs1HFsSoY7Po."/></div></div></figure><p id="c365" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">事实证明，我们使用了一些功能检测来确保占位符在较旧的浏览器(如Internet Explorer)中可见，如果当前浏览器不支持占位符，则通过不同的方式呈现输入。功能检测是实现这一点的正确方法(与用户代理嗅探相反)，但是由于在服务器呈现时没有浏览器来进行功能检测，服务器将总是呈现比大多数浏览器所呈现的内容多一点的额外内容。</p><p id="af87" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这不仅损害了性能，还导致额外的标签被可视化地呈现，然后每次都从页面上移除。詹基。我通过将该内容的呈现转移到React状态并在<code class="du lx ly lz ma b">componentDidMount</code>中设置它来解决这个问题，它在客户端呈现之前不会运行。🥂</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/414e93c5cb74479df8e75baf25dcea7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dz_-rY84jnCQrWhrlNkECw.png"/></div></div></figure><p id="1add" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我再次运行分析器，注意到<code class="du lx ly lz ma b">&lt;SummaryContainer&gt;</code>在安装后不久就更新了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/f79b8be2f3838deaec112f7b8f9df6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZPHyNBzpm6oT1dqu."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">101.63 ms spent re-rendering Redux-connected SummaryContainer</figcaption></figure><p id="36a0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当它更新时，这会重新渲染一个<code class="du lx ly lz ma b">&lt;BreadcrumbList&gt;</code>，两个<code class="du lx ly lz ma b">&lt;ListingTitles&gt;</code>，和一个<code class="du lx ly lz ma b">&lt;SummaryIconRow&gt;</code>。然而，这些都没有任何区别，所以我们可以通过在这三个组件上使用<code class="du lx ly lz ma b">React.PureComponent</code>来显著降低这个操作的成本。这和改变它一样简单:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="a322" class="mg kn hh ma b fi mh mi l mj mk">export default class SummaryIconRow extends React.Component {<br/>  ...<br/>}</span></pre><p id="9fb1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">变成这样:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="7b4d" class="mg kn hh ma b fi mh mi l mj mk">export default class SummaryIconRow extends React.PureComponent {<br/>  ...<br/>}</span></pre><p id="affb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">接下来，我们可以看到<code class="du lx ly lz ma b">&lt;BookIt&gt;</code>在初始页面加载时也经过了重新渲染。根据火焰🔥图表，大部分时间花在渲染<code class="du lx ly lz ma b">&lt;GuestPickerTrigger&gt;</code>和<code class="du lx ly lz ma b">&lt;GuestCountFilter&gt;</code>上。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/86014fb6be31be882a2d0fb9d9284b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Houn_bWBi4x1rhe."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">103.15 ms spent re-rendering BookIt</figcaption></figure><p id="5168" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">有趣的是，这些组件甚至是不可见的👻除非客人输入被聚焦。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/4062877c2c6ea7723ce994efc91f7a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*VicFFl6VVoKEvWp1."/></div></figure><p id="1474" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">解决这个问题的方法是在不需要这些组件时不要渲染它们。这加快了初始渲染以及最终可能发生的任何重新渲染的速度。🐎如果我们走得更远一点，加入一些更纯的成分，我们可以让这个区域变得更快。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/c3fbe000b6417286d35e96916eca50fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A9Fk9rNQc-hlT4cq."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">8.52 ms spent re-rendering BookIt</figcaption></figure><h1 id="16f8" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">四处滚动</h1><p id="bb4b" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">在做一些工作来使我们有时在列表页面上使用的平滑滚动动画现代化时，我注意到页面在滚动时感觉非常不自然。📜当动画没有达到平滑的60 fps(每秒帧数)，<a class="ae kj" href="https://dassur.ma/things/120fps/" rel="noopener ugc nofollow" target="_blank">甚至可能没有达到120 fps </a>时，人们通常会感到不舒服和不满意。<strong class="jp hi">滚动是一种特殊的动画，与你的手指运动直接相连，因此它对糟糕的表现甚至比其他动画更敏感。</strong></p><p id="a083" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">经过一点分析，我发现我们在滚动事件处理程序中做了很多不必要的React组件的重新渲染！这就是真正的坏人jank的样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/c677261d497c454eb4e8259df24518d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/0*CFcV7cUQMP2tuiLb."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Really bad scrolling performance on Airbnb listing pages before any fixes</figcaption></figure><p id="c336" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">通过将这些树中的三个组件转换成使用<code class="du lx ly lz ma b">React.PureComponent</code> : <code class="du lx ly lz ma b">&lt;Amenity&gt;</code>、<code class="du lx ly lz ma b">&lt;BookItPriceHeader&gt;</code>和<code class="du lx ly lz ma b">&lt;StickyNavigationController&gt;</code>，我能够解决这个问题的大部分。这大大降低了这些重新渲染的成本。虽然我们还没有达到60 fps(每秒帧数)，但我们已经非常接近了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/0b4af792d8c92f26330b0120c0a58260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fV_INfZNo5ochcKA."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Slightly improved scrolling performance of Airbnb listing pages after some fixes</figcaption></figure><p id="0705" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然而，仍然有更多的机会来提高。变焦🚗稍微进入火焰图，我们可以看到我们仍然花了很多时间重新渲染<code class="du lx ly lz ma b">&lt;StickyNavigationController&gt;</code>。如果我们向下看组件堆栈，我们会注意到有四个看起来相似的块:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/699e9be9755316a783eac7868214bd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/0*m34rAJcm9zDr2IWu."/></div><figcaption class="jj jk et er es jl jm bd b be z dx">58.80 ms spent re-rendering StickyNavigationController</figcaption></figure><p id="0b15" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du lx ly lz ma b">&lt;StickyNavigationController&gt;</code>是列表页面中贴在视窗顶部的部分。当您在各部分之间滚动时，它会突出显示您当前所在的部分。火焰中的每一块🚒图表对应于我们在粘性导航中呈现的四个链接之一。而且，当我们在各部分之间滚动时，我们会突出显示一个不同的链接，所以其中一些需要重新呈现。这是它在浏览器中的样子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/b55ca7656108f347a27b492c656ba4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/1*sFbuI4zjaunWiOhINQiV6Q.gif"/></div></figure><p id="e394" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我注意到这里有四个链接，但是只有两个在部分之间转换时改变了外观。但是，在我们的火焰图中，我们看到所有四个链接每次都重新呈现。发生这种情况是因为我们的<code class="du lx ly lz ma b">&lt;NavigationAnchors&gt;</code>组件在render中创建了一个新函数，并每次都将其作为道具传递给<code class="du lx ly lz ma b">&lt;NavigationAnchor&gt;</code>，这降低了纯组件的优化。</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="8e7b" class="mg kn hh ma b fi mh mi l mj mk">const anchors = React.Children.map(children, (child, index) =&gt; {      <br/>  return React.cloneElement(child, {<br/>    selected: activeAnchorIndex === index,<br/>    onPress(event) { onAnchorPress(index, event); },<br/>  });<br/>});</span></pre><p id="d4a3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们可以通过确保每次由<code class="du lx ly lz ma b">&lt;NavigationAnchors&gt;</code>呈现时<code class="du lx ly lz ma b">&lt;NavigationAnchor&gt;</code>总是接收相同的函数来解决这个问题:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="d9e4" class="mg kn hh ma b fi mh mi l mj mk">const anchors = React.Children.map(children, (child, index) =&gt; {      <br/>  return React.cloneElement(child, {<br/>    selected: activeAnchorIndex === index,<br/>    index,<br/>    onPress: this.handlePress,<br/>  });<br/>});</span></pre><p id="a968" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然后在<code class="du lx ly lz ma b">&lt;NavigationAnchor&gt;</code>:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="3969" class="mg kn hh ma b fi mh mi l mj mk">class NavigationAnchor extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.handlePress = this.handlePress.bind(this);<br/>  }</span><span id="0ed5" class="mg kn hh ma b fi ml mi l mj mk">  handlePress(event) {<br/>    this.props.onPress(this.props.index, event);<br/>  }</span><span id="d8fb" class="mg kn hh ma b fi ml mi l mj mk">  render() {<br/>    ...<br/>  }<br/>}</span></pre><p id="8086" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在此更改之后，我们看到只有两个链接被重新呈现！那是一半🌗工作！而且，如果我们在这里使用了四个以上的链接，那么需要完成的工作量就不会再增加了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/d7e3bef7d8765334e8d1baf27b53ae7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*UwwNS6-WeByC0sYm."/></div><figcaption class="jj jk et er es jl jm bd b be z dx">32.85 ms spent re-rendering StickyNavigationController</figcaption></figure><p id="5cd8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><a class="mw mx ge" href="https://medium.com/u/53a00712afc2?source=post_page-----6cd8d93df6f4--------------------------------" rel="noopener" target="_blank"> <em class="kl">斗南石</em></a><em class="kl">at</em><a class="mw mx ge" href="https://medium.com/u/a4c150df1e8c?source=post_page-----6cd8d93df6f4--------------------------------" rel="noopener" target="_blank"><em class="kl">Flexport</em></a><em class="kl">一直致力于</em> <a class="ae kj" href="https://github.com/flexport/reflective-bind" rel="noopener ugc nofollow" target="_blank"> <em class="kl">反射绑定</em> </a> <em class="kl">，它使用一个通天塔插件来为你执行这种类型的优化。现在还为时尚早，所以它可能还没有准备好投入生产，但我对这里的可能性感到非常兴奋。</em></p><p id="02c2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">向下看性能记录中的主面板，我注意到我们有一个非常可疑的<code class="du lx ly lz ma b">_handleScroll</code>块，它在每个滚动事件中消耗19毫秒。因为如果我们想要达到60 fps，我们只有16毫秒，这太多了。🌯</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/1f75ee7f28b3331d164e46dc1ee0b4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xRqIpxSt6fH22tCt."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">18.45 ms spent in <code class="du lx ly lz ma b">_handleScroll</code></figcaption></figure><p id="6046" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">罪魁祸首似乎就在<code class="du lx ly lz ma b">onLeaveWithTracking</code>内部的某个地方。通过一些代码搜索，我追踪到了<code class="du lx ly lz ma b">&lt;EngagementWrapper&gt;</code>。仔细观察这些调用堆栈，我注意到大部分时间都花在React的<code class="du lx ly lz ma b">setState</code>中，但奇怪的是，我们在这里实际上没有看到任何重新渲染。嗯（表示踌躇等）...</p><p id="e98e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">再深入一点，我注意到我们正在使用反应状态🗺跟踪实例的一些信息。</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="c9f1" class="mg kn hh ma b fi mh mi l mj mk">this.state = { inViewport: false };</span></pre><p id="ba8b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然而，<strong class="jp hi">我们从来没有在渲染路径中使用这个状态，也从来不需要这些状态变化来导致重新渲染，所以我们最终支付了额外的成本</strong>。💸将React state的所有这些用法转换成简单的实例变量确实有助于我们加快这些滚动动画的速度。</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="d98a" class="mg kn hh ma b fi mh mi l mj mk">this.inViewport = false;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/eb7925c6c83202c5ea8474b16443137d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FIGmkF_IXHbb36Rx."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">1.16ms spent in scroll event handler</figcaption></figure><p id="3541" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我还注意到<code class="du lx ly lz ma b">&lt;AboutThisListingContainer&gt;</code>被重新渲染，这导致了一个昂贵的💰以及<code class="du lx ly lz ma b">&lt;Amenities&gt;</code>组件不必要的重新渲染。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/1621403c06e9c64f45c385fefdd75f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*jL45wVOeK7404zcb."/></div><figcaption class="jj jk et er es jl jm bd b be z dx">32.24 ms spent in AboutThisListingContainer re-render</figcaption></figure><p id="f61e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这最终部分是由我们用来帮助我们进行实验的高阶成分引起的。这个HOC是以这样一种方式编写的，它总是把一个新创建的对象作为道具传递给它所包装的组件——去优化它路径上的任何东西。</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="bd56" class="mg kn hh ma b fi mh mi l mj mk">render() {<br/>  ...</span><span id="87a5" class="mg kn hh ma b fi ml mi l mj mk">  const finalExperiments = {<br/>    ...experiments,<br/>    ...this.state.experiments,<br/>  };</span><span id="ee5d" class="mg kn hh ma b fi ml mi l mj mk">  return (<br/>    &lt;WrappedComponent<br/>      {...otherProps}<br/>      experiments={finalExperiments}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="6c17" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我通过为这项工作引入<a class="ae kj" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>来解决这个问题，它会记住以前的结果，这样它在连续渲染之间将保持引用相等。</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="2bf0" class="mg kn hh ma b fi mh mi l mj mk">const getExperiments = createSelector(<br/>  ({ experimentsFromProps }) =&gt; experimentsFromProps,<br/>  ({ experimentsFromState }) =&gt; experimentsFromState,<br/>  (experimentsFromProps, experimentsFromState) =&gt; ({<br/>    ...experimentsFromProps,<br/>    ...experimentsFromState,<br/>  }),<br/>);</span><span id="8d5b" class="mg kn hh ma b fi ml mi l mj mk">...</span><span id="7b1f" class="mg kn hh ma b fi ml mi l mj mk">render() {<br/>  ...</span><span id="25bc" class="mg kn hh ma b fi ml mi l mj mk">  const finalExperiments = getExperiments({<br/>    experimentsFromProps: experiments,<br/>    experimentsFromState: this.state.experiments,<br/>  });</span><span id="7696" class="mg kn hh ma b fi ml mi l mj mk">  return (<br/>    &lt;WrappedComponent<br/>      {...otherProps}<br/>      experiments={finalExperiments}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="31d3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">问题的第二部分是相似的。在这个代码路径中，我们使用了一个名为<code class="du lx ly lz ma b">getFilteredAmenities</code>的函数，它将一个数组作为其第一个参数，并返回该数组的一个过滤版本，类似于:</p><pre class="iy iz ja jb fd mc ma md me aw mf bi"><span id="412a" class="mg kn hh ma b fi mh mi l mj mk">function getFilteredAmenities(amenities) {<br/>  return amenities.filter(shouldDisplayAmenity);<br/>}</span></pre><p id="b5a1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">虽然这看起来很简单，但每次运行时都会创建一个新的数组实例，即使它产生的结果是相同的，这将使任何接收该数组作为属性的纯组件不再优化。我通过引入重新选择来记忆过滤，也解决了这个问题。我没有这个的火焰图，因为整个重新渲染完全消失了！👻</p><p id="702e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里可能还有更多机会(例如<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/CSS/contain" rel="noopener ugc nofollow" target="_blank"> CSS遏制</a>)，但是滚动性能已经看起来好得多了！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/cbf93aa031ac5bda414ce06965078186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*7vX8RmLIIDkqHPWPzGPOhA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Improved scrolling performance on Airbnb listing pages after these fixes</figcaption></figure><h1 id="5cda" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">点击东西</h1><p id="f68e" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">与页面互动多一点，当我点击评论上的“帮助”按钮时，我感觉到一些明显的滞后✈️。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/238e36ebd931dcb0023255fc05be2b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMXuKO1LSSx-FGM8."/></div></div></figure><p id="98b7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我的直觉是，点击这个按钮会导致页面上的所有评论被重新呈现。看着火焰图，我并没有差太远:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/e172451e4b2fa920623b0b8b02be5f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qfYVyzrWQRqeDFXQ."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">42.38 ms re-rendering ReviewsContent</figcaption></figure><p id="2cdc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在去了几个地方的<code class="du lx ly lz ma b">React.PureComponent</code>后，我们让这些更新更有效率。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/8d7b960d9e055ab85ff219dea0222c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPNN14uZ5LqOS8B3."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">12.38 ms re-rendering ReviewsContent</figcaption></figure><h1 id="ae57" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">打字的东西</h1><p id="985c" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">回到我们的老朋友，服务器/客户端不匹配，我注意到在这个框中输入感觉真的没有反应。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/ffc44a1c373deb7d1a675ba490061dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iWJlliBeKUNDmSu3."/></div></div></figure><p id="9bfc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我的分析中，我发现每一次按键都会导致整个review部分标题和每个review被重新呈现！😱这不是那么乌鸦。🐦</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/4cf069204b743775ca484f6495cae3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GCSQEZAZyaSBjgXA."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">61.32 ms re-rendering Redux-connected ReviewsContainer</figcaption></figure><p id="2845" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">为了解决这个问题，我提取了头部的一部分作为它自己的组件，这样我就可以把它变成一个<code class="du lx ly lz ma b">React.PureComponent</code>，然后在整个树中添加一些<code class="du lx ly lz ma b">React.PureComponent</code>。这使得每次按键只重新呈现需要重新呈现的组件:输入。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es et"><img src="../Images/49ff9241f32857e71a306abb8123a9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NWzbAAPcfys13iFh."/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">3.18 ms re-rendering ReviewsHeader</figcaption></figure><h1 id="42ca" class="km kn hh bd ko kp kq kr ks kt ku kv kw in kx io ky iq kz ir la it lb iu lc ld bi translated">我们学到了什么？</h1><ul class=""><li id="203a" class="lj lk hh jp b jq le jt lf jw nf ka ng ke nh ki ni lp lq lr bi translated">我们希望页面快速启动并保持快速运行。</li><li id="515b" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki ni lp lq lr bi translated">这意味着我们需要关注的不仅仅是交互时间，我们还需要分析页面上的交互，比如滚动、点击和输入。</li><li id="f24d" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki ni lp lq lr bi translated"><code class="du lx ly lz ma b">React.PureComponent</code>和重新选择是我们React应用优化工具包中非常有用的工具。</li><li id="165f" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki ni lp lq lr bi translated">当实例变量等较轻的工具完全适合您的用例时，避免使用较重的工具，如React state。</li><li id="6e3e" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki ni lp lq lr bi translated">React给了我们很大的能力，但是编写代码去优化你的应用程序是很容易的。</li><li id="e850" class="lj lk hh jp b jq ls jt lt jw lu ka lv ke lw ki ni lp lq lr bi translated">培养剖析的习惯，做出改变，然后再次剖析。</li></ul></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="82ee" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果你喜欢读这篇文章，我们一直在寻找有才华、有好奇心的人加入到<a class="ae kj" href="https://www.airbnb.com/careers/departments/engineering" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">的团队中来。我们意识到Airbnb的性能仍有很大的提升空间，但如果你碰巧注意到一些可能需要我们关注的事情，或者只是想谈谈工作，请随时在Twitter上联系我</em></p></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="32ca" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">大呼小叫<a class="mw mx ge" href="https://medium.com/u/2d876a51e42?source=post_page-----6cd8d93df6f4--------------------------------" rel="noopener" target="_blank"> Thai Nguyen </a>帮助审查这些变化，并致力于将列表页面纳入核心预订流程单页应用程序。♨️被炒作了！非常感谢开发Chrome DevTools的团队——这些性能可视化是一流的！此外，巨大的道具网飞为<em class="kl">陌生人的事情2 </em>。🙃</p></div></div>    
</body>
</html>