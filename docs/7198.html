<html>
<head>
<title>Anatomy of an HAProxy  Java TLS bug</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析一个HAProxy Java TLS bug</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/anatomy-of-an-haproxy-java-tls-bug-5c0b3b8fb085?source=collection_archive---------4-----------------------#2017-03-27">https://medium.com/square-corner-blog/anatomy-of-an-haproxy-java-tls-bug-5c0b3b8fb085?source=collection_archive---------4-----------------------#2017-03-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f87c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">TL；DR: Java严格解释TLS规范，当连接被不干净地关闭时，不允许会话恢复。</em></p><blockquote class="jd"><p id="f722" class="je jf hh bd jg jh ji jj jk jl jm jb dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae jn" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="8ae6" class="pw-post-body-paragraph ie if hh ig b ih jo ij ik il jp in io ip jq ir is it jr iv iw ix js iz ja jb ha bi translated">在将基于HAProxy的内部负载平衡项目部署到包含数百个服务和后端的配置的暂存环境中时，HAProxy立即将CPU使用率确定为100%。由于还没有流量通过HAProxy，唯一可能的原因是对每个服务后端进行的健康检查。</p><p id="3ae7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Square使用TLS进行所有服务到服务的通信，包括健康检查，因此HAProxy被配置为使用SSL，而不进行证书验证。假设CPU使用高峰是由于不断创建到后端服务器的新连接的成本，则创建了一个补丁来添加对HAProxy的健康检查持久连接的支持。这解决了问题，但由于HAProxy是开源的，让上游集成补丁将是最好的解决方案。</p><p id="49ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦提交到邮件列表，HAProxy的创建者Willy Tarreau指出，涉及CPU密集型密钥生成的新TLS会话应该只在初始连接上创建，后续连接应该使用<a class="ae jn" href="https://hpbn.co/transport-layer-security-tls/#tls-session-resumption" rel="noopener ugc nofollow" target="_blank">会话恢复</a>。灯泡，书桌，废话。</p><p id="f3e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，HAProxy公开了一个stats套接字，其中包含了后端每秒交换的SSL密钥数量。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4031" class="kc kd hh jy b fi ke kf l kg kh">socat -t120 ./stats.sock stdio &lt;&lt;&lt; “show info” | grep SslBackendKeyRate</span></pre><p id="f5e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">持续超过300次，这意味着HAProxy每秒钟要建立300次新的(昂贵的)SSL会话。由于HAProxy是一个单线程，事件驱动的服务器，这是饱和的CPU，它甚至很难返回统计信息。</p><p id="8d6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过慢慢地将配置文件缩减到最低限度并监控<code class="du ki kj kk jy b">SslBackendKeyRate</code>，最终发现问题只影响Java服务。</p><p id="38cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用tcpdump和Wireshark，对HAProxy和后端之间的SSL流量进行了快照:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="530d" class="kc kd hh jy b fi ke kf l kg kh">sudo tcpdump -w out -i any -s 1600 ‘(tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):1] = 0x16)’</span><span id="0db4" class="kc kd hh jy b fi kl kf l kg kh">In Wireshark: Analyze -&gt; Decode As -&gt; SSL for the desired ports decodes the unencrypted SSL packet information.</span></pre><p id="a838" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在数据包转储中，似乎HAProxy将从后端接收一个会话ID，并在下一个连接中重用它，但后端仍会坚持为新连接进行完整的密钥交换。</p><p id="0ce7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OpenSSL客户端能够确认会话恢复仍然在后端正常工作:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1bd4" class="kc kd hh jy b fi ke kf l kg kh">echo “Q” | openssl s_client -connect {HOST}:{PORT} -reconnect | grep Session-ID</span></pre><p id="29fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，一旦制造出一个小的<a class="ae jn" href="https://github.com/steved/haproxy-java-ssl-check" rel="noopener ugc nofollow" target="_blank">复制案例</a>，就找到了确凿的证据。</p><p id="c902" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过启用Java的SSL调试(<code class="du ki kj kk jy b">-Djavax.net.debug=all</code>)，日志显示当连接关闭时会话是无效的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e152" class="kc kd hh jy b fi ke kf l kg kh">qtp1952751122–12, fatal error: 80: Inbound closed before receiving peer’s close_notify: possible truncation attack?javax.net.ssl.SSLException: Inbound closed before receiving peer’s close_notify: possible truncation attack?<br/>%% Invalidated: [Session-2, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384]</span></pre><p id="8829" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看HAProxy的健康检查代码，有几处连接被关闭，但最值得注意的是这几行:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2431" class="kc kd hh jy b fi ke kf l kg kh">/* Close the connection.. We absolutely want to perform a hard close<br/>* and reset the connection if data is pending, otherwise we end<br/>* up with many TIME_WAITs and eat all the source port range quickly.<br/>* To avoid sending RSTs all the time, we first try to drain pending<br/>* data.<br/>*/<br/>__conn_data_stop_both(conn);<br/>conn_data_shutw_hard(conn);</span></pre><p id="1cb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk jy b">conn_data_shutw_hard</code>依次调用SSL会话上的shutw函数，并设置不干净标志:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7e1c" class="kc kd hh jy b fi ke kf l kg kh">if (!clean)<br/>        /* don't sent notify on SSL_shutdown */<br/>        SSL_set_quiet_shutdown(conn-&gt;xprt_ctx, 1);</span></pre><p id="d85f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jn" href="https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_quiet_shutdown(3)" rel="noopener ugc nofollow" target="_blank"> SSL_set_quiet_shutdown </a>设置一个标志，当SSL会话关闭时，不会向服务器发送“关闭通知”数据包。</p><p id="000c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种行为在<a class="ae jn" href="https://tools.ietf.org/html/rfc5246#section-7.2.1" rel="noopener ugc nofollow" target="_blank"> TLS 1.1规范</a>中变得有效:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2d6a" class="kc kd hh jy b fi ke kf l kg kh">close_notify</span><span id="6f4a" class="kc kd hh jy b fi kl kf l kg kh">This message notifies the recipient that the sender will not send<br/>any more messages on this connection. Note that as of TLS 1.1,<br/>failure to properly close a connection no longer requires that a<br/>session not be resumed. This is a change from TLS 1.0 to conform<br/>with widespread implementation practice.</span></pre><p id="ea5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在来自Java的日志消息中，指出SSL会话无效是因为2013年发现的针对TLS的攻击，称为“<a class="ae jn" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Truncation_attack" rel="noopener ugc nofollow" target="_blank">截断攻击</a>”Java通过要求完整的TLS关闭序列来允许会话恢复，从而缓解了这一问题。</p><p id="1e07" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终，补丁本质上是五个字符的改变:</p><figure class="jt ju jv jw fd km"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="44b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过至少尝试干净地关闭SSL会话，将(几乎)总是发送“关闭通知”,并且可以干净地恢复会话。CPU使用率降至正常水平。该修补程序已被接受并在1.7.4版中发布。</p><p id="5db6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里找到完整的线索:</p><p id="1275" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jn" href="https://www.mail-archive.com/haproxy@formilux.org/msg25078.html" rel="noopener ugc nofollow" target="_blank">https://www . mail-archive . com/ha proxy @ formi lux . org/msg 25078 . html</a></p></div></div>    
</body>
</html>