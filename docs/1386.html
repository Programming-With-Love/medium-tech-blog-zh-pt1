<html>
<head>
<title>Why Everyone is Talking About Isomorphic / Universal JavaScript and Why it Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么每个人都在谈论同构/通用JavaScript，为什么它很重要</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905?source=collection_archive---------0-----------------------#2016-03-21">https://medium.com/capital-one-tech/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905?source=collection_archive---------0-----------------------#2016-03-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/15b342d21db9857a7d17145c8b2b2e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfSP6VFkWNCrLL9TBnYCNQ.jpeg"/></div></div></figure><p id="5564" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最初应用于数学的术语“同构”是由Airbnb 的<a class="ae jn" href="http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/" rel="noopener ugc nofollow" target="_blank"> Spike Brehm在Javascript开发中首次推广的。从一开始，许多开发人员就反对这种用法，最近，随着竞争术语“通用Javascript”作为“同构Javascript”的替代物出现(最引人注目的是在</a><a class="ae jn" rel="noopener" href="/@mjackson/universal-javascript-4761051b7ae9">迈克尔·杰克逊的帖子</a>)，这种用法已经成为新闻为了简单起见，我将坚持使用更吸引人的词同构，因为这是第一个，也是为了避免陷入技术领域如此普遍的术语之争。在这篇文章中，我们将更深入地探讨同构的概念，并揭示为什么它对web开发如此重要——不管用来描述它的流行语是什么。</p><p id="854e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">同构</strong>应用于web开发意味着在服务器端和客户端都呈现页面。这通常意味着使用JavaScript和Node.js/Io.js，因为它们允许库的重用，允许浏览器JavaScript代码在Node.js/Io.js环境中运行，只需很少的修改。由于这种可互换性，Node.js和JavaScript生态系统支持多种同构框架，例如<a class="ae jn" href="http://reactjs.net/" rel="noopener ugc nofollow" target="_blank"> React.js </a>、<a class="ae jn" href="http://lazojs.org/" rel="noopener ugc nofollow" target="_blank"> lazo.js </a>和<a class="ae jn" href="http://rendrjs.github.io/" rel="noopener ugc nofollow" target="_blank"> Rendr </a>等等。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div class="er es jo"><img src="../Images/6844bb35686485824b20193a04a33064.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*oFwqQyEaOx29qW-U.png"/></div></figure><p id="cb0b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开发人员热衷于同构的三个主要原因是:</p><ul class=""><li id="6353" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">更好的搜索引擎优化(SEO)</li><li id="1fda" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">更好的性能</li><li id="4b81" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">更好的可维护性</li></ul><p id="dcb8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们谈到这些好处之前，让我们后退一步，看看web的历史以及它与同构的关系。</p><h1 id="9896" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Web开发快速概述</h1><p id="bba8" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">在网络的早期，服务器呈现所有的HTML页面，网络体验比桌面应用差得多。每次用户与页面交互时，页面都必须刷新，大多数交互都是像提交一些数据或更新记录这样的单一操作。再加上用户体验意识差(UX)和连接慢，你就明白了…</p><p id="64bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到2000年底，所谓的单页应用程序(SPAs)变得更加流行，因为这种架构允许更快、更用户友好的应用程序，其性能更像桌面应用程序。(如今，桌面应用程序是使用web技术构建的，使用了像Electron或Adobe Air这样的包装器，所以桌子是反过来的！)SPAs的定义特征是它们不需要页面重载，异步加载数据，因此用户可以在数据加载时做其他事情。例如，您可以在Gmail中并行标记多封电子邮件，而无需等待标记电子邮件的第一个过程成功完成。这改善了用户体验，因为spa的功能更像桌面应用程序。这就是为什么你可能会使用很多spa——谷歌文档就是一个很好的例子——或者甚至已经开发了一个。</p><p id="c217" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">SPAs的另一个特征是HTML在客户端，即浏览器上呈现和操作。这减小了有效负载的大小，因为服务器只返回JSON，而不是HTML。然而，这种方法也有一些缺点:</p><ul class=""><li id="d300" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">大部分搜索引擎在抓取网站时不支持客户端渲染。甚至谷歌也声明<a class="ae jn" href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" rel="noopener ugc nofollow" target="_blank">代码必须足够简单，让它的爬虫能正确解释</a>。</li><li id="d2cf" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">随着spa变得越来越大，它们要求用户下载越来越多的前端JavaScript代码，导致应用程序可以使用之前的等待时间增加(“正在加载…”消息)。</li><li id="c1b2" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">用户必须打开JavaScript。</li><li id="d920" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">页面框架加载后，用户必须等待数据通过JSON中的AJAX/XHR返回。</li></ul><p id="4ba4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用非同构的策略来修补这些问题是非常麻烦的。例如，在同构JavaScript成为流行术语之前很久，在服务器端呈现页面就是一种实践。然而，沿着SPAs呈现服务器端通常需要使用不同的模板和逻辑，因为服务器端平台使用像Ruby、Java或PHP这样的语言。同样，另一个重要的策略是将爬虫重定向到运行类似Phantom.js 的无头浏览器的<a class="ae jn" href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" rel="noopener ugc nofollow" target="_blank">独立机器上。</a></p><p id="6dbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着Node.js的出现，编写在浏览器和服务器上呈现的代码成为可能。不用说，从可维护性的角度来看，只有一套代码要好得多，并且开始超越其他web开发策略。那么同构如何解决SEO、性能和可维护性的问题呢？</p><h1 id="189d" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">搜索引擎正确索引页面的能力</h1><p id="4896" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">用Backbone.js、Angular.js、Ember.js等框架构建的单页面应用。广泛用于编写受保护的应用程序，即需要用户名和密码才能访问的应用程序。大多数spa提供受保护的资源，并且不需要web索引，因为它们没有公共仪表板。例如，从Capital One网上银行到Gmail再到Evernote.com，每个人都要求用户在看到实际应用程序之前登录。</p><p id="bcc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，绝大多数网站在登录后并没有受到保护。对于这些公共应用和页面，SEO实际上是强制性的，因为他们的商业模式严重依赖于搜索索引和有机流量。最近，谷歌为他们的爬虫添加了JavaScript渲染功能。理论上，这意味着谷歌将像普通浏览器一样呈现SPA，并索引其内容。然而，谷歌自己说，“有时在渲染过程中事情并不完美，这可能会对你网站的搜索结果产生负面影响。”— <a class="ae jn" href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" rel="noopener ugc nofollow" target="_blank">更好地理解网页</a>。所以为了安全起见，SPA开发者<strong class="ir hi">仍然需要将他们的非JavaScript渲染</strong>尽可能地镜像到支持JavaScript的(浏览器或SPA)渲染，以避免被爬虫忽略。例如，Capital One的主页必须被搜索引擎编入索引，以便我们的客户能够轻松找到公开访问的页面。</p><p id="9766" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然有些应用程序优先考虑正确的搜索引擎索引，但其他应用程序则依赖于快速的性能。像mobile.walmart.com(<a class="ae jn" href="http://www.walmartlabs.com/2014/06/in-search-of-the-holy-grail-again" rel="noopener ugc nofollow" target="_blank">文章</a>)和Twitter.com(<a class="ae jn" href="https://blog.twitter.com/2012/improving-performance-on-twittercom" rel="noopener ugc nofollow" target="_blank">文章</a>)这样的网站做了研究，表明提高第一页(第一次加载)的速度可以提高网站的整体性能。</p><p id="6296" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这项研究证实了服务器端渲染需要尽可能快地显示第一页，而其他代码可以在用户浏览页面时加载。因此，当用户加载第一页时，他/她不会看到<em class="lk">“正在加载…”</em>消息；他们会看到一个功能页面，从而有更好的用户体验(UX)和更好的应用体验。</p><h1 id="92a9" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">更好的代码可维护性</h1><p id="2a13" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">代码是一种负担。越多，你和你的团队需要支持的就越多。因此，您通常希望避免对同一页面使用不同的模板和逻辑。幸运的是，Node.js/Io.js——以及手柄、小胡子和灰尘等模板引擎——使得在服务器上使用前端/浏览器模块变得毫不费力。</p><p id="5338" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了重用模板，开发人员还可以在服务器和浏览器上重用相同的库和实用程序，从而进一步减少对多余代码的需求。由于这个原因，像下划线. js、lodash、Request和SuperAgent这样的库非常受欢迎。在服务器和浏览器上拥有相同的库允许更好的开发和代码重用，这使得软件工程师更快乐，花费在维护代码上的时间更少。如果我们更进一步，我们甚至可以开发自己的内部模块，在浏览器和服务器之间共享。我们在Storify用jade-browser做到了这一点。该模块允许您的Node.js和Express.js驱动的应用程序向浏览器公开Jade模板，浏览器JavaScript代码可以使用这些模板(我们在浏览器上使用了Backbone和jQuery)。</p><p id="8bec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同构JavaScript的另一个优势是数据模型可以在浏览器和服务器之间共享，例如Meteor或<a class="ae jn" href="http://netflix.github.io/falcor" rel="noopener ugc nofollow" target="_blank"> Falcor </a>。这最大化了浏览器和服务器之间的一致性。在DocuSign，我们调整了Backbone.js模型(一个浏览器框架)以在服务器上工作。这允许我们在AJAX/XHR请求之前获取DocuSign web SPA的数据，从而提高了应用程序的性能。</p><h1 id="2db9" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">选项:React.js、Lazo.js和Rendr</h1><p id="04c6" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">所以你想在你的web开发中使用同构？虽然有各种各样的库和框架允许开发人员在JavaScript中使用同构，但一些最受欢迎的选择是React.js、Lazo.js和Rendr。下面是这些库的快速比较。</p><h1 id="0c78" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Rendr</h1><p id="54e4" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">Rendr是AirBnb开发的一个库，用于解决首页加载缓慢的问题。它被设计成在服务器上利用Backbone.js架构。Rendr也与Express.js一起工作。如果我们仔细研究Rendr，您会发现路由的设置与Backbone.js中的相似:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="a678" class="lq ki hh lm b fi lr ls l lt lu">module.exports = <strong class="lm hi">function</strong>(match) {<br/>    match('',                   'home#index');<br/>    match('repos',              'repos#index');<br/>    match('repos/:owner/:name', 'repos#show');<br/>    match('users',              'users#index');<br/>    match('users/:login',       'users#show');<br/>};</span></pre><p id="a268" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Rendr应用程序将拥有自己的Express.js实例，我们将它装载到主服务器上:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="91e3" class="lq ki hh lm b fi lr ls l lt lu"><strong class="lm hi">var</strong> server = rendr.createServer({<br/>    dataAdapterConfig: dataAdapterConfig  // Some configurations<br/>});</span><span id="4502" class="lq ki hh lm b fi lv ls l lt lu">//...</span><span id="f964" class="lq ki hh lm b fi lv ls l lt lu">app.use('/', server.expressApp); // Mount Rendr app to the main app</span></pre><p id="cfda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更多Rendr示例可在https://github.com/rendrjs/rendr-examples的<a class="ae jn" href="https://github.com/rendrjs/rendr-examples" rel="noopener ugc nofollow" target="_blank">获得。有很多类似的项目利用主干库来编写可以在服务器上运行的代码，或者设计在客户机和服务器之间共享的组件。这里可以找到一些这样的项目:</a><a class="ae jn" href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" rel="noopener ugc nofollow" target="_blank">主干-服务器端</a>和<a class="ae jn" href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" rel="noopener ugc nofollow" target="_blank">预览cod </a>。</p><h1 id="8b1c" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Lazo.js</h1><p id="5931" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">Lazo与Rendr的相似之处在于它利用了Backbone.js，此外，它还利用了RequireJS和jQuery前端JavaScript库。Lazo路由存储在JSON文件中:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="50fd" class="lq ki hh lm b fi lr ls l lt lu">{<br/>    "routes": {<br/>        "":             { "component": "todos-single" },<br/>        "multiple(/)":  { "component": "todos-multiple" },<br/>        "single(/)":    { "component": "todos-single" },<br/>        "layout(/)":    { "component": "main", "layout": "todos-layout" },<br/>        "header(/)":    { "component": "header" },<br/>        "main(/)":      { "component": "main" },<br/>        "footer(/)":    { "component": "footer" },<br/>        "hello(/)":     { "component": "hello", "layout": "todos-layout" }<br/>    },<br/>    "css": ["/app/client/base.css"]<br/>}</span></pre><p id="a932" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">模块以RequireJS样式定义:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="b48e" class="lq ki hh lm b fi lr ls l lt lu">define(['lazoBundle'], function (LazoBundle) {...})</span></pre><h1 id="5f26" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">React.js</h1><p id="41e9" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">React.js不是模型-视图控制器(MVC)框架；它只有MVC的视图层。这意味着它可以用于大多数其他库前端库，如backbone . js。react . js通常用于JSX语言，这是JavaScript和XML/HTML的混合。在这种情况下，JSX代码在浏览器中执行之前被编译成本机JavaScript。与其他库相比，使用React.js的主要优势在于它使用虚拟DOM进行呈现，这意味着只有变化的增量会呈现在页面上，而未改变的元素保持不变。</p><p id="ebec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是React前端代码的一个例子:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="b56c" class="lq ki hh lm b fi lr ls l lt lu"><strong class="lm hi">var</strong> Header = React.createClass({<br/>    render: <strong class="lm hi">function</strong>(){<br/>        <strong class="lm hi">return</strong> (&lt;<strong class="lm hi">h1</strong>&gt;Message Board&lt;/<strong class="lm hi">h1</strong>&gt;)<br/>    }<br/>})<br/>//...</span></pre><p id="b6f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">React的高明之处在于它没有模板——所有的HTML元素都是由JavaScript代码呈现的。类似XML的语法只是糖衣，因为功能是在JS和HTML之间分开的，这种方法有助于防止不断地从JS跳到HTML，再从JS跳到HTML，等等。当它编译成同构时，React毫不费力地呈现在服务器上，支持我们前面讨论的更快的第一页加载，而后面的交互由浏览器React支持。</p><p id="0766" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一下在用Express.js构建的服务器上呈现的相同组件头。public/js/app.js是带有React组件的浏览器文件，我们将在服务器上重用它:c</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="214b" class="lq ki hh lm b fi lr ls l lt lu"><strong class="lm hi">var</strong> React = require('react/addons'),<br/>    components = require('./public/js/app.js'),<br/>    Header = React.createFactory(components.Header)<br/>    //...<br/>    app.get('/', <strong class="lm hi">function</strong>(req, res, next) {<br/>        req.messages.find({}, {sort: {_id: -1}}).toArray(<strong class="lm hi">function</strong>(err, docs){<br/>            <strong class="lm hi">if</strong> (err) <strong class="lm hi">return</strong> next(err)<br/>            res.render('index', {<br/>                header: React.renderToString(Header()),  props: '&lt;script type="text/javascript"&gt;var messages='+JSON.stringify(docs)+'&lt;/script&gt;'<br/>            })   <br/>        })<br/>    }</span></pre><p id="cb9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在props中传递的数据将在客户端/浏览器上公开。视图的服务器端模板(手柄模板引擎)如下所示:</p><pre class="jp jq jr js fd ll lm ln lo aw lp bi"><span id="ac0e" class="lq ki hh lm b fi lr ls l lt lu">{{{props}}}<br/>&lt;<strong class="lm hi">div</strong> id="header"&gt;<br/>    {{{header}}}<br/>&lt;/<strong class="lm hi">div</strong>&gt;</span></pre><p id="86b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦客户端React代码从数据存储中获得数据(回流、jQuery、主干等)。)，它将检查服务器呈现的元素的校验和。它们将匹配，因为数据是相同的，并且不会有不必要的重新渲染来降低页面速度。这个页面的第一次加载将会非常快，因为渲染发生在服务器上，随后部分DOM更新发生在浏览器上。</p><p id="deb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着SPAs变得越来越普遍，对支持SEO、非JavaScript客户端、更好的UX和快速首页加载的单一客户端/se代码库的需求越来越大。简而言之，同构JavaScript就是这个web开发问题的答案。</p><p id="c0d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同构方法通过使用一组在后端和前端都呈现的代码(通常是JavaScript/Node.js)来解决这些问题，从而实现更好的可维护性、搜索引擎索引和用户体验。虽然这是一个有争议的术语，但这个概念的实用性是稳固的。Node.js/Io.js使同构开发变得更容易和更容易，允许它越来越受欢迎，并扩展到多个框架。</p><p id="599d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JavaScript已经是统治所有这些的第一语言了——如果你说的“所有”是指从浏览器到服务器到数据库的网络技术栈的每一层。如果同构JavaScript代表了web开发的下一次发展，消除了跟踪一千个移动的代码位的复杂性，会怎么样？如果所有那些crowd web developer恢复的缩写——HTML、CSS、HTTP、SQL、RoR、J2EE、PHP——都可以用一个漂亮的JavaScript同构方法来替换，会怎么样？这难道不是普遍的好事吗？</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><p id="f3b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lk">欲了解更多关于Capital One的API、开源、社区活动和开发者文化，请访问我们的一站式开发者门户DevExchange。</em><a class="ae jn" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="lk"/></a></p></div></div>    
</body>
</html>