<html>
<head>
<title>JavaScript Monads Made Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript单子变得简单</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8?source=collection_archive---------0-----------------------#2017-09-12">https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8?source=collection_archive---------0-----------------------#2017-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="69e6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列<strong class="iz hi"> s </strong> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">(现在一本书！)</strong> </a>关于从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae jv" rel="noopener" href="/javascript-scene/composable-datatypes-with-functions-aec72db3b093"> &lt;上一部</a> | &lt; &lt; <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-an-introduction-27b72500d6ea">从第一部开始</a></p></blockquote><p id="28d6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在开始学习单子之前，你应该已经知道:</p><ul class=""><li id="275b" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">功能组成:<code class="du ki kj kk kl b">compose(f, g)(x) = (f ∘ g)(x) = f(g(x))</code></li><li id="672b" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">仿函数基础:对数组<code class="du ki kj kk kl b">.map()</code>操作的理解。</li></ul></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><blockquote class="it iu iv"><p id="065d" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“一旦你理解了单子，你马上就变得无法向任何人解释它们了。”</p></blockquote></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><blockquote class="it iu iv"><p id="a036" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“霍尼克博士过去常说，任何不能向一个8岁的孩子解释自己在做什么的科学家都是骗子。”~库尔特·冯内古特的小说《猫的摇篮》</p></blockquote><p id="37df" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你在互联网上搜索“单子”，你将会受到令人费解的范畴理论数学的轰炸，还有一群人用墨西哥卷饼和宇航服来“有益地”解释单子。</p><p id="e064" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子很简单。行话很难。让我们切入本质。</p><p id="3954" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">一个<strong class="iz hi">单子</strong>是一种组合函数的方式，这些函数除了返回值之外还需要上下文，例如计算、分支或I/O。单子类型提升、展平和映射，以便这些类型为提升函数<code class="du ki kj kk kl b">a =&gt; M(b)</code>排队，使它们可组合。这是从某种类型<code class="du ki kj kk kl b">a</code>到某种类型<code class="du ki kj kk kl b">b</code>的映射以及一些计算上下文，隐藏在提升、展平和映射的实现细节中:</p><ul class=""><li id="7c84" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">功能图:<code class="du ki kj kk kl b">a =&gt; b</code></li><li id="232b" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">带上下文的仿函数映射:<code class="du ki kj kk kl b">Functor(a) =&gt; Functor(b)</code></li><li id="716c" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">单子展平并与上下文映射:<code class="du ki kj kk kl b">Monad(Monad(a)) =&gt; Monad(b)</code></li></ul><p id="ca0e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是“扁平化”、“地图”、“语境”是什么意思呢？</p><ul class=""><li id="389a" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated"><strong class="iz hi">映射</strong>的意思是，“对一个<code class="du ki kj kk kl b">a</code>应用一个函数，返回一个<code class="du ki kj kk kl b">b</code>”。给定一些输入，返回一些输出。</li><li id="b16f" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated"><strong class="iz hi">上下文</strong>是单子合成的计算细节(包括提升、展平和贴图)。Functor/Monad API及其工作方式提供了允许您将Monad与应用程序的其余部分组合在一起的上下文。函子和单子的要点是把上下文抽象出来，这样我们在构造东西的时候就不用担心它了。上下文内的映射意味着将函数从<code class="du ki kj kk kl b">a =&gt; b</code>应用到上下文内的值，并返回包装在同类上下文内的新值<code class="du ki kj kk kl b">b</code>。左边的可观测量？右边的可观测量:<code class="du ki kj kk kl b">Observable(a) =&gt; Observable(b)</code>。数组在左边？右侧数组:<code class="du ki kj kk kl b">Array(a) =&gt; Array(b)</code>。</li><li id="132b" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated"><strong class="iz hi">类型提升</strong>意味着将一个类型提升到一个上下文中，用一个API来支持这个值，你可以用它来计算这个值，触发上下文计算，等等……<code class="du ki kj kk kl b">a =&gt; F(a)</code>(单子是一种函子)。</li><li id="e26e" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated"><strong class="iz hi">展平</strong>意味着从上下文中展开值。<code class="du ki kj kk kl b">F(a) =&gt; a</code>。</li></ul><p id="52c4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">示例:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="f7ae" class="lg lh hh kl b fi li lj l lk ll">const x = 20;             // Some data of type `a`<br/>const f = n =&gt; n * 2;     // A function from `a` to `b`<br/>const arr = Array.of(x);  // The type lift.<br/>// JS has type lift sugar for arrays: [x]</span><span id="ade5" class="lg lh hh kl b fi lm lj l lk ll">// .map() applies the function f to the value x<br/>// in the context of the array.<br/>const result = arr.map(f); // [40]</span></pre><p id="9181" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这种情况下，<code class="du ki kj kk kl b">Array</code>是上下文，<code class="du ki kj kk kl b">x</code>是我们要映射的值。</p><p id="b509" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个例子没有包括数组的数组，但是你可以用<code class="du ki kj kk kl b">.flat()</code>或者<code class="du ki kj kk kl b">.concat()</code>在JS中展平数组:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="e8d9" class="lg lh hh kl b fi li lj l lk ll">[[1], [2, 3], [4]].flat(); // [1, 2, 3, 4] or<br/>[].concat.apply([], [[1], [2, 3], [4]]); // [1, 2, 3, 4]</span></pre><h1 id="9bf4" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">你可能已经在用单子了。</h1><p id="f23c" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">不管你的技能水平或对范畴理论的理解如何，使用单子会使你的代码更容易处理。未能利用单子可能会使您的代码更难处理(例如，回调地狱、嵌套的条件分支、更多的冗长)。</p><p id="43cc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">记住，软件开发的本质是合成，单子让合成更容易。再看看单子的本质是什么:</p><ul class=""><li id="b091" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">Functions map: <code class="du ki kj kk kl b">a =&gt; b</code>，它允许您编写<code class="du ki kj kk kl b">a =&gt; b</code>类型的函数</li><li id="bb42" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">仿函数与上下文映射:<code class="du ki kj kk kl b">Functor(a) =&gt; Functor(b)</code>，这让您可以组合函数<code class="du ki kj kk kl b">F(a) =&gt; F(b)</code></li><li id="7947" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">单子展平并映射上下文:<code class="du ki kj kk kl b">Monad(Monad(a)) =&gt; Monad(b)</code>，这让您可以编写提升函数<code class="du ki kj kk kl b">a =&gt; F(b)</code></li></ul><p id="88ff" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些都只是<strong class="iz hi">功能组合</strong>的不同表达方式而已。函数存在的全部原因是你可以组合它们。函数可以帮助您将复杂的问题分解成更容易单独解决的简单问题，这样您就可以用各种方式将它们组合起来，形成您的应用程序。</p><p id="7e21" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">理解函数及其正确使用的关键是更深入地理解函数的组成。</p><p id="599e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">函数组合创建了数据流经的函数管道。你在管道的第一阶段输入一些数据，然后一些数据从管道的最后一个阶段出来，经过转换。但是要做到这一点，管道的每个阶段都必须期望前一阶段返回的数据类型。</p><p id="954b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">编写简单的函数很容易，因为所有类型都很容易排列。只需将输出类型<code class="du ki kj kk kl b">b</code>与输入类型<code class="du ki kj kk kl b">b</code>匹配，您就可以开始工作了:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="fc4d" class="lg lh hh kl b fi li lj l lk ll">g:           a =&gt; b<br/>f:                b =&gt; c<br/>h = f(g(a)): a    =&gt;   c</span></pre><p id="36f3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">如果你在映射<code class="du ki kj kk kl b">F(a) =&gt; F(b)</code>，用仿函数组合也很容易，因为类型是一致的:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="376d" class="lg lh hh kl b fi li lj l lk ll">g:             F(a) =&gt; F(b)<br/>f:                     F(b) =&gt; F(c)<br/>h = f(g(Fa)):  F(a)    =&gt;      F(c)</span></pre><p id="79c6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是如果你想从<code class="du ki kj kk kl b">a =&gt; F(b)</code>、<code class="du ki kj kk kl b">b =&gt; F(c)</code>等等中合成函数，你需要单子。让我们把<code class="du ki kj kk kl b">F()</code>换成<code class="du ki kj kk kl b">M()</code>来说明这一点:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="452a" class="lg lh hh kl b fi li lj l lk ll">g:                  a =&gt; M(b)<br/>f:                       b =&gt; M(c)<br/>h = composeM(f, g): a    =&gt;   M(c)</span></pre><p id="eeb9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">哎呀。在本例中，<em class="iy">组件函数类型没有对齐！</em>对于<code class="du ki kj kk kl b">f</code>的输入，我们想要类型<code class="du ki kj kk kl b">b</code>，但是我们得到的是类型<code class="du ki kj kk kl b">M(b)</code>(一个<code class="du ki kj kk kl b">b</code>的单子)。由于这种错位，<code class="du ki kj kk kl b">composeM()</code>需要解开<code class="du ki kj kk kl b">g</code>返回的<code class="du ki kj kk kl b">M(b)</code>，这样我们就可以将它传递给<code class="du ki kj kk kl b">f</code>，因为<code class="du ki kj kk kl b">f</code>期待的是类型<code class="du ki kj kk kl b">b</code>，而不是类型<code class="du ki kj kk kl b">M(b)</code>。该过程(通常称为<code class="du ki kj kk kl b">.bind()</code>或<code class="du ki kj kk kl b">.chain()</code>)是<em class="iy">展平</em>和<em class="iy">映射</em>发生的地方。</p><p id="34dc" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在将<code class="du ki kj kk kl b">b</code>传递给下一个函数之前，它从<code class="du ki kj kk kl b">M(b)</code>中解开<code class="du ki kj kk kl b">b</code>,这导致:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="3f7c" class="lg lh hh kl b fi li lj l lk ll">g:             a =&gt; M(b) flattens to =&gt; b<br/>f:                                      b           maps to =&gt; M(c)<br/>h composeM(f, g):<br/>               a       flatten(M(b)) =&gt; b =&gt; map(b =&gt; M(c)) =&gt; M(c)</span></pre><p id="c7b5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子将类型排列成提升函数<code class="du ki kj kk kl b">a =&gt; M(b)</code>，这样你就可以组合它们。</p><p id="1383" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在上图中，来自<code class="du ki kj kk kl b">M(b) =&gt; b</code>的<code class="du ki kj kk kl b">flatten</code>和来自<code class="du ki kj kk kl b">b =&gt; M(c)</code>的地图发生在来自<code class="du ki kj kk kl b">a =&gt; M(c)</code>的<code class="du ki kj kk kl b">chain</code>内。在<code class="du ki kj kk kl b">composeM()</code>内部处理<code class="du ki kj kk kl b">chain</code>调用。在高水平上，你不用担心。您可以使用与编写普通函数相同的API来编写单子返回函数。</p><p id="d08a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子是必需的，因为许多函数不是来自<code class="du ki kj kk kl b">a =&gt; b</code>的简单映射。一些函数需要处理副作用(承诺、流)、处理分支(可能)、处理异常(两者之一)等...</p><p id="beea" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这里有一个更具体的例子。如果您需要从异步API获取一个用户，然后将该用户数据传递给另一个异步API来执行一些计算，该怎么办？：</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="7d4e" class="lg lh hh kl b fi li lj l lk ll">getUserById(id: String) =&gt; Promise(User)<br/>hasPermision(User) =&gt; Promise(Boolean)</span></pre><p id="3dbd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">让我们写一些函数来演示这个问题。第一，公用事业，<code class="du ki kj kk kl b">compose()</code>和<code class="du ki kj kk kl b">trace()</code>:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="2f42" class="lg lh hh kl b fi li lj l lk ll">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</span><span id="6748" class="lg lh hh kl b fi lm lj l lk ll">const trace = label =&gt; value =&gt; {<br/>  console.log(`${ label }: ${ value }`);<br/>  return value;<br/>};</span></pre><p id="cf87" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">然后是一些功能组合:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="f3d7" class="lg lh hh kl b fi li lj l lk ll">{<br/>  const label = 'API call composition';</span><span id="0573" class="lg lh hh kl b fi lm lj l lk ll">  // a =&gt; Promise(b)<br/>  const getUserById = id =&gt; id === 3 ?<br/>    Promise.resolve({ name: 'Kurt', role: 'Author' }) :<br/>    undefined<br/>  ;</span><span id="111c" class="lg lh hh kl b fi lm lj l lk ll">  // b =&gt; Promise(c)<br/>  const hasPermission = ({ role }) =&gt; (<br/>    Promise.resolve(role === 'Author')<br/>  );</span><span id="75ca" class="lg lh hh kl b fi lm lj l lk ll">  // Try to compose them. Warning: this will fail.<br/>  const authUser = compose(hasPermission, getUserById);</span><span id="ebfb" class="lg lh hh kl b fi lm lj l lk ll">  // Oops! Always false!<br/>  authUser(3).then(trace(label));<br/>}</span></pre><p id="00cf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当我们试图将<code class="du ki kj kk kl b">hasPermission()</code>与<code class="du ki kj kk kl b">getUserById()</code>组合成<code class="du ki kj kk kl b">authUser()</code>时，我们遇到了一个大问题，因为<code class="du ki kj kk kl b">hasPermission()</code>期待一个<code class="du ki kj kk kl b">User</code>对象，却得到了一个<code class="du ki kj kk kl b">Promise(User)</code>。为了解决这个问题，我们需要用<code class="du ki kj kk kl b">composePromises()</code>替换<code class="du ki kj kk kl b">compose()</code>——compose的一个特殊版本，它知道需要使用<code class="du ki kj kk kl b">.then()</code>来完成函数组合:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="3a74" class="lg lh hh kl b fi li lj l lk ll">{<br/>  const composeM = chainMethod =&gt; (...ms) =&gt; (<br/>    ms.reduce((f, g) =&gt; x =&gt; g(x)[chainMethod](f))<br/>  );</span><span id="9ca6" class="lg lh hh kl b fi lm lj l lk ll">  const composePromises = composeM('then');</span><span id="b4fc" class="lg lh hh kl b fi lm lj l lk ll">  const label = 'API call composition';</span><span id="51c2" class="lg lh hh kl b fi lm lj l lk ll">  // a =&gt; Promise(b)<br/>  const getUserById = id =&gt; id === 3 ?<br/>    Promise.resolve({ name: 'Kurt', role: 'Author' }) :<br/>    undefined<br/>  ;</span><span id="fe4e" class="lg lh hh kl b fi lm lj l lk ll">  // b =&gt; Promise(c)<br/>  const hasPermission = ({ role }) =&gt; (<br/>    Promise.resolve(role === 'Author')<br/>  );</span><span id="d1a8" class="lg lh hh kl b fi lm lj l lk ll">  // Compose the functions (this works!)<br/>  const authUser = composePromises(hasPermission, getUserById);</span><span id="a18b" class="lg lh hh kl b fi lm lj l lk ll">  authUser(3).then(trace(label)); // true<br/>}</span></pre><p id="65c8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">稍后，我们将进入<code class="du ki kj kk kl b">composeM()</code>正在做什么。</p><p id="2455" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">记住单子的本质:</p><ul class=""><li id="0733" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">功能图:<code class="du ki kj kk kl b">a =&gt; b</code></li><li id="35a4" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">带上下文的仿函数映射:<code class="du ki kj kk kl b">Functor(a) =&gt; Functor(b)</code></li><li id="c94c" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">单子展平并与上下文映射:<code class="du ki kj kk kl b">Monad(Monad(a)) =&gt; Monad(b)</code></li></ul><p id="667a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这种情况下，我们的单子实际上是承诺，所以当我们构造这些承诺返回函数时，我们有一个<code class="du ki kj kk kl b">Promise(User)</code>而不是<code class="du ki kj kk kl b">hasPermission()</code>所期望的<code class="du ki kj kk kl b">User</code>。注意，如果你去掉了<code class="du ki kj kk kl b">Monad(Monad(a))</code>的外层<code class="du ki kj kk kl b">Monad()</code>包装，你会剩下<code class="du ki kj kk kl b">Monad(a) =&gt; Monad(b)</code>，它只是常规的仿函数<code class="du ki kj kk kl b">.map()</code>。如果我们有可以弄平的东西，我们就可以做生意了。</p><h1 id="8c13" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">单子是由什么组成的</h1><p id="e6d0" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">单子基于一种简单的对称——一种将值包装到上下文中的方法，以及一种从上下文中解开值的方法:</p><ul class=""><li id="51be" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated"><strong class="iz hi">提升/单位:</strong>一个类型从某个类型提升到单子上下文:<code class="du ki kj kk kl b">a =&gt; M(a)</code></li><li id="1417" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated"><strong class="iz hi">展平/合并:</strong>从上下文中展开类型:<code class="du ki kj kk kl b">M(a) =&gt; a</code></li></ul><p id="680b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">由于单子也是函子，它们也可以映射:</p><ul class=""><li id="365c" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated"><strong class="iz hi">地图:</strong>保留上下文的地图:<code class="du ki kj kk kl b">M(a) -&gt; M(b)</code></li></ul><p id="dda8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">将flatten与map结合起来，您可以得到单子提升函数的链式函数合成，也称为Kleisli合成，以<a class="ae jv" href="https://en.wikipedia.org/wiki/Heinrich_Kleisli" rel="noopener ugc nofollow" target="_blank"> Heinrich Kleisli </a>命名:</p><ul class=""><li id="3a3d" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated"><strong class="iz hi">平面贴图/链:</strong>展平+贴图:<code class="du ki kj kk kl b">M(M(a)) =&gt; M(b)</code></li></ul><p id="0946" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对于单子，<code class="du ki kj kk kl b">.map()</code>方法经常从公共API中省略。Lift + flatten不要明确拼出<code class="du ki kj kk kl b">.map()</code>，但是你有了制作它所需的所有成分。如果你能解除(又名of/unit)和锁链(又名bind/flatMap)，你就可以制造<code class="du ki kj kk kl b">.map()</code>:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="8394" class="lg lh hh kl b fi li lj l lk ll">const MyMonad = value =&gt; ({<br/>  // &lt;... insert arbitrary chain and of here ...&gt;<br/>  map (f) {<br/>    return this.chain(a =&gt; this.constructor.of(f(a)));<br/>  }<br/>});</span></pre><p id="08a0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所以，如果你为你的单子定义了<code class="du ki kj kk kl b">.of()</code>和<code class="du ki kj kk kl b">.chain()</code> / <code class="du ki kj kk kl b">.join()</code>，就可以推断出<code class="du ki kj kk kl b">.map()</code>的定义。</p><p id="92ad" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">电梯是工厂/建造者和/或<code class="du ki kj kk kl b">constructor.of()</code>方法。在范畴论里叫“单位”。它所做的只是将类型提升到单子的上下文中。它将一个<code class="du ki kj kk kl b">a</code>变成一个<code class="du ki kj kk kl b">a</code>的<code class="du ki kj kk kl b">Monad</code>。</p><p id="2bc2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在Haskell中，它(非常容易混淆)被称为<code class="du ki kj kk kl b">return</code>，当你试图大声谈论它时，它会变得非常混乱，因为几乎每个人都会把它与函数返回混淆。我在散文中几乎总是称之为“提升”或“类型提升”，在代码中则称之为<code class="du ki kj kk kl b">.of()</code>。</p><p id="3201" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">那个展平过程(在<code class="du ki kj kk kl b">.chain()</code>中没有地图)通常被称为<code class="du ki kj kk kl b">flatten()</code>或<code class="du ki kj kk kl b">join()</code>。经常(但不总是)，<code class="du ki kj kk kl b">flatten()</code> / <code class="du ki kj kk kl b">join()</code>被完全省略，因为它内置在<code class="du ki kj kk kl b">.chain()/.flatMap()</code>中。展平通常与构图联系在一起，所以它经常与贴图结合在一起。记住，展开+贴图都是组成<code class="du ki kj kk kl b">a =&gt; M(a)</code>函数所需要的。</p><p id="ce00" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">根据你正在处理的单子的类型，展开过程可能非常简单。在身份单子的情况下，它就像<code class="du ki kj kk kl b">.map()</code>，除了你没有把结果值提升回单子上下文。其效果是丢弃了一层包装:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="14a3" class="lg lh hh kl b fi li lj l lk ll">{ // Identity monad<br/>const Id = value =&gt; ({<br/>  // Functor mapping<br/>  // Preserve the wrapping for .map() by <br/>  // passing the mapped value into the type<br/>  // lift:<br/>  map: f =&gt; Id.of(f(value)),</span><span id="7f0d" class="lg lh hh kl b fi lm lj l lk ll">  // Monad chaining<br/>  // Discard one level of wrapping<br/>  // by omitting the .of() type lift:<br/>  chain: f =&gt; f(value),</span><span id="11bc" class="lg lh hh kl b fi lm lj l lk ll">  // Just a convenient way to inspect<br/>  // the values:<br/>  toString: () =&gt; `Id(${ value })`<br/>});</span><span id="a76c" class="lg lh hh kl b fi lm lj l lk ll">// The type lift for this monad is just<br/>// a reference to the factory.<br/>Id.of = Id;</span></pre><p id="dcee" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是展开部分也是副作用、错误分支或等待异步I/O等奇怪事情通常隐藏的地方。在所有的软件开发中，组合是所有真正有趣的事情发生的地方。</p><p id="b41d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">比如有了承诺，<code class="du ki kj kk kl b">.chain()</code>就叫<code class="du ki kj kk kl b">.then()</code>。呼叫<code class="du ki kj kk kl b">promise.then(f)</code>不会马上调用<code class="du ki kj kk kl b">f()</code>。相反，它会等待承诺解决，然后<em class="iy">再</em>调用<code class="du ki kj kk kl b">f()</code>(因此得名)。</p><p id="3f64" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">示例:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="b5d8" class="lg lh hh kl b fi li lj l lk ll">{<br/>  const x = 20;                 // The value<br/>  const p = Promise.resolve(x); // The context<br/>  const f = n =&gt; <br/>    Promise.resolve(n * 2);     // The function</span><span id="3d3a" class="lg lh hh kl b fi lm lj l lk ll">  const result = p.then(f);     // The application</span><span id="00a3" class="lg lh hh kl b fi lm lj l lk ll">  result.then(<br/>    r =&gt; console.log(r)         // 40<br/>  );<br/>}</span></pre><p id="0f91" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">有了承诺，就用<code class="du ki kj kk kl b">.then()</code>代替<code class="du ki kj kk kl b">.chain()</code>，但是<em class="iy">几乎</em>一样的东西。</p><p id="6f8e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">你可能听说过承诺严格来说不是单子。这是因为，只有当价值一开始就是一个承诺时，它才会打开外在的承诺。否则，<code class="du ki kj kk kl b">.then()</code>的行为类似于<code class="du ki kj kk kl b">.map()</code>。</p><p id="7180" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是因为它对于承诺值和其他值的表现不同，<code class="du ki kj kk kl b">.then()</code>并不严格遵守所有函子和/或单子对于所有给定值必须满足的所有数学定律。在实践中，只要你意识到了行为分支，你通常可以把它们当作两者之一。请注意，一些通用的合成工具可能不会像承诺的那样工作。</p><h1 id="b886" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">建筑单体(又名Kleisli)组成</h1><p id="2dae" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">让我们更深入地看看我们用来构建承诺提升函数的<code class="du ki kj kk kl b">composeM</code>函数:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="f13b" class="lg lh hh kl b fi li lj l lk ll">const composeM = method =&gt; (...ms) =&gt; (<br/>  ms.reduce((f, g) =&gt; x =&gt; g(x)[method](f))<br/>);</span></pre><p id="ee0b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">隐藏在那个怪异的reducer里的是函数合成的代数定义:<code class="du ki kj kk kl b">f(g(x))</code>。让我们更容易发现:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="7c58" class="lg lh hh kl b fi li lj l lk ll">{<br/>  // The algebraic definition of function composition:<br/>  // (f ∘ g)(x) = f(g(x))<br/>  const compose = (f, g) =&gt; x =&gt; f(g(x));</span><span id="0086" class="lg lh hh kl b fi lm lj l lk ll">  const x = 20;    // The value<br/>  const arr = [x]; // The container</span><span id="6e0f" class="lg lh hh kl b fi lm lj l lk ll">  // Some functions to compose<br/>  const g = n =&gt; n + 1;<br/>  const f = n =&gt; n * 2;</span><span id="2d52" class="lg lh hh kl b fi lm lj l lk ll">  // Proof that .map() accomplishes function composition.<br/>  // Chaining calls to map is function composition.<br/>  trace('map composes')([<br/>    arr.map(g).map(f),<br/>    arr.map(compose(f, g))<br/>  ]);<br/>  // =&gt; [42], [42]<br/>}</span></pre><p id="36c7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这意味着我们可以编写一个通用的compose实用程序，它应该适用于所有提供<code class="du ki kj kk kl b">.map()</code>方法的函子(例如，数组):</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="5d6b" class="lg lh hh kl b fi li lj l lk ll">const composeMap = (...ms) =&gt; (<br/>  ms.reduce((f, g) =&gt; x =&gt; g(x).map(f))<br/>);</span></pre><p id="323a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这只是标准<code class="du ki kj kk kl b">f(g(x))</code>的一个微小的变化。给定任意数量的类型为<code class="du ki kj kk kl b">a -&gt; Functor(b)</code>的函数，遍历每个函数，并将每个函数应用于其输入值<code class="du ki kj kk kl b">x</code>。<code class="du ki kj kk kl b">.reduce()</code>方法采用一个带有两个输入值的函数:一个累加器(本例中为<code class="du ki kj kk kl b">f</code>)和数组中的当前项(<code class="du ki kj kk kl b">g</code>)。</p><p id="662f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们返回一个新函数<code class="du ki kj kk kl b">x =&gt; g(x).map(f)</code>，它在下一个应用程序中变成了<code class="du ki kj kk kl b">f</code>。上面我们已经证明了<code class="du ki kj kk kl b">x =&gt; g(x).map(f)</code>等价于将<code class="du ki kj kk kl b">compose(f, g)(x)</code>提升到函子的上下文中。换句话说，这相当于将<code class="du ki kj kk kl b">f(g(x))</code>应用于容器中的值:在这种情况下，这将组合应用于数组内部的值。</p><blockquote class="it iu iv"><p id="1ab6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">性能警告:我不建议对数组这样做。以这种方式组合函数需要对整个数组(可能包含成千上万的项)进行多次迭代。对于数组上的映射，首先构建简单的<code class="du ki kj kk kl b">a -&gt; b</code>函数，然后在数组上映射一次，或者用<code class="du ki kj kk kl b">.reduce()</code>或传感器优化迭代。</p></blockquote><p id="734f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">对于基于数组数据的同步、急切的函数应用程序来说，这是多余的。然而，许多事情是异步的或懒惰的，许多函数需要处理混乱的事情，比如异常或空值的分支。</p><p id="a0fa" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这就是单子出现的原因。单子可以依赖于值，这些值依赖于组合链中以前的异步或分支动作。在这些情况下，你不能从简单的函数组合中得到一个简单的值。你的单子返回动作以<code class="du ki kj kk kl b">a =&gt; Monad(b)</code>的形式出现，而不是<code class="du ki kj kk kl b">a =&gt; b</code>。</p><p id="12bb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">每当你有一个函数获取一些数据，点击一个API，并返回一个相应的值，而另一个函数获取该数据，点击另一个API，并返回对该数据的计算结果时，你会想要组合类型为<code class="du ki kj kk kl b">a =&gt; Monad(b)</code>的函数。因为API调用是异步的，所以您需要将返回值包装在某种东西中，比如promise或observable。换句话说，这些函数的签名分别是<code class="du ki kj kk kl b">a -&gt; Monad(b)</code>和<code class="du ki kj kk kl b">b -&gt; Monad(c)</code>。</p><p id="7603" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">组合<code class="du ki kj kk kl b">g: a -&gt; b</code>、<code class="du ki kj kk kl b">f: b -&gt; c</code>类型的函数很容易，因为这些类型排成一行:<code class="du ki kj kk kl b">h: a -&gt; c</code>就是<code class="du ki kj kk kl b">a =&gt; f(g(a))</code>。</p><p id="70c7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">组合<code class="du ki kj kk kl b">g: a -&gt; Monad(b)</code>、<code class="du ki kj kk kl b">f: b -&gt; Monad(c)</code>类型的函数稍微难一点:<code class="du ki kj kk kl b">h: a -&gt; Monad(c)</code>不仅仅是<code class="du ki kj kk kl b">a =&gt; f(g(a))</code>，因为<code class="du ki kj kk kl b">f</code>期待的是<code class="du ki kj kk kl b">b</code>，而不是<code class="du ki kj kk kl b">Monad(b)</code>。</p><p id="ccf0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">让我们更具体地构建一对异步函数，每个函数返回一个承诺:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="64c9" class="lg lh hh kl b fi li lj l lk ll">{<br/>  const label = 'Promise composition';</span><span id="6049" class="lg lh hh kl b fi lm lj l lk ll">  const g = n =&gt; Promise.resolve(n + 1);<br/>  const f = n =&gt; Promise.resolve(n * 2);</span><span id="dcf2" class="lg lh hh kl b fi lm lj l lk ll">  const h = composePromises(f, g);</span><span id="a02e" class="lg lh hh kl b fi lm lj l lk ll">  h(20)<br/>    .then(trace(label))<br/>  ;<br/>  // Promise composition: 42<br/>}</span></pre><p id="1e05" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们如何编写<code class="du ki kj kk kl b">composePromises()</code>以便正确记录结果？提示:你已经看过了。</p><p id="9da4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">还记得我们的<code class="du ki kj kk kl b">composeMap()</code>功能吗？你所需要做的就是把电话从<code class="du ki kj kk kl b">.map()</code>改成<code class="du ki kj kk kl b">.then()</code>。<code class="du ki kj kk kl b">Promise.then()</code>基本上是异步的<code class="du ki kj kk kl b">.map()</code>。</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="761a" class="lg lh hh kl b fi li lj l lk ll">{<br/>  const composePromises = (...ms) =&gt; (<br/>    ms.reduce((f, g) =&gt; x =&gt; g(x).then(f))<br/>  );</span><span id="dedb" class="lg lh hh kl b fi lm lj l lk ll">  const label = 'Promise composition';</span><span id="c093" class="lg lh hh kl b fi lm lj l lk ll">  const g = n =&gt; Promise.resolve(n + 1);<br/>  const f = n =&gt; Promise.resolve(n * 2);</span><span id="e161" class="lg lh hh kl b fi lm lj l lk ll">  const h = composePromises(f, g);</span><span id="9154" class="lg lh hh kl b fi lm lj l lk ll">  h(20)<br/>    .then(trace(label))<br/>  ;<br/>  // Promise composition: 42<br/>}</span></pre><p id="4e74" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">奇怪的是，当你点击第二个函数<code class="du ki kj kk kl b">f</code>(记住， <code class="du ki kj kk kl b">g</code>后的<code class="du ki kj kk kl b">f</code>)时，输入的值是一个承诺。不是<code class="du ki kj kk kl b">b</code>型，是<code class="du ki kj kk kl b">Promise(b)</code>型，但是<code class="du ki kj kk kl b">f</code>带<code class="du ki kj kk kl b">b</code>型，没包装。这是怎么回事？</p><p id="c5ac" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在<code class="du ki kj kk kl b">.then()</code>内部，有一个从<code class="du ki kj kk kl b">Promise(b) -&gt; b</code>开始的解包过程。该操作被称为<code class="du ki kj kk kl b">join</code>或<code class="du ki kj kk kl b">flatten</code>。</p><p id="5b84" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">你可能已经注意到<code class="du ki kj kk kl b">composeMap()</code>和<code class="du ki kj kk kl b">composePromises()</code>几乎是相同的功能。这是可以处理这两种情况的高阶函数的完美用例。让我们将chain方法混合到一个curried函数中，然后使用方括号符号:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="4054" class="lg lh hh kl b fi li lj l lk ll">const composeM = method =&gt; (...ms) =&gt; (<br/>  ms.reduce((f, g) =&gt; x =&gt; g(x)[method](f))<br/>);</span></pre><p id="d8d4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在，我们可以像这样编写专门的实现:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="c77d" class="lg lh hh kl b fi li lj l lk ll">const composePromises = composeM('then');<br/>const composeMap = composeM('map');<br/>const composeFlatMap = composeM('flatMap');</span></pre><h1 id="12ff" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">单子定律</h1><p id="b7ea" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">在你开始构建你自己的单子之前，你需要知道所有单子都应该满足三个定律:</p><ol class=""><li id="2eb5" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju mp kf kg kh bi translated">左侧标识:<code class="du ki kj kk kl b">unit(x).chain(f) ==== f(x)</code></li><li id="b27f" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju mp kf kg kh bi translated">权利身份:<code class="du ki kj kk kl b">m.chain(unit) ==== m</code></li><li id="9198" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju mp kf kg kh bi translated">关联性:<code class="du ki kj kk kl b">m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g))</code></li></ol><h1 id="e687" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">身份法则</h1><figure class="ky kz la lb fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/c3d37f1c0a0098a630466f150c7efa5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*X_bUJJYudP8MlhN0FLEGKg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Left and right identity</figcaption></figure><p id="5402" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子是函子。函子是范畴之间的态射，<code class="du ki kj kk kl b">A -&gt; B</code>。态射由箭头表示。除了我们在对象之间明确看到的箭头之外，类别中的每个对象也有一个指向自身的箭头。换句话说，对于类别中的每个对象<code class="du ki kj kk kl b">X</code>，都存在一个箭头<code class="du ki kj kk kl b">X -&gt; X</code>。这个箭头被称为身份箭头，它通常被绘制成一个小的圆形箭头，从一个对象指向另一个对象。</p><figure class="ky kz la lb fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/23e8fe5c68fa1a464e1d494620660a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*3jcLj7wdwWaUJ22X2iT7OA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Identity morphisms</figcaption></figure><h1 id="ca90" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结合性</h1><p id="f2cc" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">结合律只是意味着当我们组合时，括号放在哪里并不重要。例如，如果您正在添加，<code class="du ki kj kk kl b">a + (b + c)</code>与<code class="du ki kj kk kl b">(a + b) + c</code>相同。函数组合也是如此:<code class="du ki kj kk kl b">(f ∘ g) ∘ h = f ∘ (g ∘ h)</code>。</p><p id="eefa" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">克莱斯利作文也是如此。你只需要倒着读。当你看到复合运算符(<code class="du ki kj kk kl b">chain</code>)时，想想<code class="du ki kj kk kl b">after</code>:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="3c98" class="lg lh hh kl b fi li lj l lk ll">h(x).chain(x =&gt; g(x).chain(f)) ==== (h(x).chain(g)).chain(f)</span></pre><h1 id="3a36" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">证明单子定律</h1><p id="84f0" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">让我们证明单位单子满足单子定律:</p><pre class="ky kz la lb fd lc kl ld le aw lf bi"><span id="1d3a" class="lg lh hh kl b fi li lj l lk ll">{ // Identity monad<br/>  const Id = value =&gt; ({<br/>    // Functor mapping<br/>    // Preserve the wrapping for .map() by <br/>    // passing the mapped value into the type<br/>    // lift:<br/>    map: f =&gt; Id.of(f(value)),</span><span id="49ba" class="lg lh hh kl b fi lm lj l lk ll">    // Monad chaining<br/>    // Discard one level of wrapping<br/>    // by omitting the .of() type lift:<br/>    chain: f =&gt; f(value),</span><span id="8bac" class="lg lh hh kl b fi lm lj l lk ll">    // Just a convenient way to inspect<br/>    // the values:<br/>    toString: () =&gt; `Id(${ value })`<br/>  });</span><span id="bb2c" class="lg lh hh kl b fi lm lj l lk ll">  // The type lift for this monad is just<br/>  // a reference to the factory.<br/>  Id.of = Id;</span><span id="fbdd" class="lg lh hh kl b fi lm lj l lk ll">  const g = n =&gt; Id(n + 1);<br/>  const f = n =&gt; Id(n * 2);</span><span id="b039" class="lg lh hh kl b fi lm lj l lk ll">  // Left identity<br/>  // unit(x).chain(f) ==== f(x)<br/>  trace('Id monad left identity')([<br/>    Id(x).chain(f),<br/>    f(x)<br/>  ]);<br/>  // Id monad left identity: Id(40), Id(40)<br/></span><span id="9f9c" class="lg lh hh kl b fi lm lj l lk ll">  // Right identity<br/>  // m.chain(unit) ==== m<br/>  trace('Id monad right identity')([<br/>    Id(x).chain(Id.of),<br/>    Id(x)<br/>  ]);<br/>  // Id monad right identity: Id(20), Id(20)</span><span id="0870" class="lg lh hh kl b fi lm lj l lk ll">  // Associativity<br/>  // m.chain(f).chain(g) ====<br/>  // m.chain(x =&gt; f(x).chain(g)  <br/>  trace('Id monad associativity')([<br/>    Id(x).chain(g).chain(f),<br/>    Id(x).chain(x =&gt; g(x).chain(f))<br/>  ]);<br/>  // Id monad associativity: Id(42), Id(42)<br/>}</span></pre><h1 id="cae8" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="5bea" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">单子是一种组合类型提升函数的方式:<code class="du ki kj kk kl b">g: a =&gt; M(b)</code>，<code class="du ki kj kk kl b">f: b =&gt; M(c)</code>。为此，单子必须在应用<code class="du ki kj kk kl b">f()</code>之前将<code class="du ki kj kk kl b">M(b)</code>展平为<code class="du ki kj kk kl b">b</code>。换句话说，函子是可以映射的东西。单子是可以平面映射的东西:</p><ul class=""><li id="023a" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">功能图:<code class="du ki kj kk kl b">a =&gt; b</code></li><li id="5b42" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">带上下文的仿函数映射:<code class="du ki kj kk kl b">Functor(a) =&gt; Functor(b)</code></li><li id="2b88" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">单子展平并与上下文映射:<code class="du ki kj kk kl b">Monad(Monad(a)) =&gt; Monad(b)</code></li></ul><p id="19d4" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子基于一种简单的对称——一种将值包装到上下文中的方法，以及一种从上下文中解开值的方法:</p><ul class=""><li id="1aec" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">Lift/Unit:从某个类型到单子上下文的类型提升:<code class="du ki kj kk kl b">a =&gt; M(a)</code></li><li id="7b5c" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">拼合/连接:从上下文中展开类型:<code class="du ki kj kk kl b">M(a) =&gt; a</code></li></ul><p id="7f7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">由于单子也是函子，它们也可以映射:</p><ul class=""><li id="ca4a" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">地图:保留上下文的地图:<code class="du ki kj kk kl b">M(a) -&gt; M(b)</code></li></ul><p id="d3d8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">将flatten与map结合起来，您可以获得提升函数的链式函数合成，也称为Kleisli合成:</p><ul class=""><li id="4da2" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">平面贴图/链平面+贴图:<code class="du ki kj kk kl b">M(M(a)) =&gt; M(b)</code></li></ul><p id="edeb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">单子必须满足三个定律(公理)，统称为单子定律:</p><ul class=""><li id="5066" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">左身份:<code class="du ki kj kk kl b">unit(x).chain(f) ==== f(x)</code></li><li id="227a" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">权利身份:<code class="du ki kj kk kl b">m.chain(unit) ==== m</code></li><li id="fffb" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">关联性:<code class="du ki kj kk kl b">m.chain(f).chain(g) ==== m.chain(x =&gt; f(x).chain(g)</code></li></ul><p id="37cb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">您可能在每天的JavaScript代码中遇到的单子的例子包括承诺和可观察到的。Kleisli composition允许您编写数据流逻辑，而不用担心数据类型API的细节，也不用担心可能的副作用、条件分支或隐藏在<code class="du ki kj kk kl b">chain()</code>操作中的展开计算的其他细节。</p><p id="bf60" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这使得monads成为简化代码的一个非常强大的工具。您不必了解或担心单子内部发生了什么来获得单子可以提供的简化好处，但是现在您对引擎盖下的东西有了更多的了解，窥视引擎盖下的东西并不是一件可怕的事情。</p><p id="02be" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">没必要害怕莫纳德格林夫人的诅咒。</p><h1 id="b5bb" class="ln lh hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">通过实时1:1辅导提升您的技能</h1><p id="2db8" class="pw-post-body-paragraph iw ix hh iz b ja mk jc jd je ml jg jh jw mm jk jl jx mn jo jp jy mo js jt ju ha bi translated">DevAnywhere是达到高级JavaScript技能的最快方法:</p><ul class=""><li id="5aa2" class="jz ka hh iz b ja jb je jf jw kb jx kc jy kd ju ke kf kg kh bi translated">现场课程</li><li id="58c2" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">弹性工时</li><li id="b984" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">一对一指导</li><li id="cdc0" class="jz ka hh iz b ja km je kn jw ko jx kp jy kq ju ke kf kg kh bi translated">构建真正的生产应用</li></ul><figure class="ky kz la lb fd ii er es paragraph-image"><a href="https://devanywhere.io/"><div class="er es ms"><img src="../Images/03504ae5b049cdb99861a7b575be3a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pskrI-ZjRX_Y0I0zZqVTcQ.png"/></div></a><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae jv" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank">https://devanywhere.io/</a></figcaption></figure></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><p id="0ff9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">是</em> <a class="ae jv" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【编程JavaScript应用】</em> </a> <em class="iy"> (O'Reilly)的作者，也是</em><a class="ae jv" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人。他为Adobe Systems</em><strong class="iz hi"><em class="iy"/></strong><em class="iy"/><strong class="iz hi"><em class="iy">尊巴健身</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">华尔街日报</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC</em></strong><em class="iy">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他和世界上最美丽的女人一起在任何他想去的地方工作。</p></div></div>    
</body>
</html>