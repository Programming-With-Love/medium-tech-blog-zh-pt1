<html>
<head>
<title>Web-service modulari con GO Plug-in</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模块化Web服务与GO Plug-in</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/web-service-modulari-con-go-plug-in-7f59d4b15d61?source=collection_archive---------0-----------------------#2019-02-26">https://medium.com/quick-code/web-service-modulari-con-go-plug-in-7f59d4b15d61?source=collection_archive---------0-----------------------#2019-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/a23a9cd93f9333cba5a5786078f741f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UJuWDUpw8Pcv0qGz7wZv0A.jpeg"/></div></figure><div class=""/><p id="ccc7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" rel="noopener" href="/quick-code/write-a-web-service-with-go-plug-ins-c0472e0645e6"><em class="jk">英文版!(T2) (T3)</em></a></p><p id="7039" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本文的目的是检查为什么以及如何创建一个模块化的Web服务。</p><p id="2826" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在自动化驱动的环境中,有许多条件导致项目发展完全混乱,我遇到的一个原因是服务模块化程度低。</p><p id="bb3b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当您使用编译语言时,即使在微服务架构中,您也会遇到导致源代码重新编译的情况。其中包括修改项目单个部分的行为或优化终端节点的规模。</p><p id="e564" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">此外,一些主题不可避免地变得“不舒服”:</p><ul class=""><li id="961d" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">在多个服务中重用一个功能并不容易。</li><li id="e647" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">您可能只能使用一种编程语言。</li><li id="ec04" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">如果你有一个团队,你必须分享整个项目的源代码(这对于离岸项目来说是非常敏感的)。</li></ul><p id="7da3" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用插件架构,您可以将服务开发为一组组件,使您能够:</p><ul class=""><li id="1f23" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">有功能性的团队,只处理一个给定的范围。</li><li id="e928" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">独立分发组件(这也允许滚动更新策略)。</li><li id="e06c" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">在不同的项目中重复使用组件。</li><li id="40b1" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">通过配置要包含的组件自定义服务在扩展时的行为。</li><li id="2ac8" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">最后但并非最不重要的是,您可以使用编译库的任何语言开发组件(大多数语言都不是偶然的)!</li></ul></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="69f6" class="kg kh ho bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Architecture 项目</h1><p id="8d5e" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">从Web服务的解剖分析开始,我们可以将我们的项目分为以下组件:</p><ul class=""><li id="73e7" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">核心:核心部分将负责读取配置,加载插件,并管理HTTP服务。</li><li id="bad4" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">控制器:生成要返回给客户端的内容的函数。</li><li id="3371" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">中间件:控制请求是否被授权访问控制器的组件。</li></ul><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lj"><img src="../Images/8181e7489b31fbd36e88d3ababb40c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1d_Xc0oiZbgYTMbIv8SwTg.png"/></div></div></figure><p id="0e36" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这样,如果我们想通过插入HTTPS来更新我们的项目,我们只能重新分发与核心相关的文件(包含http通信处理)和<em class="jk">只用于需要此功能的服务!</em>同样,如果我们需要修改 JWT 插件的 ash 算法,我们可以重新分发插件并重新启动内核。</p><h1 id="fe6b" class="kg kh ho bd ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz lw lb lc ld bi translated">Architecture 组件</h1><h2 id="d2a4" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">控制器</h2><p id="6bb0" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">控制器是一个“HTTP处理程序函数”,它将逻辑应用于请求并返回给客户端的响应。</p><h2 id="b30d" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">中间人 Middlewares</h2><p id="e6fe" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">这种类型的对象源于需要在启动整个管理机制之前对请求应用过滤器或操作,从而避免不必要的服务器负载。</p><p id="e61a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">中间件的一个例子是 IP 过滤器:只允许特定的 IP 访问服务。当从服务器接收信息时,您可以直接检查源IP是否是白名单中可接受的IP之一。这样就不会加载其他组件,从而缩短响应时间,从而提高服务性能。</p><p id="53d1" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">另一个好处是降低了在恶意行为发生时暴露数据的风险。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ml"><img src="../Images/804910bd11ffb671a2b00bd515de72b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vo-RnVKZu3_4vlVGReUqg.png"/></div></div></figure><p id="5cad" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">中间件的另一个例子是控制请求的access header。通过将后者与前一个 IP 过滤器连接起来,只有经过授权且来自配置的 IP 之一的用户才能访问该服务。</p><p id="99c8" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此,如果响应函数(控制器)的第一步是对DB进行查询以检索用户数据,则这些过滤器可以通过避免SQL注入来提高安全性,因为除非检查中间件中所有先前声明的条件,否则甚至不会初始化与数据库的通信。</p><h2 id="9b07" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">核心</h2><p id="2f9a" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">如前所述,在这个项目中,我们将使用<a class="ae jj" href="https://golang.org/pkg/plugin/" rel="noopener ugc nofollow" target="_blank">插件</a>的功能来分离组件。为此,核心组件将加载Controllers和Middlewares插件,通过配置文件将它们分配给不同的端点,并最终启动HTTP侦听器。</p><p id="56bc" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">配置中的所有其他未映射的路由将返回“404 not found”。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mm"><img src="../Images/f51130101f398bd818e527160d8581fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AP7etBWgIvojKOBmyekj1Q.png"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx">Mapping middlewares and controller to an endpoint</figcaption></figure><p id="1fe5" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种独立性在云环境中特别受欢迎:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mr"><img src="../Images/0b06249f24fa7d5d93f2b9aa2d6d1220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BK_xZldGL7_fnuZZvA2t9g.png"/></div></div></figure></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="87b9" class="kg kh ho bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实施</h1><p id="8500" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">现在我们开始编写代码,我们将从基本的<em class="jk">核心</em>组件和一个<em class="jk">控制器(HTTP函数处理程序)开始,它将响应我们的主页:</em></p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="0db9" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们添加实现中间件所需的构造:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">The middleware type</figcaption></figure><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">…and a Chain function that provide a mechanism to concatenate middlewares</figcaption></figure><p id="7903" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们构建一个示例中间件:方法中间件将检查请求的HTTP方法是否是允许的中间件之一。否则返回 400 Bad Request。</p><p id="770b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将传递一系列参数,在这种情况下,它们将是可接受的HTTP方法序列,以“pipe”(“|”)字符分隔:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="cd20" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后我们绑定中间件(将其插入到Chain对象中),并传递我们希望允许的HTTP方法。</p><p id="b078" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来,我们将把 Chain 对象传递给 HandlerFunc 这个简单的 HTTP 服务:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="997d" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" href="https://github.com/Bebbolus/gomiddleware" rel="noopener ugc nofollow" target="_blank">所有的示例代码都在这里</a></p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="d528" class="kg kh ho bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Plugins</h1><blockquote class="mu"><p id="3de8" class="mv mw ho bd mx my mz na nb nc nd ji dx translated">注:此功能目前仅适用于 Linux,但您可以将容器用作 workaround。</p></blockquote><p id="d47d" class="pw-post-body-paragraph il im ho in b io ne iq ir is nf iu iv iw ng iy iz ja nh jc jd je ni jg jh ji ha bi translated">插件包必须是“Main”。不幸的是,<em class="jk"> package 不能访问 package principle 的实体,例如“真实” main package 中的 type 和 function。因此,我建议尽可能保持“愚蠢”的插件(T9) 。</em></p><p id="be32" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在插件中,我们需要将符号导出到一个变量或函数,该变量或函数将在加载插件本身的模块中用作引用:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="d2aa" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要构建插件,我们需要使用 -buildmode=plugin 标志并指定我们想要生成的文件的名称。</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="fe34" class="lx kh ho nk b fi no np l nq nr">$go build -buildmode=plugin -o first.so first.go</span></pre><blockquote class="mu"><p id="064c" class="mv mw ho bd mx my ns nt nu nv nw ji dx translated">你已经建立了你的第一个插件!</p></blockquote><p id="f446" class="pw-post-body-paragraph il im ho in b io ne iq ir is nf iu iv iw ng iy iz ja nh jc jd je ni jg jh ji ha bi translated">检查文件夹,你会发现first.so文件是一个<strong class="in hp">标准库,你可以导入到支持此功能的语言!(T6 )</strong></p><p id="d086" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们在GO中使用它:</p><p id="f409" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们创建一个新的 main.go 文件并加载新创建的库:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="dafd" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们添加代码以在库中查找符号:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="f850" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们可以在“main.go”中使用插件函数:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="f13f" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Run!</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="73f8" class="lx kh ho nk b fi no np l nq nr">$ go run main.go</span></pre><p id="5ebd" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果一切顺利,你会看到:</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="47f5" class="lx kh ho nk b fi no np l nq nr">Hello FROM PLUGIN!!!</span></pre><p id="d97f" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" href="https://github.com/Bebbolus/gomiddleware" rel="noopener ugc nofollow" target="_blank">这里的源代码</a></p><p id="0c02" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在,我们使用GO“Oop风格”开发项目,以便从插件中获取更多单个功能。</p><p id="f5fd" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们用一个类型修改 first.go 插件,通过它我们可以攻击方法。最后,我们将变量导出为类型对象的引用符号:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="86ab" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在,我们需要在main.go中将导入更改为更安全的菜单:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="3bd0" class="kg kh ho bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Plugins 的实施</h1><p id="99cd" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">在这一点上,你知道:</p><ul class=""><li id="4817" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">项目的目标是什么</li><li id="136f" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">我们希望在建筑层面上实现什么</li><li id="a863" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">什么是各种组件:核心,控制器,中间件</li><li id="dcf9" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">如何创建和使用plugin</li></ul><p id="caf4" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们准备创建“控制器”插件!</p><p id="0790" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在 repository 中,我们为 plugin 创建一个文件夹:</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="6e66" class="lx kh ho nk b fi no np l nq nr">$mkdir plugins</span></pre><p id="d833" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在里面,我们再创建两个文件夹,一个用于中间件,一个用于控制器。</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="15cb" class="lx kh ho nk b fi no np l nq nr">$cd plugins<br/>$mkdir controller<br/>$mkdir middlewares</span></pre><h2 id="f842" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">创建 Controller</h2><p id="8c5f" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">在 <code class="du nx ny nz nk b">plugins/controllers</code> 文件夹中,我们创建 <code class="du nx ny nz nk b">general.go</code>:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="03c1" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">创建 Middleware</h2><p id="3288" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">现在,我们将先前创建的方法中间件导出到插件中。</p><p id="b5c4" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在 <code class="du nx ny nz nk b">plugins/middlewares</code> 下,我们创建 <code class="du nx ny nz nk b">method.so</code>:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="6442" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">建立plugin:</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="a934" class="lx kh ho nk b fi no np l nq nr">$go build -buildmode=plugin -o plugins/middlewares/method.so plugins/middlewares/method.go</span><span id="7e27" class="lx kh ho nk b fi oa np l nq nr">$go build -buildmode=plugin -o plugins/controllers/genearal.so plugins/controllers/genearal.go</span></pre></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="c138" class="kg kh ho bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">进口 Plugin</h1><p id="5406" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">要导入插件,我们需要从配置文件中加载它们,以便将中间件和控制器映射到配置的路由。</p><p id="6912" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">文件<code class="du nx ny nz nk b">routes.json</code>应该看起来像这样:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="e4dd" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">通过以这种方式创建文件,我们可以将多个中间件附加到一条路径上,并在多个路径上使用一个中间件。</p><h2 id="e15c" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">阅读 Configurations</h2><p id="78bc" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">现在,我们可以从文件中读取配置并将它们映射到结构(我发现使用这个<a class="ae jj" href="https://mholt.github.io/json-to-go/" rel="noopener ugc nofollow" target="_blank">工具</a>将源json转换为结构):</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="a7b1" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们编写一个函数来读取JSON:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="e87c" class="lx kh ho bd ki ly lz ma km mb mc md kq iw me mf ku ja mg mh ky je mi mj lc mk bi translated">加载 Plugins</h2><p id="ad20" class="pw-post-body-paragraph il im ho in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">由于我们将从内核中调用导出到库文件(插件)的类型,我们将不得不采用一些约定,我选择了以下约定:</p><ul class=""><li id="affb" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">控制器有 Fire() 方法。</li><li id="5251" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">中间件有 Pass() 方法。</li></ul><p id="c71d" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">通过滚动配置,我们可以动态链接库:</p><blockquote class="ob oc od"><p id="acc9" class="il im jk in b io ip iq ir is it iu iv oe ix iy iz of jb jc jd og jf jg jh ji ha bi translated">From “plugin.Open” documentation: If a path has been opened, then the existing *Plugin is return it is safe for concurrent use by multiple goroutines. 如果路径已经被打开,那么现存的 *plugin 就返回了。</p></blockquote><p id="21a7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下载 Controller Plugin:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="3308" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们加载要附加到路线的中间件:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="7bfd" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们可以组装所有东西并启动我们的Web服务。</p><pre class="lk ll lm ln fd nj nk nl nm aw nn bi"><span id="0d53" class="lx kh ho nk b fi no np l nq nr">$go build -o start -v</span></pre><p id="5ed2" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您可以在这里看到完整的仓库<a class="ae jj" href="https://github.com/Bebbolus/gostron" rel="noopener ugc nofollow" target="_blank">以及其他一些功能:</a></p><ul class=""><li id="5273" class="jl jm ho in b io ip is it iw jn ja jo je jp ji jq jr js jt bi translated">脚本创建一个plugin的骨架</li><li id="9cce" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">makefile 用于构建和/或清理所有内容</li><li id="b2e2" class="jl jm ho in b io ju is jv iw jw ja jx je jy ji jq jr js jt bi translated">测试标准实施。</li></ul></div></div>    
</body>
</html>