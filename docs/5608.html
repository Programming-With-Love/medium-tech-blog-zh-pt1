<html>
<head>
<title>Oracle’s native JSON support not only for storing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle的原生JSON支持不仅用于存储</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracles-native-json-support-not-only-for-storing-dcab8c047b52?source=collection_archive---------2-----------------------#2019-05-06">https://medium.com/oracledevs/oracles-native-json-support-not-only-for-storing-dcab8c047b52?source=collection_archive---------2-----------------------#2019-05-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/eddffd0c8cb0c154556a76e3734ccf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*VoxyUx84YbJbZMvMonrvgw.png"/></div></figure><p id="4cae" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当你想到数据库中的<strong class="in hi"> <em class="jj"> JSON </em> </strong>时，你可能会考虑存储、查询和操作你的数据，有一篇由<a class="ae jk" href="https://blogs.oracle.com/author/chris-saxon" rel="noopener ugc nofollow" target="_blank"> Chris Saxon </a>撰写的关于<a class="ae jk" href="https://blogs.oracle.com/sql/how-to-store-query-and-create-json-documents-in-oracle-database" rel="noopener ugc nofollow" target="_blank">如何在Oracle数据库</a>中存储、查询和创建JSON文档的博客文章，但是JSON支持打开一个窗口来与外部资源对话，如<a class="ae jk" href="https://lucene.apache.org/solr/" rel="noopener ugc nofollow" target="_blank"> Apache Solr </a>或<a class="ae jk" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"> ElasticSearch </a>，它们也是JSON原生的。</p><p id="1d4c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了说明我们将向<a class="ae jk" href="https://github.com/scotas/pc/wiki/Scotas-Push-Connector" rel="noopener ugc nofollow" target="_blank">介绍开源的Scotas Push连接器</a>，该连接器可从<a class="ae jk" href="https://github.com/scotas/pc" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。该产品的大图如下所示:</p><figure class="jm jn jo jp fd ii er es paragraph-image"><div class="er es jl"><img src="../Images/dc0816a56e337e10b475bc5d4df919c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*UKNPN54BF8k3tJxyOS_wCg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Push Connector Architecture</figcaption></figure><p id="d03e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它使用Oracle Index Extensible API(<a class="ae jk" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/addci/introduction-to-data-cartridges.html#GUID-2B30E30F-D8A3-4B1D-A3FE-49DE7472A528" rel="noopener ugc nofollow" target="_blank">ODCI</a>)来提供一个新的域索引，该索引使用Apache Solr的外部实例来索引您的表。例如，如果您有一个表，如下所示:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="3be5" class="jz ka hh jv b fi kb kc l kd ke">CREATE TABLE OLS_TUTORIAL (<br/>  ID VARCHAR2(30) PRIMARY KEY,<br/>  NAME VARCHAR2(400),<br/>  MANU VARCHAR2(4000),<br/>  CAT  VARCHAR2(400),<br/>  FEATURES CLOB,<br/>  INCLUDES VARCHAR2(4000),<br/>  WEIGHT   NUMBER,<br/>  PRICE    NUMBER,<br/>  POPULARITY NUMBER,<br/>  INSTOCK    CHAR(5), -- true or false<br/>  MANUFACTUREDATE_DT TIMESTAMP,<br/>  PAYLOADS   VARCHAR2(4000),<br/>  STORE   VARCHAR2(200));</span></pre><p id="3f9e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有这样的行:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="ea0f" class="jz ka hh jv b fi kb kc l kd ke">insert into ols_tutorial values (<br/>  'SP2514N',<br/>  'Samsung SpinPoint P120 SP2514N - hard drive - 250 GB - ATA-133',<br/>  'Samsung Electronics Co. Ltd.',<br/>  '["electronics", "hard-drive"]',<br/>  '7200RPM, 8MB cache, IDE Ultra ATA-133 NoiseGuard, SilentSeek technology, Fluid Dynamic Bearing (FDB) motor',<br/>  NULL,<br/>  NULL,<br/>  92,<br/>  6,<br/>  'true',<br/>  TO_TIMESTAMP('2006-02-13T15:26:37Z','YYYY-MM-DD"T"HH24:MI:SS"Z"'),<br/>  NULL,<br/>  '35.0752,-97.032');</span></pre><p id="6fa1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用Push Connector和Apache Solr 8的索引如下所示:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="66c1" class="jz ka hh jv b fi kb kc l kd ke">CREATE INDEX TUTORIAL_PIDX ON <strong class="jv hi"><em class="jj">OLS_TUTORIAL</em></strong>(ID) INDEXTYPE IS PC.SOLR PARAMETERS('{NormalizeScore:true,<br/>  LogLevel:"INFO",<br/>  Updater:"solr@8983",<br/>  Searcher:"solr@8983",<br/>  SolrBase:"solr/tutorial",<br/>  CommitOnSync:true,<br/>  SyncMode:"OnLine",<br/>  BatchCount:5,<br/>  LockMasterTable:false,<br/>  IncludeMasterColumn:false,<br/>  HighlightColumn:"name,features",<br/>  MltColumn:"name",<br/>  DefaultColumn:"_text_",<br/>  ExtraCols:"''id'' value id, ''cat'' value cat FORMAT JSON, ''name'' value name, ''features'' value features, ''manu'' value manu, ''includes'' value includes, ''price_f'' value price, ''popularity_i'' value popularity, ''inStock_b'' value trim(inStock) FORMAT JSON, ''manufacturedate_dt'' value manufacturedate_dt, ''store_p'' value store"}');</span></pre><p id="2c5b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，使用这个新的域索引的查询很简单:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="e408" class="jz ka hh jv b fi kb kc l kd ke">SELECT id,price FROM OLS_TUTORIAL WHERE <strong class="jv hi"><em class="jj">SCONTAINS</em></strong>(ID,'video AND price_f:[* TO 400]')&gt;0</span></pre><p id="5c0b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，不仅表的ID列被索引，cat、name、features等也被索引。也被索引到Apache Solr中，然后在<strong class="in hi"> <em class="jj">中可用，包含</em> </strong>运算符，在<strong class="in hi"><em class="jj">OLS _教程</em> </strong>表中的插入、更新、删除或截断操作被自动跟踪，并在外部<strong class="in hi"> <em class="jj"> Solr </em> </strong>存储中执行，使用HTTP/HTTPS和<strong class="in hi"> <em class="jj"> JSON </em> </strong>语法使用Oracle和Solr。</p><p id="78c9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是原生<strong class="in hi"> <em class="jj"> JSON </em> </strong>支持的重要性，你可以轻松地构建和解析<strong class="in hi"> <em class="jj"> JSON </em> </strong>文档来与外部源发送/接收。让我们更深入地研究一下Push连接器源代码，看看我的意思是什么。</p><p id="6c54" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里有一部分<a class="ae jk" href="https://github.com/scotas/pc/blob/master/db/SolrPushConnector-bdy.sql" rel="noopener ugc nofollow" target="_blank">SolrPushConnector-bdy . SQL</a>代码，当删除一个索引时，一个<a class="ae jk" href="https://lucene.apache.org/solr/guide/7_7/uploading-data-with-index-handlers.html" rel="noopener ugc nofollow" target="_blank"> delete by query </a>操作被发送到Solr服务器，发送这个消息的PLSQL代码是:</p><figure class="jm jn jo jp fd ii"><div class="bz dy l di"><div class="kf kg l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">ODCIIndexDrop method</figcaption></figure><p id="11a0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，我们用查询语法delete创建一个JSON对象，并使用过程<a class="ae jk" href="https://github.com/scotas/pc/blob/ca30ce47352e49eedcfc3a7b3ceb293689d4e035/db/PushConnectorAdm-bdy.sql#L160" rel="noopener ugc nofollow" target="_blank"> PushConnectorAdm发送它。CREATEREQUEST </a>，它基本上是用JSON对象作为POST方法体创建一个HTTP连接。在此调试信息。trc文件:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="1be4" class="jz ka hh jv b fi kb kc l kd ke">POST <a class="ae jk" href="http://solr:8983/solr/tutorial/update/json?wt=json&amp;ident=on" rel="noopener ugc nofollow" target="_blank">http://solr:8983/solr/tutorial/update/json?wt=json&amp;ident=on</a><br/>{<br/>  "delete":<br/>    { "query":"solridx:SCOTT.TUTORIAL_PIDX"},<br/>  "commit":<br/>    {"softCommit":"false"}<br/>}</span></pre><p id="307e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">稍微复杂一点的是索引过程(用Solr的话说就是批量索引)，这个过程是从创建索引或重建操作开始的，这段代码是:</p><figure class="jm jn jo jp fd ii"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="447e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">重建过程首先从删除Solr服务器上现有索引的所有行开始，如上例所示，然后它以两种不同的模式工作，<strong class="in hi"><em class="jj"/></strong>，基本上是将表的所有rowids排队以插入到AQ队列(<a class="ae jk" href="https://github.com/scotas/pc/blob/ca30ce47352e49eedcfc3a7b3ceb293689d4e035/db/SolrPushConnector-bdy.sql#L1262" rel="noopener ugc nofollow" target="_blank">solrpushconnector . enqueue change(' ' | | prefix | | ' '，RIDS，“insert ' ')；</a>)或在主表中批量执行全扫描查询<strong class="in hi"><em class="jj">batch count</em></strong>rows参数值，对上述索引创建语法执行的查询如下所示:</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="6a21" class="jz ka hh jv b fi kb kc l kd ke">select json_object('rowid' value ''||L$MT.rowid ,<br/>                   'solridx' value 'SCOTT.TUTORIAL_PIDX',<br/>                   'id' value id,<br/>                   'cat' value cat FORMAT JSON,<br/>                   'name' value name,<br/>                   'features' value features,<br/>                   'manu' value manu,<br/>                   'includes' value includes,<br/>                   'price_f' value price,<br/>                   'popularity_i' value popularity,<br/>                   'inStock_b' value trim(inStock) FORMAT JSON,<br/>                   'manufacturedate_dt' value manufacturedate_dt,<br/>                   'store_p' value store <br/>                   ABSENT ON NULL returning CLOB) L$MT$R<br/>    from SCOTT.OLS_TUTORIAL L$MT,SCOTT.TUTORIAL_PIDX$C C<br/>    where L$MT.rowid=C.rid</span></pre><p id="40b3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们正在查询索引的<strong class="in hi"> <em class="jj"> rowid </em> </strong>(文档id在<strong class="in hi"> <em class="jj"> Solr </em> </strong>语法中)和由<strong class="in hi"> <em class="jj"> ExtraCols </em> </strong>参数定义的其余列，所有这些都在Oracle<a class="ae jk" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/adjsn/generation.html#GUID-1084A518-A44A-4654-A796-C1DD4D8EC2AA" rel="noopener ugc nofollow" target="_blank"><strong class="in hi"><em class="jj">JSON _ object</em></strong></a>函数的语法中，最后将该表与保存批量<strong class="in hi"><em class="jj">rowid的临时表连接起来上面的查询将返回一批准备发送给<strong class="in hi"> <em class="jj"> Solr </em> </strong>的更新命令的JSON对象数据，例如:</em></strong></p><figure class="jm jn jo jp fd ii"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="75a2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">每批5行使用HTTP/HTTPS发送到Apache <strong class="in hi"> <em class="jj"> Solr </em> </strong>实例。</p><p id="a078" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">是的，听起来很复杂，但是它展示了数据库中的JSON如何打开了一个新的应用程序世界，它与<strong class="in hi"><em class="jj"/></strong>外部存储、web服务等交互。即使您使用的是PLSQL，也可以使用本指南"<a class="ae jk" href="https://github.com/scotas/pc/wiki/Installing-on-Oracle-18c-XE" rel="noopener ugc nofollow" target="_blank">Push Connector 2.0 for Oracle XE 18c</a>"随意下载这一新Oracle索引的完整代码或使用Docker试用它</p></div></div>    
</body>
</html>