<html>
<head>
<title>Goku: Building a scalable and high performant time series database system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">悟空:构建可扩展的高性能时间序列数据库系统</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/goku-building-a-scalable-and-high-performant-time-series-database-system-a8ff5758a181?source=collection_archive---------2-----------------------#2018-09-13">https://medium.com/pinterest-engineering/goku-building-a-scalable-and-high-performant-time-series-database-system-a8ff5758a181?source=collection_archive---------2-----------------------#2018-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4266" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作者:张睿|存储和缓存工程师</p><p id="a8bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">徐、合著&amp;张天英，工程师</em></p><p id="42c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，开发者依靠Statsboard来监控他们的系统并发现问题。一个可靠高效的监控系统对开发速度非常重要。过去，我们一直使用OpenTSDB来接收和提供指标数据。然而，随着Pinterest的发展，服务的数量也从数百增加到数千，每秒产生数百万个数据点，并且还在增长。</p><p id="2348" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然OpenTSDB在功能上运行良好，但随着Pinterest的增长，它的性能下降了，导致了操作开销(例如严重的GC问题和经常崩溃的HBase)。作为一个解决方案，开发了Goku——我们的内部时间序列数据库，使用C++编写的OpenTSDB兼容API，以支持高效的数据接收和昂贵的时间序列查询。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/43d334ef3577302f6fbf1ee3ca1aae78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shrxqae9FIpz27-tAtOo0Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Two-level sharding with Goku</figcaption></figure><h1 id="cc8a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">时间序列数据模型</h1><p id="9c23" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><em class="jc">时间序列数据</em></p><p id="bae5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">悟空遵循OpenTSDB的时间序列数据模型。时间序列由一个键和一系列随时间变化的数字数据点组成。key =指标名称+一组标记键值对。例如“TC . proc . stat . CPU . total . infra-Goku-a-prod { host = infra-Goku-a-prod-001，cell_id=aws-us-east-1}”。数据点=键+值。值是时间戳和值对。例如，(1525724520，174706.61)，(1525724580，173456.08)。</p><p id="e49e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">时间序列查询</em></p><p id="c244" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了开始时间和结束时间之外，每个查询还包括以下部分/全部:指标名称、过滤器、聚合器、缩减采样器、速率选项。</p><p id="b30b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1)度量名称的一个示例是“TC . proc . stat . CPU . total . infra-Goku-a-prod”。</p><p id="5ec4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2)针对标签值应用过滤器，以减少在查询或组中选取序列的次数，并在各种标签上聚集。Goku支持的过滤器示例包括:完全匹配、通配符、Or、Not or、Regex。</p><p id="840d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3)聚合器指定了将多个时间序列合并为一个时间序列的数学方法。悟空支持的聚合器的例子包括:Sum、Max/Min、Avg、Zimsum、Count、Dev。4)下采样器需要时间间隔和聚集器。聚合器用于计算指定时间间隔内所有数据点的新数据点。</p><p id="6909" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4)比率选项可选择计算变化率。详见<a class="ae kw" href="http://opentsdb.net/docs/build/html/user_guide/query/index.html" rel="noopener ugc nofollow" target="_blank"> OpenTSDB数据模型</a>。</p><h1 id="6ee9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">挑战</h1><p id="7014" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">Goku解决了OpenTSDB中的许多限制，包括:</p><p id="d2bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1)不必要的扫描:悟空用倒排索引引擎代替OpenTSDB的低效扫描。</p><p id="a55d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2)数据大小:OpenTSDB中的一个数据点是20字节。我们采用Gorilla压缩技术实现了12倍的压缩率。</p><p id="a13e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3)单机聚合:OpenTSDB将数据读取到一个服务器上并进行聚合，而Goku的新查询引擎将计算移动到更靠近存储层的位置，从而在根节点上聚合部分结果之前在叶节点上实现并行处理。</p><p id="57d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4)序列化:OpenTSDB使用JSON，返回的数据点太多时速度较慢；悟空改用节俭二进制。</p><h1 id="d379" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">体系结构</h1><h1 id="40d0" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">存储引擎</h1><p id="798a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">悟空在内存存储引擎中使用了脸书大猩猩来存储过去24小时内的最新数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/0dcf39e33b31be0dcd4a5af9097d8a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*146fKfCEO-y_Bo7j7ArlUQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Brief introduction of the storage engine. If you want to know the details, please check the <a class="ae kw" href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf" rel="noopener ugc nofollow" target="_blank">Gorilla paper</a> and its <a class="ae kw" href="https://github.com/facebookarchive/beringei" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>.</figcaption></figure><p id="4235" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，在存储引擎中，时间序列被分成不同的片段，称为<em class="jc"> BucketMap </em>。对于一个时间序列，它也被划分为持续时间可以配置的时段(内部我们使用2小时时段)。在每个BucketMap中，每个时间序列被分配一个惟一的id，并链接到一个<em class="jc"> BucketTimeSeries </em>对象。BucketTimeSeries在<em class="jc"> BucketStorage </em>中保存最新的可修改缓冲桶和不可变数据桶的存储id。经过配置的存储桶时间后，BucketTimeSeries中的数据将被写入BucketStorage，并成为不可变的。</p><p id="78e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现持久性，BucketData也被写入磁盘。悟空重启的时候，会把数据从磁盘读入内存。我们使用NFS来存储数据，这使得碎片迁移变得容易。</p><h1 id="c599" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分片和路由</h1><p id="e0b3" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们使用两层分片策略。首先，我们对指标名称进行哈希运算，以确定一个时间序列属于哪个分片组。接下来，我们对指标名称+标记键值集进行哈希运算，以确定时间序列属于该组中的哪个片段。这种策略确保了数据在碎片间的平衡。同时，由于每个查询只进入一个组，扇出保持较低，以减少网络开销和尾部延迟。此外，我们可以独立扩展每个分片组。</p><h1 id="84e0" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">查询引擎</h1><p id="6f06" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><em class="jc">倒索引</em></p><p id="46c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">悟空通过指定标签键和标签值来支持查询。例如，如果我们想知道一台主机<strong class="ig hi"> <em class="jc"> host1 </em> </strong>的CPU使用率，我们可以发送一个查询<strong class="ig hi"><em class="jc">CPU . usage { host = host 1 }</em></strong>。为了支持这种查询，我们实现了一个倒排索引。(在内部，它是从搜索词到位集的散列表。)搜索项可以是指标名称，如<strong class="ig hi"> <em class="jc"> cpu.usage </em> </strong>或标记键值对，如<strong class="ig hi"> <em class="jc"> host=host1 </em> </strong>。有了这个倒排索引引擎，我们可以快速地执行<strong class="ig hi">和</strong>、<strong class="ig hi">或</strong>、<strong class="ig hi">而不是</strong>、<strong class="ig hi">通配符</strong>和<strong class="ig hi"> REGEX </strong>操作，与最初的基于OpenTSDB扫描的查询相比，这也减少了许多不必要的查找。</p><p id="b99f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">聚合</em></p><p id="7976" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在从存储引擎中检索数据之后，是最终结果的聚合和构造步骤。</p><p id="1ce7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们最初尝试了OpenTSDB，使用了它内置的查询引擎。性能严重下降，因为所有的原始数据都需要在网络上传输，而且那些短命的对象会导致大量的垃圾收集。</p><p id="c50f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们在悟空内部复制了OpenTSDB的聚合层。我们还尽可能早地推动计算，尽量减少网络上的数据。</p><p id="95ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">典型的查询流程如下:</p><ul class=""><li id="509d" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">来自Statsboard客户端(Pinterest的内部指标监控UI)的查询会发送到任何代理goku实例</li><li id="ca15" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">代理悟空根据分片配置将查询扇出到同一组内的相关悟空实例</li><li id="cc01" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">每个悟空读取倒排索引以获得相关的时间序列id，并继续获取它们的数据</li><li id="8ecc" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">每个悟空基于查询聚集数据，像聚集器、下采样器等</li><li id="dc80" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">代理悟空在从每个悟空收集结果后进行第二轮聚合，并返回给客户端</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/c4a2ac2bf987ba8855a7309ef53ca6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jR2s9q8A3IRejiz_6TY7MA.png"/></div></div></figure><h1 id="2d86" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">表演</h1><p id="3d78" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">与之前使用的OpenTSDB/HBase方案相比，悟空几乎在各个方面的表现都要好得多。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/8bca21bdcb4a634897b19da5313b4a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6v4zxauEExT-J-UlysOhg.png"/></div></div></figure><p id="7e7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里是另一个延迟图，重点是使用悟空前后的高基数查询。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/e82628142b67fb2d3b1e96e530eee6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqSlWueoHPi5SabNxYp-pw.png"/></div></div></figure><h1 id="3e23" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">下一步是什么</h1><p id="8e22" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><em class="jc">基于磁盘的长期数据存储</em></p><p id="874e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">悟空最终将支持超过一天的查询。对于像一年这样的长期查询，我们不强调一秒钟内发生了什么，而是着眼于整体趋势。因此，我们将进行缩减采样和压缩，将每小时的时段合并到更长的时段中，这样可以减少数据量并提高查询性能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/4fa7fc87393cb52c99b5753b0d1ab85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*186vmCJbw_qsgFegwPbPcQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Goku Phase #2 — Disk based: Data includes index data and time series data</figcaption></figure><p id="ac69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">复制</em></p><p id="1267" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前，我们有两个悟空集群在进行双重写入。这个设置为我们提供了高可用性:当一个集群出现问题时，我们可以轻松地将流量切换到另一个集群。但是，因为两个集群是独立的，所以很难确保数据的一致性。例如，如果对一个的写入成功，而对另一个的写入失败，则数据将变得不一致。另一个缺点是故障转移总是群集级别的粒度。我们正在研究基于日志的集群内复制，以支持主从碎片。这将提高读取可用性，保持数据一致性和碎片级粒度的故障转移。</p><p id="5a73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">分析用例</em></p><p id="321c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有行业都广泛需要分析，Pinterest也不例外。像实验结果和广告活动表现这样的问题每分钟都会被问到。目前，我们主要使用离线作业和HBase进行分析，这意味着没有实时数据和大量不必要的预聚合。由于时间序列数据的性质，悟空可以很容易地适应它，不仅提供实时数据，而且按需聚合。</p><p id="dda6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将继续探索悟空的用例。如果你对这样的项目感兴趣，请查看我们的<a class="ae kw" href="https://careers.pinterest.com/careers/engineering" rel="noopener ugc nofollow" target="_blank">职业页面</a>！</p><p id="6963" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">鸣谢:非常感谢可视性团队的布莱恩·奥弗斯特里特、朱未、</em>、<em class="jc">保罗·宾德斯和池永·徐帮助推出《悟空》和设计建议。</em></p></div></div>    
</body>
</html>