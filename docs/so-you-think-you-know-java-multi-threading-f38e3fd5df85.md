# 所以你以为你懂 Java 多线程！

> 原文：<https://medium.com/walmartglobaltech/so-you-think-you-know-java-multi-threading-f38e3fd5df85?source=collection_archive---------2----------------------->

![](img/ca953d1b9d785a0ffddd40d4341823d5.png)

The Himalayas — from an iPhone

作为一名 Java 程序员，在我职业生涯的大半时间里，我经常惊讶于(有时不是)有多少开发人员并不真正理解 JVM 中的多线程是如何工作的。这可能部分是因为我们已经习惯于编写`stateless`服务，或者代码的多线程方面隐藏在框架后面(Spring 中的`@async`注释和 Java 中的`Executor Framework`)。这篇文章是对多线程某些方面的快速复习(不能代替权威来源)，特别是同步和线程安全以及 JVM 如何处理它。它谈到了熟悉的生产者-消费者问题，以及如何通过例子来识别“共享状态”。

# 生产者消费者范式

从本质上讲，生产者消费者范式是一种生产者(在这个上下文中是一个线程)生产输出，而消费者消费输出的范式。输出可以存储在队列或共享变量中。在 Java 5 和更高版本中， [java 并发包](https://docs.oracle.com/javase/9/docs/api/index.html?java/util/concurrent/Executor.html)提供了一堆类，通过提供`Executor Service Framework`来帮助抽象出安全访问的底层语义。这个框架提供了一些类，允许你与接受并执行`Runnable`的任务执行器一起工作——对程序员隐藏同步结构。执行器将返回一个`Future`，然后可以用它来检索任务的结果。

考虑以下场景——我有一个需要生成一系列数字(例如 1..100)以及需要在生产 时读取数字 ***的消费者。如果有多个生产者和多个消费者，并且消费和生产的比率可能不同，那么将产生的输出放在队列中是有意义的。但是如果我们的需求只是读取一个“计数器”变量的共享状态，我们就不需要把它放入队列中。识别什么是`shared`是确定共享访问需要保护什么的第一个问题。***

> 对 Java 变量的操作不是原子的。如果多个线程在写操作完成之前读取存储器位置的值，则诸如加法之类的操作容易受到竞争条件的影响。Java 内存模型(JMM)为此定义了规范。Volatile 声明、AtomicIntegers、AtomicLongs 和 AtomicReferences 有助于确保写入是原子的，但这并不一定意味着线程正在读取正确的值。如果不考虑同步访问，它可能仍在读取旧值。在变量前面添加一个 volatile 关键字告诉 JMM，对变量的写入必须是原子的。AtomicIntegers、AtomicLongs 和 AtomicReferences 也实现了相同的原子性结果，但是具有附加的帮助器方法来帮助判断是否需要写入以及在写入后读取值。

在上面定义的生产者消费者案例中，生产者递增共享计数器的值，消费者读取共享计数器的最后一个递增值。因此，我们需要确保共享计数器在任何时候都只被一个线程访问，以读取其当前值或写入其下一个值。

打个比方，想象一下一个仓库，在这个仓库里，要拿到里面的东西，唯一的方法就是穿过一扇锁着的门。为了**将物品**放入仓库，必须获得钥匙并打开门，将物品放入仓库，一旦物品在仓库中，钥匙就被归还。要从仓库中取出一件物品，必须拿到钥匙，打开门，取回物品。在上面的例子中，仓库或`CounterObj`在生产线程(线程 A)和消费线程(线程 B)之间共享。锁是互斥的(互斥体)，也就是说，在任何时候，生产者或消费者都可以获得锁的密钥。他们不能同时获得同一个密钥。一旦任务完成，拥有的线程必须释放密钥(或锁的访问权)。

现在，当线程将商品放入仓库并且必须释放钥匙/锁时，它会做什么呢？它是睡觉还是等待？如果`synchronized`中的线程`sleeps`阻塞了或者按照我们的类比阻塞了仓库——它实际上并没有释放仓库的密钥。它仍然持有的关键和，并没有做任何工作，除了释放使用的 CPU。这意味着现在没有其他线程可以获取密钥。因此，如果锁是排他锁(互斥锁),那么实际上没有其他线程可以进入仓库，添加或获取条目，除非第一个线程从睡眠中获得`interrupted`。回到线程构造——正确的选择应该是调用锁对象的`wait`方法，该方法释放锁，这样另一个线程就可以进入由同一个锁保护的任何同步块。在仓库类比中——这就像退出仓库，归还钥匙，并在仓库入口处排队，以便在钥匙再次可用时获取它。

> 请注意，许多区域或同步块可以由同一个锁定对象保护。如果每个块保护的**状态**不同，考虑使用新的“锁”对象来同步访问。每个对象都有一个内在的锁定机制，它是 [Java 对象继承](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)(等待和通知)的一部分，并且在内部与一个`lock access count`和一个`wait set`相关联。当一个线程获得对象的锁时，`lock access count`就会递增。在互斥锁的情况下，`lock access count`只能是 1 或 0。如果`lock access count`为 1，那么另一个需要进入对象锁持有的同步块的线程将被添加到对象的`wait set`中。一个线程被添加到一个对象的`wait set`中，或者在该对象保护的同步块的入口，或者通过调用该对象的`wait`方法。一旦执行了共享访问块，持有锁的线程将调用对象的`notifyAll`或`notify`，让`wait-set`中的线程知道锁现在可以再次被获取。

下面是上面提到的生产者消费者实体的代码片段。

如果`CounterObj`被声明为易失性的，那么写更新确保对读取它的线程可见。如果我们稍微修改一下程序，去掉`wait notify`块，使用没有同步块的`Thread.sleep(1000)`，我们仍然会看到正确的输出，但是中间更新会丢失给消费者线程。

如果您的应用程序需要状态，但允许多个线程看到状态的不同版本，那么`ThreadLocal`将值限制到一个线程。你可能会问，使用`ThreadLocal`和`volatile`有什么区别。使用`volatile`提供了**弱级别的同步**，并且读取和写入是原子性的。`volatile`确保所有线程从主内存(不是从 cpu 缓存或寄存器)读取最新值，并刷新回主内存——但是，复合操作(如读取和递增`i++, i==, i+=x`等)不能保证是原子的。然而，使用`ThreadLocal`，每个线程都有自己的变量值，不需要同步。

# 但是什么是共享状态呢？

如果一个对象(Servlet 或 Spring Bean)可以被多个线程访问，并且有可变的`class level`变量，那么这个对象就有共享状态。Spring 容器、Web 服务器实现本身就是多线程的。beans 或 servlet 实例同时处理多个请求，每个请求来自一个单独的线程。如果一个对象由一个实体创建，然后通过一个引用参数在两个不同类型的单独实例中访问，它仍然是共享状态。如果对象是在正在执行的方法中创建的，那么这些对象不会被共享，因为每个线程都有自己的堆栈框架，并且局部变量被放置在堆栈框架中。考虑下面的代码片段来说明上述内容。

## 最后

在过去被多线程错误咬过之后，我一直是一个谨慎的 Java 程序员，寻找共享状态是我的检查清单的一部分。Doug Lea 关于 Java 中的[并发编程的书](https://www.amazon.com/Concurrent-Programming-Java%C2%99-Principles-Pattern/dp/0201310090)是每个 Java 开发人员必读的一本书，一读再读。如果您从未遇到过导致应用程序不可预测的行为的多线程错误，潜在的线程安全问题可能有点难以想象。希望这篇文章有助于想象！

*感谢* [*阿比吉特*](https://medium.com/u/a1025ca0f49e?source=post_page-----f38e3fd5df85--------------------------------) *的输入！*