<html>
<head>
<title>Data Structures: Traversing Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:遍历树</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/data-structures-traversing-trees-9473f6d9f4ef?source=collection_archive---------0-----------------------#2018-01-25">https://medium.com/quick-code/data-structures-traversing-trees-9473f6d9f4ef?source=collection_archive---------0-----------------------#2018-01-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="092f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树是非线性数据结构，因为它们是通过关系或层次结构来组织的。这允许我们以多种方式遍历它们。为了澄清，树遍历指的是恰好访问每个单独节点一次的过程。对于我们的遍历，我们将关注二叉树，这是最多有两个孩子的树。你可以通过下面的链接查看我之前关于二分搜索法树的文章。</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/@mbetances1002/data-structures-binary-search-trees-explained-5a2eeb1a9e8b"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">数据结构:二分搜索法树解释</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">二分搜索法树允许我们按照排序的顺序高效地存储和更新动态变化的数据集。当…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><h1 id="d093" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">如何遍历树？</strong></h1><p id="e0a1" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">遍历树有两种主要方法:</p><ol class=""><li id="31f6" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated">广度优先</li><li id="8cbc" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated">深度优先</li></ol><h2 id="4acd" class="lm jw hh bd jx ln lo lp kb lq lr ls kf ip lt lu kj it lv lw kn ix lx ly kr lz bi translated"><em class="ma">广度优先遍历</em></h2><p id="8e3d" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">当树的层次背后有某种意义时，就利用了广度优先的方法。在广度优先中，从上到下访问树中的每一层，直到遍历完整个树。在每一层，你从左到右访问每个节点一次。让我们使用我之前文章中的构造函数来构建我们的二叉查找树(BST)。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="692c" class="lm jw hh mg b fi mk ml l mm mn">function BinarySearchTree (val) {<br/>  this.value = val;<br/>  this.left = null;  // the left child node<br/>  this.right = null; // the right child node<br/>}</span><span id="d785" class="lm jw hh mg b fi mo ml l mm mn">let newTree = BinarySearchTree(20); // 20 node becomes our root</span><span id="2ac7" class="lm jw hh mg b fi mo ml l mm mn">newTree.insert(25)<br/>newTree.insert(21)<br/>newTree.insert(16)<br/>...</span></pre><p id="a99b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们演练一下广度优先利用<code class="du mp mq mr mg b">newTree</code>会发生什么。请注意，广度优先在BST中不太有用，因为级别没有任何本质意义，但为了简化这一审查，我们将对所有示例使用相同的BST:</p><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/5a778d12713abbaea5f568b6f52f9f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*fGEE6TYlsgDhZHSAQdjXeQ.png"/></div></figure><p id="7d99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决广度优先的问题，我们需要一个数据结构来跟踪每个节点之间的关系。简单地沿着二叉树往下走，我们将失去对存在的父子关系的访问。这是指已经建立的<code class="du mp mq mr mg b">this.left</code>和<code class="du mp mq mr mg b">this.right</code>连接。例如:</p><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/6ee0959507ca0a6056f7ab2e6b90c046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*cHJXXL2h4Efg7i6IsaGfDA.png"/></div></figure><p id="48d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将需要使用队列数据结构，以便能够从左到右访问每个级别中的每个节点。队列是遵循先入先出(FIFO)规则的线性数据结构。你可以把排队想象成消费者在你当地的星巴克排队等候；它是基于先到先得的原则。消费者按照他们排队等候的顺序得到服务。排在队首的人会比排在队尾的人先得到服务。如果你是初学者，你可以从<a class="ae mv" href="https://blog.coursesity.com/best-data-structure-algorithms-tutorials/" rel="noopener ugc nofollow" target="_blank">最佳数据结构算法教程</a>中受益。</p><figure class="mb mc md me fd mt er es paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="er es mw"><img src="../Images/10f5ecd184ef89486019bbccd873f8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*k3zJ6U4pYM4yunGIFjF4Qw.png"/></div></div></figure><h2 id="6164" class="lm jw hh bd jx ln lo lp kb lq lr ls kf ip lt lu kj it lv lw kn ix lx ly kr lz bi translated">编码我们的广度优先遍历</h2><p id="fa00" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">为了编写广度优先遍历的代码，让我们假设我们想要创建一个数组，按照级别顺序保存二叉查找树中的所有值。让我们写出一个回调函数，它是一个作为参数传递给另一个函数的函数，这个函数将接受一个值并将其推送到一个数组中。稍后，我们将把这个回调函数传递给广度优先方法。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="ffd7" class="lm jw hh mg b fi mk ml l mm mn">let levelOrderArray = [];</span><span id="a19a" class="lm jw hh mg b fi mo ml l mm mn">// ES6 syntax<br/>const pushOrderNodes = (num) =&gt; {<br/>  levelOrderArray.push(num);<br/>};</span></pre><p id="b414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在将编写一个简单的广度优先方法，该方法可以将回调函数作为参数(我们将不考虑错误处理)。为了节省内存，我们将利用构造函数的原型来创建这个方法。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="0627" class="lm jw hh mg b fi mk ml l mm mn">BinarySearchTree.prototype.traverseBreadthFirst = function (func) {<br/>  let queue = [this];<br/>  <br/>  while (queue.length) {<br/>    let currentNode = queue.shift();<br/>    <br/>    if (currentNode.left) {<br/>      queue.push(currentNode.left)<br/>    }<br/>    <br/>    if (currentNode.right) {<br/>      queue.push(currentNode.right)<br/>    }<br/>    <br/>    func(currentNode.value)<br/>  }<br/>};</span></pre><p id="dc2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们分解这段代码中的前几个循环，以了解到底发生了什么…</p><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/cce365b63c4a0414a07d36e7605d8cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*wMAGv40Bv3R34ktDcuqurw.png"/></div></figure><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/b5f1b6719c49b63355842f67dc4d88e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*DFx-m47rjuqtbig1FDQYAw.png"/></div></figure><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/15f2f9e9d7b1773e4d091f9867142bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*U-6iYt_hZS6sDPhwSpH93Q.png"/></div></figure><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/ab310d6febb3868069051d4a59158a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*_qMVO6gLNT6b7IvUT6NvRA.png"/></div></figure><p id="8626" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们将回调函数<code class="du mp mq mr mg b">pushOrderNodes</code>传递给我们的<code class="du mp mq mr mg b">traverseBreadthFirst</code>方法。这将遍历我们的<code class="du mp mq mr mg b">newTree</code>，并为每个节点执行一次传入的函数<code class="du mp mq mr mg b">pushOrderNodes</code>。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="ba8a" class="lm jw hh mg b fi mk ml l mm mn">newTree.traverseBreadthFirst(pushOrderNodes)</span></pre><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es nb"><img src="../Images/7d2dfc7f9cd7f48eb4a8e5c409b7b146.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*U-yCk52ZHbHIYjXDHhZORA.png"/></div><figcaption class="nc nd et er es ne nf bd b be z dx">Our levelOrderArray now holds all our nodes in breadth-first order.</figcaption></figure><h2 id="7f8d" class="lm jw hh bd jx ln lo lp kb lq lr ls kf ip lt lu kj it lv lw kn ix lx ly kr lz bi translated"><em class="ma">深度优先遍历</em></h2><p id="d150" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">深度优先遍历有三种类型:</p><ol class=""><li id="9907" class="ky kz hh ig b ih ii il im ip la it lb ix lc jb ld le lf lg bi translated"><strong class="ig hi">预排序:</strong>访问父节点，然后访问所有左边的子节点，然后访问所有右边的子节点。</li><li id="2e3c" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated"><strong class="ig hi">按顺序:</strong>访问左边的孩子，然后是父母，然后是右边的孩子。这种方法对于BST很有用，因为它按照排序的顺序遍历节点。</li><li id="5bb3" class="ky kz hh ig b ih lh il li ip lj it lk ix ll jb ld le lf lg bi translated"><strong class="ig hi">后顺序:</strong>先访问左边的孩子，再访问右边的孩子，然后再访问家长。</li></ol><p id="34bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于深度优先遍历，我们需要一个堆栈数据结构，它遵循后进先出(LIFO)规则。你可以把一叠想象成一叠报纸；最上面的报纸是最后添加到报纸堆中的，但却是第一个被顾客抢去购买的。</p><figure class="mb mc md me fd mt er es paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="er es mw"><img src="../Images/b48a7a845e7cd55fddf3b5ef7b6dcbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*0I6vTFRpztVi1Aez8Te6gA.png"/></div></div></figure><p id="87af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以编写一个方法来涵盖三种不同类型的深度优先遍历。让我们详细回顾一下我们的方法应该做什么:</p><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/a338b7633c3676918c2b3775c0e2a98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*Qb4N2hL7iZGhMjSq3198Lg.png"/></div></figure><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/4c5d16df8e1e775427bf1dbe6ad73c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*XosOeh6mAtsvTZgfB-qn9Q.png"/></div></figure><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/b371547c6dfa8c156a5a20bb4bde223b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*7UkZyvGmWmvhQn60HE5ZyA.png"/></div></figure><h2 id="f9dc" class="lm jw hh bd jx ln lo lp kb lq lr ls kf ip lt lu kj it lv lw kn ix lx ly kr lz bi translated"><strong class="ak">编码我们的深度优先遍历</strong></h2><p id="910e" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我们将利用BinarySearchTree的原型来创建<code class="du mp mq mr mg b">traverseDepthFirst</code>方法。我们的<code class="du mp mq mr mg b">traverseDepthFirst</code>方法将接受一个回调函数，类似于我们的<code class="du mp mq mr mg b">traverseBreadthFirst</code>方法。回调函数将操纵或处理每个节点。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="c5f4" class="lm jw hh mg b fi mk ml l mm mn">BinarySearchTree.prototype.traverseDepthFirst = function (func, type) {<br/>  if (type === 'pre-order') {<br/>    func(this.value)<br/>  }</span><span id="36b6" class="lm jw hh mg b fi mo ml l mm mn">  if (this.left) {<br/>    this.left.traverseDepthFirst(func, type)<br/>  }</span><span id="4a50" class="lm jw hh mg b fi mo ml l mm mn">  if (type === 'in-order') {<br/>    func(this.value)<br/>  }</span><span id="4a8a" class="lm jw hh mg b fi mo ml l mm mn">  if (this.right) {<br/>    this.right.traverseDepthFirst(func, type)<br/>  }</span><span id="097b" class="lm jw hh mg b fi mo ml l mm mn">  if (type === 'post-order') {<br/>    func(this.value)<br/>  }<br/>};</span></pre><p id="bdea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们利用前面的回调函数，<code class="du mp mq mr mg b">pushOrderNodes</code>。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="0daf" class="lm jw hh mg b fi mk ml l mm mn">newTree.traverseDepthFirst(pushOrderNodes, 'post-order')</span></pre><p id="14be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们回顾一下我们如何在<code class="du mp mq mr mg b">traverseDepthFirst</code>方法中利用栈数据结构来进行后序遍历:</p><figure class="mb mc md me fd mt er es paragraph-image"><div class="er es ms"><img src="../Images/e33a00bf12a85729254d342f31203e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*i2I8drm2GY3rlCWbjxxYyw.png"/></div></figure><h2 id="73b0" class="lm jw hh bd jx ln lo lp kb lq lr ls kf ip lt lu kj it lv lw kn ix lx ly kr lz bi translated"><strong class="ak">广度优先和深度优先的应用</strong></h2><p id="2ca3" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我们已经实现了一些基本的遍历方法，您可能想知道，这些方法在现实应用程序中实际上是如何使用的？广度优先和深度优先遍历有多种方式:社交网络推荐你可能认识的用户，在线旅游公司为你的旅行推荐航班，GPS导航系统查找附近的位置，等等。现在让我们庆祝用JavaScript实现了树遍历。</p><figure class="mb mc md me fd mt"><div class="bz dy l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>