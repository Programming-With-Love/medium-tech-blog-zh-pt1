<html>
<head>
<title>#SmallerAPK, Part 4: Multi-APK through ABI and density splits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">#SmallerAPK，第4部分:通过ABI和密度分割实现多APK</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/smallerapk-part-4-multi-apk-through-abi-and-density-splits-477083989006?source=collection_archive---------3-----------------------#2016-02-19">https://medium.com/androiddevelopers/smallerapk-part-4-multi-apk-through-abi-and-density-splits-477083989006?source=collection_archive---------3-----------------------#2016-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/16742a27007b85054b45771a39fbd376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OvLVi-G5Ldze7Novm7M0w.jpeg"/></div></div></figure><div class=""/><p id="0192" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="#4e2d" rel="noopener ugc nofollow"> <strong class="ir ht">更新1 </strong> </a> <strong class="ir ht"> : </strong>添加了一个Gradle脚本来修复自定义密度设备的分割。</p><p id="daee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="#4f51" rel="noopener ugc nofollow"> <strong class="ir ht">更新2 </strong> </a>:如何减少ABI拆分的apk数量。</p><p id="d689" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android是一个多样化的生态系统，设备从手机到平板电脑甚至电视，都有自己的硬件特征，如屏幕尺寸、像素密度和CPU架构。</p><p id="b615" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管在<a class="ae jn" href="http://developer.android.com/google/play/publishing/multiple-apks.html" rel="noopener ugc nofollow" target="_blank">文档</a>中，我们鼓励你创建一个单独的包来支持所有这些设备，但有时最大的空间节省来自于将你的应用分成多个apk。如果您以这种方式准备您的应用程序，使用ARM处理器的手机用户将不必下载x86 CPUs的本机代码，或者使用中等密度屏幕的用户将不会存储超高密度资产并浪费空间和带宽。</p><p id="7b6f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在这里找到关于多APK支持如何工作、Play Store支持哪种过滤器以及关于版本编号的一些重要规则<a class="ae jn" href="http://developer.android.com/google/play/publishing/multiple-apks.html#HowItWorks" rel="noopener ugc nofollow" target="_blank">的详细信息。理解多APK背后的理论是至关重要的，这样你作为一个开发者可以决定你是否想要增加你的发布过程的复杂性，以及它是否对你的用户有益。</a></p><p id="2c93" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给你的应用添加多APK支持的最简单的方法是通过一个叫做<a class="ae jn" href="http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits" rel="noopener ugc nofollow" target="_blank"><em class="jo"/></a>的配置选项。Splits是您可以添加到您的<em class="jo"> build.gradle </em>文件中的一个部分，它可以为不同的屏幕密度或ABI(即CPU架构)创建单独的apk，作为通常构建过程的一部分。</p><h1 id="c833" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">密度分裂</h1><p id="b8ff" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">如果你需要一个示例应用程序，在你开始将拆分添加到你的应用程序之前，我建议你查看一下Github 上的<a class="ae jn" href="https://github.com/googlesamples/android-topeka" rel="noopener ugc nofollow" target="_blank"> Topeka，它已经包含了许多密度的图像资源——非常适合尝试拆分！</a></p><p id="14d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开<em class="jo"> app/build.gradle </em>文件，在android部分添加以下几行:</p><h2 id="e224" class="ks jq hs bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">build.gradle</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fa79" class="ks jq hs ll b fi lp lq l lr ls">android {<br/>    ...<br/>    splits {<br/>        density {<br/>            enable true<br/>            exclude 'ldpi', 'tvdpi', 'xxxhdpi'<br/>//alternatively use the following two lines to only include:<br/>//            reset()<br/>//            include 'mdpi', 'hdpi', 'xhdpi', 'xxhdpi'<br/>            compatibleScreens 'small', 'normal', 'large', 'xlarge'<br/>        }<br/>    }<br/>}</span></pre><p id="d7b0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">配置选项非常简单。首先，您可以根据屏幕密度启用拆分，然后您可以排除(或包括)创建特定配置的拆分，最后指定您的应用程序兼容哪些屏幕，这通常应该是所有四个类别—从小到特大。</p><p id="ac0b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，还会创建一个包含所有密度的通用APK。至关重要的是，你在Play Store上发布的这个APK的版本号要低于所有其他特定密度的软件包。这是必要的，原因有二:</p><ol class=""><li id="ccbb" class="lt lu hs ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated">用于针对特定设备的机制是清单中的<em class="jo"> &lt;兼容屏幕&gt; </em>部分，它不是面向未来的。它要求显式列出每个支持的密度，并且没有包罗万象的存储桶。当新设备出现时，有时会引入新的屏幕密度(正如T4的Nexus 5X和6P的T5所发生的那样)，如果没有通用APK后备，这些设备将无法下载你的应用程序。</li><li id="34af" class="lt lu hs ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">遗憾的是，目前只有命名密度可以使用include/exclude语句，因此您无法创建针对280/360/420/480/560 dpi设备的APK。我已经为这个<a class="ae jn" href="https://code.google.com/p/android/issues/detail?id=198393" rel="noopener ugc nofollow" target="_blank">提交了一个bug。</a></li></ol><p id="4e2d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">更新</strong>:我已经想出了一种方法来解决上面提到的问题(2)，通过使用Gradle脚本将缺失的密度添加到生成的AndroidManifest.xml中。它可能并不优雅，但在Android Gradle插件缺少支持的情况下，它确实可以完成工作。在本例中，280dpi设备将获得<em class="jo"> xhdpi </em> APK，420/400/360 dpi设备将获得<em class="jo"> xxhdpi </em>等等。</p><h2 id="94b5" class="ks jq hs bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">build.gradle</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="edd9" class="ks jq hs ll b fi lp lq l lr ls">ext.additionalDensities = ['xhdpi': ['280'], 'xxhdpi': ['420', '400', '360'], 'xxxhdpi': ['560']]<br/>import com.android.build.OutputFile<br/><br/>android.applicationVariants.all { variant -&gt;<br/>    // assign different version code for each output<br/>    variant.outputs.each { output -&gt;<br/>        if (output.getFilter(OutputFile.DENSITY) != null &amp;&amp; project.ext.additionalDensities.containsKey(output.getFilter(OutputFile.DENSITY))) {<br/>            output.processManifest.doFirst {<br/>                def manifestFile = new File(project.buildDir, "intermediates" + File.separator + "manifests" + File.separator + "density" + File.separator + output.getFilter(OutputFile.DENSITY) + File.separator + variant.buildType.name + File.separator + "AndroidManifest.xml")<br/>                def manifestText = manifestFile.text<br/>                for (String density : project.ext.additionalDensities.get(output.getFilter(OutputFile.DENSITY))) {<br/>                    manifestText = manifestText.replaceAll("&lt;/compatible-screens&gt;", "&lt;screen android:screenSize=\"small\" android:screenDensity=\"${density}\" /&gt;\n" +<br/>                            "&lt;screen android:screenSize=\"large\" android:screenDensity=\"${density}\" /&gt;\n" +<br/>                            "&lt;screen android:screenSize=\"xlarge\" android:screenDensity=\"${density}\" /&gt;\n" +<br/>                            "&lt;screen android:screenSize=\"normal\" android:screenDensity=\"${density}\" /&gt;\n &lt;/compatible-screens&gt;")<br/>                }<br/>                manifestFile.text = manifestText<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="57b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在项目文件夹中的中间文件中检查由生成系统创建的清单项:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ca96" class="ks jq hs ll b fi lp lq l lr ls">/app/build/intermediates/manifests/density/hdpi/debug/AndroidManifest.xml</span></pre><p id="1a4d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它们是部分清单文件，只包含与主清单文件合并的<em class="jo"> &lt;兼容屏幕&gt; </em>部分:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="230f" class="ks jq hs ll b fi lp lq l lr ls">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package=""&gt;<br/> &lt;compatible-screens&gt;<br/> &lt;screen android:screenSize="small" android:screenDensity="hdpi" /&gt;<br/> &lt;screen android:screenSize="normal" android:screenDensity="hdpi" /&gt;<br/> &lt;screen android:screenSize="large" android:screenDensity="hdpi" /&gt;<br/> &lt;screen android:screenSize="xlarge" android:screenDensity="hdpi" /&gt;<br/> &lt;/compatible-screens&gt;<br/>&lt;/manifest&gt;</span></pre><p id="de67" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Play Store将使用它来过滤掉不在定义的密度桶中的设备，并向请求安装您的应用程序的设备发送正确的APK。</p><blockquote class="mh mi mj"><p id="12c5" class="ip iq jo ir b is it iu iv iw ix iy iz mk jb jc jd ml jf jg jh mm jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:如果您希望所有可用密度中包含任何图像，以便在分割过程中不会被剥离，您应该将它们放入mipmap资源文件夹中。这通常用于应用程序图标，因为一些启动器可能使用来自更高密度桶的图标。</p></blockquote><p id="319f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">启用拆分后，Topeka应用程序可以节省大量成本。以下是APK的尺码:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1a09" class="ks jq hs ll b fi lp lq l lr ls">Original (universal) APK:   3.5 MB<br/>MDPI devices:               1.1 MB (2.4 MB savings)<br/>HDPI devices:               1.2 MB (2.3 MB savings)<br/>XHDPI devices:              1.3 MB (2.2 MB savings)</span></pre><p id="d3e6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，这将因应用程序而异，取决于图像资源的大小。</p><h1 id="e507" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">ABI分裂了</h1><p id="32e5" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">与基于密度的拆分类似，您也可以为具有不同CPU体系结构的设备配置ABI拆分:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a9f0" class="ks jq hs ll b fi lp lq l lr ls">splits {<br/>    abi {<br/>        enable true<br/>        reset()<br/>        include 'x86', 'armeabi-v7a', 'mips'<br/>        universalApk false<br/>    }<br/>}</span></pre><p id="172c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想建造一个通用的APK，你可以控制，但这通常是不必要的。记得给x86_64和x86比ARM更高的版本号，因为许多x86设备可以通过仿真层运行ARM代码，尽管性能较低。通过正确设置版本编号，您可以确保他们获得最佳的库。</p><p id="4f51" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">更新:</strong>如果您不希望管理太多APK(每个ABI一个，可能会乘以密度分割数)，有一种方法可以利用通用APK。如果你的应用有任何分析数据，看看哪个ABIs上有多少用户。将最流行的(通常是ARM，也可能是x86)作为APK的目标，将通用的APK提供给其他人。这样你可以确保90%的用户获得最佳版本，而其他人仍然可以下载和使用你的应用。</p><p id="ca82" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，为每个用户提供最佳版本是最好的，但是和所有事情一样，你需要决定作为一个开发人员要花多少时间来维护版本，以及有多少用户将从优化中受益。</p><h1 id="18f3" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置版本代码</h1><p id="5997" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">这里有一个代码片段，可以帮助您为输出的apk设置不同的版本代码，以便您可以将它们作为一个列表上传到Play Store。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a474" class="ks jq hs ll b fi lp lq l lr ls">// map for the version codes<br/>ext.versionCodes = ['mdpi':1, 'hdpi':2, 'xhdpi':3].withDefault {0}</span><span id="2461" class="ks jq hs ll b fi mn lq l lr ls">import com.android.build.OutputFile</span><span id="7929" class="ks jq hs ll b fi mn lq l lr ls">android.applicationVariants.all { variant -&gt;<br/>// assign different version code for each output<br/>    variant.outputs.each { output -&gt;<br/>        output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter(OutputFile.DENSITY)) * 1000000 + android.defaultConfig.versionCode<br/>    }<br/>}</span></pre><p id="fd1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本例使用3个密度分割，版本编号计算为<em class="jo">密度版本代码* 1000000 + app版本代码</em>。所以版本号应该是这样的:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="06a7" class="ks jq hs ll b fi lp lq l lr ls">Universal:       1,      2,       3 ...<br/>MDPI:      1000001,1000002, 1000003 ...<br/>HDPI:      2000001,2000002, 2000003 ...<br/>XHDPI:     3000001,3000002, 3000003 ...</span></pre><p id="b6ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，只有不符合任何特定密度的设备才能获得通用APK。您可以使用类似的方法来设置ABI分割的版本代码，通过改变<em class="jo">输出文件。密度</em>至<em class="jo">输出文件。ABI </em>并在代码中使用ABI的名字，如‘x86’和‘arme ABI-v7a’而不是‘mdpi’、‘hdpi’和‘xhdpi’。</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="4229" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您需要多APK设置的更多灵活性，请查看<a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-5-multi-apk-through-product-flavors-e069759f19cd">第5部分:多APK产品风格</a></p></div></div>    
</body>
</html>