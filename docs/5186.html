<html>
<head>
<title>Build widgets in Mendix with React — Part 1 — Colour Counter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React在Mendix中构建小部件—第1部分—颜色计数器</h1>
<blockquote>原文：<a href="https://medium.com/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff?source=collection_archive---------0-----------------------#2022-06-21">https://medium.com/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff?source=collection_archive---------0-----------------------#2022-06-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fa072494de50ea735feea2f6110f1ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLAjaHAcMEKQD83Glnq7fA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Build widgets in Mendix with React — Part 1 — Color Counter</figcaption></figure><h1 id="582d" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">Mendix是一个低代码平台，让制造商更快地交付价值，轻松地构建应用程序。使用Mendix，可以使用React和可插拔小部件框架定制前端。</h1><p id="6b8c" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">这篇博客是熟悉为Mendix构建自己的可插拔小部件的一系列构建小部件中的第一篇。这些博客将涵盖越来越复杂的概念，并将涵盖一系列用例，包括熟悉Typescript和Pluggable widgets API，在浏览器中运行机器学习模型，以及构建一个基本的WebAssembly游戏。</p><h1 id="c46c" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">从哪里开始</h1><p id="b8c4" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">如果您还没有，那么您应该查看工作示例来创建您的第一个可插拔小部件:</p><div class="lb lc fm fo ld le"><a href="https://docs.mendix.com/howto/extensibility/create-a-pluggable-widget-one/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">构建可插入的Web小部件:第1部分</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">这篇操作指南将教你创建一个可插入的web小部件。</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lb lc fm fo ld le"><a href="https://docs.mendix.com/howto/extensibility/create-a-pluggable-widget-two/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">构建可插入的Web小部件:第2部分(高级)</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">这个操作指南将教你如何给你的文本框输入部件添加高级功能。</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">docs.mendix.com</p></div></div></div></a></div><p id="b8f8" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">可插拔小部件使用React Javascript框架，我们将在本系列中触及一些React概念，但这绝不是对React的全面介绍。因此，如果您需要介绍或复习，我强烈推荐以下课程(您甚至可能会发现这个小部件的灵感)。</p><div class="lb lc fm fo ld le"><a href="https://scrimba.com/learn/learnreact" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">React教程:学习React JS -免费11小时课程</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">终极反应101 -任何反应初学者的完美起点。通过解决以下问题学习现代反应的基础知识…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">scrimba.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ja le"/></div></div></a></div><h1 id="e897" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">本博客的目的</h1><p id="4716" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">在这篇博客中，我们将讨论:</p><ul class=""><li id="a528" class="ly lz hu bd b kg ln kk lo ko ma ks mb kw mc la md me mf mg dt translated">可插入小部件项目结构</li><li id="7afa" class="ly lz hu bd b kg mh kk mi ko mj ks mk kw ml la md me mf mg dt translated">测试设置和开发</li><li id="4696" class="ly lz hu bd b kg mh kk mi ko mj ks mk kw ml la md me mf mg dt translated">React概念介绍</li><li id="bd04" class="ly lz hu bd b kg mh kk mi ko mj ks mk kw ml la md me mf mg dt translated">利用外部库</li></ul><h1 id="49b3" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">我们正在建造的东西</h1><p id="0bb4" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">我们将建立一个计数器，可以通过点击按钮来增加或减少，点击时会随机改变颜色。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/71a67fc2f8c30b93fcac6b969f741476.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/0*cd4KoGdRJbVdnEr0.gif"/></div></figure><p id="8ad6" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">项目的结束状态可在此处找到:</p><div class="lb lc fm fo ld le"><a href="https://github.com/joe-robertson-mx/colourCount" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">GitHub -乔-罗伯逊-mx/colourCount</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">伴随ColourCount插件的一个小部件，可以增加或减少一个计数器…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">github.com</p></div></div><div class="ls l"><div class="mr l lu lv lw ls lx ja le"/></div></div></a></div><h1 id="ad46" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">入门指南</h1><p id="bac6" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">首先，我们使用Mendix小部件生成器yo @mendix/widget color count搭建小部件。这给了我们HelloWorld实现。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/86cfeb1ae596f49e72e2d90caddbe38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I6tHaCHzMKFLcygY.jpg"/></div></div></figure><p id="3969" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">文件夹结构:</strong></p><p id="c30e" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们的小部件文件夹具有以下结构:</p><blockquote class="mu mv mw"><p id="dd5c" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-dist —我们构建和捆绑的代码将输出到的地方</p><p id="c3a2" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-节点模块-我们的节点依赖关系</p><p id="93ef" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-src-我们的src代码文件夹</p><p id="672c" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-components-每个组件文件夹jsx文件</p><p id="1814" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-ui —用于样式化小部件的css</p><p id="2d94" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-package . XML-描述小部件结构</p><p id="0533" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-colourCount.editorConfig.ts —在Studio Pro和Studio中设计模式下预览的配置</p><p id="0d52" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-colour count . editor preview . jsx-在Studio Pro和Studio中提供预览的组件</p><p id="af77" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-colourCount.tsx —小部件的入口点</p><p id="de5d" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-colourcount.xml —描述小部件和Mendix之间接口的标记</p><p id="db7b" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-package.json —描述我们的npm项目和小部件依赖关系</p><p id="3fbc" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">-appearlier . config . js—允许我们为代码修改更漂亮的规则</p></blockquote><p id="9056" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">测试&amp;开发设置</strong></p><p id="a5d5" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">为了便于测试，我们在小部件的目标版本中创建了一个新的空白Mendix项目。/colourCount/tests/testProject</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nb"><img src="../Images/52cbdece38bfcecea2f4f45f2105f49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6uPAcXyr1HbtkzCO.jpg"/></div></div></figure><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/f40f7a36785579274b5adc02a5748cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jltmnMR-7RWdLhOG.jpg"/></div></div></figure><p id="f3ec" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">让它运行起来</strong></p><p id="7454" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">完成后，让我们运行构建脚本并测试小部件。</p><p id="e908" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">从终端导航到小部件根目录，然后输入</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="d9b1" class="ni jh hu ne b fv nj nk l nl nm">npm run build </span></pre><p id="6fc5" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">这将在我们的dist/文件夹和测试应用程序的widgets文件夹中创建一个widget包。</p><p id="2d77" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">要查看小部件的运行情况，我们只需在Studio Pro中打开我们的测试应用程序，然后按F4来同步我们的文件目录。然后，我们可以像添加任何其他小部件一样，将小部件添加到页面中。</p><p id="aca1" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">为了配置我们的小部件并验证参数是否从建模器传递到前端的小部件，我们可以添加一些文本来传递。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/72c8c4435d923a572d1227682d378aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Neh0M0YTm_5GikIS.jpg"/></div></div></figure><p id="78e8" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">当我们运行应用程序时，我们可以看到</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff no"><img src="../Images/d008a7f51b2bc8d2779b0646db31d0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/0*BjAIKbWcNUcFnH6H.jpg"/></div></figure><p id="efc8" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们的小部件的部署和测试过程是可行的，但是有点慢。为了加速这个过程，我们可以通过运行</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="bfc3" class="ni jh hu ne b fv nj nk l nl nm">npm run start</span></pre><p id="5be1" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">这将观察我们的代码的变化，为了看到它们的反映，我们只需要清除缓存并强制重新加载。</p><p id="0e64" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">这可以在Chrome中通过打开Chrome开发者工具(Ctrl + Shift +i)，右键点击刷新按钮，选择“清空缓存和硬重新加载”来完成。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff np"><img src="../Images/39d3f2bc5cd1bfe2b47198549eadc2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Jrtbr5vihX-tu3XT6a8u6g.png"/></div></figure><h1 id="b855" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">编写代码</h1><p id="072c" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">该编码了！</p><p id="17be" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">在我们开始</strong>之前有几个小改动</p><p id="41c1" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">让我们从react代码开始，首先让我们将组件重命名为更合理的名称:Count。</p><p id="94d7" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">首先，我们重命名HelloWorld.jsx中的组件。</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="0a29" class="ni jh hu ne b fv nj nk l nl nm">import { createElement } from "react";<br/>import { Count } from "./components/Count";<br/>import "./ui/ColourCount.css";</span><span id="badd" class="ni jh hu ne b fv nq nk l nl nm">export function ColourCount({ sampleText }) {<br/>   return &lt;Count sampleText={sampleText ? sampleText : "World"} /&gt;<br/>}</span></pre><p id="1394" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">重命名文件以匹配ColourCount中的组件也是最佳实践。</p><p id="2177" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们需要将src/ui中的CSS文件重命名为colour count . CSS——以便正确导入。我们还必须更新子组件，为此，我们首先将HelloWorldSample.jsx重命名为Count.jsx，并将其中的组件名称更新为Count。</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="df7b" class="ni jh hu ne b fv nj nk l nl nm">export function Count({ sampleText }: HelloWorldSampleProps) {<br/>    return &lt;div className="widget-hello-world"&gt;<br/>              Hello {sampleText}<br/>           &lt;/div&gt;;<br/> }</span></pre><p id="2bc2" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">为了加快开发过程，我们将改变我们的editorPreview文件，这样通过像这样更新它，它就不依赖于其余的代码了</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="0868" class="ni jh hu ne b fv nj nk l nl nm">import { ReactElement, createElement } from "react";</span><span id="10d9" class="ni jh hu ne b fv nq nk l nl nm">export function preview() {<br/>    return &lt;div /&gt;;<br/>}</span><span id="6786" class="ni jh hu ne b fv nq nk l nl nm">export function getPreviewCss() {<br/>    return require("./ui/ColourCount.css");<br/>}</span></pre><p id="9a67" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">在我们开始更新我们的组件之前，让我们将我们的子组件重命名为更合理的名称:“Count”。为此，我们需要更新ColourCount父组件，以引用components/Count文件中包含的Count组件。</p><p id="b166" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们的小部件构建可以分为3个部分:</p><ul class=""><li id="d4ba" class="ly lz hu bd b kg ln kk lo ko ma ks mb kw mc la md me mf mg dt translated">更新Mendix小部件接口，接受一个数字作为计数器的起始值</li><li id="4f1a" class="ly lz hu bd b kg mh kk mi ko mj ks mk kw ml la md me mf mg dt translated">创建更改该数字的逻辑</li><li id="85a2" class="ly lz hu bd b kg mh kk mi ko mj ks mk kw ml la md me mf mg dt translated">将随机颜色变化添加到数字中</li></ul><p id="0007" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">更新Mendix Widget接口</strong></p><p id="2bba" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">Mendix模型和小部件之间的接口在ColourCounter.xml标记中定义。我们需要通过将'<strong class="bd mt"> sampletext </strong> ' <em class="mx">属性</em>更改为以下内容来更新我们的以接受数值:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="93eb" class="ni jh hu ne b fv nj nk l nl nm">&lt;property key="initialValue" type="integer" required="true" defaultValue="5"&gt;<br/>    &lt;caption&gt;Initial Value&lt;/caption&gt;<br/>    &lt;description&gt;The initial value of the counter&lt;/description&gt;&lt;/property&gt;</span></pre><p id="2faa" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">如果我们打开我们的Mendix模型，按F4并更新小部件。打开小工具时，你会看到我们的新界面。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/e52e53f3be70e35e8aacbde0fe6257ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1c0WN4jKT3BFiJoU.png"/></div></div></figure><p id="54ec" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">然而，这还没有连接到我们的组件。</p><p id="a351" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">为此，我们需要在ColourCount文件中用<strong class="bd mt"> initialValue </strong>替换<strong class="bd mt"> sampleText </strong>:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="bdf8" class="ni jh hu ne b fv nj nk l nl nm">import { createElement } from "react";<br/>import { Count } from "./components/Count";<br/>import "./ui/ColourCount.css";</span><span id="b84a" class="ni jh hu ne b fv nq nk l nl nm">export function ColourCount({ initialValue }) {<br/>    return &lt;Count initialValue={initialValue} /&gt;;<br/>}</span></pre><p id="7bf6" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">并且在计数文件中</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="1836" class="ni jh hu ne b fv nj nk l nl nm">export function Count({ initialValue }) {<br/>    return &lt;div&gt;{initialValue}&lt;/div&gt;;<br/>}</span></pre><p id="2bcf" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">如果我们重新运行我们的应用程序，我们可以看到我们的初始值:</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/b2a7afbb0599e206715ffc6c4019931c.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/0*ZDonXH_pTl8FgT2g.png"/></div></figure><p id="737f" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">属性(或道具)从Mendix应用程序传递到ColourCount组件，在那里它在函数中被析构并传递到Count组件。</p><blockquote class="mu mv mw"><p id="457a" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">点击阅读更多关于解构javascript对象<a class="ae nt" href="https://dmitripavlutin.com/javascript-object-destructuring/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p></blockquote><p id="c056" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">创建逻辑以更改该数字</strong></p><p id="683b" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">道具不应该在React中直接改动。相反，我们存储在组件状态中改变的属性。</p><p id="88dc" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">为了在功能组件中利用状态，我们使用了useState钩子。</p><blockquote class="mu mv mw"><p id="a4b3" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">h<!-- -->ook是在React 16.8版本中引入的。它允许您在不编写类的情况下使用状态和其他React特性。挂钩是从功能组件“挂钩”反应状态和生命周期特征的功能。它在类内不起作用。点击阅读更多关于React <a class="ae nt" href="https://www.javatpoint.com/react-hooks#:~:text=Hooks%20are%20the%20new%20feature,does%20not%20work%20inside%20classes." rel="noopener ugc nofollow" target="_blank">中钩子的内容。</a></p></blockquote><p id="1a40" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">首先我们需要将<strong class="bd mt">使用状态</strong>添加到导入中。</p><p id="e5cd" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><code class="eh nu nv nw ne b">import { createElement, useState } from "react";</code></p><p id="f748" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">然后，我们将下面的代码添加到计数组件中。</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="a8e9" class="ni jh hu ne b fv nj nk l nl nm">export function Count({ initialValue }) {<br/>    const [count, setCount] = useState (initialValue)<br/>    return &lt;div&gt;{count}&lt;/div&gt;;<br/>}</span></pre><p id="7dc3" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">当我们调用<strong class="bd mt"> useState </strong>时，它返回一个状态变量数组，以及一个设置状态变量的函数。这立即被析构为<strong class="bd mt">计数</strong>状态和<strong class="bd mt">设置计数</strong>功能。</p><p id="b81f" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">它接受<strong class="bd mt"> initialValue </strong>作为参数，在创建时设置count变量的值。</p><p id="3cdf" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">现在我们可以使用<strong class="bd mt"> setCount </strong>来改变状态。在设置状态时，您可以简单地传入一个值，或者像在本例中一样，您可以使用以前的状态作为函数中的参数。</p><p id="8972" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">知道了这一点，我们可以添加一个函数来增加状态值。</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="7d34" class="ni jh hu ne b fv nj nk l nl nm">export function Count({ initialValue }) {</span><span id="7957" class="ni jh hu ne b fv nq nk l nl nm">   const [count, setCount] = useState (initialValue)<br/>   <br/>   const increment = () =&gt; {<br/>      setCount(prevState =&gt; prevState + 1);<br/>   };<!-- --> </span><span id="a220" class="ni jh hu ne b fv nq nk l nl nm">   return &lt;div&gt;{initialValue}&lt;/div&gt;;<br/>}</span></pre><p id="7ed2" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们可以对减量函数做同样的事情。</p><p id="d96b" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">现在我们需要更新JSX来呈现我们的应用程序所需的HTML:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="2939" class="ni jh hu ne b fv nj nk l nl nm">export function Count({ initialValue }) {<br/>    const [count, setCount] = useState (initialValue)</span><span id="662c" class="ni jh hu ne b fv nq nk l nl nm">    const increment = () =&gt; {<br/>         setCount(prevState =&gt; prevState + 1);<br/>    };</span><span id="7f01" class="ni jh hu ne b fv nq nk l nl nm">    const decrement = () =&gt; {<br/>        setCount(prevState =&gt; prevState - 1);<br/>    };</span><span id="7560" class="ni jh hu ne b fv nq nk l nl nm">    return (<br/>        &lt;div&gt;<br/>              &lt;p&gt;{count}&lt;/p&gt;<br/>              &lt;button onClick={increment}&gt;+&lt;/button&gt;<br/>              &lt;button onClick={decrement}&gt;-&lt;/button&gt;<br/>       &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="78ca" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">当我们运行我们的应用程序时，我们现在可以增加和减少<strong class="bd mt">状态</strong>中的值，它显示在小部件中:</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/5eeb8155e09a0c5391a6d94f32d946a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/0*eNf9AGh9JCyrVtVz.png"/></div></figure><p id="df89" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">将随机颜色变化添加到数字</strong></p><p id="c7c6" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们现在想在计数改变时生成一个随机颜色。这将是一段耗时的代码，幸运的是，我们可以使用存储在npm注册表中的预写软件包:<strong class="bd mt"> randomcolor </strong>。</p><div class="lb lc fm fo ld le"><a href="https://www.npmjs.com/package/randomcolor" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">随机颜色</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">一个生成吸引人的随机颜色的小脚本。查看演示以获得解释和一些示例。randomColor…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">www.npmjs.com</p></div></div><div class="ls l"><div class="ny l lu lv lw ls lx ja le"/></div></div></a></div><p id="027e" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">这个包提供了一个函数，当调用这个函数时，它以字符串的形式返回一个随机颜色。利用这个包很容易:首先，我们通过运行widget文件夹中的<code class="eh nu nv nw ne b">npm install randomcolor</code>来安装这个包。</p><p id="2c8f" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">然后我们开始改变计数文件中的代码。首先，我们导入函数</p><p id="44fc" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><code class="eh nu nv nw ne b">import randomColor from 'randomcolor';</code></p><p id="92b4" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">然后我们需要初始化一些状态来保存我们的颜色属性</p><p id="0bac" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><code class="eh nu nv nw ne b">const [colour, setColour] = useState('')</code></p><p id="ade4" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">我们还需要颜色反映在小部件的样式中。为此，我们可以使用HTML标签的样式属性。style属性接受一个JS对象，该对象带有您希望应用的样式属性。</p><blockquote class="mu mv mw"><p id="8825" class="ke kf mx bd b kg ln ki kj kk lo km kn my lp kq kr mz lq ku kv na lr ky kz la hn dt translated">点击这里，阅读更多关于使用React <a class="ae nt" href="https://reactjs.org/docs/dom-elements.html#style" rel="noopener ugc nofollow" target="_blank">设计Dom元素样式的信息。</a></p></blockquote><p id="c0a3" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><code class="eh nu nv nw ne b">&lt;p style={{ color: colour }}&gt;{count}&lt;/p&gt;</code></p><p id="a21b" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">在这里，我们可以通过使用内置的Mendix类来改进按钮的外观:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="a3c2" class="ni jh hu ne b fv nj nk l nl nm">import { createElement, useState } from 'react'<br/>import randomColor from 'randomcolor'</span><span id="82af" class="ni jh hu ne b fv nq nk l nl nm">export function Count({ initialValue }) {<br/>  const [count, setCount] = useState(initialValue)<br/>  const [colour, setColour] = useState('')<br/>  <br/>  const increment = () =&gt; {<br/>    setCount((prevState) =&gt; prevState + 1)<br/>  }<br/>  <br/>  const decrement = () =&gt; {<br/>    setCount((prevState) =&gt; prevState - 1)<br/>  }<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p style={{ color: colour }}&gt;{count}&lt;/p&gt;<br/>      &lt;button className="mx-button btn-primary" onClick={increment}&gt;<br/>        +<br/>      &lt;/button&gt;<br/>      &lt;button className="mx-button" onClick={decrement}&gt;<br/>        -<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )</span></pre><p id="ce6c" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">当计数变量改变时，我们现在需要触发颜色的改变。为此，我们可以使用React中可用的关键实用程序之一:<strong class="bd mt"> useEffect </strong>。</p><p id="540f" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt"> useEffect </strong>是一个钩子，在组件的每次渲染上调用一个函数(副作用)。通过添加以下内容，我们可以在渲染时将颜色设置为随机值:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="c194" class="ni jh hu ne b fv nj nk l nl nm">import { createElement, useState } from 'react'<br/>import randomColor from 'randomcolor'</span><span id="4677" class="ni jh hu ne b fv nq nk l nl nm">export function Count({ initialValue }) {<br/>  const [count, setCount] = useState(initialValue)<br/>  const [colour, setColour] = useState('')<br/>  <br/>  useEffect(() =&gt; {<br/>    setColour(randomColor())<br/>  }, [])<br/>  <br/>  const increment = () =&gt; {<br/>    setCount((prevState) =&gt; prevState + 1)<br/>  }<br/>  <br/>  const decrement = () =&gt; {<br/>    setCount((prevState) =&gt; prevState - 1)<br/>  }<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p style={{ color: colour }}&gt;{count}&lt;/p&gt;<br/>      &lt;button className="mx-button btn-primary" onClick={increment}&gt;<br/>        +<br/>      &lt;/button&gt;<br/>      &lt;button className="mx-button" onClick={decrement}&gt;<br/>        -<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/></span></pre><p id="2143" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">当我们在浏览器中运行时，我们得到…迪斯科计数！</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/69e9172fb2bdbc5441fda326049f3739.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/0*BLJ0yH2qG7Mv2xph.gif"/></div></figure><p id="3e35" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">这很酷，但绝对不是我们想要的。那么，为什么会出现这种情况呢？</p><p id="b16f" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">如果我们把console.log('Render ')放在useEffect中，我们可以看到组件在重复地重新呈现，这是因为组件在任何状态或道具改变时都会重新呈现。因此，当我们在useEffect <strong class="bd mt">中设置颜色状态时，会导致重新渲染和无限循环</strong>。</p><p id="aa46" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">幸运的是，这很容易解决。useEffect钩子接受第二个参数，这是一个要观察的状态和/或道具的数组。这意味着该功能将只在其中一个被监视的状态/道具改变时运行。我们只希望颜色在计数改变时改变，因此我们将useEffect更新为:</p><pre class="mn mo mp mq fq nd ne nf ng aw nh dt"><span id="2417" class="ni jh hu ne b fv nj nk l nl nm">useEffect(() =&gt; {<br/>    setColour(randomColor())<br/>  }, [count])</span></pre><p id="9dd9" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><em class="mx">注意:为了只运行一次useEffect，在组件加载时添加一个空数组作为第二个参数</em></p><p id="d75b" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">现在，当我们更新我们的小工具…瞧！</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/c2d7b5d4e8cec6c7e5c5b68473ed3140.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/0*I0YgsbTVXqlN7Cd0.gif"/></div></figure><h1 id="74fe" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">概述</h1><p id="db3f" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">在这篇博客中，我们介绍了如何在Mendix中使用可插拔的小部件，如何设置您的开发环境以及一些核心的React概念，包括状态、道具和useEffect。</p><p id="652d" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">小部件的最终代码可以在这里找到:</p><div class="lb lc fm fo ld le"><a href="https://github.com/joe-robertson-mx/colourCount" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">GitHub -乔-罗伯逊-mx/colourCount</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">伴随ColourCount插件的一个小部件，可以增加或减少一个计数器…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">github.com</p></div></div><div class="ls l"><div class="mr l lu lv lw ls lx ja le"/></div></div></a></div><h1 id="773a" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">接下来呢？</h1><p id="28ca" class="pw-post-body-paragraph ke kf hu bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hn dt translated">接下来，我们将开始使用Typescript，直接与Mendix实体和属性集成，并看看如何从我们的小部件触发Mendix模型中的操作。</p><p id="e157" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">让我们知道你对这篇文章的看法。有你想看的小配件吗？请在这里的评论中提出对未来小工具的任何建议。</p><p id="5318" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated"><strong class="bd mt">资源</strong></p><p id="cc6d" class="pw-post-body-paragraph ke kf hu bd b kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw lr ky kz la hn dt translated">要了解有关可插拔小部件的更多信息，以下资源可能会有所帮助:</p><div class="lb lc fm fo ld le"><a href="https://reactjs.org/docs/getting-started.html" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">开始行动-做出反应</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">用于构建用户界面的JavaScript库</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">reactjs.org</p></div></div><div class="ls l"><div class="nz l lu lv lw ls lx ja le"/></div></div></a></div><div class="lb lc fm fo ld le"><a href="https://docs.mendix.com/howto/extensibility/pluggable-widgets/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">构建可插入的Web小部件</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">可插拔web小部件是Mendix基于React定制的小部件。这种语言允许你定制部件…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="lb lc fm fo ld le"><a href="https://github.com/mendix/widgets-resources/tree/master/packages/pluggableWidgets" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">widgets-resources/packages/pluggableWidgets at master mendix/widgets-resources</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">Mendix平台支持的小部件的Mono存储库-小部件-资源/包/可插拔的widget at master…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">github.com</p></div></div><div class="ls l"><div class="oa l lu lv lw ls lx ja le"/></div></div></a></div></div></div>    
</body>
</html>