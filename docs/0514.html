<html>
<head>
<title>LiveData with Coroutines and Flow — Part III: LiveData and coroutines patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有协程和流程的LiveData——第三部分:LiveData和协程模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-iii-livedata-and-coroutines-patterns-592485a4a85a?source=collection_archive---------0-----------------------#2020-07-13">https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-iii-livedata-and-coroutines-patterns-592485a4a85a?source=collection_archive---------0-----------------------#2020-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/948170b74bfd574483cc861a75a26f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhMDChty1gzkEUQxhc4hWw.jpeg"/></div></div></figure><div class=""/><p id="0ca1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是我在2019年Android Dev峰会上与Yigit Boyar的谈话摘要的第三部分。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">LiveData with Coroutines and Flow (ADS 2019)</figcaption></figure><p id="d560" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/b20f676d25d7">第一部分:反应式用户界面</a></p><p id="3132" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/337909f37ae7">第二部分:使用架构组件启动协程</a></p><p id="05cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第三部分:LiveData和协程模式(本文)</p><h1 id="f87e" class="jy jz hs bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">视图模型模式</h1><p id="e027" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">让我们来看一些可以在视图模型中使用的模式，比较LiveData和流的使用情况:</p><h2 id="9a1c" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">LiveData:发出N个值作为LiveData</h2><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="55a0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们不做任何转换，我们可以简单地将一个分配给另一个。</p><h2 id="b4d4" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">流:将N个值作为LiveData发出</h2><p id="cde2" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">我们<em class="lq">可以</em>结合使用<code class="du lr ls lt lu b">liveData</code>协程构建器和<strong class="ir ht">收集流上的</strong>(这是一个接收每个发出值的终端操作符):</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="632b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是因为有很多样板文件，我们添加了<code class="du lr ls lt lu b"><a class="ae jx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(kotlinx.coroutines.flow.Flow).asLiveData(kotlin.coroutines.CoroutineContext,%20kotlin.Long)" rel="noopener ugc nofollow" target="_blank">Flow.asLiveData()</a></code>扩展函数，它在一行中做了同样的事情:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><h2 id="039d" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">LiveData:从数据源发出1个初始值+ N个值</h2><p id="8eb2" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">如果数据源公开了一个LiveData，我们可以使用emitSource在用emit发出一个初始值后通过管道进行更新:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><h2 id="9136" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">流程:从数据源发出1个初始值+ N个值</h2><p id="4bc5" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">同样，我们可以天真地这样做:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="519e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，如果我们利用Flow自己的API，事情看起来要整洁得多:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="d839" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lr ls lt lu b">onStart</code>设置初始值，这样我们只需要转换到LiveData一次。</p><h2 id="6cc8" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">LiveData:暂停转换</h2><p id="b3c2" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">假设您想要转换来自数据源的东西，但是它可能占用大量CPU资源，所以它在一个挂起函数中。</p><p id="ea48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在数据源的LiveData上使用<code class="du lr ls lt lu b">switchMap</code>,然后用<code class="du lr ls lt lu b">liveData</code>构建器创建协程。现在，您可以对收到的每个结果调用emit。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><h2 id="0d30" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">流程:暂停转换</h2><p id="b0af" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">与LiveData相比，这是Flow真正闪光的地方。同样，我们可以使用Flow的API来更优雅地做事情。在这种情况下，我们使用<code class="du lr ls lt lu b"><a class="ae jx" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" rel="noopener ugc nofollow" target="_blank">Flow.map</a></code>在每次更新时应用转换。这一次，因为我们已经在协程上下文中，我们可以直接调用它:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><h1 id="cb42" class="jy jz hs bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">存储库模式</h1><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/aa496af1d1babe4c9d737293a1cecb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CmrV0qtLWgq1c2jR"/></div></div></figure><p id="6566" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于存储库就不多说了，就好像您正在消费一个流并公开一个流，您只需使用<a class="ae jx" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank">流API </a>来转换和组合数据:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><h1 id="a677" class="jy jz hs bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">数据源模式</h1><p id="3545" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">同样，让我们区分一下一次性操作和流程。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/1a0b7cebfe0b0b04ec5464b002a6a6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6mXVmaqmXnm5n6YR"/></div></div></figure><h2 id="a5e4" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">数据源中的一次性操作</h2><p id="7b09" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">如果你正在使用一个支持挂起功能的库，比如Room或retrieve，你可以简单地从你的挂起功能中使用它们！</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="9475" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，一些工具和库还不支持协程，并且是基于回调的。</p><p id="3f99" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，您可以使用<code class="du lr ls lt lu b"><a class="ae jx" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/suspend-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCoroutine</a></code>或<code class="du lr ls lt lu b"><a class="ae jx" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>。</p><p id="61c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(我不知道你为什么想要使用不可取消的版本，请在评论中告诉我！)</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="70e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你调用它时，你得到一个<code class="du lr ls lt lu b">continuation</code>。在这个例子中，我们使用一个API，让我们设置一个<em class="lq">完成</em>监听器和一个<em class="lq">失败</em>监听器，所以在它们的回调中，当我们收到数据或错误时，我们调用<code class="du lr ls lt lu b">continuation.resume</code>或<code class="du lr ls lt lu b">continuation.resumeWithException</code>。</p><p id="18d4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是要注意，如果这个协程被取消，<code class="du lr ls lt lu b">resume</code>将被忽略，所以如果你的请求花费了很长时间，协程将是活动的，直到其中一个回调被执行。</p><h2 id="3f66" class="lb jz hs bd ka lc ld le ke lf lg lh ki ja li lj km je lk ll kq ji lm ln ku lo bi translated">公开数据源中的流</h2><p id="e0f7" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated"><strong class="ir ht">流程构建器</strong></p><p id="8e1b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你需要创建一个数据源的伪实现，或者你只是需要一些简单的东西，你可以使用<code class="du lr ls lt lu b">flow</code>构造函数，做一些像这样的事情:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="4da3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该代码每两秒钟发出一次天气状况。</p><p id="a4e1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">基于回调的API</strong></p><p id="fbc9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果想将基于回调的API转换成流，可以使用<code class="du lr ls lt lu b">callbackFlow</code>。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="6c6c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这看起来令人生畏，但如果你把它拆开，你会发现它很有意义。</p><ul class=""><li id="31f9" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated">当我们有新的价值时，我们称之为报价</li><li id="d84e" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">我们称之为亲密(因为？)当我们想停止发送更新时</li><li id="6a29" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">我们使用awaitClose来定义当流关闭时需要执行什么，这对于取消注册回调来说是完美的。</li></ul></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="9443" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总之，协程和流已经存在了！但它们并不能在任何地方取代LiveData。即使有非常有前途的<a class="ae jx" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/" rel="noopener ugc nofollow" target="_blank"> StateFlow </a>(目前是实验性的)我们仍然有Java编程语言和数据绑定的用户来支持，所以暂时不会被弃用:)</p><p id="965a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想了解更多信息，请点击以下链接:</p><ul class=""><li id="d28b" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb"> Sean的协程系列文章</a></li><li id="9402" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/lessons-learnt-using-coroutines-flow-4a6b285c0d06"> Manu的经验教训</a>将Android开发峰会迁移到协同程序(包括Flow)</li></ul><p id="b59b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我关于LiveData的其他博客文章</p><ul class=""><li id="0372" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/unit-testing-livedata-and-other-common-observability-problems-bb477262eb04">https://medium . com/Android developers/unit-testing-livedata-and-other-common-observability-problems-bb 477262 EB 04</a></li><li id="c1f7" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7">https://medium . com/Android developers/livedata-beyond-the-view model-reactive-patterns-using-transformations-and-mediatorlivedata-FDA 520 ba 00 b 7</a></li><li id="27a2" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">https://medium . com/Android developers/livedata-with-snack bar-navigation-and-other-events-the-singliveevent-case-AC 2622673150</a></li><li id="e2c7" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae jx" rel="noopener" href="/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54">https://medium . com/Android developers/view models-and-livedata-patterns-anti patterns-21 efaef 74 a 54</a></li></ul></div></div>    
</body>
</html>