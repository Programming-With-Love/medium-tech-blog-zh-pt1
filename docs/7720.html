<html>
<head>
<title>Primer on Front End Automation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端自动化入门</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/primer-on-front-end-automation-a9eee2c6bc1?source=collection_archive---------1-----------------------#2018-07-27">https://medium.com/walmartglobaltech/primer-on-front-end-automation-a9eee2c6bc1?source=collection_archive---------1-----------------------#2018-07-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3e049900f938348c2a7d7c5537eb9378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci5W1OycvqfaS1LbIYXFLw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Courtesy Pixabay: <a class="ae hu" href="https://pixabay.com/en/cog-wheels-gear-wheel-machine-2125169/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/en/cog-wheels-gear-wheel-machine-2125169/</a></figcaption></figure><div class=""/><p id="af8f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自动化测试是一项专门的工作，由熟悉相关框架的QE工程师来完成。在我的团队中，今年我们有一个雄心勃勃的目标，让开发人员编写这些自动化测试作为开发过程的一部分，从而使测试覆盖率(单元和自动化)成为代码质量的一个度量。</p><p id="a927" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为沃尔玛前端团队中的一名开发人员，我对自动化设置和开发流程一无所知，我正在分享我如何着手设置自动化代码库并执行它的经验。我的团队致力于沃尔玛的在线退货体验，我们的前端响应web框架使用了由沃尔玛开源的框架<a class="ae hu" href="http://www.electrode.io/" rel="noopener ugc nofollow" target="_blank">电极</a>，用于大规模前端开发，移动应用体验使用了<a class="ae hu" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank"> React Native </a>。这篇文章围绕WalmartLabs使用的框架展开，主要面向进入自动化测试开发的开发人员。</p><h1 id="0e39" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">首先是框架</h1><p id="6468" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">自动化在沃尔玛实验室已经存在一段时间了，我们有一个很棒的团队致力于开发工具(<a class="ae hu" href="http://testarmada.io/" rel="noopener ugc nofollow" target="_blank"> TestArmada </a>)。所以我真的不需要走很远就能找到我需要使用的工具。对于那些对自动化世界完全陌生的人来说，知道Selenium是最普遍的测试自动化框架(开始于ThoughtWorks，后来由Google增强)和许多各种语言的工具都是在top Selenium的web驱动程序API上开发的是很有用的。</p><p id="59d9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Selenium  —它是一个基于Java的服务器，实现了WebDriver协议(这是一个基于Rest的协议，接收在浏览器上执行的命令)。服务器产生单独的进程，这些进程启动启用了远程调试的浏览器，并通过该浏览器向浏览器发出命令。</p><p id="c4f8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://github.com/TestArmada/magellan" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Magellan </strong> </a> —这是并行运行测试的测试运行程序。与KarmaJS 相似的是，运行测试与实际定义测试是分开的。Magellan的工作方式是找到文件或标签，并产生新的工作进程来处理这些测试。每个文件都是一个新的测试用例，将在一个工人内部执行。工作环境是每个测试的沙箱。根据所提供的设置，它可以以并行或串行模式工作。</p><p id="b9a7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="http://nightwatchjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> NightwatchJS </strong> </a> —是BDD框架，它抽象出了Seleniums webdriver apis，并提供了定义测试的框架。它支持一种被称为<a class="ae hu" href="https://github.com/nightwatchjs/nightwatch/wiki/Page-Object-API" rel="noopener ugc nofollow" target="_blank">页面对象模型</a>的设计模式，通过这种模式，一个HTML页面或移动页面可以被抽象为带有<code class="du kv kw kx ky b">commands</code>、<code class="du kv kw kx ky b">sections</code>、<code class="du kv kw kx ky b">elements</code>和<code class="du kv kw kx ky b">pages</code>的页面片段。</p><p id="90bc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="http://appium.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Appium </strong> </a> —是手机app测试的硒当量。Nightwatch使用Appium与移动设备进行交互。Appium实现了Web驱动规范，使其与任何使用Web驱动api的客户端兼容。</p><p id="2ff0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://www.npmjs.com/package/shifu" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> Shifu </strong> </a> —是一个用<a class="ae hu" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank"> HapiJS </a>作为插件开发的嘲讽框架。它本质上提供了一种简单的方法来检测和配置特定URI路由的模拟。对于本地或开发端到端测试，您可能希望从模仿webapp的所有依赖下游服务开始。因此，当您启动自动化设置时，您也启动了一个模拟服务器，它将处理您所有的下游api调用并返回一个模拟响应。Shifu很酷的一点是它有一个会话的概念，允许在每个会话中为一条路由发送不同的响应。您可以通过为会话调用变量来实现这一点。变体是对同一路线的不同响应，标记不同。<code class="du kv kw kx ky b">shifu-magellan-nightwatch</code> npm模块已经与Shifu进行了开箱即用的集成，因此它可以很容易地插入到您的自动化设置中。</p><h1 id="e901" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">页面对象模型</h1><ul class=""><li id="913d" class="kz la hx iw b ix kq jb kr jf lb jj lc jn ld jr le lf lg lh bi translated">元素—这些是您将使用CSS或XPath查询选择器在页面上查询的元素的逻辑占位符</li></ul><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">elements</figcaption></figure><ul class=""><li id="a436" class="kz la hx iw b ix iy jb jc jf lo jj lp jn lq jr le lf lg lh bi translated">命令——这些是作用于元素的抽象概念</li></ul><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">commands</figcaption></figure><ul class=""><li id="2306" class="kz la hx iw b ix iy jb jc jf lo jj lp jn lq jr le lf lg lh bi translated">页面—页面由页面对象可用的元素和命令组成。</li></ul><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">page</figcaption></figure><h1 id="67c7" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">我们场景中的演员</h1><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/768c988c3774f60635956e0ab4fa2c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5_AIgSD-wdnCLhE2GZo3Q.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Entities in an automation</figcaption></figure><blockquote class="ls lt lu"><p id="a3a1" class="iu iv lv iw b ix iy iz ja jb jc jd je lw jg jh ji lx jk jl jm ly jo jp jq jr ha bi translated">关于演员的说明</p></blockquote><ol class=""><li id="c46b" class="kz la hx iw b ix iy jb jc jf lo jj lp jn lq jr lz lf lg lh bi translated">模拟服务是可选的——您也可以在现场或生产前设置上进行自动化测试</li><li id="96b2" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">每个自动化测试都在它自己的沙箱中运行，沙箱在那个进程空间中启动一个Webapp。</li><li id="db99" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">整个设置可以在一台本地机器上运行，也可以分布在网络上。您可以在本地机器上执行测试，与远程selenium服务器对话，后者从另一个域加载webapps。</li></ol><h1 id="a293" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设置它</h1><p id="8a43" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">因此，如果您正在自动化一个完整的前端应用程序，您需要能够加载页面，单击元素，设置输入值，单击按钮，断言元素值等。从一开始，为元素提供一个<code class="du kv kw kx ky b">data-automation-id</code>或类似的标识符是一个好主意，这样就不必依赖于CSS和元素id。此外，在动态生成元素的地方(比如网格或列表)，如果网格上的所有元素都有相同的类属性，那么使用CSS父子层次结构选择元素几乎是不可能的。在幕后，Selenium使用<code class="du kv kw kx ky b">document.querySelectorAll </code>来获取元素并断言这些元素。如果您没有唯一id或css选择器，当查询有多个匹配项时，它将返回一个列表。在这种情况下，单击元素将不起作用，Nightwatch Extra将给出一个类似于</p><pre class="li lj lk ll fd mf ky mg mh aw mi bi"><span id="7ea0" class="mj jt hx ky b fi mk ml l mm mn">21:39:35 [WARN] [Nightwatch Extra] getEl saw selector .new-order-item-select-container but result length was 26, with 26 of those :visible</span></pre><p id="cdf8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦您的前端页面为自动化做好了准备，您就可以开始定义一个文件夹结构来保存您的自动化测试。我们把这个放在<code class="du kv kw kx ky b">project_root/test/automation</code>名下。</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="2cd6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们遵循的示例文件夹结构—这只是指示性的。只要页面找到了它的<code class="du kv kw kx ky b">elements</code>和<code class="du kv kw kx ky b">commands</code>——它应该可以正常工作。</p><pre class="li lj lk ll fd mf ky mg mh aw mi bi"><span id="7786" class="mj jt hx ky b fi mk ml l mm mn">project_root/test/automation<br/>--conf (for configuration files)<br/>--lib (for pageobject models)<br/>---pages<br/>   ----commands<br/>   ----elements<br/>   ----sections</span><span id="246a" class="mj jt hx ky b fi mv ml l mm mn">--mocks (for mocks if applicable)<br/>--scripts (bash/csh scripts for command line)<br/>--tests (where the actual tests are)<br/></span></pre><p id="0ae2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是实现这一点所需的npm依赖项(在<code class="du kv kw kx ky b">optionalDependencies</code>下配置)。</p><pre class="li lj lk ll fd mf ky mg mh aw mi bi"><span id="181e" class="mj jt hx ky b fi mk ml l mm mn">"async": "0.9.2",<br/>"chromedriver": "2.35.0",<br/>"config": "1.30.0",<br/>"dpro": "1.2.0",<br/>"event-stream": "3.3.4",<br/>"jsonlint": "1.6.2",<br/>"nightwatch": "0.9.9",<br/>"phantomjs": "^2.1.7",<br/>"phantomjs-prebuilt": "2.1.16",<br/>"ps-tree": "1.1.0",<br/>"selenium-server": "3.9.1",<br/>"testarmada-magellan": "10.1.1",<br/>"testarmada-magellan-admiral-plugin": "^3.0.0",<br/>"testarmada-magellan-local-executor": "2.0.0",<br/>"testarmada-magellan-nightwatch-plugin": "7.0.0",<br/>"testarmada-nightwatch-extra": "5.0.0",<br/>"testarmada-renv": "4.1.0",<br/>"webpack-dev-server": "1.16.2"</span></pre></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="66f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">两个最重要的配置文件是</p><p id="5da2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> magellan.json </strong> —描述magellan应该如何执行。Magellan提供了生命周期挂钩，我们可以从这里添加引导代码来启动Webapp和mocks(如果需要的话)——这在<code class="du kv kw kx ky b">setup_teardown</code>中定义。</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">magellan.json — snippet</figcaption></figure><p id="d2ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> nightwatch.json </strong> —描述测试和selenium应该如何交互。</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">nightwatch.json</figcaption></figure><p id="199f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lv">关于Nightwatch.json的说明</em></p><ol class=""><li id="271b" class="kz la hx iw b ix iy jb jc jf lo jj lp jn lq jr lz lf lg lh bi translated">src文件夹—指示测试所在的目录</li><li id="e666" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">输出文件夹—用于测试运行报告</li><li id="f4ad" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">custom_commands_path —指示页面对象命令所在的文件夹—可选，具体取决于是否将其分离出来</li><li id="332a" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">custom_assertions_path —指示自定义断言(如果有)的路径—根据它们是否是自定义断言而可选</li><li id="88f1" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">页面对象路径—页面对象所在的目录</li><li id="65d9" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">全局路径—任何全局变量文件所在的页面</li><li id="3a70" class="kz la hx iw b ix ma jb mb jf mc jj md jn me jr lz lf lg lh bi translated">selenium配置— selenium服务器和驱动程序配置</li></ol><h1 id="91b0" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试！</h1><p id="aee2" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">这个测试是用BDD风格函数编写的<code class="du kv kw kx ky b">BaseTest</code>的一个实例。</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample Test</figcaption></figure><h1 id="44b7" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试继承</h1><p id="9f00" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们可以向测试对象添加额外的功能，通过继承测试并向其原型添加功能。这对于在所有测试中使用一些公共函数是很有用的。此外，测试原型具有可以被覆盖的<code class="du kv kw kx ky b">before</code>、<code class="du kv kw kx ky b">beforeEach</code>、<code class="du kv kw kx ky b">afterEach</code>和<code class="du kv kw kx ky b">after</code>功能。</p><h1 id="c3c2" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">调试测试失败</h1><p id="c98a" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">如果测试失败，并且您不确定原因，您可以通过安装Chrome的Selenium IDE插件来验证CSS查询选择器的正确性，并从那里运行测试。所有的WebDriver api调用都是异步的。因此检查调用的结果有助于验证测试的正确性。</p><h1 id="c936" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">使用SauceLabs进行大规模测试</h1><p id="4a32" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">测试大量的并行测试需要本地工作站可能无法满足的基础设施和资源。在沃尔玛，我们使用SauceLabs进行测试，作为CI CD渠道的一部分。这是一个托管平台，您可以在其上运行测试。</p><h1 id="19db" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后</h1><p id="9799" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在WalmartLabs，我们将自动化测试作为开发的首要要求，开发人员将为他们开发的每个功能添加自动化测试用例。这需要一种正在形成势头的文化转变。希望这篇文章有助于理解底层组件如何协同工作，并为自动化测试提供一个快速的引导指南。</p></div></div>    
</body>
</html>