<html>
<head>
<title>The Futures Are Now — iOS and Asynchronous Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">未来是现在——iOS和异步开发</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/the-futures-are-now-ios-and-asynchronous-development-88a317047b47?source=collection_archive---------1-----------------------#2016-11-21">https://medium.com/capital-one-tech/the-futures-are-now-ios-and-asynchronous-development-88a317047b47?source=collection_archive---------1-----------------------#2016-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cc9092e9d0b3de774c1e52fcbf893fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpE1FLhOEhkWQUPWoqGyEw.jpeg"/></div></div></figure><p id="7213" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在编程中，我们经常遇到异步操作。这可能包括网络、文件系统、数据库、UI、长时间运行的任务或任何其他I/O事件。在iOS中，我们有许多机制来处理这个问题，包括GCD、NSOperation、NSNotifications、delegates和callbacks。</p><p id="0984" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个在iOS上不太常见的构造——但在JavaScript和Scala等其他语言中非常成熟和常见——是期货。也称为承诺、延期、任务或异步；这种技术允许您以同步方式处理异步值，将连续传递样式的调用切换为直接样式。通过使用futures，你的程序将更容易推理，因为不会有太多的嵌套调用。</p><p id="b40e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是未来到底是什么？未来是一个还不存在的价值的表示。当你处理未来的时候，你不会知道这个值当前是否可用。但是，您可以像使用该值一样使用它。一旦该值变得可用，未来将处理您的指令。</p><h2 id="110a" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">未来的框架</h2><p id="67b2" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">如果你想在你的iOS应用中开始使用期货，你有几个不同的第三方库可供选择，包括:</p><p id="dec8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">-</strong><a class="ae kn" href="https://github.com/Thomvis/BrightFutures" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a></p><p id="bc00" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">-</strong><a class="ae kn" href="https://github.com/mxcl/PromiseKit" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">promise kit</strong></a></p><p id="6d44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">-</strong><a class="ae kn" href="https://github.com/FutureKit/FutureKit" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">future kit</strong></a></p><p id="78f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">——</strong>——<a class="ae kn" href="https://github.com/bignerdranch/Deferred" rel="noopener ugc nofollow" target="_blank">——<strong class="ir hi">——</strong>——</a></p><p id="4b55" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">-</strong>-<a class="ae kn" href="https://github.com/BoltsFramework" rel="noopener ugc nofollow" target="_blank">-<strong class="ir hi">螺栓</strong>-</a></p><p id="68c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据您选择的库，您将有不同的设计选择。例如，Big Nerd Ranch的Deferred library的灵感来自OCaml的Deferred。这意味着future/deferred值并没有说明异步操作是否已经失败。要表示失败，您需要通过返回结果类型或类似的关联枚举来将其表示为值的一部分。BrightFutures遵循Scala的承诺和未来，因此有一个隐含的理解，即每个未来都可能失败。FutureKit和Bolts还包含一个“取消”状态，表示用户取消了未来/任务，不再关心结果。</p><p id="40fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些库可能有不同的方法和设计目标；然而，它们都解决了同一个问题，即提供一个接口来表示和处理异步结果。它们也都处理一些常见的任务，比如一起排序期货、并行运行期货以及在特定线程上处理结果。</p><p id="b1bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以让我们开始吧。</p><h2 id="f948" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">只是最基本的</h2><p id="dd7b" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">使用期货最基本的方法是设置一个完成处理程序。这只是允许您在值可用时执行一个操作。要设置处理程序，您可以通过调用<em class="ko">on success</em>(bright futures/FutureKit)、<em class="ko">on</em>(Deferred)、<em class="ko"> then </em> (PromiseKit)或<em class="ko">continue onSuccess with</em>(Bolts)来设置未来的延续函数。这些框架中的大多数还允许您通过调用<em class="ko"> onFailure </em> (BrightFutures)、<em class="ko"> onError </em> (FutureKit)或<em class="ko"> catch </em> (PromiseKit)来附加一个错误处理程序。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="7236" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这应该感觉类似于只使用回调来处理异步任务。这里的主要区别是您仍然有一个userFuture <em class="ko"> </em>对象，您可以对其执行进一步的处理，比如添加更多的完成处理程序或者传递给另一个函数或组件。</p><h2 id="fe8f" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">用未来绘制地图</h2><p id="48a5" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">当处理期货时，我们可以传递未来，而不需要用回调来处理价值。假设我们有一种类型的未来(比如<em class="ko"> Future &lt; JSON &gt; </em>)，但是我们需要另一种类型的未来(比如<em class="ko"> Future &lt; User </em> &gt;)。如果我们有一个函数可以将第一个内部类型(JSON)转换成第二个内部类型(<em class="ko">用户</em>)，我们可以在<em class="ko">未来&lt; JSON &gt; </em>上调用map，传入映射函数得到一个<em class="ko">未来&lt;用户&gt;。</em></p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="1720" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">测序未来</h2><p id="7b9d" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">在处理多个未来的时候，有时候你会需要一个未来的结果来得到另一个未来。例如，如果您需要在获取用户地址之前查找用户，您可能需要像这样连接两个请求:</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="28b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这是正确的，但是请注意您的主逻辑将如何嵌套在两个完成块中。还要注意如果getUser调用失败，我们将无法运行getAddress。这种链接或排序期货的行为非常常见，期货上有一个函数可以调用来完成这一操作。该函数或者被命名为<em class="ko">flat map</em>(bright futures/Deferred)，<em class="ko"> then </em> (PromiseKit)，<em class="ko">continueWithTask</em>(Bolts)，或者<em class="ko"> onSuccess </em> (FutureKit)。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="59c8" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">并行的未来</h2><p id="9b54" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">另一种常见的情况是，当你有多个相互不依赖的期货时，你需要所有的值才能继续。大多数未来框架都有一个功能，将一组未来转换成一个包含一组价值的未来。如果所有的期货都成功，新的期货将返回一个包含所有期货值的数组。这个函数被称为<em class="ko">序列</em>(光明未来)<em class="ko">任务.当所有</em>(螺栓)<em class="ko">加入值</em>(延迟)或<em class="ko">当</em>(承诺)。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="8c06" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">多个异步值</h2><p id="7a83" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">虽然未来是伟大的，但它们并不适合每一种异步处理。例如，如果你想开发一个聊天应用，你需要处理来自其他用户的无限多的消息。在这种情况下，需要一个反应式结构(如<em class="ko">信号、可观测信号、</em>或<em class="ko">流</em>)。它们类似于期货，除了它们提供一系列的值，而不仅仅是一个值。期货实际上可以被认为是一种特殊的信号，一种只返回一个值的信号。有关这方面的更多信息，请查看<a class="ae kn" href="https://github.com/ReactiveX/RxSwift/" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>或<a class="ae kn" href="https://github.com/ReactiveCocoa/ReactiveCocoa" rel="noopener ugc nofollow" target="_blank"> ReactiveCocoa </a>框架。</p><h2 id="f263" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">句法糖</h2><p id="d52e" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">另外需要注意的是，通过为Swift编程语言提供额外的关键字，我们可以使我们的代码看起来更像同步编程，同时保留异步编程的优势。C#和JavaScript已经用<em class="ko"> async/await </em>关键字做到了这一点。在Swift中可能是这样的:</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="dcc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ko">retrieve</em>实际上会返回一个<em class="ko"> Future &lt; Int？&gt; </em>，而<em class="ko"> retrieveUserFromDB </em>会返回一个<em class="ko">未来的&lt;用户吗？&gt;T25。通过使用await关键字，代码的其余部分变成异步的，并将一直等到retrieveAge返回，有效地将代码的其余部分放入如下所示的<em class="ko"> onSuccess </em>处理程序中:</em></p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="31b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意使用<em class="ko"> await </em>是如何隐藏期货正在被使用的事实，并使代码看起来像同步命令式编程，这应该为许多人所熟悉。</p><p id="6959" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">截至Swift 3，Swift尚不具备该功能。然而，根据swift-evolution邮件列表上的<a class="ae kn" href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" rel="noopener ugc nofollow" target="_blank">这条消息</a>，克里斯·拉特纳表示这可能是Swift 4 Stage 2的成果。所以希望我们最终能看到这一点。</p><h2 id="dc62" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">结论</h2><p id="0a8c" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">如果需要处理异步结果，期货是一个很好的构造。与简单的回调相比，它们有很多好处，因为您可以传递它们，并按顺序或并行地将它们组合在一起。目前，您必须使用第三方框架来获得这一功能，但是现在要了解未来，这样您的编程工具库中就有了这一工具。这样，您就可以为未来完全融入Swift编程语言做好准备。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><p id="5058" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ko">最初发表于</em><a class="ae kn" href="https://developer.capitalone.com/blog-post/the-futures-are-now-ios-and-asynchronous-development/" rel="noopener ugc nofollow" target="_blank"><em class="ko">【developer.capitalone.com】</em></a><em class="ko">。</em></p><p id="c3a7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ko">欲了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。</em><a class="ae kn" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://developer.capitalone.com/</em></a></p></div></div>    
</body>
</html>