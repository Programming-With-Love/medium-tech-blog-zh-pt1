<html>
<head>
<title>Android Architecture Components — LiveData (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android架构组件——LiveData(第1部分)</h1>
<blockquote>原文：<a href="https://medium.easyread.co/android-architecture-components-livedata-pt-1-133cad38e67e?source=collection_archive---------1-----------------------#2018-07-01">https://medium.easyread.co/android-architecture-components-livedata-pt-1-133cad38e67e?source=collection_archive---------1-----------------------#2018-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn"><div class="bz fp l di"><div class="jo jp l"/></div></figure><p id="51c0" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated"><strong class="js io"> LiveData </strong>是数据持有者。它能够被观察到，可以保存任何类型的数据，最重要的是，它还具有<em class="ko">生命周期意识。</em>这提供了一个<strong class="js io">异步机制</strong>来使用<strong class="js io">观察者模式提供数据变化。这是一个非常相似但非常简化的版本，是流行且非常强大的RxJava或RxKotlin的版本。最大的区别在于，LiveData<strong class="js io">尊重附加到</strong>的Android组件的生命周期，并且仅当组件处于“活动”状态时才交付数据更改。这种LiveData避免了内存泄漏、由于停止活动而导致的崩溃和其他问题。</strong></p><figure class="kr ks kt ku gt jn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/e22c76f486f518492f4b7e8177723b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*C-f2QtBVExDrkyPLNSa7xQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Architecture Component</figcaption></figure><p id="0994" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">LiveData有许多有趣特征</p><ul class=""><li id="ba64" class="lb lc in js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">当观察器被绑定到一个生命周期时，防止内存泄漏</li><li id="e9ce" class="lb lc in js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">防止由于停止活动而导致的崩溃</li><li id="674c" class="lb lc in js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">数据总是最新的</li><li id="6914" class="lb lc in js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">顺利处理配置更改</li><li id="6af3" class="lb lc in js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">使得资源共享成为可能</li><li id="1815" class="lb lc in js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">自动处理生命周期</li></ul><p id="acf5" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">这也有另一个隐含的好处<strong class="js io">你的代码变得更容易测试</strong>。您去掉了测试起来更复杂的组件，如果您使用<a class="ae kp" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>与活动进行通信，您可以在测试期间订阅它们并模拟所有可能的组合。Joe Birch写了一篇关于测试架构组件的好文章。</p><p id="2005" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">例:用科特林语写的</p><pre class="kr ks kt ku gt lp lq lr ls aw lt bi"><span id="48aa" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">private val fullname </strong>= MutableLiveData&lt;String&gt;()<br/><br/><em class="ko">// Called on app launch<br/></em><strong class="lq io">fun </strong>initNetworkRequest() {<br/>    <em class="ko">// expensive operation, e.g. network request<br/>    </em><strong class="lq io">fullname</strong>.<em class="ko">value </em>= <strong class="lq io">"Andriiginting"<br/></strong>}</span><span id="c92e" class="lu lv in lq b gy ma lx l ly lz"><strong class="lq io">fun </strong>getFullname(): LiveData&lt;String&gt; {<br/>    <strong class="lq io">return fullname<br/></strong>}</span><span id="9fdb" class="lu lv in lq b gy ma lx l ly lz"><em class="ko">// Called on Activity creation<br/></em>getFullname().observe(<strong class="lq io">this</strong>, <em class="ko">Observer </em><strong class="lq io">{ </strong>user <strong class="lq io">-&gt; </strong>Log.d(TAG, user) <strong class="lq io">}</strong>)</span></pre><p id="6149" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">让我们讨论一下代码片段</p><pre class="kr ks kt ku gt lp lq lr ls aw lt bi"><span id="5b3f" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">private val fullname </strong>= MutableLiveData&lt;String&gt;()</span></pre><p id="630e" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">val表示该变量不能被重新赋值或终结。Kotlin是强类型的，即每个变量都有一个显式类型。如果它可以被推断出来，那么你可以避免写它，就像这个例子。否则也可以写成:<br/><strong class="js io">val full name:</strong>mutable livedata&lt;String&gt;<strong class="js io"/>= mutable livedata&lt;String&gt;</p><pre class="kr ks kt ku gt lp lq lr ls aw lt bi"><span id="6603" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">fun </strong>getFullname(): LiveData&lt;String&gt; {<strong class="lq io">return fullname</strong>}</span></pre><p id="2a1e" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">在Kotlin单元中没有空类型。Kotlin足够聪明，可以将setter/getter放入这样的属性中</p><pre class="kr ks kt ku gt lp lq lr ls aw lt bi"><span id="b984" class="lu lv in lq b gy lw lx l ly lz">getFullname().observe(<strong class="lq io">this</strong>, <em class="ko">Observer </em><strong class="lq io">{ </strong>user <strong class="lq io">-&gt; </strong>Log.d(TAG, user) <strong class="lq io">}</strong>)</span></pre><p id="9419" class="pw-post-body-paragraph jq jr in js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ig bi translated">这里使用了一个匿名的Observer类，Kotlin会自动决定覆盖哪个方法(看一下Java代码来帮助你理解Kotlin在做什么)。</p><h1 id="2b79" class="mb lv in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">参考</h1><p id="8284" class="pw-post-body-paragraph jq jr in js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn ig bi translated"><a class="ae kp" href="https://developer.android.com/jetpack/docs/guide" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/docs/guide</a></p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><figure class="kr ks kt ku gt jn"><div class="bz fp l di"><div class="nk jp l"/></div></figure></div></div>    
</body>
</html>