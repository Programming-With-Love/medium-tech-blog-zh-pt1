<html>
<head>
<title>The Missing Introduction to React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应过来的缺失介绍</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76?source=collection_archive---------0-----------------------#2020-09-03">https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76?source=collection_archive---------0-----------------------#2020-09-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f9b4" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">为什么React是世界顶级UI框架</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/e955debb90e2bd0cc54bf245483edd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OL08Z0XE7lqqQxVybL1Yg.png"/></div></div></figure><p id="caf2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">React是世界上最流行的JavaScript框架，但它并不酷，因为它很流行。它流行是因为它很酷。大多数React介绍直接向您展示如何使用React的示例，并跳过“为什么”。</p><p id="3828" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">太酷了。如果您想立即开始使用React，官方文档中有很多资源可以帮助您<a class="ae ke" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">开始使用</a>。</p><p id="e4d6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这篇文章是写给那些想知道“为什么要做出反应？React的工作原理是什么？API设计的目的是什么？”</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kf kg l"/></div></figure><h1 id="c422" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">为什么要反应？</h1><blockquote class="kz"><p id="d261" class="la lb hh bd lc ld le lf lg lh li kd dx translated">当UI组件不知道网络、业务逻辑或应用程序状态时，生活会更简单。给定相同的属性，总是呈现相同的数据。</p></blockquote><p id="8d9b" class="pw-post-body-paragraph ji jj hh jk b jl lj ii jn jo lk il jq jr ll jt ju jv lm jx jy jz ln kb kc kd ha bi translated">当React首次推出时，它从根本上改变了JavaScript框架的工作方式。当其他人都在推动MVC、MVVM等时，React选择将视图渲染与模型表示分离，并为JavaScript前端生态系统引入了一个全新的架构:Flux。</p><p id="52bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">React团队为什么要这么做？为什么它比之前的MVC框架(和jQuery意大利面)更好？</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="96b7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在2013年，脸书刚刚花了相当多的精力集成聊天功能:这个功能将在整个应用程序体验中实时可用，集成在网站的几乎每个页面上。这是一个在已经很复杂的应用中的复杂应用，DOM不受控制的突变，以及多用户I/O的并行和异步特性给脸书团队带来了困难的挑战。</p><p id="f523" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，当任何东西都可以在任何时间出于任何原因抓取DOM并对其进行变异时，您如何预测将呈现给屏幕的内容，以及您如何证明呈现的内容是正确的？</p><p id="e14c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在React之前，您无法用任何流行的前端框架做出这些保证。DOM竞争条件是早期web应用程序中最常见的错误之一。</p><blockquote class="lo lp lq"><p id="e6c5" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="hh">非确定性=并行处理+可变状态</em></strong>——<a class="ae ke" href="https://en.wikipedia.org/wiki/Martin_Odersky" rel="noopener ugc nofollow" target="_blank">马丁·奥德斯基</a></p></blockquote><p id="6d9a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">React团队的首要任务就是解决这个问题。他们通过两项关键创新做到了这一点:</p><ul class=""><li id="a253" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated"><strong class="jk hi">采用flux架构的单向数据绑定</strong>。</li><li id="40f0" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">组件状态是不可变的。</strong>一旦设定，组件的状态不能改变。状态更改不会更改现有的视图状态。相反，它们触发一个具有新状态的新视图呈现。</li></ul><blockquote class="lo lp lq"><p id="cd3c" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated">“我们发现，从概念上来说，构建和呈现我们的视图的最简单的方法就是尽量避免突变。”— Tom Occhino，JSConfUS 2013</p></blockquote><p id="7bab" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有了flux，React驯服了不受控制的变异问题。React没有将事件侦听器附加到任意数量的任意对象(模型)来触发DOM更新，而是引入了一种操作组件状态的方法:分派到存储。当存储状态改变时，存储将要求组件重新呈现。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mj"><img src="../Images/4ccf4711d2a153551414822ade421e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNLcKqywLkrHadcA-zhgBA.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx">Flux architecture</figcaption></figure><p id="e0ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当有人问我“为什么我应该关心React”时，我的回答很简单:因为我们想要<strong class="jk hi">确定性视图渲染，</strong>和React使这变得容易得多。</p><blockquote class="lo lp lq"><p id="0ddd" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>从DOM读取数据是一种反模式，目的是实现域逻辑。这样做违背了使用React的目的。相反，从存储中读取数据并在渲染之前做出选择。</p></blockquote><p id="d851" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果确定性渲染是React的唯一技巧，它仍将是一项惊人的创新。但是React团队还没有完成创新。他们推出了更多的杀手级功能，多年来，他们增加了更多。</p><h1 id="13f6" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">JSX</h1><p id="5af0" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">JSX是JavaScript的扩展，它允许你以声明的方式创建自定义的UI组件。JSX有重要的好处:</p><ul class=""><li id="76e6" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated"><strong class="jk hi">简单的声明式标记。</strong></li><li id="2df9" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">与您的组件放在一起。</strong></li><li id="87b9" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">按关注点分开，</strong>(如UI vs状态逻辑，vs副作用)而不是按<strong class="jk hi">技术</strong>(如HTML，CSS，JavaScript)。</li><li id="1ff4" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">抽象掉DOM差异。</strong></li><li id="dc0b" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">从底层技术中抽象出来</strong>这样你就可以用React瞄准许多不同的平台。(例如<a class="ae ke" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ke" href="https://github.com/facebook/react-360" rel="noopener ugc nofollow" target="_blank"> VR </a>、<a class="ae ke" href="https://netflixtechblog.com/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b" rel="noopener ugc nofollow" target="_blank">网飞·吉本</a>、<a class="ae ke" href="https://github.com/raphamorim/react-ape" rel="noopener ugc nofollow" target="_blank">画布/WebGL </a>、<a class="ae ke" href="https://github.com/chromakode/react-html-email" rel="noopener ugc nofollow" target="_blank">邮件</a>、...)</li></ul><p id="1c71" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在JSX之前，如果你想写声明性的UI代码，你必须使用HTML模板，而且当时还没有好的标准。每个框架都使用它们自己的特殊语法，你必须学会做一些事情，比如循环数据、插入变量或进行条件分支。</p><p id="0b31" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">今天，如果你看看其他框架，你仍然需要学习特殊的语法，比如Angular的<code class="du mt mu mv mw b">*ngFor</code>指令。因为JSX是JavaScript的超集，所以JSX标记中包含了JavaScript的所有现有特性。</p><p id="a2ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可以使用<code class="du mt mu mv mw b">Array.prototype.map</code>迭代条目，使用逻辑运算符，使用三元表达式分支，<a class="ae ke" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">调用纯函数</a>，在<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>上插值，或者JavaScript表达式可以做的任何事情。在我看来，这是竞争UI框架的一个巨大优势。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx kg l"/></div></figure><p id="9351" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一开始你可能会纠结于几条规则:</p><ul class=""><li id="0e63" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated">在JSX，<code class="du mt mu mv mw b">class</code>属性变成了<code class="du mt mu mv mw b">className</code>。</li><li id="740b" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">对于您想要显示的项目列表中的每一个项目，您需要一个稳定的、惟一的标识符用于JSX <code class="du mt mu mv mw b">key</code>属性。添加或删除项目时，密钥不能更改。实际上，在您的数据模型中，大多数列表项都有惟一的id，这些id通常作为键非常有用。</li></ul><p id="14c4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">React并没有为CSS开出单一的解决方案。您可以将一个JavaScript样式对象传递给style属性，在这种情况下，许多常见的样式名称将被转换为对象文字形式的camelCase，但还有其他选项。我混合搭配了几种不同的解决方案，这取决于我所应用的样式的范围:主题化和公共布局的全局样式，以及仅用于该组件的局部范围。</p><p id="774b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以下是我最喜欢的选项:</p><ul class=""><li id="71d2" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated"><strong class="jk hi"> CSS文件</strong>可以加载到您的页眉中，用于通用的全局布局、字体等。它们工作正常。</li><li id="228b" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><a class="ae ke" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> CSS模块</strong> </a>是本地范围的CSS文件，可以直接导入到JavaScript文件中。你需要一个正确配置的<a class="ae ke" href="https://github.com/webpack-contrib/css-loader" rel="noopener ugc nofollow" target="_blank">装载器</a>。<a class="ae ke" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>默认启用。</li><li id="4094" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><a class="ae ke" href="https://github.com/vercel/styled-jsx" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> styled-jsx </strong> </a>让你在React组件中内嵌声明样式，类似于HTML中的<code class="du mt mu mv mw b">&lt;style&gt;</code>标签。这些样式的范围是超本地的，这意味着只有兄弟标签及其子标签会受到样式的影响。Next.js也默认启用styled-jsx。</li></ul><h1 id="ee7f" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">合成事件</h1><p id="31f0" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">React提供了一个包装DOM事件的包装器，称为合成事件。他们非常酷有几个原因。合成事件:</p><ol class=""><li id="7a55" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd my mb mc md bi translated"><strong class="jk hi">消除事件处理中的跨平台差异</strong>，让你的JS代码更容易在每个浏览器中工作。</li><li id="7304" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd my mb mc md bi translated"><strong class="jk hi">自动进行内存管理。</strong>如果你要用原始的JavaScript + HTML制作一个无限滚动的列表，你需要委托事件或者在元素滚动时挂钩和脱钩事件监听器，以避免内存泄漏。合成事件被自动委托给根节点，这意味着React开发人员可以免费获得事件内存管理。</li></ol><blockquote class="lo lp lq"><p id="f629" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>在React v17之前，由于事件池的原因，无法在异步函数中访问合成事件属性。相反，从事件对象中获取所需的数据，并在闭包环境中引用它。<a class="ae ke" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html" rel="noopener ugc nofollow" target="_blank">事件池在v17 </a>中被移除，因为浏览器优化处理了它。</p><p id="8021" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>在v17之前，合成事件委托给单据节点。在v17之后，合成事件被委托给React根节点。</p></blockquote><h1 id="5613" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">组件生命周期</h1><p id="32b8" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">React组件生命周期的存在是为了保护组件状态。当React绘制组件时，组件状态不得发生变化。相反，一个组件进入一个已知的状态，绘制，然后打开效果、状态更新和事件的生命周期。</p><p id="6bd0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">理解生命周期是理解如何用React方式做事的关键，这样你就不会与React发生冲突，也不会因为不正确地改变或读取DOM中的状态而意外地违背了使用React的初衷。</p><p id="5bab" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从React 0.14开始，React引入了类语法来挂钩React的组件生命周期。React有两个不同的生命周期需要考虑:挂载、更新和卸载:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mz"><img src="../Images/a88963ce03c3a1ff5e481629ab5dec41.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*xRzCfozCPTWXp8wgnZrXiA.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx">React Lifecycle</figcaption></figure><p id="8bee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在更新生命周期中，还有三个阶段:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es na"><img src="../Images/49bdd686226dbb6fab3864d625c155e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*9wk48udC9l884fOZydImiw.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx">React Update Cycle</figcaption></figure><ul class=""><li id="6aa2" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated">除了调用钩子之外，你的渲染函数应该是确定性的，并且没有副作用。你通常应该认为它是一个从道具到JSX的纯功能。</li><li id="3637" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">预提交</strong> —这里您可以使用<code class="du mt mu mv mw b">getSnapShotBeforeUpdate</code>生命周期方法从DOM中读取。如果您需要在DOM重新呈现之前读取滚动位置或元素的呈现大小之类的内容，这很有用。</li><li id="247f" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">提交</strong> —在提交阶段，React更新DOM和refs。你可以使用<code class="du mt mu mv mw b">componentDidUpdate</code>或<code class="du mt mu mv mw b">useEffect</code>挂钩来接入它。这是可以运行效果、安排更新、使用DOM等的地方。</li></ul><p id="bf8d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Dan Abramov制作了一个很棒的图表，详细说明了从React类的角度可以看到的所有细节:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nb"><img src="../Images/bbc0334726ad5d1fc2293083e430a02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEWErpe-oY-_S1dOaT1NtA.jpeg"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx">React Component Lifecycle Diagram by Dan Abramov (<a class="ae ke" href="https://twitter.com/dan_abramov/status/981712092611989509" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="5010" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我看来，将一个组件视为一个长期存在的类并不是React工作方式的最佳心理模型。请记住:React组件状态并不意味着被改变。它应该被替换，当前状态的每次替换都会触发一次重新渲染。这启用了React最好的特性:使创建<strong class="jk hi">确定性视图渲染变得容易。</strong></p><p id="96f0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于这种行为，一个更好的心理模型是，每次React渲染时，它都会调用一个返回JSX的确定性函数。该函数不应该直接调用自己的副作用，而是可以将效果排队等待React运行。</p><p id="d18c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">换句话说，你应该把大多数React组件看作是从道具到JSX的纯函数。</p><p id="cf7c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">一个纯粹的函数:</strong></p><ul class=""><li id="132a" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated"><strong class="jk hi">给定相同的输入，总是返回相同的输出</strong>(确定性)。</li><li id="55c7" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">没有副作用</strong>(例如，网络I/O、登录控制台、写入本地存储等。)</li></ul><blockquote class="lo lp lq"><p id="b607" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>如果你的组件需要效果，使用<code class="du mt mu mv mw b">useEffect</code>或者调用一个通过props传递的<a class="ae ke" rel="noopener" href="/javascript-scene/10-tips-for-better-redux-architecture-69250425af44">动作创建器</a>，在中间件中处理效果<a class="ae ke" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><h1 id="5cb9" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">反应钩</h1><p id="e659" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">React 16.8引入了一个新的概念:<a class="ae ke" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> React钩子</strong> </a>是允许你在不使用类语法或者直接调用生命周期方法的情况下进入React组件生命周期的函数。您不用声明类，而是编写一个呈现函数。</p><p id="eafe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">调用钩子通常会引入副作用——这种副作用会让你的组件挂钩到组件状态和I/O之类的东西上。</p><p id="8ca9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du mt mu mv mw b"><a class="ae ke" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>让你在组件生命周期中合适的时间运行效果，可以是组件挂载之后(比如<code class="du mt mu mv mw b"><a class="ae ke" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount</a></code>)，提交阶段(比如<code class="du mt mu mv mw b"><a class="ae ke" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank">componentDidUpdate</a></code>)，或者组件卸载之前(比如<code class="du mt mu mv mw b"><a class="ae ke" href="https://reactjs.org/docs/react-component.html#componentwillunmount" rel="noopener ugc nofollow" target="_blank">componentWillUnmount</a></code>)。</p><p id="71d5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">注意三个不同的生命周期方法是如何从一个React钩子上掉下来的？这是因为钩子允许您将相关的逻辑放在一起，而不是将逻辑放在生命周期方法中。</p><p id="67c5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">很多组件需要在组件挂载时挂接一些东西，每次组件重绘时更新，然后在组件卸载前清理，防止内存泄漏。使用<code class="du mt mu mv mw b">useEffect</code>，您可以在一个函数调用中完成所有这些，而不是将您的逻辑分成3个不同的方法，与所有其他不相关的也需要使用这些方法的逻辑混合在一起。</p><p id="9324" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">挂钩使您能够:</strong></p><ul class=""><li id="81b0" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated">将你的组件写成函数而不是类。</li><li id="ad0d" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">更好地组织你的代码。</li><li id="be43" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">在不同组件之间共享可重用逻辑</strong>。</li><li id="497f" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">编写钩子</strong>创建你自己的定制钩子(从另一个钩子内部调用一个钩子)。</li></ul><p id="0749" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一般来说，比起基于类的组件，你应该更喜欢函数组件和React钩子。它们通常代码更少，组织更好，可读性更强，可重用性更高，可测试性更强。</p><h1 id="06de" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">容器与表示组件</h1><p id="7d8c" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">为了提高组件的模块化和可重用性，我倾向于将组件分为两部分:</p><ul class=""><li id="fe19" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated"><strong class="jk hi">容器组件</strong>是连接到数据存储的组件，可能有副作用。</li><li id="1640" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">表示组件</strong>是<em class="lr">大部分是</em>纯组件，给定相同的道具和上下文，它们总是返回相同的JSX。</li></ul><blockquote class="lo lp lq"><p id="d53f" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated"><strong class="jk hi">提示:</strong>纯成分不应与<a class="ae ke" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">反应混淆。PureComponent </a>，以纯组件命名，因为对非纯组件使用它是不安全的。</p></blockquote><p id="0ed3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">演示组件:</strong></p><ul class=""><li id="81a6" class="lv lw hh jk b jl jm jo jp jr lx jv ly jz lz kd ma mb mc md bi translated">不要接触网络</li><li id="6896" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">不要从本地存储中保存或加载</li><li id="af8f" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">不要生成随机数据</li><li id="fb86" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">不要直接读取当前系统时间(例如，通过调用类似<code class="du mt mu mv mw b">Date.now()</code>的函数)</li><li id="5cb5" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">不要直接与商店互动</li><li id="1673" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">可以使用本地组件状态，比如表单输入，只要你可以传入一个初始状态，这样它们就可以被确定性地测试</li></ul><p id="ed9c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后一点就是为什么我称表示组件为“大部分是纯的”。一旦React控制了生命周期，他们实质上是从React全局状态中读取组件状态。所以像<code class="du mt mu mv mw b">useState</code>和<code class="du mt mu mv mw b">useReducer</code>这样的钩子提供隐式数据输入(没有在函数签名中声明的输入源),使得它们在技术上不纯。如果你想让它们真正纯净，你可以把所有的状态管理责任委托给容器组件，但是在我看来，只要你的组件仍然是单元可测试的，这就太过分了。</p><blockquote class="lo lp lq"><p id="1aae" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated">“完美是好的敌人”——伏尔泰</p></blockquote><h2 id="1e50" class="nc ki hh bd kj nd ne nf kn ng nh ni kr jr nj nk kt jv nl nm kv jz nn no kx np bi translated">容器组件</h2><p id="08e5" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">容器组件是处理状态管理、I/O和任何其他效果的组件。它们不应该呈现自己的标记，而是将呈现委托给它们包装的表示组件。通常，React+Redux应用程序中的容器组件将简单地调用<code class="du mt mu mv mw b">mapStateToProps</code>、<code class="du mt mu mv mw b">mapDispatchToProps</code>，并用结果包装表示组件。它们还可能构成许多跨领域的问题(见下文)。</p><h1 id="0eaf" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">高阶组件</h1><p id="29b4" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated"><strong class="jk hi">高阶组件(HOC) </strong>是接受一个组件并返回一个组件以便组合成附加功能的组件。</p><p id="dd07" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">高阶组件通过将一个组件缠绕在另一个组件上来工作。包装组件添加了一些DOM或逻辑，可能会也可能不会向包装组件传递额外的属性。</p><p id="7b69" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与React hooks和<a class="ae ke" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> render props </a>组件不同，hoc可以使用标准函数组合来组合，因此您可以声明性地混合所有应用程序组件的共享行为，而这些组件并不知道这些行为的存在。例如，这里有一个来自EricElliottJS.com的特设项目:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx kg l"/></div></figure><p id="eefc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这混合了EricElliottJS.com<a class="ae ke" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank">上所有页面共有的所有共同的、交叉的关注点。<code class="du mt mu mv mw b">withEnv</code>拉入环境设置，<code class="du mt mu mv mw b">withAuth</code>添加GitHub认证，<code class="du mt mu mv mw b">withLoader</code>在加载用户数据时显示一个微调器，<code class="du mt mu mv mw b">withLayout({ showFooter: true })</code>在页面底部显示我们的默认布局，<code class="du mt mu mv mw b">withFeatures</code>加载我们的功能切换设置，<code class="du mt mu mv mw b">withRouter</code>加载我们的路由器，<code class="du mt mu mv mw b">withCoupon</code>处理神奇优惠券链接，<code class="du mt mu mv mw b">withMagicLink</code>使用</a><a class="ae ke" href="https://magic.link/" rel="noopener ugc nofollow" target="_blank">魔法</a>处理我们的无密码用户认证。</p><blockquote class="lo lp lq"><p id="16fd" class="ji jj lr jk b jl jm ii jn jo jp il jq ls js jt ju lt jw jx jy lu ka kb kc kd ha bi translated">提示:<a class="ae ke" rel="noopener" href="/javascript-scene/passwords-are-obsolete-how-to-secure-your-app-and-protect-your-users-1cd6c7b7c3bc">密码过时且危险</a>。今天，没有人应该用密码认证来编写新的应用程序。</p></blockquote><p id="2409" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们网站上几乎所有的页面都使用了这些功能。在高阶组件中完成这种组合后，我们可以用一行代码将其组合到我们的容器组件中。这是我们的课程页面处理程序的样子:</p><pre class="ix iy iz ja fd nq mw nr ns aw nt bi"><span id="3f45" class="nc ki hh mw b fi nu nv l nw nx">import LessonPage from '../features/lesson-pages/lesson-page.js';<br/>import pageHOC from '../hocs/page-hoc.js';</span><span id="0215" class="nc ki hh mw b fi ny nv l nw nx">export default pageHOC(LessonPage);</span></pre><p id="d3ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">除了这些hoc之外，还有一种常见但很糟糕的选择，那就是末日金字塔:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mx kg l"/></div></figure><p id="a312" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">每一页都重复。如果你需要在任何地方改变它，你必须记住在任何地方都要改变它。为什么这么烂应该是不言而喻的。</p><p id="695d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">利用组合来解决横切关注点是降低应用程序中代码复杂性的最佳方式之一。作文这个话题太重要了，我为此写了一整本书:<a class="ae ke" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">《作文软件》</a>。</p><h1 id="f2f7" class="kh ki hh bd kj kk kl km kn ko kp kq kr in ks io kt iq ku ir kv it kw iu kx ky bi translated">概述</h1><ul class=""><li id="d298" class="lv lw hh jk b jl mo jo mp jr nz jv oa jz ob kd ma mb mc md bi translated"><strong class="jk hi">为什么反应？</strong> <em class="lr">确定性视图呈现，</em>由<em class="lr">单向数据绑定促成，</em>和<em class="lr">组件状态不可变。</em></li><li id="5eaa" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">JSX在你的JavaScript中提供了简单的声明性标记。</li><li id="a863" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">合成事件</strong>平滑跨平台事件，减少内存管理难题。</li><li id="408c" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">组件生命周期的存在是为了保护组件状态。它包括装载、更新和卸载，更新阶段包括呈现、预提交和提交阶段。</li><li id="772b" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated">React hooks 允许你在不使用类语法的情况下进入组件的生命周期，也使得在组件之间共享行为变得更加容易。</li><li id="cfe9" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">容器和表示组件</strong>允许你将表示问题从状态和效果中分离出来，使你的组件和业务逻辑更加可重用和可测试。</li><li id="7b0a" class="lv lw hh jk b jl me jo mf jr mg jv mh jz mi kd ma mb mc md bi translated"><strong class="jk hi">高阶组件</strong>使得在你的应用程序中跨多个页面共享可组合行为变得容易，你的组件不需要知道它们(或者与它们紧密耦合)。</li></ul><h2 id="2708" class="nc ki hh bd kj nd ne nf kn ng nh ni kr jr nj nk kt jv nl nm kv jz nn no kx np bi translated">后续步骤</h2><p id="1458" class="pw-post-body-paragraph ji jj hh jk b jl mo ii jn jo mp il jq jr mq jt ju jv mr jx jy jz ms kb kc kd ha bi translated">在这篇简单的React简介中，我们涉及了许多函数式编程概念。如果你真的想了解如何构建React应用程序，加强你对概念的理解是个好主意，比如<a class="ae ke" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">纯函数</a>、<a class="ae ke" rel="noopener" href="/javascript-scene/the-dao-of-immutability-9f91a70c88cd">不变性</a>、<a class="ae ke" rel="noopener" href="/javascript-scene/curry-and-function-composition-2c208d774983">约束函数、部分应用程序和函数组合</a>。这些主题都包含在<a class="ae ke" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">EricElliottJS.com</a>的视频和代码练习中。</p><p id="fe55" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我推荐用<a class="ae ke" rel="noopener" href="/javascript-scene/10-tips-for-better-redux-architecture-69250425af44"> Redux </a>、<a class="ae ke" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>和<a class="ae ke" href="https://github.com/ericelliott/riteway" rel="noopener ugc nofollow" target="_blank"> RITEway </a>进行配对反应。我推荐把Redux和<a class="ae ke" href="https://github.com/ericelliott/autodux" rel="noopener ugc nofollow" target="_blank"> Autodux </a>和<a class="ae ke" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank"> Immer </a>配对。对于复杂的状态转换，请查看<a class="ae ke" href="https://github.com/ericelliott/redux-dsm" rel="noopener ugc nofollow" target="_blank"> Redux-DSM </a>。</p><p id="894a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当你打好基础，准备用React构建真正的应用时，<a class="ae ke" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>和<a class="ae ke" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>可以自动完成构建配置、CI/CD和高度优化的无服务器部署的设置过程。这就像有一个全职的DevOps团队，但它实际上节省了你的钱，而不是花费你的全职工资。</p></div><div class="ab cl oc od go oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ha hb hc hd he"><p id="ef60" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="lr">埃里克·艾略特</em> </strong> <em class="lr">是一位科技产品和平台顾问，《T5】 <a class="ae ke" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="lr">【作曲软件】</em></a><em class="lr"/><a class="ae ke" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="lr">【EricElliottJS.com】</em></a><em class="lr"/><a class="ae ke" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="lr">devanywhere . io</em></a><em class="lr">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="jk hi"> <em class="lr">、Zumba Fitness、</em> </strong> <em class="lr"> </em> <strong class="jk hi"> <em class="lr">【华尔街日报、</em></strong><em class="lr"/><strong class="jk hi"><em class="lr">【ESPN、</em></strong><em class="lr"/><strong class="jk hi"><em class="lr">【BBC】</em></strong><em class="lr">等顶级录音艺人和包括</em> <strong class="jk hi"> <em class="lr"> Usher、【Metallica】</em></strong></em></p><p id="faf6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>