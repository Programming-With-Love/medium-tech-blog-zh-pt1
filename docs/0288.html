<html>
<head>
<title>Room 🔗 RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间🔗RxJava</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757?source=collection_archive---------1-----------------------#2017-06-23">https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757?source=collection_archive---------1-----------------------#2017-06-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/5414fdb8d24f521c1c8447ba7ee2c326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5aKXziMA3VUPhzicQiSzw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Room and RxJava — easily linked together (<a class="ae hu" href="https://unsplash.com/photos/PDxYfXVlK2M" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><div class=""/><p id="cafd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用RxJava在房间中进行查询</p><p id="bec1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更少的样板代码，编译时检查的SQL查询，最重要的是，异步和可观察查询的能力——听起来怎么样？所有这些都可以通过<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room </a>、来自<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>的持久性库来实现。异步查询返回<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>或RxJava的<a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" rel="noopener ugc nofollow" target="_blank">可能是</a>、<a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank"> Single </a>或<a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html" rel="noopener ugc nofollow" target="_blank">flowered</a>。返回LiveData和Flowable的查询是可观察的查询。它们允许您在数据发生变化时获得自动更新，以确保您的UI反映数据库中的最新值。如果你已经在你的应用中使用了RxJava 2，那么将Room与<code class="du js jt ju jv b"><a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" rel="noopener ugc nofollow" target="_blank">Maybe</a></code>、<code class="du js jt ju jv b"><a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank">Single</a></code>和<code class="du js jt ju jv b"><a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html" rel="noopener ugc nofollow" target="_blank">Flowable</a></code>一起使用将会轻而易举。</p><blockquote class="jw jx jy"><p id="b17a" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">后期编辑:从' 2.0.0-beta01 '开始，Room也支持<code class="du js jt ju jv b"><a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html" rel="noopener ugc nofollow" target="_blank">Observable</a></code></p></blockquote></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><blockquote class="jw jx jy"><p id="b97a" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">后期编辑2:从2.1.0-alpha01室开始，用<code class="du js jt ju jv b">@Insert</code>、<code class="du js jt ju jv b">@Delete</code>或<code class="du js jt ju jv b">@Update</code>标注的DAO方法支持Rx返回类型<code class="du js jt ju jv b">Completable</code>、<code class="du js jt ju jv b">Single&lt;T&gt;</code>和<code class="du js jt ju jv b"> Maybe&lt;T&gt;</code>。</p></blockquote></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><p id="7ef4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们考虑下面的UI:用户能够看到和编辑他们的用户名。这些信息和其他关于用户的信息都保存在数据库中。下面介绍如何插入、更新、删除和查询用户。</p><h1 id="400b" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">插入</h1><p id="b8e7" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">与RxJava的房间集成允许插入以下相应的返回类型:</p><ul class=""><li id="c0b6" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated"><code class="du js jt ju jv b">Completable</code> —插入完成后立即调用<code class="du js jt ju jv b">onComplete</code></li><li id="4fee" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du js jt ju jv b">Single&lt;Long&gt;</code>或<code class="du js jt ju jv b">Maybe&lt;Long&gt;</code>—<code class="du js jt ju jv b">onSuccess</code>上发出的值是插入项目的行id</li><li id="2e3d" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du js jt ju jv b">Single&lt;List&lt;Long&gt;&gt;</code>或<code class="du js jt ju jv b">Maybe&lt;List&lt;Long&gt;&gt;</code> —其中<code class="du js jt ju jv b">onSuccess</code>上发出的值是插入项目的行id列表</li></ul><p id="0889" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果数据插入错误，<code class="du js jt ju jv b">Completable</code>、<code class="du js jt ju jv b">Single</code>和<code class="du js jt ju jv b">Maybe</code>将在<code class="du js jt ju jv b">onError</code>中发出异常。</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="81c6" class="mj kl hx jv b fi mk ml l mm mn">@Insert<br/>Completable insert(User user);</span><span id="366a" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Insert<br/>Maybe&lt;Long&gt; insert(User user);</span><span id="2610" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Insert<br/>Single&lt;Long&gt; insert(User[] user);</span><span id="dcfc" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Insert<br/>Maybe&lt;List&lt;Long&gt;&gt; insert(User[] user);</span><span id="b7db" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Insert<br/>Single&lt;List&lt;Long&gt;&gt; insert(User[] user);</span></pre><p id="77ba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用<code class="du js jt ju jv b">observeOn</code>操作器指定<code class="du js jt ju jv b">Observer</code>观察<code class="du js jt ju jv b">Observable</code>的<code class="du js jt ju jv b">Scheduler</code>和<code class="du js jt ju jv b">subscribeOn</code>指定<code class="du js jt ju jv b">Observable</code>操作的<code class="du js jt ju jv b">Scheduler</code>。</p><h1 id="1af2" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">更新/删除</h1><p id="77ce" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">房间与RxJava的集成允许更新/删除以下相应的退货类型:</p><ul class=""><li id="0a8a" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated"><code class="du js jt ju jv b">Completable</code> —更新/删除完成后立即调用<code class="du js jt ju jv b">onComplete</code></li><li id="f7d8" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du js jt ju jv b">Single&lt;Integer&gt;</code>或<code class="du js jt ju jv b">Maybe&lt;Integer&gt;</code> —其中onSuccess上发出的值是受更新/删除影响的行数</li></ul><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="79ca" class="mj kl hx jv b fi mk ml l mm mn">@Update<br/>Completable update(User user);</span><span id="1a28" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Update<br/>Single&lt;Integer&gt; update(User user);</span><span id="2e8c" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Update<br/>Single&lt;Integer&gt; updateAll(User[] user);</span><span id="4c7a" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Delete<br/>Single&lt;Integer&gt; deleteAll(User[] user);</span><span id="7a69" class="mj kl hx jv b fi mo ml l mm mn">// or<br/>@Delete<br/>Single&lt;Integer&gt; deleteAll(User[] user);</span></pre><p id="cbb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用<code class="du js jt ju jv b">observeOn</code>操作器指定<code class="du js jt ju jv b">Observer</code>观察<code class="du js jt ju jv b">Observable</code>的<code class="du js jt ju jv b">Scheduler</code>和<code class="du js jt ju jv b">subscribeOn</code>指定<code class="du js jt ju jv b">Observable</code>操作的<code class="du js jt ju jv b">Scheduler</code>。</p><h1 id="0222" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">询问</h1><p id="b499" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">为了从数据库中获取用户，我们可以在数据访问对象类(<code class="du js jt ju jv b">UserDao</code>)中编写以下查询:</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="2ad2" class="mj kl hx jv b fi mk ml l mm mn">@Query(“SELECT * FROM Users WHERE id = :userId”)<br/>User getUserById(String userId);</span></pre><p id="27a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种方法有两个缺点:</p><ol class=""><li id="a6d2" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr mp lt lu lv bi translated">这是一个阻塞的同步调用</li><li id="7317" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">每次修改用户数据时，我们都需要手动调用这个方法</li></ol><p id="6e2b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Room提供观察数据库中数据的选项，并借助RxJava <a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" rel="noopener ugc nofollow" target="_blank"> Maybe </a>、<a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank"> Single </a>和<a class="ae hu" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html" rel="noopener ugc nofollow" target="_blank">flow</a>对象执行异步查询。</p><p id="d635" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你担心线程，Room会让你放松，并确保<strong class="iw hy">可观察的查询是在主线程</strong>之外完成的。通过在<code class="du js jt ju jv b">observeOn</code>方法中设置<code class="du js jt ju jv b">Scheduler</code>，由您决定在哪个线程上向下游发出事件。</p><p id="aaa6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于返回<code class="du js jt ju jv b">Maybe</code>或<code class="du js jt ju jv b">Single</code>的查询，确保您使用不同于<code class="du js jt ju jv b">AndroidSchedulers.mainThread()</code>的<code class="du js jt ju jv b">Scheduler</code>调用<code class="du js jt ju jv b">subscribeOn</code>。</p><p id="0723" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要开始在RxJava 2中使用Room，只需将以下依赖项添加到您的<code class="du js jt ju jv b">build.gradle</code>文件中:</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="91bf" class="mj kl hx jv b fi mk ml l mm mn">// RxJava support for Room<br/>implementation “android.arch.persistence.room:rxjava2:1.0.0-alpha5”</span><span id="3dad" class="mj kl hx jv b fi mo ml l mm mn">// Testing support<br/>androidTestImplementation “android.arch.core:core-testing:1.0.0-alpha5”</span></pre><h2 id="67ce" class="mj kl hx bd km mq mr ms kq mt mu mv ku jf mw mx ky jj my mz lc jn na nb lg nc bi translated"><strong class="ak">也许是</strong></h2><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="2d99" class="mj kl hx jv b fi mk ml l mm mn">@Query(“SELECT * FROM Users WHERE id = :userId”)<br/><strong class="jv hy">Maybe</strong>&lt;User&gt; getUserById(String userId);</span></pre><p id="8ca4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事情是这样的:</p><ol class=""><li id="060c" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr mp lt lu lv bi translated">当数据库中没有用户并且查询没有返回行时，<code class="du js jt ju jv b">Maybe</code>将<strong class="iw hy">完成</strong>。</li><li id="a94b" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">当数据库中有<strong class="iw hy">用户时，<code class="du js jt ju jv b">Maybe</code>将触发<code class="du js jt ju jv b"><strong class="iw hy">onSuccess</strong></code> <strong class="iw hy">并完成</strong>。</strong></li><li id="7d46" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">如果在<code class="du js jt ju jv b">Maybe</code>完成后<strong class="iw hy">用户被更新</strong>，则<strong class="iw hy">不会发生任何事情</strong>。</li></ol><h2 id="ec8c" class="mj kl hx bd km mq mr ms kq mt mu mv ku jf mw mx ky jj my mz lc jn na nb lg nc bi translated"><strong class="ak">单身</strong></h2><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="560b" class="mj kl hx jv b fi mk ml l mm mn">@Query(“SELECT * FROM Users WHERE id = :userId”)<br/><strong class="jv hy">Single</strong>&lt;User&gt; getUserById(String userId);</span></pre><p id="b17d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是一些场景:</p><ol class=""><li id="7b33" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr mp lt lu lv bi translated">当<strong class="iw hy">数据库</strong>中没有用户并且查询没有返回行时，<code class="du js jt ju jv b">Single</code>将触发<code class="du js jt ju jv b"><strong class="iw hy">onError(EmptyResultSetException.class)</strong></code></li><li id="0fe2" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">当数据库中有<strong class="iw hy">用户时，<code class="du js jt ju jv b">Single</code>会触发<code class="du js jt ju jv b"><strong class="iw hy">onSuccess</strong></code>。</strong></li><li id="ede0" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">如果在<code class="du js jt ju jv b">Single</code>完成后<strong class="iw hy">用户被更新</strong>，则<strong class="iw hy">不会发生任何事情</strong>。</li></ol><h2 id="c924" class="mj kl hx bd km mq mr ms kq mt mu mv ku jf mw mx ky jj my mz lc jn na nb lg nc bi translated"><strong class="ak">可流动/可观察</strong></h2><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="cca7" class="mj kl hx jv b fi mk ml l mm mn">@Query(“SELECT * FROM Users WHERE id = :userId”)<br/><strong class="jv hy">Flowable</strong>&lt;User&gt; getUserById(String userId);</span></pre><p id="3326" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是<code class="du js jt ju jv b">Flowable</code> / <code class="du js jt ju jv b">Observable</code>的行为方式:</p><ol class=""><li id="5e97" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr mp lt lu lv bi translated">当<strong class="iw hy">数据库</strong>中没有用户，查询没有返回行时，<code class="du js jt ju jv b"><strong class="iw hy">Flowable</strong></code> <strong class="iw hy">不会发出</strong>、<code class="du js jt ju jv b">onNext</code>和<code class="du js jt ju jv b">onError</code>。</li><li id="6e96" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">当数据库中有<strong class="iw hy">用户时，<code class="du js jt ju jv b">Flowable</code>将触发<code class="du js jt ju jv b"><strong class="iw hy">onNext</strong></code>。</strong></li><li id="e057" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mp lt lu lv bi translated">每次<strong class="iw hy">用户数据更新</strong>时，<code class="du js jt ju jv b">Flowable</code>对象会自动<strong class="iw hy">发出</strong>，让你根据最新数据更新UI。</li></ol><h1 id="c044" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">测试</h1><p id="7d6f" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">测试一个返回<code class="du js jt ju jv b">Maybe</code> / <code class="du js jt ju jv b">Single</code> / <code class="du js jt ju jv b">Flowable</code>的查询与测试它的同步对等项没有太大的不同。在<code class="du js jt ju jv b">UserDaoTest</code>中，我们确保使用内存数据库，因为当进程被终止时，存储在这里的信息会被自动清除。</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="ffcc" class="mj kl hx jv b fi mk ml l mm mn">@RunWith(AndroidJUnit4.class)<br/>public class UserDaoTest {<br/>…<br/>private UsersDatabase mDatabase;</span><span id="0551" class="mj kl hx jv b fi mo ml l mm mn">@Before<br/>public void initDb() throws Exception {<br/>    mDatabase = Room.<em class="jz">inMemoryDatabaseBuilder</em>(<br/>                     InstrumentationRegistry.<em class="jz">getContext</em>(),<br/>                     UsersDatabase.class)<br/>            // allowing main thread queries, just for testing<br/>            .allowMainThreadQueries()<br/>            .build();<br/>}<br/><br/>@After<br/>public void closeDb() throws Exception {<br/>    mDatabase.close();<br/>}</span></pre><p id="a18f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将<code class="du js jt ju jv b">InstantTaskExecutorRule</code>规则添加到您的测试中，以确保Room立即执行所有数据库操作。</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="14b2" class="mj kl hx jv b fi mk ml l mm mn">@Rule<br/>public InstantTaskExecutorRule instantTaskExecutorRule = <br/>                                      new InstantTaskExecutorRule();</span></pre><p id="58fa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们实现一个测试，订阅<code class="du js jt ju jv b">getUserById</code>的发射，并检查当用户被插入时，正确的数据是否由<code class="du js jt ju jv b">Flowable</code>发射。</p><pre class="mb mc md me fd mf jv mg mh aw mi bi"><span id="0742" class="mj kl hx jv b fi mk ml l mm mn">@Test<br/>public void insertAndGetUserById() {<br/>    // Given that we have a user in the data source<br/>    mDatabase.userDao().insertUser(<em class="jz">USER</em>);</span><span id="f597" class="mj kl hx jv b fi mo ml l mm mn">    // When subscribing to the emissions of user<br/>    mDatabase.userDao()<br/>             .getUserById(<em class="jz">USER</em>.getId())<br/>             .test()<br/>             // assertValue asserts that there was only one emission<br/>             .assertValue(new Predicate&lt;User&gt;() {<br/>                @Override<br/>                public boolean test(User user) throws Exception {<br/>                    // The emitted user is the expected one<br/>                    return user.getId().equals(<em class="jz">USER</em>.getId()) &amp;&amp;<br/>                      user.getUserName().equals(<em class="jz">USER</em>.getUserName());<br/>                }<br/>            });<br/>}</span></pre><p id="26a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！如果您在应用程序中使用RxJava 2，也要让您的数据库具有反应性，并确保您的UI总是显示最新的数据。点击查看使用Room和RxJava <a class="ae hu" href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample" rel="noopener ugc nofollow" target="_blank">的示例应用程序。</a></p></div></div>    
</body>
</html>