<html>
<head>
<title>Federated GraphQL @ Walmart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">联合图表QL @ Walmart</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/federated-graphql-walmart-bfc85c2553de?source=collection_archive---------0-----------------------#2020-12-31">https://medium.com/walmartglobaltech/federated-graphql-walmart-bfc85c2553de?source=collection_archive---------0-----------------------#2020-12-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a3d1f9d15d733385e62d5220bce1e5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5puH3peY5jyidx1oturd6Q.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Trail in Bangalore — from my iPhone</figcaption></figure><p id="e0d0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这篇文章讨论了我们采用联合GraphQL的动机(沃尔玛客户体验)以及我们在将基于REST的编排器迁移到联合GraphQL时看到的一些用例&amp;模式。这里假设您熟悉GraphQL语义，但可能对联邦规范不熟悉。</p><h1 id="6f72" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">介绍</h1><p id="f90a" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">联合GraphQL是一种便于分布式GraphQL服务解析单个图的图节点的机制。它有一个中央网关节点，分析GQL查询并确定哪些GQL服务满足查询。客户端将查询发送到网关，网关遵循分散收集模式来编排向其注册的服务提供者。在沃尔玛，我们使用<a class="ae ku" href="https://www.apollographql.com/docs/federation/" rel="noopener ugc nofollow" target="_blank"> Apollo框架</a>提供联合GraphQL网关&amp;联合GraphQL服务。服务是使用<code class="du kv kw kx ky b">apollo-server</code> <code class="du kv kw kx ky b">apollo-gateway</code>和<code class="du kv kw kx ky b">fastify</code>构建的</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="e68b" class="jr js hh bd jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk lk km kn ko bi translated">动机</h1><h2 id="b441" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">领域模型一致性</h2><p id="9cd1" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">我们的客户之旅包括由BFF(后端对前端)编排器驱动的页面。旅程分为多个页面，每个页面都有自己的编排器来满足客户的需求。这些是用Java或NodeJS编写的基于REST的编排器。大多数Orchestrator引擎要么是由组织结构决定的，要么是由需要定制视图模型的客户团队决定的。例如，POV传送带上的产品信息将由与产品服务对话的个性化服务提供。搜索页面上的搜索结果由另一个orchestrator提供支持，该orchestrator也与产品服务进行对话。没有实施通用的共享数据模型，导致在每个页面上为一个产品块定制实现。在客户端上。</p><h2 id="8fda" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">开发人员工效学</h2><p id="5583" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">我们希望开发人员有一个一致的模型来工作，它总是最新的并且容易获得。在GraphQL中，带有文档化字段和类型的模式是事实上的API契约。此外，GraphQL Playground允许开发人员在集成之前尝试各种查询。开发横向关注点，比如今天的<code class="du kv kw kx ky b">adding item to wishlist</code>，意味着接触与产品服务相协调的各种服务，将喜欢的项目添加到它们的模型中。有了Federated GraphQL，List团队可以扩展产品模式并将<code class="du kv kw kx ky b">isFavourite</code>功能添加到<code class="du kv kw kx ky b">product schema</code>中，从而减少团队之间所需的协调。</p><h2 id="e028" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">表演</h2><p id="5b01" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">对于前端应用和驱动前端的协调器来说，性能是头等大事。在联合模型中，网关与服务位于同一个WAN中，因此网关产生服务调用的网络开销在20-40毫秒之间。它不执行任何计算量大的任务，主要是I/O。此外，网关通过最小化对服务p的调用次数来进行自己的网络路径优化。因此，如果假设产品服务满足图中的N个字段，则只有一个对产品服务的调用。这在大多数情况下都能很好地工作，除了本文后面提到的一个特殊用例。</p><h2 id="9107" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">根据目标衡量成功</h2><p id="cb94" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">鉴于我们正在转向一个全新的平台，确保我们做出的决策可以用数据来衡量，并且我们可以在未来改进它，这一点非常重要。我们采用的一些成功衡量标准如下</p><ul class=""><li id="d063" class="lz ma hh iv b iw ix ja jb je mb ji mc jm md jq me mf mg mh bi translated">客户端有效负载大小减少—我们发现，对于相同的功能，有效负载大小提高了大约<strong class="iv hi">60%</strong></li><li id="56ee" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">对同一个域服务的重叠呼叫数量— <strong class="iv hi"> 100% </strong>改进，因为所有呼叫都通过单一服务或网关</li><li id="31ab" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">FE &amp; BE的领域实体的可重用性— <strong class="iv hi"> 100% </strong>模式被扩展用于附加功能。此外，GQL确保只有一个解析器a类型。</li></ul></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="929c" class="jr js hh bd jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk lk km kn ko bi translated">使用联合图表学习</h1><p id="2a06" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">虽然GraphQL解决了我们现有的许多棘手问题，但联邦GQL并不是解决分布式图形共享的灵丹妙药。有些用例不太适合GraphQL模式，仍然需要额外的后端编排模式。我们首先关注边缘的GQL，向下移动到域服务，如果有意义的话，引入联邦。这里有一些不太符合要求的用例。</p><h2 id="556f" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">共享实体</h2><p id="bf18" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">共享实体是跨多个领域的模型。这方面的一个例子是在主页、搜索页面、项目页面等之间共享的视图模块。模块是视图的构建块，语义上等同于<code class="du kv kw kx ky b">div</code>或<code class="du kv kw kx ky b">ViewModel</code>。视图是从我们的内容管理系统中配置的模块构建的。布局驱动哪些模块进入视口的哪些部分。在case Layouts &amp;模块中，我们有许多域驱动的后端系统，它们想要驱动客户端页面上的最终布局&amp;模块。例如，搜索页面上的模块是由ML模型&amp;查询上下文驱动的。主页视图由个性化后端驱动，个性化后端根据客户环境决定哪些模块是相关的。这两个后端都希望最终决定应该将什么样的布局&amp;模块发送给请求客户端。主页&amp;搜索页面的客户端请求如下所示</p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="f443" class="ll js hh ky b fi mv mw l mx my">//Types in ViewModule Service<br/>interface ModuleConfigs {<br/>  configs: JSON<br/>}<br/>type ViewModule {<br/>  name: String!<br/>  type: String!<br/>  version: Int!<br/>  configs: ModuleConfigs!</span><span id="b277" class="ll js hh ky b fi mz mw l mx my">}</span><span id="2114" class="ll js hh ky b fi mz mw l mx my">type P13NModuleConfig implements ModuleConfigs {<br/> recommendations: [ProductInfo]<br/> metaData:MetaData<br/>}<br/>type BannerModuleConfig implements ModuleConfig {<br/>  bannerImgUrl:String<br/>  bannerText:String<br/>}<br/>type ContentLayout {<br/> layout: JSON<br/> modules: [ViewModule]<br/>}<br/>extend type query {<br/> contentLayout:ContentLayout<br/>}</span><span id="ff1a" class="ll js hh ky b fi mz mw l mx my">//Query</span><span id="06a1" class="ll js hh ky b fi mz mw l mx my">query HomeLayout {<br/>contentLayout {<br/>   layoutJSON,<br/>   modules {<br/>     moduleName<br/>     ...on BannerModuleConfig {<br/>       bannerImageUrl<br/>     }<br/>     ...on P13NModuleConfig {<br/>        product {<br/>          productId<br/>          description<br/>          url<br/>        }<br/>     }<br/>   }<br/>}</span><span id="f1bf" class="ll js hh ky b fi mz mw l mx my">//Search ViewModel Types<br/><br/>type GuidedNavConfig implements ModuleConfig {<br/>  config: JSON<br/>  guidedNavigation: [NavigationItems] //comes from Search Response <br/>}</span><span id="0a90" class="ll js hh ky b fi mz mw l mx my">//SearchView Query<br/>searchView {<br/>   layoutJSON,<br/>   modules {<br/>     moduleName<br/>     ...on GuidedNavConfig  {<br/>       guidedNavigation {<br/>          navigationItems {<br/>              itemName<br/>              link<br/>          }<br/>       }<br/>     }<br/>   }<br/>}</span></pre><p id="2d66" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一个简单的GQL模式将首先获取模块，然后从联邦服务中丰富模块。然而，这种方法在搜索的情况下不起作用，因为模块和搜索结果紧密地联系在一起，并且对搜索结果的查询是编排的长杆，我们不希望在第一次获取模块和随后用搜索结果丰富时增加任何延迟。</p><p id="0971" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们最初的联邦版本，导致了基于域的分离。因此，搜索视图模型是由搜索服务驱动的(其主要职责是提供给定查询的搜索结果)。在搜索中，客户端既需要页面上的模块，也需要搜索查询的结果。搜索页面上有许多依赖于搜索结果的模块(如方面、过滤器或导航)。我们需要能够为CMS中的搜索视图和搜索结果并行编排，然后从结果中缝合视图。这一要求产生了以下问题</p><ul class=""><li id="69e2" class="lz ma hh iv b iw ix ja jb je mb ji mc jm md jq me mf mg mh bi translated">使用模式拼接技术(如<code class="du kv kw kx ky b">delegateToSchema</code>)的ViewModel服务的后端入口</li><li id="fdaf" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq me mf mg mh bi translated">客户对搜索视图与任何其他视图的不同查询有助于请求进行搜索</li></ul><p id="bea8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了克服这些问题并使代码更易于维护，我们将ViewModel服务作为一个迷你的协调器，与个性化服务、内容管理系统和搜索后端进行对话。下一节将讨论为什么这种模式(不同的域控制聚合结果)很难在GQL中建模。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="15e1" class="jr js hh bd jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk lk km kn ko bi translated"><code class="du kv kw kx ky b">@extends</code> &amp; <code class="du kv kw kx ky b">@requires</code>联邦指令</h1><h2 id="e1a0" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">@扩展</h2><p id="3921" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">在我们深入研究之前，我们将触及这个指令的作用。<code class="du kv kw kx ky b">@extends</code>是在类型级别指定的GraphQL指令，指示该实体是当前服务中引用的远程实体。如果我们用等价的Rest术语来说，远程实体是一个可以从服务中获取的实体。因此，在这种意义上，实体还需要指定如何获取它的契约。这是我们在远程实体上指定<code class="du kv kw kx ky b">key fields</code>的地方，它规定了与远程服务的契约，以获取该实体。因此，从ViewModule服务扩展的模块实体可以是这样的。要获取模块，需要提供由<code class="du kv kw kx ky b">@external</code>标记的<code class="du kv kw kx ky b">moduleId</code></p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="02eb" class="ll js hh ky b fi mv mw l mx my">extend type ViewModule @key(fields:"moduleId") {<br/>  moduleId: String! @external </span><span id="730d" class="ll js hh ky b fi mz mw l mx my">}</span></pre><p id="6a56" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">指定对该模块的依赖有两个原因</p><ol class=""><li id="dafe" class="lz ma hh iv b iw ix ja jb je mb ji mc jm md jq na mf mg mh bi translated">当您需要修饰模块以向其添加功能时</li><li id="53ae" class="lz ma hh iv b iw mi ja mj je mk ji ml jm mm jq na mf mg mh bi translated">当您使用中的远程实体作为类型中的组合字段时</li></ol><p id="dfac" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">装饰扩展实体</em> </strong></p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="e601" class="ll js hh ky b fi mv mw l mx my">extend type Product <a class="ae ku" href="http://twitter.com/key" rel="noopener ugc nofollow" target="_blank">@key</a>(fields: "productId") {<br/>  productId: String @external //populated by the Product Service<br/>  canAddToCart: boolean // decorated by CartService on Product entity<br/>}</span></pre><p id="9d3b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">扩展实体作为另一个字段的输入</em> </strong></p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="3f0e" class="ll js hh ky b fi mv mw l mx my">extend type Product <a class="ae ku" href="http://twitter.com/key" rel="noopener ugc nofollow" target="_blank">@key</a>(fields: "productId") {<br/>  productId:String  <a class="ae ku" href="http://twitter.com/external" rel="noopener ugc nofollow" target="_blank">@external</a> //indicates that the service extending this entity, will provide the productId to resolve a Product using __resolveType function<br/>}<br/>type Cart {<br/>  items:[Product]<br/>}</span></pre><h2 id="a8e7" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">@需要</h2><p id="4431" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated"><code class="du kv kw kx ky b">@requires</code>用于指定业务逻辑内部需要的字段。客户端可能不会查询必填字段，但当前服务需要该字段来解析定义它的字段。例如，如果我们需要将特定类型的模块标记为顶级模块，那么<code class="du kv kw kx ky b">topModules</code>是一个字段，您可以将它添加到视图模型中来实现这一功能，您可以使用<code class="du kv kw kx ky b">@require</code>指令在过滤之前获取所有模块。客户只会要求<code class="du kv kw kx ky b">topModules</code>，而不会要求<code class="du kv kw kx ky b">modules</code>。另外<code class="du kv kw kx ky b">modules</code>不会是远程实体的键的一部分，但是它在它的字段中。</p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="c08a" class="ll js hh ky b fi mv mw l mx my">extend type View <a class="ae ku" href="http://twitter.com/key" rel="noopener ugc nofollow" target="_blank">@key</a>(fields: "pageId") {<br/> pageId : String <a class="ae ku" href="http://twitter.com/external" rel="noopener ugc nofollow" target="_blank">@external</a><br/> modules: [Module] //needed for field below<br/> topModules: [Module] <a class="ae ku" href="http://twitter.com/requires" rel="noopener ugc nofollow" target="_blank">@requires</a> (fields:"modules { moduleId description config { configJSON }") <br/>}</span></pre><p id="c190" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果Module是由其他类型组成的复杂字段，那么<code class="du kv kw kx ky b">requires </code>指令将需要对复杂对象进行解结构，以指定所需的确切字段。随着需要进行的锅炉板延伸量的增加，这可能会很快失控。</p><h2 id="fde5" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">联合和接口</h2><p id="a1d6" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">不能从远程服务扩展联合。然而，它们可以被打包并在需要相同签名的不同服务之间共享。</p><h2 id="59af" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">查询计划执行</h2><p id="04d6" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">网关分析查询，然后准备编排路径。为此，它分析由<code class="du kv kw kx ky b">@extends</code>和<code class="du kv kw kx ky b">@requires</code>指定的服务之间的依赖关系。然后，在调用服务之前，所有对依赖项的获取调用都被“提升”。虽然这是最明显的&amp;确保依赖于图中其他部分的服务在调用服务之前<strong class="iv hi">得到解决的最佳方法，但当出于性能原因(比如服务SLA很高)您希望在需要依赖之前开始调用服务解决方案，以便它们并行执行时，这可能会变得棘手。</strong></p><p id="3e1b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">举例来说，一个<code class="du kv kw kx ky b">Product</code>有一个<code class="du kv kw kx ky b">fulfilment</code>属性，它来自履行服务，需要400毫秒才能得到响应。我们有一个<code class="du kv kw kx ky b">reviews</code>属性，它扩展了产品模式，并由评论服务填充。为此，它需要来自产品服务的productId。因为父解析器和履行解析器都在<strong class="iv hi">产品服务</strong>中，并且查询计划在服务<strong class="iv hi">跃点上优化，所以在这种情况下，网关将在调用Reviews服务之前等待来自产品服务的所有属性。因此，虽然<code class="du kv kw kx ky b">reviews</code>不需要履行信息，但它必须等待产品解决方案的长尾效应，然后才能进行点评。</strong></p><pre class="mn mo mp mq fd mr ky ms mt aw mu bi"><span id="8057" class="ll js hh ky b fi mv mw l mx my">//Review Service<br/>extend type Reviews <a class="ae ku" href="http://twitter.com/key" rel="noopener ugc nofollow" target="_blank">@key</a>(fields: "productId") {<br/> productId: String <a class="ae ku" href="http://twitter.com/external" rel="noopener ugc nofollow" target="_blank">@external</a><br/> reviews: [Review] <br/>}</span><span id="457e" class="ll js hh ky b fi mz mw l mx my">//Product Service<br/>type Product <a class="ae ku" href="http://twitter.com/key" rel="noopener ugc nofollow" target="_blank">@key</a>(fields: "productId")  {<br/>    productId:String<br/> productId: String <br/> url: String<br/> fulfilmentInfo:FulfilmentInfo<br/>}</span></pre><figure class="mn mo mp mq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/e6f36db95916f89873d6757db615959f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9bAajEL1Qx606zN5HrehQ.jpeg"/></div></div></figure><blockquote class="nd ne nf"><p id="0ab7" class="it iu nb iv b iw ix iy iz ja jb jc jd ng jf jg jh nh jj jk jl ni jn jo jp jq ha bi translated">上面的内容表明，一个模式有太多的依赖关系会增加在联合服务中必须编写的模板，并且依赖关系会影响查询执行计划——因此，为搜索视图建模性能优化的视图模型是一个难题</p></blockquote><h2 id="0e2c" class="ll js hh bd jt lm ln lo jx lp lq lr kb je ls lt kf ji lu lv kj jm lw lx kn ly bi translated">服务集成模式</h2><p id="f3a4" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">为了能够快速识别各种服务所使用的GQL模式，我们发现将一个名称与我们在此列出的各种模式相关联是非常有用的。</p><p id="9dd1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">原子实体</em> </strong></p><p id="3274" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最简单的集成，其中服务与图中的其他部分没有任何依赖关系。</p><figure class="mn mo mp mq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nj"><img src="../Images/fda6ee2e834627232b8406d712650fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAj1OzY3PVCuzGNTlYDhOg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Atomic Entity Representation</figcaption></figure><p id="9280" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">迷你管弦乐</em> </strong></p><p id="467f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里，GQL服务直接与其他服务协调，因为它有一个复杂的上游依赖关系来解析它的模式。</p><figure class="mn mo mp mq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nk"><img src="../Images/d7c10f393ba48a15dfb0ffd66ff6fd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvAU1leeRba7pWQGAxMc3g.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Mini orchestrator Entity Representation</figcaption></figure><p id="c6ee" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">聚合实体</em> </strong></p><p id="5c86" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">聚合实体引用远程实体并聚合它们的类型，它们需要这样做，因为它们需要在解析到远程实体之前进行预处理。</p><figure class="mn mo mp mq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/90ece3134ecddc1f1bac4128f862f7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1VOgG79b3XuxQb0OIDCeQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Aggregated Entity Representation</figcaption></figure><p id="22c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="nb">扩展实体</em> </strong></p><p id="50c9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">扩展实体通过向远程类型添加字段来修饰远程类型。</p><figure class="mn mo mp mq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/7f366bca137cfd365873ec7032f61e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Akk9GGvpzNNrzFIvkdJGQw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Extended Entity Representation</figcaption></figure><h1 id="2a69" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="8dec" class="pw-post-body-paragraph it iu hh iv b iw kp iy iz ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ha bi translated">联邦GraphQL对于关注点的分离和团队的自治非常有效。然而，必须对一些用例进行建模，牢记上述考虑因素，例如共享实体、图中节点之间的依赖关系，从性能角度和模式维护角度来看，这些都会导致效率低下。</p><p id="7380" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="nb">感谢</em> <a class="nn no ge" href="https://medium.com/u/60157e388cc0?source=post_page-----bfc85c2553de--------------------------------" rel="noopener" target="_blank"> <em class="nb">纳加·马莱帕蒂</em> </a> <em class="nb">对本文的贡献和评论。</em></p></div></div>    
</body>
</html>