<html>
<head>
<title>Cut the SASS: How to Use Inline JavaScript Styles for Everything.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">废话少说:如何在任何事情上使用内联JavaScript样式。</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/cut-the-sass-how-to-use-inline-javascript-styles-for-everything-f5ac5b77ae57?source=collection_archive---------0-----------------------#2016-10-05">https://medium.com/capital-one-tech/cut-the-sass-how-to-use-inline-javascript-styles-for-everything-f5ac5b77ae57?source=collection_archive---------0-----------------------#2016-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/79a074e3eaa24db93e2ef78a12286ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*jWocd5gR7jiw7GuuAX1HUg.jpeg"/></div></figure><p id="e458" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">今天，前端web开发是关于构建应用程序，而不仅仅是网页。虽然CSS和SASS都非常适合样式化页面，但是它们并不适合样式化应用程序。如果您正在使用基于组件的策略进行构建，这一点尤其正确。</p><p id="e01f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">基于组件的策略是将应用程序分解成称为组件的小的、可重用的构建块。使用组件构建您的应用程序可以为您的前端带来可重用性、清晰性和效率。</p><p id="a807" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了从基于组件的方法中获得全部好处，我们希望组件完全封装功能、标记和样式。</p><p id="61da" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我们将探索如何使用内联JavaScript编写风格是支持基于组件的开发的一个好方法。最终，我们将得到前端组件，它们是单个文件，易于共享，并且完全独立。</p><p id="5129" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">用JS编写你的风格是一个很大的改变，所以我想花一些时间来解释为什么我们想要这样做。我相信为正确的工作选择正确的工具。SASS无疑是当时的正确工具，提供了一些巨大的好处，例如:</p><ul class=""><li id="88ff" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated"><strong class="in hi">嵌套</strong></li><li id="2ffc" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">变数</strong></li><li id="0dc9" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> Mixins </strong></li></ul><p id="546b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">嵌套是一个很大的好处，因为它允许您的样式反映您的标记。如果你有:</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="df71" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可以做:</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="97b0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种好处不再有用了。我们仍然对让我们的样式反映我们的标记非常感兴趣，但是我们的标记已经改变了！</p><p id="c075" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">今天，使用基于组件的方法，我们更愿意将这些分成两个不同的组件，称为“用户列表”和“用户”。结果是两个文件，其中“用户列表”将包含一系列重复的“用户”。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="46b5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因为我们将应用程序分解成组件，所以我们应该使用相同的策略来编写我们的样式。这意味着我们应该尝试将样式和组件的标记放在一起，这样它们就可以封装在一起了。</p><p id="6a83" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">实现这一点的一种方法是使用内嵌样式，就像级联样式表出现之前的日子一样。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="3cdc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种经典方法非常适合基于组件的方法。我们不会使用它，因为它非常有限，但它展示了我们在现代造型解决方案中寻找的原则。</p><h1 id="cd9f" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">变量和混合</strong></h1><p id="4163" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">我们已经讨论了SASS的嵌套，那么其他大的好处呢——变量和混合？</p><p id="15e3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">好吧，恰好存在另一个非常流行的解决方案——JavaScript！</p><p id="6591" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们能够利用JavaScript的“var”和“function”的自然特性来提供我们在样式解决方案中需要的东西，这不是很好吗？如果我们使用JavaScript来编写我们的风格，我们会获得我们喜欢的JS的灵活性、功能和熟悉性。另外！我们的整个组件可以用一种语言编写！甚至一个文件！</p><h2 id="cb78" class="lg ke hh bd kf lh li lj kj lk ll lm kn iw ln lo kr ja lp lq kv je lr ls kz lt bi translated"><strong class="ak">我们的目标</strong></h2><p id="6078" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">这是我们想要做的:</p><ul class=""><li id="fde3" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">在标记旁边直接组合我们的样式</li><li id="766c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">“导入”和“导出”变量，如颜色或断点</li><li id="e3ce" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">基于状态(打开/关闭菜单等)编写“动态”样式。)</li></ul><p id="fccf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里还有一些要求:</p><ul class=""><li id="e96c" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">需要覆盖伪状态，如`:hover，:before，:after `等</li><li id="c5e9" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">必须直接支持媒体查询，如` @media (max-width: 600px)`等</li><li id="7c0d" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">允许函数/术语(见上面的动态)</li></ul><h2 id="f33d" class="lg ke hh bd kf lh li lj kj lk ll lm kn iw ln lo kr ja lp lq kv je lr ls kz lt bi translated"><strong class="ak"> <em class="lu">旁注:解释“JS样式”和“JS中的CSS”的区别</em> </strong></h2><p id="f5e2" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">有两种不同的方法:</p><ul class=""><li id="7109" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">您可以在JS中包含CSS</li><li id="3207" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">你可以使用JS编写你的CSS</li></ul><p id="89ea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我更喜欢第二种方法，这也是我们将在这里讨论的。</p><p id="efe8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于第一种方法，<a class="ae lv" href="https://github.com/css-modules/" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>是“在你的JS中编写CSS”类别中一个流行的解决方案。它限定了你写在组件的“div&lt;div&gt;T22】/div&gt;中的常规CSS的范围，或者命名空间。名称间距是您可以用类或id手动完成的事情，并不是单独使用这种东西的足够理由。对于可变支持或混合，您需要使用CSS“增强器”,如PostCSS或带有CSS模块的SASS。</p><p id="b304" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">同样，我们希望能够利用JavaScript的语言特性，包括变量、术语或函数。如果我们的解决方案迫使我们编写某种“增强的”CSS而不是JS，它将无法满足我们的需求。</p><p id="1c9f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有很多css-in-js解决方案可以用于这两种方法。看看他们！现在，我们将实现我发现的最能解决我们的目标和需求的方法。</p><h1 id="08e1" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">我们开始吧！</strong></h1><p id="3dce" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">我们将使用:</p><ul class=""><li id="7254" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">由<a class="ae lv" href="http://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>改造的ES6</li><li id="f5a5" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><a class="ae lv" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank">反应</a>来呈现我们的标记</li><li id="64de" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">从我们写的JS创建CSS。</li></ul><p id="2e42" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，我们将创建一个简单的组件，名为UserMenu。它会有一个小小的用户头像，当你点击它时会有一个下拉菜单。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="f4d6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您可以在您的应用程序页面上使用它，如下所示:</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="d0f5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">标记并不重要。这只是基本的React甚至AngularJS加上一点ES6 / <a class="ae lv" href="https://facebook.github.io/react/docs/reusable-components.html" rel="noopener ugc nofollow" target="_blank">无状态功能组件</a>语法。</p><p id="43d2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">开始造型吧！从阿芙罗狄蒂开始。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="1b92" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这里，我们按照文档的指示从<a class="ae lv" href="https://www.npmjs.com/package/aphrodite" rel="noopener ugc nofollow" target="_blank"> Aphrodite </a>导入我们需要的特定功能。</p><p id="8a64" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">关于导入的注意事项:我们使用“import {bar}”从“foo”语法导入特定的引用。阅读更多关于<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> MDN导入文档的信息</a></p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="01a1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们已经编写了一个“const styles ”,并在其中使用了“StyleSheet.create()”。这是来自<a class="ae lv" href="https://www.npmjs.com/package/aphrodite" rel="noopener ugc nofollow" target="_blank">阿芙罗狄蒂</a>的文档。Aphrodite将`&lt; style &gt;'标签插入到您的文档中，并为该标签插入`. foo ' CSS。它也有适当的名称空间。</p><p id="0b59" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们写了‘background color’而不是‘background-color’。我们所有的CSS属性都必须用JS封装！比如“marginLeft”、“fontSize”或“justifyContent”。这实际上很容易适应，尤其是如果你像我一样写了很多JavaScript的话！</p><p id="5fde" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> <em class="lw">这是最基本的。</em> </strong></p><p id="6953" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们想使用一种品牌颜色，而不是红色十六进制颜色。我们可以使用JavasScript变量。让我们建立一个“colors.js”文件。这是整个文件:</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="4a3e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们的颜色变量都是从这个文件中导出的。我们使用“const”而不是“var ”,因为这些值不会被重新赋值。现在我们可以在组件中导入文件，并像这样使用我们的颜色:</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="bb84" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们需要将JS变量与字符串结合使用，该怎么办呢？就像“边框”规格一样？简单。只需使用<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> ES6模板文字</a>。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="6a9d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们走吧。我们的变量与我们的字符串相结合。</p><p id="6604" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">伪类呢？没问题。Aphrodite非常支持伪类，如`:before `和`:after`。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="6757" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">简单地嵌套伪类，但是使用“string”作为键名(`:before `)！上面的例子将在用户名的左边创建一个小圆圈。</p><p id="08a5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">媒体查询的工作方式相同。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="8525" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们有了一个断点！填充将减少到“600像素”以下。</p><p id="1729" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，如果我们想更进一步，跟踪应用程序中的断点，会怎么样呢？JavaScript！</p><p id="d6a1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将创建一个单独的文件，编写我们希望用作字符串的断点，并将它们赋给变量。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="4c16" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们可以从。js文件，并把它作为一个变量，就像我们对' colors.js '做的那样。</p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="ca7d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">“[isMobile]”将从我们的“breakpoints.js”文件插入到字符串“@media (max-width: 600px)”中，并按预期工作。</p><p id="49b9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们做最后的实现。我们要把所有的放在一起，包括我们所学的一切。我们还将创建一个基于状态的样式，根据组件是打开还是关闭来显示菜单。</p><p id="a2fe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> <em class="lw">注:</em> </strong> <em class="lw">忽略从更高层次接收‘iso pen’变量的一些细节是安全的。假设它在其他地方被管理，单击我们的div会将它从“真”切换到“假”。</em></p><p id="6697" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> <em class="lw">注2: </em> </strong> <em class="lw">为了阅读这段代码，理解箭头函数很重要。当你习惯了它们，你会发现它们很棒。它们本质上是“函数”，会立即“返回”。</em><a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">MDN</a>上的箭头功能。</p><p id="5fcd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是我们的最终代码:(你也可以<a class="ae lv" href="http://codepen.io/jonandrewdavis/pen/WxLKrV?editors=1010" rel="noopener ugc nofollow" target="_blank">在CodePen上查看一个工作演示</a></p><figure class="jx jy jz ka fd ii"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="0977" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里的主要变化是我们将样式常量变成了一个返回StyleSheet.create对象的函数。它将isOpen作为组件的参数。当isOpen改变时，我们的菜单将显示和隐藏。</p><p id="6c7e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae lv" href="http://codepen.io/jonandrewdavis/pen/WxLKrV?editors=1010" rel="noopener ugc nofollow" target="_blank">查看工作演示</a></p><h1 id="6c97" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">结论</strong></h1><p id="f732" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">那么，我们用这种方法做了什么呢？嗯，我们能够将一个相当复杂的组件的所有内容封装在一个文件中，并且使用一种语言。</p><p id="e6dc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因为实现本质上都是JavaScript，所以您可以选择想要如何构造组件。JavaScript允许的所有模式对您都是可用的。</p><p id="69fa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这意味着您的样式解决方案可以直接反映您的整体应用程序架构。这种方法允许您完全控制自己的结构。您可以移动这些部分，并以您认为最容易阅读和最合理的方式将它们组合在一起。</p><p id="fb91" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">根据我的经验，最好的方法是创建许多小的、完全隔离的组件；其中大部分是“无状态”或“愚蠢”的组件，只在所谓的<a class="ae lv" href="https://vimeo.com/album/3953264/video/166790294" rel="noopener ugc nofollow" target="_blank">不可变应用架构</a>中自顶向下接收数据。</p><p id="3c6c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我更喜欢这些组件封装它们的标记、样式和功能。当有一个单一的位置和一个清晰的依赖树时，维护或更改组件就变得微不足道了。</p><p id="59b1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因为这些组件只有一个关注点，所以文件很少会变得太大。如果它们变得太复杂，您可以很容易地将它们抽象或重构为单独的组件。</p><p id="51ea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">内联JS样式的另一个好处是，在进行更新时定位代码变得很简单，因为组件所需的一切都在同一个文件中。</p><p id="d777" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以这种方式组成的组件也易于共享，因为您可以冒充为单个组件。js文件。你的消费者可以满足他们认为合适的“进口”申报。“进口反应”没有理由不能变成“进口角度”</p><p id="b4e4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我希望我已经展示了内联JS风格的强大之处，以及它们如何能够取代SASS，并对基于组件的开发提供了一些见解。这是一种真正适合我们团队的方法，希望它也适合你的团队！</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="0578" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">自2014年以来，安德鲁·戴维斯一直在为Capital One设计和开发出色的用户体验，自2001年以来一直在为更广泛的网络设计和开发用户体验。</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="e189" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="lw">欲了解更多关于Capital One的API、开源、社区活动和开发者文化，请访问我们的一站式开发者门户DevExchange。</em><a class="ae lv" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="lw"/></a></p></div></div>    
</body>
</html>