<html>
<head>
<title>Firebase Phone Authentication in Jetpack Compose using MVVM architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MVVM体系结构在Jetpack组合中进行Firebase电话认证</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/firebase-phone-authentication-in-jetpack-compose-using-mvvm-architecture-258775059aa7?source=collection_archive---------0-----------------------#2022-09-16">https://blog.kotlin-academy.com/firebase-phone-authentication-in-jetpack-compose-using-mvvm-architecture-258775059aa7?source=collection_archive---------0-----------------------#2022-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eba0d5031945f533c2e1201d69a0aa42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGCRJ5ONlbumUlRn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Franck</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cf71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将向你展示如何使用短信进行Firebase认证。</p><h1 id="c375" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目设置</h1><p id="c6ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用Jetpack Compose项目模板在Android Studio中创建新的Jetpack Compose项目。接下来我们要做的是将<em class="me">hilt-Android-gradle-plugin</em>和<em class="me"> google-services </em>插件添加到项目的根<em class="me"> build.gradle </em>文件中，并添加所需的Firebase和Play services依赖项</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="865b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后接下来，将这两个插件应用到你的<em class="me"> app/build.gradle </em>文件和<em class="me"> kotlin-kapt中。</em></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保您将Android Studio项目连接到Firebase项目，以便将<em class="me"> google-services.json </em>文件下载到您的项目中。</p><p id="d225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的下一件事是编写实际的代码。在我们继续之前，请注意，使用最新版本进行Firebase phone身份验证需要我们设置将进行身份验证的活动。这是为了让Firebase知道当验证码验证完成时要返回的活动。因此，在这种情况下，我们被迫使用反模式。这就是我们项目的结构。</p><pre class="mf mg mh mi gt ml mm mn mo aw mp bi"><span id="85b6" class="mq lc iq mm b gy mr ms l mt mu">AuthService-&gt;AuthServiceImpl-&gt;AuthViewModel-&gt;PhoneLoginUI()-&gt;MainActivity</span></pre><p id="7d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将创建一个<strong class="kf ir"> <em class="me">响应</em> </strong>密封类来指定身份验证所处的状态。它可以是已初始化、正在加载、出错或成功。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="64ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的下一件事是创建<em class="me"> AuthService </em>接口。它将有做一个firebase电话认证所需的基本方法。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me"> signUpdateState </em>变量将用于更新认证的状态。发送短信时调用onCodeSent方法。此时，状态会相应地更新。方法authenticate将用于调用Firebase服务来发送SMS，当用户手动键入发送到他们电话号码的SMS代码时，方法<em class="me"> onVerifyOtp </em>将被调用。如果一切顺利，我们将调用<em class="me">on verification completed</em>，否则我们将调用onverificationFailed。注意，我们按照<a class="ae kc" href="https://firebase.google.com/docs/reference/android/com/google/firebase/auth/PhoneAuthProvider.OnVerificationStateChangedCallbacks" rel="noopener ugc nofollow" target="_blank">OnVerificationStateChangedCallbacks</a>中的方法对其中的一些方法进行建模。</p><p id="b809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的下一个类是通过AuthServiceImpl实现AuthService接口。这里我们将创建一个类型为phoneauthprovider . OnVerificationStateChangedCallbacks的authCallbacks变量，我们关注的是OnVerificationStateChangedCallbacks的三个重要方法，分别是<em class="me"> onCodeSent </em>、<em class="me">onVerificationCompleted</em>和<em class="me"> onVerificationFailed。每种方法都有其用途。下面，让我们看看每种方法的作用。</em></p><p id="1a5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> onCodeSent <em class="me"> : </em> </strong> <em class="me">当短信代码发送到用户设备时调用</em></p><p id="15cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> onVerificationCompleted </strong>:在用户不输入代码的情况下，从用户的设备自动检索SMS时调用。当他们的SIM卡存在于该设备上并且SMS代码被自动选取时，这很可能会发生。然后，我们使用此代码并完成验证过程。</p><p id="918b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> onVerificationFailed </strong>:验证失败时调用。这可能是由于键入了错误的SMS代码或向Firebase发送了太多发送代码的请求。</p><p id="5428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<em class="me"> AuthServiceImpl </em>类。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="380b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AuthServiceImpl类看起来代码很多，但它相当简单。我们从构造函数注入<em class="me"> FirebaseAuth </em>和<em class="me"> MainActivity开始。这就是我们谈到的ani模式的用武之地。我们可以传递一个上下文，而不是我们的MainActivity，并用@ActivityContext对其进行注释，从而为我们提供<em class="me"> MainActivity </em>(因为我们的组件将由它托管)。我们这样做只是为了在创建<em class="me"> authBuilder </em>变量时调用<em class="me"> setActivity </em>方法。如果不设置活动，我们将无法进行身份验证。不知何故，我试图传递一个上下文参数并用<em class="me"> @ActivityContext </em>对其进行注释，以便它充当活动，但它一直失败。我不得不通过这种方式来提供主活动。我们将在ViewModel中使用这个类，我们可能会担心它可能会泄漏活动，但不要担心，我们将通过创建MainActivity的静态实例并在<em class="me"> onDestroy </em>中将它设置为null来确保这不会在MainActivity中发生。</em></p><p id="49ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用FirebaseAuth auth变量来创建<em class="me"> authBuilder </em>变量，并在创建<em class="me"> authBuilder </em>时将<em class="me"> authCallbacks </em>设置为回调。在每个被覆盖的方法中，我们相应地调用<em class="me"> authCallbacks </em>的适当方法。如果代码发送成功，并且设备自动获取代码，则调用onVerificationCompleted。我们现在使用此代码来检索使用此代码的<em class="me"> PhoneAuthCredential </em>，并使用此凭据将用户登录到应用程序。这就是<em class="me">signInWithAuthCredential</em>方法的目的。如果用户的SIM卡在不同的设备中，他们将不得不手动键入代码，在这种情况下，我们还将调用signInWithAuthCredential。这就是<em class="me"> onVerifyOtp </em>方法的目的。</p><p id="d52f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户提交电话号码时调用的方法是authenticate。我们在authBuilder上调用<em class="me"> setPhoneNumber(phone) </em>，然后构建一个PhoneAuthOptions对象，并进一步调用<em class="me">phoneauthprovider . verify phonenumber(options)</em>。请注意signUpState的状态在每种情况下是如何更新的。</p><p id="87b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的下一件事是创建AuthViewModel类。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们将大部分工作委托给了AuthServiceImpl类，所以ViewModel将相应地调用AuthServiceImpl中的每个方法。<em class="me">号</em>和<em class="me"> phone </em> I将分别用于输入电话号码和代码。每个<em class="me">on exchange</em>方法用于更新<em class="me">电话</em>号码和<em class="me">代码</em>的状态。ViewModel将在我们的根组件中用于身份验证。</p><p id="ff06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的下一件事是为身份验证编写实际的UI代码。我们不会只对所有代码使用一个大的可组合组件，而是会根据应用程序状态(s <em class="me"> ignUpState </em>)来分解这些组件。因此，我们将拥有用于<strong class="kf ir">初始化状态</strong>、<strong class="kf ir">加载状态</strong>和<strong class="kf ir">错误</strong>状态的用户界面。我们假设在成功状态下，我们将导航到下一个屏幕。最后，我们将拥有包含主题组件的根组件。</p><p id="d646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">未初始化状态有一个供用户输入电话号码的文本字段和一个继续操作的按钮。当发送代码时，将会有为用户提供的UI，当出现错误时，将会有错误UI。让我们首先看看可组合的电话输入。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电话号码UI取<em class="me">电话</em>号码、<em class="me"> onPhoneChange </em>、<em class="me"> onClick </em>和<em class="me">on one</em>。我想你应该明白州政府的做法。我们已经为电话号码专门编写了一个单独的composable，它获取电话号码，附加到value参数，onNumberChange，它被分配给<em class="me"> OutlinedTextField </em>的<em class="me"> onValueChange </em>方法和<em class="me">on one</em>方法，当用户点击键盘上的Done按钮时将调用它们。这就是我们将imeAction设置为onDone的原因。</p><p id="e309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个组件是输入代码的组件。它几乎类似于电话号码，但这一次，我们没有按钮。当用户点击Go操作键时，我们将调用适当的方法。这就是为什么我们在这里将imeAction设置为onGo。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="84a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个错误UI只是显示基于Throwable的错误消息。它提供了一个重启按钮，供用户重启。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个可组合组件是我们的主可组合组件，它将根据状态显示上述每个可组合组件。我们将在这个可组合组件中使用AuthViewModel。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于状态更改，我们使用StateFlows和collectAsState composable，它是Flow的一个扩展函数。</p><p id="5352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来要做的是提供各种对象，比如FirebaseAuth、MainActivity和AccountService。我们将使用@Provides注释来提供FirebaseAuth和MainActivity，并将使用@Binds来构造AuthService。在这种情况下，我们将实现传递给方法的构造函数，返回类型是接口。我们仍然可以使用@Binds显式地创建它。以下是模块。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ea35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将在MainActivity中创建getInstance方法来返回实例。我们当然会在活动的<em class="me">on detail</em>方法中销毁它，以避免泄露活动上下文。不要忘记用@ AndroidEntryPoint对MainActivity类进行注释。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a9f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，创建我们的Hilt应用程序类，并将其设置为<em class="me"> AndroidManifest.xml </em>中的名称。</p><pre class="mf mg mh mi gt ml mm mn mo aw mp bi"><span id="d559" class="mq lc iq mm b gy mr ms l mt mu">@HiltAndroidApp<br/>class MainHiltApp : Application()</span></pre><p id="b9e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正在清单中设置应用程序。</p><pre class="mf mg mh mi gt ml mm mn mo aw mp bi"><span id="d4f7" class="mq lc iq mm b gy mr ms l mt mu">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:tools="http://schemas.android.com/tools"&gt;<br/><br/>    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;<br/>  &lt;application<br/>        android:allowBackup="true"<br/>        android:name=".ui.MainHiltApp"<br/>        ....../&gt;<br/>/&gt;</span></pre><p id="6877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇长文能帮助一些人。请在下面留下您的评论和批评。</p></div></div>    
</body>
</html>