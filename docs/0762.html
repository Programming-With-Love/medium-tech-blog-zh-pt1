<html>
<head>
<title>Migrating the AOSP QuickSearchBox App to Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将AOSP QuickSearchBox应用程序迁移到科特林</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-the-aosp-quicksearchbox-app-to-kotlin-1264346619ec?source=collection_archive---------0-----------------------#2022-09-23">https://medium.com/androiddevelopers/migrating-the-aosp-quicksearchbox-app-to-kotlin-1264346619ec?source=collection_archive---------0-----------------------#2022-09-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2bdc" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">提交人:<em class="jd"> Ryan O'Leary，Android实习生</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/71657467aedf1a3f99689d6e57756270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWnPe-kD4hAVuH3IIcNUcA.png"/></div></div></figure><h1 id="a67c" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">概观</h1><p id="f17a" class="pw-post-body-paragraph if ig hh ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc ha bi translated">在过去的三年里，<a class="ae kt" href="https://android.googlesource.com/platform/packages/apps/" rel="noopener ugc nofollow" target="_blank"> Android开源项目(AOSP)应用</a>团队承担了将AOSP应用从Java转换成Kotlin的任务。这种追求是Android承诺的一部分，即通过<a class="ae kt" href="https://developer.android.com/kotlin/first" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hi"> Kotlin-first </strong> </a>不断发展。Kotlin是一种安全、实用、简洁的语言，具有许多语言特有的优势。有用的Kotlin语言特性包括:</p><ul class=""><li id="51b5" class="ku kv hh ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hi">空安全</strong>:除非明确指定，否则Kotlin类型不可为空。这对于开发人员避免难以跟踪的空指针异常非常有用。</li><li id="a333" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hi">简洁</strong> : Kotlin允许开发人员减少样板代码的数量，与Java相比，用更少的代码行表达更多。</li><li id="a75d" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hi"> Java互操作性</strong>:Kotlin和Java编程语言之间的互操作性被证明对这个项目非常有帮助，因为移植可以逐步完成，并且对所有从事混合Java和kot Lin项目的开发人员都很有用。</li><li id="3b09" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hi"> Jetpack库和协程</strong> : Kotlin通过协程为轻量级结构化并发提供了语言内支持。此外，Android开发内容是Kotlin-first，并提供对有用的Jetpack库的访问。</li></ul><p id="fd6c" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">AOSP实习生在2019年转换了AOSP <a class="ae kt" rel="noopener" href="/androiddevelopers/re-writing-the-aosp-deskclock-app-in-kotlin-76c836370cb">桌面时钟</a> app，在2020年转换了<a class="ae kt" rel="noopener" href="/androiddevelopers/re-writing-the-aosp-calendar-app-in-kotlin-48ceb0e3a65c">日历</a> app，在类似文章中详细介绍了迁移过程。今年，AOSP团队开始全面转换QuickSearchBox应用程序，作为2022年夏季实习生项目的一部分。QuickSearchBox应用程序于2009年通过Android 1.6版本推出，允许用户直接从主屏幕上搜索他们的设备和网络，根据下载的内容、联系人、应用程序和浏览器历史记录提供建议。在6周的时间里，QuickSearchBox应用程序中超过11，000行Java代码被转换为Kotlin，以展示Android开发中的最佳实践，并以Kotlin为先的理念提供QuickSearchBox应用程序的功能。</p><h1 id="9d75" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">自动转换和错误修复</h1><p id="71b4" class="pw-post-body-paragraph if ig hh ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc ha bi translated">为了将QuickSearchBox应用迁移到Kotlin，我们利用了Android Studio中包含的<a class="ae kt" href="https://developer.android.com/kotlin/add-kotlin#convert" rel="noopener ugc nofollow" target="_blank"> Kotlin转换工具</a>。我们的流程遵循五个步骤:</p><ol class=""><li id="83a3" class="ku kv hh ih b ii ij im in iq kw iu kx iy ky jc li la lb lc bi translated">使用命令<code class="du lj lk ll lm b">cp ExampleFile.java ExampleFile.kt</code>将<code class="du lj lk ll lm b">.java</code>文件复制到同名的<code class="du lj lk ll lm b">.kt</code>文件中</li><li id="a042" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">利用提供的转换工具将Java代码转换成Kotlin</li><li id="90f1" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">将<code class="du lj lk ll lm b">.java</code>文件添加到<code class="du lj lk ll lm b">Android.bp</code>文件的<code class="du lj lk ll lm b">exclude_srcs</code>属性中，这样转换就可以增量进行，一次一个文件</li><li id="13b1" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">解决编译错误和由转换引入的任何其他错误</li><li id="5e78" class="ku kv hh ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">运行并通过单元测试来检查基于Kotlin的实现的正确性，并运行手动测试来检查Kotlin和基于Java的遗留应用程序之间的功能对等性。</li></ol><p id="8780" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">每个步骤的git历史都被维护，以向外部开发人员展示迁移过程，并且可以在<a class="ae kt" href="https://cs.android.com/android/_/android/platform/packages/apps/QuickSearchBox/+/master:src/com/android/quicksearchbox/" rel="noopener ugc nofollow" target="_blank"> AOSP QuickSearchBox </a>的主分支中查看每个文件。由于在Android Studio的Java-to-Kotlin转换工具中发现了几个常见问题，这一过程中的错误修复步骤是必要的，这些问题出现在大多数迁移的AOSP QuickSearchBox文件中。</p><p id="94d6" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">这些常见问题及其解决方案如下:</p><p id="1e9a" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong>在转换后的Kotlin文件中，所需的导入语句经常会被删除</p><p id="b0e8" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方案:</strong>在需要的导入报表中手工转换</p><p id="5396" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong><code class="du lj lk ll lm b">override</code>关键字通常不会添加到标记为<code class="du lj lk ll lm b">@Override</code>的方法和变量中</p><p id="73fc" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方法:</strong>手动加入<code class="du lj lk ll lm b">override</code>修改量</p><p id="ba08" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong>遇到的一个更大的问题是Kotlin代码中可空变量到不可空变量的转换。这导致了各种各样的错误，从类型不匹配到QuickSearchBox代码的大部分没有被执行，因为依赖于空值检查的逻辑现在没有被使用。一次转换一个文件也意味着在未转换的Java文件中使用固有的可空类型会在Kotlin代码中试图赋值、覆盖或返回那些继承的变量时产生问题。</p><p id="35bc" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方案:</strong>在大多数情况下，为了实现期望的功能，这些属性实际上需要是可空的。这里的解决方案只是通过在类型声明中添加<code class="du lj lk ll lm b">?</code>来使用可空类型。这需要在适当的地方添加安全调用(<code class="du lj lk ll lm b">?.</code>)，并在必要的地方更改预期类型以避免不匹配错误。虽然这看起来与Kotlin的空安全性质相违背，但是有必要让一些属性保持为空，因为它们是异步设置的，并且所有不可为空的变量都是如此。</p><p id="8684" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong>以<code class="du lj lk ll lm b">get</code>和<code class="du lj lk ll lm b">set</code>开头的函数被转换器更改为带有显式定义的getter/setter的变量，但是许多用法没有改变，没有定义</p><p id="9c06" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方案:</strong>手动将对转换后的函数的调用改为变量名；例如<code class="du lj lk ll lm b">getSuggestions()</code>-&gt;-<code class="du lj lk ll lm b">suggestions</code></p><p id="3134" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong><code class="du lj lk ll lm b">getClass()</code>的用法未被Kotlin代码中的转换器更改。与Java不同，Kotlin不支持在对象上调用<code class="du lj lk ll lm b">getClass()</code>来检索<code class="du lj lk ll lm b">Class</code>类型的令牌。</p><p id="4174" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方案:</strong>利用Kotlin的类引用语法，将<code class="du lj lk ll lm b">getClass()</code>的用法改为<code class="du lj lk ll lm b">::class</code>来返回<code class="du lj lk ll lm b">KClass</code>令牌。</p><p id="fb62" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">常见问题:</strong>quick search box项目是在打开了<code class="du lj lk ll lm b">-Werror</code>标志的情况下构建的，一个常见的错误来源是在Kotlin类中使用了<code class="du lj lk ll lm b"><a class="ae kt" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener ugc nofollow" target="_blank">java.util.Collection</a></code>。将应用程序迁移到Kotlin时，建议开发人员利用为Kotlin构建的库，以最大化特定语言的优势。</p><p id="59aa" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><strong class="ih hi">解决方案:</strong>切换到使用所需类的Kotlin等价类。这样做的好处是增加了安全性，因为在必要时可以将类指定为可变的或不可变的。</p><p id="8467" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">即<code class="du lj lk ll lm b">java.util.Collection</code>-&gt;-<code class="du lj lk ll lm b">kotlin.collections.Collection</code>或<code class="du lj lk ll lm b">kotlin.collections.MutableCollection</code></p><p id="13de" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">随着迁移的进行，QuickSearchBox应用程序的API级别也更新到了最新版本。这涉及到用Android推荐的新版本替换几个被否决的函数调用。这方面的一个例子是在<code class="du lj lk ll lm b">SearchBaseUrlHelper</code>中弃用了<code class="du lj lk ll lm b">AsyncTask</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f099" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><code class="du lj lk ll lm b">AsyncTask</code>在API level 30中被弃用，<a class="ae kt" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank"> Android文档</a>推荐使用<code class="du lj lk ll lm b"><a class="ae kt" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.util.concurrent</a></code>或<a class="ae kt" href="https://developer.android.com/topic/libraries/architecture/coroutines" rel="noopener ugc nofollow" target="_blank"> Kotlin并发实用程序</a>。由于这个项目是为了展示在Kotlin中开发的好处，我们用Kotlin协程作用域和<code class="du lj lk ll lm b">async</code>块来异步发出网络请求，从而取代了<code class="du lj lk ll lm b">AsyncTask</code>的使用。虽然像Java一样，Kotlin支持线程的创建，但协程是非阻塞和无堆栈的，允许使用更少的内存。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9257" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">最后，开发人员应该注意的一个微妙的错误来源来自Kotlin converter特性，该特性将名称以<code class="du lj lk ll lm b">get</code>和<code class="du lj lk ll lm b">set</code>开头的方法更改为带有显式定义的getters和setters的变量。当这种变化发生时，转换器将把迁移的函数重新命名为相同名称的变量，除了没有前面的<code class="du lj lk ll lm b">get</code>或<code class="du lj lk ll lm b">set</code>。但是，转换器无法检查同名的现有用法，这可能会在转换后的代码中引入毁灭性的错误。在大量使用这些变量的大型文件中，这些错误难以捕捉。这见于文件<code class="du lj lk ll lm b">DelayingSuggestionsAdapter</code>，其中的行:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="7265" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">在Kotlin代码中被更改为:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="7d17" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">这引入了一个微妙的运行时错误，对象会过早释放，在一个完全不同的文件中生成一个异常。虽然修复只是简单的一行代码更改，但是对于开发人员来说，跟踪由转换引起的所有不正确的用法可能非常耗时，并且理想情况下，转换器在创建新变量之前会利用更全面的代码检查。</p><h1 id="a5f9" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">技术性能分析</h1><p id="e3cb" class="pw-post-body-paragraph if ig hh ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc ha bi translated">完成转换后，我们运行了一些基准测试，以分析AOSP QuickSearchBox应用程序在迁移到Kotlin时发生的变化。我们可以使用一些有趣的性能指标来比较功能完整的QuickSearchBox应用程序的Java和Kotlin版本，包括:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/25796c3f6601aef83a580c4348ac55cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6CTIV_4uQytd8hv7uwtXw.png"/></div></div></figure><p id="f192" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">迁移完成后，我们看到总代码行数减少了大约<strong class="ih hi"> 11.5% </strong>。还值得注意的是，QuickSearchBox应用程序的迁移侧重于在转换到Kotlin时保持应用程序的现有功能，而没有对代码结构进行大规模重构。如果我们从Kotlin开始重新编写整个QuickSearchBox应用程序，我们相信通过更好地利用Kotlin的简洁特性，有可能实现更大的规模缩减。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lq"><img src="../Images/87915b5e4e379634928c3c2a5060805b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6iPeWl4WMLcBnDf4sOKdA.png"/></div></div></figure><p id="7600" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">我们确实看到了APK大小的显著增加，但是这种增加可以归因于这个项目中新包含的<code class="du lj lk ll lm b"><a class="ae kt" href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener ugc nofollow" target="_blank">kotlinx-coroutines</a></code>和<code class="du lj lk ll lm b"><a class="ae kt" href="https://developer.android.com/jetpack/androidx/releases/core" rel="noopener ugc nofollow" target="_blank">androidx.core</a></code>库。添加<code class="du lj lk ll lm b">androidx.core</code>库是为了用推荐的替换来替换几个不赞成使用的函数调用，以便QuickSearchBox能够以最新的API级别为目标，并且无论Kotlin迁移如何都会发生。由于QuickSearchBox APK的整体大小仍然很小(总共不到一MB)，我们认为这种增长是合理的。</p><p id="1c7a" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">从一开始，小应用程序的另一个后果是，相对代码大小的增加看起来相当大，然而，这种增加并不随着APK的大小而增加，并且无论应用程序有多大，在增加的KB方面基本保持不变。也就是说，对于一个大的应用程序来说，它将是百分之几。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/3a840acf0baf09f1c4cba3cdcc0b2b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CinyhwFGuID57XbV3yxgkw.png"/></div></div></figure><p id="1465" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated">最后，对于每种语言，代码的干净构建时间平均超过10次试验。这些测试以及之前的基准测试都是在一台拥有96个内核和180 GB内存的机器上进行的。我们实际上看到Kotlin版本的应用程序的总构建时间略有减少，这可能是由于# LOC的减少，切换到几个更新的API调用，以及使用Kotlin的协同程序。</p><h1 id="d9f5" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="a7a5" class="pw-post-body-paragraph if ig hh ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc ha bi translated">总的来说，AOSP QuickSearchBox应用程序的迁移花费了大约6周的时间，有一名实习生参与了这个项目。随着对Git/Repo、Kotlin和Android Studio Kotlin工具中常见错误的熟悉，转化率大大提高。到项目中期，转换文件、修复错误、格式化和维护Git历史的过程非常高效，每天迁移多达10个文件。最终，这个项目帮助证明了将应用程序转换为Kotlin的好处，从更简洁的语法到提供对有用的库和轻量级并发的访问，并可以作为其他寻求迁移自己的应用程序的开发人员的榜样。</p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><p id="879c" class="pw-post-body-paragraph if ig hh ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc ha bi translated"><em class="jd"> Java是甲骨文和/或其附属公司的商标或注册商标。</em></p></div></div>    
</body>
</html>