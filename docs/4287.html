<html>
<head>
<title>Android MVI architecture with Jetpack &amp; Coroutines/Flow — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Jetpack和协程/流的Android MVI架构—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-1-recyclerview-adapter-w-83a10134207f?source=collection_archive---------1-----------------------#2020-03-29">https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-1-recyclerview-adapter-w-83a10134207f?source=collection_archive---------1-----------------------#2020-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="e5a5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">具有ViewBinding的RecyclerView适配器</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/8c1484ec73a3a34bcd7809ebe53d5a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdHQrw_ZDOQnCQLS-OromA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@mikeanywhere?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mike Lewis HeadSmart Media</a> on <a class="ae js" href="https://unsplash.com/s/photos/flow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="d68d" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">我从2011年末开始在Android上进行开发，并且一直记得，从早期开始，我们就希望谷歌对Android上建议的架构发表意见:)</p><p id="698f" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">这确实在几年后发生了，Jetpack的Android架构组件引入了<strong class="kc hi">视图模型</strong>。<strong class="kc hi"> ViewModels </strong>是<strong class="kc hi"> VM </strong>的一部分，属于<strong class="kc hi"> MVVM </strong>架构，也能经受住屏幕上的配置变化。视图模型通过由<strong class="kc hi"> LiveData </strong>实现的可观察流与UI通信。</p><p id="7b9c" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">不过，事实是，社区也需要一种新的方法来使异步API调用和数据库操作(或一般的非主线程工作)更容易，而没有RxJava对大多数反应式框架初学者的学习曲线。RxJava的替代方案也很老套，更容易被像我这样不擅长原始线程和并发的人错误地使用😝！</p><h1 id="22dd" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">输入Kotlin协程和流程</h1><p id="1717" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">尽管社区最近开始转向Kotlin协同例程，它提供了结构化并发和Kotlin流，可以基本上取代我们过去使用的RxJava方式，以便将我们架构各层之间的数据转换为流。这可能是双向的，也可能是单向的，取决于每个项目的需要。</p><h1 id="d382" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我们将要讨论的内容</h1><p id="d0b4" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">在这一系列文章中，我们将看到如何创建一个新的应用程序，它获取Github用户的Github存储库，将它们保存在本地存储中，并且只观察本地存储，以便显示任何UI更改。我们还将看到如何在新发布的ViewBinding的帮助下创建RecyclerView ListAdapter，以便免费利用不同的功能。</p><p id="5bd9" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">为了实现上述所有目标，我们将利用Jetpack的Android架构组件以及Kotlin Coroutines + Flow来处理我们需要在任何层上进行异步工作的部分，无论是远程API源，还是由Room支持的本地存储。</p><p id="b691" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">最后但同样重要的是，我们将看到如何模块化应用程序，以及如何为多模块项目配置我们的Kotlin风格和静态代码分析工具(Detekt+pincavity)。最后，我们将了解如何利用所有这些配置来为我们新创建的应用程序创建无缝的CI渠道。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="0147" class="ie if hh bd ig ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb bi translated">使用ViewBinding创建基本RecyclerView适配器</h1><p id="6f7e" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">为了在应用程序中为我们所有的RecyclerViews创建一个基本适配器，我们决定也使用新发布的ViewBinding，并使用ListAdapter的功能来非常容易地实现区分。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="535d" class="li if hh bd ig lj lk ll ik lm ln lo io kl lp lq is kp lr ls iw kt lt lu ja lv bi translated">创建基本适配器项目</h2><p id="9edd" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">通过这样做，我们将能够有一个单一的接口来实现和使用我们的适配器项目的公共配置。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="b6fc" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">该项只包含一个<code class="du ly lz ma mb b">itemViewType</code>属性，这样我们就可以拥有多态RecyclerView适配器。我们现在只需要这个属性，但是我们可以在将来添加更多的属性来丰富我们的基本功能。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="0e02" class="li if hh bd ig lj lk ll ik lm ln lo io kl lp lq is kp lr ls iw kt lt lu ja lv bi translated">创建基础视图固定器</h2><p id="9f19" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">我们的基本视图容器将从每个适配器中的每个视图容器扩展而来。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="b06c" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">我们在这里做的是创建一个抽象类，并使用泛型来利用我们在上面创建的基本适配器项和该项布局的ViewBinding。</p><p id="caf2" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">我们的视图持有者的<code class="du ly lz ma mb b">bind</code>方法是抽象的，因为我们需要每个新的视图持有者扩展那个视图持有者来实现这个方法。</p><p id="5466" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">另一个可用的方法是<code class="du ly lz ma mb b">bind</code>，它有一个有效负载列表，可以帮助我们部分更新RecyclerView中的行。因为我们在基本适配器上覆盖了这两个方法(见下文)，所以我们需要生成那个方法<code class="du ly lz ma mb b">open</code>并提供一个调用<code class="du ly lz ma mb b">abstract bind(item: Item)</code>的默认实现，以确保当区分操作不输出任何结果时(见下文)，我们能够正确地回退。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="af3a" class="li if hh bd ig lj lk ll ik lm ln lo io kl lp lq is kp lr ls iw kt lt lu ja lv bi translated">创建基本适配器</h2><p id="9e79" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">我们的基本适配器将从<code class="du ly lz ma mb b">ListAdapter</code>开始扩展，因为我们希望在回收视图中使用<code class="du ly lz ma mb b">DiffUtil</code>进行区分。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="ff85" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">我们这里的实现只是将<code class="du ly lz ma mb b">onBindViewHolder</code>方法委托给我们自己的视图持有者。我们还提供了一个扩展函数，以便在创建新的适配器时更容易访问布局生成器。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="063e" class="li if hh bd ig lj lk ll ik lm ln lo io kl lp lq is kp lr ls iw kt lt lu ja lv bi translated">创建基本差异回调</h2><p id="5d6a" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">我们的基本DiffUtil回调将从<code class="du ly lz ma mb b">DiffUtil.ItemCallback</code>扩展并使用<code class="du ly lz ma mb b">ViewBindingAdapterItem</code>作为通用输入。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="fcf1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="65f2" class="pw-post-body-paragraph ka kb hh kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx ha bi translated">我们现在可以通过扩展已经创建的基本组件，用最少的努力创建尽可能多的适配器:)</p><p id="14af" class="pw-post-body-paragraph ka kb hh kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ha bi translated">您可以在下面的repo中找到上面的所有代码以及它们的用法示例，这也是我们将在这一系列文章中讨论的内容！</p><div class="mc md ez fb me mf"><a href="https://github.com/pavlospt/refactored-umbrella" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">pavlospt/重构-雨伞</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">重构的保护伞是一个附带项目，以检查与科特林协同程序和流量，MVVM和Koin现代Android开发…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jm mf"/></div></div></a></div></div></div>    
</body>
</html>