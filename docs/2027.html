<html>
<head>
<title>What is slicing in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的切片是什么？</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/what-is-slicing-in-python-8584abf2eabe?source=collection_archive---------1-----------------------#2019-09-19">https://medium.com/duomly-blockchain-online-courses/what-is-slicing-in-python-8584abf2eabe?source=collection_archive---------1-----------------------#2019-09-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d0a9a6350c77b1fa3e2f0928649605a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odSHhPuVDAbwjKvR1yyl3Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="5a58" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发表于<a class="ae it" href="https://www.blog.duomly.com/slicing-in-python-what-is-it/" rel="noopener ugc nofollow" target="_blank">https://www.blog.duomly.com/slicing-in-python-what-is-it/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="19ab" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python中的切片是一种支持访问字符串、元组和列表等序列部分的特性。您还可以使用它们来修改或删除可变序列的项目，如列表。切片还可以应用于第三方对象，如NumPy数组，以及Pandas系列和数据框。</p><p id="3c61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">切片使得编写干净、简洁、可读的代码成为可能。</p><p id="2b9d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文展示了如何访问、修改和删除带有索引和切片的项目，以及如何使用内置的类slice()。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="kd ke l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://youtu.be/ZOxs7grEjWM" rel="noopener ugc nofollow" target="_blank">Slicing in Python</a></figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="7ad9" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">索引</h1><p id="0429" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">您可以使用相应的整数索引来访问Python序列的单个项目(如字符串、元组或列表)。Python中的索引是从零开始的。这意味着索引0对应于序列的第一个(最左边的)项，1对应于第二个项，依此类推。</p><p id="3c04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们创建一个字符串、一个元组和一个列表来说明如何使用索引:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="87fb" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_ = 'Python is awesome!'<br/>&gt;&gt;&gt; str_<br/>'Python is awesome!'<br/>&gt;&gt;&gt; tuple_ = (1, 2, 4, 8, 16, 32, 64, 128)<br/>&gt;&gt;&gt; tuple_<br/>(1, 2, 4, 8, 16, 32, 64, 128)<br/>&gt;&gt;&gt; list_ = [1, 2, 4, 8, 16, 32, 64, 128]<br/>&gt;&gt;&gt; list_<br/>[1, 2, 4, 8, 16, 32, 64, 128]</span></pre><p id="9d1a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">括号内提供了索引，即语法序列[index]:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="9a5f" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[0]<br/>'P'<br/>&gt;&gt;&gt; str_[1]<br/>'y'<br/>&gt;&gt;&gt; str_[4]<br/>'o'<br/>&gt;&gt;&gt; tuple_[0]<br/>1<br/>&gt;&gt;&gt; tuple_[1]<br/>2<br/>&gt;&gt;&gt; tuple_[4]<br/>16<br/>&gt;&gt;&gt; list_[0]<br/>1<br/>&gt;&gt;&gt; list_[1]<br/>2<br/>&gt;&gt;&gt; list_[4]<br/>16</span></pre><p id="fa3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如你所见,“P”是字符串“Python太棒了！”的第一个字符它对应的索引是0，' y '是第二个，索引是1，以此类推。</p><p id="d5e9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它与元组和列表非常相似。</p><p id="6237" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python也提供了使用负整数索引的可能性。这在实践中似乎非常有用，尤其是当您想要访问序列的最后(最右边)项时。</p><p id="782c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">索引-1对应于最后一项，-2对应于倒数第二项，依此类推:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="d3e4" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[-1]<br/>'!'<br/>&gt;&gt;&gt; str_[-2]<br/>'e'<br/>&gt;&gt;&gt; str_[-5]<br/>'s'<br/>&gt;&gt;&gt; tuple_[-1]<br/>128<br/>&gt;&gt;&gt; tuple_[-2]<br/>64<br/>&gt;&gt;&gt; tuple_[-5]<br/>8<br/>&gt;&gt;&gt; list_[-1]<br/>128<br/>&gt;&gt;&gt; list_[-2]<br/>64<br/>&gt;&gt;&gt; list_[-5]<br/>8</span></pre><p id="072c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如你所见，字符'！'是字符串“Python真棒！”中的最后一项它对应于索引-1。它还有索引17，也就是string_[17]返回'！'。字符“e”出现在它的前面，索引为-2和16。</p><p id="3cdf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，元组和列表的行为类似。</p><p id="80a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用索引来修改可变序列的项目。在Python中，字符串和元组是不可变的，但列表是可变的:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="05db" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; list_[-1] = 100<br/>&gt;&gt;&gt; list_<br/>[1, 2, 4, 8, 16, 32, 64, 100]</span></pre><p id="f5de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本示例将列表的最后一项更改为100。因为这个列表有八个条目，所以您也可以使用从零开始的索引7来访问最后一个条目，也就是说，您可以使用语句list_[7] = 100来实现相同的效果。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="794f" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">限幅</h1><p id="31c3" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">切片类似于索引，但它返回一系列项目，而不是单个项目。用于切片的索引也是从零开始的。</p><p id="fd93" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">切片语法有两种变体:sequence[start:stop]和sequence[start:stop:step]。这篇文章解释了这两者。</p><p id="166d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当你使用语法序列[start:stop]时，你会得到新的序列。它将从索引开始(含)的项目开始，并在索引停止的项目之前结束<em class="ls">。换句话说，语句sequence[start:stop]返回项目sequence[start]，sequence[stop-1]以及它们之间的所有项目:</em></p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="4636" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[1:5]<br/>'ytho'<br/>&gt;&gt;&gt; tuple_[2:4]<br/>(4, 8)<br/>&gt;&gt;&gt; tuple_[2:3]<br/>(4,)<br/>&gt;&gt;&gt; tuple_[2:2]<br/>()</span></pre><p id="1d20" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如您所见，当start + 1 == stop时，返回序列只能包含一个项目，或者当start == stop时，它可以是一个空序列。</p><p id="8d41" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您省略start时，取值0，即结果序列从原始序列的开始处开始:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="73b4" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[:2]<br/>'Py'<br/>&gt;&gt;&gt; tuple_[:4]<br/>(1, 2, 4, 8)</span></pre><p id="b655" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果省略stop，则产生的序列将在原始序列的末尾停止:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="4fa2" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[2:]<br/>'thon is awesome!'<br/>&gt;&gt;&gt; tuple_[4:]<br/>(16, 32, 64, 128)</span></pre><p id="c5b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，您可以省略start和stop:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="ae57" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[:]<br/>'Python is awesome!'<br/>&gt;&gt;&gt; tuple_[:]<br/>(1, 2, 4, 8, 16, 32, 64, 128)<br/>&gt;&gt;&gt; list_[:]<br/>[1, 2, 4, 8, 16, 32, 64, 100]</span></pre><p id="e40c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是你如何得到一个序列的浅层拷贝。</p><p id="7dae" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以像索引一样应用负值的开始和停止:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="0c63" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; str_[-8:]<br/>'awesome!'<br/>&gt;&gt;&gt; tuple_[:-1]<br/>(1, 2, 4, 8, 16, 32, 64)<br/>&gt;&gt;&gt; tuple_[-4:-2]<br/>(8, 16)<br/>&gt;&gt;&gt; tuple_[3:5]<br/>(8, 16)</span></pre><p id="81de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在tuple_的情况下，从-1开始向后计数时，值-4对应于从0开始向前计数时的值3。对于值5和-2也是一样的。同样，对应于索引停止点<em class="ls">的项目不包含在结果序列中。</em></p><p id="6fc4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">语法序列[start:stop:step]是相似的，但是细节更少。</p><p id="d4ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果要跳过某些项目，可以使用步骤来指定步骤:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="7017" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; tuple_[1:5:2]<br/>(2, 8)</span></pre><p id="3531" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，步骤为2，因此您从索引为1的项目(项目2)开始，每隔一个项目收集一次，并在到达索引为5的项目(32)之前停止。你拿第二项，跳过第四项，拿第八项。</p><p id="61d9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果步长为正，并且您省略了start，则生成的序列将再次从原始序列的开始处开始。如果省略stop，操作将在原始文件的末尾停止。然而，如果你省略了一个步骤，它被认为是1，你会得到与语法序列[start:stop]相同的行为:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="3730" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; tuple_[:6:2]<br/>(1, 4, 16)<br/>&gt;&gt;&gt; tuple_[3::2]<br/>(8, 32, 128)<br/>&gt;&gt;&gt; tuple_[1:5:]<br/>(2, 4, 8, 16)</span></pre><p id="3bf8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">负值的步长与大于停止时间的开始时间相结合，可用于向后收集物料:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="6183" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; tuple_[4:1:-1]<br/>(16, 8, 4)<br/>&gt;&gt;&gt; tuple_[6:1:-2]<br/>(64, 16, 4)</span></pre><p id="7552" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在负步长和省略start的情况下，结果序列从原始序列的结尾开始。如果省略stop，操作将在原始文件的开头停止:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="82a4" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; tuple_[:2:-1]<br/>(128, 64, 32, 16, 8)<br/>&gt;&gt;&gt; tuple_[5::-1]<br/>(32, 16, 8, 4, 2, 1)</span></pre><p id="30a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过省略start和stop，可以方便地应用这些规则来获得项目顺序相反的序列的浅层副本:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="4137" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; tuple_[::-1]<br/>(128, 64, 32, 16, 8, 4, 2, 1)</span></pre><p id="add8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用切片来修改可变序列的项目:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="273f" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; list_[1:6:2]<br/>[2, 8, 32]<br/>&gt;&gt;&gt; list_[1:6:2] = [20, 80, 320]<br/>&gt;&gt;&gt; list_<br/>[1, 20, 4, 80, 16, 320, 64, 100]</span></pre><p id="277d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，具有索引1、3和5的项目被访问和修改。</p><p id="4efa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果使用语法sequence[start:stop]，可以用更小或更大的序列替换序列的一部分:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="b071" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; list_[1:5]<br/>[20, 4, 80, 16]<br/>&gt;&gt;&gt; list_[1:5] = [0, 0]<br/>&gt;&gt;&gt; list_<br/>[1, 0, 0, 320, 64, 100]</span></pre><p id="0e25" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，删除了四个项目([20，4，80，16])，并添加了两个新项目([0，0])。</p><p id="e9c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按照这个逻辑，您可以删除可变序列的一部分，方法是用空序列替换它们，如[]:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="974c" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; list_[1:3]<br/>[0, 0]<br/>&gt;&gt;&gt; list_[1:3] = []<br/>&gt;&gt;&gt; list_<br/>[1, 320, 64, 100]</span></pre><p id="a28d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也可以在del语句中使用slices删除部分序列:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="61a4" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; list_[:2]<br/>[1, 320]<br/>&gt;&gt;&gt; del list_[:2]<br/>&gt;&gt;&gt; list_<br/>[64, 100]</span></pre><p id="df61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，有两种方法可以删除列表的一部分。然而，后者看起来可读性更强，也更容易理解，因为使用del语句可以让您的意图(删除某些内容)更加明显。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="e0ec" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">切片是什么？</h1><p id="af7d" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">切片是Python内置类切片的实例。您可以用语句片段(start、stop、step)来创建它们。可以传递切片的实例，而不是start:stop:step或start:stop:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="8aca" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; s = slice(1, 5, 2)<br/>&gt;&gt;&gt; s<br/>slice(1, 5, 2)<br/>&gt;&gt;&gt; s.start, s.stop, s.step<br/>(1, 5, 2)<br/>&gt;&gt;&gt; tuple_[s]<br/>(2, 8)</span></pre><p id="37a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，您可以省略step并获得start:stop:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="87fc" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; s = slice(1, 5)<br/>&gt;&gt;&gt; s.start, s.stop, s.step<br/>(1, 5, None)<br/>&gt;&gt;&gt; tuple_[s]<br/>(2, 4, 8, 16)</span></pre><p id="e6e7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您传递一个参数，slice将其用作stop，并表现为:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="aa4a" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; s = slice(5)<br/>&gt;&gt;&gt; s.start, s.stop, s.step<br/>(None, 5, None)<br/>&gt;&gt;&gt; tuple_[s]<br/>(1, 2, 4, 8, 16)</span></pre><p id="20a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在函数和方法中操作切片:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="9e22" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; def get_items_with_slice(sequence, start, stop, step):<br/>...     return sequence[slice(start, stop, step)]<br/>... <br/>&gt;&gt;&gt; get_items_with_slice([1, 2, 4, 8, 16, 32, 64, 128], 1, 5, None)<br/>[2, 4, 8, 16]</span></pre><p id="fdaa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个函数使用自己的参数创建一个切片，并传递它以从序列中获取一些数据。</p><p id="01a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，下面是一个示例，说明如何结合使用切片和Python特殊方法__getitem__()来定义一个类，该类的实例可以与索引符号一起使用:</p><pre class="jz ka kb kc fd li lj lk ll aw lm bi"><span id="2112" class="ln kg hh lj b fi lo lp l lq lr">&gt;&gt;&gt; class C:<br/>...     def __init__(self, *args):<br/>...         self.__data = args<br/>...     def __getitem__(self, index_or_slice):<br/>...         print('index or slice:', index_or_slice)<br/>...         return self.__data[index_or_slice]<br/>... <br/>&gt;&gt;&gt; x = C(1, 2, 4, 8, 16, 32, 128)<br/>&gt;&gt;&gt; x[4]<br/>index or slice: 4<br/>16<br/>&gt;&gt;&gt; x[1:5:2]<br/>index or slice: slice(1, 5, 2)<br/>(2, 8)</span></pre><p id="e17a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果将一个整数传递给__getitem__()，它将表现为self的索引。_ _数据。如果您改为传递start:stop:step，__getitem__()实际上会获取一个切片对象作为参数。</p><p id="add5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还可以使用__setitem__()来修改数据，使用__delitem__()来删除数据，这可能与切片结合使用。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="4c49" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="4c65" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">本文展示了如何在Python中使用切片。当您需要从字符串、元组和列表等序列中提取项目时，它们非常强大和有用。还有一些第三方对象比如NumPy数组和Pandas系列和数据框。</p><p id="3a40" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在函数和方法中使用切片。如果您希望使用instance[index_or_slice]表示法定义可以访问、修改或删除数据的类，则应该实现特殊方法__getitem__()、__setitem__()、或__delitem__()并可能应用切片。</p><figure class="jz ka kb kc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/373724f5e413def0e29f153c00af2f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W8POZZh6L4XXEBdk.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="186e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="3801" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文由我们的队友米尔科提供。</p></div></div>    
</body>
</html>