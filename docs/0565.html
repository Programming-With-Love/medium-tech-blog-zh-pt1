<html>
<head>
<title>Biometric Authentication on Android — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的生物认证—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/biometric-authentication-on-android-part-1-264523bce85d?source=collection_archive---------0-----------------------#2020-10-05">https://medium.com/androiddevelopers/biometric-authentication-on-android-part-1-264523bce85d?source=collection_archive---------0-----------------------#2020-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b911131c1d399d94515164dfbc9c1c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3jNfHQGTe7f7ptGpa74yA.png"/></div></div></figure><div class=""/><div class=""><h2 id="c470" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">为什么您的应用需要它</h2></div><p id="d8fd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了保护隐私和敏感信息，许多应用程序要求用户登录。如果您的应用程序支持传统的登录体验，它可能与图1中描述的过程类似。用户输入用户名和密码，应用程序将凭证发送到远程服务器，最后远程服务器返回一个<code class="du kd ke kf kg b">userToken</code>,应用程序稍后可以使用它来查询远程服务器的受限数据。无论是要求用户每次打开应用程序都要登录，还是每次安装只登录一次，图1都很好。</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es kh"><img src="../Images/24d90ddbcfee1b83ca2d53ef83581448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*tZL_anF0qoFyeZWr"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Figure 1: Authentication without biometrics</figcaption></figure><p id="4436" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，使用图1所示的过程有几个缺点:</p><ul class=""><li id="5c0e" class="kq kr hs jj b jk jl jn jo jq ks ju kt jy ku kc kv kw kx ky bi translated">如果它用于银行应用程序使用的每次会话认证，那么这个过程很快就会变得繁琐，因为用户每次打开应用程序时都需要输入密码。</li><li id="f661" class="kq kr hs jj b jk kz jn la jq lb ju lc jy ld kc kv kw kx ky bi translated">如果它用于电子邮件应用程序使用的每次安装身份验证，那么设备所有者的私人内容对任何碰巧持有该设备的人都是可见的，因为它不会验证所有者的存在。</li></ul><p id="808d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了帮助克服这些缺点，生物特征认证提供了许多便利，使认证过程对最终用户更容易，对开发人员更有吸引力，即使开发人员可能不需要经常登录他们的应用程序。这些优势中的关键是，使用生物认证就像轻按传感器或查看您的设备一样简单。重要的是，作为开发人员，您可以决定用户必须重新认证的频率——每天一次，每周一次，每次打开应用程序时，等等。总的来说，API surface有许多特性使得开发者和他们的用户更容易登录。</p><p id="7702" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如今，许多处理个人数据的应用程序，如电子邮件或社交网络应用程序，往往只需要在安装时进行一次性身份验证。当用户每次打开应用程序时输入用户名和密码会对用户体验产生负面影响时，这种做法就流行起来了。但是有了生物认证，安全性就不必对用户造成如此沉重的负担。即使您的应用程序通常需要一次性认证，您也可以考虑定期要求生物特征认证来验证用户的存在。周期的长短完全取决于你，开发者。</p><p id="d8e6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果应用程序要求每次会话都进行身份验证(或者每2小时一次或每天一次等频率)。)，那么与每次都必须键入密码相比，看着设备或轻敲传感器几乎不会被注意到。如果一个应用程序只需要一次性认证，就像许多电子邮件应用程序一样，那么生物识别技术将增加一层额外的安全性，用户只需拿起并查看他们的设备。如果用户想继续保持他们的电子邮件打开，而不需要重新认证，那么他们应该有这个选择。但是对于想要更多隐私的用户来说，生物认证应该可以让他们更加放心。无论哪种方式，最终用户的成本都是微乎其微的，尤其是与额外的好处相比。</p><h1 id="9ea2" class="le lf hs bd lg lh li lj lk ll lm ln lo iy lp iz lq jb lr jc ls je lt jf lu lv bi translated">使用BiometricPrompt实现生物认证</h1><p id="1f7a" class="pw-post-body-paragraph jh ji hs jj b jk lw it jm jn lx iw jp jq ly js jt ju lz jw jx jy ma ka kb kc ha bi translated"><code class="du kd ke kf kg b">BiometricPrompt</code> API允许您在加密和不加密的情况下实现认证。如果你正在开发一个需要更强安全系统的应用程序，比如医疗保健应用程序或银行应用程序，那么你可能希望<a class="ae mb" rel="noopener" href="/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7">将你的加密密钥与生物认证</a>绑定，以便验证用户的存在。否则，为了方便用户，您可能希望实现生物认证。两种情况下的代码片段非常相似，除了对于加密实现，您将传入一个<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/androidx/biometric/BiometricPrompt.CryptoObject" rel="noopener ugc nofollow" target="_blank">CryptoObject</a></code>，而为了方便实现，您将省略<code class="du kd ke kf kg b">CryptoObject</code>参数。</p><p id="1d1f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">加密版本:</strong></p><pre class="ki kj kk kl fd mc kg md me aw mf bi"><span id="b527" class="mg lf hs kg b fi mh mi l mj mk">biometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(cipher))</span></pre><p id="18b4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然在上面的代码片段中，我们将一个<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/javax/crypto/Cipher" rel="noopener ugc nofollow" target="_blank">Cipher</a></code>传递给了<code class="du kd ke kf kg b">CryptoObject,</code>，但是您可以自由地传递多个替代项，比如一个<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/javax/crypto/Mac" rel="noopener ugc nofollow" target="_blank">Mac</a></code>或<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/java/security/Signature" rel="noopener ugc nofollow" target="_blank">Signature</a></code>。</p><p id="a0a3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">无密码对象版本:</strong></p><pre class="ki kj kk kl fd mc kg md me aw mf bi"><span id="ed07" class="mg lf hs kg b fi mh mi l mj mk">biometricPrompt.authenticate(promptInfo)</span></pre><p id="e5ff" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要在您的Android应用中实现生物认证，请使用<code class="du kd ke kf kg b"><a class="ae mb" href="https://android-developers.googleblog.com/2019/10/one-biometric-api-over-all-android.html" rel="noopener ugc nofollow" target="_blank">AndroidX Biometric library</a></code>。尽管API处理不同的模态(指纹、面部、虹膜等。)自动地，作为一个开发者，你仍然可以通过设置<code class="du kd ke kf kg b">setAllowedAuthenticators()</code>来选择你的应用将接受的生物特征的安全级别，如下面的代码片段所示。<strong class="jj ht"> <em class="ml"> Class 3 </em> </strong>(原<strong class="jj ht"> Strong </strong>)表示你想要的生物特征，即解锁<code class="du kd ke kf kg b">Keystore</code>中存储的凭证(即密码术)；<strong class="jj ht"> <em class="ml"> Class 2 </em> </strong>(之前的<strong class="jj ht"> Weak </strong>)表示你只是想解锁你的app，而不依赖于进一步被密码术保护的凭证。有一个<strong class="jj ht"> <em class="ml"> Class 1 </em> </strong>，但是和apps不兼容。详见<a class="ae mb" href="https://source.android.com/compatibility/android-cdd#7_3_10_biometric_sensors" rel="noopener ugc nofollow" target="_blank">安卓兼容性定义文档</a>。</p><pre class="ki kj kk kl fd mc kg md me aw mf bi"><span id="a500" class="mg lf hs kg b fi mh mi l mj mk">fun createPromptInfo(activity: AppCompatActivity): BiometricPrompt.PromptInfo =</span><span id="c488" class="mg lf hs kg b fi mm mi l mj mk">   BiometricPrompt.PromptInfo.Builder().<em class="ml">apply </em><strong class="kg ht">{</strong></span><span id="bf14" class="mg lf hs kg b fi mm mi l mj mk">      setAllowedAuthenticators(<em class="ml">BIOMETRIC_STRONG</em>)</span><span id="9dce" class="mg lf hs kg b fi mm mi l mj mk">      // Continue setting other PromptInfo attributes such as title,  subtitle, description</span><span id="0e31" class="mg lf hs kg b fi mm mi l mj mk"><strong class="kg ht">   }</strong>.build()</span></pre><h1 id="e386" class="le lf hs bd lg lh li lj lk ll lm ln lo iy lp iz lq jb lr jc ls je lt jf lu lv bi translated">加密和每次使用授权密钥与限时密钥</h1><p id="fec8" class="pw-post-body-paragraph jh ji hs jj b jk lw it jm jn lx iw jp jq ly js jt ju lz jw jx jy ma ka kb kc ha bi translated"><strong class="jj ht"> <em class="ml">每次使用授权</em>密钥</strong>是可用于执行一次加密操作的秘密密钥。因此，举例来说，如果你想执行十次加密操作，那么你必须解锁密钥十次。因此命名为<em class="ml"> auth-per-use </em>:你必须在每次使用时进行认证(即解锁密钥)。</p><p id="7bd4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">另一方面，一个<strong class="jj ht"> <em class="ml">有时间限制的</em>密钥</strong>是一个在某个时间段内有效的秘密密钥——您可以通过将几秒钟传递给<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder" rel="noopener ugc nofollow" target="_blank">setUserAuthenticationValidityDurationSeconds</a></code>来预先建立它。如果您传递给<em class="ml">有时间限制的</em>函数的秒数是-1，这是默认值，那么系统假设您想要<em class="ml">每次使用授权</em>。对于所有其他数字，我们建议三秒或更长时间，系统会遵循您设置的持续时间。要轻松创建有时间限制的密钥，请参见<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/topic/security/data" rel="noopener ugc nofollow" target="_blank">Jetpack Security</a></code>中的<code class="du kd ke kf kg b"><a class="ae mb" href="https://developer.android.com/reference/androidx/security/crypto/MasterKeys" rel="noopener ugc nofollow" target="_blank">MasterKeys</a> </code>类。</p><p id="e49d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通常——结合前面提到的-1——您将传递一个<code class="du kd ke kf kg b">CryptoObject</code>到<code class="du kd ke kf kg b">BiometricPrompt.authenticate()</code>来请求<code class="du kd ke kf kg b"><em class="ml">auth-per-use</em>. </code>,然而，您可以设置一个非常短的持续时间，比如5秒，来使用一个<em class="ml">有时间限制的</em>密钥，就好像它是一个<em class="ml">每次使用授权</em>密钥一样。这两种方法在显示用户存在方面实际上是等效的，所以如何设计应用程序的UX取决于你自己。</p><p id="84b9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关于引擎盖下发生的事情:当您使用<code class="du kd ke kf kg b">CryptoObject</code>时，密钥仅针对指定的操作解锁。这是因为Keymint(或Keymaster)获得了一个带有特定操作Id的<code class="du kd ke kf kg b">HardwareAuthToken</code> ( <code class="du kd ke kf kg b">HAT</code>)。密钥被解锁，您只能使用它来执行您环绕<code class="du kd ke kf kg b">CryptoObject</code>的<code class="du kd ke kf kg b">Cipher/Mac/Signature</code>操作所代表的操作，并且在它再次锁定之前，您只能执行一次指定的操作——这是一个<em class="ml">每次使用授权密钥</em>。当你不使用<code class="du kd ke kf kg b">CryptoObject</code>时，送去造币厂的帽子没有<code class="du kd ke kf kg b">operationId</code>；因此，Keymint简单地寻找一个具有有效<code class="du kd ke kf kg b">timestamp</code> ( <code class="du kd ke kf kg b">timestamp + time-based-key-duration &gt; now)</code>)的<code class="du kd ke kf kg b">HAT</code>，并且您可以使用那个密钥直到它的时间到期——它是一个<em class="ml">有时间限制的</em>密钥。</p><p id="fc49" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">乍一看，这听起来像是一个有时间限制的键，只要时间窗口有效，任何应用程序都可以访问它。但事实是，除了妥协的用户空间，没有人会担心某个app <em class="ml"> X </em>使用某个app <em class="ml"> Y </em>的按键或操作。Android框架不会允许其他应用程序找到或初始化另一个应用程序的操作。</p><h1 id="bd1f" class="le lf hs bd lg lh li lj lk ll lm ln lo iy lp iz lq jb lr jc ls je lt jf lu lv bi translated">第1部分总结</h1><p id="a934" class="pw-post-body-paragraph jh ji hs jj b jk lw it jm jn lx iw jp jq ly js jt ju lz jw jx jy ma ka kb kc ha bi translated">在这篇文章中，你学到了以下内容:</p><ul class=""><li id="00a2" class="kq kr hs jj b jk jl jn jo jq ks ju kt jy ku kc kv kw kx ky bi translated">为什么只有用户名+密码的认证是有问题的。</li><li id="4c91" class="kq kr hs jj b jk kz jn la jq lb ju lc jy ld kc kv kw kx ky bi translated">为什么在你的应用中加入生物认证是个好主意。</li><li id="cd33" class="kq kr hs jj b jk kz jn la jq lb ju lc jy ld kc kv kw kx ky bi translated">不同类型应用的设计考虑。</li><li id="1293" class="kq kr hs jj b jk kz jn la jq lb ju lc jy ld kc kv kw kx ky bi translated">加密或不加密如何调用<code class="du kd ke kf kg b">BiometricPrompt</code>。</li><li id="6c11" class="kq kr hs jj b jk kz jn la jq lb ju lc jy ld kc kv kw kx ky bi translated"><em class="ml">每次使用授权</em>与<em class="ml">限时</em>加密密钥的区别。</li></ul><p id="6719" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在下一篇文章中，您将了解如何将正确的ui和逻辑整合到您的生物认证流程中。</p></div></div>    
</body>
</html>