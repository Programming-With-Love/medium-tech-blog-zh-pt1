<html>
<head>
<title>Single Thread Dart, What? — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单线镖，什么？—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/single-thread-dart-what-part-2-a5592bef5213?source=collection_archive---------1-----------------------#2020-01-07">https://medium.com/globant/single-thread-dart-what-part-2-a5592bef5213?source=collection_archive---------1-----------------------#2020-01-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="521d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您还没有阅读本系列的第一部分，请在继续之前阅读这里。</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/@parthdave93/single-thread-dart-what-ccbca2543ae9"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">单线镖，什么？</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">我知道你们中的一些人可能会对我说有Async Await和RxDart，所以不要担心兄弟。我当时……</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div></div></a></div></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="2208" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">孤立就是一根线。隔离不共享内存，因为我们已经介绍过，主要隔离有其事件循环，其他隔离也是如此，因此要发送和接收处理过的数据，您需要使用端口来来回回地通信。</p><blockquote class="jv jw jx"><p id="9898" class="ie if jy ig b ih ii ij ik il im in io jz iq ir is ka iu iv iw kb iy iz ja jb ha bi translated"><em class="hh">“孤立”在扑动中不共享内存。就交流而言，不同“隔离”之间的交互是通过“消息”进行的。</em></p></blockquote><p id="517a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以通过两种方式创建隔离:</p><ol class=""><li id="2daf" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">使用计算功能，它将处理所有数据发送和接收的通信过程。</li><li id="0d3d" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">编写您自己来回发送和接收数据的所有逻辑。</li></ol><blockquote class="jv jw jx"><p id="195e" class="ie if jy ig b ih ii ij ik il im in io jz iq ir is ka iu iv iw kb iy iz ja jb ha bi translated"><em class="hh">隔离是TCP套接字的一种。我们需要为此创建一个握手机制。还有另一个原因是，正如我们之前定义的，Isolate不共享内存，您需要使用端口和消息来来回回地传递数据。这就是为什么我们需要使用某种握手。</em></p></blockquote><p id="7ce4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建隔离有一些规则</p><ol class=""><li id="97d7" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">隔离需要有一个非静态的顶级函数。</li><li id="ca6c" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">如果你使用<code class="du kq kr ks kt b">compute</code>函数或<code class="du kq kr ks kt b">Isolate.spawn</code>函数，现在函数必须有一个参数。你可能会问为什么？检查方法签名。</li></ol><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="0599" class="lc ld hh kt b fi le lf l lg lh">external static Future&lt;Isolate&gt; spawn&lt;T&gt;(<br/>    void entryPoint(T message), T message,<br/>    {bool paused: false,<br/>    bool errorsAreFatal,<br/>    SendPort onExit,<br/>    SendPort onError,<br/>    @Since("2.3") String debugName});</span></pre><p id="6385" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查<code class="du kq kr ks kt b">entryPoint(T message)</code>方法调用，它需要T消息，所以你需要有一个单参数函数。</p><p id="129d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.每个隔离区占用大约2MB，它很轻，所以要小心使用。<a class="ae li" href="https://www.youtube.com/watch?v=M8jGSkACneE&amp;t=27m25s" rel="noopener ugc nofollow" target="_blank">隔离内存大小和分配</a> -查看更多详细信息</p><p id="6714" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.从隔离区传递的每个消息都需要消息大小* 2的内存，因为隔离区不共享内存，所以在系统上将有两个副本，所以如果您有1 GB的文件，并且想要从一个隔离区传递到第二个隔离区，则需要设备上2Gb的内存(在设备上，我指的是RAM -查看参考链接以了解详细信息)。</p><p id="8ed6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.即使您已经完成了工作或从方法中执行了所有语句，隔离和端口也可能是活动的。所以我们有责任杀死隔离者并关闭港口。</p><p id="0b52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码(这个纯Dart代码没有颤振代码):</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="9876" class="lc ld hh kt b fi le lf l lg lh">import 'dart:isolate';</span><span id="cdd6" class="lc ld hh kt b fi lj lf l lg lh">void main() async{<br/> startIsolate();<br/>}</span></pre><p id="e690" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">导入隔离包并调用startIsolate函数。我们将从创建用于来回传递消息的<code class="du kq kr ks kt b">ReceivePort</code>开始。要记住的是<code class="du kq kr ks kt b">ReceivePort Stream</code>只能使用一次，所以如果我们发送一次数据并从<code class="du kq kr ks kt b">receivePort.first</code>获取数据，现在当我们再次发送数据并试图从<code class="du kq kr ks kt b">receivePort.first</code>获取数据时，它将不起作用，并将抛出一个错误语句:<code class="du kq kr ks kt b">Unhandled Exception: Bad state: Stream has already been listened to.</code>最常见的流形式一次只能监听一次。如果您尝试添加多个侦听器，它将抛出一个异常。因此，我们将使用<code class="du kq kr ks kt b">receivePort.first</code>来来回回地获取<code class="du kq kr ks kt b">SendPort</code>，如果我们想使用一个<code class="du kq kr ks kt b">ReceivePort</code>来获得更好的优化，我们需要使用该类的listen方法。握手的步骤(将给出虚拟的例子来清楚地了解什么类是用来做什么的)</p><ol class=""><li id="a13e" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">创建接收端口对象(例如:接收端口有点像公开的服务器)</li><li id="a365" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">使用发送端口生成隔离(例如:发送端口有点像套接字8080端口，我们在那里启动套接字，其他人可以通过调用网站来访问它……:8080，服务器将在该端口上对该请求做出响应)</li><li id="e098" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">在Isolate中，我们需要使用握手，我的意思是我们有两个线程，我们需要传递消息，因此我们需要一些流来监听事件的双方，因此我们将首先传递发送端口，以确定我们需要将消息发送到哪里。</li><li id="5b49" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">因此，在通过spawn创建了Isolate之后，我们将等待Isolate发送其发送端口，我们将向其ping消息。</li><li id="69ef" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">在Isolate端，我们将再次创建ReceiverPort，并向我们在方法参数中传递的发送端口发送一条消息，该消息将是该Isolate的发送端口。</li><li id="08a8" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">记住只使用一次<code class="du kq kr ks kt b">receiverPort.first</code>，我们将得到发送端口。</li><li id="0462" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">现在，一旦我们获得所有端口，就像套接字开放通道一样，我们将来回发送消息。</li></ol><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="32d0" class="lc ld hh kt b fi le lf l lg lh">startIsolate() async{<br/> //create ReceivePort<br/> ReceivePort receivePort = ReceivePort();<br/> //receivePort.sendPort is our destination for receiving message<br/> var isolate = await Isolate.spawn(calculateFunction, receivePort.sendPort);</span><span id="ff2b" class="lc ld hh kt b fi lj lf l lg lh"> SendPort sendPort = await receivePort.first;<br/> // we got Isolate's SendPort or should I say Message destination<br/>}</span><span id="6c22" class="lc ld hh kt b fi lj lf l lg lh">calculateFunction(SendPort sendPort) async{<br/> var calculateFunctionReceivePort = ReceivePort();<br/> sendPort.send(calculateFunctionReceivePort.sendPort);</span><span id="271c" class="lc ld hh kt b fi lj lf l lg lh"> await for (var msg in calculateFunctionReceivePort){<br/>  var data = msg[0];<br/>  SendPort replyTo = msg[1];<br/>  replyTo.send("$data from Isolate");<br/>  print("Received inside Isolate: $data");<br/> }<br/>}</span></pre><p id="3350" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们获得了隔离的发送端口，我们将发送一条消息并监听隔离响应。</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="47a8" class="lc ld hh kt b fi le lf l lg lh">import 'dart:isolate';</span><span id="823b" class="lc ld hh kt b fi lj lf l lg lh">void main() async{<br/> startIsolate();<br/>}</span><span id="6abd" class="lc ld hh kt b fi lj lf l lg lh">startIsolate() async{<br/> ReceivePort receivePort = ReceivePort();<br/> var isolate = await Isolate.spawn(calculateFunction, receivePort.sendPort);</span><span id="9699" class="lc ld hh kt b fi lj lf l lg lh"> SendPort sendPort = await receivePort.first;<br/> receivePort.close(); // closing the port , do not forget to close it.<br/> var msg = await sendStreamData(sendPort, "Test Data");<br/> print(msg);</span><span id="5b74" class="lc ld hh kt b fi lj lf l lg lh"> Future.delayed(Duration(seconds: 1),()async{<br/>  msg = await sendStreamData(sendPort, "Test Data 2");<br/>  print(msg);</span><span id="3b42" class="lc ld hh kt b fi lj lf l lg lh">  isolate.kill(priority: Isolate.immediate);<br/> });<br/>}</span><span id="c8af" class="lc ld hh kt b fi lj lf l lg lh">sendStreamData(SendPort sendPort, String msg) async{<br/> ReceivePort sendStreamDataPort = ReceivePort();<br/> sendPort.send([msg, sendStreamDataPort.sendPort]);<br/> var response = await sendStreamDataPort.first;<br/> sendStreamDataPort.close();<br/> return response;<br/>}</span><span id="075b" class="lc ld hh kt b fi lj lf l lg lh">calculateFunction(SendPort sendPort) async{<br/> var calculateFunctionReceivePort = ReceivePort();<br/> sendPort.send(calculateFunctionReceivePort.sendPort);</span><span id="b76e" class="lc ld hh kt b fi lj lf l lg lh"> await for (var msg in calculateFunctionReceivePort){<br/>  var data = msg[0];<br/>  SendPort replyTo = msg[1];<br/>  replyTo.send("$data from Isolate");<br/>  print("Received inside Isolate: $data");<br/> }<br/>}</span></pre><p id="47f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出:</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="cefc" class="lc ld hh kt b fi le lf l lg lh">Received inside Isolate: Test Data<br/>Test Data from Isolate<br/>Received inside Isolate: Test Data 2<br/>Test Data 2 from Isolate</span></pre><h1 id="9e70" class="lk ld hh bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">问题:</h1><ol class=""><li id="3a21" class="kc kd hh ig b ih mh il mi ip mj it mk ix ml jb kh ki kj kk bi translated">我们为什么使用ReceiverPort？或者孤立的接收器端口是什么？</li><li id="6bcc" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">当我们有异步代码时，为什么我们需要使用Isolate？</li><li id="fe75" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">隔离物能存活多久？以及如何杀死或关闭它？</li><li id="d6fe" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">隔离共享内存吗？如果没有，那么如何传递数据？</li></ol><p id="3138" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考链接:</p><ol class=""><li id="5344" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=M8jGSkACneE" rel="noopener ugc nofollow" target="_blank">隔离性能指标评测器示例和更多深度</a></li><li id="301f" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=UUfXWzp0-DU&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">颤振渲染流水线</a></li><li id="29a4" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae li" href="https://www.didierboelens.com/2019/01/futures---isolates---event-loop/" rel="noopener ugc nofollow" target="_blank">颤振隔离和事件循环解释</a></li><li id="8524" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=M8jGSkACneE&amp;t=27m25s" rel="noopener ugc nofollow" target="_blank">隔离内存大小和分配</a></li><li id="d43e" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=vl_AaCgudcY" rel="noopener ugc nofollow" target="_blank">从Flutter Devs中分离和事件循环介绍视频</a></li><li id="334d" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae li" href="https://www.youtube.com/watch?v=M8jGSkACneE&amp;t=27m25s" rel="noopener ugc nofollow" target="_blank">隔离内存大小和分配</a></li></ol><p id="ab10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就结束了颤振单线程镖系列。我希望你喜欢它。</p><p id="e680" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你知道你可以按拍手吗👏按钮50次？你走得越高，我就越有动力为你们写更多的东西！</p><p id="ef69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你好，我是帕斯·戴夫。noob开发者和noob摄影师。你可以在<a class="ae li" href="https://in.linkedin.com/in/parth-dave-907b8177" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我或者在<a class="ae li" href="https://github.com/parthdave93" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上跟踪我或者在<a class="ae li" href="https://twitter.com/the_parth_dave" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我？</p><p id="ed90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">祝你有一个愉快的飞行日！</p></div></div>    
</body>
</html>