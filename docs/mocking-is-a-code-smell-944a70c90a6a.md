# 嘲讽是一种代码气味

> 原文：<https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a?source=collection_archive---------0----------------------->

![](img/b5319c93f5a4237f1472d1686f5b1e6f.png)

Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)

> **注:**这是《作曲软件》系列的一部分**s**[(现在一本书！)](https://leanpub.com/composingsoftware) 从基础开始学习 JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！[*<上一个*](/javascript-scene/javascript-monads-made-simple-7856be57bfe8)*|*[*<<开始结束*](/javascript-scene/composing-software-an-introduction-27b72500d6ea)

我听到的关于 TDD 和单元测试的最大的抱怨之一是，人们与隔离单元所需的所有嘲笑做斗争。有些人甚至很难理解他们的单元测试有什么意义。事实上，我已经看到开发人员迷失在模仿、伪造和存根中，以至于他们编写了整个单元测试文件，而*根本没有实际的实现代码。糟糕。*

另一方面，经常看到开发人员如此沉迷于 TDD 的教条，以至于他们认为他们绝对必须实现 100%的代码覆盖率，*通过任何必要的手段*，即使这意味着他们必须使他们的代码库更加复杂才能实现它。

我经常告诉人们，模仿是一种代码味道，但是大多数开发人员在他们的 TDD 技能中经历了一个阶段，他们希望实现 100%的单元测试覆盖率，并且无法想象他们不广泛使用模仿的世界。为了将模拟压缩到他们的应用程序中，他们倾向于将依赖注入功能包装在他们的单元周围，或者(更糟糕的)将服务打包到依赖注入容器中。

Angular 将这一点发挥到了极致，将依赖注入融入到所有 Angular 组件类中，诱使用户将依赖注入视为解耦的主要手段。但是依赖注入并不是实现解耦的最佳方式。

# TDD 应该导致更好的设计

> 学习有效 TDD 的过程就是学习如何构建更多模块化应用的过程。

TDD 倾向于对代码产生简化的效果，而不是复杂化的效果。如果您发现当您使代码更易测试时，您的代码变得更难阅读或维护，或者您必须用依赖注入样板文件来膨胀您的代码，那么您在使用 TDD 是错误的。

不要浪费时间在你的应用中加入依赖注入，这样你就可以嘲笑整个世界了。很有可能它对你的伤害大于帮助。编写更多可测试的代码会简化你的代码。它应该需要更少的代码行和更可读、更灵活、更易维护的结构。依赖注入有相反的效果。

这篇文章的存在是为了教你两件事:

1.  您可以编写没有依赖注入的解耦代码，并且
2.  最大化代码覆盖率带来的回报是递减的——你越接近 100%的覆盖率，你就越需要使你的应用程序代码变得复杂，这可能会破坏减少应用程序中的 bug 这一重要目标。

更复杂的代码通常伴随着更混乱的代码。出于同样的原因，您希望生成整洁的代码，就像您希望保持房间整洁一样:

*   更多的混乱导致更多方便虫子躲藏的地方，这导致更多的虫子，并且
*   当没有太多杂乱的东西让人迷失时，你会更容易找到你要找的东西。

# 什么是代码气味？

> “代码气味是一种表面迹象，通常对应于系统中更深层的问题。”~马丁·福勒

代码气味并不意味着某些东西肯定是错误的，或者某些东西必须马上修复。这是一条经验法则，它应该提醒你可能有机会改进某些东西。

这篇文章和它的标题并不意味着所有的嘲笑都是不好的，或者你不应该嘲笑任何东西。

此外，不同类型的代码需要不同级别(和不同种类)的模拟。一些代码的存在主要是为了促进 I/O，在这种情况下，除了测试 I/O 之外没有什么可做的，减少模拟可能意味着您的单元测试覆盖率将接近 0。

如果您的代码中没有逻辑(只有管道和纯组合)，假设您的集成或功能测试覆盖率接近 100%，0%的单元测试覆盖率可能是可以接受的。然而，如果有逻辑(条件表达式、变量赋值、对单元的显式函数调用等等)，您可能确实需要单元测试覆盖，并且可能有机会简化您的代码并减少模仿需求。

# 什么是模仿？

模拟是在单元测试过程中代表真实实现代码的测试替身。mock 能够生成关于测试主体在测试运行期间如何操作它的断言。如果您的 test double 产生断言，那么它就是一个特定意义上的模拟。

术语“模拟”也更普遍地用于指代任何类型的测试 double 的使用。出于本文的目的，我们将交替使用“模拟”和“双重测试”这两个词来匹配流行的用法。所有的测试替身(假人、间谍、假货等)代表测试主体紧密耦合的真实代码，因此，所有的测试替身都是耦合的指示，并且可能有机会简化实现和提高测试代码的质量。同时，消除对模拟的需求可以从根本上简化测试本身，因为您不必构建模拟。

# 什么是单元测试？

单元测试测试独立于程序其余部分的单个单元(模块、函数、类)。

将单元测试与集成测试和功能测试进行对比，前者测试两个或更多单元之间的集成，后者从用户的角度测试应用程序，包括从模拟 UI 操作到数据层更新，再到用户输出(例如，应用程序的屏幕显示)的完整用户交互工作流。功能测试是集成测试的子集，因为它们测试应用程序的所有单元，集成在运行的应用程序的上下文中。

一般来说，单元只使用单元的公共接口(也称为“公共 API”或“表面区域”)进行测试。这被称为黑盒测试。黑盒测试导致了不那么脆弱的测试，因为一个单元的实现细节往往比该单元的公共 API 更容易随着时间而改变。如果您使用白盒测试，其中测试知道实现细节，对实现细节的任何更改都可能会破坏测试，即使公共 API 继续按预期运行。换句话说，白盒测试导致了浪费的返工。

# 什么是测试覆盖率？

代码覆盖率是指测试用例覆盖的代码量。覆盖率报告可以通过检测代码并记录在测试运行期间执行了哪些行来创建。总的来说，我们试图产生高水平的覆盖率，但是当代码覆盖率接近 100%时，它开始产生递减的回报。

根据我的经验，将覆盖率提高到 90%以上似乎与更低的 bug 密度没有持续的联系。

为什么会这样？难道 100%测试过的代码不意味着我们 100%确定代码做了它被设计要做的事情吗？

事实证明，事情没那么简单。

大多数人没有意识到有两种保险:

1.  **代码覆盖率:**执行了多少代码，以及
2.  **用例覆盖:**测试套件覆盖了多少用例

案例覆盖指的是用例场景:代码在真实世界环境中的行为，真实的用户，真实的网络，甚至黑客为了邪恶的目的故意试图颠覆软件的设计。

覆盖率报告识别代码覆盖率的弱点，而不是案例覆盖率的弱点。同一个代码可能应用于不止一个用例，一个用例可能依赖于测试对象之外的代码，甚至是在一个单独的应用程序或第三方 API 中。

因为用例可能涉及环境、多个单元、用户和网络条件，所以不可能用一个只包含单元测试的测试套件覆盖所有需要的用例。根据定义，单元测试是在隔离中测试单元，而不是在集成中测试单元，这意味着一个只包含单元测试的测试套件对于集成和功能用例场景总是有接近 0%的覆盖率。

100%的代码覆盖率并不能保证 100%的案例覆盖率。

以 100%代码覆盖率为目标的开发人员正在追逐错误的指标。

# 什么是紧耦合？

为了达到单元测试的目的而进行模拟的需要是由单元之间的耦合引起的。紧密耦合使得代码更加僵化和脆弱:当需要更改时更容易崩溃。一般来说，耦合越少越好，因为这样代码更容易扩展和维护。事实上，它还通过消除对模拟的需求而使测试变得更容易，这只是锦上添花。

由此我们可以推断出，如果我们在嘲笑什么，可能有机会通过减少单元之间的耦合来使我们的代码更加灵活。一旦完成，你就不再需要模仿了。

耦合是一个代码单元(模块、函数、类等等)依赖于其他代码单元的程度。紧密耦合，或者说高度耦合，指的是当一个单元的依赖关系发生变化时，这个单元崩溃的可能性有多大。换句话说，耦合越紧密，维护或扩展应用程序就越困难。松散耦合降低了修复 bug 和使应用程序适应新用例的复杂性。

耦合有不同的形式:

*   子类耦合:子类依赖于父类的实现和整个层次结构:这是 OO 设计中最紧密的耦合形式。
*   **控制依赖:**通过告诉依赖者做什么来控制依赖者的代码，例如，传递方法名等等……如果依赖者的控制 API 发生变化，依赖的代码将会中断。
*   **可变状态依赖:**与其他代码共享可变状态的代码，例如，可以改变共享对象的属性。如果突变的相对时间发生变化，可能会破坏相关代码。如果时间是不确定的，如果不彻底检查所有相关的单元，就不可能实现程序的正确性:例如，可能会有不可修复的竞争条件的混乱。修复一个 bug 可能会导致其他 bug 出现在其他依赖单元中。
*   **状态形状依赖:**与其他代码共享数据结构的代码，并且只使用该结构的子集。如果共享结构的形状发生变化，可能会破坏相关代码。
*   **事件/消息耦合:**通过消息传递、事件等与其他单元通信的代码

# 什么导致了紧密耦合？

紧密耦合有许多原因:

*   **突变** vs *不变性*
*   **副作用**与*纯度/独立副作用*
*   **责任超载** vs *做一件事(打点)*
*   **程序指令** vs *描述结构*
*   **类继承** vs *作文*

命令式和面向对象的代码比函数式代码更容易受到紧耦合的影响。这并不意味着用函数式风格编程会使您的代码不受紧耦合的影响，但是函数式代码使用纯函数作为组成的基本单位，纯函数天生就不太容易受到紧耦合的影响。

纯函数:

*   给定相同的输入，总是返回相同的输出，并且
*   不产生副作用

纯函数如何减少耦合？

*   **不变性:**纯函数不会改变现有的值。相反，他们会退回新的。
*   **没有副作用:**一个纯函数唯一可观察到的效果是它的返回值，所以它没有机会干扰其他可能观察外部状态的函数的操作，比如屏幕、DOM、控制台、标准输出、网络或磁盘。
*   **做一件事:**纯函数做一件事:将一些输入映射到一些对应的输出，避免了容易困扰对象和基于类的代码的责任过载。
*   **结构，而不是指令:**纯函数可以被安全地记忆，这意味着，如果系统有无限的内存，任何纯函数都可以被替换为一个查找表，该表使用函数的输入作为索引，从表中检索相应的值。换句话说，纯函数描述的是数据之间的结构关系，而不是让计算机遵循的指令，因此同时运行的两套不同的相互冲突的指令不会踩到对方的脚趾而导致问题。

# 作文和嘲讽有什么关系？

一切。所有软件开发的本质是将一个大问题分解成更小的、独立的部分(分解)并将解决方案组合在一起以形成一个解决大问题的应用程序(组合)的过程。

> 当我们的分解策略失败时，嘲讽是必需的。

当用于将大问题分解成小部分的单元相互依赖时，就需要模仿了。换句话说，*当我们假设的组成的原子单位不是真正的原子时，就需要嘲讽，*而且我们的分解策略未能将较大的问题分解成较小的独立问题。

当分解成功时，可以使用一个通用的组合实用程序将片段组合在一起。示例:

*   **功能组成**例如`lodash/fp/compose`
*   **组件组合**例如，用功能组合组合更高阶的组件
*   **陈述商店/模型构成**，例如[Redux combiner reducers](http://redux.js.org/docs/api/combineReducers.html)
*   **对象或工厂组合**例如混合或功能混合
*   **过程组成**例如传感器
*   **许诺或一元成分**如`asyncPipe()`、克雷斯利成分与`composeM()`、`composeK()`等...
*   等等…

当您使用通用组合实用程序时，组合的每个元素都可以单独进行单元测试*而不会模仿其他元素。*

组合本身将是声明性的，因此它们将包含*零单元可测试逻辑*(大概组合实用程序是一个拥有自己单元测试的第三方库)。

在这种情况下，单元测试没有任何意义。相反，您需要集成测试。

让我们用一个熟悉的例子来对比命令式和声明式组合:

```
// Function composition OR
// import pipe from 'lodash/fp/flow';
const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);// Functions to compose
const g = n => n + 1;
const f = n => n * 2;// Imperative composition
const doStuffBadly = x => {
  const afterG = g(x);
  const afterF = f(afterG);
  return afterF;
};// Declarative composition
const doStuffBetter = pipe(g, f);console.log(
  doStuffBadly(20), // 42
  doStuffBetter(20) // 42
);
```

函数合成是将一个函数应用于另一个函数的返回值的过程。换句话说，您创建一个函数管道，然后将一个值传递给管道，该值将像装配线上的一个阶段一样通过每个函数，在传递给管道中的下一个函数之前以某种方式转换该值。最终，管道中的最后一个函数返回最终值。

```
initialValue -> [g] -> [f] -> result
```

它是在每一种主流语言中组织应用程序代码的主要方法，不管其范式如何。甚至 Java 也使用函数(方法)作为不同类实例之间的主要消息传递机制。

您可以手动(命令式)或自动(声明式)组合函数。在没有一级函数的语言中，你没有太多的选择。你被命令束缚住了。在 JavaScript(以及几乎所有其他主流语言)中，使用声明性组合可以做得更好。

命令式意味着我们命令计算机一步一步地做一些事情。这是一本操作指南。在上面的例子中，命令式风格说:

1.  取一个参数并将其分配给`x`
2.  创建一个名为`afterG`的绑定，并将`g(x)`的结果赋给它
3.  创建一个名为`afterF`的绑定，并将`f(afterG)`的结果赋给它
4.  返回`afterF`的值。

命令式版本需要经过测试的逻辑。我知道这些只是简单的赋值，但是我经常看到(或者写下)传递或者返回错误变量的错误。

声明式风格意味着我们告诉计算机事物之间的关系。这是用方程式推理对结构的描述。这个声明性的例子说:

*   `doStuffBetter` *是`g`和`f`的管道组合*。

就是这样。

假设`f`和`g`有自己的单元测试，`pipe()`也有自己的单元测试(使用 Lodash 的`flow()`或 Ramda 的`pipe()`，它会的)，这里没有新的单元测试逻辑。

为了让这种风格正确工作，我们构建的单元需要*解耦。*

# 我们如何去除耦合？

为了消除耦合，我们首先需要更好地理解耦合依赖来自哪里。以下是主要来源，大致按耦合紧密程度排序:

紧密耦合:

*   类继承(耦合是通过每一层继承和每一个子类来倍增的)
*   全局变量
*   其他可变的全局状态(浏览器 DOM、共享存储、网络等)
*   有副作用的模块导入
*   来自组合的隐式依赖，例如`const enhancedWidgetFactory = compose(eventEmitter, widgetFactory, enhancements);`，其中`widgetFactory`依赖于`eventEmitter`
*   依赖注入容器
*   依赖注入参数
*   控制参数(外部单元通过告诉主体单元做什么来控制主体单元)
*   可变参数

松散耦合:

*   没有副作用的模块导入(在黑盒测试中，不是所有的导入都需要隔离)
*   消息传递/发布订阅
*   不可变参数(仍然会导致对状态形状的共享依赖)

具有讽刺意味的是，大多数耦合源都是最初设计用来减少耦合的机制。这是有意义的，因为为了将我们更小的问题解决方案重组为一个完整的应用程序，它们需要以某种方式集成和交流。有好的方法，也有坏的方法。只要可行，就应该避免导致紧耦合的来源。在健康的应用程序中，松耦合选项通常是可取的。

您可能会感到困惑，因为我将依赖注入容器和依赖注入参数归入了“紧耦合”组，而许多书籍和博客文章都将它们归类为“松耦合”。耦合不是二元的。这是一个梯度标度。这意味着任何分组都会有些主观和武断。

我用一个简单客观的石蕊测试来划分界限:

可以在不嘲笑依赖的情况下测试单元吗？如果不能，那么*就和*紧密耦合到被模仿的依赖项上。

您的单元拥有的依赖越多，就越有可能存在有问题的耦合。现在我们了解了耦合是如何发生的，我们能做些什么呢？

1.  **使用纯函数**作为组成的原子单位，而不是类、命令式过程或变异函数。
2.  **将副作用**与你程序逻辑的其余部分隔离开来。也就是说不要把逻辑和 I/O(包括网络 I/O、渲染 UI、日志等等)混在一起。
3.  从命令性组合中移除依赖逻辑,这样它们就可以成为不需要自己的单元测试的声明性组合。如果没有逻辑，单元测试就没有任何意义。

这意味着您用来设置网络请求和请求处理程序的代码不需要单元测试。相反，使用集成测试。

值得重复的是:

> *不要单元测试 I/O.*
> 
> *I/O 用于集成。请改用集成测试。*

对于集成测试来说，模仿和伪造是完全可以的。

# 使用纯函数

使用纯函数需要一点实践，没有这种实践，并不总是清楚如何编写一个纯函数来做你想做的事情。纯函数不能直接变异全局变量、传递给它们的参数、网络、磁盘或屏幕。它们所能做的就是返回一个值。

如果传递给你一个数组或一个对象，你想返回该对象的一个修改版本，你不能只对对象进行修改就返回它。您必须使用所需的更改创建对象的新副本。您可以使用数组访问器方法(例如，concat、filter、map、reduce、slice)、`Object.assign()`，使用一个新的空对象作为目标，或者使用数组或对象扩展语法。例如:

```
// Not pure
const signInUser = user => user.isSignedIn = true;const foo = {
  name: 'Foo',
  isSignedIn: false
};// Foo was mutated
console.log(
  signInUser(foo), // true
  foo              // { name: "Foo", isSignedIn: true }
);
```

vs…

```
// Pure
const signInUser = user => ({...user, isSignedIn: true });const foo = {
  name: 'Foo',
  isSignedIn: false
};// Foo was not mutated
console.log(
  signInUser(foo), // { name: "Foo", isSignedIn: true }
  foo              // { name: "Foo", isSignedIn: false }
);
```

或者，您可以尝试不可变数据类型的库，例如 [Mori](http://swannodette.github.io/mori/) 或 [Immutable.js](https://facebook.github.io/immutable-js/) 。我希望有一天我们会得到一组不可变的数据类型，类似于 JavaScript 中的 Clojure，但我并不抱太大希望。

您可能认为返回新对象可能会导致性能下降，因为我们正在创建一个新对象，而不是重用现有的对象，但是一个幸运的副作用是，我们可以通过使用身份比较(`===` check)来检测对象的更改，因此我们不必遍历整个对象来发现是否有任何更改。

如果您有一个复杂的状态树，可能不需要在每个渲染过程中深入遍历，则可以使用该技巧使 React 组件渲染得更快。从`PureComponent`继承，它用一个浅属性和状态比较来实现`shouldComponentUpdate()`。当它检测到身份相等时，它知道在状态树的那个部分中没有任何改变，并且它可以继续前进，而不需要深度的状态遍历。

纯函数也可以被记忆，这意味着如果你以前见过相同的输入，你不必重新构建整个对象。您可以用计算复杂性换取内存，并将预先计算的值存储在查找表中。对于不需要无限内存的计算昂贵的进程，这可能是一个伟大的优化策略。

纯函数的另一个特性是，因为它们没有副作用，所以使用分治策略将复杂的计算分布到大型处理器集群上是安全的。这种策略通常用于使用大规模并行 GPU 处理图像、视频或音频帧，这些 GPU 最初是为图形设计的，但现在通常用于许多其他目的，如科学计算。

换句话说，突变并不总是更快，它通常会慢几个数量级，因为它以牺牲宏优化为代价进行了微优化。

# 将副作用与程序逻辑的其余部分隔离开来

有几种策略可以帮助您将副作用与程序逻辑的其余部分隔离开来。以下是其中的一些:

1.  使用发布/订阅将 I/O 从视图和程序逻辑中分离出来。与其在 UI 视图或程序逻辑中直接触发副作用，不如发出一个描述事件或意图的事件或动作对象。
2.  将逻辑与 I/O 隔离，例如，使用`asyncPipe()`编写返回承诺的函数。
3.  使用代表未来计算的对象，而不是用 I/O 直接触发计算，例如，来自 [redux-saga](https://github.com/redux-saga/redux-saga) 的`call()`实际上并不调用函数。相反，它返回一个对象，该对象带有对函数及其参数的引用，saga 中间件会为您调用它。这使得`call()`和所有使用它的函数*都是纯函数*，很容易用*进行单元测试，不需要模仿。*

## 使用发布/订阅

发布/订阅是发布/订阅模式的缩写。在发布/订阅模式中，单元不直接相互调用。相反，他们发布其他单位(订户)可以收听的消息。发布者不知道什么(如果有的话)单位会订阅，订阅者也不知道发布者会发布什么(如果有的话)。

发布/订阅被嵌入到文档对象模型(DOM)中。应用程序中的任何组件都可以侦听从 DOM 元素调度的事件，如鼠标移动、单击、滚动事件、击键等。当每个人都使用 jQuery 构建 web 应用程序时，jQuery 自定义事件通常会将 DOM 转换为发布/订阅事件总线，以将视图呈现问题从状态逻辑中分离出来。

Pub/sub 也被烤成 Redux。在 Redux 中，您为应用程序状态创建一个全局模型(称为存储)。视图和 I/O 处理程序不是直接操纵模型，而是将动作对象分派给存储。一个动作对象有一个特殊的键，叫做`type`，各种 reducers 可以监听并响应这个键。此外，Redux 支持中间件，中间件也可以监听和响应特定的动作类型。这样，您的视图不需要知道应用程序状态是如何处理的，状态逻辑也不需要知道视图的任何信息。

它还使得通过中间件修补调度程序并触发跨领域问题变得很简单，例如动作日志记录/分析、与存储或服务器同步状态，以及修补与服务器和网络对等体的实时通信功能。

## 将逻辑与 I/O 隔离

有时候你可以使用单子成分(比如承诺)来消除成分中的依赖逻辑。例如，下面的函数包含不模仿所有异步函数就无法进行单元测试的逻辑:

```
async function uploadFiles({user, folder, files}) {
  const dbUser = await readUser(user);
  const folderInfo = await getFolderInfo(folder);
  if (await haveWriteAccess({dbUser, folderInfo})) {
    return uploadToFolder({dbUser, folderInfo, files });
  } else {
    throw new Error("No write access to that folder");
  }
}
```

让我们加入一些辅助伪代码，使它可以运行:

```
const log = (...args) => console.log(...args);// Ignore these. In your real code you'd import
// the real things.
const readUser = () => Promise.resolve(true);
const getFolderInfo = () => Promise.resolve(true);
const haveWriteAccess = () => Promise.resolve(true);
const uploadToFolder = () => Promise.resolve('Success!');// gibberish starting variables
const user = '123';
const folder = '456';
const files = ['a', 'b', 'c'];async function uploadFiles({user, folder, files}) {
  const dbUser = await readUser({ user });
  const folderInfo = await getFolderInfo({ folder });
  if (await haveWriteAccess({dbUser, folderInfo})) {
    return uploadToFolder({dbUser, folderInfo, files });
  } else {
    throw new Error("No write access to that folder");
  }
}uploadFiles({user, folder, files})
  .then(log)
;
```

现在通过`asyncPipe()`重构它以使用 promise composition:

```
const asyncPipe = (...fns) => x => (
  fns.reduce(async (y, f) => f(await y), x)
);const uploadFiles = asyncPipe(
  readUser,
  getFolderInfo,
  haveWriteAccess,
  uploadToFolder
);uploadFiles({user, folder, files})
  .then(log)
;
```

条件逻辑很容易删除，因为承诺内置了条件分支。想法是逻辑和 I/O 不能很好地混合，所以我们想从 I/O 相关代码中移除逻辑。

为了让这种组合发挥作用，我们需要确保两件事:

1.  如果用户没有写权限，`haveWriteAccess()`将拒绝。这将条件逻辑移到了 promise 上下文中，因此我们不必对它进行单元测试，也不必担心它(promise 在 JS 引擎代码中嵌入了自己的测试)。
2.  这些函数中的每一个都采用相同的数据类型并以相同的数据类型进行解析。我们可以为这个组合创建一个`pipelineData`类型，它只是一个包含以下键的对象:`{ user, folder, files, dbUser?, folderInfo? }`。这在组件之间创建了一个共享依赖关系的结构，但是您可以在其他地方使用这些函数的更通用的版本，并使用瘦包装函数将它们专用于这个管道。

满足这些条件后，在不模仿其他函数的情况下，单独测试这些函数是很简单的。因为我们已经从管道中提取了所有的逻辑，所以这个文件中没有任何有意义的单元测试。剩下要测试的就是集成了。

> 记住:*逻辑和 I/O 是分开的。
> 逻辑就是思考。效果就是行动。三思而后行！*

## 使用代表未来计算的对象

redux-saga 使用的策略是使用代表未来计算的对象。这个想法类似于返回一个单子，除了它并不总是被返回的单子。单子能够通过链操作来组合函数，但是您可以使用命令式代码来手动链接函数。下面是 redux-saga 如何做到这一点的粗略草图:

```
// sugar for console.log we'll use later
const log = msg => console.log(msg);const call = (fn, ...args) => ({ fn, args });
const put = (msg) => ({ msg });// imported from I/O API
const sendMessage = msg => Promise.resolve('some response');// imported from state handler/Reducer
const handleResponse = response => ({
  type: 'RECEIVED_RESPONSE',
  payload: response
});const handleError = err => ({
  type: 'IO_ERROR',
  payload: err
}); function* sendMessageSaga (msg) {
  try {
    const response = yield call(sendMessage, msg);
    yield put(handleResponse(response));
  } catch (err) {
    yield put(handleError(err));
  }
}
```

您可以看到单元测试中进行的所有调用，而不会嘲笑网络 API 或引起任何副作用。好处:这使得你的应用程序非常容易调试，而不用担心不确定的网络状态等…

想要模拟当网络错误发生时在你的应用中会发生什么？只需调用`iter.throw(NetworkError)`

在其他地方，一些库中间件正在驱动该功能，并且实际上触发了生产应用程序中的副作用:

```
const iter = sendMessageSaga('Hello, world!');// Returns an object representing the status and value:
const step1 = iter.next();log(step1);
/* =>
{
  done: false,
  value: {
    fn: sendMessage
    args: ["Hello, world!"]
  }
}
*/
```

从产生的值中析构`call()`对象，以检查或调用未来的计算:

```
const { value: {fn, args }} = step1;
```

效果在真实的中间件中运行。在测试和调试时，可以跳过这一部分。

```
const step2 = fn(args);step2.then(log); // "some response"
```

如果您想在不模仿 API 或 http 调用的情况下模拟网络响应，您可以将模拟响应传递到`.next()`:

```
iter.next(simulatedNetworkResponse);
```

从那里你可以继续调用`.next()`，直到`done`变为`true`，你的函数运行完毕。

在你的单元测试中使用生成器和计算的表示，你可以模拟所有的*直到但是不包括*调用真实的副作用。您可以将值传递到`.next()`调用中来伪造响应，或者在迭代器中抛出错误来伪造错误并承诺拒绝。

使用这种风格，没有必要在单元测试中模仿任何东西，即使对于复杂的集成工作流，也有很多副作用。

# “代码气味”是警告信号，而不是法律。嘲笑不是邪恶的。

所有这些关于使用更好的架构的东西都很棒，但在现实世界中，我们必须使用其他人的 API，并与遗留代码集成，并且有许多 API 不是纯粹的。在这些情况下，隔离测试双精度可能会有用。例如，express 传递共享的可变状态，并通过延续传递对副作用进行建模。

我们来看一个常见的例子。人们试图告诉我 express 服务器定义文件需要依赖注入，否则你如何对所有进入 express 应用程序的东西进行单元测试？例如:

```
const express = require('express');
const app = express();app.get('/', function (req, res) {
  res.send('Hello World!')
});app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
});
```

为了“单元测试”*这个文件，*我们必须制定一个依赖注入解决方案，然后将所有的模拟传递到其中(可能包括`express()`本身)。如果这是一个非常复杂的文件，其中不同的请求处理程序使用不同的 express 特性，并且依赖于其中的逻辑，那么您可能必须想出一个非常复杂的伪造品来实现它。我见过开发人员精心制作的伪造品和仿制品，比如 express、会话中间件、日志处理程序、实时网络协议等等。我自己也面临过尖锐的嘲讽问题，但正确的答案很简单。

> 这个文件不需要单元测试。

根据定义，express 应用程序的服务器定义文件是应用程序的主要集成点。根据定义，测试 express 应用程序文件就是测试您的程序逻辑、express 和该 express 应用程序的所有处理程序之间的集成。即使你能达到 100%的单元测试覆盖率，你也绝对不应该跳过集成测试。

不要试图对这个文件进行单元测试，而是将您的程序逻辑隔离到单独的单元中，并对这些文件进行单元测试。为服务器文件编写真正的集成测试，这意味着您将实际访问网络，或者至少创建实际的 http 消息，使用像 [supertest](https://github.com/visionmedia/supertest) 这样的工具完成头部。

让我们重构 Hello World express 示例，使其更易于测试:

将`hello`处理程序放到它自己的文件中，并为它编写单元测试。没有必要嘲笑其余的应用程序组件。这显然不是一个纯粹的函数，所以我们需要监视或模拟响应对象，以确保我们调用了`.send()`。

```
const hello  = (req, res) => res.send('Hello World!');
```

你可以这样测试它。将`if`语句换成您最喜欢的测试框架期望:

```
{
  const expected = 'Hello World!';
  const msg = `should call .send() with ${ expected }`; const res = {
    send: (actual) => {
      if (actual !== expected) {
        throw new Error(`NOT OK ${ msg }`);
      }
      console.log(`OK: ${ msg }`);
    }
  } hello({}, res);
}
```

将监听处理程序放到它自己的文件中，并为它编写单元测试。我们这里也有同样的问题。快速处理程序不是纯的，所以我们需要监视日志记录器以确保它被调用。测试与前面的示例相似:

```
const handleListen = (log, port) => () => log(`Example app listening on port ${ port }!`);
```

现在，服务器文件中只剩下集成逻辑:

```
const express = require('express');const hello = require('./hello.js');
const handleListen = require('./handleListen');
const log = require('./log');const port = 3000;
const app = express();app.get('/', hello);app.listen(port, handleListen(port, log));
```

您仍然需要对这个文件进行集成测试，但是进一步的单元测试不会有意义地提高您的案例覆盖率。我们使用一些非常小的依赖注入来传递一个日志到`handleListen()`，但是对于 express apps 来说当然不需要任何依赖注入框架。

# 模仿对于集成测试来说是很棒的

因为集成测试测试单元之间的协作集成，所以完全可以伪造服务器、网络协议、网络消息等等，以便重现您在与其他单元通信时会遇到的各种情况，这些情况可能分布在 CPU 集群或网络上的独立机器上。

有时你会想测试你的单元如何与第三方 API 通信，而有时这些 API 的测试费用非常昂贵。您可以记录真实服务的真实工作流事务，并从一个假服务器上重放它们，以测试您的单元与实际运行在独立网络进程中的第三方服务的集成程度。通常，这是测试诸如“我们看到了正确的消息头吗？”

有许多有用的集成测试工具会限制网络带宽、引入网络延迟、产生网络错误，或者测试许多其他条件，这些条件是无法使用模拟通信层的单元测试来测试的。

没有集成测试就不可能实现 100%的案例覆盖率。即使你设法实现了 100%的单元测试覆盖率，也不要跳过它们。有时候 100%不是 100%。

# 后续步骤

*   了解为什么我认为[每个开发团队都应该在横切关注点播客中使用 TDD](https://crosscuttingconcerns.com/Podcast-061-Eric-Elliott-on-TDD) 。
*   JS 啦啦队长正在 Instagram 上记录[我们的冒险。](https://www.instagram.com/js_cheerleader/)

# 在 EricElliottJS.com 了解更多信息

EricElliottJS.com 的成员可以观看单元测试的视频课程。如果你还不是会员，[今天就注册](https://ericelliottjs.com/)。

[![](img/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png)](https://ericelliottjs.com/product/lifetime-access-pass/)

***埃里克·艾略特*** *是一位科技产品和平台顾问，《 [*【作曲软件】*](https://leanpub.com/composingsoftware)*[*【EricElliottJS.com】*](https://ericelliottjs.com)*[*devanywhere . io*](https://devanywhere.io)*的联合创始人，以及 dev 团队导师。他曾为 Adobe Systems、* ***、Zumba Fitness、*** ***【华尔街日报、*******【ESPN、*******【BBC】****等顶级录音艺人和包括* ***Usher、【Metallica】********

*他和世界上最美丽的女人享受着与世隔绝的生活方式。*