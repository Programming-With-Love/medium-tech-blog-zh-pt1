# 用连接模式粉碎您的适配器整体

> 原文：<https://medium.com/google-developer-experts/smash-your-adapter-monolith-with-the-connect-pattern-fd4854a18e61?source=collection_archive---------0----------------------->

在这篇文章中，我描述了一种以模块化和可扩展的方式编写第三方适配器的模式，希望它足够新颖，我可以将其命名为。🙃

# TL；速度三角形定位法(dead reckoning)

> ****

![](img/6f99bcb15f4f678f6110f07cec8a0302.png)

*读者注意:虽然这篇文章是关于一个不特定于 Kotlin 的模式，但是它使用 Kotlin 编写的代码演示了这个模式。这使用了各种语言特性如* [***数据类***](https://kotlinlang.org/docs/reference/data-classes.html) *，* [***伴侣对象***](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) *，运算符重载和* [***扩展函数***](https://kotlinlang.org/docs/reference/extensions.html) *。它还使用了*[***http4k***](https://http4k.org)*HTTP 工具包的基础知识，如果不熟悉的话，可能值得参考一下。*

在一个现代的基于服务器的 HTTP 微服务中，大部分非操作性的应用程序代码可以分成几个大的区域:

1.  入站服务器端 API，路由和解组传入的请求
2.  业务逻辑功能
3.  数据访问查询和变异
4.  出站远程 API 通信的适配器代码

## 构建我们的入站 API

对于**1)**——服务器端——我们倾向于将应用程序建模为一组独立的 HTTP 入口点类/函数，它们组合成一个整体来表示传入的 HTTP API，或者显式地，或者通过一些元编程(如注释)来表示。例如，使用 http4k，我们可以创建并启动我们的服务器:

在这种情况下，将服务器端 API 分割成独立的函数，使我们能够从整体上保持对应用程序的良好控制，并且能够独立于其他部分轻松测试应用程序中的各种端点——例如，如果我们能够直接测试`echo()`和`health()`，我们就不需要提供一个无记名令牌来访问我们的 API 调用。

此外，因为我们以这种方式模块化了代码，所以它也可以在其他上下文中重用——我们可以将通用端点代码(如`health()`)放入共享位置，并在我们的微服务群中重用它们。

## 构建我们的出站 API

当谈到上面列表中的**4)**——其他远程 API 的适配器代码——我们通常没有合适的模式来使用相同的结构。远程系统的 HTTP 适配器通常被构造为具有许多方法的整体类，所有这些都是围绕一个单独配置的 HTTP 适配器构建的。假设我们想要与 GitHub API 对话，我们通常会构建一个 API 适配器，如下所示:

这是非常明智的——有一个共享的 HTTP 客户端，它被配置为使用正确的`Accept`头向 API 发送请求。然而不幸的是，随着我们对 API 使用的增长，`GitHubApi`类的规模也会增长——它可能会获得许多(几十个甚至上百个)函数，所有这些函数通常都提供对单个 API 调用的单一访问。如果不检查的话，我们最终会得到一个长达数千行的巨大物体。

由于这些函数之间通常没有交互——以模块化、易于测试和可重用的方式，以类似于我们构建入站 API 的方式构建代码是可取的。即便如此，我们也想找到一种方法来构建结合一个或多个 API 调用的函数。

这就是连接模式将帮助我们的地方。本质上，Connect 允许将一个适配器整体拆分成单独的动作和一个共享的协议对象，该对象集中了与 API 的通信。

## 介绍连接模式

模式本身是围绕 Kotlin 语言中可用的特性创建的——最显著的是接口和扩展函数的使用。其他语言可能没有这些完全相同的功能，但是 Connect 应该是可适应的(或多或少)。让我们把它分解开来，通过重新实现上面的例子来看一看。

下面的解释基于简化版本的 [**http4k-connect**](https://github.com/http4k/http4k-connect) 库，我们将它用作模式的规范实现。顾名思义，http4k-connect 本身构建在用于核心 http 抽象的[**http4k**](https://http4k.org)http toolkit 之上，尽管模式中没有任何东西将它绑定到这个库(甚至 HTTP 协议)。

## 行动

Connect 模式中的基本工作单元是`Action`接口，它代表与远程系统的单一交互，由返回对象`R`的类型来概括。每个动作都包含需要传输的数据的状态，以及如何将动作中的数据封送到底层 HTTP API 和从底层 HTTP API 封送数据。

对于我们的`GitHubApi`适配器，我们创建了超接口和一个动作的实现，以从 API 获取用户和结果类型。请注意，动作和结果类型被建模为 Kotlin 数据类——这将给我们带来优势，我们将在后面介绍:

## 适配器

适配器接口代表了与远程 API 交互的公共基础协议——它将处理服务器主机位置、授权和其他报头，并执行实际的 HTTP 交互。每个适配器都被建模为一个简单的接口，带有一个接受通用动作类型的通用方法。

注意这里 Kotlin `companion object`的存在——它应该是空的，正好给我们一个点，让我们在一会儿把其他代码挂在上面。这是为了让 API 用户的生活更轻松。

我们对 companion 对象的第一次使用是将我们之前的版本重写为`GitHubApi`的匿名实现，并将其附加到我们的适配器，由`Http()`工厂函数返回。适配器所需的所有依赖项都在这里传递并关闭。注意，我们显式地传入 HTTP 客户端，而不是在函数内部构造它——如果我们希望能够用调用日志记录或其他操作问题来修饰客户端适配器，对它的访问是至关重要的:

## 使用适配器

除了使用 Companion 对象作为钩子之外，我们的适配器的构造看起来与以前的版本相似——我们没有公开任何更多的具体类型(仍然只有`GitHubApi`)。然而，调用 API 看起来确实有所不同——由于操作符函数`invoke()`，我们现在将服务器视为一个简单的函数，它接受动作实例:

这种变化可能会留下一点不好的印象，因为 API 不再容易被发现。幸运的是，科特林还有另一个锦囊妙计，这将帮助我们…

## 扩展功能

通过为每个动作创建另一个扩展函数，模仿动作本身的签名并委托给客户端中的`invoke()`调用，我们可以非常简单地恢复我们的旧 API:

更好的是，对于包含不止一个 API 调用的动作，比如下面的`getLatestUser()`,我们可以创建更多的扩展函数，将它们委托给单独的动作。这些函数可以在全局级别添加到`GitHubApi`实例中，或者只添加到有意义的上下文或模块中。扩展功能有效地允许我们从我们感兴趣的单个动作部件中组合出我们自己的定制`GitHubApi`适配器:

# 测试连接模式

适配器和各种动作类的模块化都使得为使用 Connect 模式创建的动作代码编写单元测试变得非常容易，但是考虑 API 设计将如何影响客户端代码的测试也很重要。

幸运的是，单个 arity 函数适配器接口的简单性与作为 Kotlin 数据类实现的动作(很容易比较)使得作为 Connect APIs 客户端的测试在多个层面上变得微不足道。例如，如果我们打算模拟一个函数，它有七个我们不关心的参数——在前面的实现中，我们必须模拟出每个带值的参数(或一个`any()`匹配器),而不是一个覆盖连接版本的`any<Action>()`:

Action 对象是`invoke()`方法的一个参数，这也让我们能够轻松地修饰我们的适配器实例以用于测试或其他目的，例如，我们可以为任何目的记录所有的来电:

编写适配器的存根实现也非常简单，并且 Connect 模式还鼓励与真实适配器相同类型的分解结构——通过创建扩展函数，这些函数作用于我们的内存状态以创建它们的响应。同样，这有助于控制适配器代码的大小。

## 改变编程模型

根据团队的风格，有几种不同的流行编程模型，它们可能在野外很常见，这将影响为 Action 类实现的`R`类型的值。

正如我们上面的例子，使用支持抛出异常的语言的传统 OO 风格团队将把`R`表示为方法返回的直接结果类型，但是采用更函数式编程方法的团队将倾向于使用更一元的返回类型，例如 [**Result4k**](https://github.com/fork-handles/forkhandles/tree/trunk/result4k) **的** `Result`、 [**箭头**](https://arrow-kt.io/docs/apidocs/arrow-core-data/arrow.core/-either/) **的** `Either`，或者(当它普遍可用时)Kotlin 的内置

好消息是，由于 Connect 抽象的解耦，这些模型中的任何一个都可以简单地通过以相关的风格编写动作来支持。下面是使用 Result4k 单子的`GetUser`动作的另一个例子:

# 摘要

Connect 模式结合了简单的抽象来提供一个模型，该模型允许我们将整体出站 API 适配器的常见问题分解成容易理解的部分。这种模块化提供了我们在构建入站服务器端接口时所期望的可组合性的镜像，这进一步导致了更易测试和可扩展的代码库。对于这样一个小例子，这种方法可能看起来有些矫枉过正，但是经验告诉我们，通常来说，改进一个组合设计比从一开始就推广它要困难得多。

该模式最初是围绕 HTTP 设计的，适合任何请求/响应协议，并且可以很容易地适应不同的编程模型，包括结果单子和未来类型。

最后，尽管对 Connect 模式的实现并不重要，但具有扩展函数等特性的更高级的编程语言(如 Kotlin)为使用 Connect 提供了一个理想的平台。在静态类型语言中，足够高级的泛型功能是唯一需要的语言特性。

**注:**本帖显示的代码在 [**GitHub**](https://github.com/http4k/http4k-connect-examples/tree/master/connect-pattern) 中有。

# 模式的 http4k-connect 实现的脚注

![](img/33c42029be4afaf21ca147c21ae3dcba.png)

开源的[**http4k-Connect**](https://github.com/http4k/http4k-connect)**kot Lin 库既提供了实现连接模式适配器的基本框架，也提供了一组预构建的 API 适配器，用于与 AWS 等流行的云服务进行通信。此外，http4k-connect 提供了一组协议兼容的内存/可运行的伪服务器，可以用作各种服务的测试替身，以及一组存储后端(如内存、S3 和 Redis ),用于存放测试数据。**

**这些库被设计为尽可能的轻量级，这意味着它们是无服务器部署的完美用例，它们使用编译时代码生成为每个使用 Kapt 实现的操作自动编写扩展函数，并且通过使用 [**Kotshi**](https://github.com/ansman/kotshi) 插件为 [**Moshi**](https://github.com/square/moshi) JSON 框架生成消息适配器，不需要 JSON 消息解析中的反射。**

***喜欢这篇文章吗？你可以在*[***https://dentondav.id/writing***](https://dentondav.id/writing)*阅读我所有的科技文章，或者了解更多关于**[***http4k***](https://http4k.org)*的信息。****