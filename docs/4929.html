<html>
<head>
<title>Kotlin for Interviews — Part 1: Common Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试用Kotlin第1部分:常见数据类型</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-for-interviews-part-1-common-data-types-886ea1e40645?source=collection_archive---------1-----------------------#2020-10-27">https://blog.kotlin-academy.com/kotlin-for-interviews-part-1-common-data-types-886ea1e40645?source=collection_archive---------1-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2f4d31a1ddd9b0cb1a00d70f61bda580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oqzs93xRPyeRc7lr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rumpflet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christina Rumpf</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5de8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了五月和六月的大部分时间准备面试，我说的准备面试是指做大量的Leetcode。自从我申请Android职位以来，我决定解决Kotlin中的大多数问题，并注意到我写的Kotlin与我在工作中使用的Kotlin非常不同。我决定将面试准备过程中经常出现的代码片段汇总成一份备忘单，然后在5篇中型文章中深入研究这些代码片段。你可以在这里找到备忘单<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-cheatsheet-88a9831e9d55"/>。</p><p id="b016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第1部分中，我将介绍一些在算法和数据结构问题中经常出现的常见数据类型——如何初始化它们，如何对它们进行一些常见操作，以及一些用例。我们将回顾:</p><ul class=""><li id="c48d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="#6f73" rel="noopener ugc nofollow">可变列表</a></li><li id="29e5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#adbe" rel="noopener ugc nofollow">数组</a></li><li id="d41e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#f261" rel="noopener ugc nofollow">散列表</a></li><li id="2d8a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#911c" rel="noopener ugc nofollow">优先级队列</a></li><li id="a2a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#332c" rel="noopener ugc nofollow">比较器</a></li><li id="cc1a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#3f49" rel="noopener ugc nofollow">可比</a></li></ul><p id="413a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到第2部分<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-2-collection-functions-a4a488fa0a14">这里</a>，第3部分<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-3-numbers-and-math-786660295cea">这里</a>，第4部分— <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-4-iteration-b176dee4f1ae">这里</a>，第5部分— <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-5-frequently-used-code-snippets-444ad4d137f5">这里</a>。</p><h2 id="6f73" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">可变列表</h2><p id="a877" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是我最常用的数据结构，你可能已经很熟悉了。我想指出的是，如果你遇到一个需要堆栈或队列的问题，你可以很容易地将它用作堆栈或队列；在广度优先搜索中，我通常使用一个可变列表来表示队列。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ec6a" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create an empty MutableList</em><strong class="ms ir"><br/>val list1 = mutableListOf&lt;Int&gt;()</strong></span><span id="c07a" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create a MutableList with elements [0, 1, 2, 3, 4]</em><strong class="ms ir"><br/>val list2 = mutableListOf(0, 1, 2, 3, 4)</strong></span></pre><p id="9455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用可变列表作为堆栈</strong></p><ul class=""><li id="cf42" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nc nd ne ms b">add()</code>在列表末尾添加一个元素，可用作<code class="fe nc nd ne ms b">push</code></li><li id="1d0a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">removeLast()</code>从列表中删除最后一个元素并返回，可用作<code class="fe nc nd ne ms b">pop</code></li><li id="ed1a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">last()</code>返回最后一个元素而不删除，可用作<code class="fe nc nd ne ms b">peek</code></li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="70bd" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">val stack: MutableList&lt;Int&gt; = mutableListOf()<br/></strong><em class="na">// push</em><strong class="ms ir"><br/>stack.add(1)<br/>stack.add(2)<br/></strong><em class="na">// peek</em><strong class="ms ir"><br/>stack.last()</strong><em class="na"> // returns 2<br/>// pop</em><br/><strong class="ms ir">stack.removeLast() </strong><em class="na">// returns 2<br/></em><strong class="ms ir">stack.removeLast() </strong><em class="na">// returns 1</em></span></pre><p id="ed6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用可变列表作为队列</strong></p><ul class=""><li id="e5eb" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nc nd ne ms b">add()</code>可用作<code class="fe nc nd ne ms b">enqueue</code></li><li id="60a8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">removeAt(0)</code>从列表中删除第一个元素并返回，可用作<code class="fe nc nd ne ms b">dequeue</code></li><li id="844c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">get(0)</code>返回第一个元素，可作为<code class="fe nc nd ne ms b">peek</code></li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b65a" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">val queue: MutableList&lt;Int&gt; = mutableListOf()<br/></strong><em class="na">// enqueue</em><strong class="ms ir"><br/>queue.add(1)<br/>queue.add(2)</strong><em class="na"><br/>// peek</em><strong class="ms ir"><br/>queue[0]</strong><em class="na"> // returns 1<br/>// dequeue</em><br/><strong class="ms ir">queue.removeAt(0) </strong><em class="na">// returns 1<br/></em><strong class="ms ir">queue.removeAt(0) </strong><em class="na">// returns 2</em></span></pre><h2 id="adbe" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">排列</h2><p id="0c93" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">数组看起来很基本，但是当我开始准备面试时，我意识到我对它们不是很了解，因为我倾向于使用列表。当一个Leetcode问题有一个数组输入或者期望一个数组输出时，我必须做一些谷歌搜索。</p><p id="771b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Kotlin中，数组是固定大小的，支持<code class="fe nc nd ne ms b">get()</code>、<code class="fe nc nd ne ms b">set()</code>和<code class="fe nc nd ne ms b">size</code>，以及大多数<a class="ae kc" href="https://kotlinlang.org/docs/reference/collection-operations.html" rel="noopener ugc nofollow" target="_blank"> Kotlin集合函数</a>。您可以使用<code class="fe nc nd ne ms b">[]</code>，也就是一个索引操作符，更简洁地进行获取和设置。您不能更改大小或删除元素。我发现数组对于需要跟踪固定数量的计数器或标志的问题很有用。</p><p id="72c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种方法可以初始化数组。可以用<code class="fe nc nd ne ms b">arrayOf&lt;T&gt;()</code>:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4811" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create an array with elements [0, 1, 2, 3, 4]</em><br/><strong class="ms ir">val array1 = arrayOf&lt;Int&gt;(0, 1, 2, 3, 4)</strong></span></pre><p id="820a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者用<code class="fe nc nd ne ms b">Array&lt;T&gt;(n) { initFunction }</code>。这将创建一个大小为<em class="na"> n </em>的数组，其中每个元素都是使用<code class="fe nc nd ne ms b">initFunction</code>创建的。<code class="fe nc nd ne ms b">initFunction</code>可以只是一个缺省值，比如一个数组<code class="fe nc nd ne ms b">Ints</code>的-1，或者一个代码块。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5379" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create an array with elements [0, 0, 0, 0, 0]</em><br/><strong class="ms ir">val array2 = Array&lt;Int&gt;(5) { 0 }</strong></span><span id="4769" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create an array with elements [0, 2, 4, 6, 8]<br/>// The initFunction block can access the index as a parameter.<br/>// Here, each element is initialized by taking its index and multiplying it by 2.</em><strong class="ms ir"><br/>val array3 = Array&lt;Int&gt;(5) { index -&gt; 2 * index }</strong></span></pre><p id="3984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下原语类型也有专用的<em class="na">数组</em>方法:<code class="fe nc nd ne ms b">double</code> <em class="na">，</em> <code class="fe nc nd ne ms b">float</code> <em class="na">，</em> <code class="fe nc nd ne ms b">long</code> <em class="na">，</em> <code class="fe nc nd ne ms b">int</code> <em class="na">，</em> <code class="fe nc nd ne ms b">char</code> <em class="na">，</em> <code class="fe nc nd ne ms b">short</code> <em class="na">，</em> <code class="fe nc nd ne ms b">byte</code> <em class="na">，</em> <code class="fe nc nd ne ms b">boolean</code>，通过避免科特林的<a class="ae kc" href="https://kotlinlang.org/docs/reference/basic-types.html#representation" rel="noopener ugc nofollow" target="_blank">装箱开销</a>:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4e0b" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create an array with elements [0, 1, 2, 3, 4]</em><strong class="ms ir"><br/>val intArray1 = intArrayOf(0, 1, 2, 3, 4)</strong></span><span id="86e9" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create an array with elements [0, 0, 0, 0, 0]</em><strong class="ms ir"><br/>val intArray2 = IntArray(5) { 0 }</strong></span><span id="f400" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create an array with elements [true, true, false, true, true]<br/></em><strong class="ms ir">val booleanArray1 = booleanArrayOf(true, true, false, true, true)</strong></span><span id="3d65" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create an array with elements [true, false, true, false, true]<br/></em><strong class="ms ir"><em class="na">// </em></strong><em class="na">Each element is initialized by by whether or not its index is even</em><strong class="ms ir"><br/>val booleanArray2 = BooleanArray(5) { index -&gt; index % 2 == 0 }</strong></span></pre><p id="c871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://leetcode.com/problems/running-sum-of-1d-array/" rel="noopener ugc nofollow" target="_blank">运行一维数组的和</a>是一个简单的Leetcode问题的例子，您可以使用<code class="fe nc nd ne ms b">IntArray</code>来跟踪结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7888" class="lp lq iq ms b gy mw mx l my mz"><em class="na">/**<br/>* </em><strong class="ms ir"><em class="na">Problem description</em></strong><em class="na">: Given an array </em>nums<em class="na">. We define a running sum <br/>* of an array as </em><em class="na">runningSum[i] = sum(nums[0]…nums[i])</em><em class="na">. Return the <br/>* running sum of </em>nums<em class="na">.<br/>*<br/>* </em><strong class="ms ir"><em class="na">Example:</em></strong><em class="na"><br/>* Input: nums = [1,2,3,4]<br/>* Output: [1,3,6,10]<br/>* Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, <br/>* 1+2+3+4].<br/>** /</em><br/><strong class="ms ir">fun runningSum(nums: IntArray): IntArray {<br/>    val results = IntArray(nums.size) { 0 }<br/>    results[0] = nums[0]<br/>    for (i in 1 <em class="na">until </em>nums.size) {<br/>        results[i] = results[i - 1] + nums[i]<br/>    }<br/>    return results<br/>}</strong></span></pre><h2 id="f261" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">散列表</h2><p id="d2a9" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">HashMaps表示一组键-值对，其中键是惟一的，每个键只能有一个值。在面试问题中，它们通常有助于存储信息。例如，<code class="fe nc nd ne ms b">HashMap&lt;Node, Boolean&gt;</code>可以存储图中哪些节点已经被访问过，而<code class="fe nc nd ne ms b">HashMap&lt;String, Int&gt;</code>可以存储句子中出现的不同单词的计数。</p><p id="bc55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些有用的功能:</p><ul class=""><li id="6d45" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nc nd ne ms b">clear()</code> <strong class="kf ir"> </strong>从地图上删除所有元素。</li><li id="d04e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">containsKey(key: K)</code>如果映射包含指定的键，则返回true。</li><li id="6429" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">remove(key: K)</code>从该映射中删除指定的键及其相应的值。</li><li id="eb4f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">getOrPut(key: K, defaultValue: () -&gt; V) </code>如果给定键在地图中，则返回该键的值。如果不是，调用<code class="fe nc nd ne ms b">defaultValue</code>函数，将其结果放入给定键下的map中，并返回。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f660" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create an empty HashMap</em><strong class="ms ir"><br/>val map1 = hashMapOf&lt;String, Int&gt;()</strong></span><span id="c410" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Create a HashMap with initial values<br/></em><strong class="ms ir">val map2 = hashMapOf(<br/>    "Never Let Me Go" to 2005,<br/>    "A Little Life" to 2015<br/>)</strong></span><span id="1376" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Two ways to insert a key-value pair</em><strong class="ms ir"><br/>map2.put("The Name of the Wind", 2007)<br/>map2["The Bell Jar"] = 1963</strong></span><span id="64d4" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Two ways to retrieve a value<br/></em><strong class="ms ir">map2.get("The Name of the Wind") </strong><em class="na">// returns 2007</em><strong class="ms ir"><br/>map2["The Bell Jar"] </strong><em class="na">// returns 1963</em></span><span id="521c" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Using getOrPut()<br/></em><strong class="ms ir">map2.getOrPut("The Name of the wind", 1990)</strong> <em class="na">// Returns 2007</em><br/><strong class="ms ir">map2.getOrPut("1984", 1949)</strong> <em class="na">// Inserts new entry and </em>returns 1949</span></pre><h2 id="911c" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">优先级队列</h2><p id="2d1c" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">当您希望根据元素的优先级来处理元素时，优先级队列非常有用。这个类是使用堆实现的。它们经常被用在要求K次最大，K次最小，K次最频繁等等的面试问题中。</p><p id="ac9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe nc nd ne ms b">PriorityQueue&lt;T&gt;()</code>来初始化一个，在这里它将使用类型<code class="fe nc nd ne ms b">T</code>的自然排序来确定优先级，或者使用像<code class="fe nc nd ne ms b">PriorityQueue&lt;T&gt; { (a: T, b: T) -&gt; Int }</code>这样的自定义<code class="fe nc nd ne ms b">Comparator</code>，在这里您可以指定一种自定义方式来确定优先级。</p><p id="7c2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些有用的功能:</p><ul class=""><li id="a95b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nc nd ne ms b">add(element: E)</code>和<code class="fe nc nd ne ms b">offer(element: E)</code>都插入了一个元素，你可以使用其中任何一个；<code class="fe nc nd ne ms b">PriorityQueue</code>有两个函数做完全相同的事情，因为它实现了两个接口<code class="fe nc nd ne ms b">Collection</code>和<code class="fe nc nd ne ms b">Queue</code>。集合使用<code class="fe nc nd ne ms b">add()</code>进行插入，而队列使用<code class="fe nc nd ne ms b">offer()</code> <em class="na">。</em></li><li id="d644" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">peek()</code> <strong class="kf ir"> <em class="na"> </em> </strong>返回，但不删除队列的头。</li><li id="1df1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nc nd ne ms b">poll()</code> <strong class="kf ir"> </strong>返回并删除队列头。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5c38" class="lp lq iq ms b gy mw mx l my mz"><em class="na">// Create a PriorityQueue pq where the maximum value Int has highest <br/>// priority</em><br/><strong class="ms ir">val pq = PriorityQueue&lt;Int&gt; {<br/>    a, b -&gt; b - a<br/>}<br/></strong><em class="na">// Add 2, 1, 3 to the pq</em><br/><strong class="ms ir">pq.offer(2)<br/>pq.add(1)<br/>pq.offer(3)</strong><br/><br/><strong class="ms ir">pq.peek()</strong> <em class="na">// returns 3 but does not remove it from pq</em></span><span id="c8aa" class="lp lq iq ms b gy nb mx l my mz">// <em class="na">pq will be empty after 3 iterations</em><strong class="ms ir"><br/>while(pq.<em class="na">isNotEmpty</em>()) {<br/>    pq.poll()<em class="na"> </em></strong><em class="na">// returns 3, then 2, then 1</em><strong class="ms ir"><br/>}</strong></span></pre><h2 id="332c" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">比较仪</h2><p id="5ec6" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated"><code class="fe nc nd ne ms b">Comparator&lt;T&gt;</code>接口提供了一个比较函数，用于在类型<code class="fe nc nd ne ms b">T</code>的实例之间强加一个总排序。对于需要排序或区分优先次序的技术面试问题来说，这通常很有用，因为大多数Kotlin排序算法会让你通过一个<code class="fe nc nd ne ms b">Comparator</code>。</p><p id="8747" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用Kotlin的<code class="fe nc nd ne ms b"><a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/compare-by.html" rel="noopener ugc nofollow" target="_blank">compareBy(</a>)</code>函数创建一个<em class="na"> </em> <code class="fe nc nd ne ms b">Comparator</code>，它使用您传入的函数序列来计算比较结果。对成对的值连续计算函数序列，一旦函数返回的两个值的结果不相等，就返回结果，并跳过该对的其余函数。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="595d" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">val customComparator = compareBy&lt;T&gt; { <br/>    ...<br/>}</strong></span></pre><p id="2e97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个用绝对值来比较<code class="fe nc nd ne ms b">Ints</code>的<code class="fe nc nd ne ms b">Comparator</code>的例子:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="deca" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">val absComparator = compareBy&lt;Int&gt;{ Math.abs(it) }<br/>val nums: MutableList&lt;Int&gt; = mutableListOf(-1, 3, 7, -5, 3)<br/>nums.sortWith(absComparator)</strong></span><span id="7cf7" class="lp lq iq ms b gy nb mx l my mz"><em class="na">// Or if you only need to use the comparator once, you can pass in <br/>// the call to compareBy() directly.</em><strong class="ms ir"><br/>val nums: MutableList&lt;Int&gt; = mutableListOf(-1, 3, 7, -5, 3)<br/>nums.sortWith(compareBy{ Math.abs(it) })</strong></span></pre><p id="5164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个<code class="fe nc nd ne ms b">Comparator</code>的例子，它通过颜色属性来比较自定义的<code class="fe nc nd ne ms b">Card</code>类，并且<code class="fe nc nd ne ms b">BLACK</code>卡比<code class="fe nc nd ne ms b">RED</code>卡“更好”。我们将使用number属性来打破平局:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8495" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">enum class Color { RED, BLACK }</strong></span><span id="9f45" class="lp lq iq ms b gy nb mx l my mz"><strong class="ms ir">data class Card(val number: Int, val color: Color)</strong></span><span id="0a32" class="lp lq iq ms b gy nb mx l my mz"><strong class="ms ir">val cardComparator = compareBy(<br/></strong><em class="na">    // Compare by color first </em><strong class="ms ir"><br/>    { if(it.color == BLACK) 1 else 0 }, <br/></strong><em class="na">    // If the results of color comparison are equal, compare by <br/>    // number</em><strong class="ms ir"><br/>    { it.number }<br/>)</strong></span><span id="0b57" class="lp lq iq ms b gy nb mx l my mz"><strong class="ms ir">val cards: MutableList&lt;Card&gt; = mutableListOf(<br/>    Card(4, Color.RED), <br/>    Card(2, Color.BLACK), <br/>    Card(1, Color.RED), <br/>    Card(3, Color.BLACK)<br/>)<br/>cards.sortWith(cardComparator) </strong><br/><em class="na">// cards becomes:<br/>// [Card(1, RED), Card(4, RED), Card(2, BLACK), Card(3, BLACK)]</em></span></pre><p id="b196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果比较比较复杂，您可能希望创建一个显式实现<em class="na"> </em> <code class="fe nc nd ne ms b">Comparator</code>接口的对象，并覆盖<code class="fe nc nd ne ms b">compare()</code> <em class="na"> </em>函数。如果参数相等，它应该返回零；如果第一个参数小于第二个参数，它应该返回负数；如果第一个参数大于第二个参数，它应该返回正数。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d53f" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">object CustomComparator: Comparator&lt;T&gt;{ <br/>        override fun compare(a: T, b: T): Int { <br/>            ...<br/>            return ...<br/>        }<br/>}</strong></span></pre><p id="4691" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个<code class="fe nc nd ne ms b">Comparator</code>对象在卡片比较中的样子:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2961" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">object cardComparator: Comparator&lt;Card&gt;{ <br/>        override fun compare(a: Card, b: Card): Int { <br/>            if (a.color == b.color) {<br/>                return a.number - b.number<br/>            } else if (a.color == Color.BLACK) {<br/>                </strong><em class="na">// Case where a is BLACK and b is RED</em><strong class="ms ir"><br/>                return 1<br/>            } else {<br/>               </strong><em class="na"> // Case where a is RED and b is BLACK   </em><strong class="ms ir">              <br/>                return -1<br/>            }<br/>        }<br/>}</strong></span></pre><h2 id="3f49" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">可比较的</h2><p id="4c19" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">对于自定义类，您也可以让您的类扩展<code class="fe nc nd ne ms b">Comparable</code>接口并覆盖<code class="fe nc nd ne ms b">compareTo()</code>来实现总排序，而不是创建一个单独的对象。您可以使用Kotlin的<code class="fe nc nd ne ms b"><a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/compare-values-by.html" rel="noopener ugc nofollow" target="_blank">compareValuesBy(</a>)</code>辅助函数，类似于<code class="fe nc nd ne ms b">compareBy()</code>，它使用您传入的函数序列来计算比较结果。因此，不需要使用<code class="fe nc nd ne ms b">sortWith()</code>并传入您的自定义比较器，您可以只使用<code class="fe nc nd ne ms b">sort()</code>，该函数将知道如何进行总排序。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="60e5" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">enum class Color { RED, BLACK }</strong></span><span id="f0fe" class="lp lq iq ms b gy nb mx l my mz"><strong class="ms ir">data class Card(val number: Int, val color: Color)<br/>        : Comparable&lt;Card&gt; {<br/>    override operator fun compareTo(other: Card): Int {<br/>        compareValuesBy(<br/>            this, <br/>            other, <br/>            </strong><em class="na">// Compare by color first<br/></em><strong class="ms ir">            { it.color }, <br/>            </strong><em class="na">// If the results of color comparison are equal, <br/>            // compare by number<br/></em><strong class="ms ir">            { it.number }<br/>        ) <br/>    }<br/>}<br/>val cards: MutableList&lt;Card&gt; = mutableListOf(<br/>    Card(4, Color.RED), <br/>    Card(2, Color.BLACK), <br/>    Card(1, Color.RED), <br/>    Card(3, Color.BLACK)<br/>)<br/>cards.sort() </strong><br/><em class="na">// cards becomes:<br/>// [Card(1, RED), Card(4, RED), Card(2, BLACK), Card(3, BLACK)]</em></span></pre><p id="a8ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果您能更清楚地理解，您可以选择在没有<code class="fe nc nd ne ms b">compareValuesBy()</code>助手的情况下实现<code class="fe nc nd ne ms b">compareTo()</code>:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="95c3" class="lp lq iq ms b gy mw mx l my mz"><strong class="ms ir">data class Card(val number: Int, val color: Color)<br/>        : Comparable&lt;Card&gt; {<br/>    override operator fun compareTo(other: Card): Int {<br/>        if (this.color == other.color) {<br/>            return this.number - other.number<br/>        } else if (this.color == Color.BLACK) {<br/>            return 1<br/>        } else {<br/>            return -1<br/>        }<br/>    }<br/>}</strong></span></pre><p id="2949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是第1部分！在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-2-collection-functions-a4a488fa0a14">第2部分</a>中，我回顾了有用的Kotlin集合函数。这里是<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-cheatsheet-88a9831e9d55">到备忘单</a>的链接，再次涵盖了所有5个部分。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="e9d5" class="nm lq iq bd lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz oa ob mg oc bi translated">点击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="38d7" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kc" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kc" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在Medium上关注我们。</p><p id="f69a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kc" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi od"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>