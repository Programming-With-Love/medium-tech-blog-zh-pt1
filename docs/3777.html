<html>
<head>
<title>Building an address parser with spaCy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用spaCy构建地址解析器</h1>
<blockquote>原文：<a href="https://medium.com/globant/building-an-address-parser-with-spacy-e3376b7cff?source=collection_archive---------0-----------------------#2021-11-08">https://medium.com/globant/building-an-address-parser-with-spacy-e3376b7cff?source=collection_archive---------0-----------------------#2021-11-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8a6a" class="pw-subtitle-paragraph if hg hh bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">应用命名实体识别来识别地址。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/27356adda5b44cbadec791dbea8f5385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_XppAazqcCEKncqe"/></div></div></figure><p id="ba18" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">组织的地址数据在收集客户分析或支持业务运营(如营销、物流、交付和业务通信)方面通常至关重要。经过净化、良好解析、标准化和验证的地址是数据整合和分析引擎的基础。</p><p id="f10b" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">大量的企业地址数据可以以手动键入数据库或平面文件的原始地址串的形式找到。但是它是可消耗的吗？以下是一个独特美国地址的不同写法:</p><blockquote class="kf kg kh"><p id="3625" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke ha bi translated"><code class="du km kn ko kp b"><strong class="jl hi">111 8th Ave Ste 1509 Tulsa OK 74136 US</strong></code></p><p id="ace2" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke ha bi translated"><code class="du km kn ko kp b"><strong class="jl hi">C/o John Doe LLC, 111, 8th Ave Ste 1509, Oklahoma, 74136-1922, USA</strong></code></p><p id="8a54" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke ha bi translated"><code class="du km kn ko kp b"><strong class="jl hi">111, 8th Ave Ste 1509, Tulsa, OK, , USA</strong></code></p></blockquote><p id="aaed" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">相当混乱。对吗？😳</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kq kr l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx">Because the code you wrote with Python regex just can’t handle human absurdities.</figcaption></figure><p id="7a36" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">因此，有必要通过解析、去杜平、标准化(映射到标准名称并填充缺失部分)、地理标记等对数据进行预处理。才能用于进一步的分析。<strong class="jl hi">地址解析</strong>是这几个预处理步骤之一，它有助于识别&amp;将地址字符串分割成不同的部分，如收件人、建筑物、街道、州、县、邮政编码以及该特定国家的其他适用部分。</p><p id="a85f" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">很明显，这类问题根本无法解决😉)通过编写传统的基于规则(通常是<a class="ae kw" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">正则</a>表达式驱动)的算法。我们需要更多的复杂性，这就是自然语言处理(NLP)算法的用武之地。</p><h1 id="2762" class="kx ky hh bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">spaCy是什么，我为什么要关心？</h1><p id="b11a" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated">对，就是<a class="ae kw" href="https://spacy.io/usage/spacy-101" rel="noopener ugc nofollow" target="_blank"> spaCy </a>(就是这么写的！).正如其<a class="ae kw" href="https://en.wikipedia.org/wiki/SpaCy" rel="noopener ugc nofollow" target="_blank">维基页面</a>上介绍的那样，</p><blockquote class="kf kg kh"><p id="831c" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke ha bi translated">spaCy是一个用于高级自然语言处理的开源软件库，用编程语言Python和Cython编写。</p></blockquote><p id="ad6d" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">NLP做了人类能做而传统算法做不到的事情:学习和提高。我们<em class="ki">建立</em>和<em class="ki">训练</em>我们的语言处理模型，以识别句子、段落甚至小说中隐含的上下文模式。从<a class="ae kw" href="https://towardsdatascience.com/python-libraries-for-natural-language-processing-be0e5a35dd64" rel="noopener" target="_blank">众多可用的机器学习库</a>、<a class="ae kw" href="https://spacy.io/usage/spacy-101" rel="noopener ugc nofollow" target="_blank"> spaCy </a>就是这样一个<strong class="jl hi">、</strong>、<strong class="jl hi">、</strong>用最少的努力和计算资源完成工作，否则会淹没模型构建和训练过程。</p><p id="ddea" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">spaCy的核心是使用深度学习库<a class="ae kw" href="https://thinc.ai/" rel="noopener ugc nofollow" target="_blank"> Thinc </a>，它针对CPU使用进行了优化(通常是一种采用限制)，并处理专门的NLP任务，如<a class="ae kw" href="https://spacy.io/usage/spacy-101#features" rel="noopener ugc nofollow" target="_blank">标记化、词汇化、词性(POS)标记、文本分类、命名实体识别以及许多其他任务</a>。在不深入这些技术的情况下，我们将讨论局限于与我们的地址解析用例相关的<strong class="jl hi">命名实体识别</strong>。</p><h1 id="3e70" class="kx ky hh bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">命名实体识别(NER)和空间</h1><p id="a8fc" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated">命名实体识别(NER)被<a class="ae kw" href="https://en.wikipedia.org/wiki/Named-entity_recognition" rel="noopener ugc nofollow" target="_blank">描述为</a></p><blockquote class="kf kg kh"><p id="48a2" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke ha bi translated">信息提取的一个子任务，旨在定位非结构化文本中提到的<a class="ae kw" href="https://en.wikipedia.org/wiki/Named_entity" rel="noopener ugc nofollow" target="_blank">命名实体</a>并将其分类为预定义的类别，如人名、组织、位置、医疗代码、时间表达式、数量、货币值、百分比等。</p></blockquote><p id="c5ad" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">简单地说，我们在浏览一段文字或句子时，试图寻找与特定领域类别相关的“现实世界的对象”，并在找到时突出显示它们。所有这些主要是通过对文本的直觉和上下文理解(在模型训练过程中获得)来完成的，而无需编写任何编程规则。下面是NER模式在一段文字上的应用可以揭示的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/35eaf5b9819d2a08352a75ed5699e37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JnZxW2byywAhptxr3MCjQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">NER output as generated by displaCy visualizer. Courtesy: <a class="ae kw" href="https://spacy.io/usage/linguistic-features#named-entities" rel="noopener ugc nofollow" target="_blank">spaCy NER usage guide</a></figcaption></figure><p id="a9ed" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们得到了不同实体的简洁表示，如组织、地理位置、日期、人名等。已确认。很厉害吧？</p><p id="b907" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">spaCy提供了开箱即用的<a class="ae kw" href="https://spacy.io/usage/linguistic-features#named-entities" rel="noopener ugc nofollow" target="_blank"> NER特性</a>作为其预训练管道的一部分，这样您就不必从头开始经历构建模型的步骤(尽管<a class="ae kw" href="https://spacy.io/usage/layers-architectures" rel="noopener ugc nofollow" target="_blank">定制模型设计</a>始终是一个选项):确定神经网络架构、添加层、初始化/调整权重等。</p><p id="7d98" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在spaCy中创建统计NER模型的构建和训练过程非常简单，并遵循配置驱动的方法:我们从预训练或空语言模型开始，添加实体识别器，可选地定义自定义实体，在我们的训练集上开始迭代训练循环，通过对训练集和配置进行少量调整，我们获得了最佳模型。让我们在接下来的小节中回顾这些步骤，并构建我们的<strong class="jl hi">地址解析器</strong>。</p><h1 id="ea4c" class="kx ky hh bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">NER在地址解析中的应用</h1><p id="c3f3" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated">您现在可能已经知道，我们将地址字符串分割成不同部分的任务属于命名实体识别的范畴。我们希望看到我们的NER模型能够以合理的准确度解析任何地址字符串，比如:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/e4af9b1ef597457ce7082a26ecfc8102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLZTrqZ_n0ZV63kvKvFy6A.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Tagged entities in an address string</figcaption></figure><p id="5740" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">那么，我们开始吧。我们将遵循训练过程，详细的<a class="ae kw" href="https://spacy.io/usage/training" rel="noopener ugc nofollow" target="_blank">在这里</a>，来创建我们的解析美国地址的模型。</p><p id="9a4d" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi"> spaCy安装:</strong> spaCy包可以使用pip进行<a class="ae kw" href="https://spacy.io/usage" rel="noopener ugc nofollow" target="_blank">安装</a>，如下所示:</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="5990" class="ma ky hh kp b fi mb mc l md me">pip install -U spacy</span><span id="cb02" class="ma ky hh kp b fi mf mc l md me">&gt;&gt;&gt; import spacy<br/>&gt;&gt;&gt; spacy.__version__<br/>'3.1.2'</span></pre><p id="ed71" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">自定义实体标签</strong>:针对美国地址，我们为我们的模型确定了以下自定义实体标签:</p><p id="ce20" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><code class="du km kn ko kp b">[‘STREET’, ‘RECIPIENT’, ‘BUILDING_NUMBER’, ‘BUILDING_NAME’, ‘ZIP_CODE’, ‘CITY’, ’STATE’, ‘COUNTRY’]</code></p><p id="a6d8" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">训练数据集准备:</strong>我们以原始CSV格式准备我们的<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/corpus/dataset/us-train-dataset.csv" rel="noopener ugc nofollow" target="_blank">训练数据集</a>，将其限制为我们的源系统中地址数据的良好代表性样本。通常建议将数据(对于我们的案例研究，我们选择了大约100+20个数据训练和验证数据点)随机80:20分割成训练和验证数据集。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/5594938cd9eb06c5a011e2a9cb60dbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdJyMJv3ZalOKDri-oySRA.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Sample training dataset for US addresses</figcaption></figure><p id="8191" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">然而，这个原始数据集需要在用于训练之前转换成spaCy的<a class="ae kw" href="https://spacy.io/api/docbin" rel="noopener ugc nofollow" target="_blank"> DocBin </a>格式。这里有一个在我们的<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/training_data_prep.py" rel="noopener ugc nofollow" target="_blank">代码</a>中如何做到这一点的快速演练。</p><p id="44f0" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">I)我们从预处理地址字符串开始，去掉多余的空格和换行符。根据源数据，可能需要添加一些额外的数据处理步骤。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="0bfd" class="ma ky hh kp b fi mb mc l md me">def massage_data(address):                           <br/>'''Pre process address string to remove new line characters, add comma punctuations etc.'''                           </span><span id="ee97" class="ma ky hh kp b fi mf mc l md me">cleansed_address1=re.sub(r'(,)(?!\s)',', ',address)                           cleansed_address2=re.sub(r'(\\n)',', ',cleansed_address1)                           cleansed_address3=re.sub(r'(?!\s)(-)(?!\s)',' - ',cleansed_address2)                           cleansed_address=re.sub(r'\.','',cleansed_address3)                           return cleansed_address</span></pre><p id="407e" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">ii)接下来，我们从我们的训练/验证数据集中导出每个地址串的实体跨度(实体的开始和结束位置)。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="3952" class="ma ky hh kp b fi mb mc l md me">get_address_span(address=None,address_component=None,label=None):</span><span id="dd24" class="ma ky hh kp b fi mf mc l md me">'''Search for specified address component and get the span. Eg: get_address_span(address="221 B, Baker Street, London",address_component="221",label="BUILDING_NO") would return (0,2,"BUILDING_NO")'''</span><span id="b27c" class="ma ky hh kp b fi mf mc l md me"> if pd.isna(address_component) or str(address_component)=='nan':<br/>   pass                           <br/> else:                               <br/>   address_component1=re.sub('\.','',address_component)                               <br/>   address_component2=re.sub(r'(?!\s)(-)(?!\s)',' - ',address_component1)                               <br/>   span=re.search('\\b(?:'+address_component2+')\\b',address)                                                              <br/>   return (span.start(),span.end(),label)</span></pre><p id="a5d5" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">下面是一些数据点的情况:</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="438a" class="ma ky hh kp b fi mb mc l md me">(<em class="ki">19 ST ANDREW ST, BULRINGTON, VT, 05401, , United States</em>, [(0, 2, BUILDING_NO), (3, 15, STREET_NAME), (33, 38, ZIP_CODE), (17, 27, CITY), (29, 31, STATE), (42, 55, COUNTRY)]) <br/>                                       <br/>(<em class="ki">2574 EAST 23RD STREE, CHATTANOOGA, TN 37404, United States</em>, [(0, 4, BUILDING_NO), (5, 20, STREET_NAME), (38, 43, ZIP_CODE), (22, 33, CITY), (35, 37, STATE), (45, 58, COUNTRY)])<br/>                                <br/>(<em class="ki">5931 W ANGELA RD, MEMPHIS, TN 38120, United States</em>, [(0, 4, BUILDING_NO), (5, 16, STREET_NAME), (30, 35, ZIP_CODE), (18, 25, CITY), (27, 29, STATE), (37, 50, COUNTRY)])<br/>                                            <br/>(<em class="ki">3812 MYERS STREET, GREENEVILLE, TN 37743, United States</em>, [(0, 4, BUILDING_NO), (5, 17, STREET_NAME), (35, 40, ZIP_CODE), (19, 30, CITY), (32, 34, STATE), (42, 55, COUNTRY)])</span></pre><p id="c65b" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">iii)最后，我们用这个数据初始化一个<a class="ae kw" href="https://spacy.io/api/docbin" rel="noopener ugc nofollow" target="_blank"> DocBin </a>对象。这将以<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/tree/main/corpus/spacy-docbins" rel="noopener ugc nofollow" target="_blank">的形式持久化。spacy corpus </a>文件——训练和验证数据集各一个。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="fc2a" class="ma ky hh kp b fi mb mc l md me">def get_doc_bin(training_data,nlp):</span><span id="44d1" class="ma ky hh kp b fi mf mc l md me">'''Create DocBin object for building training/test corpus'''<br/># the DocBin will store the example documents<br/> <br/>  db = DocBin()<br/>  for text, annotations in training_data:<br/>    doc = nlp(text) #Construct a Doc object<br/>    ents = []<br/>    for start, end, label in annotations:<br/>        span = doc.char_span(start, end, label=label)<br/>        ents.append(span)<br/>    doc.ents = ents<br/>    db.add(doc)<br/>  return db<br/>.<br/>.<br/>.</span><span id="8206" class="ma ky hh kp b fi mf mc l md me">###### Training dataset prep ###########                       # Read the training dataset into pandas                       df_train=pd.read_csv(filepath_or_buffer="./corpus/dataset/us-train-dataset.csv",sep=",",dtype=str)                                               # Get entity spans                       <br/>df_entity_spans= create_entity_spans(df_train.astype(str),tag_list)                       training_data= df_entity_spans.values.tolist()<br/>.<br/>.</span><span id="d80a" class="ma ky hh kp b fi mf mc l md me">.<br/># Get &amp; Persist DocBin to disk                       <br/>doc_bin_train= get_doc_bin(training_data,nlp)                       doc_bin_train.to_disk("./corpus/spacy-docbins/train.spacy")                       ######################################</span></pre><p id="ace3" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">训练配置:</strong>在开始训练过程之前，我们需要准备一个包含所有基本参数的训练配置。让我们创建一个最小的训练框架配置文件<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/config/base_config.cfg" rel="noopener ugc nofollow" target="_blank">如下。</a></p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="104d" class="ma ky hh kp b fi mb mc l md me">[components]<br/>[components.ner]<br/>factory="ner"</span><span id="8366" class="ma ky hh kp b fi mf mc l md me">[nlp]<br/>lang = "en"<br/>pipeline = ["ner"]</span><span id="cb1a" class="ma ky hh kp b fi mf mc l md me">[training]<br/>[training.batch_size]<br/><a class="ae kw" href="http://twitter.com/schedules" rel="noopener ugc nofollow" target="_blank">@schedules</a> = "compounding.v1"<br/>start = 4<br/>stop = 32<br/>compound = 1.001</span></pre><p id="bc51" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">通过上述配置，我们使用空白英语语言模型定义了一个培训管道。我们的管道包含一个单一的模块，即NER将被培训。我们还初始化训练批量大小和其他相关参数。点击阅读更多关于培训配置设置<a class="ae kw" href="https://spacy.io/usage/training#config" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="80c6" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">接下来，我们运行下面的控制台命令来创建一个最终的详细配置文件。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="5b2d" class="ma ky hh kp b fi mb mc l md me"><strong class="kp hi">python -m spacy init fill-config config\base_config.cfg config\config.cfg</strong></span></pre><p id="cfc6" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们快速浏览一下<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/config/config.cfg" rel="noopener ugc nofollow" target="_blank">生成的config </a>文件，其中有我们模型和培训过程的完整蓝图。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="0457" class="ma ky hh kp b fi mb mc l md me">.<br/>.<br/>.<br/>.</span><span id="e914" class="ma ky hh kp b fi mf mc l md me">[components]</span><span id="2f55" class="ma ky hh kp b fi mf mc l md me">[components.ner]<br/>factory = "ner"<br/>incorrect_spans_key = null<br/>moves = null<br/>update_with_oracle_cut_size = 100</span><span id="0259" class="ma ky hh kp b fi mf mc l md me">[components.ner.model]<br/><a class="ae kw" href="http://twitter.com/architectures" rel="noopener ugc nofollow" target="_blank"><strong class="kp hi">@architectures</strong></a><strong class="kp hi"> = "spacy.TransitionBasedParser.v2"</strong><br/>state_type = "ner"<br/>extra_state_tokens = false<br/>hidden_width = 64<br/>maxout_pieces = 2<br/>use_upper = true<br/>nO = null</span><span id="a6f6" class="ma ky hh kp b fi mf mc l md me">[components.ner.model.tok2vec]<br/><a class="ae kw" href="http://twitter.com/architectures" rel="noopener ugc nofollow" target="_blank"><strong class="kp hi">@architectures</strong></a><strong class="kp hi"> = "spacy.HashEmbedCNN.v2"</strong><br/>pretrained_vectors = null<br/>width = 96<br/>depth = 4<br/>embed_size = 2000<br/>window_size = 1<br/>maxout_pieces = 3<br/>subword_features = true</span><span id="4d88" class="ma ky hh kp b fi mf mc l md me">.<br/>.<br/>.<br/>.</span><span id="2b73" class="ma ky hh kp b fi mf mc l md me">[training.optimizer]<br/><a class="ae kw" href="http://twitter.com/optimizers" rel="noopener ugc nofollow" target="_blank"><strong class="kp hi">@optimizers</strong></a><strong class="kp hi"> = "Adam.v1"</strong><br/>beta1 = 0.9<br/>beta2 = 0.999<br/>L2_is_weight_decay = true<br/>L2 = 0.01<br/>grad_clip = 1.0<br/>use_averages = false<br/>eps = 0.00000001<br/><strong class="kp hi">learn_rate = 0.001</strong></span><span id="d7c2" class="ma ky hh kp b fi mf mc l md me">[training.score_weights]<br/>ents_f = 1.0<br/>ents_p = 0.0<br/>ents_r = 0.0<br/>ents_per_type = null</span><span id="835b" class="ma ky hh kp b fi mf mc l md me">.<br/>.<br/>.<br/>.<br/>.</span></pre><p id="7339" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们可以找到以spaCy强大的预训练模型形式定义的<a class="ae kw" href="https://spacy.io/api/architectures#TransitionBasedParser" rel="noopener ugc nofollow" target="_blank">解析器</a>和<a class="ae kw" href="https://spacy.io/api/architectures#HashEmbedCNN" rel="noopener ugc nofollow" target="_blank">标记器</a>架构。至于训练参数，我们注意到优化器配置，即<a class="ae kw" href="https://towardsdatascience.com/adam-latest-trends-in-deep-learning-optimization-6be9a291375c" rel="noopener" target="_blank"> Adam optimizer </a>，学习率，评估频率，以及覆盖的纪元数量。正如我们将在下一节中看到的，其中一些配置可以在训练运行期间被覆盖。</p><p id="7485" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">训练过程:</strong>好了，代码和设置的东西已经够多了！让我们开始我们的培训。我们拥有最少的资源(没有GPU，但有一个适中的四核英特尔i7 CPU&amp;16gb内存！)，我们发出<a class="ae kw" href="https://spacy.io/api/cli#train" rel="noopener ugc nofollow" target="_blank"> train </a>命令，这将触发训练过程，在大约一分钟内生成我们的模型！</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="ddb4" class="ma ky hh kp b fi mb mc l md me"><strong class="kp hi">python -m spacy train config\config.cfg --paths.train corpus\spacy-docbins\train.spacy --paths.dev corpus\spacy-docbins\test.spacy --output output\models --training.eval_frequency 10 --training.max_steps 300</strong></span><span id="7e5d" class="ma ky hh kp b fi mf mc l md me">ℹ Saving to output directory: output\models<br/>ℹ Using CPU</span><span id="0919" class="ma ky hh kp b fi mf mc l md me">=========================== Initializing pipeline ===========================<br/>[2021-09-11 18:30:04,925] [INFO] Set up nlp object from config<br/>[2021-09-11 18:30:04,925] [INFO] Pipeline: ['ner']<br/>[2021-09-11 18:30:04,941] [INFO] Created vocabulary<br/>[2021-09-11 18:30:04,941] [INFO] Finished initializing nlp object<br/>[2021-09-11 18:30:05,141] [INFO] Initialized pipeline components: ['ner']<br/>✔ Initialized pipeline</span><span id="348f" class="ma ky hh kp b fi mf mc l md me">============================= Training pipeline =============================<br/>ℹ Pipeline: [ 'ner']<br/>ℹ Initial learn rate: 0.001<br/>E    #       LOSS NER  ENTS_F  ENTS_P  ENTS_R  SCORE<br/>---  ------  --------  ------  ------  ------  ------<br/>  0       0     62.71    6.18    4.13   12.21    0.06<br/>  0      10    808.79    0.00    0.00    0.00    0.00<br/>  0      20    468.03   23.00   33.33   17.56    0.23<br/>  1      30    286.96   44.55   58.75   35.88    0.45<br/>  1      40    348.01   75.10   75.38   74.81    0.75<br/>  2      50    254.44   76.56   78.40   74.81    0.77<br/>  2      60    244.69   82.11   87.83   77.10    0.82<br/>  3      70    115.05   91.12   92.19   90.08    0.91<br/>  3      80     61.84   94.57   96.06   93.13    0.95<br/>  4      90     99.36   98.47   98.47   98.47    0.98<br/>  4     100     29.16   98.47   98.47   98.47    0.98<br/>  5     110     34.48   98.08   98.46   97.71    0.98<br/>  5     120     27.44   98.08   98.46   97.71    0.98<br/>  6     130     16.41   98.08   98.46   97.71    0.98<br/>  6     140     15.01   98.85   99.23   98.47    0.99<br/>  7     150      5.20  100.00  100.00  100.00    1.00<br/>  7     160      9.05  100.00  100.00  100.00    1.00<br/>  8     170      2.39  100.00  100.00  100.00    1.00<br/>  9     180      0.77  100.00  100.00  100.00    1.00<br/>  9     190      3.11  100.00  100.00  100.00    1.00<br/> 10     200      3.14  100.00  100.00  100.00    1.00<br/> 10     210      1.31  100.00  100.00  100.00    1.00<br/> 11     220      3.40  100.00  100.00  100.00    1.00<br/> 11     230      0.05  100.00  100.00  100.00    1.00<br/> 12     240      1.55  100.00  100.00  100.00    1.00<br/> 13     250      1.40  100.00  100.00  100.00    1.00<br/> 13     260      0.02  100.00  100.00  100.00    1.00<br/> 14     270      0.55  100.00  100.00  100.00    1.00<br/> 14     280      0.82  100.00  100.00  100.00    1.00<br/> 15     290      3.63  100.00  100.00  100.00    1.00<br/> 16     300      0.00  100.00  100.00  100.00    1.00<br/>✔ Saved pipeline to output directory<br/>output\models\model-last</span></pre><p id="8a24" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们浏览一下上面的控制台输出。train命令启动spaCy的训练循环，该循环生成管道，初始化模型权重，并反复执行调整权重、检查损失和根据验证数据集评估模型准确性的循环。请注意性能指标:<a class="ae kw" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精度、召回率和f值</a>如何随着每个循环向完美的100分移动。然而，对于更大和更多样化的训练/验证集，这些指标通常会向满分靠拢，但不一定会达到满分。</p><p id="ce0a" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在达到大约300步的配置阈值之后，训练过程停止，并且两个模型图像被保存到磁盘:<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/tree/main/output/models/model-best" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hi">【最佳】</strong> </a> <strong class="jl hi"> </strong>(具有针对验证的最大分数)和<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/tree/main/output/models/model-last" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hi">【最后</strong> </a> <strong class="jl hi"> </strong>(在最后一个历元周期中获得)。</p><p id="d24b" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">预测:</strong>真相大白的时刻到了！让我们看看我们的模型如何在几个<em class="ki">看不见的</em> <strong class="jl hi"> </strong>地址串上执行。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="383c" class="ma ky hh kp b fi mb mc l md me">import spacy<br/><br/>nlp=spacy.load("output\models\model-best")<br/><br/>address_list=["130 W BOSE ST STE 100, PARK RIDGE, IL, 60068, USA",<br/>              "8311 MCDONALD RD, HOUSTON, TX, 77053-4821, USA",<br/>              "PO Box 317, 4100 Hwy 20 E Ste 403, NICEVILLE, FL, 32578-5037, USA",<br/>              "C/O Elon Musk Innovations Inc, 1548 E Florida Avenue, Suite 209, TAMPA, FL, 33613, USA",<br/>              "Seven Edgeway Plaza, C/O Mac Dermott Inc, OAKBROOK TERRACE, IL, 60181, USA"]<br/><br/>for address in address_list:<br/>    doc=nlp(address)<br/>    ent_list=[(ent.text, ent.label_) for ent in doc.ents]<br/>    print("Address string -&gt; "+address)<br/>    print("Parsed address -&gt; "+str(ent_list))<br/>    print("******")</span><span id="e094" class="ma ky hh kp b fi mf mc l md me">###Prediction output###</span><span id="ac2e" class="ma ky hh kp b fi mf mc l md me"><strong class="kp hi">Address string -&gt; 130 W BOSE ST STE 100, PARK RIDGE, IL, 60068, USA<br/>Parsed address -&gt; [('130', 'BUILDING_NO'), ('W BOSE ST', 'STREET_NAME'), ('PARK RIDGE', 'CITY'), ('IL', 'STATE'), ('60068', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong><br/>******<br/><strong class="kp hi">Address string -&gt; 8311 MCDONALD RD, HOUSTON, TX, 77053-4821, USA<br/>Parsed address -&gt; [('8311', 'BUILDING_NO'), ('MCDONALD RD', 'STREET_NAME'), ('HOUSTON', 'CITY'), ('TX', 'STATE'), ('77053-4821', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong><br/>******<br/><strong class="kp hi">Address string -&gt; PO Box 317, 4100 Hwy 20 E Ste 403, NICEVILLE, FL, 32578-5037, USA, US<br/>Parsed address -&gt; [('4100', 'BUILDING_NO'), ('Hwy 20 E', 'STREET_NAME'), ('NICEVILLE', 'CITY'), ('FL', 'STATE'), ('32578-5037', 'ZIP_CODE'), ('US', 'COUNTRY')]</strong><br/>******<br/><strong class="kp hi">Address string -&gt; C/O Elon Musk Innovations Inc, 1548 E Florida Avenue, Suite 209, TAMPA, FL, 33613, USA<br/>Parsed address -&gt; [('C/O Elon Musk Innovations Inc', 'RECIPIENT'), ('1548', 'BUILDING_NO'), ('E Florida Avenue', 'STREET_NAME'), ('TAMPA', 'CITY'), ('FL', 'STATE'), ('33613', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong><br/>******<br/><strong class="kp hi">Address string -&gt; Seven Edgeway Plaza, C/O Mac Dermott Inc, OAKBROOK TERRACE, IL, 60181, USA<br/>Parsed address -&gt; [('Seven Edgeway Plaza', 'STREET_NAME'), ('C/O Mac Dermott Inc', 'RECIPIENT'), ('OAKBROOK TERRACE', 'CITY'), ('IL', 'STATE'), ('60181', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong><br/>******</span></pre><p id="aca9" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">一点都不差！😀除了一些地址模式之外，我们的模型相当好地识别了地址串中的大多数实体。随着我们添加更多的训练示例来更新我们的模型，并开始提取其他地址实体(比如公寓号、邮政信箱等)。)，我们会观察到更好的预测结果。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><h1 id="5779" class="kx ky hh bd kz la mo lc ld le mp lg lh io mq ip lj ir mr is ll iu ms iv ln lo bi translated"><strong class="ak">额外的好处:将NER与模式匹配结合起来</strong></h1><p id="1aa2" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated">虽然一个训练有素的模型肯定会提高我们的地址数据解析能力，但我们仍然会在这里或那里看到一些异想天开的预测。虽然可能并不总是有一个简单的方法来解决这些问题，但是spaCy确实提供了通过一套基于<a class="ae kw" href="https://spacy.io/usage/rule-based-matching" rel="noopener ugc nofollow" target="_blank">模式的规则</a>来加强模型，通过其<a class="ae kw" href="https://spacy.io/api/entityruler" rel="noopener ugc nofollow" target="_blank">实体统治者</a>来覆盖。</p><p id="7e33" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们为我们的解析器运行另一个地址字符串。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="60c4" class="ma ky hh kp b fi mb mc l md me">address="C/o John Doe LLC, 111 8th Avenue Ste 1301, Tulsa, Oklahoma, 74136–1922, USA"<br/>doc=nlp(address)<br/>ent_list=[(ent.text, ent.label_) for ent in doc.ents]<br/>print("Address string -&gt; "+address)<br/>print("Parsed address -&gt; "+str(ent_list))<br/>#######################</span><span id="1770" class="ma ky hh kp b fi mf mc l md me"><strong class="kp hi">Address string -&gt; C/o John Doe LLC, 111 8th Avenue Ste 1301, Tulsa, Oklahoma, 74136–1922, USA<br/>Parsed address -&gt; [('C/o John Doe LLC', 'RECIPIENT'), ('111', 'BUILDING_NO'), ('8th Avenue', 'STREET_NAME'), ('Tulsa', 'CITY'), <em class="ki">('Oklahoma', 'CITY')</em>, ('74136–1922', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong></span></pre><p id="9d29" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">相当不稳定的是，我们看到俄克拉何马州被确定为一个城市，而不是一个州！我们推断这是使用训练地址数据的结果，训练地址数据只有两个字母的州代码，而没有扩展的州名。解决这个问题的一个方法是在训练数据中添加更多这样的模式。</p><p id="513f" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">或者，我们可以创建基于模式的正则表达式规则来处理这些问题。让我们用美国所有州的列表创建一个<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/corpus/rules/entity_ruler_patterns.jsonl" rel="noopener ugc nofollow" target="_blank">模式文件</a>。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="0676" class="ma ky hh kp b fi mb mc l md me">{"label":"STATE","pattern":[{"LOWER":"alabama"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"alaska"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"arizona"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"arkansas"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"california"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"colorado"}]}<br/>{"label":"STATE","pattern":[{"LOWER":"connecticut"}]}<br/>.<br/>.<br/>.</span></pre><p id="b39d" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了在我们的模型中使用这些模式规则，我们将修改我们的<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/config/base_config_er.cfg" rel="noopener ugc nofollow" target="_blank">训练配置</a>来添加<strong class="jl hi">实体标尺</strong>作为一个附加模块以及模式文件读取器设置。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="2331" class="ma ky hh kp b fi mb mc l md me">.<br/>.<br/>[components.ner]<br/>factory="ner"</span><span id="ba3e" class="ma ky hh kp b fi mf mc l md me"><strong class="kp hi">[components.entity_ruler]<br/>factory="entity_ruler"</strong></span><span id="cb31" class="ma ky hh kp b fi mf mc l md me"><strong class="kp hi">[initialize]<br/>[initialize.components]<br/>[initialize.components.entity_ruler]<br/>[initialize.components.entity_ruler.patterns]<br/></strong><a class="ae kw" href="http://twitter.com/readers" rel="noopener ugc nofollow" target="_blank"><strong class="kp hi">@readers</strong></a><strong class="kp hi"> = "srsly.read_jsonl.v1"<br/>path = "corpus\rules\entity_ruler_patterns.jsonl</strong></span><span id="73bd" class="ma ky hh kp b fi mf mc l md me">[nlp]<br/>lang = "en"<br/>pipeline = ["ner",<strong class="kp hi">"entity_ruler"</strong>]<br/>.<br/>.</span></pre><p id="d83d" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们遵循相同的过程，再次生成完整的<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/blob/main/config/config_er.cfg" rel="noopener ugc nofollow" target="_blank">配置文件</a>，并通过它进行训练以生成规则增强预测<a class="ae kw" href="https://github.com/swapnil-saxena/address-parser/tree/main/output/models_er" rel="noopener ugc nofollow" target="_blank">模型</a>。</p><p id="99e8" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们看看结果。</p><pre class="iy iz ja jb fd lw kp lx ly aw lz bi"><span id="aa71" class="ma ky hh kp b fi mb mc l md me">nlp=spacy.load("output\models_er\model-best")<br/><br/>doc=nlp(address)<br/>ent_list=[(ent.text, ent.label_) for ent in doc.ents]<br/>print("Address string -&gt; "+address)<br/>print("Parsed address -&gt; "+str(ent_list))</span><span id="78a1" class="ma ky hh kp b fi mf mc l md me">###################<br/><strong class="kp hi">Address string -&gt; C/o John Doe LLC, 111 8th Avenue Ste 1301, Tulsa, Oklahoma, 74136–1922, USA<br/>Parsed address -&gt; [('C/o John Doe LLC', 'RECIPIENT'), ('111', 'BUILDING_NO'), ('8th Avenue', 'STREET_NAME'), ('Tulsa', 'CITY'), <em class="ki">('Oklahoma', 'STATE')</em>, ('74136–1922', 'ZIP_CODE'), ('USA', 'COUNTRY')]</strong></span></pre><p id="3b28" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">完美！</strong>通过仔细添加更多这样的规则(县、国家命名模式)，我们可以进一步提高模型的准确性。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><h1 id="b185" class="kx ky hh bd kz la mo lc ld le mp lg lh io mq ip lj ir mr is ll iu ms iv ln lo bi translated"><strong class="ak">最终想法</strong></h1><p id="d7ca" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated">使用spaCy强大的NLP-NER功能，加上其独特的规则引擎产品，我们已经展示了几乎零代码和很大程度上配置驱动的训练过程是多么容易！)和经济上(无GPU需求)，可以构建一个最小的地址解析实现。</p><p id="ee62" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">虽然这种实现本身不足以处理各种各样的地址数据语义，但是与通过纯基于规则的解析方法工作相比，良好的数据预处理策略与更大的、不同的训练集相结合有望产生更好的结果。</p><p id="3d06" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在本案例研究中，我们将范围仅限于美国地址。然而，地址解析问题的另一个有趣的扩展是从不同地理位置的混合数据集中解析地址的国家(在运行特定于国家的解析器之前)。也许，一个合适的用例可以用spaCy的tokenizer和<a class="ae kw" href="https://scikit-learn.org/stable/modules/multiclass.html" rel="noopener ugc nofollow" target="_blank"> sklearn的multiclass </a>算法来探索。但是，让我们把它留到另一篇博文中去吧！</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><h1 id="eba1" class="kx ky hh bd kz la mo lc ld le mp lg lh io mq ip lj ir mr is ll iu ms iv ln lo bi translated">资源</h1><p id="72b5" class="pw-post-body-paragraph jj jk hh jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke ha bi translated"><a class="ae kw" href="https://spacy.io/usage/spacy-101" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hi">空间101:你需要知道的一切</strong> </a></p><p id="a69c" class="pw-post-body-paragraph jj jk hh jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kw" href="https://github.com/swapnil-saxena/address-parser" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hi"> GitHub案例库</strong> </a></p></div></div>    
</body>
</html>