<html>
<head>
<title>Using vector assets in Android apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android应用中使用矢量资源</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9?source=collection_archive---------2-----------------------#2018-12-11">https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9?source=collection_archive---------2-----------------------#2018-12-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e6dbe285a1bdcfb9d85208c8c046e2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqnL46dzsUEDsmfABwTapg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="5fc7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在之前的帖子中，我们已经了解了Android的<code class="du js jt ju jv b">VectorDrawable</code>图像格式及其功能:</p><div class="hg hh ez fb hi jw"><a rel="noopener follow" target="_blank" href="/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hy fi z dy kb ea eb kc ed ef hw bi translated">理解Android的矢量图像格式:VectorDrawable</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">Android设备有各种尺寸、形状和屏幕密度。这就是为什么我非常喜欢使用分辨率…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk ho jw"/></div></div></a></div><div class="hg hh ez fb hi jw"><a rel="noopener follow" target="_blank" href="/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hy fi z dy kb ea eb kc ed ef hw bi translated">绘制路径:渲染Android VectorDrawables</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">在上一篇文章中，我们研究了Android的VectorDrawable格式，探讨了它的优点和功能。</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kl l kh ki kj kf kk ho jw"/></div></div></a></div><p id="7901" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我们将深入探讨如何在你的应用中使用它们。<code class="du js jt ju jv b">VectorDrawable</code>是在Lollipop (API 21)中引入的，也可以在AndroidX(如<code class="du js jt ju jv b">VectorDrawableCompat</code>)中获得，支持一直追溯到API 14(超过<a class="ae hu" href="https://developer.android.com/about/dashboards/" rel="noopener ugc nofollow" target="_blank"> 99%的设备</a>)。这篇文章将概述在你的应用中实际使用<code class="du js jt ju jv b">VectorDrawable</code>的建议。</p><h1 id="7e80" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">AndroidX优先</h1><p id="0751" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">从Lollipop开始，你可以在任何使用其他drawable类型的地方使用<code class="du js jt ju jv b">VectorDrawable</code>(使用标准的<code class="du js jt ju jv b">@drawable/foo</code>语法来引用它们),但是我会<em class="lp">而不是</em>建议<strong class="iw hy">总是</strong>使用AndroidX实现。这显然增加了您可以使用它们的平台范围，但不仅如此，它还支持将功能和错误修复移植到旧平台。例如，使用AndroidX的<code class="du js jt ju jv b">VectorDrawableCompat</code>可以:</p><ul class=""><li id="fa70" class="lq lr hx iw b ix iy jb jc jf ls jj lt jn lu jr lv lw lx ly bi translated"><code class="du js jt ju jv b">nonZero</code>和<code class="du js jt ju jv b">evenOdd</code>路径<code class="du js jt ju jv b">fillTypes</code>—<a class="ae hu" href="https://www.sitepoint.com/understanding-svg-fill-rule-property/" rel="noopener ugc nofollow" target="_blank">定义形状</a>的内部的<em class="lp">的两种常见方式，常用于SVG中(<code class="du js jt ju jv b">evenOdd</code>在API 24中添加到平台实现)</em></li><li id="5726" class="lq lr hx iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated">渐变&amp; <code class="du js jt ju jv b">ColorStateList</code>填充/描边(在API 24中添加到平台实现)</li><li id="9fa5" class="lq lr hx iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated">错误修复</li></ul><p id="f140" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，AndroidX将使用compat实现，甚至在一些存在本机实现的平台上(<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/src/main/java/androidx/appcompat/widget/AppCompatDrawableManager.java#100" rel="noopener ugc nofollow" target="_blank">目前为API 21–23</a>)来提供上述好处。否则，它将委托给平台实现，因此仍然可以获得新版本的任何改进(例如，为了提高性能，在API 24中用C重新实现了<code class="du js jt ju jv b">VectorDrawable</code>)。</p><p id="434d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于这些原因，你应该<strong class="iw hy">总是</strong>使用AndroidX，即使你足够幸运有一个<code class="du js jt ju jv b">minSdkVersion</code>24。如果/当 <code class="du js jt ju jv b">VectorDrawable</code>在未来被扩展了新的功能<em class="lp">和</em>它们也被添加到AndroidX，那么它们将直接可用，而无需重新访问您的代码。</p><p id="c618" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="me mf ge" href="https://medium.com/u/f61fb1c467cd?source=post_page-----4318fd662eb9--------------------------------" rel="noopener" target="_blank">亚历克斯·洛克伍德</a> <em class="lp">如愿以偿</em>:</p><figure class="mg mh mi mj fd hj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">(VDC == <code class="du js jt ju jv b">VectorDrawableCompat</code>)</figcaption></figure><h1 id="ae93" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">怎么会？</h1><p id="6815" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">要使用AndroidX矢量支持，您需要做<em class="lp"> 2件事</em>:</p><h2 id="454e" class="mm kn hx bd ko mn mo mp ks mq mr ms kw jf mt mu la jj mv mw le jn mx my li mz bi translated">1.启用支持</h2><p id="7413" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">你需要在你的应用程序的<code class="du js jt ju jv b">build.gradle</code>中选择AndroidX矢量支持:</p><pre class="mg mh mi mj fd na jv nb nc aw nd bi"><span id="b0c5" class="mm kn hx jv b fi ne nf l ng nh">android {<br/>    defaultConfig {<br/>        vectorDrawables.useSupportLibrary = true<br/>    }<br/>}</span></pre><p id="c5c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你的<code class="du js jt ju jv b">minSdkVersion</code>是&lt; 21，这个标志防止Android Gradle插件<a class="ae hu" href="https://developer.android.com/studio/write/vector-asset-studio#apilevel" rel="noopener ugc nofollow" target="_blank">生成你的矢量资产的PNG版本</a>——我们不需要这个，因为我们将使用AndroidX库。</p><p id="cdfc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它还被传递给构建工具链。默认情况下<a class="ae hu" href="https://developer.android.com/studio/command-line/aapt2" rel="noopener ugc nofollow" target="_blank"> AAPT </a>(安卓资产打包工具)<em class="lp">版本</em>资源。这意味着如果你在<code class="du js jt ju jv b">res/drawable/</code>中声明一个<code class="du js jt ju jv b">VectorDrawable</code>，它会把它移到<code class="du js jt ju jv b">res/drawable-v21/</code>，因为它知道这是<code class="du js jt ju jv b">VectorDrawable</code>类被引入的时间。</p><blockquote class="ni nj nk"><p id="5968" class="iu iv lp iw b ix iy iz ja jb jc jd je nl jg jh ji nm jk jl jm nn jo jp jq jr ha bi translated">这可以防止属性ID冲突——您在<code class="du js jt ju jv b">VectorDrawable</code>中使用的属性(<code class="du js jt ju jv b">android:pathData</code>、<code class="du js jt ju jv b">android:fillColor</code>等)都有一个与之相关联的整数ID，这是在API 21中添加的。在旧版本的Android上，没有任何东西阻止OEM使用任何“无人认领”的id，这使得在旧平台上使用新属性变得不安全。</p></blockquote><p id="7e39" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种版本控制会阻止在较旧的平台上访问资源，使反向移植成为不可能gradle标志禁用了矢量绘图的这种版本控制。这就是为什么你在向量中使用<code class="du js jt ju jv b"><strong class="iw hy">android</strong>:pathData</code>等，而不是像其他后端口功能一样切换到<code class="du js jt ju jv b"><strong class="iw hy">app</strong>:pathData</code>等。</p><h2 id="1e2d" class="mm kn hx bd ko mn mo mp ks mq mr ms kw jf mt mu la jj mv mw le jn mx my li mz bi translated">2.装载安卓系统</h2><p id="3d30" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">当加载drawables时，你需要使用来自AndroidX的方法，它提供了反向矢量支持。这样做的切入点是<strong class="iw hy">总是</strong>用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/appcompat/content/res/AppCompatResources.html#getDrawable(android.content.Context,%20int)" rel="noopener ugc nofollow" target="_blank">AppCompatResources.getDrawable</a></code>加载可提取的内容。虽然 <a class="ae hu" href="https://developer.android.com/reference/android/content/Context#getDrawable(int)" rel="noopener ugc nofollow" target="_blank">方式</a>中有一个<a class="ae hu" href="https://developer.android.com/reference/android/content/Context#getDrawable(int)" rel="noopener ugc nofollow" target="_blank">号</a> <a class="ae hu" href="https://developer.android.com/reference/android/support/v4/content/res/ResourcesCompat.html#getDrawable(android.content.res.Resources,%20int,%20android.content.res.Resources.Theme)" rel="noopener ugc nofollow" target="_blank">来加载drawables(因为原因)，但是如果你想使用compat向量，你<strong class="iw hy">必须</strong>使用<code class="du js jt ju jv b">AppCompatResources</code>。如果你做不到这一点，那么你就不能进入AndroidX代码路径，当你试图使用任何你运行的平台不支持的特性时，你的应用可能会崩溃。</a></p><blockquote class="ni nj nk"><p id="ceb7" class="iu iv lp iw b ix iy iz ja jb jc jd je nl jg jh ji nm jk jl jm nn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><em class="hx">VectorDrawableCompat</em></code>也提供了一种<code class="du js jt ju jv b"><em class="hx">create</em></code>的方法。我建议总是使用<code class="du js jt ju jv b"><em class="hx">AppCompatResources</em></code>，因为这增加了一层缓存。</p></blockquote><p id="f81b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想声明性地设置drawables(即在你的布局中),那么<code class="du js jt ju jv b">appcompat</code>提供了许多<code class="du js jt ju jv b">*Compat</code>属性，你应该使用标准平台的<strong class="iw hy">而不是</strong>:</p><p id="56e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">ImageView</code>，<code class="du js jt ju jv b">ImageButton</code>:</p><ul class=""><li id="6f13" class="lq lr hx iw b ix iy jb jc jf ls jj lt jn lu jr lv lw lx ly bi translated">不要:<code class="du js jt ju jv b">android:src</code></li><li id="270b" class="lq lr hx iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated">做:<code class="du js jt ju jv b">app:srcCompat</code></li></ul><p id="ce83" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">CheckBox</code>，<code class="du js jt ju jv b">RadioButton</code>:</p><ul class=""><li id="e96c" class="lq lr hx iw b ix iy jb jc jf ls jj lt jn lu jr lv lw lx ly bi translated">不要:<code class="du js jt ju jv b">android:button</code></li><li id="c7b1" class="lq lr hx iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated">Do: <code class="du js jt ju jv b">app:buttonCompat</code></li></ul><p id="2c29" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">TextView</code> ( <a class="ae hu" href="https://developer.android.com/jetpack/androidx/androidx-rn#2018-dec-03-appcompat" rel="noopener ugc nofollow" target="_blank">截至</a> <code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/androidx-rn#2018-dec-03-appcompat" rel="noopener ugc nofollow" target="_blank">appcompat:1.1.0</a></code>):</p><ul class=""><li id="8cca" class="lq lr hx iw b ix iy jb jc jf ls jj lt jn lu jr lv lw lx ly bi translated"><code class="du js jt ju jv b">android:drawableStart</code>不要:<code class="du js jt ju jv b">android:drawableTop</code>等。</li><li id="a615" class="lq lr hx iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated">Do: <code class="du js jt ju jv b">app:drawableStartCompat</code> <code class="du js jt ju jv b">app:drawableTopCompat</code>等。</li></ul><p id="d7f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为这些属性是<code class="du js jt ju jv b">appcompat</code>库的一部分，所以一定要使用<code class="du js jt ju jv b">app:</code>名称空间。在内部，这些<code class="du js jt ju jv b">AppCompat*</code>视图使用<code class="du js jt ju jv b">AppCompatResources</code>本身来启用加载向量。</p><blockquote class="ni nj nk"><p id="a1b2" class="iu iv lp iw b ix iy iz ja jb jc jd je nl jg jh ji nm jk jl jm nn jo jp jq jr ha bi translated">如果你想了解<code class="du js jt ju jv b">appcompat</code>如何将你声明的<code class="du js jt ju jv b">TextView</code>等换成启用该功能的<code class="du js jt ju jv b">AppCompatTextView</code>，那么看看这篇文章:<a class="ae hu" href="https://helw.net/2018/08/06/appcompat-view-inflation/" rel="noopener ugc nofollow" target="_blank">https://helw.net/2018/08/06/appcompat-view-inflation/</a></p></blockquote><h1 id="aed0" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">在实践中</h1><p id="72d5" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">这些要求会影响您创建布局或访问资源的方式。以下是一些实际的考虑因素。</p><h2 id="de11" class="mm kn hx bd ko mn mo mp ks mq mr ms kw jf mt mu la jj mv mw le jn mx my li mz bi translated">没有兼容性属性的视图</h2><p id="d36e" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">不幸的是，有许多地方你可能想在不提供compat属性的视图上指定drawables(例如，<code class="du js jt ju jv b">ProgressBar</code> s没有<code class="du js jt ju jv b">indeterminateDrawableCompat</code>属性)，即上面没有列出的任何东西。仍然可以使用AndroidX vectors，但是您需要从代码中完成:</p><figure class="mg mh mi mj fd hj"><div class="bz dy l di"><div class="no ml l"/></div></figure><p id="e768" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您正在使用<a class="ae hu" href="https://developer.android.com/topic/libraries/data-binding/" rel="noopener ugc nofollow" target="_blank">数据绑定</a>，那么这可以通过使用自定义绑定适配器来完成:</p><figure class="mg mh mi mj fd hj"><div class="bz dy l di"><div class="no ml l"/></div></figure><p id="aeb4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，我们<strong class="iw hy">不希望</strong>让数据绑定为我们加载drawable(因为它不使用<code class="du js jt ju jv b">AppCompatResources</code>加载drawable<a class="ae hu" href="https://issuetracker.google.com/issues/111345022" rel="noopener ugc nofollow" target="_blank"><em class="lp">当前是</em> </a>)所以不能像<code class="du js jt ju jv b">@{@drawable/foo}</code>那样直接引用drawable。相反，我们希望将drawable <strong class="iw hy"> id </strong>传递给绑定适配器，因此需要导入<code class="du js jt ju jv b">R</code>类来引用它:</p><figure class="mg mh mi mj fd hj"><div class="bz dy l di"><div class="no ml l"/></div></figure><h2 id="a550" class="mm kn hx bd ko mn mo mp ks mq mr ms kw jf mt mu la jj mv mw le jn mx my li mz bi translated">嵌套d <code class="du js jt ju jv b">rawable</code> s</h2><p id="ffe2" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">一些可绘制类型是可嵌套的，例如<code class="du js jt ju jv b">StateListDrawable</code>、<code class="du js jt ju jv b">InsetDrawable</code>或<code class="du js jt ju jv b">LayerDrawable</code>包含其他子可绘制类型。AndroidX支持通过明确知道如何膨胀<code class="du js jt ju jv b">&lt;vector&gt;</code>元素(还有<code class="du js jt ju jv b">animated-vector</code>和<code class="du js jt ju jv b">animated-selector</code>元素，但我们今天将重点关注静态向量)来工作。当您调用<code class="du js jt ju jv b">AppCompatResources.getDrawable</code>时，它会用给定的<code class="du js jt ju jv b">id</code>查看资源，如果它是一个vector(即根元素是<code class="du js jt ju jv b">&lt;vector&gt;</code>)，它会为您手动膨胀它。否则，它会将它交给平台进行充气——当这样做时，AndroidX没有办法将<em class="lp">自身重新插入</em>的过程中。这意味着，如果你有一个包含向量的<code class="du js jt ju jv b">InsetDrawable</code>并请求<code class="du js jt ju jv b">AppCompatResources</code>为你加载它，它会看到<code class="du js jt ju jv b">&lt;inset&gt;</code>标签，耸耸肩，并把它交给平台来加载。因此，它将没有机会加载嵌套的<code class="du js jt ju jv b">&lt;vector&gt;</code>，因此这将失败(在API &lt; 21上)或者只是退回到平台支持。</p><p id="a56b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要解决这个问题，您可以在代码中创建drawables即使用<code class="du js jt ju jv b">AppCompatResources</code>膨胀矢量，然后手动创建<code class="du js jt ju jv b">InsetDrawable</code> drawable。</p><p id="4978" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个例外是最近添加到AndroidX(<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/androidx-rn#1.0.0-new" rel="noopener ugc nofollow" target="_blank">appcompat:1.0.0</a></code><a class="ae hu" href="https://developer.android.com/jetpack/androidx/androidx-rn#1.0.0-new" rel="noopener ugc nofollow" target="_blank">)的后向移植<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/appcompat/graphics/drawable/AnimatedStateListDrawableCompat" rel="noopener ugc nofollow" target="_blank">AnimatedStateListDrawable</a></code> s，这是一个带有状态间动画转换的<code class="du js jt ju jv b">StateListDrawable</code>版本(以<code class="du js jt ju jv b">AnimatedVectorDrawables</code>的形式)。但是没有什么要求你去声明转变。因此，如果你只需要一个能够使用AndroidX膨胀子向量的<code class="du js jt ju jv b">StateListDrawable</code>，那么你可以使用这个:</a></p><figure class="mg mh mi mj fd hj"><div class="bz dy l di"><div class="no ml l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Credit for this genius hack: <a class="ae hu" href="https://twitter.com/alexjlockwood/status/1029088247131996160" rel="noopener ugc nofollow" target="_blank">https://twitter.com/alexjlockwood/status/1029088247131996160</a></figcaption></figure><blockquote class="ni nj nk"><p id="10c8" class="iu iv lp iw b ix iy iz ja jb jc jd je nl jg jh ji nm jk jl jm nn jo jp jq jr ha bi translated">有一种方法可以使用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/support/v7/app/AppCompatDelegate.html#setCompatVectorFromResourcesEnabled(boolean)" rel="noopener ugc nofollow" target="_blank"><em class="hx">AppCompatDelegate#setCompatVectorFromResourcesEnabled</em></a></code>在嵌套的drawables中启用向量，但是它有很多缺点。请务必仔细阅读javadoc。</p></blockquote><h2 id="7543" class="mm kn hx bd ko mn mo mp ks mq mr ms kw jf mt mu la jj mv mw le jn mx my li mz bi translated">进程外加载</h2><p id="f33a" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">有时你需要在你不能控制<em class="lp">的地方提供drawables，当</em>或<em class="lp">如何加载</em>时。例如:通知、主屏幕窗口小部件或者你的主题中指定的一些资产(例如设置<code class="du js jt ju jv b">android:windowBackground</code>，它是在创建预览窗口时由平台加载的)。在这些情况下，你不负责加载drawable，所以没有机会集成AndroidX支持，你不能使用vectors API 21之前的版本😞。</p><p id="b3a4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你当然可以在API 21+上使用vectors，但是要注意你可能不会喜欢AndroidX提供的特性/错误修复。例如，虽然AndroidX反向端口<code class="du js jt ju jv b">fillType="evenOdd"</code>很好，但是在API 21–23设备上使用AndroidX支持之外的<em class="lp">的向量不会理解这个属性。对于这个具体的例子，我将在下一篇文章中介绍如何在设计时转换<code class="du js jt ju jv b">fillType</code>。否则，您可能需要为不同的API级别提供替代资源:</em></p><pre class="mg mh mi mj fd na jv nb nc aw nd bi"><span id="e23c" class="mm kn hx jv b fi ne nf l ng nh">res/<br/>  drawable-xxhdpi/<br/>    foo.png             &lt;-- raster<br/>  drawable-anydpi-v21/<br/>    foo.xml             &lt;-- vector<br/>  drawable-anydpi-v24/<br/>    foo.xml             &lt;-- vector with fancy features</span></pre><p id="42d2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，除了api级别限定符之外，我们还需要包括<code class="du js jt ju jv b">anydpi</code>资源限定符。这是由于<a class="ae hu" href="https://developer.android.com/guide/topics/resources/providing-resources#BestMatch" rel="noopener ugc nofollow" target="_blank">资源限定符优先级</a>的工作方式；<code class="du js jt ju jv b">drawable-&lt;whatever&gt;dpi</code>中的任何资产都将被视为比仅<code class="du js jt ju jv b">drawable-v21</code>中的资产更好的匹配。</p><h1 id="125f" class="km kn hx bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">x标记了地点</h1><p id="a16e" class="pw-post-body-paragraph iu iv hx iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">希望这篇文章强调了使用AndroidX vector支持的好处以及您需要了解的一些限制。使用AndroidX支持不仅可以在更多平台版本上启用vectors和backports功能，而且<em class="lp">还可以</em>设置您接收任何<em class="lp">未来的</em>更新。</p><p id="dd78" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经了解了<em class="lp">为什么</em>和<em class="lp">如何</em>应该<em class="lp">使用</em>向量，下一篇文章将深入探讨如何<em class="lp">创建</em>它们。</p><p id="6ad1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lp">即将推出:为Android创建矢量资产<br/>即将推出:剖析Android </em> <code class="du js jt ju jv b"><em class="lp">VectorDrawable</em></code> <em class="lp"> s </em></p></div></div>    
</body>
</html>