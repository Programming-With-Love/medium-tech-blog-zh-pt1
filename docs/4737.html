<html>
<head>
<title>Can You Avoid Functional Programming as a Policy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一种策略，你能避免函数式编程吗？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/can-you-avoid-functional-programming-as-a-policy-7bd0570bcfb2?source=collection_archive---------0-----------------------#2018-03-22">https://medium.com/javascript-scene/can-you-avoid-functional-programming-as-a-policy-7bd0570bcfb2?source=collection_archive---------0-----------------------#2018-03-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6d6e21b514d05d5c22146daf734a0c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJMH1oNCwUd3QgvZHwlgpg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Policy by <a class="ae it" href="http://www.nyphotographic.com/" rel="noopener ugc nofollow" target="_blank">Nick Youngson</a> <a class="ae it" href="http://creativecommons.org/licenses/by-sa/3.0/" rel="noopener ugc nofollow" target="_blank">CC BY-SA 3.0</a> <a class="ae it" href="http://alphastockimages.com/" rel="noopener ugc nofollow" target="_blank">Alpha Stock Images</a></figcaption></figure><p id="e5d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">函数式编程已经渗透到大多数主流编程领域——JS生态系统的大部分，C#的Linq，甚至Java中的高阶函数。这是2018年的Java:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0f0e" class="kb kc hh jx b fi kd ke l kf kg"><em class="kh">getUserName(</em>users, user -&gt; user.getUserName<em class="kh">())</em>;</span></pre><p id="df46" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">FP是如此有用和方便，它已经在我所能想到的主流现代编程语言中找到了自己的路。</p><p id="0e7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但不全是彩虹和小狗。许多开发人员都在努力应对我们对软件的看法的这种结构性转变。坦率地说，现在很难找到一份不需要熟悉函数式编程概念的JavaScript工作。</p><p id="1ef7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">FP位于两个主流框架React(避免共享可变DOM是其架构和单向数据流的动机)和Angular (RxJS是通过高阶函数作用于流的实用操作符库——在Angular中广泛使用)的核心。Redux和ngrx/store也是如此:在这两方面都起作用。</p><p id="65da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于刚接触函数式编程的开发人员来说，这可能是一个令人生畏的话题，为了快速入门，你团队中的一些人可能会建议你通过<strong class="iw hi">避免使用函数式编程作为策略，让你的团队更容易适应代码库。</strong></p><p id="a068" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于不熟悉FP是什么，或者它在现代代码生态系统中的普遍性的管理者来说，这听起来可能是一个明智的建议。毕竟30年来OOP不是很好的服务了软件世界吗？为什么不继续这样做呢？</p><p id="3dbb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们暂时考虑一下这个想法。</p><p id="23de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“禁止”计划生育<em class="kh">作为一项政策意味着什么？</em></p><h1 id="e0c2" class="ki kc hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">什么是函数式编程？</h1><p id="2fde" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">我最喜欢的函数式编程的定义是:</p><p id="8656" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">函数式编程</strong>是一种编程范式，使用<strong class="iw hi">纯函数</strong>作为组合的原子单位，避免了<em class="kh">共享可变状态</em>和<em class="kh">副作用。</em></p><p id="34e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">纯函数是这样的函数:</p><ul class=""><li id="cecd" class="lk ll hh iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">给定相同的输入，总是返回相同的输出</li><li id="4b76" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">没有副作用</li></ul><p id="f78e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">FP的本质可以归结为:</p><ul class=""><li id="b139" class="lk ll hh iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated"><strong class="iw hi">带功能的程序</strong></li><li id="82b6" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated"><strong class="iw hi">避免共享可变状态&amp;副作用</strong></li></ul><p id="d43e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当你把这些放在一起时，你得到了使用纯函数作为你的构建块的软件开发(“组成的原子单位”)。</p><p id="32ac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">顺便提一下，根据所有现代面向对象程序设计的倡导者艾伦·凯的观点，面向对象程序设计的本质是:</p><ul class=""><li id="f1fa" class="lk ll hh iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated"><strong class="iw hi">封装</strong></li><li id="bea3" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated"><strong class="iw hi">消息传递</strong></li></ul><p id="2621" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以OOP只是避免共享可变状态和副作用的另一种方法。</p><p id="5925" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">显然，FP的反义词不是OOP。FP的对立面是无结构的、过程化的编程。</p><p id="1bd4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">small talk(Alan Kay奠定OOP基础的地方)既是<strong class="iw hi">面向对象的</strong>又是<strong class="iw hi">功能性的</strong>，选择其中一个的想法完全是外来的，不可想象的。</p><p id="0c3f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">JavaScript也是如此。当Brendan Eich受雇开发JavaScript时，他的想法是:</p><ul class=""><li id="c4ad" class="lk ll hh iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">浏览器中的方案(FP)</li><li id="ddf4" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">看起来像Java (OOP)</li></ul><p id="bd10" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在JavaScript中，你可以选择其中之一，但无论好坏，它们都是密不可分的。JavaScript中的封装依赖于闭包——一个来自函数式编程的概念。</p><p id="9bef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不管你是否知道，很有可能你已经在做一些函数式编程了。</p><h1 id="5e0d" class="ki kc hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">如何不做FP:</h1><p id="b877" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">为了避免函数式编程，你必须避免使用纯函数。问题是，现在你不能写这个，因为它可能是纯的:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="e2a1" class="kb kc hh jx b fi kd ke l kf kg">const getName = obj =&gt; obj.name;<br/>const name = getName({ uid: '123', name: 'Banksy' }); // Banksy</span></pre><p id="c718" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们重构它，这样它就不再是FP了。相反，我们可以使它成为一个具有公共属性的类。因为它没有使用封装，所以称之为OOP有些牵强。也许我们应该称之为“过程化对象编程”？：</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="9a72" class="kb kc hh jx b fi kd ke l kf kg">class User {<br/>  constructor ({name}) {<br/>    this.name = name;<br/>  }<br/>  getName () {<br/>    return this.name;<br/>  }<br/>}</span><span id="4599" class="kb kc hh jx b fi ly ke l kf kg">const myUser = new User({ uid: '123', name: 'Banksy' });<br/>const name = myUser.getName(); // Banksy</span></pre><p id="524a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">恭喜你！我们刚刚把两行代码变成了11行，并引入了不受控制的外部突变的可能性。我们<strong class="iw hi">收获了什么？</strong></p><p id="8db0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯，没什么，真的。事实上，我们已经失去了很多灵活性和节省大量代码的潜力。</p><p id="47d9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">前面的<code class="du lz ma mb jx b">getName()</code>函数适用于任何输入对象。这个也可以(因为它是JavaScript，我们可以将方法委托给随机的对象)，但是它要笨拙得多。我们可以让这两个类从一个公共基类继承——但这意味着对象类之间可能根本不需要存在关系。</p><p id="19fd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">忘记可重用性。我们刚刚把它冲进了下水道。下面是代码复制的样子:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6ebc" class="kb kc hh jx b fi kd ke l kf kg">class Friend {<br/>  constructor ({name}) {<br/>    this.name = name;<br/>  }<br/>  getName () {<br/>    return this.name;<br/>  }<br/>}</span></pre><p id="2399" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个乐于助人的学生从教室后面插嘴道:</p><blockquote class="mc md me"><p id="e59b" class="iu iv kh iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">“当然是创建人类啦！”</p></blockquote><p id="2164" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是后来:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="cecb" class="kb kc hh jx b fi kd ke l kf kg">class Country {<br/>  constructor ({name}) {<br/>    this.name = name;<br/>  }<br/>  getName () {<br/>    return this.name;<br/>  }<br/>}</span></pre><blockquote class="mc md me"><p id="49a7" class="iu iv kh iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">“但显然这些是不同的类型。<strong class="iw hi">当然</strong>你不能在一个国家上用一个人的方法！”</p></blockquote><p id="e257" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对此我回答:<em class="kh">“为什么不呢？”</em></p><p id="c074" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">函数式编程的一个惊人的好处是非常简单的泛型编程。你可以称之为“默认通用”:编写单个函数的能力，该函数可以与满足其<strong class="iw hi">通用需求的任何</strong>类型一起工作。</p><blockquote class="mc md me"><p id="b60c" class="iu iv kh iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated">注意:对于Java人来说，这与静态类型无关。一些FP语言有很好的静态类型系统，并且仍然使用像结构和/或更高级类型的特性来分享这个好处。</p></blockquote><p id="a80e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个例子很简单，但是我们从这个技巧中节省的代码量是巨大的。</p><p id="0106" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它使得像<a class="ae it" href="https://github.com/ericelliott/autodux" rel="noopener ugc nofollow" target="_blank"> autodux </a>这样的库能够为任何由getter/setter对组成的对象自动生成域逻辑(除此之外还有更多)。单单这个技巧就可以将领域逻辑的代码减少一半或更多。</p><h2 id="1590" class="kb kc hh bd kj mi mj mk kn ml mm mn kr jf mo mp kv jj mq mr kz jn ms mt ld mu bi translated">不再有高阶函数</h2><p id="8332" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">因为大多数(但不是全部)高阶函数利用纯函数基于相同的输入返回相同的值，所以你也不能使用像<code class="du lz ma mb jx b">.map()</code>、<code class="du lz ma mb jx b">.filter()</code>、<code class="du lz ma mb jx b">reduce()</code>这样的函数而不产生副作用，只是说你不纯:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="7cd5" class="kb kc hh jx b fi kd ke l kf kg">const arr = [1,2,3];</span><span id="ea22" class="kb kc hh jx b fi ly ke l kf kg">const double = n =&gt; n * 2;<br/>const doubledArr = arr.map(double);</span></pre><p id="47a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">变成了:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0b7d" class="kb kc hh jx b fi kd ke l kf kg">const arr = [1,2,3];</span><span id="1b69" class="kb kc hh jx b fi ly ke l kf kg">const double = (n, i) =&gt; {<br/>  console.log('Random side-effect for no reason.');<br/>  console.log(`Oh, I know, we could directly save the output<br/>to the database and tightly couple our domain logic to our I/O. That'll be fine. Nobody else will need to multiply by 2, right?`);<br/>  saveToDB(i, n);<br/>  return n * 2;<br/>};</span><span id="45c7" class="kb kc hh jx b fi ly ke l kf kg">const doubledArr = arr.map(double);</span></pre><h2 id="a079" class="kb kc hh bd kj mi mj mk kn ml mm mn kr jf mo mp kv jj mq mr kz jn ms mt ld mu bi translated"><strong class="ak"> RIP，功能合成1958–2018</strong></h2><p id="7b89" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">忘掉<a class="ae it" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0"><strong class="iw hi"/></a>的<strong class="iw hi">高阶组件</strong>来封装你跨页面的横切关注点。这种方便的声明性语法现在已经被禁止使用了:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2867" class="kb kc hh jx b fi kd ke l kf kg">const wrapEveryPage = compose(<br/>  withRedux,<br/>  withEnv,<br/>  withLoader,<br/>  withTheme,<br/>  withLayout,<br/>  withFeatures({ initialFeatures })<br/>);</span></pre><p id="e270" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您将不得不手动地将这些导入到每个组件中，或者更糟——陷入一个混乱的、不灵活的类继承层次结构中(<a class="ae it" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">被大多数理智的人正确地认为是一个反模式</a>,甚至[特别是？] by <a class="ae it" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612//ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6bf38f374c00b60d798680a47193cd12" rel="noopener ugc nofollow" target="_blank"> OO设计佳能</a>)。</p><h2 id="caf4" class="kb kc hh bd kj mi mj mk kn ml mm mn kr jf mo mp kv jj mq mr kz jn ms mt ld mu bi translated">告别、承诺和异步/等待</h2><p id="b1f9" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">承诺是单子。从范畴理论上讲，但我听说它们也是FP的东西，因为Haskell有它们，并使用单子使一切变得纯粹和懒惰。</p><p id="9f10" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">老实说，失去单子和函子教程可能是一件好事。这些事情比我们说的要简单得多！在我介绍函子和单子的一般概念之前，我教人们如何使用<code class="du lz ma mb jx b">Array.prototype.map</code>和承诺<em class="kh">是有原因的。</em></p><p id="d82e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你知道怎么用吗？你对函子和单子的理解已经超过一半了。</p><h1 id="90d0" class="ki kc hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">所以，为了避免FP</h1><ul class=""><li id="de81" class="lk ll hh iw b ix lf jb lg jf mv jj mw jn mx jr lp lq lr ls bi translated">不要使用任何JavaScript最流行的框架或库(它们都会把你出卖给FP！).</li><li id="9cba" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">不要写纯函数。</li><li id="477d" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">不要使用大量JavaScript的内置特性:大多数数学函数(因为它们是纯的)，不可变的字符串和数组方法。map()，。filter()，。forEach()、promises或async/await。</li><li id="e2c0" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">一定要写不必要的类。</li><li id="8a50" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">通过手动为几乎所有东西编写getters和setters，使您的域逻辑翻倍。</li><li id="8d03" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">采取“可读、明确”的命令式方法，将您的域逻辑与呈现和网络I/O问题结合起来。</li></ul><p id="f411" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">和...说再见:</p><ul class=""><li id="c80d" class="lk ll hh iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">时间旅行调试</li><li id="45c2" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">轻松的撤消/重做功能开发</li><li id="d154" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">坚如磐石、一致的单元测试</li><li id="1f27" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">模拟和D/I自由测试</li><li id="880f" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">不依赖网络I/O的快速单元测试</li><li id="ec52" class="lk ll hh iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">小型、可测试、可调试、可维护的代码库</li></ul><p id="aa30" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">避免将函数式编程作为一种策略？没问题。</p><p id="6659" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">哦，等等。</p></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><h1 id="7116" class="ki kc hh bd kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la nj lc ld le bi translated">在EricElliottJS.com了解更多信息</h1><p id="d76c" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">EricElliottJS.com的会员可以上函数式编程的视频课。如果您还不是会员，<a class="ae it" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">今天就注册吧</a>。</p><figure class="js jt ju jv fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es nk"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="kh">埃里克·艾略特</em> </strong> <em class="kh">是</em> <a class="ae it" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="kh">【编程JavaScript应用】</em> </a> <em class="kh"> (O'Reilly)的作者，软件导师平台</em><a class="ae it" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="kh">devanywhere . io</em></a><em class="kh">的联合创始人。他曾为</em><strong class="iw hi"><em class="kh">Adobe Systems</em></strong><em class="kh"/><strong class="iw hi"><em class="kh">尊巴健身</em></strong><em class="kh"/><strong class="iw hi"><em class="kh">华尔街日报</em></strong><em class="kh"/><strong class="iw hi"><em class="kh">ESPN</em></strong><em class="kh"/><strong class="iw hi"><em class="kh">BBC</em></strong><em class="kh">等顶级录音师贡献过软件经验</em></p><p id="98ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">他在远离任何地方的地方和世界上最美丽的女人一起工作。</p></div></div>    
</body>
</html>