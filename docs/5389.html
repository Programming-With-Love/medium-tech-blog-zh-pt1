<html>
<head>
<title>Using Terraform to provision Oracle Cloud Infrastructure Classic Instances with Persistent Block Storage Attachments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform为Oracle云基础架构经典实例配置永久块存储附件</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/using-terraform-to-provision-oracle-cloud-infrastructure-classic-instances-with-persistent-block-ef47fb90c2b0?source=collection_archive---------0-----------------------#2018-01-18">https://medium.com/oracledevs/using-terraform-to-provision-oracle-cloud-infrastructure-classic-instances-with-persistent-block-ef47fb90c2b0?source=collection_archive---------0-----------------------#2018-01-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0287" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文通过使用<code class="du jc jd je jf b"><a class="ae jg" href="https://www.terraform.io/docs/providers/opc/index.html" rel="noopener ugc nofollow" target="_blank">opc</a></code>提供者，研究了在使用持久引导和数据存储卷时，使用Terraform配置和管理Oracle云基础架构计算经典实例生命周期的选项。</p><p id="9ad7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先让我们看看Terraform如何提供一个基本的计算实例</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="03cb" class="jp jq hh jf b fi jr js l jt ju">resource "opc_compute_instance" "storage-example" {<br/>  name  = "storage-example"<br/>  image = "/oracle/public/OL_7.2_UEKR4_x86_64"<br/>  shape = "oc3"<br/>}</span></pre><p id="5ca2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于没有明确定义存储资源，Terraform将创建一个<em class="jv">临时</em>实例，用于本地引导存储。当实例被销毁时，本地存储就消失了，并且不可恢复。当没有本地持久性需求时，临时实例是理想的，但是如果您需要在错误或中断后启动/停止、调整大小或轻松恢复实例，那么实例将需要持久性块存储。</p><h1 id="48b7" class="jw jq hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">永久启动卷</h1><p id="8d58" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">让我们扩展基本实例定义，添加一个持久引导卷。</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="31b9" class="jp jq hh jf b fi jr js l jt ju"><strong class="jf hi">resource "opc_compute_storage_volume" "boot-volume" {<br/>  size = "20"<br/>  name = "boot-volume"<br/>  bootable = true<br/>  image_list = "/oracle/public/OL_7.2_UEKR4_x86_64"<br/>  image_list_entry = 1<br/>}</strong></span><span id="68e8" class="jp jq hh jf b fi ky js l jt ju">resource "opc_compute_instance" "storage-example" {<br/>  name = "storage-example"<br/>  shape = "oc3"<br/>  <strong class="jf hi">storage {<br/>    index = 1<br/>    volume = "${opc_compute_storage_volume.boot-volume.name}"<br/>  }<br/>  boot_order = [ 1 ]<br/></strong>}</span></pre><p id="1758" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，Terraform将使用所请求的基本映像创建一个可引导块存储卷，创建附加了引导卷的实例，并从该卷引导实例。使用<code class="du jc jd je jf b"><strong class="ig hi">boot_order</strong></code>属性识别哪个存储附件用作引导卷。</p><p id="31d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用单独的实例和存储资源，现在可以修改<strong class="ig hi">实例资源</strong>(例如，将所需状态从运行设置为暂停，或者更改形状)，而存储卷将保持不变。修改<strong class="ig hi">存储资源</strong>定义(例如，更改大小、存储类型或映像)仍然是破坏性事件。Terraform <code class="du jc jd je jf b"><strong class="ig hi">prevent_destroy</strong></code>标志可用于降低意外破坏存储资源的几率。</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="f388" class="jp jq hh jf b fi jr js l jt ju">resource "opc_compute_storage_volume" "boot-volume" {<br/>  size = "20"<br/>  name = "boot-volume"<br/>  bootable = true<br/>  image_list = "/oracle/public/OL_7.2_UEKR4_x86_64"<br/>  image_list_entry = 1<br/><strong class="jf hi">  lifecycle {<br/>    prevent_destroy = true<br/>  }</strong><br/>}</span></pre><h1 id="605d" class="jw jq hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">持久数据卷</h1><p id="d204" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">除了启动卷，我们还可以附加多个数据卷。这有助于将操作系统从应用程序和数据分区中分离出来，并且更容易调整大小。让我们向实例定义中添加一个新的数据量。</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="d027" class="jp jq hh jf b fi jr js l jt ju">resource "opc_compute_storage_volume" "boot-volume" {<br/>...<br/>}</span><span id="4777" class="jp jq hh jf b fi ky js l jt ju"><strong class="jf hi">resource "opc_compute_storage_volume" "data-volume" {<br/>  size = "20"<br/>  name = "data-volume"<br/>}</strong></span><span id="1b9d" class="jp jq hh jf b fi ky js l jt ju">resource "opc_compute_instance" "storage-example" {<br/>  name = "storage-example"<br/>  shape = "oc3"<br/>  storage {<br/>    index = 1<br/>    volume = "${opc_compute_storage_volume.boot-volume.name}"<br/>  }<br/>  <strong class="jf hi">storage {<br/>    index = 2<br/>    volume = "${opc_compute_storage_volume.data-volume.name}"<br/>  }</strong><br/>  boot_order = [ 1 ]<strong class="jf hi"><br/></strong>}</span></pre><p id="5492" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，现在有了一个包含持久引导和数据卷的实例。如前所述,<code class="du jc jd je jf b"><strong class="ig hi">prevent_destroy</strong></code>选项可用于进一步防止资源被意外删除。如果您在上面的配置上运行<code class="du jc jd je jf b">terraform apply</code>，您会注意到实例资源被销毁并重新创建，这是因为在实例定义中声明的存储附件是启动定义的一部分，并且是在引导时间附加的<em class="jv">。</em></p><p id="cf63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您通常希望在引导时连接存储，使启动脚本能够自动启动任何应用程序并访问存储卷上的数据，但是让我们考虑这样一种情况:您希望将存储卷连接到一个已经运行的实例，而不停止并重新创建该实例。</p><h1 id="e8df" class="jw jq hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">动态存储附件</h1><p id="7a83" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">使用<strong class="ig hi">存储附件</strong>资源，我们可以将新的存储资源关联到已经创建/运行的实例。将以下内容添加到之前的配置中</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="aba3" class="jp jq hh jf b fi jr js l jt ju">resource "opc_compute_storage_volume" "attached-volume" {<br/>  size = "20"<br/>  name = "attached-volume"<br/>}</span><span id="fcae" class="jp jq hh jf b fi ky js l jt ju">resource "opc_compute_storage_attachment" "storage-attachment" {<br/>  instance = "${opc_compute_instance.storage-example.name}"<br/>  index = 3<br/>  storage_volume = "${opc_compute_storage_volume.attached-volume.name}"<br/>}</span></pre><p id="44f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的一个关键区别是，存储附件仅在实例创建完成之后与实例<em class="jv">相关联，包括运行可能是实例定义一部分的任何置备程序。新卷的检测和安装将特定于实例操作系统(参见<a class="ae jg" href="https://docs.oracle.com/en/cloud/iaas/compute-iaas-cloud/stcsg/mounting-and-unmounting-storage-volume.html" rel="noopener ugc nofollow" target="_blank">安装和卸载存储卷</a>)。对于运行Oracle Linux的实例，新的存储附件将自动显示为块设备<code class="du jc jd je jf b"><strong class="ig hi">/dev/xvdd</strong></code></em></p><p id="883b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用存储附件资源中的<code class="du jc jd je jf b"><strong class="ig hi">remote-exec</strong></code>置备程序，可以在Terraform配置中管理存储卷的格式化和安装。</p><p id="5aad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jv">注意:此处我们假设实例已经配置了ssh访问，使用了适当提供的ssh密钥，并且可以访问本地网络上的Terraform为了简洁和不离题，配置了适当的密钥、bastion主机、vpn、ip网络和/或公共ip预留等。留给读者一个练习。</em></p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="bdfd" class="jp jq hh jf b fi jr js l jt ju">resource "opc_compute_storage_attachment" "storage-attachment" {<br/>  instance = "${opc_compute_instance.storage-example.name}"<br/>  index = 3<br/>  storage_volume = "${opc_compute_storage_volume.attached-volume.name}"</span><span id="0de7" class="jp jq hh jf b fi ky js l jt ju"><strong class="jf hi">  connection {<br/>    type = "ssh"<br/>    host = "${opc_compute_instance.storage-example.ip_address}"<br/>    user = "opc"<br/>    private_key = "${file(var.ssh_private_key_file)}"<br/>    timeout = "10m"<br/>  }</strong></span><span id="8e66" class="jp jq hh jf b fi ky js l jt ju">  <strong class="jf hi">provisioner "remote-exec" {<br/>    inline = [<br/>      "</strong><strong class="jf hi">sudo mkfs -t ext3 /dev/xvdd</strong><strong class="jf hi">",     # FORMAT THE VOLUME<br/>      "</strong><strong class="jf hi">sudo mkdir /mnt/store",           # CREATE THE MOUNT POINT<br/>      "sudo mount /dev/xvdd /mnt/store"  # MOUNT THE VOLUME</strong><strong class="jf hi"> <br/>    ]<br/>  }</strong><br/>}</span></pre><p id="584b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此示例将在每次(重新)连接存储时重新格式化存储，如果您使用的存储卷已经包含数据，则需要删除该步骤(例如，以前连接到不同实例或从快照恢复的卷)</p><p id="a4fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">初始化和安装存储对于使用存储卷显然很重要，但可能更重要的是确保干净地分离存储卷，以避免潜在的数据损坏。销毁存储附件资源相当于在没有首先弹出的情况下拔出USB驱动器。</p><p id="8123" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Terraform提供了一个特殊的<a class="ae jg" href="https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners" rel="noopener ugc nofollow" target="_blank">销毁时间供应器</a>选项，用于在销毁而非创建期间执行命令。要确保在分离之前卸载卷，请将以下附加的<code class="du jc jd je jf b"><strong class="ig hi">remote-exec</strong></code>置备程序添加到存储附件资源定义中</p><pre class="jh ji jj jk fd jl jf jm jn aw jo bi"><span id="d7cc" class="jp jq hh jf b fi jr js l jt ju"><strong class="jf hi">  provisioner "remote-exec" {<br/>    when = "destroy"<br/>    inline = [</strong><strong class="jf hi"><br/>      "sudo umount /mnt/store"  # UNMOUNT THE VOLUME</strong><strong class="jf hi"> <br/>    ]<br/>  }</strong></span></pre><p id="6db0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">然而</strong>，请务必注意Terraform文档中的以下片段:</p><blockquote class="kz la lb"><p id="6405" class="ie if jv ig b ih ii ij ik il im in io lc iq ir is ld iu iv iw le iy iz ja jb ha bi translated">销毁时置备程序只有在销毁资源时仍在配置中才能运行。如果从配置中完全删除带有销毁时置备程序的资源块，其置备程序配置也会随之删除，因此销毁置备程序将不会运行。要解决此问题，可以使用销毁时置备程序通过多步过程安全删除资源:</p><p id="35df" class="ie if jv ig b ih ii ij ik il im in io lc iq ir is ld iu iv iw le iy iz ja jb ha bi translated">更新资源配置以包括<code class="du jc jd je jf b">count = 0</code>。</p><p id="dd1e" class="ie if jv ig b ih ii ij ik il im in io lc iq ir is ld iu iv iw le iy iz ja jb ha bi translated">应用配置以销毁资源的任何现有实例，包括运行销毁置备程序。</p><p id="b0b2" class="ie if jv ig b ih ii ij ik il im in io lc iq ir is ld iu iv iw le iy iz ja jb ha bi translated">从配置中完全删除资源块及其<code class="du jc jd je jf b">provisioner</code>块。</p><p id="966c" class="ie if jv ig b ih ii ij ik il im in io lc iq ir is ld iu iv iw le iy iz ja jb ha bi translated">再次申请，此时不应采取进一步的行动，因为资源已经被破坏。</p></blockquote></div></div>    
</body>
</html>