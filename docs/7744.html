<html>
<head>
<title>Electrode Confippet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电极配置</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/electrode-confippet-85bafe1c9a42?source=collection_archive---------3-----------------------#2018-11-20">https://medium.com/walmartglobaltech/electrode-confippet-85bafe1c9a42?source=collection_archive---------3-----------------------#2018-11-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/46cec8f025a113995bf442c5c6cb3e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGOU5P65O5X6aFhcCx9dgg.jpeg"/></div></div></figure><div class=""/><p id="abb9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://www.electrode.io/" rel="noopener ugc nofollow" target="_blank">电极</a>，由<a class="ae jn" href="https://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank">walmartlab</a>开发的开源平台，用于构建强大的网络和移动应用。<a class="ae jn" href="https://github.com/electrode-io/electrode-confippet" rel="noopener ugc nofollow" target="_blank">电极配置</a>是<a class="ae jn" href="https://www.electrode.io/site/web.html" rel="noopener ugc nofollow" target="_blank">电极网</a>中众多可用模块之一，用于管理Node.js应用的配置。在这篇博文中，我们将深入了解<a class="ae jn" href="https://github.com/electrode-io/electrode-confippet" rel="noopener ugc nofollow" target="_blank">电极配置</a>。</p><h1 id="e135" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么Confippet</h1><p id="f5fd" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在软件工程中，当我们使用<strong class="ir ht"> SOA </strong>或<strong class="ir ht">微服务</strong>架构开发web应用或服务时，我们会有<strong class="ir ht">频繁变化的键/值对</strong>属性。这些变化的属性的几个例子可以是<code class="du kr ks kt ku b">URL:port</code>、<code class="du kr ks kt ku b">connection timeout</code>、<code class="du kr ks kt ku b">response timeout </code>用于我们所依赖的特定服务、<code class="du kr ks kt ku b">DB connection string</code>以及各种<code class="du kr ks kt ku b">framework settings</code>等。使用配置文件比直接在应用程序代码中硬编码它的好处是，我们有一个集中的配置文件存储库，存放所有这些属性。在这些属性文件中更改一个值比搜索整个代码库来找出在哪里进行更改要快很多倍。它为读取整个应用程序的配置属性提供了统一的界面。我们可以形象地将confippet看作一个提供两种操作的容器:</p><p id="b165" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kv">加载</em> —加载一堆配置文件，其中文件的<strong class="ir ht">加载顺序</strong>由其<strong class="ir ht">顺序</strong>值定义，值被合并，给定<code class="du kr ks kt ku b">key</code>的冲突值被具有<code class="du kr ks kt ku b">greater order value </code>的文件覆盖。</p><p id="0495" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kv"> get(key) </em> —为给定的键检索一个<strong class="ir ht">可选的</strong>值。</p><h1 id="e2a8" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">积极着手进行</h1><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kw"><img src="../Images/502c6d8341f2ffcba6fcdc3b855fdccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9FlHjqZ5wuA_XGFW4_o3Q.jpeg"/></div></div></figure><p id="e284" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Confippet遵循<a class="ae jn" href="https://github.com/lorenwest/node-config/wiki/Configuration-Files#file-load-order" rel="noopener ugc nofollow" target="_blank"> <em class="kv"> node-config </em> </a>文件的约定，在<code class="du kr ks kt ku b">config/</code>目录下编译文件，用法非常简单。</p><ol class=""><li id="e584" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">去一个文件夹，做<code class="du kr ks kt ku b">npm install electrode-confippet --save</code></li><li id="0b8c" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">创建一个名为<code class="du kr ks kt ku b">config</code>的文件夹，添加<code class="du kr ks kt ku b">3</code>文件:<code class="du kr ks kt ku b">default.json</code>、<code class="du kr ks kt ku b">development.json</code>、<code class="du kr ks kt ku b">production.json</code>。</li></ol><p id="70d0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">default.json</code></p><pre class="kx ky kz la fd lp ku lq lr aw ls bi"><span id="56c7" class="lt jp hs ku b fi lu lv l lw lx">{<br/>  "settings": {<br/>    "db": {<br/>      "host": "localhost",<br/>      "port": 5432,<br/>      "database": "clients"<br/>    }<br/>  }<br/>}</span></pre><p id="268a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">development.json</code></p><pre class="kx ky kz la fd lp ku lq lr aw ls bi"><span id="a977" class="lt jp hs ku b fi lu lv l lw lx">{<br/>  "settings": {<br/>    "db": {<br/>      "host": "development-db-server"<br/>    }<br/>  }<br/>}</span></pre><p id="4c13" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">production.json</code></p><pre class="kx ky kz la fd lp ku lq lr aw ls bi"><span id="074a" class="lt jp hs ku b fi lu lv l lw lx">{<br/>  "settings": {<br/>    "db": {<br/>      "host": "prod-db-server"<br/>    }<br/>  }<br/>}</span></pre><p id="16ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.要使用<code class="du kr ks kt ku b">electrode-confippet</code>，我们需要做的是，</p><p id="4f84" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">run.js</code></p><pre class="kx ky kz la fd lp ku lq lr aw ls bi"><span id="a5ab" class="lt jp hs ku b fi lu lv l lw lx">const config = require("electrode-confippet").config;<br/>const db = config.$("settings.db");</span></pre><p id="cad5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4.我们可以在两种模式下运行:</p><ul class=""><li id="2e44" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm ly lh li lj bi translated"><code class="du kr ks kt ku b">node run.js</code> —这将首先加载<code class="du kr ks kt ku b">default.json</code>，然后加载<code class="du kr ks kt ku b">development.json</code>，这将确保<code class="du kr ks kt ku b">development.json</code>中相同键的值将覆盖来自<code class="du kr ks kt ku b">default.json</code>的值。confippet的加载顺序:<code class="du kr ks kt ku b">default.json &lt; development.json </code>。<code class="du kr ks kt ku b">settings.db</code>的值将为<code class="du kr ks kt ku b">development-db-server</code>。</li><li id="9fa7" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm ly lh li lj bi translated"><code class="du kr ks kt ku b">NODE_ENV=production node run.js</code> —这将首先加载<code class="du kr ks kt ku b">default.json</code>，然后加载<code class="du kr ks kt ku b">production.json</code>，这将确保<code class="du kr ks kt ku b">production.json</code>中相同键的当前值将覆盖来自<code class="du kr ks kt ku b">default.json</code>的值。confippet的加载顺序:<code class="du kr ks kt ku b">default.json &lt; production.json</code>。<code class="du kr ks kt ku b">settings.db</code>的值将为<code class="du kr ks kt ku b">prod-db-server</code>。</li></ul><p id="285f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">特别是，confippet根据<code class="du kr ks kt ku b">order</code>值加载文件，合并值，给定<code class="du kr ks kt ku b">key</code>的冲突值被具有<code class="du kr ks kt ku b">greater priority</code>的文件覆盖。我们能否尝试用编程中其他领域的概念来解释confippet的这种行为？</p><ul class=""><li id="7329" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm ly lh li lj bi translated"><em class="kv">继承和覆盖</em> —在传统的面向对象编程中，继承使新对象能够呈现现有的属性。在上面的例子中，<code class="du kr ks kt ku b">development.json</code>和<code class="du kr ks kt ku b">production.json</code>能够重用来自<code class="du kr ks kt ku b">default.json</code>的键/值对。同样，在面向对象编程中，覆盖是一个特性，它允许子类或子类提供一个方法的特定实现，该方法已经由它的一个超类或父类提供。在上面的例子中，<code class="du kr ks kt ku b">default.json</code>中<code class="du kr ks kt ku b">host</code>的值被<code class="du kr ks kt ku b">development.json</code>和<code class="du kr ks kt ku b">production.json</code>覆盖。</li><li id="43b4" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm ly lh li lj bi translated"><em class="kv">事件顺序</em> —在编程的许多其他领域中，一个事件在另一个事件发生之前发生的顺序。例如，从服务器上的数据库复制必须按照它们在主服务器上应用的顺序进行，以保证<code class="du kr ks kt ku b">ACID</code>。在<code class="du kr ks kt ku b">redo</code>日志中发生的写操作的顺序在<code class="du kr ks kt ku b">master</code>中被捕获，并在从机中以相同的顺序准确重放。在上面的confippet示例中，文件加载的排序是基于它们的<code class="du kr ks kt ku b">order</code>值来完成的，使用它们可以实现键/值对的重用和覆盖。</li></ul><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="a5fb" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">容纳不同的观点</h1><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/627a191cab9067a64832d2cbeb962f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRXsykILxGD-tIjwPRboBA.jpeg"/></div></div></figure><p id="b49a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，<code class="du kr ks kt ku b">confippet</code>根据<code class="du kr ks kt ku b">config</code>文件夹下的<code class="du kr ks kt ku b">NODE_ENV</code>环境变量，遵循<a class="ae jn" href="https://github.com/lorenwest/node-config/wiki/Configuration-Files#file-load-order" rel="noopener ugc nofollow" target="_blank"> <em class="kv">节点配置</em> </a>文件的约定，自动加载<code class="du kr ks kt ku b">default.json</code>、<code class="du kr ks kt ku b">development.json</code>或<code class="du kr ks kt ku b">production.json</code>。但是不同的应用程序希望在不同的<code class="du kr ks kt ku b">order</code>集合中加载更多(或更少)不同文件名的文件。<a class="ae jn" href="https://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank"> WalmartLabs </a>使用<a class="ae jn" href="http://oneops.com/" rel="noopener ugc nofollow" target="_blank"> OneOps </a>在我们的云环境中部署我们的应用。每个应用程序都有不同的云环境，如<code class="du kr ks kt ku b">oneops-development</code>、<code class="du kr ks kt ku b">oneops-staging</code>、<code class="du kr ks kt ku b">oneops-production</code>等。，他们希望根据应用程序运行的云环境加载不同的配置文件。Confippet非常易于配置，可以根据各种客户需求进行定制。为了实现这一点，我们需要通过添加如下所示的<a class="ae jn" href="http://oneops.com/" rel="noopener ugc nofollow" target="_blank"> OneOps </a>配置文件来扩展<code class="du kr ks kt ku b">providers</code>，并将附加配置传递给<code class="du kr ks kt ku b">Confippet.presetConfig.autoLoad</code> api。</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="4c2c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">能够根据不同的客户需求扩展confippet是一个出色的特性，这使得它比<a class="ae jn" href="https://github.com/lorenwest/node-config/wiki/Configuration-Files#file-load-order" rel="noopener ugc nofollow" target="_blank"> <em class="kv">节点配置</em> </a> <em class="kv">更加强大。</em>流行的库和框架通常<em class="kv">适应不同的观点</em>。例如，Spring Framework支持灵活性，并且不会固执己见地认为事情应该如何完成。它从不同的角度支持广泛的应用需求。我们可以在这里阅读更多关于Spring框架设计哲学<a class="ae jn" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="2d63" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用Confippet的<code class="du kr ks kt ku b">composeConfig</code>特性进行更多的定制。更多信息，请阅读此处的<a class="ae jn" href="https://github.com/electrode-io/electrode-confippet#customization" rel="noopener ugc nofollow" target="_blank">和</a></p><h1 id="99c3" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">电极服务器+ Confippet —强大的组合</h1><p id="29e3" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/electrode-io/electrode-server" rel="noopener ugc nofollow" target="_blank">电极服务器</a>提供了一个标准化的节点web服务器，可以使用<a class="ae jn" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank"> Hapi.js </a>在<a class="ae jn" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>之上为您的web应用提供服务。电极服务器使用电极配置来引导web应用程序。在配置文件中，电极服务器标准化了我们配置日志设置的方式、与下游服务对话的客户端配置、可由前端代码访问的注册UI配置、引导索引页面的各种插件、收集指标等。，下面显示了配置的要点。在我们的生产就绪应用程序中，这些配置文件大约有100到300多行，具体取决于应用程序。</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="082a" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">规模经济</h1><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/c1cea5fae4049319cb42238c39a8340d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCj8YTAj3VB43NZH9ggk5w.jpeg"/></div></div></figure><p id="6779" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://www.electrode.io/" rel="noopener ugc nofollow" target="_blank">在</a> <a class="ae jn" href="https://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank">沃尔玛实验室</a>，<a class="ae jn" href="https://www.electrode.io/" rel="noopener ugc nofollow" target="_blank">电极</a>被整个公司用来驱动前端网络应用。如上所述，电极服务器和电极配置工具标准化了web应用程序的引导。同样，Electrode有大量的模块，可以帮助开发人员以多种方式构建web应用程序。因此，在一个团队中使用电极框架的开发人员可以无缝地在一个完全不同的电极web应用程序中工作，为网站中的不同页面提供动力，并且加速时间非常短。工程师已经熟悉电极模块如何协同工作、电极伪影如何产生、使用OneOps将电极构件部署到生产中的流程，以及如何在生产中监控电极应用。唯一缺少的是新应用程序的领域知识。本质上，电极有助于标准化在生产中如何构建、部署和监控web应用程序，这是一个强大的模型，提供了巨大的规模经济，并帮助组织更快地创新。电极成为共享词汇的一部分，使得更多的团队使用它来构建更新的web应用程序，在应用程序团队和电极平台团队之间创建了一个强大的反馈循环，以持续改进电极平台，并最终成为一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Snowball_effect" rel="noopener ugc nofollow" target="_blank">雪球效应</a>。编写一次，在任何地方运行是Sun Microsystems提出的口号，用来说明Java语言的跨平台优势。同样，Electrode体现了这样一个事实，即一个强大的平台能够让开发人员以标准化的方式构建、部署和监控web应用程序，从而提供巨大的规模经济，并真正帮助企业高效运营。</p><h1 id="e8e9" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="10b1" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">用于管理配置的电极配置工具是一个灵活的、可扩展的通用库，可以通过多种方式构建生产就绪型应用程序。我们展示了电极服务器如何使用电极配置程序在整个组织中以一致的方式引导web应用程序。我真诚地希望这篇博客帖子能够激发您开始研究Confippet模块的兴趣，最终推动您更深入地研究电极生态系统，并希望在您的公司中使用电极来构建强大的网络应用程序，就像我们在沃尔玛实验室所做的那样。</p><p id="057f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="md me ge" href="https://medium.com/u/e4a810d1adaf?source=post_page-----85bafe1c9a42--------------------------------" rel="noopener" target="_blank">马达夫·德弗肯达</a>和<a class="md me ge" href="https://medium.com/u/54a709eacdb7?source=post_page-----85bafe1c9a42--------------------------------" rel="noopener" target="_blank">亚历克斯·格里戈良</a>帮助我审阅和发表这篇博文。</p></div></div>    
</body>
</html>