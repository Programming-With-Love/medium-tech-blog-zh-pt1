<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/kotlin-demystified-scope-functions-57ca522895b1?source=collection_archive---------0-----------------------#2018-06-27">https://medium.com/androiddevelopers/kotlin-demystified-scope-functions-57ca522895b1?source=collection_archive---------0-----------------------#2018-06-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/9037088cef799057cbad0e8c1b3c63cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtPx96F_yaj5eLjHDPieKA.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><a class="ae hu" href="https://www.flickr.com/photos/photographingtravis/15283079263/" rel="noopener ugc nofollow" target="_blank">Hello My Name Is</a> by <a class="ae hu" href="https://www.flickr.com/photos/photographingtravis/" rel="noopener ugc nofollow" target="_blank">Travis Wise</a></figcaption></figure><p id="7ab1" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">无论是在编程中还是在现实世界中，名字都非常有用。用这种方式谈论某人要比记住某个任意的ID容易得多。给变量命名非常有用，事实上，甚至1944年8月初提交给学校的<a class="ae hu" href="https://en.wikipedia.org/wiki/Harvard_Mark_I" rel="noopener ugc nofollow" target="_blank">哈佛Mark I </a>也有给变量命名的能力。</p><p id="804b" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">虽然名字很有用，但是根据群体和情况的不同，同一个人可能会有不同的称呼:我、你、Nikki、Nicole、Google的Nicole等等。这类似于计算机科学中的<em class="iu"> scope </em>的工作方式。</p><h1 id="43ed" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><code class="du jt ju jv jw b">.let</code>谈谈作用域函数</h1><p id="22aa" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">Kotlin“范围函数”是允许改变变量的<em class="iu">范围</em>或范围的函数。Kotlin标准库中包含了五个这样的函数:<code class="du jt ju jv jw b">apply</code>、<code class="du jt ju jv jw b">run</code>、<code class="du jt ju jv jw b">with</code>、<code class="du jt ju jv jw b">let</code>和<code class="du jt ju jv jw b">also</code>。</p><p id="a145" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">这里有一个非常人为的例子:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="1e18" class="kk iw hx jw b fi kl km l kn ko">fun myFun() {<br/>    val outside = 6.2831853071<br/>    run {<br/>        val inside = 1.61803398875<br/>        // Both outside and inside are usable and in scope<br/>    }<br/>    // inside is out of scope, and only outside is available<br/>}</span></pre><p id="fca9" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">在那个例子中，我们使用<code class="du jt ju jv jw b">run</code>为<code class="du jt ju jv jw b">inside</code>创建了一个更小的<em class="iu">范围</em>。</p><h1 id="ae67" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><code class="du jt ju jv jw b">'this’</code>是接收器</h1><p id="0320" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">对于范围函数<code class="du jt ju jv jw b">apply</code>、<code class="du jt ju jv jw b">run</code>和<code class="du jt ju jv jw b">with</code>，最有用的特性之一是块内<code class="du jt ju jv jw b">this</code>引用的对象是调用中使用的变量。</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="816f" class="kk iw hx jw b fi kl km l kn ko">class Foo {<br/>    //...<br/>    myView.run {<br/>        // this refers to myView rather than Foo inside the block.<br/>        alpha = 0.5f<br/>        background = ContextCompat.getDrawable(context, R.drawable.my_drawable)<br/>    }<br/>}</span></pre><p id="39bf" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">这是因为<code class="du jt ju jv jw b">this</code>的<em class="iu">范围</em>已经变为<code class="du jt ju jv jw b">run</code>块内的<code class="du jt ju jv jw b">myView</code>。除此之外，如果我们想从前面访问<code class="du jt ju jv jw b">this</code>对象，我们可以像从内部类或匿名对象使用<code class="du jt ju jv jw b">this@Foo</code>那样做。</p><h1 id="0372" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">三个，呃…两个值</h1><p id="ccfe" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">因为作用域函数是函数，所以它们应该返回一个值，经过思考，人们可能会考虑这些值的三个候选值:</p><ul class=""><li id="b349" class="kp kq hx hy b hz ia id ie ih kr il ks ip kt it ku kv kw kx bi translated">物体本身</li><li id="5c5b" class="kp kq hx hy b hz ky id kz ih la il lb ip lc it ku kv kw kx bi translated">块的最后一个值</li><li id="dad5" class="kp kq hx hy b hz ky id kz ih la il lb ip lc it ku kv kw kx bi translated">N̶o̶t̶h̶i̶n̶g̶</li></ul><p id="975c" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">实际上，它没有理由永远没有<em class="iu">或</em>值(又名“单位”)，因为我们总是可以忽略它，这给我们留下了两种块值的可能性。</p><p id="4d0c" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">第一种选择是让值成为对象，也就是接收者本身。有点像建筑工人。这就是<code class="du jt ju jv jw b">apply</code>的工作原理。</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="3a34" class="kk iw hx jw b fi kl km l kn ko">val paint = Paint().apply {<br/>    color = Color.MAGENTA<br/>    style = Paint.Style.STROKE<br/>    textSize = textHeadlinePx<br/>}</span></pre><p id="2160" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">相当方便！我们可以在一条语句中创建<em class="iu">和</em>配置我们的<code class="du jt ju jv jw b">Paint</code>。</p><p id="31ab" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">第二个选项是函数类型，其中块的值是块中最后一条语句的值。这实际上是<em class="iu"/><code class="du jt ju jv jw b">run</code>和<code class="du jt ju jv jw b">with</code>共同完成的。</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="325e" class="kk iw hx jw b fi kl km l kn ko">val line = PoetryGenerator.obtain().run {<br/>    style = "Emily Dickinson"<br/>    style += "Lucille Clifton"<br/>    lines = 1<br/>    generate()<br/>}</span></pre><p id="71f0" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">这里我们得到一个对<code class="du jt ju jv jw b">PoetryGenerator</code>实例的引用，并在其上执行我们的配置。但是我们对<code class="du jt ju jv jw b">PoetryGenerator</code>本身不感兴趣，我们感兴趣的是它创造的诗歌。由于<code class="du jt ju jv jw b">run</code>会将<code class="du jt ju jv jw b">line</code>的值设置为上一条语句的值，所以我们要做的就是在最后调用<code class="du jt ju jv jw b">generate()</code>。<code class="du jt ju jv jw b">line</code>然后被设置为<code class="du jt ju jv jw b">generate()</code>的返回值。</p><p id="63e6" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated"><code class="du jt ju jv jw b">with</code>的工作方式完全相同，但是虽然可以编写<code class="du jt ju jv jw b">nullableVar?.run {...}</code>，但是使用<code class="du jt ju jv jw b">with</code>会有一点不同:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="0561" class="kk iw hx jw b fi kl km l kn ko">val hash = with(nullableGenerator) {<br/>    this?.configuration = config<br/>    this?.generate()<br/>}</span></pre><p id="ffb0" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">尽管<code class="du jt ju jv jw b">with</code>返回一个值，但它让我想起了<a class="ae hu" href="https://www.pascal-programming.info/lesson11.php#with" rel="noopener ugc nofollow" target="_blank"> Pascal </a>和<a class="ae hu" href="https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/with-end-with-statement#example" rel="noopener ugc nofollow" target="_blank"> VB </a>中的<code class="du jt ju jv jw b">with</code>关键字，这意味着我通常会像这样使用它:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="ea15" class="kk iw hx jw b fi kl km l kn ko">with (myConfig) {<br/>    data = value<br/>    autoRefresh = false<br/>    // ...etc...<br/>}</span></pre><h1 id="2c1e" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">我宁愿是“它”</h1><p id="e76f" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">有时将<code class="du jt ju jv jw b">this</code>的范围暂时转移到另一个对象会使事情变得更容易，但有时情况并非如此:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="0bc6" class="kk iw hx jw b fi kl km l kn ko">myIntent?.run { <br/>    data = this@MainActivity.data<br/>    startActivity(this)<br/>}</span></pre><p id="0772" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">呸！我们不仅要用一个<a class="ae hu" href="https://kotlinlang.org/docs/reference/this-expressions.html#qualified" rel="noopener ugc nofollow" target="_blank">限定这个</a>，仅仅是引用一个类属性，而且由于<code class="du jt ju jv jw b">myIntent</code>是被<code class="du jt ju jv jw b">this</code>引用的，所以对<code class="du jt ju jv jw b">startActivity</code>的调用看起来有点奇怪。</p><p id="4b84" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">幸运的是，这正是<code class="du jt ju jv jw b">also</code>和<code class="du jt ju jv jw b">let</code>的用武之地。在这种情况下，我们主要是想检查<code class="du jt ju jv jw b">myIntent</code>是否为空，只有当它不为空时才继续。在Kotlin中，惯用的方法是使用<code class="du jt ju jv jw b">let</code>范围函数:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="a5aa" class="kk iw hx jw b fi kl km l kn ko">myIntent?.let {<br/>    it.data = data<br/>    startActivity(it)<br/>}</span></pre><p id="2d1c" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated"><code class="du jt ju jv jw b">let</code>的工作方式与<code class="du jt ju jv jw b">run</code>完全一样，除了它不是被<code class="du jt ju jv jw b">this</code>引用，而是被<code class="du jt ju jv jw b">it</code>引用。</p><p id="2b63" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">至少如果你愿意的话。这也像预期的那样工作:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="d247" class="kk iw hx jw b fi kl km l kn ko">myIntent?.let { intent -&gt;<br/>    intent.data = data<br/>    startActivity(intent)<br/>}</span></pre><p id="6885" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">现在块内的<code class="du jt ju jv jw b">intent</code>引用了<code class="du jt ju jv jw b">myIntent</code>，这在您想要提供比<code class="du jt ju jv jw b">it</code>更多的上下文时会很有帮助。</p><p id="cf32" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">最后一个作用域函数<code class="du jt ju jv jw b">also</code>的工作方式类似于<code class="du jt ju jv jw b">apply</code>，但是，同样，对象是用<code class="du jt ju jv jw b">it</code>而不是<code class="du jt ju jv jw b">this</code>引用的。</p><p id="4c7d" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">这很有用，主要有两个原因。首先，它可以被认为是它的名字:创建一个对象，并对其执行以下操作:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="a77a" class="kk iw hx jw b fi kl km l kn ko">val myListener = Listener().also {<br/>    addListener(it)<br/>}</span></pre><p id="de61" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">但是当用一个不相关的物体或语句做某事时，它也非常有用。日志记录就是一个很好的例子:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="5b4b" class="kk iw hx jw b fi kl km l kn ko">val key: String get() = keystore.getKey(KEY_ID).also {<br/>    Log.v(TAG, "Read key at ${System.currentTimeMillis()}")<br/>}</span></pre><p id="71e5" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">日志甚至不使用对象。使用<code class="du jt ju jv jw b">also</code>允许我们添加日志消息，而不必修改其余的代码，然后，当不再需要日志时，很容易再次取出。</p><h1 id="cdb3" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">那有什么特别的？</h1><p id="70ca" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">“但是等等！”，你可能会说，“所有的函数和lambdas都创建新的作用域。这些有什么特别的？”是的，实际上我们在编写Kotlin的时候一直在创建新的作用域。例如:</p><pre class="kc kd ke kf fd kg jw kh ki aw kj bi"><span id="b9da" class="kk iw hx jw b fi kl km l kn ko">parentViewGroup.forEach { favoriteChild -&gt;<br/>    // Do something with favoriteChild…<br/>}</span></pre><p id="4ae7" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">这里，<code class="du jt ju jv jw b">favoriteChild</code>的作用域被限制在<code class="du jt ju jv jw b">forEach</code> lambda的内部，但是<code class="du jt ju jv jw b">forEach</code>不是作用域函数。他们有什么不同？</p><p id="0292" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">事实上，正是他们的平凡让他们与众不同。<code class="du jt ju jv jw b">forEach</code>、<code class="du jt ju jv jw b">map</code>、<code class="du jt ju jv jw b">filter</code>和许多其他的方法创建新的作用域，但是它们也迭代<code class="du jt ju jv jw b">Iterable</code>，或者执行映射、过滤值等等…</p><p id="985a" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">相反，作用域函数除了创建一个新的作用域之外什么也不做。Kotlin使这些功能的实现变得非常简单。</p><h1 id="9f1d" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">我该如何选择？</h1><p id="7e90" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">有很多关于作用域函数的讨论，包括帮助选择使用什么函数的流程图。</p><p id="5964" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">选择归结为:如果你想返回你开始的对象，那么你的选择是在<code class="du jt ju jv jw b">apply</code>和<code class="du jt ju jv jw b">also</code>之间。如果你想返回一个方法的结果，那么你需要查看<code class="du jt ju jv jw b">let</code>、<code class="du jt ju jv jw b">run</code>和<code class="du jt ju jv jw b">with</code>。</p><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ld"><img src="../Images/ca53604b6f7a2f323f91e35969888f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW1WkqmUnbJc1QEGzm59jg.png"/></div></div></figure><p id="ee0f" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">那么问题就在于引用对象的哪种方法更容易阅读和维护。</p><h1 id="5e70" class="iv iw hx bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">将<code class="du jt ju jv jw b">it</code>包起来</h1><p id="fd1f" class="pw-post-body-paragraph hv hw hx hy b hz jx ib ic id jy if ig ih jz ij ik il ka in io ip kb ir is it ha bi translated">我们讨论了Kotlin如何在标准库中包含五个作用域函数。其中的三个，<code class="du jt ju jv jw b">apply</code>、<code class="du jt ju jv jw b">run</code>和<code class="du jt ju jv jw b">with</code>，使用一个接收器将<code class="du jt ju jv jw b">this</code>的范围更改为对象，这样就可以访问它的公共属性和方法，而不需要通过变量名进行限定。</p><p id="9b33" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">我们讨论了剩下的两个，<code class="du jt ju jv jw b">let</code>和<code class="du jt ju jv jw b">also</code>如何获取对象并像参数一样使用它，允许用<code class="du jt ju jv jw b">it</code>或另一个名称引用它。</p><p id="9d57" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">最后，我们讨论了如何根据如何引用对象以及语句应该返回什么来选择使用哪个作用域函数。</p><p id="5b3b" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it ha bi translated">查看<a class="ae hu" href="https://medium.com/google-developers" rel="noopener"> Google开发者</a>博客，获取更多精彩内容，并关注更多关于Kotlin的文章！</p></div></div>    
</body>
</html>