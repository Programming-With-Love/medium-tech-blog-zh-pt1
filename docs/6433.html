<html>
<head>
<title>Simple Rails CRUD app with React Frontend, using ‘react-rails’ gem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的Rails CRUD应用程序，带有React前端，使用React-Rails gem</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/simple-rails-crud-app-with-react-frontend-using-react-rails-gem-b708b89a9419?source=collection_archive---------0-----------------------#2018-02-20">https://medium.com/quick-code/simple-rails-crud-app-with-react-frontend-using-react-rails-gem-b708b89a9419?source=collection_archive---------0-----------------------#2018-02-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4056" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Flatiron学校的训练营期间，我学会了如何创建使用Rails API后端和React前端的应用程序，这只是结合使用这两种技术的可能方式之一。我决定研究一个不同的场景，在这个场景中，开发人员利用gem“react-Rails”来直接在Rails javascript资产管道中创建和管理React组件。</p><p id="45d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我找到的最好的一篇文章是赫里斯托·乔尔杰夫写的:<a class="ae jc" href="https://www.pluralsight.com/guides/ruby-ruby-on-rails/building-a-crud-interface-with-react-and-ruby-on-rails" rel="noopener ugc nofollow" target="_blank">https://www . plural sight . com/guides/ruby-ruby-on-rails/building-a-crud-interface-with-react-and-ruby-on-rails</a>。然而，在工作之后，我注意到它主要使用了旧的React语法，以及过时的“refs”用法。这篇博客的目标是展示一个构建非常基本的CRUD应用程序的类似教程，但是稍微更新了一下React语法。</p><h2 id="af5b" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">用一个模型创建新的Rails应用程序</h2><p id="3e44" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们将开始创建一个新的Rails应用程序，运行以下命令:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="1a0b" class="jd je hh ki b fi km kn l ko kp">rails new fruits-app</span></pre><p id="70fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一个标题到Gemfile并添加<code class="du kq kr ks ki b">gem 'react-rails'</code>，下一次运行</p><p id="2266" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kq kr ks ki b">bundle install</code></p><p id="4cf2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后</p><p id="4d58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kq kr ks ki b">rails g react:install</code></p><p id="11ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">React:安装我们在这里使用的生成器会自动将React JS库添加到您的资产管道中。</p><p id="3404" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将要使用的模型是<strong class="ig hi">水果</strong>，所以让我们继续生成它:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="f021" class="jd je hh ki b fi km kn l ko kp">rails g model Fruit name:string description:text</span></pre><p id="9e8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">跳转到db/seeds.rb文件并创建一些示例项目:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="8e47" class="jd je hh ki b fi km kn l ko kp">fruits = ['Mango', 'Pineapple', 'Passion fruit', 'Dragonfruit']</span><span id="989e" class="jd je hh ki b fi kt kn l ko kp">fruits.each{|fruit| Fruit.create(name: fruit, description: "I am a delicious #{fruit}.")}</span></pre><p id="34b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">迁移数据库并设定种子:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="361b" class="jd je hh ki b fi km kn l ko kp">rake db:migrate db:seed</span></pre><p id="0d37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">控制器</strong></p><p id="7087" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们只需要对应用程序控制器做一个调整。因此，在app/controllers/application _ controller . Rb中粘贴以下代码行:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="4fb1" class="jd je hh ki b fi km kn l ko kp">class ApplicationController &lt; ActionController::Base<br/><strong class="ki hi"> protect_from_forgery with: :null_session</strong><br/>end</span></pre><p id="200b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的应用程序是基于API的，因此控制器文件夹结构要求我们遵循API版本规范的命名空间约定，例如:app/controllers/api/v1。对API进行版本控制意味着将来可以对其进行更改，而不会破坏原始版本。</p><p id="e3b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，让我们在app/controllers中创建这两个降序文件夹(api和v1 ),并在其中创建一个名为<code class="du kq kr ks ki b">fruits_controller.rb</code>的新文件</p><p id="c35e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的水果控制器中，让我们定义CRUD动作。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="181f" class="jd je hh ki b fi km kn l ko kp">class Api::V1::FruitsController &lt; <!-- -->ApplicationController<br/>  def index<br/>    render json: Fruit.all<br/>  end<br/><br/>  def create<br/>    fruit = Fruit.create(fruit_params)<br/>    render json: fruit<br/>  end<br/><br/>  def destroy<br/>    Fruit.destroy(params[:id])<br/>  end<br/><br/>  def update<br/>    fruit = Fruit.find(params[:id])<br/>    fruit.update_attributes(fruit_params)<br/>    render json: fruit<br/>  end<br/><br/>  private<br/><br/>  def fruit_params<br/>    params.require(:fruit).permit(:id, :name, :description)<br/>  end<br/>end</span></pre><h2 id="32b1" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">路由控制器</h2><p id="2290" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">让我们浏览config/routes.rb并设置所有必要的CRUD路径:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="aaa7" class="jd je hh ki b fi km kn l ko kp">Rails.application.routes.draw do <br/>  namespace :api do <br/>    namespace :v1 do <br/>     resources :fruits, only: [:index, :create, :destroy, :update]<br/>    end <br/>  end <br/>end</span></pre><p id="79d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此时，如果您在浏览器中导航到<a class="ae jc" href="http://localhost:3000/api/v1/fruits.json" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/v1/fruits . json</a>，您应该会看到JSON和我们的4个水果。酷！</p><p id="d3d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们在相应的新文件<code class="du kq kr ks ki b">app/controllers/home_controller.rb</code>中再创建一个名为Home的控制器，它将只负责一个索引页面，我们将在这里执行所有的React魔法。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b23e" class="jd je hh ki b fi km kn l ko kp">class HomeController &lt; ApplicationController<br/>  def index<br/>  end<br/>end</span></pre><p id="9aca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们回到<code class="du kq kr ks ki b">config/routes.rb</code>一会儿，添加我们的主页索引页面作为根:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="e533" class="jd je hh ki b fi km kn l ko kp">root to: 'home#index'</span></pre><p id="6154" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的索引页面只需要一个相应的视图。在<code class="du kq kr ks ki b">app/views</code>中创建一个新的“home”文件夹，并向其中添加index.html.erb文件:</p><p id="57b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kq kr ks ki b">app/views/home/index.html.erb</code></p><p id="e60e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该文件将只包含一行利用了<strong class="ig hi"> react_component </strong>视图助手的代码，该助手随<strong class="ig hi">‘react-rails’</strong>gem一起提供。现在还不行，但过一会儿一切都会变得有意义。</p><p id="6b93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kq kr ks ki b">&lt;%= react_component 'Main' %&gt;</code></p><p id="31ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建我们的第一个React组件</strong></p><p id="7c25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个名为<code class="du kq kr ks ki b">app/assets/javascripts/components/_main.js.jsx</code>的文件</p><p id="c51e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将遵循创建无状态/表示性React组件的常用语法，我们将称之为<strong class="ig hi"> Main </strong>:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="eb39" class="jd je hh ki b fi km kn l ko kp">const Main = (props) =&gt; {<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Fruits are great!&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="cca3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在浏览器中转至<strong class="ig hi"> localhost:3000 </strong>，亲自查看我们的第一个组件已加载到页面上。相当酷！</p><p id="892d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">显示所有水果</strong></p><p id="16fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建下一个显示水果列表的组件。创建一个名为<code class="du kq kr ks ki b">app/assets/javascripts/components/_all_fruits.js.jsx</code>的新文件，并定义一个名为<strong class="ig hi"> AllFruits </strong>的新组件:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="6f7b" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">AllFruits</strong> extends <strong class="ki hi">React.Component</strong> {</span><span id="4670" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;h1&gt;To do: List of fruits&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="b1b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，让我们将这个组件放入我们的主组件中，并确保它成功加载到页面中。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="f8c8" class="jd je hh ki b fi km kn l ko kp">const<strong class="ki hi"> Main</strong> = (props) =&gt; {<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Fruits are great!&lt;/h1&gt;<br/>        <strong class="ki hi">&lt;AllFruits /&gt;</strong><br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="4400" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是为<strong class="ig hi"> AllFruits </strong>组件创建一个状态，并从我们的API中获取所有的水果，最后使用this.setState()更新在构造函数中创建的空状态。在下一步中，我们将添加处理获取请求的构造函数和componentDidMount()生命周期挂钩:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9d07" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">AllFruits</strong> extends <strong class="ki hi">React.Component</strong> {<br/>  <br/> <strong class="ki hi"> constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      fruits: []<br/>    };<br/>  }</strong></span><span id="afe2" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">  componentDidMount(){<br/>    fetch('/api/v1/fruits.json')<br/>      .then((response) =&gt; {return response.json()})<br/>      .then((data) =&gt; {this.setState({ fruits: data }) });<br/>  }</strong></span><span id="6e30" class="jd je hh ki b fi kt kn l ko kp">  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;To do: List of fruits&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>     )<br/>   }<br/>}</span></pre><p id="1508" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们将更新<strong class="ig hi"> AllFruits </strong>组件的render()方法，以迭代状态中的每个水果，显示每个项目的名称和描述。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="359c" class="jd je hh ki b fi km kn l ko kp">render(){<br/> <strong class="ki hi">var fruits = this.state.fruits.map((fruit) =&gt; {<br/>  return(<br/>   &lt;div key={fruit.id}&gt;<br/>    &lt;h1&gt;{fruit.name}&lt;/h1&gt;<br/>    &lt;p&gt;{fruit.description}&lt;/p&gt;<br/>   &lt;/div&gt;<br/>  )<br/> })</strong></span><span id="cdfa" class="jd je hh ki b fi kt kn l ko kp"> return(<br/>  &lt;div&gt;<br/>   <strong class="ki hi">{fruits}</strong><br/>  &lt;/div&gt;<br/> )<br/>}</span></pre><p id="7bbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你会注意到我们使用了一个额外的<strong class="ig hi"> key </strong>属性，我们将其设置为等于<strong class="ig hi"> fruit.id </strong>。这是我们以后引用相似项目列表中的特定项目的方式，也是React中的一个需求。强烈推荐2021年<a class="ae jc" href="https://blog.coursesity.com/best-react-js-tutorials/" rel="noopener ugc nofollow" target="_blank">学React </a>。前往localhost:3000查看我们最初的水果清单！</p><p id="3c42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">添加新水果</strong></p><p id="7414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们创建新的水果组件和表单之前，让我们暂停一下，稍微修改一下我们的应用程序结构。我们希望有一个主要组件来处理<strong class="ig hi">水果</strong>状态的所有变化。让我们再创建一个名为Body的更高级别的<strong class="ig hi">容器</strong>组件，并移动带有state的构造函数，以及componentDidMount()从<strong class="ig hi"> AllFruits </strong>获取部分代码到<strong class="ig hi"> Body </strong>。创建一个新文件<code class="du kq kr ks ki b">/app/assets/javascripts/components/_body.js.jsx</code></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9980" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Body</strong> extends <strong class="ki hi">React.Component</strong> {</span><span id="7a27" class="jd je hh ki b fi kt kn l ko kp">constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      fruits: []<br/>    };<br/>  }</span><span id="1006" class="jd je hh ki b fi kt kn l ko kp">componentDidMount(){<br/>    fetch('/api/v1/fruits.json')<br/>      .then((response) =&gt; {return response.json()})<br/>      .then((data) =&gt; {this.setState({ fruits: data }) });<br/>  }</span><span id="9677" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        <strong class="ki hi">&lt;AllFruits fruits={this.state.fruits} /&gt;</strong><br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="60c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新的AllFruits组件可以修改为无状态/表示性的:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="5054" class="jd je hh ki b fi km kn l ko kp"><strong class="ki hi">const AllFruits = (props) =&gt; {</strong></span><span id="023f" class="jd je hh ki b fi kt kn l ko kp">var fruits = <strong class="ki hi">props.fruits</strong>.map((fruit) =&gt; {<br/>    return(<br/>      &lt;div key={fruit.id}&gt;<br/>        &lt;h1&gt;{fruit.name}&lt;/h1&gt;<br/>        &lt;p&gt;{fruit.description}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  })</span><span id="d1cd" class="jd je hh ki b fi kt kn l ko kp">return(<br/>      &lt;div&gt;<br/>       <strong class="ki hi"> {fruits}</strong><br/>      &lt;/div&gt;<br/>    )<br/><strong class="ki hi">}</strong></span></pre><p id="39b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新的主要组件:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="311a" class="jd je hh ki b fi km kn l ko kp">const Main = (props) =&gt; {<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Fruits are great!&lt;/h1&gt;<br/>       <strong class="ki hi"> &lt;Body /&gt;</strong><br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="7002" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在从这个更高层次的Body组件内部渲染AllFruits组件，从而将水果作为道具传递给它。检查你的浏览器，看看你是否正确地完成了所有的事情，然后我们的水果清单就会显示出来。</p><p id="32a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以向页面添加一个用于创建新水果的表单。创建一个新文件<code class="du kq kr ks ki b">/app/assets/javascripts/components/_new_item.js.jsx</code>并用一个包含两个字段的简单表单定义一个新组件NewFruit:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="2e92" class="jd je hh ki b fi km kn l ko kp">const <strong class="ki hi">NewFruit</strong> = (props) =&gt; {</span><span id="15ce" class="jd je hh ki b fi kt kn l ko kp">  let formFields = {}<br/> <br/>  return(<br/>    &lt;form&gt;<br/>    <strong class="ki hi"> &lt;input ref={input =&gt; formFields.name = input} placeholder='Enter the name of the item'/&gt;<br/>     &lt;input ref={input =&gt; formFields.description = input} placeholder='Enter a description' /&gt;<br/>     &lt;button&gt;Submit&lt;/button&gt;</strong><br/>    &lt;/form&gt;<br/>  )<br/>}</span></pre><p id="2169" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你注意到那些<code class="du kq kr ks ki b">ref = {input =&gt; formFields.name = input}</code>了吗？类似于我们迭代中的<strong class="ig hi">键</strong>，我们使用<strong class="ig hi">引用</strong>来访问某个DOM元素。在这种情况下，它将允许我们抓住我们的投入的价值。在我们的应用程序中，我将表单输入存储在一个对象formFields中，这样我们就可以稍后使用onClick()事件处理程序将字段值传递给父组件，我们将把该事件处理程序放在button中。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="e8ab" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Body</strong> extends<strong class="ki hi"> React.Component</strong> {</span><span id="a648" class="jd je hh ki b fi kt kn l ko kp">constructor(props) {<br/>    ...<br/>  }</span><span id="e88f" class="jd je hh ki b fi kt kn l ko kp">componentDidMount(){<br/>    ...<br/>  }</span><span id="f39f" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        <strong class="ki hi">&lt;NewFruit /&gt;</strong><br/>        &lt;AllFruits fruits={this.state.fruits} /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="fb12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将<strong class="ig hi"> NewFruit </strong>组件放入<strong class="ig hi"> Body </strong>中，您将看到我们新制作的表单出现在浏览器中。</p><p id="d30f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是让我们的<strong class="ig hi">提交</strong>按钮工作。</p><p id="59bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Body组件中，我们将创建handleFormSubmit()函数，它从表单中接收名称和描述作为参数。现在，它将只是console.log()参数，让我们看看它是否全部工作。我们还将把这个handleFormSubmit()函数作为道具传递给<strong class="ig hi"> NewFruit </strong>组件。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9540" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Body</strong> extends<strong class="ki hi"> React.Component </strong>{</span><span id="3f03" class="jd je hh ki b fi kt kn l ko kp">constructor(props) {<br/>  ...<br/>  <strong class="ki hi">this.handleFormSubmit = this.handleFormSubmit.bind(this)</strong><br/>}</span><span id="634a" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">handleFormSubmit(name, description){<br/>    console.log(name, description)<br/>}</strong></span><span id="9bd3" class="jd je hh ki b fi kt kn l ko kp">componentDidMount(){<br/>   ...<br/>  }</span><span id="cd59" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;NewFruit <strong class="ki hi">handleFormSubmit={this.handleFormSubmit}</strong>/&gt;<br/>        &lt;AllFruits fruits={this.state.fruits}  /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="f545" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">至于我们的NewFruit组件，我们所要做的就是向表单标签添加一个Submit事件处理程序，它将从字段中传递值作为道具。我还将我们的事件(e)作为参数传递，以便在表单提交后清除字段:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="8e78" class="jd je hh ki b fi km kn l ko kp">const <strong class="ki hi">NewFruit </strong>= (props) =&gt; {<br/>  <br/>    let formFields = {}<br/> <br/>    return(<br/>      &lt;form <strong class="ki hi">onSubmit={ (e) =&gt; { <br/>            </strong>e.preventDefault();<br/>            <strong class="ki hi">props.handleFormSubmit(<br/>              formFields.name.value,<br/>              formFields.description.value<br/>            ); <br/>            e.target.reset();}<br/>        }</strong>&gt;<br/>        &lt;input ref={input =&gt; formFields.name = input} placeholder='Enter the name of the item'/&gt;<br/>        &lt;input ref={input =&gt; formFields.description = input} placeholder='Enter a description' /&gt;<br/>        &lt;button&gt;Submit&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    )<br/>}</span></pre><p id="a043" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们回到身体，实际上处理新水果的整个创作。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="74ea" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Body</strong> extends <strong class="ki hi">React.Component</strong> {</span><span id="5a30" class="jd je hh ki b fi kt kn l ko kp">  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      fruits: []<br/>    };<br/>   <strong class="ki hi"> this.handleFormSubmit = this.handleFormSubmit.bind(this)<br/>    this.addNewFruit = this.addNewFruit.bind(this)</strong><br/>  }</span><span id="7eb2" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">  handleFormSubmit(name, description){<br/>    let body = JSON.stringify({fruit: {name: name, description:   description} })</strong></span><span id="f02c" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">  fetch('</strong><a class="ae jc" href="http://localhost:3000/api/v1/fruits'" rel="noopener ugc nofollow" target="_blank"><strong class="ki hi">http://localhost:3000/api/v1/fruits'</strong></a><strong class="ki hi">, {<br/>      method: 'POST',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      body: body,<br/>    }).then((response) =&gt; {return response.json()})<br/>    .then((fruit)=&gt;{<br/>      this.addNewFruit(fruit)<br/>    })<br/>    <br/>  }</strong></span><span id="fb4c" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">  addNewFruit(fruit){<br/>    this.setState({<br/>      fruits: this.state.fruits.concat(fruit)<br/>    })<br/>  }</strong></span><span id="6aef" class="jd je hh ki b fi kt kn l ko kp">componentDidMount(){<br/>    fetch('/api/v1/fruits.json')<br/>      .then((response) =&gt; {return response.json()})<br/>      .then((data) =&gt; {this.setState({ fruits: data }) });<br/>  }</span><span id="852d" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;NewFruit handleFormSubmit={this.handleFormSubmit}/&gt;<br/>        &lt;AllFruits fruits={this.state.fruits}  /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="157e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那里刚刚发生了很多事情。在<strong class="ig hi"> handleFormSubmit() </strong>内部，我们现在使用<strong class="ig hi"> fetch() </strong>向后端发送一个POST请求，其中包含我们新的水果数据。一旦返回promise，我们就调用新函数<strong class="ig hi"> handleAddNewFruit() </strong>，该函数将返回的Fruit对象作为参数，并使用this.setState()更新状态，以便立即将这个新的fruit加载到页面。相当整洁！现在你可以打开浏览器，亲自看看它是如何工作的。</p><p id="68bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">删除一个水果</strong></p><p id="0784" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为我们的水果模型实现完整CRUD功能的下一步是处理水果删除。</p><p id="daf4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我们已经将所有的水果作为一个列表加载到all fruits中。但是，将水果作为一个单独的实体并将其移动到一个单独的水果组件中是一个很好的做法。就这么办吧！</p><p id="784f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个新文件<code class="du kq kr ks ki b">app/assets/javascripts/components/_fruit.js.jsx</code>。下面是我们的水果组件现在的样子:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="f329" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Fruit</strong> extends <strong class="ki hi">React.Component</strong>{<br/>  <br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{<strong class="ki hi">this.props.fruit.name</strong>}&lt;/h1&gt;<br/>        &lt;p&gt;{<strong class="ki hi">this.props.fruit.description</strong>}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="8286" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所见，我们使用this.props.fruit加载名称和描述。这意味着我们将从父AllItems组件中传递整个水果对象作为道具，如下所示:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b099" class="jd je hh ki b fi km kn l ko kp">const <strong class="ki hi">AllFruits</strong> = (props) =&gt; {</span><span id="0fac" class="jd je hh ki b fi kt kn l ko kp">var fruits = props.fruits.map((fruit) =&gt; {<br/>    return(<br/>      &lt;div key={fruit.id}&gt;<br/>       <strong class="ki hi">&lt;Fruit fruit={fruit}/&gt;</strong><br/>      &lt;/div&gt;<br/>    )<br/>  })</span><span id="33a3" class="jd je hh ki b fi kt kn l ko kp">return(<br/>      &lt;div&gt;<br/>        {fruits}<br/>      &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="7a60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">再次检查浏览器，看看您是否正确地实现了所有的更改。页面看起来应该和以前完全一样，所有的水果应该和我们新的水果表单一起显示。</p><p id="b31a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们给水果添加<strong class="ig hi">删除</strong>按钮。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d024" class="jd je hh ki b fi km kn l ko kp">class<strong class="ki hi"> Fruit </strong>extends <strong class="ki hi">React.Component</strong>{<br/>  <br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.props.fruit.name}&lt;/h1&gt;<br/>        &lt;p&gt;{this.props.fruit.description}&lt;/p&gt;<br/>        <strong class="ki hi">&lt;button onClick={() =&gt; this.props.handleDelete()}&gt;Delete&lt;/button&gt;</strong><br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="26f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还没有创建<strong class="ig hi"> handleDelete() </strong>函数，但是它将作为一个道具从Body传递给AllItems，然后传递给Fruit组件。让我们继续在Body组件中定义该函数，在构造函数中绑定它，并作为一个prop传递给AllFruits:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="0b20" class="jd je hh ki b fi km kn l ko kp">class Body extends React.Component {</span><span id="3c05" class="jd je hh ki b fi kt kn l ko kp">constructor(props) {<br/>    ...<br/>   <strong class="ki hi"> this.handleDelete = this.handleDelete.bind(this)</strong><br/>  }</span><span id="fafa" class="jd je hh ki b fi kt kn l ko kp"> <strong class="ki hi"> handleDelete(id){<br/>    fetch(`</strong><a class="ae jc" href="http://localhost:3000/api/v1/items/${id}`" rel="noopener ugc nofollow" target="_blank"><strong class="ki hi">http://localhost:3000/api/v1/fruits/${id}`</strong></a><strong class="ki hi">, <br/>    {<br/>      method: 'DELETE',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      }<br/>    }).then((response) =&gt; { <br/>        console.log('Item was deleted!')<br/>      })<br/>  }</strong></span><span id="4190" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;NewFruit handleFormSubmit={this.handleFormSubmit}/&gt;<br/>        &lt;AllFruits fruits={this.state.fruits} <strong class="ki hi">handleDelete={this.handleDelete}</strong>/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="c012" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的handleDelete()的工作方式如下:它接收fruit的id，使用<strong class="ig hi"> fetch() </strong>和(目前)console.logs <strong class="ig hi">向具有该id的fruit route发送一个<strong class="ig hi"> DELETE </strong>请求，“项目已删除！”</strong>。</p><p id="c1e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们接下来的步骤:</p><ol class=""><li id="90d5" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">确保所有水果通过<strong class="ig hi">手柄删除</strong>作为水果组件的道具。</li></ol><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="f3a3" class="jd je hh ki b fi km kn l ko kp">const <strong class="ki hi">AllFruits</strong> = (props) =&gt; {</span><span id="23b1" class="jd je hh ki b fi kt kn l ko kp">var fruits = props.fruits.map((fruit) =&gt; {<br/>    return(<br/>      &lt;div key={fruit.id}&gt;<br/>       &lt;Fruit fruit={fruit} <strong class="ki hi">handleDelete={props.handleDelete}</strong>/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  })</span><span id="2e0f" class="jd je hh ki b fi kt kn l ko kp">...<br/>}</span></pre><p id="a2ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.从水果组件中传递水果的<strong class="ig hi"> id </strong>。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="8f47" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Fruit</strong> extends<strong class="ki hi"> React.Component</strong>{<br/>  <br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.props.fruit.name}&lt;/h1&gt;<br/>        &lt;p&gt;{this.props.fruit.description}&lt;/p&gt;<br/>        &lt;button <strong class="ki hi">onClick={() =&gt; this.props.handleDelete(this.props.fruit.id)}</strong>&gt;Delete&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="60bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.创建一个处理从状态中删除项目的函数，这样它会立即从页面中删除，而无需刷新。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="2f27" class="jd je hh ki b fi km kn l ko kp">class Body extends React.Component {</span><span id="bd4c" class="jd je hh ki b fi kt kn l ko kp">constructor(props) {<br/>    ...<br/>    this.handleDelete = this.handleDelete.bind(this)<br/>    <strong class="ki hi">this.deleteFruit = this.deleteFruit.bind(this)</strong><br/>  }</span><span id="c6a5" class="jd je hh ki b fi kt kn l ko kp">...</span><span id="55f0" class="jd je hh ki b fi kt kn l ko kp">handleDelete(id){<br/>    fetch(`<a class="ae jc" href="http://localhost:3000/api/v1/items/${id}`" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/items/${id}`</a>, <br/>    {<br/>      method: 'DELETE',<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      }<br/>    }).then((response) =&gt; { <br/>        <strong class="ki hi">this.deleteFruit(id)</strong><br/>      })<br/>  }</span><span id="549e" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">deleteFruit(id){<br/>    newFruits = this.state.fruits.filter((fruit) =&gt; fruit.id !== id)<br/>    this.setState({<br/>      fruits: newFruits<br/>    })<br/>  }</strong></span><span id="e9f4" class="jd je hh ki b fi kt kn l ko kp">componentDidMount(){<br/>  ...<br/>  }</span><span id="77ca" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>   return(<br/>      &lt;div&gt;<br/>        &lt;NewFruit handleFormSubmit={this.handleFormSubmit}/&gt;<br/>        &lt;AllFruits fruits={this.state.fruits} <strong class="ki hi">handleDelete={this.handleDelete}</strong>/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="114c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，除了React，<a class="ae jc" href="https://blog.coursesity.com/best-ruby-on-rails-tutorials/" rel="noopener ugc nofollow" target="_blank"> ruby on rails教程</a>可以帮助你更自由地探索应用开发过程。就是这样！前往浏览器，删除所有你讨厌的水果！</p><p id="29a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">编辑一个水果</strong></p><p id="14d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了完成CRUD功能，我们只剩下编辑/更新水果的能力了。让我们这样做吧。</p><p id="9471" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们修改我们的水果组件，创建一个带有'<strong class="ig hi"> editable' </strong>属性的状态，并添加一个编辑按钮。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9b00" class="jd je hh ki b fi km kn l ko kp">class <strong class="ki hi">Fruit</strong> extends <strong class="ki hi">React.Component</strong>{</span><span id="fb44" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      editable: false<br/>    }<br/>  }</strong><br/>  <br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.props.fruit.name}&lt;/h1&gt;<br/>        &lt;p&gt;{this.props.fruit.description}&lt;/p&gt;<br/>       <strong class="ki hi"> &lt;button&gt;{this.state.editable? 'Submit' : 'Edit'}&lt;/button&gt;</strong><br/>        &lt;button onClick={() =&gt; this.props.handleDelete(this.props.fruit.id)}&gt;Delete&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="2dd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们将修改渲染水果的方式。根据state. <strong class="ig hi"> editable </strong>值，它将呈现名称和描述或输入字段来编辑该水果。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="8c13" class="jd je hh ki b fi km kn l ko kp">class Fruit extends React.Component{</span><span id="6880" class="jd je hh ki b fi kt kn l ko kp">constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      <strong class="ki hi">editable: false</strong><br/>    }<br/>  }<br/>  <br/>  render(){<br/>   <strong class="ki hi"> let name = this.state.editable ? &lt;input type='text' ref={input =&gt; this.name = input} defaultValue={this.props.fruit.name}/&gt;:&lt;h3&gt;{this.props.fruit.name}&lt;/h3&gt;<br/>    let description = this.state.editable ? &lt;input type='text' ref={input =&gt; this.description = input} defaultValue={this.props.fruit.description}/&gt;:&lt;p&gt;{this.props.fruit.description}&lt;/p&gt;</strong><br/>    return(<br/>      &lt;div&gt;<br/>       <strong class="ki hi"> {name}</strong><br/>       <strong class="ki hi"> {description}</strong><br/>        &lt;button&gt;{this.state.editable? 'Submit' : 'Edit'}&lt;/button&gt;<br/>        &lt;button onClick={() =&gt; this.props.handleDelete(this.props.fruit.id)}&gt;Delete&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="4f71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，让我们向编辑按钮添加一个onClick()事件处理程序，并创建处理编辑的实际函数:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="dbb4" class="jd je hh ki b fi km kn l ko kp">class Fruit extends React.Component{</span><span id="ae0b" class="jd je hh ki b fi kt kn l ko kp">constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      editable: false<br/>    }<br/>    <strong class="ki hi">this.handleEdit = this.handleEdit.bind(this)</strong><br/>  }</span><span id="78e0" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi"> handleEdit(){<br/>    this.setState({<br/>      editable: !this.state.editable<br/>    })<br/>  }</strong><br/>  <br/>  render(){<br/>    let name = this.state.editable ? &lt;input type='text' ref={input =&gt; this.name = input} defaultValue={this.props.fruit.name}/&gt;:&lt;h3&gt;{this.props.fruit.name}&lt;/h3&gt;<br/>    let description = this.state.editable ? &lt;input type='text' ref={input =&gt; this.description = input} defaultValue={this.props.fruit.description}/&gt;:&lt;p&gt;{this.props.fruit.description}&lt;/p&gt;<br/>    return(<br/>      &lt;div&gt;<br/>        {name}<br/>        {description}<br/>        &lt;button <strong class="ki hi">onClick={() =&gt; this.handleEdit()}</strong>&gt;{this.state.editable? 'Submit' : 'Edit'}&lt;/button&gt;<br/>        &lt;button onClick={() =&gt; this.props.handleDelete(this.props.fruit.id)}&gt;Delete&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="2a5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，这个按钮所做的只是在点击时改变我们的<strong class="ig hi">可编辑</strong>属性。</p><p id="6403" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像删除操作一样，实际的更新操作以及对后端的PUT请求将发生在更高级别的组件主体中。因此，让我们创建发送PUT请求并相应更新水果状态的函数。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d039" class="jd je hh ki b fi km kn l ko kp">class Body extends React.Component {</span><span id="4477" class="jd je hh ki b fi kt kn l ko kp">  constructor(props) {<br/>    ...<br/>    <strong class="ki hi">this.handleUpdate = this.handleUpdate.bind(this);<br/>    this.updateFruit = this.updateFruit.bind(this)</strong><br/>  }</span><span id="c90a" class="jd je hh ki b fi kt kn l ko kp">  <strong class="ki hi">handleUpdate(fruit){<br/>    fetch(`</strong><a class="ae jc" href="http://localhost:3000/api/v1/fruit/${fruit.id}`" rel="noopener ugc nofollow" target="_blank"><strong class="ki hi">http://localhost:3000/api/v1/fruits/${fruit.id}`</strong></a><strong class="ki hi">, <br/>    {<br/>      method: 'PUT',<br/>      body: JSON.stringify({fruit: fruit}),<br/>      headers: {<br/>        'Content-Type': 'application/json'<br/>      }<br/>    }).then((response) =&gt; { <br/>        this.updateFruit(fruit)<br/>      })<br/>  }</strong></span><span id="08f3" class="jd je hh ki b fi kt kn l ko kp"><strong class="ki hi">  updateFruit(fruit){<br/>    let newFruits = this.state.fruits.filter((f) =&gt; f.id !== fruit.id)<br/>    newFruits.push(fruit)<br/>    this.setState({<br/>      fruits: newFruits<br/>    })<br/>  }</strong></span><span id="b77e" class="jd je hh ki b fi kt kn l ko kp"><br/> componentDidMount(){<br/>    fetch('/api/v1/items.json')<br/>      .then((response) =&gt; {return response.json()})<br/>      .then((data) =&gt; {this.setState({ items: data }) });<br/>  }</span><span id="1417" class="jd je hh ki b fi kt kn l ko kp">render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;NewItem handleSubmit = {this.handleSubmit} /&gt;<br/>        &lt;AllItems items={this.state.items} handleDelete = {this.handleDelete} <strong class="ki hi">handleUpdate = {this.handleUpdate}</strong>/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="0fbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们再次定义了两个函数:<strong class="ig hi"> handleUpdate() </strong>将水果作为参数并向后端发送PUT请求，以及<strong class="ig hi"> updateFruit() </strong>在浏览器中用更新的信息无缝更新水果。<strong class="ig hi"> handleUpdate() </strong>作为道具传递给AllItems，AllItems将其作为道具传递给Fruit:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="cbd0" class="jd je hh ki b fi km kn l ko kp">const AllFruits = (props) =&gt; {</span><span id="ab98" class="jd je hh ki b fi kt kn l ko kp">var fruits = props.fruits.map((fruit) =&gt; {<br/>    return(<br/>      &lt;div key={fruit.id}&gt;<br/>       &lt;Fruit fruit={fruit} handleDelete={props.handleDelete} <strong class="ki hi">handleUpdate={props.handleUpdate}</strong>/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  })</span><span id="ab7d" class="jd je hh ki b fi kt kn l ko kp">...<br/>}</span></pre><p id="fd97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">快到了！！！剩下的工作就是创建一个合适的水果对象，并将其从水果组件传递给handleUpdate函数，该函数在水果的handleEdit函数中调用。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="bef4" class="jd je hh ki b fi km kn l ko kp">class Fruit extends React.Component{</span><span id="fd4f" class="jd je hh ki b fi kt kn l ko kp">constructor(props){<br/>    ...<br/>    <strong class="ki hi">this.handleEdit = this.handleEdit.bind(this)</strong><br/>  }</span><span id="e8e0" class="jd je hh ki b fi kt kn l ko kp">handleEdit(){<br/>   <strong class="ki hi">if(this.state.editable){<br/>      let name = this.name.value<br/>      let description = this.description.value<br/>      let id = this.props.fruit.id<br/>      let fruit = {id: id, name: name, description: description}<br/>      this.props.handleUpdate(fruit)<br/>    }</strong><br/>    this.setState({<br/>      editable: !this.state.editable<br/>    })<br/>  }<br/>  <br/>  render(){<br/>    let name = this.state.editable ? &lt;input type='text' ref={input =&gt; this.name = input} defaultValue={this.props.fruit.name}/&gt;:&lt;h3&gt;{this.props.fruit.name}&lt;/h3&gt;<br/>    let description = this.state.editable ? &lt;input type='text' ref={input =&gt; this.description = input} defaultValue={this.props.fruit.description}/&gt;:&lt;p&gt;{this.props.fruit.description}&lt;/p&gt;<br/>    return(<br/>      &lt;div&gt;<br/>        {name}<br/>        {description}<br/>        &lt;button onClick={() =&gt; this.handleEdit()}&gt;{this.state.editable? 'Submit' : 'Edit'}&lt;/button&gt;<br/>        &lt;button onClick={() =&gt; this.props.handleDelete(this.props.fruit.id)}&gt;Delete&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )      <br/>  }<br/>}</span></pre><p id="3900" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就是这样！现在你可以用你的水果完成所有的脏动作了。这篇博文中有很多代码，我们在每一步都做了大量的修改，所以如果你想看完整的应用程序代码，请点击这里:</p><p id="171c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://github.com/nothingisfunny/fruits-crud-react-rails-app" rel="noopener ugc nofollow" target="_blank">https://github . com/nothing is funny/fruits-crud-react-rails-app</a></p><p id="779a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢你留下来，如果你对如何改进这个应用程序有任何建议，或者如果你发现任何错误/错别字，请留下评论！</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><p id="33dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客的灵感来自:<a class="ae jc" href="https://www.pluralsight.com/guides/ruby-ruby-on-rails/building-a-crud-interface-with-react-and-ruby-on-rails" rel="noopener ugc nofollow" target="_blank">https://www . plur alsight . com/guides/ruby-ruby-on-rails/building-a-crud-interface-with-react-and-ruby-on-rails</a></p></div></div>    
</body>
</html>