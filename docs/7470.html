<html>
<head>
<title>Flutter Continuous Integration using GitLab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GitLab进行颤振连续积分</h1>
<blockquote>原文：<a href="https://medium.com/version-1/flutter-continuous-integration-using-gitlab-80f3d896704a?source=collection_archive---------0-----------------------#2021-04-29">https://medium.com/version-1/flutter-continuous-integration-using-gitlab-80f3d896704a?source=collection_archive---------0-----------------------#2021-04-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3f6a" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">第1部分——构建管道并运行我们的测试。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f9737181753bb7fe4423cee2001d3fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KDP0LkmDoQQm1XscAJ9JFg.gif"/></div></div></figure><h2 id="a202" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">介绍</h2><p id="3052" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">对于大大小小的项目，需要多个贡献者向<a class="ae kz" href="https://www.version1.com/" rel="noopener ugc nofollow" target="_blank">交付产品来构建出色的功能并交付突破性的产品</a>增加了如何整合单个变更的复杂性。优秀的工具通过持续集成降低了复杂性。DevOps过程中的一个cog允许多个个体一天多次自动将他们代码的变更合并到一个中央存储库中。然后，每个签入都由一个自动构建来验证，允许团队尽早发现问题。</p><p id="7fba" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">通过定期集成，您可以快速检测错误，并更容易地定位错误。这就是我将向您展示的如何使用GitLab构建Flutter应用程序。</p><h2 id="e65f" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">先决条件</h2><ul class=""><li id="79a3" class="lf lg hh ki b kj kk km kn jt lh jx li kb lj ky lk ll lm ln bi translated">Flutter安装在您的本地机器上。</li><li id="f0c8" class="lf lg hh ki b kj lo km lp jt lq jx lr kb ls ky lk ll lm ln bi translated">GitLab账户。</li><li id="81a6" class="lf lg hh ki b kj lo km lp jt lq jx lr kb ls ky lk ll lm ln bi translated">Git安装在您的本地机器上。</li><li id="2a79" class="lf lg hh ki b kj lo km lp jt lq jx lr kb ls ky lk ll lm ln bi translated">SSH密钥已创建。</li></ul><h2 id="af82" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">项目设置</h2><p id="7d98" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">因此，作为开始，我们将从零开始创建一个全新的应用程序，它带有Flutter scaffold命令。但是请注意，您将能够遵循现有项目和应用程序的过程。</p><p id="e74d" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">在你最喜欢的终端上创建一个新的Flutter应用程序，你可以随意命名，但我们的命名如下:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="6ed0" class="ji jj hh lu b fi ly lz l ma mb">flutter create flutterclilab</span></pre><p id="dc90" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">这将为您提供一个使用以下文件夹结构的脚手架项目:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mc"><img src="../Images/c0ba3697a1a8266ac0837051553e2592.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*oEI96QxCn3cH_SPmOTBDBA.png"/></div><figcaption class="md me et er es mf mg bd b be z dx">Folder structure for created scaffold application.</figcaption></figure><p id="2b33" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">所以我想看看测试是什么样的，看看我在做什么。在Flutter中有一个名为test的文件夹，它告诉Flutter/Dart SDK在这个文件夹中查找，以运行它的测试命令“$ flutter test”。让我们看看现有的脚手架附带了哪些测试:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mh"><img src="../Images/41f2ec81a6a1effb560fa9b0dba928c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_opgv9WxQSS1QcWM_Mojw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">widget_test.darts contents.</figcaption></figure><p id="1089" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">好的，让我们启动它，进行一次测试运行，我说的测试运行是指单元测试运行！！</p><p id="0cff" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">Visual Studio代码是我选择的IDE，所以当我想运行我的测试时，我打开Test=&gt;Run All Tests。让我们看看结果吧:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mi"><img src="../Images/51882821d598cf1d81da7e80dec0779d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*PGb9xpi_hdv7TJqmdXVl1w.png"/></div><figcaption class="md me et er es mf mg bd b be z dx">Passed all tests belonging to the project</figcaption></figure><p id="9abe" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">太好了！单元测试直接通过了。我们现在可以设置我们的源代码控制。</p><p id="7c63" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">就我个人而言，我喜欢GitLab。自从我开始开发以来，我一直在使用它，我喜欢它给你提供的运行管道的工具以及界面的布局。所以让我们在GitLab中建立一个新的空项目。如果你还没有GitLab的帐户，建立一个帐户是非常容易的，而且是免费的…这是我喜欢GitLab的另一个原因，因为我所有的收入几乎都花在了我的咖啡爱好☕上🤯</p><p id="1537" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">在GitLab中，单击New Project，然后单击Create blank project/repository。然后会给你一张表格输入你的详细资料。为项目命名并选择可见性级别，然后单击创建:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mj"><img src="../Images/ff97b9eedf9109166e127905b3630a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBWxVi6N5Hb_5Ri0H3g1Pg.png"/></div></div></figure><p id="6697" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">现在库已经建立起来了，我们可以把我们的代码库放到GitLab中，让其他人来处理。</p><p id="f4ba" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">在您的终端中，输入GitLab提供的命令来推送现有文件夹:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="2670" class="ji jj hh lu b fi ly lz l ma mb">cd existing_folder<br/>git init<br/>git remote add origin git@gitlab.com:SmiffyKMc/fluttercilab.git<br/>git add .<br/>git commit -m "Initial commit"<br/>git push -u origin master</span></pre><p id="3065" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">如果一切顺利，您应该会看到存储在项目概述选项卡中的代码库！</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mk"><img src="../Images/81c4e7335715e8d949e2fe04be865c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sA0YR75Oj4iL5u97Y0sk5Q.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Visual proof of source code in our source control host.</figcaption></figure><h2 id="25d3" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">建立质量关</h2><p id="2353" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">现在是时候为其他人如何使用我们惊人的创新计数器应用程序添加一些礼仪和规则了！我们将通过引入质量关来做到这一点。</p><blockquote class="ml mm mn"><p id="5646" class="kg kh mo ki b kj la ii kl km lb il ko mp lc kq kr mq ld kt ku mr le kw kx ky ha bi translated">一个<strong class="ki hi">质量关</strong>是一组条件，表明被分析的项目是否“对你来说足够好”以交付到你的软件生命周期的下一个阶段。</p></blockquote><p id="45a8" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">因此，让我们创建一些分支，这些分支将受到保护，防止用户在没有进行一些验证的情况下推送他们的更改。在GitLab菜单中，点击Repository=&gt;Branches。在这里，点击新的分支，称之为<strong class="ki hi">“发展”。</strong></p><p id="1a4b" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">我们现在可以在这两个分支之间切换，但是我们现在希望保护开发分支，避免在没有代码审查的情况下直接推送代码，因为我们希望我们的开发人员使用这个分支将他们的更改集成到。</p><p id="454c" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">点击设置= &gt;存储库= &gt;受保护的分支。选择开发分支并设置允许合并到维护人员和不允许推给任何人:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ms"><img src="../Images/1f7613adf0312eb977536bbede2f6d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpV544G1qN8NTzok7mhfZw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Example of the settings</figcaption></figure><p id="f7b5" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">这种改变保护了分支不被人直接推进，并且只允许存储库的维护者在合并请求发出后合并改变，我们很快就会看到。</p><p id="b9c3" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">我们现在准备通过构建gitlab-ci.yaml文件来创建我们的持续集成管道</p><h2 id="18ac" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">与YAML一起建立CI渠道</h2><p id="03e8" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">对于要进行的新更改，我们需要创建一个新的分支来处理，然后推送到GitLab来创建我们的合并请求。要创建新分支，请输入:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="1c3b" class="ji jj hh lu b fi ly lz l ma mb">git branch cipipeline<br/>git checkout cipipeline</span></pre><p id="56ef" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">在项目的根目录中，创建一个名为gitlab-ci.yaml的新文件。在该文件中粘贴以下代码:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="7356" class="ji jj hh lu b fi ly lz l ma mb"># This file is a template, and might need editing before it works on your project.<br/># https://hub.docker.com/r/google/dart<br/>image: mobiledevops/flutter-sdk-image:2.0.1<br/><br/>variables:<br/><br/># Cache downloaded dependencies and plugins between builds.<br/># To keep cache across branches add 'key: "$CI_JOB_NAME"'<br/>cache:<br/>  paths:<br/>    - .pub-cache/global_packages<br/><br/>stages:<br/>  - analyze_and_test<br/><br/>before_script:<br/>  - export PATH="$PATH":"$HOME/.flutter-sdk/.pub-cache/bin"<br/>  - flutter pub get<br/>  - flutter pub global activate junitreport<br/><br/>analyze_and_test:<br/>  stage: analyze_and_test<br/>  script:<br/>    - flutter analyze<br/>    - flutter test --machine | tojunit -o report.xml<br/>  artifacts:<br/>    when: always<br/>    reports:<br/>      junit:<br/>        - report.xml<br/>  tags:<br/>    - shared<br/>  only:<br/>    - merge_requests</span></pre><h2 id="ecee" class="ji jj hh bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">提出合并请求</h2><p id="4607" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">现在，我们可以创建一个合并请求来添加我们的新文件，这将为我们创建CI管道来分析我们的代码并确保没有错误，同时运行我们的测试！</p><p id="6f2e" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">运行以下命令添加我们的更改并将这些更改推送到GitLab:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="5bea" class="ji jj hh lu b fi ly lz l ma mb">git add .<br/>git commit -m "Added gitlab-ci.yaml file for ci pipeline"<br/>git push --set-upstream origin cipipeline</span></pre><p id="2062" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">您应该会收到一条从终端返回的消息，如下所示:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="70b1" class="ji jj hh lu b fi ly lz l ma mb">remote:<br/>remote: To create a merge request for cipipeline, visit:<br/>remote:   <a class="ae kz" href="https://gitlab.com/SmiffyKMc/fluttercilab/-/merge_requests/new?merge_request%5Bsource_branch%5D=cipipeline" rel="noopener ugc nofollow" target="_blank"><strong class="lu hi">https://gitlab.com/SmiffyKMc/fluttercilab/-/merge_requests/new?merge_request%5Bsource_branch%5D=cipipeline</strong></a><strong class="lu hi"><br/></strong>remote:</span></pre><p id="81c7" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">点击返回的链接。这是创建合并请求的直接链接，请求将您的更改集成到现有的分支或功能中。点击它会显示如下内容:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/ccc4465bf851e87a66b0cdcef76eda6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*API2g9tHY1Ub_NGadx4_kA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Detail entry for merge request.</figcaption></figure><p id="9c88" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">填写完详细信息并设置了受理人和审阅人后，您就可以创建合并请求了。审阅者和受分配者(或本教程中的我)😜)将会收到一个通知，告知他们有一个新的合并请求需要审阅。我确实收到了通知，所以让我们检查一下！</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mu"><img src="../Images/ed2f9e19d43e2909032e4bf26afd826c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*cH9BrfSxnUHK18VjCnPK8A.png"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mv"><img src="../Images/0d9abc36699bf64e7e17afd430206b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8N0LJ24VTQzuDyYmx3ZrBg.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Showing the pipeline running after it was created.</figcaption></figure><p id="e91a" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">喔呼🥳！我们可以看到一个管道已经创建并正在运行！我想在合并或审查更改之前看看管道是否成功，因为GitLab将能够告诉我们是否有任何东西被破坏或是否有任何测试因更改而失败！让我们单击带有散列的管道ID来查看构建的输出:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mw"><img src="../Images/037d9d8b97c99bce7d409a69afbe4c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkAUibOtFWGOFAJieFkqZw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Output from pipeline build</figcaption></figure><p id="bee5" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">我们可以看到gitlab-ci.yaml文件中的命令被输出到日志中，还可以看到作业成功了。但是测试在哪里呢？他们成功了吗？工作没有失败，所以他们一定失败了。在颤振测试命令之后，我们可以看到作业正在上传工件。</p><p id="a032" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">如果我们回到我们的合并请求，我们还会看到另一个部分:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mx"><img src="../Images/3f5e325770b1639cc91565e784a29e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yGexHDzf4CRR3_obNvqBQ.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">Section for our tests</figcaption></figure><p id="63fb" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">点击“查看完整报告”，您将能够在一个漂亮的列表中看到所有通过、失败或跳过的测试，以便我们查看:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es my"><img src="../Images/770751a639d6a7d6271c9639dc95474a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NE5GiZQnMsHnkpzpLKhP5g.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx">An overview of our tests being run and passed in GitLab</figcaption></figure><p id="1cd1" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">我认为我们现在已经准备好将这些变更合并到我们的开发分支中了。在我们的合并请求中，只需点击合并变更并给开发人员一个👍+1.</p><h1 id="5520" class="mz jj hh bd jk na nb nc jo nd ne nf js in ng io jw iq nh ir ka it ni iu ke nj bi translated">第一部分结束</h1><p id="393c" class="pw-post-body-paragraph kg kh hh ki b kj kk ii kl km kn il ko jt kp kq kr jx ks kt ku kb kv kw kx ky ha bi translated">我们创建了一个项目，为它建造了一个居所，保护了它的分支，并为它建造了一个管道来分析和运行与之相关的测试。对于一天的工作来说还不错！但是这里重要的是为一个可靠的高质量代码库打下基础，在这个基础上，多个开发人员将能够自动化他们的更改，并且在出错时快速得到结果，允许他们正确地进行更改。</p><p id="d5cf" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">在下一部分中，我们将实现一个代码覆盖集成，以从我们的测试中导出代码覆盖的报告，并添加一个覆盖徽章来炫耀。我们还将把林挺添加到我们的Flutter项目中，这样开发者就必须遵循代码所有者和技术领导者基于可变配置制定的标准和规则。这也会影响我们的构建，如果不遵循林挺规则，构建将会中断，你将得到一个👎！</p><p id="c632" class="pw-post-body-paragraph kg kh hh ki b kj la ii kl km lb il ko jt lc kq kr jx ld kt ku kb le kw kx ky ha bi translated">所以跟着👍为了更好地保护您的项目，第2部分创建时会通知您这篇文章。</p></div></div>    
</body>
</html>