<html>
<head>
<title>An Introduction to the io_uring Asynchronous I/O Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步输入输出框架简介</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/an-introduction-to-the-io-uring-asynchronous-i-o-framework-fad002d7dfc1?source=collection_archive---------1-----------------------#2020-06-03">https://medium.com/oracledevs/an-introduction-to-the-io-uring-asynchronous-i-o-framework-fad002d7dfc1?source=collection_archive---------1-----------------------#2020-06-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/424d6212c1650faff0941065a21453bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TEuhyiZGjbXQ8zbD.png"/></div></div></figure><p id="7daa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博客中，Oracle Linux内核开发人员<strong class="ir hi"><em class="jn">Bijan Mottahedeh</em></strong><em class="jn">谈到了Unbreakable Enterprise Kernel 6中包含的异步I/O框架。</em></p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="9be9" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="21d5" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">这篇博客文章简要介绍了Unbreakable Enterprise Kernel(UEK)第6版中的异步I/O框架。它强调了引入新框架的动机，借助示例应用程序描述了它的系统调用和库接口，并提供了一个参考列表，进一步详细描述了该技术，包括更多的使用示例。</p><p id="6666" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring异步I/O (AIO)框架是一个新的Linux I/O接口，首次在上游Linux内核版本5.1(2019年3月)中引入。它为需要AIO功能但更喜欢内核执行I/O的应用程序提供了低延迟和功能丰富的接口。这可能是为了利用在文件系统上运行的优势，或者利用镜像和块级加密等功能。这与SPDK应用形成对比，例如，它们明确地不希望内核执行I/O，因为它们实现了自己的文件系统和特性。</p><h1 id="2bbc" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">动机</h1><p id="9d66" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">本机Linux AIO框架受到各种限制的困扰，io uring旨在克服这些限制:</p><ul class=""><li id="0dea" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm li lj lk ll bi translated">它不支持缓冲I/O，只支持直接I/O。</li><li id="b869" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">它具有非确定性行为，在各种情况下可能会阻塞。</li><li id="eda5" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">它有一个次优的API，每个I/O至少需要两次系统调用，一次提交请求，一次等待请求完成。</li></ul><h1 id="9b9e" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">通信电路</h1><p id="8428" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">一个运行中的实例有两个环，一个提交队列(SQ)和一个完成队列(CQ ),在内核和应用程序之间共享。队列的大小是单个生产者、单个消费者和2的幂。</p><p id="94be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">队列提供无锁访问接口，与内存屏障相协调。</p><p id="2d43" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序创建一个或多个SQ条目(SQE)，然后更新SQ尾部。内核消耗SQE，并更新SQ头。</p><p id="5478" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">内核为一个或多个已完成的请求创建CQ条目(CQE)，并更新CQ尾部。应用程序使用cqe并更新CQ报头。</p><p id="62cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完成事件可能以任何顺序到达，但是它们总是与特定的SQE相关联。</p><h1 id="e3fc" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">系统调用API</h1><p id="c524" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">io_uring API由三个系统调用组成:io_uring_setup(2)、io_uring_register(2)和io_uring_enter(2)，下面几节将对此进行描述。系统调用的完整手册页可在<a class="ae lr" href="https://github.com/axboe/liburing/tree/master/man" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="b446" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">安装过程中</h1><p id="2e34" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated"><em class="jn">设置执行异步I/O的上下文</em></p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="431b" class="mb jw hh lx b fi mc md l me mf">int io_uring_setup(u32 entries, struct io_uring_params *p);</span></pre><p id="28f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_setup()系统调用使用至少<em class="jn">个条目</em>个元素设置提交队列和完成队列，并返回一个文件描述符，该文件描述符可用于在io_uring实例上执行后续操作。提交和完成队列在应用程序和内核之间共享，这消除了在启动和完成I/O时复制数据的需要。</p><p id="b4bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> params </em>由应用程序用来配置io_uring实例，并由内核传送回有关已配置的提交和完成环形缓冲区的信息。</p><p id="d49f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以在三种主要操作模式下配置运行实例:</p><ul class=""><li id="f894" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm li lj lk ll bi translated"><strong class="ir hi">中断驱动</strong> —默认情况下，io_uring实例是为中断驱动I/O设置的。I/O可以使用io_uring_enter()提交，并且可以通过直接检查完成队列来获得。</li><li id="a620" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">轮询</strong> —执行忙碌等待I/O完成，而不是通过异步IRQ(中断请求)获得通知。文件系统(如果有)和块设备必须支持轮询，这样才能工作。忙等待提供了更低的延迟，但可能比中断驱动的I/O消耗更多的CPU资源。目前，此功能仅在使用<em class="jn"> O_DIRECT </em>标志打开的文件描述符上可用。当一个读或写被提交给轮询上下文时，应用程序必须通过调用io_uring_enter()来轮询CQ环上的完成。在一个运行中的实例上混合和匹配轮询和非轮询I/O是非法的。</li><li id="ff4c" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><strong class="ir hi">内核轮询</strong> —在这种模式下，创建一个内核线程来执行提交队列轮询。以这种方式配置的I/O过程实例使应用程序能够发出I/O，而无需将上下文切换到内核中。通过使用提交队列来填充新的提交队列条目，并观察完成队列上的完成情况，应用程序可以提交并获取I/o，而无需进行任何系统调用。如果内核线程空闲的时间超过了用户可配置的时间量，它将在首先通知应用程序后进入空闲状态。当这种情况发生时，应用程序必须调用io_uring_enter()来唤醒内核线程。如果I/O保持忙碌，内核线程将永远不会休眠。</li></ul><p id="2304" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_setup()成功时返回一个新的文件描述符。然后，应用程序可以在后续的mmap(2)调用中提供文件描述符，以映射提交和完成队列，或者映射到io_uring_register()或io_uring_enter()系统调用。</p><h1 id="1011" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">io_uring_register</h1><p id="1585" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated"><em class="jn">异步I/O的寄存器文件或用户缓冲器</em></p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="ffc3" class="mb jw hh lx b fi mc md l me mf">int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args);</span></pre><p id="d6c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_register()系统调用注册由<em class="jn"> fd </em>引用的io_uring实例中使用的用户缓冲区或文件。注册文件或用户缓冲区允许内核长期引用与文件相关联的内部内核数据结构，或者创建与缓冲区相关联的应用存储器的长期映射，只在注册期间进行一次，而不是在处理每个I/O请求期间，因此减少了每个I/O的开销。</p><p id="e556" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注册的缓冲区将被锁定在内存中，并根据用户的<em class="jn"> RLIMIT_MEMLOCK </em>资源限制收费。此外，每个缓冲区的大小限制为1gb。目前，缓冲区必须是匿名的、非文件支持的内存，例如由malloc(3)或mmap(2)返回的设置了<em class="jn"> MAP_ANONYMOUS </em>标志的内存。也支持大页面。请注意，整个巨大的页面将被固定在内核中，即使只使用了其中的一部分。</p><p id="dcf8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置一个大的缓冲区，然后只使用它的一部分用于I/O，只要范围在最初映射的区域内，这是完全有效的。</p><p id="e1bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序可以增加或减少已注册缓冲区的大小或数量，方法是首先取消注册现有缓冲区，然后使用新的缓冲区对io_uring_register()发出新的调用。</p><p id="1bc9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序可以动态更新已注册的文件集，而无需先注销它们。</p><p id="c495" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以使用eventfd(2)来获得关于正在运行的实例的完成事件的通知。如果需要，可以通过这个系统调用注册一个eventfd文件描述符。</p><p id="0758" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正在运行的应用程序的凭证可以向io_uring注册，io _ uring返回与这些凭证相关联的id。希望在不同的用户/进程之间共享环的应用程序可以在SQE个性字段中传递这个凭证id。如果设置，将向特定的SQE颁发这些凭据。</p><h1 id="c21c" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">输入命令(_ u)</h1><p id="510d" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated"><em class="jn">启动和/或完成异步输入/输出</em></p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3d1f" class="mb jw hh lx b fi mc md l me mf">int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);</span></pre><p id="06d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_enter()用于通过调用io_uring_setup()使用共享提交和完成队列来启动和完成I/O。单个调用既可以提交新的I/O，也可以等待由此调用或之前对io_uring_enter()的调用启动的I/O完成。</p><p id="6744" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn"> fd </em>是io_uring_setup()返回的文件描述符。<em class="jn"> to_submit </em>指定从提交队列中提交的I/o数量。如果应用程序如此指示，系统调用将在返回之前尝试等待<em class="jn"> min_complete </em>事件完成。如果io_uring实例是为轮询配置的，那么<em class="jn"> min_complete </em>的含义略有不同。传递值0指示内核返回任何已经完成的事件，而不阻塞。如果<em class="jn"> min_complete </em>为非零值，如果有任何完成事件可用，内核仍将立即返回。如果没有可用的事件完成，则调用将进行轮询，直到一个或多个完成可用，或者直到进程超过其调度器时间片。</p><p id="bbaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，对于中断驱动的I/O，应用程序可以检查事件完成的完成队列，而根本不进入内核。</p><p id="b468" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_enter()支持多种操作，包括</p><ul class=""><li id="9252" class="ld le hh ir b is it iw ix ja lf je lg ji lh jm li lj lk ll bi translated">打开、关闭和统计文件</li><li id="4926" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">读取和写入多个缓冲区或预映射缓冲区</li><li id="d3fb" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">套接字输入/输出操作</li><li id="b1a7" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">同步文件状态</li><li id="9044" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">异步监控一组文件描述符</li><li id="3dde" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">创建与环中特定操作相关联的超时</li><li id="9549" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">试图取消当前正在进行的操作</li><li id="2aaa" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">创建I/O链</li><li id="8142" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">链内的有序执行</li><li id="2d7e" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated">多个链的并行执行</li></ul><p id="9962" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当系统调用返回已经消耗并提交了一定数量的SQE时，在环中重用SQE条目是安全的。即使实际的IO提交必须被踢到异步上下文，也是如此，这意味着SQE可能实际上还没有被提交。如果内核需要以后使用某个特定的SQE条目，它会制作一个私有副本。</p><h1 id="7c60" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">Liburing</h1><p id="02a6" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">Liburing为基本用例提供了一个简单的高级API，并允许应用程序避免处理完整的系统调用实现细节。API还避免了重复的操作代码，例如设置io _ uring实例。</p><p id="9163" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，从io_uring_setup()获取一个环形文件描述符后，应用程序必须始终调用mmap()，以便映射访问的提交和完成队列，如io_uring_setup()手册页中所述。整个序列有点长，但是可以通过下面的liburing调用来完成:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="af5d" class="mb jw hh lx b fi mc md l me mf">int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags);</span></pre><p id="6d7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的示例应用程序包含在liburing source中，帮助说明了这些要点。</p><p id="ae4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">liburing示例应用程序的源代码可从<a class="ae lr" href="https://github.com/axboe/liburing/tree/master/examples" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="08d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前没有可用的liburing API文档，API在<a class="ae lr" href="https://github.com/axboe/liburing/blob/master/src/include/liburing.h" rel="noopener ugc nofollow" target="_blank"> liburing.h </a>头文件中描述。</p><h1 id="d88c" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">测试期间的示例应用程序</h1><p id="34a5" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">io_uring-test使用4个SQEs从用户指定的文件中读取最多16KB。每个SQE都是一个从固定文件偏移量读取4KB数据的请求。然后，io-uring会获取每个CQE，并检查是否按照请求从文件中读取了完整的4KB。</p><p id="e322" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果文件小于16KB，仍会提交所有4个SQE，但一些CQE结果会指示部分读取或零字节读取，具体取决于文件的实际大小。</p><p id="d5d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io-ouring最后报告它已经处理的SQE和cqe的数量。</p><p id="0521" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面列出了完整的源代码，后面是对liburing调用的描述。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="f02e" class="mb jw hh lx b fi mc md l me mf">/* SPDX-License-Identifier: MIT */<br/>/*<br/> * Simple app that demonstrates how to setup an io_uring interface,<br/> * submit and complete IO against it, and then tear it down.<br/> *<br/> * gcc -Wall -O2 -D_GNU_SOURCE -o io_uring-test io_uring-test.c -luring<br/> */<br/>#include &lt;stdio.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include "liburing.h"<br/> <br/>#define QD  4<br/> <br/>int main(int argc, char *argv[])<br/>{<br/>    struct io_uring ring;<br/>    int i, fd, ret, pending, done;<br/>    struct io_uring_sqe *sqe;<br/>    struct io_uring_cqe *cqe;<br/>    struct iovec *iovecs;<br/>    off_t offset;<br/>    void *buf;<br/> <br/>    if (argc &lt; 2) {<br/>        printf("%s: file\n", argv[0]);<br/>        return 1;<br/>    }<br/> <br/>    ret = io_uring_queue_init(QD, &amp;ring, 0);<br/>    if (ret &lt; 0) {<br/>        fprintf(stderr, "queue_init: %s\n", strerror(-ret));<br/>        return 1;<br/>    }<br/> <br/>    fd = open(argv[1], O_RDONLY | O_DIRECT);<br/>    if (fd &lt; 0) {<br/>        perror("open");<br/>        return 1;<br/>    }<br/> <br/>    iovecs = calloc(QD, sizeof(struct iovec));<br/>    for (i = 0; i &lt; QD; i++) {<br/>        if (posix_memalign(&amp;buf, 4096, 4096))<br/>            return 1;<br/>        iovecs[i].iov_base = buf;<br/>        iovecs[i].iov_len = 4096;<br/>    }<br/> <br/>    offset = 0;<br/>    i = 0;<br/>    do {<br/>        sqe = io_uring_get_sqe(&amp;ring);<br/>        if (!sqe)<br/>            break;<br/>        io_uring_prep_readv(sqe, fd, &amp;iovecs[i], 1, offset);<br/>        offset += iovecs[i].iov_len;<br/>        i++;<br/>    } while (1);<br/> <br/>    ret = io_uring_submit(&amp;ring);<br/>    if (ret &lt; 0) {<br/>        fprintf(stderr, "io_uring_submit: %s\n", strerror(-ret));<br/>        return 1;<br/>    }<br/> <br/>    done = 0;<br/>    pending = ret;<br/>    for (i = 0; i &lt; pending; i++) {<br/>        ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);<br/>        if (ret &lt; 0) {<br/>            fprintf(stderr, "io_uring_wait_cqe: %s\n", strerror(-ret));<br/>            return 1;<br/>        }<br/> <br/>        done++;<br/>        ret = 0;<br/>        if (cqe-&gt;res != 4096) {<br/>            fprintf(stderr, "ret=%d, wanted 4096\n", cqe-&gt;res);<br/>            ret = 1;<br/>        }<br/>        io_uring_cqe_seen(&amp;ring, cqe);<br/>        if (ret)<br/>            break;<br/>    }<br/> <br/>    printf("Submitted=%d, completed=%d\n", pending, done);<br/>    close(fd);<br/>    io_uring_queue_exit(&amp;ring);<br/>    return 0;<br/>}</span></pre><h1 id="ccc5" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">描述</h1><p id="02e1" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">在默认的中断驱动模式下创建一个io_uring实例，仅指定环的大小。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3d85" class="mb jw hh lx b fi mc md l me mf">ret = io_uring_queue_init(QD, &amp;ring, 0);</span></pre><p id="e344" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来取出所有的环SQE，并为IORING_OP_READV操作做准备，该操作为readv(2)系统调用提供了异步接口。Liburing提供了许多帮助函数来准备操作。</p><p id="b986" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个SQE将指向由iovec结构描述的分配的缓冲区。完成后，缓冲区将包含相应readv操作的结果。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="9e4e" class="mb jw hh lx b fi mc md l me mf">sqe = io_uring_get_sqe(&amp;ring); io_uring_prep_readv(sqe, fd, &amp;iovecs[i], 1, offset);</span></pre><p id="da79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过对io_uring_submit()的一次调用来提交SQE，该调用返回提交的SQE的数量。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="60f3" class="mb jw hh lx b fi mc md l me mf">ret = io_uring_submit(&amp;ring);</span></pre><p id="8c17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过重复调用io_uring_wait_cqe()来获取cqe，并且通过cqe-&gt;res字段来验证给定提交是否成功；对io_uring_cqe_seen()的每个匹配调用都通知内核给定的cqe已经被消耗。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="a900" class="mb jw hh lx b fi mc md l me mf">ret = io_uring_wait_cqe(&amp;ring, &amp;cqe); io_uring_cqe_seen(&amp;ring, cqe);</span></pre><p id="73b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io uring实例最终被拆除。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="c5f9" class="mb jw hh lx b fi mc md l me mf">void io_uring_queue_exit(struct io_uring *ring)</span></pre><h1 id="2739" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">示例应用程序链接-cp</h1><p id="f6c7" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">link-cp使用SQE链接功能复制文件。</p><p id="d60d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，io ouring支持创建I/O链。链中的I/O操作是顺序执行的，并且多个I/O链可以并行执行。</p><p id="72bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了复制文件，link-cp创建长度为2的SQE链。链中的第一个SQE是从输入文件到缓冲区的读请求。链接到第一个请求的第二个请求是从同一个缓冲区到输出文件的写请求。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="4b1e" class="mb jw hh lx b fi mc md l me mf">/* SPDX-License-Identifier: MIT */<br/>/*<br/> * Very basic proof-of-concept for doing a copy with linked SQEs. Needs a<br/> * bit of error handling and short read love.<br/> */<br/>#include &lt;stdio.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;assert.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include &lt;inttypes.h&gt;<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/ioctl.h&gt;<br/>#include "liburing.h"<br/> <br/>#define QD  64<br/>#define BS  (32*1024)<br/> <br/>struct io_data {<br/>    size_t offset;<br/>    int index;<br/>    struct iovec iov;<br/>};<br/> <br/>static int infd, outfd;<br/>static unsigned inflight;<br/> <br/> <br/>static int setup_context(unsigned entries, struct io_uring *ring)<br/>{<br/>    int ret;<br/> <br/>    ret = io_uring_queue_init(entries, ring, 0);<br/>    if (ret &lt; 0) {<br/>        fprintf(stderr, "queue_init: %s\n", strerror(-ret));<br/>        return -1;<br/>    }<br/> <br/>    return 0;<br/>}<br/> <br/>static int get_file_size(int fd, off_t *size)<br/>{<br/>    struct stat st;<br/> <br/>    if (fstat(fd, &amp;st) &lt; 0)<br/>        return -1;<br/>    if (S_ISREG(st.st_mode)) {<br/>        *size = st.st_size;<br/>        return 0;<br/>    } else if (S_ISBLK(st.st_mode)) {<br/>        unsigned long long bytes;<br/> <br/>        if (ioctl(fd, BLKGETSIZE64, &amp;bytes) != 0)<br/>            return -1;<br/> <br/>        *size = bytes;<br/>        return 0;<br/>    }<br/> <br/>    return -1;<br/>}<br/> <br/>static void queue_rw_pair(struct io_uring *ring, off_t size, off_t offset)<br/>{<br/>    struct io_uring_sqe *sqe;<br/>    struct io_data *data;<br/>    void *ptr;<br/> <br/>    ptr = malloc(size + sizeof(*data));<br/>    data = ptr + size;<br/>    data-&gt;index = 0;<br/>    data-&gt;offset = offset;<br/>    data-&gt;iov.iov_base = ptr;<br/>    data-&gt;iov.iov_len = size;<br/> <br/>    sqe = io_uring_get_sqe(ring);<br/>    io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, 1, offset);<br/>    sqe-&gt;flags |= IOSQE_IO_LINK;<br/>    io_uring_sqe_set_data(sqe, data);<br/> <br/>    sqe = io_uring_get_sqe(ring);<br/>    io_uring_prep_writev(sqe, outfd, &amp;data-&gt;iov, 1, offset);<br/>    io_uring_sqe_set_data(sqe, data);<br/>}<br/> <br/>static int handle_cqe(struct io_uring *ring, struct io_uring_cqe *cqe)<br/>{<br/>    struct io_data *data = io_uring_cqe_get_data(cqe);<br/>    int ret = 0;<br/> <br/>    data-&gt;index++;<br/> <br/>    if (cqe-&gt;res &lt; 0) {<br/>        if (cqe-&gt;res == -ECANCELED) {<br/>            queue_rw_pair(ring, BS, data-&gt;offset);<br/>            inflight += 2;<br/>        } else {<br/>            printf("cqe error: %s\n", strerror(cqe-&gt;res));<br/>            ret = 1;<br/>        }<br/>    }<br/> <br/>    if (data-&gt;index == 2) {<br/>        void *ptr = (void *) data - data-&gt;iov.iov_len;<br/> <br/>        free(ptr);<br/>    }<br/>    io_uring_cqe_seen(ring, cqe);<br/>    return ret;<br/>}<br/> <br/>static int copy_file(struct io_uring *ring, off_t insize)<br/>{<br/>    struct io_uring_cqe *cqe;<br/>    size_t this_size;<br/>    off_t offset;<br/> <br/>    offset = 0;<br/>    while (insize) {<br/>        int has_inflight = inflight;<br/>        int depth;<br/> <br/>        while (insize &amp;&amp; inflight &lt; QD) {<br/>            this_size = BS;<br/>            if (this_size &gt; insize)<br/>                this_size = insize;<br/>            queue_rw_pair(ring, this_size, offset);<br/>            offset += this_size;<br/>            insize -= this_size;<br/>            inflight += 2;<br/>        }<br/> <br/>        if (has_inflight != inflight)<br/>            io_uring_submit(ring);<br/> <br/>        if (insize)<br/>            depth = QD;<br/>        else<br/>            depth = 1;<br/>        while (inflight &gt;= depth) {<br/>            int ret;<br/> <br/>            ret = io_uring_wait_cqe(ring, &amp;cqe);<br/>            if (ret &lt; 0) {<br/>                printf("wait cqe: %s\n", strerror(ret));<br/>                return 1;<br/>            }<br/>            if (handle_cqe(ring, cqe))<br/>                return 1;<br/>            inflight--;<br/>        }<br/>    }<br/> <br/>    return 0;<br/>}<br/> <br/>int main(int argc, char *argv[])<br/>{<br/>    struct io_uring ring;<br/>    off_t insize;<br/>    int ret;<br/> <br/>    if (argc &lt; 3) {<br/>        printf("%s: infile outfile\n", argv[0]);<br/>        return 1;<br/>    }<br/> <br/>    infd = open(argv[1], O_RDONLY);<br/>    if (infd &lt; 0) {<br/>        perror("open infile");<br/>        return 1;<br/>    }<br/>    outfd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);<br/>    if (outfd &lt; 0) {<br/>        perror("open outfile");<br/>        return 1;<br/>    }<br/> <br/>    if (setup_context(QD, &amp;ring))<br/>        return 1;<br/>    if (get_file_size(infd, &amp;insize))<br/>        return 1;<br/> <br/>    ret = copy_file(&amp;ring, insize);<br/> <br/>    close(infd);<br/>    close(outfd);<br/>    io_uring_queue_exit(&amp;ring);<br/>    return ret;<br/>}</span></pre><h1 id="727d" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">描述</h1><p id="2277" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">三个例程copy_file()、queue_rw_pair()和handle_cqe()实现了文件复制。</p><p id="b72c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">copy_file()实现了高级复制循环；它调用queue_rw_pair()来构造每个SQE对</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="48e1" class="mb jw hh lx b fi mc md l me mf">queue_rw_pair(ring, this_size, offset);</span></pre><p id="9fde" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并在每次迭代中提交所有构建的SQE对，只需调用io_uring_submit()。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3792" class="mb jw hh lx b fi mc md l me mf">if (has_inflight != inflight) io_uring_submit(ring);</span></pre><p id="d69e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">只要仍有数据需要拷贝，copy_file()就会在运行中维护多达QD的SQEs在输入文件被完全读取后，它等待并获取所有cqe。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6688" class="mb jw hh lx b fi mc md l me mf">ret = io_uring_wait_cqe(ring, &amp;cqe); if (handle_cqe(ring, cqe))</span></pre><p id="8c73" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">queue_rw_pair()构造一个读写SQE对。IOSQE_IO_LINK标志为读SQE置位，标志着链的开始。没有为标记链结束的写SQE设置标志。将两个SQE的用户数据字段设置为该对的相同数据描述符，并将在完成处理期间使用。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="9d94" class="mb jw hh lx b fi mc md l me mf">sqe = io_uring_get_sqe(ring); io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, 1, offset); sqe-&gt;flags |= IOSQE_IO_LINK; io_uring_sqe_set_data(sqe, data); sqe = io_uring_get_sqe(ring); io_uring_prep_writev(sqe, outfd, &amp;data-&gt;iov, 1, offset); io_uring_sqe_set_data(sqe, data);</span></pre><p id="572f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">handle_cqe()从cqe中检索queue_rw_pair()保存的数据描述符，并将检索结果记录在描述符中。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="81d8" class="mb jw hh lx b fi mc md l me mf">struct io_data *data = io_uring_cqe_get_data(cqe); data-&gt;index++;</span></pre><p id="a9e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果请求被取消，handle_cqe()重新提交读写对。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="f385" class="mb jw hh lx b fi mc md l me mf">if (cqe-&gt;res == -ECANCELED) { queue_rw_pair(ring, BS, data-&gt;offset);</span></pre><p id="7d17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">io_uring_enter()手册页中的以下摘录更详细地描述了链式请求的行为:</p><h1 id="365e" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated"><strong class="ak"> IOSQE_IO_LINK </strong></h1><p id="ca9d" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">当这个标志被指定时，它与提交环中的下一个SQE形成一个链接。在这一个完成之前，下一个SQE不会开始。这实际上形成了一个SQE链，可以任意长。链的尾部由没有设置该标志的第一个SQE表示。此标志对以前的SQE提交没有影响，也不会影响链尾之外的SQE。这意味着多个链可以并行执行，或者链和单个SQE可以并行执行。只有链内的成员被序列化。如果一个SQE链中的任何请求以错误结束，那么这个SQE链就会中断。io uring认为任何意外结果都是错误。这意味着，例如，一个短读也将终止链的剩余部分。如果SQE链接链断开，链的剩余未启动部分将被终止，并以-ecanced作为错误代码结束。</p><p id="836c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在处理完cqe对的两个成员后，handle_cqe()释放共享数据描述符。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="20b0" class="mb jw hh lx b fi mc md l me mf">if (data-&gt;index == 2) { void *ptr = (void *) data - data-&gt;iov.iov_len; free(ptr); }</span></pre><p id="e067" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">handle_cqe()最后通知内核给定的cqe已经被使用了。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="2818" class="mb jw hh lx b fi mc md l me mf">io_uring_cqe_seen(ring, cqe);</span></pre><h1 id="c5a4" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">Liburing API</h1><p id="b923" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">io-uring-test和link-cp使用liburing API的以下子集:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="734b" class="mb jw hh lx b fi mc md l me mf">/*<br/> * Returns -1 on error, or zero on success. On success, 'ring'<br/> * contains the necessary information to read/write to the rings.<br/> */<br/>int io_uring_queue_init(unsigned entries, struct io_uring *ring, unsigned flags);<br/> <br/>/*<br/> * Return an sqe to fill. Application must later call io_uring_submit()<br/> * when it's ready to tell the kernel about it. The caller may call this<br/> * function multiple times before calling io_uring_submit().<br/> *<br/> * Returns a vacant sqe, or NULL if we're full.<br/> */<br/>struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring);<br/> <br/>/*<br/> * Set the SQE user_data field.<br/> */<br/>void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data);<br/> <br/>/*<br/> * Prepare a readv I/O operation.<br/> */<br/>void io_uring_prep_readv(struct io_uring_sqe *sqe, int fd,<br/>                         const struct iovec *iovecs,<br/>                         unsigned nr_vecs, off_t offset);<br/> <br/>/*<br/> * Prepare a writev I/O operation.<br/> */<br/>void io_uring_prep_writev(struct io_uring_sqe *sqe, int fd,<br/>                          const struct iovec *iovecs,<br/>                          unsigned nr_vecs, off_t offset);<br/> <br/>/*<br/> * Submit sqes acquired from io_uring_get_sqe() to the kernel.<br/> *<br/> * Returns number of sqes submitted<br/> */<br/>int io_uring_submit(struct io_uring *ring);<br/> <br/>/*<br/> * Return an IO completion, waiting for it if necessary. Returns 0 with<br/> * cqe_ptr filled in on success, -errno on failure.<br/> */<br/>int io_uring_wait_cqe(struct io_uring *ring,<br/>                      struct io_uring_cqe **cqe_ptr);<br/> <br/>/*<br/> * Must be called after io_uring_{peek,wait}_cqe() after the cqe has<br/> * been processed by the application.<br/> */<br/>static inline void io_uring_cqe_seen(struct io_uring *ring,<br/>                                     struct io_uring_cqe *cqe);<br/> <br/>void io_uring_queue_exit(struct io_uring *ring);</span></pre><h1 id="0121" class="jv jw hh bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">参考</h1><ul class=""><li id="843f" class="ld le hh ir b is kt iw ku ja mg je mh ji mi jm li lj lk ll bi translated"><a class="ae lr" href="https://kernel.dk/io_uring.pdf" rel="noopener ugc nofollow" target="_blank">带IO期间的高效IO</a></li><li id="0e91" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://lwn.net/Articles/776703/" rel="noopener ugc nofollow" target="_blank">一个新的异步输入输出API </a></li><li id="c6dd" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://lwn.net/Articles/810414/" rel="noopener ugc nofollow" target="_blank">期间的快速增长</a></li><li id="94bc" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://www.youtube.com/watch?v=-5T4Cjw46ys" rel="noopener ugc nofollow" target="_blank">通过io期间更快的I/O速度</a></li><li id="08a0" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://github.com/axboe/liburing/tree/master/man" rel="noopener ugc nofollow" target="_blank">系统调用API </a></li><li id="8c1a" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://github.com/axboe/liburing/blob/master/src/include/liburing.h" rel="noopener ugc nofollow" target="_blank"> Liburing API </a></li><li id="b298" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://github.com/axboe/liburing/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例</a></li><li id="e807" class="ld le hh ir b is lm iw ln ja lo je lp ji lq jm li lj lk ll bi translated"><a class="ae lr" href="https://github.com/axboe/liburing" rel="noopener ugc nofollow" target="_blank">创建库</a></li></ul></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="a1a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于https://blogs.oracle.com</em><a class="ae lr" href="https://blogs.oracle.com/linux/an-introduction-to-the-io_uring-asynchronous-io-framework" rel="noopener ugc nofollow" target="_blank"><em class="jn"/></a><em class="jn">。</em></p></div></div>    
</body>
</html>