<html>
<head>
<title>Mocking is not rocket science: MockK advanced features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘲笑不是火箭科学:嘲笑高级功能</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-advanced-features-42277e5983b5?source=collection_archive---------0-----------------------#2019-02-18">https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-advanced-features-42277e5983b5?source=collection_archive---------0-----------------------#2019-02-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="032d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">去年一年，MockK在Kotlin世界飞速发展。用户通过提交问题和提出改进建议来积极地帮助改进它。上个月，<a class="ae ki" href="https://mockk.io" rel="noopener ugc nofollow" target="_blank">mock</a>推出了许多强大的功能，我很高兴与您分享它们。这篇文章并不短，因为我想分享很多你可以用来改进测试的新的可能性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ac12efb1b7fb9faac1642ae749c9cf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRLy_Q1beGH4TDjRQHREmw.jpeg"/></div></div></figure><h1 id="0d37" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">等级嘲讽</h1><p id="f255" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">从最近的一个版本开始，1.9.1 MockK支持所谓的分层嘲讽。例如，如果您有以下从属接口:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="1f0b" class="md kw in lz b gy me mf l mg mh">interface AddressBook {<br/>    val contacts: List&lt;Contact&gt;<br/>}</span><span id="5b5d" class="md kw in lz b gy mi mf l mg mh">interface Contact {<br/>    val name: String<br/>    val telephone: String<br/>    val address: Address<br/>}</span><span id="7123" class="md kw in lz b gy mi mf l mg mh">interface Address {<br/>    val city: String<br/>    val zip: String<br/>}</span></pre><p id="44b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且需要模仿整个通讯录，可以使用<code class="fe mj mk ml lz b">mockk</code>函数的初始化块来指定其内部的行为，并通过一个链将其他模仿放在<code class="fe mj mk ml lz b">every</code>的<code class="fe mj mk ml lz b">returns</code>中。这产生了一个很好DSL来定义依赖对象:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="bb83" class="md kw in lz b gy me mf l mg mh">val addressBook = mockk&lt;AddressBook&gt; {<br/>    every { contacts } returns listOf(<br/>        mockk {<br/>            every { name } returns "John"<br/>            every { telephone } returns "123-456-789"<br/>            every { address.city } returns "New-York"<br/>            every { address.zip } returns "123-45"<br/>        },<br/>        mockk {<br/>            every { name } returns "Alex"<br/>            every { telephone } returns "789-456-123"<br/>            every { address } returns mockk {<br/>                every { city } returns "Wroclaw"<br/>                every { zip } returns "543-21"<br/>            }<br/>        }<br/>    )<br/>}</span></pre><p id="e65d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以注意到这里的<code class="fe mj mk ml lz b">address.city</code>和<code class="fe mj mk ml lz b">address.zip</code>是通过链式调用被嘲笑的。这是另一种方法，由你决定选择哪一种。</p><p id="4ee6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，真正的层次结构将由真实对象和模拟对象混合组成。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="c411" class="md kw in lz b gy me mf l mg mh">val serviceLocator = <em class="mm">mockk</em>&lt;ServiceLocator&gt; {<br/>    <em class="mm">every </em>{ transactionRepository } returns <em class="mm">mockk </em>{<br/>        <em class="mm">coEvery </em>{<br/>            getTransactions()<br/>        } returns Result.build {<br/>            <em class="mm">listOf</em>(<br/>                NoteTransaction(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note1.",<br/>                    transactionType = TransactionType.DELETE<br/>                ),<br/>                NoteTransaction(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note2.",<br/>                    transactionType = TransactionType.DELETE<br/>                ),<br/>                NoteTransaction(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note3.",<br/>                    transactionType = TransactionType.DELETE<br/>                )<br/>            )<br/>        }<br/><br/>        <em class="mm">coEvery </em>{<br/>            deleteTransactions()<br/>        } returns Result.build { Unit }<br/>    }<br/><br/>    <em class="mm">every </em>{ remoteRepository } returns <em class="mm">mockk </em>{<br/>        <em class="mm">coEvery </em>{ getNotes() } returns Result.build {<br/>            <em class="mm">listOf</em>(<br/>                Note(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note1.",<br/>                    upVotes = 0,<br/>                    imageUrl = "",<br/>                    creator = User(<br/>                        "8675309",<br/>                        "Ajahn Chah",<br/>                        ""<br/>                    )<br/>                ), Note(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note2.",<br/>                    upVotes = 0,<br/>                    imageUrl = "",<br/>                    creator = User(<br/>                        "8675309",<br/>                        "Ajahn Chah",<br/>                        ""<br/>                    )<br/>                ), Note(<br/>                    creationDate = "28/10/2018",<br/>                    contents = "Content of note3.",<br/>                    upVotes = 0,<br/>                    imageUrl = "",<br/>                    creator = User(<br/>                        "8675309",<br/>                        "Ajahn Chah",<br/>                        ""<br/>                    )<br/>                )<br/>            )<br/>        }<br/><br/>        <em class="mm">coEvery </em>{<br/>            synchronizeTransactions(any())<br/>        } returns Result.build {<br/>            Unit<br/>        }<br/>    }<br/>}</span></pre><p id="b67e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mm">(采用，来源:</em><a class="ae ki" href="https://github.com/BracketCove/SpaceNotes/blob/master/domain/src/test/java/com/wiseassblog/domain/RegisteredNoteSourceTest.kt" rel="noopener ugc nofollow" target="_blank"><em class="mm">registerednotesourcestest . kt</em></a><em class="mm">)</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/88318544d009f943468788e25fe259cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4UeeUmHATCC67HCgA2qNw.jpeg"/></div></div></figure><h1 id="fac6" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">协同程序</h1><p id="3e1d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">MockK从一开始就支持协程，但在去年，内部引擎变得更加先进，并且也添加了一些语法子句。</p><p id="7260" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，您需要记住的是，在MockK中所有使用协程的函数都是由常规函数+前缀<code class="fe mj mk ml lz b">co</code>构建的。比如<code class="fe mj mk ml lz b">every</code>变成了<code class="fe mj mk ml lz b">coEvery</code>、<code class="fe mj mk ml lz b">verify</code> — <code class="fe mj mk ml lz b">coVerify</code>、<code class="fe mj mk ml lz b">answers</code> — <code class="fe mj mk ml lz b">coAnswers</code>。此类函数采用suspend lambdas代替常规lambdas，并允许调用<code class="fe mj mk ml lz b">suspend</code>函数。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="656a" class="md kw in lz b gy me mf l mg mh"><em class="mm">coEvery </em><strong class="lz io">{ <br/>  </strong>mock.divide(capture(slot), any()) <br/><strong class="lz io">} </strong>coAnswers <strong class="lz io">{<br/>  </strong>slot.captured * 11<br/><strong class="lz io">}</strong></span></pre><p id="c705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以第一眼看上去，一切都很像常规的嘲讽。但从内部来看，这并不容易。</p><p id="2b6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一件事是，当对<code class="fe mj mk ml lz b">divide</code>函数的调用被拦截时，它将隐式continuation参数作为字节码级别的最后一个参数。Continuation是一个回调函数，在结果准备好时使用。这意味着库需要将这个延续传递给<code class="fe mj mk ml lz b">coAnswers</code>子句，所以它不仅仅是传递了<code class="fe mj mk ml lz b">runBlocking</code>suspend lambda。</p><p id="1038" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个区别是<code class="fe mj mk ml lz b">divide</code>暂停功能可能决定暂停。这意味着在内部它将返回特殊的悬浮标记。当计算恢复时，再次调用<code class="fe mj mk ml lz b">divide</code>。因此，每个这样的恢复调用都将被视为对<code class="fe mj mk ml lz b">divide</code>函数的额外调用。这意味着您需要在验证过程中小心处理它。</p><p id="7ae5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解这种内部情况并不是一件非常愉快的工作，但不幸的是，没有其他方法来处理它。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/4dd583ec0ed5c6489b9e0209af21faeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i088SGV3u3ODVgEmSQHFXg.jpeg"/></div></div></figure><h1 id="c070" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">验证超时</h1><p id="161d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">当处理协程时，人们经常忘记<code class="fe mj mk ml lz b">launch</code>运行一个并行执行的任务，为了验证这种进程的结果，你需要一个进程等待另一个进程。这可以通过<code class="fe mj mk ml lz b">join</code>来实现。但是接下来你需要显式地到处传递对<code class="fe mj mk ml lz b">Job</code>的引用。</p><p id="3ce8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简化这类测试的编写，MockK支持超时验证:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="93e3" class="md kw in lz b gy me mf l mg mh">mockk&lt;MockCls&gt; {<br/>    coEvery { sum(1, 2) } returns 4</span><span id="8631" class="md kw in lz b gy mi mf l mg mh">    launch {<br/>        delay(2000)<br/>        sum(1, 2)<br/>    }</span><span id="34b5" class="md kw in lz b gy mi mf l mg mh">    verify(timeout = 3000) { sum(1, 2) }<br/>}</span></pre><p id="665e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，<code class="fe mj mk ml lz b">verify</code>子句将退出，要么满足验证标准，要么在超时的情况下抛出异常。这样你就不需要明确地等待<code class="fe mj mk ml lz b">launch</code>中的时刻计算完成。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/36a456a1c87893264a2df8273ea955bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yu7qVHCM1LTjyQyDHvTrnQ.jpeg"/></div></div></figure><h1 id="15d9" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">验证确认和记录排除</h1><p id="96f9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><code class="fe mj mk ml lz b">verifyAll</code>和<code class="fe mj mk ml lz b">verifySequence</code>是两种验证模式，在这两种模式下会验证一组专用的调用。不存在出错和调用次数超过需要的可能性。</p><p id="8fbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一方面,<code class="fe mj mk ml lz b">verifyOrder</code>和简单的<code class="fe mj mk ml lz b">verify</code>不能这样工作。另一方面，他们给你更多的灵活性。</p><p id="d318" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个差异，您可以在所有验证块之后使用一个特殊的验证确认调用。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="7cdc" class="md kw in lz b gy me mf l mg mh">confirmVerified(object1, object2)</span></pre><p id="5366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将确保<code class="fe mj mk ml lz b">object1</code>和<code class="fe mj mk ml lz b">object2</code>的所有调用都包含在<code class="fe mj mk ml lz b">verify</code>子句中。</p><p id="2983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您有一些不太重要的调用，您可以通过<code class="fe mj mk ml lz b">excludeRecords</code>构造将它们从确认验证中排除。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="3323" class="md kw in lz b gy me mf l mg mh">excludeRecords { object1.someCall(andArguments) <!-- -->}</span></pre><p id="bd62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用参数匹配器排除一系列调用。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mp"><img src="../Images/66e364acc53b73685eb76bf3be77aeba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvepM3yUODkGs2rtrs7g3w.jpeg"/></div></div></figure><h1 id="5de1" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">瓦拉格斯</h1><p id="4f94" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">对变量参数的简单处理出现在早期的MockK版本中，但是从版本1.9.1开始，实现了额外的匹配器。</p><p id="924b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我用一个接受变量参数的简单函数来演示这一点:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="e656" class="md kw in lz b gy me mf l mg mh">interface VarargExample {<br/>    fun example(vararg sequence: Int): Int<br/>}</span></pre><p id="437e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们模仿一下，看看有哪些模仿的可能性:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="56c2" class="md kw in lz b gy me mf l mg mh">val mock = mockk&lt;VarargExample&gt;()</span></pre><p id="9cd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，可以将它用作简单的参数:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="071f" class="md kw in lz b gy me mf l mg mh">every { mock.example(1, 2, 3, more(4), 5) } returns 6</span></pre><p id="be73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着，如果变量参数数组的大小为5，并且它匹配所提供的参数，那么<code class="fe mj mk ml lz b">example</code>函数的结果就是6。</p><p id="8ab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要处理可变参数的可变长度，这当然不是很灵活。</p><p id="8133" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了克服这个限制，MockK增加了三个匹配器:<code class="fe mj mk ml lz b">anyVararg</code>、<code class="fe mj mk ml lz b">varargAll</code>和<code class="fe mj mk ml lz b">varargAny</code></p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="2be2" class="md kw in lz b gy me mf l mg mh">every { mock.example(*anyVararg()) } return 1</span></pre><p id="60f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将简单地匹配任何可能的变量参数数组。</p><p id="cd1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以添加匹配器的任何前缀或后缀。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="296e" class="md kw in lz b gy me mf l mg mh">every { mock.example(1, 2, *anyVararg(), 3) } return 4</span></pre><p id="b089" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其将匹配从<code class="fe mj mk ml lz b">1</code>、<code class="fe mj mk ml lz b">2</code>开始到<code class="fe mj mk ml lz b">3</code>结束的至少3个元素的数组。</p><p id="9b86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了进行更高级的匹配<code class="fe mj mk ml lz b">varargAll</code>允许提供一个lambda，该lambda将设置所有参数(除了前缀和后缀)都应该被满足的条件。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="588c" class="md kw in lz b gy me mf l mg mh">every { mock.example(1, 2, *varargAll { it &gt; 5 }, 9) } returns 10</span></pre><p id="771a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这与以下参数数组匹配:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="c60d" class="md kw in lz b gy me mf l mg mh">mock.example(1, 2, 5, 9)</span><span id="3bb2" class="md kw in lz b gy mi mf l mg mh">mock.example(1, 2, 5, 6, 9)</span><span id="7e72" class="md kw in lz b gy mi mf l mg mh">mock.example(1, 2, 5, 6, 7, 9)</span></pre><p id="c404" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="f73a" class="md kw in lz b gy me mf l mg mh">mock.example(1, 2, 5, 5, 5, 9)</span></pre><p id="3431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">诸如此类。</p><p id="f3ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，在这个lambda的范围内，<code class="fe mj mk ml lz b">position</code>和<code class="fe mj mk ml lz b">nArgs</code>属性可用于允许更复杂的匹配表达式。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="9fcb" class="md kw in lz b gy me mf l mg mh">every { mock.example(1, *varargAll { nArgs &gt; 5}) } returns 6</span></pre><p id="e024" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有在向第一个参数为<code class="fe mj mk ml lz b">1</code>的<code class="fe mj mk ml lz b">example</code>传递<code class="fe mj mk ml lz b">6</code>或更多参数时才会匹配</p><p id="9bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">varargAny</code>是一个类似的构造，需要至少一个元素来匹配lambda中传递的条件。前缀、后缀、参数<code class="fe mj mk ml lz b">position</code>和<code class="fe mj mk ml lz b">nArgs</code>等其他都是一样的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mq"><img src="../Images/74dc22aa649dd9ed2d06edaec03c1843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhUViaGbL9agEj14-2MckA.jpeg"/></div></div></figure><h1 id="6cb5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">扩展和顶级函数</h1><p id="9c7e" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了成功地模仿扩展和顶级函数，你需要理解它是如何工作的。</p><h2 id="6df0" class="md kw in bd kx mr ms dn lb mt mu dp lf jv mv mw lj jz mx my ln kd mz na lr nb bi translated">顶级功能</h2><p id="a1a7" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">首先，让我展示如何模拟顶级函数。</p><p id="1f71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kotlin将这些函数翻译成为您的源代码片段创建的特殊类的<code class="fe mj mk ml lz b">static</code>方法。因此，如果在字节码级别的<code class="fe mj mk ml lz b">Code.kt</code>源文件中有<code class="fe mj mk ml lz b">lowercase</code>，它将使用<code class="fe mj mk ml lz b">lowercase</code>静态方法创建<code class="fe mj mk ml lz b">CodeKt</code>类。</p><p id="ed50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，下面的例子:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="fe1c" class="md kw in lz b gy me mf l mg mh">// Code.kt source file</span><span id="a1c5" class="md kw in lz b gy mi mf l mg mh">package pkg</span><span id="efcf" class="md kw in lz b gy mi mf l mg mh">fun lowercase(str: String): String {...}</span></pre><p id="73f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">翻译过来就是:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="4bd0" class="md kw in lz b gy me mf l mg mh">package pkg;</span><span id="ddb3" class="md kw in lz b gy mi mf l mg mh">class CodeKt {<br/>    public static String lowercase(String str) {...}<br/>}</span></pre><p id="60d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在因为你不能在你的Kotlin代码中引用类<code class="fe mj mk ml lz b">CodeKt</code>，你需要通过使用字符串参数告诉MockK这个类名给<code class="fe mj mk ml lz b">mockkStatic</code>。之后<code class="fe mj mk ml lz b">lowercase</code>可能会用在不同的嘲讽表达中。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="97e4" class="md kw in lz b gy me mf l mg mh">mockkStatic("pkg.CodeKt")</span><span id="de84" class="md kw in lz b gy mi mf l mg mh">every { lowercase("A") } returns "lowercase-abc"</span></pre><p id="240c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要确切地知道像<code class="fe mj mk ml lz b">lowercase</code>这样的函数将在哪里登陆，你需要检查构建产生的实际类文件。</p><p id="1a76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时候名字很花哨。例如:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="a937" class="md kw in lz b gy me mf l mg mh">mockkStatic("kotlin.io.FilesKt__UtilsKt")<br/>every { File("abc").endsWith(any&lt;String&gt;()) } returns <strong class="lz io">true</strong></span></pre><p id="737b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Kotlin中有一个特殊的指令来指导编译器把这样的顶级函数放在什么文件中。它叫做<code class="fe mj mk ml lz b">@file:JvmName</code></p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="3b47" class="md kw in lz b gy me mf l mg mh">@file:JvmName("KHttp")</span><span id="226d" class="md kw in lz b gy mi mf l mg mh"><strong class="lz io">package</strong> khttp<br/>// ... KHttp code</span></pre><p id="b5a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mj mk ml lz b">mockkStatic</code>中，你只需要使用这个名字:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="7440" class="md kw in lz b gy me mf l mg mh">mockkStatic("khttp.KHttp")</span></pre><h2 id="14b1" class="md kw in bd kx mr ms dn lb mt mu dp lf jv mv mw lj jz mx my ln kd mz na lr nb bi translated">附加到类或对象的扩展函数</h2><p id="e629" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">模仿绑定到类或对象的扩展函数也需要一些解释。</p><p id="7107" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您需要理解，字节码级别的分派接收器(<code class="fe mj mk ml lz b">this</code>与包含扩展函数声明的类或对象相关)是作为JVM <code class="fe mj mk ml lz b">this</code>传递的。</p><p id="dfb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">扩展接收器(<code class="fe mj mk ml lz b">this</code>与我们正在执行的类扩展相关)将是字节码级别的第一个参数。这样就有可能为扩展接收器放置一个参数匹配器。在字节码层次上，它将是最后的第一个参数。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="abc9" class="md kw in lz b gy me mf l mg mh">class ExtensionExample {<br/>    fun String.concat(other: String): String<br/>}</span><span id="dc23" class="md kw in lz b gy mi mf l mg mh">val mock = mockk&lt;ExtensionExample&gt;()</span><span id="ea23" class="md kw in lz b gy mi mf l mg mh">with (mock) {<br/>    every { any&lt;String&gt;().concat(any&lt;String&gt;()) } returns "result"<br/>}</span></pre><h2 id="a778" class="md kw in bd kx mr ms dn lb mt mu dp lf jv mv mw lj jz mx my ln kd mz na lr nb bi translated">顶级扩展函数</h2><p id="f743" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">要模仿顶级扩展函数，您需要结合这两种方法。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="18a6" class="md kw in lz b gy me mf l mg mh">// Code.kt source file<br/>package pkg</span><span id="635f" class="md kw in lz b gy mi mf l mg mh">fun String.concat(other: String): String</span></pre><p id="48fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在测试中，您需要创建静态模拟，并调用带有参数匹配器的函数作为参数:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="5906" class="md kw in lz b gy me mf l mg mh">mockkStatic("pkg.CodeKt")<br/>every { any&lt;String&gt;().concat(any&lt;String&gt;()) } returns "fake value"</span></pre><p id="abcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，您可以使用常量或常量和匹配器的组合来代替参数:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="ca30" class="md kw in lz b gy me mf l mg mh">mockkStatic("pkg.CodeKt")<br/>every { "abc".concat("def") } returns "abc-and-def"</span></pre><p id="0695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这个解释能让嘲笑扩展和顶级函数的尝试不那么痛苦。如果没有，请让我在评论中知道什么是不清楚的，我会努力调整文章，以便更好地理解。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nc"><img src="../Images/ebfd5834b6553858e67bc2165dd54fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pb_OEy4WHNDkF9qd2xlqrA.jpeg"/></div></div></figure><h1 id="d73e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">对象和枚举模拟</h1><p id="2199" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">嘲讽对象很简单。你只需将一个对象传递给<code class="fe mj mk ml lz b">mockkObject</code>，对象就变成了<code class="fe mj mk ml lz b">spy</code>。这使得仍然可以像使用原始对象一样使用它，但是您可以存根、记录和验证行为。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="450a" class="md kw in lz b gy me mf l mg mh">object ExampleObject {<br/>    fun sum(a: Int, b: Int): Int<br/>}</span><span id="ef76" class="md kw in lz b gy mi mf l mg mh">mockkObject(ExampleObject)<br/>every { ExampleObject.sum(5, 7) } returns 10</span></pre><p id="4616" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法可以应用于任何对象。从类、由<code class="fe mj mk ml lz b">object</code>子句声明的对象、伴随对象或<code class="fe mj mk ml lz b">enum class</code>元素创建。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nd"><img src="../Images/61bc2717de59c17572f7336bb22cb8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqZ7qbggNEW-fSGcIQs2Jw.jpeg"/></div></div></figure><h1 id="8d86" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">单元返回函数的模拟松弛</h1><p id="2ef4" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">严格是一件好事，但是有时候有很多语句模拟函数返回<code class="fe mj mk ml lz b">Unit</code>而没有真实的行为或结果是没有意义的。在这种情况下，MockK在完全严格和完全宽松之间提供了一种折衷。</p><p id="f081" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以创建一个所谓的“单元返回函数的模拟松弛”:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="392c" class="md kw in lz b gy me mf l mg mh">val mock = mockk&lt;ExampleClass&gt;(<!-- -->relaxUnitFun<!-- --> = true)</span></pre><p id="06c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这种返回<code class="fe mj mk ml lz b">Unit</code>的模拟函数，您没有义务指定行为。这样，您可以减少样板文件，并在所有其他情况下保持严格性。</p><h1 id="665d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">模拟函数不返回任何内容</h1><p id="e7b6" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">返回<code class="fe mj mk ml lz b">Nothing</code>是Kotlin语言中的特例。</p><p id="9a99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，您有一个不返回任何内容的函数:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="730d" class="md kw in lz b gy me mf l mg mh">fun quit(status: Int): Nothing {<br/>    exitProcess(status)<br/>}</span></pre><p id="b8be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了嘲弄它而不滥用类型系统和运行时，你唯一的选择就是<code class="fe mj mk ml lz b">throw</code>一个异常:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="be47" class="md kw in lz b gy me mf l mg mh">every { quit(1) } throws Exception("this is a test")</span></pre><h1 id="a9a7" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">构造函数模拟</h1><p id="47e2" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">要将刚刚创建的(用构造函数初始化的)对象转换成对象模仿，可以使用所谓的构造函数模仿。通常，您应该避免这样的设计，或者将对象或工厂注入到被测试的对象中，但是有时别无选择。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="5dc4" class="md kw in lz b gy me mf l mg mh">class MockCls {<br/>  fun add(a: Int, b: Int) = a + b<br/>}</span><span id="f655" class="md kw in lz b gy mi mf l mg mh">mockkConstructor(MockCls::class)</span><span id="6c3e" class="md kw in lz b gy mi mf l mg mh">every { anyConstructed&lt;MockCls&gt;().add(1, 2) } returns 4</span><span id="39e2" class="md kw in lz b gy mi mf l mg mh">MockCls().add(1, 2) // returns 4</span></pre><p id="f421" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里你可以看到，使用了<code class="fe mj mk ml lz b">anyConstructed</code>来表示为某个类构造的所有对象。没有更好的粒度，您无法区分构造函数。尽管在Kotlin中通常只创建一个主构造函数。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/91d9d12e381db59d3e203fc2bcdc6e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nR_J_gv40SDycCNRI0I4Pw.jpeg"/></div></div></figure><h1 id="71bb" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">私有函数模拟</h1><p id="77ad" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在极少数情况下，可能需要模仿私有函数。这很乏味，因为你不能直接调用这样的函数。通常，不建议使用这种方法。科特林有一个很好的<code class="fe mj mk ml lz b">internal</code>修改器，从测试中可以看出。</p><p id="b7ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论如何，情况可能不同，说这根本不应该使用是对复杂世界的过度简化。</p><p id="d7f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要问题是这样一个<code class="fe mj mk ml lz b">private</code>函数应该被动态引用，并且参数的类型应该完全匹配以通过反射来选择它:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="015b" class="md kw in lz b gy me mf l mg mh">every { mock["sum"](any&lt;Int&gt;(), 5) } returns 25</span></pre><p id="40e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一件事是，这样的呼叫在默认情况下不会被记录，否则它们会影响<code class="fe mj mk ml lz b">verifyAll</code>、<code class="fe mj mk ml lz b">verifySequenece</code>或<code class="fe mj mk ml lz b">confirmVerified</code>构造。要启用录制，请通过<code class="fe mj mk ml lz b">recordPrivateCalls = true</code> <strong class="jm io"> </strong>至<code class="fe mj mk ml lz b">mockk</code>或<code class="fe mj mk ml lz b">spyk</code>功能。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="7ade" class="md kw in lz b gy me mf l mg mh"><strong class="lz io">val</strong> mock = spyk(ExampleClass(), recordPrivateCalls = <strong class="lz io">true</strong>)</span></pre><p id="9e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，还有[]运算符的替代表达式:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="924a" class="md kw in lz b gy me mf l mg mh">every {<br/>    mock invoke "openDoor" withArguments listOf("left", "rear")<br/>} returns "OK"</span><span id="3a55" class="md kw in lz b gy mi mf l mg mh">verify {<br/>    mock invoke "openDoor" withArguments listOf("left", "rear")<br/>}</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/9a45dafc64ee609442fbaf12dc162791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlUqWAafnrU5J7DJ7cSCog.jpeg"/></div></div></figure><h1 id="7d39" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">属性模拟</h1><p id="6462" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">通常，您可以模仿属性，就好像它是<code class="fe mj mk ml lz b">get/set…</code>函数或<code class="fe mj mk ml lz b">field</code>访问一样。但是如果您有<code class="fe mj mk ml lz b">private</code>属性，或者您需要更详细的语法，或者您需要访问<code class="fe mj mk ml lz b">field</code>，您可以使用替代方法:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="e99b" class="md kw in lz b gy me mf l mg mh">every { mock getProperty "speed" } returns 33<br/>every { mock setProperty "acceleration" value less(5) } just Runs</span><span id="9e6f" class="md kw in lz b gy mi mf l mg mh">verify { mock getProperty "speed" }<br/>verify { mock setProperty "acceleration" value less(5) }</span><span id="3f06" class="md kw in lz b gy mi mf l mg mh">every {<br/>   mock.property<br/>} answers { fieldValue + 6 }</span><span id="3e85" class="md kw in lz b gy mi mf l mg mh">every {<br/>    mock.property = any()<br/>} propertyType Int<strong class="lz io">::</strong>class answers { fieldValue += value }</span><span id="456d" class="md kw in lz b gy mi mf l mg mh">every {<br/>    mock getProperty "property"<br/>} propertyType Int<strong class="lz io">::</strong>class answers { fieldValue + 6 }</span><span id="0f21" class="md kw in lz b gy mi mf l mg mh">every {<br/>    mock setProperty "property" value any&lt;Int&gt;()<br/>} propertyType Int<strong class="lz io">::</strong>class answers  { fieldValue += value }</span><span id="fdb6" class="md kw in lz b gy mi mf l mg mh">every {<br/>    mock.property = any()<br/>} propertyType Int<strong class="lz io">::</strong>class answers {<br/>    fieldValue = value + 1<br/>} andThen {<br/>    fieldValue = value - 1<br/>}</span></pre><p id="7ee5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，你可以看到<code class="fe mj mk ml lz b">propertyType</code>是一种特殊的属性提示，以防编译器不直接向MockK提供该信息。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nf"><img src="../Images/60afa8820b4832f3e3222ec512ef541b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uT7Z5O9wkA2TrO8kK3QZug.jpeg"/></div></div></figure><h1 id="12da" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">班级模拟</h1><p id="e2a0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">当你需要创建一个由反射<code class="fe mj mk ml lz b">KClass</code>对象指定的任意类的模拟时，你可以使用<code class="fe mj mk ml lz b">mockkClass</code>函数。</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="f89c" class="md kw in lz b gy me mf l mg mh">val mock = mockkClass(ExampleClass::class)</span></pre><h1 id="4c9e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">设置</h1><p id="5c06" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">MockK支持很少的全局开关。要激活它们，您应该根据这个模板将<code class="fe mj mk ml lz b">io/mockk/settings.properties</code>放在您的类路径中:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="2f2a" class="md kw in lz b gy me mf l mg mh">relaxed=true|false<br/>relaxUnitFun=true|false<br/>recordPrivateCalls=true|false</span></pre><p id="d5c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许在默认情况下放松模拟，或者为返回函数的单元放松模拟，或者记录私有调用。</p><h1 id="4167" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">清除</h1><p id="c051" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">到目前为止，关于正确清理有许多问题。我意识到这是一个重要的话题，我想提出一个很好的解决方案。虽然现在我还不了解所有的情况，但这可能会是突破性的改变。</p><p id="31a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我将只告诉当前的函数集在做什么。<code class="fe mj mk ml lz b">clear</code>函数删除与模仿相关的对象的内部状态，<code class="fe mj mk ml lz b">unmock</code>函数返回类的转换。</p><p id="afdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">clearAllMocks</code> —清除所有嘲笑。如果您有简单的顺序测试，这将是一个最佳选择。</p><p id="ebd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">clearMocks</code> —清除特别指定的规则或对象模拟。在并行测试中很有价值，因为<code class="fe mj mk ml lz b">clearAllMocks</code>可能会干扰你的其他测试。</p><p id="fb75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">clearStaticMockk</code>、<code class="fe mj mk ml lz b">clearConstructorMockk</code> —类似地清理特别指定的静态或构造函数模拟。我认为如果你在并行测试中使用相同的类，你会遇到麻烦。测试框架需要用不同的类加载器隔离测试。我不确定是否有框架在这么做。</p><p id="3414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">unmockkObject</code> —返回特定规则或对象模拟的转换。</p><p id="5c33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">unmockkAll</code> —同样，如果您只有顺序测试，并且需要将所有内容恢复到初始状态，这可能是最佳选择。</p><p id="c107" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">unmockkStatic</code>、<code class="fe mj mk ml lz b">unmockkConstructor</code> —静态模拟的返回转换。类似于<code class="fe mj mk ml lz b">clearStaticMock</code>的情况——对相同的类进行并行测试可能不安全。</p><p id="faf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml lz b">mockkObject</code>、<code class="fe mj mk ml lz b">mockkStatic</code>、<code class="fe mj mk ml lz b">mockkConstructor</code>有最后一个参数为λ的版本。之后会做相应的<code class="fe mj mk ml lz b">unmockk</code>操作:</p><pre class="kk kl km kn gt ly lz ma mb aw mc bi"><span id="db1e" class="md kw in lz b gy me mf l mg mh">inline fun mockkStatic(vararg classes: String, block: () -&gt; Unit) {<br/>    mockkStatic(*classes)<br/>    try {<br/>        block()<br/>    } finally {<br/>        unmockkStatic(*classes)<br/>    }<br/>}</span></pre><p id="01d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">清理工作到此为止。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/52ce02b040bc50b5ea473924fc085616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0s5iRQQcjTbhZ70jojiLQ.jpeg"/></div></div></figure><p id="368d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一系列文章中，我们讨论了与嘲讽和<a class="ae ki" href="https://mockk.io" rel="noopener ugc nofollow" target="_blank">嘲讽</a>相关的所有主题。从最基本的到高级功能。这篇文章是关于高级特性的。mock有一个非常广泛的集合:分层模拟、协程、验证超时、验证确认&amp;记录排除、变量、扩展&amp;顶级函数、对象&amp;枚举模拟、单元返回函数的模拟宽松、不返回任何内容的模拟函数、构造函数模拟、私有函数模拟、属性模拟、类模拟、设置和清理。</p><p id="0eca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢大家！</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://kt.academy/article"><div class="gh gi no"><img src="../Images/5cf9179effdb3e8ab1a9bf39598fdfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNxjFpvGWzjC5h4VRjLyCw.png"/></div></a></figure><h2 id="0cbb" class="md kw in bd kx mr ms dn lb mt mu dp lf jv mv mw lj jz mx my ln kd mz na lr nb bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="2ae5" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ki" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ki" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://twitter.com/ktdotacademy"><div class="gh gi no"><img src="../Images/bf0a5f94aadb4cca1bc11e05f6dfcb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7TYzvm0wvmewBX67TFH4A.png"/></div></a></figure></div></div>    
</body>
</html>