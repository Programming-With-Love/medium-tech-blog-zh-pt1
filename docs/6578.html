<html>
<head>
<title>Write a Web Service with Go Plug-Ins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go插件编写一个Web服务</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/write-a-web-service-with-go-plug-ins-c0472e0645e6?source=collection_archive---------0-----------------------#2019-02-20">https://medium.com/quick-code/write-a-web-service-with-go-plug-ins-c0472e0645e6?source=collection_archive---------0-----------------------#2019-02-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d98364f4146db35398dbcf036610b378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVKB83GozPulENVR-rMV6Q.jpeg"/></div></div></figure><div class=""/><p id="5789" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/quick-code/web-service-modulari-con-go-plug-in-7f59d4b15d61"> <em class="jo">意大利版！</em>T3】</a></p><p id="cb5f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文的目标是研究为什么以及如何构建一个模块化的web服务。</p><p id="5e7a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在一个自动化驱动的环境中，有许多条件将项目演进带入地狱。其中一些来自非模块化环境。</p><p id="7a01" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使你在一个微服务架构上，用一种编译过的语言，所有这些情况都会导致重新构建整个服务项目:</p><ul class=""><li id="98cf" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">编辑项目单个部分的工作方式。</li><li id="fd98" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">优化单个端点的纵向扩展。</li></ul><p id="9b09" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，你会面临一些不舒服的情况:</p><ul class=""><li id="3a44" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">将您在一个服务中的相同行为重用到另一个服务中。</li><li id="10f6" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated"><em class="jo">你可能只能使用一种编程语言。</em></li><li id="ab53" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">如果你有一个团队，你需要分享整个项目(离岸项目中的这件小事可能非常糟糕)。</li></ul><p id="b1ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">借助插件架构，您可以将服务开发为一组组件，从而能够:</p><ul class=""><li id="9429" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">拥有职能专用团队</li><li id="e941" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">具有滚动更新的组件的分离部署。</li><li id="f7a2" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">在多个项目中重用一个组件。</li><li id="7306" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">通过配置必须包含的winch组件，自定义如何扩展服务。</li><li id="8c90" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">最后但同样重要的是，您可以用构建库的每种语言来开发组件！</li></ul></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><h1 id="69f6" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">体系结构</h1><p id="8d5e" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">以web服务为例，我们可以将我们的项目分成以下几个部分:</p><ul class=""><li id="73e7" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">核心:它将读取配置、加载组件、监听和服务HTTP。</li><li id="bad4" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">控制器:一个HTTP处理函数。</li><li id="3371" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">中间件:检查请求是否被授权访问控制器的组件。</li></ul><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ln"><img src="../Images/8181e7489b31fbd36e88d3ababb40c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1d_Xc0oiZbgYTMbIv8SwTg.png"/></div></div></figure><p id="0e36" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，如果您将核心更新到HTTPS，您可以只重新部署核心文件，并且只为需要符合HTTPS标准的服务重新部署<em class="jo">。同样，如果你更新JWT插件来使用一个新的散列方法，你只需要重新部署插件并重新加载核心。使用<a class="ae jn" href="https://blog.coursesity.com/best-golang-tutorials/" rel="noopener ugc nofollow" target="_blank">最佳Golang教程</a>在线学习或提高您的Golang技能。</em></p><h1 id="fe6b" class="kk kl hs bd km kn ls kp kq kr lt kt ku kv lu kx ky kz lv lb lc ld lw lf lg lh bi translated"><strong class="ak">架构组件</strong></h1><h2 id="d2a4" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">控制器</h2><p id="6bb0" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">控制器是一个HTTP处理函数，它将逻辑应用于请求，以构建并返回响应。</p><h2 id="b30d" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">中间件</h2><p id="e6fe" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">这种类型的对象产生于需要做的事情，如过滤、跟踪或记录传入的请求，而不涉及管理它的所有项目。</p><p id="e61a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一种中间件可以是IP过滤器:您希望只允许特定的IP访问您的服务。当请求到达您的服务器时，您可以直接检查源IP是否在您的白名单中。这样，你就不用加载服务的其他部分了。</p><p id="62eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其中一个优势是降低了在恶意情况下暴露细节的风险。</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ml"><img src="../Images/804910bd11ffb671a2b00bd515de72b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vo-RnVKZu3_4vlVGReUqg.png"/></div></div></figure><p id="5cad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例:让我们创建另一个检查访问头的中间件。现在，<em class="jo">链接</em>它与以前的IP中间件，只有在我们的IP池授权的用户可以访问服务。</p><p id="99c8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，如果控制器的第一步是查询您的数据库中的用户数据，那么您就不会受到SQL注入的攻击。这是因为如果所有先决条件都满足，您就不会开始与DB通信。</p><h2 id="9b07" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">核心</h2><p id="2f9a" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">如前所述，对于这个项目，我们使用<a class="ae jn" href="https://golang.org/pkg/plugin/" rel="noopener ugc nofollow" target="_blank">插件</a>功能来分离组件。对于我们的范围，核心组件将负责加载控制器和中间件插件，使用配置文件将其映射到端点，最后启动HTTP侦听器。</p><p id="56bc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有其他路由将返回“404未找到”。</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/f51130101f398bd818e527160d8581fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AP7etBWgIvojKOBmyekj1Q.png"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx">Mapping middlewares and controller to an endpoint</figcaption></figure><p id="1fe5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种级别的独立性很容易被云用例所接受:</p><figure class="lo lp lq lr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mr"><img src="../Images/0b06249f24fa7d5d93f2b9aa2d6d1220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BK_xZldGL7_fnuZZvA2t9g.png"/></div></div></figure></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><h1 id="87b9" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">履行</h1><p id="8500" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">让我们从一个基本的<em class="jo">内核</em>开始，它带有一个<em class="jo">控制器(HTTP函数处理器)</em>来响应我们的家:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="0db9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在此基础上，添加实现中间件所需的结构:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">The middleware type</figcaption></figure><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx">…and a Chain function that provide a mechanism to concatenate middlewares</figcaption></figure><p id="7903" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在构建一个示例中间件:方法中间件检查HTTP方法和作为参数传递的方法之间的匹配。否则，返回一个400错误请求。</p><p id="770b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本例中的参数是一系列被认可的HTTP方法，我们需要对它们进行分割和检查:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="cd20" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是时候在链内附加中间件了，在函数参数中传递您希望允许的HTTP方法。</p><p id="b078" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后将这个链传递给我们的基本HTTP服务中的HandlerFunc:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="997d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完整的<a class="ae jn" href="https://github.com/Bebbolus/gomiddleware" rel="noopener ugc nofollow" target="_blank">示例源代码在这里</a></p></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><h1 id="d528" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">插件</h1><blockquote class="mu"><p id="3de8" class="mv mw hs bd mx my mz na nb nc nd jm dx translated">注意:它只能在Linux上工作，但是容器提供了一个很好的解决方法。</p></blockquote><p id="d47d" class="pw-post-body-paragraph ip iq hs ir b is ne iu iv iw nf iy iz ja ng jc jd je nh jg jh ji ni jk jl jm ha bi translated">一个插件的包需要是“主”的。像这样，包看不到“真正的”主包中的实体，比如类型和函数。所以，作为一个建议，尽可能保持插件的愚蠢。</p><p id="be32" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在插件内部，您必须导出一个变量或函数作为要加载的符号</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="d2aa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要构建插件，我们需要使用-buildmode=plugin标志并指定结果名称</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="fe34" class="lx kl hs nk b fi no np l nq nr">$go build -buildmode=plugin -o first.so first.go</span></pre><blockquote class="mu"><p id="064c" class="mv mw hs bd mx my ns nt nu nv nw jm dx translated">你已经创建了你的第一个插件！</p></blockquote><p id="f446" class="pw-post-body-paragraph ip iq hs ir b is ne iu iv iw nf iy iz ja ng jc jd je nh jg jh ji ni jk jl jm ha bi translated">在您的path ad中搜索，您将看到first.so文件，这是一个<strong class="ir ht">标准库，您可以用支持它的任何语言导入它。</strong></p><p id="9403" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我为你感到骄傲，我的小学徒…让我们把它用在围棋上:</p><p id="f409" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个新文件“main.go ”,并加载您之前创建的库文件:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="dafd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">添加符号搜索代码:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="f850" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您可以从“main.go”中的插件使用您的功能:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="f13f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">奔跑</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="73f8" class="lx kl hs nk b fi no np l nq nr">$ go run main.go</span></pre><p id="5ebd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你会看到的</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="47f5" class="lx kl hs nk b fi no np l nq nr">Hello FROM PLUGIN!!!</span></pre><p id="d97f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/Bebbolus/gomiddleware" rel="noopener ugc nofollow" target="_blank">此处示例源代码</a></p><p id="0c02" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是时候继续“Oop风格”了，从插件中获得不止一个功能。</p><p id="f5fd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用一种类型来改进first.go插件，通过这种类型，您可以将函数作为方法附加，然后导出一个变量符号，将该类型作为对象引用:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="86ab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您必须以一种更安全的方式来更改导入的类型。</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><h1 id="3bd0" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">插件实现</h1><p id="99cd" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">这时你知道:</p><ul class=""><li id="4817" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">项目目标是什么</li><li id="136f" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">目标架构是什么</li><li id="a863" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">核心是什么</li><li id="5daf" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">什么是控制器</li><li id="9c98" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">什么是中间件</li><li id="dcf9" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">如何构建插件并使用它</li></ul><p id="caf4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您已经准备好构建“控制器”插件了！</p><p id="0790" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的存储库中创建一个插件文件夹:</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="6e66" class="lx kl hs nk b fi no np l nq nr">$mkdir plugins</span></pre><p id="d833" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在里面我们创建了两个文件夹，一个用于中间件，一个用于控制器</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="15cb" class="lx kl hs nk b fi no np l nq nr">$cd plugins<br/>$mkdir controller<br/>$mkdir middlewares</span></pre><h2 id="f842" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">构建控制器</h2><p id="8c5f" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">在<code class="du nx ny nz nk b">plugins/controllers</code>文件夹中创建<code class="du nx ny nz nk b">general.go</code>:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="03c1" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">构建中间件</h2><p id="3288" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">现在导出你之前做的方法中间件，在插件里面。</p><p id="b5c4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du nx ny nz nk b">plugins/middlewares</code>文件夹下创建<code class="du nx ny nz nk b">method.so</code>:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="6442" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建插件:</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="a934" class="lx kl hs nk b fi no np l nq nr">$go build -buildmode=plugin -o plugins/middlewares/method.so plugins/middlewares/method.go</span><span id="7e27" class="lx kl hs nk b fi oa np l nq nr">$go build -buildmode=plugin -o plugins/controllers/genearal.so plugins/controllers/genearal.go</span></pre></div><div class="ab cl kd ke go kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ha hb hc hd he"><h1 id="c138" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">导入插件</h1><p id="5406" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">要导入插件，您将从一个配置文件中加载它，该配置文件将端点映射到中间件和控制器。</p><p id="6912" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du nx ny nz nk b">routes.json</code>的样貌是这样的:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="e4dd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这种方式创建文件，您可以将<strong class="ir ht">几个</strong>中间件附加到一个路由，并在几个路由中使用一个中间件。</p><h2 id="e15c" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">阅读配置</h2><p id="78bc" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">现在，您可以继续读取配置并将其映射到一个struct(使用<a class="ae jn" href="https://mholt.github.io/json-to-go/" rel="noopener ugc nofollow" target="_blank">这个</a>工具可以非常简单地将json转换成go struct):</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="a7b1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们创建一个函数来读取JSON:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="e87c" class="lx kl hs bd km ly lz ma kq mb mc md ku ja me mf ky je mg mh lc ji mi mj lg mk bi translated">加载插件</h2><p id="ad20" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">当您从插件中调用导出的类型方法时，我们需要采用一些约定，我选择了:</p><ul class=""><li id="affb" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">具有方法Fire()的控制器类型</li><li id="5251" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">具有方法Pass()的中间件类型</li></ul><p id="c71d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">进入配置，我们可以动态地链接库:</p><blockquote class="ob oc od"><p id="acc9" class="ip iq jo ir b is it iu iv iw ix iy iz oe jb jc jd of jf jg jh og jj jk jl jm ha bi translated">来自”插件。Open”文档:如果一个路径已经打开，那么现有的*插件将被返回，它对于多个goroutines的并发使用是安全的。</p></blockquote><p id="21a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">负载控制器插件:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="3308" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">加载要在路线上附加的中间件模块:</p><figure class="lo lp lq lr fd hj"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="7bfd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以将所有这些放在一起，启动web服务器并测试我们的服务。</p><pre class="lo lp lq lr fd nj nk nl nm aw nn bi"><span id="0d53" class="lx kl hs nk b fi no np l nq nr">$go build -o start -v</span></pre><p id="5ed2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在完整的<a class="ae jn" href="https://github.com/Bebbolus/gostron" rel="noopener ugc nofollow" target="_blank">资源库中看到</a>具有的其他功能:</p><ul class=""><li id="5273" class="jp jq hs ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">创建插件支架的脚本</li><li id="9cce" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">makefile来构建全部并清除全部</li><li id="b2e2" class="jp jq hs ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">标准实施测试</li></ul></div></div>    
</body>
</html>