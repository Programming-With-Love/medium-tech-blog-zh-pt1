<html>
<head>
<title>How to Write UI components with optionally controlled state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写具有可选受控状态的UI组件</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/writing-ui-components-with-optionally-controllable-state-86e396a6f1ec?source=collection_archive---------2-----------------------#2019-02-22">https://medium.com/quick-code/writing-ui-components-with-optionally-controllable-state-86e396a6f1ec?source=collection_archive---------2-----------------------#2019-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/db385e95a3c263738bab5bb91d85f514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kteElAHLXuG6Wm7h0lnS1g.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="http://time.com/4494496/tesla-mobileye-autopilot-safety/" rel="noopener ugc nofollow" target="_blank">image source</a></figcaption></figure><p id="e76f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">广泛的用户界面元素恰好是以下抽象的一个例子:</p><blockquote class="js jt ju"><p id="7a41" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated"><em class="hh">屏幕的一部分，根据某个</em> <strong class="iw hi"> <em class="hh">值</em> </strong> <em class="hh">(状态)以不同方式显示，并为</em> <strong class="iw hi"> <em class="hh">改变</em> </strong> <em class="hh">该值提供一组交互。</em></p></blockquote><p id="71d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如:</p><ul class=""><li id="9ac4" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">一个普通的旧input元素:它显示输入中的值，并提供一些改变该值的方法(键入、粘贴、拖动、撤销/重做等)。</li><li id="d995" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">zippy/accordion(一个标题和一个可折叠的内容):它显示基于<strong class="iw hi">打开</strong>状态展开或折叠的内容，并提供一些更改(切换)的方法(单击标题)。</li><li id="2c41" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">可调整大小的窗口:它显示一个矩形表面，其位置和大小基于表单<strong class="iw hi"> {x，y，width，height} </strong>的值，并且它提供了一些更改该值的方法(拖动窗口标题来移动它，或者拖动其角上的调整大小手柄来调整它的大小)。</li></ul><p id="e6d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，是<strong class="iw hi">值</strong>和提供的<strong class="iw hi">变化机制</strong>定义了这些UI元素中的每一个。在本文的其余部分，我们将深入探讨实现这种“状态和变更机制”的方法。虽然这几乎是一个框架不可知的主题，但我选择了React，它让我们用<a class="ae it" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">钩子</strong> </a> <strong class="iw hi">提出了一个非常简洁和通用的解决方案。</strong></p><p id="3352" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们继续使用zippy组件作为一个简单但真实的例子。这是zippy的样子。您可以单击标题来切换内容。就是这样:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of a Zippy component</figcaption></figure><p id="8f2e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与您选择的框架无关，zippy组件的实现主要由这两部分逻辑组成:</p><ul class=""><li id="7b61" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">基于<code class="du kt ku kv kw b">open</code>值显示或隐藏细节。</li><li id="a891" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">处理点击标题，切换<code class="du kt ku kv kw b">open</code>值。</li></ul><p id="2f14" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将该值的状态保存在组件中，并通过处理用户在标题上的点击来更新它，这可能很有吸引力。<br/>下面是一个非常简单的zippy组件的实现，它将自己的<code class="du kt ku kv kw b">open</code>状态保存为本地状态值:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Zippy1.tsx</figcaption></figure><p id="0e3d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从UX的角度来看，它完全符合活泼的定义。它的用法也相当简单。你只需要这样指定头和内容:<code class="du kt ku kv kw b">&lt;Zippy header="..."&gt;content&lt;/Zippy&gt;</code>。仅此而已。你有一个工作的活力。但是如果你想在zippy打开的时候做点什么呢？zippy组件上应该有一个API (prop ),让您知道它何时被切换(值被更改)。<br/>我们可以简单地在现有实现中添加一个<code class="du kt ku kv kw b">onToggle</code>道具:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Zippy2.tsx</figcaption></figure><p id="27e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">父组件现在可以得到zippy状态变化的通知，但它仍然无法控制该状态。这种控制有时是必需的。例如，您的页面中可能有一堆这样的文件，您希望根据当前路线来控制打开哪一个。<br/>为了控制组件的状态，我们需要<a class="ae it" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">提升状态</a>并让父组件通过<code class="du kt ku kv kw b">open</code>状态作为输入(prop)。由于我们不再在组件中保存<code class="du kt ku kv kw b">open</code>状态，所以当用户点击标题时，我们所能做的就是让父组件知道用户的意图。由父组件来处理。<br/>这种模式对于拦截用户的动作(例如验证)特别有用。<br/>这是完全由其父组件控制的zippy组件的第三个版本:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Zippy3.tsx</figcaption></figure><p id="f548" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种无状态的实现也是非常简单的，从某种意义上说，我们可以在它的基础上创建有状态的版本(<code class="du kt ku kv kw b">Zippy1</code>)，可能是通过几个更高阶的组件，如<a class="ae it" href="https://github.com/acdlite/recompose/blob/master/docs/API.md#withstate" rel="noopener ugc nofollow" target="_blank"> withState </a>和<a class="ae it" href="https://github.com/acdlite/recompose/blob/master/docs/API.md#withhandlers" rel="noopener ugc nofollow" target="_blank"> withHandlers </a>。换句话说，有状态版本就像无状态版本加上内置的状态管理。</p><p id="b6eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然这个无状态版本让我们可以完全控制它的行为，但是它将状态管理样板文件推到了组件层次结构的更高层。你不再能够通过这样的代码片段获得zippy的工作版本:<code class="du kt ku kv kw b">&lt;Zippy header="..."&gt;content&lt;/Zippy&gt;</code> <br/>你需要这样使用它:<code class="du kt ku kv kw b">&lt;Zippy header="..." open="someSource" onToggle="someHandler"&gt;content&lt;/Zippy&gt;</code>。</p><p id="39ab" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们能有一个灵活的组件，它足够聪明，能判断出我们是否想控制它的状态，那该多好。当我们不想控制它时，它可以表现得像<code class="du kt ku kv kw b">Zippy1</code>一样，而当<code class="du kt ku kv kw b">open</code> prop通过时，它仍然支持对其状态的外部控制。您可能已经注意到，这种行为非常类似于react-dom为原生表单输入提供的<a class="ae it" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">。您可以选择在</a><a class="ae it" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控</a>或<a class="ae it" href="https://reactjs.org/docs/uncontrolled-components.html" rel="noopener ugc nofollow" target="_blank">非受控</a>模式下使用。事实上，在野外有很多组件已经采用了这种模式来支持对状态的可选控制。</p><p id="2efd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以让我们实现另一个版本的zippy组件，它支持对状态的可选控制。为此，我们接受一个可选的<code class="du kt ku kv kw b">open</code>道具。我们还对不受控制的使用保持开放状态。当<code class="du kt ku kv kw b">open</code>道具为<code class="du kt ku kv kw b">undefined</code>时，我们处于非受控模式。为了响应用户的点击，根据是否处于受控模式，我们或者调用<code class="du kt ku kv kw b">onToggle</code>或者设置我们的内部<code class="du kt ku kv kw b">open</code>状态。</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Zippy4.tsx</figcaption></figure><p id="e9dd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们的zippy组件的最高级版本。对其状态的控制是一个可选的特性。如果不受控制地使用zippy，您仍然可以得到切换事件的通知。</p><p id="81a9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这种方法，我们可以将“依赖于状态并提供改变状态方法的UI元素”视为接受两个可选属性的组件:<strong class="iw hi">值</strong>和<strong class="iw hi"> changeHandler </strong>(在Angular中，<code class="du kt ku kv kw b">value </code>是输入，<code class="du kt ku kv kw b">changeHandler </code>是输出)。<br/>根据<strong class="iw hi">值</strong>和<strong class="iw hi">变化处理程序</strong>是否通过，我们有以下4种使用组合，每种组合在特定情况下都有效。</p><ul class=""><li id="aef6" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated"><strong class="iw hi">值</strong>⠀⠀⠀<strong class="iw hi">change handler</strong><br/><strong class="iw hi"><em class="jv">受控</em> </strong> <em class="jv">。</em>值的状态被提升到父组件，并作为属性传递。变更请求也在父组件中处理。<em class="jv"> <br/>示例:</em>只接受数字的输入。选项卡视图，其中选定的选项卡是基于当前路线确定的。</li><li id="7b0a" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">值</strong>⠀⠀⠀<strong class="iw hi">change handler</strong><em class="jv">✗<br/></em><strong class="iw hi"><em class="jv">受控</em> </strong>。值是受控的(强制的),它独立于组件提供的正常更改机制。<em class="jv"> <br/>示例:</em>只读输入。不能移动或调整大小的固定窗口。</li><li id="49da" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">值</strong>t32】✗⠀⠀⠀<strong class="iw hi">change handler<br/>t36】不受控制。</strong>值作为本地状态保存在组件本身中。将通过<code class="du kt ku kv kw b">changeHandler</code>通知父组件值的变化。<br/> <em class="jv">示例</em>:一个可拖动的可调整大小的窗口，它由正常的交互方式控制，但是你想在它被拖动到特定边界之外时显示一个警告。</li><li id="8c2e" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">值</strong><em class="jv">✗</em>⠀⠀⠀<strong class="iw hi">change handler</strong><em class="jv">✗<br/></em><strong class="iw hi"><em class="jv">不受控制。</em> </strong>值作为一个局部状态保存在组件本身中，你不关心它的变化。<em class="jv"> <br/> </em>示例<strong class="iw hi"> : </strong>标签视图、zippy、窗口等。当您只想要该组件的默认功能，而不关心它在任何时候的状态时。</li></ul></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><blockquote class="js jt ju"><p id="43d1" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">“第一次做对一点都不重要。最后一次做对非常重要。”<br/>  —编程的艺术，安德鲁·亨特和戴维·托马斯</p></blockquote><p id="35a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们最终实现的zippy组件(<code class="du kt ku kv kw b">Zippy4</code>)支持受控和非受控模式。但是它的大部分代码(第4-32行)都是针对它的，而不是与zippy本身相关的逻辑(第34-40行)。换句话说，在我们的实现中混合了两种不同的关注。当我们决定实现另一个组件(比如一个时间选择器)时，这一点就变得更加明显了，它具有完全相同的行为，既支持受控使用，也支持不受控使用。</p><p id="f431" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一种排除这种逻辑的方法是<a class="ae it" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">一个特设的</a>。它可以接受关于哪个属性可选地成为有状态的以及哪个属性被认为是改变处理器的配置。事实上，你可以找到一些这样的HOC的现有实现，比如带有不可控道具的<a class="ae it" href="https://github.com/klarna/higher-order-components#withuncontrolledprop-config-component" rel="noopener ugc nofollow" target="_blank">或者不可控道具的</a><a class="ae it" href="https://github.com/jquense/uncontrollable" rel="noopener ugc nofollow" target="_blank"/>。不久前，我还试图用typescript编写一个(我不记得为什么，但可能是因为现有的没有一个是我想要的)，但我很快就陷入了类型定义。过了一段时间，我了解了react的新特性:<a class="ae it" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">钩子</a>。事实证明，很容易“使用”钩子来为<strong class="iw hi">可选控制状态</strong>提出一个简单、可读和直观的解决方案，而不需要额外的努力来使它对类型脚本友好。</p><h2 id="b4e9" class="lf lg hh bd lh li lj lk ll lm ln lo lp jf lq lr ls jj lt lu lv jn lw lx ly lz bi translated">UseControllableState</h2><p id="0002" class="pw-post-body-paragraph iu iv hh iw b ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn me jp jq jr ha bi translated">使用React内置的<code class="du kt ku kv kw b">useState</code>钩子，我们可以在组件中创建一个状态变量。它返回一个有状态的值和一个更新它的函数。它也接受初始值。用<code class="du kt ku kv kw b">useState</code>创建我们的Zippy组件(类似于<code class="du kt ku kv kw b">Zippy1</code>)的有状态(不可控)版本非常简单:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Zippy1WithHook.tsx</figcaption></figure><p id="c79e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在想要的是用props可选地控制状态值(及其设置器)的能力。我们实际上需要一个新版本的<code class="du kt ku kv kw b">useState </code>，它除了<code class="du kt ku kv kw b">initialValue</code>之外，还接受<code class="du kt ku kv kw b">value</code>和<code class="du kt ku kv kw b">changeHandler</code>。我们称之为<code class="du kt ku kv kw b">useControllableState</code>。如果<code class="du kt ku kv kw b">value</code>未定义，我们处于非受控模式，并且<code class="du kt ku kv kw b">useControllableState</code>像正常的<code class="du kt ku kv kw b">useState</code>一样运行，并且在状态改变时也调用<code class="du kt ku kv kw b">changeHandler</code>(如果通过)。否则，我们处于受控模式。</p><p id="3f61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在编写<code class="du kt ku kv kw b">useControllableState</code>之前，让我们编写一些测试，确保它涵盖我们之前讨论过的所有<a class="ae it" href="#aef6" rel="noopener ugc nofollow"> 4种用法。</a></p><p id="d89f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们希望在组件中使用它的方式:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="b5a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这与我们使用<code class="du kt ku kv kw b">useState</code> hook ( <code class="du kt ku kv kw b">Zippy1withHook</code>)的Zippy的有状态版本非常相似。粗略来说，唯一的区别是<code class="du kt ku kv kw b">useState</code>被换成了<code class="du kt ku kv kw b">useControllableState</code>。</p><p id="bc31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还在测试中使用了一个小工具，它装载了我们的组件，并返回一个带有<a class="ae it" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> enzyme </a>包装器和几个实用函数的对象:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="c9f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="#8c2e" rel="noopener ugc nofollow">最后一种用法类型</a>(当<code class="du kt ku kv kw b">value</code>和<code class="du kt ku kv kw b">changeHandler</code>都没有通过时)，是最容易测试的一种:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="0fa5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们为 <code class="du kt ku kv kw b"><a class="ae it" href="#49da" rel="noopener ugc nofollow">value</a></code> <a class="ae it" href="#49da" rel="noopener ugc nofollow">未通过而</a> <code class="du kt ku kv kw b"><a class="ae it" href="#49da" rel="noopener ugc nofollow">changeHandler</a></code> <a class="ae it" href="#49da" rel="noopener ugc nofollow">为</a>时的情况<a class="ae it" href="#49da" rel="noopener ugc nofollow">添加一个测试:</a></p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="f129" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来的两个测试案例用于受控模式。首先，我们测试如果<a class="ae it" href="#7b0a" rel="noopener ugc nofollow">值被传递但是没有改变处理器</a>，点击按钮不会改变值:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="cc4b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们用变更处理器测试<a class="ae it" href="#aef6" rel="noopener ugc nofollow">受控模式:</a></p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kx ks l"/></div></figure><p id="3917" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是我们测试的完整版本:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">useControllableState.test.tsx</figcaption></figure><p id="957f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得注意的是，我们可以在不渲染任何东西的情况下测试<code class="du kt ku kv kw b">useControllableState</code>hook easy<a class="ae it" rel="noopener" href="/@se.mo.moosavi/testing-react-hooks-without-pain-7bc2c26146ed">。</a></p><p id="37c9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编写<code class="du kt ku kv kw b">useControllableState</code>的实现比它看起来要简单:</p><figure class="kn ko kp kq fd ii"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">useControllableState.ts</figcaption></figure><p id="3a3f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它在内部使用状态挂钩来保存状态值。像<code class="du kt ku kv kw b">useState</code>一样，它返回一个值和一个设置器。为了确定该值，我们应该检查我们是否处于受控模式。如果<code class="du kt ku kv kw b">value</code>参数不是<code class="du kt ku kv kw b">undefined</code>，我们处于受控模式，我们返回那个值。否则，我们处于非受控模式，我们返回当前状态值。<br/>对于setter，我们返回一个调用<code class="du kt ku kv kw b">changeHandler</code>的函数，如果通过，还将<code class="du kt ku kv kw b">newValue</code>存储到我们的本地状态(使用我们从<code class="du kt ku kv kw b">useState</code>获得的setter)。如果我们处于受控模式，我们可以跳过设置状态，这在某些情况下会导致较小的性能改进。</p><h2 id="0b57" class="lf lg hh bd lh li lj lk ll lm ln lo lp jf lq lr ls jj lt lu lv jn lw lx ly lz bi translated">进一步的改进</h2><ul class=""><li id="f5ca" class="jz ka hh iw b ix ma jb mb jf mf jj mg jn mh jr ke kf kg kh bi translated"><strong class="iw hi">使用相同的setter函数</strong>:为了与<code class="du kt ku kv kw b">useState</code>钩子更加一致，我们可以使用<a class="ae it" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">回调钩子</a>返回同一个setter，除非<code class="du kt ku kv kw b">changeHandler</code>被改变。我们还需要避免setter中的<a class="ae it" href="https://github.com/facebook/react/issues/14010" rel="noopener ugc nofollow" target="_blank">闭包陷阱</a>。</li><li id="016d" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hi">控制模式改变时的警告</strong>:从受控模式改变到非受控模式(反之亦然)通常是一个无意的错误。在这种情况下，React本身会显示一个警告。我们也可以处理并显示一个警告。</li></ul><p id="443c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">y̵o̵u̵̵c̵a̵n̵̵f̵i̵n̵d̵̵a̵̵b̵e̵t̵t̵e̵r̵̵v̵e̵r̵s̵i̵o̵n̵̵o̵f̵̵<code class="du kt ku kv kw b">u̵s̵e̵C̵o̵n̵t̵r̵o̵l̵l̵a̵b̵l̵e̵S̵t̵a̵t̵e̵</code>̵w̵i̵t̵h̵̵t̵h̵e̵s̵e̵̵e̵n̵h̵a̵n̵c̵e̵m̵e̵n̵t̵s̵̵i̵n̵̵<a class="ae it" href="https://github.com/alirezamirian/react-use-controllable-state/" rel="noopener ugc nofollow" target="_blank">u̵s̵e̵c̵o̵n̵t̵r̵o̵l̵l̵a̵b̵l̵e̵s̵t̵a̵t̵e̵</a>̵n̵p̵m̵̵p̵a̵c̵k̵a̵g̵e̵.</p><p id="092f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">更新(2021–04–24)</strong>:我最近在<a class="ae it" href="https://www.npmjs.com/package/@react-stately/utils" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">@ react-estorary/utils</strong></a>中发现了<a class="ae it" href="https://github.com/adobe/react-spectrum/blob/main/packages/%40react-stately/utils/src/useControlledState.ts" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">usecontrolled state</strong></a>类似的钩子。<a class="ae it" href="https://react-spectrum.adobe.com/react-stately/index.html" rel="noopener ugc nofollow" target="_blank">react-庄严</a>是<a class="ae it" href="https://react-spectrum.adobe.com/index.html" rel="noopener ugc nofollow" target="_blank"> react光谱库</a>的一部分。我推荐用那个代替<a class="ae it" href="https://github.com/alirezamirian/react-use-controllable-state/" rel="noopener ugc nofollow" target="_blank">usecontrolablestate</a>。签名有一点不同，它不支持懒惰默认值。</p><h1 id="a0d3" class="mi lg hh bd lh mj mk ml ll mm mn mo lp mp mq mr ls ms mt mu lv mv mw mx ly my bi translated">结论</h1><p id="e3f3" class="pw-post-body-paragraph iu iv hh iw b ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn me jp jq jr ha bi translated">大量的UI组件都是某种状态的函数，它们也提供了一些改变这种状态的方法。这些组件的灵活实现允许有状态和无状态的使用。在React中，我们可以通过<code class="du kt ku kv kw b">useState</code>钩子在组件中维护本地状态。有了<code class="du kt ku kv kw b">useControllableState</code>，我们可以维持一个由道具随意控制的本地状态。</p></div></div>    
</body>
</html>