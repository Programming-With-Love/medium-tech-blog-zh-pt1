<html>
<head>
<title>Hilt Testing Best Practices in the MAD Skills series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MAD技能系列中的刀柄测试最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/hilt-testing-best-practices-in-the-mad-skills-series-8186a57eee2c?source=collection_archive---------0-----------------------#2021-08-30">https://medium.com/androiddevelopers/hilt-testing-best-practices-in-the-mad-skills-series-8186a57eee2c?source=collection_archive---------0-----------------------#2021-08-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><div class=""><h2 id="b0a4" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">剑柄狂技能系列第二集</h2></div><p id="8cf3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是下一篇关于<a class="ae kd" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">剑柄</a>的狂技能文章！这一次我们将关注如何用Hilt编写测试，以及一些需要注意的最佳实践。</p><p id="5730" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您喜欢以视频格式观看这些内容，请点击此处查看:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><h1 id="6664" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">刀柄测试理念</h1><p id="f1c1" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">因为Hilt是一个更加固执己见的框架，所以Hilt测试API的构建都有特定的目标。了解Hilt进行测试的方法将使API更容易使用和理解。你可以在这里阅读更多关于测试哲学的深度<a class="ae kd" href="https://dagger.dev/hilt/testing-philosophy" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7f87" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Hilt中测试API的核心目标之一是避免在测试中不必要的使用伪造品或模仿品，尽可能多地使用真实对象。真实的对象将增加测试覆盖率，并且比假的或模仿的对象更能经受住时间的变化。当真实对象正在执行IO等昂贵的任务时，Fakes或mocks是有用的，但它们经常被过度使用来掩盖其他问题，在这些问题中，没有任何概念上不能在测试中完成的事情。</p><p id="8a59" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">其中一个问题是在测试中使用没有刀柄的匕首会很麻烦。为测试设置Dagger组件可能需要大量的工作和样板文件，但是不使用Dagger而只是手动实例化对象会导致过度使用mocks。让我们来看看这是为什么。</p><h1 id="10c2" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">手动实例化(无柄测试)</h1><p id="cd03" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">为了了解为什么在测试中手动实例化对象会导致过度使用mocks，让我们看一个例子。</p><p id="01cb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">下面，我们测试了一个有一些依赖关系的<code class="du lh li lj lk b">EventManager</code>类。因为我们不想为这个简单的测试设置Dagger组件，所以我们只是手动实例化该对象。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ll kj l"/></div></figure><p id="0137" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">起初这似乎很简单，因为我们只是像Dagger一样调用构造函数，但是当我们需要弄清楚如何获得我们的<code class="du lh li lj lk b">DataModel</code>和<code class="du lh li lj lk b">ErrorHandler</code>的实例时，问题就出现了。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ll kj l"/></div></figure><p id="d971" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们也可以实例化这些类，但是如果这些类也有依赖关系，那么这可能会变得非常复杂。我们可能会在实际测试之前调用很多构造函数。另一个问题是所有这些构造函数调用会使测试变得脆弱。这里对构造函数的任何更改都可能会破坏测试，即使它们不会破坏生产中的任何东西。不应该做的改变，比如对<code class="du lh li lj lk b">@Inject</code>构造函数中的参数重新排序，或者用<code class="du lh li lj lk b">@Inject</code>构造函数在类上添加一个依赖项，会破坏测试，并且更新起来很痛苦。</p><p id="1e25" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以为了避免这种情况，许多人经常嘲笑依赖关系<code class="du lh li lj lk b">DataModel</code>和<code class="du lh li lj lk b">ErrorHandler</code>。这是一个问题，因为引入这些模拟并不是为了避免测试中任何昂贵的东西，而是为了处理测试设置样板文件。</p><h1 id="9df6" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">用刀柄测试</h1><p id="d2b4" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">有了Hilt，Dagger组件就为您设置好了，因此您可以避免手动实例化，并避免在测试中设置Dagger的样板文件。有关完整的测试文档，请参见此处的<a class="ae kd" href="https://dagger.dev/hilt/testing" rel="noopener ugc nofollow" target="_blank">和</a>。</p><p id="29b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在测试中设置Hilt需要您:</p><ol class=""><li id="2aec" class="lm ln hs jj b jk jl jn jo jq lo ju lp jy lq kc lr ls lt lu bi translated">用<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/testing/HiltAndroidTest.html" rel="noopener ugc nofollow" target="_blank">@HiltAndroidTest</a></code>注释你的测试</li><li id="c92a" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc lr ls lt lu bi translated">添加测试规则<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/testing/HiltAndroidRule.html" rel="noopener ugc nofollow" target="_blank">HiltAndroidRule</a></code></li><li id="df2a" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc lr ls lt lu bi translated">为你的<code class="du lh li lj lk b">Application</code>类使用<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/hilt/android/testing/HiltTestApplication.html" rel="noopener ugc nofollow" target="_blank">HiltTestApplication</a></code></li></ol><p id="8448" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于第三步，如何使用<code class="du lh li lj lk b">HiltTestApplication</code>将取决于测试的类型，因此请参见此处的机器人电气测试<a class="ae kd" href="https://dagger.dev/hilt/robolectric-testing" rel="noopener ugc nofollow" target="_blank">和此处</a>的仪器测试<a class="ae kd" href="https://dagger.dev/hilt/instrumentation-testing" rel="noopener ugc nofollow" target="_blank">的说明。</a></p><p id="11a6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">设置完成后，您现在可以向测试中添加<code class="du lh li lj lk b">@Inject</code>字段来访问绑定。这些字段将在您调用<code class="du lh li lj lk b">HiltAndroidRule</code>上的<code class="du lh li lj lk b">inject()</code>后设置，因此您可能希望在您的设置方法中这样做。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ll kj l"/></div></figure><p id="a3bd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">需要注意的一点是，注入的对象必须来自<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/components" rel="noopener ugc nofollow" target="_blank">SingletonComponent</a></code>。如果您需要来自<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/components" rel="noopener ugc nofollow" target="_blank">ActivityComponent</a></code>或<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/components" rel="noopener ugc nofollow" target="_blank">FragmentComponent</a></code>的东西，您将需要使用常规的Android测试API来创建一个活动或片段，并从中获取依赖。</p><p id="3af3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">之后，你就可以写你的测试了，因为你的注入字段，在这里是我们的<code class="du lh li lj lk b">EventManager</code>类，将会像在产品中一样由Dagger构造。没有必要担心来自管理依赖关系的任何样板文件！</p><h1 id="8f02" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">TestInstallIn</h1><p id="8a4b" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">当您需要替换测试中的依赖项时，例如当真实对象做了一些昂贵的事情，比如调用服务器，您可以使用<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/testing#testinstallin" rel="noopener ugc nofollow" target="_blank">TestInstallIn</a></code>来进行更改。</p><p id="8bc7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然你不能直接替换Hilt中的单个绑定，但是<code class="du lh li lj lk b">TestInstallIn</code>允许你替换模块。<code class="du lh li lj lk b">TestInstallIn</code>的工作方式与<code class="du lh li lj lk b">InstallIn</code>类似，除了它还允许您指定应该替换的模块。被替换的模块不会被Hilt使用，取而代之的是添加到<code class="du lh li lj lk b">TestInstallIn</code>模块中的任何绑定都会被使用。类似于<code class="du lh li lj lk b">InstallIn</code>模块，<code class="du lh li lj lk b">TestInstallIn</code>模块将应用于所有依赖于它们的测试(例如Gradle模块中的所有测试)。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ll kj l"/></div></figure><h1 id="b90c" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">卸载模块</h1><p id="6cd0" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">当您只想在单次测试中进行替换时，您可以使用<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/testing#uninstall-modules" rel="noopener ugc nofollow" target="_blank">UninstallModules</a></code>。<code class="du lh li lj lk b">UninstallModules</code>直接放在测试上，允许你指定哪些模块是Hilt不应该使用的。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="ll kj l"/></div></figure><p id="11e0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在测试中，您可以直接使用<code class="du lh li lj lk b"><a class="ae kd" href="https://dagger.dev/hilt/testing#bind-value" rel="noopener ugc nofollow" target="_blank">@BindValue</a></code>或者通过定义嵌套模块来添加绑定。</p><h1 id="c528" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">测试安装与卸载模块</h1><p id="4910" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">所以你可能想知道，你应该使用哪一个？以下是两者的快速对比:</p><p id="32ec" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">测试安装程序</strong></p><ul class=""><li id="0413" class="lm ln hs jj b jk jl jn jo jq lo ju lp jy lq kc ma ls lt lu bi translated">全球适用</li><li id="ae15" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc ma ls lt lu bi translated">更简单的配置</li><li id="09ea" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc ma ls lt lu bi translated">更有利于构建速度</li></ul><p id="1621" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">卸载模块</strong></p><ul class=""><li id="4476" class="lm ln hs jj b jk jl jn jo jq lo ju lp jy lq kc ma ls lt lu bi translated">仅单一测试</li><li id="673e" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc ma ls lt lu bi translated">更大的灵活性</li><li id="114e" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc ma ls lt lu bi translated">构建速度更差</li></ul><p id="e62b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一般来说，我们建议从<code class="du lh li lj lk b">TestInstallIn</code>开始，因为它对构建速度更好。当您确实需要单独的配置时，仍可使用<code class="du lh li lj lk b">UninstallModules</code>,但建议您谨慎使用，仅在特别需要时使用。</p><h1 id="8ecb" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">为什么TestInstallIn/UninstallModules会影响构建速度</h1><p id="8ddf" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">对于用于测试的每一组不同的模块，Hilt必须创建一组新的组件。这些组件最终会变得非常大，尤其是如果您依赖于生产代码中的许多模块。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/d7fca221bd2ab28c05441c5accf9b0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWwrAR5i5qgNiqV12Xc-HA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Components are generated for each different set of modules.</figcaption></figure><p id="2d7a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"/><code class="du lh li lj lk b"><strong class="jj ht">UninstallModules</strong></code><strong class="jj ht">的每一次使用都会添加一组需要构建的新组件，这可以根据您的测试数量快速增加。</strong>另一方面，由于<code class="du lh li lj lk b">TestInstallIn</code>是全局适用的，所以它属于可共享的默认组件集，可以在多个测试中重用。如果你可以改变一个测试，使它不必使用<code class="du lh li lj lk b">UninstallModules</code>，那么你就可以节省一组正在构建的组件。</p><p id="7bc6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有时候测试需要使用<code class="du lh li lj lk b">UninstallModules</code>,这没关系！请注意权衡，尽可能默认使用<code class="du lh li lj lk b">TestInstallIn</code>。</p><h1 id="f47d" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">测试依赖关系</h1><p id="4b2f" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">降低测试构建速度的另一个方法是处理另一个轴，减少被拉进测试的模块和入口点。这是每次使用<code class="du lh li lj lk b">UninstallModules</code>都会增加的部分。有时，您的测试可能依赖于您的所有产品代码，而实际上它只测试代码的很小一部分。因为Hilt不能在编译时告诉你将要在运行时测试什么，所以Hilt必须构建一个组件，它拥有通过你的deps可以找到的每个模块和入口点。这可能是一个很大的数目，可能会导致非常大的Dagger组件，从而增加你的构建时间。</p><p id="f967" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您能够减少这些依赖性，那么<code class="du lh li lj lk b">UninstallModules</code>的每一次新的使用可能不会那么昂贵，这可能会在配置您的测试时给您更多的灵活性。</p><p id="4318" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以这样做的一个方法是组织你的Gradle模块，这样你的很多测试不在主应用程序Gradle模块中，而是在单独的库Gradle模块中，以减少依赖性。</p><figure class="ke kf kg kh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/a3e58125549b5203980b909428ec0cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaDDUcJPUjhpw5DpP5Lt4g.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx">Organize tests into library Gradle modules when possible.</figcaption></figure><h1 id="d5d5" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">组织手柄模块</h1><p id="79b2" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">要记住的一件事也将帮助你写测试，那就是考虑你如何组织你的刀柄模块。非常大的Dagger模块有很多绑定是很常见的，但是对于Hilt，拥有做很多事情的大模块可能会使测试更加困难，因为你必须替换整个模块，而不是单独的绑定。</p><p id="5ee2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在Hilt中制作模块时，尽量让它们有一个单一的用途，甚至可能只有一个公共绑定。这有助于可读性，如果需要的话，在测试中更容易替换它们。</p><h1 id="925b" class="kk kl hs bd km kn ko kp kq kr ks kt ku iy kv iz kw jb kx jc ky je kz jf la lb bi translated">更多资源</h1><p id="c991" class="pw-post-body-paragraph jh ji hs jj b jk lc it jm jn ld iw jp jq le js jt ju lf jw jx jy lg ka kb kc ha bi translated">应用这些实践并了解更多的权衡将有望帮助您更轻松地用Hilt编写测试。对于其中的一些权衡，您选择哪种方式来做事将在很大程度上取决于您的应用程序、测试和构建系统目前是如何设置的。</p><p id="3a45" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关于使用Hilt测试的更多信息，你可以在这里查看完整的文档。这里还有一个测试指南<a class="ae kd" href="https://developer.android.com/training/dependency-injection/hilt-testing" rel="noopener ugc nofollow" target="_blank">和更多的例子。</a></p><p id="8ede" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就是剑柄测试，但请留意更多疯狂的技能集即将到来！</p></div></div>    
</body>
</html>