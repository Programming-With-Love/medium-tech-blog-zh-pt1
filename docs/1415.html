<html>
<head>
<title>Java Meets “Auto” Immutable with AutoValue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java用AutoValue满足了“自动”不可变</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/java-meets-auto-immutable-with-autovalue-805662dcba8d?source=collection_archive---------1-----------------------#2016-10-31">https://medium.com/capital-one-tech/java-meets-auto-immutable-with-autovalue-805662dcba8d?source=collection_archive---------1-----------------------#2016-10-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e13df3d1b99f2c779186612fb4899d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpGGxg2PHIpkYtqQNbzUKw.jpeg"/></div></div></figure><blockquote class="ip"><p id="dbbe" class="iq ir hh bd is it iu iv iw ix iy iz dx translated">“希望没有人还在写豆子”——杰克·沃顿</p></blockquote><p id="3bd7" class="pw-post-body-paragraph jb jc hh jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx iz ha bi translated">过去，当我第一次开发Android应用程序时，我被告知要将数据模型类编写为“bean”——文件中的每个属性都有getters和setters。当时，这是标准，但那是几年前的事了。</p><p id="15f0" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">最终，Android开发人员开始意识到Beans在某些情况下并不那么好。Beans的一些缺点是可变性和样板文件。这种可变性违反了线程安全，其他线程可能会覆盖Beans的属性。此外，随着类的增长，为每个属性设置getters和setters会产生大量的样板文件。</p><p id="551c" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">但是不用担心！如果你还在写豆子，你不应该感到尴尬或觉得自己是个糟糕的开发者。最近才停写豆子！希望在读完这篇文章后，您也能找到编写Beans的替代方法，因为我在这里向您展示了创建和管理数据模型类的更好方法。</p><h1 id="b77c" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">豆子是什么？</h1><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/7aaacbefb7b0fbe5c7ebad048586f51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LRUsyIZK4v62WpYJ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Asteroid model with “Beans” style</figcaption></figure><p id="b4cf" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">下面是一个Beans类的例子。这个小行星类有三个属性，每个属性都有getter和setter来引用和更改它的值。如您所见，这里的一切基本上都是可变的，因为每个属性中都有一个mutator。因此，您可以从任何类、任何线程中更改这些实例属性。</p><p id="93a2" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">在某些情况下，你可能需要一个可变的对象，比如一个类，<em class="lk"> Comment。评论</em>允许用户发布、更新和删除。假设<em class="lk">注释</em>类具有<em class="lk">消息</em>和<em class="lk">更新数据</em>属性，并且它们都需要能够初始化、更新和删除。</p><p id="0c02" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">这些例子怎么样？</p><ul class=""><li id="bdbb" class="ll lm hh jd b je jy ji jz jm ln jq lo ju lp iz lq lr ls lt bi translated"><strong class="jd hi">你有一个从API服务器获取数据并显示在Android屏幕上的应用。</strong></li><li id="8ca8" class="ll lm hh jd b je lu ji lv jm lw jq lx ju ly iz lq lr ls lt bi translated"><strong class="jd hi">用户在屏幕上输入一些数据，点击“发送”按钮，数据被发送到API服务器。</strong></li></ul><p id="afb4" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">在这两种情况下，模型都可以是不可变的。在第一个例子中，当您从API服务器获取数据时，您初始化一个数据模型类，并且您将只在任何视图类中引用它的属性来显示它。在第二个例子中，一旦用户输入数据并单击“send”按钮，您初始化一个数据模型并传递给一个API调用处理程序类，然后处理程序类只能读取属性以将其发送给服务器。</p><p id="5169" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">在这些情况下，只需设置一次数据，之后就可以引用属性了。因此，我们不需要允许这些属性是可变的——没有“Beans”。请记住这些案例，因为我们稍后将回到它。</p><p id="f7ce" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">现在，让我们使用上面的小行星例子，并使类不可变。</p><h1 id="749a" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使其不可改变</h1><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/3f94d3dce8415d5119f96fcf6cc7ce84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lmEzp8y03fe8QFut.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Asteroid model with immutable approach</figcaption></figure><p id="91ae" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">这里，属性只通过构造函数设置一次，每个字段都有一个getter来读取值。这个小行星类不是可变的。在“Beans”示例中，我故意省略了<em class="lk"> equals、hashCode </em>和<em class="lk"> toString </em>函数。然而，如果你写一个完整的模型类，你将需要所有那些函数。虽然equals和hashCode可能没有那么流行，但您至少应该编写toString，以便其他开发人员可以看到实际的实例内容，而不是在日志中看到“<em class="lk"> Asteroid@66x1b21 </em>”。</p><p id="f4d7" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">查看该类，它充满了样板文件，主要是关于<em class="lk">名称、绝对大小</em>和<em class="lk">接近方式</em>。我需要知道的所有信息都在前几行，剩下的就是废话了。</p><p id="6636" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">你可以说Android Studio在你第一次创建文件的时候就生成了所有的getters，<em class="lk">等于</em>，<em class="lk"> hashCode </em>和<em class="lk"> toString </em>函数。这部分很简单。但是，当您尝试向现有类添加字段时，问题会变得更加明显。</p><p id="cec6" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">要向类中添加一个字段，您可以添加:(数一数fraidy猫表情符号以获得快速回答)</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/15ab8d19e7d9c4b6a167b14bea76c1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GmOWJURmAqshJ623.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Adding a single field to an existing model class, as shown using fraidy cat emojis</figcaption></figure><p id="0406" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">带有fraidy猫表情符号的绿色高亮线是添加的线。在这张图片中你能看到多少表情符号？有六个。添加一个属性需要写的六件事。Android Studio在这里甚至没有太大的帮助——你基本上需要编写样板文件，没有捷径可走。</p><p id="ae7b" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">除了……如果用“自动赋值”呢？</p><h1 id="1191" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">AutoValue-您的新好友</h1><p id="7e80" class="pw-post-body-paragraph jb jc hh jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx iz ha bi translated"><a class="ae mg" href="https://github.com/google/auto/tree/master/value" rel="noopener ugc nofollow" target="_blank"> AutoValue </a>是一个基于注释的库，它使用简单的注释生成一个不可变的模型类，其中包含自动生成的equals、hashCode和toString。它也给了我们在类中添加自定义函数的灵活性。</p><p id="1f50" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">此外，还有一些扩展包可用于Parcelable和JSON转换器。</p><p id="845a" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">让我们以上面的小行星类为例，对其使用AutoValue。</p><p id="c69f" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">带Gradle的安装:</p><p id="458d" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">apt ' com . Google . auto . value:auto-value:1.2 '<br/>提供' com . jakewharton . auto . value:auto-value-annotations:1.2-update 1 '</p><p id="2ea0" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">修改小行星类别:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/d0d68308fb2a1c824b210ec512038b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mgqTvo08n_LSUg2B.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Asteroid model with AutoValue</figcaption></figure><p id="0337" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">首先，在类名上添加<em class="lk">自动值</em>注释。然后将每个字段改为一个“公共抽象”函数；吸气剂的替代品。既然我们把它改成了abstract，下一步就是把这个类也改成abstract。然后我们创建一个静态工厂方法来实例化AutoValue的Asteroid对象。最后，去掉你之前准备好的所有样板文件。所有的人。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/b418d612e2b0d8ebd542436fec2eec53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*luANlFfPoozC06yw.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Without and With AutoValue</figcaption></figure><p id="8bec" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">现在，你可能已经注意到班级变得有多小了。我们去掉了所有的<em class="lk"> equals、hashCode、toString </em>函数和getters(嗯，算是吧)。现在，我们或多或少只有我们想看到的信息——一个工厂方法(构造函数)和一些抽象的getters。</p><p id="b71b" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">一旦编译了这段代码，AutoValue会自动生成一个名为$AutoValue_Asteroid的类，它实现了所有的getters、equals、hashCode和toString。</p><p id="979f" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">好吧。这很酷，那么…我如何将AutoValue应用到我在这篇文章前面提到的例子中呢？</p><p id="5f36" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">你使用一个从API服务器获取数据并显示在Android屏幕上的应用程序。</p><p id="3bf8" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">自动值-Moshi + Retrofit2</p><p id="b1eb" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">我为此选择了<a class="ae mg" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank">魔石转换器</a>，但你也可以选择其他转换器，如Gson、Jackson等。</p><p id="2800" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">用Gradle安装:</p><p id="40c1" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">apt ' com . ryanharter . auto . value:auto-value-Moshi:0 . 3 . 0 '</p><p id="952c" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">修改小行星类别:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/a0e680049163d994aa2fd31bd1f52fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gBj07HYAhDutstti.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">AutoValue with Moshi</figcaption></figure><p id="ee5b" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">为了让AutoValue类与Moshi转换器一起工作，如果需要的话，可以在抽象的getter行上添加Json注释。然后添加此块:</p><p id="585e" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">公共静态JSON adapter<asteroid>JSON adapter(Moshi Moshi){<br/>返回新的AutoValue_Asteroid。MoshiJsonAdapter(莫希)；<br/> }</asteroid></p><p id="9033" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">如果一个类用于JSON响应，您可以删除一个工厂函数，这由转换器负责。</p><p id="de50" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">要将此应用于HTTP客户端Retrofit2，您需要创建如下所示的翻新构建器:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/2836f337ba66f1cc5b900c4f563886af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*47QYo54W5LRP_OuT.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Apply AutoValue Moshi to Retrofit2</figcaption></figure><p id="f76b" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">代码的其余部分与您通常使用Retrofit2和Android framework编写的代码相同。</p><h1 id="b5d0" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">综上</h1><p id="befa" class="pw-post-body-paragraph jb jc hh jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx iz ha bi translated">AutoValue引入了两个主要优势:它会自动创建一个不可变的对象，并清除数据模型类中的大部分样板文件。它还可以很好地与Parcelable和JSON converter配合使用。在某些情况下，您可能需要一个可变对象。然而，如果不是这样，为什么不用AutoValue使它不可变呢！</p><h2 id="13c6" class="ml ke hh bd kf mm mn mo kj mp mq mr kn jm ms mt kr jq mu mv kv ju mw mx kz my bi translated">为了进一步阅读</h2><p id="bdd6" class="pw-post-body-paragraph jb jc hh jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx iz ha bi translated">*我推荐瑞安·哈特的这篇文章:<br/><a class="ae mg" href="http://ryanharter.com/blog/2016/05/16/autovalue-extensions/" rel="noopener ugc nofollow" target="_blank">http://ryanharter.com/blog/2016/05/16/autovalue-extensions/</a></p><p id="2fe0" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">*几个月前，我偶然看到杰克·沃顿的一个演示视频。这个视频是2016年我最喜欢的Android视频之一，我肯定会推荐观看它。</p></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><p id="9668" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated"><em class="lk">原载于</em><a class="ae mg" href="https://developer.capitalone.com/blog-post/java-meets-immutable-with-autovalue/" rel="noopener ugc nofollow" target="_blank"><em class="lk">developer.capitalone.com</em></a><em class="lk">。</em></p><p id="75d1" class="pw-post-body-paragraph jb jc hh jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx iz ha bi translated">如需了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。【https://developer.capitalone.com/】<a class="ae mg" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="lk"/></a></p></div></div>    
</body>
</html>