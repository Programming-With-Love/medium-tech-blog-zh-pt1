<html>
<head>
<title>A simple technique for real-time video Gaussian blurs that did seem to work.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种简单的实时视频高斯模糊技术似乎确实有效。</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/a-simple-technique-for-real-time-video-gaussian-blurs-that-did-seem-to-work-42b2c6bb9989?source=collection_archive---------3-----------------------#2021-11-19">https://medium.com/quick-code/a-simple-technique-for-real-time-video-gaussian-blurs-that-did-seem-to-work-42b2c6bb9989?source=collection_archive---------3-----------------------#2021-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e339" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我有时会遇到这样的情况，用户提供的视频需要在网页中进行高斯模糊，动态地使用用户给定的半径(类似于<a class="ae jc" href="https://projector.com/" rel="noopener ugc nofollow" target="_blank">投影仪</a>所做的，不过它使用了WebGL 2。)</p><p id="5320" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，我对WebGL不太熟悉，我在WebGL中为此目的所做的尝试失败了(这将在后面讨论)。</p><p id="a976" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在经历了这么多的尝试和错误之后，我最终选择了2D的好东西。但是让我列举一些我做过的尝试。</p><div class="jh ji ez fb jj jk"><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" rel="noopener  ugc nofollow" target="_blank"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">canvasrenderingcontext 2d-Web API | MDN</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">CanvasRenderingContext2D接口是Canvas API的一部分，它为绘图提供了2D渲染上下文…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">developer.mozilla.org</p></div></div><div class="jt l"><div class="ju l jv jw jx jt jy jz jk"/></div></div></a></div><h2 id="9277" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">CSS过滤器</h2><p id="8385" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">我的第一次尝试是用<code class="du jd je jf jg b">blur()</code> CSS过滤器直接设计<code class="du jd je jf jg b">video</code>的样式。</p><pre class="la lb lc ld fd le jg lf lg aw lh bi"><span id="f652" class="ka kb hh jg b fi li lj l lk ll">&lt;video<br/>    src={userProvidedSource}<br/>    style={{<br/>        filter: `blur(${userProvidedBlur}px)`<br/>    }}<br/>/&gt;</span></pre><p id="4e46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，渲染将是不正确的。最边缘的像素将变得半透明，并溢出视频边界。</p><figure class="la lb lc ld fd ln er es paragraph-image"><div class="er es lm"><img src="../Images/46d809bc7950e311fa95afdd6626a170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*0HHZXkD0JsbmkNN6uH-8Xw.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Simulated rendering. This is what CSS filters do.</figcaption></figure><h2 id="100d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">CSS背景-过滤器</h2><p id="6dbe" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">当我第一次遇到这个问题时，CSS属性似乎是一个完美的解决方案。</p><pre class="la lb lc ld fd le jg lf lg aw lh bi"><span id="e269" class="ka kb hh jg b fi li lj l lk ll">&lt;div class="video-box"&gt;<br/>    &lt;video src={userProvidedSource} class="video-box__video" /&gt;<br/>    &lt;div<br/>        class="video-box__backdrop"<br/>        style={{<br/>            backdropFilter: `blur(${userProvidedBlur}px)`<br/>        }}<br/>    /&gt;<br/>&lt;/div&gt;</span></pre><figure class="la lb lc ld fd ln er es paragraph-image"><div class="er es lt"><img src="../Images/90968e91448887adff3c6dee90407ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*J3EtIDlVT44ZvcXFQx2yfw.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Simulated rendering. Seems perfect at first glance.</figcaption></figure><p id="8061" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，当模糊半径变大时，渲染结果可能会出错。</p><figure class="la lb lc ld fd ln er es paragraph-image"><div class="er es lu"><img src="../Images/c418c09983b2b6e601308c462cb72276.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*ICQXhw_PlL599WGCRoinbA.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Unblurred image is revealed below the backdrop, though I don’t quite know why.</figcaption></figure><h2 id="476e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">2D画布，第一次尝试</h2><p id="e0f8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">幸运的是，<code class="du jd je jf jg b">CanvasRenderingContext2D.filter</code>属性同时支持CSS和SVG过滤器。</p><div class="jh ji ez fb jj jk"><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter" rel="noopener  ugc nofollow" target="_blank"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">canvasrenderingcontext 2d . filter-Web API | MDN</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">画布2D API的canvasrenderingcontext 2d . filter属性提供了诸如模糊和…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">developer.mozilla.org</p></div></div><div class="jt l"><div class="lv l jv jw jx jt jy jz jk"/></div></div></a></div><p id="ad67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在画布上绘制整个视频似乎是值得的，在画布上应用了滤镜。</p><pre class="la lb lc ld fd le jg lf lg aw lh bi"><span id="bb7a" class="ka kb hh jg b fi li lj l lk ll">canvas.width = w;<br/>canvas.height = h;<br/>/** @type{<!-- -->CanvasRenderingContext2D<!-- -->} */<br/>const context = canvas.getContext('2d');<br/>context.save();<br/>context.filter = `blur(${userProvidedBlur}px)`;<br/>context.drawImage(video,<br/>    0, 0, video.videoWidth, video.videoHeight,<br/>    0, 0, w, h<br/>);<br/>context.restore();</span></pre><p id="9499" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，使用这种方法，最边缘的像素仍然是半透明的。</p><figure class="la lb lc ld fd ln"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">A demonstration of semi-transparent pixels drawn with canvas.</figcaption></figure><h2 id="8788" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">2D-帆布，第二次尝试</h2><p id="b6b9" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">所以我先画出最边缘的像素，然后将画布溢出的容器设置为隐藏。</p><pre class="la lb lc ld fd le jg lf lg aw lh bi"><span id="7a51" class="ka kb hh jg b fi li lj l lk ll">const r = userProvidedBlur * 2; // to cover the transparent pixels<br/>context.filter = `blur(${userProvidedBlur}px)`;<br/>// draw the corners<br/>// draw the sides<br/>// draw the video in the center</span></pre><figure class="la lb lc ld fd ln"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="d605" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">渲染看起来几乎是正确的，但是当重复调用时，很多时间会浪费在<code class="du jd je jf jg b">drawImage()</code>调用上，这使得它不适合实时视频渲染。根据这篇文章中的<a class="ae jc" href="http://blog.ivank.net/fastest-gaussian-blur.html" rel="noopener ugc nofollow" target="_blank">，即使最快的高斯模糊实现也具有与模糊形状的面积成比例的不可约的时间×空间复杂度组合。即使最大程度地并行化，这也可以转化为O(max(width，height，blurRadius))时间。</a></p><p id="68af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在模糊的画布中重复调用<code class="du jd je jf jg b">drawImage()</code>可能意味着对画布上绘制的像素进行不必要的重复访问，这可能是我遇到的性能问题的基础。</p><h2 id="cf92" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">WebGL，尝试失败</h2><p id="6630" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这让我想到了WebGL渲染。不幸的是，我对WebGL知之甚少，不知道——也还不知道——如何在WebGL代码中实现上述算法，所以我不必要地在每次调用片段着色器时多次访问纹理。</p><pre class="la lb lc ld fd le jg lf lg aw lh bi"><span id="eaa9" class="ka kb hh jg b fi li lj l lk ll">// the code below doesn't work<br/>// for severe perf problems</span><span id="3d46" class="ka kb hh jg b fi ly lj l lk ll">precision mediump float;<br/>uniform sampler2D img;<br/>uniform vec2 texSize;<br/>uniform float boxSize;<br/>uniform float center;<br/>uniform vec2 dir;<br/>uniform bool flip;</span><span id="e0e9" class="ka kb hh jg b fi ly lj l lk ll">void main() {<br/>    vec4 ret=vec4(.0);<br/>    vec2 px=dir*vec2(1.,1.)/texSize;<br/>    vec2 coord=gl_FragCoord.xy/texSize.xy;<br/>    float comp=boxSize-.1;<br/>    if(flip){ coord.y=1.-coord.y; }<br/>    float fi=.0;<br/>    for(int i=0;i&lt;200;i++){<br/>        float offset=fi-center;<br/>        vec2 curCoord=coord+px*offset;<br/>        ret+=texture2D(img, curCoord);<br/>        fi+=1.;<br/>        if(fi&gt;=comp){ gl_FragColor = vec4(ret.rgb/boxSize,1); return; }<br/>    }<br/>    gl_FragColor = ret;<br/>}</span></pre><p id="719e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后来我放弃了。</p><h2 id="ceac" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">屏幕外的画布</h2><p id="ec61" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">所以我回到了优化我之前的2D-画布方法。</p><p id="dca0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将边缘像素和视频本身绘制到屏幕外画布的渲染上下文中，最后将其绘制到模糊的画布上。</p><div class="jh ji ez fb jj jk"><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener  ugc nofollow" target="_blank"><div class="jl ab dw"><div class="jm ab jn cl cj jo"><h2 class="bd hi fi z dy jp ea eb jq ed ef hg bi translated">屏幕外画布-Web API | MDN</h2><div class="jr l"><h3 class="bd b fi z dy jp ea eb jq ed ef dx translated">OffscreenCanvas接口提供了一个可以在屏幕外呈现的画布。它在窗口和中均可用…</h3></div><div class="js l"><p class="bd b fp z dy jp ea eb jq ed ef dx translated">developer.mozilla.org</p></div></div><div class="jt l"><div class="lz l jv jw jx jt jy jz jk"/></div></div></a></div><figure class="la lb lc ld fd ln"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="a150" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">剪切和模糊之前的样子。</p><figure class="la lb lc ld fd ln"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Blur once, run on every Chromium-based browser</figcaption></figure><p id="9ff9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当在视频帧渲染的<code class="du jd je jf jg b">requestAnimationFrame()</code>回调中被调用时，性能也比我之前的2D-画布方法有所提高，尽管离完美的60 fps还有一段距离。</p><h2 id="3aa0" class="ka kb hh bd kc kd ke kf kg kh ki kj kk ip kl km kn it ko kp kq ix kr ks kt ku bi translated">警告</h2><p id="607a" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">然而，这种方法在非基于Chromium的浏览器上效果不佳，比如Firefox。Firefox默认不支持<code class="du jd je jf jg b">OffscreenCanvas</code> API，即使手动启用，它也不支持2d渲染上下文。</p><p id="3846" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du jd je jf jg b">HTMLCanvasElement</code>可以进行多种填充，但性能仍然不佳，产生的帧速率约为2 fps。我不太清楚哪里出了问题。</p><p id="c99a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论性能提升有多小，都很难实现。</p></div></div>    
</body>
</html>