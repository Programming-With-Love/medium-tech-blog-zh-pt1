<html>
<head>
<title>Node.js Control Flow — An Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js控制流—概述</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/node-js-control-flow-an-overview-68f76ef750c3?source=collection_archive---------0-----------------------#2020-10-15">https://medium.com/capital-one-tech/node-js-control-flow-an-overview-68f76ef750c3?source=collection_archive---------0-----------------------#2020-10-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="2cdd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">异步初学者指南</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/c1b19068574e0be8e5aadf5198cdf4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q7CXbwsvagsyrFSt"/></div></div></figure><p id="b289" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我发现大多数关于Node.js如何处理异步控制流的解释对我来说很难理解，因为这些解释要么假设1)对计算机科学有很深的了解，要么假设2)读者只对Node.js感兴趣，而不是它所构建的基础部分。</p><p id="36be" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这篇文章是我填补这一空白的尝试。</p><h1 id="5876" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">总体并发性</h1><p id="2053" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在现代编程环境中，并发随处可见:</p><ul class=""><li id="601f" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">一个网站可能必须同时处理许多用户。</li><li id="98dd" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">一组需要协调事务的API可能分布在云计算环境中的许多计算机上。</li><li id="ad54" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">开发人员编写代码时，IDE可能会在后台编译代码。</li></ul><p id="34f1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如Golang的创造者之一罗布·派克所说:</p><blockquote class="lq lr ls"><p id="da54" class="ji jj lt jk b jl jm ii jn jo jp il jq lu js jt ju lv jw jx jy lw ka kb kc kd ha bi translated"><em class="hh">“并发是独立执行的事物(通常是功能)的组合。”</em></p></blockquote><p id="1f36" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，良好的代码设计在一个并发的环境中是很难的— <em class="lt">时期</em>。在并发程序中，开发人员必须管理多个有重叠时间线的活动。即使有一组相对简单的组件，复杂的通信模式或糟糕的组合也会导致竞争情况。众所周知，竞争条件很难测试和调试，因为它们经常受到环境条件的影响，如网络流量、操作系统的状态，甚至硬件的使用。</p><h1 id="0ea2" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Node.js和线程</h1><p id="1a13" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">如<a class="ae lp" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>所述，JavaScript试图通过提供单线程<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环</a>来简化并发代码的问题。该事件循环负责:</p><ul class=""><li id="2580" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">执行代码。</li><li id="4b49" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">收集和处理事件。</li><li id="b303" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">执行排队的子任务。</li></ul><p id="7a28" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">特别是，一旦一个函数开始运行，它将在程序的任何其他部分开始运行之前运行完成——您知道没有其他代码会破坏数据。但是如果你想建立一个web服务器，例如，并发性仍然需要解决。</p><h2 id="78e6" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated"><strong class="ak">默认异步</strong></h2><p id="bfff" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">为了提供并发性，Node.js中耗时的操作(特别是I/O事件和I/O回调)在默认情况下是异步的。为了实现这种异步行为，modern Node.js利用事件循环作为中央调度程序，将请求路由到C++并将结果返回给JavaScript。</p><p id="f65f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在I/O中采用这种方法的决定从一开始就包含在Node.js中。Ryan Dahl(node . js的创建者)在NGINX的启发下，<a class="ae lp" href="https://mappingthejourney.com/single-post/2017/08/31/episode-8-interview-with-ryan-dahl-creator-of-nodejs/" rel="noopener ugc nofollow" target="_blank">当时相信，</a>，<em class="lt">“也许我们做I/O是错误的，也许如果我们以非阻塞的方式做每件事，我们将解决编程中的许多困难。比如，也许我们可以完全忘记线程，只使用流程抽象和序列化通信。”</em></p><p id="0f27" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，Node.js最终还是不能放弃线程。</p><p id="b208" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要了解Node.js在哪里利用线程实现并发性，以及它在哪里依赖于其他方法，重要的是要了解Node.js架构中的下一层是<a class="ae lp" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> libuv </em> </a>，这是一个专门为Node.js构建的C库。libuv处理以下操作:</p><ul class=""><li id="d1ff" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">由epoll、kqueue、IOCP、事件端口支持的全功能事件环路</li><li id="1c39" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">异步TCP和UDP套接字</li><li id="114b" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">异步DNS解析</li><li id="e490" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">异步文件和文件系统操作</li><li id="23dc" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">文件系统事件</li><li id="3cf7" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">子进程</li><li id="6d61" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated"><em class="lt">线程池</em></li><li id="810f" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">信号处理</li><li id="dd0c" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated"><em class="lt">线程和同步原语</em></li></ul><p id="28ef" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个列表中的一些项目允许libuv(和Node.js)不关心线程。例如，使用操作系统事件通知系统(如epoll和IOCP)来处理web服务器操作。</p><p id="9fc0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">另一方面，libuv(和Node.js)中的某些操作是同步和线程化的。如<a class="ae lp" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank">所述，不要阻塞事件循环</a>:</p><blockquote class="lq lr ls"><p id="6728" class="ji jj lt jk b jl jm ii jn jo jp il jq lu js jt ju lv jw jx jy lw ka kb kc kd ha bi translated">“Node.js有两种类型的线程:一个事件循环和k个工作线程。事件循环负责JavaScript回调和非阻塞I/O，工作线程执行与完成异步请求的C++代码对应的任务，包括阻塞I/O和CPU密集型工作。这两种类型的线程一次只能处理一个活动。</p></blockquote><p id="0c8e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Node.js使用工作池来处理“昂贵”的任务。这包括操作系统不提供非阻塞版本的I/O，以及CPU密集型任务。</p><p id="4364" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这些是利用该工作池的Node.js模块API:</p><ol class=""><li id="43c2" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd ml lh li lj bi translated"><strong class="jk hi"> I/O密集型</strong></li></ol><ul class=""><li id="377e" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">DNS: dns.lookup()，dns.lookupService()。</li><li id="32f3" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">文件系统:除fs之外的所有文件系统API。FSWatcher()和那些显式同步的使用libuv的线程池。</li></ul><p id="5414" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 2。CPU密集型</strong></p><ul class=""><li id="cfef" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">Crypto: crypto.pbkdf2()、crypto.scrypt()、crypto.randomBytes()、crypto.randomFill()、crypto.generateKeyPair()。</li><li id="3d35" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">Zlib:除了那些显式同步的以外，所有zlib APIs都使用libuv的线程池。"</li></ul><h2 id="4b96" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">你想要线索，你已经得到了！</h2><p id="fcc8" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">Node.js还提供了一个单独的<a class="ae lp" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank"> Worker Thread </a>模块，用于开发人员希望执行CPU密集型JavaScript操作的情况(例如，文件压缩——这不打算由I/O操作使用)。工作线程模块允许开发人员创建自己的自定义线程池，并允许线程通过共享内存进行通信。</p><p id="1f28" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">底线是:</p><ul class=""><li id="59a8" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">对于Node.js擅长的许多用例(比如创建web服务器)，开发人员真的不必考虑线程，可以专注于“进程抽象”</li><li id="cb42" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">但是线程是为有限的用例而存在的；如果你需要的话。</li></ul><h1 id="242b" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">从回调到异步/等待的旅程</h1><p id="c6fc" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">Node.js中从回调到async/await的旅程反映了它与<a class="ae lp" href="https://v8.dev/docs" rel="noopener ugc nofollow" target="_blank"> V8 </a>的紧密关系——谷歌的开源JavaScript和WebAssembly引擎，用C++编写。随着V8增加功能，Chrome浏览器和Node.js都将把这些变化集成到它们的代码库中。</p><h2 id="ac3a" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">回调——驯服异步复杂性的首次尝试</h2><p id="8b07" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">最初，V8(和Node.js)使用延续传递样式(CPS)模式处理异步代码。这种模式最初出现在20世纪70年代中期的Scheme语言中:</p><blockquote class="lq lr ls"><p id="00c4" class="ji jj lt jk b jl jm ii jn jo jp il jq lu js jt ju lv jw jx jy lw ka kb kc kd ha bi translated"><em class="hh">“以传递延续方式编写的函数需要一个额外的参数:一个显式的“延续”，即一个参数的函数。当CPS函数计算出它的结果值后，它通过调用continuation函数将这个值作为参数来“返回”它。这意味着当调用一个CPS函数时，调用函数需要提供一个用子例程的“返回”值调用的过程。——</em><a class="ae lp" href="https://en.wikipedia.org/wiki/Continuation-passing_style#:~:text=In%20functional%20programming%2C%20continuation%2Dpassing,the%20usual%20style%20of%20programming.&amp;text=Reynolds%20gives%20a%20detailed%20account%20of%20the%20numerous%20discoveries%20of%20continuations." rel="noopener ugc nofollow" target="_blank"><em class="hh">【延续-传承风格】</em></a><em class="hh"/><a class="ae lp" href="https://en.wikipedia.org/wiki/Continuation-passing_style#:~:text=In%20functional%20programming%2C%20continuation%2Dpassing,the%20usual%20style%20of%20programming.&amp;text=Reynolds%20gives%20a%20detailed%20account%20of%20the%20numerous%20discoveries%20of%20continuations." rel="noopener ugc nofollow" target="_blank">维基百科</a> <a class="ae lp" href="https://creativecommons.org/licenses/by-sa/3.0/legalcode" rel="noopener ugc nofollow" target="_blank"> (CC BY-SA 3.0) </a></p></blockquote><p id="91c0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在JavaScript/Node.js中，我们称之为<em class="lt">回调模式</em>。虽然回调函数对于简单的程序来说已经足够好了，但是在现实生活中，大多数情况下使用回调函数容易出错。例如，假设您有一个需要检索远程数据的网页，然后根据检索到的数据，需要加载更多的数据和一组图像。在这种情况下，您可能会陷入“回调地狱”——具有难以理解的成功和失败路径的深度嵌套回调。这是经典的“末日金字塔”(如Mozilla指南中关于<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">使用承诺</a>的说明所示):</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="95cd" class="lx kf hh mn b fi mr ms l mt mu">doSomething(function(result) {<br/>doSomethingElse(result, function(newResult) {<br/>    doThirdThing(newResult, function(finalResult) {<br/>      console.log(‘Got the final result: ‘ + finalResult);<br/>    }, failureCallback);<br/>  }, failureCallback);<br/>}, failureCallback);</span></pre><h2 id="827b" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">承诺——进一步简化</h2><p id="7e22" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">那么，如何避开末日金字塔呢？<em class="lt">许下诺言。</em></p><p id="a6e8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">承诺的想法已经存在了一段时间。大约在CPS出现在Scheme的同时，处理异步的替代方法以不同的名称出现在各种编程语言中:futures、defers等..在1988年，<a class="ae lp" href="https://heather.miller.am/teaching/cs7680/pdfs/liskov1988.pdf" rel="noopener ugc nofollow" target="_blank"> Barbara Liskov和Liuba Shrira(在为DARPA做研究时)创造了术语<em class="lt"> promises </em> </a>来描述一种构造，这种构造<em class="lt">“支持高效的异步远程过程调用机制，供分布式程序的组件使用。承诺是未来存在的价值的占位符。它是在发出呼叫时创建的。该调用计算承诺的价值，与发出调用的程序并行运行。当它完成时，其结果被存储在承诺中，然后可以被调用者‘认领’。”</em></p><p id="1a9b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">2014年1月发布的Chrome版本32引入了对承诺的支持。Node.js于2015年2月跟进，在0.12中提供了promise支持。</p><p id="02b1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与1988年描述的愿景非常相似，JavaScript承诺是允许您组合并行运行调用的异步任务的对象；并且将呼叫管道化在一起:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="5635" class="lx kf hh mn b fi mr ms l mt mu">doSomething()<br/>.then(result =&gt; doSomethingElse(result))<br/>.then(newResult =&gt; doThirdThing(newResult))<br/>.then(finalResult =&gt; {<br/>    console.log(`Got the final result: ${finalResult}`);<br/>})<br/>.catch(failureCallback);<br/>});</span></pre><p id="997a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在高层次上，承诺有三种状态:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="c7bc" class="lx kf hh mn b fi mr ms l mt mu">//A new Promise starts in a “Pending” state<br/>new Promise(function (resolve, reject) {<br/>    reject(new Error(‘Transition to a “Rejected State”’))<br/>    resolve({ message: ‘Transition to a “Fulfilled State”’})<br/>})</span></pre><p id="6de1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为一名开发人员，除了在Node.js中链接承诺之外，您还可以使用多种方法来组合承诺，以便更轻松地管理异步任务组:</p><ul class=""><li id="517d" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated"><strong class="jk hi"> Promise.all </strong> —这种方法通常在有多个相互依赖才能成功完成的异步任务时使用。all接受一个可迭代的承诺作为输入，返回一个承诺作为输出。当输入的所有承诺都已解决并且非承诺已返回时，或者如果输入iterable不包含承诺，则此返回的承诺将得到解决。它会在任何输入承诺拒绝或未承诺抛出错误时立即拒绝，并将拒绝第一个拒绝消息/错误。</li><li id="16c2" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated"><strong class="jk hi"> Promise.race </strong> —该方法返回一个承诺，只要iterable中的一个承诺满足或拒绝，该承诺就会满足或拒绝，并返回该承诺的值或原因。</li><li id="9ac1" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated"><strong class="jk hi"> Promise.allSettled </strong> —这种方法通常用在你有多个不依赖于对方成功完成的异步任务时，或者你总是想知道每个承诺的结果时。Promise.allSettled()返回一个承诺，该承诺在所有给定承诺完成或被拒绝后解析，并带有一个对象数组，每个对象描述每个承诺的结果，例如:</li></ul><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="5474" class="lx kf hh mn b fi mr ms l mt mu">// asynchronous processing<br/>// we will talk about async/await syntax in a minute<br/>async processor(message) {<br/>    return await someOperation(message);<br/>    });<br/>}</span><span id="ff02" class="lx kf hh mn b fi mv ms l mt mu">// initial call<br/>// inside of Promise.allSettled, map all messages to the asynchronous processor call<br/>const results = await Promise.allSettled(messages.map(message =&gt; processor(message)));</span><span id="7dae" class="lx kf hh mn b fi mv ms l mt mu">// values returned to results<br/>//[<br/>// {“status”:”rejected”,”reason”:”my first promise call failed”},<br/>// {“status”:”fulfilled”,”value”:”success”}<br/>//]</span></pre><p id="cdfb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="lt">注:</em> </strong> <em class="lt"> Promise.allSettled是12.9.0版本(2019年8月发布)才引入Node.js的。同样，虽然使用原生Node.js功能进行组合的能力可以最大限度地减少依赖关系树，但有时也会牺牲性能——例如，根据至少一组测试</em>  <em class="lt">，蓝鸟</em>  <em class="lt">库可以快四倍。</em></p><p id="d114" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在链接承诺的能力和组合多个承诺链的能力之间，V8(和Node.js)消除了CPS/callback风格编程中固有的复杂性，而没有牺牲任何功能。</p><h2 id="7b16" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">async/Await——使承诺看起来像同步代码并提高性能</h2><p id="a46e" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">2017年10月，V8引入了<em class="lt"> async/await </em>作为更复杂的promises语法的替代方案——同时，Node 8也开始支持相同的语法。</p><p id="01f8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Async/await以与同步代码相同的方式构造异步代码。也就是说，使用async/await函数的代码与幕后承诺的操作非常相似:</p><blockquote class="lq lr ls"><p id="1e80" class="ji jj lt jk b jl jm ii jn jo jp il jq lu js jt ju lv jw jx jy lw ka kb kc kd ha bi translated">“Await表达式通过一个异步函数暂停进程，产生控制，然后仅当一个等待的基于承诺的异步操作完成或被拒绝时才恢复进程。承诺的解析值被视为await表达式的返回值。使用async / await可以在异步代码周围使用普通的try / catch块。—  <a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> <em class="hh">【异步函数— JavaScript】由Mozilla贡献者</em></a><em class="hh"/><a class="ae lp" href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="noopener ugc nofollow" target="_blank">(CC BY-SA 4.0)</a><em class="hh"/><a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"><em class="hh">Mozilla文档</em> </a></p></blockquote><p id="f3cf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="02b0" class="lx kf hh mn b fi mr ms l mt mu">async function foo() {<br/>try {<br/>    const result = await doSomething();<br/>    const newResult = await doSomethingElse(result);<br/>    const finalResult = await doThirdThing(newResult);<br/>    console.log(`Got the final result: ${finalResult}`);<br/>} catch(error) {<br/>    failureCallback(error);<br/>  }<br/>}</span></pre><p id="0fd6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在可能的情况下，使用<em class="lt"> async/await </em>比原来的promise设置有许多优点:</p><ul class=""><li id="6195" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">async/await代码肯定比CPS/callback风格，甚至是promise语法更具可读性。</li><li id="1b48" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">异步/等待代码<a class="ae lp" href="https://v8.dev/blog/fast-async" rel="noopener ugc nofollow" target="_blank">优于手写承诺代码</a> — <em class="lt">，但仅限于顺序承诺代码</em> —至少从2018年11月开始。也就是说，差异相对较小——例如，当我对Node.js v12.16.2运行<a class="ae lp" href="https://github.com/v8/promise-performance-tests" rel="noopener ugc nofollow" target="_blank"> V8 Promise性能测试</a>时，我得到了以下结果:</li></ul><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="454a" class="lx kf hh mn b fi mr ms l mt mu">Time(doxbee-async-es2017-native): 19.9 ms. Time(doxbee-promises-es2015-native): 26.3 ms.</span></pre><p id="4e75" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">关于promise性能的当前状态的更多细节可以在这个由<a class="ae lp" href="https://blog.kuzzle.io/bluebird-native-async_await-javascript-promises-performances-2020" rel="noopener ugc nofollow" target="_blank"> Kuzzle团队</a>撰写的精彩文章中找到。</p><h2 id="0995" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">Async/Await和Promises —一句警告</h2><p id="5b19" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">即使有了async/await，简化异步代码仍然是一个挑战。例如，core Node.js的撰稿人詹姆斯·斯内尔提供了七条建议来避免违背诺言:</p><ul class=""><li id="6655" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">知道你的代码何时被执行</li><li id="1e8a" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">不要使用意想不到的承诺</li><li id="1b93" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">避免混淆承诺和回电</li><li id="00c8" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">不要在循环中创造承诺</li><li id="feb1" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">要明白同步承诺是没有用的</li><li id="750a" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">忌长。then()链</li><li id="3fcc" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">避免过度思考</li></ul><h1 id="a87e" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">生成器和迭代器——产生控制的另一种方式</h1><p id="5208" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">如上所述，<em class="lt">“Await表达式通过一个异步函数暂停进程，产生控制，然后只有当一个等待的基于承诺的异步操作被完成或拒绝时才恢复进程。”</em></p><p id="5c92" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在V8和Node.js中获得控制权的另一种方式是通过生成器。虽然在最近的Node.js中直接使用生成器相对较少，但如果您偶然发现它们，它们仍然值得理解。</p><h2 id="4102" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">作为协程的生成器</h2><p id="0237" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">为了理解生成器以及它们与控制流的关系，理解子例程和协程的概念是很重要的。</p><p id="2744" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个<em class="lt">子程序</em>是一个执行特定任务的集中代码块(一个函数)，打包成一个单元。每当需要执行特定任务时，这个单元就可以在程序中使用。当子程序被调用时，执行从开始处开始，一旦子程序退出，它就结束了；子例程的实例只返回一次，并且在调用之间不保持状态。例如，在JavaScript中，同步子例程可能如下所示:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="f693" class="lx kf hh mn b fi mr ms l mt mu">function add(x, y) {<br/>return x + y;<br/>}</span></pre><p id="f7cc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">子例程是结构化编程的一个主要部分，这是我们许多人在早期作为程序员接受教育时学到的一个范例。</p><ul class=""><li id="a92e" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated"><strong class="jk hi">一个协程</strong>也是一个集中式代码块。然而，与子程序不同的是，通过允许暂停和恢复执行，为<em class="lt">协作多任务</em>概括子程序。进程自动<em class="lt">周期性地产生</em>控制，以使多个任务能够同时运行。协程可以通过调用其他协程来退出，这些协程稍后可能会返回到它们在原始代码例程中被调用的位置。</li><li id="cf2d" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated"><strong class="jk hi">生成器</strong>是一个“半协同程序”——协同程序的一个子集。</li></ul><p id="02d3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">生成器和协程都可以产生多次，暂停它们的执行并允许在多个点重新进入。生成器只是将控制权转移回生成器的调用者，并传递一个值。在JavaScript世界中，所有生成器也是迭代器:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="845c" class="lx kf hh mn b fi mr ms l mt mu">// code example borrowed from Arfat Salman at<br/>// <a class="ae lp" href="https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5" rel="noopener" target="_blank">https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5</a></span><span id="68c6" class="lx kf hh mn b fi mv ms l mt mu">function * generatorFunction() { // Line 1<br/>    console.log(‘This will be executed first.’);<br/>    yield ‘Hello, ‘; // Line 2<br/>    console.log(‘I will be printed after the pause’);<br/>    yield ‘World!’;<br/>}</span><span id="4be2" class="lx kf hh mn b fi mv ms l mt mu">const generatorObject = generatorFunction(); // Line 3<br/>console.log(generatorObject.next().value); // Line 4<br/>console.log(generatorObject.next().value); // Line 5<br/>console.log(generatorObject.next().value); // Line 6</span><span id="09b6" class="lx kf hh mn b fi mv ms l mt mu">/*********************************************/<br/>/* Output begins */<br/>/*********************************************/</span><span id="4a9d" class="lx kf hh mn b fi mv ms l mt mu">// This will be executed first.<br/>// Hello,<br/>// I will be printed after the pause<br/>// World!<br/>// undefined</span><span id="57a8" class="lx kf hh mn b fi mv ms l mt mu">/*********************************************/<br/>/* Output ends */<br/>/*********************************************/</span></pre><p id="b4bb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">StackOverflow上一个关于Python 的<a class="ae lp" href="https://stackoverflow.com/questions/29864366/difference-between-function-and-generator" rel="noopener ugc nofollow" target="_blank">线程说得好:</a></p><blockquote class="lq lr ls"><p id="8cda" class="ji jj lt jk b jl jm ii jn jo jp il jq lu js jt ju lv jw jx jy lw ka kb kc kd ha bi translated"><em class="hh">“生成器与返回数组的函数非常相似，因为生成器有参数，可以被调用，并生成一系列值。但是，生成器一次生成一个值，而不是构建一个包含所有值的数组并一次返回所有值，这需要较少的内存并允许调用者立即开始处理前几个值。简而言之，生成器看起来像函数，但行为像迭代器。”——</em><a class="ae lp" href="https://stackoverflow.com/questions/29864366/difference-between-function-and-generator" rel="noopener ugc nofollow" target="_blank"><em class="hh">“函数和生成器的区别？”</em> </a> <em class="hh">上栈溢出无编码器</em> <a class="ae lp" href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="noopener ugc nofollow" target="_blank"> (CC BY-SA 4.0) </a></p></blockquote><h2 id="cc58" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">什么是迭代器？</h2><p id="eb39" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">如前所述，生成器总是迭代器。因此，迭代器通常采用代码引用的形式，在执行时，计算容器中的下一项并返回它。当迭代器到达容器的末尾时，它返回一个商定的值。</p><p id="3dc0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">迭代器和可迭代对象实际上分散在整个JavaScript中。例如，在幕后<em class="lt">展开语法</em>利用迭代:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="92fe" class="lx kf hh mn b fi mr ms l mt mu">const someString = ‘hi’<br/>console.log([…someString]); // [“h”,”i”]</span></pre><p id="f093" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">也就是说，JavaScript中可迭代值最常见的用法可能是for of循环。例如，由于数组是可迭代的，所以下面的代码会按预期工作:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="47a2" class="lx kf hh mn b fi mr ms l mt mu">for (const element of [10,12,17,19]) {<br/>console.log(element);<br/>}</span></pre><p id="983c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以下容器都是内置的可迭代对象，因为它们的每个原型对象都实现了一个@@iterator方法:</p><ul class=""><li id="fd82" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">线</li><li id="4774" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">排列</li><li id="13c3" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">地图</li><li id="fc22" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">一组</li></ul><p id="b927" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">同样，JavaScript中的许多API都接受可重复项，包括:</p><ul class=""><li id="f536" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">地图</li><li id="dd78" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">一组</li><li id="bd5d" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">承诺。所有</li><li id="f2f6" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">承诺。都解决了</li><li id="e665" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">承诺.比赛</li><li id="1eb7" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">数组. from</li></ul><h2 id="9ab5" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">发电机——为什么？</h2><p id="0b00" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">一般来说，自定义迭代器和生成器不是您需要实现的东西——您可以主要利用JavaScript的内置迭代器和async/await语法的组合。特别是，它回避了这样一个问题——“<em class="lt">为什么生成器曾经在语言中实现过？”</em></p><p id="155c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在<em class="lt"> async/await </em>操作之前的日子里，在像<a class="ae lp" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank"> co </a>这样的库的帮助下，生成器可以被用来给开发者一个更干净的方法来处理异步代码:</p><pre class="ix iy iz ja fd mm mn mo mp aw mq bi"><span id="c31e" class="lx kf hh mn b fi mr ms l mt mu">// code example borrowed from Arfat Salman at<br/>// <a class="ae lp" href="https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5" rel="noopener" target="_blank">https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5</a></span><span id="a690" class="lx kf hh mn b fi mv ms l mt mu">/* original code written with Promises */<br/>function fetchJson(url) {<br/>    return fetch(url)<br/>    .then(request =&gt; request.text())<br/>    .then(text =&gt; {<br/>      return JSON.parse(text);<br/>    })<br/>    .catch(error =&gt; {<br/>      console.log(`ERROR: ${error.stack}`);<br/>    });<br/>}</span><span id="8843" class="lx kf hh mn b fi mv ms l mt mu">/* using the co library to polyfill async/await */<br/>const fetchJson = co.wrap(function* (url) {<br/>    try {<br/>      let request = yield fetch(url);<br/>      let text = yield request.text();<br/>      return JSON.parse(text);<br/>    }<br/>    catch (error) {<br/>      console.log(`ERROR: ${error.stack}`);<br/>    }<br/>});</span><span id="9c2d" class="lx kf hh mn b fi mv ms l mt mu">/* the same call using plain old async/await */<br/>async function fetchJson(url) {<br/>    try {<br/>      let request = await fetch(url);<br/>      let text = await request.text();<br/>      return JSON.parse(text);<br/>    }<br/>    catch (error) {<br/>      console.log(`ERROR: ${error.stack}`);<br/>    }<br/>}</span></pre><p id="893a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">同样，在2018年11月V8优化底层实现之前，写得好的生成器代码实际上可以胜过类似的async/await代码。例如，参见<a class="ae lp" href="https://glebbahmutov.com/blog/performance-of-v8-generators-vs-promises/" rel="noopener ugc nofollow" target="_blank">2015年</a>的这个析因试验。</p><p id="f58d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">综上所述，async/await是2020年Node.js中占主导地位的异步范例。</p><h2 id="6d0f" class="lx kf hh bd kg ly lz ma kk mb mc md ko jr me mf kq jv mg mh ks jz mi mj ku mk bi translated">最后一点——简单的东西</h2><p id="a0ee" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">像大多数语言一样，Node.js/JavaScript有一套标准的结构化控制流构造，其操作方式与其他语言非常相似。有关这些的更多信息，请查看<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><ul class=""><li id="9ed6" class="lb lc hh jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">if/else</li><li id="9ff1" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">为</li><li id="620c" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">在…期间</li><li id="5794" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">尝试/抓住</li><li id="b5e1" class="lb lc hh jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">扔</li></ul><h1 id="e4e6" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">把一切都包起来</h1><p id="2ab9" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">理解Node.js控制流对于构建大规模应用程序来说是至关重要的，这些应用程序可以可靠地交付可预测的商业价值。我希望这篇文章能帮助软件工程师更好地理解Node.js如何处理这个问题。</p></div><div class="ab cl mw mx go my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ha hb hc hd he"><p id="1949" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lt">披露声明:2020首创一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>