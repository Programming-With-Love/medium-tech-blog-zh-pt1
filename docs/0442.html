<html>
<head>
<title>Lessons learnt using Coroutines Flow in the Android Dev Summit 2019 app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android Dev Summit 2019应用程序中使用协程流的经验教训</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/lessons-learnt-using-coroutines-flow-4a6b285c0d06?source=collection_archive---------1-----------------------#2019-11-26">https://medium.com/androiddevelopers/lessons-learnt-using-coroutines-flow-4a6b285c0d06?source=collection_archive---------1-----------------------#2019-11-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/eea09d7b1d1ec02d05ac8a99b4f7caa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8-LfEBjLlXK6djnGxLOkg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrak</a></figcaption></figure><div class=""/><p id="e365" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章是关于我们在<a class="ae hu" href="https://play.google.com/store/apps/details?id=com.google.samples.apps.adssched" rel="noopener ugc nofollow" target="_blank">Android Dev Summit(ADS)2019 app</a>中使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener ugc nofollow" target="_blank">Flow</a></code>时发现的最佳实践；刚刚被<a class="ae hu" href="https://github.com/google/iosched/tree/adssched" rel="noopener ugc nofollow" target="_blank">开源的</a>。请继续阅读，了解我们应用的每一层是如何处理数据流的。</p><p id="e6ed" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ADS应用架构遵循<a class="ae hu" href="https://developer.android.com/jetpack/docs/guide#recommended-app-arch" rel="noopener ugc nofollow" target="_blank">推荐的应用架构指南</a>，增加了一个领域层(用例),有助于分离关注点，保持类小、集中、可重用和可测试:</p><figure class="jx jy jz ka fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jw"><img src="../Images/cd52bd79815392ead9d18f57ec39c31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anZUrs-wCLc5mEN0ElDaow.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Architecture of the ADS 2019 app</figcaption></figure><p id="5ed3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">像许多安卓应用一样，ADS应用从网络或缓存中缓慢加载数据；我们发现这是<code class="du js jt ju jv b">Flow</code>的完美用例。对于一次性操作，<a class="ae hu" rel="noopener" href="/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45">暂停功能</a>更合适。有两个主要的提交来重构应用程序以使用协程。<a class="ae hu" href="https://github.com/google/iosched/pull/333/commits/5f5115e21f1cb008b1a6c1d6130104a86f20904b" rel="noopener ugc nofollow" target="_blank">第一次提交</a>迁移单次操作，而<a class="ae hu" href="https://github.com/google/iosched/pull/333/commits/643e531d00884291d79c6742601e2bd53b9f2ee4" rel="noopener ugc nofollow" target="_blank">第二次提交</a>迁移到数据流。</p><p id="190d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，您可以找到我们重构应用所遵循的原则，从在架构的所有层中使用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>到仅使用<code class="du js jt ju jv b">LiveData</code>在视图和视图模型之间进行通信，以及在用例和架构的较低层使用协程。</p><h1 id="423c" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">1.更喜欢将流公开为流(而不是通道)</h1><p id="d3a0" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">在协程中有两种方法可以处理数据流:一种是<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener ugc nofollow" target="_blank">Flow</a></code> <a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener ugc nofollow" target="_blank"> API </a>另一种是<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank">Channel</a></code> <a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank"> API </a>。频道是一种同步原语，而<code class="du js jt ju jv b">Flow</code>是为数据流建模而构建的:它是订阅数据流的工厂。然而，通道可以用来支持一个<code class="du js jt ju jv b">Flow</code>，我们将在后面看到。</p><blockquote class="le"><p id="8e91" class="lf lg hx bd lh li lj lk ll lm ln jr dx translated">更喜欢公开流，因为它比通道给你更多的灵活性，更明确的契约和操作符</p></blockquote><p id="4cb5" class="pw-post-body-paragraph iu iv hx iw b ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn ls jp jq jr ha bi translated">由于终端操作符的性质，流自动关闭数据流，终端操作符触发数据流的执行，并根据生产者端的所有流操作成功或异常地完成。因此，你不能(几乎同样容易地)泄露生产者方面的资源。这对于通道来说更容易做到:如果<code class="du js jt ju jv b">Channel</code>没有正确关闭，制作方可能不会清理大量资源。</p><p id="4dac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">应用程序的数据层负责提供数据，通常通过从数据库读取或从互联网获取。例如<a class="ae hu" href="https://github.com/google/iosched/blob/adssched/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/UserEventDataSource.kt" rel="noopener ugc nofollow" target="_blank">这里有一个公开用户事件数据流的数据源接口</a>:</p><pre class="jx jy jz ka fd lt jv lu lv aw lw bi"><span id="4afb" class="lx kc hx jv b fi ly lz l ma mb">interface UserEventDataSource {<br/>  fun getObservableUserEvent(userId: String): <strong class="jv hy">Flow</strong>&lt;UserEventResult&gt;<br/>}</span></pre><h1 id="afd0" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">2.如何在你的Android应用架构中使用Flow</h1><h2 id="bc4d" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">用例与存储库</h2><p id="c51b" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">View/ViewModel和DataSource之间的层(即我们的用例中的UseCase和Repository)通常需要在ViewModel层使用之前组合来自多个查询的数据或转换数据。就像<a class="ae hu" href="https://kotlinlang.org/docs/reference/sequences.html" rel="noopener ugc nofollow" target="_blank"> Kotlin序列</a>，<code class="du js jt ju jv b">Flow</code>支持大量的操作符来转换你的数据。已经有大量的<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/#extension-functions" rel="noopener ugc nofollow" target="_blank">操作符可用</a>，或者您可以创建自己的转换(例如使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" rel="noopener ugc nofollow" target="_blank">transform</a></code>操作符)。然而，<code class="du js jt ju jv b">Flow</code>在许多操作符上公开了suspend lambdas，通常不需要定制转换来完成复杂的任务，只需从你的<code class="du js jt ju jv b">Flow</code>内部调用suspend函数即可。</p><p id="5f52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的ADS示例中，我们希望将<code class="du js jt ju jv b">UserEventResult</code>与<a class="ae hu" href="https://github.com/google/iosched/blob/adssched/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/DefaultSessionAndUserEventRepository.kt" rel="noopener ugc nofollow" target="_blank">存储库层</a>中的会话数据结合起来。我们使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" rel="noopener ugc nofollow" target="_blank">map</a></code>操作符将suspend lambda应用于从DataSource检索的<code class="du js jt ju jv b">Flow</code>的每个值:</p><figure class="jx jy jz ka fd hj"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="0118" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">视图模型</h2><p id="82d7" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">当使用<code class="du js jt ju jv b">LiveData</code>执行UI ↔视图模型通信时，视图模型层应使用终端操作符(例如<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html" rel="noopener ugc nofollow" target="_blank">collect</a></code>、<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" rel="noopener ugc nofollow" target="_blank">first</a></code>或<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">toList</a></code>)消费来自数据层的数据流。</p><figure class="jx jy jz ka fd hj"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="9607" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mr">参见完整代码</em> <a class="ae hu" href="https://github.com/google/iosched/blob/adssched/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessiondetail/SessionDetailViewModel.kt" rel="noopener ugc nofollow" target="_blank"> <em class="mr">此处</em> </a> <em class="mr">。</em></p><p id="ce47" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你正在将一个<code class="du js jt ju jv b">Flow</code>转换成一个<code class="du js jt ju jv b">LiveData</code>，你可以使用来自<a class="ae hu" href="https://mvnrepository.com/artifact/androidx.lifecycle/lifecycle-livedata-ktx?repo=google" rel="noopener ugc nofollow" target="_blank"> androidX生命周期LiveData ktx库</a>的<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">Flow.asLiveData()</a></code>扩展函数。这非常方便，因为它将共享一个对<code class="du js jt ju jv b">Flow</code>的底层订阅，并将基于观察者的生命周期来管理订阅。此外，<code class="du js jt ju jv b">LiveData</code>还为后来者保持最新的值，并在配置改变时保持订阅活动。查看这段简单的代码，它展示了如何使用扩展函数:</p><pre class="jx jy jz ka fd lt jv lu lv aw lw bi"><span id="d295" class="lx kc hx jv b fi ly lz l ma mb">class SimplifiedSessionDetailViewModel(<br/>  private val loadUserSessionUseCase: LoadUserSessionUseCase,<br/>  ...<br/>): ViewModel() {</span><span id="6ca3" class="lx kc hx jv b fi ms lz l ma mb">  val sessions = loadUserSessionUseCase(sessionId)<strong class="jv hy">.asLiveData()</strong></span><span id="75f4" class="lx kc hx jv b fi ms lz l ma mb">}</span></pre><p id="68cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mr">免责声明:</em>上面的代码片段不是app的一部分；这是代码的简化版本，展示了如何使用<code class="du js jt ju jv b">Flow.asLiveData()</code>。</p><h1 id="a8c3" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">3.何时使用广播信道或流作为实现细节</h1><p id="d477" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">回到数据源实现，我们如何实现上面公开的<code class="du js jt ju jv b">getObservableUserEvent</code>函数？该团队考虑了两种替代实现:构建器或API。每个服务于不同用例。</p><h2 id="81f2" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">何时使用流量</h2><p id="5c03" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated"><code class="du js jt ju jv b">Flow</code>是一股<em class="mr">寒流</em>。冷流是一个数据源，它的<em class="mr">生成器</em>将为每个开始使用事件的侦听器执行，从而在每个订阅上创建一个新的数据流。一旦消费者停止监听或生产者块结束，数据流将自动关闭。</p><blockquote class="le"><p id="3c0b" class="lf lg hx bd lh li lj lk ll lm ln jr dx translated"><em class="mt">当数据生产需要开始/停止以匹配观察者时,</em>流是一个很好的选择</p></blockquote><p id="b906" class="pw-post-body-paragraph iu iv hx iw b ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn ls jp jq jr ha bi translated">您可以使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html" rel="noopener ugc nofollow" target="_blank">flow</a></code>构建器发出有限或无限数量的元素。</p><pre class="jx jy jz ka fd lt jv lu lv aw lw bi"><span id="3a80" class="lx kc hx jv b fi ly lz l ma mb">val oneElementFlow: Flow&lt;Int&gt; = flow {<br/>  // producer block starts here, stream starts<br/>  emit(1)<br/>  // producer block finishes here, stream will be closed<br/>}</span><span id="006f" class="lx kc hx jv b fi ms lz l ma mb">val unlimitedElementFlow: Flow&lt;Int&gt; = flow {<br/>  // producer block starts here, stream starts<br/>  while(true) {<br/>    // Do calculations<br/>    emit(result)<br/>    delay(100)<br/>  }<br/>  // producer block finishes here, stream will be closed<br/>}</span></pre><p id="b5cf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flow倾向于用于昂贵的任务，因为它通过协程取消提供自动清理。注意，这种取消是合作性的，从不挂起的流也永远不会被取消:在我们的例子中，因为<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" rel="noopener ugc nofollow" target="_blank">delay</a></code>是一个检查取消的挂起函数，当订户停止侦听时，<code class="du js jt ju jv b">Flow</code>将停止并清理资源。</p><h2 id="f2c8" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">何时使用广播频道</h2><p id="009b" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">一个<code class="du js jt ju jv b">Channel</code>是一个<a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank">并发原语</a>，用于协同程序之间的通信。一个<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-broadcast-channel/" rel="noopener ugc nofollow" target="_blank">BroadcastChannel</a></code>是一个具有组播能力的<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank">Channel</a></code>的实现。</p><p id="e930" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在某些情况下，您可能希望在数据源层中使用<code class="du js jt ju jv b">BroadcastChannel</code>的实现:</p><blockquote class="le"><p id="73b2" class="lf lg hx bd lh li lj lk ll lm ln jr dx translated"><em class="mt">当生产者和消费者具有不同的生命周期或彼此完全独立运行时，使用BroadcastChannel】</em></p></blockquote><p id="002e" class="pw-post-body-paragraph iu iv hx iw b ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn ls jp jq jr ha bi translated">当你想让生产者遵循不同的生命周期，并把当前的结果传播给任何听众时，API是最合适的。这样，生成器就不需要在每次新的侦听器开始使用事件时都启动。</p><p id="2d6b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您仍然可以向调用者公开一个<code class="du js jt ju jv b">Flow</code>，他们不需要知道这是如何实现的。您可以使用扩展函数<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html" rel="noopener ugc nofollow" target="_blank">BroadcastChannel.asFlow()</a></code>将一个<code class="du js jt ju jv b">BroadcastChannel</code>公开为一个<code class="du js jt ju jv b">Flow</code>。</p><p id="002f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，关闭那个<code class="du js jt ju jv b">Flow</code>不会取消订阅。在使用<code class="du js jt ju jv b">BroadcastChannel</code>的时候，你要照顾到它的生命周期。他们不知道是否有监听器，并且将保持资源存活直到<code class="du js jt ju jv b">BroadcastChannel</code>被取消或关闭。确保不再需要时关闭<code class="du js jt ju jv b">BroadcastChannel</code>。此外，请记住，关闭的通道不能再次激活，您需要创建一个新的实例。</p><p id="2429" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如何使用<code class="du js jt ju jv b">BroadcastChannel</code> API的例子可以在下一节找到。</p><h2 id="a14a" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">放弃</h2><p id="5875" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">部分<code class="du js jt ju jv b">Flow</code>和<code class="du js jt ju jv b">Channel</code>API仍处于实验阶段，它们可能会改变。在某些情况下，您目前可能会使用频道，但未来的建议可能会改为使用<code class="du js jt ju jv b">Flow</code>。具体来说，<code class="du js jt ju jv b"><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/pull/1354" rel="noopener ugc nofollow" target="_blank">StateFlow</a></code>和Flow的<code class="du js jt ju jv b"><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/issues/1261" rel="noopener ugc nofollow" target="_blank">share</a></code> <a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/issues/1261" rel="noopener ugc nofollow" target="_blank">操作符</a>的建议可能会在未来减少<code class="du js jt ju jv b">Channel</code>的使用。</p><h1 id="d875" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">4.将数据流基于回调的API转换为协同例程</h1><p id="85d3" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">多个库已经支持数据流操作的协同程序，包括<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/room" rel="noopener ugc nofollow" target="_blank"> Room </a>。对于那些没有的，你可以将任何基于回调的API转换成协程程序。</p><h2 id="debe" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">流程实施</h2><p id="0657" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">如果您想转换一个基于流回调的API来使用<code class="du js jt ju jv b">Flow</code>，您可以使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html" rel="noopener ugc nofollow" target="_blank">channelFlow</a></code>函数(还有<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html" rel="noopener ugc nofollow" target="_blank">callbackFlow</a></code>，它共享相同的实现)。<code class="du js jt ju jv b">channelFlow</code>创建一个<code class="du js jt ju jv b">Flow</code>的实例，其元素被发送到一个<code class="du js jt ju jv b">Channel</code>。这允许我们提供在不同的上下文中运行或并发运行的元素。</p><p id="bbe2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下面的示例中，我们希望将从回调中获得的元素发送到<code class="du js jt ju jv b">Flow</code>:</p><ol class=""><li id="d2a5" class="mu mv hx iw b ix iy jb jc jf mw jj mx jn my jr mz na nb nc bi translated">用<code class="du js jt ju jv b">channelFlow</code>构建器创建一个流程，它注册一个对第三方库的回调。</li><li id="2085" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr mz na nb nc bi translated">将从回调中收到的所有项目发送到<code class="du js jt ju jv b">Flow</code>。</li><li id="f26f" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr mz na nb nc bi translated">当订阅者停止监听时，我们使用<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/await-close.html" rel="noopener ugc nofollow" target="_blank">suspend fun</a>T3】将订阅取消注册到API。</li></ol><figure class="jx jy jz ka fd hj"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="8644" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mr">参见完整代码</em> <a class="ae hu" href="https://github.com/google/iosched/blob/adssched/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/FirestoreUserEventDataSource.kt" rel="noopener ugc nofollow" target="_blank"> <em class="mr">此处</em> </a> <em class="mr">。</em></p><h2 id="9edb" class="lx kc hx bd kd mc md me kh mf mg mh kl jf mi mj kp jj mk ml kt jn mm mn kx mo bi translated">广播频道实现</h2><p id="b6a9" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">对于我们跟踪Firestore用户认证的数据流，我们使用了<code class="du js jt ju jv b">BroadcastChannel</code> API，因为我们想要注册一个遵循不同生命周期的认证监听器，并将当前结果广播给正在监听的任何人。</p><p id="67bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要将回调API转换成<code class="du js jt ju jv b">BroadcastChannel</code>，你需要比使用<code class="du js jt ju jv b">Flow</code>多一点的代码。您可以创建一个类，将<code class="du js jt ju jv b">BroadcastChannel</code>的实例保存在一个变量中。在初始化过程中，像以前一样注册向<code class="du js jt ju jv b">BroadcastChannel</code>发送元素的回调:</p><figure class="jx jy jz ka fd hj"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="ac71" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mr">参见全码</em> <a class="ae hu" href="https://github.com/google/iosched/blob/adssched/mobile/src/main/java/com/google/samples/apps/iosched/shared/data/signin/datasources/FirebaseAuthStateUserDataSource.kt" rel="noopener ugc nofollow" target="_blank"> <em class="mr">此处</em> </a> <em class="mr">。</em></p><h1 id="6f2f" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">5.测试技巧</h1><p id="64a9" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">为了<strong class="iw hy">测试流程转换</strong>(正如我们在用例层和存储库层中所做的那样)，您可以使用<code class="du js jt ju jv b">flow</code>构建器来返回假数据。例如:</p><pre class="jx jy jz ka fd lt jv lu lv aw lw bi"><span id="5ecc" class="lx kc hx jv b fi ly lz l ma mb">/* Copyright 2019 Google LLC.<br/>   SPDX-License-Identifier: Apache-2.0 */</span><span id="59d9" class="lx kc hx jv b fi ms lz l ma mb">object FakeUserEventDataSource : UserEventDataSource {<br/>  override fun getObservableUserEvents(userId: String) = <strong class="jv hy">flow</strong> {<br/>    emit(UserEventsResult(userEvents))<br/>  }<br/>}</span><span id="3010" class="lx kc hx jv b fi ms lz l ma mb">class DefaultSessionAndUserEventRepositoryTest {<br/>  @Test<br/>  fun observableUserEvents_areMappedCorrectly() = runBlockingTest {<br/>    // Prepare repo<br/>    val userEvents = repository<br/>          .getObservableUserEvents("user", true)<strong class="jv hy">.first()</strong><br/>    // Assert user events<br/>  }<br/>}</span></pre><p id="fd6a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了<strong class="iw hy">成功测试流程</strong>的实现，一个好主意是使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" rel="noopener ugc nofollow" target="_blank">take</a></code>操作符从流程中获取一些项目，使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">toList</a></code>操作符作为终端操作符来获取列表中的结果。请参见以下测试中的示例:</p><pre class="jx jy jz ka fd lt jv lu lv aw lw bi"><span id="8a1a" class="lx kc hx jv b fi ly lz l ma mb">class AnotherStreamDataSourceImplTest {<br/>  @Test<br/>  fun `Test happy path`() = runBlockingTest {<br/>    // Prepare subject<br/>    val result = subject.flow<strong class="jv hy">.take(1).toList()</strong><br/>    // Assert expected result<br/>  }<br/>}</span></pre><p id="a41a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">take</code>操作员非常适合在你拿到物品后关闭<code class="du js jt ju jv b">Flow</code>。每次测试后不关闭一个已启动的<code class="du js jt ju jv b">Flow</code>(或<code class="du js jt ju jv b">BroadcastChannel</code>)将会泄漏内存，并创建一个脆弱且不一致的测试套件。</p><p id="4e2e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意:</strong>如果用一个<code class="du js jt ju jv b">BroadcastChannel</code>来完成DataSource的实现，上面的代码是不够的。你必须管理它的生命周期，确保在测试前启动<code class="du js jt ju jv b">BroadcastChannel</code>，在测试结束后关闭它。如果没有，你会泄漏内存。您可以在另一个流样本中看到类似的<a class="ae hu" href="https://github.com/manuelvicnt/MathCoroutinesFlow/blob/master/app/src/test/java/com/manuelvicnt/coroutinesflow/fibonacci/impl/NeverEndingFibonacciProducerTest.kt#L38" rel="noopener ugc nofollow" target="_blank">测试。</a></p><p id="ad5c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">测试协程的最佳实践也适用于此。如果您在测试代码中创建了一个新的协程，那么您可能希望在测试线程中执行它，以便确定性地执行您的测试。请在<a class="ae hu" href="https://youtu.be/KMb0Fs8rCRs?t=416" rel="noopener ugc nofollow" target="_blank">测试协程ADS 2019讲座</a>中查看更多相关信息。</p></div><div class="ab cl ni nj go nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ha hb hc hd he"><h1 id="c75a" class="kb kc hx bd kd ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky bi translated">摘要</h1><ul class=""><li id="2b53" class="mu mv hx iw b ix kz jb la jf nu jj nv jn nw jr nx na nb nc bi translated">我更喜欢向消费者公开<code class="du js jt ju jv b">Flow</code>而不是<code class="du js jt ju jv b">Channel</code>，因为<code class="du js jt ju jv b">Flow</code>提供了所有明确的契约和操作符。</li><li id="a136" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr nx na nb nc bi translated">有了<code class="du js jt ju jv b">Flow</code>，生产者块将在每次有新的监听器时被执行，数据流的生命周期将被自动处理<strong class="iw hy">。</strong></li><li id="f0da" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr nx na nb nc bi translated">使用<code class="du js jt ju jv b">BroadcastChannel</code>，你可以共享生产者，但是你必须自己管理它的生命周期。</li><li id="ac37" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr nx na nb nc bi translated">考虑将基于回调的API转换为协程，以便在应用程序中更好、更习惯地集成API。</li><li id="4d1c" class="mu mv hx iw b ix nd jb ne jf nf jj ng jn nh jr nx na nb nc bi translated">通过使用<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" rel="noopener ugc nofollow" target="_blank">take</a></code>和<code class="du js jt ju jv b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">toList</a></code>操作符，轻松测试流的实现。</li></ul></div></div>    
</body>
</html>