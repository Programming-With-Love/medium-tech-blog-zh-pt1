<html>
<head>
<title>Blurring the Lines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模糊界限</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/blurring-the-lines-4fd33821b83c?source=collection_archive---------4-----------------------#2022-11-14">https://medium.com/androiddevelopers/blurring-the-lines-4fd33821b83c?source=collection_archive---------4-----------------------#2022-11-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="af8b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Android渲染效果#1:模糊效果</h2></div><p id="ff9b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章(以及下一篇文章<a class="ae js" href="https://chethaase.medium.com/agsl-made-in-the-shade-r-7d06d14fe02a" rel="noopener"/>)基本上是我和<a class="ae js" href="https://twitter.com/SumirKodes" rel="noopener ugc nofollow" target="_blank"> Sumir Kataria </a>为今年的Android开发者峰会录制的视频的书面版本:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Here’s the video version of this article (and more!)</figcaption></figure><p id="b0f4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我开始学习如何使用模糊效果时，我并不清楚如何将它融入到整体应用程序中，所以我认为这可能有助于澄清它的用途，它在Android整体渲染工具箱中的位置，以及如何实际创建和使用模糊效果。</p><h1 id="ad0f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">首先，关于在Android上绘图的一句话</h1><p id="8eaa" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">在最基本的层面上，Android上的视觉元素(如按钮、文本和其他UI或自定义元素)通常是通过调用<code class="du lb lc ld le b">Canvas</code>API来绘制的，如<code class="du lb lc ld le b">drawLine()</code>、<code class="du lb lc ld le b">drawText()</code>、<code class="du lb lc ld le b">drawBitmap()</code>等等。除非您在自定义视图中绘制对象，否则您的代码可能不会直接调用这些方法，但是当绘制应用程序中的UI组件时，会以您的名义调用这些方法。</p><p id="90b6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些绘图命令中的大多数向渲染系统提供三条信息。你可以把这些想象成<em class="lf">什么</em>、<em class="lf">哪里</em>以及<em class="lf">如何</em>进行绘图的信息，其中<em class="lf">什么</em>是操作本身(要绘制的“图元”)、<em class="lf">哪里</em>是对象的放置(位置和大小)、以及<em class="lf">如何</em>是绘图属性的集合。我们今天关注的正是这些属性，因为这就是模糊的由来。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/2d2cc1d88f5a90502d4cff47cd4e3c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqthOosKO23bTqHNNMaxEw.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx">Each drawing primitive tells the render what, where, and how to draw the object</figcaption></figure><p id="229c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">绘图属性是由一个<code class="du lb lc ld le b">Paint</code>对象提供的，这个对象的默认属性可以被调用者(你的应用程序或者代表你的UI系统)修改。大多数的<code class="du lb lc ld le b">Paint</code>API都相对简单明了，比如<code class="du lb lc ld le b">setColor()</code>表示图元应该被绘制的颜色，<code class="du lb lc ld le b">setStyle()</code>表示对象应该被填充还是“描边”(表示对象的轮廓)，再加上大量的文本属性，我在这里就不赘述了。</p><p id="dca1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还有更强大和复杂的属性可以分配给一个<code class="du lb lc ld le b">Paint</code>对象。其中包括用于改变图元颜色的<code class="du lb lc ld le b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/ColorFilter" rel="noopener ugc nofollow" target="_blank">ColorFilter</a></code>子类(比如我个人最喜欢的<code class="du lb lc ld le b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/ColorMatrixColorFilter" rel="noopener ugc nofollow" target="_blank">ColorMatrixColorFilter</a></code>，它应该获得longestandmostreativeclassrepetivenamever奖)，以及<em class="lf">着色器</em>。着色器包括各种渐变对象和位图，并提供绘制操作从中采样的源颜色，以提供所绘制的几何图形的结果颜色。例如，使用着色器可以使用线性或圆形渐变来填充矩形，或者使用位图中的值来填充或描边该矩形。(预告:Android 13中有一个新的“着色器”API，允许你超越这些效果；请继续关注本系列的下一篇文章。</p><h1 id="31a4" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">然后是渲染效果</h1><p id="8987" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">当您想要影响单独的绘图操作(比如在自定义视图中绘制一条线)时，上面所有的API都允许您为单独的<code class="du lb lc ld le b">draw*()</code>调用设置属性。但是如果您想在一个<code class="du lb lc ld le b">View</code>中使用所有绘图操作的属性呢？例如，如果您想要给一个按钮着色(它由几个独立的内部绘制操作组成)，或者在一个<code class="du lb lc ld le b">View</code>上应用一个着色器，该怎么办？</p><p id="6f63" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是<code class="du lb lc ld le b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RenderEffect" rel="noopener ugc nofollow" target="_blank">RenderEffect</a></code>的用武之地。<code class="du lb lc ld le b">RenderEffect</code>将一个或多个着色器捆绑在一起，并将它们应用到一个整体<code class="du lb lc ld le b">View</code>——或一个<a class="ae js" href="https://developer.android.com/reference/android/graphics/RenderNode" rel="noopener ugc nofollow" target="_blank">render node</a>(<code class="du lb lc ld le b">Views</code>的底层渲染机制)——通过让渲染器将那些效果应用到整个<code class="du lb lc ld le b">View</code>来简化事情。你可以使用单个<code class="du lb lc ld le b">RenderEffect</code>或者将几个链接在一起来应用多种效果。</p><p id="f8f8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当在API level 31中引入<code class="du lb lc ld le b">RenderEffect</code>时，它提供了将现有的属性效果(如<code class="du lb lc ld le b">ColorFilter</code>、<code class="du lb lc ld le b">Bitmap</code>和<code class="du lb lc ld le b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/Shader" rel="noopener ugc nofollow" target="_blank">Shader</a></code>)收集到效果中，以及将它们链接起来的方法，工厂方法如下:</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="225e" class="lr kf hh le b fi ls lt l lu lv">static RenderEffect createBitmapEffect(Bitmap bitmap)<br/>static RenderEffect createColorFilterEffect(ColorFilter colorFilter)<br/>static RenderEffect createShaderEffect(Shader shader)<br/>static RenderEffect createChainEffect(RenderEffect outer,<br/>                                      RenderEffect inner)</span></pre><p id="5fea" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是<code class="du lb lc ld le b">RenderEffect</code>也引入了一种全新的绘制效果:<em class="lf">模糊</em>。</p><h1 id="c256" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">视力模糊</h1><p id="a141" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">除了封装现有<code class="du lb lc ld le b">Paint</code>属性的对象之外，<code class="du lb lc ld le b">RenderEffect</code>还引入了一种新的效果，可以轻松模糊<code class="du lb lc ld le b">View</code>或<code class="du lb lc ld le b">RenderNode</code>内容:</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="9dde" class="lr kf hh le b fi ls lt l lu lv">static RenderEffect createBlurEffect(float radiusX, float radiusY,<br/>                                     Shader.TileMode edgeTreatment)<br/>static RenderEffect createBlurEffect(float radiusX, float radiusY,<br/>                                     RenderEffect inputEffect,<br/>                                     Shader.TileMode edgeTreatment)</span></pre><p id="f620" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这些方法，您现在可以轻松地在一个<code class="du lb lc ld le b">View</code>(或者，使用上面的第二个重载，另一个<code class="du lb lc ld le b">RenderEffect</code>)上创建一个模糊效果，以便在渲染时模糊整个内容。可以把它想象成通过一个过滤器发送视图的原始内容，这个过滤器在发送的过程中模糊了视图的内容。这就是正在发生的事情，尽管它实现这一点的实际方式是通过渲染屏幕外的内容，应用模糊，然后将模糊的结果复制到原始目标。</p><p id="a821" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lb lc ld le b">radius</code>参数决定了模糊有多大(源输入中每个像素之外的像素在每个方向上有多少)，而<code class="du lb lc ld le b">TileMode</code>决定了模糊边缘会发生什么。这最后一个参数是必需的，因为模糊在被计算的像素之外的像素上操作，所以它需要知道当那些其他像素位于输入内容之外时该做什么。</p><p id="36ae" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建模糊后，您可以通过调用以下命令将其设置在<code class="du lb lc ld le b">View</code>上:</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="effc" class="lr kf hh le b fi ls lt l lu lv">View.setRenderEffect(renderEffect RenderEffect)</span></pre><p id="14a2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以类似地将其设置在<code class="du lb lc ld le b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RenderNode" rel="noopener ugc nofollow" target="_blank">RenderNode</a></code>上:</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="718b" class="lr kf hh le b fi ls lt l lu lv">RenderNode.setRenderEffect(renderEffect RenderEffect)</span></pre><p id="d8b1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">…就是这样！一旦您设置了<code class="du lb lc ld le b">RenderEffect</code>，在该对象中发生的任何绘图都将使用您在其上设置的效果。如果你想改变效果的属性(如模糊半径)，你重新创建并再次设置它，如上所述。</p><h1 id="e745" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">例子</h1><p id="f4b2" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">我写了一个简单的应用程序来看看如何在UI中使用模糊。具体来说，我想演示如何使用模糊来帮助从背景中“弹出”前景内容，就像相机对焦有助于将图片主体从背景中分离出来一样。</p><p id="24c3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我在背景上做了模糊处理。在这种情况下，背景是照片库；包含一组图片缩略图的布局。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lw"><img src="../Images/cc7f1a3c933873c2ccde0cd4786bf564.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*dw6Wh8YzJxrSqHCDUP16FA.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">A layout containing picture thumbnails. Clicking on a picture shows an enlarged view of it.</figcaption></figure><p id="0053" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">点击其中一张图片可以放大它，并显示该图片的标题。如果我们可以模糊背景，这样当我们试图专注于前景图片及其标题时，其余的图片就不会产生太多的视觉噪音，这不是很好吗？</p><p id="f8f5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在应用程序中添加了一个<code class="du lb lc ld le b">SeekBar</code>，允许动态改变模糊度。这不是我在一个完成的应用程序中需要的东西(只是选择一个模糊的工作，并坚持下去；用户不会想要修改这种东西，所以保持用户界面简单)。但我最初想用它来玩不同的模糊，并展示如何用不同的参数重新创建它们。<code class="du lb lc ld le b">seekBar</code>传入一个从0到50的值(<code class="du lb lc ld le b">SeekBar</code> UI组件上的最小/最大值)。</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="8e80" class="lr kf hh le b fi ls lt l lu lv"><strong class="le hi">seekBar</strong>.setOnSeekBarChangeListener(<strong class="le hi">object </strong>: SeekBar.OnSeekBarChangeListener{<br/>    <strong class="le hi">override fun </strong>onProgressChanged(seekBar: SeekBar, progress: Int,<br/>                                   fromUser: Boolean) {<br/>        updateEffect(progress.toFloat())<br/>    }<br/>    // start/stop overrides stubbed out...<br/>})</span></pre><p id="83d9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lb lc ld le b">updateEffect()</code>使用<code class="du lb lc ld le b">progress</code>值作为模糊半径(我对x和y使用相同的值)。<strong class="iy hi"> <em class="lf">重要提示</em> </strong>:一个<code class="du lb lc ld le b">0</code>的值用来表示应该去除模糊，这是通过设置<code class="du lb lc ld le b">RenderEffect</code>到<code class="du lb lc ld le b">null</code>来实现的。原来要求0半径模糊(数学上等同于不模糊)会，呃，崩溃。<code class="du lb lc ld le b">0</code>显然不是系统要求模糊效果时期望的值。这是很少记录的(我们正在修复…)，所以我想你可能想知道，如果你在家里尝试这个的话。我知道我想知道当我的初始代码试图处理那个值时发生了什么。</p><pre class="jt ju jv jw fd ln le lo lp aw lq bi"><span id="2425" class="lr kf hh le b fi ls lt l lu lv"><strong class="le hi">fun </strong>updateEffect(progress: Float) {<br/>    <strong class="le hi">if </strong>(progress &gt; 0) {<br/>        <strong class="le hi">val </strong>blur = RenderEffect.createBlurEffect(<br/>            progress, progress, Shader.TileMode.<em class="lf">CLAMP</em>)<br/>        <strong class="le hi">pictureGrid</strong>.setRenderEffect(blur)<br/>    } <strong class="le hi">else </strong>{<br/>        <strong class="le hi">pictureGrid</strong>.setRenderEffect(<strong class="le hi">null</strong>)<br/>    }<br/>}</span></pre><p id="bc1c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lb lc ld le b">updateEffect()</code>创建RenderEffect(或使其无效以移除它)，用<code class="du lb lc ld le b">progress</code>的值作为半径，然后在图片布局上设置它，<code class="du lb lc ld le b">voilà</code>，我们有模糊:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lx"><img src="../Images/ef67dfd22fd3695092197c539f14b02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*0uPB9MgIaQDPyQQ_Zx2BjQ.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Picture gallery with blur RenderEffect applied to the container</figcaption></figure><p id="546e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们有了模糊的工作，是时候在放大的图片上工作了。这种效果是通过Android 13中新的AGSL <code class="du lb lc ld le b">RuntimeShader</code>功能处理的，在本系列的第2部分中有所描述:<a class="ae js" href="https://chethaase.medium.com/agsl-made-in-the-shade-r-7d06d14fe02a" rel="noopener"> AGSL:在阴影中制造(r) </a>。</p></div></div>    
</body>
</html>