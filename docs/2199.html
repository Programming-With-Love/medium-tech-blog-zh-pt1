<html>
<head>
<title>Avoiding Memory Leak in Golang API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang API中避免内存泄漏</h1>
<blockquote>原文：<a href="https://medium.easyread.co/avoiding-memory-leak-in-golang-api-1843ef45fca8?source=collection_archive---------0-----------------------#2018-01-16">https://medium.easyread.co/avoiding-memory-leak-in-golang-api-1843ef45fca8?source=collection_archive---------0-----------------------#2018-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7b41" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在将Golang API发布到产品中之前，您必须阅读这篇文章。基于我们在Kurio的真实故事，我们如何努力争取每一个版本，因为我们没有以正确的方式做它。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/946a32712214a4d175bc5b73ec056e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WK1t5y-D6WtwzAFvVg62A.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">laptop on fire taken from google image search</figcaption></figure><p id="25bf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">几周前，我们在<a class="ae lo" href="https://kurio.co" rel="noopener ugc nofollow" target="_blank"> Kurio </a>修复我们主要服务中奇怪且未被发现的错误。我们已经尝试了很多方法来调试和修复它。问题不在于业务逻辑。因为它已经在生产中运行了几个星期。但我们总是通过我们的自动缩放机制来节省，所以它就像运行良好。</p><p id="3a18" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">直到后来，我们想通了，是因为我们的代码，我们没有做好。</p><h2 id="79e3" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">体系结构</h2><p id="6b06" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">仅供参考，我们正在我们的架构中使用微服务模式。我们有一个网关API——我们称之为<code class="fe mn mo mp mq b">main API</code>——为我们的用户(移动和网络)提供API。由于它的角色类似于API网关，所以它的任务只是处理来自用户的请求，然后调用所需的服务，并构建对用户的响应。这个<code class="fe mn mo mp mq b">main API</code>，完全用Golang写的。选择golang的原因是另一个故事，我在这里就不说了。</p><p id="1a9d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果画在一张图上，我们的系统看起来会更像这样。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/cf70fc6b069c3edace9855edc40a02ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8KqwAtasbTzt96hYntjMQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Kurio architecture</figcaption></figure><h1 id="a161" class="ms lq in bd lr mt mu mv lu mw mx my lx jt mz ju ma jw na jx md jz nb ka mg nc bi translated">问题是</h1><p id="c662" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我们已经为我们的主要API奋斗了很长时间，它总是关闭，并对我们的移动应用程序返回很长的响应，有时会导致我们的API无法访问。我们的API仪表板监视器变成红色——老实说，当我们的API仪表板监视器变成红色时，这是一件危险的事情，会给我们工程师带来压力、恐慌和疯狂😈。</p><p id="ad3a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">其他事情是，我们的CPU和内存使用率越来越高。如果发生这种情况，我们只需手动重启，等待它再次运行。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/19fa07e76e9bd9dd8b2d4a225efe23a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*bqsD1tLb4gAvHw4kJOnvjA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Our API response time up-to 86 seconds for a single request.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/c4bb098ddf4fe01a23a84757a444036f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hw-Mdt7ctshVu2SbsM4Vhw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">graph our API response time, and doing restart manually for safety.</figcaption></figure><p id="83dd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个bug真的让我们很沮丧，因为我们没有任何关于这个bug的日志。我们只是知道响应时间太长了。CPU和内存使用量不断增加。这就像一场噩梦。</p><h1 id="e81a" class="ms lq in bd lr mt mu mv lu mw mx my lx jt mz ju ma jw na jx md jz nb ka mg nc bi translated">阶段1:使用定制的http。客户</h1><p id="fd13" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我们在开发这项服务时学到的一件事是，不要相信默认配置。</p><p id="e1a3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们使用一个定制的<code class="fe mn mo mp mq b">http.Client</code>，而不是使用http包中的缺省值，</p><pre class="kd ke kf kg gt nf mq ng nh aw ni bi"><span id="d5e9" class="lp lq in mq b gy nj nk l nl nm">client:=http.Client{} //default</span></pre><p id="873f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们根据需要添加一些配置。因为我们需要重用连接，所以我们在传输中进行一些配置，并控制最大空闲可重用连接。</p><pre class="kd ke kf kg gt nf mq ng nh aw ni bi"><span id="2926" class="lp lq in mq b gy nj nk l nl nm">keepAliveTimeout:= 600 * time.Second<br/>timeout:= 2 * time.Second<br/>defaultTransport := &amp;http.Transport{<br/>    Dial: (&amp;net.Dialer{<br/>                     KeepAlive: keepAliveTimeout,}<br/>           ).Dial,<br/>    MaxIdleConns: 100,<br/>    MaxIdleConnsPerHost: 100,</span><span id="6576" class="lp lq in mq b gy nn nk l nl nm">}</span><span id="eea1" class="lp lq in mq b gy nn nk l nl nm">client:= &amp;http.Client{<br/>           Transport: defaultTransport,<br/>           Timeout:   timeout,<br/>}</span></pre><p id="3b0c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种配置可以帮助我们减少用于调用另一个服务的最大时间。</p><h1 id="fea5" class="ms lq in bd lr mt mu mv lu mw mx my lx jt mz ju ma jw na jx md jz nb ka mg nc bi translated">阶段2:避免未关闭响应体的内存泄漏</h1><p id="b150" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我们从这个阶段学到的是:如果我们想将我们的连接池重用到另一个服务，我们必须读取响应体，并关闭它。</p><p id="58ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因为我们的<code class="fe mn mo mp mq b">main API</code>只是调用另一个服务，所以我们犯了一个致命的错误。我们的<code class="fe mn mo mp mq b">main API </code>假设重用来自<code class="fe mn mo mp mq b">http.Client</code>的可用连接，所以无论发生什么，我们必须读取响应体，即使我们不需要它。我们还必须关闭响应体。这两者都用来避免我们的服务器内存泄漏。</p><p id="5a4d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们忘记了在代码中关闭响应体。这可能会给我们的生产带来巨大的灾难。</p><p id="c0f8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">解决方案是:我们关闭响应体并读取它，即使我们不需要数据。</p><pre class="kd ke kf kg gt nf mq ng nh aw ni bi"><span id="d069" class="lp lq in mq b gy nj nk l nl nm">req, err:= http.NewRequest("GET","http://example.com?q=one",nil)<br/>if err != nil {<br/>  return err<br/>}</span><span id="58a0" class="lp lq in mq b gy nn nk l nl nm">resp, err:= client.Do(req)<br/>//=================================================<br/>// CLOSE THE RESPONSE BODY<br/>//=================================================<br/>if resp != nil {<br/>    defer resp.Body.Close() // MUST CLOSED THIS <br/>}<br/>if err != nil {<br/>  return err<br/>}</span><span id="7f73" class="lp lq in mq b gy nn nk l nl nm">//=================================================<br/>// READ THE BODY EVEN THE DATA IS NOT IMPORTANT<br/>// THIS MUST TO DO, TO AVOID MEMORY LEAK WHEN REUSING HTTP <br/>// CONNECTION<br/>//=================================================<br/>_, err = io.Copy(ioutil.Discard, resp.Body) // WE READ THE BODY</span><span id="098c" class="lp lq in mq b gy nn nk l nl nm">if err != nil { <br/>   return err<br/>}</span></pre><p id="11e0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们在这里阅读了一篇很棒的文章后修复了这个问题:<a class="ae lo" href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" rel="noopener ugc nofollow" target="_blank">http://devs . cloud immunity . com/gotchas-and-common-errors-in-go-golang/</a>还有这里:<a class="ae lo" href="http://tleyden.github.io/blog/2016/11/21/tuning-the-go-http-client-library-for-load-testing/" rel="noopener ugc nofollow" target="_blank">http://tleyden . github . io/blog/2016/11/21/tuning-the-go-http-client-library-for-load-testing/</a></p><p id="1f23" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第一阶段和第二阶段，并借助自动伸缩成功地减少了这个bug。好吧，老实说，从2017年开始，这种情况再也不会发生了，哪怕是3个月。</p><h1 id="904f" class="ms lq in bd lr mt mu mv lu mw mx my lx jt mz ju ma jw na jx md jz nb ka mg nc bi translated">阶段Golang通道中的超时控制</h1><p id="ff86" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">运行几个月后，这个bug再次出现。2018年1月的第一周，我们的<code class="fe mn mo mp mq b">main API</code>打来的一个服务，let说:宕机了。由于某些原因，无法访问。</p><p id="423b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以当我们的<code class="fe mn mo mp mq b">content service</code>停机时，我们的<code class="fe mn mo mp mq b">main API</code>又会被解雇。API仪表板再次变红，API响应时间变得越来越长，越来越慢。即使使用自动缩放，我们的CPU和内存使用率也会非常高。</p><p id="7c4f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们再次试图找到问题的根源。嗯，重新运行<code class="fe mn mo mp mq b">content service</code>后，我们再次运行良好。</p><p id="bd75" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于这种情况，我们很好奇，为什么会发生这种情况。因为我们认为，我们已经在<code class="fe mn mo mp mq b">http.Client</code>中设置了超时期限，所以那样的话，这种情况永远不会发生。</p><p id="33f9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">搜索我们代码中的潜在问题，然后我们发现了一些危险的代码。</p><p id="f705" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了更简单，代码看起来更像这个<br/> * ps:这个函数只是一个例子，但在模式上与我们的相似</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">our code before fixed</figcaption></figure><p id="025f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们看上面的代码，它就像没有错。但是这个函数是我们<code class="fe mn mo mp mq b">main API</code>中被访问次数最多、调用次数最多的函数。因为这个函数会做3个API调用，处理量很大。</p><p id="fa20" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了改善这一点，我们提出了一种新的方法，在通道上使用超时控制。因为使用上面的样式代码——使用<code class="fe mn mo mp mq b">WaitGroup</code>会等到所有的过程都完成——我们必须等待所有的API调用都完成，这样我们才能处理并向用户返回响应。</p><p id="7b52" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是我们的一个大错误。当我们的一个服务终止时，这个代码会造成巨大的灾难。因为要等到死掉的服务恢复过来会有很长的等待。用5K通话/秒，当然这是灾难。</p><p id="b97e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">第一次尝试解决方案:</strong></p><p id="32b4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们通过添加超时来修改它。所以我们的用户不会等太久，他们只会得到一个内部服务器错误。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">trying to add timeout</figcaption></figure><h1 id="3054" class="ms lq in bd lr mt mu mv lu mw mx my lx jt mz ju ma jw na jx md jz nb ka mg nc bi translated">阶段4:使用上下文的超时控制</h1><p id="c652" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">在做了<strong class="ku io">第三阶段之后，</strong>我们的问题仍然没有完全解决。我们的<code class="fe mn mo mp mq b"> main API</code>还是很消耗CPU和内存的。</p><p id="de14" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是因为，即使我们已经把<code class="fe mn mo mp mq b">Internal Server Error</code>还给我们的用户，但是我们的goroutine仍然存在。我们想要的是，如果我们已经返回了响应，那么所有的资源也被清除，没有例外，包括在后台运行的goroutine和API调用。</p><p id="bc63" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">后来看完这篇文章:<br/><a class="ae lo" href="http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/" rel="noopener ugc nofollow" target="_blank">http://daher nan . github . io/2015/02/04/context-and-cancellation-of-goroutines/</a></p><p id="5156" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们在golang中发现了一些我们还没有意识到的有趣特征。在围棋程序中使用<code class="fe mn mo mp mq b">Context</code>帮助取消。</p><p id="d1f8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们没有使用<code class="fe mn mo mp mq b">time.After</code>来使用超时，而是转移到<code class="fe mn mo mp mq b">context.Context</code>。有了这种新方法，我们的服务更加可靠。</p><p id="d718" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后，我们通过向相关函数添加上下文来再次改变我们的代码结构。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">final fixed code. using context</figcaption></figure><p id="7cff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以我们在代码中对每个goroutine调用使用<code class="fe mn mo mp mq b">Context</code>。这有助于我们释放内存并取消goroutine调用。</p><p id="9c60" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">此外，为了更加可控和可靠，我们还将上下文传递给我们的HTTP请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">using context on HTTP request</figcaption></figure><p id="4da8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了所有这些设置和超时控制，我们的系统更加安全和可控。</p><h2 id="ad71" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">吸取的教训:</h2><ul class=""><li id="7edc" class="nq nr in ku b kv mi ky mj lb ns lf nt lj nu ln nv nw nx ny bi translated">从未在生产中使用默认选项。<br/>只是从来没有使用过默认选项。如果您正在构建一个大的并发A，就不要使用默认选项。</li><li id="fbeb" class="nq nr in ku b kv nz ky oa lb ob lf oc lj od ln nv nw nx ny bi translated">读了很多，尝试了很多，失败了很多，收获了很多。<br/>我们从这次经历中学到了很多，这种经历只有在真实的案例和真实的用户中才能获得。我很高兴能参与修复这个bug。</li></ul><p id="a69b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">* <em class="oe">最后更新时间:2018年1月18日:修复部分错别字</em></p></div><div class="ab cl of og hr oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ig ih ii ij ik"><p id="3abe" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你认为这本书值得一读，给我一个👏<br/>也在你的twitter、facebook等网站上分享，这样其他人也可以阅读。如果你有什么问题，你可以在下面回复或者发邮件给我。</p></div></div>    
</body>
</html>