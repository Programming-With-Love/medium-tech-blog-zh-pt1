<html>
<head>
<title>Building a Conference Session Recommendation engine using Neo4J Graph Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Neo4J图形数据库构建会议会话推荐引擎</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/building-a-conference-session-recommendation-engine-using-neo4j-graph-database-2365b3b80ad9?source=collection_archive---------0-----------------------#2018-11-19">https://medium.com/oracledevs/building-a-conference-session-recommendation-engine-using-neo4j-graph-database-2365b3b80ad9?source=collection_archive---------0-----------------------#2018-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d6c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文描述了一个用例，对于这个用例，传统的基于SQL的关系数据库方法可以提供一个解决方案——但是对于这个用例，传统的方法不是最佳的解决方案。SQL是万能的——你几乎可以让它做任何你需要的事情。因此很容易成为你的锤子，每一个挑战都是钉子。如果说这篇文章有什么意义的话，那就是让我(也许还有你)认识到，有一些技术可以补充我们工具箱中的SQL hammer。在这种特殊情况下，补充工具是图形数据库，更具体地说是Neo4J。</p><p id="d195" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的同事Rosanna Denis最近在我们的AMIS技术博客上发表了这篇文章，这是对Neo4J的第一次很好的介绍。您可能想查看一下Neo4J的一些背景知识。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3c431adb874a981483242f2d08113572.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*mZT1P45xqWoo8D2d.png"/></div></figure><p id="ede1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里讨论的挑战是Code One会话推荐引擎。CodeOne之类的会议有很多环节可以选择。选择最佳会议是一个真正的挑战。我的时间很宝贵——我如何确保自己不会浪费在口齿不清或缺乏灵感的演讲者的会议上？</p><p id="33ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想要的是一个引擎，它会向我推荐与我参加相同会议的人喜欢的演讲者的会议。当然，如果人们来参加我参加的会议，那么他们对他们喜欢的演讲者的推荐对我来说一定是有价值的。</p><p id="302a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面我将创建这个建议的两个实现。一个基于关系和SQL，另一个使用Graph DB和Cypher(Neo4J查询和数据操作语言)。</p><p id="df69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文的所有代码都在GitHub上:<a class="ae jc" href="https://github.com/lucasjellema/conference-recommendation-engine-in-graphdb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/conference-re commendation-engine-in-graphdb</a>。</p><h1 id="d7e9" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">举一个例子——关系和SQL</h1><p id="6733" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">我设计的关系数据模型看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ko"><img src="../Images/d2f795419315f7dece7d42cdba1e7707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RWnNzNaQY9gUsQJT.png"/></div></div></figure><p id="077c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我必须考虑到这样的事实，即与会者将参加多个会议，会议有多个与会者，发言者可以介绍多个会议，一个会议可以有多个发言者。此外，人们可以喜欢不止一个说话者，同样，一个说话者可以被多个人喜欢。</p><p id="2322" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GitHub repo包含带有表创建DDL和数据创建DML的源文件。两者都很简单。</p><p id="caad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将为<em class="kt">创建的SQL查询从我和我参加的会议开始，然后定位这些会议中的其他与会者，接下来找到他们喜欢的发言人，最后检索这些发言人介绍的会议</em>如下所示:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="a181" class="kz jm hh kv b fi la lb l lc ld">select s.code</span><span id="a4bb" class="kz jm hh kv b fi le lb l lc ld">,      s.title</span><span id="390d" class="kz jm hh kv b fi le lb l lc ld">,      a2.attendee_name "suggested by"</span><span id="1d86" class="kz jm hh kv b fi le lb l lc ld">from   people p1</span><span id="d096" class="kz jm hh kv b fi le lb l lc ld">join</span><span id="64c9" class="kz jm hh kv b fi le lb l lc ld">attendance a1</span><span id="15e2" class="kz jm hh kv b fi le lb l lc ld">on (p1.name = a1.attendee_name)</span><span id="c5bd" class="kz jm hh kv b fi le lb l lc ld">join attendance a2</span><span id="bf47" class="kz jm hh kv b fi le lb l lc ld">on (a2.session_code = a1.session_code)</span><span id="5aa9" class="kz jm hh kv b fi le lb l lc ld">join speaker_liking sl</span><span id="4373" class="kz jm hh kv b fi le lb l lc ld">on (sl.attendee_name = a2.attendee_name)</span><span id="852e" class="kz jm hh kv b fi le lb l lc ld">join speakers sp</span><span id="9ab5" class="kz jm hh kv b fi le lb l lc ld">on (sl.speaker_name = sp.speaker_name)</span><span id="82c2" class="kz jm hh kv b fi le lb l lc ld">join sessions s</span><span id="398b" class="kz jm hh kv b fi le lb l lc ld">on (sp.session_code = s.code)</span><span id="1809" class="kz jm hh kv b fi le lb l lc ld">where  p1.name = 'Lucas Jellema'</span></pre><p id="6c88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此查询的结果(在SQL Developer中):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lf"><img src="../Images/a4ca1362a47a0cde7c6a48b619c24ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FwXtMDPWBnj5RDTN.png"/></div></div></figure><p id="3be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我走了一些捷径，但这个查询还是有点冗长。在SQL中，这种特殊的搜索挑战严重依赖于对象之间的关系，最终使用许多表连接来找到正确的答案。这不一定是一件坏事——这只是关系数据库和SQL的方式。然而，我们最终得到的查询不是很直观，因此也不太容易维护。此外，对于真正的大数据集，这种方法在性能方面可能无法很好地扩展。我们或许可以采用智能索引策略来扩展这种方法的性能。但是我们很可能在某个阶段达到极限。</p><p id="9ede" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以让我们考虑另一种方法。</p><h1 id="ea4a" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">取两个图形数据库(Neo4J和Cypher)</h1><p id="99be" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">图形数据库对数据有非常不同的看法。存储在图形数据库中的数据和针对图形数据库执行的查询由对象之间的关系驱动，或者由图形中顶点之间的边驱动。图形数据库可以很好地用于特定的查询用例，这些查询用例需要基于这些关系的非常丰富、可伸缩和性能良好的数据访问路径。它们通常会补充关系数据库，但不一定会取代它。</p><p id="b3e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Neo4J是一个流行的图形数据库，因此显然是我在本文中演示的对象。</p><p id="c235" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了开始，我按照Rosanna在她的<a class="ae jc" href="https://technology.amis.nl/2018/11/16/querying-connected-data-in-graph-databases-with-neo4j/" rel="noopener ugc nofollow" target="_blank">文章</a>中提供的说明进行了工作。在带有Docker引擎的Linux虚拟机上工作，我需要做的就是:</p><p id="fe5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建目录</p><p id="e425" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">mkdir ~/neo4j mkdir ~/neo4j/data</p><p id="1c4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">mkdir ~/neo4j/logs</p><p id="4a88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后运行:</p><p id="bdfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">docker run–publish = 7474:7474–publish = 7687:7687–volume = $ HOME/neo4j/data:/data–volume = $ HOME/neo4j/logs:/logs neo4j:3.0</p><p id="ca21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在通过浏览器7474端口访问Neo4J，例如:<a class="ae jc" href="http://192.168.188.120:7474/" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 188 . 120:7474</a></p><p id="12c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Neo4J的Cypher语言，我在我的图中创建了顶点和边(查看<a class="ae jc" href="https://github.com/lucasjellema/conference-recommendation-engine-in-graphdb/blob/master/neo4j_ddl_and_dml.txt" rel="noopener ugc nofollow" target="_blank">这个文件</a>中所有的数据操作语句):</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="246a" class="kz jm hh kv b fi la lb l lc ld">CREATE (lucas:Person{name:'Lucas Jellema'}) – [:PRESENTS] -&gt;(session:Session {title:'50 Shades of Data: How, When, Why—Big, Relational, NoSQL, Elastic, Graph, Event', code:'DEV4976'})<br/>CREATE (daniel:Person{name:'Daniel Bryant'}) – [:PRESENTS] -&gt;(session:Session {title:'Continuous Delivery with Containers and Java: Lessons Learned and Mistakes Made', code:'DEV5349'})<br/>CREATE (luis:Person{name:'Luis Weir'}) – [:PRESENTS] -&gt;(session:Session {title:'The Seven Deadly Sins of API Design', code:'DEV4921'})<br/>MERGE (daniel:Person{name:'Daniel Bryant'}) CREATE (daniel) - [:PRESENTS] -&gt; (session:Session{title:'AdoptOpenJDK: Lessons Learned from the New Build Farm for Java Itself', code:'TUT5283'})<br/>CREATE (adam:Person{name:'Adam Farley'}) <br/>MATCH (adam:Person {name:'Adam Farley'}), ((session:Session {code:'TUT5283'})) MERGE (adam)-[:PRESENTS]-&gt; (session)<br/>CREATE (session:Session{title:'Oracle Cloud Soaring: Live Demo of a Poly-Cloud Microservices Implementation ', code:'DEV4979'}) <br/><br/>MATCH (luis:Person {name:'Luis Weir'}), ((session:Session {code:'DEV4854'})) MERGE (luis)-[:ATTENDS]-&gt; (session)<br/>MATCH (lucas:Person {name:'Lucas Jellema'}), ((session:Session {code:'DEV4854'})) MERGE (lucas)-[:ATTENDS]-&gt; (session)</span><span id="0d4f" class="kz jm hh kv b fi le lb l lc ld">//Luis likes Daniel Bryant as a speaker<br/>MATCH (luis:Person {name:'Luis Weir'}), ((daniel:Person {name:'Daniel Bryant'})) MERGE (luis)-[:VALUES]-&gt; (daniel)</span></pre><p id="dd81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这导致了下面的图形表示(粉红色的会话和蓝色的人员):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/7527f350844a39c8fb9cff8e454b2df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*meMfCb17cfMDFUx2.png"/></div></figure><p id="5c88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这个图，我就可以创建提供会话建议的查询了。在Cypher中，我可以非常接近描述我的查询的自然语言:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lh"><img src="../Images/e4893d060edc8406ce812f45ac518375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uyhXunIK4oxbO81p.png"/></div></div></figure><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="ddc4" class="kz jm hh kv b fi la lb l lc ld">// now the hunt is on <br/>//find me and the sessions I attended <br/>match (lucas:Person {name:'Lucas Jellema'}) - [:ATTENDS] -&gt; (s1) RETURN s1</span><span id="2550" class="kz jm hh kv b fi le lb l lc ld">// find people who attended the same sessions as ME<br/>match (lucas:Person {name:'Lucas Jellema'}) - [:ATTENDS] -&gt; (s1) &lt;- [:ATTENDS] - (p2) RETURN p2</span><span id="918e" class="kz jm hh kv b fi le lb l lc ld">// find presenters valued by the people who attended the same sessions as I did:<br/>match (lucas:Person {name:'Lucas Jellema'}) - [:ATTENDS] -&gt; (s1) &lt;- [:ATTENDS] - (p2) - [:VALUES] -&gt; (p3) RETURN p3</span><span id="e4e6" class="kz jm hh kv b fi le lb l lc ld">// find sessions presented by presenters valued by the people who attended the same sessions as I did:<br/>match (lucas:Person {name:'Lucas Jellema'}) - [:ATTENDS] -&gt; (session1) <br/>  &lt;- [:ATTENDS] - (recommender) - [:VALUES] -&gt; (speaker) - [:PRESENTS] -&gt; (session) RETURN session, speaker.name, recommender.name</span></pre><p id="6c50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从我开始(Person类型的顶点，属性名等于Lucas Jellema)，遍历我参加的所有会话。对于这些会议，导航到所有与会者(让我们称他们为推荐者)，并找到他们重视的所有发言人。遍历所有这些演讲者的演示边缘，以获取他们演示的会话。返回这些会话，以及发言者的姓名和推荐者的姓名。</p><p id="f0d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">毫不奇怪，我得到了想要的结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lh"><img src="../Images/ebb236d44195f494f91da7230de29bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-apW3vlrGgxjsG7Z.png"/></div></div></figure><h1 id="ff13" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">比较</h1><p id="6799" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">这两个查询可以并排比较。很明显哪个更短。在稍微习惯了Cypher语法之后，我敢说较短的语法将被证明是更直观和更容易维护的语法。我没有专门测试性能；然而，种种迹象表明，Graph DB方法对于这个用例来说性能(明显)更好，尽管SQL性能对于这个用例来说可能已经足够好了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es li"><img src="../Images/f6973a17a281c2ed0ebf90d960a1b8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3tlHxBeEczQETngt.png"/></div></div></figure><p id="2c21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Neo4J中的数据操作肯定是不同的——没有预先定义固定的表结构，元数据是在数据创建时获得的。对于一个小的演示系统来说，这很好，也很方便。对于更严肃的应用程序，这几乎没有关系。所有的软件都依赖于特定的数据结构，所以仍然非常需要严格的元数据管理。</p><p id="eaa3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我喜欢在我的工具箱中有图形数据库的想法，作为一种工具，它可以帮助我处理查询挑战，在传统的关系方法中，这些挑战可能会让我非常头疼。随之而来的有趣挑战当然是如何将数据变更从关系主数据库复制到Graph DB query only存储。我们称之为CQRS。我们会再次讨论这个问题。</p><p id="1c22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:在Graph DB的顶部找出Cypher中的查询应该是什么非常有趣！这就像重新发现SQL一样。</p><h1 id="eedd" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">资源</h1><p id="c405" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">本文源代码:<a class="ae jc" href="https://github.com/lucasjellema/conference-recommendation-engine-in-graphdb" rel="noopener ugc nofollow" target="_blank">https://github . com/lucasjellema/conference-re commendation-engine-in-graphdb</a></p><p id="fbf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自我的50个数据色度演示文稿的幻灯片:<a class="ae jc" href="https://www.slideshare.net/lucasjellema/50-shades-of-data-how-when-and-why-bigrelationalnosqlelasticgraphevent-codeone-2018-san-francisco" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/lucasjellema/50-Shades-of-Data-how-when-and-why-bigreelationalnosqleelasticgrapevent-code one-2018-旧金山</a> <br/>(或者观看来自CodeOne 2018的YouTube录制:<a class="ae jc" href="https://www.youtube.com/watch?v=S2wEDlKzVok" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=S2wEDlKzVok</a>)</p><p id="ad9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的同事Rosanna Denis最近在我们的AMIS技术博客上发表了这篇文章，这是对Neo4J的第一次很好的介绍。您可能想查看一下Neo4J的一些背景知识。</p><p id="381e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://technology.amis.nl/tag/graph-database/" rel="noopener ugc nofollow" target="_blank">图形数据库</a><a class="ae jc" href="https://technology.amis.nl/tag/graphdb/" rel="noopener ugc nofollow" target="_blank">graphdb</a><a class="ae jc" href="https://technology.amis.nl/tag/neo4j/" rel="noopener ugc nofollow" target="_blank">Neo4j</a><a class="ae jc" href="https://technology.amis.nl/tag/nosql/" rel="noopener ugc nofollow" target="_blank">no SQL</a><a class="ae jc" href="https://technology.amis.nl/tag/relational/" rel="noopener ugc nofollow" target="_blank">关系型</a> <a class="ae jc" href="https://technology.amis.nl/tag/sql/" rel="noopener ugc nofollow" target="_blank"> sql </a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/7af32578a09d9a38b8b0149afbaf56a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/0*FjWLc6vdvLOSvAWg"/></div></figure><p id="64c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kt">原载于2018年11月19日</em><a class="ae jc" href="https://technology.amis.nl/2018/11/20/building-a-conference-session-recommendation-engine-using-neo4j-graph-database/" rel="noopener ugc nofollow" target="_blank"><em class="kt">technology . amis . nl</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>