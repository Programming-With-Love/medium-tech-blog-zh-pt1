<html>
<head>
<title>Misnomers, Mistakes and Misunderstandings to watch for when learning Kotlin Coroutines and Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Kotlin协程和流程时要注意的用词不当、错误和误解</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/misnomers-mistakes-and-misunderstandings-to-watch-for-when-learning-kotlin-coroutines-and-flow-2744186be3e?source=collection_archive---------2-----------------------#2021-03-10">https://medium.com/google-developer-experts/misnomers-mistakes-and-misunderstandings-to-watch-for-when-learning-kotlin-coroutines-and-flow-2744186be3e?source=collection_archive---------2-----------------------#2021-03-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="7720" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">当我在几个不同的项目(包括我自己的项目)中学习使用协程和流时，我注意到一些常见的反模式，这些反模式往往是在处理结构化并发和反应式流时出现的。在本文中，我将概述如何识别和重构四种最常见的情况。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/f237f25e572f6ca53e9222fa7881c732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiaL58lQdsOjXdL_CERd0g.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><strong class="bd jm">Keep your eyes open! A Tarsier I met near Bitung, Sulawesi</strong></figcaption></figure><h1 id="3d4a" class="jn jo hh bd jm jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">1.使用流而不是挂起函数</h1><p id="bd82" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">当设计你的方法和函数时，从一个暂停函数开始，如果你卡住了，把它改成一个流程。</p><p id="38bc" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">考虑调用RESTful API的典型函数签名。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="a160" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">这样的函数在从RxJava迁移过来的项目中尤其常见，在RxJava中我们有一个<code class="du lh li lj lk b">Single</code>的概念</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="de38" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">一个<code class="du lh li lj lk b">Single</code>意味着你期望从你的流中接收一个<em class="ll">单个</em>事件，而不是<em class="ll">多个</em>。一个<em class="ll">单个</em>事件...听起来不像是“溪流”，对吧？更像一滴而不是一条小溪。这就是为什么<code class="du lh li lj lk b">Single</code>在Flow中不是作为一个显式类型存在，而是作为一个操作符:<a class="ae lm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html" rel="noopener ugc nofollow" target="_blank"> Flow.single() </a>。</p><p id="5dfe" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">但是不要使用运算符！只有在出于某种原因需要合并或组合流时，它才是有用的…没有必要把事情复杂化——如果您期待的是单个事件——只需返回它！</p><p id="2f5c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">挂起函数应该是您开箱即用的第一个工具，这主要是因为它是制作可读代码的正确选择，还因为如果您以后还想试验一个流，它可以很容易地重构为一个流:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="554c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">你要问自己的关键问题是——我期待的是一件事(暂停功能)还是许多事(流)？</p><h1 id="2fbe" class="jn jo hh bd jm jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">2.用回调参数挂起函数</h1><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9ce7" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">挂起函数是回调的直接替代——它是结构化并发的基本前提之一。回调使得代码难以理解(例如它们让你的代码<em class="ll">变得无结构</em>。这方面的经典例子是<a class="ae lm" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>或<a class="ae lm" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>。协程(在Kotlin中主要表示为suspend函数)旨在清理这类代码——不再需要回调:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5ad1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">下面是一个具有多个回调的更复杂的例子:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c10f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">你如何把它转换成一个挂起函数？如果你仔细观察，你会发现只有一个回调会被调用，这取决于调用成功与否。在过去的Java时代，我们会创建一个<code class="du lh li lj lk b">Listener</code>接口并发送一个内联实现。奇怪的是，Kotlin/Coroutine解决方案与它有相似的感觉，尽管它在技术上非常不同:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9cdc" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">但是，如果我们正在下载一个大文件，并希望取得进展呢？</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="cfed" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">现在我们期待<em class="ll">多个</em>调用，所以我们需要重构一个流程:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Notice that if we are returning a Flow, we no longer need the <code class="du lh li lj lk b">suspend</code> attribute</figcaption></figure><p id="b483" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">如果您对上述函数的实现感兴趣，请查看我的关于将回调转换为流的文章。</p><h1 id="6983" class="jn jo hh bd jm jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">3.使用全球范围</h1><p id="0390" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">这个<a class="ae lm" href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank"> Kotlin的协程文档</a>明确警告不要使用<code class="du lh li lj lk b">GlobalScope</code>。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c97a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><code class="du lh li lj lk b">Activity</code>、<code class="du lh li lj lk b">Fragment</code>、<code class="du lh li lj lk b">ViewModel</code>、<code class="du lh li lj lk b">View</code>...它们都有相应的<a class="ae lm" href="https://developer.android.com/kotlin/ktx#lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期扩展</a>，您应该使用它们来启动协程。使用这些扩展来自由启动并经常启动，因为协程不像线程一样<a class="ae lm" href="https://developer.android.com/kotlin/coroutines#features" rel="noopener ugc nofollow" target="_blank">便宜且轻量级</a>。您可以<a class="ae lm" href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank">启动数以千计的协程</a>,开销可以忽略不计——重要的是将协程绑定到一个生命周期，以避免内存泄漏。</p><h1 id="92a5" class="jn jo hh bd jm jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">4.不必要的调度</h1><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b4ed" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">如果你确实需要跳转到另一个线程，尽可能在最近的时候做。使用协程很容易在线程之间来回切换，但是除非万不得已，否则不要编写防御性代码。大多数支持协程的现代IO库会在内部处理这种编组，所以你甚至不需要思考，除非你自己去敲打金属。</p><p id="2d99" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">除了清洁之外，好处还在于测试。一旦您开始与Dispatchers打交道，您就必须开始<a class="ae lm" href="https://craigrussell.io/2019/11/unit-testing-coroutine-suspend-functions-using-testcoroutinedispatcher/" rel="noopener ugc nofollow" target="_blank">注入DispatcherProvider </a>以便您可以正确地进行单元测试。这很聪明，但是仍然有不必要的额外开销。</p><p id="d64a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">习惯于在RxJava上处理线程的团队会纠结于这个概念，并且在从RxJava迁移到Flow时经常会编写非常防御性的代码:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="385b" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">RxJava和普通回调一样，不能保证哪个线程被回调——所以你必须有所防备，明确地将回调闭包封送到主线程。这是<em class="ll">结构化并发</em>背后的另一个目标，在Kotlin中通过<a class="ae lm" href="https://elizarov.medium.com/execution-context-of-kotlin-flows-b8c151c9309b" rel="noopener">上下文保持</a>来解决。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="355f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">希望这些片段能帮助你避免常见的反模式，让你的代码保持干净。</p></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="401a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">ta<a class="lu lv ge" href="https://medium.com/u/f08187f6a023?source=post_page-----2744186be3e--------------------------------" rel="noopener" target="_blank">Enrique lópez-Maas</a>和<a class="lu lv ge" href="https://medium.com/u/f85aa4d26d12?source=post_page-----2744186be3e--------------------------------" rel="noopener" target="_blank"> Panini </a>进行校对。热爱你的工作。</p></div></div>    
</body>
</html>