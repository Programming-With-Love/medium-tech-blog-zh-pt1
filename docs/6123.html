<html>
<head>
<title>Introducing Plank: Immutable model generation for iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Plank:面向iOS的不可变模型生成</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/introducing-plank-immutable-model-generation-for-ios-4b2f64bda00c?source=collection_archive---------2-----------------------#2017-03-17">https://medium.com/pinterest-engineering/introducing-plank-immutable-model-generation-for-ios-4b2f64bda00c?source=collection_archive---------2-----------------------#2017-03-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Rahul Malik | Pinterest技术主管，iOS核心体验</p><p id="28c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">去年，我们的iOS团队<a class="ae jc" rel="noopener" href="/@Pinterest_Engineering/re-architecting-pinterest-039-s-ios-app-e0a2d34a6ac2#.qodvqwle1">对我们整个应用的架构</a>进行了彻底检查。这是一项巨大的努力，它让开发者迭代更快，更容易扩展，并让全世界的Pinners快了3倍。我们的新系统非常依赖于并发性。UI渲染、图像下载、GIF解码和网络响应处理只是利用多线程提升性能的几个方面。这意味着这些组件使用的对象必须是线程安全的，以避免错误和潜在的崩溃。由于模型对象在我们应用程序的几乎所有组件中传递，所以我们的模型层可以安全地跨线程使用是很重要的。</p><p id="f857" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我们转移到了一个<a class="ae jc" rel="noopener" href="/@Pinterest_Engineering/immutable-models-and-data-consistency-in-our-ios-app-d10e248bfef8#.jf1rib7oz">不可变模型层</a>。不可变对象与可变对象的不同之处在于，它们一旦被创建就不能被修改，这使得它们本质上是线程安全的。这允许开发人员编写更容易推理的代码，因为不变量一旦建立就不能改变。今天<a class="ae jc" href="https://pinterest.github.io/plank/" rel="noopener ugc nofollow" target="_blank">我们开源了Plank，</a>一个不可变的iOS模型生成器来实现这个目标。<a class="ae jc" href="https://pinterest.github.io/plank/" rel="noopener ugc nofollow" target="_blank"> Plank </a>是一个用Swift编写的命令行工具，可以生成不可变的Objective-C模型。在这篇文章中，我们将重点介绍它的一些主要功能和创建动机。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2ae6e983f7ae8f5bfae68133585d86e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bgfy3LbWkhMWOR2SYTlzPQ.png"/></div></div></figure><h1 id="564e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">动机</h1><p id="fd4d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">设计和维护一个模型层可能是乏味且容易出错的。缺少简单的空检查或试图序列化包含无法序列化的属性的对象会导致未定义的行为和崩溃。手写的模型在实现中也会遇到不一致的问题，并且在序列化时会导致不同的行为和策略。</p><p id="022c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有几个由于手写模型中的问题而导致的常见错误和崩溃的例子。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="d97f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们开始构建我们的不可变模型层时，我们正在着手一个新的领域。我们中的一些人熟悉不变性的好处，但是没有构建不可变对象的经验。</p><p id="922b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们的应用程序模式中有数百种类型的模型，那么模型设计中的任何错误，比如添加一个类似序列化的新功能，都可能是很难修复的。当您考虑处理JSON解析、序列化、等式和其他常见操作的更新方法时，即使是为模型类型添加新字段这样简单的任务也很容易出错，而且很乏味。</p><p id="da34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们将模型严格定义为一组值的表示，那么像合并和序列化这样的特性就可以从该模式中派生出来。这意味着我们的模型代码是完全可预测的，所以我们选择生成它们。</p><h1 id="0323" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">目标</h1><p id="1a1f" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">开始时，我们对生成的代码有几个主要目标:</p><ul class=""><li id="ef1f" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated"><strong class="ig hi">不可变:</strong>模型类将根据不变性作为一个需求来生成。每个类都有一个“生成器”类来处理变异。</li><li id="e827" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated"><strong class="ig hi">类型安全:</strong>基于模式定义中指定的类型信息，每个类将提供类型验证和空引用检查，以确保模型的完整性。</li><li id="f3f1" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated"><strong class="ig hi">模式定义的:</strong>模型类型应该以一种独立于语言的格式定义，这种格式易于扩展并且广为人知。</li></ul><h1 id="da18" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">政纲条目</h1><p id="9fa6" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Plank模式基于<a class="ae jc" href="http://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>，这是一个定义良好、可扩展且独立于语言的规范。在JSON中定义模式使我们能够避免编写不必要的解析器代码，并为从服务器上使用的相同类型的系统中生成代码提供了可能性。</p><p id="8a26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于编译器，我们将这些JSON模式转换成一个中间表示(IR)，我们称之为“模式IR”一旦我们有了模式IR，我们就把它翻译成一个目标-C IR。这个额外的IR级别很重要，因为虽然Plank现在生成Objective-C代码，但它是为将来支持更多语言而设计的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/b94633469f1a1bfe15dd987fe720a50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1oQlqZGFq14C_eVn."/></div></div></figure><h1 id="2967" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">通过Plank生成模型</h1><p id="8c51" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">让我们用这些字段创建一个表示Pin的模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/b155768430cc104f6e00802127a558c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNYAzvweQI7HsZwz6SRfsg.png"/></div></div></figure><h1 id="5611" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">定义模式</h1><p id="1dea" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Plank接受一个模式文件作为输入，所以我们需要创建一个。这是我们的Pin类型的模式。您会注意到我们指定了模型的名称及其属性列表。注意，link指定了一个附加的<code class="du lk ll lm ln b">format</code>属性，告诉Plank使用一个更具体的类型，比如<code class="du lk ll lm ln b">NSURL</code>或<code class="du lk ll lm ln b">NSDate</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/605c3855eefa88541c9176a3918f5c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7p7ZAQO2d0XJAlEfuWcddQ.png"/></div></div></figure><h1 id="6129" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">生成模型</h1><p id="0d48" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">假设这个模式被保存为<code class="du lk ll lm ln b">pin.json</code>，我们通过运行<code class="du lk ll lm ln b">plank</code> <code class="du lk ll lm ln b">pin.json</code>来生成我们的模型。下面我们将重点介绍Plank从您的模式中生成的一些功能。</p><pre class="je jf jg jh fd lp ln lq lr aw ls bi"><span id="87b8" class="lt jq hh ln b fi lu lv l lw lx">$ plank pin.json</span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">The Pin class interface created by Plank</figcaption></figure><p id="adf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到的第一件事是所有属性都是<code class="du lk ll lm ln b">readonly</code>。这使得该类成为不可变的，但是它并不真正有用，因为我们没有办法用任何值来填充<code class="du lk ll lm ln b">Pin</code>的实例。为了解决这个问题，我们需要一个抽象，它接受一组值并产生一个不可变的对象。</p><h1 id="a06a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">突变和建设者</h1><p id="bc63" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Plank生成的模型中的变异是通过一个构建器类执行的。这是<a class="ae jc" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>的直接实现，Plank将为您生成它。builder类是一个单独的类型，它包含了<code class="du lk ll lm ln b">readwrite</code>属性和一个<code class="du lk ll lm ln b">build</code>方法，该方法将创建一个新的对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="92e5" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JSON解析</h1><p id="e00d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">现在我们有了一个不可变的模型和一个生成器类来创建新的实例。然而，大多数应用程序并不是静态的，而是依赖于从API返回的JSON数据。下面是我们的Pin模型的JSON响应示例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5c38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了正确处理这个响应，我们不仅需要断言响应类型是正确的，还需要添加额外的逻辑来将链接表示为<code class="du lk ll lm ln b">NSURL</code>的一个实例。小心处理<code class="du lk ll lm ln b">null</code>值也很重要，以避免将属性设置为<code class="du lk ll lm ln b">NSNull</code>的值或将<code class="du lk ll lm ln b">null</code>传递给需要<code class="du lk ll lm ln b">nonnull</code>参数的API。这些错误会导致不可预测的行为和崩溃。</p><p id="d9be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Plank将创建一个名为<code class="du lk ll lm ln b">initWithModelDictionary</code>的初始化方法，用于解析符合您的模式的<code class="du lk ll lm ln b">NSDictionary</code>对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="4d41" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">序列化</h1><p id="30a3" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">如果您想要为您的应用程序构建离线支持或者在应用程序启动时持久化数据，您需要将模型存储到磁盘。iOS上最传统的方式是在每个模型上实现<code class="du lk ll lm ln b">NSSecureCoding</code>。在Pinterest，我们使用<a class="ae jc" href="https://github.com/pinterest/PINCache" rel="noopener ugc nofollow" target="_blank"> PINCache </a>作为冗余的直写模式缓存，它也通过<code class="du lk ll lm ln b">NSSecureCoding</code>管理持久性。</p><p id="34e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Plank为您生成了<code class="du lk ll lm ln b">NSSecureCoding</code>实现。因为所有本机类型都已经是可序列化的，所以您可以免费获得这一功能。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="c7b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过这种实现，使用<code class="du lk ll lm ln b">NSKeyedArchiver</code>对对象进行序列化</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="a1c6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型合并和部分对象具体化</h1><p id="6221" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">如果你的团队决定采用一个新奇的后端API，允许消费者精确地指定他们需要的字段，类似于<a class="ae jc" href="https://developers.pinterest.com/docs/api/overview/" rel="noopener ugc nofollow" target="_blank"> Pinterest开发者API </a>或<a class="ae jc" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，我们之前请求的Pin现在可能只返回<code class="du lk ll lm ln b">identifier</code>或<code class="du lk ll lm ln b">link</code>或两者！Pinterest中的一个例子是，当你点击一个大头针，我们就会加载更多信息。</p><p id="f7ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们必须考虑几个因素:</p><ul class=""><li id="054e" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">如果您有Pin并收到包含更多信息的更新版本，您如何知道要更新哪些属性？</li><li id="0d6e" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">如果一个属性是<code class="du lk ll lm ln b">nil</code>，如何检测该属性是否被设置过，而不是有一个值<code class="du lk ll lm ln b">nil</code>？</li><li id="4c8b" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">更新Pin后，我们如何在整个应用程序中传播该信息？</li></ul><p id="bbbe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Plank使用传统的“最后写入者获胜”方法来解决一致性问题，方法是保留该实体的最近实例中的属性集。我们使用<code class="du lk ll lm ln b">identifier</code>值作为主键，用来确定两个对象是否代表同一个实体。为了知道设置了哪些属性，我们在初始化期间或通过任何变异方法在模型本身内部跟踪这些信息。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="959b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于不可变模型，您必须考虑数据如何流经您的应用程序，以及如何保持一致的状态。在每个模型类初始化器的末尾，有一个更新模型的通知。这对于与您的<a class="ae jc" rel="noopener" href="/@Pinterest_Engineering/immutable-models-and-data-consistency-in-our-ios-app-d10e248bfef8#.d1solh378">数据一致性框架</a>集成非常有用。有了它，我们就可以跟踪模型的更新，并且可以使用内部跟踪来合并新的模型。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="57fc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">代数数据类型</h1><p id="ca4a" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">随着应用程序变得越来越复杂，数据模型也会变得越来越复杂。您可能会发现自己需要对一个属性进行建模，这个属性可能是一组类型中的一个特殊变体，这些类型通常被称为代数数据类型(ADT)。</p><p id="2dd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，我们会显示一个Pin的原因或属性，告诉用户他们为什么会看到它。这可能是因为它来自他们关注的另一个Pinner或董事会，也可能是基于他们兴趣的推荐。</p><p id="0e81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们更新我们的Pin模式，使其具有一个<code class="du lk ll lm ln b">attribution</code>属性，该属性可以是<code class="du lk ll lm ln b">User</code>、<code class="du lk ll lm ln b">Board</code>或<code class="du lk ll lm ln b">Interest</code>。假设我们在文件<code class="du lk ll lm ln b">user.json</code>、<code class="du lk ll lm ln b">board.json</code>和<code class="du lk ll lm ln b">interest.json</code>中分别定义了单独的模式。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Representing Algebraic Data Types with Plank</figcaption></figure><p id="41e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Plank采用了这个<code class="du lk ll lm ln b">attribution</code>的定义，并创建了必要的样板代码来处理每种可能性。它还通过生成一个新的类来表示您的ADT，从而提供了额外的类型安全。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Implicitly generated ADT class for the “attribution” property</figcaption></figure><p id="9f54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意在头中声明了一个“匹配”函数。这就是提取ADT实例的真正潜在价值的方式。这种方法保证在编译时您已经显式地处理了每一种可能的情况，防止了错误并减少了对使用运行时反射的需求，运行时反射会降低性能。下面的例子展示了如何使用这个匹配函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="ee93" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">迅速发生的</h1><p id="7cbb" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Plank是在Swift中从头开始构建的，Swift是完成这项任务的理想语言，因为它具有强大的类型安全特性和优雅的语法。我们利用递归枚举来定义模式的所有排列。此外，尾随闭包和内联字符串插值被用来为生成代码创建一个优雅的DSL。</p><p id="51fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我们如何利用Swift的语言功能创建DSL来表达生成的Objective-C switch语句的一个例子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="28ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一个使用我们刚刚创建的<code class="du lk ll lm ln b">switch</code>语句DSL的例子。假设我们有一个变量<code class="du lk ll lm ln b">dayOfWeek</code>，它是一个从1到7的整数，分别代表周一到周日。如果<code class="du lk ll lm ln b">dayOfWeek</code>是周末，可以生成下面的switch语句。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="859c" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">建立强大的核心</h1><p id="f9fd" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated"><a class="ae jc" href="https://pinterest.github.io/plank/" rel="noopener ugc nofollow" target="_blank"> Plank </a>是构建和缩放不可变模型层的宝贵工具。生成代码为我们节省了大量开发时间，并消除了常见错误的风险。在过去的一年里，它已经在Pinterest的生产中进行了大量测试，我们很高兴能与社区分享这项技术。如果您有改进Plank的建议，请随时<a class="ae jc" href="https://github.com/pinterest/plank" rel="noopener ugc nofollow" target="_blank">在Github </a>上提交问题或PR。如果这些是让你兴奋的问题，我们将雇佣你。</p><p id="0476" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mc">鸣谢:感谢我们所有的iOS开发者对plank的使用和反馈，特别是我的队友Wendy Lu、Brandon Kase、Levi McCallum、Bill Kunz、Jon Parise、Tim Johnsen、Connor Montgomery、Harry Shamansky和Garrett Moon对本文的反馈，以及Laurie Berger为Plank设计的徽标。</em></p></div></div>    
</body>
</html>