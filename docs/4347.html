<html>
<head>
<title>From Java to Kotlin and back (I) — Calling Kotlin from Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Java到Kotlin并返回(I) —从Java调用Kotlin</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-i-java-calling-kotlin-9abfc6496b04?source=collection_archive---------0-----------------------#2021-02-27">https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-i-java-calling-kotlin-9abfc6496b04?source=collection_archive---------0-----------------------#2021-02-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e2b661caf6c49ecb8e0e782e7fbdcb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJxHuGoy2lo6FkV2lDjV4Q.jpeg"/></div></div></figure><div class=""/><p id="cbe8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是系列文章的一部分。您可以在这里找到本系列的其余文章:</p><p id="4438" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/google-developer-experts/from-java-to-kotlin-and-back-ii-calling-kotlin-from-java-3bdf72da6e52">从Java到Kotlin并返回(II):从Java调用kot Lin</a></p><p id="90bf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://enriquelopezmanas.medium.com/from-java-to-kotlin-and-back-iii-calling-java-from-kotlin-f33f5c246d69" rel="noopener">从Java到科特林并返回(三):从科特林调用Java</a></p><p id="0549" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我目前正在进行一个多模块项目，该项目结合了各种Java和Kotlin代码，所以我决定将我的想法和笔记作为一个系列文章发表。这可能对我的日志实践有所帮助，也希望能帮助其他面临同样问题的潜在读者找到一些建议。</p><p id="3cdb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android开发者普遍意识到Java可以相对无缝地与Kotlin交互。Kotlin从一开始就被设计成完全与Java互操作，JetBrains和Google都在朝这个方向努力。例如，IntelliJ和Android Studio允许用户将文件从Java转换成Kotlin。这种转换并不总是没有问题的，但它通常做得很好。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es jo"><img src="../Images/c30a8d7aa65e612cbd2c39d4f96d55b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*Gd33fGUKyThR7nsGVggWHQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Converting from Java to Kotlin in IntelliJ-based IDEs.</figcaption></figure><p id="cad9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们处理需要两种语言相互交互的项目时，互用性规则是关键。在Android中，这很可能会经常发生。</p><p id="7925" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个典型的例子是SDK，它的API可能被各种应用程序调用。SDK开发人员可能希望用Kotlin编写库来充分利用这种语言，但最终用户可能会将SDK集成到用Java编写的应用程序中。</p><p id="7025" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个例子是具有不同代码库的单个应用程序。由于Java和Kotlin可以在同一个代码库上共存，因此Kotlin和Java代码有可能在一段不确定的时间内共存。鉴于Android生态系统中模块化的趋势，这尤其可能，在Android生态系统中，模块由多个团队开发，尽管他们正在开发同一产品，但彼此独立操作，一直到语言的选择。</p><p id="22c9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">交互可以双向进行:Kotlin代码调用Java代码，Java代码调用Kotlin代码。因此，记住一些规则以使系统在两个方向上正常工作是很重要的。在本系列的第一篇文章中，我将重点介绍一些我们在处理Kotlin代码并将其公开给Java时(或者当Java访问Kotlin代码时)需要记住的技巧</p><h2 id="b32f" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">使用JvmName注释</h2><p id="c2ab" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">让我们看一下下面的文件，它用Kotlin声明了一个类和一个函数:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Kotlin file without JvmName annotation</figcaption></figure><p id="d8f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当从Java访问这个文件时(由于myFunction是一个顶级函数)，所需的代码必须编写如下:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Accessing code from Java</figcaption></figure><p id="ff85" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以使用包名来引用该类，但是必须使用带有后缀Kt的原始文件名来引用该函数(例如，如果该文件名为file，我们引用的是名为FileKt的Java类的静态方法，因为Java中不存在顶级函数)。</p><p id="0dec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，这是不舒服的。通过使用注释<strong class="ir ht"> JvmName </strong>，我们可以确保我们定义了生成的Java文件的名称:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="bfe3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果在Kotlin文件上有一个顶级函数可能会向Java用户公开，请确保正确使用了JvmName。</p><p id="c87a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JvmName还避免了签名类，这在我们进行<a class="ae jn" href="https://en.wikipedia.org/wiki/Type_erasure" rel="noopener ugc nofollow" target="_blank">类型擦除</a>时可能会发生。例如，看看下面这段代码:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Kotlin signature collision</figcaption></figure><p id="355f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，这些函数不能并排定义，因为JVM签名是相同的:相同的返回类型，属于List类，相同的名称(filter valid(Ljava/util/List；)Ljava/util/List；).手动解决方案是编写不同的名称，但更好的解决方案是使用JvmName在编译成JVM时更改名称:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Avoiding signature collision with JvmName</figcaption></figure><h2 id="8ec9" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">使用<strong class="ak">JVM multipileclass</strong></h2><p id="fad2" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">我们可能经常面临的另一个问题是用相同的Java名称生成多个文件(想想一个类的常用名称，比如Utils)。编译器不喜欢这样，会抛出一个错误。然而，注解<strong class="ir ht">jvmmmultipileclass</strong>允许编译器将多个类合并成一个同名的类。如果您正在处理一个您认为在生成Java文件时会与其他类的名称空间发生冲突的类，那么可以考虑使用<strong class="ir ht">JVM multipileclass。</strong></p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">First class using the annotation JvmMultifileClass</figcaption></figure><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Another class using the annotation JvmMultifileClass</figcaption></figure><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Both will happily coexist in Java</figcaption></figure><h2 id="c4ba" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">使用JVMOverloads</h2><p id="5b92" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">Kotlin包含了一些不错的特性，允许我们编写更符合习惯的代码。例如，我们可以定义默认参数，因此用户不需要指定它们。与参数命名一起，函数名现在更容易阅读，也更不容易出错。例如，让我们检查以下假设的某种自定义HTTP服务的构造函数:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Constructor without JvmOverloads</figcaption></figure><p id="64bc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于构造函数的每个实例化，像名称、主机等字段可能是唯一的，但其他一些可能不是，它们初始化起来可能也很复杂(我们不能总是应用依赖注入来解决这个问题)。通过声明缺省参数，我们只需要指定没有缺省值的属性。</p><p id="1fa4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，Java不支持缺省参数，所以与我们的服务交互的Java文件需要声明所有的参数。真是浪费时间。</p><p id="2adf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注解JvmOverloads在这里起了作用:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Constructor-with-JvmOverloads.kt</figcaption></figure><p id="69e2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JvmOverloads命令Kotlin编译器为此函数生成替换默认参数值的重载。</p><p id="64f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，JvmOverloads与函数一起工作也很好:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Function with JvmOverloads</figcaption></figure><p id="45a5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的Kotlin函数可以在Java中使用，并且您有默认的参数，请考虑使用JvmOverloads。</p><h2 id="f068" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">可见性等价</h2><p id="c09c" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">在我的<a class="ae jn" rel="noopener" href="/google-developer-experts/considerations-when-creating-android-libraries-c80940d79ae">上一篇文章</a>中，我写了开发库时的注意事项，其中一个话题是Kotlin 1.4中的严格库模式。如果默认可见性意味着可见性修饰符将是公共的，则此方法强制可见性修饰符。如果您在用Kotlin开发库时激活了这种模式，那么您可能已经准备好了，但是尽管如此，您还是应该意识到Kotlin和Java之间的可见性等价性。</p><ul class=""><li id="4099" class="kz la hs ir b is it iw ix ja lb je lc ji ld jm le lf lg lh bi translated">Kotlin中的<code class="du li lj lk ll b">private</code>成员被编译成Java中的<code class="du li lj lk ll b">private</code>成员</li><li id="1ed9" class="kz la hs ir b is lm iw ln ja lo je lp ji lq jm le lf lg lh bi translated">顶级的<code class="du li lj lk ll b">private</code>声明将被编译成包局部声明</li><li id="cd9b" class="kz la hs ir b is lm iw ln ja lo je lp ji lq jm le lf lg lh bi translated"><code class="du li lj lk ll b">protected</code>停留在<code class="du li lj lk ll b">protected</code></li><li id="5d5b" class="kz la hs ir b is lm iw ln ja lo je lp ji lq jm le lf lg lh bi translated"><code class="du li lj lk ll b">internal</code>声明在Java中是<code class="du li lj lk ll b">public</code>。</li><li id="a95e" class="kz la hs ir b is lm iw ln ja lo je lp ji lq jm le lf lg lh bi translated"><code class="du li lj lk ll b">public</code>遗体<code class="du li lj lk ll b">public</code></li></ul><h2 id="1b1e" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">例外</h2><p id="af36" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">与Java不同，Kotlin没有检查异常。在JVM级别没有被检查的异常。让我们检查Kotlin中的以下文件:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Exception in Kotlin</figcaption></figure><p id="ea0c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，我们将使用类似下面的语句调用:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Exception in Java</figcaption></figure><p id="18d1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将删除Java中的一个编译错误。我们的函数<code class="du li lj lk ll b">myFunction()</code>不会在任何时候声明<code class="du li lj lk ll b">IOException</code>或任何其他类型的异常。如果我们想让它在Java中工作，我们需要在Kotlin中使用<code class="du li lj lk ll b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throws/index.html" rel="noopener ugc nofollow" target="_blank">@Throws</a></code>注释:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Exception and Throw annotation</figcaption></figure><p id="661d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">额外收获:Kotlin函数可能抛出任何异常类型，包括独立于<code class="du li lj lk ll b">@Throws</code>注释使用的捕获异常。看看我的火箭科学家兼同事尤金的这篇文章，他探讨了潜在的副作用。</p><h2 id="1f58" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">Kotlin中的伴随函数</h2><p id="0ac7" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">当我们需要编写一个不需要类的实例就可以调用的函数，但仍然可以访问同一个类的内部时，我们在Kotlin中编写配套函数。例如，看看下面的类:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="b232" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们需要在Java中使用它，结果如下:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Companion with no annotation in Java</figcaption></figure><p id="82d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们使用<code class="du li lj lk ll b">@JvmStatic</code>注释，它将作为静态方法公开。</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9418" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以及由此产生的Java代码:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Kotlin companion with annotation</figcaption></figure><p id="8a76" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您正在使用伴随函数，记得用<code class="du li lj lk ll b">@JvmStatic</code>注释标记它们。</p><h2 id="18aa" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">伴随常数</h2><p id="a00c" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">与上一节相关，在伴随常量的情况下最好使用注释<code class="du li lj lk ll b">@JvmField</code>，因为<code class="du li lj lk ll b">@JvmStatic</code>创建了一个奇怪的getter。例如，考虑下面的伴随常数:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Companion constant</figcaption></figure><p id="d633" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用<code class="du li lj lk ll b">@JvmField</code>注释伴随值将再次产生更加全面的Java代码:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Companion constant in Java</figcaption></figure><p id="d49a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想知道如果我们使用<code class="du li lj lk ll b">@JvmStatic</code>注释会是什么样子，这是为Java生成的访问:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Companion constant using JvmStatic annotation</figcaption></figure><h2 id="81eb" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ja ki kj kk je kl km kn ji ko kp kq kr bi translated">摘要</h2><p id="502b" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">下面的文章从Kotlin的角度介绍了Java和Kotlin之间的互操作性的一些技巧(例如，Kotlin代码必须如何准备自己，以便促进对Java方面的有效访问。在接下来的文章中，我们将继续探索我们需要对Kotlin代码做些什么。</p><p id="03e6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="ae jn" href="https://twitter.com/jonnyzzz?lang=en" rel="noopener ugc nofollow" target="_blank">尤金·佩特连科</a>和<a class="ae jn" href="https://twitter.com/nshred" rel="noopener ugc nofollow" target="_blank">尼克·斯凯尔顿</a>给我们的反馈。</p><p id="5e0c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的<a class="ae jn" href="https://twitter.com/eenriquelopez" rel="noopener ugc nofollow" target="_blank"> Twitter账户</a>上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它对你有帮助，请随意分享，👏和/或发表评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>