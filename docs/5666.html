<html>
<head>
<title>Lessons learned when upgrading to Terraform 0.12- part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级到Terraform 0.12的经验教训-第2部分</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/lessons-learned-when-upgrading-to-terraform-0-12-part-2-b33ade13f20c?source=collection_archive---------0-----------------------#2019-10-14">https://medium.com/oracledevs/lessons-learned-when-upgrading-to-terraform-0-12-part-2-b33ade13f20c?source=collection_archive---------0-----------------------#2019-10-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b34e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在之前的一篇文章中，我列出了升级到Terraform 0.12要做的事情。这些包括:</p><ol class=""><li id="de59" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">修复重大变更</li><li id="b32f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用一流的表达式</li><li id="ea05" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用改进的条件句</li><li id="7b1a" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用动态块减少代码重复</li><li id="adb2" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">升级独立模块</li></ol><p id="fc7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将主要关注使用丰富类型和<a class="ae jc" href="https://www.terraform.io/docs/configuration/types.html" rel="noopener ugc nofollow" target="_blank">类型约束</a>。</p><h2 id="8a65" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">原始类型</h2><p id="bac9" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">正如定义所说，基本类型是一种简单类型，它不是由任何其他类型构成的。基本类型是字符串、数字和布尔值。</p><p id="8727" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Terraform会在需要时自动将数字和布尔值转换为字符串，反之亦然。然而，明确定义变量类型以避免歧义是一个好习惯。</p><h2 id="d746" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">复杂类型</h2><p id="7059" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">一个<a class="ae jc" href="https://www.terraform.io/docs/configuration/types.html#complex-types" rel="noopener ugc nofollow" target="_blank">复杂类型</a>是一种<em class="kr">将多个值</em>组合成一个值的类型。</p><p id="ca0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有两种复杂类型:</p><ol class=""><li id="63f9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">集合:列表、地图、集合</li><li id="f215" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">结构化:对象，元组</li></ol><p id="0bf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">集合类型<em class="kr">通常是</em>同一类型<em class="kr">的多个值</em>分组在一个集合下，例如</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0c4e" class="jr js hh kx b fi lb lc l ld le">// list of integers<br/>gitlab_lb_ports = [22, 80, 443]</span><span id="c7b3" class="jr js hh kx b fi lf lc l ld le">// map of [string,integers]<br/>variable "availability_domains" {<br/>  description = "ADs where to provision non-OKE resources"<br/>  type        = "map"<br/>  default = {<br/>    bastion = 1<br/>  }<br/>}</span></pre><p id="05c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">偶尔，你也可能需要混合类型。您可以创建自定义的结构类型，也可以使用元组。我们将很快回到结构类型，但是让我们看看元组给我们提供了什么。</p><p id="9962" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">元组允许你定义一系列的元素和它们各自的类型，例如</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7fb9" class="jr js hh kx b fi lb lc l ld le">//vcn_name, cidr, create_nat_gateway         <br/>variable vcn = tuple([string,string,bool])</span></pre><p id="786c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用元组时，您的值必须按照指定的顺序匹配相同数量和类型的参数，例如</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ef89" class="jr js hh kx b fi lb lc l ld le">// bad tuple based on the above definition<br/>vcn = [false,"my_vcn","10.0.0.0/16"]</span><span id="9a7a" class="jr js hh kx b fi lf lc l ld le">//good tuple<br/>vcn = ["my_vcn","10.0.0.0/16",false]</span></pre><p id="a7ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，变量的顺序和类型与元组有关。</p><p id="077e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结构类型允许你创建任何对象模式</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a251" class="jr js hh kx b fi lb lc l ld le">variable "oke_identity" {<br/>  type = object({<br/>    compartment_id = string<br/>    user_id        = string<br/>  })<br/>}</span><span id="423f" class="jr js hh kx b fi lf lc l ld le">variable "oke_bastion" {<br/>  type = object({<br/>    bastion_public_ip         = string<br/>    create_bastion            = bool<br/>    enable_instance_principal = bool<br/>  })<br/>}</span></pre><p id="aae8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，结构类型还可以包含集合类型的属性，例如</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="57ec" class="jr js hh kx b fi lb lc l ld le">variable "oke_general" {<br/>  type = object({<br/>    <strong class="kx hi">ad_names     = list(string)</strong><br/>    label_prefix = string<br/>    region       = string<br/>  })<br/>}</span><span id="f40f" class="jr js hh kx b fi lf lc l ld le">variable "oke_network_vcn" {<br/>  type = object({<br/>    ig_route_id                = string<br/>    is_service_gateway_enabled = bool<br/>    nat_route_id               = string<br/>    <strong class="kx hi">newbits                    = map(number)</strong><br/>    <strong class="kx hi">subnets                    = map(number)</strong><br/>    vcn_cidr                   = string<br/>    vcn_id                     = string<br/>  })<br/>}</span></pre><p id="1c99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当属性由集合类型组成时，您还必须指定上面突出显示的值的类型。</p><p id="ae41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有时，您可能还需要传递一个混合类型的集合，然后您可以通过<a class="ae jc" href="https://www.terraform.io/docs/configuration/functions.html" rel="noopener ugc nofollow" target="_blank">集合函数</a>检索该集合。在这种情况下，你可以使用'<em class="kr">任何</em>类型例如</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4ebf" class="jr js hh kx b fi lb lc l ld le">variable "node_pools" {<br/>  <strong class="kx hi">type        = map(any)</strong><br/>  description = "number of node pools"<br/>}</span></pre><p id="64d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">允许我们传递这样的值:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3475" class="jr js hh kx b fi lb lc l ld le">node_pools = {<br/>  "np1" = ["VM.Standard.E2.1", 3]<br/>  "np2" = ["VM.Standard2.1", 4]<br/>  "np3" = ["VM.Standard.E2.2", 5]<br/>}</span></pre><p id="c441" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您已经知道如何定义类型，剩下3个最后的问题:</p><ol class=""><li id="1fed" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">如何创建结构类型</li><li id="b9a9" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">当使用模块/子模块时，如何使用/重用它们</li><li id="3d7e" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">如何指定根变量</li></ol><h2 id="3461" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">创建结构类型</h2><p id="5c23" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">如果你熟悉面向对象(OOP)原则，你可以相应地定义你的类型。例如，在<a class="ae jc" href="https://github.com/oracle-terraform-modules/terraform-oci-oke" rel="noopener ugc nofollow" target="_blank"> terraform-oci-oke </a>项目中，我们定义了一组对变量进行分组的对象:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7070" class="jr js hh kx b fi lb lc l ld le">variable "oci_base_identity" {<br/>  type = object({<br/>    api_fingerprint      = string<br/>    api_private_key_path = string<br/>    compartment_id       = string<br/>    compartment_name     = string<br/>    tenancy_id           = string<br/>    user_id              = string<br/>  })<br/>}</span><span id="d4ea" class="jr js hh kx b fi lf lc l ld le">variable "oci_base_ssh_keys" {<br/>  type = object({<br/>    ssh_private_key_path = string<br/>    ssh_public_key_path  = string<br/>  })<br/>}</span></pre><p id="03b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您通常会将特定对象/资源的属性或相关参数分组在一起，例如，oci_base_identity包含与身份相关的属性，而oci_base_ssh_keys包含公共和私有ssh密钥对路径。</p><h2 id="9210" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">将结构类型用于模块/子模块</h2><p id="fffc" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">如果你有几个模块，我发现在变量名的前面加上模块名的前缀<em class="kr">是一个好习惯，这样我就知道这些变量在哪里被使用。</em></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7e9a" class="jr js hh kx b fi lb lc l ld le">//base module variables<strong class="kx hi"><br/>oci_base</strong>_identity = {<br/>...<br/>}</span><span id="396f" class="jr js hh kx b fi lf lc l ld le"><strong class="kx hi">oci_base</strong>_ssh_keys = {<br/>...<br/>}</span><span id="3453" class="jr js hh kx b fi lf lc l ld le"><strong class="kx hi">oci_base</strong>_general = {<br/>...<br/>}</span><span id="08f2" class="jr js hh kx b fi lf lc l ld le">//oke_module variables<br/><strong class="kx hi">oke</strong>_general = {<br/>...<br/>}</span><span id="f595" class="jr js hh kx b fi lf lc l ld le"><strong class="kx hi">oke</strong>_bastion = {<br/>...<br/>}</span><span id="b99a" class="jr js hh kx b fi lf lc l ld le">//oke_network variables<br/><strong class="kx hi">oke_network</strong>_vcn = {<br/>...<br/>}</span></pre><h2 id="a56e" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">指定根变量</h2><p id="bfb9" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">这一条可能会有点争议，但这是我的观点:</p><ol class=""><li id="4219" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">如果您的terraform项目是一个可重用模块，并且将被另一个项目重用，请在根变量中使用结构类型</li><li id="110a" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">如果您的terraform项目将用于实际创建基础设施，而不是为了重用，请尽可能使用平面结构和简单/集合类型</li></ol><p id="f517" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一种情况下，开发人员将针对您的根变量(实际上是您的模块的API)编写代码。因此，他们应该理解你的变量和它们的类型，以便有效地调用和重用你的模块。他们甚至可能阅读你的代码。</p><p id="6dd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用结构类型还有助于减少他们必须编写的样板代码的数量，例如在Terraform 0.11中，如果没有对象类型，我们必须这样做来定义和重用基本模块:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0db9" class="jr js hh kx b fi lb lc l ld le">module "base" {  <br/>  source = "./modules/base"   <br/>  <br/>  # identity   <br/>  api_fingerprint      = "${var.api_fingerprint}"<br/>  api_private_key_path = "${var.api_private_key_path}"<br/>  compartment_name     = "${var.compartment_name}"  <br/>  compartment_ocid     = "${var.compartment_ocid}"  <br/>  tenancy_ocid         = "${var.tenancy_ocid}"  <br/>  user_ocid            = "${var.user_ocid}"  <br/>  ssh_private_key_path = "${var.ssh_private_key_path}"<br/>  ssh_public_key_path  = "${var.ssh_public_key_path}"   </span><span id="d42d" class="jr js hh kx b fi lf lc l ld le">  # general  </span><span id="a591" class="jr js hh kx b fi lf lc l ld le">  label_prefix = "${var.label_prefix}"  <br/>  region       = "${var.region}"   </span><span id="c76f" class="jr js hh kx b fi lf lc l ld le">  # networking  </span><span id="a832" class="jr js hh kx b fi lf lc l ld le">  newbits                = "${var.newbits}"  <br/>  subnets                = "${var.subnets}"  <br/>  vcn_cidr               = "${var.vcn_cidr}"  <br/>  vcn_dns_name           = "${var.vcn_dns_name}"  <br/>  vcn_name               = "${var.vcn_name}"  <br/>  create_nat_gateway     = "${var.create_nat_gateway}"<br/>  nat_gateway_name       = "${var.nat_gateway_name}"  <br/>  create_service_gateway = "${var.create_service_gateway}"  <br/>  service_gateway_name   = "${var.service_gateway_name}"   </span><span id="8e3f" class="jr js hh kx b fi lf lc l ld le">  # bastion  <br/>  bastion_shape               = "${var.bastion_shape}"   <br/>  create_bastion              = "${var.create_bastion}"  <br/>  enable_instance_principal   ="${var.enable_instance_principal}"  <br/>  image_ocid                  = "${var.image_ocid}"  <br/>  image_operating_system      = "${var.image_operating_system}"   <br/>  image_operating_system_version = "${var.image_operating_system_version}"   </span><span id="2a72" class="jr js hh kx b fi lf lc l ld le"># availability_domains<br/>availability_domains = "${var.availability_domains}"}</span></pre><p id="4572" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用对象类型时，请在Terraform 0.12中进行比较:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d5ef" class="jr js hh kx b fi lb lc l ld le">module "base" {  <br/>  source = "./modules/base"   <br/>  <br/>  # identity  <br/>  oci_base_identity = local.oci_base_identity</span><span id="193c" class="jr js hh kx b fi lf lc l ld le">  # ssh keys  <br/>  oci_base_ssh_keys = local.oci_base_ssh_keys   </span><span id="e20b" class="jr js hh kx b fi lf lc l ld le">  # general oci parameters  <br/>  oci_base_general = local.oci_base_general   </span><span id="4a24" class="jr js hh kx b fi lf lc l ld le">  # vcn parameters  <br/>  oci_base_vcn = local.oci_base_vcn   </span><span id="28a6" class="jr js hh kx b fi lf lc l ld le">  # bastion parameters  <br/>  oci_base_bastion = local.oci_base_bastion<br/>}</span></pre><p id="013d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在本地做脏活:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b7f1" class="jr js hh kx b fi lb lc l ld le">locals {   </span><span id="8985" class="jr js hh kx b fi lf lc l ld le">  oci_base_identity = {    <br/>    api_fingerprint      = var.api_fingerprint    <br/>    api_private_key_path = var.api_private_key_path      <br/>    compartment_name     = var.compartment_name    <br/>    compartment_id       = var.compartment_id    <br/>    tenancy_id           = var.tenancy_id    <br/>    user_id              = var.user_id  <br/>  }<br/>   <br/>  oci_base_ssh_keys = {    <br/>    ssh_private_key_path = var.ssh_private_key_path       <br/>    ssh_public_key_path  = var.ssh_public_key_path  <br/>  }<br/> ....<br/>}</span></pre><p id="9b13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当您向模块添加新特性并将新版本发布到注册中心时，您可以使用<a class="ae jc" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本控制</a>来确保模块的用户及其下游用户不会遇到兼容性问题。这是我们在可重用的<a class="ae jc" href="https://github.com/oracle-terraform-modules/terraform-oci-base" rel="noopener ugc nofollow" target="_blank"> terraform-oci-base </a>模块中采用的方法。重用它将如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="03ea" class="jr js hh kx b fi lb lc l ld le">module "base" {<br/>  source  = "mybase"<br/><strong class="kx hi">  version = "1.0.1"</strong><br/>}</span></pre><p id="51c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第二种情况下，最终用户不是开发人员，他们需要在运行Terraform时创建变量文件。因此，如果结构是平面的，他们更容易创建变量文件。我对这种方法的灵感来自于<a class="ae jc" href="https://github.com/toml-lang/toml" rel="noopener ugc nofollow" target="_blank"> TOML </a>，它“旨在成为最小化的配置文件格式，由于明显的语义而易于阅读。”</p><p id="c711" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然terraform变量文件结构并不完全符合TOML，但这里的目的是让用户可以轻松地创建配置文件，因此在这种情况下，为根变量保持一个平面结构是更可取的。这是我们在<a class="ae jc" href="https://github.com/oracle-terraform-modules/terraform-oci-oke" rel="noopener ugc nofollow" target="_blank"> terraform-oci-oke </a>模块中采用的方法。</p><h2 id="8c0c" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">Terraform提示:使用for对数字列表求和</h2><p id="a4f9" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我在试图计算一系列数字的总和时发现了这个<a class="ae jc" href="https://github.com/hashicorp/terraform/issues/17239" rel="noopener ugc nofollow" target="_blank">小宝石</a>。</p><h2 id="a2da" class="jr js hh bd jt ju jv jw jx jy jz ka kb ip kc kd ke it kf kg kh ix ki kj kk kl bi translated">摘要</h2><p id="5e5b" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">使用富类型时，请使用以下方法:</p><ol class=""><li id="b929" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">如果你的项目是一个可重用的模块，在你的根变量中使用丰富的类型。否则，使用扁平结构，使最终用户使用起来简单。</li><li id="77d1" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">显式指定变量的类型</li><li id="0ea2" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用OOP原则对变量进行分组</li><li id="415c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">在变量名前面加上使用它们的模块名</li><li id="2065" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">尽可能使用集合，并指定它们将使用的值类型</li><li id="3832" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><a class="lg lh ge" href="https://medium.com/u/5771c68b8656?source=post_page-----b33ade13f20c--------------------------------" rel="noopener" target="_blank">漂亮的机器人</a>建议<a class="ae jc" rel="noopener" href="/@nicerobot/i-will-argue-that-when-possible-concatenation-should-be-done-in-locals-76444655537f">在本地</a>做拼接。更进一步，在局部变量中进行对象初始化。</li></ol></div></div>    
</body>
</html>