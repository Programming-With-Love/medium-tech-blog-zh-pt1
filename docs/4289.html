<html>
<head>
<title>Android MVI architecture with Jetpack &amp; Coroutines/Flow — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Jetpack和协程/流的Android MVI架构—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-2-bc1f3cb1dd2d?source=collection_archive---------0-----------------------#2020-04-11">https://medium.com/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-2-bc1f3cb1dd2d?source=collection_archive---------0-----------------------#2020-04-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="666c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">在MVI建筑中创建视图模型</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a44e125b3b14c292ba9bc61e5d507d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lu7PUSB3Q-P0IYi4AlhBw.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@nordwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NordWood Themes</a> on <a class="ae js" href="https://unsplash.com/t/business-work?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jt ju jv"><p id="0957" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">如果您还没有阅读这些系列的前一篇文章，您可以在这里找到它:</p><p id="ccba" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">第1部分— <a class="ae js" rel="noopener" href="/google-developer-experts/android-mvi-architecture-with-jetpack-coroutines-flow-part-1-recyclerview-adapter-w-83a10134207f">使用视图绑定回收视图适配器</a></p></blockquote><blockquote class="kv"><p id="fa91" class="kw kx hh bd ky kz la lb lc ld le ku dx translated">现在我们已经创建了一个基本的RecyclerView适配器来引导列表，我们需要看看如何获取、转换和显示屏幕数据。</p></blockquote></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h1 id="a79b" class="ie if hh bd ig ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb bi translated">进入视图模型</h1><p id="69bc" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated"><strong class="jz hi"> ViewModel </strong>是Jetpack组件，我们需要对其进行扩展，以便托管其他几个组件的编排。其他组件的协调将导致实现我们的业务目标。</p><p id="e2a7" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">通常在<strong class="jz hi"> ViewModel </strong>中，我们需要进行一些API调用或数据库操作，并相应地在ViewModel的UI消费者中显示我们更新的信息。</p><p id="3ff4" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们将展示的并且目前正在我们的示例项目中使用的组件是用例，也称为交互器。</p><p id="5db5" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们更喜欢将这些用例“注入”到视图模型的构造函数中。通过这样做，我们获得了可测试性。</p><h1 id="a7b9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">构造函数注入</strong></h1><h2 id="79d0" class="lz if hh bd ig ma mb mc ik md me mf io lt mg mh is lv mi mj iw lx mk ml ja mm bi translated">和Koin一起</h2><p id="0dba" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated">如果我们使用Koin，一个<strong class="jz hi">视图模型</strong>可以很容易地将它的依赖注入到它的构造函数中。</p><p id="864f" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们声明一个新的Koin模块，如下所示:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="3764" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们使用<code class="du mp mq mr ms b">factory</code>是为了总是在我们的<strong class="jz hi"> ViewModel </strong>中注入一个新的实例(根据我们的应用程序的需求和我们的用例所做的工作，将它声明为singleton可能是合适的)。我们的<strong class="jz hi">用例</strong>的其余依赖项来自图的其余部分(我们将在以后的文章中对此进行分析)。</p><h2 id="1e4d" class="lz if hh bd ig ma mb mc ik md me mf io lt mg mh is lv mi mj iw lx mk ml ja mm bi translated">用匕首</h2><p id="ea9d" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated">为了在使用<strong class="jz hi"> Dagger </strong>时通过构造函数注入依赖关系，我们需要创建一个<strong class="jz hi"> ViewModelFactory </strong>，并通过类名将我们的<strong class="jz hi">viewmodel</strong>绑定到<strong class="jz hi"> Dagger </strong>图。</p><p id="5d45" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">该注入的一个快速实现如下:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mn mo l"/></div></figure></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h1 id="119e" class="ie if hh bd ig ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb bi translated">视图模型中的用户操作消耗</h1><p id="8bd2" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated">因为我们想要的架构是MVI架构，所以我们需要创建一个用户动作/意图流，我们的视图模型将消费和操作它。</p><p id="8ac2" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们在示例项目中使用的方法如下:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="4665" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们的<strong class="jz hi">视图模型</strong>在这里使用了一个<code class="du mp mq mr ms b">ConflatedBroadcastChannel</code>，它在我们的<code class="du mp mq mr ms b">init</code>方法中被转换为一个<code class="du mp mq mr ms b">Flow</code>。在每一次发射中，我们都调用了等价的<code class="du mp mq mr ms b">suspend fun</code>，它要么产生一些数据在我们的UI上传播，要么做一些其他的工作！</p></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h1 id="17f4" class="ie if hh bd ig ih lm ij ik il ln in io ip lo ir is it lp iv iw ix lq iz ja jb bi translated">向我们的UI(生命周期感知)组件公开数据</h1><p id="29a0" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated">既然我们能够消费用户动作/意图，我们需要看看如何将数据传播到我们的UI。</p><p id="492f" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">为了做到这一点，我们更愿意使用数据库作为我们唯一的真实来源，并产生一个数据流，我们可能会在委托给我们的UI之前对其进行预处理。</p><p id="71a1" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">例如，我们将观察本地数据库中的一个表，其中存储了我们所有的Github库(我们将在以后的文章中研究如何获取它们)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="186e" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们注入的<strong class="jz hi">用例</strong>在这里可以被观察，以便在它被调用后返回一个<strong class="jz hi">流&lt; T &gt; </strong>来产生它的工作。对<strong class="jz hi">用例</strong>的调用是在我们的<code class="du mp mq mr ms b">init</code>方法的末尾完成的。</p><p id="45dc" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">然后，我们将发出的数据库实体<code class="du mp mq mr ms b">map</code>到我们的适配器项中，并在将它们“发送”到我们的UI(在我们的例子中是一个<strong class="jz hi">片段</strong>)之前，将它们转换成<strong class="jz hi"> LiveData </strong>。最后但同样重要的是，由于我们使用了Flow，我们需要使用<code class="du mp mq mr ms b">viewModelScope.coroutineContext</code>来利用我们的<strong class="jz hi">流</strong>的内置取消。</p><p id="0b69" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">我们现在需要做的就是观察这个LiveData，并将商品列表提交给我们的适配器。考虑到我们根据上一篇文章中所做的工作来适当区分我们的项目，我们可以确信，尽管我们的DB表中有大量的无效项，但我们的适配器中所需的更新是最少的。</p><p id="c1db" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">这里我们可以做的另一个增强是使用<code class="du mp mq mr ms b">.distinctUntiChanged()</code>操作符来避免相同的数据库排放。</p><blockquote class="jt ju jv"><p id="1740" class="jw jx jy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ha bi translated">免责声明:用例实现的灵感来自于<a class="mt mu ge" href="https://medium.com/u/9303277cb6db?source=post_page-----bc1f3cb1dd2d--------------------------------" rel="noopener" target="_blank"> Chris Banes </a> TiVi repo</p></blockquote></div><div class="ab cl lf lg go lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ha hb hc hd he"><h2 id="d9f8" class="lz if hh bd ig ma mb mc ik md me mf io lt mg mh is lv mi mj iw lx mk ml ja mm bi translated">结论</h2><p id="e789" class="pw-post-body-paragraph jw jx hh jz b ka lr kc kd ke ls kg kh lt lu kk kl lv lw ko kp lx ly ks kt ku ha bi translated">这是一个基于我们所看到的对我们有用的MVI架构的建议方法:)我们将在下面的一篇文章中讨论我们的<strong class="jz hi">视图模型</strong>的测试部分！欢迎任何改进或建议！#安全停留</p><p id="ffff" class="pw-post-body-paragraph jw jx hh jz b ka kb kc kd ke kf kg kh lt kj kk kl lv kn ko kp lx kr ks kt ku ha bi translated">您可以在下面的repo中找到上面的所有代码以及它们的用法示例，这也是我们将在这一系列文章中讨论的内容！</p><div class="mv mw ez fb mx my"><a href="https://github.com/pavlospt/refactored-umbrella" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hi fi z dy nd ea eb ne ed ef hg bi translated">pavlospt/重构-雨伞</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">重构的保护伞是一个附带项目，以检查与科特林协同程序和流量，MVVM和Koin现代Android开发…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jm my"/></div></div></a></div></div></div>    
</body>
</html>