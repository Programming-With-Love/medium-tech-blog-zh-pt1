<html>
<head>
<title>Continuous Delivery (CI/CD) in AEM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AEM中的连续交付(CI/CD)</h1>
<blockquote>原文：<a href="https://medium.com/globant/continuous-delivery-ci-cd-in-aem-507f89808132?source=collection_archive---------0-----------------------#2021-03-17">https://medium.com/globant/continuous-delivery-ci-cd-in-aem-507f89808132?source=collection_archive---------0-----------------------#2021-03-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="61ae" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="9928" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在构建良好的交付渠道方面投入大量资金，可以保证良好的节奏，并有助于满足交付时间。</p><p id="ca50" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这个具体案例中，客户有一个AEM的多部分手动部署流程，我们从零开始构建了一个全新的管道，第一个版本使用Jenkins作为CI引擎，它适用于整体应用程序(AEM核心)。然后，我们开始了创建独立模块的旅程，并转移到一个连续交付的世界，产品所有者只需简单地点击一下，就可以部署并发布单个模块的新版本。只有在较低的环境和试运行中对特定模块/包进行了测试(自动和手动)之后，才能进行生产部署。</p><h1 id="9cb0" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">基础</h1><h1 id="2cde" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">分支模型</h1><p id="e37c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们使用<a class="ae kf" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Git流</a>作为分支模型来支持多个特性和版本。这是大多数组织的常见做法，因为它相对容易实现和维护。问题是，只有在发布之后(我们每两周发布一次)，我们才在主分支和开发分支中集成代码。所以整个周期是缓慢的，并且合并很有可能产生代码冲突。</p><h2 id="d959" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">Git流分支模型</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/b757981b8de4ca63c33378514d44220a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WaVwaiMrJvqueeZy"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 1. Git Flow branching model</em></figcaption></figure><h2 id="9fb8" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">基于主干的开发</h2><p id="7352" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">相反，我们可以应用<a class="ae kf" href="https://trunkbaseddevelopment.com/" rel="noopener ugc nofollow" target="_blank">基于主干的开发</a>，并且一直(至少每天)将特性和错误修复合并到主干(主)中，并且每次合并到主中可以作为一个潜在的发布来处理，这将潜在地减少冲突的数量，并且发布周期将被减少到这样的程度，如果一个特性已经准备好并且经过测试，那么它可以在几分钟内被部署到生产中。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ll"><img src="../Images/cc61e93ae331ed2b4673230e9eb3e170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_w0vj-D0GjKR25Iq"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 2. Trunk Branching Model</em></figcaption></figure><h1 id="7963" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">涉及的做法</h1><ul class=""><li id="d1c3" class="lm ln hh je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu bi translated"><strong class="je hi">执行:</strong>任何组件的每一个变更都应该启动反馈过程:代码变更、配置修改、主机环境和/或数据突变。然后，如果反馈是负面的，那么流程应该被中断，并且团队可以清楚地看到中断的原因。例如，如果拉请求的回归测试失败，拉请求应该被自动拒绝。</li><li id="cf39" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">存储库驱动的开发:</strong>在一个共享分支中所做的任何改变都应该自动触发管道，以尽快获得反馈。</li><li id="91fc" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">时机:必须尽快收到反馈。测试自动化、集成测试和性能测试已经就绪，如果任何测试失败，代码(或测试代码)应该被修复，因为过程完全停止，防止坏代码在环境之间进一步移动。</li><li id="efe5" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">可视反馈:</strong>仪表板将在发布团队能够随时了解应用程序健康状况的地方可用。</li><li id="1c57" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">构建一次，随处部署:</strong>不要为每个部署编译代码，只需在引入变更时构建，然后将二进制工件存储在工件库中，并在不同环境中的实际部署中使用该工件。</li><li id="9382" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">持续改进:</strong>整个持续集成/持续交付管道的反馈应该产生管道定义的改进，这意味着管道代码应该是源代码的一部分，这样它就可以与应用程序一起发展。</li><li id="46e0" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">受保护的共享分支:像trunk/master这样的共享分支应该受到保护，以免直接提交和/或重写。每个更改都应该通过拉请求来完成。</li></ul><h1 id="244a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">反模式</h1><p id="0184" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们需要避免:</p><ul class=""><li id="6f21" class="lm ln hh je b jf ka jj kb jn ma jr mb jv mc jz lr ls lt lu bi translated">直接提交到共享分支(像本例中的主干/主节点)</li><li id="0576" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">提交没有关联票证id的更改。所有的提交都应该包括对描述变更的标签的引用，这样我们就可以跟踪每一次提交。</li><li id="35e7" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">手动部署软件。我们应该防止任何强制人们仅使用管道进行部署的手动部署。</li><li id="1620" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">仅当整个开发完成时，才在类似生产的环境中部署。相反，在类似生产的环境中集成测试、部署和发布作为开发流程的一部分，并添加功能切换以禁用/启用客户尚未准备好的功能。</li><li id="9c5f" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">环境的手动配置管理。相反，配置中的每个更改都应该位于代码中，并作为管道的一部分自动部署/安装。</li></ul><h1 id="20a3" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">管道</h1><h2 id="dcfb" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">詹金斯2.0管道:</h2><p id="853a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">从根本上说，Jenkins是一个支持许多自动化模式的自动化引擎。Pipeline为Jenkins添加了一套强大的自动化工具，支持从简单的持续集成到全面的CD管道的用例。通过对一系列相关任务进行建模，用户可以利用Pipeline的许多功能:</p><ul class=""><li id="645d" class="lm ln hh je b jf ka jj kb jn ma jr mb jv mc jz lr ls lt lu bi translated">代码:管道在代码中实现，并且通常被签入到源代码控制中，使团队能够编辑、审查和迭代他们的交付管道。</li><li id="cc95" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">耐用:管道可以在Jenkins master的计划内和计划外重启中存活。</li><li id="0060" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">暂停:在继续管道运行之前，可以选择停止管道，等待人工输入或批准。</li><li id="d808" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">多功能:管道支持复杂的真实世界CD需求，包括分叉/连接、循环和执行并行工作的能力。</li><li id="f5d8" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">可扩展:Pipeline插件支持对其领域脚本语言(DSL)的自定义扩展，并支持与其他插件集成的多种选项。</li></ul><h2 id="e570" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">比特桶管道</h2><p id="46dd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Bitbucket Pipelines是Bitbucket Cloud的CI/CD，它与UI集成在一起，位于您的存储库旁边，使团队可以轻松地开始运行、构建、测试和部署他们的代码。Bitbucket Pipelines对于从CI/CD新手到拥有复杂的交付和部署管道的团队来说都是一个很好的工具。</p><h1 id="75d7" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">特定场景</h1><p id="28d1" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因为我们需要一个特定的场景来测试所描述的在AEM中持续交付的方法。我们将在网站中使用一个特殊的独立模块，这将从零开始创建。</p><h1 id="684e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">产品视图AEM模块</h1><p id="1ccd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><a class="ae kf" href="https://www.royalcaribbean.com/cruises/itinerary/3-night-bahamas-perfect-day-from-orlando-port-canaveral-on-mariner/MA03PCN-3464559193?sail-date=2021-10-29&amp;currency=USD." rel="noopener ugc nofollow" target="_blank">产品视图</a>是一个允许客户查看产品路线的应用程序。</p><p id="df36" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这个模块可以完全独立于单一的应用程序，并且它是一个可以在自己的阶段部署的强有力的候选者。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es md"><img src="../Images/f2f77fe649a7d4ae74158c3a55757da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/0*IeGKtWRuSFOW6ZtT"/></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 3. OSGI Module architecture</em></figcaption></figure><p id="e875" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">产品视图仅通过服务使用AEM核心(单一应用程序),因此对代码没有任何依赖性。</p><h1 id="f96b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">管道实施</h1><p id="ea36" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">该管道是使用与Jenkins集成的Bitbucket管道创建的。</p><h2 id="4ddb" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">要求:</h2><p id="94dd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了实现本项目的持续交付，关键实践是必要的:</p><ul class=""><li id="fed9" class="lm ln hh je b jf ka jj kb jn ma jr mb jv mc jz lr ls lt lu bi translated">单元测试覆盖率必须超过80%</li><li id="bccc" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">连续测试，这意味着测试是自动执行的，每次提交到主机，它会产生可读的结果，这些结果可以与以前的执行进行比较。</li><li id="58e0" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">生产类环境。环境的行为应该与生产完全一样，因此我们将努力保持数据同步，包括字典和资产。</li><li id="57a3" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">测试应该是CI/CD管道的一部分</li></ul><p id="5123" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">管道的初始设计是:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/08f64154391ec3027b07058206d7c761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YrPhr68kXG27XwuH"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 4. Ci/CD Pipeline sequence diagram</em></figcaption></figure><p id="d7cc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">注意事项:</p><ul class=""><li id="cd90" class="lm ln hh je b jf ka jj kb jn ma jr mb jv mc jz lr ls lt lu bi translated">在测试中部署意味着，代码将被部署在所有的测试环境中。</li><li id="463b" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">构建步骤将编译代码，生成工件，并将其上传到工件存储库(在本例中是S3)。</li><li id="f23d" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">在任何环境中部署都将从工件存储库中获取工件，并在各自的环境中进行部署。</li></ul><h1 id="a825" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">环境管理:</h1><ul class=""><li id="71c4" class="lm ln hh je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu bi translated"><strong class="je hi">测试</strong>:当一个提交在master中被合并时，它将自动被部署到所有的测试环境中，包括stage。这些环境将用于不同类型的测试。新功能的手动测试、回归测试和性能测试将在不同的环境中同时进行。</li><li id="f918" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">暂存</strong>:当一个发布候选被批准(在Bitbucket管道中)移动到暂存时，它将被部署到暂存中。</li><li id="b008" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated"><strong class="je hi">生产</strong>:当一个候选发布被批准(在Bitbucket管道中)进入生产时，它将被部署到生产中。</li></ul><h1 id="8ff1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">连续测试</h1><p id="1804" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">持续测试是执行自动化测试的过程，作为软件交付管道的一部分，以便尽可能快地获得与候选软件发布相关的业务风险的反馈。它发展并扩展了测试自动化，以应对现代应用程序开发和交付的日益增长的复杂性和速度。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/d609d94ce370979ff1d0177c7ed2206b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JjKOCE3sskuk--RS"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 5. Continuous Testing as part of the Software Lifecycle</em></figcaption></figure><h1 id="4e14" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">实施细节</h1><p id="bc22" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">位桶管道将作为管道编排器工作，每次新的PR合并到干线(主)时，整个过程将自动触发。</p><p id="dd1e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">詹金斯将作为裁谈会的一部分工作。它将获取工件并将其部署到实际的实例中。这有两个原因，一是我们希望将流程分成两部分，分别在CI和CD上独立执行，这样我们就可以在需要时重新部署旧的工件[回滚]，二是环境实例只能通过负载平衡器[ELB]或内部实例(如位于同一亚马逊虚拟私有云[VPC]中的Jenkins服务器)进行访问</p><p id="afa4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">备注:</strong></p><ul class=""><li id="4475" class="lm ln hh je b jf ka jj kb jn ma jr mb jv mc jz lr ls lt lu bi translated">每次提交到master都会创建一个新版本的项目。</li><li id="7be1" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">每个新版本都将作为一个新的工件生成</li><li id="78d6" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">所有的工件/版本将被存储在工件存储库中(在这个例子中是S3)</li><li id="5161" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">部署作业将从S3获取工件，并将其安装在各自的环境实例中。</li><li id="e316" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">部署将按顺序进行，从测试开始，然后是试运行，最后是生产。</li><li id="cd98" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">在部署完成后，持续测试框架将被自动触发，只有当它成功完成时，下一个环境部署才会被启用，相反，如果测试失败，工件不能被移动到下一个环境，从而停止该过程。</li><li id="3348" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">如果测试失败，需要创建一个新的带有修复的提交，以便能够在下一个期望的环境中部署。</li></ul><h1 id="e813" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">逐步过程</h1><p id="ebc2" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">1.当分支合并到主服务器时，部署作业会自动触发</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/da21939fd2e522d18028efd653061fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RE4B0iZWrXHQsTjV"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 6. Automatic execution of the pipeline after a PR is merged</em></figcaption></figure><p id="c8be" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">2.然后<a class="ae kf" href="https://maven.apache.org/maven-release/maven-release-plugin/" rel="noopener ugc nofollow" target="_blank"> maven发布插件</a>被用于移动到下一个版本(这将增加pom.xml文件中的版本到下一个可用的版本，例如:从0.0.10到0.0.11)并且工件被创建(例如，product-view . ui . apps-0 . 0 . 11 . zip)</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mh"><img src="../Images/08fda5b8c8938978c619ccdee5fa969f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IGGextZqOjs7tBlI"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 7. Ci/CD Pipeline in Bitbucket</em></figcaption></figure><p id="e96a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">3.然后工件被上传到我们的工件库，在这个例子中是S3，所有这些都使用AWS CLI。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/78b599729161c8f01e58bb4f46063cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wMWGkgwW0W0JyfEp"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 8. S3 Artifacts Bucket</em></figcaption></figure><p id="911a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">4.由于这是一个连续的交付管道，该过程将一直等到涉众在测试环境中触发部署。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mi"><img src="../Images/b1ced3f144b5f48f519e1a41d143bf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/0*APzFFyFi7AB5sj0a"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 9. Bitbucket Pipeline step 3, Upload to S3</em></figcaption></figure><p id="1042" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">5.当按下Deploy按钮时，将显示部署的预览，包括与Pull请求相关的票证编号，并且将部署的代码的diff视图被启用以供查看。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mj"><img src="../Images/4c90cf33b4d59c89d4e8844bcf357772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fH1Lrb9UHKTAtqte"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 10. Deployment preview in Bitbucket Pipelines</em></figcaption></figure><p id="bf6f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">6.然后，如果您确认了部署，那么在S3上传的工件将被安装在所有的测试环境中(Bitbucket保存了执行部署的用户的注册)。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mh"><img src="../Images/309973cb7cff03867e24365100e3938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YLvrDIU2o47rz67j"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 11. Deployment preview in Bitbucket Pipelines</em></figcaption></figure><p id="40fc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如前所述，环境中的实际部署是由Jenkins完成的，因此Bitbucket管道用三个参数(工件名称、版本和环境)触发Jenkins作业</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mk"><img src="../Images/87aada41c095d749f8f76d3b54227906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7HJw_P_agVpb2FwX"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 12. Deployment via Jenkins</em></figcaption></figure><p id="9b83" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">7.部署完成后，测试阶段开始。一个环境由QA团队手动测试，另一个环境通过持续测试框架自动测试，另一个环境使用性能测试框架自动测试。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ml"><img src="../Images/9dc5065107ce0dc6c509ad53ceadf094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0NiZqCVcO_4fxbZ1"/></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 13. Deployment done</em></figcaption></figure><p id="a369" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">8.如果测试很好，授权用户可以以类似的方式在预编程中部署工件。</p><p id="a5de" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">注意</strong>:可以在Bitbucket中的Deployments视图中查看部署状态的完整视图，显示内部版本号、触发作业的用户以及将部署提升到下一个环境的选项。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mm"><img src="../Images/7d5d76661bf1fc6bc6de9c4f791d54ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iB9Ml0GPzf7cyIYh"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 14. Deployment done</em></figcaption></figure><h1 id="6028" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">在吉拉的代表权</h1><p id="4df5" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在吉拉，相关的标签将根据部署进行相应的更新，指出部署完成的时间、执行的次数以及工件安装的环境。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mn"><img src="../Images/4b2e1b7d131082b4eb02a4d501115c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/0*eBUpxhgK3WbmV8Pr"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 15. Bitbucket Pipelines status integrated in Jira</em></figcaption></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mo"><img src="../Images/555532577d96cc3378e90f6e6c51b7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/0*FX9ku_Oz5_SCbtcd"/></div><figcaption class="lg lh et er es li lj bd b be z dx"><em class="lk">Figure 16. Bitbucket Pipelines environments integrated in Jira</em></figcaption></figure><h1 id="60e6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><ul class=""><li id="c70f" class="lm ln hh je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu bi translated">有多种工具可以用于持续集成和持续交付，使用什么工具的决定取决于公司的特定需求。您甚至可以基于bash脚本创建自己的工具，这里最重要的目标是尽可能地自动化这个过程，这样在这段时间内，您就不用担心部署和提交的机制，可以尽快地、安全地和尽可能地进行测试。</li><li id="5c97" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">使用基于主干的开发将减少多分支管理的过载，但是您需要能够通过切换机制在需要时关闭不完整的功能。</li><li id="2c33" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">自动化所有你能自动化的测试，这包括回归测试，性能测试和冒烟测试，这里的关键是确定一种方法，测试可以与代码一起发展。</li><li id="db5a" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">在AEM中，考虑一种微服务/微模块方法，在这种方法中，特定的特性将拥有自己独立的生命周期。</li><li id="3dbe" class="lm ln hh je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu bi translated">考虑在CI/CD管道中包含强制新更改可用所需的任何缓存清除步骤。</li></ul></div></div>    
</body>
</html>