<html>
<head>
<title>Monitoring sensor data in an Oracle JET Mobile App over WebSocket (Part 2 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过WebSocket监控Oracle JET Mobile应用程序中的传感器数据(第2部分，共2部分)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/monitoring-sensor-data-in-an-oracle-jet-mobile-app-over-websocket-part-2-of-2-d070c867956a?source=collection_archive---------0-----------------------#2017-08-30">https://medium.com/oracledevs/monitoring-sensor-data-in-an-oracle-jet-mobile-app-over-websocket-part-2-of-2-d070c867956a?source=collection_archive---------0-----------------------#2017-08-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="849a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个博客系列的<a class="ae jc" rel="noopener" href="/oracledevs/monitoring-sensor-data-in-jet-mobile-app-over-websockets-part-1-2-f7fa81d9774b">第一部分，我们开发并测试了运行在NodeMCU上的WebSocket服务器，并发送温度传感器数据。现在我们将使用WebSocket Javascript APIs开发一个</a><a class="ae jc" href="https://www.oraclejet.org" rel="noopener ugc nofollow" target="_blank"> Oracle JET </a>移动温度传感器应用程序。</p><p id="1508" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们将在本博客中介绍的应用程序的屏幕截图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/45acc5818051d65cd29daac21b0482eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwLrmURvZOfI0-lis8lCTg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">JET Hybrid Mobile app monitoring live room temperature</figcaption></figure><p id="a646" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">开发客户端Oracle JET混合应用</strong></p><p id="f5d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将从头开始实施，以在oracle jet混合应用程序中实施接收传感器值。</p><p id="5886" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用Yeoman </strong> <br/> <a class="ae jc" href="https://github.com/oracle/generator-oraclejet" rel="noopener ugc nofollow" target="_blank">的项目设置用于<a class="ae jc" href="http://www.oracle.com/webfolder/technetwork/jet/index.html" rel="noopener ugc nofollow" target="_blank"> Oracle JET </a>的Yeoman generator </a>可让您快速设置项目，用作Android和iOS的Web应用程序或移动混合应用程序。使用以下命令为Android生成混合应用程序:</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="a9c3" class="jy jz hh ju b fi ka kb l kc kd">yo oraclejet:hybrid tempsensor — template=navbar — platforms=android</span></pre><p id="6a1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于<em class="ke"> navbar </em>模板的原生混合应用程序代码将放在“tempsensor”文件夹中。更多脚手架选项，请参考<a class="ae jc" href="https://docs.oracle.com/middleware/jet320/jet/developer/GUID-C75CD8DC-5084-4831-BE1A-FFEE4EA8600C.htm#GUID-02F219FA-3060-4949-9755-5363F2BC9D9D" rel="noopener ugc nofollow" target="_blank">此处</a></p><p id="7b7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">实施步骤</strong></p><p id="a105" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦上面的命令成功，这意味着你的应用程序准备好了。转到您的新应用程序目录应用程序，并更新以下内容:</p><p id="7f32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ke">注意:为了便于实施，我们将更新仪表板视图和视图模型</em></p><p id="1897" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="ke"> dashboard.js </em>文件中添加附加模块:</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="5d4c" class="jy jz hh ju b fi ka kb l kc kd">define([‘ojs/ojcore’, ‘knockout’, ‘jquery’, ‘ojs/ojgauge’, ‘ojs/ojbutton’, ‘ojs/ojinputtext’],</span></pre><p id="53a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为<em class="ke"> gaugeValue </em>、<em class="ke"> urlvalue </em>和<em class="ke"> currentstatus </em>添加可观察变量:</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="7f66" class="jy jz hh ju b fi ka kb l kc kd">self.gaugeValue = ko.observable(30);<br/>self.urlvalue = ko.observable(“ws://192.168.43.29:81”);<br/>self.currentStatus = ko.observable(“CLOSED”);</span></pre><p id="9415" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">添加websocket客户端实现:</strong></p><p id="0575" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">WebSocket是用于在客户端和服务器之间建立连续连接流的协议。WebSocket减少了延迟，提高了实时通信的效率，因为它只需要发出一个请求就可以打开一个连接，并在客户端和服务器之间的后续调用中重用同一个连接。</p><p id="0f00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">创建WebSocket对象并注册事件</strong></p><p id="fdd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个webSocket对象，使用WebSocket协议进行通信，并注册各种事件。</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="95f6" class="jy jz hh ju b fi ka kb l kc kd">function getWSUri() {<br/>  return self.urlvalue();<br/>}</span><span id="e0d6" class="jy jz hh ju b fi kf kb l kc kd">function connectSocket() {<br/>  if (‘WebSocket’ in window) {<br/>     websocket = new WebSocket(getWSUri());<br/>     websocket.onmessage = onMessage;<br/>     websocket.onerror = onError;<br/>     websocket.onclose = onClose;<br/>     websocket.onopen = onOpen;<br/>     console.log(‘socket opened !’);<br/>     self.currentStatus(‘WS Opened!’);<br/>  } else {<br/>     console.log(‘websocket not supported…!’);<br/>     self.currentStatus(‘WS not supported’);<br/>  }<br/>}</span><span id="ce8c" class="jy jz hh ju b fi kf kb l kc kd">self.ConnectToWS = function (data, event) {<br/>  connectSocket();<br/>  return true;<br/>};</span></pre><p id="14a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">打开连接</strong></p><p id="b95f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦成功建立连接，套接字就被打开:</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="7b7f" class="jy jz hh ju b fi ka kb l kc kd">function onOpen() {<br/>  console.log(“in onOpen method”);<br/>  self.currentStatus(‘WS Open’);<br/>};</span></pre><p id="d9fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">向服务器发送数据</strong></p><p id="a11e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">打开连接后，开始使用<em class="ke"> send() </em>方法向服务器传输数据</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="2d45" class="jy jz hh ju b fi ka kb l kc kd">self.StartMeasuring = function (data, event) {<br/>  self.handle = setInterval(function (){websocket.send(“temp”);}, 2000);<br/>  return true;<br/>};</span></pre><p id="b2fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从服务器接收消息</strong></p><p id="97e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">WebSocket是一个事件驱动的API当收到消息时，一个“消息”事件被传递给<em class="ke"> onmessage </em>功能</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="0766" class="jy jz hh ju b fi ka kb l kc kd">function onMessage(evt) {<br/>  self.gaugeValue(evt.data);<br/>  console.log(self.gaugeValue());<br/>}</span></pre><p id="5aec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">关闭连接</strong></p><p id="4a39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您完成WebSocket连接后，调用<em class="ke"> close() </em>方法</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="9113" class="jy jz hh ju b fi ka kb l kc kd">// on close event<br/>function onClose(evt) {<br/>  console.log(‘websocket closed :’ + evt.code + “:” + evt.reason);<br/>  self.currentStatus(‘WS closed, status:’ + evt.code);<br/>}</span><span id="798b" class="jy jz hh ju b fi kf kb l kc kd">self.DisconnectToWS = function (data, event) {<br/>  websocket.close();<br/>  return true;<br/>};</span></pre><p id="28d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">接收错误</strong></p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="1350" class="jy jz hh ju b fi ka kb l kc kd">// on error event<br/>function onError(evt) {<br/>  console.log(‘error :’ + evt);<br/>  self.currentStatus(‘error :’ + evt);<br/>}</span></pre><p id="f093" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">添加停止从服务器接收数据的功能</p><pre class="je jf jg jh fd jt ju jv jw aw jx bi"><span id="3766" class="jy jz hh ju b fi ka kb l kc kd">self.StopMeasuring = function (data, event) {<br/>clearInterval(self.handle);<br/> self.handle = 0;<br/> return true;<br/> };</span></pre><p id="ed5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，更新<em class="ke">dashboard.html</em>代码渲染UI:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kg"><img src="../Images/d840bfe9a01321a65834b7ea7b606899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJ2FNlWEP4jeTKy_P7QSJQ.png"/></div></div></figure><p id="84f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">在Android设备上构建并运行应用程序</strong> <br/>在您的命令提示符下，请将目录更改为项目文件夹</p><p id="6712" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用以下命令构建应用程序:<br/><strong class="ig hi"><em class="ke">grunt build—platform = Android</em></strong><br/><br/>一旦构建成功，则使用以下命令运行应用程序:<br/><strong class="ig hi"><em class="ke">grunt serve—platform = Android—disable livereload = true</em></strong></p><p id="ca16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">演示输出:</strong></p><p id="26fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，节点MCU和移动设备应该在同一个网络后面，这样它们应该能够相互连接</p><p id="23ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> WebSocket服务器</strong></p><p id="4a9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请在您的NodeMCU硬件上运行上一篇博客中显示的web-socket服务器:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/0d9bf60584b271ffbe4edc314ab81074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmMNhyZ9rjH__q48YBoq6Q.jpeg"/></div></div></figure><p id="c97c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">串行监视器</strong></p><p id="133c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">打开串行监视器查看分配给WebSocket服务器的IP地址。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/47e97655955a38ce8306aabbab1a5c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs_Ob1lslB9BkV1XSgqVXg.png"/></div></div></figure><p id="bdbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> JET混合动力移动温度传感器应用</strong></p><p id="0877" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以ws://IP_ADDRESS_ASSIGNED:PORT格式连接到WebSocket服务器地址，并开始监控温度数据！下面是该应用程序的一个小视频演示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kj kk l"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Temperature Sensor App (WebSocket client)</figcaption></figure><blockquote class="kl km kn"><p id="799e" class="ie if ke ig b ih ii ij ik il im in io ko iq ir is kp iu iv iw kq iy iz ja jb ha bi translated">本文表达的观点是我个人的观点，不一定代表甲骨文的观点。</p></blockquote></div></div>    
</body>
</html>