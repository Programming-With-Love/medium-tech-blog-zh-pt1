<html>
<head>
<title>7 Pro-tips for Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间的7个小贴士</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/7-pro-tips-for-room-fbadea4bfbd1?source=collection_archive---------0-----------------------#2017-11-02">https://medium.com/androiddevelopers/7-pro-tips-for-room-fbadea4bfbd1?source=collection_archive---------0-----------------------#2017-11-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0d56fe8d240d547db97de65e47033b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSCC_nLOSp1VJ6wXeANgCQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><a class="ae hu" href="https://unsplash.com/photos/PaFUKopuirM" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><div class=""/><p id="c4f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Room 是SQLite之上的一个抽象层，它使持久化数据变得更容易、更好。如果你是新来的，看看这本入门书:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/google-developers/7-steps-to-room-27a5fe5f99b2"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">7步到房间</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">如何将您的应用程序迁移到Room的分步指南</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><p id="48bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我想分享一些关于充分利用房间的专业建议:</p><ul class=""><li id="a6b6" class="kh ki hx iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><a class="ae hu" href="#4785" rel="noopener ugc nofollow">通过</a> <code class="du kq kr ks kt b"><a class="ae hu" href="#4785" rel="noopener ugc nofollow">RoomDatabase#Callback</a></code>预先填充您的数据库</li><li id="3cbe" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#dd40" rel="noopener ugc nofollow">使用刀的继承能力</a></li><li id="1a53" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#026b" rel="noopener ugc nofollow">通过</a> <code class="du kq kr ks kt b"><a class="ae hu" href="#026b" rel="noopener ugc nofollow">@Transaction</a></code>用最少的样板代码在交易中执行查询</li><li id="63e0" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#829a" rel="noopener ugc nofollow">只读您需要的内容</a></li><li id="4430" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#3e94" rel="noopener ugc nofollow">在具有外键的实体之间实施约束</a></li><li id="041f" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#4f14" rel="noopener ugc nofollow">通过</a> <code class="du kq kr ks kt b"><a class="ae hu" href="#4f14" rel="noopener ugc nofollow">@Relation</a></code>简化一对多查询</li><li id="1dda" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated"><a class="ae hu" href="#5e38" rel="noopener ugc nofollow">避免可观察查询的误报通知</a></li></ul><h1 id="4785" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.预填充数据库</h1><p id="caf0" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">您是否需要在创建数据库后或打开数据库时向数据库中添加默认数据？使用<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.Callback.html" rel="noopener ugc nofollow" target="_blank">RoomDatabase#Callback</a></code>！构建房间数据库时调用<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.Builder.html#addCallback(android.arch.persistence.room.RoomDatabase.Callback)" rel="noopener ugc nofollow" target="_blank">addCallback</a></code>方法，并覆盖<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.Callback.html#onCreate(android.arch.persistence.db.SupportSQLiteDatabase)" rel="noopener ugc nofollow" target="_blank">onCreate</a></code>或<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.Callback.html#onOpen(android.arch.persistence.db.SupportSQLiteDatabase)" rel="noopener ugc nofollow" target="_blank">onOpen</a></code>。</p><p id="c384" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在创建表之后，第一次创建数据库时，将调用<code class="du kq kr ks kt b">onCreate</code>。<code class="du kq kr ks kt b">onOpen</code>在数据库打开时被调用。因为DAO只能在这些方法返回后才能被访问，所以我们创建了一个新的线程，在这个线程中我们获取对数据库的引用，获取DAO，然后插入数据。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="e645" class="mk la hx kt b fi ml mm l mn mo">Room.databaseBuilder(context.<em class="mp">applicationContext</em>,<br/>        DataDatabase::class.java, "Sample.db")<br/>        // prepopulate the database after onCreate was called<br/>        .addCallback(object : <strong class="kt hy">Callback</strong>() {<br/>            override fun <strong class="kt hy">onCreate</strong>(db: SupportSQLiteDatabase) {<br/>                super.onCreate(db)<br/>                // moving to a new thread<br/>                <em class="mp">ioThread </em>{<br/>                    getInstance(context).dataDao()<br/>                                        .insert(PREPOPULATE_DATA)<br/>                }<strong class="kt hy"><br/>            </strong>}<br/>        })<br/>        .build()</span></pre><p id="53c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看完整示例<a class="ae hu" href="https://gist.github.com/florina-muntenescu/697e543652b03d3d2a06703f5d6b44b5" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="2fb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意</strong>:当使用<code class="du kq kr ks kt b">ioThread</code>方法时，如果你的应用在第一次启动时崩溃，在数据库创建和插入之间，数据将永远不会被插入。</p><h1 id="dd40" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.使用DAO的继承功能</h1><p id="65be" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">您的数据库中有多个表，并且发现自己复制了相同的<code class="du kq kr ks kt b">Insert</code>、<code class="du kq kr ks kt b">Update</code>和<code class="du kq kr ks kt b">Delete</code>方法吗？Dao支持继承，所以创建一个<code class="du kq kr ks kt b"> BaseDao&lt;T&gt; </code>类，并在那里定义你的泛型<code class="du kq kr ks kt b">@Insert</code>、<code class="du kq kr ks kt b">@Update</code>和<code class="du kq kr ks kt b">@Delete</code>方法。让每个DAO扩展<code class="du kq kr ks kt b">BaseDao</code>并添加特定于它们的方法。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="7a9e" class="mk la hx kt b fi ml mm l mn mo">interface BaseDao&lt;T&gt; {<br/><em class="mp">    </em>@Insert<br/>    fun insert(vararg obj: T)<br/>}</span><span id="8720" class="mk la hx kt b fi mq mm l mn mo">@Dao<br/>abstract class DataDao : BaseDao&lt;Data&gt;() {<br/><em class="mp">    </em>@Query("SELECT * FROM Data")<br/>    abstract fun getData(): List&lt;Data&gt;<br/>}</span></pre><p id="aae6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">点击查看更多详情<a class="ae hu" href="https://gist.github.com/florina-muntenescu/1c78858f286d196d545c038a71a3e864" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e3ed" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dao必须是接口或抽象类，因为Room在编译时生成它们的实现，包括来自<code class="du kq kr ks kt b">BaseDao</code>的方法。</p><h1 id="026b" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3.用最少的样板代码在事务中执行查询</h1><p id="b81e" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">用<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Transaction.html" rel="noopener ugc nofollow" target="_blank">@Transaction</a></code>注释方法可以确保在该方法中执行的所有数据库操作都将在一个事务中运行。当方法体中引发异常时，事务将失败。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="8422" class="mk la hx kt b fi ml mm l mn mo">@Dao<br/>abstract class UserDao {<br/>    <br/>    @Transaction<br/>    open fun updateData(users: List&lt;User&gt;) {<br/>        deleteAllUsers()<br/>        insertAll(users)<br/>    }</span><span id="340d" class="mk la hx kt b fi mq mm l mn mo">    @Insert<br/>    abstract fun insertAll(users: List&lt;User&gt;)</span><span id="56d9" class="mk la hx kt b fi mq mm l mn mo">    @Query("DELETE FROM Users")<br/>    abstract fun deleteAllUsers()<br/>}</span></pre><p id="ab33" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下列情况下，您可能希望对具有select语句的<code class="du kq kr ks kt b">@Query</code>方法使用<code class="du kq kr ks kt b">@Transaction</code>注释:</p><ul class=""><li id="1aa9" class="kh ki hx iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">当查询结果相当大时。通过在一个事务中查询数据库，您可以确保如果查询结果不适合单个游标窗口，它不会由于数据库在<a class="ae hu" rel="noopener" href="/google-developers/large-database-queries-on-android-cb043ae626e8">游标窗口交换</a>之间的变化而被破坏。</li><li id="d770" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr km kn ko kp bi translated">当查询结果是带有<code class="du kq kr ks kt b">@Relation</code>字段的POJO时。这些字段是单独的查询，因此在单个事务中运行它们将保证查询之间的结果一致。</li></ul><p id="9ce9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">具有多个参数的<code class="du kq kr ks kt b">@Delete</code>、<code class="du kq kr ks kt b">@Update</code>和<code class="du kq kr ks kt b">@Insert</code>方法在一个事务内部自动运行。</p><h1 id="829a" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">4.只读你需要的东西</h1><p id="1c6b" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">当您查询数据库时，是否使用了查询中返回的所有字段？注意你的应用程序使用的<strong class="iw hy">内存</strong>的数量，只加载你最终会用到的字段的子集。这也将通过降低IO成本来提高查询的速度。Room将为您进行列和对象之间的映射。</p><p id="e5ba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑一下这个复杂的<code class="du kq kr ks kt b">User</code>物体:</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="58d1" class="mk la hx kt b fi ml mm l mn mo">@Entity(tableName = "users")<br/>data class User(@PrimaryKey<br/>                val id: String,<br/>                val userName: String,<br/>                val firstName: String, <br/>                val lastName: String,<br/>                val email: String,<br/>                val dateOfBirth: Date, <br/>                val registrationDate: Date)</span></pre><p id="5cf2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在某些屏幕上，我们不需要显示所有这些信息。因此，我们可以创建一个只保存所需数据的<code class="du kq kr ks kt b">UserMinimal</code>对象。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="5ab0" class="mk la hx kt b fi ml mm l mn mo">data class UserMinimal(val userId: String,<br/>                       val firstName: String, <br/>                       val lastName: String)</span></pre><p id="c8f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在DAO类中，我们定义查询并从users表中选择正确的列。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="5a8f" class="mk la hx kt b fi ml mm l mn mo">@Dao<br/>interface UserDao {<br/>    @Query(“SELECT userId, firstName, lastName FROM Users)<br/>    fun getUsersMinimal(): List&lt;UserMinimal&gt;<br/>}</span></pre><h1 id="3e94" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">5.在具有外键的实体之间实施约束</h1><p id="a3b5" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">尽管Room<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html#no-object-references" rel="noopener ugc nofollow" target="_blank">不直接支持关系</a>，但它允许您定义实体之间的外键约束。</p><p id="1faa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">房间有<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/ForeignKey.html" rel="noopener ugc nofollow" target="_blank">@ForeignKey</a></code>注释，是<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Entity.html" rel="noopener ugc nofollow" target="_blank">@Entity</a></code>注释的一部分，允许使用<a class="ae hu" href="https://sqlite.org/foreignkeys.html" rel="noopener ugc nofollow" target="_blank"> SQLite外键</a>特性。它跨表实施约束，以确保在修改数据库时关系有效。在实体上，定义要引用的父实体、父实体中的列和当前实体中的列。</p><p id="4a7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑一个<code class="du kq kr ks kt b">User</code>和一个<code class="du kq kr ks kt b">Pet</code>类。<code class="du kq kr ks kt b">Pet</code>有一个所有者，它是作为外键引用的用户id。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="96b2" class="mk la hx kt b fi ml mm l mn mo">@Entity(tableName = "pets",<br/>        foreignKeys = <em class="mp">arrayOf</em>(<br/>            ForeignKey(entity = User::class,<br/>                       parentColumns = <em class="mp">arrayOf</em>("userId"),<br/>                       childColumns = <em class="mp">arrayOf</em>("owner"))))<br/>data class Pet(@PrimaryKey val petId: String,<br/>              val name: String,<br/>              val owner: String)</span></pre><p id="4ba1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者，您可以定义在数据库中删除或更新父实体时要采取的操作。您可以从以下选项中选择一个:<code class="du kq kr ks kt b">NO_ACTION</code>、<code class="du kq kr ks kt b">RESTRICT</code>、<code class="du kq kr ks kt b">SET_NULL</code>、<code class="du kq kr ks kt b">SET_DEFAULT</code>或<code class="du kq kr ks kt b">CASCADE</code>，其行为与<a class="ae hu" href="https://sqlite.org/foreignkeys.html#fk_actions" rel="noopener ugc nofollow" target="_blank"> SQLite </a>中的行为相同。</p><p id="68b5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注</strong>:在Room中，<code class="du kq kr ks kt b">SET_DEFAULT</code>作为<code class="du kq kr ks kt b">SET_NULL</code>使用，因为Room还不允许设置列的默认值。</p><h1 id="4f14" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">6.通过<code class="du kq kr ks kt b">@Relation</code>简化一对多查询</h1><p id="8b1e" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">在前面的<code class="du kq kr ks kt b">User</code> - <code class="du kq kr ks kt b">Pet</code>例子中，我们可以说我们有一个<strong class="iw hy">一对多关系</strong>:一个用户可以有多个宠物。假设我们想获得一个用户及其宠物的列表:<code class="du kq kr ks kt b">List&lt;UserAndAllPets&gt;</code>。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="4ca6" class="mk la hx kt b fi ml mm l mn mo">data class UserAndAllPets (val user: User,<br/>                           val pets: List&lt;Pet&gt; = ArrayList())</span></pre><p id="4a8b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要手动完成这项工作，我们需要实现两个查询:一个获取所有用户的列表，另一个获取基于用户id的宠物列表。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="22f8" class="mk la hx kt b fi ml mm l mn mo">@Query(“SELECT * FROM Users”)<br/>public List&lt;User&gt; getUsers();</span><span id="6453" class="mk la hx kt b fi mq mm l mn mo">@Query(“SELECT * FROM Pets where owner = :userId”)<br/>public List&lt;Pet&gt; getPetsForUser(String userId);</span></pre><p id="d934" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们将遍历用户列表并查询Pets表。</p><p id="cf7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更简单，Room的<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Relation.html" rel="noopener ugc nofollow" target="_blank">@Relation</a></code>注释自动获取相关实体。<code class="du kq kr ks kt b">@Relation</code>只能应用于<code class="du kq kr ks kt b">List</code>或<code class="du kq kr ks kt b">Set</code>的对象。<code class="du kq kr ks kt b">UserAndAllPets</code>类必须更新:</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="fc6b" class="mk la hx kt b fi ml mm l mn mo">class UserAndAllPets {</span><span id="45de" class="mk la hx kt b fi mq mm l mn mo">   @Embedded<br/>   var user: User? = null</span><span id="066d" class="mk la hx kt b fi mq mm l mn mo">   @Relation(parentColumn = “userId”,<br/>             entityColumn = “owner”)<br/>   var pets: List&lt;Pet&gt; = ArrayList()</span><span id="433d" class="mk la hx kt b fi mq mm l mn mo">}</span></pre><p id="3335" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在DAO中，我们定义了一个查询，Room将查询<code class="du kq kr ks kt b">Users</code>和<code class="du kq kr ks kt b">Pets</code>表，并处理对象映射。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="14fa" class="mk la hx kt b fi ml mm l mn mo">@Transaction<br/>@Query(“SELECT * FROM Users”)<br/>List&lt;UserAndAllPets&gt; getUsers();</span></pre><h1 id="5e38" class="kz la hx bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">7.避免可观察查询的误报通知</h1><p id="5849" class="pw-post-body-paragraph iu iv hx iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr ha bi translated">假设您想在一个可观察的查询中基于用户id获得一个用户:</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="49d8" class="mk la hx kt b fi ml mm l mn mo">@Query(“SELECT * FROM Users WHERE userId = :id)<br/>fun getUserById(id: String): LiveData&lt;User&gt;</span><span id="a355" class="mk la hx kt b fi mq mm l mn mo">// or</span><span id="e6aa" class="mk la hx kt b fi mq mm l mn mo">@Query(“SELECT * FROM Users WHERE userId = :id)<br/>fun getUserById(id: String): Flowable&lt;User&gt;</span></pre><p id="c976" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当用户更新时，您将获得一个新的<code class="du kq kr ks kt b">User</code>对象的发射。但是当<code class="du kq kr ks kt b">Users</code>表上发生与您感兴趣的<code class="du kq kr ks kt b">User</code>无关的其他更改(删除、更新或插入)时，您也将获得相同的对象，从而导致误报通知。更重要的是，如果您的查询涉及多个表，那么只要其中任何一个表发生了变化，您就会得到一个新的发射。</p><p id="e635" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是幕后发生的事情:</p><ol class=""><li id="4d5d" class="kh ki hx iw b ix iy jb jc jf kj jj kk jn kl jr mr kn ko kp bi translated">SQLite支持每当表中发生<code class="du kq kr ks kt b">DELETE</code>、<code class="du kq kr ks kt b">UPDATE</code>或<code class="du kq kr ks kt b">INSERT</code>时触发的<a class="ae hu" href="https://sqlite.org/lang_createtrigger.html" rel="noopener ugc nofollow" target="_blank">触发器</a>。</li><li id="3733" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr mr kn ko kp bi translated">Room创建了一个<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/InvalidationTracker.html" rel="noopener ugc nofollow" target="_blank">InvalidationTracker</a></code>，它使用<code class="du kq kr ks kt b">Observers</code>来跟踪观察到的表中的任何变化。</li><li id="d734" class="kh ki hx iw b ix ku jb kv jf kw jj kx jn ky jr mr kn ko kp bi translated"><code class="du kq kr ks kt b">LiveData</code>和<code class="du kq kr ks kt b">Flowable</code>查询都依赖于<code class="du kq kr ks kt b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/InvalidationTracker.Observer.html#onInvalidated(java.util.Set&lt;java.lang.String&gt;)" rel="noopener ugc nofollow" target="_blank">InvalidationTracker.Observer#onInvalidated</a></code>通知。当接收到此消息时，它会触发重新查询。</li></ol><p id="fcd0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">房间只知道桌子被修改过，但<strong class="iw hy">不知道</strong>和<strong class="iw hy">为什么</strong>变了。因此，在重新查询之后，查询的结果由<code class="du kq kr ks kt b">LiveData</code>或<code class="du kq kr ks kt b">Flowable</code>发出。由于Room在内存中不保存任何数据，也不能假设对象有<code class="du kq kr ks kt b">equals()</code>，所以它无法判断这是否是相同的数据。</p><p id="4651" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你需要确保你的DAO <strong class="iw hy">过滤发射</strong>并且只对不同的物体做出反应。</p><p id="b959" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果使用<code class="du kq kr ks kt b">Flowables</code>实现可观察查询，则使用<code class="du kq kr ks kt b"><a class="ae hu" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#distinctUntilChanged--" rel="noopener ugc nofollow" target="_blank">Flowable#distinctUntilChanged</a></code>。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="cd30" class="mk la hx kt b fi ml mm l mn mo">@Dao</span><span id="b2eb" class="mk la hx kt b fi mq mm l mn mo">abstract class UserDao : BaseDao&lt;User&gt;() {</span><span id="f3eb" class="mk la hx kt b fi mq mm l mn mo">/**<br/>* Get a user by id.<br/>* @return the user from the table with a specific id.<br/>*/</span><span id="1e68" class="mk la hx kt b fi mq mm l mn mo">@Query(“SELECT * FROM Users WHERE userid = :id”)<br/>protected abstract fun getUserById(id: String): Flowable&lt;User&gt;</span><span id="696d" class="mk la hx kt b fi mq mm l mn mo">fun getDistinctUserById(id: String): <br/>   Flowable&lt;User&gt; = getUserById(id)<br/>                          .distinctUntilChanged()</span><span id="23ad" class="mk la hx kt b fi mq mm l mn mo">}</span></pre><p id="4954" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您的查询返回一个<code class="du kq kr ks kt b">LiveData</code>，您可以使用一个<code class="du kq kr ks kt b">MediatorLiveData</code>，它只允许来自一个源的不同对象发射。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="3514" class="mk la hx kt b fi ml mm l mn mo">fun &lt;T&gt; LiveData&lt;T&gt;.getDistinct(): LiveData&lt;T&gt; {<br/>    val distinctLiveData = MediatorLiveData&lt;T&gt;()<br/>    distinctLiveData.addSource(this, object : Observer&lt;T&gt; {<br/>        private var initialized = false<br/>        private var lastObj: T? = null</span><span id="c41b" class="mk la hx kt b fi mq mm l mn mo">        override fun onChanged(obj: T?) {<br/>            if (!initialized) {<br/>                initialized = true<br/>                lastObj = obj<br/>                distinctLiveData.postValue(lastObj)<br/>            } else if ((obj == null &amp;&amp; lastObj != null) <br/>                       || obj != lastObj) {<br/>                lastObj = obj<br/>                distinctLiveData.postValue(lastObj)<br/>            }<br/>        }<br/>    })</span><span id="3039" class="mk la hx kt b fi mq mm l mn mo">    return distinctLiveData<br/>}</span></pre><p id="716a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您的DAOs中，使用返回distinct <code class="du kq kr ks kt b">LiveData</code> <code class="du kq kr ks kt b">public</code>的方法和查询数据库<code class="du kq kr ks kt b">protected</code>的方法。</p><pre class="mc md me mf fd mg kt mh mi aw mj bi"><span id="8e28" class="mk la hx kt b fi ml mm l mn mo">@Dao<br/>abstract class UserDao : BaseDao&lt;User&gt;() {</span><span id="db62" class="mk la hx kt b fi mq mm l mn mo">@Query(“SELECT * FROM Users WHERE userid = :id”)<br/>   protected abstract fun getUserById(id: String): LiveData&lt;User&gt;</span><span id="c3b1" class="mk la hx kt b fi mq mm l mn mo">fun getDistinctUserById(id: String): <br/>         LiveData&lt;User&gt; = getUserById(id).getDistinct()</span><span id="cd05" class="mk la hx kt b fi mq mm l mn mo">}</span></pre><p id="c92c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">点击查看更多代码<a class="ae hu" href="https://gist.github.com/florina-muntenescu/fea9431d0151ce0afd2f5a0b8834a6c7" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="65c6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意</strong>:如果你要返回一个要显示的列表，考虑使用<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页库</a>并返回一个<a class="ae hu" href="https://developer.android.com/reference/android/arch/paging/LivePagedListProvider.html" rel="noopener ugc nofollow" target="_blank"> LivePagedListBuilder </a>，因为这个库将帮助自动计算列表项之间的差异并更新你的UI。</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="e8e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">新来的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank">室</a>？查看我们以前的文章:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/google-developers/7-steps-to-room-27a5fe5f99b2"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">7步到房间</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">如何将您的应用程序迁移到Room的分步指南</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/google-developers/room-rxjava-acb0cd4f3757"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">房间🔗RxJava</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">使用RxJava在房间中进行查询</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="mz l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/google-developers/understanding-migrations-with-room-f01e04b07929"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">了解迁移与空间</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">用SQLite API执行数据库迁移总是让我感觉像是在拆除一颗炸弹——好像我就是一颗…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="na l kd ke kf kb kg ho js"/></div></div></a></div></div></div>    
</body>
</html>