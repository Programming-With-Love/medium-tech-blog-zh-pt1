<html>
<head>
<title>setState() Gate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">setState()门</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82?source=collection_archive---------1-----------------------#2017-03-19">https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82?source=collection_archive---------1-----------------------#2017-03-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="fc9d" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">导航React setState()行为混乱</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/04066cdb1f84778247041564c6e1865a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*YvimnE7n9gk2Oesw_Dmxhg.jpeg"/></div></figure><p id="53b5" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一切都是从上周开始的。3名不同的React学习者在项目中尝试使用<code class="du ka kb kc kd b">setState()</code>时遇到了3种不同的障碍。我经常指导新的React用户，并向从其他架构过渡到React的团队提供咨询。</p><p id="e60e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">其中一个学员正在做一个非常适合Redux的产品项目，所以我建议我们用Redux代替<code class="du ka kb kc kd b">setState()</code>,这样可以从绘制DOM的组件中移除状态更新的时间，而不是解决如何用<code class="du ka kb kc kd b">setState()</code>来固定时间。然后，该模块只需根据商店中的道具来决定要呈现什么，时间复杂度被神奇地避开了。</p><p id="9a22" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">激发了这条推特:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">“React has a setState() problem: Asking newbies to use setState() is a recipe for headaches. Advanced users have learned to avoid it. ;)</figcaption></figure><p id="9b61" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">之后，一些高级用户插话纠正我:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">“React team member checking in. Please learn to use setState before other approaches.”</figcaption></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">“Those ‘adanced’ users will get left behind when we turn on async scheduling by default in React 17”</figcaption></figure><p id="48e6" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">关于第二点:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">“Fiber has a strategy for pausing, splitting, rebasing, aborting updates that doesn’t work if you deviate from component state”</figcaption></figure><p id="a87c" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">两者都有道理。其他人创造了迷因:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/04066cdb1f84778247041564c6e1865a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*YvimnE7n9gk2Oesw_Dmxhg.jpeg"/></div></figure><p id="c02e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">取笑令人沮丧的情况很好，但我们不要假装没有问题。</p><p id="6c19" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在我与另一位学员的下一次会面中，<em class="kk">他也对<code class="du ka kb kc kd b">setState()</code>的工作方式感到困惑</em>，并且已经放弃了，将他的状态填充到一个闭包中，当然，如果闭包状态改变，它不会自动触发渲染。</p><p id="f55b" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">鉴于<em class="kk">不断涌入</em>困惑的React新手，我袖手旁观了我推文的第一部分，但如果我有机会再做一次，我会稍微修改第二部分<em class="kk">，</em>因为一些高级用户(特别是许多脸书和网飞用户)广泛使用<code class="du ka kb kc kd b">setState()</code>:</p><blockquote class="kl"><p id="d339" class="km kn hh bd ko kp kq kr ks kt ku jz dx translated">React有一个setState()问题:要求新手使用setState()是一个令人头疼的问题。高级用户有秘方。”</p></blockquote><p id="78e0" class="pw-post-body-paragraph je jf hh jg b jh kv ii jj jk kw il jm jn kx jp jq jr ky jt ju jv kz jx jy jz ha bi translated">当然，Twitter可能仍然会失去它的集体意识。毕竟React是<em class="kk">完美的</em>，我们都必须认同<code class="du ka kb kc kd b">setState()</code>本来就很美，否则就要面对嘲笑和鄙视。</p><p id="b594" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果<code class="du ka kb kc kd b">setState()</code>让你困惑，那是<em class="kk">你的错。你一定是疯了或傻了。(我有没有提到过<a class="ae la" rel="noopener" href="/javascript-scene/the-js-community-has-a-bullying-problem-96c10f11c85d#.wagjqz54o">JavaScript社区存在欺凌问题？</a>)</em></p><p id="3353" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让我们检查一下我们的自我，不要再为我们的精通而沾沾自喜，同时嘲笑每一个没有学到同样课程的人。</p><p id="cb7f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这种行为是荒谬的，精英主义的，对新来者非常没有吸引力。如果人们经常对API感到困惑，这可能是一个改进API的机会，或者至少是改进文档的机会。</p><p id="1ba0" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让社区和我们的工具变得更加友好和有吸引力对每个人都有好处。</p><h1 id="2e82" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">setState()怎么了？</h1><p id="6750" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">这个问题有两个答案:</p><ol class=""><li id="da47" class="ly lz hh jg b jh ji jk jl jn ma jr mb jv mc jz md me mf mg bi translated">不多。它(大部分)表现得像是需要解决它被设计来解决的问题。</li><li id="c260" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz md me mf mg bi translated">学习曲线。刚接触React和<code class="du ka kb kc kd b">setState()</code>的用户在尝试做<em class="kk">用普通JS和直接DOM操作就能完成的事情时经常会遇到障碍。</em></li></ol><p id="9043" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">React旨在简化应用程序的构建，但是:</p><ul class=""><li id="c73e" class="ly lz hh jg b jh ji jk jl jn ma jr mb jv mc jz mm me mf mg bi translated">你不能随便抓取一些DOM并以你喜欢的方式更新它们。</li><li id="676d" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">你不能在任何时候把状态设置成任何东西，取决于你喜欢的任何数据源。</li><li id="7444" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">在组件生命周期的任何阶段，您都不能只观察屏幕上呈现的DOM或元素的可见性，这限制了您何时以及如何使用<code class="du ka kb kc kd b">setState()</code>呈现依赖状态(您正在处理的状态可能还没有呈现到屏幕上)。</li></ul><p id="d2da" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在所有这些情况下，混淆都是由React组件生命周期的<em class="kk">(故意的，好的)</em>限制造成的。</p><h2 id="84f0" class="mn lc hh bd ld mo mp mq lh mr ms mt ll jn mu mv ln jr mw mx lp jv my mz lr na bi translated">从属状态</h2><p id="bdbe" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">当我们更新状态时，有时更新的值取决于React试图帮助我们的事情:</p><ul class=""><li id="26c8" class="ly lz hh jg b jh ji jk jl jn ma jr mb jv mc jz mm me mf mg bi translated">当前状态</li><li id="a6e5" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">同一周期中先前更新状态的尝试</li><li id="ab74" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">呈现的DOM(例如，组件坐标、可见性、计算的CSS值等)</li></ul><p id="8107" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当您有这些依赖状态时，如果您试图以一种简单的方式更新状态，React的行为可能会以一种令人讨厌的难以调试的方式让您吃惊。通常，无论你尝试做什么，都不会奏效。您将得到不正确的状态，或者您将在控制台中看到一个错误。</p><p id="119e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我对<code class="du ka kb kc kd b">setState()</code>的不满在于，它的限制性行为在API文档中对新手来说并不明显，而且处理其限制性行为的通用模式也没有得到很好的解释。这迫使用户求助于试错法、谷歌和其他社区成员的帮助，而在<code class="du ka kb kc kd b">setState()</code>和它的API文档中可以有更好的指南。</p><blockquote class="nb nc nd"><p id="38d4" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated"><strong class="jg hi">更新:</strong><br/><a class="ae la" href="https://github.com/facebook/react/pull/9329" rel="noopener ugc nofollow" target="_blank">API文档已经更新</a>，试图更好地解释<code class="du ka kb kc kd b">setState()</code>行为。以下引用了该文档的旧版本。</p></blockquote><p id="e37b" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当前的<code class="du ka kb kc kd b">setState()</code>API文档以此开头:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="88ef" class="mn lc hh kd b fi nl nm l nn no">setState(nextState, callback)</span></pre><blockquote class="nb nc nd"><p id="a948" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated">执行nextState到当前状态的浅层合并。这是从事件处理程序和服务器请求回调触发UI更新的主要方法。</p></blockquote><p id="b647" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">它在结尾非常简短地提到了它具有异步行为:</p><blockquote class="nb nc nd"><p id="0934" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated">不能保证对<code class="du ka kb kc kd b">setState</code>调用的同步操作，调用可能会被批量处理以提高性能。</p></blockquote><p id="f700" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这两种情况的综合结果是许多用户域错误的根源:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="fcfc" class="mn lc hh kd b fi nl nm l nn no">// assuming state.count === 0<br/>this.setState({count: state.count + 1});<br/>this.setState({count: state.count + 1});<br/>this.setState({count: state.count + 1});<br/>// state.count === 1, not 3</span></pre><p id="0067" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">它本质上相当于:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="271a" class="mn lc hh kd b fi nl nm l nn no">Object.assign(state,<br/>  {count: state.count + 1},<br/>  {count: state.count + 1},<br/>  {count: state.count + 1}<br/>); // {count: 1}</span></pre><p id="7f85" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">API文档中没有明确提到这一点(在专门指南的其他地方有所涉及)。</p><p id="81c9" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">API文档还提到了一个替代<code class="du ka kb kc kd b">setState()</code>签名的函数:</p><blockquote class="nb nc nd"><p id="05b6" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated">也可以传递带有签名<code class="du ka kb kc kd b">function(state, props) =&gt; newState</code>的函数。这使原子更新排队，该原子更新在设置任何值之前参考state和props的先前值。</p><p id="940b" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated"><code class="du ka kb kc kd b">...</code></p><p id="fb54" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated"><code class="du ka kb kc kd b">setState()</code>不会立即变异<code class="du ka kb kc kd b">this.state</code>，而是创建一个待定状态转换。在调用此方法后访问<code class="du ka kb kc kd b">this.state</code>可能会返回现有值。</p></blockquote><p id="0750" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">API文档删除了一些面包屑，但它们并没有真正解释新手经常遇到的行为，从而清楚地将读者引导到正确的道路上，尽管React以在dev模式下生成有用的错误而闻名，但当<code class="du ka kb kc kd b">setState()</code>计时错误突然出现时，不会记录这样的警告。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="963a" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">生命周期时间问题是StackOverflow上关于<code class="du ka kb kc kd b">setState()</code>的很多问题的原因。当然React很受欢迎，所以那些问题被<a class="ae la" href="http://stackoverflow.com/questions/25996891/react-js-understanding-setstate" rel="noopener ugc nofollow" target="_blank">问了</a> <a class="ae la" href="http://stackoverflow.com/questions/35248748/calling-setstate-in-a-loop-only-updates-state-1-time" rel="noopener ugc nofollow" target="_blank">很多</a> <a class="ae la" href="http://stackoverflow.com/questions/30338577/reactjs-concurrent-setstate-race-condition/30341560#30341560" rel="noopener ugc nofollow" target="_blank">次</a>，有各种质量和正确性的答案。</p><p id="7b42" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">那么新手如何才能学会管理<code class="du ka kb kc kd b">setState()</code>时机问题的正确方法呢？</p><p id="262f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在名为<a class="ae la" href="https://facebook.github.io/react/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">“状态和生命周期”</a>的React文档中有更深入的信息:</p><blockquote class="nb nc nd"><p id="8db4" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated">“…要解决这个问题，请使用第二种形式的<code class="du ka kb kc kd b">setState()</code>，它接受函数而不是对象。该函数将接收以前的状态作为第一个参数，应用更新时的属性作为第二个参数:"</p></blockquote><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="eba7" class="mn lc hh kd b fi nl nm l nn no">// Correct<br/>this.setState((prevState, props) =&gt; ({<br/>  count: prevState.count + props.increment<br/>}));</span></pre><p id="13ba" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这种函数-参数形式(有时称为“函数型<code class="du ka kb kc kd b">setState()</code>”)的工作方式更像这样:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="f9ec" class="mn lc hh kd b fi nl nm l nn no">[<br/>  {increment: 1},<br/>  {increment: 1},<br/>  {increment: 1}<br/>].reduce(<!-- -->(prevState, props) =&gt; ({<br/>  count: prevState.count + props.increment<br/>}), {count: 0}); // {count: 3}</span></pre><p id="48ce" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">不确定reduce如何工作？参见<a class="ae la" rel="noopener" href="/javascript-scene/the-rise-and-fall-and-rise-of-functional-programming-composable-software-c2d91b424c8c#.7k9w6v9ok">【排版软件】</a>中的<a class="ae la" rel="noopener" href="/javascript-scene/reduce-composing-software-fe22f0c39a1d#.8d8kw0l40">【缩小】</a>。</p><p id="86d7" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">关键是<strong class="jg hi">更新函数</strong>:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="5d17" class="mn lc hh kd b fi nl nm l nn no">(prevState, props) =&gt; ({<br/>  count: prevState.count + props.increment<br/>})</span></pre><p id="aaa2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这基本上是一个缩减器，其中<code class="du ka kb kc kd b">prevState</code>充当累加器，<code class="du ka kb kc kd b">props</code>充当新更新数据的来源。像Redux的reducer一样，您可以使用任何标准的reduce实用程序(包括<code class="du ka kb kc kd b">Array.prototype.reduce()</code>)通过这个函数进行reduce。也和Redux一样，减速器应该是一个<a class="ae la" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">纯函数</a>。</p><blockquote class="nb nc nd"><p id="c0ea" class="je jf kk jg b jh ji ii jj jk jl il jm ne jo jp jq nf js jt ju ng jw jx jy jz ha bi translated">注意:试图直接变异<code class="du ka kb kc kd b">prevState</code>是新用户常见的困惑来源。</p></blockquote><p id="9e64" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">API文档中没有提到updater函数的这些属性和期望，所以偶然发现函数式的<code class="du ka kb kc kd b">setState()</code>形式做了一些对象字面形式不支持的有用的事情的少数幸运的新手可能仍然会感到困惑。</p><h1 id="724f" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">只是新手问题？</h1><p id="9754" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">当我处理表单或DOM元素坐标时，我仍然会不时碰到粗糙的边缘，因为当您使用<code class="du ka kb kc kd b">setState()</code>时，您必须直接处理组件生命周期。当您使用容器组件或存储并通过props传递状态时，React会为您处理计时问题。</p><p id="c32a" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">共享的可变状态和状态锁可能很难导航<a class="ae la" rel="noopener" href="/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e#.saj7jn6wh"> <em class="kk">不管你的经验水平</em> </a> <em class="kk">。有经验的用户更善于快速识别问题，并跳到一个方便的解决方法。</em></p><p id="efc0" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">由于新手以前没有见过这个问题，也不知道解决方法，它只是碰巧对他们打击最大。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="8d10" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当事情发生时，你可以与React斗争，或者你可以让React做它自己的事，顺其自然。这就是我说Redux有时比<code class="du ka kb kc kd b">setState()</code>、<em class="kk">更容易<em class="kk">的意思，即使对初学者来说也是如此。</em></em></p><p id="22e4" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在并发系统中，状态更新通常以以下两种方式之一进行处理:</p><ul class=""><li id="9e0b" class="ly lz hh jg b jh ji jk jl jn ma jr mb jv mc jz mm me mf mg bi translated">当其他事物正在使用状态时，锁定或限制对状态更新的访问(例如，<code class="du ka kb kc kd b">setState()</code>)或…</li><li id="c1fb" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">使用不变性来消除共享的可变状态，这允许不受限制地访问状态，并在任何时间点创建新的状态。(例如，Redux)</li></ul><p id="3c3d" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在我看来(在向许多学生教授了这两种技术之后)，第一种方法比第二种方法更容易出错，也更令人困惑。当状态更新被简单地阻塞(或者在<code class="du ka kb kc kd b">setState()</code>的情况下，批处理或延迟)时，问题的正确解决方案并不立即清晰。</p><p id="a649" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当我遇到<code class="du ka kb kc kd b">setState()</code>计时问题时，我的默认反应很简单:将我的状态管理沿着树向上移动，或者移动到Redux(或MobX ),或者移动到容器组件。我通常出于很多原因使用和推荐Redux，但是很明显，这不是对每个人都正确的建议。</p><p id="84af" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Redux有它自己的<em class="kk">巨大的学习曲线，</em>但是回避了共享的可变状态和状态更新时间复杂性，所以我发现一旦我教学生避免突变，它就相当顺利，<em class="kk">没有太多的陷阱或障碍。</em></p><p id="6e9c" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个没有任何函数式编程经验而试图学习Redux的新手可能会比使用<code class="du ka kb kc kd b">setState()</code>遇到更多的麻烦——但至少有一个关于这个主题的<a class="ae la" href="https://egghead.io/courses/getting-started-with-redux" rel="noopener ugc nofollow" target="_blank">免费</a> <a class="ae la" href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux" rel="noopener ugc nofollow" target="_blank">课程</a>，作者是Redux。</p><p id="e3ec" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">React应该向Redux book学习一页:一个关于常见React模式和<code class="du ka kb kc kd b">setState()</code> gotchas的很好的视频教程将会给React主页带来惊人的增加。</p><h2 id="07a9" class="mn lc hh bd ld mo mp mq lh mr ms mt ll jn mu mv ln jr mw mx lp jv my mz lr na bi translated">渲染前决定状态</h2><p id="baa9" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">将状态管理转移到容器组件(或Redux)会迫使你以不同的方式思考你的组件状态，明确在你可以呈现组件之前，它的状态必须已经确定(因为你必须将它作为道具传递)。</p><p id="4b13" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">值得重复的是:</p><blockquote class="kl"><p id="fd2f" class="km kn hh bd ko kp kq kr ks kt ku jz dx translated">渲染之前，先决定状态！</p></blockquote><p id="7b9e" class="pw-post-body-paragraph je jf hh jg b jh kv ii jj jk kw il jm jn kx jp jq jr ky jt ju jv kz jx jy jz ha bi translated">一个显而易见的推论是，试图在您的<code class="du ka kb kc kd b">render()</code>方法中使用<code class="du ka kb kc kd b">setState()</code>是一种反模式。</p><p id="4f30" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在你的渲染方法中计算依赖状态是很好的(例如，如果你有<code class="du ka kb kc kd b">firstName</code>和<code class="du ka kb kc kd b">lastName</code>并且你想计算<code class="du ka kb kc kd b">fullName</code>，在<code class="du ka kb kc kd b">render()</code>中这样做也是可以的)，但是我更喜欢在一个容器中计算依赖状态并把它作为道具传递给表示组件。</p><h1 id="1917" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">setState()如何修复？</h1><p id="1449" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">我倾向于反对<code class="du ka kb kc kd b">setState()</code>的对象字面形式。我知道这(表面上)更容易理解，也更方便，但这也是许多新用户陷入困境的原因，我认为有人这样做是不言而喻的:</p><pre class="ix iy iz ja fd nh kd ni nj aw nk bi"><span id="7bb6" class="mn lc hh kd b fi nl nm l nn no">state.count; // 0<br/>this.setState({count: state.count + 1});<br/>this.setState({count: state.count + 1});<br/>this.setState({count: state.count + 1});</span></pre><p id="2c04" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">希望之后能见到<code class="du ka kb kc kd b">{count: 3}</code>。我还没有见过在同一个属性上批量对象合并是预期行为的情况。我认为，如果存在这样的情况，它们与React的实现细节耦合得太紧密，不适合作为有效的用例。</p><p id="ce2d" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我还希望看到<code class="du ka kb kc kd b">setState()</code>文档的API部分链接到深入的<a class="ae la" href="https://facebook.github.io/react/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">“状态和生命周期”</a>指南，为那些试图了解<code class="du ka kb kc kd b">setState()</code>来龙去脉的用户提供更多关于这个主题的细节。因为它不同步操作或返回任何有意义的东西，简单地描述它的函数签名而不更彻底地讨论它的效果和行为是不能成功地接纳新用户的。</p><p id="3a95" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">他们不得不求助于数小时的故障排除、谷歌搜索、StackOverflow和GitHub问题。</p><h1 id="b63f" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">setState()为什么这么严格？</h1><p id="a240" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">setState()的古怪行为不是一个错误。这是一个特点。事实上，你可能会说<em class="kk">这是React首先存在的全部原因。</em></p><p id="8388" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">React的驱动力之一是确保确定性呈现:给定一些应用程序状态，呈现一些特定的输出。理想情况下，给定相同的状态，总是呈现相同的输出。</p><p id="1478" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了实现这一点，React必须通过限制变异发生的时间来管理变异。我们不只是抓住DOM，然后在适当的地方改变它。相反，React呈现DOM，当一些状态改变时，React决定如何再次呈现。<em class="kk">我们不渲染DOM。React有。</em></p><p id="4820" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">但是为了在更新周期中不重新触发渲染，React引入了一个规则:</p><p id="c6f3" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在DOM渲染过程中，React用于渲染的状态不能发生变化。<em class="kk">我们不决定组件状态何时更新。React有。</em></p><p id="5d2c" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因此产生了困惑。当你调用<code class="du ka kb kc kd b">setState()</code>时，你认为你在设置状态。你不是。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es np"><img src="../Images/d759aaca676b94fdba28626f0f112185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*cGqz_qxBGnJTsGygPe8ItQ.jpeg"/></div><figcaption class="kg kh et er es ki kj bd b be z dx">“You keep using that word. I don’t think it means what you think it means.”</figcaption></figure><h1 id="b4cb" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">什么时候应该使用setState()？</h1><p id="fa0d" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">我几乎专门将<code class="du ka kb kc kd b">setState()</code>用于不需要保持状态的自包含功能单元。换句话说，像可重用的表单验证组件、自定义日期或时间段选择小部件、允许您自定义视图状态的数据可视化小部件等等…</p><p id="ecd7" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我将这样的组件称为“小部件”，它们实际上由两个或更多组件组成:一个用于内部状态管理的容器，以及一个或多个处理实际DOM和表示方面的子组件。</p><p id="a0cd" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">以下是一些简单的试金石:</p><ul class=""><li id="fe07" class="ly lz hh jg b jh ji jk jl jn ma jr mb jv mc jz mm me mf mg bi translated">其他组件是否依赖于状态？</li><li id="9214" class="ly lz hh jg b jh mh jk mi jn mj jr mk jv ml jz mm me mf mg bi translated">需要持久化状态吗？(保存到本地存储还是发送到服务器？)</li></ul><p id="69f8" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果这两个问题的答案都是“不”，也许使用<code class="du ka kb kc kd b">setState()</code>就可以了。否则，你可能要考虑别的事情。</p><p id="31f0" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">据我所知，在脸书，他们使用由<a class="ae la" href="https://facebook.github.io/relay/" rel="noopener ugc nofollow" target="_blank">中继容器</a>管理的<code class="du ka kb kc kd b">setState()</code>来封装脸书UI的不同部分，就像在更大的脸书应用程序中的迷你应用程序一样。对他们来说，这是将许多复杂的数据依赖项与实际使用它们的组件放在一起的好方法。</p><p id="3529" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于非常大的(企业级)应用程序，我推荐类似的策略。如果你的应用程序有很多代码(几十万个LOC+)，这对你来说可能也是一个好策略——但是这种方法没有理由不能缩小规模。</p><p id="4ba4" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">也没有理由不使用类似的方法，而是将这些不同的部分分解成实际上独立的小应用程序，然后组合成更大的应用程序。我已经用Redux for enterprise软件做到了这一点。例如，我经常将分析仪表板、消息传递、管理、团队/用户角色管理和计费管理分离到完全独立的应用程序中，这些应用程序拥有自己的Redux商店。这种应用程序可以共享一个域，以及使用API令牌和OAuth的通用登录/会话管理，这样这些应用程序就像一个连接的应用程序。</p><p id="2d27" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于大多数app，我推荐<strong class="jg hi">默认为Redux </strong>。值得注意的是，丹·阿布拉莫夫(Redux的创造者)不同意我的观点。他理所当然地支持让应用程序尽可能简单，直到不能再简单为止。传统的社区智慧说“不要使用Redux，直到你感到痛苦。”</p><p id="d6d4" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我的回答是这样的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="er es nq"><img src="../Images/10b29a51ab8a5bd2e6ee2d1401d57c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_XSyNy2GoSEOipCeOVM_g.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">“Those who are unaware they are walking in darkness will never seek the light”.</figcaption></figure><p id="81a5" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如我已经提到的，<em class="kk">在某些情况下，</em> Redux比<code class="du ka kb kc kd b">setState()</code>更简单。Redux通过消除与共享可变状态和时序依赖相关的所有类型的错误，简化了状态管理。</p><p id="4788" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一定要学习<code class="du ka kb kc kd b">setState()</code>，但是即使你决定不想在你的应用中使用Redux，<strong class="jg hi">你还是应该学习Redux。</strong>它将教你思考应用程序状态的新方法，并且可能帮助你简化你的应用程序状态，不管你为你的应用程序选择什么其他的解决方案。</p><p id="9267" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于有大量派生状态的应用程序，<a class="ae la" href="https://github.com/mobxjs/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>可能是比<code class="du ka kb kc kd b">setState()</code>或Redux更好的解决方案，因为它非常擅长有效地管理和组织计算状态。</p><p id="7900" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">由于其细粒度的可观察订阅模型，它也非常擅长高效地呈现大量动态DOM元素(成千上万)。因此，如果您正在构建一个图形游戏，或者一个监控企业微服务所有实例的控制台，它可能是实时可视化显示所有复杂信息的绝佳选择。</p><h1 id="f948" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">后续步骤</h1><p id="fafa" class="pw-post-body-paragraph je jf hh jg b jh lt ii jj jk lu il jm jn lv jp jq jr lw jt ju jv lx jx jy jz ha bi translated">想了解更多关于用React和Redux构建软件的知识吗？</p><p id="ff71" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><a class="ae la" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟随Eric Elliott </a>学习JavaScript。如果你不是会员，你就错过了！</p><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es nv"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl nw nx go ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="jg hi"> <em class="kk">埃里克艾略特</em> </strong> <em class="kk">著有</em> <a class="ae la" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="kk">【编程JavaScript应用】</em> </a> <em class="kk">(奥赖利)，以及</em> <a class="ae la" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="kk">【跟埃里克艾略特学JavaScript】</em></a><em class="kk">。他曾为</em><strong class="jg hi"><em class="kk">Adobe Systems</em></strong><em class="kk"/><strong class="jg hi"><em class="kk">尊巴健身</em></strong><em class="kk"/><strong class="jg hi"><em class="kk">华尔街日报</em></strong><em class="kk"/><strong class="jg hi"><em class="kk">ESPN</em></strong><em class="kk"/><strong class="jg hi"><em class="kk">BBC</em></strong><em class="kk">等顶级录音师贡献过软件经验</em></p><p id="98ef" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>