<html>
<head>
<title>Building Multi-Architecture Containers with Buildah</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Buildah构建多架构容器</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/building-multi-architecture-containers-with-buildah-44ed100ec3f3?source=collection_archive---------0-----------------------#2022-06-16">https://medium.com/oracledevs/building-multi-architecture-containers-with-buildah-44ed100ec3f3?source=collection_archive---------0-----------------------#2022-06-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a61745e131c4c06c82fa1611c58da00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*inAZU4NhB8wD23cxiLEnxw.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Photo by Tom Fisk: <a class="ae ip" href="https://www.pexels.com/photo/aerial-photography-of-container-van-lot-3063470/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/aerial-photography-of-container-van-lot-3063470/</a></figcaption></figure><p id="55b6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最近，我一直在研究如何成功地构建多架构容器(有人称之为系列)。首先我们看了一下涉及到的高层概念，然后深入到T2如何使用Docker构建多架构容器。接下来我们看了看<a class="ae ip" rel="noopener" href="/@timclegg/building-multi-architecture-containers-on-oci-with-podman-67d49a8b965e">如何使用Podman </a>做同样的事情。现在我们将看看如何使用另一个工具来完成这个任务:<a class="ae ip" href="https://buildah.io" rel="noopener ugc nofollow" target="_blank"> Buildah </a>。你会问为什么？因为我们可以！不，实际上，拥有多种可用工具是有益的，因为我们可能有偏好或要求使用一种工具而不是另一种。当然还有其他方法来构建图像，但是除了本系列的最后一篇文章之外，我们不会更深入地研究这个主题(至少在此时)。</p><h1 id="bfc2" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">先决条件</h1><p id="90c1" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">如果你想跟进，你需要一个<a class="ae ip" href="https://signup.cloud.oracle.com" rel="noopener ugc nofollow" target="_blank"> Oracle云基础设施(OCI)账户</a>和一个名为<em class="kr"> hello-world </em>的OCI容器库(OCIR)。参见<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registrycreatingarepository.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>了解更多关于如何创建存储库的信息。</p><p id="e8a7" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于这个场景，我使用了运行在Oracle Linux 8.5上的Buildah v1.23.1。要查看您正在运行的Oracle Linux版本，请看一下<em class="kr"> cat /etc/os-release </em>的输出。不同的版本可能会导致不同的结果。</p><p id="9c8e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们之前看到的工具(Docker和Podman)对不同的操作系统都有相当不错的支持。不幸的是，Buildah是一个“专属于Linux”的工具。您可能希望在一个Oracle Linux OCI实例上运行这个程序。</p><h1 id="1257" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">入门指南</h1><p id="e2b8" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">首先，我们需要了解如何使用Buildah认证(登录和注销)OCIR。登录(验证)到OCIR应该和我们用其他工具做的事情很相似:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="728c" class="lb jp hh kx b fi lc ld l le lf">$ buildah login phx.ocir.io</span></pre><p id="dcf9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">您需要为您正在使用的OCI地区使用正确的地区主机名。请参见<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Concepts/registryprerequisites.htm#regional-availability" rel="noopener ugc nofollow" target="_blank">区域可用性</a>了解特定区域的主机名。<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registrypushingimagesusingthedockercli.htm" rel="noopener ugc nofollow" target="_blank"> OCI集装箱注册文档</a>更详细地讨论了这一点，以及<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>中的区域密钥。</p><p id="d38d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">确保您提供的用户名使用正确的格式。用户名的格式应该是<namespace> / <username>(或者如果您使用的是IDCS，<namespace>/oracleidentitycloudservice/<username>)。密码将是与您的帐户相关联的身份验证令牌。如果这看起来有点陌生或令人困惑，请看一下OCI文档<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registrypushingimagesusingthedockercli.htm" rel="noopener ugc nofollow" target="_blank">以了解更多细节。</a></username></namespace></username></namespace></p><p id="de14" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">注销OCIR很容易完成:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d10e" class="lb jp hh kx b fi lc ld l le lf">$ buildah logout phx.ocir.io</span></pre><p id="8524" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在我们可以与OCIR交互，让我们学习如何使用Buildah构建多拱容器！</p><h1 id="ee42" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">建造集装箱</h1><p id="849f" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">和以前的文章一样，我们将保持一个简短的Dockerfile文件:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="15fb" class="lb jp hh kx b fi lc ld l le lf">FROM container-registry.oracle.com/os/oraclelinux:8-slim<br/><br/>CMD echo "Hello world!"</span></pre><p id="7924" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是故意的。我们需要把重点放在容器构建上，而不是特定语言的复杂性上。</p><p id="1337" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们在以前的文章中已经这样做了，但是为了彻底，我们将检查以确保基础映像对于我们将要构建的两种架构(arm64和amd64)都可用。查看该容器的<a class="ae ip" href="https://container-registry.oracle.com/" rel="noopener ugc nofollow" target="_blank"> Oracle容器注册表</a>(您需要点击<em class="kr"> OS </em>，然后点击<em class="kr"> oraclelinux </em>来查看我在下面展示的内容)，我们可以看到有两个平台受支持(这两个平台都是我们想要构建的):</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/67471812fbb7e3b5f73f4276acf15184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6kvKjFlFj4ie67m1PRRGQ.jpeg"/></div></div></figure><p id="0ad3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">总是检查以确保您有一个用于您将要构建的不同目标体系结构的基础映像！</p><p id="260a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">使用Buildah时，有两种方法可以构建容器多拱容器映像。我称之为“简单路径”(批处理)和手动方法。</p><p id="0963" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">所以我就不拿batched (easy)的方法来吊你的“胃口”了，先来看看怎么手动做事吧。</p><h1 id="7367" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">手动方法</h1><h2 id="4f90" class="lb jp hh bd jq ll lm ln ju lo lp lq jy jb lr ls kc jf lt lu kg jj lv lw kk lx bi translated">建造集装箱</h2><p id="7084" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">我们首先创建两个容器映像(每个架构一个:arm64和amd64):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a205" class="lb jp hh kx b fi lc ld l le lf">$ buildah build --pull --platform linux/arm64/v8 -t phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-arm64 .<br/>  &lt;omitted for brevity&gt;</span><span id="15a5" class="lb jp hh kx b fi ly ld l le lf">$ buildah build --pull --platform linux/amd64 -t phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-amd64 .<br/>  &lt;omitted for brevity&gt;</span></pre><p id="4835" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="kr"> — platform </em>参数用于指定所需的目标体系结构(将为其构建容器的体系结构)。一个平台通常由操作系统、CPU架构和一个架构变体(这是可选的，并且经常被排除在外)组成，每个由正斜杠(/)分隔。</p><p id="0b64" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们检查我们刚刚构建的容器，寻找架构以确保它是正确的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4278" class="lb jp hh kx b fi lc ld l le lf">$ buildah build --pull --platform linux/amd64 -t phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-amd64 .<br/>  &lt;omitted for brevity&gt;</span><span id="fe74" class="lb jp hh kx b fi ly ld l le lf">$ buildah inspect phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-arm64 | grep \"architecture\"<br/>        "architecture": "arm64",<br/>        "architecture": "arm64",</span><span id="cb3d" class="lb jp hh kx b fi ly ld l le lf">$ buildah inspect phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-amd64 | grep \"architecture\"<br/>        "architecture": "amd64",<br/>        "architecture": "amd64",</span></pre><p id="47ed" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从上面我们可以看到，我们构建的两个容器都有正确的架构。太棒了。</p><p id="ad3a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">是时候将图像推送到OCI注册中心(OCIR)了:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5644" class="lb jp hh kx b fi lc ld l le lf">$ buildah push phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-arm64<br/>  &lt;omitted for brevity&gt;</span><span id="d33f" class="lb jp hh kx b fi ly ld l le lf">$ buildah push phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-amd64<br/>  &lt;omitted for brevity&gt;</span></pre><p id="c20d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">随着我们的图像被推送到OCIR，我们能够运行它们。问题是，我们不想为执行环境CPU架构调用每个变体。换句话说，如果我在一个OCI A1 (Arm)实例上，我不想说<em class="kr"> docker运行phx.ocir.io/&lt;命名空间&gt;/hello-world:v 1 . 0 . 0-Linux-Arm 64</em>和当在x86_64(又名amd64) OCI实例(如E4实例形状)上运行<em class="kr"> docker运行phx.ocir.io/&lt;命名空间&gt;/hello-world:v 1 . 0 . 0-Linux-amd64</em>。这有点乱。这在Kubernetes (K8s)清单中是不可管理的。相反，我希望能够说<em class="kr"> docker运行phx.ocir.io/&lt;名称空间&gt; /hello-world:v1.0.0 </em>，并让它获得将要运行容器的架构的正确映像。这就是清单解决的问题。</p><h2 id="3f09" class="lb jp hh bd jq ll lm ln ju lo lp lq jy jb lr ls kc jf lt lu kg jj lv lw kk lx bi translated">创建清单</h2><p id="a729" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">使用Buildah制作清单非常简单:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="20cb" class="lb jp hh kx b fi lc ld l le lf">$ buildah manifest create phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0 \<br/>  phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-arm64 \<br/>  phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0-linux-amd64<br/>  &lt;omitted for brevity&gt;</span><span id="b81f" class="lb jp hh kx b fi ly ld l le lf">$ buildah manifest push phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0 docker://phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0<br/>  &lt;omitted for brevity&gt;</span><span id="7c13" class="lb jp hh kx b fi ly ld l le lf">$ buildah manifest rm phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0<br/>  &lt;omitted for brevity&gt;</span></pre><p id="484e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">第一个命令创建清单(hello-world:v1.0.0)，向其中添加两个容器(hello-world:v1.0.0-linux-amd64和hello-world:v1.0.0-arm64)。</p><p id="0dfa" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在第二个命令中，Buildah将新创建的清单推送给OCIR。</p><p id="a444" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最后，为了保持整洁，我们删除了清单的本地(缓存)副本。</p><p id="7750" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了验证清单看起来是否良好，我们来检查一下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9041" class="lb jp hh kx b fi lc ld l le lf">$ buildah manifest inspect phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.0<br/>{<br/>    "schemaVersion": 2,<br/>    "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",<br/>    "manifests": [<br/>        {<br/>            "mediaType": "application/vnd.oci.image.manifest.v1+json",<br/>            "size": 722,<br/>            "digest": "sha256:abc123...",<br/>            "platform": {<br/>                "architecture": "arm64",<br/>                "os": "linux"<br/>            }<br/>        },<br/>        {<br/>            "mediaType": "application/vnd.oci.image.manifest.v1+json",<br/>            "size": 722,<br/>            "digest": "sha256:xyz123...",<br/>            "platform": {<br/>                "architecture": "amd64",<br/>                "os": "linux"<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><p id="ee92" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">万一需要(或想要)，有一种手工完成的方法是很棒的。让我们试试分批，或者我喜欢称之为“简单”的方法。</p><h1 id="602a" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">分批(简易)方法</h1><p id="2a79" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">Buildah可以负责为每个期望的目标平台构建容器以及清单，所有这些都在一个命令中完成:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b469" class="lb jp hh kx b fi lc ld l le lf">$ buildah build --jobs=2 --platform=linux/arm64/v8,linux/amd64 --manifest phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.2 .<br/>  &lt;omitted for brevity&gt;</span></pre><p id="0b57" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下一步，我们需要将它推广到OCIR:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="18c8" class="lb jp hh kx b fi lc ld l le lf">$ buildah push phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.2<br/>  &lt;omitted for brevity&gt;</span></pre><p id="afd2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">虽然这里没有显示，但是如果您想查看构建的图像(将此视为“额外学分”)，请查看<em class="kr">buildah images–all</em>的输出。</p><p id="c9d5" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于咧嘴笑，我们可以看看清单:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4ea5" class="lb jp hh kx b fi lc ld l le lf">$ buildah manifest inspect phx.ocir.io/&lt;namespace&gt;/hello-world:v1.0.2<br/>{<br/>    "schemaVersion": 2,<br/>    "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",<br/>    "manifests": [<br/>        {<br/>            "mediaType": "application/vnd.oci.image.manifest.v1+json",<br/>            "size": 715,<br/>            "digest": "sha256:abc123...",<br/>            "platform": {<br/>                "architecture": "amd64",<br/>                "os": "linux"<br/>            }<br/>        },<br/>        {<br/>            "mediaType": "application/vnd.oci.image.manifest.v1+json",<br/>            "size": 715,<br/>            "digest": "sha256:xyz123...",<br/>            "platform": {<br/>                "architecture": "arm64",<br/>                "os": "linux",<br/>                "variant": "v8"<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><p id="abae" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">平台看起来很棒！有多简单？</p><h1 id="3178" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="f1dd" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">虽然Buildah不是最容易移植的工具(对Linux来说)，但它非常强大，可以让生活变得非常简单。能够在一个命令中构建容器<em class="kr">和</em>清单是非常强大的。</p><p id="36d8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">本系列没有试图穷尽我们所研究的工具的每一个角落(或者多架构容器的主题)。我真的希望它对理解在多架构世界中构建和使用容器的基础知识有所帮助。</p><p id="f30a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在结束这一系列文章时，我想特别感谢我的同事阿苏，他在为我同行评审这一系列文章时帮了我很大的忙。直到下一次，保持位流！</p><p id="2115" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当然，你可以在我们的<a class="ae ip" href="https://signup.cloud.oracle.com/?language=en&amp;sourceType=:ex:tb:::::&amp;SC=:ex:tb:::::&amp;pcode=" rel="noopener ugc nofollow" target="_blank">免费层</a>上试试这个。</p><p id="ed8c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">想讨论一下吗？加入我们<a class="ae ip" href="https://bit.ly/devrel_slack" rel="noopener ugc nofollow" target="_blank">公共休闲频道</a>的对话吧！</p></div></div>    
</body>
</html>