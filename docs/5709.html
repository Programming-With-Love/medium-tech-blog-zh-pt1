<html>
<head>
<title>Spring: Blocking vs non-blocking: R2DBC vs JDBC and WebFlux vs Web MVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring:阻塞vs非阻塞:R2DBC vs JDBC和WebFlux vs Web MVC</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc-900d72ee19c1?source=collection_archive---------0-----------------------#2020-04-28">https://medium.com/oracledevs/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc-900d72ee19c1?source=collection_archive---------0-----------------------#2020-04-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d1bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2017年9月发布的Spring Framework第5版引入了Spring WebFlux。完全反应式堆栈。2019年12月Spring Data R2DBC发布了反应式关系数据库驱动程序。在这篇博文中，我将展示在高并发时，WebFlux和R2DBC的性能更好。它们有更好的响应时间和更高的吞吐量。作为额外的好处，它们在处理每个请求时使用更少的内存和CPU，并且当在R2DBC的情况下省略JPA时，您的胖罐子会变得更小。在高并发情况下，使用WebFlux和R2DBC是一个好主意！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/537303d211aec0d8d0479f15e947698f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*f9xXS1t_dooRgY4k.png"/></div></figure></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><p id="820a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博文中，我研究了4个实现</p><ul class=""><li id="74cf" class="jr js hh ig b ih ii il im ip jt it ju ix jv jb jw jx jy jz bi translated">Spring Web MVC + JDBC数据库驱动</li><li id="9dc3" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">Spring Web MVC + R2DBC数据库驱动</li><li id="0b72" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">Spring WebFlux + JDBC数据库驱动</li><li id="f6e0" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">Spring WebFlux + R2DBC数据库驱动程序</li></ul><p id="538a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将正在处理的请求数量(并发性)从4个增加到500个，步长为50个，并为负载生成器和服务分配了4个内核(我的笔记本电脑有12个内核)。我已经将所有连接池配置为100。为什么内核数量和连接池大小是固定的？在<a class="ae kf" href="https://technology.amis.nl/2020/03/27/performance-of-relational-database-drivers-r2dbc-vs-jdbc/" rel="noopener ugc nofollow" target="_blank">之前对JDBC vs R2DBC数据的探索</a>中，改变这些变量并没有提供更多的见解，所以我决定在这次测试中保持它们不变，通过几个因素减少我的测试运行时间。</p><p id="48af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在服务上做了一个GET请求。该服务从数据库中获取10条记录，并以JSON的形式返回它们。首先，我在服务上加了很重的负载，让服务“启动”了2秒钟。接下来，我从1分钟基准开始。我将每个场景重复了5次(被其他测试分开，所以不是彼此重复5次)，然后计算结果的平均值。我只查看了没有导致错误的运行。当我将并发性增加到1000以上时，所有实现的额外并发请求都无一例外地失败了。结果似乎是可重复的。</p><p id="28a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为后端数据库，我使用了Postgres (12.2)。我使用<a class="ae kf" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> wrk </a>对实现进行了基准测试(因为有几个建议)。我测量了</p><ul class=""><li id="c33a" class="jr js hh ig b ih ii il im ip jt it ju ix jv jb jw jx jy jz bi translated">wrk报道的响应时间<br/></li><li id="6c93" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">wrk报告的吞吐量(请求数)<br/></li><li id="7e26" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">进程CPU使用率<br/>用户和内核时间(基于/proc/PID/stat)</li><li id="f00f" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">内存使用<br/>私有和共享进程内存(基于/proc/PID/maps)</li></ul><p id="7205" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里查看<a class="ae kf" href="https://github.com/MaartenSmeets/db_perftest/blob/r2dbc/test_scripts/run_test.py" rel="noopener ugc nofollow" target="_blank">使用的测试脚本。你可以在这里查看</a><a class="ae kf" href="https://github.com/MaartenSmeets/db_perftest/tree/r2dbc/test_apps" rel="noopener ugc nofollow" target="_blank">使用的实现</a>。</p><p id="a71a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里查看我用于图表<a class="ae kf" href="https://github.com/MaartenSmeets/db_perftest/blob/r2dbc/test_scripts/restotal.txt" rel="noopener ugc nofollow" target="_blank">的原始数据</a>。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/4d197da2559c0889262e5643135c9077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*mdV8XbtMM-Kfsqr7.png"/></div></figure><p id="d143" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很明显，在更高的并发性下，Spring Web MVC + JDBC的响应时间开始下降。R2DBC显然在更高的并发性下提供了更好的响应时间。Spring WebFlux也比使用Spring Web MVC的类似实现做得更好。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/15d6920262a5c90977f54398659abae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*WKdmVnLl8FdeZzRZ.png"/></div></figure><p id="caab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于响应时间，JDBC的Spring Web MVC在更高的并发性上表现更差。R2DBC显然做得最好。然而，从Spring Web MVC迁移到Spring WebFlux也有助于提高吞吐量，但不如从JDBC迁移到R2DBC那么多。在低并发的情况下，Spring Web MVC + JDBC比Spring WebFlux + JDBC表现稍好。</p><p id="bba3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> CPU </strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/f41e302550f1ddab91ae806c38c89a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*auYtoYFFXS9qKuyN.png"/></div></figure><p id="a8ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">JDBC的Spring WebFlux使用的CPU最少。然而，正如您在上面看到的，它的吞吐量也是最低的。当您查看每个处理的请求所使用的CPU时，您会得到代码/JVM利用CPU的效率的度量:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/a80fbd2b82725ec1cd18f7a2599fe6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*josCg0PiIlqLpvVw.png"/></div></figure><p id="5f91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">WebFlux和R2DBC每个请求使用的CPU最少。R2DBC每个请求使用的CPU显然比JDBC少。然而，在低并发时，Web MVC + JDBC最有效地利用了可用内存。当任何组件是非阻塞的(使用R2DBC的WebFlux)时，处理的每个请求的内存使用比完全阻塞的堆栈(Web MVC + R2DBC)更稳定。</p><p id="4b6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">内存</strong></p><p id="ee58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行结束时，内存作为进程私有内存进行测量。内存使用取决于垃圾收集。G1GC用于JDK 11.0.6。Xms为0.5 Gb(默认为我的可用32 Gb的1/64)。Xmx是8 Gb(默认为我的可用32 Gb的1/4)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/108a155b49d7cee71063cbe09a80c460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*2LhjO60_ocniXkM-.png"/></div></figure><p id="964d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Web MVC在较高并发时开始占用更多内存，而WebFlux是稳定的。在低并发情况下，Web MVC + JDBC做得最好，但是在高并发情况下，WebFlux + R2DBC每个处理的请求使用的内存最少。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/384d7fd832ce0ee848db423c32799ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*OKI9u7TdVwgueyMV.png"/></div></figure><p id="e2f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">脂肪罐大小</strong></p><p id="5dcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示JPA是一个大的。如果在R2DBC的情况下不能使用，你的胖罐子大小下降到15Mb的量级！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/5fbdef8e951397857b9c08a02c616a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*Nk0en-vZn9GCqr6K.png"/></div></div></figure><p id="db9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">R2DBC和WebFlux，高并发的好主意！</p><p id="d948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在高并发时，使用R2DBC代替JDBC，使用WebFlux代替Web MVC的好处是显而易见的。</p><ul class=""><li id="128a" class="jr js hh ig b ih ii il im ip jt it ju ix jv jb jw jx jy jz bi translated">处理一个请求需要更少的CPU。</li><li id="06e5" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">处理单个请求所需的内存更少。</li><li id="3514" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">高并发的响应时间更短。</li><li id="fccf" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">高并发的吞吐量更好</li><li id="50dc" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">fat JAR尺寸较小(没有带R2DBC的JPA)</li></ul><p id="d44a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用R2DBC或WebFlux并不要求您拥有一个完全非阻塞的堆栈。然而，最好在高并发时同时使用这两者。WebFlux + JDBC不是一个好主意，因为它在内存和CPU使用方面效率不高，并且与其他测试服务相比吞吐量较低。</p><p id="58b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在低并发性(低于200个并发请求)的情况下，使用Web MVC和JDBC可能会得到更好的结果。测试这个来确定你自己的盈亏平衡点！</p><p id="36c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用R2DBC时的一些挑战</strong></p><ul class=""><li id="ab34" class="jr js hh ig b ih ii il im ip jt it ju ix jv jb jw jx jy jz bi translated">JPA不能处理诸如Spring Data R2DBC提供的反应式存储库。这意味着在使用R2DBC时，您将不得不手动做更多的事情。</li><li id="780b" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">周围还有其他反应式驱动程序，例如Quarkus反应式Postgres客户端(使用Vert.x)。这不使用R2DBC，具有不同的性能特征(见<a class="ae kf" href="https://technology.amis.nl/2020/03/27/performance-of-relational-database-drivers-r2dbc-vs-jdbc/" rel="noopener ugc nofollow" target="_blank">此处</a>)。</li><li id="5052" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">有限的可用性<br/>不是所有的关系数据库都有反应式驱动程序。比如甲骨文就没有(还没有？)有一个R2DBC实现。</li><li id="51b1" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">应用服务器仍然依赖于JDBC。<br/>在这个Kubernetes时代，人们还用那些做非遗吗？</li><li id="b76b" class="jr js hh ig b ih ka il kb ip kc it kd ix ke jb jw jx jy jz bi translated">当引入Java纤程时(Project Loom，可能是Java 15)，驱动程序的前景可能会再次改变，R2DBC可能根本不会成为JDBCs的继任者。</li></ul></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><p id="c6e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kl">原载于</em><a class="ae kf" href="https://javaoraclesoa.blogspot.com/2020/04/blocking-vs-non-blocking-in-spring.html" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://javaoraclesoa.blogspot.com</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>