<html>
<head>
<title>Unit testing with Mendix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mendix进行单元测试</h1>
<blockquote>原文：<a href="https://medium.com/mendix/unittesting-with-mendix-63d2a1ba01f5?source=collection_archive---------1-----------------------#2020-03-19">https://medium.com/mendix/unittesting-with-mendix-63d2a1ba01f5?source=collection_archive---------1-----------------------#2020-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0e4a0c100e5b1ff8213bd8d2a80d4537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQRphCYbIDu7HiJW9TP5OA.png"/></div></div></figure><p id="3f31" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">通过<a class="ae jz" href="https://www.newspark.nl" rel="noopener ugc nofollow" target="_blank"> Newspark B.V. </a>，我一直作为<a class="ae jz" href="https://www.anwb.nl" rel="noopener ugc nofollow" target="_blank"> ANWB </a>的测试自动化顾问工作，这意味着我负责创建和执行测试计划，编写Postman脚本和套件，设置应用程序监控，等等。去年10月，我成长为ANWB一个新项目的Mendix开发人员。</p><p id="202c" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">自从我们开始新项目以来，Mendix已经发布了一个官方支持的模块，我们可以用它来编写和执行“单元测试”。我将单词unittests放在引号中，因为在引擎盖下，Mendix使用Java，我们不能/不会在那个级别上测试它。单元测试意味着测试最小可能的微流。通过这个博客，我想和大家分享我使用单元测试模块的经验，希望你能从中学习。</p><p id="bb48" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">先决条件:</strong></p><p id="bee3" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">对门德克斯的一些理解</p><p id="5199" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">Mendix Studio Pro 8.x (8.6.1用于创建此示例)</p><p id="4bd5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">CommunityCommons v8.2.0</p><p id="1c90" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">对象处理3.0.1版</p><p id="ac7c" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">单元测试v8.0</p><p id="2a35" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">CommunityCommons、ObjectHandling和UnitTesting模块可以在Mendix应用商店中找到。</p><p id="110c" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">本博客的目的:</strong></p><p id="c469" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我创建了一个简单的项目来提供对单元测试模块的一些见解。我没有在我的例子中使用这个模块的所有方面，而是创建了一个简单的、可理解的测试。所以请记住，这不是我在Mendix开发中最好的作品，但这个项目纯粹是作为一个例子，并激励其他人使用这个模块。</p><p id="67f5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">领域模型</strong></p><p id="a0fc" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">这是我的领域模型的样子:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/afadebdfd67c92d1cd543ccb2a44a5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*bytQO8HnfUJ5HkJGje4wbg.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">A single persistable database entity with a Name attribute (string value).</figcaption></figure><p id="61ac" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">图形用户界面</strong></p><p id="0f14" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我的主页由一个数据网格组成，它链接到Person对象:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/3611b4f338b463259a9ae2366fb48ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc8RvBuVR6SAl8RlstrCMA.png"/></div></div></figure><p id="9300" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我的NewEdit页面(需要在数据库中创建一个新的“Person ”,或者编辑一个)也很简单，由Mendix:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/ef26d12f16e98d5bdfd3646798546975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MghZ1Sog2w_VVxj7AB761w.png"/></div></div></figure><p id="90d9" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">“真实”页面(当通过“本地运行”运行代码时)如下所示:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/4ee3e2133d77b09a65c4736e0a24e2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loe5CU5vwkuAplWCE-dn7w.png"/></div></div></figure><p id="0d1f" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">微流量</strong></p><p id="60e8" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">然而，在“保存”按钮的背后，有一个微流。默认情况下，当生成新的编辑页面时，按“保存”按钮会导致保存任何更改而不进行检查。在这种情况下，我在一个微流中做了一个简单的验证，检查“Name”属性是空的还是空字符串。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/cfb9fb358fd078472133020052da9897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qz9rzmFpcTqgMzEf40gMkw.png"/></div></div></figure><p id="4303" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">如果没有填写“Name”属性，流程会停止，弹出一个错误消息，并且不会提交(保存)任何内容。如果“Name”属性被填充，则流程继续向右，提交(保存)更改并关闭弹出窗口。</p><p id="2fa8" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">为了使这个例子尽可能简单和基本，我选择不添加任何进一步的验证，比如检查数据库中的重复项。</p><p id="f7d5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">单元测试</strong></p><p id="a66d" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">现在我们有了一个数据库，一个用于在数据库中添加和更改名称的GUI，以及一个检查添加/更改的名称是否为空的验证流。让我们做一个单元测试！</p><p id="68c6" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">应用商店模块</strong></p><p id="68ff" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">为了使用UnitTesting模块，我们需要三个Mendix应用商店模块。<strong class="bd ka">平视！</strong>在写这个例子时，我遇到了一种情况，这种情况可能会在将来得到解决。安装UnitTesting模块后，我们的错误屏幕中会显示一个错误，因为模块找不到它期望的图标。双击错误信息就可以很容易地解决这个问题。您将在缺少图标的元素处结束，并且您可以从列表中选择一个随机存在的图标来使事情再次工作！</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kl"><img src="../Images/ca5c6ef803844d2a3c099334d2e2f70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aM5ksIfsqeVfmTQFgHNbEg.png"/></div></div></figure><p id="a61c" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">运行时设置</strong></p><p id="ed02" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">除了添加这些模块，我们需要对我们的项目做一个小的改变，这样工具就知道我们写了哪些测试。通过在应用程序开始时调用这个微流，UnitTesting模块将搜索以Test_或UT_开头的文件:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/69206e49c565d7b2f2ecfa180bb268a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzQxXzYgFQY-0tkIFoAktQ.png"/></div></div></figure><p id="8b6e" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">单元测试概述</strong></p><p id="b7ad" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">此外，我们希望在主屏幕上查看我们的单元测试，这样我们就可以通过自己的GUI运行它们。我已经通过向我的页面添加一个容器并将“UnitTestOverview”片段拖动到该容器中实现了这一点。片段是页面的一部分，您可以在其他页面上重复使用。非常方便，因为通过将这个片段添加到我的GUI中，我不需要为了查看和运行测试而更改或做任何其他事情！</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/4f0b8e3b5ce2e994a33024148e4d360a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCcWwNGj69vtY0TBsSteoQ.png"/></div></div></figure><p id="470e" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">当我们再次运行我们的代码(本地运行)时，我们应该在已经有过的Datagrid下面看到单元测试:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/9595ab950ec5a8c5ced0b224b4561d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZswLRX7mM6lDPs0J9iCFAA.png"/></div></div></figure><p id="343d" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">如果您不能直接看到任何单元测试，但是您确实看到了“运行所有模块测试”和“重置所有测试”按钮，那么请按“重置所有测试”按钮。这将使工具寻找新的测试，并将使工具找到UnitTesting模块附带的测试(该模块附带了一组示例测试)。如果你愿意，你可以点击“运行所有模块测试”按钮。一眨眼，你就会看到你的报告出现。</p><p id="08a5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">编写单元测试</strong></p><p id="09f2" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">因此，编写我们的第一个单元测试。我们的应用程序只包含一个带逻辑的微流；验证流程。这个流程检查属性“Name”是否被填充。我们可以为此编写一个测试。</p><p id="0948" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">单元测试微流</strong></p><p id="51bc" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">在第一个测试中，我们会写，我们称之为“Test_Validation_No_Name”。我们可能会在命名约定上全力以赴，但还是让它保持简单。这里最重要的部分是UnitTesting工具检查以“Test_”或“UT_”开头的微流。因此，请确保您的测试微流名称以其中之一开头。</p><p id="cb0d" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">测试数据</strong></p><p id="fc6a" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">当编写单元测试时，我们想要控制我们使用的数据，所以在我们的流程中，我们创建了一个新的“Person”对象，没有“Name”属性。通常，对象是在我们填充GUI上的字段时创建的，但是我们可以通过在代码中创建一个对象来解决这个问题:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/b23d1877e96c5ef6ce5623b9dc9c41ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yJ5cHtq38nXzjBxfo4eqQ.png"/></div></div></figure><p id="e227" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">被测逻辑的子微流</strong></p><p id="be22" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">下一步是将我们的验证微流拖到我们的测试微流中。这个微流成为我们的测试流中的一个块，这使得它成为我们的单元测试的子微流:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/dc64f05aaa61c370908216bd7d976a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KUL4843KFv_E3u4Xw2DRQ.png"/></div></div></figure><p id="dad5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我们不应该忘记将我们新创建的“Person”对象传递给“Validation”微流。否则，该流将没有输入参数。我们通过双击验证流并双击配置屏幕中的参数来实现这一点。这里我们将值设置为$NewPerson，我们的新对象！</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/9aa47a74597117c97930821e017bbe4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76UegiBeuQ57FKFzMpTkQg.png"/></div></div></figure><p id="a10b" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">验证</strong></p><p id="f004" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">在“验证”流的下面(我在我的流中把它变成了紫色，这样我们就可以很容易地识别它)，我们看到一个叫做“变量”的东西，它下面的“布尔”是蓝色的。这是我在验证流程中准备的东西。我们可以在子微流中使用返回值，它可以返回从字符串或整数到对象或对象列表的任何内容。在这种情况下，我准备了我们的验证流，当“Name”属性被填充并且一切按计划进行时，返回一个布尔值“true”。当没有填写“Name”属性时，流程返回“false ”,我们向用户返回一条错误消息。我们可以在测试中将这个返回值用于断言:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/2e703b94727f1bc00aab8a1b656e151e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEZ3uaQsdfBWC78eddHr7w.png"/></div></div></figure><p id="bb0d" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">好了，我们已经完成了一个“创建对象”动作来创建一个没有“名字”属性的“人”对象。然后我们进入紫色块，即“验证”流程。正如我们在上面的图片中看到的，当“Name”属性不存在时，验证流出错(进入错误场景)。因此，我们期望从验证流返回的$变量是“false”！</p><p id="a367" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我们将在测试中检查这一点:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/38d97c44573ca746818488a3060c7a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMtZdzg0tuMTdgAV_vyZsQ.png"/></div></div></figure><p id="dc72" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">测试正常/不正常</strong></p><p id="9edc" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">接下来，我为单元测试的结束标记(红点)提供“真”或“假”，以便工具知道它应该将我的测试结果标记为绿色还是红色(OK/NOK):</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/b1679cacf1d80845b622b768d18c69c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Boe5d71hlJzb3dmbXYZNdQ.png"/></div></div></figure><p id="35c1" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">我们自己的单元测试概述</strong></p><p id="ef56" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">当我们再次运行代码(本地运行)，并再次点击“Reset all tests”按钮时，我们应该在概览中看到一个额外的单元测试…我们刚刚创建的单元测试！</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/8fffe83233bf68c507aedc66a4347a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiBbglDv-Vo0p01UJQu4zA.png"/></div></div></figure><p id="7741" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">结果</strong></p><p id="4de7" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">当我们点击右下角的“运行测试”时…</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kk"><img src="../Images/247d86d3e4478fdbb877585e5b216662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGgmxD-9fdLzDTtFghO7AQ.png"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Test passed!</figcaption></figure><p id="4ca5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ka">结论</strong></p><p id="7c3a" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">这是Mendix现在提供的单元测试工具的第一印象。正如我在这篇博客开始时所说的，有许多方法可以使用单元测试模块。我现在保持它的简单，让它对广大公众来说是可读和可理解的，我选择对来自我的验证微流的“真”或“假”返回值做我自己的断言。UnitTesting模块有两种不同的断言微流，我也可以用它们来进行断言。除此之外，我还没有使用过UnitTesting模块提供的“ReportStep”微流。这个报告步骤有助于调试，因为“细节”屏幕(“运行测试”按钮的右边)将显示测试失败前最后一个通过的步骤。</p><p id="4348" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">但是我可能会在我的下一篇博客中谈论这些。</p><blockquote class="km kn ko"><p id="4d6d" class="jc jd kp bd b je jf jg jh ji jj jk jl kq jn jo jp kr jr js jt ks jv jw jx jy hn dt translated">您想了解更多关于使用Mendix进行低代码开发和/或测试您的Mendix应用程序的信息吗？不要犹豫，给我发电子邮件，邮箱:<a class="ae jz" href="mailto:wb@newspark.nl" rel="noopener ugc nofollow" target="_blank"> wb@newspark.nl </a></p></blockquote><h1 id="5274" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">关于我</h1><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/038cdfb2ff875244e7e11a18ea08543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*fY3a0jZTXNjOYr5fpNiFPQ.jpeg"/></div></figure><p id="dd44" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">我叫韦塞尔·布拉克曼。我从2012年开始从事测试自动化工作，从2016年开始在专业公司<a class="ae jz" href="https://www.newspark.nl" rel="noopener ugc nofollow" target="_blank">new park b . v .</a>工作。在我目前的任务中，我有机会作为后端开发人员开始与Mendix一起工作，我真的很喜欢自己。我的目标是与他人分享知识，并让其他人对这一低代码运动感到兴奋。希望在Mendix world见到大家，或者通过<a class="ae jz" href="mailto:wb@newspark.nl" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或<a class="ae jz" href="http://linkedin.com/in/wesselbraakman" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我！</p></div></div>    
</body>
</html>