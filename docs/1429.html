<html>
<head>
<title>NoSQL Database Doesn’t Mean No Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NoSQL数据库并不意味着没有模式</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/nosql-database-doesnt-mean-no-schema-a824d591034e?source=collection_archive---------1-----------------------#2017-02-07">https://medium.com/capital-one-tech/nosql-database-doesnt-mean-no-schema-a824d591034e?source=collection_archive---------1-----------------------#2017-02-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="11f4" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">手工甜甜圈&gt;手工数据</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/5070a69015d25010d28e7924952c7d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*YuYGGeuTE3jyRMtAcAeELA.png"/></div></figure><p id="361e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">如果我给你一个手工制作的甜甜圈，它可能会得到一个强调的回答，<em class="kj">“好的，请！”</em>但是你对我提供的手工数据会有什么反应呢？不规则的、唯一的数据不是很吸引人，所以我猜你会不那么热衷。什么是手工数据？想象一下，每笔商业交易的数据都被写成体育赛事的彩色解说词，<em class="kj">“今天，一对老夫妇买了一盒我们最好的……”</em>，然后被要求对其进行分类、排序和解释。这就是手工数据的样子——它并不是非常有用。那么，我们能做些什么来确保我们有可用的数据集合，用于有意义的决策呢？</p><p id="f799" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这当然引发了关于数据质量、数据管理甚至数据的基本含义的问题。如何才能相信独一无二的数据？如果它与其他数据不符，它是如何创建的？保存它有什么实际价值吗？虽然NoSQL数据库在处理这种情况时提供了很好的灵活性，但是正式的模式定义非常有用。但首先，有一点背景知识，然后我们将看看为什么以及如何才能避免创建手工数据。</p><p id="83a6" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当使用SQL数据库时，我们经常会遇到定义数据结构的复杂模式。当我们想要对数据库进行更改时，我们可能还必须处理模式更改。进行模式更改的含义包括确保现有数据适合新的模式。或者，更常见的是，当我们修改数据库模式时，现有的应用程序编程不会中断。</p><p id="fcb8" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了避免模式更新的成本，聪明的工程师发明了各种打破SQL模式的数据库。这里我将使用<a class="ae kk" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Mongo </a>数据库作为例子，但是我们也可以使用<a class="ae kk" href="http://couchdb.apache.org/" rel="noopener ugc nofollow" target="_blank"> CouchDB </a>或<a class="ae kk" href="https://www.elastic.co/cloud" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>数据库。这也适用于所有试图减少或消除与正式模式定义冲突的数据库。</p><p id="e8a8" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这种方法的缺点是软件永远不会真正摆脱模式的约束。最糟糕的情况是一个非正式的、混乱的模式，其中每个事实都是一片独特的、闪闪发光的雪花。为了进行批量分析，必须对数据进行某种排序。虽然让应用程序代码灵活并能对变化做出响应是件好事，但在某种程度上，过于灵活可能会让人觉得步履蹒跚。那么，我们如何实现高度的灵活性，同时仍然对数据施加有意义的约束呢？</p><p id="7d83" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">而且没错，这是一个<em class="kj">《蟒蛇来营救》</em>的故事。很像<a class="ae kk" rel="noopener" href="/capital-one-developers/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792#.r33wlemze">我上一篇博文</a>。</p><h1 id="9e43" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">多重图式</h1><p id="df2d" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">一种SQL数据库策略需要使用三种密切相关的模式来描述我们的数据。这些模式提供了一个整洁、正式的定义，可以确保数据和处理一致。这三种模式是:</p><p id="f261" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">● <strong class="jg hi">作为数据分析师</strong>，我们关心能够回答我们问题的有意义的数据。在关系数据库中，这个模式是逻辑模型的视图定义和表。</p><p id="6fa0" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">● <strong class="jg hi">作为应用程序开发人员</strong>，我们关心数据的逻辑模型。这个模式将在应用程序代码上强加一个结构。该模式还应该满足许多技术约束，以减少数据重复，并防止“更新异常”。(想象一下当您更新一笔交易而总余额不变时的混乱。数据库工程师称之为“范式”违规。)</p><p id="eda1" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">● <strong class="jg hi">作为数据库管理员</strong>，我们关心数据的物理模型。此模式定义了数据在某些计算机的文件和磁盘驱动器中的位置。</p><p id="aa0b" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">虽然核心思想是优雅的，但实现可能会导致成本和复杂性的增加。请注意，这些图式没有抓住意义；他们专注于结构。例如，作为数据分析师，我们可能知道理解数据所需的不同策略和约束。像“不完整”和“不适用”这样的值之间的区别不是数据库模式的一部分:在数据库中，它们仅仅是一串字母。然而，对于处理数据的人来说，这些字符串可能反映了意义上的深刻差异。</p><p id="1faa" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">此外，为了使事情稍微复杂一点，这些模式中的每一个都有几种表示。模式以SQL语言语句的形式表示。它们也存在于数据库中，可供数据库引擎使用。此外，它们也反映在应用程序中。开发人员和数据库管理员将编写和执行SQL语句来定义和修改数据库结构。开发人员还将编写反映数据库结构的代码(例如，用Python)。</p><p id="77eb" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">保持数据库、应用程序处理和SQL代码同步是成本和复杂性增加的原因。虽然三模式的想法将不同的社区相互隔离，但这也意味着一个社区的变化会波及到另一个社区。如果开发人员更改了逻辑视图，用户视图的定义可能也需要更改，以便视图保持一致。当业务模型改变时，开发人员可能必须调整逻辑模式——可能还有物理模式——以确保可以处理新的特性。</p><p id="9913" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">随着我们的深入，我们将看到不同的模式表示。实际上，应用程序代码是逻辑模式的副本，但是是用Python这样的编程语言编写的。这意味着开发人员必须协调模式的代码版本和模式的SQL版本。</p><h1 id="5235" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">NoSQL自由</h1><p id="4552" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">一种NoSQL数据库方法是避开SQL语言。这是减轻正式模式定义负担的一部分。当然，这种自由有可能演变成无政府状态。NoSQL无政府状态是指似乎需要太多代码才能使数据可用的那种感觉。</p><p id="4b56" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">以下功能有助于避免无政府状态:</p><p id="9bd9" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●正式的模式</p><p id="49fa" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●仅定义一次</p><p id="6ff2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●最好是在代码中</p><p id="04b2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们需要一个正式的模式来提供数据组织的一个整洁的、集中的定义。我们希望在一个地方定义它，这样我们就不会有冲突。将模式放入应用程序代码意味着应用程序开发人员可以创建模式定义并定义数据处理。几乎显而易见的好处是消除了编写SQL语句。另一个好处是允许应用程序开发人员做一些数据库管理工作。这可以降低模式更改的成本和复杂性。</p><p id="b0b5" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们如何在没有开销的情况下获得模式的好处？下面我将介绍Python中几种可用的技术。</p><h1 id="c174" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">即席模式</h1><p id="894c" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">最容易导致无政府状态和手工数据的方法是隐藏在代码中的完全特定的模式。这里有一个例子，隐藏了一个可能的大失败。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/d2e9772b1d9e7b07c7351f33607c575c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpyYFKI-hUxdDDKwKDgMtQ.png"/></div></div></figure><p id="3a04" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个失败藏在哪里？在这段代码中，<strong class="jg hi"> doc['status'] </strong>、<strong class="jg hi"> doc['name'] </strong>和<strong class="jg hi"> doc['address'] </strong>都基于一些隐式模式定义。其他程序也使用这些字段吗？与该数据库交互的所有程序都同意该模式吗？如果他们不这样做，会发生什么？</p><p id="fd99" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如您所看到的，这种方法会导致手工数据。不同的应用程序可能对数据库中文档结构和集合名称的定义有不同意见。这意味着数据库中的文档没有一个通用的模式，我们的大数据分析变成了大数据清理。更糟糕的是，我们可能有应用程序看不见的数据，或者应用程序产生错误的结果，因为产生数据的程序与分析数据的程序没有相同的模式。</p><h1 id="a03b" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">对象-文档映射层</h1><p id="6486" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">有许多Python项目提供了Mongo数据库文档和Python对象之间的映射。可以看<a class="ae kk" href="http://mongoengine.org/" rel="noopener ugc nofollow" target="_blank"> mongoengine </a>、<a class="ae kk" href="http://namlook.github.io/mongokit/" rel="noopener ugc nofollow" target="_blank"> MongoKit </a>，或者<a class="ae kk" href="https://ming.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">明基础层</a>来解决。</p><p id="7028" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这些都允许我们通过类定义来定义模式。我们可以这样使用:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/3985273ac69e8f4d2e666fc6dac6f846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zh8nxZxDy-e6Gyfte-bFxg.png"/></div></div></figure><p id="38ac" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这具有优雅清晰的优点。我们可以将特定于文档的处理作为方法添加到类定义中。添加方法可能有一些优点，但是，它并不是普遍有价值的。</p><p id="51c3" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">然而，在一些应用中，尤其是大数据分析，细节文档没有任何方法可言。创建这些Python对象的处理开销可能没有好处。直接处理低级的Mongo友好的BSON对象也可能更有效。</p><p id="fca2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果我们只在Python中工作，这些类定义的优点是为数据库中的文档提供了一个整洁、完整的定义。我们可以利用这一点来避免人工数据。</p><p id="ff8a" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">此外，如果我们在多语言环境中工作，我们可能必须在多种编程语言之间共享定义。在这种情况下，Python类定义并不理想，因为它不能跨语言共享。</p><h1 id="5451" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">作为单独元数据的模式</h1><p id="c896" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">避免混乱的一个好方法是用某种语言不可知的形式来定义模式。这可以在程序和工具之间共享。不同的程序可以在模式上达成一致，我们可以避免手工数据。许多NoSQL数据库用JSON符号表示文档。我们也可以用JSON符号表示模式定义。</p><p id="05a2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="jg hi"> <em class="kj">参见</em></strong><a class="ae kk" href="http://json-schema.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jg hi"><em class="kj">http://json-schema.org/</em></strong></a><strong class="jg hi"><em class="kj">关于使用JSON文档的优雅的正式模式规范。</em>T19】</strong></p><p id="3744" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">基于JSON的模式定义是OpenAPI(也称为Swagger)规范的支柱。它提供了一套相当完整的规则，为我们可以保存在NoSQL数据库中的各种文档定义一个模式。我们可以使用JSON模式定义来表示模式。然后，在加载数据库文档之前，我们可以使用各种工具来验证文档。在这篇文章中，我们将关注用jsonschema项目验证模式和数据。</p><p id="6910" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="jg hi"> <em class="kj">详见</em></strong><a class="ae kk" href="https://python-jsonschema.readthedocs.org/en/latest/" rel="noopener ugc nofollow" target="_blank"><strong class="jg hi"><em class="kj"/></strong></a><strong class="jg hi"><em class="kj">。</em>T13】</strong></p><p id="e9ef" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当我们以Python列表和字典的形式处理数据库文档时，我们可以使用<strong class="jg hi"> jsonschema </strong>来确定这些数据结构是否匹配给定的模式定义。Mongo SON对象是Python字典的扩展，这使得它非常适合使用<strong class="jg hi"> jsonschema </strong>进行验证。</p><p id="b3fd" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将看看JSON模式定义的三个用例:<strong class="jg hi">设计和建模</strong>、<strong class="jg hi">数据验证</strong>，以及<strong class="jg hi">模式迁移</strong>。之后，我们将查看三个可以存储模式定义的地方，以便所有Python(和非Python)程序都可以使用它。最后，我们将看看Python元类，它使这变得相对简单。</p><h2 id="35d3" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">设计和建模</strong></h2><p id="663e" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">数据库设计通常从白板开始。我在骗谁呢？它似乎经常始于一张装满甜甜圈屑的咖啡店餐巾纸。和 <strong class="jg hi"> <em class="kj">然后</em> </strong> <em class="kj">移动到白板。)</em></p><p id="d150" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在某些时候，一个有形的例子比白板上的另一个演示或草图更有价值。使用Python时，这一点可能会在项目生命周期的早期出现。我们越早找到具体的例子，就能越早发现反例和性能瓶颈。</p><p id="9322" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我个人认为，用Python创造技术高峰可能是探索设计替代方案的理想方式。简单地构建Python代码并显示数据和性能影响的细节，通常比在相互竞争的演示文稿中反复推敲更容易。</p><p id="aa9f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">假设我们有几百万条客户档案记录。让我们进一步假设我们正在分析统一来自几个业务线的信息的源数据，每个业务线都有一个独特的客户关系视图。</p><p id="20c4" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以这样开始这个项目。首先，我们可以将近似我们将要使用的文档定义的类放在一起。具有嵌入式模式定义的类可能如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mc"><img src="../Images/4f7b0f3932fecdd6d275c06e11b4e9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHcxQ7JQ01h9sNFpZe7PjQ.png"/></div></div></figure><p id="547f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">该类扩展了PyMongo <strong class="jg hi"> bson。子</strong>类定义。这个类是一个有序的字典，添加了一些Mongo友好的特性。</p><p id="7d08" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在<strong class="jg hi"> Customer1 </strong>类中，我们以SON对象的形式提供了JSON模式，分配给类级变量<strong class="jg hi"> SCHEMA </strong>。这个模式可以用于很多事情。</p><p id="8021" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因为这个类本质上是一个字典，所以我们可以自由地试验不同种类的文档。我们能够以非常低的成本填充文档并草拟实验处理流程。这就是用Python构建的技术尖峰的好处。</p><p id="a655" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我喜欢包含<em class="kj"> pass </em>语句来确认类中除了docstring之外真的没有其他东西。该语句不做任何事情，也不是必需的，但是我发现它是一个有用的提示，表明类定义是完整的。</p><p id="3aaa" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在，我们可以把用具体例子说明模式的文档放在一起。创建模式的两个实例如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es md"><img src="../Images/28bf8f35f589432f89870f88547b0dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IS_ck2ZW6SPkMWF8yNx9wg.png"/></div></div></figure><p id="7577" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以使用这些对象来设计算法和HTML表示。当我们更好地理解问题和每个潜在的解决方案时，我们也可以改进模式。</p><p id="4a9c" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="jg hi">注意:</strong>SON作为基类有一个缺点。属性引用使用大量语法，导致如下表达式:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es me"><img src="../Images/8404e3da17327b928c3f1a4311c91d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nC-naB0kTO8flV55nlz3Pw.png"/></div></div></figure><p id="0dc2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">通常我们更喜欢使用<strong class="jg hi"> c2.address </strong>来引用一个属性的值。为此，我们必须使用复杂的元类。这里的要点是快速处理想法，而不是构建最终的应用程序。</p><p id="f258" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于设计和建模，它有助于在每次使用时验证每一个文档。这增加了一点处理开销。知道文档符合模型的好处远远超过成本。</p><p id="1f0d" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">那么我们如何知道模式本身是有效的呢？对模式语法的检查如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mf"><img src="../Images/1f19ab5753cee38809b8ba13d36ff71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqWcCnFA4U9hUvW8h6y4xw.png"/></div></div></figure><p id="2aa3" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以快速检查一下，确保模式本身符合JSON-Schema标准。除了一些小的例外，符合JSON模式标准的模式也将符合Open API (Swagger)标准。如果你好奇的话:Swagger改变了JSON模式的一些更高级的特性。Swagger不使用 <strong class="jg hi"> <em class="kj"> allOf </em> </strong> <em class="kj">关键字；它还限制了什么可以出现在一个</em> <strong class="jg hi"> <em class="kj">项</em> </strong> <em class="kj">，</em> <strong class="jg hi"> <em class="kj">属性</em> </strong> <em class="kj">和</em> <strong class="jg hi"> <em class="kj">附加属性</em> </strong> <em class="kj">关键字中。】</em></p><p id="cf42" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以使用下面的代码来生成一个JSON文档，作为Swagger规范中的外部引用:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mf"><img src="../Images/1d9077d7cb20cabd1e40a52c38fcc9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SQ2t7TfSbiU9Rr2QHO97w.png"/></div></div></figure><p id="60c9" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这将把<strong class="jg hi">模式</strong>文档翻译成JSON符号。</p><h2 id="ec22" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">数据验证</strong></h2><p id="e2b9" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">仔细观察示例文档——如上所示的<strong class="jg hi"> c1 </strong>和<strong class="jg hi">C2</strong>——我们可以看到文档<strong class="jg hi"> c2 </strong>不符合模式:状态字段具有无效值。当创建技术尖峰时，这是一个方便的特性。一种放松的验证方法允许我们探索问题空间，而不同时与技术障碍作斗争。</p><p id="fceb" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">随着我们向健壮、可扩展的解决方案迈进，数据必须是有效的。数据验证是一个复杂的主题，有几种有效程度:</p><p id="e838" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●原子字段值。在<strong class="jg hi"> jsonschema </strong>验证中很好地涵盖了值是原始类型的单个实例的字段。</p><p id="0c81" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●文档结构。具有复杂数组或文档值的字段也被<strong class="jg hi"> jsonschema </strong>验证很好地覆盖了。</p><p id="783f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●记录关系。我们可能有一个文档，其中有一个余额数组和一个包含该数组总计的字段。JSON模式没有提供一种正式的方式来指定项目之间的关系。我们可以为此提供描述文本。</p><p id="6814" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●收集文件。我们可能有更深层次的约束，Mongo数据库中的一个集合有描述另一个集合中的文档的汇总信息。</p><p id="74bf" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">字段验证的一个简单例子如下:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mf"><img src="../Images/12565d8eec345e89c862258b4cf584ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6VeRm687e9dPLsFxwdqnA.png"/></div></div></figure><p id="dea3" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这将对一个文档应用<strong class="jg hi"> validate() </strong>方法，该方法将对任何无效值引发异常。我们可能还想使用一个<strong class="jg hi"> try </strong>:语句来为引发的异常打印一些有意义的内容。我们稍后将回到这一点。</p><p id="a8e7" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">异常摘要如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mg"><img src="../Images/d6a150959642cfbf3d5df9f6d1066fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5maNI-81ad4g8KYgvmqrwA.png"/></div></div></figure><p id="6c26" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当我们在做设计工作时，这可以帮助我们确定设计涵盖了示例。我们可以利用这种简单的技术来快速构建示例和细化模式。</p><p id="7e29" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">通常，我们需要观察我们进行数据验证的频率。对于大量的数据和复杂的文档，处理时间会增加。创建文档时对其进行验证是非常重要的。另一个重要的时候是在进行模式迁移的时候。</p><p id="d87a" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">然而，对于应用程序代码中的操作，我们不想做这种手动验证。为此，我们需要更智能的东西。下面，我们将展示一个元类的一些代码，它在创建对象时处理验证过程。</p><h2 id="fb51" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">模式迁移</strong></h2><p id="79e0" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">当我们要对集合中的文档结构进行大规模更改时，例如向所有现有文档添加一个字段或重命名字段，就会发生模式迁移。添加一个可选字段对应用程序的影响较小:代码可以继续使用没有字段的旧文档和有字段的新文档。</p><p id="e294" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当对数据库中的现有文档进行更改时，在尝试任何更改之前，确保文档确实符合旧的模式是很有帮助的。我们还应该检查所有文档，以确保它们符合新的模式，然后在更改后尝试使用数据库。</p><p id="ff77" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以像这样使用<strong class="jg hi"> jsonschema </strong>验证:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mf"><img src="../Images/5c80d1e44672dd4c7a8a2611199c2fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-RpcCgj0zNSRYBWWVVNOCQ.png"/></div></div></figure><p id="54bf" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们使用了<strong class="jg hi">客户1。模式</strong>验证<strong class="jg hi"> customer_1 </strong>集合中的每个对象。我们使用了一个<strong class="jg hi"> try </strong>:块，这样我们就可以打印每个引发的异常并显示不兼容的文档。</p><p id="6f8b" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于大型数据库或数据库中的复杂文档，这需要时间。必须权衡所需的时间和不合规文件的成本。因为代码非常简单，所以很容易将处理分解成多个并发进程，每个进程验证一个大型数据库的一部分。</p><p id="558e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">迁移可能涉及额外的处理。在这种情况下，我们可以创建一个<strong class="jg hi"> Customer </strong> 1类的实例，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mh"><img src="../Images/e784e78026ffaad85317dc92aa1b76f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCIKYh1vux8nqAb6aI1ygQ.png"/></div></div></figure><p id="adec" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这将把底层的Mongo BSON文档转换成<strong class="jg hi"> Customer1 </strong>的一个实例。如果我们已经定义了定制的方法，它们可以在<strong class="jg hi">文档</strong>中使用。</p><h1 id="73d1" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">保存模式的位置</h1><p id="3e8d" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">在上面的例子中，我们使用一个类级变量<strong class="jg hi"> SCHEMA </strong>将模式包含在类定义中。对于保存模式的位置，我们有另外三种常见的选择:<strong class="jg hi"> <em class="kj">在文件中，在服务器中，在数据库中</em> </strong> <em class="kj">。</em></p><h2 id="d70b" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">在一档</strong></h2><p id="03b0" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">要包含文件中的模式，我们可能会使用如下代码:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mc"><img src="../Images/728484cbb8cb78ead511e637fd9441f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUywWepjy7neUu8_I7G9gw.png"/></div></div></figure><p id="0766" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们已经为包含模式定义的目录定义了一个<strong class="jg hi">路径</strong>。然后，我们可以打开一个特定的模式文件，并使用该对象来填充与应用程序类相关联的定义。</p><h2 id="2d2c" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">服务器中的</strong></h2><p id="caf4" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">我们也可以使用一个URL从一个<strong class="jg hi"> api-docs </strong>目录中加载一个模式。我们可以使用<strong class="jg hi"> urllib.request </strong>来读取模式定义。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mi"><img src="../Images/8ca7e4860535f1e9a6bba8ff181dcf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_ej4Xh15-KN2SjkptlywA.png"/></div></div></figure><p id="c6b8" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在我们已经打开了一个URL并阅读了JSON规范。这些通常以字节的形式提供，我们需要解码这些字节来恢复正确的文本。然后，我们可以解析该文本来创建应用程序可以使用模式文档。</p><h2 id="6241" class="lo km hh bd kn lp lq lr kr ls lt lu kv jn lv lw kx jr lx ly kz jv lz ma lb mb bi translated"><strong class="ak">数据库中的</strong></h2><p id="c005" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">如果我们想在数据库中保存模式信息，我们可以使用类似这样的东西来读取模式细节。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mc"><img src="../Images/b4d6d3759f4a3b2d3b07f1591881b934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWUb9ZkEbJwwiXIvkocHCQ.png"/></div></div></figure><p id="2b31" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这里假设我们有一个名为<strong class="jg hi"> db </strong>的PyMongo客户端。它还要求数据库有一个包含各种模式文档的<strong class="jg hi">模式</strong>集合。我们已经使用了模式标题和扩展(<strong class="jg hi"> x-version </strong>)来定位在我们的应用程序中使用的模式定义的正确版本。</p><p id="9a66" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在MongoDB中，有一个可以附加到集合的模式验证规则集。这为在数据库插入和更新操作期间实现JSON模式验证的某些方面提供了一种方法。</p><p id="c140" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在这三种情况下，从外部源加载模式所需的代码量都很少。这是Python的一个令人欣喜的特性！因为Python是一种动态语言，我们可以编写非常聪明的类来适应模式细节。</p><p id="0b58" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">通常，我们希望模式验证基本上是不可见的。创建无缝验证的最佳方式是使用元类。</p><h1 id="f48e" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">Python元类</h1><p id="0827" class="pw-post-body-paragraph je jf hh jg b jh ld ii jj jk le il jm jn lf jp jq jr lg jt ju jv lh jx jy jz ha bi translated">我们的应用程序代码通常关注一些数据模型的实例。上面，我们创建了扩展SON集合的类。这需要一点人工开销来进行验证。我们可以使用元类使验证步骤无缝。</p><p id="252c" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">添加一个元类将把我们带到一个抽象的<strong class="jg hi">模型</strong>类。拥有这个定义基类和元类的抽象类将会简化我们的应用程序。下面是我们可以用于经验证的NoSQL数据模型的超类:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mj"><img src="../Images/3ccba647b52f229fb1cb5f0267a48c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgzro3zWBJN08NBWQiGtTQ.png"/></div></div></figure><p id="253e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个<strong class="jg hi">模型</strong>类是PyMongo的<strong class="jg hi">儿子</strong>类的子类。我们可以以直接和低开销的方式与Mongo <strong class="jg hi"> SON </strong>对象进行交互。</p><p id="e1fb" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">任何子类都需要为<strong class="jg hi">模式</strong>提供一个值，给定的模式定义将用于数据验证。这将涉及到一点元类的魔力，如下所示。</p><p id="95cb" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">例如，<strong class="jg hi"> __init__ </strong>方法利用了元类创建的名为<strong class="jg hi"> _validator </strong>的属性。根据模式定义的细节设置一些其他类级别的值是很有帮助的。</p><p id="9340" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以如下使用<strong class="jg hi">模型</strong>类:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mk"><img src="../Images/a3f4ca44630428c4bbb7763b2786e0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NFCezFgUlNVRQMuh3ZCiQ.png"/></div></div></figure><p id="3765" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这与上面给出的例子基本相同。我们做了一个实质性的改变:我们用<strong class="jg hi">型号</strong>替换了<strong class="jg hi">子</strong>。类定义的其余部分是相同的，但是我们现在有了可用的验证特性。</p><p id="e261" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们如何创造<strong class="jg hi">自我。_validator </strong>？下面是根据模式定义构建<strong class="jg hi"> _validator </strong>属性的元类:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mc"><img src="../Images/7041ebd5ecb9b6d7fbc7747b5bc0e31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHKcRADOSUsOmT43gf9pjw.png"/></div></div></figure><p id="f96e" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们已经做了一些事情来准备一个通用的<strong class="jg hi">模型</strong>的子类。首先，我们检查了模式，以确保根据JSON模式规范它是有效的。这一步不是必需的，因为当我们试图构建<strong class="jg hi"> _validator </strong>时，也会执行这一步。但是，单独做这件事很方便，因为它可以帮助调试模式定义的问题。</p><p id="7d76" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果模式有效，那么我们将从模式中提取四个值。</p><p id="3a87" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●我们将使用模式的<strong class="jg hi">描述</strong>属性作为整个类的文档字符串。</p><p id="68ec" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●模式扩展<strong class="jg hi"> x-collection </strong>用于设置集合属性。这对于识别正确的MongoDB集合名称非常方便。</p><p id="5a92" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●模式扩展<strong class="jg hi"> x-version </strong>设置版本属性。这对于检查应用程序兼容性非常方便。</p><p id="1f6d" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●最后，我们创建类的<strong class="jg hi">_验证器</strong>属性。这使我们能够<strong class="jg hi">利用自我。_validator.validate() </strong>根据需要检查类实例的有效性。默认情况下，我们只在创建新实例时这样做。我们可以添加同样使用<strong class="jg hi"> _validator </strong>的方法。同样，其他类可以使用<strong class="jg hi"> Customer1。_validator </strong>作为数据准备或清理操作的一部分。</p><h1 id="7adc" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">结论</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ml"><img src="../Images/795f814f36135a59ced3e700b2bfb4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1w7eKPFcY51JKOl8oDZAw.jpeg"/></div></div></figure><p id="53a2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">NoSQL数据库消除了数据库解决方案开发中的一些复杂性和开销。虽然它允许我们放弃正式的模式定义，但这可能太自由了。对数据缺乏控制的NoSQL数据库可能会变成手工数据，从而降低数据的价值。共享模式的一般思想对于确保所有使用数据库的应用程序在数据库结构上保持一致是至关重要的。一盒12个甜甜圈不应该包括网球、牡蛎或小猫。(<em class="kj">也不应该包括果冻甜甜圈</em>。)</p><p id="bf04" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以将模式嵌入Python类定义中，我们可以用JSON符号将它保存在外部文件中，我们可以从服务器提供它，甚至可以将它保存在Mongo数据库中。重要的是我们坚持三个核心原则:</p><p id="71d5" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●正式的模式</p><p id="943f" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●仅定义一次</p><p id="4ca3" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">●最好是在代码中。</p><p id="62b2" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以在项目生命周期的几个点上将模式应用于数据验证。我们可能希望在初始设计阶段有很大的灵活性。当我们构建应用程序时，我们希望确保对象实例符合模式。当对数据库进行结构更改时，我们希望在尝试任何更改之前确认所有文档都与模式匹配。我们还希望在做出更改后确认所有文档都匹配一个模式。</p><p id="a738" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了获得NoSQL数据库的灵活性，并避免手工数据，我们需要模式的灵活定义。使用像<strong class="jg hi"> jsonschema </strong>这样的模块允许我们用JSON表示一个模式。该模式可以嵌入到类定义中，并且可以用于验证该类的所有实例。</p><p id="09e9" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">上面的例子包括一个小的(10行代码)元类定义，<strong class="jg hi"> SchemaMeta </strong>，和另一个小的(18行代码)超类定义，<strong class="jg hi">模型</strong>。有了它，我们可以利用一个具有面向数据库的类定义的模式。这使我们能够保证数据的质量，并避免创建无法分析的数据，或对数据应用错误的分析。</p><p id="3ea7" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Python的强大意味着几行代码就可以提供管理数据的基本功能。这可以避免NoSQL数据库可能带来的混乱。我更喜欢手工制作的甜甜圈，而不是纠结于复杂的手工数据。我打赌你也有同感。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="bec4" class="pw-post-body-paragraph je jf hh jg b jh ji ii jj jk jl il jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">要了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。<a class="ae kk" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="kj"/></a></p></div></div>    
</body>
</html>