<html>
<head>
<title>Introduction to Jetpack DataStore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack数据存储简介</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7?source=collection_archive---------3-----------------------#2022-01-18">https://medium.com/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7?source=collection_archive---------3-----------------------#2022-01-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/fda03c74b14dc698b050c410ba68987c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWqA2GDAZEsF3sFppQTd1g.png"/></div></div></figure><div class=""/><p id="0a97" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> DataStore </strong> </a>是一个Jetpack数据存储库，它提供了一种安全一致的方式来存储少量数据，如首选项或应用程序状态。它基于支持异步数据存储的<strong class="ir ht"> Kotlin协同程序和流程</strong>。它旨在取代<code class="du jo jp jq jr b">SharedPreferences</code>，因为它是线程安全和非阻塞的。它提供了两种不同的实现:<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-typed" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto DataStore</strong></a>，它存储类型化的对象(由<a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>支持)和<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-preferences" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Preferences DataStore</strong></a>，它存储键值对。接下来，当我们仅使用<code class="du jo jp jq jr b">DataStore</code>时，这指的是两种实现，除非另有说明。</p><p id="f0f8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博文中，我们将进一步了解<strong class="ir ht">数据存储— </strong>它是如何工作的，它提供了哪些实现以及它们各自的使用案例。我们还将看看它给<code class="du jo jp jq jr b">SharedPreferences</code>带来了什么好处和改进，以及为什么这些让数据存储值得你去做。</p><h1 id="feb4" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据存储与共享首选项</h1><p id="d0b6" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">很可能你已经在你的应用中使用过<code class="du jo jp jq jr b">SharedPreferences</code>。你也可能经历过<code class="du jo jp jq jr b">SharedPreferences</code>的问题，这些问题<strong class="ir ht">很难重现</strong>——在你的分析中看到由于未捕获的异常导致的奇怪的崩溃，在调用时阻塞UI线程，或者在你的应用中出现不一致的持久数据。数据存储库就是为了解决所有这些问题而构建的。</p><p id="d9f7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看一下<code class="du jo jp jq jr b">SharedPreferences</code>和数据存储之间的直接比较:</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kv"><img src="../Images/ff12eecb6d04fad51b39d79d8377030d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PY9ynFd3rwC05qTQ7pDFlg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">Comparing DataStore implementations with SharedPreferences</figcaption></figure><h2 id="3646" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">异步API </strong></h2><p id="20dc" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">对于大多数数据存储API，当数据被修改时，您通常需要得到异步通知<strong class="ir ht">。<code class="du jo jp jq jr b">SharedPreferences</code>确实为<em class="ls">提供了一些</em>异步支持，但仅仅是为了通过<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/android/content/SharedPreferences.OnSharedPreferenceChangeListener" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">OnSharedPreferenceChangeListener</strong></a></code>获得更改值的更新。然而，这个回调仍然在<strong class="ir ht">主线程</strong>上被调用。类似地，如果你想将文件保存工作卸载到后台，你可以使用<code class="du jo jp jq jr b">SharedPreferences</code> <code class="du jo jp jq jr b">apply()</code>，但是记住这将<strong class="ir ht">阻塞<code class="du jo jp jq jr b">fsync()</code>上的UI线程</strong>，潜在地导致jank和ANRs。这可能发生在服务启动或停止，或者活动暂停或停止的任何时候。相比之下，DataStore提供了一个<strong class="ir ht">完全异步的API </strong>来检索和保存数据，使用Kotlin协同程序和流的能力，降低了阻塞UI线程的风险。对于那些不熟悉Kotlin流的人来说，它只是一个可以异步计算的值流。</strong></p><h2 id="6049" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">同步工作</strong></h2><p id="eb99" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b">SharedPreferences</code> API支持开箱即用的同步工作。然而，它的用于修改持久化数据的同步<code class="du jo jp jq jr b">commit()</code>看起来在UI线程上调用是安全的，但是它实际上执行了<strong class="ir ht">更重的I/O操作</strong>。这是一个有风险的场景，可能并且经常会导致ANRs和UI jank。为了防止这种情况，数据存储<strong class="ir ht">不提供现成的同步支持</strong>。DataStore将首选项保存在一个文件中，除非另有说明，否则它会在<code class="du jo jp jq jr b"><strong class="ir ht">Dispatchers.IO</strong></code> <strong class="ir ht">、</strong>上执行所有数据操作，从而保持UI线程的畅通。</p><p id="cfac" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，在协程构建器的帮助下，将数据存储和同步工作结合起来是可能的，我们将在后面看到。</p><h2 id="38aa" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">错误处理</strong></h2><p id="f606" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b">SharedPreferences</code>可以抛出解析错误作为运行时异常，让你的应用容易崩溃。例如，<code class="du jo jp jq jr b">ClassCastException</code>是API在请求<strong class="ir ht">错误数据类型</strong>时抛出的常见异常。数据存储提供了一种<strong class="ir ht">在读取或写入数据时捕捉任何异常</strong>的方式，依靠流的错误信号机制。</p><h2 id="b932" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">类型安全</strong></h2><p id="e3ff" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">使用映射键值对来保存和检索数据不提供类型安全保护。然而，使用Proto DataStore，您可以为您的数据模型预定义一个模式，并获得<strong class="ir ht">全类型安全</strong>的额外好处。</p><h2 id="10af" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">数据一致性</strong></h2><p id="5f13" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">缺乏原子性保证意味着你不能依赖于你的数据修改总是在任何地方被反映。这可能是危险的，特别是因为这个API的全部目的是<strong class="ir ht">持久化数据存储</strong>。相比之下，数据存储的<strong class="ir ht">完全事务API </strong>提供了强大的<a class="ae jn" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>保证，因为数据是在<strong class="ir ht">原子读-修改-写</strong>操作中更新的。它还提供了“<em class="ls">写后读</em>”一致性，反映了所有已完成的更新将反映在读取值中的事实。</p><h2 id="3afd" class="le jt hs bd ju lf lg lh jy li lj lk kc ja ll lm kg je ln lo kk ji lp lq ko lr bi translated"><strong class="ak">迁移支持</strong></h2><p id="fe83" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b">SharedPreferences</code>没有内置的迁移机制，您需要完成一些繁琐且容易出错的工作，将旧存储中的值重新映射到新存储中，然后进行清理。所有这些都增加了<strong class="ir ht">运行时异常</strong>的几率，因为您很容易遇到数据类型不匹配的问题。然而，数据存储提供了一种将数据轻松迁移到数据存储的方式，并提供了从<code class="du jo jp jq jr b">SharedPreferences</code>到数据存储的迁移实现。</p><h1 id="26c1" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">首选项与原始数据存储</h1><p id="0261" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">既然我们已经看到了数据存储相对于<code class="du jo jp jq jr b">SharedPreferences</code>提供的优势，那么让我们来讨论如何在它的两种实现— <strong class="ir ht"> Preferences和Proto DataStore </strong>之间做出选择。</p><p id="1f48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-preferences" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">首选项</strong> <strong class="ir ht">数据存储</strong> </a>根据<strong class="ir ht">键值对</strong>读取和写入数据，无需预先定义模式。虽然这听起来可能类似于<code class="du jo jp jq jr b">SharedPreferences</code>，但是请记住上面提到的数据存储带来的所有改进。不要被它们在命名中联合使用“<em class="ls"> Preferences </em>”所迷惑——它们没有任何共同点，并且来自两个完全不同的API。</p><p id="2bb7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-typed" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto</strong><strong class="ir ht">DataStore</strong></a>存储<strong class="ir ht">类型化的对象</strong>，由<code class="du jo jp jq jr b"><a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Protocol Buffers</strong></a></code>支持，提供类型安全并消除对密钥的需求。Protobufs比XML和其他类似的数据格式更快、更小、更简单、更明确。如果你以前没有用过它们，不用担心！这些很容易学。虽然Proto DataStore确实需要您学习一种新的序列化机制，但我们相信它的优势，尤其是<strong class="ir ht">类型安全</strong>，是值得的。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es lt"><img src="../Images/96930be058b8dcd470b4861aac345424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*vppLP99jQd578PjJbHmonw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx">Comparing DataStore implementations</figcaption></figure><p id="1ab6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在两者之间进行选择时，您应该考虑以下因素:</p><ul class=""><li id="cfe8" class="lu lv hs ir b is it iw ix ja lw je lx ji ly jm lz ma mb mc bi translated">如果您正在使用<strong class="ir ht">键-值对</strong>来读写数据，希望<strong class="ir ht">以最小的改变从<code class="du jo jp jq jr b">SharedPreferences</code>快速迁移</strong>，同时仍然利用数据存储的改进，并且在没有类型安全检查的情况下感到足够自信，您可以使用<strong class="ir ht">首选项数据存储</strong></li><li id="28f0" class="lu lv hs ir b is md iw me ja mf je mg ji mh jm lz ma mb mc bi translated">如果您希望学习协议缓冲区以获得提高可读性的额外好处，如果您的数据需要处理<strong class="ir ht">更复杂的类</strong>，如枚举或列表，并且您希望在这样做的同时获得<strong class="ir ht">完全类型安全</strong>支持，您可以尝试<strong class="ir ht"> Proto DataStore </strong></li></ul><h1 id="c6ff" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据存储与房间</h1><p id="f13e" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">你可能会问——“<em class="ls">嗯，为什么不直接用</em> <a class="ae jn" href="https://developer.android.com/training/data-storage/room" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> <em class="ls">房间</em> </strong> </a> <em class="ls">来存储我的数据</em>？”。这是一个公平的问题！所以，让我们来看看这一切的空间。</p><p id="935f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您需要处理大于几十kb的复杂数据集，很可能您需要不同数据表之间的部分更新。在这种情况下，你应该考虑使用<strong class="ir ht">房间</strong>。</p><p id="4c43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，如果你正在使用<strong class="ir ht">更小更简单的</strong> <strong class="ir ht">数据集</strong>，比如偏好或应用状态，因此不需要部分更新或参照完整性，你应该选择<strong class="ir ht">数据存储</strong>。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/1328d552d811150782f56dd0edc0d932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axaWKqHMR3NdT_NIUhISRQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">How to choose between DataStore and Room</figcaption></figure><h1 id="11f4" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">待续</h1><p id="17b6" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们已经更详细地介绍了<strong class="ir ht">数据存储库</strong> —它是如何工作的，它带来了哪些变化和改进，以及如何在两种实现方式之间做出选择。在接下来的两篇博文中，我们将进一步讨论<strong class="ir ht"> Proto和Preferences DataStore</strong>——如何创建、读取和写入数据，处理任何错误，以及如何从<code class="du jo jp jq jr b">SharedPreferences</code>迁移。敬请期待！</p><p id="f8ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在这里找到我们的Jetpack DataStore系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack DataStore简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项DataStore </a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型DataStore</a><br/><a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">DataStore和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c"> DataStore和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c"> DataStore和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa"> DataStore和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8"> DataStore和测试</a></p></div></div>    
</body>
</html>