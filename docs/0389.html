<html>
<head>
<title>Easy Coroutines in Android: viewModelScope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的简单协同程序:视图模型范围</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471?source=collection_archive---------0-----------------------#2019-03-19">https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471?source=collection_archive---------0-----------------------#2019-03-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1fd9f5c7b4ee89f90326151046f4afbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Dyf1lQkPqZa08juZk6lKw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="hu">Illustration by </em><a class="ae hv" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank"><em class="hu">Virginia Poltrack</em></a></figcaption></figure><div class=""/><p id="a38b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">当不再需要协程时，取消它们是一项容易忘记的任务，这是一项单调的工作，并且增加了许多样板代码。<code class="du jt ju jv jw b">viewModelScope</code>通过向ViewModel类添加一个<a class="ae hv" href="https://kotlinlang.org/docs/reference/extensions.html#extension-properties" rel="noopener ugc nofollow" target="_blank">扩展属性</a>来为<a class="ae hv" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank">结构化并发</a>做出贡献，该扩展属性在ViewModel被销毁时自动取消其子协程。</p><h1 id="5fc8" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">视图模型中的范围</h1><p id="9acf" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">一个<a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" rel="noopener ugc nofollow" target="_blank">协程作用域</a>跟踪它创建的所有协程。因此，如果取消一个作用域，就会取消它创建的所有协程。如果您在<a class="ae hv" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">视图模型</a>中运行协程，这一点尤其重要。如果您的ViewModel被破坏，那么它可能正在做的所有异步工作都必须停止。否则，您将浪费资源并可能泄漏内存。如果您认为某些异步工作应该在ViewModel销毁后继续，那是因为它应该在应用程序架构的较低层完成。</p><p id="7062" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">通过使用您在<code class="du jt ju jv jw b">onCleared()</code>方法中取消的<a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html" rel="noopener ugc nofollow" target="_blank"> SupervisorJob </a>创建一个新的作用域，向您的ViewModel添加一个协程作用域。只要ViewModel还在使用，用这个作用域创建的协程就会一直存在。请参见以下代码:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="5614" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果视图模型被破坏，后台发生的繁重工作将被取消，因为协程是由那个特定的<code class="du jt ju jv jw b">uiScope</code>启动的。</p><p id="9a8f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">但是每个视图模型中都包含大量代码，对吗？<code class="du jt ju jv jw b"><strong class="ix hz">viewModelScope</strong></code>来简化这一切。</p><h1 id="9930" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">viewModelScope意味着更少的样板代码</h1><p id="16bd" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated"><a class="ae hv" href="https://developer.android.com/jetpack/androidx/releases/lifecycle" rel="noopener ugc nofollow" target="_blank">AndroidX life cycle v 2 . 1 . 0</a>向ViewModel类引入了扩展属性<code class="du jt ju jv jw b">viewModelScope</code>。它管理协程的方式与我们在上一节中所做的一样。这段代码被简化为:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="1ed3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">所有的协同作用域设置和取消都为我们完成了。要使用它，请在您的<code class="du jt ju jv jw b">build.gradle</code>文件中导入以下依赖项:</p><pre class="la lb lc ld fd lg jw lh li aw lj bi"><span id="06d8" class="lk jy hy jw b fi ll lm l ln lo">implementation "androidx.lifecycle.lifecycle-viewmodel-ktx$lifecycle_version"</span></pre><p id="a9d6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们来看看引擎盖下发生了什么。</p><h1 id="d52a" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">深入查看视图模型范围</h1><p id="c517" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">代码是<a class="ae hv" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt" rel="noopener ugc nofollow" target="_blank">公开可用的</a>。<code class="du jt ju jv jw b">viewModelScope</code>实现如下:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="9688" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">ViewModel类有一个<code class="du jt ju jv jw b">ConcurrentHashSet</code>属性，可以存储任何类型的对象。协程示波器存放在那里。如果我们看一下代码，方法<code class="du jt ju jv jw b">getTag(JOB_KEY)</code>试图从那里检索范围。如果它不存在，那么它会像我们之前一样创建一个新的协同作用域，并将标签添加到包中。</p><p id="7e1b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">当ViewModel被清除时，它在调用<code class="du jt ju jv jw b">onCleared()</code>方法之前执行<code class="du jt ju jv jw b">clear()</code>方法，否则我们将不得不覆盖这个方法。在<code class="du jt ju jv jw b">clear()</code>方法中，ViewModel取消了<code class="du jt ju jv jw b">viewModelScope.</code>的工作<a class="ae hv" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle/ViewModel.java" rel="noopener ugc nofollow" target="_blank">完整的ViewModel代码也是可用的</a>，但是我们只关注我们感兴趣的部分:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="4e32" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">该方法遍历包中的所有项目，并调用<code class="du jt ju jv jw b">closeWithRuntimeException</code>来检查对象是否属于类型<code class="du jt ju jv jw b">Closeable </code>，如果是，则关闭它。为了让ViewModel关闭范围，它需要实现<code class="du jt ju jv jw b">Closeable</code>接口。这就是为什么<code class="du jt ju jv jw b">viewModelScope</code>是扩展<code class="du jt ju jv jw b">CoroutineScope</code>覆盖<code class="du jt ju jv jw b">coroutineContext</code>并实现<code class="du jt ju jv jw b">Closeable</code>接口的<code class="du jt ju jv jw b"><strong class="ix hz">CloseableCoroutineScope</strong></code>类型。</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="28ea" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">调度员。默认为Main</h1><p id="438a" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated"><code class="du jt ju jv jw b">Dispatchers.Main.immediate</code>被设置为<code class="du jt ju jv jw b">viewModelScope</code>的默认<a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" rel="noopener ugc nofollow" target="_blank">协程调度器</a>。</p><pre class="la lb lc ld fd lg jw lh li aw lj bi"><span id="d6a6" class="lk jy hy jw b fi ll lm l ln lo">val scope = CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span></pre><p id="8f24" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><code class="du jt ju jv jw b">Dispatchers.Main</code>很适合这种情况，因为ViewModel是一个与UI相关的概念，经常涉及更新它，因此在另一个dispatcher上启动将引入至少2个额外的线程切换。考虑到suspend函数将正确地执行自己的线程限制，使用其他调度程序将不是一个选项，因为我们将假设ViewModel正在做什么。</p><p id="28ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><code class="du jt ju jv jw b">immediate</code>用于立即执行协程，而无需将工作重新<code class="du jt ju jv jw b"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/dispatch.html" rel="noopener ugc nofollow" target="_blank">dispatch</a></code>到适当的线程。</p><h1 id="a419" class="jx jy hy bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">单元测试视图模型范围</h1><p id="9813" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated"><code class="du jt ju jv jw b">Dispatchers.Main</code>使用Android <code class="du jt ju jv jw b">Looper.getMainLooper()</code>方法在UI线程中运行代码。这种方法在Android测试中可用，但在单元测试中不可用。</p><p id="e8d3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">通过用<code class="du jt ju jv jw b">org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version</code>中可用的<a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">TestCoroutineDispatcher</a>调用<code class="du jt ju jv jw b">Dispatchers.setMain(dispatcher: CoroutineDispatcher)</code>，使用<code class="du jt ju jv jw b">org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version</code>库来替换Coroutines主调度程序。请注意，只有当您在代码库中使用<code class="du jt ju jv jw b">viewModelScope</code>或者硬编码<code class="du jt ju jv jw b">Dispatchers.Main</code>时，才需要<code class="du jt ju jv jw b">Dispatchers.setMain</code>。</p><p id="8cc2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><a class="ae hv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">TestCoroutineDispatcher</strong></a>是一个调度程序，它让我们控制协同程序如何执行，能够暂停/恢复执行并控制其虚拟时钟。它是作为一个实验性的API被添加到Kotlin Coroutines v1.2.1中的。你可以在<a class="ae hv" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test" rel="noopener ugc nofollow" target="_blank">文档</a>中读到更多关于它的内容。</p><p id="dfe4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">不要用<code class="du jt ju jv jw b">Dispatchers.Unconfined</code>代替<code class="du jt ju jv jw b">Dispatchers.Main</code>，这会破坏所有使用<code class="du jt ju jv jw b">Dispatchers.Main</code>的代码的假设和计时。由于单元测试应该在隔离状态下运行良好，并且没有任何副作用，所以您应该在测试结束运行时调用<code class="du jt ju jv jw b">Dispatchers.resetMain()</code>并清理执行器。</p><p id="78cb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">您可以使用这个带有逻辑的JUnitRule来简化您的代码:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="492d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在，您可以在您的单元测试中使用它。</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="bbbf" class="lk jy hy bd jz lp lq lr kd ls lt lu kh jg lv lw kl jk lx ly kp jo lz ma kt mb bi translated">使用Mockito测试协程</h2><p id="d066" class="pw-post-body-paragraph iv iw hy ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">你是否使用Mockito并希望<code class="du jt ju jv jw b">verify</code>与一个对象发生交互？注意，使用Mockito的<code class="du jt ju jv jw b">verify</code>方法并不是单元测试代码的首选方式。您应该检查特定于应用程序的逻辑，如元素是否存在，而不是验证与对象的交互是否发生。</p><p id="0005" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在检查与对象的交互发生之前，我们需要确保所有启动的协程都已经完成。让我们看看下面的例子。</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="466d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在测试中，我们在规则创建的<code class="du jt ju jv jw b">TestCoroutineDispatcher</code>中调用<code class="du jt ju jv jw b">runBlockingTest</code>方法。由于该调度程序覆盖了<code class="du jt ju jv jw b">Dispatchers.Main</code>，MainViewModel也将在该调度程序上运行协程。调用<code class="du jt ju jv jw b">runBlockingTest</code>将使协程在测试中同步执行。因为我们的<code class="du jt ju jv jw b">verify</code> Mockito调用在<code class="du jt ju jv jw b">runBlockingTest</code>块中，所以它将在协程完成后被调用，并且交互将在那时发生。</p><p id="105d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">再举一个例子，看看我们是如何将这种单元测试添加到Kotlin协同程序代码实验室的:</p><div class="hg hh ez fb hi mc"><a href="https://github.com/googlecodelabs/kotlin-coroutines/pull/29" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hz fi z dy mh ea eb mi ed ef hx bi translated">通过manuelvicnt Pull请求#29将单元测试添加到MainViewModel</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">GitHub是超过3600万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ho mc"/></div></div></a></div></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><p id="992b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果您正在使用架构组件、视图模型和协程，使用<code class="du jt ju jv jw b">viewModelScope</code>让框架为您管理其生命周期。这是显而易见的！</p><p id="f0e6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><a class="ae hv" href="https://codelabs.developers.google.com/codelabs/kotlin-coroutines" rel="noopener ugc nofollow" target="_blank">协程代码实验室</a>已经被更新以使用它。请查看这篇文章，了解更多关于协程以及如何在Android应用程序中使用它们的信息。</p></div></div>    
</body>
</html>