<html>
<head>
<title>Mocking is not rocket science: Expected behavior and behavior verification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘲讽不是火箭科学:预期行为和行为验证</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03?source=collection_archive---------1-----------------------#2018-01-16">https://blog.kotlin-academy.com/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03?source=collection_archive---------1-----------------------#2018-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="449d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前一篇文章中，我描述了嘲讽的基础。现在让我来概述一下<a class="ae ki" href="http://mockk.io" rel="noopener ugc nofollow" target="_blank">默克</a>的基本特征。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/79b133a42db9b6f96be13837868c93b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjGApuQKNxEpbqmuNHg-_g.jpeg"/></div></div></figure><p id="f58a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对依赖组件的调用可能相当复杂。这就是为什么有时您需要提供复杂的预期行为。有两件事可以帮助你做到这一点:参数匹配器和预期答案。</p><blockquote class="kv kw kx"><p id="5d6c" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">参数匹配器是一个参数占位符，用于指定在<code class="fe lc ld le lf b">every</code>和<code class="fe lc ld le lf b">verify</code>结构中参数可以接受的各种值。</p><p id="7d2d" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">预期答案是在被测系统中使用时调用返回的答案。</p></blockquote><h2 id="faa9" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">参数匹配</h2><p id="5170" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">比如你用<code class="fe lc ld le lf b">call(arg: Int): Int</code>功能嘲讽了DOC。如果参数大于<code class="fe lc ld le lf b">5</code>，则返回<code class="fe lc ld le lf b">1</code>，如果参数小于或等于<code class="fe lc ld le lf b">5</code>，则返回<code class="fe lc ld le lf b">-1</code>。这可以通过以下结构实现:</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="71b3" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock.call(more(5)) <strong class="lf io">} </strong>returns 1<br/><em class="ky">every </em><strong class="lf io">{ </strong>mock.call(or(less(5), eq(5))) <strong class="lf io">} </strong>returns -1</span></pre><p id="4822" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">more</code>、<code class="fe lc ld le lf b">less</code>、<code class="fe lc ld le lf b">eq</code>和<code class="fe lc ld le lf b">or</code>是参数匹配器。你可以在文档中查看它们的<a class="ae ki" href="http://mockk.io/#matchers" rel="noopener ugc nofollow" target="_blank">完整列表</a>。对于大多数情况来说，这应该足够了，但是当然，你可以通过子类化或者lambda函数来创建你自己的。</p><p id="1a71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，对于Mockito中的参数匹配，不需要为所有参数指定所有参数匹配器。您可以将一些参数保留为固定值。如果您给匹配器留一个固定值，它会自动被包含在<code class="fe lc ld le lf b">eq</code>匹配器中。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="ed83" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock.call(more(5), 6) <strong class="lf io">} </strong>returns 1</span><span id="0e89" class="lg lh in lf b gy mm mj l mk ml">// is same as</span><span id="1aab" class="lg lh in lf b gy mm mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock.call(more(5), eq(6)) <strong class="lf io">} </strong>returns 1</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/2f4722d181fb06dd8c2a4285f9489c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LByADZj4wpCgGRU8wwikVA.jpeg"/></div></div></figure><h2 id="4170" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">预期答案</h2><p id="86af" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">答案定义了被模仿方法的行为。最简单的回答是<code class="fe lc ld le lf b">returns</code>。我们已经在前面的例子中观察到了。提供的值是固定的，并在每次匹配调用时返回。</p><p id="1262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">returnsMany</code>指定一个接一个使用的数值，即第一个匹配的调用返回第一个元素，第二个-第二个元素，等等</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="67fa" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock1.call(5) <strong class="lf io">} </strong>returnsMany <em class="ky">listOf</em>(1, 2, 3)</span></pre><p id="ec55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用<code class="fe lc ld le lf b">andThen</code>构造实现同样的目的:</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="4064" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock1.call(5) <strong class="lf io">} </strong>returns 1 andThen 2 andThen 3</span></pre><p id="f4dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">throws</code>如果调用匹配，抛出异常。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="12da" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock1.call(5) <strong class="lf io">} </strong>throws RuntimeException(<strong class="lf io">"error happened"</strong>)</span></pre><p id="e488" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当返回值为<code class="fe lc ld le lf b">Unit</code>时，应使用<code class="fe lc ld le lf b">just Runs</code>。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="792e" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock1.callReturningUnit(5) <strong class="lf io">} </strong>just Runs</span></pre><p id="b87f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">answers</code>允许指定返回答案的自定义lambda函数。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="dd6f" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">every </em><strong class="lf io">{ </strong>mock1.call(5) <strong class="lf io">} </strong>answers <strong class="lf io">{ </strong>arg&lt;Int&gt;(0) + 5 <strong class="lf io">}</strong></span></pre><p id="aaae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">arg&lt;Int&gt;(0)</code>代表拦截调用中第一个参数的值。在answer lambda的范围内有很多这样的属性和函数。这有助于构建复杂的自定义答案。文档中提供了完整的列表。</p><h2 id="f10d" class="lg lh in bd li lj lk dn ll lm ln dp lo jv lp lq lr jz ls lt lu kd lv lw lx ly bi translated">行为验证</h2><p id="11d1" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这是对上一篇文章中的示例的扩展。这模仿文档的行为，检查SUT并验证文档是否被调用。</p><blockquote class="kv kw kx"><p id="3360" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">从这一点开始，当我们添加验证时，它可以被称为嘲讽，作为一个行业创造的术语。点击阅读更多信息。</p></blockquote><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="6ead" class="lg lh in lf b gy mi mj l mk ml">@Test<br/><strong class="lf io">fun </strong>calculateAddsValues() {<br/>  <strong class="lf io">val </strong>doc1 = <em class="ky">mockk</em>&lt;Dependency1&gt;()<br/>  <strong class="lf io">val </strong>doc2<strong class="lf io"> </strong>= <em class="ky">mockk</em>&lt;Dependency2&gt;()<br/><br/>  <em class="ky">every </em><strong class="lf io">{ </strong>doc1.<strong class="lf io">value1 } </strong>returns 5<br/>  <em class="ky">every </em><strong class="lf io">{ </strong>doc2.<strong class="lf io">value2 } </strong>returns <strong class="lf io">"6"<br/><br/>  val </strong>sut = SystemUnderTest(doc1, doc2)<br/><br/>  a<em class="ky">ssertEquals</em>(11, sut.calculate())</span><span id="c31f" class="lg lh in lf b gy mm mj l mk ml"><em class="ky">  verify </em><strong class="lf io">{ <br/>    </strong>doc1.<strong class="lf io">value1</strong><br/>    doc2.<strong class="lf io">value2</strong><br/>  <strong class="lf io">}<br/></strong>}</span></pre><blockquote class="kv kw kx"><p id="161d" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">模拟依赖组件的行为验证检查被调用。该检查应在测试结束时进行，在检查被测系统之后。</p></blockquote><p id="fff7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上支持四种类型的验证:<code class="fe lc ld le lf b">unordered</code>、<code class="fe lc ld le lf b">ordered</code>、<code class="fe lc ld le lf b">sequential</code>和<code class="fe lc ld le lf b">all</code>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/00fb9c49c3e0b7ea1631b851c92b0d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g__uxXcU0-HA_OJRfCkxtw.jpeg"/></div></div></figure><p id="352f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无序验证保证调用的发生不考虑顺序。例如，您想检查<code class="fe lc ld le lf b">call(5)</code>是否至少发生过一次。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="ebab" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify </em><strong class="lf io">{ </strong>mock1.call(5) <strong class="lf io">}</strong></span></pre><p id="49ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不像在<code class="fe lc ld le lf b">every</code>中，在<code class="fe lc ld le lf b">verify</code>块中，你可以一个接一个地进行几个调用。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="b2b3" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify </em><strong class="lf io">{ <br/>  </strong>mock1.call(5)<br/><strong class="lf io">  </strong>mock1.call(6)<br/><strong class="lf io">}</strong></span></pre><p id="5d34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将检查<code class="fe lc ld le lf b">call(5)</code>和<code class="fe lc ld le lf b">call(6)</code>是否至少出现过一次。</p><p id="0939" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">verify</code>可以有参数。<code class="fe lc ld le lf b">atLeast</code>、<code class="fe lc ld le lf b">atMost</code>指定发生了多少已验证的呼叫。默认情况下，<code class="fe lc ld le lf b">atLeast</code>是<code class="fe lc ld le lf b">1</code>而<code class="fe lc ld le lf b">atMost</code>是<code class="fe lc ld le lf b">Int.MAX_VALUE</code>，这实际上意味着我们期望调用至少发生一次。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="99d5" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify(atLeast = 5, atMost = 7) </em><strong class="lf io">{ <br/>  </strong>mock1.call(5)<br/>}</span></pre><p id="92ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将检查<code class="fe lc ld le lf b">call(5)</code>至少发生<code class="fe lc ld le lf b">5</code>次，最多发生<code class="fe lc ld le lf b">7</code>次。</p><p id="664e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">exactly</code>参数将<code class="fe lc ld le lf b">atLeast</code>和<code class="fe lc ld le lf b">atMost</code>设置为相同的值。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="ce91" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify(exactly = 5) </em><strong class="lf io">{ <br/>  </strong>mock1.call(5)<br/>}</span></pre><p id="f6f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个检查<code class="fe lc ld le lf b">call(5)</code>正好发生了5次。</p><p id="7506" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">指定<code class="fe lc ld le lf b">exactly = 0</code>您可以验证通话根本没有发生:</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="e474" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify(exactly = 0) </em><strong class="lf io">{ <br/>  </strong>mock1.call(5)<br/>}</span></pre><p id="c0ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时你想检查是否根本没有调用模拟文件。这可以通过特殊的<code class="fe lc ld le lf b">wasNot Called</code>构造来实现。相当于Mockito中的<code class="fe lc ld le lf b">verifyZeroInteractions</code>。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="435e" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verify </em><strong class="lf io">{ <br/>  </strong>mock1 <em class="ky">wasNot </em>Called <br/><strong class="lf io">}</strong></span></pre><p id="7724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是无序验证的基本内容。</p><p id="b82a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">verifyAll</code>和<code class="fe lc ld le lf b">verify</code>做的一样，除了它额外检查所有匹配的呼叫是唯一发生在提到的模仿上的呼叫。这类似于《摩奇托》中的<code class="fe lc ld le lf b">verifyNoMoreInteractions</code>。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="f9cf" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verifyAll </em><strong class="lf io">{ <br/>  </strong>mock1.call(5)<br/>}</span></pre><p id="df8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来的两种验证类型是<code class="fe lc ld le lf b">verifyOrder</code>和<code class="fe lc ld le lf b">verifySequence</code>。他们检查来电的顺序。</p><p id="3094" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不同之处在于<code class="fe lc ld le lf b">verifySequence</code>检查顺序，所有匹配的调用都是发生在提到的模仿上的唯一调用。这样它就能验证调用的确切顺序。</p><p id="e505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，让我们听听发生在SUT的电话:</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="67af" class="lg lh in lf b gy mi mj l mk ml">mock1.call(1)<br/>mock1.call(2)<br/>mock1.call(3)</span></pre><p id="b935" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要验证发生的确切序列，您需要编写以下代码:</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="976f" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verifySequence </em><strong class="lf io">{<br/>  </strong>mock1.call(1)<br/>  mock1.call(2)<br/>  mock1.call(3)<br/><strong class="lf io">}</strong></span></pre><p id="4736" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lc ld le lf b">verifyOrder</code>另一方面，只验证调用发生的顺序，允许调用序列中有间隔。</p><pre class="kk kl km kn gt me lf mf mg aw mh bi"><span id="3f1d" class="lg lh in lf b gy mi mj l mk ml"><em class="ky">verifyOrder </em><strong class="lf io">{<br/>  </strong>mock1.call(1)<br/>  mock1.call(3)<br/><strong class="lf io">}</strong></span></pre><p id="b194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将检查<code class="fe lc ld le lf b">call(1)</code>是否发生在<code class="fe lc ld le lf b">call(3)</code>之前。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/247a3a5a0063feed6647aae55c89339b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpCi1Kdt7P_BbGpiho6wbQ.jpeg"/></div></div></figure><p id="aa6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是你应该知道的最基本的MockK特性，在下一篇文章中，我们将继续讨论更高级的东西。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="e9a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一篇文章:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/mocking-is-not-rocket-science-mockk-features-e5d55d735a98"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">嘲笑不是火箭科学:嘲笑特征</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">如果你使用Kotlin，那么与其他嘲讽框架相比，MockK无疑是更好的选择。前一篇文章展示了一些…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kt mz"/></div></div></a></div></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="2419" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">拍手</strong>说“谢谢”并帮助他人找到这篇文章。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://kt.academy/article"><div class="gh gi no"><img src="../Images/5cf9179effdb3e8ab1a9bf39598fdfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNxjFpvGWzjC5h4VRjLyCw.png"/></div></a></figure><p id="bec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于用MockK进行单元测试的下一篇文章将在下周发表。不要错过它。订阅出版物和作者频道。这是以前的文章:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/mocking-is-not-rocket-science-basics-ae55d0aadf2b"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">嘲笑不是火箭科学:基础</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">模仿是一种使测试代码可读和可维护的技术。在随后的三篇文章中，我想…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ni l"><div class="np l nk nl nm ni nn kt mz"/></div></div></a></div><p id="3e06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢<a class="ae ki" href="https://twitter.com/DBacinski" rel="noopener ugc nofollow" target="_blank"> Dariusz Baciński </a>的技术验证。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nq"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>