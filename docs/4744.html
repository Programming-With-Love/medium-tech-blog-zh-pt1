<html>
<head>
<title>Lenses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">镜头</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/lenses-b85976cb0534?source=collection_archive---------0-----------------------#2018-12-23">https://medium.com/javascript-scene/lenses-b85976cb0534?source=collection_archive---------0-----------------------#2018-12-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="eebb" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">用于函数式编程的可组合Getters和Setters</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="jm jn jo"><p id="62a6" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="js hi">注意:</strong>这是<a class="ae km" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="js hi">“编写软件”一书</strong> </a>的一部分，该书最初是作为一个博客系列开始的。它从头开始涵盖了JavaScript (ES6+)中的函数式编程和组合软件技术。<br/> <a class="ae km" rel="noopener" href="/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d"> <em class="hh"> &lt;上一篇</em></a><em class="hh">|</em><a class="ae km" rel="noopener" href="/javascript-scene/composing-software-an-introduction-27b72500d6ea"><em class="hh">&lt;&lt;从第1部分开始</em> </a></p></blockquote><p id="556b" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">透镜是一对可组合的纯getter和setter函数，它们聚焦于对象内部的特定场，并遵循一组称为透镜定律的公理。把物体想象成<em class="jr">整体</em>，把场想象成<em class="jr">部分</em>。getter取一个整体，返回镜头聚焦的对象部分。</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="4cf0" class="kv kw hh kr b fi kx ky l kz la">// view = whole =&gt; part</span></pre><p id="cc8d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">setter接受一个整体和一个用于设置该部分的值，并返回一个更新了该部分的新整体。与简单地将值设置到对象的成员字段中的函数不同，镜头设置器是纯函数:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="4d2c" class="kv kw hh kr b fi kx ky l kz la">// set = whole =&gt; part =&gt; whole</span></pre><blockquote class="jm jn jo"><p id="5bdc" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="js hi">注意:</strong>在本文中，我们将在代码示例中使用一些简单的镜头，只是为了让您从本质上窥见一般概念。对于生产代码，您应该查看像Ramda这样经过良好测试的库。不同的镜头库之间的API是不同的，可以用比这里更可组合、更优雅的方式来表达镜头。</p></blockquote><p id="65ef" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">假设您有一个元组数组，表示一个点的<code class="du lb lc ld kr b">x</code>、<code class="du lb lc ld kr b">y</code>和<code class="du lb lc ld kr b">z</code>坐标:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="d3e0" class="kv kw hh kr b fi kx ky l kz la">[x, y, z]</span></pre><p id="f1e9" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">要单独获取或设置每个字段，可以创建三个镜头。每个轴一个。您可以手动创建专注于每个字段的getters:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="32ab" class="kv kw hh kr b fi kx ky l kz la">const getX = ([x]) =&gt; x;<br/>const getY = ([x, y]) =&gt; y;<br/>const getZ = ([x, y, z]) =&gt; z;</span><span id="e266" class="kv kw hh kr b fi le ky l kz la">console.log(<br/>  getZ([10, 10, 100]) // 100<br/>);</span></pre><p id="84c2" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">同样，相应的setters可能如下所示:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="d268" class="kv kw hh kr b fi kx ky l kz la">const setY = ([x, _, z]) =&gt; y =&gt; ([x, y, z]);</span><span id="2b78" class="kv kw hh kr b fi le ky l kz la">console.log(<br/>  setY([10, 10, 10])(999) // [10, 999, 10]<br/>);</span></pre><h1 id="3b1d" class="lf kw hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">为什么是镜片？</h1><p id="2199" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">状态形状依赖是软件中耦合的一个常见来源。许多组件可能依赖于某个共享状态的形状，因此如果您稍后需要更改该状态的形状，您必须在多个地方更改逻辑。</p><p id="8876" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">镜头允许你在getters和setters后面抽象状态形状。不要在你的代码库中乱放深入到特定对象形状的代码，导入一个镜头。如果您以后需要更改状态形状，您可以在镜头中这样做，依赖于镜头的代码都不需要更改。</p><p id="5d17" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">这遵循了这样一个原则:需求的小变化应该只需要系统的小变化。</p><h1 id="d211" class="lf kw hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">背景</h1><p id="5fb6" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">在1985年，<a class="ae km" href="https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=9fac31d60f8b9b60f63f71ab716694bc" rel="noopener ugc nofollow" target="_blank">“计算机程序的结构和解释”</a>描述了getter和setter对(本文中称为<code class="du lb lc ld kr b">put</code>和<code class="du lb lc ld kr b">get</code>)作为一种将对象的形状与使用该对象的代码隔离的方法。本文展示了如何创建通用的选择器来访问一个复数的各个部分，而不管这个数是如何表示的。这种隔离很有用，因为它打破了状态形状依赖关系。这些getter/setter对有点像在关系数据库中已经存在了几十年的引用查询。</p><p id="2b57" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">Lenses通过使getter/setter对更加通用和可组合，进一步发展了这个概念。在Edward Kmett为Haskell发布镜头库之后，它们开始流行起来。他受到Jeremy Gibbons和Bruno C. d. S. Oliveira的影响，他们论证了遍历表达迭代器模式，Luke Palmer的“访问器”，Twan van Laarhoven和Russell O'Connor。</p><blockquote class="jm jn jo"><p id="5577" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="js hi">注:</strong>一个容易犯的错误是将现代的功能性镜头概念等同于变形，这是基于埃里克·梅耶尔、马腾·福金加和罗斯·帕特森在1991年的<a class="ae km" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125" rel="noopener ugc nofollow" target="_blank">“用香蕉、镜头、信封和带刺铁丝网进行功能性编程”</a>。“术语‘透镜’在功能参考意义上是指它观察整体的一部分。术语“透镜”在递归模式中是指这样一个事实，即<code class="du lb lc ld kr b">[(</code>和<code class="du lb lc ld kr b">)]</code>在语法上看起来有点像凹透镜。<strong class="js hi">TL；他们互不相干。”~ <a class="ae km" href="https://stackoverflow.com/questions/17198072/how-is-anamorphism-related-to-lens" rel="noopener ugc nofollow" target="_blank">栈溢出时的爱德华·克米特</a></strong></p></blockquote><h1 id="44dd" class="lf kw hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">透镜定律</h1><p id="e564" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">透镜定律是代数公理，它确保透镜性能良好。</p><ol class=""><li id="c817" class="mb mc hh js b jt ju jw jx kn md ko me kp mf kl mg mh mi mj bi translated"><code class="du lb lc ld kr b">view(lens, set(lens, a, store)) ≡ a</code>——如果你在商店里设置了一个值，并立即通过镜头查看该值，你就会得到所设置的值。</li><li id="57b4" class="mb mc hh js b jt mk jw ml kn mm ko mn kp mo kl mg mh mi mj bi translated"><code class="du lb lc ld kr b">set(lens, b, set(lens, a, store)) ≡ set(lens, b, store)</code> —如果您将镜头值设置为<code class="du lb lc ld kr b">a</code>，然后立即将镜头值设置为<code class="du lb lc ld kr b">b</code>，这与您刚刚将值设置为<code class="du lb lc ld kr b">b</code>是一样的。</li><li id="f004" class="mb mc hh js b jt mk jw ml kn mm ko mn kp mo kl mg mh mi mj bi translated"><code class="du lb lc ld kr b">set(lens, view(lens, store), store) ≡ store</code> —如果您从存储中获取镜头值，然后立即将该值设置回存储中，则该值保持不变。</li></ol><p id="5385" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">在我们深入代码示例之前，请记住，如果您在产品中使用镜头，您可能应该使用经过良好测试的镜头库。我所知道的最好的JavaScript是Ramda。我们现在要跳过这一步，自己制作一些天真的镜头，只是为了学习:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="1f58" class="kv kw hh kr b fi kx ky l kz la">// Pure functions to view and set which can be used with any lens:<br/>const view = (lens, store) =&gt; lens.view(store);<br/>const set = (lens, value, store) =&gt; lens.set(value, store);</span><span id="9b16" class="kv kw hh kr b fi le ky l kz la">// A function which takes a prop, and returns naive<br/>// lens accessors for that prop.<br/>const lensProp = prop =&gt; ({<br/>  view: store =&gt; store[prop],<br/>  // This is very naive, because it only works for objects:<br/>  set: (value, store) =&gt; ({<br/>    ...store,<br/>    [prop]: value<br/>  })<br/>});</span><span id="794c" class="kv kw hh kr b fi le ky l kz la">// An example store object. An object you access with a lens<br/>// is often called the "store" object:<br/>const fooStore = {<br/>  a: 'foo',<br/>  b: 'bar'<br/>};</span><span id="7e99" class="kv kw hh kr b fi le ky l kz la">const aLens = lensProp('a');<br/>const bLens = lensProp('b');</span><span id="b392" class="kv kw hh kr b fi le ky l kz la">// Destructure the `a` and `b` props from the lens using<br/>// the `view()` function.<br/>const a = view(aLens, fooStore);<br/>const b = view(bLens, fooStore);<br/>console.log(a, b); // 'foo' 'bar'</span><span id="2d21" class="kv kw hh kr b fi le ky l kz la">// Set a value into our store using the `aLens`:<br/>const bazStore = set(aLens, 'baz', fooStore);</span><span id="8129" class="kv kw hh kr b fi le ky l kz la">// View the newly set value.<br/>console.log( view(aLens, bazStore) ); // 'baz'</span></pre><p id="df67" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">让我们证明这些函数的透镜定律:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="7e95" class="kv kw hh kr b fi kx ky l kz la">const store = fooStore;</span><span id="4f8c" class="kv kw hh kr b fi le ky l kz la">{<br/>  // `view(lens, set(lens, value, store))` = `value`<br/>  // If you set a value into the store, and immediately<br/>  // view the value through the lens, you get the value<br/>  // that was set.<br/>  const lens = lensProp('a');<br/>  const value = 'baz';</span><span id="8bdf" class="kv kw hh kr b fi le ky l kz la">  const a = value;<br/>  const b = view(lens, set(lens, value, store));</span><span id="5c22" class="kv kw hh kr b fi le ky l kz la">  console.log(a, b); // 'baz' 'baz'<br/>}</span><span id="5c52" class="kv kw hh kr b fi le ky l kz la">{<br/>  // set(lens, b, set(lens, a, store)) = set(lens, b, store)<br/>  // If you set a lens value to `a` and then immediately set the lens value to `b`,<br/>  // it's the same as if you'd just set the value to `b`.<br/>  const lens = lensProp('a');</span><span id="9ac0" class="kv kw hh kr b fi le ky l kz la">  const a = 'bar';<br/>  const b = 'baz';</span><span id="2407" class="kv kw hh kr b fi le ky l kz la">  const r1 = set(lens, b, set(lens, a, store));<br/>  const r2 = set(lens, b, store);<br/>  <br/>  console.log(r1, r2); // {a: "baz", b: "bar"} {a: "baz", b: "bar"}<br/>}</span><span id="54dd" class="kv kw hh kr b fi le ky l kz la">{<br/>  // `set(lens, view(lens, store), store)` = `store`<br/>  // If you get the lens value from the store, and then immediately set that value<br/>  // back into the store, the value is unchanged.<br/>  const lens = lensProp('a');</span><span id="197b" class="kv kw hh kr b fi le ky l kz la">  const r1 = set(lens, view(lens, store), store);<br/>  const r2 = store;<br/>  <br/>  console.log(r1, r2); // {a: "foo", b: "bar"} {a: "foo", b: "bar"}<br/>}</span></pre><h1 id="8b71" class="lf kw hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">合成镜头</h1><p id="504b" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">镜头是可组合的。当您合成镜头时，生成的镜头将深入到对象中，遍历整个对象路径。让我们从Ramda导入更全功能的<code class="du lb lc ld kr b">lensProp</code>来演示一下:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="a40c" class="kv kw hh kr b fi kx ky l kz la">import { compose, lensProp, view } from 'ramda';</span><span id="e299" class="kv kw hh kr b fi le ky l kz la">const lensProps = [<br/>  'foo',<br/>  'bar',<br/>  1<br/>];</span><span id="ff7b" class="kv kw hh kr b fi le ky l kz la">const lenses = lensProps.map(lensProp);<br/>const truth = compose(...lenses);</span><span id="7e45" class="kv kw hh kr b fi le ky l kz la">const obj = {<br/>  foo: {<br/>    bar: [false, true]<br/>  }<br/>};</span><span id="cf8c" class="kv kw hh kr b fi le ky l kz la">console.log(<br/>  view(truth, obj)<br/>);</span></pre><p id="0ad2" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">这很好，但是我们应该知道更多关于镜头的构图。让我们深入探讨一下。</p><h1 id="6e5c" class="lf kw hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">超过</h1><p id="6472" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">可以在任何仿函数数据类型的上下文中应用来自<code class="du lb lc ld kr b">a =&gt; b</code>的函数。我们已经证明函子映射<em class="jr">是合成。</em>同样，我们可以对镜头的焦距值应用一个函数。通常，该值属于同一类型，所以它是来自<code class="du lb lc ld kr b">a =&gt; a</code>的一个函数。镜头贴图操作在JavaScript库中通常被称为“over”。我们可以这样创建它:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="27fc" class="kv kw hh kr b fi kx ky l kz la">// over = (lens, f: a =&gt; a, store) =&gt; store<br/>const over = (lens, f, store) =&gt; set(lens, f(view(lens, store)), store);</span><span id="7789" class="kv kw hh kr b fi le ky l kz la">const uppercase = x =&gt; x.toUpperCase();</span><span id="9177" class="kv kw hh kr b fi le ky l kz la">console.log(<br/>  over(aLens, uppercase, store) // { a: "FOO", b: "bar" }<br/>);</span></pre><p id="f406" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">Setters遵守函子定律:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="c2bc" class="kv kw hh kr b fi kx ky l kz la">{ // if you map the identity function over a lens<br/>  // the store is unchanged.<br/>  const id = x =&gt; x;<br/>  const lens = aLens;<br/>  const a = over(lens, id, store);<br/>  const b = store;</span><span id="f724" class="kv kw hh kr b fi le ky l kz la">  console.log(a, b);<br/>}</span></pre><p id="1a5f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">对于合成示例，我们将使用自动编写的over:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="4c83" class="kv kw hh kr b fi kx ky l kz la">import { curry } from 'ramda';</span><span id="bf3c" class="kv kw hh kr b fi le ky l kz la">const over = curry(<br/>  (lens, f, store) =&gt; set(lens, f(view(lens, store)), store)<br/>);</span></pre><p id="f19f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">现在很容易看出，过度运算下的透镜也服从函子合成定律:</p><pre class="ix iy iz ja fd kq kr ks kt aw ku bi"><span id="4ba9" class="kv kw hh kr b fi kx ky l kz la">{ // over(lens, f) after over(lens g) is the same as<br/>  // over(lens, compose(f, g))<br/>  const lens = aLens;</span><span id="f163" class="kv kw hh kr b fi le ky l kz la">  const store = {<br/>    a: 20<br/>  };</span><span id="08b7" class="kv kw hh kr b fi le ky l kz la">  const g = n =&gt; n + 1;<br/>  const f = n =&gt; n * 2;</span><span id="f5d9" class="kv kw hh kr b fi le ky l kz la">  const a = compose(<br/>    over(lens, f),<br/>    over(lens, g)<br/>  );</span><span id="3483" class="kv kw hh kr b fi le ky l kz la">  const b = over(lens, compose(f, g));</span><span id="a94d" class="kv kw hh kr b fi le ky l kz la">  console.log(<br/>    a(store), // {a: 42}<br/>    b(store)  // {a: 42}<br/>  );<br/>}</span></pre><p id="1443" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">我们在这里仅仅触及了透镜的表面，但是它应该足以让你开始。关于更多细节，爱德华·克迈特已经就这个话题谈了很多，许多人也写了更深入的探索。</p></div><div class="ab cl mp mq go mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ha hb hc hd he"><p id="ea07" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi"> <em class="jr"> Eric Elliott </em> </strong> <em class="jr">是一位分布式系统专家，著有以下书籍:</em> <a class="ae km" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="jr">【排版软件】</em></a><em class="jr"/><a class="ae km" href="https://ericelliottjs.com/product/programming-javascript-applications-ebook/" rel="noopener ugc nofollow" target="_blank"><em class="jr">【编程JavaScript应用】</em> </a> <em class="jr">。作为</em><a class="ae km" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="jr">devanywhere . io</em></a><em class="jr">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，并为以下项目提供软件体验:</em> <strong class="js hi"> <em class="jr"> Adobe Systems、</em></strong><em class="jr"/><strong class="js hi"><em class="jr">Zumba Fitness、</em> </strong> <em class="jr"> </em> <strong class="js hi"> <em class="jr">【华尔街日报、</em> </strong> <em class="jr"> </em> <strong class="js hi"> <em class="jr">、</em></strong><em class="jr"/><strong class="js hi"><em class="jr">BBC、</em> </strong> <em class="jr">和</em></p><p id="0b51" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>