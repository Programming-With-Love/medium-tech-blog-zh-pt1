<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison (Part 4): Interop Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协同程序和rx Java——异步比较(第4部分):互操作库</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-4-interop-library-4a2439a690f9?source=collection_archive---------0-----------------------#2018-04-26">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-4-interop-library-4a2439a690f9?source=collection_archive---------0-----------------------#2018-04-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ee90136029c91d2644bfb2555dce4465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_oB5QceNwKttmh_jCD5bA.png"/></div></div></figure><div class=""/><h1 id="e06d" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="8ba2" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这个博客系列中，我将比较<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>和<a class="ae kl" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，因为它们都试图解决Android开发中的一个常见问题:<strong class="jp ht">异步编程</strong>。</p><p id="6525" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791">第3部分</a>中，我们已经讨论完了<strong class="jp ht"><em class="kr">publish</em></strong>——一个内置了通道的协程，它在每次打开订阅时运行协程内的暂停lambda。</p><p id="55ca" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在第3部分中，我们说过<em class="kr"> publish </em>是interop库的一部分。这就是本文要讲的:<a class="ae kl" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx2" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">协程和RxJava互操作库</strong> </a>。</p><h1 id="f9a6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么需要互操作库？</h1><p id="9ffe" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">最明显的答案是你正在从一个库迁移到另一个库。您不应该进行一次性迁移，因为这将增加出错的风险。一个更好的方法是一个功能一个功能地迁移。在这种情况下，你需要在你的项目中同时使用这两个库，并且能够使用其中一个库。</p><p id="e883" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">不太明显的答案是当你想从Java代码中使用协程的时候。由于Kotlin编译器为您创建的代码，您不能从Java调用协程。出于这个原因，您需要一个能够从Java使用协程的桥。<strong class="jp ht"> RxJava是一个选项</strong>。</p><h1 id="dfbd" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">入门指南</h1><p id="54b7" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果要使用Interop库，需要将该库导入到项目中。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ff81" class="lb iq hs kx b fi lc ld l le lf">implementation "org.jetbrains.kotlinx:<strong class="kx ht">kotlinx-coroutines-rx2</strong>:$kotlin_coroutines_version"</span></pre><p id="2b45" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这将导入协程和RxJava 2，以防您还没有将它们导入到您的项目中。</p><h1 id="fed9" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">RxJava之上的协程</h1><p id="5222" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">让我们回到我们在<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068">第二部分</a>中使用的例子:一个每秒发出一个项目的计时器。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f662" class="lb iq hs kx b fi lc ld l le lf">Observable.interval(1, TimeUnit.SECONDS)</span></pre><p id="9cf4" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这是RxJava代码。我们如何使用协程来消费它呢？</p><p id="eeaf" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以在可观察对象上使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/io.reactivex.-observable-source/open-subscription.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht"> openSubscription </strong>扩展函数</a>。这将返回一个<code class="du lg lh li kx b">SubscriptionReceiveChannel</code>,您可以用它来打开订阅，然后<strong class="jp ht">消费这些元素，就好像它们是由通道</strong>发出的一样。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="38a0" class="lb iq hs kx b fi lc ld l le lf">Observable.interval(1, TimeUnit.SECONDS)<br/>    .<strong class="kx ht"><em class="kr">openSubscription</em>()</strong>.<em class="kr">use </em><strong class="kx ht">{ </strong>channel <strong class="kx ht">-&gt;<br/>        </strong>for (value in channel) {<br/>            consumeValue(value)<br/>        }<br/>    <strong class="kx ht">}</strong></span></pre><p id="aedd" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">您还可以使用<strong class="jp ht"> await </strong>方法族，只使用RxJava信息源发送的第一个元素。你有<code class="du lg lh li kx b">.await()</code>单个可用，<code class="du lg lh li kx b">.awaitFirst()</code>可观测，等等。</p><p id="ea27" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这就是如何使用<code class="du lg lh li kx b"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/io.reactivex.-observable-source/await-first-or-default.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">awaitFirstOrDefault(value)</strong></a></code>扩展功能。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6ecd" class="lb iq hs kx b fi lc ld l le lf"><strong class="kx ht">val value</strong> = Observable.interval(1, TimeUnit.SECONDS)<br/>                .<strong class="kx ht"><em class="kr">awaitFirstOrDefault</em></strong><em class="kr">(-1)</em></span></pre><p id="8515" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">反过来呢？如何使用RxJava消费协程？</p><h1 id="ecd0" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">协程之上的RxJava</h1><p id="b65b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以使用RxJava使用一些扩展函数来消费通道和协程。</p><h2 id="c6f7" class="lb iq hs bd ir lj lk ll iv lm ln lo iz jy lp lq jd kc lr ls jh kg lt lu jl lv bi translated">使用RxJava消费协程</h2><p id="1b55" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">您可以使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/kotlinx.coroutines.experimental.-job/as-completable.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">Job . as Completable</strong></a>扩展功能将任何作业转换为Completable。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ebcb" class="lb iq hs kx b fi lc ld l le lf">val job = <em class="kr">launch </em><strong class="kx ht">{<br/>    </strong>heavyComputation()<br/><strong class="kx ht">}</strong></span><span id="c3ba" class="lb iq hs kx b fi lw ld l le lf">job.<strong class="kx ht"><em class="kr">asCompletable</em></strong>(CommonPool).subscribe(<strong class="kx ht">{<br/>    </strong>// Job completed<br/><strong class="kx ht">}</strong>)</span></pre><p id="f4fd" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们想象一下，我们有一个执行繁重计算的协程。我们可以将该作业转换为Completable并订阅它，就好像它最初是用RxJava创建的一样。</p><p id="7626" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在那个例子中，我们将<code class="du lg lh li kx b">CommonPool</code>作为一个参数传递给扩展函数:这是CoroutineContext，结果completable将从它发出信号。</p><p id="839c" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">也可以用同样的方法使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/kotlinx.coroutines.experimental.-deferred/as-single.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">deferred . as single</strong></a>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e44a" class="lb iq hs kx b fi lc ld l le lf">val deferred = <em class="kr">async </em><strong class="kx ht">{<br/>    </strong>heavyComputation()<br/><strong class="kx ht">}</strong></span><span id="73f4" class="lb iq hs kx b fi lw ld l le lf">deferred.<strong class="kx ht"><em class="kr">asSingle</em></strong>(CommonPool).subscribe(<strong class="kx ht">{<br/>    </strong>// Job completed<br/><strong class="kx ht">}</strong>, <strong class="kx ht">{<br/>    </strong>// Error happened<br/><strong class="kx ht">}</strong>)</span></pre><h2 id="7837" class="lb iq hs bd ir lj lk ll iv lm ln lo iz jy lp lq jd kc lr ls jh kg lt lu jl lv bi translated">协同程序生成器</h2><p id="dbab" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">有一些CoroutineBuilders将返回RxJava信息源。当您订阅它时，就像任何其他协程构建器一样，它将创建一个新的协程，并在其中运行挂起的lambda。</p><p id="2dd2" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">可用方法</strong> : rxCompletable、rxMaybe、rxSingle、rxObservable、rx flow。</p><p id="6b7e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">例如如何使用使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/rx-completable.html" rel="noopener ugc nofollow" target="_blank"> rxCompletable </a>？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="09ec" class="lb iq hs kx b fi lc ld l le lf"><strong class="kx ht"><em class="kr">rxCompletable</em></strong><em class="kr"> </em><strong class="kx ht">{<br/>    </strong>// Suspending lambda<br/><strong class="kx ht">}</strong>.subscribe()</span></pre><p id="a0cc" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">取消订阅将取消协程。</p><h2 id="a5e0" class="lb iq hs bd ir lj lk ll iv lm ln lo iz jy lp lq jd kc lr ls jh kg lt lu jl lv bi translated">使用RxJava使用通道</h2><p id="8017" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">您还可以使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/kotlinx.coroutines.experimental.rx2/kotlinx.coroutines.experimental.channels.-receive-channel/as-observable.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">receive channel . as observable</strong></a>扩展功能将任何通道转换为热反应可观察值。</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><h1 id="9fef" class="ip iq hs bd ir is me iu iv iw mf iy iz ja mg jc jd je mh jg jh ji mi jk jl jm bi translated">接下来会发生什么？</h1><p id="5958" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们系列的<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-5-operators-2603a8ecaa5f">第五部</a>将全部是关于<strong class="jp ht">操作者</strong>！</p><p id="23ef" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">所有这些令人惊叹的RxJava操作符在协程中都可用吗？默认支持哪些？哪些是我必须实现的？</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><h1 id="e963" class="ip iq hs bd ir is me iu iv iw mf iy iz ja mg jc jd je mh jg jh ji mi jk jl jm bi translated">更多教育</h1><p id="bec0" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">链接到本系列的前几部分</p><div class="hg hh ez fb hi mj"><a rel="noopener follow" target="_blank" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd ht fi z dy mo ea eb mp ed ef hr bi translated">协程和rx Java——异步比较(第1部分):异步编程</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">异步编程</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">异步Programmingmedium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx ho mj"/></div></div></a></div><div class="hg hh ez fb hi mj"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd ht fi z dy mo ea eb mp ed ef hr bi translated">协程和rx Java——异步比较(第2部分):取消执行</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">第2部分—取消执行</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="my l mu mv mw ms mx ho mj"/></div></div></a></div><div class="hg hh ez fb hi mj"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd ht fi z dy mo ea eb mp ed ef hr bi translated">协程和rx Java——异步性比较(第3部分):传递价值流</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">第3部分—转移价值流</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mz l mu mv mw ms mx ho mj"/></div></div></a></div><p id="72c7" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">感谢阅读，</p><p id="e42b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>