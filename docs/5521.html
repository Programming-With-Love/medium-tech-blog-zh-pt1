<html>
<head>
<title>Running Reactive Spring Boot on GraalVM in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker中的GraalVM上运行反应式Spring Boot</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/running-reactive-spring-boot-on-graalvm-in-docker-b36744fe299c?source=collection_archive---------1-----------------------#2018-11-10">https://medium.com/oracledevs/running-reactive-spring-boot-on-graalvm-in-docker-b36744fe299c?source=collection_archive---------1-----------------------#2018-11-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ea7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GraalVM 是一个开源的多语言VM，可以很容易地混合和匹配不同的语言，如Java、Javascript和r。它能够(有一些限制)将代码编译成本地可执行文件。这当然提供了巨大的性能优势。最近，GraalVM Docker文件和图像变得可用。见<a class="ae jc" href="https://github.com/oracle/docker-images/tree/master/GraalVM/CE" rel="noopener ugc nofollow" target="_blank">此处</a>。因为Spring Boot是一个流行的Java框架，而且在Spring Boot实现的反应式(非阻塞)RESTful服务/客户端看起来也很有趣，我想；让我们将这些结合起来，生成一个在GraalVM上运行反应式Spring Boot应用程序的Docker映像。我使用并组合了以下内容</p><p id="72f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为基础，我使用了下面的Git库<a class="ae jc" href="https://github.com/spring-guides/gs-reactive-rest-service" rel="noopener ugc nofollow" target="_blank">中提供的代码。在“complete”文件夹(本教程的最终结果)中是一个示例反应式RESTful Web服务和客户端。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/52e91e0b570e80880aafcca2f65a3c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZfjUmqSjYybgBT7cspEsA.png"/></div></div></figure></div><div class="ab cl jp jq go jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="ha hb hc hd he"><h2 id="3b7c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg ip kh ki kj it kk kl km ix kn ko kp kq bi translated">反应式Spring Boot RESTful web服务和客户端</h2><p id="ff19" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在查看这个示例时，您可以看到如何实现一个非阻塞的web服务和客户端。基本上这意味着你使用。</p><ul class=""><li id="e664" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">org . spring framework . web . reactive . function . server . server request和ServerResponse，而不是org . spring framework . web . bind . annotation . rest controller</li><li id="6759" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">Mono <serverresponse>用于web服务的响应</serverresponse></li><li id="f7f8" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">对于web服务客户端，您使用org . spring framework . web . reactive . function . client . client response和Mono <clientresponse>来获得响应</clientresponse></li><li id="4af1" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">因为您不会使用带有RequestMapping注释的(经典阻塞)RestController，所以您需要创建自己的配置类，该类使用org . spring framework . web . reactive . function . server . router functions定义路由</li></ul><p id="7f2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为响应不是直接的POJO，所以需要像res.bodyToMono(String.class)那样将其转换为显式的。更多细节请看<a class="ae jc" href="https://spring.io/guides/gs/reactive-rest-service/" rel="noopener ugc nofollow" target="_blank">本教程</a>或浏览<a class="ae jc" href="https://github.com/spring-guides/gs-reactive-rest-service" rel="noopener ugc nofollow" target="_blank">本资源库</a></p><p id="8d99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就我个人而言，我希望有一个类似ReactiveRestController的东西，并保持其余部分(双关语)不变。这将使得对反应式服务和客户端的重构更加容易。</p><h2 id="4ba5" class="jw jx hh bd jy jz ka kb kc kd ke kf kg ip kh ki kj it kk kl km ix kn ko kp kq bi translated">GraalVM</h2><p id="d791" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">GraalVM是Oracle开源的多语言VM。它有社区版和企业版，提供改进的性能(更小的内存占用)和更好的安全性(本机代码的沙箱功能)，如这里的<a class="ae jc" href="https://www.graalvm.org/docs/faq/" rel="noopener ugc nofollow" target="_blank">所示</a>。社区版可以从GitHub下载，企业版可以从Oracle的技术网下载。对GraalVM for Windows的支持目前仍在开发中，尚未发布。使用GraalVM的Oracle面临的一个挑战是保持它所支持的多语言系统保持最新版本。这已经是一个挑战，例如Oracle数据库中的R支持和应用程序容器云服务中的节点支持。见<a class="ae jc" href="https://www.oracle.com/technetwork/database/database-technologies/r/r-enterprise/overview/index.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="9176" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您下载GraalVM CE时，您将获得带有特定OpenJDK 8版本的GraalVM(对于GraalVM 1.0.0-rc8，这是1.8.0_172)。当你从OTN下载GraalVM EE时，你会得到相同版本的Oracle JDK 8。</p><p id="006c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要查看哪些组件可用，您可以:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="c8b3" class="jw jx hh ll b fi lp lq l lr ls">bash-4.2# gu available<br/>Downloading: Component catalog<br/>ComponentId Version Component name<br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — <br/>python 1.0.0-rc8 Graal.Python<br/>R 1.0.0-rc8 FastR<br/>ruby 1.0.0-rc8 TruffleRuby</span></pre><p id="126c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> GraalVM和LLVM </strong></p><p id="cea5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GraalVM支持LLVM。LLVM是一个流行的工具集，为特定平台提供语言无关的代码编译和优化。LLVM是许多编程语言最近开始流行的原因之一。点击阅读更多关于LLVM <a class="ae jc" href="https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html" rel="noopener ugc nofollow" target="_blank">的信息，或者点击</a>访问他们的网站<a class="ae jc" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank">。如果你能把一种语言编译成LLVM位代码或者LLVM中间表示(IR)，你就能在GraalVM上运行它(见</a><a class="ae jc" href="https://www.graalvm.org/docs/reference-manual/languages/llvm/" rel="noopener ugc nofollow" target="_blank">此处</a>)。GraalVM对LLVM位代码进行了额外的优化，以获得更好的结果。</p><p id="e7da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> GraalVM和R </strong></p><p id="cf08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GraalVM使用基于GNU-R的FastR，它是R的参考实现。这是R语言在GraalVM上的替代实现，因此不是真正的R！例如:“对dplyr和data.table的支持正在进行中”。点击阅读更多<a class="ae jc" href="https://github.com/oracle/fastr" rel="noopener ugc nofollow" target="_blank">。特别是如果你在R中使用外来包，我认为会有兼容性问题。将GraalVM上的FastR的性能与将R代码编译成LLVM指令并在GraalVM上运行(使用类似</a><a class="ae jc" href="https://github.com/duncantl/RLLVMCompile" rel="noopener ugc nofollow" target="_blank"> RLLVMCompile </a>的东西)进行比较是很有趣的。不过，我还没试过。GraalVM目前似乎有势头，我对RLLVMCompile不太确定。</p><p id="51b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">更新GraalVM的JVM</strong></p><p id="59cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以点击查看下面这篇关于用JDK 8版本构建GraalVM的文章<a class="ae jc" href="https://neomatrix369.wordpress.com/2018/06/11/building-wholly-graal-with-truffle/" rel="noopener ugc nofollow" target="_blank">。这里的</a>指的是GitHub <a class="ae jc" href="https://github.com/oracle/graal/blob/master/compiler/README.md" rel="noopener ugc nofollow" target="_blank">上的文档。</a></p><blockquote class="lt lu lv"><p id="7843" class="ie if lw ig b ih ii ij ik il im in io lx iq ir is ly iu iv iw lz iy iz ja jb ha bi translated">Graal依赖于支持JVMCI (JVM编译器接口)兼容版本的JDK。JDK 8有一个JVMCI端口，从JDK 11 (build 20或更高版本)开始，JDK中内置了所需的JVMCI版本。</p></blockquote><p id="743b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我没有尝试过，但是从支持不同JDK的源代码中编译GraalVM似乎相对容易。</p><h2 id="48ec" class="jw jx hh bd jy jz ka kb kc kd ke kf kg ip kh ki kj it kk kl km ix kn ko kp kq bi translated">停靠栏中的GraalVM</h2><p id="18fd" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">Oracle最近提供了GraalVM作为Docker映像，并将Docker文件放在他们的Github存储库中。见<a class="ae jc" href="https://github.com/oracle/docker-images/tree/master/GraalVM/CE" rel="noopener ugc nofollow" target="_blank">此处</a>。这些仅适用于社区版。由于GitHub上提供了docker文件，所以如果需要，可以很容易地创建自己的GraalVM EE映像(例如，希望使用Oracle JDK而不是OpenJDK来测试GraalVM)。</p><p id="572b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要签出GraalVM，可以像下面这样运行容器:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="a937" class="jw jx hh ll b fi lp lq l lr ls">docker run -it oracle/graalvm-ce:1.0.0-rc8 bash</span></pre><h2 id="b2ee" class="jw jx hh bd jy jz ka kb kc kd ke kf kg ip kh ki kj it kk kl km ix kn ko kp kq bi translated">Spring Boot在码头的GraalVM</h2><p id="4ddd" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如何在Docker中运行一个Spring Boot应用程序相对简单，在这里<a class="ae jc" href="https://spring.io/guides/gs/spring-boot-docker/" rel="noopener ugc nofollow" target="_blank">描述</a>。我也在各种虚拟机上运行过Spring Boot应用程序，并在这里描述了如何实现这个<a class="ae jc" href="http://javaoraclesoa.blogspot.com/2018/03/running-spring-boot-in-docker-container.html" rel="noopener ugc nofollow" target="_blank">的过程。如上所述，我已经使用了这个</a><a class="ae jc" href="https://github.com/MaartenSmeets/provisioning/tree/master/ubuntudev" rel="noopener ugc nofollow" target="_blank"> Ubuntu开发虚拟机</a>。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="63f7" class="jw jx hh ll b fi lp lq l lr ls">sudo apt-get install maven<br/>git clone <a class="ae jc" href="https://github.com/spring-guides/gs-reactive-rest-service.git" rel="noopener ugc nofollow" target="_blank">https://github.com/spring-guides/gs-reactive-rest-service.git</a><br/>cd gs-reactive-rest-service/complete</span></pre><p id="55be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在创建一个Dockerfile文件:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="c6b7" class="jw jx hh ll b fi lp lq l lr ls">FROM oracle/graalvm-ce:1.0.0-rc8<br/>VOLUME /tmp<br/>ARG JAR_FILE<br/>COPY ${JAR_FILE} app.jar<br/>ENTRYPOINT [“java”,”-Djava.security.egd=file:/dev/./urandom”,”-jar”,”/app.jar”]</span></pre><p id="5edb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编辑pom.xml文件</p><p id="7ebd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">向属性标签添加一个前缀变量:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="bcc5" class="jw jx hh ll b fi lp lq l lr ls">&lt;properties&gt;<br/>&lt;java.version&gt;1.8&lt;/java.version&gt;<br/><strong class="ll hi">&lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;<br/></strong>&lt;/properties&gt;</span></pre><p id="d9be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">添加构建插件</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="076e" class="jw jx hh ll b fi lp lq l lr ls">&lt;build&gt;<br/>&lt;plugins&gt;<br/>&lt;plugin&gt;<br/>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>&lt;/plugin&gt;<br/><strong class="ll hi">&lt;plugin&gt;<br/>&lt;groupId&gt;com.spotify&lt;/groupId&gt;<br/>&lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;<br/>&lt;version&gt;1.3.6&lt;/version&gt;<br/>&lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;<br/>&lt;buildArgs&gt;&lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt;&lt;/buildArgs&gt;<br/>&lt;/configuration&gt;<br/>&lt;/plugin&gt;<br/></strong>&lt;/plugins&gt;<br/>&lt;/build&gt;</span></pre><p id="f33c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在你可以做:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="4c94" class="jw jx hh ll b fi lp lq l lr ls">mvn clean package<br/>mvn dockerfile:build</span></pre><p id="0204" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并运行它:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="d499" class="jw jx hh ll b fi lp lq l lr ls">docker run -p 8080:8080 -t springio/gs-reactive-rest-service:latest</span></pre><p id="b326" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这么简单！</p></div><div class="ab cl jp jq go jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="ha hb hc hd he"><p id="ad9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lw">原载于2018年11月10日</em><a class="ae jc" href="http://javaoraclesoa.blogspot.com/2018/10/running-reactive-spring-boot-on-graalvm.html" rel="noopener ugc nofollow" target="_blank"><em class="lw">【javaoraclesoa.blogspot.com】</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>