<html>
<head>
<title>Revisiting the Performance &amp; Scalability of Java Applications that use RDBMSes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新审视使用RDBMSes的Java应用程序的性能和可伸缩性</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/revisiting-java-applications-performance-scalability-with-rdbms-68d9f85466ca?source=collection_archive---------0-----------------------#2018-09-04">https://medium.com/oracledevs/revisiting-java-applications-performance-scalability-with-rdbms-68d9f85466ca?source=collection_archive---------0-----------------------#2018-09-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="474c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">我最近的</em> <a class="ae jd" href="http://db360.blogspot.com/2018/03/optimizing-performance-scalability-of.html" rel="noopener ugc nofollow" target="_blank"> <em class="jc">博文</em> </a>的再版</p><p id="4477" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi je translated">这里有大量关于Java性能的文献(书籍、文章、博客、网站等等)；谷歌搜索返回超过500万次点击。举几个例子，<em class="jc">有效的Java编程语言指南</em>，<em class="jc"> Java性能权威指南</em>，<em class="jc"> Java性能调优简讯</em>及其相关的<a class="ae jd" href="http://www.javaperformancetuning.com" rel="noopener ugc nofollow" target="_blank">网站</a>。<br/>这篇博文回顾了已知的加速和扩展Java应用程序数据库操作的最佳实践，然后讨论了新的机制，如数据库代理和异步数据库访问(ADBA)提议。</p><h1 id="32f4" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">加速Java应用程序中的RDBMS操作</h1><p id="904a" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">优化Java应用程序的数据库操作包括:加速数据库连接、加速SQL语句处理、优化网络流量和就地处理。</p><h2 id="14f5" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">加速数据库连接</h2><p id="c524" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">连接建立是最昂贵的数据库操作；Java开发人员多年来一直使用的明显优化是连接池，它避免在运行时创建连接(除非您耗尽了池容量。</p><p id="002c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">客户端连接池</em> </strong> <br/> Java连接池，如Apache Commons DBCP、C3P0、<a class="ae jd" href="https://docs.oracle.com/database/122/JJUCP/toc.htm" rel="noopener ugc nofollow" target="_blank">Oracle Universal Connection Pool(UCP)</a>等，是用作独立Java应用程序的一部分或用作Java EE容器(如Tomcat、Weblogic、WebSphere等)的数据源的一部分的库。Java EE容器嵌入了它们自己的连接池，但也允许第三方池(例如，将UCP与Tomcat一起使用<a class="ae jd" href="http://www.oracle.com/technetwork/database/application-development/planned-unplanned-rlb-ucp-tomcat-2265175.pdf" rel="noopener ugc nofollow" target="_blank">，将UCP与Weblogic一起使用</a><a class="ae jd" href="https://blogs.oracle.com/dev2dev/create-and-deploy-a-java-servlet-using-weblogic-server-wls" rel="noopener ugc nofollow" target="_blank"/><a class="ae jd" href="https://blogs.oracle.com/dev2dev/create-and-deploy-a-java-servlet-using-weblogic-server-wls" rel="noopener ugc nofollow" target="_blank"/>)。<br/> <br/>大多数Java应用程序使用客户端或中间层连接池来支持中小型工作负载，但是，这些连接池仅限于JRE/JDK实例(即，不能超出其边界共享)，并且在部署数万个中间层或Web服务器时不切实际。即使每个web层上的池非常小，RDBMS服务器也会被数以千计的预分配连接所淹没，这些连接在90%以上的时间都处于空闲状态。</p><p id="d9ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">代理连接池</em> </strong> <br/> <br/>数据库代理，如<a class="ae jd" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" rel="noopener ugc nofollow" target="_blank"> MySQL路由器</a>、流量管理器模式下的Oracle数据库连接管理器(<a class="ae jd" href="http://www.oracle.com/technetwork/database/enterprise-edition/cman-overview-084817.html" rel="noopener ugc nofollow" target="_blank"> CMAN-TDM </a>)、<a class="ae jd" href="http://NGINX | High Performance Load Balancer, Web Server, &amp; Reverse ... https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>等，是位于数据库客户机(即Java应用程序、Web层)和RDBMS之间的代理服务器。这允许数千个中间层共享一个公共连接池。参见本博客第二部分的数据库代理。</p><p id="1cf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，Oracle数据库还提供了数据库端连接池，如<a class="ae jd" href="https://gerardnico.com/db/oracle/shared_server" rel="noopener ugc nofollow" target="_blank">共享服务器</a>和<a class="ae jd" href="https://docs.oracle.com/cd/E85694_01/ODPNT/featConnecting.htm#ODPNT-GUID-757A465B-4025-4550-8F13-EA92FE0C1B5A" rel="noopener ugc nofollow" target="_blank">数据库常驻连接池</a>(DRCP)；这些就不在本帖讨论了。</p><p id="2f18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">杂项连接优化</em> </strong></p><p id="f236" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其他连接优化功能包括:推迟连接健康检查，并降低故障节点的优先级。</p><p id="0d27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">推迟连接运行状况检查</em> <br/>连接池将连接运行状况检查<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/jjucp/validating-ucp-connections.html#GUID-139508B9-1456-41CA-A860-2AFD9352C1E6" rel="noopener ugc nofollow" target="_blank">推迟一段时间</a>的能力，可以加快连接检查(即<em class="jc"> getConnection() </em>返回速度)。<br/> <em class="jc"> <br/> </em> <em class="jc">取消失败节点的优先级<br/> </em>在Oracle RAC等多实例集群数据库环境中，<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/jjdbc/JDBC-getting-started.html#GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B" rel="noopener ugc nofollow" target="_blank">此功能</a>在定义的时间段内为失败的实例分配低优先级(也就是说，避免尝试从失败的实例获取连接)，从而加快连接检查。</p><h2 id="a9d9" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">加速SQL语句处理</h2><p id="ba77" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">处理SQL语句需要几个步骤，包括:解析(至少一次)、绑定变量、执行、获取结果集(如果是查询)以及提交或回滚事务(如果是DML，即插入、更新或删除)。JDBC提供了几个APIs旋钮来优化SQL语句处理，包括:预处理语句、语句缓存和结果集缓存。</p><p id="2d42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">禁用默认提交</em> </strong></p><p id="3d1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动提交每个DML是JDBC的默认/隐式事务模式。除非此模式符合您的需要，否则您应该在连接对象上显式禁用它，并用显式提交或回滚调用来区分您的事务(DML +查询)。<br/> <em class="jc">即conn.setAutoCommit(假)；</em></p><p id="4a76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">准备好的报表</em> </strong></p><p id="5a1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在执行SQL语句之前，必须对其进行解析(如果尚未解析的话)。解析(即<a class="ae jd" href="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:2588723819082" rel="noopener ugc nofollow" target="_blank">硬解析</a>)是处理SQL语句时开销最大的操作。最佳实践包括使用<a class="ae jd" href="https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html" rel="noopener ugc nofollow" target="_blank">准备好的语句</a>，在为绑定变量设置新值后，这些语句被解析一次，然后在后续调用中被多次重用。预准备语句的一个安全副产品是预防SQL注入。</p><p id="90c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">报表缓存</em> </strong></p><p id="894d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以指示JDBC驱动程序在<em class="jc"> smt.close() </em>上自动缓存SQL语句(PreparedStatements和CallableStatements)。在相同语句的后续调用中，驱动程序指示RDBMS使用现有语句(即“<em class="jc"> use statement #2 </em>”)，而不发送语句字符串，从而避免了软解析(词法分析、语法解析)和潜在的网络往返。</p><p id="61e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在connection对象或datasource对象上启用了隐式语句缓存(注意:语句缓存是每个物理连接的一个数组)。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="d88f" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">带有更改通知的结果集缓存—困难的方式</h2><p id="9595" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">缓存JDBC结果集可以避免重复执行相应的SQL查询，从而显著提高Java应用程序的性能。RDBMSes允许在服务器端缓存结果集，但是应用程序需要往返于数据库来检索它。本主题将在<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/18/tgdba/database-performance-tuning-guide.pdf" rel="noopener ugc nofollow" target="_blank"> Oracle数据库性能调优指南</a>的第15章中详细讨论。</p><p id="2a21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过进一步优化，这些结果集可以被推送到驱动程序(Java、C/C++、PHP、C#等)中，由应用程序使用，而无需数据库往返。如果结果集变得陈旧，与RDBMS表中的实际数据不同步，该怎么办？RDBMSes提供了维护最新结果集的机制，从而确保了缓存结果集的一致性。例如，Oracle数据库的查询更改通知允许向RDBMS注册SQL查询，并在其他线程提交的DML导致结果集不同步时接收通知。</p><p id="7080" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java应用程序可以通过以下步骤显式实现带有更改通知的结果集缓存:</p><p id="aff3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">0)先决条件:必须启用服务器端结果集缓存，并且必须授予数据库用户模式“更改通知”权限。<br/>如<em class="jc">向人力资源部授予变更通知</em>；//可能需要您的数据库管理员的帮助。</p><ol class=""><li id="b786" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lq lr ls lt bi translated">在连接对象上创建“注册”</li></ol><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="74ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2)将查询与注册相关联</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="721f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3)听通知</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a64f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参阅《甲骨文JDBC开发者指南》的第26章了解更多详情。</p><h2 id="22da" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">带有更改通知的结果集缓存—更简单的方法</h2><p id="834e" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">您最好使用以下步骤，以更简单的方式启用客户端带无效的恢复集缓存(在Oracle JDBC驱动程序18.3版及更高版本中可用)</p><ol class=""><li id="df88" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lq lr ls lt bi translated">在数据库配置文件(也称为INIT.ORA)中设置以下参数。</li></ol><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f309" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2)将JDBC连接属性<em class="jc">Oracle . JDBC . enablequeryresultcache</em>设置为true(默认值)。</p><p id="ac3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3)将以下提示添加到SQL查询字符串"<em class="jc"> /*+ RESULT_CACHE */ </em>"</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a98d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果不能通过修改Java/JDBC源代码来添加SQL提示，可以指示RDBMS缓存与特定表相关的所有查询的结果集，可以在创建表时(默认模式)缓存，也可以在以后(强制模式)缓存；这就是所谓的“表格标注”。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="dd77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle RDBMS提供了一些视图，如用于监控结果集缓存有效性的V$RESULT_CACHE_STATISTICS 和一个<em class="jc">CLIENT _ RESULT _ CACHE _ STATS $</em>表。有关配置服务器端结果集缓存的更多详细信息，请参见<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/tgdba/database-performance-tuning-guide.pdf" rel="noopener ugc nofollow" target="_blank">性能调整指南</a>中的第15节</p><h2 id="c91c" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">数组提取</h2><p id="c12e" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">当从结果集中检索大量行时，必须进行数组提取。可以在语句、PreparedStatement、CallableStatement或ResultSet对象上指定提取大小。<br/>示例:pstmt . setfetchsize(20)；</p><p id="1476" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当使用Oracle数据库时，该数组大小受RDBMS的内部缓冲区(称为会话数据单元(SDU ))的限制。SDU缓冲区用于通过网络将数据从表传输到客户机。该缓冲区的大小(以字节为单位)可以在JDBC URL中指定，如下所示。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4b31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者在网络服务配置文件<em class="jc"> sqlnet.ora </em>和<em class="jc"> tnsnames.ora </em>中的服务级别。根据RDBMS版本的不同，有一个硬限制:DB 12c和更高版本为2MB，DB 11.2为64K，DB 11.2之前为32K。<br/>总之，即使您将数组获取设置为一个较大的数字，它也不能在每次往返中检索到比SDU允许的更多的数据。</p><h2 id="48b9" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">数组DML(更新批次)</h2><p id="484f" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">JDBC规范允许发送一批相同的DML操作(即，阵列插入、阵列更新、阵列删除)以便在服务器上顺序执行，从而减少网络往返。</p><p id="0077" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新批处理包括显式调用<em class="jc"> addBatch </em>方法，该方法将一条语句添加到一个操作数组中，然后显式调用<em class="jc"> executeBatch </em>方法发送该语句，如下例所示。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="3e0a" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">优化网络流量</h2><p id="66a0" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">这里有两种机制可以帮助优化Java代码和RDBMS之间的网络流量:网络压缩和会话多路复用。</p><p id="c414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">网络数据压缩</em> </strong></p><p id="0d55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过局域网或广域网压缩Java应用程序和RDBMS之间传输的数据的能力减少了数据量、传输时间和往返次数。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9e9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">会话多路复用</em></strong><em class="jc"/><br/><br/>Oracle数据库连接管理器(又名CMAN)提供了在单个网络连接上汇集多个数据库连接的能力，从而节省了操作系统资源。在<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/18/netag/net-services-administrators-guide.pdf" rel="noopener ugc nofollow" target="_blank">网络服务管理指南</a>中查看更多详细信息。</p><h2 id="a4c6" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">就地处理</h2><p id="c88f" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">如前所述，SQL语句处理涉及数据库客户机(即Java中间层/web服务器)和RDBMS之间的多次往返。如果将Java代码移近或移入RDBMS会话/进程，就减少了构成大部分延迟的网络流量。<br/>好吧，存储过程是过时的，所以是七十年代的，但是现代数据处理，如Hadoop或Spark，将处理和数据放在一起以实现低延迟。</p><p id="3ee1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你的目标是效率，你应该考虑在数据绑定模块中使用Java存储过程。我在我的书的第一章<a class="ae jd" href="http://www.amazon.com/exec/obidos/ASIN/1555583296" rel="noopener ugc nofollow" target="_blank">中讨论了存储过程的利弊。我要补充的是，在现代基于微服务的架构中，REST包装的存储过程是数据绑定服务的良好设计选择。</a></p><p id="cf76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有RDBMSes都提供各种语言的存储过程，包括专有过程语言、Java、JavaScript、PHP、Perl、Python和TCL。Oracle数据库提供Java和<a class="ae jd" href="https://github.com/oracle/oracle-db-examples/tree/master/plsql" rel="noopener ugc nofollow" target="_blank"> PL/SQL存储过程</a>。数据库中的Java是最好的无名Oracle数据库宝石之一；参见GitHub上的一些代码示例。</p><h1 id="fbd7" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">横向扩展Java工作负载</h1><p id="66a6" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">在这篇博文的第二部分，我将讨论扩展Java工作负载的各种机制，包括分片和多租户数据库、数据库代理和异步Java数据库访问API提议。</p><h2 id="b904" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">使用分片数据库的Java应用程序的水平伸缩</h2><p id="93fa" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">分片数据库——跨越几个数据库对表进行水平分区——已经存在一段时间了。使用分片数据库的Java应用程序必须:<br/> (i)定义哪些字段用作分片键(和超级分片键)<br/> (ii)设置值并构建键，然后请求连接到数据源。<br/> Java SE 9提供了<a class="ae jd" href="https://docs.oracle.com/javase/9/docs/api/java/sql/ShardingKey.html" rel="noopener ugc nofollow" target="_blank">标准API</a>来构建分片和超级分片密钥。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="787f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有进一步的优化，所有碎片感知连接请求都将转到一个中央机制，该机制维护碎片键的映射或拓扑，从而导致每个请求多一跳。</p><p id="dc61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle通用连接池(UCP)得到了增强，可以透明地收集映射到特定碎片的所有密钥。一旦UCP获得了密钥范围，它就根据碎片密钥将连接请求定向到适当的碎片。</p><h2 id="ce65" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">扩展多租户Java应用程序</h2><p id="8d81" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">完全多租户Java应用程序必须使用多租户RDBMS，其中一组租户或每个租户都有自己的数据库(用Oracle的说法，它有自己的<em class="jc">可插拔数据库或PDB </em>)。对于成千上万的租户，使用成千上万的数据库(或pdb ),一种简单的方法是为每个数据库分配一个池；我们已经见证了每个租户一个连接的幼稚架构。<br/>Oracle UCP已经过增强，可以使用一个池来管理所有(数万)数据库。在向特定数据库发出连接请求时，如果没有连接到该数据库的空闲/可用连接，UCP会透明地重新利用池中的一个空闲连接，该连接连接到另一个要重新连接到该数据库的数据库，从而允许使用一小组池连接来服务所有租户。</p><p id="e061" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参见<a class="ae jd" href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/jjucp/shared-pool-for-multitenant-data-sources.html#GUID-7C397AA8-9C78-4DB0-AAF4-15BBF9AFFB85" rel="noopener ugc nofollow" target="_blank">UCP文档</a>了解关于每个租户使用一个数据源或所有租户使用一个数据源的更多详细信息。</p><h2 id="ff4e" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated">数据库代理</h2><p id="85e2" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">代理是运行在数据库和其客户端之间的中间人软件，例如Java应用程序。市场上有几种代理产品；举几个例子:<a class="ae jd" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" rel="noopener ugc nofollow" target="_blank"> MySQL路由器</a>、流量管理器模式下的Oracle数据库连接管理器(<a class="ae jd" href="http://www.oracle.com/technetwork/database/enterprise-edition/cman-overview-084817.html" rel="noopener ugc nofollow" target="_blank"> CMAN-TDM </a>)、ProxySQL等等。<br/>Oracle CMAN-TDM是Oracle数据库18c中的新增功能；它是现有Oracle连接管理器(也称为CMAN)的扩展，提供了以下新功能</p><ul class=""><li id="f9e1" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lu lr ls lt bi translated">对应用程序完全透明</li><li id="8524" class="ll lm hh ig b ih lv il lw ip lx it ly ix lz jb lu lr ls lt bi translated">将数据库流量路由到正确的实例(计划)</li><li id="9085" class="ll lm hh ig b ih lv il lw ip lx it ly ix lz jb lu lr ls lt bi translated">隐藏数据库计划内和计划外停机，以支持零应用程序停机</li><li id="0a80" class="ll lm hh ig b ih lv il lw ip lx it ly ix lz jb lu lr ls lt bi translated">优化数据库会话使用和应用程序性能</li><li id="e6b3" class="ll lm hh ig b ih lv il lw ip lx it ly ix lz jb lu lr ls lt bi translated">增强数据库安全性</li></ul><p id="1b17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">CMAN-TDM是客户端无关的，它支持所有的数据库客户端应用程序，包括:Java，C，C++，DotNET，Node.js，Python，Ruby，r</p><p id="400b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java应用程序将连接到CMAN-TDM，后者又使用最新的驱动程序和库连接到数据库，然后透明地提供应用程序只有使用最新的驱动程序和API才能获得的服务质量。</p><p id="2bed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jd" href="http://www.oracle.com/technetwork/database/enterprise-edition/cman-overview-084817.html" rel="noopener ugc nofollow" target="_blank"> CMAN登录页面</a>和登录页面链接的网络服务文档中查看更多详细信息。</p><h2 id="57de" class="kq jo hh bd jp kr ks kt jt ku kv kw jx ip kx ky kb it kz la kf ix lb lc kj ld bi translated"><strong class="ak">异步数据库访问API (ADBA) </strong></h2><p id="463e" class="pw-post-body-paragraph ie if hh ig b ih kl ij ik il km in io ip kn ir is it ko iv iw ix kp iz ja jb ha bi translated">现有的JDBC API导致线程阻塞、线程调度和争用；它不适合反应式应用程序或高吞吐量和大规模部署。有第三方异步Java数据库访问库，但是Java社区需要一个标准API，用户线程在其中提交数据库操作并返回。</p><p id="b735" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于Java . util . concurrent . completion stage接口的新API提案；它可以从OpenJDK沙箱@<a class="ae jd" href="http://tinyurl.com/java-async-db." rel="noopener ugc nofollow" target="_blank">http://tinyurl.com/java-async-db.</a>下载。API实现负责执行操作，完成CompletableFutures。<br/>您可以通过<a class="ae jd" href="https://www.slideshare.net/oracledevs/silicon-valley-jug-meetup-july-18-2018/oracledevs/silicon-valley-jug-meetup-july-18-2018" rel="noopener ugc nofollow" target="_blank">最新的演示和示例</a>感受ADBA API。</p><p id="8012" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> ADBA战胜JDBC</em></strong></p><p id="9b30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了帮助社区了解ADBA，它的一个测试/功能版本(没有异步行为)在JDBC运行——我们称之为AoJ在ADBA而不是JDBC —@<a class="ae jd" href="https://github.com/oracle/oracle-db-examples/tree/master/java/AoJ" rel="noopener ugc nofollow" target="_blank">https://github . com/Oracle/Oracle-d b-examples/tree/master/Java/AoJ</a>。我鼓励读者去玩<a class="ae jd" href="https://github.com/oracle/oracle-db-examples/tree/master/java/AoJ/test/com/oracle/adbaoverjdbc/test" rel="noopener ugc nofollow" target="_blank">张博的例子</a>。</p><p id="adbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着将纤程和Java延续引入JVM的项目Loom的发布，我们将再次回顾使用RDBMSes的Java应用程序的性能和可伸缩性。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="25b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">原载于2018年3月29日</em><a class="ae jd" href="http://db360.blogspot.com/2018/03/optimizing-performance-scalability-of.html" rel="noopener ugc nofollow" target="_blank"><em class="jc">db360.blogspot.com</em></a><em class="jc">。</em></p></div></div>    
</body>
</html>