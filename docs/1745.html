<html>
<head>
<title>Using Stub vs Mock in iOS Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS单元测试中使用存根与模拟</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-stub-vs-mock-in-ios-unit-testing-634ec4cc6a10?source=collection_archive---------0-----------------------#2020-06-30">https://medium.com/capital-one-tech/using-stub-vs-mock-in-ios-unit-testing-634ec4cc6a10?source=collection_archive---------0-----------------------#2020-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="ee64" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">为什么这些稍微相似的物体不能互换</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/412f1913ed46af46832328ac7bde6756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eeXRbZqksIySIukz"/></div></div></figure><p id="6489" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">存根和模拟对象之间有非常细微的差别。在我职业生涯的早期，我知道它们是什么，但不知道正确使用它们的重要性。在应该使用存根的地方使用模拟可能会导致脆弱和难以维护的测试。此外，在我们应该使用模拟的地方使用存根可以防止我们捕捉到意外的有害行为，这些行为会让本应该失败的测试通过。</p><p id="412d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了帮助确保我们团队中的所有iOS工程师都在同一页面上，并理解存根和模拟之间的差异，我决定以博客帖子的形式交流这一点。在这篇博文中，我将讲述如何为iOS项目创建和使用可靠且易于维护的存根和模拟。</p><h1 id="593f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">什么是存根和模拟？</h1><p id="7d75" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">首先，让我们定义我们的术语模拟和存根。</p><h2 id="4bf4" class="lb kf hh bd kg lc ld le kk lf lg lh ko jr li lj kq jv lk ll ks jz lm ln ku lo bi translated">烟蒂</h2><p id="5994" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">存根只是为我们的测试返回假数据。仅此而已。</p><h2 id="7437" class="lb kf hh bd kg lc ld le kk lf lg lh ko jr li lj kq jv lk ll ks jz lm ln ku lo bi translated">模拟的</h2><p id="5eee" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">mock比stub稍微复杂一些。它返回一些假数据，还可以验证是否调用了特定的方法。</p><h1 id="6fc9" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">存根和模拟之间的细微差别</h1><p id="b620" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">测试<em class="lp">并不真正关心函数是否在存根上被调用，只要测试对象(或被测系统)从存根上获得它需要的数据并做正确的事情。</em></p><p id="a361" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于一个模拟，我们能够<em class="lp">验证模拟对象上的</em>方法调用的事实意味着我们确实<em class="lp">关心</em>它做了什么。我们通常可以在模拟对象上指定我们期望<em class="lp">调用</em>什么方法。因此，如果在测试动作之后没有调用我们期望的方法，那么当我们验证模拟对象时，测试应该会失败。此外，如果发生了意想不到的事情——例如，在模拟对象上调用了一个意想不到的方法——验证模拟对象上的方法调用应该会使测试失败。</p><h1 id="8146" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Swift单元测试示例</h1><p id="4e9c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">下面是创建模拟类进行测试的最常见的方法之一。假设我们正在测试一个具有多种功能的手机屏幕。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="6f2e" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">// code<br/>struct</strong> MoreViewController {<br/>    <strong class="lr hi">let</strong> viewRenderer: ViewRendererProtocol<br/>    <br/>    <strong class="lr hi">func</strong> loadFeatureOne() {<br/>      viewRenderer.renderFeatureOne()<br/>    }</span><span id="6ecf" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    func</strong> loadFeatureTwo() {<br/>      viewRenderer.renderFeatureTwo()<br/>    }<br/>}</span><span id="72b1" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">// mock<br/>class</strong> MockViewRenderer: ViewRendererProtocol {</span><span id="0016" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    private(set)</strong> <strong class="lr hi">var</strong> hasCalledRenderFeatureOne = <strong class="lr hi">false<br/>    func</strong> renderFeatureOne() {<br/>      hasCalledRenderFeatureOne = <strong class="lr hi">true<br/>    </strong>}</span><span id="b8ad" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    private(set)</strong> <strong class="lr hi">var</strong> hasCalledRenderFeatureTwo = <strong class="lr hi">false<br/>    func</strong> renderFeatureTwo() {<br/>      hasCalledRenderFeatureTwo = <strong class="lr hi">true<br/>    </strong>}<br/>}</span><span id="9e44" class="lb kf hh lr b fi lz lw l lx ly">// usage<br/><strong class="lr hi">func</strong> test_loadFeatureOne_featureOneRendered() {<br/>    <strong class="lr hi">let</strong> mockViewRenderer = MockViewRenderer()<br/>    <strong class="lr hi">let</strong> sut = MoreViewController(viewRenderer: mockViewRenderer)</span><span id="8639" class="lb kf hh lr b fi lz lw l lx ly">    // when<br/>    sut.loadFeatureOne()</span><span id="4dae" class="lb kf hh lr b fi lz lw l lx ly">    // then<br/>    XCTAssertTrue(mockViewRenderer.hasCalledRenderFeatureOne)<br/>    XCTAssertFalse(mockViewRenderer.hasCalledRenderFeatureTwo)<br/>}</span></pre><p id="3e07" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">以上是创建模拟/伪造对象的一种基本方法。但是随着我们项目的扩展，我们可以在上面的例子中发现一些问题。</p><p id="f9e2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有时，当我们向协议中添加一个新函数并更新它的fake/mock类时，很容易忘记为这个新行为添加断言。在上面的例子中，如果ViewRendererProtocol有十个特性，并且我们的每个测试只关心是否调用了一个函数，那么在测试结束时，我们会有一个很长的<code class="du ma mb mc lr b">XCTAssertFalse</code>列表。</p><h1 id="42d8" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">开源拯救世界</h1><p id="3b28" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">有很多开源框架可以帮助我们创建模拟或伪造的对象。在本文中，我们将使用一个名为<a class="ae md" href="https://github.com/mflint/SwiftMock" rel="noopener ugc nofollow" target="_blank"> SwiftMock </a>的开源模仿框架。有了这个框架，我们就不用担心在新函数上调用断言了。它还帮助我们捕捉意外的函数调用，因此不需要“XCTAssertFalse”所有其他不应该被调用的函数。</p><p id="3779" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">SwiftMock 的思想是，它持有一个预期动作的数组(一个函数名的字符串数组)，当在Mock对象上调用函数时，动作被从数组中删除。最后，它验证最终的数组是否为空。如果为空，则意味着所有预期的动作都已被调用，并且没有任何意外的动作被调用。</p><p id="42e1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个例子，展示了我们如何使用SwiftMock使用相同的代码库创建模拟，但这次功能的外观取决于功能切换值。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="8dde" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">// code to test<br/>struct</strong> MoreViewController {</span><span id="bfb0" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    let</strong> featureToggle: FeatureToggleProtocol<br/>    <strong class="lr hi">let</strong> viewRenderer: ViewRendererProtocol</span><span id="c123" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    func</strong> loadFeatures() {</span><span id="dcdc" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">      if</strong> featureToggle.isFeatureOneOn() {<br/>        viewRenderer.renderFeatureOne()<br/>      }</span><span id="e356" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">      if</strong> featureToggle.isFeatureTwoOn() {<br/>        viewRenderer.renderFeatureTwo()<br/>      }<br/>    }<br/>}</span><span id="81b3" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">// stub and mock<br/>class StubFeatureToggle: FeatureToggleProtocol {<br/>    var featureOneEnabled = false<br/>    func isFeatureOneOn() -&gt; Bool {<br/>      return featureOneEnabled<br/>    }</strong></span><span id="16da" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    var featureTwoEnabled = false<br/>    func isFeatureTwoOn() -&gt; Bool {<br/>      return featureTwoEnabled<br/>    }<br/>}</strong></span><span id="d53d" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">class</strong> MockViewRenderer: Mock&lt;ViewRendererProtocol&gt;, ViewRendererProtocol {<br/>    <strong class="lr hi">func</strong> renderFeatureOne() {<br/>      accept()<br/>    }</span><span id="3eb3" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    func</strong> renderFeatureTwo() {<br/>      accept()<br/>    }<br/>}</span><span id="8a8c" class="lb kf hh lr b fi lz lw l lx ly">// test<br/><strong class="lr hi">func</strong> test_loadFeatures_featureOneRendered() {<br/> <br/>    // given<br/>    // .create() is one way a create a mock object for the SwiftMock framework<br/>    <strong class="lr hi">let</strong> mockViewRenderer = MockViewRenderer.create()<br/>    <strong class="lr hi">let</strong> stubFeatureToggle = StubFeatureToggle.create()<br/>    stubFeatureToggle.featureOneEnabled = <strong class="lr hi">true<br/>    let</strong> sut = MoreViewController(<br/>      featureToggle: stubFeatureToggle,<br/>      viewRenderer: mockViewRenderer)</span><span id="f277" class="lb kf hh lr b fi lz lw l lx ly">    // expect<br/>    mockViewRenderer.expect { object <strong class="lr hi">in</strong> object.renderFeatureOne() }</span><span id="2ebf" class="lb kf hh lr b fi lz lw l lx ly">    // when<br/>    sut.loadFeatures()</span><span id="b351" class="lb kf hh lr b fi lz lw l lx ly">    // then<br/>    mockViewRenderer.verify()</span><span id="e89f" class="lb kf hh lr b fi lz lw l lx ly">}</span></pre><p id="5ca8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">SwiftMock框架为我们提供了<code class="du ma mb mc lr b"><strong class="jk hi">.</strong>expect</code> <em class="lp"> </em>和<code class="du ma mb mc lr b">.verify()</code> <strong class="jk hi"> </strong>。注意，这个版本在验证阶段稍微简单一些，我们可以通过调用<code class="du ma mb mc lr b">verify()</code>对预期和意外的动作进行相同的检查。</p><p id="c0bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于存根，我们保持它应该的简单。当<code class="du ma mb mc lr b">isFeatureOneOn()</code>被调用时，<code class="du ma mb mc lr b">stubFeatureToggle</code>就返回true。</p><h1 id="1679" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">所以我们为什么不把一切都变成一场模拟呢？</h1><p id="8a35" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">因为模拟可能是维护的负担，尤其是当我们的测试并不真正关心的时候。</p><p id="6abb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，让我们重新看看同一个代码示例。开始时，可能只有一个功能。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="dfb2" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">struct</strong> MoreViewController {</span><span id="ddef" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    let</strong> featureToggle: FeatureToggleProtocol<br/>    <strong class="lr hi">let</strong> viewRenderer: ViewRendererProtocol</span><span id="113a" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    func</strong> loadFeatures() {</span><span id="c3b7" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">      if</strong> featureToggle.isFeatureOneOn() {<br/>        viewRenderer.renderFeatureOne()<br/>      }<br/>    }<br/>}</span></pre><p id="abcb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可能有一个单元测试，其中的<code class="du ma mb mc lr b">FeatureToggle</code>对象是一个模拟对象。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="10d0" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">func</strong> test_loadFeatures_featureOneRendered() {</span><span id="4bb2" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    let</strong> mockViewRenderer = MockViewRenderer.create()<br/>    <strong class="lr hi">let</strong> mockFeatureToggle = MockFeatureToggle.create()<br/>    mockFeatureToggle.featureOneEnabled = <strong class="lr hi">true<br/>    let</strong> sut = MoreViewController(<br/>      featureToggle: mockFeatureToggle,<br/>      viewRenderer: mockViewRenderer)</span><span id="6047" class="lb kf hh lr b fi lz lw l lx ly">    // expect<br/>    mockFeatureToggle.expect { object <strong class="lr hi">in</strong> object.isFeatureOneOn() }<br/>    mockViewRenderer.expect { object <strong class="lr hi">in</strong> object.renderFeatureOne() }</span><span id="b579" class="lb kf hh lr b fi lz lw l lx ly">    // when<br/>    sut.loadFeatures()</span><span id="8ca0" class="lb kf hh lr b fi lz lw l lx ly">    // then<br/>    mockFeatureToggle.verify()<br/>    mockViewRenderer.verify()<br/>}</span></pre><p id="e0fa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，我们的测试期望调用<code class="du ma mb mc lr b">isFeatureOneOn()</code>，并且断言调用了<code class="du ma mb mc lr b">renderFeatureOne()</code>。</p><p id="3e8b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们在屏幕上添加第二个特性，相同的<code class="du ma mb mc lr b">ViewController</code>现在将调用<code class="du ma mb mc lr b">featureToggle.isFeatureTwoOn()</code>。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="803d" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">func</strong> loadFeatures() {</span><span id="7a1d" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    if</strong> featureToggle.isFeatureOneOn() {<br/>      viewRenderer.renderFeatureOne()<br/>    }</span><span id="a219" class="lb kf hh lr b fi lz lw l lx ly"><strong class="lr hi">    if</strong> featureToggle.isFeatureTwoOn() {<br/>      viewRenderer.renderFeatureTwo()<br/>    }<br/>}</span></pre><p id="d7bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于<code class="du ma mb mc lr b">FeatureToggle.isFeatureTwoOn()</code>上的“意外调用”，这将中断现有的单元测试<code class="du ma mb mc lr b">test_loadFeatures_featureOneRendered()</code>。</p><pre class="ix iy iz ja fd lq lr ls lt aw lu bi"><span id="8432" class="lb kf hh lr b fi lv lw l lx ly"><strong class="lr hi">error: -[StubVsMockTests.StubVsMockTests test_loadFeatures_featureOneRendered] : failed — Unexpected call: isFeatureTwoOn()</strong></span></pre><p id="88c5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，我们必须在<code class="du ma mb mc lr b">test_loadFeatures_featureOneRendered()</code>上添加<code class="du ma mb mc lr b">featureToggle.isFeatureTwoOn() </code>的期望值，以消除错误。</p><p id="4b37" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后，如果我们添加第三个特性，<code class="du ma mb mc lr b">ViewController</code>将调用<code class="du ma mb mc lr b">featureToggle.isFeatureThreeOn()</code>，这将破坏我们的<code class="du ma mb mc lr b">featureOne</code>和<code class="du ma mb mc lr b">featureTwo</code>测试。为了通过测试，我们现在需要更新两倍的内容。</p><p id="4cce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">记住，我们的测试只关心<code class="du ma mb mc lr b">ViewController</code>是否调用了正确的渲染函数。它不关心<code class="du ma mb mc lr b">ViewController</code>是如何做到的。我们的测试是脆弱的，因为假的<code class="du ma mb mc lr b">FeatureToggle</code>是模拟的而不是存根。</p><h1 id="be41" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">结论</h1><p id="11fc" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">俗话说<em class="lp">小不忍则乱大谋</em>。Stub和mock是软件测试领域中不应该被忽视的两个小概念。不正确地使用它们意味着你的单元测试会变得脆弱和/或不可靠。这会导致难以维护的代码库和/或糟糕的软件质量。后果还在继续。</p><p id="1e99" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，这些并不是新的挑战。有许多众所周知的工具和实践可以帮助我们在单元测试中使用存根和模拟。我们在这里刚刚谈到了其中的一些。只要你<em class="lp">理解</em>你所使用的概念、工具和实践，你将在维护和/或修复你的软件项目上节省大量的时间和精力。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="0a0c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lp">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>