<html>
<head>
<title>Building instant image feature detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建筑即时图像特征检测</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/building-instant-image-feature-detection-c6f394fbc922?source=collection_archive---------3-----------------------#2017-04-21">https://medium.com/pinterest-engineering/building-instant-image-feature-detection-c6f394fbc922?source=collection_archive---------3-----------------------#2017-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a940" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kent Brewster | Pinterest产品工程工程师</p><p id="c7bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上个月，我们在Chrome浏览器扩展中推出了<a class="ae jc" rel="noopener" href="/@Pinterest_Engineering/engineering-visual-search-inside-pinterest-browser-extensions-90e7ed9d2b14">视觉搜索。</a>在我们发货后，我们注意到很多点击显示“网站”的注释更仔细的检查发现，这些总是来自于从上下文菜单发起的搜索，该菜单在从浏览器窗口生成的屏幕截图上运行视觉搜索。(要用Chrome试试这个，右击任何页面的空白处，选择“搜索”。)</p><p id="f505" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">全窗口截图的结果和注释非常令人失望。由于它们倾向于匹配之前保存到Pinterest的截图，我们显示的结果是“网站”、“互联网网站”和“Wordpress主题”，而不是截图中有趣的对象。</p><p id="4ab6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们没有一个后端API准备好看一个截图，返回里面有趣的东西的列表。即使我们这样做了，它也会慢得令人无法接受，在最好的情况下，会使用户第一次看到选择工具时延迟几秒钟。</p><p id="8fce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们没有将每一张截图发送回Pinterest进行分析，而是想出了一种方法，在浏览器扩展中只使用JavaScript来检测有趣的东西。</p><h2 id="2022" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">将屏幕截图转换为数据</h2><p id="63cc" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">要搜索图像内部，我们需要查看单个像素的颜色。使用普通的HTML、CSS和JavaScript通常不可能做到这一点，但是因为我们在浏览器扩展中，所以我们有更高的特权。这里有一个原始截图，渲染到一个<canvas>标签:</canvas></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/5da619e8311aa2eb10b9390968605ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DSw_UJoSPlUQIYT0."/></div></div></figure><h2 id="1346" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">对原始数据进行缩减采样</h2><p id="bb50" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">屏幕截图可能会很大，我们将进行一系列递归函数调用，这是一个很好的方式来崩溃浏览器的最大调用堆栈大小超过错误。因此，在我们做任何其他事情之前，让我们将统计世界的大小从1100x800(几乎一百万像素)减少到最大80x80。</p><p id="2d0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们取两个维度(高度或宽度)中较大的一个，除以80得到样本大小。如果我们的原始图像是1100x800，我们将使用14x14的样本，将我们的原始图像转换成类似这样的图像:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/3695466032fa6486ed3f90bd6370a904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t4WpFOXk6zSgGqji."/></div></div></figure><p id="7d69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们没有做任何花哨的事情，比如平均每个样本样本中的所有颜色；我们只是使用左上角的像素。当被采样的页面没有滚动时，这似乎给了我们更好的结果；顶行和左列的左上角像素往往是主要的背景色。</p><h1 id="98c9" class="kp je hh bd jf kq kr ks jj kt ku kv jn kw kx ky jq kz la lb jt lc ld le jw lf bi translated">计算并宣布最流行的颜色为“背景色”</h1><p id="4cbb" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">一旦我们进行了缩减采样，我们依次查看每个样本样本，并计算我们看到它的颜色的次数。完成后，我们按计数排序，最终得到如下颜色列表:</p><pre class="ke kf kg kh fd lg lh li lj aw lk bi"><span id="5b24" class="jd je hh lh b fi ll lm l ln lo">[ “#ffffff”: 1321, “#ffeeee”: 910, “#ffeeaa”: 317 … “#a5e290”: 1]</span></pre><p id="8cff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显示最常见颜色的样本(这里我们将使用前三种)被标记为背景。</p><p id="3612" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们知道我们的背景颜色，我们再次投票所有前景样本。这一次，我们将红绿蓝(RGB)值转换为色调-饱和度-值(HSV)值，并找到与顶部背景色具有相同色调和值的所有样本。当我们找到这些样本时，我们声明它们本身也是背景样本。这捕捉到了许多放大图像下有半透明背景的情况，例如Twitter图像和Instagram帖子的特写视图。</p><p id="9cde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在计算和标记背景之后，剩下的就是这些了。背景块设置为绿色，所以发生了什么在视觉上很明显。剩余的前景块已经被灰度化，因为它们的颜色不再重要。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/c41a235c5274ce7e0840476d654ed68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lElwqNE6h6Xvd5Of."/></div></div></figure><h2 id="0ab7" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">移除孤立像素</h2><p id="78e6" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">看到那些绿色的白色和灰色的小岛了吗？那些不够大，无法搜索，所以我们需要一种方法来摆脱它们。我们一次一个样本地浏览图像，并移除任何在北面、南面、东面或西面有包含背景颜色的相邻块的样本。剩下的看起来简单多了:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/384ef1b1fe0a74e6901a2b08c72c0dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2cRlmGypczhqvN3O."/></div></div></figure><h2 id="3ff9" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">填充剩余的前景块，注意高度和宽度</h2><p id="ad30" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们只剩下几件事了。现在我们需要选出获胜者。我们是这样做的。</p><ol class=""><li id="09a9" class="lp lq hh ig b ih ii il im ip lr it ls ix lt jb lu lv lw lx bi translated">扫描每个样本，<strong class="ig hi"> </strong>计算前景样本的总数<strong class="ig hi">，</strong>这样我们就知道什么时候完成了。</li><li id="26c8" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">再次扫描。这一次，当我们遇到一个前景块，<strong class="ig hi"> </strong>对它和它所有的邻居<strong class="ig hi">，</strong>进行泛色填充，减少每个块剩下的前景块的数量。</li><li id="2cc0" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">当每个前景区域的整体填充完成时，注意每个区域的最小和最大行和列。每组坐标给我们一个矩形区域，其中包含填充区域内的任何不规则性。转换为行、列、高度和宽度，并添加到感兴趣的矩形列表中。</li><li id="f04d" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">继续扫描，直到没有任何前景块留下来填充。</li></ol><p id="cba2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还剩下什么？只有有趣的矩形，这里显示为白色:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/41b786d47df759451d8e157004e7b2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T1w0-dzWdKnGi-Ha."/></div></div></figure><h2 id="7d08" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">找到世界上最有趣的矩形</h2><p id="bf7e" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">矩形更有趣，如果它是:</p><ul class=""><li id="338f" class="lp lq hh ig b ih ii il im ip lr it ls ix lt jb md lv lw lx bi translated">面积大于画布大小的1/16</li><li id="143b" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb md lv lw lx bi translated">宽度不超过高度的3倍</li><li id="2925" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb md lv lw lx bi translated">肖像而不是风景</li><li id="59a5" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb md lv lw lx bi translated">比其他相同大小的矩形更靠近左上角</li></ul><p id="56fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果矩形是这样的，它就一点也不有趣:</p><ul class=""><li id="25ae" class="lp lq hh ig b ih ii il im ip lr it ls ix lt jb md lv lw lx bi translated">尺寸小于100x100像素</li><li id="9627" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb md lv lw lx bi translated">宽度是高度的5倍多</li></ul><p id="3556" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重要提示:我们实际上并没有试图寻找矩形或任何其他形状。我们只是在寻找相邻像素之间的颜色差异。如果我们有一个全屏的背景图片，在深绿色的背景上有一朵不规则的黄色的花，我们希望我们的选择器能够围绕着这朵花，即使它不是一个矩形。</p><p id="dd21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们有了分数，排序和扭转，以找到最好的地区选择。规则没有禁止的最佳矩形获胜。如果我们没有找到一个可接受的矩形，像以前一样选择整个截图。无论哪种方式，画出选择工具，运行搜索，沐浴在更多相关结果的光辉中！</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/277c49b8a3b52f26f969e4b00fee5652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KCoJf53-kIhGYK7-."/></div></div></figure><h2 id="434b" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">结果</h2><p id="5070" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在我们的浏览器扩展中首次发布视觉搜索后，我们检查了一个匿名的全窗口截图样本，该样本已经由Pinners使用选择器工具进行了优化。即时图像特征检测在85%的情况下与Pinner选择的一致(或有所改进)。在所有检测到有趣事物的案例中，搜索注释都返回了比“网站”更好的东西</p><p id="ceb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些改进现在对每个人都适用，我们在96%的时间里都能在截图中检测到有趣的东西，相关搜索结果出现和保存的比率更高，所有这些都不需要Pinner来优化初始选择。</p><p id="7075" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鸣谢:徐克雷、瑞恩·施、史蒂文·拉姆库玛&amp;史蒂文·沃林</p></div></div>    
</body>
</html>