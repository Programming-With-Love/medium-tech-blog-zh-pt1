<html>
<head>
<title>Kotlin and WebFlux in Space</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">太空中的科特林和WebFlux</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/kotlin-and-webflux-in-space-40615f28cb5?source=collection_archive---------2-----------------------#2020-12-14">https://medium.com/google-developer-experts/kotlin-and-webflux-in-space-40615f28cb5?source=collection_archive---------2-----------------------#2020-12-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/935ec88a68880cb67b186ede3d527553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6-h5QCsTIt_u5EK6WFYrA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Logo for the JetBrains Space product</figcaption></figure><h1 id="df9d" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">介绍</h1><p id="0b2b" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">2020年12月9日星期三将见证<a class="ae kp" href="https://www.jetbrains.com/space/" rel="noopener ugc nofollow" target="_blank"> JetBrains Space </a>的正式发布。空间是团队的环境，旨在为版本控制、博客、聊天、代码审查等提供“一站式商店”</p><p id="1e13" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">在<a class="ae kp" href="https://instil.co/" rel="noopener ugc nofollow" target="_blank">研究所</a>，我们是太空的早期采用者。我们的培训团队出席了哥本哈根的<a class="ae kp" href="https://kotlinconf.com/2019/" rel="noopener ugc nofollow" target="_blank"> KotlinConf并参加了发布活动。此后，我们使用它取得了很好的效果，最初是在内部管理新课程的代码库，然后在冠状病毒疫情期间作为我们向虚拟培训转变的一部分。</a></p><p id="65ff" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">Space有自己的HTTP API，可以用来对实例中的各种资源执行CRUD操作。这些包括个人资料、项目、出版物、聊天和日历。为了使用这些端点，您通常会创建并注册自己的应用程序，但是要开始使用，空间管理员可以使用内置的HTTP API Playground。</p><p id="4d32" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">下面是一个使用API Playground检索一个实例中所有注册用户的配置文件的例子。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/954e4a2fac9646902e6772ea5ee7ff61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shHqnStFkHCCk6fDAVfCuw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Space HTTP API Playground</figcaption></figure><h1 id="5e55" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">要完成的任务</h1><p id="6fb6" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">为了庆祝Space的正式发布，让我向您展示如何创建和注册一个可以从外部访问相同端点的应用程序。为了与现代技术的主题保持一致，我们将使用<a class="ae kp" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>语言和Reactive Spring(通过<a class="ae kp" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>和<a class="ae kp" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> WebFlux </a>)。</p><p id="3f82" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">完整的代码可以在<a class="ae kp" href="https://bitbucket.org/GarthGilmour/kotlin-spring-space-2020" rel="noopener ugc nofollow" target="_blank">这个BitBucket Git存储库</a>中找到，但是在这里我将带你从头开始设置和实现。</p></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="01f2" class="it iu hh bd iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ll jo jp jq bi translated">开始吧</h1><p id="d405" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">第一步是用Spring Initializr 创建一个新项目。我们选择Kotlin作为我们的语言，Gradle作为我们的构建工具。</p><p id="5458" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">在依赖关系窗口中，我们选择<em class="lm"> Spring Reactive Web </em>来获取<em class="lm"> WebClient </em>。我们将使用它来访问空间API。但是在我们这样做之前，我们需要通过OAuth登录，所以我们还包括了<em class="lm"> OAuth2客户端</em>。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/ca79ce49549dadf5e3770d341c9be874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXwQTO97PW6LU-RABBjbaQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Spring Initializr Tool</figcaption></figure><p id="7a6e" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">当我们点击<em class="lm"> Generate </em>按钮时，浏览器将下载一个ZIP文件，其中包含一个预配置的构建文件和一些示例代码。我们可以解压缩这个归档文件，并在IntelliJ中打开生成的文件夹。</p><p id="5e22" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">在下面的截图中，我修改了Initializr生成的标准代码，创建了一个基本的控制台应用程序。<em class="lm"> SpaceApp </em>类包含一个bean provider方法，该方法依次构建并返回一个<em class="lm"> CommandLineRunner </em>。Spring将自动检测并运行它来产生我们的“你好，Spring Boot”输出。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/4b9a701c91b9917dbb65104b3a892c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qe3qgWYIY6j0I3ZmU5e68w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Code For a Hello World Spring Boot Application</figcaption></figure><p id="5b49" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">因为我们已经包含了WebFlux框架，Spring会自动启动Netty服务器的一个实例。我们必须在<em class="lm"> application.properties </em>配置文件中显式禁用它(如上所示)。</p></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="2f43" class="it iu hh bd iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ll jo jp jq bi translated">注册我们的应用程序</h1><p id="c0c3" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们现在已经启动并运行了基本的应用程序。在我们继续之前，我们需要在空间中注册它。</p><p id="25f2" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">在我们的空间实例的管理菜单中，我们选择创建一个新的应用程序，并给它命名…</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/c4f047acefe1a892a588e46eab8b58f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVJGY3cE1sFuehwd5lm8fA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Dialog for Creating a New Application in Space</figcaption></figure><p id="63bd" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">然后，我们需要指定我们希望使用哪个OAuth流来验证我们自己。由于我们的应用程序不需要支持通过第三方登录，我们可以选择<em class="lm">客户端凭证流</em>。</p><p id="89e8" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">注意，Space已经为我们的应用程序分配了一个<em class="lm">客户端ID </em>和<em class="lm">客户端秘密</em>。这些是我们在Kotlin / Spring代码中访问HTTP API所需要的。通常这些是安全的，但是为了演示的目的，我们将它们直接放在属性文件中。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/0749ec5b00c42ee833338a804e108418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zh3t92DHRQwPmcxNFacaNw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Space Dialog for Managing Application Authentication</figcaption></figure><p id="b81f" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">最后，我们需要明确授予应用程序适当的权限。空间权限模型是非常细粒度的，目的是使您能够集成外部系统而不损害安全性。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/0373a1f102ce25981c9652ee4e1187de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mWN32VvN2opTBrdSVMD4A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Space Dialog for Managing Application Permissions</figcaption></figure></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="d7f8" class="it iu hh bd iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ll jo jp jq bi translated">向应用程序添加注册详细信息</h1><p id="d487" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">回到IntelliJ，我们需要将刚刚发现的设置添加到<em class="lm"> application.properties </em>文件中。在下面的清单中，我用<em class="lm"> megacorp </em>替换了实际的公司名称，并为客户ID <em class="lm"> (1234) </em>和机密信息<em class="lm"> (5678) </em>添加了虚拟值。</p><blockquote class="ls lt lu"><p id="1549" class="jr js lm jt b ju kq jw jx jy kr ka kb lv ks ke kf lw kt ki kj lx ku km kn ko ha bi translated">space . base . URL = https://mega corp . jetbrains . space<br/>space . API . URL = $ { space . base . URL }/API/http<br/><br/>spring . security . oauth 2 . client . registration . hello . authorization-type = client _ credentials<br/>spring . security . oauth 2 . client . registration . hello . client-id = 1234<br/>spring . security . oauth 2 . client . registration . hello . secret = 5678<br/></p></blockquote><p id="3793" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">注意，属性的名称是由Spring OAuth2模块定义的。但是每个属性名的倒数第二部分是一个标识符，我们可以在代码中使用它来获取一组相关的设置。在这种情况下，标识符是<em class="lm"> HELLO </em>。</p></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="9390" class="it iu hh bd iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ll jo jp jq bi translated">完成代码</h1><p id="4dfe" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">这个过程的最后阶段是我们都喜欢的阶段。编码:-)</p><p id="bb44" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们首先创建Kotlin类型来表示Space返回的数据。Kotlin简洁的语法使得它比老的OO语言中的等价代码要短得多。</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="a4a0" class="md iu hh lz b fi me mf l mg mh">class Name(var firstName: String,<br/>           var lastName: String) {<br/>    override fun toString() = "$firstName $lastName"<br/>}<br/><br/>class Profile(var id: String,<br/>              var username: String,<br/>              var name: Name) {<br/>    override fun toString() = "$id is $name with username $username"<br/>}<br/><br/>class AllProfilesResponse(var next: String,<br/>                          var totalCount: String,<br/>                          var data: List&lt;Profile&gt;)</span></pre><p id="a277" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">接下来的部分是最棘手的。我们需要创建一个Bean Provider方法，它将为我们制造一个<em class="lm"> WebClient </em>对象。通常这是微不足道的，但是这里我们必须使用Spring中的OAuth2支持来确保客户端自动让我们登录。</p><p id="320e" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">这是怎么做的。为了清楚起见，我将该方法放在一个单独的配置类中:</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="c297" class="md iu hh lz b fi me mf l mg mh">@Configuration<br/>class SpaceAppConfig {<br/>    @Bean<br/>    fun oauthWebClient(<br/>          clientRegistrations: ReactiveClientRegistrationRepository,<br/>          @Value("\${space.api.url}") baseUrl: String<br/>        ): WebClient {<br/><br/>        val clientService = InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrations)</span><span id="14b3" class="md iu hh lz b fi mi mf l mg mh">        val manager = AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(clientRegistrations, clientService)</span><span id="683f" class="md iu hh lz b fi mi mf l mg mh">        val oauth = ServerOAuth2AuthorizedClientExchangeFilterFunction(manager)<br/>        oauth.setDefaultClientRegistrationId("HELLO")<br/><br/>        return WebClient.builder()<br/>                .filter(oauth)<br/>                .baseUrl(baseUrl)<br/>                .build()<br/>    }<br/>}</span></pre><p id="0c30" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">请注意:</p><ul class=""><li id="aaf0" class="mj mk hh jt b ju kq jy kr kc ml kg mm kk mn ko mo mp mq mr bi translated">我们使用<em class="lm">值</em>注释传入在<em class="lm"> application.properties </em>文件中定义的空间实例的URL。从而避免重复。</li><li id="a35c" class="mj mk hh jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">我们使用<em class="lm"> HELLO </em>标识符来指定我们希望OAuth2模块使用配置文件中的哪些设置。在实际的解决方案中，我们可能需要对许多远程服务进行身份验证，因此我们需要一种方法来支持任意的属性组。</li></ul><p id="6725" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">现在我们有了一个可以与空间实例通信的<em class="lm"> WebClient </em>对象，我们可以编写一个方法来检索所有可用的概要文件:</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="7029" class="md iu hh lz b fi me mf l mg mh">fun retrieveSpaceProfiles(webClient: WebClient) = webClient<br/>        .get()<br/>        .uri("/team-directory/profiles")<br/>        .retrieve()<br/>        .bodyToFlux(AllProfilesResponse::class.<em class="lm">java</em>)<br/>        .flatMap <strong class="lz hi">{ </strong>Flux.fromIterable(<strong class="lz hi">it</strong>.data) <strong class="lz hi">}</strong></span></pre><p id="e451" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">正如你所看到的，这段代码使用了Springs反应流，更好的说法是Flux。<em class="lm"> WebClient </em>类型是面向未来的(没有双关语的意思),所有的API都是被动的。这已被广泛预期，但尚未实现。具体来说,<em class="lm"> WebClient </em>假设服务器想要通过SSE、WebSockets或RSocket之类的协议以增量方式向我们发送项目。</p><p id="fe58" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">由于情况并非如此，我们需要:</p><ul class=""><li id="2a17" class="mj mk hh jt b ju kq jy kr kc ml kg mm kk mn ko mo mp mq mr bi translated">向服务器发送一个标准的GET请求</li><li id="f4c2" class="mj mk hh jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">将返回的数据整理成一个<em class="lm"> AllProfilesResponse </em></li><li id="1256" class="mj mk hh jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">将其中的配置文件列表转换成通量</li></ul><p id="b4ea" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">最后，我们需要像这样扩展我们的控制台方法:</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="08cd" class="md iu hh lz b fi me mf l mg mh">@Bean<br/>fun console(webClient: WebClient) = <em class="lm">CommandLineRunner </em><strong class="lz hi">{<br/><br/>    </strong>val header = Mono.just("Details of all the profiles:")<br/>    val profiles = <em class="lm">retrieveSpaceProfiles</em>(webClient).map <strong class="lz hi">{ </strong>"\t $<strong class="lz hi">it</strong>" <strong class="lz hi">}<br/>    </strong>val footer = Mono.just("All done - hit return to exit")<br/><br/>    val values = header<br/>            .concatWith(profiles)<br/>            .concatWith(footer)<br/><br/>    values.subscribe(::println)<br/><br/>    <em class="lm">//Because this is a console app we need to keep the<br/>    // main thread alive. Otherwise Spring would exit.<br/>    readLine</em>()<br/><strong class="lz hi">}</strong></span></pre><p id="8b8c" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">如您所见，bean provider方法现在将<em class="lm"> WebClient </em>作为参数。这将通过依赖注入来创建和传递。我们需要记住，<em class="lm"> WebClient </em>中的活动将与主线程异步发生。所以进入溪流的世界后，最好继续前进。</p><p id="9f8a" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">我们创建一个单一的项目流(又名。单声道)用于我们想要发送的第一条和最后一条消息，然后将这些消息与简档流连接起来。然后可以订阅合并的流。我们只需要为完整的值指定事件处理程序。在我们的简单演示中，那只是<em class="lm"> println </em>。</p><p id="007d" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">因为这是一个控制台应用程序，并且Spring<em class="lm">application context</em>是在主线程上管理的，所以我们需要保持该线程运行，直到所有结果都显示出来。显然，如果这段代码运行在Netty内执行的WebFlux控制器中，情况就不会这样了。</p><p id="d533" class="pw-post-body-paragraph jr js hh jt b ju kq jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk ku km kn ko ha bi translated">下面是针对一个示例Spring实例运行的完整代码:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/a4299aa538cbd167b21499da6854621e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER9K2iyVjupCir1vJ7me1A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Finished Application</figcaption></figure></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="fdb1" class="it iu hh bd iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ll jo jp jq bi translated">结论</h1><p id="dce3" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">希望本教程向您展示了登录和远程管理一个空间实例并不太复杂。当我们使用Kotlin删除不必要的样板文件并简化反应式管道时，尤其如此。在未来的教程中，我将展示我们如何使用Instil的API为课程、研讨会和黑客马拉松配置定制空间实例。</p></div></div>    
</body>
</html>