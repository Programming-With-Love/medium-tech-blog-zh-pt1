<html>
<head>
<title>Docker Compose For Containerizing A MEAN Stack Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于集装箱化平均堆栈应用Docker组合器</h1>
<blockquote>原文：<a href="https://medium.com/edureka/docker-compose-containerizing-mean-stack-application-e4516a3c8c89?source=collection_archive---------1-----------------------#2017-11-18">https://medium.com/edureka/docker-compose-containerizing-mean-stack-application-e4516a3c8c89?source=collection_archive---------1-----------------------#2017-11-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/62a2adfd5cf78e5b7895fe880213a930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*QGEln16m72wQZjCV2VqGnQ.png"/></div><figcaption class="il im et er es in io bd b be z dx">Docker Compose - Edureka</figcaption></figure><p id="1a7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在之前关于Docker的博客中，你可能已经了解了什么是Docker图像、Docker容器以及对它们的需求。如果你没有读过它们，那么我请求你在继续Docker Compose上的这篇博客之前，先读一读<em class="jn">什么是Docker </em>。</p><p id="a36c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在探索了Docker带来的可能性之后，了解更多当然是非常令人兴奋的。不是吗？好吧，至少我遇到挑战的时候是这样。</p><h1 id="cb90" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Docker撰写简介</h1><p id="f16f" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">对我来说，将单个服务应用程序容器化很容易。但是，当我必须将多种服务封装到不同的容器中时，我遇到了障碍。我的要求是容器化和托管一个普通的堆栈应用程序。</p><p id="8fe0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是的，你没看错。全栈应用。最初，我认为这是不可能的。但是在我听说Docker Compose之后，我知道我所有的问题都会得到解决。</p><p id="96da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker Compose可以用来为一个MEAN stack应用程序中的每个堆栈创建单独的容器(并托管它们)。MEAN是MongoDB Express Angular &amp; NodeJs的首字母缩写。我将在这个博客中展示的演示也是关于同一主题的。</p><p id="39b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用Docker Compose，我们可以在同一台主机上的不同容器中托管这些技术，并让它们相互通信。每个容器将暴露一个用于与其他容器通信的端口。</p><p id="a0ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些容器的通信和正常运行时间将由Docker Compose维护。</p><p id="5d38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以你可能会问，如何建立整个基础设施？那么，让我给你更详细的解释。</p><h1 id="51bb" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Dockerfile文件</h1><p id="81d2" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">类似于我们如何通过编写dockerfile来旋转任何单个应用程序容器，我们将不得不为构建每个单个容器应用程序编写单独的dockerfile。此外，我们还必须编写一个Docker Compose文件来完成实际工作。Docker合成文件将执行不同的docker文件来创建不同的容器，并让它们彼此交互。</p><p id="1e6f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的例子中，我们有一个完整的堆栈应用程序，由MongoDB、ExpressJS、Angular和NodeJS组成。MongoDB负责后端数据库，NodeJS和ExpressJS负责服务器端渲染，Angular负责前端。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kr"><img src="../Images/ea797d36d7b1a222a74234813cc4fbc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7fpMe7j02EG6OizUYrteBw.png"/></div></div></figure><p id="82a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于有三个组件，我们必须为每个组件旋转容器。我们必须按照以下方式旋转容器:</p><ol class=""><li id="1d87" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">容器1 —角形</li><li id="6632" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">容器2 — NodeJS和ExpressJS</li><li id="8412" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">容器3 — MongoDB</li></ol><h1 id="8cc9" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建Docker容器</h1><p id="ff93" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">作为对mean应用程序进行dockerize化的第一步，让我们从Angular的容器开始，为构建每个组件编写dockerfile。这个docker文件必须与“package.json”文件一起存在于项目目录中。“package.json”包含关于“NPM”需要使用哪个版本的依赖项来构建angular应用程序的详细信息。</p><h2 id="94a9" class="lo jp hh bd jq lp lq lr ju ls lt lu jy ja lv lw kc je lx ly kg ji lz ma kk mb bi translated">1.前端的docker文件</h2><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="6755" class="lo jp hh md b fi mh mi l mj mk">FROM node:6<br/>RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY package.json /usr/src/app<br/>RUN npm cache clean<br/>RUN npm install<br/>COPY . /usr/src/app<br/>EXPOSE 4200<br/>CMD ["npm","start"]</span></pre><p id="5c6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">和往常一样，<strong class="ir hi"> <em class="jn">我们的第一个命令是拉一个基础映像</em> </strong>，我们正在拉一个基础‘节点:6’映像。</p><p id="8dd1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">接下来的两个命令是关于在Docker容器内创建一个新的目录</em> </strong> '/usr/src/app '，用于存储角度代码，并使其成为容器内的工作目录。</p><p id="94d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们<strong class="ir hi"> <em class="jn">将‘package . JSON’文件</em> </strong>从我们的项目目录复制到容器内部。</p><p id="8d31" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们<strong class="ir hi"> <em class="jn">运行“npm缓存清理”命令</em> </strong>，清理npm缓存。</p><p id="5e11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后，我们<strong class="ir hi"> <em class="jn">运行“npm安装”命令</em> </strong>，开始下载托管Angular应用程序所需的样板文件。它开始根据“package.json”中指定的依赖项版本下载样板文件。</p><p id="f153" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来的'<strong class="ir hi"> <em class="jn"> RUN </em> </strong>'命令运行是将项目目录下的所有代码、文件夹复制到容器内。</p><p id="cc09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的<strong class="ir hi"> <em class="jn">命令要求容器暴露端口号4200 </em> </strong>用于与后端服务器通信，以发送用户通过Web UI访问前端客户端所发出的请求。</p><p id="3785" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，最后一个命令是，'<strong class="ir hi"> <em class="jn">运行</em> </strong>'命令启动'<strong class="ir hi"> <em class="jn"> npm </em> </strong>'。这将开始执行构建Angular应用程序的代码。</p><p id="bca9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular应用程序现在已经准备好了，但是由于它依赖于后端服务器和数据库，所以不能被正确托管。所以让我们更进一步，编写一个dockerfile来容器化后端服务器。</p><h2 id="f7ca" class="lo jp hh bd jq lp lq lr ju ls lt lu jy ja lv lw kc je lx ly kg ji lz ma kk mb bi translated">2.后端的docker文件</h2><p id="bc49" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">甚至这个dockerfile文件也会出现在项目目录中。该目录还将包含'<strong class="ir hi"> <em class="jn"> package.json </em> </strong>'文件，用于定义Express server的依赖关系和NodeJS的其他要求。但最重要的是，它包含了支持后端服务器的项目代码。</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="55d5" class="lo jp hh md b fi mh mi l mj mk">FROM node:6<br/>RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY package.json /usr/src/app<br/>RUN npm cache clean<br/>RUN npm install<br/>COPY . /usr/src/app<br/>EXPOSE 3000<br/>CMD ["npm","start"]</span></pre><p id="328e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，这两个docker文件有很多相似之处。我们使用相同的'<strong class="ir hi"> <em class="jn">节点:6 </em> </strong>'作为基础图像层，在容器内创建一个新目录，使其成为工作目录，并运行'<strong class="ir hi"> <em class="jn"> npm install </em> </strong>'等命令。但是唯一的区别是用于通信的端口号。在这种情况下，<strong class="ir hi"> <em class="jn">端口号3000 </em> </strong>被定义。这是服务器将被托管的地方，并且将寻找来自客户端的请求。</p><h2 id="1560" class="lo jp hh bd jq lp lq lr ju ls lt lu jy ja lv lw kc je lx ly kg ji lz ma kk mb bi translated">3.数据库ˌ资料库</h2><p id="fbf1" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">你可能想知道为什么我没有在标题中提到'<strong class="ir hi"> dockerfile </strong> For Database '。原因是，我们实际上不需要进行定制。我们可以直接提取一个“MongoDB”基础映像来存储我们的数据，只需公开可以访问它的端口号。</p><p id="7295" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在你脑海中的问题是，我在哪里做呢？好吧，我们可以在Docker撰写文件中这样做。</p><h1 id="1b1b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Docker合成文件</h1><p id="8480" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">Docker Compose文件是一个YAML文件，包含有关服务、网络和卷的详细信息，用于设置Docker应用程序。</p><p id="307a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行下面的命令来查找您的Docker引擎的版本。</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="d10a" class="lo jp hh md b fi mh mi l mj mk">docker -v</span></pre><p id="1885" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">执行该命令将返回在您的主机上运行的版本。根据您主机上的Docker引擎版本，下载适当版本的Docker Compose。你可以从<em class="jn"> Docker的官方文档</em>中寻找合适的版本下载。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ml"><img src="../Images/6c0f3adf4ee39df164c75c77e882355b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bx7UfCBrOPqlhp53Yxy-XQ.png"/></div></div></figure><p id="043e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于我运行的是Docker引擎版本17.05.0-ce，所以我使用了Docker Compose版本3。</p><h1 id="1a02" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">安装Docker撰写</h1><p id="3f7a" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">要下载Compose，请运行下面的命令集。</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="3983" class="lo jp hh md b fi mh mi l mj mk">sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br/>sudo chmod +x /usr/local/bin/docker-compose</span></pre><p id="4a58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，命令中的版本号将根据您运行的Docker引擎版本而变化。</p><p id="f616" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是我的Docker编写文件的一部分命令。</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="5088" class="lo jp hh md b fi mh mi l mj mk">version: '3.0' # specify docker-compose version<br/> <br/># Define the services/ containers to be run<br/>services:<br/> angular: # name of the first service<br/>  build: angular-app # specify the directory of the Dockerfile<br/>  ports:<br/>  - "4200:4200" # specify port mapping<br/> <br/> express: # name of the second service<br/>  build: express-server # specify the directory of the Dockerfile<br/>  ports:<br/>  - "3000:3000" #specify ports mapping<br/>  links:<br/>  - database # link this service to the database service<br/> <br/> database: # name of the third service<br/>  image: mongo # specify image to build container from<br/>  ports:<br/>  - "27017:27017" # specify port forwarding</span></pre><p id="8c0e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我很确定上面文件中的命令对你来说毫无意义。所以，让我们来解决这个问题。</p><p id="ac0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在第一行代码中，我已经定义了我正在使用的Docker Compose的版本。如果希望Compose正常工作而不抛出任何错误，这是非常重要的一步。确保根据您的Docker引擎版本下载Docker Compose版本。</p><p id="8a9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后，我使用关键字“服务”定义了三个容器。这些服务指的是我的堆栈的三个组件，前端、后端和数据库。因此，在这种情况下，我的容器的名称将是我的服务的名称，即' angular '，' express '和' database '。</p><p id="1cae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关键字“build”用于指示用于旋转该容器的docker文件存在于该目录中。等等，你怎么糊涂了？</p><p id="e479" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很简单。需要在'<strong class="ir hi"> <em class="jn">构建:</em> </strong>之后指定路径。在我们的例子中，'<strong class="ir hi"> <em class="jn"> angular-app </em> </strong>和'<strong class="ir hi"><em class="jn">express-server</em></strong>'是两个目录的路径，可以从Docker合成文件所在的目录访问这两个目录。对于我们的数据库容器，我只是说使用一个基本的'<strong class="ir hi"> <em class="jn"> image: mongo </em> </strong>'而不是dockerfile的路径。</p><p id="235b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这些服务中的每一个，我还指定了端口号，这些端口号可用于接收/发送来自其他容器(服务)的请求。angular的4200，express的3000，mongo的27017。</p><p id="69b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，express容器有一个到数据库容器的“link:”链接，表明服务器端接收到的任何数据都将被发送到数据库并存储在那里。</p><p id="1ee8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们终于完成了构建。要启动Docker Compose并使用三个服务旋转三个容器，我们只需从Docker Compose文件(YAML文件)所在的目录中执行以下两个命令:</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="3fd4" class="lo jp hh md b fi mh mi l mj mk">docker-compose build<br/>docker-compose up</span></pre><p id="ddcf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">'<strong class="ir hi"><em class="jn">docker-compose build</em></strong>'命令用于构建/重建服务，而'<strong class="ir hi"> <em class="jn"> docker-compose up </em> </strong>'命令用于创建/启动容器。去吧！你自己试试。</p><p id="d844" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是Docker映像被构建和执行的截图。您可以注意到，角度图像正在建立，然后用名称标记为“angular:latest”。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mm"><img src="../Images/d2168e5458836cae59f503a3cc429a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWcIXRqi3xQFBcbS5wYElA.png"/></div></div></figure><p id="0516" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，Express的图像是用名称和标签构建的，如'<strong class="ir hi"> <em class="jn"> express:latest </em> </strong>'。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mm"><img src="../Images/d8a85696ee27b07829f06e9b08c3919a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ev8hie_ls2tSlms4K-cDA.png"/></div></div></figure><p id="b299" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在映像已经构建好了，让我们试着运行它，从而在这个过程中旋转一个容器。下面是那个截图。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mn"><img src="../Images/f71f815d9a16b33cf3e88999c0693034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kauROauc4fKH3ptwGJrvKg.png"/></div></div></figure><p id="641c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是显示“webpack:编译成功”的截图，这意味着这三个服务被Docker成功地容器化了。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ml"><img src="../Images/5818973697ab51554b38a07b7d8e6387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OM88T2Koe70V60Zb-TvUxQ.png"/></div></div></figure><p id="49ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在容器已经托管，您可以看到服务在它们各自的端口上是活动的。在您的网络浏览器中键入以下端口号，与MEAN应用程序的GUI进行交互。</p><blockquote class="mo mp mq"><p id="0797" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">localhost:4200 — <em class="hh"> Angular App(前端)<br/></em>localhost:3000—<em class="hh">Express Server&amp;NodeJS(后端/服务器端)<br/></em>localhost:27017—MongoDB(数据库)</p></blockquote><p id="29c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">印象深刻吗？等等，因为Docker还没做好！我们可以使用“docker-compose scale='x '”命令来轻松地增加/减少部署的数量。换句话说，我们可以为一个服务创建那么多容器。以下是将特定服务扩展到“5”个容器的完整命令:</p><pre class="ks kt ku kv fd mc md me mf aw mg bi"><span id="8a80" class="lo jp hh md b fi mh mi l mj mk">docker-compose scale=5</span></pre><p id="8671" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如此轻松地扩展服务，以如此经济高效的方式包装和打包服务，使Docker成为最好的部署工具之一，也是我个人的最爱。</p><p id="338f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释DevOps的各个方面。</p><blockquote class="mo mp mq"><p id="12a1" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 1。</em> <a class="ae mu" rel="noopener" href="/edureka/devops-tutorial-89363dac9d3f"> <em class="hh"> DevOps教程</em> </a></p><p id="afba" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 2。</em> <a class="ae mu" rel="noopener" href="/edureka/git-tutorial-da652b566ece"> <em class="hh">饭桶教程</em> </a></p><p id="d36b" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 3。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-tutorial-68110a2b4bb3"> <em class="hh">詹金斯教程</em> </a></p><p id="e500" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 4。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-tutorial-9a6a6140d917"> <em class="hh">码头工人教程</em> </a></p><p id="bdbb" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 5。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-tutorial-9a6794a49b23"> <em class="hh"> Ansible教程</em> </a></p><p id="8d48" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 6。</em> <a class="ae mu" rel="noopener" href="/edureka/puppet-tutorial-848861e45cc2"> <em class="hh">木偶教程</em> </a></p><p id="b6bb" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 7。</em> <a class="ae mu" rel="noopener" href="/edureka/chef-tutorial-8205607f4564"> <em class="hh">厨师教程</em> </a></p><p id="fb1f" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">8。 <a class="ae mu" rel="noopener" href="/edureka/nagios-tutorial-e63e2a744cc8"> <em class="hh"> Nagios教程</em> </a></p><p id="60db" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 9。</em> <a class="ae mu" rel="noopener" href="/edureka/devops-tools-56e7d68994af"> <em class="hh">如何编排DevOps工具？</em> </a></p><p id="b6c6" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 10。</em> <a class="ae mu" rel="noopener" href="/edureka/continuous-delivery-5ca2358aedd8"> <em class="hh">连续交货</em> </a></p><p id="db01" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 11。</em> <a class="ae mu" rel="noopener" href="/edureka/continuous-integration-615325cfeeac"> <em class="hh">持续集成</em> </a></p><p id="8961" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 12。</em> <a class="ae mu" rel="noopener" href="/edureka/continuous-deployment-b03df3e3c44c"> <em class="hh">连续部署</em> </a></p><p id="5fd0" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 13。</em> <a class="ae mu" rel="noopener" href="/edureka/continuous-delivery-vs-continuous-deployment-5375642865a"> <em class="hh">持续交付vs持续部署</em> </a></p><p id="3bbf" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 14。</em> <a class="ae mu" rel="noopener" href="/edureka/ci-cd-pipeline-5508227b19ca"> <em class="hh"> CI CD管道</em> </a></p><p id="10aa" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 15。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-swarm-cluster-of-docker-engines-for-high-availability-40d9662a8df1"> <em class="hh">码头工人群</em> </a></p><p id="f059" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 16。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-networking-1a7d65e89013"> <em class="hh"> Docker联网</em> </a></p><p id="b147" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 17。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-roles-78d48578aca1"> <em class="hh">可担任的角色</em> </a></p><p id="cc40" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 18。</em><a class="ae mu" rel="noopener" href="/edureka/ansible-vault-secure-secrets-f5c322779c77"><em class="hh"/></a></p><p id="714e" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 19。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-for-aws-provision-ec2-instance-9308b49daed9"> <em class="hh">适用于AWS </em> </a></p><p id="3d63" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 20。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-pipeline-tutorial-continuous-delivery-75a86936bc92"> <em class="hh">詹金斯管道</em> </a></p><p id="79d0" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 21。</em> <a class="ae mu" rel="noopener" href="/edureka/git-commands-with-example-7c5a555d14c"> <em class="hh"> Top Git命令</em> </a></p><p id="3b83" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 22。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-commands-29f7551498a8"> <em class="hh">顶级Docker命令</em> </a></p><p id="49ea" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 23。</em> <a class="ae mu" rel="noopener" href="/edureka/git-vs-github-67c511d09d3e"> <em class="hh"> Git vs GitHub </em> </a></p><p id="acc8" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">24。 <a class="ae mu" rel="noopener" href="/edureka/devops-interview-questions-e91a4e6ecbf3"> <em class="hh"> DevOps面试问题</em> </a></p><p id="b947" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 25。</em> <a class="ae mu" rel="noopener" href="/edureka/devops-engineer-role-481567822e06"> <em class="hh">谁是DevOps工程师？</em> </a></p><p id="f809" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 26。</em> <a class="ae mu" rel="noopener" href="/edureka/devops-lifecycle-8412a213a654"> <em class="hh"> DevOps生命周期</em> </a></p><p id="46f4" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">27。<a class="ae mu" rel="noopener" href="/edureka/git-reflog-dc05158c1217"><em class="hh">Git Reflog</em></a></p><p id="8d7c" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh">二十八。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-provisioning-setting-up-lamp-stack-d8549b38dc59"> <em class="hh">不可预见的准备</em> </a></p><p id="b9b8" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 29。</em> <a class="ae mu" rel="noopener" href="/edureka/devops-skills-f6a7614ac1c7"> <em class="hh">组织正在寻找的顶尖DevOps技能</em> </a></p><p id="f43e" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 30。</em> <a class="ae mu" rel="noopener" href="/edureka/waterfall-vs-agile-991b14509fe8"> <em class="hh">瀑布vs敏捷</em> </a></p><p id="4908" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 31。</em> <a class="ae mu" rel="noopener" href="/edureka/maven-tutorial-2e87a4669faf"> <em class="hh"> Maven用于构建Java应用</em> </a></p><p id="7ba1" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 32。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-cheat-sheet-e0f7e25558a3"> <em class="hh">詹金斯小抄</em> </a></p><p id="d6af" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 33。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-cheat-sheet-guide-5fe615ad65c0"> <em class="hh"> Ansible备忘单</em> </a></p><p id="5cbd" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 34。</em> <a class="ae mu" rel="noopener" href="/edureka/ansible-interview-questions-adf8750be54"> <em class="hh"> Ansible面试问答</em> </a></p><p id="b0af" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 35。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-interview-questions-da0010bedb75"> <em class="hh"> 50码头工人面试问题</em> </a></p><p id="f8ce" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 36。</em> <a class="ae mu" rel="noopener" href="/edureka/what-is-agile-methodology-fe8ad9f0da2f"> <em class="hh">敏捷方法论</em> </a></p><p id="3dee" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 37。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-interview-questions-7bb54bc8c679"> <em class="hh">詹金斯面试问题</em> </a></p><p id="3f81" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 38。</em> <a class="ae mu" rel="noopener" href="/edureka/git-interview-questions-32fb0f618565"> <em class="hh"> Git面试问题</em> </a></p><p id="40b4" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 39。</em> <a class="ae mu" rel="noopener" href="/edureka/docker-architecture-be79628e076e"> <em class="hh"> Docker架构</em> </a></p><p id="6aac" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 40。</em><a class="ae mu" rel="noopener" href="/edureka/linux-commands-in-devops-73b5a2bcd007"><em class="hh">devo PS中使用的Linux命令</em> </a></p><p id="e6f0" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 41。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯vs竹子</em> </a></p><p id="83b0" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 42。</em> <a class="ae mu" rel="noopener" href="/edureka/nagios-interview-questions-f3719926cc67"> <em class="hh"> Nagios面试题</em> </a></p><p id="a00d" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">43。 <a class="ae mu" rel="noopener" href="/edureka/jenkins-x-d87c0271af57"> <em class="hh"> DevOps实时场景</em> </a></p><p id="b0cd" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 44。</em> <a class="ae mu" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯和詹金斯X的区别</em> </a></p><p id="59f6" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated"><em class="hh"> 45。</em><a class="ae mu" rel="noopener" href="/edureka/docker-for-windows-ed971362c1ec"><em class="hh">Windows Docker</em></a></p><p id="2b8b" class="ip iq jn ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">46。<a class="ae mu" href="http://git%20vs%20github/" rel="noopener ugc nofollow" target="_blank"><em class="hh">Git vs Github</em></a></p></blockquote></div><div class="ab cl mv mw go mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ha hb hc hd he"><p id="f9a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2017年11月18日</em><a class="ae mu" href="https://www.edureka.co/blog/docker-compose-containerizing-mean-stack-application/" rel="noopener ugc nofollow" target="_blank"><em class="jn">www.edureka.co</em></a><em class="jn">。</em></p></div></div>    
</body>
</html>