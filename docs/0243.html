<html>
<head>
<title>Making loading data lifecycle aware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让加载数据具有生命周期意识</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/making-loading-data-on-android-lifecycle-aware-897e12760832?source=collection_archive---------0-----------------------#2016-02-03">https://medium.com/androiddevelopers/making-loading-data-on-android-lifecycle-aware-897e12760832?source=collection_archive---------0-----------------------#2016-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="23ae" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">注意:如果你正在寻找一个不依赖于加载器的现代、灵活的解决方案(这里选择的解决方案)，看看<a class="ae jg" rel="noopener" href="/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4"> <strong class="ik hi">生命周期感知数据加载与架构组件</strong>博客文章</a>。</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/e3bc33b5e1c23ea7fef2bf2f598fbf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyIVgWfkM5og4wNzTXYQEQ.png"/></div></div></figure><p id="2ecc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">构建一个动态的Android应用程序需要动态数据。但是我希望我们都已经超越了在UI线程上加载数据(#perfmatters或类似的东西)。关于<a class="ae jg" href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">季和</a>季的讨论可以继续，但是让我们关注一种情况:用<a class="ae jg" href="http://developer.android.com/guide/components/loaders.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <strong class="ik hi">加载器</strong> </a>专门加载数据以显示在您的活动或片段中。</p><p id="8c6f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">关于加载器的很多讨论都是围绕着<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/CursorLoader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij">游标加载器</em> </a>展开的，但是加载器比仅仅使用游标要灵活得多。</p><p id="51a8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">虽然加载器作为API 11和更高版本框架的一部分存在，但它们也是<a class="ae jg" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#v4" rel="noopener ugc nofollow" target="_blank">支持v4库</a>的一部分，并带来了最新的特性(和错误修复！)到每个API 4和更高的设备。</p><h1 id="bc7e" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">装载机有什么特别之处？</h1><p id="e72a" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated">默认情况下，<a class="ae jg" href="http://developer.android.com/guide/topics/resources/runtime-changes.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">设备配置更改</a>如旋转屏幕涉及重新启动您的整个<em class="ij">活动</em>(这是不保留对您的活动或任何视图的引用如此重要的众多原因之一)。装载机最好的一点是<strong class="ik hi">装载机能经受住配置变化</strong>。你刚刚取回的昂贵数据？当活动恢复时，仍然可以立即检索。数据排队等待交付，因此您也不会在设备配置期间丢失数据。</p><p id="6813" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">但是更好的是:<strong class="ik hi">装载机不会永远留在附近</strong>。当请求的活动或片段被永久销毁时，它们将被自动清除。这意味着没有挥之不去的，不必要的负荷。</p><p id="984f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">这两个事实合在一起意味着它们完美地匹配了你真正关心的生命周期:<em class="ij">当你有数据要展示的时候。</em></p><h1 id="5aa5" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我不相信你</h1><p id="c931" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated">或许举个例子会有启发。假设您正在将一个常规的<a class="ae jg" href="http://developer.android.com/reference/android/os/AsyncTask.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij"> AsyncTask </em> </a>转换为加载器等价物，恰当地命名为<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/AsyncTaskLoader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="ij">async task loader</em></a>:</p><pre class="ji jj jk jl fd kz la lb lc aw ld bi"><span id="9b32" class="le jx hh la b fi lf lg l lh li">public static class JsonAsyncTaskLoader extends<br/>    AsyncTaskLoader&lt;List&lt;String&gt;&gt; {</span><span id="65f1" class="le jx hh la b fi lj lg l lh li">  // You probably have something more complicated<br/>  // than just a String. Roll with me<br/>  private List&lt;String&gt; mData;</span><span id="caf2" class="le jx hh la b fi lj lg l lh li">  public JsonAsyncTaskLoader(Context context) {<br/>    super(context);<br/>  }</span><span id="36d0" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  protected void onStartLoading() {<br/>    <strong class="la hi">if (mData != null) {<br/>      // Use cached data<br/>      deliverResult(mData);<br/>    } else {<br/>      // We have no data, so kick off loading it<br/>      forceLoad();<br/>    }</strong><br/>  }</span><span id="310e" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public List&lt;String&gt; loadInBackground() {<br/>    // This is on a background thread</span><span id="df97" class="le jx hh la b fi lj lg l lh li">    <strong class="la hi">// Good to know: the Context returned by getContext()<br/>    // is the application context</strong><br/>    File jsonFile = new File(<br/>      getContext().getFilesDir(), "downloaded.json");<br/>    List&lt;String&gt; data = new ArrayList&lt;&gt;();<br/>    // Parse the JSON using the library of your choice<br/>    // Check <strong class="la hi">isLoadInBackgroundCanceled()</strong> to cancel out early<br/>  return data;<br/>}</span><span id="a0f5" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public void deliverResult(List&lt;String&gt; data) {<br/>    // We’ll save the data for later retrieval<br/>    mData = data;<br/>    // We can do any pre-processing we want here<br/>    // Just remember this is on the UI thread so nothing lengthy!<br/>    super.deliverResult(data);<br/>  }<br/>}</span></pre><p id="b429" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">看起来非常类似于一个<em class="ij"> AsyncTask </em>，但是我们现在可以将结果保存在一个成员变量中，并在配置更改后通过立即调用我们的<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onStartLoading%28%29" rel="noopener ugc nofollow" target="_blank"><em class="ij">【onstart loading()</em></a>方法中的<em class="ij">【deliver result()</em>立即将它们返回。请注意，如果我们已经缓存了数据，我们<strong class="ik hi">不会</strong> <em class="ij"> </em>调用<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#forceLoad()" rel="noopener ugc nofollow" target="_blank"><em class="ij">forceLoad()</em></a>——这就是我们避免不断重新加载数据的方法！</p><blockquote class="ie if ig"><p id="d533" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">在声明<em class="hh"> JsonAsyncTaskLoader </em>时，您可能已经注意到了<strong class="ik hi"> <em class="hh">静态</em> </strong>关键字。<strong class="ik hi">非常重要的一点是，你的<em class="hh">加载器</em>不包含对任何包含<em class="hh">活动</em>或<em class="hh">片段</em> </strong>的任何引用，这包括由非静态内部类创建的隐式引用。显然，如果你没有将你的<em class="hh">加载器</em>声明为内部类，你就不需要static关键字。</p></blockquote><h1 id="1e8c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">不够好—如果我的数据发生变化怎么办？</h1><p id="7c18" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated">这个简单的例子没有注意到的是，您并不局限于只加载一次——您的<em class="ij">加载器</em>也是放置广播接收器的最佳位置，一个<a class="ae jg" href="http://developer.android.com/reference/android/database/ContentObserver.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij">内容观察者</em> </a>(一个<em class="ij">光标加载器</em>为您做的事情)，一个<a class="ae jg" href="http://developer.android.com/reference/android/os/FileObserver.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij">文件观察者</em> </a>，或者一个<a class="ae jg" href="http://developer.android.com/reference/android/content/SharedPreferences.OnSharedPreferenceChangeListener.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="ij">onsharepreferencechangelistener</em></a>。突然之间<strong class="ik hi">你的<em class="ij">加载器</em>可以对其他地方的变化做出反应并重新加载它的数据</strong>。让我们用一个<em class="ij">文件观察者</em>来扩充我们之前的<em class="ij">加载器</em>:</p><pre class="ji jj jk jl fd kz la lb lc aw ld bi"><span id="1eb2" class="le jx hh la b fi lf lg l lh li">public static class JsonAsyncTaskLoader extends<br/>    AsyncTaskLoader&lt;List&lt;String&gt;&gt; {</span><span id="d365" class="le jx hh la b fi lj lg l lh li">  // You probably have something more complicated<br/>  // than just a String. Roll with me<br/>  private List&lt;String&gt; mData;</span><span id="01cc" class="le jx hh la b fi lj lg l lh li">  <strong class="la hi">private FileObserver mFileObserver;</strong></span><span id="bb58" class="le jx hh la b fi lj lg l lh li">  public JsonAsyncTaskLoader(Context context) {<br/>    super(context);<br/>  }</span><span id="1ed3" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  protected void onStartLoading() {<br/>    if (mData != null) {<br/>      // Use cached data<br/>      deliverResult(mData);<br/>    }</span><span id="883b" class="le jx hh la b fi lj lg l lh li">    <strong class="la hi">if (mFileObserver == null) {<br/>      String path = new File(<br/>          getContext().getFilesDir(), "downloaded.json").getPath();<br/>      mFileObserver = new FileObserver(path) {<br/>          @Override<br/>          public void onEvent(int event, String path) {<br/>            // Notify the loader to reload the data<br/>            onContentChanged();<br/>            // If the loader is started, this will kick off<br/>            // loadInBackground() immediately. Otherwise,<br/>            // the fact that something changed will be cached<br/>            // and can be later retrieved via takeContentChanged()<br/>          }<br/>      };<br/>      mFileObserver.startWatching();<br/>    }</strong></span><span id="d8ed" class="le jx hh la b fi lj lg l lh li"><strong class="la hi">    if (takeContentChanged() || mData == null) {</strong><br/>      // Something has changed or we have no data,<br/>      // so kick off loading it<br/>      forceLoad();<br/>    }<br/>  }</span><span id="fe22" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public List&lt;String&gt; loadInBackground() {<br/>    // This is on a background thread<br/>    File jsonFile = new File(<br/>        getContext().getFilesDir(), "downloaded.json");<br/>    List&lt;String&gt; data = new ArrayList&lt;&gt;();<br/>    // Parse the JSON using the library of your choice<br/>    return data;<br/>  }</span><span id="bd81" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public void deliverResult(List&lt;String&gt; data) {<br/>    // We’ll save the data for later retrieval<br/>    mData = data;<br/>    // We can do any pre-processing we want here<br/>    // Just remember this is on the UI thread so nothing lengthy!<br/>    super.deliverResult(data);<br/>  }</span><span id="9077" class="le jx hh la b fi lj lg l lh li">  <strong class="la hi">protected void onReset() {<br/>    // Stop watching for file changes<br/>    if (mFileObserver != null) {<br/>      mFileObserver.stopWatching();<br/>      mFileObserver = null;<br/>    }<br/>  }</strong><br/>}</span></pre><p id="2d3a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">所以通过挂钩到<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onStartLoading()" rel="noopener ugc nofollow" target="_blank"><em class="ij">【onstart loading()</em></a>回调来启动我们的处理和最终的<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onReset()" rel="noopener ugc nofollow" target="_blank"><em class="ij">【on reset()</em></a>，我们可以与底层数据保持完美的同步。我们本来可以使用<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onStopLoading()" rel="noopener ugc nofollow" target="_blank"><em class="ij">onStopLoading()</em></a>作为结束回调，但是<em class="ij"> onReset() </em>确保了我们有连续的覆盖(甚至是中间的配置更改)。</p><p id="e31e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">您会注意到在<em class="ij"> onStartLoading() </em>中<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#takeContentChanged()" rel="noopener ugc nofollow" target="_blank"><em class="ij">takeContentChanged()</em></a>的用法——这是您的<em class="ij">加载器</em>知道某些事情已经改变(即，有人调用了<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/content/Loader.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onContentChanged()" rel="noopener ugc nofollow" target="_blank"><em class="ij">onContentChanged()</em></a>)而<em class="ij">加载器</em>已经停止，因此即使有缓存的结果，仍然需要进行数据加载。</p><blockquote class="ie if ig"><p id="a207" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi">注意</strong>:在加载新数据之前，我们仍然会提供旧的缓存数据——确保这是你的应用程序的正确行为，并根据需要更改<em class="hh"> onStartLoading() </em>。例如，您可能会检查<em class="hh"> takeContentChanged() </em>并立即丢弃缓存的结果，而不是重新交付它们。</p></blockquote><h1 id="ef30" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用应用程序的其余部分:LoaderManager</h1><p id="d333" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated">当然，如果不连接到某个东西，即使是最好的加载程序也将一无是处。活动和片段的连接点以<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="ij">loader manager</em></strong></a>的形式出现。您将调用<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/FragmentActivity.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="ij">fragmentation activity</em></a>的<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/FragmentActivity.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#getSupportLoaderManager()" rel="noopener ugc nofollow" target="_blank"><em class="ij">getSupportLoaderManager()</em></a>或<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/Fragment.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="ij">Fragment</em></a><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/Fragment.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#getLoaderManager()" rel="noopener ugc nofollow" target="_blank"><em class="ij">getLoaderManager()</em></a>来获取您的实例。</p><p id="b887" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">几乎在所有情况下，你只需要调用一个方法:<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#initLoader(int, android.os.Bundle, android.support.v4.app.LoaderManager.LoaderCallbacks&lt;D&gt;)" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="ij">【init loader()</em></strong></a><strong class="ik hi">。这通常在</strong><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/FragmentActivity.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onCreate(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="ij">onCreate()</em></strong></a><strong class="ik hi">或</strong><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/Fragment.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onActivityCreated(android.os.Bundle)" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="ij">on activity created()</em></strong></a>中调用——基本上只要你知道你需要加载一些数据。您将传入一个惟一的id(尽管只在那个<em class="ij">活动</em> / <em class="ij">片段</em>中——不是全局惟一的),传入一个可选的Bundle，以及一个<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="ij">loader callbacks</em></a>的实例。</p><blockquote class="ie if ig"><p id="6ff1" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">注意:如果您想要在片段的<em class="hh"> onCreate() </em>中调用<em class="hh"> initLoader() </em>，请确保升级到Android支持库的版本24.0.0或更高版本——以前版本的支持库(以及所有框架片段&lt; API 24)中存在问题，加载程序将在片段间共享，如<a class="ae jg" href="https://code.google.com/p/android/issues/detail?id=94081&amp;utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> this Lint request </a>和<a class="ae jg" href="https://plus.google.com/+JonFHancock/posts/bgXh4XEAeui?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> this related Google+ post </a>中所述。</p></blockquote><p id="e902" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">您可能会注意到在<em class="ij"> LoaderManager </em>中有一个<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#restartLoader(int, android.os.Bundle, android.support.v4.app.LoaderManager.LoaderCallbacks&lt;D&gt;)" rel="noopener ugc nofollow" target="_blank"> <em class="ij"> restartLoader() </em> </a>方法，它让您能够强制重新加载。在大多数情况下，如果加载程序正在管理自己的侦听器，这应该是不必要的，但是在您想要传入不同的<em class="ij">包</em>的情况下，这是有用的——您会发现您现有的<em class="ij">加载程序</em>被销毁，并且对<em class="ij"> onCreateLoader() </em>的新调用已经完成。</p><p id="bf37" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">在上面的<em class="ij"> FileObserver </em>示例中，我们提到使用<em class="ij"> onReset() </em>而不是<em class="ij">on stoploading()</em>——在这里我们可以看到这与正常生命周期的交互。仅仅通过调用<em class="ij"> initLoader() </em>，我们就挂接了<em class="ij">活动</em> / <em class="ij">片段</em>生命周期，当相应的<em class="ij"> onStop() </em>被调用时<em class="ij"> onStopLoading() </em>也会被调用。但是，<em class="ij"> onReset() </em>只有在您专门调用<a class="ae jg" href="http://developer.android.com/reference/android/app/LoaderManager.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#destroyLoader(int)" rel="noopener ugc nofollow" target="_blank"><em class="ij">destroy loader()</em></a>或者在<em class="ij">Activity</em>/<em class="ij">Fragment</em>被完全销毁时才会被调用。</p><h2 id="c8ae" class="le jx hh bd jy lk ll lm kc ln lo lp kg jt lq lr kk ju ls lt ko jv lu lv ks lw bi translated">loader回调</h2><p id="a696" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated"><em class="ij"> LoaderCallbacks </em>是一切<em class="ij">实际上</em>发生的地方。我们所说的“一切”是指三次回访:</p><ul class=""><li id="f540" class="lx ly hh ik b il im ip iq jt lz ju ma jv mb jf mc md me mf bi translated"><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onCreateLoader(int,%20android.os.Bundle)" rel="noopener ugc nofollow" target="_blank"><em class="ij">oncreate Loader()</em></a>—在这里您可以构造实际的加载器实例</li><li id="cb5a" class="lx ly hh ik b il mg ip mh jt mi ju mj jv mk jf mc md me mf bi translated"><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onLoadFinished(android.support.v4.content.Loader&lt;D&gt;, D)" rel="noopener ugc nofollow" target="_blank"><strong class="ik hi"><em class="ij">【onload finished()</em></strong></a><strong class="ik hi">—这是您交付的结果出现的地方</strong></li><li id="6fa5" class="lx ly hh ik b il mg ip mh jt mi ju mj jv mk jf mc md me mf bi translated"><a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#onLoaderReset(android.support.v4.content.Loader&lt;D&gt;)" rel="noopener ugc nofollow" target="_blank"><em class="ij">【onLoaderReset()</em></a>—您有机会清除对现在已重置的加载程序数据的任何引用</li></ul><p id="0347" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">所以我们之前的例子可能看起来像:</p><pre class="ji jj jk jl fd kz la lb lc aw ld bi"><span id="585a" class="le jx hh la b fi lf lg l lh li">// A RecyclerView.Adapter which will display the data<br/>private MyAdapter mAdapter;</span><span id="5309" class="le jx hh la b fi lj lg l lh li">// Our Callbacks. Could also have the Activity/Fragment implement<br/>// LoaderManager.LoaderCallbacks&lt;List&lt;String&gt;&gt;<br/>private LoaderManager.LoaderCallbacks&lt;List&lt;String&gt;&gt;<br/>    mLoaderCallbacks =<br/>    new LoaderManager.LoaderCallbacks&lt;List&lt;String&gt;&gt;() {<br/>      @Override<br/>      public Loader&lt;List&lt;String&gt;&gt; onCreateLoader(<br/>          int id, Bundle args) {<br/>        return new JsonAsyncTaskLoader(MainActivity.this);<br/>      }</span><span id="a509" class="le jx hh la b fi lj lg l lh li">      <strong class="la hi">@Override<br/>      public void onLoadFinished(<br/>          Loader&lt;List&lt;String&gt;&gt; loader, List&lt;String&gt; data) {<br/>        // Display our data, for instance updating our adapter<br/>        mAdapter.setData(data);<br/>      }</strong></span><span id="7f0a" class="le jx hh la b fi lj lg l lh li">      @Override<br/>      public void onLoaderReset(Loader&lt;List&lt;String&gt;&gt; loader) {<br/>        // Loader reset, throw away our data,<br/>        // unregister any listeners, etc.<br/>        mAdapter.setData(null);<br/>        // Of course, unless you use destroyLoader(),<br/>        // this is called when everything is already dying<br/>        // so a completely empty onLoaderReset() is<br/>        // totally acceptable<br/>      }<br/>    };</span><span id="3074" class="le jx hh la b fi lj lg l lh li">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>  super.onCreate(savedInstanceState);<br/>  // The usual onCreate() — setContentView(), etc.</span><span id="f605" class="le jx hh la b fi lj lg l lh li">  <strong class="la hi">getSupportLoaderManager().initLoader(0, null, mLoaderCallbacks);</strong><br/>}</span></pre><p id="73d0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">当然，使用<em class="ij"> LoaderManager </em>并没有硬性要求，尽管如果你这么做了，你会发现生活变得容易多了。请随意查看<a class="ae jg" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/master/v4/java/android/support/v4/app/FragmentActivity.java?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij">碎片活动</em>源</a>和<a class="ae jg" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/master/v4/java/android/support/v4/app/LoaderManager.java?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="ij">加载器管理器</em>源</a>以详细了解它给你的一切。</p><h1 id="85b1" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">酷，但我不需要一个背景线程</h1><p id="f7ea" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated"><em class="ij"> AsyncTaskLoader </em>试图让脱离后台线程变得容易，但是如果你已经完成了自己的后台线程或者依赖于事件总线/订阅模型的话，<em class="ij"> AsyncTaskLoader </em>就有些矫枉过正了。让我们举一个例子，在不把所有代码扔进你的<em class="ij">活动</em> / <em class="ij">片段</em>的情况下，载入位置变化:</p><pre class="ji jj jk jl fd kz la lb lc aw ld bi"><span id="46c7" class="le jx hh la b fi lf lg l lh li">public static class LocationLoader extends Loader&lt;Location&gt;<br/>    implements GoogleApiClient.ConnectionCallbacks,<br/>    GoogleApiClient.OnConnectionFailedListener,<br/>    LocationListener {</span><span id="2289" class="le jx hh la b fi lj lg l lh li">  private GoogleApiClient mGoogleApiClient;<br/>  private Location mLastLocation;<br/>  private ConnectionResult mConnectionResult;</span><span id="70d2" class="le jx hh la b fi lj lg l lh li">  public LocationLoader(Context context) {<br/>    super(context);<br/>  }</span><span id="ca2f" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  protected void onStartLoading() {<br/>    if (mLastLocation != null) {<br/>      deliverResult(mLastLocation);<br/>    }</span><span id="d5a3" class="le jx hh la b fi lj lg l lh li"><strong class="la hi">    if (mGoogleApiClient == null) {<br/>      mGoogleApiClient = <br/>            new GoogleApiClient.Builder(getContext(), this, this)<br/>            .addApi(LocationServices.API)<br/>            .build();<br/>      mGoogleApiClient.connect();<br/>    }</strong> else if (mGoogleApiClient.isConnected()) {<br/>      // Request updates<br/>      LocationServices.FusedLocationApi.requestLocationUpdates(<br/>          mGoogleApiClient, new LocationRequest(), this);<br/>    }<br/>  }</span><span id="5658" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  protected void onStopLoading() {<br/>    // Reduce battery usage when the activity is stopped<br/>    // This helps us handle if the home button is pressed<br/>    // And the loader is stopped but not yet destroyed <br/>    if (mGoogleApiClient.isConnected()) {<br/>      LocationServices.FusedLocationApi.requestLocationUpdates(<br/>        mGoogleApiClient,<br/>        new LocationRequest()<br/>            .setPriority(LocationRequest.PRIORITY_NO_POWER),<br/>        this);<br/>    }<strong class="la hi"><br/>  </strong>}</span><span id="c58a" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  protected void onForceLoad() {<br/>    // Resend the last known location if we have one<br/>    if (mLastLocation != null) {<br/>      deliverResult(mLastLocation);<br/>    }<br/>    // Try to reconnect if we aren’t connected<br/>    if (!mGoogleApiClient.isConnected()) {<br/>      mGoogleApiClient.connect();<br/>    }<br/>  }</span><span id="d316" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public void onConnected(Bundle connectionHint) {<br/>    mConnectionResult = null;<br/>    // Try to immediately return a result<br/>    mLastLocation = LocationServices.FusedLocationApi<br/>        .getLastLocation(mGoogleApiClient);<br/>    if (mLastLocation != null) {<br/>      deliverResult(mLastLocation);<br/>    }<br/>    // Request updates<br/>    LocationServices.FusedLocationApi.requestLocationUpdates(<br/>        mGoogleApiClient, new LocationRequest(), this);<br/>  <strong class="la hi">}</strong></span><span id="90db" class="le jx hh la b fi lj lg l lh li"><strong class="la hi">  @Override<br/>  public void onLocationChanged(Location location) {<br/>    mLastLocation = location;<br/>    // Deliver the location changes<br/>    deliverResult(location);<br/>  }</strong></span><span id="050a" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public void onConnectionSuspended(int cause) {<br/>    // Cry softly, hope it comes back on its own<br/>  }</span><span id="4c23" class="le jx hh la b fi lj lg l lh li">  @Override<br/>  public void onConnectionFailed(<br/>      @NonNull ConnectionResult connectionResult) {<br/>    mConnectionResult = connectionResult;<br/>    // Signal that something has gone wrong.<br/>    deliverResult(null);<br/>  }</span><span id="cc68" class="le jx hh la b fi lj lg l lh li">  /**<br/>   * Retrieve the ConnectionResult associated with a null <br/>   * Location to aid in recovering from connection failures.<br/>   * Call startResolutionForResult() and then restart the<br/>   * loader when the result is returned.<br/>   * @return The last ConnectionResult<br/>   */<br/>  public ConnectionResult getConnectionResult() {<br/>    return mConnectionResult;<br/>  }</span><span id="8569" class="le jx hh la b fi lj lg l lh li"><strong class="la hi">  @Override<br/>  protected void onReset() {<br/>    LocationServices.FusedLocationApi<br/>        .removeLocationUpdates(mGoogleApiClient, this);<br/>    mGoogleApiClient.disconnect();<br/>  }<br/></strong>}</span></pre><p id="f676" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">这里我们可以看到三个主要组件:</p><ul class=""><li id="40ea" class="lx ly hh ik b il im ip iq jt lz ju ma jv mb jf mc md me mf bi translated"><em class="ij"> onStartLoading() </em>启动订阅过程(在本例中，通过连接到Google Play服务)</li><li id="a745" class="lx ly hh ik b il mg ip mh jt mi ju mj jv mk jf mc md me mf bi translated"><em class="ij"> onStopLoading() </em>是指当我们进入后台时(或者是暂时旋转，或者是按下Home键，加载程序进入后台)，这样我们可以减少电池/处理器的使用</li><li id="520c" class="lx ly hh ik b il mg ip mh jt mi ju mj jv mk jf mc md me mf bi translated">当我们得到结果时，我们调用<em class="ij"> deliverResult() </em></li><li id="18df" class="lx ly hh ik b il mg ip mh jt mi ju mj jv mk jf mc md me mf bi translated">最后，我们在<em class="ij"> onReset() </em>中断开并清理</li></ul><p id="4831" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">在这里，加载器框架对Google Play服务一无所知，但是<strong class="ik hi">我们仍然可以将该逻辑封装在一个地方，并依靠一个带有更新位置的单个<em class="ij"> onLoadFinished() </em> </strong>。这种类型的封装还有助于切换出位置提供者——代码的其余部分不关心位置对象是如何或从哪里来的。</p><blockquote class="ie if ig"><p id="fd6e" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi">注意</strong>:在这种情况下，通过发送一个空的<em class="hh">位置</em>来报告故障。这向侦听<em class="hh">活动</em> / <em class="hh">片段</em>发送信号，以调用<em class="hh"> getConnectionResult() </em>并处理失败。请记住，<em class="hh"> onLoadFinished() </em>包含了对<em class="hh">加载器</em>的引用，因此您拥有的任何状态都可以在该点被检索到。</p></blockquote><h1 id="2f5c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">加载器:仅用于数据</h1><p id="ecd7" class="pw-post-body-paragraph ih ii hh ik b il ku in io ip kv ir is jt kw iv iw ju kx iz ja jv ky jd je jf ha bi translated">所以一个加载器有一个人生目标:给你最新的信息。它通过保存设备配置更改并包含自己的数据观察器来实现这一点。这意味着你的<em class="ij">活动</em> / <em class="ij">片段</em>的其余部分不需要知道那些细节。(你的<em class="ij">加载器</em>也不应该知道数据是如何被使用的！)</p><p id="9906" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">如果您一直使用保留片段(那些调用<a class="ae jg" href="http://developer.android.com/reference/android/support/v4/app/Fragment.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog#setRetainInstance(boolean)" rel="noopener ugc nofollow" target="_blank"><em class="ij"/></a>setRetainInstance(true)】)的片段)来存储跨配置更改的数据，<strong class="ik hi">强烈考虑从保留片段切换到加载器</strong>。保留的片段，虽然知道整个活动生命周期，但应该被视为完全独立的实体，而加载器直接绑定到活动或片段生命周期(甚至子片段！)并因此更适合于准确检索显示所需的数据。以动态添加或删除片段为例——加载器允许您将加载过程与生命周期联系起来，同时避免配置更改破坏加载的数据。</p><p id="59e1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">这种单一焦点也意味着你可以独立于用户界面测试加载。这里的例子只是在上下文中传递的，但是你当然可以传递任何必需的类(或者模拟类！)来简化测试。由于完全是事件驱动的，还可以随时准确地确定加载程序处于什么状态，以及只为测试而显示其他状态。</p><blockquote class="ie if ig"><p id="052e" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated"><strong class="ik hi">注意</strong>:虽然有一个为框架类设计的<a class="ae jg" href="http://developer.android.com/reference/android/test/LoaderTestCase.html?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> LoaderTestCase </a>，但是如果你想用支持v4加载器做类似的事情(有些事情<a class="ml mm ge" href="https://medium.com/u/295ee3666612?source=post_page-----897e12760832--------------------------------" rel="noopener" target="_blank"> Nicholas Pike </a> <a class="ae jg" href="http://www.npike.net/2016/unit-testing-loaders?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">已经做了</a>)，你需要从<a class="ae jg" href="https://android.googlesource.com/platform/frameworks/base/+/master/test-runner/src/android/test/LoaderTestCase.java?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> LoaderTestCase源代码</a>中创建一个支持库等价物！).这也给了你一个在没有<em class="hh"> LoaderManager </em>的情况下如何与<em class="hh"> Loader </em>交互的好主意。</p></blockquote><p id="e342" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">现在，重要的是要提到<strong class="ik hi">加载器是被动的，是数据的接收者。</strong>他们不负责改变底层数据。但就它们的作用而言，它们确实填补了生命周期感知组件的空白，这些组件能够在配置更改后存活下来，并将您的数据传送到您的UI。</p><p id="6d53" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated"># BuildBetterApps</p><p id="105f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jt iu iv iw ju iy iz ja jv jc jd je jf ha bi translated">加入关于<a class="ae jg" href="https://plus.google.com/u/0/+AndroidDevelopers/posts/96FWwtN2Vhr" rel="noopener ugc nofollow" target="_blank"> Google+帖子</a>的讨论，关注<a class="ae jg" href="https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_loaders_020216&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集合</a>了解更多！</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mn"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>