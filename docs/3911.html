<html>
<head>
<title>Headless AEM Approaches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无头AEM接近</h1>
<blockquote>原文：<a href="https://medium.com/globant/headless-aem-approaches-3ef1252c445d?source=collection_archive---------0-----------------------#2022-07-06">https://medium.com/globant/headless-aem-approaches-3ef1252c445d?source=collection_archive---------0-----------------------#2022-07-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b913" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当它们开始出现时，内容管理系统遵循一个单一的架构，负责内容管理、交付、页面呈现和缓存，这意味着开发人员通常需要了解每个特定CMS的工作方式，以便能够根据项目的需要对其进行定制。</p><p id="828c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">许多现代CMS仍然提供这种headful或传统的方法，但大多数也开始支持headless交付，包括Adobe Experience Manager (AEM)。在本文中，我们将快速浏览一下AEM可以实现的五种不同的无头交付方法。</p><h2 id="bea6" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">什么是无头交付，我为什么需要它？</h2><p id="a34f" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">简而言之，无头交付从CMS那里拿走了页面渲染的责任。CMS将数据作为API公开，其他应用程序可以使用它来处理和呈现数据。这对于全渠道交付、解耦架构、可伸缩性、面向未来等非常有用。</p><p id="46a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并不是所有的项目都需要它，需要根据具体情况进行分析，但是如果以上任何一个都是一个问题，那么考虑去headless是一个好主意。</p><h2 id="ab4e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">JSON方法</h2><p id="4bdd" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">AEM添加对无头交付的支持已经有一段时间了，从简单地交换<em class="kc">开始。html </em>的扩展名为。<em class="kc"> infinity.json </em>到一个已发布的资源。这是AEM的Sling模型实现的一部分。</p><p id="9c1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样做将检索存储在特定资源中的原始JCR (Java Content Repository)属性，并将其显示为JSON树。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/cfb88733c07e81928aeec953cd3fcbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpAaNHDG4BXLpOGATiOMvA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">JSON Approach (about-us.infinity.json)</figcaption></figure><p id="71cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kc"> Infinity </em>在这种情况下意味着API将显示的子节点的数量，这可以更改为0以仅显示顶级属性，1以显示顶级加1，等等。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/1806f6aeba0df517c95eda1c582d678c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0NahoXEFsGMox0Pl6zdag.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">JSON Approach (about-us.0.json)</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/9c24697e24f6ddb3a2bddc5f38b7fc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyU9TJkJrmZKWIC05hVbSw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">JSON Approach (about-us.1.json)</figcaption></figure><p id="7ba9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法在大多数情况下都能创造奇迹，尽管它也有一些缺点:</p><ul class=""><li id="be35" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">它仍然依赖AEM的dispatcher和publisher实例来访问，这意味着尽管渲染不再是CMS的责任，但它仍然需要缓存数据并将其直接交付给第三方应用程序，这可能会带来可扩展性问题。</li><li id="ad43" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">它是不可变的，因为它只是AEM中存储数据的可视化表示，所以它包含了许多不必要的信息，很难解析。</li></ul><h2 id="79e8" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">内容片段</h2><p id="fa35" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">内容片段是没有任何表示层的模型的实例，它们本质上是遵循定义的模式的数据块。片段可以以多种方式使用，包括将它们链接到一个组件以检索存储在其中的信息，或者只是作为数据优先资源。</p><p id="ac9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些实体作为资产存储在AEM中，还附带了一个OOTB JSON API，可以用来直接检索数据。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/41845bb203d77213998b30826610cf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pY7szDCylpt0tLGRncK-7A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">JSON Representation of a Content Fragment</figcaption></figure><p id="4579" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于第三方应用程序来说，这与前面的方法有相同的缺点，即调度程序仍然需要处理这些请求和不变性，尽管数据存储在<code class="du lh li lj lk b">jcr:content/data</code>下，所以开箱即用会更整洁一些。</p><h2 id="eadd" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">吊索模型出口商</h2><p id="9218" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">虽然上述方法可行，但是通过使用Sling模型导出器可以实现更健壮的东西。这些基本上允许公开一个Sling模型的属性，但是可以修改以适应特定的命名约定，可以插入代码来转换现有的属性或者注入额外的属性。因为它是一个完全成熟的类，它允许任何可能需要的操作(例如，基于模型的属性查询节点，进行计算，等等。)然后将该数据显示为有效载荷的一部分。它提供了很大的灵活性，可以通过像<code class="du lh li lj lk b">JsonIgnore</code>这样的注释显示或隐藏特定的属性。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es ll"><img src="../Images/cc43c764e82cb5dfffd7b5653573c701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*A6n7Yz25n1nzv4_XVdQN8w.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">An example of a Sling Model Exporter payload (resource.model.json)</figcaption></figure><p id="25f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个例子可以使用如下的类来实现。这个类让AEM知道，对于资源类型<code class="du lh li lj lk b">test/sampleModel</code>，它将通过访问资源地址并添加<code class="du lh li lj lk b">model.json</code>来使用这个模型导出器，就像我们使用<code class="du lh li lj lk b">infinity</code>修饰符一样。</p><p id="beca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用<code class="du lh li lj lk b">@JsonProperty</code>注释并赋予它一个值来注入属性，并且我们可以在属性的<code class="du lh li lj lk b">get</code>方法中执行操作。使用<code class="du lh li lj lk b">PostConstruct</code>注释，我们可以访问其他JCR资源并执行更昂贵的计算，查看参考资料以获得关于如何使用它们的更详细的描述。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Sample Sling Model Exporter</figcaption></figure><h2 id="04ba" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">GraphQL API</h2><p id="4196" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">还有AEM 6.5附带的GraphQL API，专门用于处理内容片段。利用内容片段的数据优先方法，AEM合并了一个GraphQL实例(graph QL)。</p><p id="2724" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，GraphQL中的模式是强类型的，因此在使用之前必须对它们进行定义和结构化。然而，在AEM中，模式是基于内容片段模型生成的，该模型可以根据业务需求进行修改，并将根据这些变化自动更新所述模型。</p><p id="6ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该实现超出了本文的范围，但是GraphQL接口仍然是通过dispatcher提供的，因为所有以前的方法都是这样做的。当我们需要完全解耦的东西时会发生什么？</p><h2 id="3e5f" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">自定义复制/传输</h2><p id="390e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">有时候，出于多种原因，如性能、平台可用性、有限的网络等，项目需要一个完全解耦的架构。</p><p id="0701" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自定义复制提供了对数据流及其存储位置的完全控制，这可能是AWS、ElasticSearch、Solr、Kafka、SQS等公司的S3桶。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lo"><img src="../Images/bc0377f6c62dfb028c926e9ef1717cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQ86b6N17F7sURYgWpxm1A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Diagram of a decoupled application using Custom Transport</figcaption></figure><p id="c598" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从开发的角度来看，这是最费力的，需要最大的努力，但是，它允许一个真正解耦的环境，不直接依赖于AEM的dispatcher或publisher实例。</p><p id="e9b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，您需要创建一个<code class="du lh li lj lk b">TransportHandler</code>，一个传输处理程序允许我们挂钩到复制机制，以便构建我们自己的解决方案。AEM已经与该实现捆绑在一起，用于author和publisher上的开箱即用复制代理。</p><p id="d1e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">传输处理程序的实现基本上需要两件主要的事情，一个是确定是否使用定制代理的<code class="du lh li lj lk b">canHandle</code>方法，另一个是负责大部分流程的<code class="du lh li lj lk b">deliver</code>方法。在这里您可以添加一个自定义的ContentBuilder来管理内容，否则它将尝试发送整个页面，就像在创作和发布之间那样。下面是一种基本方法:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Sample Custom Transport</figcaption></figure><p id="0f3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这需要与此复制代理的实例一起进行，它可以在miscadmin面板上创建。为了确保使用自定义传输，我们需要指定URI来使用处理程序上的那个。通常情况下，您会在这里添加一个用户和密码，以及其他配置选项，如S3存储桶的名称，可能还有AWS凭证等。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lp"><img src="../Images/c75d76e46632d56c6c34d6c74f3d4419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*IFUeFYj3br1QRTrNi-wlxQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Custom Agent Settings</figcaption></figure><p id="7859" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当一个资源发布后，您可以查看日志，看看它是否通过了。在这种情况下，我们会看到添加到日志中的自定义消息。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lq"><img src="../Images/4d854aae0f67301a29038605b67fa99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7njnlPsuvRBjWXpsw8FhQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Custom Agent Log</figcaption></figure><p id="2b9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，这允许一个完全解耦的架构，不依赖于分发器来提供内容，如前所述，这是最费开发精力的，但提供了很大的灵活性。我们将在以后的文章中进行更详细的讨论。</p><blockquote class="lr ls lt"><p id="2d43" class="ie if kc ig b ih ii ij ik il im in io lu iq ir is lv iu iv iw lw iy iz ja jb ha bi translated">注意，在AEM Cloud中，使用<a class="ae lx" href="https://sling.apache.org/documentation/bundles/content-distribution.html" rel="noopener ugc nofollow" target="_blank"> Sling内容分发</a>发布内容。不再支持自定义复制代理或传输，需要通过EventHandler来处理。</p></blockquote><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ly"><img src="../Images/db7c3fe250f8935853ff8b2098a4a2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aHTfO_awV5_NbnVv.png"/></div></div></figure><h2 id="413b" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">结论</h2><p id="9098" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">使用Adobe Experience Manager实现无头交付有许多不同的方法，其中许多我们甚至没有包括在内，如自定义Servlets、QueryBuilder API、Assets CRUD操作等。在这篇文章中，我们只是触及了这个主题的表面，给出了一些实现这种响应的最常见的方法，希望这是一个好的起点。编码快乐！</p><h2 id="96de" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">参考</h2><ul class=""><li id="19bf" class="kt ku hh ig b ih jx il jy ip lz it ma ix mb jb ky kz la lb bi translated"><a class="ae lx" href="https://experienceleague.adobe.com/docs/experience-manager-cloud-service/content/headless/graphql-api/content-fragments.html?lang=en" rel="noopener ugc nofollow" target="_blank">用于内容片段的AEM graph QL API | Adobe Experience Manager</a></li><li id="4f6f" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><a class="ae lx" href="https://experienceleague.adobe.com/docs/experience-manager-learn/foundation/development/develop-sling-model-exporter.html?lang=en#:~:text=Sling%20Model%20Exporter%20is%20a%20feature%20of%20the,and%20later.%20The%20use-case%20for%20Sling%20Model%20Exporter" rel="noopener ugc nofollow" target="_blank">在AEM | Adobe Experience Manager中开发吊索模型导出器</a></li></ul></div></div>    
</body>
</html>