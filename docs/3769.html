<html>
<head>
<title>Let’s get started with Java Testing Framework : JUnit 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们从Java测试框架开始:JUnit 5</h1>
<blockquote>原文：<a href="https://medium.com/globant/lets-get-started-with-java-testing-framework-junit-5-3c1d1b67a074?source=collection_archive---------0-----------------------#2021-10-18">https://medium.com/globant/lets-get-started-with-java-testing-framework-junit-5-3c1d1b67a074?source=collection_archive---------0-----------------------#2021-10-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/87c1a8c4181dbf7aec2767bc82f262f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DcAHGyvG0UzHYhYW.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><a class="ae hu" href="https://junit.org/" rel="noopener ugc nofollow" target="_blank">Ref</a></figcaption></figure><div class=""/><p id="c6dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">测试覆盖率越高，代码失败就越少。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div class="ab fe cl jw"><img src="../Images/1b5698a16144affae4be85a07b1e9d04.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QC1CH1Ix_VND9K47iGiWVQ.jpeg"/></div></figure><h2 id="9931" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">在编写失败的单元测试之前，您可能无法编写成功的产品代码</h2><p id="1d2d" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">在开发阶段发现错误比在生产中发现错误的成本要低得多。它不仅让你免于尴尬，也让你的公司和用户免于沮丧。</p><p id="8a8a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">原因很简单。如果你有测试，你就不会害怕修改现有的代码！没有测试，每一个变化都是可能的错误。</p><p id="a3f2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不管你的架构有多灵活！</p><p id="4fe7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不管你的设计有多好！</p><p id="b59b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果没有测试，你将不愿意做出改变，因为害怕你会引入未被发现的错误。</p><blockquote class="kx ky kz"><p id="af55" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">坚持基本原则:什么是单元测试？</p></blockquote><p id="8c4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单元测试处于最低级别，通常检查单个方法，以确认它们根据条件返回预期的结果</p><p id="7b7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单元测试通常是由软件开发人员编写和运行的自动化测试，以确保应用程序的一部分(称为“单元”)符合其设计并按预期运行。因此，我们可以解释，单元测试是为了确保我们的代码或源代码上的每个单元运行得如何，基于已经定义的业务流程。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><blockquote class="kx ky kz"><p id="5ad2" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">让我们动手写干净的测试用例:</strong></p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/4eb62bea01ca54519c58e41e0231ef35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoR7zfAa9lxzp23arjibOA.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://www.homestratosphere.com/types-of-sculpting-clay/" rel="noopener ugc nofollow" target="_blank">home stratosphere</a></figcaption></figure><blockquote class="kx ky kz"><p id="1471" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="hx">第一件事:添加JUnit 5依赖项</em> </strong></p></blockquote><ul class=""><li id="b47a" class="lm ln hx iw b ix iy jb jc jf lo jj lp jn lq jr lr ls lt lu bi translated"><code class="du lv lw lx ly b">junit-jupiter-api</code>提供了编写测试用例的公共API</li></ul><figure class="js jt ju jv fd hj er es paragraph-image"><div class="er es lz"><img src="../Images/aa1bdd7bb96e64e7c3628ad54c8fd06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*dZNI-EJ1rL_CIUPz"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Ref <a class="ae hu" href="https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine/5.8.0" rel="noopener ugc nofollow" target="_blank">Maven Repository</a></figcaption></figure><p id="1cf7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="la">问题陈述:</em> </strong> <br/>根据给定的出生日期(日、月、年)求年龄。</p><p id="fcef" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="la">约束:</em> </strong> <br/>出生日期应该在今天日期之前</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/f19836cb3d144bf4f1543c699d52e87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qHu5j-Sgy0ci0XhGemPQw.png"/></div></div></figure><p id="0cdd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要编写一个简单的JUnit测试用例，我们需要在测试包中声明一个类，并使用<code class="du lv lw lx ly b">@Test</code>注释<br/>实现一个方法。测试方法的返回类型总是void，您需要验证预期和实际的结果，以决定测试是通过还是失败。</p><blockquote class="kx ky kz"><p id="c200" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">测试用例1:成功场景</p></blockquote><p id="9e8a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输入:出生日期:1992年8月15日<br/>预计输出年龄:29岁</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/58cdb385a1cbcc294e7b2ebffae18e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laJuYjbbLkY3i-6jY1g_YA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Success Scenario Test Case</figcaption></figure><blockquote class="kx ky kz"><p id="9c42" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">测试用例2:失败场景</p></blockquote><p id="4329" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输入:出生日期:2022年8月15日<br/>预期输出:抛出InvalidAgeException并显示消息“无效的出生日期”</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/5c7c9334886fb5d8698055a4eab0c53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RgBlR0oUg5uxq5PIfkjYg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fail Scenario Test Case</figcaption></figure><p id="8bf9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lv lw lx ly b">assertEquals</code>是断言类的静态方法，用于检查两个对象是否相等，如果提供给<code class="du lv lw lx ly b">assertEquals</code>的条件失败，那么我们的测试用例将会失败。<code class="du lv lw lx ly b">assertThrows</code>断言提供的可执行文件抛出预期类型的异常。</p><p id="3d1b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果测试中没有断言，那么测试用例总是通过。稍后我们将了解一下<strong class="iw hy">断言类</strong>。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="93dc" class="md jy hx bd jz me mf mg kd mh mi mj kh mk ml mm kk mn mo mp kn mq mr ms kq mt bi translated">JUnit测试的生命周期</h1><p id="2392" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">我们可以在每个JUnit测试类中有很多测试用例，每个测试用例都经历一个生命周期，如下所示。我们有一个在所有测试运行之前和每个测试之前进行设置的选项。我们可以选择在所有测试后和每次测试后进行清理。</p><p id="0a72" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">每个方法的生命周期(默认生命周期):</strong>对于测试类中的每个测试方法，将会创建一个测试实例。</p><p id="7f1b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">每个类的生命周期:</strong>对于每个测试类，将会创建一个测试实例，而不是每个测试方法。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mu"><img src="../Images/1576db3f9303e9237b319e8e48b5fd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZin0W5m_TggK0xd8gyjNg.png"/></div></div></figure><ul class=""><li id="b9f1" class="lm ln hx iw b ix iy jb jc jf lo jj lp jn lq jr lr ls lt lu bi translated"><code class="du lv lw lx ly b">@BeforeEach</code> <em class="la"> → </em>表示注释的方法将在每个测试方法之前执行(JUnit4的<code class="du lv lw lx ly b">@Before</code>)</li><li id="90cd" class="lm ln hx iw b ix mv jb mw jf mx jj my jn mz jr lr ls lt lu bi translated"><code class="du lv lw lx ly b">@AfterEach</code> <em class="la"> → </em>表示注释的方法将在每个测试方法之后执行(6月4日的<code class="du lv lw lx ly b">@After</code>)</li><li id="3229" class="lm ln hx iw b ix mv jb mw jf mx jj my jn mz jr lr ls lt lu bi translated"><code class="du lv lw lx ly b">@BeforeAll</code> <em class="la"> → </em>表示注释的方法将在当前类的所有测试方法之前执行(JUnit4的<code class="du lv lw lx ly b">@BeforeClass</code>)</li><li id="4f7b" class="lm ln hx iw b ix mv jb mw jf mx jj my jn mz jr lr ls lt lu bi translated"><code class="du lv lw lx ly b">@AfterAll</code> <em class="la"> → </em>表示注释的方法将在当前类的所有测试方法之后执行(JUnit4的<code class="du lv lw lx ly b">@AfterClass</code> <em class="la"> </em>)</li></ul><blockquote class="kx ky kz"><p id="61ee" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">让我们看看实现的生命周期。</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es na"><img src="../Images/68fd328cb5c5ed7fbf084476411bfbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z3ZK7mZZ1KpNgaJ-HmFog.png"/></div></div></figure><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/862857fb5e3c02348c9606b1926f7c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgtVcZe0LHG2UkrAK9gpaw.png"/></div></div></figure><blockquote class="kx ky kz"><p id="406e" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">输出</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/eefb58de6d566686abeb2e6f2728b7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdIBLpUCDj2rHl3d8lnVrQ.png"/></div></div></figure><p id="d47a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">全局计数增加了一次，因为<code class="du lv lw lx ly b">init()</code>方法只执行了一次，因为我们已经用<code class="du lv lw lx ly b">@BeforeAll.</code>对它进行了注释</p><p id="4ef4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本地计数增加了两次，因为<code class="du lv lw lx ly b">beforeEachTest()</code>方法执行了两次，因为我们已经用<code class="du lv lw lx ly b">@BeforeEach.</code>对其进行了注释</p><h1 id="a363" class="md jy hx bd jz me nc mg kd mh nd mj kh mk ne mm kk mn nf mp kn mq ng ms kq mt bi translated">JUnit 5断言</h1><p id="fc15" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">JUnit 5断言有助于用测试用例的实际输出来验证预期的输出。为了简单起见，所有JUnit Jupiter断言都是<code class="du lv lw lx ly b">org.junit.jupiter.Assertions</code>类中的静态方法，如下所示:</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nh"><img src="../Images/2f13d9def060035d73f8eb5ca8c2bedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni4Zm6lUUqAI7dzswnPeIw.jpeg"/></div></div></figure><blockquote class="kx ky kz"><p id="3d93" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">断言布尔变量。</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ni"><img src="../Images/351dfd5e06c31e5c4170a5ebef2c0d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3B9ix9yRi5efjgp7TUqLVg.png"/></div></div></figure><blockquote class="kx ky kz"><p id="8d1d" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">验证两个对象是否相等。</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nj"><img src="../Images/abf446ca0e1f3f17a49bdce4603cef4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zChWYM7hhqafG9vLifGd6Q.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="bd jz">Note</strong>: We should always implement equals and hashCode when we want to test the equality of two custom objects, else it might not work as expected.</figcaption></figure><blockquote class="kx ky kz"><p id="3e6f" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">测试对象的空条件</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nk"><img src="../Images/517d7cce9ca60ee9d31a30432249dc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRSsyZ4JZLspcPt3IExhxA.png"/></div></div></figure><blockquote class="kx ky kz"><p id="a534" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">检查两个数组是否相等。</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nl"><img src="../Images/72d1aa974902e1fdaddbb625fcc6953b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2V-2Cmzkktn4Gjstp1jAYA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="bd jz">Note</strong>: We have to make sure that the elements in both the arrays are in the same order and If both the array objects are null then they are considered equal.</figcaption></figure><blockquote class="kx ky kz"><p id="d946" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">通过深度比较验证两个<strong class="iw hy">可迭代变量</strong>是否相等</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nm"><img src="../Images/97fb40f7bf3289e48d8f23d4a29a65c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CKn7Klg-uT3ztvX-GPzNw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="bd jz">Note</strong>: Both iterables should return the objects in the same order.</figcaption></figure><blockquote class="kx ky kz"><p id="7ccd" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">测试变量是否引用同一个对象</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nn"><img src="../Images/298b70fcaad590fb0d27699593828930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNRUUiGHLYMfUj_MBHCXxQ.png"/></div></div></figure><blockquote class="kx ky kz"><p id="330b" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">一次验证所有多个可执行文件</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es no"><img src="../Images/e6a55884e566a6a883edf3d54c81eec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFxJAETEvcRp7wSeCgroGQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="bd jz">Note:</strong> if any executables throws exception it will continue to run all the other executables, consolidates the exceptions and report all of them at once.</figcaption></figure><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es np"><img src="../Images/39f1d411e0bc3c844b1e7f73b1886fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdvPd0Z0OgUKyJANWtFr1g.png"/></div></div></figure><blockquote class="kx ky kz"><p id="82aa" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">异常处理</strong>:预期可执行文件会抛出预期类型的异常</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nq"><img src="../Images/57a75d9138e997b79de6d8f9bc439762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0wldAOvBlAijZDsLAZZ1g.png"/></div></div></figure><blockquote class="kx ky kz"><p id="4110" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">自定义断言</strong>:如果我们想在某个条件下测试失败，那么我们可以使用<code class="du lv lw lx ly b">fail</code>方法。</p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nr"><img src="../Images/9f9a81228e46b43e1b5ba253d995f736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwDLrIWOBuj9rA6cGJ-iSg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="bd jz">Note</strong> : Calling this method results in <em class="ns">AssertionFailedError</em>.</figcaption></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="ef90" class="md jy hx bd jz me mf mg kd mh mi mj kh mk ml mm kk mn mo mp kn mq mr ms kq mt bi translated">有用的JUnit注释</h1><blockquote class="kx ky kz"><p id="4fd8" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy"> @DisplayName </strong></p></blockquote><p id="390c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">测试类和测试方法可以声明将由测试运行程序和测试报告显示的自定义显示名称。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nt"><img src="../Images/c6143045bd58b879e585c9f8226eef62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ1CI0Ad48vI6w2kIULS9w.png"/></div></div></figure><blockquote class="kx ky kz"><p id="04d6" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">@禁用</strong></p></blockquote><p id="530d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lv lw lx ly b">@Disabled</code>注释用于禁用或跳过类或方法级别的测试。这类似于JUnit 4的<code class="du lv lw lx ly b">@Ignore</code>。</p><p id="8a96" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当在类级别声明时，所有的<code class="du lv lw lx ly b">@test</code>方法都会被跳过。当我们在方法级别使用<code class="du lv lw lx ly b">@Disabled</code>时，只有带注释的方法被禁用。</p><p id="43e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lv lw lx ly b">@Disabled</code>用于表示带注释的测试方法当前被禁用，不应该被执行。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nt"><img src="../Images/0b4848d47815633e08cf054ee514f8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIpDc4itYFW08UoQFSnRqg.png"/></div></div></figure><blockquote class="kx ky kz"><p id="1ecd" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">JUnit 5中的依赖注入</strong></p></blockquote><p id="81c4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在所有以前的JUnit版本中，测试构造函数或方法不允许有参数。作为JUnit 5的主要变化之一，测试构造函数和方法现在都允许有参数。</p><p id="a224" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这允许更大的灵活性，并支持构造函数和方法的依赖注入。</p><p id="3f64" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> TestInfo </strong>用于将关于当前测试或容器的信息注入到测试用例中</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nt"><img src="../Images/b894454df0bd82c77b1a8a16cbed3fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PJTFkZdelItRRuYwjYvXQ.png"/></div></div></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><blockquote class="kx ky kz"><p id="3d9d" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><strong class="iw hy">最后但同样重要的是:清洁测试F.I.R.S.T规则</strong></p></blockquote><figure class="js jt ju jv fd hj er es paragraph-image"><div class="er es nu"><img src="../Images/d3b1d7dc48157f1d6deff22faa4944d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*QXWgwfYqIj0VjsTWUoWj2Q.png"/></div></figure><p id="16e2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="la"> F.I.R.S.T. </em> </strong>干净测试遵循形成上述缩写词的其他五个规则:</p><p id="a28c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">快速</strong>:测试应该快速。他们应该跑得很快。当测试运行缓慢时，您不会想要频繁地运行它们。</p><p id="0467" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">独立</strong>:测试不应该互相依赖。一次测试不应该为下一次测试设置条件。</p><p id="ec29" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可重复的:测试应该在任何环境下都是可重复的。您应该能够在没有网络的开发、QA、生产环境中运行测试。</p><p id="a7ca" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">自验证</strong>:测试应该有一个布尔输出。他们要么通过，要么失败。您不必通读日志文件来判断测试是否通过。</p><p id="e584" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">及时:测试需要及时地编写。单元测试应该在产品代码通过之前编写。</p><h1 id="f074" class="md jy hx bd jz me nc mg kd mh nd mj kh mk ne mm kk mn nf mp kn mq ng ms kq mt bi translated">谢谢大家！！！</h1><p id="9671" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">“对知识的投资总是会有最好的回报。”我希望这篇文章对你来说是一次很好的学习经历。谢谢你坚持到底。<br/>敬请关注第2部分，Mockito框架<br/>快乐学习编码！..</p></div></div>    
</body>
</html>