<html>
<head>
<title>Grouping Semantics in Jetpack Compose UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写UI中的分组语义</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/grouping-semantics-in-jetpack-compose-ui-93fa47e615db?source=collection_archive---------1-----------------------#2022-01-23">https://medium.com/google-developer-experts/grouping-semantics-in-jetpack-compose-ui-93fa47e615db?source=collection_archive---------1-----------------------#2022-01-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="29a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">语义修饰符让我们改变Jetpack Compose UI中的<a class="ae jc" href="https://developer.android.com/jetpack/compose/semantics" rel="noopener ugc nofollow" target="_blank">语义树</a>的各个方面——这是一种对可访问性服务和测试框架有帮助的UI表示。</p><p id="f596" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用这些修饰符将许多小部件组合成一个逻辑元素，这样就可以使用诸如TalkBack之类的可访问性服务更快地浏览相似元素的列表。</p><p id="7888" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，在YouTube Music中，当前播放列表表示为一个曲目列表，每个曲目包含:</p><ul class=""><li id="f1a8" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">一个标题</li><li id="df69" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">艺术家</li><li id="66c2" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">轨道长度</li><li id="a916" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">播放/暂停动作</li><li id="2878" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">查看更多/菜单操作</li><li id="851b" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">(状态—正在播放)</li></ul><figure class="jr js jt ju fd jv er es paragraph-image"><div class="ab fe cl jw"><img src="../Images/de38850b2e2f72c9342826554a9b7a49.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eEO7KoRjFcYKRkuBmCFdxg.png"/></div></figure><p id="fbcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像TalkBack这样的屏幕阅读器会用一个内在的描述(文本)或动作来关注每个元素，这意味着从一个轨道导航到下一个轨道会花费用户~5个手势。</p><h2 id="322b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">重写语义</h2><p id="a7f1" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">我们可以重新编写轨道的语义信息，以便将其表示为单个逻辑元素:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="d42c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du lb lc ld le b">clearAndSetSemantics()</code>修改器是<strong class="ig hi">必需的</strong>；在这种情况下，使用<code class="du lb lc ld le b">semantics()</code>修饰符是不够的。</p><h2 id="3f0c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">Modifier.clearAndSetSemantics()</h2><p id="1018" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><code class="du lb lc ld le b">Modifier.clearAndSetSemantics()</code>将清除所有后代节点的语义信息，并用给定的属性更新当前节点。</p><p id="96f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该函数的文档说明如下:</p><blockquote class="lf lg lh"><p id="d308" class="ie if li ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated">这可以用来提供更好的屏幕阅读器体验:例如，清除一组小按钮的语义，并在包含它们的卡片上设置等效的动作。</p></blockquote><p id="00a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这正是我们想要的！但是，清除后代节点的语义有一些含义:</p><ul class=""><li id="9af2" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">任何基于文本的后代将不再是焦点，也不会包含在内容描述中。我们的内容描述必须是对整行的忠实描述。</li><li id="3608" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">任何可点击的后代将不再是焦点。相反，我们必须在行上公开这些操作(<code class="du lb lc ld le b">customActions</code>)。</li></ul><h2 id="1d59" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">Modifier.semantics()</h2><p id="b0bf" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><code class="du lb lc ld le b">Modifier.semantics()</code>让我们给当前节点添加语义信息。我们的目标是将每个轨迹的表示简化为一个节点，所以这在这里没有帮助。</p><p id="f468" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">事实上，如果让整行都成为可聚焦的(除了我们已经拥有的)，情况会更糟。</p><h2 id="10d7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">modifier . semantics(merge descendants = true)</h2><p id="65a3" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">使用<code class="du lb lc ld le b">Modifier.semantics(mergeDescendants = true)</code>稍微有用一些，因为它会减少可聚焦元素的数量。</p><p id="3611" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将<code class="du lb lc ld le b">mergeDescendants</code>设置为<code class="du lb lc ld le b">true</code>将会:</p><ul class=""><li id="6ef5" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">移除所有后代节点(除非他们也在使用<code class="du lb lc ld le b">mergeDescendants = true</code>)</li><li id="247b" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">尽可能将属性合并在一起</li></ul><p id="f0b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">带有<code class="du lb lc ld le b">clickable</code>修饰符的元素不会被删除，因为它们使用了<code class="du lb lc ld le b">mergeDescendants = true</code>。在我们的例子中，这意味着播放/暂停和菜单动作仍然是焦点。</p><p id="3009" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">标题、艺术家和曲目长度节点不可点击。这里，将尝试合并来自这些节点的语义信息，这将导致重复的信息，因为我们手动设置内容描述。</p><h2 id="53b9" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">概述</h2><p id="23f8" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><code class="du lb lc ld le b">Modifier.clearAndSetSemantics()</code>在Compose UI中，我们可以对节点及其后代的语义表示进行大量控制。虽然它比<code class="du lb lc ld le b">Modifier.semantics()</code>更强大，但我们也需要更加小心。</p><p id="7767" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据经验，考虑将其用于集合中的元素(列表或网格),并始终测试其行为。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lm la l"/></div></figure><p id="85c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢这篇文章，有任何问题，评论或更正，请联系<a class="ae jc" href="https://twitter.com/ataulm/status/1485180047778537476" rel="noopener ugc nofollow" target="_blank">推特</a>。</p></div></div>    
</body>
</html>