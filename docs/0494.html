<html>
<head>
<title>The one and only object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">唯一的一件物品</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/the-one-and-only-object-5dfd2cf7ab9b?source=collection_archive---------2-----------------------#2020-05-01">https://medium.com/androiddevelopers/the-one-and-only-object-5dfd2cf7ab9b?source=collection_archive---------2-----------------------#2020-05-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/70fba01ba4a45cb602c88d394a663914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dF3Ek-ltwlpauuYE"/></div></div></figure><div class=""/><div class=""><h2 id="a457" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇</h2></div><p id="c5be" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在Java中，<code class="du kd ke kf kg b">static</code>关键字用于表示属于<em class="kh">对象</em>的方法和属性，而不是属于对象的<em class="kh">实例</em>的方法和属性。<code class="du kd ke kf kg b">static</code>关键字也用于创建<a class="ae ki" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>，这是最广泛使用的设计模式之一。单例帮助您创建一个对象的单个实例，它可以被其他对象访问和共享。</p><p id="45fd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">科特林有一个更优雅的方法来处理这个问题。你可以使用一个关键字:<code class="du kd ke kf kg b">object</code>，来实现单例模式。请继续阅读，了解在Java和Kotlin中实现单例的区别，如何在Kotlin中不使用<code class="du kd ke kf kg b">static</code>关键字创建单例(通过使用<code class="du kd ke kf kg b">object</code>关键字来破坏这一点)，并了解当您使用<code class="du kd ke kf kg b">object</code>时会发生什么。</p><p id="24cc" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，让我们回顾一下，找出为什么我们需要一个对象的单个实例，也就是Singleton。</p><h1 id="aa58" class="kj kk hs bd kl km kn ko kp kq kr ks kt iy ku iz kv jb kw jc kx je ky jf kz la bi translated">什么是独生子女？</h1><p id="8f50" class="pw-post-body-paragraph jh ji hs jj b jk lb it jm jn lc iw jp jq ld js jt ju le jw jx jy lf ka kb kc ha bi translated">Singleton是一种设计模式，它确保一个类只有一个实例，并提供对对象的全局访问点。对于需要在应用程序的不同部分之间共享的对象，以及创建成本高昂的资源，单例模式尤其有用。</p><h1 id="3c93" class="kj kk hs bd kl km kn ko kp kq kr ks kt iy ku iz kv jb kw jc kx je ky jf kz la bi translated">Java中的Singleton</h1><p id="5785" class="pw-post-body-paragraph jh ji hs jj b jk lb it jm jn lc iw jp jq ld js jt ju le jw jx jy lf ka kb kc ha bi translated">为了保证一个类只有一个实例，您需要控制如何创建对象。若要创建只有一个实例的类，请将构造函数设为私有，并创建对象的公共可访问静态引用。这样做的时候，你并不真的想在启动时创建Singleton，因为Singleton用于创建代价很高的对象。为此，提供一个静态方法来检查对象是否被创建。方法必须返回以前创建的实例，或者调用构造函数并返回实例。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7501" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">上面的代码看起来不错，但是有一个主要问题。<strong class="jj ht">该代码不是线程安全的</strong>。在任何时候，一个线程都可以通过if检查，但在另一个线程创建singleton时会被挂起。当第一个线程在<code class="du kd ke kf kg b">if</code>块中恢复时，它会创建另一个实例。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="a38a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要解决线程问题，可以使用双重检查锁定。使用双重检查锁定，如果实例是<code class="du kd ke kf kg b">null</code>，<code class="du kd ke kf kg b">synchronized</code>关键字创建一个锁，第二次检查确保实例仍然是<code class="du kd ke kf kg b">null</code>。如果实例是<code class="du kd ke kf kg b">null</code>，那么创建单例。然而，这还不够，实例还需要标记<code class="du kd ke kf kg b"><a class="ae ki" href="https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java" rel="noopener ugc nofollow" target="_blank">volatile</a></code>。Volatile关键字告诉编译器，并发运行的线程可能会异步修改变量。</p><p id="8a27" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所有这些导致了很多样板文件，每次你需要一个单例时都需要重复这些文件。因为对于这样一个简单的任务来说，这段代码太复杂了，所以枚举在大多数时候被用于在Java中创建单例。</p><h1 id="f4eb" class="kj kk hs bd kl km kn ko kp kq kr ks kt iy ku iz kv jb kw jc kx je ky jf kz la bi translated">科特林的单身族</h1><p id="ec34" class="pw-post-body-paragraph jh ji hs jj b jk lb it jm jn lc iw jp jq ld js jt ju le jw jx jy lf ka kb kc ha bi translated">现在，让我们来看看科特林。Kotlin没有静态方法或字段，那么我们如何在Kotlin中创建一个Singleton？</p><p id="648a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">其实Android Studio/IntelliJ可以帮助我们理解。当您将Java中的Singleton代码转换为Kotlin时，所有静态属性和方法都被移动到一个<code class="du kd ke kf kg b">companion object</code>中。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1cc2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">转换后的代码按预期工作，但我们可以使它更简单。为了简化代码，从<code class="du kd ke kf kg b">object</code>中移除构造函数和<code class="du kd ke kf kg b">companion</code>关键字。<code class="du kd ke kf kg b">object</code>和<code class="du kd ke kf kg b">companion objects</code>之间的区别将在本文后面介绍。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="697b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您想使用<code class="du kd ke kf kg b">count()</code>方法时，您可以通过Singleton对象访问它。在Kotlin中，<code class="du kd ke kf kg b">object</code>是一个只有一个实例的特殊类。如果用<code class="du kd ke kf kg b">object</code>关键字而不是<code class="du kd ke kf kg b">class</code>创建一个类，Kotlin编译器会将构造函数设为私有，为对象创建一个静态引用，并在静态块中初始化引用。</p><p id="82df" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">静态块只在第一次访问静态字段时调用一次。JVM以类似于同步块的方式处理静态块，即使它们没有<code class="du kd ke kf kg b">synchronized</code>关键字。当这个单例类初始化时，JVM获得同步块上的一个锁，使得另一个线程无法访问它。当锁被释放时，Singleton实例已经被创建，因此静态块不会再次执行。这保证了只有一个Singleton实例，它实现了Singleton契约。另外，该对象是线程安全的，并且是在第一次访问时延迟创建的。瞧啊。</p><p id="b117" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们来看看反编译的Kotlin字节码，以了解幕后发生了什么。</p><blockquote class="lm ln lo"><p id="1bc7" class="jh ji kh jj b jk jl it jm jn jo iw jp lp jr js jt lq jv jw jx lr jz ka kb kc ha bi translated">要检查Kotlin类的字节码，选择<strong class="jj ht">工具&gt; Kotlin &gt;显示Kotlin字节码</strong>。一旦Kotlin字节码显示出来，点击<strong class="jj ht">反编译</strong>显示反编译的Java代码。</p></blockquote><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="982d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，<code class="du kd ke kf kg b">object</code>有一个限制。对象声明不能有构造函数，这意味着它们不能带参数。即使他们这样做了，也不可能传递参数，因为构造函数中传递的非静态参数不能从静态块中访问。</p><blockquote class="lm ln lo"><p id="fb43" class="jh ji kh jj b jk jl it jm jn jo iw jp lp jr js jt lq jv jw jx lr jz ka kb kc ha bi translated">⚠️静态初始化块，就像其他静态方法一样，只能访问类的静态属性。静态块在构造函数之前被调用，因此它们无法访问对象的属性或构造函数中传递的参数。</p></blockquote><h1 id="10c3" class="kj kk hs bd kl km kn ko kp kq kr ks kt iy ku iz kv jb kw jc kx je ky jf kz la bi translated">伴随物体</h1><p id="ff21" class="pw-post-body-paragraph jh ji hs jj b jk lb it jm jn lc iw jp jq ld js jt ju le jw jx jy lf ka kb kc ha bi translated"><code class="du kd ke kf kg b">companion object</code>类似于<code class="du kd ke kf kg b">object</code>。总是在类中声明，它们的属性可以通过使用主机对象来访问。<code class="du kd ke kf kg b">companion object</code>不需要名字。如果<code class="du kd ke kf kg b">companion object</code>有名字，调用者可以使用<code class="du kd ke kf kg b">companion object</code>的名字访问成员。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ef23" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">例如，这里我们有相似的有名字和没有名字的伴随对象。任何调用者都可以访问<code class="du kd ke kf kg b">SomeClass</code>上的<code class="du kd ke kf kg b">count()</code>方法，就像它是<code class="du kd ke kf kg b">SomeClass</code>的静态成员一样。或者，任何调用者都可以通过使用<code class="du kd ke kf kg b">Counter</code>来访问<code class="du kd ke kf kg b">count()</code>方法，就像使用<code class="du kd ke kf kg b">AnotherClass</code>的静态成员一样。</p><p id="9c6f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">伴随对象用私有构造函数反编译成内部类。宿主类通过只有它才能访问的合成构造函数初始化内部类。host类保存了对companion对象的公共引用，可以从其他类访问该对象。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="8ee7" class="kj kk hs bd kl km kn ko kp kq kr ks kt iy ku iz kv jb kw jc kx je ky jf kz la bi translated">对象表达式</h1><p id="7889" class="pw-post-body-paragraph jh ji hs jj b jk lb it jm jn lc iw jp jq ld js jt ju le jw jx jy lf ka kb kc ha bi translated">到目前为止，我们已经看到了在对象声明中使用的<code class="du kd ke kf kg b">object</code>关键字。<code class="du kd ke kf kg b">object</code>关键字也可以用在对象表达式中。当用作表达式时，<code class="du kd ke kf kg b">object</code>关键字帮助你创建匿名对象和匿名内部类。</p><p id="6bed" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设您需要一个临时对象来保存一些值。您可以当场用所需的值声明和初始化您的对象，并在以后访问它们。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="88cd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在生成的代码中，这转化为一个匿名Java类，用<code class="du kd ke kf kg b">&lt;undefinedtype&gt;</code>标记，用生成的getters和setters存储匿名对象。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1d11" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kd ke kf kg b">object</code>关键字还可以帮助您创建匿名类，而无需编写任何样板代码。您可以使用对象表达式，Kotlin编译器生成包装类声明来创建匿名类。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="4f99" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kd ke kf kg b">object</code>关键字帮助你用更少的代码创建线程安全的单例、匿名对象和匿名类。使用<code class="du kd ke kf kg b">object</code>和<code class="du kd ke kf kg b">companion object</code>，Kotlin生成所有代码来实现<code class="du kd ke kf kg b">static</code>关键字提供的相同功能。另外，您可以使用对象表达式创建匿名对象和类，而无需任何样板代码。</p></div></div>    
</body>
</html>