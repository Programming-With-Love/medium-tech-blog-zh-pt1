<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/globant/eliminating-boiler-plate-while-implementing-clean-architecture-6810512fbab4?source=collection_archive---------3-----------------------#2018-09-11">https://medium.com/globant/eliminating-boiler-plate-while-implementing-clean-architecture-6810512fbab4?source=collection_archive---------3-----------------------#2018-09-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="2a13" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">实现干净架构的同时消除样板代码</h2><p id="1591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">在实现<a class="ae iz" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净的架构</a>时，我们创建了不同的层，如域、数据和表示层。每一层都有自己的模型，为了在各层之间进行无缝通信，我们需要将属性从一种类型的对象复制到另一种类型的对象，反之亦然。</p><p id="a03b" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">因此，我们最终创建了不同的数据或普通类，它们具有几乎相同的属性和morpher/mapper类，这可以帮助我们复制属性。对于这个过程，对象映射是一个众所周知的术语。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/bda15070cf4e4d522fa1a68e1f34eb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbXOLiRY1Ez0OwRouKHfPQ.png"/></div></div></figure><p id="0557" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">这是一项乏味且容易出错的任务。在<a class="ae iz" href="https://github.com/GaurangShaha/KMorph" rel="noopener ugc nofollow" target="_blank"> KMorph </a>库的帮助下，你可以通过添加一些注释来轻松完成。它使用注释处理来生成代码，所以在运行时不会有额外的开销。</p><p id="5b51" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">例如，假设您有两个名为EmployeeDTO和EmployeeDAO的对象。EmployeeDTO属于域层，而EmployeeDAO属于数据层。</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="1e4e" class="hf hg hh js b fi jw jx l jy jz">public class EmployeeDTO {<br/>    private String firstName;</span><span id="453e" class="hf hg hh js b fi ka jx l jy jz">    private String lastName;</span><span id="7aaa" class="hf hg hh js b fi ka jx l jy jz">    private BigInteger idNumber;</span><span id="b93a" class="hf hg hh js b fi ka jx l jy jz">    // Getter and Setter<br/>}</span></pre></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><pre class="jr js jt ju aw jv bi"><span id="42ea" class="hf hg hh js b fi ki kj kk kl km jx l jy jz">public class EmployeeDAO {<br/>    private String firstName;</span><span id="7acf" class="hf hg hh js b fi ka jx l jy jz">    private String lastName;</span><span id="ab15" class="hf hg hh js b fi ka jx l jy jz">    private BigInteger idNumber;</span><span id="a4de" class="hf hg hh js b fi ka jx l jy jz">    // Getter and Setter<br/>}</span></pre><p id="cfc8" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">要将属性值从EmployeeDAO复制到EmployeeDTO，反之亦然，我们需要编写一个类似下面所示的类的代码。</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="b9d6" class="hf hg hh js b fi jw jx l jy jz">public final class EmployeeDAOMorpher {<br/>   public static EmployeeDTO morph(EmployeeDAO source) {<br/>       EmployeeDTO target = new EmployeeDTO();<br/>       target.setLastName(source.getLastName());<br/>       target.setFirstName(source.getFirstName());<br/>       target.setIdNumber(source.getIdNumber());<br/>       return target;<br/>   }</span><span id="7e69" class="hf hg hh js b fi ka jx l jy jz">public static EmployeeDAO reverseMorph(EmployeeDTO target) {<br/>       EmployeeDAO source = new EmployeeDAO();<br/>       source.setLastName(target.getLastName());<br/>       source.setFirstName(target.getFirstName());<br/>       source.setIdNumber(target.getIdNumber());<br/>       return source;<br/>   }<br/>}</span></pre><p id="d1b5" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">让KMorph库来为您处理这个繁琐且容易出错的任务。您可以使用KMorph库提供的注释来实现上述功能。</p><div class="kn ko ez fb kp kq"><a href="https://github.com/GaurangShaha/KMorph" rel="noopener  ugc nofollow" target="_blank"><div class="kr ab dw"><div class="ks ab kt cl cj ku"><h2 class="bd kv fi z dy kw ea eb kx ed ef ky bi translated">GaurangShaha/KMorph</h2><div class="kz l"><h3 class="bd b fi z dy kw ea eb kx ed ef dx translated">一个Kotlin库，它自动生成代码在类之间复制你的数据。- GaurangShaha/KMorph</h3></div><div class="la l"><p class="bd b fp z dy kw ea eb kx ed ef dx translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg jp kq"/></div></div></a></div><h2 id="02c9" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">向Android项目添加库</h2><p id="db98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">将库依赖项添加到build.gradle文件中。</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="06a9" class="hf hg hh js b fi jw jx l jy jz">dependencies {<br/>    implementation 'com.kmorph:kmorph-annotation:1.0.0'<br/>    annotationProcessor 'com.kmorph:kmorph-processor:1.0.0'<br/>}</span></pre><p id="96a7" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果Android Studio没有检测到生成的文件，那么您可能需要在应用级build.gradle中添加以下几行</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="a2dd" class="hf hg hh js b fi jw jx l jy jz">android {<br/>        ... <br/>	<br/>        sourceSets {<br/>		debug.java.srcDirs += 'build/generated/source/kaptKotlin/debug'<br/>		release.java.srcDirs += 'build/generated/source/kaptKotlin/release'<br/>	}<br/>}</span></pre><p id="4dbc" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">这就是你建立图书馆所需要做的一切</p><h2 id="6cbf" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">@MorphTo(TargetClass::class)</h2><p id="d9ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">此注释用在需要变形的类中。它需要它应该变形的目标的类别。</p><p id="26c0" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">为了生成morpher，源和目标类KMorph库需要以下东西</p><ul class=""><li id="d11f" class="lh li hh ig b ih ja il jb hr lj hv lk hz ll iy lm ln lo lp bi translated">这两个类都应该是公共类类型，即接口、注释、枚举、私有和受保护类，抽象类不能与它一起使用。</li><li id="6d16" class="lh li hh ig b ih lq il lr hr ls hv lt hz lu iy lm ln lo lp bi translated">需要复制的属性应该有getter和setter。</li></ul><p id="869f" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">KMorph库将自动比较两个类的属性，并为您创建morpher。Morpher将包含具有相同名称和兼容数据类型的属性。</p><p id="6526" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果属性有不同的名称，您可以使用@MorphToField注释指示KMorph库生成映射。</p><p id="03fe" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果属性具有不同的数据类型，您可以使用@FieldTransformer注释指示KMorph库生成映射。</p><p id="f4c0" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">注意:目标类不需要注释。</p><h2 id="da70" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">@MorphToField("字段名称")</h2><p id="cc53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">此注释用于在两个类中具有不同名称的属性。它需要来自目标类的属性名，它需要与目标类一起变形。</p><p id="b742" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">它可以与@FieldTransformer批注结合使用。</p><p id="598f" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">注意:这个注释应该在用@MorphTo注释的类中使用。如果在由@MorphTo注释的类之外使用，KMorph库将忽略此注释。</p><p id="e3ce" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果用this注释的属性具有不兼容的数据类型，KMorph库将忽略它。</p><h2 id="41b7" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">@ field transformer(field transformer . class)</h2><p id="0c4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">此注释用于在两个类中具有不同数据类型的属性。它需要一个类来帮助库转换字段。</p><p id="5da2" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">transformer类需要实现KMorph库提供的FieldTransformerContract接口。为transform和reverseTransform方法提供实现，该库将负责调用适当的方法。</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="aab1" class="hf hg hh js b fi jw jx l jy jz">class MillisToDateStringTransformer : FieldTransformerContract&lt;String, Long&gt; {<br/>    private val DATE_FORMAT = "dd MMM yyyy"<br/><br/>    override fun reverseTransform(target: Long): String {<br/>        return SimpleDateFormat(DATE_FORMAT).format(Date(target))<br/>    }<br/><br/>    override fun transform(source: String): Long {<br/>        return try {<br/>            SimpleDateFormat(DATE_FORMAT).parse(source).time<br/>        } catch (e: ParseException) {<br/>            (-1).toLong()<br/>        }<br/>    }<br/>}</span></pre><p id="a1c0" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">它可以与@MorphToField批注一起使用。</p><h2 id="f1a4" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">在两个类之间复制数据</h2><p id="1cd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">这个库可以在</p><ol class=""><li id="75f8" class="lh li hh ig b ih ja il jb hr lj hv lk hz ll iy lv ln lo lp bi translated">两个数据类别</li><li id="7750" class="lh li hh ig b ih lq il lr hr ls hv lt hz lu iy lv ln lo lp bi translated">两个正常类</li><li id="2ed1" class="lh li hh ig b ih lq il lr hr ls hv lt hz lu iy lv ln lo lp bi translated">一个普通类和一个数据类</li><li id="a749" class="lh li hh ig b ih lq il lr hr ls hv lt hz lu iy lv ln lo lp bi translated">变量数量不同的两个数据类</li><li id="a0ed" class="lh li hh ig b ih lq il lr hr ls hv lt hz lu iy lv ln lo lp bi translated">变量个数不同的两个正规类</li></ol><p id="f569" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">让我们考虑一个场景，您需要在两个普通类之间复制数据</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="8dd6" class="hf hg hh js b fi jw jx l jy jz">@MorphTo(EmployeeDTO::class)<br/>class EmployeeDAO {<br/>    var firstName: String = ""<br/>    var lastName: String = ""<br/>    var idNumber: BigInteger = BigInteger("-1")<br/>    var phone: String = ""<br/>    var email: String = ""<br/>    var jobTitle: String = ""<br/>    @MorphToField("departmentName")<br/>    @FieldTransformer(DepartmentIdToNameTransformer::class)<br/>    var departmentId: Int = 0<br/>    var supervisor: String = ""<br/>    @MorphToField("workLocation")<br/>    var location: String = ""<br/>    var employeeType: Int = 0<br/>    var active: Boolean = false<br/>    @FieldTransformer(MillisToDateStringTransformer::class)<br/>    var startDate: Long = 0<br/>    @FieldTransformer(MillisToDateStringTransformer::class)<br/>    var endDate: Long = 0<br/>    var documentLink: String = ""<br/>}</span></pre></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><pre class="jr js jt ju aw jv bi"><span id="29db" class="hf hg hh js b fi ki kj kk kl km jx l jy jz">class EmployeeDTO {<br/>    var lastName: String = ""<br/>    var firstName: String = ""<br/>    var idNumber: BigInteger = BigInteger("-1")<br/>    var phone: String = ""<br/>    var email: String = ""<br/>    var jobTitle: String = ""<br/>    var departmentName: String = ""<br/>    var supervisor: String = ""<br/>    var workLocation: String = ""<br/>    var employeeType: Int = 0<br/>    var startDate: String = ""<br/>    var endDate: String = ""<br/>    var documentLink: String = ""<br/>    var active: Boolean = false<br/>}</span></pre><p id="3cda" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">由于EmployeeDAO中的位置需要复制到EmployeeDTO的workLocation中，所以我使用了@MorphToField注释。</p><p id="2744" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">两个类中的startDate有不同的数据类型，为了复制那里的值，我使用了@FieldTransformer注释。为其转换创建了MillisToDateStringTransformer类，并将其作为参数传递给批注。</p><p id="ec63" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">现在，如果您重新构建项目，您会发现一个名为EmployeeDAOMorpher.kt的Kotlin文件，其中包含两个扩展，用于将值从EmployeeDAO复制到EmployeeDTO，反之亦然。</p><pre class="jg jh ji jj fd jr js jt ju aw jv bi"><span id="863f" class="hf hg hh js b fi jw jx l jy jz">fun EmployeeDAO.morphToEmployeeDTO(): EmployeeDTO {<br/>    val target = EmployeeDTO()<br/>    target.departmentName = com.kmorph.DepartmentIdToNameTransformer().transform(departmentId)<br/>    target.lastName = lastName<br/>    target.endDate = com.kmorph.MillisToDateStringTransformer().reverseTransform(endDate)<br/>    target.jobTitle = jobTitle<br/>    target.active = active<br/>    target.idNumber = idNumber<br/>    target.workLocation = location<br/>    target.firstName = firstName<br/>    target.employeeType = employeeType<br/>    target.phone = phone<br/>    target.documentLink = documentLink<br/>    target.email = email<br/>    target.supervisor = supervisor<br/>    target.startDate = com.kmorph.MillisToDateStringTransformer().reverseTransform(startDate)<br/>    return target<br/>}</span><span id="86a5" class="hf hg hh js b fi ka jx l jy jz">fun EmployeeDTO.morphToEmployeeDAO(): EmployeeDAO {<br/>    val source = EmployeeDAO()<br/>    source.departmentId = com.kmorph.DepartmentIdToNameTransformer().reverseTransform(departmentName)<br/>    source.lastName = lastName<br/>    source.endDate = com.kmorph.MillisToDateStringTransformer().transform(endDate)<br/>    source.jobTitle = jobTitle<br/>    source.active = active<br/>    source.idNumber = idNumber<br/>    source.location = workLocation<br/>    source.firstName = firstName<br/>    source.employeeType = employeeType<br/>    source.phone = phone<br/>    source.documentLink = documentLink<br/>    source.email = email<br/>    source.supervisor = supervisor<br/>    source.startDate = com.kmorph.MillisToDateStringTransformer().transform(startDate)<br/>    return source<br/>}</span></pre><p id="c38d" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">现在只需在对象上调用这个方法，就可以轻松地在不同类型的对象中复制数据。</p><p id="46f8" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">这个库的Java版本也是可用的，您可以在</p><div class="kn ko ez fb kp kq"><a href="https://github.com/GaurangShaha/JMorph" rel="noopener  ugc nofollow" target="_blank"><div class="kr ab dw"><div class="ks ab kt cl cj ku"><h2 class="bd kv fi z dy kw ea eb kx ed ef ky bi translated">GaurangShaha/JMorph</h2><div class="kz l"><h3 class="bd b fi z dy kw ea eb kx ed ef dx translated">一个自动生成代码在POJO类之间复制数据的库。- GaurangShaha/JMorph</h3></div><div class="la l"><p class="bd b fp z dy kw ea eb kx ed ef dx translated">github.com</p></div></div><div class="lb l"><div class="lw l ld le lf lb lg jp kq"/></div></div></a></div></div></div>    
</body>
</html>