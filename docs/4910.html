<html>
<head>
<title>Item: Consider aggregating elements to a map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">项目:考虑将元素聚合到一个映射中</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/item-consider-aggregating-elements-to-map-a5a35a7b6c61?source=collection_archive---------1-----------------------#2020-04-20">https://blog.kotlin-academy.com/item-consider-aggregating-elements-to-map-a5a35a7b6c61?source=collection_archive---------1-----------------------#2020-04-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/146ae6999c4b5b579cc3df68e7eb54ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ySvlYWhj8NE334_5.jpg"/></div></div></figure><div class=""/><p id="9154" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要多次访问大量的元素，这种情况并不少见。可能是:</p><ul class=""><li id="e732" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">缓存——我们从一些服务下载数据，然后保存在本地内存中以便更快地访问它们</li><li id="72a5" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">从某个文件加载数据的存储库</li><li id="400f" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">用于不同类型测试的内存存储库</li></ul><p id="3289" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些数据可能代表用户、id、配置等的列表。它们通常以列表的形式提供给我们，在我们的记忆中以同样的方式呈现它们是很有诱惑力的:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="9d0c" class="lq lr iy lm b gy ls lt l lu lv"><strong class="lm iz">class </strong>NetworkUserRepo(<strong class="lm iz">val userService</strong>: UserService): UserRepo {<br/>    <strong class="lm iz">private var users</strong>: List&lt;User&gt;? = <strong class="lm iz">null</strong></span><span id="f8d8" class="lq lr iy lm b gy lw lt l lu lv"><strong class="lm iz">    override fun </strong>getUser(id: UserId): User? {<br/>        <strong class="lm iz">if</strong>(<strong class="lm iz">users </strong>== <strong class="lm iz">null</strong>) {<br/>            <strong class="lm iz">users </strong>= <strong class="lm iz">userService</strong>.getUsers()<br/>        }<br/>        <strong class="lm iz">return users</strong>?.<em class="lx">firstOrNull </em><strong class="lm iz">{ it</strong>.<strong class="lm iz">id </strong>== id <strong class="lm iz">}<br/>    </strong>}<br/>}<br/><br/><strong class="lm iz">class </strong>ConfigurationsRepository(<br/>    <strong class="lm iz">val configurations</strong>: List&lt;Configuration&gt;<br/>) {<br/>    <strong class="lm iz">fun </strong>getByName(name: String) = <strong class="lm iz">configurations<br/>        </strong>.<em class="lx">firstOrNull </em><strong class="lm iz">{ it</strong>.<strong class="lm iz">name </strong>== name <strong class="lm iz">}<br/></strong>}</span><span id="7e9e" class="lq lr iy lm b gy lw lt l lu lv">class InMemoryUserRepo: UserRepo {<br/>   private val users: MutableList&lt;User&gt; = mutableListOf()</span><span id="b417" class="lq lr iy lm b gy lw lt l lu lv">   override fun getUser(id: UserId): User?<br/>      = users.firstOrNull { it.id == id }<br/>   <br/>   fun addUser(user: User) {<br/>      user.add(user)<br/>   }<br/>}</span></pre><p id="3005" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很少是存储这些元素的最佳方式。注意我们加载的数据是如何使用的。我们通常通过一些标识符或名称来访问一个元素(这与我们如何在数据库中设计具有唯一键的数据有关)。在列表中查找元素的复杂度为O(n)，其中n是列表的大小。更具体地说，平均需要n/2次比较才能找到一个元素。这对于更大的列表来说尤其成问题。解决这个问题的好办法是用<code class="fe ly lz ma lm b">Map</code>代替<code class="fe ly lz ma lm b">List</code>。Kotlin默认使用哈希映射(具体是<code class="fe ly lz ma lm b">LinkedHashMap</code>)，正如我们在<a class="ae mb" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank"> Item 41:尊重hashCode </a>的契约中所描述的，当我们使用哈希映射时，查找元素的性能要好得多。实际上，在JVM中，由于所使用的hash map的大小被调整为map本身的大小，如果<code class="fe ly lz ma lm b">hashCode</code>被正确实现，查找一个元素应该只需要一次比较。</p><p id="7899" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是<code class="fe ly lz ma lm b">InMemoryRepo</code>用地图代替列表:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="3369" class="lq lr iy lm b gy ls lt l lu lv">class InMemoryUserRepo: UserRepo {<br/>   private val users: MutableMap&lt;UserId, User&gt; = mutableMapOf()</span><span id="fdee" class="lq lr iy lm b gy lw lt l lu lv">   override fun getUser(id: UserId): User? = users[id]<br/>   <br/>   fun addUser(user: User) {<br/>      user.put(user.id, user)<br/>   }<br/>}</span></pre><p id="d88b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数其他操作，如修改或迭代这些数据(可能使用集合处理方法，如过滤、映射、平面映射、排序、求和等。)对于标准列表和地图具有或多或少相同的性能。</p><figure class="lh li lj lk gt ip gh gi paragraph-image"><a href="https://www.kt.academy/workshop/refactoringToPatterns"><div class="gh gi mc"><img src="../Images/62520e901df6820dab70ac182f9613ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyoUl26C3O3OEdhpbEuN0A.png"/></div></a></figure><p id="e2a4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是我们如何从列表转换到地图，反之亦然。为此，我们使用<code class="fe ly lz ma lm b">associate</code>功能。最常见的是<code class="fe ly lz ma lm b">associateBy</code>,它构建一个映射，其中值是列表中的元素，键是在lambda表达式上生成的:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="f04b" class="lq lr iy lm b gy ls lt l lu lv">data class User(val id: Int, val name: String)<br/>val users = listOf(User(1, "Michal"), User(2, "Marek"))</span><span id="a911" class="lq lr iy lm b gy lw lt l lu lv">val byId = users.associateBy { it.id }<br/>byId == mapOf(1 to User(1, "Michal"), 2 to User(2, "Marek")) </span><span id="d55d" class="lq lr iy lm b gy lw lt l lu lv">val byName = users.associateBy { it.name }<br/>byName == mapOf("Michal" to User(1, "Michal"), <br/>              "Marek" to User(2, "Marek"))</span></pre><p id="ffc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，映射中的键必须是唯一的，否则重复项将被删除。这就是为什么我们应该只通过一个唯一的标识符来关联(要通过不唯一的东西来分组，使用<code class="fe ly lz ma lm b"><a class="ae mb" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html" rel="noopener ugc nofollow" target="_blank">groupBy</a></code>)。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="010d" class="lq lr iy lm b gy ls lt l lu lv">val users = listOf(User(1, "Michal"), User(2, "Michal"))</span><span id="9bbb" class="lq lr iy lm b gy lw lt l lu lv">val byName = users.associateBy { it.name }<br/>byName == mapOf("Michal" to User(2, "Michal"))</span></pre><p id="c29f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要反过来转换，可以使用<code class="fe ly lz ma lm b">values</code>:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="eeec" class="lq lr iy lm b gy ls lt l lu lv"><strong class="lm iz">val </strong>users = <em class="lx">listOf</em>(User(1, <strong class="lm iz">"Michal"</strong>), User(2, <strong class="lm iz">"Michal"</strong>))<br/><strong class="lm iz">val </strong>byId = users.<em class="lx">associateBy </em><strong class="lm iz">{ it</strong>.<strong class="lm iz">id }<br/></strong>users == byId.<strong class="lm iz">values</strong></span></pre><p id="7390" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是使用map实现其他存储库以提高元素访问性能的方式:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="0569" class="lq lr iy lm b gy ls lt l lu lv"><strong class="lm iz">class </strong>NetworkUserRepo(<strong class="lm iz">val userService</strong>: UserService): UserRepo {<br/>    <strong class="lm iz">private var users</strong>: Map&lt;UserId, User&gt;? = <strong class="lm iz">null<br/>    override fun </strong>getUser(id: UserId): User? {<br/>        <strong class="lm iz">if</strong>(<strong class="lm iz">users </strong>== <strong class="lm iz">null</strong>) {<br/>            <strong class="lm iz">users </strong>= <strong class="lm iz">userService</strong>.getUsers().<em class="lx">associateBy </em><strong class="lm iz">{ it</strong>.<strong class="lm iz">id }<br/>        </strong>}<br/>        <strong class="lm iz">return users</strong>?.get(id)<br/>    }<br/>}<br/><br/><strong class="lm iz">class </strong>ConfigurationsRepository(<br/>    configurations: List&lt;Configuration&gt;<br/>) {<br/>    <strong class="lm iz">val configurations</strong>: Map&lt;String, Configuration&gt; = <br/>        configurations.<em class="lx">associateBy </em><strong class="lm iz">{ it</strong>.<strong class="lm iz">name }<br/>    <br/>    fun </strong>getByName(name: String) = <strong class="lm iz">configurations</strong>[name]<br/>}</span></pre><p id="e8da" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这项技术很重要，但并不适用于所有情况。当我们经常需要访问这些元素时，它会更有用。这就是为什么它在后端特别重要，因为这些集合可能每秒被访问很多次。在前端(我指的也是Android或iOS)用户最多访问几次这个存储库并不重要。我们还需要记住，从列表到映射也需要一些时间，所以如果我们经常这样做，也可能会影响我们的性能。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="1ec2" class="mk lr iy bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="99f2" class="pw-post-body-paragraph jv jw iy jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae mb" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae mb" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><p id="72b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要一个科特林工作室，看看我们如何能帮助你:<a class="ae mb" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="lh li lj lk gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mc"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>