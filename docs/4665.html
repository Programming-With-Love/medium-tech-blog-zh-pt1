<html>
<head>
<title>JavaScript Factory Functions vs Constructor Functions vs Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript工厂函数vs构造函数vs类</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e?source=collection_archive---------0-----------------------#2016-06-01">https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e?source=collection_archive---------0-----------------------#2016-06-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f22bf29c1c209dd089920e6e78bdad35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlTZhtIdWEBYjjlgf1BRJw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Shaolin — larique (CC BY-NC-ND 2.0)</figcaption></figure><p id="8515" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在ES6之前，人们对JavaScript中工厂函数和构造函数的区别有很多困惑。由于ES6有了<em class="jr"> `class` </em>关键字，很多人似乎认为这解决了构造函数的许多问题。它没有。让我们探讨一下您仍然需要了解的主要区别。</p><p id="7b61" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，让我们来看看每一个例子:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="873f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这些策略中的每一个都将方法存储在一个共享的原型上，并通过构造函数闭包可选地支持私有数据。换句话说，它们具有几乎相同的特性，并且可以互换使用。</p><blockquote class="jy"><p id="554a" class="jz ka hh bd kb kc kd ke kf kg kh jq dx translated">在JavaScript中，任何函数都可以返回一个新对象。当它不是构造函数或类时，它被称为工厂函数。</p></blockquote><p id="d33f" class="pw-post-body-paragraph it iu hh iv b iw ki iy iz ja kj jc jd je kk jg jh ji kl jk jl jm km jo jp jq ha bi translated">ES6类与构造函数无关，因此关于构造函数的所有内容也适用于ES6类:</p><pre class="js jt ju jv fd kn ko kp kq aw kr bi"><span id="0ff2" class="ks kt hh ko b fi ku kv l kw kx">class Foo {}</span><span id="96d1" class="ks kt hh ko b fi ky kv l kw kx">console.log(typeof Foo); // function</span></pre><h1 id="5ac7" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">工厂和建造师有什么区别？</h1><p id="2905" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">构造函数强制调用方使用<code class="du mb mc md ko b">new</code>关键字。工厂没有。就是这样，但这有一些相关的副作用。</p><p id="ddab" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">那么<code class="du mb mc md ko b">new</code>关键字是做什么的呢？</p><blockquote class="me mf mg"><p id="3923" class="it iu jr iv b iw ix iy iz ja jb jc jd mh jf jg jh mi jj jk jl mj jn jo jp jq ha bi translated">注意:我们将使用<code class="du mb mc md ko b">instance</code>来引用新创建的实例，使用<code class="du mb mc md ko b">Constructor</code>来引用创建该实例的构造函数或类。</p></blockquote><ol class=""><li id="1e6c" class="mk ml hh iv b iw ix ja jb je mm ji mn jm mo jq mp mq mr ms bi translated">实例化一个新的实例对象，并在构造函数中将<code class="du mb mc md ko b">this</code>绑定到它。</li><li id="46a1" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq mp mq mr ms bi translated">将<code class="du mb mc md ko b">instance.__proto__</code>绑定到<code class="du mb mc md ko b">Constructor.prototype</code>。</li><li id="6ebc" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq mp mq mr ms bi translated">作为2的副作用，将<code class="du mb mc md ko b">instance.__proto__.constructor</code>绑定到<code class="du mb mc md ko b">Constructor</code>。</li><li id="a724" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq mp mq mr ms bi translated">隐式返回<code class="du mb mc md ko b">this</code>，引用<code class="du mb mc md ko b">instance</code>。</li></ol><h1 id="e3cd" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构造函数的好处&amp; `class '</h1><ul class=""><li id="2043" class="mk ml hh iv b iw lw ja lx je my ji mz jm na jq nb mq mr ms bi translated">大多数书教你使用类或构造函数。</li><li id="664a" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated"><code class="du mb mc md ko b">this</code>指新对象。</li><li id="cf98" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">有些人喜欢<code class="du mb mc md ko b">myFoo = new Foo()</code>的阅读方式。</li><li id="f590" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">微优化可能会带来性能上的好处，但是您不应该担心这一点，除非您已经分析了您的代码并证明这对您来说是一个问题。</li></ul><h1 id="3bc0" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构造函数的缺点&amp; `class</h1><h2 id="bd0f" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">1.必需的“新”。</h2><p id="4b3d" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">在ES6之前，忘记<code class="du mb mc md ko b">new</code>是一个很常见的bug。为了对抗它，许多人使用样板文件来执行它:</p><pre class="js jt ju jv fd kn ko kp kq aw kr bi"><span id="691c" class="ks kt hh ko b fi ku kv l kw kx">function Foo() {<br/>  if (!(this instanceof Foo)) { return new Foo(); }<br/>}</span></pre><p id="8b7e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在ES6+ (ES2015)中，如果你试图在没有<code class="du mb mc md ko b">new</code>的情况下调用一个类构造函数，它总是会抛出一个错误。如果不将类包装在工厂函数中，就不可能避免对调用者施加<code class="du mb mc md ko b">new</code>要求。</p><h2 id="c756" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">2.实例化的细节泄露到调用API中(通过“新”需求)。</h2><p id="141a" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">所有调用方都与构造函数实现紧密耦合。如果你需要工厂的额外灵活性，重构是一个突破性的变化。类到工厂的重构非常普遍，以至于它们出现在开创性的重构书《重构:改进现有代码的设计》中，作者是Martin Fowler、Kent Beck、John Brant、William Opdyke和Don Roberts。</p><h2 id="0210" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">3.构造函数打破了开放/封闭原则</h2><p id="e2e6" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">由于<code class="du mb mc md ko b">new</code>需求，构造函数违反了<strong class="iv hi">打开/关闭</strong>原则:一个API应该<strong class="iv hi">打开</strong>进行扩展，而<strong class="iv hi">关闭</strong>进行修改。</p><p id="a452" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我认为类到工厂的重构非常普遍，应该被认为是所有构造函数的标准扩展:从类到工厂的升级不应该破坏东西，但在JavaScript中却是这样。</p><p id="bd95" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您开始导出一个构造函数或类，而用户开始使用该构造函数，那么接下来您会意识到您需要工厂的灵活性(例如，切换实现以使用对象池，或者跨执行上下文实例化，或者使用替代原型获得更大的继承灵活性)，如果不对调用者强制进行重构，您将很难做到这一点。</p><p id="a33b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不幸的是，在JavaScript中，从构造函数或类切换到工厂是一个突破性的变化:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="1c88" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的例子中，我们从一个类开始，但是我们想增加提供不同种类的汽车捆绑包的能力。为此，工厂为不同的汽车套件使用替代原型。我使用这种技术存储了媒体播放器界面的各种实现，根据播放器需要控制的媒体类型选择正确的原型。</p><h2 id="22c9" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">4.使用构造函数会导致欺骗性的“instanceof”</h2><p id="1fd4" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">构造函数到工厂重构的突破性变化之一是<code class="du mb mc md ko b">instanceof</code> <em class="jr">。有时候，人们很想在他们的代码中使用<code class="du mb mc md ko b">instanceof</code>作为类型检查保护。这可能会很成问题。我建议你避开<code class="du mb mc md ko b">instanceof</code> <em class="jr">。</em></em></p><blockquote class="jy"><p id="a56f" class="jz ka hh bd kb kc kd ke kf kg kh jq dx translated">谎言的实例。</p></blockquote><figure class="nq nr ns nt nu ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="8008" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du mb mc md ko b">instanceof</code>不像在强类型语言中那样进行类型检查。相反，它通过比较对象的<code class="du mb mc md ko b">__proto__</code>对象和<code class="du mb mc md ko b">Constructor.prototype</code>属性来进行身份检查。</p><p id="f7df" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它不能跨不同的内存领域工作，比如iframes(第三方JavaScript嵌入中常见的错误来源)。如果你的<code class="du mb mc md ko b">Constructor.prototype</code>被替换，它也不起作用。</p><p id="58e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您从一个类或构造函数(它返回<code class="du mb mc md ko b">this</code>，链接到<code class="du mb mc md ko b">Constructor.prototype</code>)开始，然后切换到导出一个任意对象(不链接到<code class="du mb mc md ko b">Constructor.prototype</code>)，这也会失败，当您从构造函数更改为工厂时就会发生这种情况。</p><p id="4448" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">简而言之，<code class="du mb mc md ko b">instanceof</code>是另一种方式，从建筑商到工厂的转换是一种<strong class="iv hi">突破性的变化</strong>。</p><h1 id="bb0c" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用类的好处</h1><ul class=""><li id="7168" class="mk ml hh iv b iw lw ja lx je my ji mz jm na jq nb mq mr ms bi translated">方便、独立的语法。</li><li id="1144" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">在JavaScript中模拟类的单一、规范的方式。在ES6之前，流行的库中有几个竞争的实现。</li><li id="c0c7" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">来自基于类的语言背景的人更熟悉。</li></ul><h1 id="4b5b" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用类的缺点</h1><p id="e89c" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">所有构造函数的缺点，加上:</p><ul class=""><li id="2c7e" class="mk ml hh iv b iw ix ja jb je mm ji mn jm mo jq nb mq mr ms bi translated">诱惑用户使用<code class="du mb mc md ko b">extends</code>关键字创建有问题的类层次结构。</li></ul><p id="f22c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在面向对象设计中，类层次导致了一系列众所周知的问题，包括<strong class="iv hi">脆弱基类问题、大猩猩香蕉问题、必然复制问题、</strong>等等。不幸的是，阶级提供延伸就像球提供投掷和椅子提供坐着。更多信息，请阅读<a class="ae np" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">“JavaScript的两大支柱:原型OO”</a>和<a class="ae np" rel="noopener" href="/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b">“开发团队死亡螺旋内部”</a>。</p><p id="5b65" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">值得注意的是，构造函数和工厂都可以用来创建有问题的继承层次结构，但是使用<em class="jr"> `extends` </em>关键字，class会创建一个启示，把你引向错误的道路。换句话说，它鼓励你去思考不灵活的(而且经常是错误的)关系，而不是更灵活的组合关系。</p><blockquote class="me mf mg"><p id="d68f" class="it iu jr iv b iw ix iy iz ja jb jc jd mh jf jg jh mi jj jk jl mj jn jo jp jq ha bi translated"><em class="hh">一个</em> <strong class="iv hi"> <em class="hh">启示</em> </strong> <em class="hh">是提供执行某个动作的机会的特征。例如，旋钮提供扭转，杠杆提供拉动，按钮提供按压，等等……</em></p></blockquote><h1 id="26cf" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用工厂的好处</h1><p id="e11b" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">工厂比构造函数或类灵活得多，而且它们不会用关键字<em class="jr"> `extends` </em>和深层继承层次来引诱人们误入歧途。比起类继承，有许多更安全的代码重用机制，包括函数和模块。</p><h2 id="109e" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">1.返回任意对象并使用任意原型</h2><p id="5692" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">例如，您可以轻松创建实现相同API的各种类型的对象，例如，可以实例化使用不同API的多种类型视频内容的播放器的媒体播放器，或者可以发出DOM事件或web套接字事件的事件库。</p><p id="14be" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">工厂还可以跨执行上下文实例化对象，利用对象池，并允许更灵活的原型继承模型。</p><h2 id="58da" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">2.没有重构的烦恼</h2><p id="e49b" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">您永远不需要从工厂转换到构造函数，因此重构永远不会成为问题。</p><h2 id="db8a" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">3.否<em class="nv">`新`</em></h2><p id="e820" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">使用<code class="du mb mc md ko b">new</code>没有歧义。不要。(会让<code class="du mb mc md ko b">this</code>表现不好，见下一点)。</p><h2 id="ca85" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">4.标准<em class="nv"> `this` </em>行为</h2><p id="0766" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated"><code class="du mb mc md ko b">this</code>像平常一样工作，所以你可以用它来访问父对象。例如，在<code class="du mb mc md ko b">player.create()</code>中，<code class="du mb mc md ko b">this</code>指的是玩家，就像其他方法调用一样。<code class="du mb mc md ko b">call()</code>和<code class="du mb mc md ko b">apply()</code>也按预期重新分配<code class="du mb mc md ko b">this</code>。</p><h2 id="63ca" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">5.没有欺骗性<em class="nv"> `instanceof` </em></h2><h2 id="cfb1" class="ks kt hh bd la nc nd ne le nf ng nh li je ni nj lm ji nk nl lq jm nm nn lu no bi translated">6.有些人喜欢“myFoo = createFoo()”的读法</h2><h1 id="7580" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">工厂的弊端</h1><ul class=""><li id="3a4a" class="mk ml hh iv b iw lw ja lx je my ji mz jm na jq nb mq mr ms bi translated">没有创建从实例到<code class="du mb mc md ko b">Factory.prototype</code><em class="jr">——</em>的链接，但这实际上是一件好事，因为你不会得到欺骗性的<code class="du mb mc md ko b">instanceof</code> <em class="jr">。</em>相反，<em class="jr"> </em> <code class="du mb mc md ko b">instanceof</code>总会失败。见福利。</li><li id="f4ce" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated"><code class="du mb mc md ko b">this</code>不是指工厂内部的新对象。见福利。</li><li id="7bb8" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">在微优化基准测试中，它的执行速度可能比构造函数慢。慢速路径仍然非常快——在旧计算机上每秒数百万次运算。与应用程序代码相比，这更可能是库或框架代码中的一个问题。在使用微优化之前，始终从用户角度进行基准测试。</li></ul><h1 id="b536" class="kz kt hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="75e1" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">在我看来，<code class="du mb mc md ko b">class</code>可能有一个方便的语法，但这不能弥补它引诱粗心的用户撞上类继承的岩石这一事实。这也是有风险的，因为在将来，你可能想要升级到一个工厂，但是你所有的调用者都将紧密耦合到构造函数，因为关键字<code class="du mb mc md ko b">new</code>和从类到工厂的移动是一个突破性的改变。</p><p id="3097" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可能认为您可以重构调用点，但是在大型团队中，或者如果您正在使用的类是公共API的一部分，您可能会破坏不受您控制的代码。换句话说，你不能总是假设重构调用者是一种选择。</p><p id="9e46" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">工厂的酷之处在于，它们不仅更强大、更灵活，而且是鼓励整个团队和整个API用户群使用简单、灵活、安全的模式的最简单的方式。</p></div><div class="ab cl nw nx go ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ha hb hc hd he"><h1 id="c02e" class="kz kt hh bd la lb od ld le lf oe lh li lj of ll lm ln og lp lq lr oh lt lu lv bi translated">通过实时1:1辅导提升您的技能</h1><p id="2db8" class="pw-post-body-paragraph it iu hh iv b iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ma jo jp jq ha bi translated">DevAnywhere是达到高级JavaScript技能的最快方法:</p><ul class=""><li id="5aa2" class="mk ml hh iv b iw ix ja jb je mm ji mn jm mo jq nb mq mr ms bi translated">现场课程</li><li id="58c2" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">弹性工时</li><li id="b984" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">一对一指导</li><li id="cdc0" class="mk ml hh iv b iw mt ja mu je mv ji mw jm mx jq nb mq mr ms bi translated">构建真正的生产应用</li></ul><figure class="js jt ju jv fd ii er es paragraph-image"><a href="https://devanywhere.io/"><div class="er es oi"><img src="../Images/03504ae5b049cdb99861a7b575be3a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pskrI-ZjRX_Y0I0zZqVTcQ.png"/></div></a><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae np" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank">https://devanywhere.io/</a></figcaption></figure></div><div class="ab cl nw nx go ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ha hb hc hd he"><p id="b215" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="jr">埃里克·艾略特</em> </strong> <em class="jr">是一位科技产品和平台顾问，《T5】 <a class="ae np" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="jr">【作曲软件】</em></a><em class="jr"/><a class="ae np" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="jr">【EricElliottJS.com】</em></a><em class="jr"/><a class="ae np" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="jr">devanywhere . io</em></a><em class="jr">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="iv hi"> <em class="jr">、Zumba Fitness、</em> </strong> <em class="jr"> </em> <strong class="iv hi"> <em class="jr">【华尔街日报、</em></strong><em class="jr"/><strong class="iv hi"><em class="jr">【ESPN、</em></strong><em class="jr"/><strong class="iv hi"><em class="jr">【BBC】</em></strong><em class="jr">等顶级录音艺人和包括</em> <strong class="iv hi"> <em class="jr"> Usher、【Metallica】</em></strong></em></p><p id="61a2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>