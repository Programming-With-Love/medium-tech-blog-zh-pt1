<html>
<head>
<title>Node is history! Or is it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点是历史！或者是？</h1>
<blockquote>原文：<a href="https://medium.com/globant/node-is-history-or-is-it-4d2616f01d83?source=collection_archive---------1-----------------------#2020-12-11">https://medium.com/globant/node-is-history-or-is-it-4d2616f01d83?source=collection_archive---------1-----------------------#2020-12-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/991101c3c5e49e407eff89301265889e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1diiQHcvb2sqyc1XlrEgsw.jpeg"/></div></div></figure><p id="e06d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Node.js的原创者Ryan Dahl在他的谈话《Node.js我后悔的10件事》中宣布了2018年的Deno。他在Node.js中发现了一些程序员通常不会想到的缺陷，比如整个包管理是如何事后想起的。此外，Ryan对于将npm与包管理联系在一起也不太满意——或者他可能很早就跳到了async/await，而忽略了承诺的一些潜在优势。Deno 1.0正式版于2020年5月13日发布</p><h1 id="b476" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">什么是Deno？</strong></h1><blockquote class="kl km kn"><p id="5d38" class="ip iq ko ir b is it iu iv iw ix iy iz kp jb jc jd kq jf jg jh kr jj jk jl jm ha bi translated">Deno基于V8 JavaScript引擎和Rust编程语言。Deno像Node.js执行JavaScript一样在你的系统上执行JavaScript和TypeScript。默认情况下，它是安全的，并提供了很好的开发人员体验。首先，Deno不仅仅是Node.js和TypeScript的组合，它是一个从头开始设计的全新系统。但是，如果可以轻松地将TypeScript编译器集成到Node.js中进行静态类型检查，那么为什么还要使用Deno呢？</p></blockquote><p id="b97e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Deno与Node.js的主要区别在于以下几个方面:</p><ol class=""><li id="66db" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated">Deno不使用<code class="du lb lc ld le b">npm </code>和<code class="du lb lc ld le b">package.json</code>，它使用模块作为URL或文件路径引用。</li><li id="3726" class="ks kt hh ir b is lf iw lg ja lh je li ji lj jm kx ky kz la bi translated">Deno中的所有异步操作都返回一个承诺。因此，它提供了与Node.js不同的API。</li><li id="280b" class="ks kt hh ir b is lf iw lg ja lh je li ji lj jm kx ky kz la bi translated">Deno需要明确的网络、文件和环境访问权限。</li><li id="4aca" class="ks kt hh ir b is lf iw lg ja lh je li ji lj jm kx ky kz la bi translated">使用“es模块”，不支持<code class="du lb lc ld le b">require()</code>。第三方模块通过URL导入:<br/> <code class="du lb lc ld le b">import * as log from "https://deno.land/std@0.79.0/log/mod.ts";</code></li></ol><figure class="ll lm ln lo fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/85b639648012c1f7f99cfb80c8b0de3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8lUiPv_IkJlVosvFRcaUg.jpeg"/></div></div></figure><h1 id="c48a" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">装置</h1><p id="4044" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">在您的系统上安装Deno的一行命令。您只需要运行以下命令来安装。<br/>带壳:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="eada" class="ly jo hh le b fi lz ma l mb mc">curl -fsSL <a class="ae md" href="https://deno.land/x/install/install.sh" rel="noopener ugc nofollow" target="_blank">https://deno.land/x/install/install.sh</a> | sh</span></pre><p id="119e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个简单的shell脚本将deno二进制文件下载到您主目录中的. Deno目录。它包括TypeScript编译器、V8 JavaScript引擎、Rust binding crates等。之后，使用以下命令将“deno”二进制文件添加到PATH变量中:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="6e38" class="ly jo hh le b fi lz ma l mb mc">echo ‘export DENO_INSTALL=”/home/user/.deno”’ &gt;&gt; ~/.zshrc<br/>echo ‘export PATH=”$DENO_INSTALL/bin:$PATH”’ &gt;&gt; ~/.zshrc</span></pre><p id="1d87" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要测试您的安装，运行<code class="du lb lc ld le b">deno --version</code>。如果这给出了Deno版本，则安装成功。</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div class="er es me"><img src="../Images/f779caea95b6ddac0e3c133fcf80c970.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/1*_LuArwbvlegnHHF-c00xDw.gif"/></div></figure><h1 id="eccc" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">走吧</strong></h1><p id="3b1c" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">显示了使用标准库提供的HTTP服务器的基本服务器。</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="110f" class="ly jo hh le b fi lz ma l mb mc">import { serve } from “https://deno.land/std@0.57.0/http/server.ts";<br/>const server = serve({ port: 8080}); console.log(“http://localhost:8080/"); <br/>for await (const request of server) { <br/>    request.respond({ body: “Welcome to Deno\n” });<br/>}</span></pre><blockquote class="kl km kn"><p id="0734" class="ip iq ko ir b is it iu iv iw ix iy iz kp jb jc jd kq jf jg jh kr jj jk jl jm ha bi translated">与HTML的脚本标签相似，Deno可以从任何地方获取和执行脚本。您也可以在代码中这样做。Node.js中没有类似npm模块的“模块”概念。Deno只需要一个指向有效TypeScript文件的URL，它将运行/导入该文件。您还会看到如上所示的导入语句。</p></blockquote><p id="a5d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记下我们讨论的URL导入。接下来，创建一个名为server.ts的文件，输入以下代码，并尝试运行它:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="6bc4" class="ly jo hh le b fi lz ma l mb mc">deno run server.ts</span></pre><p id="6fe1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行后，我们将得到一个权限问题错误，我们应该可以通过执行“sudo”来解决这个问题，对吗？不完全是。就像它说的，你必须用一个'- -allow-net '标志来运行它，以便手动允许它访问网络。让我们再试一次:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="4193" class="ly jo hh le b fi lz ma l mb mc">deno run --allow-net server.ts</span></pre><p id="9f1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Deno在默认情况下是安全的。这是Node.js中完全缺失的另一个方面。您必须显式地授予这些资源权限，这增加了一层安全性和同意。</p><p id="b469" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个与数据库交互的例子。用Deno连接MongoDB实例是开发人员经常做的另一件事。</p><p id="dcff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于一个MongoDB实例，让我们用下面的代码构建一个基本的MongoDB容器:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="342f" class="ly jo hh le b fi lz ma l mb mc">docker run --name test-mongo -p 27017:27017 -d mongo</span></pre><p id="0d76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们创建文件database.ts，下面的代码将创建一个包含集合“employees”的文档。</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="ca25" class="ly jo hh le b fi lz ma l mb mc">import { MongoClient } from "https://deno.land/x/mongo@v0.8.0/mod.ts"; </span><span id="a3fc" class="ly jo hh le b fi mf ma l mb mc">const client = new MongoClient();<br/>client.connectWithUri("mongodb://localhost:27017"); </span><span id="1389" class="ly jo hh le b fi mf ma l mb mc">const db = client.database("sample");<br/>const users = db.collection("employees");</span><span id="7809" class="ly jo hh le b fi mf ma l mb mc">// insert<br/>const insertId = await users.insertOne({  <br/>      name: "Rishikesh",  <br/>      email: "rishikesh@gmail.com",  <br/>      mobile: 9999999999<br/>});<br/>console.log(`Successfully inserted with the <br/>id: ${JSON.stringify(insertId)}`)</span></pre><p id="b444" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如您所见，这看起来非常类似于Node.js代码。事实上，大多数编程风格保持不变，您可以遵循类似的模式。接下来，让我们运行这个命令，将文档插入到MongoDB容器中:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="65f0" class="ly jo hh le b fi lz ma l mb mc">deno run -A database.ts</span></pre><p id="7bb6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发生的情况是，您会得到如下所示的错误:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="ee1f" class="ly jo hh le b fi lz ma l mb mc">load deno plugin “deno_mongo” from local “/home/user/.deno_plugins/deno_mongo_2970fbc7cebff869aa12ecd5b8a1e7e4.so”<br/>error: Uncaught TypeError: Deno.openPlugin is not a function <br/>return Deno.openPlugin(localPath);<br/>^</span><span id="11e9" class="ly jo hh le b fi mf ma l mb mc">at prepare(https://deno.land/x/plugin_prepare@v0.6.0/mod.ts:64:15)<br/>at async init (https://deno.land/x/mongo@v0.8.0/ts/util.ts:41:3)<br/>at async <a class="ae md" href="https://deno.land/x/mongo@v0.8.0/mod.ts:13:1" rel="noopener ugc nofollow" target="_blank">https://deno.land/x/mongo@v0.8.0/mod.ts:13:1</a></span></pre><p id="326a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是因为我们甚至给了“-A”标志，允许访问所有类型的资源。</p><p id="95fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用'--不稳定'标志重新运行它:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="c102" class="ly jo hh le b fi lz ma l mb mc">deno run -A --unstable database.ts</span></pre><p id="dd6e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，这似乎运行了，输出应该类似于:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="cd49" class="ly jo hh le b fi lz ma l mb mc">load deno plugin “deno_mongo” from local “/home/user/.deno_plugins/deno_mongo_2970fbc7cebff869aa12ecd5b8a1e7e4.so<br/>”Successfully inserted with the id:{“$oid”:”5ef0ba4a000d214a00c4367f”}</span></pre><p id="e380" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是因为MongoDB驱动程序使用了一些额外的功能(准确地说是“哎呀”)。它们不存在于Deno的运行时中，所以它添加了一个插件。虽然Deno有一个插件系统，但接口本身并没有最终确定，而是隐藏在<em class="ko">'--不稳定的'</em>标志后面。默认情况下，Deno不允许脚本使用不稳定的API，但同样，有这个标志来强制它。</p><h1 id="961e" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Node.js有那么差吗？</h1><figure class="ll lm ln lo fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/c6c92a15941084ecfbda1a730b2cb881.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*ujqw467-3IPu0dh3LSX8Kg.gif"/></div></figure><p id="3d6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为什么我们需要不同的视角？Node.js的问题大到我们需要一个新的系统来取代它吗？嗯，不。许多人甚至不会认为它们是问题，但Deno背后有一个中心思想，使其存在合理，设计选择可以理解。节点明显偏离了浏览器的做事方式。</p><p id="c709" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，当一个网站想要录制音频时的权限；浏览器会要求用户同意。Node中没有这种权限，但是Deno将它们带了回来。</p><p id="7666" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于依赖性，浏览器只理解可以从网络上任何地方链接的脚本，而不是节点模块。Node.js不一样。您必须制作并发布一个模块，以便它可以被导入并在全球范围内重用。以获取API为例。Node.js中有一个不同的node-fetch模块来使用fetch，Deno回到简单的脚本，尽力做类似于浏览器的事情。</p><p id="47b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是实施细节和总体主题。从长远来看，这可能会更好。</p><h1 id="e463" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">澄清🦕</h1><p id="cddb" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated"><strong class="ir hi">如果它原生运行TypeScript，那么速度呢？因为V8，节点很快。</strong></p><p id="ccf5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的问题是Deno实际上“运行”TypeScript。</p><p id="4308" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，是的，但实际上不是。</p><p id="6ebb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Deno执行TypeScript，但是它也使用V8来运行代码。所有的类型检查都是预先完成的，在运行时，只有JavaScript。一切都是从开发者这边抽象出来的，不用安装配置<strong class="ir hi"> <em class="ko"> tsc </em> </strong>。</p><p id="a56d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以是的，它很快，因为它也运行在V8上，并且没有运行时类型。</p><p id="ebbe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">URL导入看起来丑陋而脆弱。当其中一个依赖关系的网站关闭时会发生什么？</strong></p><p id="598f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一件事是Deno下载并缓存每个依赖项，他们建议在您的项目中检查这些，以便它们总是可用的。</p><p id="3ce7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您不想在代码中看到URL导入，您可以做两件事:</p><p id="c527" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.在本地重新导出依赖项:要在本地导出标准HTTP服务器，您可以使用下面的代码行<em class="ko">“export { serve } from "</em><a class="ae md" href="https://deno.land/std@0.57.0/http/server.ts" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://deno.land/std@0.57.0/http/server.ts</em></a><em class="ko">" '</em>创建一个名为“local_http.ts”的文件，然后在原始代码中从此文件导入。</p><p id="5566" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.使用导入映射:创建一个JSON文件，将URL映射到您希望在代码中使用的名称。因此，创建一个名为“importmap.json”的文件，并向其中添加以下内容:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="b6e3" class="ly jo hh le b fi lz ma l mb mc">{ <br/>  “imports”: { <br/>      “http/”: “https://deno.land/std/http/" <br/>   }<br/>}</span></pre><p id="1766" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当您运行该脚本时，您只需要提供它作为要使用的importmap:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="a821" class="ly jo hh le b fi lz ma l mb mc">deno run -A --importmap=importmap.json script.ts</span></pre><p id="ce2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以从HTTP名称导入serve函数，如下所示:</p><pre class="ll lm ln lo fd lu le lv lw aw lx bi"><span id="29c4" class="ly jo hh le b fi lz ma l mb mc">import { serve } from “http/server.ts”;</span></pre><p id="8496" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">‍ <strong class="ir hi">依靠URL进行版本控制安全吗？如果开发人员在同一个URL上推送最新版本，而不是新版本，会发生什么？</strong></p><p id="00d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，那就是开发者的错了，npm模块系统也会出现这种情况。但是如果您不确定是否已经缓存了最新的依赖项，那么可以选择重新加载它们。</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/6f63dddc5792a8e28e3407932ea5455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*CaCYMrNgAxD2E2j2a6NM7A.gif"/></div></figure><h1 id="b8fa" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">关闭思想！</h1><p id="cf39" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">至少可以说，Deno是一个有趣的项目。我们只有第一个稳定版，还有很长的路要走。例如，他们正积极致力于提高TypeScript编译器的性能。此外，在<em class="ko">'--不稳定'</em>标志背后隐藏着大量的API。这些可能会在即将发布的版本中发生变化。像TypeScript first和浏览器兼容模块这样的想法当然很有吸引力，这使得Deno值得关注。</p></div></div>    
</body>
</html>