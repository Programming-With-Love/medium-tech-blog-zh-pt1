<html>
<head>
<title>All About using Enums in Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在Hibernate中使用枚举的所有内容</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/all-about-using-enums-in-hibernate-96b72b469836?source=collection_archive---------1-----------------------#2021-08-28">https://medium.com/quick-code/all-about-using-enums-in-hibernate-96b72b469836?source=collection_archive---------1-----------------------#2021-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3c1231bfaa9ee25762a42294d5a3e57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lyblRVRBXJmYG7ei"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="de75" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">枚举是在Java 5中引入的。Hibernate框架识别Java enum，并随后从数据库读取或写入enum状态，而无需任何额外的配置。</p><p id="31fa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以通过两种方式将枚举映射到数据库。让我们看看下面学生的两种方法。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><blockquote class="jy jz ka"><p id="28ad" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated">studentRepo.save(新学生实体(" John Doe "，StudentGrade。优秀))；</p></blockquote><h1 id="0e65" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">序数值</h1><ol class=""><li id="a311" class="ld le hh iw b ix lf jb lg jf lh jj li jn lj jr lk ll lm ln bi translated">默认情况下，Hibernate将枚举映射到序数值，序数值是枚举定义中从零开始的位置。</li><li id="5a6f" class="ld le hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated">因为这是hibernate采用的默认映射，所以不需要添加任何特殊的注释。</li></ol><h2 id="bc0a" class="lt kg hh bd kh lu lv lw kl lx ly lz kp jf ma mb kt jj mc md kx jn me mf lb mg bi translated">数据库表示</h2><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/763f5bb8aef1a7fea2e0e7215ff8a586.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*u6Tmy_hSSU5rCAtvYU8tHw.png"/></div></figure><h2 id="ee0f" class="lt kg hh bd kh lu lv lw kl lx ly lz kp jf ma mb kt jj mc md kx jn me mf lb mg bi translated">缺点</h2><p id="06c4" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">这种映射非常有效，但是存在很高的风险，即在枚举中添加或删除一个值会改变其余值的顺序值。这在不重构数据库的情况下添加新记录时会导致问题。</p><h1 id="c280" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">字符串表示</h1><p id="fc1c" class="pw-post-body-paragraph iu iv hh iw b ix lf iz ja jb lg jd je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">您可以将枚举值映射到一个<em class="kb">字符串</em>。这使用定义它时使用的字符串值。这可以通过在实体中的枚举上添加以下注释来实现。</p><blockquote class="jy jz ka"><p id="830b" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated"><a class="ae it" href="http://twitter.com/Enumerated" rel="noopener ugc nofollow" target="_blank">@枚举</a> (EnumType。字符串)</p></blockquote><h2 id="5cab" class="lt kg hh bd kh lu lv lw kl lx ly lz kp jf ma mb kt jj mc md kx jn me mf lb mg bi translated">数据库表示</h2><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/03736924fdbc0b9d9807cd42ac877807.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*jw-6HtlFZt4yCY1wWytpoQ.png"/></div></figure><h2 id="1d48" class="lt kg hh bd kh lu lv lw kl lx ly lz kp jf ma mb kt jj mc md kx jn me mf lb mg bi translated">缺点</h2><ol class=""><li id="5301" class="ld le hh iw b ix lf jb lg jf lh jj li jn lj jr lk ll lm ln bi translated">这种映射效率不高，因为考虑到下面的例子，我们存储的是视频的类型，这里我们存储的是字符串表示，每个条目大约需要<em class="kb"> 8 </em> <em class="kb">字节</em>。假设我们有10亿行，那么仅这一列就占用了<em class="kb"> 8 GB </em>的空间。</li><li id="294c" class="ld le hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated">您可以添加或删除枚举值而不会产生任何副作用，但是如果不进行迁移，则无法重命名条目。</li></ol><p id="3a04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面讨论的两种方法都使用hibernate提供的缺省值，在很多情况下这就是goto。当我们的应用程序使用遗留数据库或者当我们的枚举不断变化时，它们是没有帮助的。</p><p id="f979" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用属性转换器自定义映射</strong></p><p id="3ee9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们用一个案例来讨论这个</p><p id="2774" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有一个需要存储的学生评级枚举</p><blockquote class="jy jz ka"><p id="103a" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated">{低于，符合，高于，优秀}</p></blockquote><p id="8f76" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是在将来，我们可能想要调整它们并添加另一个条目</p><blockquote class="jy jz ka"><p id="3715" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated">{低于，低于_符合，符合，高于，优秀}</p></blockquote><p id="aec6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用顺序值是一个很大的问题，因为条目更新了，顺序值也会更新。枚举的字符串表示可能看起来是正确的方法，但是当从枚举中移除一个条目时，这将导致问题。</p><p id="f59c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自定义映射是这种情况下唯一有效的选项。为了创建自定义映射，我们实现了AttributeConverter接口，用<strong class="iw hi"> @Converter </strong>注释了该类，并实现了提供实体和数据库表示之间的映射的两个方法。</p><blockquote class="jy jz ka"><p id="12af" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated">convertToDatabaseColumn(学生等级学生等级)</p><p id="fcfd" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr ha bi translated">convertToEntityAttribute(整数ratingVal)</p></blockquote><p id="7695" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以将<strong class="iw hi"> @Converter </strong>注释的autoApply属性设置为true，以便将该转换器应用于所有实体中该类型的所有枚举。</p><p id="72eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是StudentGrade枚举的转换器代码</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="18d9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了让这个转换器与枚举一起工作，我们需要在枚举上添加以下注释</p><pre class="js jt ju jv fd mm mn mo mp aw mq bi"><span id="49b9" class="lt kg hh mn b fi mr ms l mt mu">@Convert(converter = StudentGradeConverter.class)<br/>private StudentGrade studentGrade;</span></pre><h2 id="5f65" class="lt kg hh bd kh lu lv lw kl lx ly lz kp jf ma mb kt jj mc md kx jn me mf lb mg bi translated">数据库表示</h2><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/717ef8d453686d69b054d11420e9907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*XrEilek7AKafkRcf47JL2g.png"/></div></figure><p id="bff8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，如果您需要完全控制枚举，您使用的goto选项是AttributeConverter。但是选择完全取决于您的用例。</p></div></div>    
</body>
</html>