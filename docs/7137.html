<html>
<head>
<title>Optimizing ruby-protobuf deserialization by 50%</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将ruby-protobuf反序列化优化50%</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/optimizing-ruby-protobuf-deserialization-by-50-8aa14ca330d9?source=collection_archive---------1-----------------------#2015-11-23">https://medium.com/square-corner-blog/optimizing-ruby-protobuf-deserialization-by-50-8aa14ca330d9?source=collection_archive---------1-----------------------#2015-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9e9f" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何使用ruby-prof查找代码中的热点</h2></div><p id="5403" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="jt ju ge" href="https://medium.com/u/a29cf9bf448c?source=post_page-----8aa14ca330d9--------------------------------" rel="noopener" target="_blank">撰写<em class="js">扎克瑞</em> </a> <em class="js">。</em></p><blockquote class="jv"><p id="58b6" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="01f5" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated">我在Square的一个俗称“WebScale”的团队工作，该团队负责从我们的monorail中提取遗留支付数据。我们最近的任务之一是推出新的内部服务，在Square上搜索支付。我们主要使用protobuf作为数据传输，一个单独的支付协议在序列化时大约为1，500-2，000字节，并且每个请求返回多达500条记录。</p><p id="ca72" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">新服务推出后，来自Ruby MRI 2.2.3客户端的一些请求在几个端点上从250毫秒变成了1600毫秒。我们已经有了关于花费在RPC请求上的时间的度量，所以我们猜测protobuf反序列化是罪魁祸首。</p><p id="5b37" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了验证我们的猜测，我们使用了<a class="ae kf" href="https://github.com/ruby-prof/ruby-prof" rel="noopener ugc nofollow" target="_blank"> ruby-prof </a>来分析ruby中的代码(在本例中，是<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf" rel="noopener ugc nofollow" target="_blank"> protobuf </a> gem)。RubyProf是一个分析MRI代码的有用工具，下面是我们如何使用它来查找热点。</p><p id="3d08" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的测试案例:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6f90" class="ku kv hh kq b fi kw kx l ky kz">require 'protobuf'<br/>require 'ruby-prof'</span><span id="4357" class="ku kv hh kq b fi la kx l ky kz"><em class="js"># Just so we don't get spammed when testing</em><br/>Protobuf<strong class="kq hi">.</strong>print_deprecation_warnings <strong class="kq hi">=</strong> <strong class="kq hi">false</strong></span><span id="15c0" class="ku kv hh kq b fi la kx l ky kz"><em class="js"># Construct a proto that mimics the size of our production responses</em><br/>encoded <strong class="kq hi">=</strong> RecordResponse<strong class="kq hi">.</strong>new(<br/>  payment: 500<strong class="kq hi">.</strong>times<strong class="kq hi">.</strong>map <strong class="kq hi">do</strong> <strong class="kq hi">|</strong>i<strong class="kq hi">|</strong><br/>    Record<strong class="kq hi">.</strong>new( <strong class="kq hi">.</strong>.<strong class="kq hi">.</strong>test data<strong class="kq hi">.</strong>.<strong class="kq hi">.</strong> )<br/>  <strong class="kq hi">end</strong><br/>)<strong class="kq hi">.</strong>encode</span><span id="abaa" class="ku kv hh kq b fi la kx l ky kz">result <strong class="kq hi">=</strong> RubyProf<strong class="kq hi">.</strong>profile <strong class="kq hi">do</strong><br/>  RecordResponse<strong class="kq hi">.</strong>decode(encoded)<br/><strong class="kq hi">end</strong></span><span id="5e0e" class="ku kv hh kq b fi la kx l ky kz">printer <strong class="kq hi">=</strong> RubyProf<strong class="kq hi">::</strong>FlatPrinter<strong class="kq hi">.</strong>new(result)<br/>printer<strong class="kq hi">.</strong>print(<br/>  STDOUT,<br/>  <em class="js"># Only want to focus on hotspots right now</em><br/>  min_percent: 1<br/>)</span></pre><p id="0907" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RubyProf支持多种打印报告的方式。我是用它出现在“名单第一”的<em class="js">科学方法</em>来挑选平板打印机的。为了简洁起见，我只展示了花费超过1%时间的代码。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5fd1" class="ku kv hh kq b fi kw kx l ky kz">Measure Mode: wall_time<br/>Thread ID: 70093065552380<br/>Fiber ID: 70093084071700<br/>Total: 4.599523<br/>Sort by: self_time</span><span id="d2d7" class="ku kv hh kq b fi la kx l ky kz"> %self      total      self      wait     child     calls  name<br/> 16.25      0.748     0.748     0.000     0.000  2031000   Protobuf::Enum#to_i<br/> 15.35      1.454     0.706     0.000     0.748    30000   Array#select<br/>  7.30      0.745     0.336     0.000     0.410   140000   &lt;Class::Protobuf::Decoder&gt;#read_varint<br/>  3.44      0.176     0.158     0.000     0.018    94000   Kernel#respond_to?<br/>  3.32      1.156     0.152     0.000     1.003    72000   &lt;Class::Protobuf::Decoder&gt;#read_field<br/>  2.44      0.508     0.112     0.000     0.396    72000   &lt;Class::Protobuf::Decoder&gt;#read_key<br/>  2.26      0.298     0.104     0.000     0.194    72000   Protobuf::Message::Fields::ClassMethods#get_field<br/>  2.00      0.159     0.092     0.000     0.067   166500   IO::generic_readable#readbyte<br/>  1.76      0.124     0.081     0.000     0.043   171500   Numeric#nonzero?<br/>  1.66      0.076     0.076     0.000     0.000   410500   Fixnum#&amp;<br/>  1.58      0.073     0.073     0.000     0.000   144000   Protobuf::Field::BaseField#repeated?<br/>  1.48      0.068     0.068     0.000     0.000    69000   Protobuf::Field::BaseField#setter<br/>  1.46      0.067     0.067     0.000     0.000   166500   StringIO#getbyte<br/>  1.19      0.055     0.055     0.000     0.000     1500   Kernel#caller<br/>  1.17      0.054     0.054     0.000     0.000    72000   Protobuf::Message::Fields::ClassMethods#field_store<br/>  1.05      0.087     0.048     0.000     0.039    72000   Protobuf::Field::BaseField#packed?<br/>  1.00      0.137     0.046     0.000     0.091    36003   Class#new</span></pre><p id="0dbc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">继续我们“列表第一”的科学方法，我们将深入研究<a class="ae kf" href="https://raw.githubusercontent.com/ruby-protobuf/protobuf/4cbb1f7cb98bb5a63875f4fc0cdf0c8109feffa7/lib/protobuf/enum.rb" rel="noopener ugc nofollow" target="_blank"> Protobuf::Enum </a>。在那个类中有一些to_i的用法，但是最突出的一个是:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="1f00" class="ku kv hh kq b fi kw kx l ky kz"><em class="js"># Public: Get an array of Enum objects with the given tag.</em><br/><em class="js">#</em><br/><em class="js"># tag - An object that responds to to_i.</em><br/><em class="js">#</em><br/><em class="js"># Examples</em><br/><em class="js">#</em><br/><em class="js">#   class StateMachine &lt; ::Protobuf::Enum</em><br/><em class="js">#     set_option :allow_alias</em><br/><em class="js">#     define :ON, 1</em><br/><em class="js">#     define :STARTED, 1</em><br/><em class="js">#     define :OFF, 2</em><br/><em class="js">#   end</em><br/><em class="js">#</em><br/><em class="js">#   StateMachine.enums_for_tag(1) #=&gt; [ #&lt;StateMachine::ON=1&gt;, #&lt;StateMachine::STARTED=1&gt; ]</em><br/><em class="js">#   StateMachine.enums_for_tag(2) #=&gt; [ #&lt;StateMachine::OFF=2&gt; ]</em><br/><em class="js">#</em><br/><em class="js"># Returns an array with zero or more Enum objects or nil.</em><br/><em class="js">#</em><br/><strong class="kq hi">def</strong> <strong class="kq hi">self.enums_for_tag</strong>(tag)<br/>  enums<strong class="kq hi">.</strong>select <strong class="kq hi">do</strong> <strong class="kq hi">|</strong>enum<strong class="kq hi">|</strong><br/>    enum<strong class="kq hi">.</strong>to_i <strong class="kq hi">==</strong> tag<strong class="kq hi">.</strong>to_i<br/>  <strong class="kq hi">end</strong><br/><strong class="kq hi">end</strong></span></pre><p id="a6bc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码中有关于该方法如何工作的很好的文档，这对我们来说很容易。我们在protos中使用了很多Enum，环顾一下<a class="ae kf" href="https://raw.githubusercontent.com/ruby-protobuf/protobuf/4cbb1f7cb98bb5a63875f4fc0cdf0c8109feffa7/lib/protobuf/enum.rb" rel="noopener ugc nofollow" target="_blank"> Protobuf::Enum </a>类，很明显enum_for_tag被频繁调用(在Enum _ for _ tag和fetch中)。看看all_tags和values方法，我们知道缓存枚举数据是安全的。在这种情况下，它是O(n) - &gt; O(1)的一个简单优化。我们只能映射int - &gt;枚举，因为你可以<a class="ae kf" href="https://developers.google.com/protocol-buffers/docs/proto?hl=en#enum" rel="noopener ugc nofollow" target="_blank">别名枚举</a>。不过，这种情况下没问题。</p><p id="0c42" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完整的改动在最后，但要点是:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3943" class="ku kv hh kq b fi kw kx l ky kz"><strong class="kq hi">def</strong> <strong class="kq hi">self.mapped_enums</strong><br/>  @mapped_enums <strong class="kq hi">||=</strong> enums<strong class="kq hi">.</strong>each_with_object({}) <strong class="kq hi">do</strong> <strong class="kq hi">|</strong>enum, hash<strong class="kq hi">|</strong><br/>    list <strong class="kq hi">=</strong> hash<strong class="kq hi">[</strong>enum<strong class="kq hi">.</strong>to_i<strong class="kq hi">]</strong> <strong class="kq hi">||=</strong> <strong class="kq hi">[]</strong><br/>    list <strong class="kq hi">&lt;&lt;</strong> enum<br/>  <strong class="kq hi">end</strong><br/><strong class="kq hi">end</strong></span><span id="0185" class="ku kv hh kq b fi la kx l ky kz"><strong class="kq hi">def</strong> <strong class="kq hi">self.enums_for_tag</strong>(tag)<br/>  mapped_enums<strong class="kq hi">[</strong>tag<strong class="kq hi">.</strong>to_i<strong class="kq hi">]</strong> <strong class="kq hi">||</strong> <strong class="kq hi">[]</strong><br/><strong class="kq hi">end</strong></span></pre><p id="47b5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后在RubyProf中重新运行它</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="ffed" class="ku kv hh kq b fi kw kx l ky kz">Measure Mode: wall_time<br/>Thread ID: 70271059223040<br/>Fiber ID: 70271070182440<br/>Total: 3.308983<br/>Sort by: self_time</span><span id="1c9a" class="ku kv hh kq b fi la kx l ky kz"> %self      total      self      wait     child     calls  name<br/> 10.16      0.736     0.336     0.000     0.400   140000   &lt;Class::Protobuf::Decoder&gt;#read_varint<br/>  4.92      0.182     0.163     0.000     0.019    94000   Kernel#respond_to?<br/>  4.62      1.148     0.153     0.000     0.995    72000   &lt;Class::Protobuf::Decoder&gt;#read_field<br/>  3.33      0.501     0.110     0.000     0.391    72000   &lt;Class::Protobuf::Decoder&gt;#read_key<br/>  3.25      0.308     0.108     0.000     0.201    72000   Protobuf::Message::Fields::ClassMethods#get_field<br/>  2.70      0.156     0.089     0.000     0.066   166500   IO::generic_readable#readbyte<br/>  2.37      0.078     0.078     0.000     0.000   410500   Fixnum#&amp;<br/>  2.34      0.119     0.077     0.000     0.042   171500   Numeric#nonzero?</span></pre><p id="71a6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好多了！RubyProf中列出的总时间是精确的节省百分比(~25%)，但是总时间更高，因为RubyProf挂钩到Ruby来分析所有的东西。没有RubyProf，我们看到来自Ruby MRI 2.2.3客户端的请求从1，000毫秒下降到大约750毫秒。</p><p id="9731" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于750毫秒仍然太长，我们将看看下一个最慢的调用点<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/blob/58ca57e2aac6d5f9860e64534d5ef2d23c934ed2/lib/protobuf/decoder.rb" rel="noopener ugc nofollow" target="_blank"> Protobuf::Decoder </a>和read_varint方法。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2d48" class="ku kv hh kq b fi kw kx l ky kz"><em class="js"># Read varint integer value from +stream+.</em><br/><strong class="kq hi">def</strong> <strong class="kq hi">self.read_varint</strong>(stream)<br/>  value <strong class="kq hi">=</strong> index <strong class="kq hi">=</strong> 0<br/>  <strong class="kq hi">begin</strong><br/>    byte <strong class="kq hi">=</strong> stream<strong class="kq hi">.</strong>readbyte<br/>    value <strong class="kq hi">|=</strong> (byte <strong class="kq hi">&amp;</strong> 0x7f) <strong class="kq hi">&lt;&lt;</strong> (7 <strong class="kq hi">*</strong> index)<br/>    index <strong class="kq hi">+=</strong> 1<br/>  <strong class="kq hi">end</strong> <strong class="kq hi">while</strong> (byte <strong class="kq hi">&amp;</strong> 0x80)<strong class="kq hi">.</strong>nonzero?<br/>  value<br/><strong class="kq hi">end</strong></span></pre><p id="df84" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码足够简单，任何优化都是微不足道的。Ruby对于我们正在进行的调用量来说太慢了，这使得它成为用c重写该方法的候选对象。事实证明，ruby-protocol-buffers gem(与我们使用的ruby protobuf gem不同)的作者发布了一个名为<a class="ae kf" href="https://github.com/liquidm/varint/blob/master/ext/varint/varint.c" rel="noopener ugc nofollow" target="_blank"> varint </a>的gem，它正是我们所需要的。</p><p id="04b5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常，我不喜欢用C语言替换Ruby，尤其是从库中。不能保证C和Ruby代码会以同样的方式运行，调试和维护都更加困难。因为它已经被另一个gem使用，而且代码是独立的，所以我试了一下。</p><p id="c33c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在测试用例中添加了一个简单的monkeypatch:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="f7e6" class="ku kv hh kq b fi kw kx l ky kz"><strong class="kq hi">module</strong> Protobuf<br/>  <strong class="kq hi">class</strong> <strong class="kq hi">FastVarint</strong><br/>    <strong class="kq hi">extend</strong> <strong class="kq hi">::</strong>Varint<br/>  <strong class="kq hi">end</strong></span><span id="0b86" class="ku kv hh kq b fi la kx l ky kz">  <strong class="kq hi">class</strong> <strong class="kq hi">Decoder</strong><br/>    <strong class="kq hi">def</strong> <strong class="kq hi">self.read_varint</strong>(stream)<br/>      FastVarint<strong class="kq hi">.</strong>decode(stream)<br/>    <strong class="kq hi">end</strong><br/>  <strong class="kq hi">end</strong><br/><strong class="kq hi">end</strong></span></pre><p id="a975" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">重新运行RubyProf</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="f23d" class="ku kv hh kq b fi kw kx l ky kz">Measure Mode: wall_time<br/>Thread ID: 70126242488840<br/>Fiber ID: 70126246561280<br/>Total: 2.722766<br/>Sort by: self_time</span><span id="a816" class="ku kv hh kq b fi la kx l ky kz"> %self      total      self      wait     child     calls  name<br/>  5.65      0.676     0.154     0.000     0.522    72000   &lt;Class::Protobuf::Decoder&gt;#read_field<br/>  5.64      0.172     0.154     0.000     0.018    94000   Kernel#respond_to?<br/>  4.55      0.283     0.124     0.000     0.159    72000   &lt;Class::Protobuf::Decoder&gt;#read_key<br/>  4.04      0.302     0.110     0.000     0.192    72000   Protobuf::Message::Fields::ClassMethods#get_field<br/>  3.48      0.250     0.095     0.000     0.156   140000   &lt;Class::Protobuf::Decoder&gt;#read_varint<br/>  3.13      0.156     0.085     0.000     0.070   140000   Varint#decode<br/>  2.86      0.078     0.078     0.000     0.000   144000   Protobuf::Field::BaseField#repeated?<br/>  2.58      0.070     0.070     0.000     0.000   166500   StringIO#getbyte<br/>  2.49      0.068     0.068     0.000     0.000    69000   Protobuf::Field::BaseField#setter<br/>  2.10      0.058     0.057     0.000     0.000     1500   Kernel#caller</span></pre><p id="eefb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过公然作弊，让C来做，我们得到了18%的优化。即使有了这些改进，我们的解码时间仍然在600毫秒左右。</p><p id="f56f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">继续，我们再来看看<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/blob/58ca57e2aac6d5f9860e64534d5ef2d23c934ed2/lib/protobuf/decoder.rb" rel="noopener ugc nofollow" target="_blank"> Protobuf::Decoder </a>。不幸的是，read_field和read_key方法对我们来说太简单了，无法实现真正的优化。内核# respond _ to？为了安全起见，在太多的地方使用了，比如如果to_i不存在就返回nil，而不是error。</p><p id="1e01" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这实际上只给我们留下了<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/blob/71fd6ae9185c53764dd665da7e45e8fbb73853da/lib/protobuf/message/fields.rb" rel="noopener ugc nofollow" target="_blank">proto buf::Message::Fields::class methods</a>，除非我们想优化50个调用点，每个优化几毫秒。查看get_field，我们看到:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="84ec" class="ku kv hh kq b fi kw kx l ky kz"><strong class="kq hi">def</strong> <strong class="kq hi">get_field</strong>(name_or_tag, allow_extension <strong class="kq hi">=</strong> <strong class="kq hi">false</strong>)<br/>  name_or_tag <strong class="kq hi">=</strong> name_or_tag<strong class="kq hi">.</strong>to_sym <strong class="kq hi">if</strong> name_or_tag<strong class="kq hi">.</strong>respond_to?(:to_sym)<br/>  field <strong class="kq hi">=</strong> field_store<strong class="kq hi">[</strong>name_or_tag<strong class="kq hi">]</strong></span><span id="461a" class="ku kv hh kq b fi la kx l ky kz">  <strong class="kq hi">if</strong> field <strong class="kq hi">&amp;&amp;</strong> (allow_extension <strong class="kq hi">||</strong> <strong class="kq hi">!</strong>field<strong class="kq hi">.</strong>extension?)<br/>    field<br/>  <strong class="kq hi">else</strong><br/>    <strong class="kq hi">nil</strong><br/>  <strong class="kq hi">end</strong><br/><strong class="kq hi">end</strong></span></pre><p id="6209" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看上面的RubyProf跟踪，我们已经知道respond_to？总共被调用了94000次。在添加了一些调试来统计调用数之后，结果是get_field占了72，000 (75%)个要响应的调用？，而且它只调用_ sym 2,000次。基本上，只有2.7%的人回复了？调用会导致。</p><p id="2c11" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">而不是调用respond_to？而to_sym，我们可以缓存一个string field -&gt; field的映射，使之成为两个O(1)查找。get_field方法如下所示:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="0450" class="ku kv hh kq b fi kw kx l ky kz"><strong class="kq hi">def</strong> <strong class="kq hi">get_field</strong>(name_or_tag, allow_extension <strong class="kq hi">=</strong> <strong class="kq hi">false</strong>)<br/>  field <strong class="kq hi">=</strong> field_store<strong class="kq hi">[</strong>name_or_tag<strong class="kq hi">]</strong> <strong class="kq hi">||</strong> str_field_store<strong class="kq hi">[</strong>name_or_tag<strong class="kq hi">]</strong></span><span id="25b1" class="ku kv hh kq b fi la kx l ky kz">  <strong class="kq hi">if</strong> field <strong class="kq hi">&amp;&amp;</strong> (allow_extension <strong class="kq hi">||</strong> <strong class="kq hi">!</strong>field<strong class="kq hi">.</strong>extension?)<br/>    field<br/>  <strong class="kq hi">else</strong><br/>    <strong class="kq hi">nil</strong><br/>  <strong class="kq hi">end</strong><br/><strong class="kq hi">end</strong></span></pre><p id="039a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RubyProf的最后一次重播</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="44ba" class="ku kv hh kq b fi kw kx l ky kz">Measure Mode: wall_time<br/>Thread ID: 70107917574660<br/>Fiber ID: 70107924939720<br/>Total: 2.428846<br/>Sort by: self_time</span><span id="7fcd" class="ku kv hh kq b fi la kx l ky kz"> %self      total      self      wait     child     calls  name<br/>  6.12      0.666     0.155     0.000     0.511    72000   &lt;Class::Protobuf::Decoder&gt;#read_field<br/>  4.70      0.277     0.119     0.000     0.158    72000   &lt;Class::Protobuf::Decoder&gt;#read_key<br/>  3.70      0.248     0.094     0.000     0.154   140000   &lt;Class::Protobuf::Decoder&gt;#read_varint<br/>  3.39      0.132     0.086     0.000     0.046    72000   Protobuf::Message::Fields::ClassMethods#get_field<br/>  3.39      0.154     0.086     0.000     0.068   140000   Varint#decode<br/>  2.96      0.075     0.075     0.000     0.000   144000   Protobuf::Field::BaseField#repeated?<br/>  2.70      0.068     0.068     0.000     0.000   166500   StringIO#getbyte<br/>  2.60      0.066     0.066     0.000     0.000    69000   Protobuf::Field::BaseField#setter</span></pre><p id="0757" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这又给了我们12%的提升，内核# respond _ to？被降到了2.2万次(1.29%的自己%)。总的来说，我们优化了50%的反序列化，而且只花了RubyProf几个小时的调查。</p><p id="0506" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RubyProf是一个很棒的工具，你可以使用GraphPrinter或CallTreePrinter获得更多细节，它们可以与<a class="ae kf" href="http://kcachegrind.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> KCachegrind </a>一起使用。对于我们的例子来说，FlatPrinter很简单，代码很容易跟踪，可以缩小优化的范围。RubyProf中各种打印机的例子可以在repo 上的<a class="ae kf" href="https://github.com/ruby-prof/ruby-prof/tree/master/examples" rel="noopener ugc nofollow" target="_blank">中找到。</a></p><p id="e628" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将所有的变更上传到了proto buf gem中。您可以看到在<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/pull/269" rel="noopener ugc nofollow" target="_blank">变量</a>、<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/pull/267" rel="noopener ugc nofollow" target="_blank">获取_字段/获取_扩展_字段</a>和<a class="ae kf" href="https://github.com/ruby-protobuf/protobuf/pull/264" rel="noopener ugc nofollow" target="_blank">枚举</a>优化PRs中所做的确切更改。如果您使用protobuf gem，安装了<a class="ae kf" href="https://rubygems.org/gems/varint" rel="noopener ugc nofollow" target="_blank"> varint </a> gem(仅MRI)的v3.5.5和更高版本将为您提供全套优化。</p><p id="d829" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将来，我们会考虑迁移到<a class="ae kf" href="https://github.com/google/protobuf/tree/master/ruby" rel="noopener ugc nofollow" target="_blank"> protobuf3 </a>。Ruby gem在alpha中，但是它是基于Google的第一方<a class="ae kf" href="https://github.com/google/protobuf" rel="noopener ugc nofollow" target="_blank"> C++ </a>库构建的。在上述优化的基准测试中，谷歌的实现比ruby-protobuf快了7倍。</p></div><div class="ab cl lb lc go ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ha hb hc hd he"><div class="kl km kn ko fd li"><a href="https://twitter.com/zachanker" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab dw"><div class="lk ab ll cl cj lm"><h2 class="bd hi fi z dy ln ea eb lo ed ef hg bi translated">扎卡里·安克尔(@zachanker) |推特</h2><div class="lp l"><h3 class="bd b fi z dy ln ea eb lo ed ef dx translated">Zachary Anker的最新推文(@zachanker)。广场的工程师。旧金山</h3></div><div class="lq l"><p class="bd b fp z dy ln ea eb lo ed ef dx translated">twitter.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw lx li"/></div></div></a></div></div></div>    
</body>
</html>