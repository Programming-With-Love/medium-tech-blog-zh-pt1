<html>
<head>
<title>Policy Enabled Kubernetes with Open Policy Agent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用开放策略代理启用策略的Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203?source=collection_archive---------0-----------------------#2018-12-06">https://medium.com/capital-one-tech/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203?source=collection_archive---------0-----------------------#2018-12-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a337" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">利用云计算和开发运维解决常见问题</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/274dfeb0c7edbb6083570858b245393e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcxbOfUbgpJYMeO2USYcPQ.png"/></div></div></figure><p id="5713" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">迁移到公共云在很大程度上是为了解决所有应用程序团队共同关心的“基础架构供应”问题。云帮助组织极大地减少了对“<a class="ae ke" href="https://www.cio.co.nz/article/466635/amazon_cto_stop_spending_money_undifferentiated_heavy_lifting_/" rel="noopener ugc nofollow" target="_blank">无差别的繁重工作</a>”的需求，即交付应用程序和功能所需的直立服务器、网络和安全性。迁移到容器和Kubernetes可以被看作是下一次发展，允许开发团队专注于他们的工作，而不是基础设施。</p><p id="42d3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">解决这些共同需求也是DevOps持续旅程的一大部分。事实上，DevOps完全是为了减少可变性和人为错误，提高可重复性，并实施由策略支持的实践，以可靠和高效地交付应用程序和功能。这在Kubernetes都很重要。而且，我们知道，通过云计算和开发运维解决功能团队的常见问题，可以让应用团队更快地交付，让业务更快地发展。</p><h1 id="1b24" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">常见的应用问题</h1><p id="42f1" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">当我们采用现代方法来提供基础设施时，我们也使用模式来解决构建应用程序和交付服务和API的常见问题。就像十年前<a class="ae ke" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向方面编程(AOP) </a>通过满足<a class="ae ke" href="https://en.wikipedia.org/wiki/Cross-cutting_concern" rel="noopener ugc nofollow" target="_blank">横切关注点</a>所做的一样，我们正在通过采用模式来解决现代应用程序的设计和构建，例如<a class="ae ke" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">12因素</a>方法。策略支持也是一个常见问题，我们可以利用它来更好地管理应用程序及其相关环境。</p><h1 id="f094" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">什么是政策？</h1><p id="a5a8" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">如<a class="ae ke" href="http://www.openpolicyagent.org/docs/" rel="noopener ugc nofollow" target="_blank">开放策略代理文档网站</a>所示:</p><blockquote class="lc ld le"><p id="d99f" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated">“所有组织都有政策。策略对于组织的长期成功至关重要，因为它们编码了关于如何遵守法律要求、在技术限制内工作、避免重复错误等的重要知识。</p><p id="70a2" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated">最简单的形式是，策略可以基于写下的规则或未言明但渗透到组织文化中的约定来手动应用。策略也可以通过应用程序逻辑来实施，或者在部署时静态配置。"</p></blockquote><p id="83dd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">简而言之，策略是我们交付应用和基础设施的界限。这些界限决定了我们的可交付成果的验收标准，以及我们对完成的定义。衡量我们的部分标准是我们满足这些政策要求的程度，以及我们在客户使用我们的解决方案时如何有效地让他们遵守政策。</p><h1 id="d960" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">满足常见问题的自动化策略</h1><p id="6bc9" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">成功的DevOps公式的一部分是确保我们在推动计算环境的变化时遵循内部政策和程序。并非所有的策略实施都是通过自动化开发运维管道完成的。例如，像<a class="ae ke" href="https://www.capitalone.io/" rel="noopener ugc nofollow" target="_blank">云保管人</a>(开源规则引擎)这样的工具被用于自动化策略的实施，以维护管理良好且安全的云。这些政策旨在为云的使用设置护栏，而不会对云用户产生负面影响。</p><h1 id="1782" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">通用策略启用的情况</h1><p id="27f3" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">对于其他应用程序设置，应考虑通过云托管或类似工具实施的自动化策略实施类型。在规定的策略内执行是云原生应用程序的一个常见问题。<a class="ae ke" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理(OPA) </a>是一种通用的策略启用方法。</p><p id="ff15" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">根据文档，开放策略代理(OPA)是:</p><blockquote class="lc ld le"><p id="3986" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated">“…一个轻量级通用策略引擎，可以与您的服务放在同一位置。您可以将OPA集成为sidecar、主机级守护进程或库。</p><p id="d8b4" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated">服务通过执行查询将策略决策卸载给OPA。OPA评估策略和数据以产生查询结果(这些结果被发送回客户端)。策略是用高级声明性语言编写的，可以通过文件系统或定义良好的API加载到OPA中。"</p></blockquote><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/dadadd903bca61a438f885642d45c2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XcxuiEEDYv4WMPgTLx1DQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">OPA handles the heavy-lifting of policy decisions, and removes the need for custom programming in each application/service. Image Source: openpolicyagent.org</figcaption></figure><h1 id="3610" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">在Kubernetes中实现准入控制策略</h1><p id="8353" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">随着我们转向容器和容器编排平台，还需要自动化的策略执行。作为我们企业Kubernetes平台团队的技术主管，我一直在研究和开发集群中管理策略的模式。</p><p id="2f94" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Kubernetes中的一个策略控制点是<a class="ae ke" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制</a>。使用Kubernetes准入控制器，我们可以在相关对象(提供所需集群状态的意图)被持久存储到<a class="ae ke" href="https://coreos.com/etcd/" rel="noopener ugc nofollow" target="_blank"> etcd </a>键/值对象存储之前，拦截对Kubernetes API服务器的请求。</p><blockquote class="lc ld le"><p id="8f93" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated">我研究过的模式可以在这里<a class="ae ke" href="https://www.openpolicyagent.org/docs/kubernetes-admission-control.html" rel="noopener ugc nofollow" target="_blank">找到</a>，它的同伴GitHub repos <a class="ae ke" href="https://github.com/open-policy-agent/opa" rel="noopener ugc nofollow" target="_blank">在这里</a>和<a class="ae ke" href="https://github.com/open-policy-agent/kube-mgmt" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></blockquote><h1 id="92f6" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">实现Kubernetes部署许可控制器</h1><p id="d74e" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">(我将关注的OPA用例是控制容器图像的来源，作为Kubernetes部署清单的一部分。)</p><p id="db9f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为良好治理和法规遵从性立场的一部分，理解、指导甚至控制Kubernetes工作负载的映像源非常重要。通过OPA和Kubernetes验证准入控制器，事件驱动和动态配置的基于自动化策略的决策可以防止不需要的映像部署到您的集群中。在这个解决方案中，<code class="du lo lp lq lr b">opa</code>服务连接到Kubernetes <code class="du lo lp lq lr b">ValidatingAdmissionWebhook</code>，并监听来自Kubernetes API服务器的部署<code class="du lo lp lq lr b">CREATE</code>和<code class="du lo lp lq lr b">UPDATE</code>事件。</p><p id="b498" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">该解决方案包括创建一个由以下对象组成的Kubernetes对象图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ls"><img src="../Images/906978d64bcbd3de382e95b3df41ecb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gdLJSnqsdS1y1sFen5VGw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">OPA Solution Kubernetes Object Graph</figcaption></figure><p id="4b87" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在一般操作中，OPA服务器是一个RESTful服务器，它公开服务来产生和使用事件数据和策略。由于OPA是与域无关的，任何数据都可以发送到OPA服务器，由任何策略进行评估，只要策略与传入的事件数据相匹配。</p><p id="ec60" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我的示例解决方案中，OPA策略作为Kubernetes ConfigMap资源存储在<code class="du lo lp lq lr b">opa</code>名称空间中。策略被称为<code class="du lo lp lq lr b">kube-mgmt</code>的sidecar工作负载存储在<code class="du lo lp lq lr b">opa</code>容器中。<code class="du lo lp lq lr b">kube-mgmt</code>读取应用于<code class="du lo lp lq lr b">opa</code>名称空间的配置映射，并编译它们以验证正确的语法。</p><p id="8c68" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">编译成功后，策略由<code class="du lo lp lq lr b">kube-mgmt</code>存储在<code class="du lo lp lq lr b">opa</code>容器中。此外，<code class="du lo lp lq lr b">kube-mgmt</code>被配置为在事件不包含评估策略中定义的逻辑所需的所有数据的情况下，定期提取<code class="du lo lp lq lr b">opa</code>服务可能需要的资源元数据，以正确评估API服务器事件。<code class="du lo lp lq lr b">kube-mgmt</code>扫描的资源是用Kubernetes部署清单中的容器规范参数配置的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lt"><img src="../Images/ae84900cea8ad7e02ff9a2aa875977cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3m8hVgADxLIdsUwxmBsiLA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">opa and kube-mgmt workloads in opa pod</figcaption></figure><h1 id="7d09" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">逐步准备OPA工件</h1><p id="5b46" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">首先，我们为解决方案应用名称空间和授权资源，如下所示。<code class="du lo lp lq lr b">opa</code> ServiceAccount使用<code class="du lo lp lq lr b">opa</code> ClusterRoleBinding绑定到<code class="du lo lp lq lr b">opa</code> ClusterRole，以访问其中包含的权限。</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="bf1f" class="ly kg hh lr b fi lz ma l mb mc">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: opa<br/>  labels:<br/>    app: opa<br/>---<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: opa<br/>  namespace: opa<br/>  labels:<br/>    app: opa<br/>---<br/>kind: ClusterRole<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/>  name: opa<br/>  labels:<br/>    app: opa<br/>rules:<br/>  - apiGroups: [""]<br/>    resources:<br/>      - namespaces<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups: ["extensions"]<br/>    resources:<br/>      - ingresses<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups: ["apps"]<br/>    resources:<br/>      - deployments<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups: [""]<br/>    resources:<br/>      - configmaps<br/>    verbs:<br/>      - get<br/>      - list<br/>      - patch<br/>      - watch<br/>---<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: opa<br/>  labels:<br/>    app: opa<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: opa<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: opa<br/>  namespace: opa</span></pre><p id="8511" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，我们构建OPA秘密和服务器配置文件，并将<code class="du lo lp lq lr b">opa-server</code>秘密应用于<code class="du lo lp lq lr b">opa</code>名称空间:</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="c041" class="ly kg hh lr b fi lz ma l mb mc">openssl genrsa -out ca.key 2048</span><span id="f015" class="ly kg hh lr b fi md ma l mb mc">openssl req -x509 -new -nodes -key ca.key -days 100000 -out ca.crt -subj "/CN=admission_ca"</span><span id="d7c0" class="ly kg hh lr b fi md ma l mb mc">cat &gt;server.conf &lt;&lt;EOF<br/>[req]<br/>req_extensions = v3_req<br/>distinguished_name = req_distinguished_name<br/>[req_distinguished_name]<br/>[ v3_req ]<br/>basicConstraints = CA:FALSE<br/>keyUsage = nonRepudiation, digitalSignature, keyEncipherment<br/>extendedKeyUsage = clientAuth, serverAuth<br/>EOF</span><span id="914c" class="ly kg hh lr b fi md ma l mb mc">openssl genrsa -out server.key 2048</span><span id="4e1f" class="ly kg hh lr b fi md ma l mb mc">openssl req -new -key server.key -out server.csr -subj "/CN=opa.opa.svc" -config server.conf</span><span id="c41f" class="ly kg hh lr b fi md ma l mb mc">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 100000 -extensions v3_req -extfile server.conf</span><span id="21cf" class="ly kg hh lr b fi md ma l mb mc">kubectl create secret tls opa-server --cert=server.crt --key=server.key</span></pre><p id="2ef3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，我们使用以下命令部署OPA解决方案容器、服务和默认策略配置图:<code class="du lo lp lq lr b">kubectl apply -f admission-controller.yaml</code></p><p id="f4ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面可以看到YAML:</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="2da7" class="ly kg hh lr b fi lz ma l mb mc">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: opa<br/>  namespace: opa<br/>  labels:<br/>    app: opa<br/>spec:<br/>  selector:<br/>    app: opa<br/>  ports:<br/>  - name: https<br/>    protocol: TCP<br/>    port: 443<br/>    targetPort: 443<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: opa<br/>  name: opa<br/>  namespace: opa<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: opa<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: opa<br/>      name: opa<br/>    spec:<br/>      serviceAccountName: opa<br/>      containers:<br/>        - name: opa<br/>          image: &lt;REGISTRY&gt;/&lt;REGISTRY_NAMESPACE&gt;/openpolicyagent-opa:0.9.1<br/>          resources:<br/>            limits:<br/>              cpu: 500m<br/>              memory: 512Mi<br/>            requests:<br/>              cpu: 500m<br/>              memory: 512Mi<br/>          args:<br/>            - "run"<br/>            - "--server"<br/>            - "--tls-cert-file=/certs/tls.crt"<br/>            - "--tls-private-key-file=/certs/tls.key"<br/>            - "--addr=0.0.0.0:443"<br/>            - "--insecure-addr=127.0.0.1:8181"<br/>          volumeMounts:<br/>            - readOnly: true<br/>              mountPath: /certs<br/>              name: opa-server<br/>        - name: kube-mgmt<br/>          image: &lt;REGISTRY&gt;/&lt;REGISTRY_NAMESPACE&gt;/openpolicyagent-kube-mgmt:0.7<br/>          resources:<br/>            limits:<br/>              cpu: 500m<br/>              memory: 512Mi<br/>            requests:<br/>              cpu: 500m<br/>              memory: 512Mi<br/>          args:<br/>            - "--replicate-cluster=v1/namespaces"<br/>            - "--replicate=extensions/v1beta1/ingresses"<br/>            - "--replicate=apps/v1/deployments"<br/>      volumes:<br/>        - name: opa-server<br/>          secret:<br/>            secretName: opa-server<br/>---<br/>kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: opa-default-system-main<br/>  namespace: opa<br/>  labels:<br/>    app: opa<br/>data:<br/>  main: |<br/>    package system</span><span id="c580" class="ly kg hh lr b fi md ma l mb mc">import data.kubernetes.admission</span><span id="ceeb" class="ly kg hh lr b fi md ma l mb mc">main = {<br/>      "apiVersion": "admission.k8s.io/v1beta1",<br/>      "kind": "AdmissionReview",<br/>      "response": response,<br/>    }</span><span id="749b" class="ly kg hh lr b fi md ma l mb mc">default response = {"allowed": true}</span><span id="77c1" class="ly kg hh lr b fi md ma l mb mc">response = {<br/>        "allowed": false,<br/>        "status": {<br/>            "reason": reason,<br/>        },<br/>    } {<br/>        reason = concat(", ", admission.deny)<br/>        reason != ""<br/>    }</span></pre><p id="9afa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此YAML的最后一部分应用包含主OPA策略和默认响应的ConfigMap。该策略用作策略评估的入口点，如果策略与入站数据不匹配，则返回<code class="du lo lp lq lr b">allowed:true</code>。</p><h1 id="672c" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">准入控制器Webhook</h1><p id="25bb" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">OPA准入控制器是一个验证准入控制器，作为服务器<a class="ae ke" href="https://en.wikipedia.org/wiki/Webhook" rel="noopener ugc nofollow" target="_blank"> webhook </a>工作。当向Kubernetes API服务器发出请求以创建一个受策略准入控制的对象(比如一个部署资源)时，webhook触发，<code class="du lo lp lq lr b">opa</code>和<code class="du lo lp lq lr b">kube-mgmt</code>容器协同工作，用策略评估API服务器事件和资源数据，以执行准入审查。</p><p id="fb6f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如下所示，YAML设置webhook来监听Kubernetes API服务器<code class="du lo lp lq lr b">CREATE</code>和<code class="du lo lp lq lr b">UPDATE</code>事件，以获取包含的资源列表，而不考虑API组或API版本。YAML文件底部的<code class="du lo lp lq lr b">namespaceSelector</code>允许我们从这个验证解决方案中排除某些敏感的名称空间。</p><p id="4fbe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们<code class="du lo lp lq lr b">base64</code>对来自之前<a class="ae ke" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>操作的<code class="du lo lp lq lr b">ca.crt</code>文件进行编码，并将其添加到<code class="du lo lp lq lr b">webhook-configuration.yaml</code>中。这将允许webhook安全地与<code class="du lo lp lq lr b">opa</code>服务进行通信。</p><blockquote class="lc ld le"><p id="f76b" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>与大多数集中管理的Kubernetes秘密不同，OPA秘密只在webhook和<code class="du lo lp lq lr b">opa</code>服务之间使用。因此，这些秘密是等幂的，并且与集群秘密和CA解耦，并且可以根据需要重新生成以重新配置OPA解决方案。</p></blockquote><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="b548" class="ly kg hh lr b fi lz ma l mb mc">kind: ValidatingWebhookConfiguration<br/>apiVersion: admissionregistration.k8s.io/v1beta1<br/>metadata:<br/>  name: opa-validating-webhook<br/>  namespace: opa<br/>  labels:<br/>    app: opa<br/>webhooks:<br/>  - name: validating-webhook.openpolicyagent.org<br/>    rules:<br/>      - operations: ["CREATE", "UPDATE"]<br/>        apiGroups: ["*"]<br/>        apiVersions: ["*"]<br/>        resources:<br/>          - pods<br/>          - services<br/>          - replicasets<br/>          - deployments<br/>          - daemonsets<br/>          - cronjobs<br/>          - jobs<br/>          - ingresses<br/>          - roles<br/>          - statefulsets<br/>          - podtemplates<br/>          - configmaps<br/>          - secrets<br/>    clientConfig:<br/>      caBundle: ${base64 ca.crt}<br/>      service:<br/>        namespace: opa<br/>        name: opa<br/>    namespaceSelector:<br/>      matchExpressions:<br/>      - {key: opa-webhook, operator: NotIn, values: [ignore]}</span></pre><p id="5b0a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在clientConfig部分，引用了<code class="du lo lp lq lr b">opa</code>名称空间和服务。<code class="du lo lp lq lr b">CREATE</code>和<code class="du lo lp lq lr b">UPDATE</code>操作将导致这个webhook触发。</p><h1 id="0d9d" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">减压阀:农产品加工政策语言</h1><p id="36c1" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">减压阀是OPA的本地查询语言。它类似于Datalog，但也支持结构化文档，如YAML和JSON。OPA用来审查资源的策略是在减压阀编写的，通常保存为<code class="du lo lp lq lr b">*.rego</code>文件。</p><p id="2243" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是<code class="du lo lp lq lr b">deployment_create_whitelist.rego</code>，它创建了一个可接受的注册中心的白名单，这将是Kubernetes部署规范中图像属性的一部分。<code class="du lo lp lq lr b">deny[msg]</code>块是这个策略的入口点，它从API服务器事件中提取数据。</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="c50e" class="ly kg hh lr b fi lz ma l mb mc">package kubernetes.admission  <br/>  <br/>import data.kubernetes.namespaces  <br/>  <br/>deny[msg] {  <br/>    input.request.kind.kind = "Deployment"  <br/>    input.request.operation = "CREATE"  <br/>    registry = input.request.object.spec.template.spec.containers[_].image  <br/>    name = input.request.object.metadata.name  <br/>    namespace = input.request.object.metadata.namespace  <br/>    not reg_matches_any(registry,valid_deployment_registries)  <br/>    msg = sprintf("invalid deployment, namespace=%q, name=%q, registry=%q", [namespace,name,registry])  <br/>}  <br/>  <br/>valid_deployment_registries = {registry |  <br/>    whitelist = "&lt;COMMA_SEPARATED_LIST_OF_ALLOWED_REGISTRIES&gt;"  <br/>    registries = split(whitelist, ",")  <br/>    registry = registries[_]  <br/>}  <br/>  <br/>reg_matches_any(str, patterns) {  <br/>    reg_matches(str, patterns[_])  <br/>}  <br/>  <br/>reg_matches(str, pattern) {  <br/>    contains(str, pattern)  <br/>}</span></pre><p id="4204" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从事件中收集数据后，通过调用<code class="du lo lp lq lr b">reg_matches_any(…)</code>块将这些数据与白名单进行比较。调用堆栈使用<code class="du lo lp lq lr b">reg_matches(…)</code>块来检查注册表变量值(来自容器映像属性)是否包含注册表白名单中的值。如果没有找到白名单中的值，策略评估将使用<code class="du lo lp lq lr b">deny</code>进行响应，并返回在<code class="du lo lp lq lr b">msg</code>变量中构造的原因。</p><blockquote class="lc ld le"><p id="bff1" class="ji jj lf jk b jl jm ii jn jo jp il jq lg js jt ju lh jw jx jy li ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>即使webhook为<code class="du lo lp lq lr b">CREATE</code>和<code class="du lo lp lq lr b">UPDATE</code> API服务器事件触发，上面的策略仅用于评估部署<code class="du lo lp lq lr b">CREATE</code> API服务器事件中的JSON有效负载。提醒一下，如果一个API服务器事件被发送到OPA进行评估，并且找不到匹配的策略，OPA将用状态<code class="du lo lp lq lr b">allowed:true</code>进行响应。这将告诉API服务器继续对etcd进行写操作。</p></blockquote><h1 id="84d2" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">作为配置映射的策略</h1><p id="5b3f" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">减压阀文件作为ConfigMap资源存储在Kubernetes集群中。当在<code class="du lo lp lq lr b">opa</code>名称空间中创建配置映射资源时，<code class="du lo lp lq lr b">kube-mgmt</code>边车容器读取配置映射，并编译策略。编译成功后，<code class="du lo lp lq lr b">kube-mgmt</code>边车将配置图标注为ok状态，如下所示。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/16976b2c8385dc56f8a9be0d5c07e35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysr1QIA7DpgoS71iaYWPaA.png"/></div></div></figure><p id="33ff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">接下来，<code class="du lo lp lq lr b">kube-mgmt</code> sidecar将策略内容从ConfigMap加载到<code class="du lo lp lq lr b">opa</code>容器中作为策略。一旦策略被安装在<code class="du lo lp lq lr b">opa</code>容器中，就可以根据部署资源评估策略，在映像规范中查找白名单中的注册中心。如果映像规范中的注册中心不在策略的白名单中，那么部署将会失败，如下所示。</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="7adf" class="ly kg hh lr b fi lz ma l mb mc">Error from server (invalid deployment, namespace="app-ns", name="app-name", registry="app-registry"): error when creating "app-deployment.yaml": admission webhook "validating-webhook.openpolicyagent.org" denied the request...</span></pre><p id="eacc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果<code class="du lo lp lq lr b">kube-mgmt</code> sidecar不能成功编译减压阀策略文件，那么它将用失败状态注释标记配置图，并且不将策略加载到<code class="du lo lp lq lr b">opa</code>容器中。</p><pre class="ix iy iz ja fd lu lr lv lw aw lx bi"><span id="d0cf" class="ly kg hh lr b fi lz ma l mb mc">openpolicyagent.org/policy-status:  {"status":"error","error":{"code":"invalid_parameter","message":"error(s) occurred while compiling module(s)","errors":[{"code":"rego_parse_error","message":"no match found","location":{"file":"opa/deployment-create-whitelist/main","row":5,"col":10},"details":{}}]}}</span></pre><h1 id="2220" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">其他使用案例</h1><p id="9a59" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">开放策略代理可用于评估许多API服务器事件的JSON负载，多个策略可用于评估同一个API事件。Kubernetes的核心特征之一是它如何选择资源，由标签驱动。此外，集群内的治理和合规性可以通过正确标记资源来驱动。使用开放策略代理来评估API服务器事件有效负载以确保新的和重新配置的对象被正确标记是非常有意义的。这确保了如果没有正确的标记方案，就不会有工作负载被引入集群。</p><p id="64b9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在幕后，开放策略代理是一个RESTful服务器，它接收数据和策略来评估这些数据。鉴于其与域无关的性质，开放策略代理可以部署到Kubernetes集群中，为需要数据验证的其他工作负载提供服务，而不仅仅是验证Kubernetes资源的用例。</p><h1 id="3027" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">技巧</h1><p id="fa47" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在使用开放策略代理和Kubernetes验证准入控制器时，我们发现了一些潜在的问题，读者应该注意:</p><ol class=""><li id="72af" class="mf mg hh jk b jl jm jo jp jr mh jv mi jz mj kd mk ml mm mn bi translated">因为Kubernetes资源删除是如何触发<code class="du lo lp lq lr b">UPDATE</code>事件的，所以需要仔细制定策略来考虑非删除<code class="du lo lp lq lr b">UPDATE</code>事件中不需要的行为。</li><li id="1da3" class="mf mg hh jk b jl mo jo mp jr mq jv mr jz ms kd mk ml mm mn bi translated">在节点上配置公司代理连接时，<code class="du lo lp lq lr b">.svc</code>可能需要添加到<code class="du lo lp lq lr b">NO_PROXY</code>环境导出中，以防止错误地将<code class="du lo lp lq lr b">opa.opa.svc</code>调用路由到集群外部。</li></ol><h1 id="2a75" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">结论</h1><p id="64ac" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">随着向云计算的转移，向Kubernetes的转移需要深思熟虑的设计，以确保包括治理、合规性和安全控制。使用策略来应用基于规则的资源控制是管理Kubernetes配置的一种动态方法。策略支持是寻求Kubernetes管理自动化的团队普遍关心的问题。</p><p id="1087" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">开放策略代理与领域无关的特性使其非常适合于策略管理和评估。结合Kubernetes验证准入控制器，开放策略代理可以减少不需要的资源配置进入Kubernetes集群的机会。开放策略代理是一个RESTful服务器，可以承担企业中的其他数据验证角色。</p><h1 id="b878" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">相关:</h1><ul class=""><li id="1407" class="mf mg hh jk b jl kx jo ky jr mt jv mu jz mv kd mw ml mm mn bi translated"><a class="ae ke" rel="noopener" href="/capital-one-tech/using-kubernetes-configmap-resources-for-dynamic-apps-9e23ef589121">将Kubernetes ConfigMap资源用于动态应用</a></li></ul></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="6905" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lf">以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>