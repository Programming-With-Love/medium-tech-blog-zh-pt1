<html>
<head>
<title>How to create a REST API client and its integration tests in Kotlin Multiplatform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kotlin多平台中创建REST API客户端及其集成测试</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/how-to-create-a-rest-api-client-and-its-integration-tests-in-kotlin-multiplatform-d76c9a1be348?source=collection_archive---------0-----------------------#2019-03-01">https://blog.kotlin-academy.com/how-to-create-a-rest-api-client-and-its-integration-tests-in-kotlin-multiplatform-d76c9a1be348?source=collection_archive---------0-----------------------#2019-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4d1de63c713a9627d149dadc975e0c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZOoqp8Yxb0Vkc7k3FO9dA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Kotlin Multiplatform Library</figcaption></figure><p id="431e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章是我在博客<a class="ae kx" href="http://xurxodev.com/cliente-api-rest-y-test-de-integracion-en-kotlin-multiplatform" rel="noopener ugc nofollow" target="_blank">xurxodev.com</a>中的原文的英文翻译。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="4f90" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大多数移动应用程序都基于与API Rest的通信。</p><p id="ea1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">与外部服务的集成是移动开发的基础。为了获得最佳的集成，有必要通过集成测试来确保它。</p><p id="b90e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">随着Kotlin多平台的出现，出现了一个非常有趣的场景，比如在多平台库中有一个REST API的客户端，我们可以在Android应用程序和iOS应用程序中使用它。</p><p id="6e0a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇博文中，我们将回顾如何使用Kotlin多平台创建REST API客户端，以及如何创建验证我们的集成工作正常所需的集成测试。</p><p id="8138" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">几周前，我参加了一个卡鲁米的<a class="ae kx" href="https://blog.karumi.com/5th-mobile-testing-training-edition-is-over/" rel="noopener ugc nofollow" target="_blank">移动测试培训，我们在那里制作了这个</a><a class="ae kx" href="https: / /github.com/Karumi/KataTODOApiClientKotlin" rel="noopener ugc nofollow" target="_blank">形</a>，我们将回顾一个科特林多平台版本。</p><h1 id="981f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">API REST</h1><p id="adef" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">我们将要创建的客户机与下面的web服务通信:<a class="ae kx" href="http://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">http://jsonplaceholder.typicode.com/</a></p><p id="25b5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个REST API管理任务，您将能够获取所有现有的任务，使用其标识符获取任务，添加新任务，更新任务或删除现有的任务。</p><h1 id="b07e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建Gradle项目</h1><p id="0ad0" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">首先要做的是创建项目，可以使用Intellij或者Android Studio。</p><p id="24bd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如何配置Kotlin多平台库的详细解释超出了本文的范围，但是这里有Jetbrains的官方文档:<a class="ae kx" href="https://kotlinlang.org/docs/tutorials/multiplatform-library.html" rel="noopener ugc nofollow" target="_blank">多平台Kotlin库</a>。</p><h1 id="26a5" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置持续集成</h1><p id="dea2" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">为一个项目设置CI的最佳时间是在开始的时候，所以这将是下一步。</p><p id="7a92" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我已经使用了Travis，你所要做的就是进入<a class="ae kx" href="https://travis-ci.org" rel="noopener ugc nofollow" target="_blank">https://travis-ci.org</a>，启用你的Github项目进行持续集成，并在项目的根目录下添加一个travis.yml文件:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a4e8" class="mr lg in mn b gy ms mt l mu mv">os: osx<br/>  osx_image: xcode10.1</span><span id="fc2b" class="mr lg in mn b gy mw mt l mu mv">script:<br/>  - ./gradlew build</span></pre><p id="95f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个文件中，我们将OS X作为执行构建的操作系统。</p><p id="1609" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是执行我们将要在iOS模拟器中创建的测试所必需的。</p><p id="0acf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们指出运行构建任务的脚本命令。</p><p id="f9c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在其他子任务中，build task将为JVM和iOS编译库代码，最后，它将在两个平台上运行测试。</p><h1 id="e50f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建客户端</h1><h2 id="1637" class="mr lg in bd lh mx my dn ll mz na dp lp kk nb nc lt ko nd ne lx ks nf ng mb nh bi translated">要使用的库</h2><p id="6324" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">我们需要下一个图书馆:</p><ul class=""><li id="5dd3" class="ni nj in kb b kc kd kg kh kk nk ko nl ks nm kw nn no np nq bi translated">对于T1来说，它是一个多平台库，可以向远程服务发出请求。类似于Android的翻新或者iOS的Alamofire和AFNetworking。</li><li id="53fa" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated"><a class="ae kx" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank"> Kotlinx序列化</a>，它是一个多平台的序列化和反序列化库，JSON是支持的格式之一。</li></ul><h2 id="2bb9" class="mr lg in bd lh mx my dn ll mz na dp lp kk nb nc lt ko nd ne lx ks nf ng mb nh bi translated">TodoApiClient</h2><p id="4fd5" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">我们的客户机包含一个HttpClient来发出请求，并由构造函数接收一个HttpClientEngine，我们将在后面看到原因。</p><p id="0cfd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">引擎可以由build.gradle文件中包含的工件显式或隐式分配。</p><p id="3852" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JVM有一些引擎像Apache，Jetty，OkHttp对于iOS，它只存在一个iOS引擎，它在内部使用异步NSURLSession，并且没有额外的配置。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e809" class="mr lg in mn b gy ms mt l mu mv">class TodoApiClient constructor(      <br/>    httpClientEngine: HttpClientEngine? = null) { </span><span id="1baf" class="mr lg in mn b gy mw mt l mu mv">    companion object {         <br/>        const val BASE_ENDPOINT =  <br/>              "http://jsonplaceholder.typicode.com"     <br/>    }<br/>      <br/>    private val client: HttpClient = <br/>         HttpClient(httpClientEngine!!) {             <br/>             install(JsonFeature) {             <br/>               serializer = KotlinxSerializer().apply {                  <br/>                  register(Task.serializer())            <br/>         } <br/>    }   <br/> }</span></pre><p id="4e3b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将为远程服务允许的每个操作提供一个方法，让我们看一些例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="94c9" class="mr lg in mn b gy ms mt l mu mv">suspend fun getAllTasks(): Either&lt;ApiError, List&lt;Task&gt;&gt; = try {<br/>    val tasksJson = client.<em class="nw">get</em>&lt;String&gt;("$BASE_ENDPOINT/todos")<br/><br/>    // JsonFeature does not working currently with root-level array<br/>    // https://github.com/Kotlin/kotlinx.serialization/issues/179<br/>    val tasks = Json.nonstrict.parse(Task.serializer().<em class="nw">list</em>,   <br/>                tasksJson)<br/><br/>    Either.Right(tasks)<br/>} catch (e: Exception) {<br/>    handleError(e)<br/>}<br/><br/>suspend fun addTask(task: Task): Either&lt;ApiError, Task&gt; = try {<br/>    val taskResponse = client.<em class="nw">post</em>&lt;Task&gt;("$BASE_ENDPOINT/todos") <strong class="mn io">{<br/>        </strong><em class="nw">contentType</em>(ContentType.Application.Json)<br/>        body = task<br/>    <strong class="mn io">}<br/><br/>    </strong>Either.Right(taskResponse)<br/>} catch (e: Exception) {<br/>    handleError(e)<br/>}</span></pre><p id="bf22" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意，每个方法都返回一个要么类型，记住它是一种<a class="ae kx" href="http://xurxodev.com/desde-donde-comunicar-o-tratar-errores-parte-2/" rel="noopener ugc nofollow" target="_blank">函数式编程技术</a>，在不使用异常的情况下处理错误。</p><p id="7520" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在更传统的面向对象编程中，这些方法都可能返回异常。</p><p id="0f9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果结果令人满意，我们返回相应泛型的正确类型。</p><p id="33da" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果出现错误，Ktor会返回一个异常，我们用它自己的方法来处理这个异常:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3056" class="mr lg in mn b gy ms mt l mu mv">private fun handleError(exception: Exception): Either&lt;ApiError, Nothing&gt; =<br/>    if (exception is BadResponseStatusException) {<br/>        if (exception.statusCode.value == 404) {<br/>            Either.Left(ItemNotFoundError)<br/>        } else {<br/>            Either.Left(UnknownError(exception.statusCode.value))<br/>        }<br/>    } else {<br/>        Either.Left(NetworkError)<br/>    }</span></pre><h1 id="3461" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">集成测试</h1><p id="63d8" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">为了测试我们的客户端与Rest API的集成，我们需要验证以下内容:</p><ul class=""><li id="7680" class="ni nj in kb b kc kd kg kh kk nk ko nl ks nm kw nn no np nq bi translated">请求被正确地发送到API:端点、动词、头、主体(如果适用)。</li><li id="8dfa" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated">服务器响应被正确解析。</li><li id="4ede" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated">正确处理服务器错误响应。</li></ul><p id="09af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了执行这些检查，我们必须模拟服务器响应，并且能够以某种方式访问我们发送的HTTP请求。</p><h2 id="3659" class="mr lg in bd lh mx my dn ll mz na dp lp kk nb nc lt ko nd ne lx ks nf ng mb nh bi translated">要使用的库</h2><p id="d65d" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">我们需要下一个图书馆:</p><ul class=""><li id="98a8" class="ni nj in kb b kc kd kg kh kk nk ko nl ks nm kw nn no np nq bi translated">ktor-client-mock ，这是一个多平台库，它公开了MockEngine，允许我们模拟服务器响应，并访问发送的请求来执行验证。</li><li id="74dc" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated"><a class="ae kx" href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener ugc nofollow" target="_blank"> Kotlinx协同程序</a>，Ktor基于<a class="ae kx" href="https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html" rel="noopener ugc nofollow" target="_blank">暂停函数</a>，因此，我们需要协同程序库从测试中调用我们的客户端。</li></ul><h2 id="6766" class="mr lg in bd lh mx my dn ll mz na dp lp kk nb nc lt ko nd ne lx ks nf ng mb nh bi translated">创建测试</h2><p id="7741" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">让我们看看我们可以创建的一些测试。</p><p id="51fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以尝试的第一个测试是验证todos端点，例如:</p><ul class=""><li id="92e3" class="ni nj in kb b kc kd kg kh kk nk ko nl ks nm kw nn no np nq bi translated">验证响应是否被正确解析。</li><li id="b01b" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated">验证accept标头是否已发送。</li><li id="b200" class="ni nj in kb b kc nr kg ns kk nt ko nu ks nv kw nn no np nq bi translated">如果出现错误，请验证其处理是否正确。</li></ul><p id="196f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要什么基础设施？我们需要有一种方法来配置一个MockEngine，在这里我们可以模拟一个响应，并将这个mock engine传递给构造函数中的客户端，而不是一个真实的客户端。</p><p id="59c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要一个JSON来表示服务器的响应，最简单的方法是用一个函数返回JSON字符串:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b844" class="mr lg in mn b gy ms mt l mu mv">fun getTasksResponse() =<br/>    "[{\n" +<br/>        "  \"userId\": 1,\n" +<br/>        "  \"id\": 1,\n" +<br/>        "  \"title\": \"delectus aut autem\",\n" +<br/>        "  \"completed\": false\n" +<br/>        "}," +<br/>        " {\n" +<br/>        "  \"userId\": 1,\n" +<br/>        "  \"id\": 2,\n" +<br/>        "  \"title\": \"quis ut nam facilis et officia qui\",\n" +<br/>        "  \"completed\": false\n" +<br/>        "}, " +<br/>        "{\n" +<br/>        "  \"userId\": 2,\n" +<br/>        "  \"id\": 3,\n" +<br/>        "  \"title\": \"fugiat veniam minus\",\n" +<br/>        "  \"completed\": false\n" +<br/>        "}," +<br/>        "{\n" +<br/>        "  \"userId\": 2,\n" +<br/>        "  \"id\": 4,\n" +<br/>        "  \"title\": \"et porro tempora\",\n" +<br/>        "  \"completed\": true\n" +<br/>        "}]"</span></pre><p id="e839" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们需要能够配置一个模拟引擎来返回存根响应，并使用这个引擎来访问发送的请求，以实现对它的验证。</p><p id="f29f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以为我们的测试创建一个基类，或者创建一个特定的类来实现这项工作。在测试中，我更喜欢组合而不是继承。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bd5c" class="mr lg in mn b gy ms mt l mu mv">class TodoApiMockEngine {<br/>    private lateinit var mockResponse: MockResponse<br/>    private var lastRequest: MockHttpRequest? = null<br/><br/>    fun enqueueMockResponse(<br/>        endpointSegment: String,<br/>        responseBody: String,<br/>        httpStatusCode: Int = 200<br/>    ) {<br/>        mockResponse = MockResponse(endpointSegment, responseBody, httpStatusCode)<br/>    }<br/><br/>    fun get() = MockEngine <strong class="mn io">{<br/>        </strong>lastRequest = this<br/><br/>        when (url.encodedPath) {<br/>            "${mockResponse.endpointSegment}" -&gt; {<br/>                MockHttpResponse(<br/>                    call,<br/>                    HttpStatusCode.fromValue(<br/>                    mockResponse.httpStatusCode),<br/>                    <em class="nw">ByteReadChannel</em>(mockResponse.responseBody<br/>                        .<em class="nw">toByteArray</em>(Charsets.UTF_8)),<br/>                    <em class="nw">headersOf</em>(HttpHeaders.ContentType <em class="nw">to listOf</em>(<br/>                    ContentType.Application.Json.toString()))<br/>                )<br/>            }<br/>            else -&gt; {<br/>                <em class="nw">error</em>("Unhandled ${url.<em class="nw">fullPath</em>}")<br/>            }<br/>        }<br/>    <strong class="mn io">}<br/><br/>    </strong>fun verifyRequestContainsHeader(key: String, <br/>         expectedValue: String) {<br/>        val value = lastRequest!!.headers[key]<br/>        <em class="nw">assertEquals</em>(expectedValue, value)<br/>    }<br/><br/>    fun verifyRequestBody(addTaskRequest: String) {<br/>        val body = (lastRequest!!.content as TextContent).text<br/><br/>        <em class="nw">assertEquals</em>(addTaskRequest, body)<br/>    }<br/><br/>    fun verifyGetRequest() {<br/>        <em class="nw">assertEquals</em>(HttpMethod.Get.value,  <br/>        lastRequest!!.method.value)<br/>    }<br/><br/>    fun verifyPostRequest() {<br/>        <em class="nw">assertEquals</em>(HttpMethod.Post.value,  <br/>                     lastRequest!!.method.value)<br/>    }<br/><br/>    fun verifyPutRequest() {<br/>        <em class="nw">assertEquals</em>(HttpMethod.Put.value, <br/>                     lastRequest!!.method.value)<br/>    }<br/><br/>    fun verifyDeleteRequest() {<br/>        <em class="nw">assertEquals</em>(HttpMethod.Delete.value, <br/>                     lastRequest!!.method.value)<br/>    }<br/>}</span></pre><p id="b5ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如您在这个类中看到的，在get函数中，我们配置了一个MockEngine，根据编码的路径，我们将返回一个带有HTTP状态代码和主体的响应，该响应已在enqueueMockResponse方法中传递。</p><p id="b630" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果encodedPath不匹配，我们将抛出一个错误:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4721" class="mr lg in mn b gy ms mt l mu mv">error("Unhandled ${url.fullPath}")</span></pre><p id="5caf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这样，我们就没有必要为每个端点创建一个特定的测试来验证发送请求的端点是否正确，它将在每个测试中被隐式地验证。</p><p id="cb0b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们编写测试:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="107b" class="mr lg in mn b gy ms mt l mu mv">class TodoApiClientShould {<br/>    companion object {<br/>        private const val ALL_TASK_SEGMENT = "/todos"<br/>    }<br/><br/>    private val todoApiMockEngine = TodoApiMockEngine()<br/><br/>    @Test<br/>    fun `send accept header`() = <em class="nw">runTest </em><strong class="mn io">{<br/>        </strong>val apiClient = givenAMockTodoApiClient(<br/>                    ALL_TASK_SEGMENT, <em class="nw">getTasksResponse</em>())<br/><br/>        apiClient.getAllTasks()<br/><br/>        todoApiMockEngine<br/>         .verifyRequestContainsHeader("Accept", "application/json")<br/>    <strong class="mn io">}<br/><br/>    </strong>@Test<br/>    fun `send request with get http verb getting all task`() =   <br/>      <em class="nw">runTest </em><strong class="mn io">{<br/>        </strong>val apiClient = givenAMockTodoApiClient(ALL_TASK_SEGMENT, <br/>                        <em class="nw">getTasksResponse</em>())<br/><br/>        apiClient.getAllTasks()<br/><br/>        todoApiMockEngine.verifyGetRequest()<br/>    <strong class="mn io">}<br/><br/>    </strong>@Test<br/>    fun `return tasks and parses it properly`() = <em class="nw">runTest </em><strong class="mn io">{<br/>        </strong>val apiClient = givenAMockTodoApiClient(ALL_TASK_SEGMENT, <br/>                        <em class="nw">getTasksResponse</em>())<br/><br/>        val tasksResponse = apiClient.getAllTasks()<br/><br/>        tasksResponse.<em class="nw">fold</em>(<br/>            <strong class="mn io">{ </strong>left <strong class="mn io">-&gt; </strong><em class="nw">fail</em>("Should return right but was left: <br/>                           $left") <strong class="mn io">}</strong>,<br/>            <strong class="mn io">{ </strong>right <strong class="mn io">-&gt;<br/>                </strong><em class="nw">assertEquals</em>(4, right.size.toLong())<br/>                assertTaskContainsExpectedValues(right[0])<br/>            <strong class="mn io">}</strong>)<br/>    <strong class="mn io">}<br/><br/>    </strong>@Test<br/>    fun `return http error 500 if server response internal server <br/>         error getting all task`() =<br/>        <em class="nw">runTest </em><strong class="mn io">{<br/>            </strong>val apiClient =givenAMockTodoApiClient(ALL_TASK_SEGMENT, <br/>            httpStatusCode = 500)<br/><br/>            val tasksResponse = apiClient.getAllTasks()<br/><br/>            tasksResponse.<em class="nw">fold</em>(<br/>                <strong class="mn io">{ </strong>left <strong class="mn io">-&gt; </strong><em class="nw">assertEquals</em>(UnknownError(500), left) <strong class="mn io">}</strong>,<br/>                <strong class="mn io">{ </strong>right <strong class="mn io">-&gt; </strong><em class="nw">fail</em>("Should return left but was right:  <br/>                                $right") <strong class="mn io">}</strong>)<br/>        <strong class="mn io">}</strong></span><span id="18c8" class="mr lg in mn b gy mw mt l mu mv">    private fun assertTaskContainsExpectedValues(task: Task?) {<br/>       <em class="nw">assertTrue</em>(task != null)<br/>       <em class="nw">assertEquals</em>(task.id, 1)<br/>       <em class="nw">assertEquals</em>(task.userId, 1)<br/>       <em class="nw">assertEquals</em>(task.title, "delectus aut autem")<br/>       <em class="nw">assertFalse</em>(task.completed)<br/>    }<br/><br/>    private fun givenAMockTodoApiClient(<br/>       endpointSegment: String,<br/>       responseBody: String = "",<br/>       httpStatusCode: Int = 200): TodoApiClient {<br/>       <br/>       todoApiMockEngine.enqueueMockResponse(endpointSegment,   <br/>       responseBody, httpStatusCode)<br/><br/>       return TodoApiClient(todoApiMockEngine.get())<br/>    }<br/>}</span></pre><p id="cc5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意，在我们返回runTest的测试中，这是协程发挥作用的地方。</p><p id="9be2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">目的是用runBlocking运行测试，以便同步执行测试。</p><p id="45c8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于我们在多平台项目的公共模块中，我们没有这个构建器可用，所以我们必须做的是创建一个抽象，并按照<a class="ae kx" href="http://xurxodev.com/kotlin-multiplatform-y-el-principio-de-inversion-de-dependencias/" rel="noopener ugc nofollow" target="_blank">期望/实际机制</a>在每个平台的源集中定义它的实现:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="cf80" class="mr lg in mn b gy ms mt l mu mv">// This is within CommonTest source test     <br/>internal expect fun &lt;T&gt; runTest(block: suspend () -&gt; T): T  </span><span id="1f2e" class="mr lg in mn b gy mw mt l mu mv">// This is within JvmTest source test     <br/>internal actual fun &lt;T&gt; runTest(block: suspend () -&gt; T): T {            <br/>    return runBlocking { block() }     <br/>}</span><span id="846c" class="mr lg in mn b gy mw mt l mu mv">// This is within iosTest source test     <br/>internal actual fun &lt;T&gt; runTest(block: suspend () -&gt; T): T {      <br/>   return runBlocking { block() }<br/>}</span></pre><h2 id="0981" class="mr lg in bd lh mx my dn ll mz na dp lp kk nb nc lt ko nd ne lx ks nf ng mb nh bi translated">为什么不为iOS执行测试？</h2><p id="d52a" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">当您第一次运行构建时，不会为iOS执行测试。</p><p id="06e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是因为该插件默认只支持在macOS、Windows等平台上执行测试。</p><p id="95d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是我们可以创建一个容易执行的Gradle任务。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0a7e" class="mr lg in mn b gy ms mt l mu mv">task iosTest {<br/>    doLast {<br/>        def binary = kotlin.targets.iOS.compilations.test.getBinary('EXECUTABLE', 'DEBUG')<br/>        exec {<br/>            commandLine 'xcrun', 'simctl', 'spawn', "iPhone XR", binary.absolutePath<br/>        }<br/>    }<br/>}<br/>tasks.check.dependsOn iosTest</span></pre><h1 id="0788" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">形和源代码</h1><p id="8bba" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">你可以在这里找到源代码<a class="ae kx" href="https://github.com/xurxodev/integration-testing-kotlin-multiplatform-kata" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1a25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">主分支包含了所有由我解决的形。</p><p id="a79a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最好的学习方法是通过练习，所以我推荐使用整合-测试-科特林-多平台-形分支，你自己做练习。</p><h1 id="4bfb" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">相关课程</h1><p id="d93c" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated"><a class="ae kx" href="http://xurxodev.com/curso-testing/" rel="noopener ugc nofollow" target="_blank">测试过程</a></p><h1 id="eeb1" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="ba70" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">在本文中，我们看到了如何创建包含REST API客户端的多平台库，以及如何创建测试来验证与远程服务的集成，并在JVM和iOS模拟器上运行它们。</p><p id="536b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但这只是一个形的例子，它不是一个准备发布到产品中的库。</p><p id="ea2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">感谢您阅读这篇文章！如果你喜欢，请按👏🏼按钮，这样其他人也可以阅读:)</strong></p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi nx"><img src="../Images/68557afd7e8ae2a75dec26b78d8ec016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxZ6inD12UP7rnbt-2PJZw.png"/></div></a></figure></div></div>    
</body>
</html>