<html>
<head>
<title>5 helpful RxJS solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个有用的RxJS解决方案</h1>
<blockquote>原文：<a href="https://medium.com/compendium/5-helpful-rxjs-solutions-d34f7c2f1cd9?source=collection_archive---------0-----------------------#2021-04-19">https://medium.com/compendium/5-helpful-rxjs-solutions-d34f7c2f1cd9?source=collection_archive---------0-----------------------#2021-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3dfb" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">日常问题</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/42396532f6982e9d08e2c8d98e8e4f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCwKN7rMuxpURsLTXdiM2Q.jpeg"/></div></div></figure><p id="ac5d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">RxJS是一个javascript库，允许我们使用可观察的流进行反应式编码。利用RxJS提供的观察值和函数，我们可以编写可读的异步代码。</p><p id="4c11" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你正在使用Angular，你已经在使用它了，因为框架是建立在它之上的。尽管如此，许多开发人员除了在http请求上调用subscribe之外，并没有更多地使用它。</p><h1 id="a8bb" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">开始使用带有管道操作符的RxJS！</h1><p id="b9f9" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">RxJS背后的许多力量来自它的管道运营商。你问的是什么？这些基本上是可以在管道中按照执行顺序“堆叠”以组成新流的函数。“这将创建更好的解决方案，可读性更强，代码通常更少。</p><p id="f911" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有许多关于最佳实践的文章，并解释了这些操作符的作用。</p><blockquote class="lb lc ld"><p id="f743" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated">你绝对应该读一读这几本书！</p></blockquote><p id="e5e8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是，尽管它们中的许多可能很棒，我发现它们包含的例子经常不能反映我们在日常编码中发现的问题。所以我决定采取另一种方法，给你5个解决日常问题的方法。</p><h1 id="f1dc" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">1.简化多个HTTP请求的处理。</h1><p id="bf17" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">让我们从web程序员日常生活中最常见的场景之一开始，即:处理多个http请求。许多人可能已经知道这一点，但由于这是我经常看到的事情，我决定把它包括进来。</p><h2 id="9af4" class="lj kf hh bd kg lk ll lm kk ln lo lp ko jr lq lr kq jv ls lt ks jz lu lv ku lw bi translated">场景1:顺序请求。在下一个请求中使用以前请求中的数据。</h2><p id="c182" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">我们经常需要根据早期请求的响应来提出请求。在下面的场景中确实如此。</p><ul class=""><li id="5602" class="lx ly hh jk b jl jm jo jp jr lz jv ma jz mb kd mc md me mf bi translated">我们首先基于id检索帖子。</li><li id="ca69" class="lx ly hh jk b jl mg jo mh jr mi jv mj jz mk kd mc md me mf bi translated">使用第一次调用的post响应，我们希望检索post的用户。</li><li id="7701" class="lx ly hh jk b jl mg jo mh jr mi jv mj jz mk kd mc md me mf bi translated">在我们得到用户之后，我们希望得到被检索用户的所有帖子。</li></ul><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="a520" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如我们所看到的，这导致了嵌套混乱。想象一下其他场景，我们可能希望在将响应传递给下一个请求之前对其进行一些操作。这可能会使筑巢变得更糟。</p><h2 id="69c9" class="lj kf hh bd kg lk ll lm kk ln lo lp ko jr lq lr kq jv ls lt ks jz lu lv ku lw bi translated">解决方案:开关图</h2><p id="d264" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">这可以用操作符<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap" rel="noopener ugc nofollow" target="_blank"> <em class="le"> switchMap </em> </a>轻松简化。<em class="le"> switchMap </em>的功能在于它的名字。在第一个可观察对象发出后，它订阅一个内部可观察对象。</p><p id="7922" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这非常适合我们的场景。我们希望使用我们的第一个帖子的可观察对象，并将结果映射到一个加载用户的新的可观察对象。</p><p id="3fee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">操作员将获取帖子的外部可观察值，当帖子发出时，<em class="le">将</em>切换到“用户”的内部可观察值，并且<em class="le">将</em>外部可观察值的结果映射到我们的内部可观察值。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><blockquote class="lb lc ld"><p id="3ac8" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>值得注意的switchMap的其他特性是，如果一个新的可观察值在前一个值完成之前发出，则能够取消前一个可观察值。这在创建<a class="ae li" href="https://en.wikipedia.org/wiki/Autocomplete" rel="noopener ugc nofollow" target="_blank">自动完成</a>特性时非常有用。</p></blockquote><h2 id="572e" class="lj kf hh bd kg lk ll lm kk ln lo lp ko jr lq lr kq jv ls lt ks jz lu lv ku lw bi translated">场景2:发出并行请求。</h2><p id="f242" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">有时候我们并不关心多个请求完成的顺序。我们可能只是想在它们全部完成后收集它们。假设我们只有一个用户标识。我们希望获得用户发布的所有帖子和关于同一用户的元数据。</p><p id="7684" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于这两个请求相互独立，它们完成的顺序并不重要。然而，我们确实想等到我们从两者都得到数据。通常在加载数据时，我们也想显示某种加载指示器。</p><p id="5065" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个简单的解决方案，我们修补一个对象来表明我们有数据。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="b188" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你可以同意这似乎不是一个好的解决方案。想象一下，如果我们需要发出更多的并行请求。代码会很快变得冗长而不可读。</p><h2 id="49db" class="lj kf hh bd kg lk ll lm kk ln lo lp ko jr lq lr kq jv ls lt ks jz lu lv ku lw bi translated">解决方案:forkJoin</h2><p id="9924" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">使用RxJs，只需几行代码就可以用操作符<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin" rel="noopener ugc nofollow" target="_blank"> forkJoin </a>解决这个问题。对于那些习惯于承诺的人来说，这个操作符的工作方式和承诺差不多..]).在操作符内部，所有请求并行执行，并将在所有请求都解决后发出。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><blockquote class="lb lc ld"><p id="e07e" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated"><strong class="jk hi">注意</strong>:请注意，如果任何一个请求抛出错误，您将丢失其他请求的值，即使它们已经完成。如果你关心他们，你就必须抓住他们。</p></blockquote><h1 id="31d4" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">2.将多个流合并为一个流以实现搜索功能</h1><p id="024c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在我的一个项目中，我们实现了智能搜索。我们的搜索请求由多个来源组成，例如</p><ul class=""><li id="5c01" class="lx ly hh jk b jl jm jo jp jr lz jv ma jz mb kd mc md me mf bi translated">来自输入字段的搜索词$ term</li><li id="abaa" class="lx ly hh jk b jl mg jo mh jr mi jv mj jz mk kd mc md me mf bi translated">一组metadataFilters$(范围，复选框)</li><li id="7240" class="lx ly hh jk b jl mg jo mh jr mi jv mj jz mk kd mc md me mf bi translated">可以画在地图上的一组多边形</li><li id="b817" class="lx ly hh jk b jl mg jo mh jr mi jv mj jz mk kd mc md me mf bi translated">currentResultPage$来自带有分页按钮的结果页</li></ul><p id="a721" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">源数据来自不同的组件，因此我们需要一种易于阅读的方式将它们组合成一个方便的流。</p><h2 id="72a3" class="lj kf hh bd kg lk ll lm kk ln lo lp ko jr lq lr kq jv ls lt ks jz lu lv ku lw bi translated">解决方案:组合测试</h2><p id="d0e7" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest" rel="noopener ugc nofollow" target="_blank"> combineLatest </a>函数将一个流数组合并成一个流数组，并在其中一个流发生变化时发出所有流。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="e9a7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们有了进行搜索所需的所有资源。每次这些来源发生变化时，我们都会进行新的搜索。这意味着每次我们点击next按钮或在输入框中输入内容时，我们都会发出一个新的请求。但这是我们想要的吗？这将意味着对后端的大量请求。</p><p id="4ab7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以用一个新的操作符<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime" rel="noopener ugc nofollow" target="_blank">去抖时间</a>和我们第一个场景中的朋友<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap" rel="noopener ugc nofollow" target="_blank">切换图</a>来进一步改进我们的解决方案。请记住，之前<em class="le"> switchMap </em>的另一个特性是，如果在当前请求完成之前提出了新的请求，它会取消之前的请求。这意味着我们总是从最后一个请求中得到结果。</p><p id="5c58" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">改进我们的解决方案:取消快速请求</strong></p><p id="d6a2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">新操作符<em class="le"> debounceTime </em>也具有取消功能，但是这个操作符取消了在所提供的dueTime内发出的任何新值。假设我们将dueTime设置为1000毫秒。这意味着，如果我们单击分页中的next按钮，并在1秒钟之前再次单击它，将不会发出新的请求。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="914b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们一前一后使用这两个操作符时，我们可以在<em class="le">反跳时间</em>的帮助下，取消在所提供的dueTime内做出的任何新请求。我们熟悉的<em class="le"> switchMap </em>会取消之前的请求，如果它还没有完成，给我们最后的结果。</p><p id="a70f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">改进我们的解决方案:取消平等请求</strong></p><p id="d9d0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们现在已经减少了不必要的请求，只在交互<em class="le">稳定</em>时发出请求。但这意味着新的问题出现了。假设我们在过滤器中选中一个复选框，然后立即再次将其取消选中。这将触发一个具有与我们刚才相同响应的请求。</p><p id="3cc9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">输入<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/distinctuntilchanged" rel="noopener ugc nofollow" target="_blank"> distinctUntilChanged </a>运算符！这将停止当前值与先前值相同的任何发射。厉害！</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="8d9b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">或者是？我们将看到<em class="le"> distinctUntilChanged </em>在我们的例子中不起作用。尽管我们的请求是相同的，它仍然会产生一个新的请求事件。为什么会这样！？</p><p id="8bbd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是因为<em class="le"> distinctUntilChanged </em>默认使用' === '比较。这意味着当使用对象和数组时，如果它们有相同的引用，它们就被认为是相同的。为了让它工作，我们需要提供一个比较函数来比较一些独特的东西，比如一个id。</p><p id="c769" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">更多问题？！我的信号源没有发射</strong></p><p id="db5e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">重要的是要注意到<em class="le">combine test</em>函数不会发出，直到它的每个源可观测量至少发出一次。</p><p id="395d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有时你可能会发现<em class="le">组合测试</em>不发射。如果任何源是类型<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/subjects" rel="noopener ugc nofollow" target="_blank">主题</a>或<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject" rel="noopener ugc nofollow" target="_blank">重放主题</a>，则可能出现这种情况。这些可观察值不需要初始值，因此<em class="le">combine test</em>不会发出任何东西，直到您对它们至少调用了一次next。</p><p id="f0e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通常，在创建可观测量时，最好使用<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">行为主体</a>，但是如果它们不适合您的用例，可以使用<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/startwith" rel="noopener ugc nofollow" target="_blank"> startWith </a>操作符来缓解问题。</p><p id="2756" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设我们的搜索术语$ observable是一个ReplaySubject。它没有被提供一个起始值，并且<em class="le"> combineLatest </em>不会发出一个值，直到你输入一些东西。然后，您可以轻松地用管道连接<em class="le"> startWith </em>，并提供一个空字符串作为它的起始值。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="c2f0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">3.单击一个按钮，使用流中的数据作为参数进行http请求</h1><p id="cfdf" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">假设您有一个按钮，单击该按钮将下载一个包含用户所有帖子的excel表格。该请求需要当前选定用户的用户标识。但是用户对象被存储为可观察对象。</p><p id="27b1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个简单的解决方案可能是这样的。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="f2f9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这有什么错呢？这里最大的问题是，我们没有在调用click函数的同时获取userId。这意味着极有可能出现竞态条件。此外，下载所涉及的代码是分散的，并不包含在一个函数中。</p><p id="a104" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">解决方案:使用LatestFrom、fromEvent和switchMap </strong></p><p id="ac71" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们首先用函数<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/creation/fromevent" rel="noopener ugc nofollow" target="_blank"> fromEvent </a>将点击事件提升为一个流。您可能还记得上一个例子中的<em class="le">组合测试</em>。我们能这样做吗？</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="d8c8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以，但是记住<em class="le"> combineLatest </em>会在observables发出的任何时候发出，所以每次按下下载按钮时都会下载，而且每次用户改变时也会下载。</p><p id="f376" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/withlatestfrom" rel="noopener ugc nofollow" target="_blank"> withLatestFrom </a>只会在源可观测值发出时添加可观测值的最后一个值。</p><blockquote class="lb lc ld"><p id="0fb1" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>注意，传递给withLatestFrom的可观察对象需要在源可观察对象发出之前发出一次。</p></blockquote><p id="d592" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这样，我们可以添加user$ stream的值，但是只有当click事件被触发时才会发出。然后，我们使用熟悉的switchMap将流切换到下载调用。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="4665" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">4.使用筛选运算符而不是if/else</h1><p id="34ef" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在我们作为程序员的日常生活中，当处理条件语句时，我们经常会用到if/else语句。当用流编码时，处理条件的需要没有什么不同。但是有一种更为T2反应式的方法来处理条件句。</p><p id="e1e7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">场景:根据类型提出不同的请求</strong></p><p id="b0ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设我们有两种不同类型的用户。一个读者和作家。读者只能看帖子，不能写帖子。作者当然被允许读和写帖子。现在想象一下，当点击UI中的用户时，我们希望为读者和作者加载不同的内容。对于读者，我们可能希望加载用户已经阅读的所有文章，对于作者，我们可能希望加载用户已经创建的所有文章。解决方案可能看起来像这样。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="fa4a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如我们所见，这很快变得不可读。然后图像添加更多的条件。</p><p id="6a0b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">解决方案:过滤器</strong></p><p id="bd96" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter" rel="noopener ugc nofollow" target="_blank">过滤器</a>操作符将只允许通过所提供条件的值通过。</p><blockquote class="lb lc ld"><p id="d712" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated"><strong class="jk hi">注意:</strong>RxJs过滤器不要与数组使用的过滤器函数混淆。这个过滤水流。如果发出的值是要过滤的数组，则使用map运算符返回过滤后的数组:<em class="hh">map(array =&gt;array . filter(…)</em></p></blockquote><p id="feaa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用filter操作符，我们可以将流分成每种类型。这比在流中执行条件要好得多。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="305f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">5.使两个不同的可观测量共享同一个订阅。</h1><p id="3c80" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">有时你可能有两个观察值，它们发出相同类型的值，但调用相同的函数。它可能是这样的。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="5dbe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">编程的一个好习惯就是保持“干爽”(不要重复自己)。所以订阅两个相等的流感觉非常没有必要。</p><p id="ffc2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">解决方案:合并</strong></p><p id="8413" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了避免订阅每个单独的可观察对象并在它们的subscribe块中调用相同的函数，这可以通过使用<a class="ae li" href="https://www.learnrxjs.io/learn-rxjs/operators/combination/merge" rel="noopener ugc nofollow" target="_blank"> <em class="le"> merge </em> </a>函数来简化。这将把多个可观测性变成一个可观测性。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="42eb" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">包扎</h1><p id="5971" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">那都是peeps！今天我们学习了5个RxJS食谱，它们改善了常见问题的解决方案。我希望你能找到有用的。</p><p id="fb5c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你知道其他有用的解决方法吗？请在下面的评论中告诉我。</p><p id="4660" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在出去用RxJS做出更好更清洁的解决方案吧！</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mn mm l"/></div></figure><blockquote class="lb lc ld"><p id="168e" class="ji jj le jk b jl jm ii jn jo jp il jq lf js jt ju lg jw jx jy lh ka kb kc kd ha bi translated">特别感谢Jan Greger Hemb和Erik Tallang审阅了这篇博文，并提出了宝贵的意见以使它变得更好！</p></blockquote></div></div>    
</body>
</html>