<html>
<head>
<title>Exploring Kotlin initialization with Android custom views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Android自定义视图探索Kotlin初始化</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-kotlin-initialization-with-android-custom-views-cde06e915e8d?source=collection_archive---------2-----------------------#2021-04-12">https://medium.com/google-developer-experts/exploring-kotlin-initialization-with-android-custom-views-cde06e915e8d?source=collection_archive---------2-----------------------#2021-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a00c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">仔细看看Kotlin和程序/动态视图膨胀之间的关系</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/1311793a064e071e2c91d0dae8b65d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VB89SnxjlXjhP_BY"/></div></div></figure><p id="7484" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">今天，我们探讨“在视图的生命周期中，初始化发生在哪里？”这是我的队友们激烈争论了几个月的话题，所以我决定亲自看看。本文介绍了两种扩展自定义视图进行比较的方法:通过布局资源和以编程方式。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ke"><img src="../Images/2a163d6ba1b376abeabeeb9ec2926c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*FBMLUxlTJSp8L15TFfq69Q.png"/></div></figure><p id="cb2e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个探索中，我们看一个小的指南针应用程序。为了方便起见，您可以在Github 上下载<a class="ae kf" href="https://github.com/ahinchman1/Custom-View-Exploration-Compass" rel="noopener ugc nofollow" target="_blank">代码，以便在您自己的设备上跟随/运行该应用程序。</a></p><p id="2b2d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个应用程序使用<a class="ae kf" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank">视图绑定</a>和一个自定义视图，根据用户设备的朝向来旋转指针。这两个不同的案例存在于来自<code class="du kg kh ki kj b">main</code>分支的不同分支上。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h2 id="7ebe" class="kr ks hh bd kt ku kv kw kx ky kz la lb jr lc ld le jv lf lg lh jz li lj lk ll bi translated">Kotlin构造函数和init块什么时候调用？</h2><p id="3e71" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">像Java一样，Kotlin可以声明多个构造函数，但是区分了<em class="lr">主</em>和<em class="lr">次</em> <em class="lr">构造函数。</em>都用关键字<code class="du kg kh ki kj b">constructor</code>表示。</p><p id="7573" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大多数情况下，一个Kotlin类只会使用一个<em class="lr">主</em> <em class="lr">构造函数。</em>如果没有可见性修饰符或注释，那么一个类可以省略<code class="du kg kh ki kj b">constructor</code>关键字。没有主构造函数的Kotlin类会生成一个什么都不做的类。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="7a57" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一个<em class="lr">主构造函数</em>也可以包括一个用关键字<code class="du kg kh ki kj b">init</code>表示的<em class="lr">初始化程序块</em>。作为主<em class="lr"/><em class="lr">构造器</em>的一部分，一旦类被初始化，初始化器块就执行逻辑。</p><p id="4d19" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lr">二级构造器</em>多用于Java互操作。对于下面的<code class="du kg kh ki kj b">CompassView</code>的情况，没有声明<em class="lr">主构造函数</em>，但是有多个<em class="lr">次构造函数</em>为:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="dac0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这些<em class="lr">次级构造函数</em>将委托给超类中适当的构造函数，或者找到一个这样做的构造函数。但是，具体来说，一个<em class="lr">二级构造函数</em>相对于<em class="lr">一级构造函数</em>会以什么顺序执行呢？</p><p id="381b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">来自科特林官方<a class="ae kf" href="https://kotlinlang.org/docs/classes.html#secondary-constructors" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lu lv lw"><p id="a635" class="ji jj lr jk b jl jm ii jn jo jp il jq lx js jt ju ly jw jx jy lz ka kb kc kd ha bi translated">对主构造函数的委托发生在次构造函数的第一条语句中，因此所有初始化器块和属性初始化器中的代码都在次构造函数体之前执行。</p></blockquote><p id="33af" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在<code class="du kg kh ki kj b">CompassView</code>中，<em class="lr">初始化块</em>在<em class="lr">二级构造器</em>执行之前执行。但是Kotlin类初始化在视图生命周期中到底处于什么位置呢？我们通过研究视图是如何膨胀的来回答这个问题。</p><h1 id="bc2c" class="ma ks hh bd kt mb mc md kx me mf mg lb in mh io le iq mi ir lh it mj iu lk mk bi translated">创建视图时会发生什么？</h1><p id="61ed" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">答案取决于如何在树中添加视图。在屏幕上，Android中的所有视图都存在于单个树中。有两种方法可以将视图添加到树中:</p><ul class=""><li id="3f90" class="ml mm hh jk b jl jm jo jp jr mn jv mo jz mp kd mq mr ms mt bi translated"><strong class="jk hi">以编程方式:</strong>向树中添加一个视图。</li><li id="b8a0" class="ml mm hh jk b jl mu jo mv jr mw jv mx jz my kd mq mr ms mt bi translated"><strong class="jk hi"> XML: </strong>通过Android布局文件指定另一棵树。</li></ul><p id="e2e7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我们的compass应用程序中，我们将自定义的<code class="du kg kh ki kj b">CompassView</code>扩展到<code class="du kg kh ki kj b">MainActivity</code>上，作为唯一的自定义视图组件。本文展示了通过XML ( <code class="du kg kh ki kj b">CompassView(context, attrs)</code>)和代码(<code class="du kg kh ki kj b">CompassView(context)</code>)膨胀定制视图之间的区别。</p><h2 id="2795" class="kr ks hh bd kt ku kv kw kx ky kz la lb jr lc ld le jv lf lg lh jz li lj lk ll bi translated">案例1:通过XML膨胀的定制Kotlin视图</h2><p id="083c" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">当您将一个视图元素放入XML文件时，Android将使用一个<code class="du kg kh ki kj b">LayoutInflater</code>来解析XML中的相应对象并将其映射到展开的视图。<code class="du kg kh ki kj b">LayoutInflater</code>通过打开ResourceManager并检查其当前配置中所有可能匹配的布局来检索<code class="du kg kh ki kj b">resource</code>。Android将解析回适当的二进制XML资源。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mz"><img src="../Images/28f6939fd9a4608347d024eec53280fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CNjZE-ot3_j8cCreK2Ufg.png"/></div></div><figcaption class="na nb et er es nc nd bd b be z dx">XML uses LayoutInflater, sends the callback onFinishInflate() from the final child inflation back to the root.</figcaption></figure><p id="f5bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于<code class="du kg kh ki kj b">CompassView(context, attrs)</code>,第二个参数将利用必要的属性来告诉视图层次如何在树中调整和放置元素。这篇文章并不关注<code class="du kg kh ki kj b">View</code>生命周期的这些阶段(测量/布局/绘制)，但有一个来自<a class="ae kf" href="https://www.youtube.com/watch?v=zdQRIYOST64&amp;ab_channel=AndroidDevelopers" rel="noopener ugc nofollow" target="_blank">的非常棒的演讲:Android如何渲染(Google I/O '18) </a>，它深入探究了好奇者的机制。</p><p id="d9bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后，对其子视图及其子视图的子视图重复这一膨胀过程，直到所有视图都被膨胀。当膨胀完成时，<code class="du kg kh ki kj b">LayoutInflater</code>从子视图向根视图发送一个回调<code class="du kg kh ki kj b">onFinishInflate()</code>,以指示视图准备好进行交互。</p><p id="7eff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">既然我们已经描述了这个过程，让我们检查用XML实例化我们的定制<code class="du kg kh ki kj b">CompassView</code>所需的代码:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="e180" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在<code class="du kg kh ki kj b">MainActivity</code>中，<code class="du kg kh ki kj b">CompassView</code>通过视图绑定从XML中引用。以这种方式初始化自定义视图时，会执行默认的辅助构造函数:</p><pre class="ix iy iz ja fd ne kj nf ng aw nh bi"><span id="1ac3" class="kr ks hh kj b fi ni nj l nk nl">D/Compass_View_Kotlin: Kotlin init block called.</span><span id="146a" class="kr ks hh kj b fi nm nj l nk nl">     <strong class="kj hi">   CompassView(context, attrs) called</strong></span><span id="271a" class="kr ks hh kj b fi nm nj l nk nl">D/Compass_View_Kotlin: Inflation started from constructor.</span><span id="3056" class="kr ks hh kj b fi nm nj l nk nl">D/Compass_View_Kotlin: <strong class="kj hi">onFinishInflate() called.</strong></span><span id="ecc8" class="kr ks hh kj b fi nm nj l nk nl">D/MainActivity: onStart(): Start compass.</span></pre><p id="287c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先调用Kotlin初始化块，<em class="lr">然后</em>调用次级构造函数<code class="du kg kh ki kj b">CompassView(context, attrs)</code>。请记住，没有用于扩展视图类的主构造函数(除非您自己创建一个)，所以在次构造函数之前先执行<code class="du kg kh ki kj b">init</code>是有意义的。因为调用<code class="du kg kh ki kj b">CompassView(context, attrs)</code>使用了<code class="du kg kh ki kj b">LayoutInflater</code>，所以当所有视图都完成膨胀时，就会进行<code class="du kg kh ki kj b">onFinishInflate()</code>回调。</p><h1 id="fdce" class="ma ks hh bd kt mb mc md kx me mf mg lb in mh io le iq mi ir lh it mj iu lk mk bi translated">案例2:以编程方式膨胀的定制Kotlin视图</h1><p id="e9fa" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">在很大程度上，通过XML初始化视图是在Android中创建视图元素的首选方式，因为它成为了树视图层次结构的一部分。这样做有好处:使用XML对Android内存更友好，因为它可以很容易地压缩，并有助于减少编程绘制可能必须做的运行时工作负载。</p><p id="e8ba" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设您不能在XML中包含自定义视图的创建，而是必须只在运行时初始化视图。</p><p id="5511" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">代码可能是这样的:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="2fe9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如您所见，仅仅为了使<code class="du kg kh ki kj b">CompassView</code>元素适合ConstraintLayout，就有大量的工作以编程方式设置UI。这种特殊情况在现实生活中难以置信地不切实际，但是我们谈论初始化<code class="du kg kh ki kj b">CompassView(this)</code>有一个特殊的原因。为了进行演示，我们将运行以下代码:</p><pre class="ix iy iz ja fd ne kj nf ng aw nh bi"><span id="76d6" class="kr ks hh kj b fi ni nj l nk nl">D/Compass_View_Kotlin: Kotlin init block called.</span><span id="e876" class="kr ks hh kj b fi nm nj l nk nl"><strong class="kj hi">CompassView(context) called</strong></span><span id="3578" class="kr ks hh kj b fi nm nj l nk nl">D/Compass_View_Kotlin: Inflation started from constructor.</span><span id="4a09" class="kr ks hh kj b fi nm nj l nk nl">D/MainActivity: onStart(): Start compass.</span></pre><p id="947b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">和前面的例子一样，Kotlin初始化块首先执行，然后是次级构造函数<code class="du kg kh ki kj b">CompassView(context)</code>。但是，你可能已经注意到<em class="lr">没有</em> <code class="du kg kh ki kj b"><em class="lr">onFinishInflate()</em></code> <em class="lr">回调曾经做过</em>。这是因为<code class="du kg kh ki kj b">CompassView(context)</code>没有被XML实例化，这意味着没有<code class="du kg kh ki kj b">LayoutInflater</code>发挥作用。递归实例化不需要等待子进程，因此回调也不需要<code class="du kg kh ki kj b">onFinishInflate()</code>。</p><p id="138f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您需要为不依赖于该系统调用的不同构造函数调用添加共享逻辑，这可能会给在旧代码和其他与UI相关的操作中创建更多的手动视图绑定带来问题。</p><h1 id="b3d4" class="ma ks hh bd kt mb mc md kx me mf mg lb in mh io le iq mi ir lh it mj iu lk mk bi translated"><strong class="ak">推荐</strong></h1><p id="fb01" class="pw-post-body-paragraph ji jj hh jk b jl lm ii jn jo ln il jq jr lo jt ju jv lp jx jy jz lq kb kc kd ha bi translated">您可以用<code class="du kg kh ki kj b">@<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/" rel="noopener ugc nofollow" target="_blank">JvmOverloads</a></code>注释来注释自定义视图，这告诉Kotlin编译器生成重载方法。每个重载都会用默认值替换生成的方法中省略的任何参数，这意味着下面的代码相当于本文开头写的<code class="du kg kh ki kj b">CompassView</code>类构造函数:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="7df8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不要依赖系统来调用<code class="du kg kh ki kj b">onFinishInflate</code>，你可以使用Kotlin <code class="du kg kh ki kj b">init{ }</code>来共享逻辑(即使视图在代码中动态膨胀)。在初始化块中运行<code class="du kg kh ki kj b">inflate</code>方法将保证无论您选择如何初始化您的自定义视图都会发生膨胀。</p><p id="2981" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望你喜欢这篇简介:在Android中，通过Kotlin的镜头来看某些概念可以为看似基本的问题提供新的视角。您可以在<code class="du kg kh ki kj b">main</code>项目上找到推荐的代码版本，以及下面的其他资源。</p><h1 id="f712" class="ma ks hh bd kt mb mc md kx me mf mg lb in mh io le iq mi ir lh it mj iu lk mk bi translated">其他资源:</h1><ul class=""><li id="881f" class="ml mm hh jk b jl lm jo ln jr nn jv no jz np kd mq mr ms mt bi translated"><a class="ae kf" href="https://www.youtube.com/watch?v=Y06wmVIFlsw&amp;ab_channel=Touchlab" rel="noopener ugc nofollow" target="_blank">droid con NYC 2016:LayoutInflater如何工作</a></li><li id="85fc" class="ml mm hh jk b jl mu jo mv jr mw jv mx jz my kd mq mr ms mt bi translated">布局充气器:<a class="ae kf" href="https://developer.android.com/reference/android/view/LayoutInflater" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/view/layout Inflater</a></li><li id="fc6e" class="ml mm hh jk b jl mu jo mv jr mw jv mx jz my kd mq mr ms mt bi translated">科特林初始化:<a class="ae kf" href="https://kotlinlang.org/docs/classes.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/classes.html</a></li></ul></div></div>    
</body>
</html>