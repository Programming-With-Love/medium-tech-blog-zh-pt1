<html>
<head>
<title>Creating an adaptive loading of media content</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建媒体内容的自适应加载</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/hello-guys-9e2c00993057?source=collection_archive---------5-----------------------#2019-12-18">https://medium.com/quick-code/hello-guys-9e2c00993057?source=collection_archive---------5-----------------------#2019-12-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="bf9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你们好，伙计们！我目前正在为我的项目开发一个网站。在网站上，我需要展示很多gif，每个都很重要。如果一次显示所有内容，页面加载时间过长。同时，它应该明确包含gif在最开始，所以内容不能加载后加载一个页面。</p><p id="cceb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对这个问题的解决方案感兴趣，那么这篇文章将会很有帮助。</p><h1 id="0cf1" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">实际上问题是</h1><p id="9f30" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">正如我以前说过的，网站上有太多的gif。你可以在<a class="ae kf" href="https://reface.tech/" rel="noopener ugc nofollow" target="_blank"> reface.tech </a>上查看它们</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/fdf8df817c84e41bd2bb3a4e6254d2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*4sftjdajuldEMDYK.jpg"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Gifs on the webpage</figcaption></figure><p id="9875" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我开发登陆页面的测试版时，就出现了一个加载问题:对于一些用户来说，它要加载很长时间。这当然是一件令人沮丧的事情。</p><p id="3b10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有必要以某种方式解决它。那时，媒体内容已经通过compressor.io无损压缩，所以我与此无关。因此，有必要进行有损压缩，并给出质量较低的gif。</p><p id="4aa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是把不好的媒体内容发给互联网好的用户，是某种亵渎。因此，我决定以某种方式确定一个客户端的互联网速度，并根据速度滑动适当的质量。</p><h1 id="1778" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">画草图</h1><p id="d63b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我将有一个数组，其中包含实际显示的媒体内容的描述。</p><p id="3f89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">举例:</strong></p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="747f" class="kx jd hh kt b fi ky kz l la lb">[<br/>   {<br/>      "large": <br/>         {<br/>            "size": 0.6211118698120117,<br/>            "url":"gifs/control/large/control_1.gif"<br/>         },<br/>      "middle": <br/>         {<br/>            "size":0.5330495834350586,<br/>            "url":"gifs/control/middle/control_1.gif"<br/>         },<br/>      "small": <br/>         {<br/>            "size":0.4901447296142578,<br/>            "url":"gifs/control/small/control_1.gif"<br/>         }<br/>   }<br/>]</span></pre><p id="d604" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在元素中有一个url和文件大小(针对每个质量)。</p><h2 id="d793" class="kx jd hh bd je lc ld le ji lf lg lh jm ip li lj jq it lk ll ju ix lm ln jy lo bi translated">我们只是:</h2><ol class=""><li id="b5e7" class="lp lq hh ig b ih ka il kb ip lr it ls ix lt jb lu lv lw lx bi translated">遍历数组(当页面加载时)</li><li id="2890" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">计算每种质量的已加载内容的总大小</li><li id="5ee1" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">检查它们中的哪一个(从最好的开始)可以在4秒内加载(这个时间符合我的要求)</li></ol><h2 id="3437" class="kx jd hh bd je lc ld le ji lf lg lh jm ip li lj jq it lk ll ju ix lm ln jy lo bi translated">那么我们应该:</h2><ol class=""><li id="ba0a" class="lp lq hh ig b ih ka il kb ip lr it ls ix lt jb lu lv lw lx bi translated">编写一个脚本来自动输出这样的数组</li><li id="0e10" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">写一个输出网络连接速度的东西</li></ol><h1 id="fca2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">写一个检查速度的东西</h1><p id="7bb1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">会比较简单。在你浏览器的地址栏中输入eu.httpbin.org/stream-bytes/51200<a class="ae kf" href="http://eu.httpbin.org/stream-bytes/51200" rel="noopener ugc nofollow" target="_blank"/>。然后你的浏览器会下载一个51200字节的文件。将它粘贴到“公共”目录中(以测量主机速度)。</p><p id="2e3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们需要检查文件下载了多少。让我们为此编写一个简单的函数，它将以每秒兆字节为单位返回速度。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="a668" class="kx jd hh kt b fi ky kz l la lb">async checkDownloadSpeed(baseUrl, fileSizeInBytes) {<br/>   return new Promise((resolve, _) =&gt; {<br/>      let startTime = new Date().getTime();<br/>      return axios.get(baseUrl).then( response =&gt; {<br/>         const endTime = new Date().getTime();<br/>         const duration = (endTime - startTime) / 1000;<br/>         const bytesPerSecond = (fileSizeInBytes / duration);<br/>         const megabytesPerSecond = (bytesPerSecond / 1000 / 1000);<br/>         resolve(megabytesPerSecond);<br/>      });<br/>   }).catch(error =&gt; {<br/>      throw new Error(error);         <br/>   });<br/>}</span></pre><p id="c35d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们只需设置开始下载的时间，完成下载的时间，测量差异，并且，因为我们知道文件的大小，只需划分。</p><p id="0a83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们写一个函数，用这个速度做一些事情:</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="66ba" class="kx jd hh kt b fi ky kz l la lb">async getNetworkDownloadSpeed() {<br/>   const baseUrl = process.env.PUBLIC_URL + ‘/51200’;<br/>   const fileSize = 51200;<br/>   const speed = await this.checkDownloadSpeed(baseUrl, fileSize);<br/>   console.log(“Network speed: “ + speed);</span><span id="8b4d" class="kx jd hh kt b fi md kz l la lb">   if (speed.mbps === “Infinity”) {<br/>      SpeedMeasure.speed = 1;<br/>   } </span><span id="381f" class="kx jd hh kt b fi md kz l la lb">   else { <br/>      SpeedMeasure.speed = speed * 5;<br/>   }<br/>}</span></pre><p id="12d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实际上，这段代码存在一个问题:由于下载文件很小，无法确定互联网连接的准确速度。但是我们不能下载更大的东西，所以我们只是将确定的速度乘以5。实际上它会比正确的速度还要慢。</p><p id="19c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们写一个函数，它将根据速度设置质量:</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="c297" class="kx jd hh kt b fi ky kz l la lb">static getResolution(gifsArray) {<br/>   let totalSizeLevel1 = 0;<br/>   let totalSizeLevel2 = 0;<br/>   let totalSizeLevel3 = 0;</span><span id="32b0" class="kx jd hh kt b fi md kz l la lb">   for (let i = 0; i &lt; gifsArray.length; i++) {<br/>      for (let a = 0; a &lt; gifsArray[i].length; a++) {<br/>         let element = gifsArray[i][a];<br/>         totalSizeLevel1 += element.small.size;<br/>         totalSizeLevel2 += element.middle.size;<br/>         totalSizeLevel3 += element.large.size;<br/>      }<br/>   }</span><span id="d06c" class="kx jd hh kt b fi md kz l la lb">   if (isNaN(SpeedMeasure.speed)) {<br/>      SpeedMeasure.speed = 1;<br/>   }</span><span id="d0c8" class="kx jd hh kt b fi md kz l la lb">   let timeLevel1 = totalSizeLevel1 / SpeedMeasure.speed;<br/>   let timeLevel2 = totalSizeLevel2 / SpeedMeasure.speed;<br/>   let timeLevel3 = totalSizeLevel3 / SpeedMeasure.speed;</span><span id="b1f9" class="kx jd hh kt b fi md kz l la lb">   if (timeLevel3 &lt; APPROPRIATE_TIME_LIMIT) {<br/>      return "large";<br/>   }</span><span id="8f2d" class="kx jd hh kt b fi md kz l la lb">   else if (timeLevel2 &lt; APPROPRIATE_TIME_LIMIT) {<br/>      return "middle";<br/>   }</span><span id="abca" class="kx jd hh kt b fi md kz l la lb">   else {<br/>      return "small";<br/>   } <br/>}</span></pre><p id="9053" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为计算速度的函数是异步的，所以SpeedMeasure.speed可以是NaN。默认情况下，我们认为连接速度是每秒1兆字节。当函数计算速度时，我们只是重新渲染容器。</p><p id="ef1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将数组的数组传递给getResolution函数。为什么？因为如果我们页面上有几个带有gif的容器，那么我们把对应的内容作为数组传递给其中的每一个容器会更方便，但是要考虑一下子全部加载的速度。</p><h1 id="2097" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">用法的例子</h1><p id="5843" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">下面是一个用法示例(React):</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="8c5d" class="kx jd hh kt b fi ky kz l la lb">async runFunction() {<br/>   let speedMeasure = new SpeedMeasure();<br/>   await speedMeasure.getNetworkDownloadSpeed();<br/>   this.forceUpdate()<br/>}</span><span id="c063" class="kx jd hh kt b fi md kz l la lb">componentDidMount() {<br/>   this.runFunction();<br/>}</span><span id="aabf" class="kx jd hh kt b fi md kz l la lb">render() {<br/>   let quality = SpeedMeasure.getResolution([Control.getControlArray(),Health.getHealthArray()]);</span><span id="2d1c" class="kx jd hh kt b fi md kz l la lb">   return (<br/>      &lt;div className="app"&gt;<br/>         &lt;Presentation /&gt;<br/>         &lt;Control quality={quality} /&gt;<br/>         &lt;Health quality={quality} /&gt;<br/>      &lt;/div&gt;<br/>   );<br/>}</span></pre><p id="4bb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，当一切都将被下载，速度将被测量，容器将被重新渲染。</p><p id="90d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在容器内部(比如在控件内部)，我只是从一个数组中取出一个相应的gif(通过索引)，然后我只是通过“quality”键得到一个对象，通过“url”键得到一个链接。其实很简单。</p><h1 id="73e2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">编写Python脚本:</h1><p id="12ee" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在我需要以某种方式压缩gif并输出一个包含内容描述的数组。</p><p id="364d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先让我们写一个压缩gif的脚本。我们将使用gifsicle。对于“中等”质量的gif，压缩率为80(满分为200)，对于“小”质量的gif，压缩率为160。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="fcd1" class="kx jd hh kt b fi ky kz l la lb">import os</span><span id="7cc2" class="kx jd hh kt b fi md kz l la lb">GIFS_DIR = "/home/mixeden/Документы/Landingv2/"<br/>COMPRESSOR_DIR = "/home/mixeden/Документы/gifsicle-static"<br/>NOT_OPTIMIZED_DIR = "not_optimized"<br/>OPTIMIZED_DIR = "optimized"<br/>GIF_RESIZED_DIR = "gif_not_optimized_resized"<br/>GIF_COMPRESSED_DIR = "gif_compressed"<br/>COMPRESSION_TYPE = ["middle", "small"]</span><span id="f0ed" class="kx jd hh kt b fi md kz l la lb">for (root, dirs, files) in os.walk(GIFS_DIR, topdown=True):<br/>   if len(files) &gt; 0 and GIF_RESIZED_DIR in root:<br/>      for file in files:<br/>         path = root + "/" + file<br/>            for compression in COMPRESSION_TYPE:<br/>               final_path = path.replace(GIF_RESIZED_DIR, GIF_COMPRESSED_DIR + "/" + compression + "/" + OPTIMIZED_DIR)<br/>               print(path, final_path)</span><span id="5e9b" class="kx jd hh kt b fi md kz l la lb">               if compression == COMPRESSION_TYPE[0]:<br/>                  rate = 80</span><span id="0001" class="kx jd hh kt b fi md kz l la lb">               else:<br/>                  rate = 160</span><span id="df11" class="kx jd hh kt b fi md kz l la lb">               os.system("echo 0 &gt; " + final_path)<br/>               os.system(COMPRESSOR_DIR + " -O3 --lossy={} -o {} {}".format(rate, final_path, path))</span></pre><p id="ca6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让您理解我的文件系统的结构，这里有一个描述:</p><ol class=""><li id="5670" class="lp lq hh ig b ih ii il im ip me it mf ix mg jb lu lv lw lx bi translated">未优化目录-未优化的gif</li><li id="bd90" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">GIF _ RESIZED _ DIR未优化的GIF，但根据页面容器的大小调整大小</li><li id="0377" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">GIF_COMPRESSED_DIR —压缩的GIF</li><li id="79f6" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">目录里有文件夹，文件夹里有gif的类别名称。类别文件夹内有大、中、小文件夹(根据质量类型)。</li></ol><p id="61c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在脚本中，我们只需遍历包含gif的目录，并使用适当的命令压缩每个文件。</p><p id="bf9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们写一个脚本来生成一个包含信息的数组。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="db67" class="kx jd hh kt b fi ky kz l la lb">import json import os</span><span id="cd8d" class="kx jd hh kt b fi md kz l la lb">GIFS_DIR = "/home/mixeden/Документы/Landingv2/"<br/>COMPRESSOR_DIR = "/home/mixeden/Документы/gifsicle-static"<br/>NOT_OPTIMIZED_DIR = "not_optimized"<br/>OPTIMIZED_DIR = "optimized"<br/>GIF_RESIZED_DIR = "gif_not_optimized_resized"<br/>GIF_COMPRESSED_DIR = "gif_compressed"<br/>COMPRESSION_TYPE = ["large", "middle", "small"]<br/>OUTPUT = {}</span><span id="e426" class="kx jd hh kt b fi md kz l la lb">for (root, dirs, files) in os.walk(GIFS_DIR, topdown=True):<br/>   if len(files) &gt; 0 and GIF_COMPRESSED_DIR in root and NOT_OPTIMIZED_DIR not in root:<br/>      files.sort()<br/>      type = root.split(GIFS_DIR)[1].split(GIF_COMPRESSED_DIR)[0].replace("/", "")<br/>      print(type)</span><span id="12fa" class="kx jd hh kt b fi md kz l la lb">      if type not in OUTPUT:<br/>          OUTPUT[type] = []</span><span id="8094" class="kx jd hh kt b fi md kz l la lb">      if len(OUTPUT[type]) == 0:<br/>         for file in files:<br/>            OUTPUT[type].append(<br/>               {<br/>                  "large": {<br/>                           "url": "",<br/>                           "size": 0<br/>                  },<br/>                  "middle": {<br/>                           "url": "",<br/>                           "size": 0<br/>                  }, <br/>                  "small": {<br/>                           "url": "",<br/>                           "size": 0<br/>                  }<br/>               })</span><span id="6b6c" class="kx jd hh kt b fi md kz l la lb">         for file in files:<br/>            full_path = root + "/" + file<br/>            bytes_size = os.path.getsize(full_path)<br/>            kilobytes_size = bytes_size / 1000<br/>            megabytes_size = kilobytes_size / 1000<br/>            index = int(file.split("_")[1].replace(".gif", "")) - 1<br/>            <br/>            for typer in COMPRESSION_TYPE:<br/>               if typer in root:<br/>                  local_type = typer<br/>            <br/>            new_url = "gifs/" + full_path.replace(GIFS_DIR, "").replace("/" + GIF_COMPRESSED_DIR, "").replace("/" + OPTIMIZED_DIR, "")<br/>            OUTPUT[type][index][local_type]['url'] = new_url<br/>            OUTPUT[type][index][local_type]['size'] = megabytes_size</span><span id="2f24" class="kx jd hh kt b fi md kz l la lb"><br/>print(OUTPUT)<br/>print(json.dumps(OUTPUT, indent=4, sort_keys=True))</span></pre><p id="071d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们浏览文件夹，确定每个文件的大小，找出压缩类型，并将信息放入数组中。然后我们把这个数组输出到控制台(然后就可以复制了)。</p><h1 id="72ef" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="d6d5" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">希望这篇文章能对你有所帮助。祝你们编码愉快，伙计们。</p></div></div>    
</body>
</html>