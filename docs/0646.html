<html>
<head>
<title>repeatOnLifecycle API design story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重复生命周期API设计故事</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333?source=collection_archive---------0-----------------------#2021-07-01">https://medium.com/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333?source=collection_archive---------0-----------------------#2021-07-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/67652710350970bedb352a287891992d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KS6PSbXbPjBwsK-zkyC10Q.png"/></div></div></figure><div class=""/><p id="b85f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博文中，你将了解到<code class="du jn jo jp jq b">Lifecycle.repeatOnLifecycle</code> API背后的设计决策，以及<em class="jr">为什么</em>我们删除了在2.4.0 <code class="du jn jo jp jq b"><a class="ae js" href="https://developer.android.com/jetpack/androidx/releases/lifecycle" rel="noopener ugc nofollow" target="_blank">lifecycle-runtime-ktx</a></code>库的第一个alpha版本中添加的一些助手函数。</p><p id="fb76" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个过程中，您将看到在某些场景中使用某些协同程序API是多么危险，命名是多么困难，以及为什么我们决定只在库中保留低级的suspend APIs。</p><p id="cc4c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，您将意识到所有的API决策都需要在复杂性、可读性以及API的易错性方面进行一些权衡。</p><p id="14d2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">特别感谢<a class="ae js" href="https://twitter.com/adamwp" rel="noopener ugc nofollow" target="_blank"> Adam Powell </a>、<a class="ae js" href="https://twitter.com/wkalic" rel="noopener ugc nofollow" target="_blank"> Wojtek Kaliciński </a>、<a class="ae js" href="https://twitter.com/ianhlake" rel="noopener ugc nofollow" target="_blank"> Ian Lake </a>和<a class="ae js" href="https://twitter.com/yigitboyar" rel="noopener ugc nofollow" target="_blank"> Yigit Boyar </a>提供反馈并讨论这些API的形式。</p><blockquote class="jt ju jv"><p id="b7de" class="ip iq jr ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注:</strong>如果你正在寻找<code class="du jn jo jp jq b">repeatOnLifecycle</code>的指导，请查看<a class="ae js" rel="noopener" href="/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda">一个从Android用户界面博客文章</a>收集流量的更安全的方法。</p></blockquote><h1 id="4c64" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">重复生命周期</h1><p id="14ff" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><code class="du jn jo jp jq b">Lifecycle.repeatOnLifecycle</code> API的诞生主要是为了允许从Android的UI层进行更安全的流量收集。它的可重启行为考虑到了UI的生命周期，使得它成为完美的缺省API，只有当UI在屏幕上可见时才处理项目。</p><blockquote class="jt ju jv"><p id="d498" class="ip iq jr ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注:</strong> <code class="du jn jo jp jq b">LifecycleOwner.repeatOnLifecycle</code>也可用。它将功能委托给它的生命周期。这样，任何已经是<code class="du jn jo jp jq b">LifecycleOwner</code>作用域一部分的代码都可以省略显式接收器。</p></blockquote><p id="1f04" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b"><strong class="ir ht">repeatOnLifecycle</strong></code> <strong class="ir ht">是暂停功能</strong>。因此，它需要在协程内<em class="jr">执行。<code class="du jn jo jp jq b">repeatOnLifecycle</code>挂起调用的协程，然后运行给定的挂起<code class="du jn jo jp jq b">block</code>，每次给定的生命周期达到目标状态或更高状态时，将它作为参数传递给新的协程。如果生命周期状态低于目标，为<code class="du jn jo jp jq b">block</code>启动的协程被取消。最后，<code class="du jn jo jp jq b">repeatOnLifecycle</code>函数本身不会恢复调用协程，直到生命周期到达<code class="du jn jo jp jq b">DESTROYED</code>。</em></p><p id="9642" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看这个API的运行情况。如果你读过我之前的<a class="ae js" rel="noopener" href="/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda"> <em class="jr">一个更安全的从Android用户界面收集流量的方法</em>博客文章</a>，这些都不会让你感到惊讶。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><blockquote class="jt ju jv"><p id="2a50" class="ip iq jr ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注意:</strong>如果你对<code class="du jn jo jp jq b">repeatOnLifecycle</code>是如何实现的感兴趣，这里有一个<a class="ae js" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/RepeatOnLifecycle.kt;l=63" rel="noopener ugc nofollow" target="_blank">到其源代码</a>的链接。</p></blockquote><h1 id="c30e" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">为什么它是一个挂起函数</h1><p id="f79d" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht">暂停功能是重启行为的最佳选择</strong>，因为它保留了调用上下文。它<em class="jr">尊重</em>调用协程的<code class="du jn jo jp jq b">Job</code>树。由于<code class="du jn jo jp jq b">repeatOnLifecycle</code>的实现在幕后使用了<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>，所以它配合了取消:取消调用的协程也取消了<code class="du jn jo jp jq b">repeatOnLifecycle</code>及其重启<code class="du jn jo jp jq b">block</code>。</p><p id="a80e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，我们可以在<code class="du jn jo jp jq b">repeatOnLifecycle</code>之上添加更多的API，比如<code class="du jn jo jp jq b"><a class="ae js" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/FlowExt.kt;l=87" rel="noopener ugc nofollow" target="_blank">Flow.flowWithLifecycle</a></code>流操作符。更重要的是，如果您的项目需要的话，它还允许您在这个API之上创建助手函数。这就是我们试图用<code class="du jn jo jp jq b">LifecycleOwner.addRepeatingJob</code> API做的事情，我们在<code class="du jn jo jp jq b">lifecycle-runtime-ktx:2.4.0-alpha01</code>中添加了这个API，事实上，在<code class="du jn jo jp jq b">alpha02</code>中删除了这个API。</p><h1 id="e04d" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">删除addRepeatingJob API</h1><p id="91f6" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">第一个alpha版本的库中添加了具有此功能的<code class="du jn jo jp jq b">LifecycleOwner.addRepeatingJob</code> API，现在已从库中移除，实现如下:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="a91f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给定一个<code class="du jn jo jp jq b">LifecycleOwner</code>，您可以运行一个suspend块，每当它的生命周期移入和移出目标状态时，它就会重新启动。这个API使用<code class="du jn jo jp jq b">LifecycleOwner</code>的<code class="du jn jo jp jq b">lifecycleScope</code>来触发一个新的协程，并在其中调用<code class="du jn jo jp jq b">repeatOnLifecycle</code>。</p><p id="b49c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jn jo jp jq b">addRepeatingJob</code> API时，上面的代码如下所示:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7e21" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乍一看，您可能认为这段代码更干净，需要的代码更少。然而，如果你不密切注意，有一些隐藏的陷阱会让你搬起石头砸自己的脚:</p><ul class=""><li id="73e0" class="li lj hs ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">尽管<code class="du jn jo jp jq b">addRepeatingJob</code>使用了一个挂起块，但是<code class="du jn jo jp jq b">addRepeatingJob</code>不是而是<strong class="ir ht">一个挂起函数。因此，您不应该在协程内部调用它！！！</strong></li><li id="ea00" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">代码少？您只节省了一行代码，代价是拥有一个更容易出错的API。</li></ul><p id="2c77" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一点可能看起来很明显，但它总是困扰着开发者。具有讽刺意味的是，它实际上是基于协程中最核心的概念之一:<a class="ae js" href="https://elizarov.medium.com/structured-concurrency-722d765aa952" rel="noopener"> <strong class="ir ht">结构化并发</strong> </a>。</p><p id="5c5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">addRepeatingJob</code>不是一个挂起函数，因此，默认情况下不支持结构化并发(注意，您可以通过使用它作为参数的<code class="du jn jo jp jq b">coroutineContext</code>手动使它支持它)。因为<code class="du jn jo jp jq b">block</code>参数是一个suspend lambda，所以您将这个API与协程相关联，并且您可以很容易地编写像这样的危险代码:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="57c9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个代码有什么问题？<code class="du jn jo jp jq b">addRepeatingJob</code>协程可以填充，我可以在协程中调用它，对吗？</p><p id="387d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du jn jo jp jq b">addRepeatingJob</code>使用<code class="du jn jo jp jq b">lifecycleScope</code>创建新的协同程序来运行重复块，这在实现细节中是隐含的，新的协同程序不考虑结构化并发性，也不保留调用协同程序的上下文。因此，当您调用<code class="du jn jo jp jq b">job.cancel()</code>时不会被取消。<strong class="ir ht">这会导致你的应用程序出现非常细微的错误，很难调试。</strong></p><h1 id="251a" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">重复生命周期FTW</h1><p id="f866" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在<code class="du jn jo jp jq b">addRepeatingJob</code>中使用的隐式<code class="du jn jo jp jq b">CoroutineScope</code>使得API在某些情况下不安全。这是一个隐藏的问题，需要格外注意才能写出正确的代码。这一点是反复出现的论点，以避免在库中的<code class="du jn jo jp jq b">repeatOnLifecycle</code>之上增加额外的包装API。</p><p id="6575" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">suspend <code class="du jn jo jp jq b">repeatOnLifecycle</code> API的主要好处是它默认与结构化并发协作，而<code class="du jn jo jp jq b">addRepeatingJob</code>没有。它还有助于您考虑希望重复作业在哪个范围内发生。该API不言自明，符合开发人员的期望:</p><ul class=""><li id="903e" class="li lj hs ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">像任何其他挂起函数一样，它将挂起协程的执行，直到有事情发生。在这种情况下，直到生命周期被破坏。</li><li id="3a47" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">没有惊喜！它可以与其他协程代码结合使用，并且会像您预期的那样运行。</li><li id="0e4e" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">围绕<code class="du jn jo jp jq b">repeatOnLifecycle</code>的代码对于新手来说是可读且有意义的:<em class="jr">“首先，我启动了一个遵循UI生命周期的新协程。然后，我调用repeatOnLifecycle，每当UI到达这个生命周期状态时，它就启动这个块"</em>。</li></ul><h1 id="8517" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Flow.flowWithLifecycle</h1><p id="7754" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><code class="du jn jo jp jq b">Flow.flowWithLifecycle</code>操作符(这里的<a class="ae js" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/FlowExt.kt;l=87" rel="noopener ugc nofollow" target="_blank">实现</a>)构建在<code class="du jn jo jp jq b">repeatOnLifecycle</code>之上，并且仅在生命周期至少达到<code class="du jn jo jp jq b">minActiveState</code>时发出上游流发送的项目。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="35bc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管这个API也有一些需要注意的问题，但我们决定保留它，因为它作为流操作符很有用。例如，可以在Jetpack Compose 中轻松使用<a class="ae js" href="https://manuelvivo.dev/coroutines-addrepeatingjob#safe-flow-collection-in-jetpack-compose" rel="noopener ugc nofollow" target="_blank">。尽管您可以通过使用<code class="du jn jo jp jq b"><a class="ae js" href="https://developer.android.com/jetpack/compose/side-effects#producestate" rel="noopener ugc nofollow" target="_blank">produceState</a></code>和<code class="du jn jo jp jq b">repeatOnLifecycle</code> API在Compose中实现相同的功能，但是我们将这个API留在了库中，作为一种更具反应性的方法的替代方案。</a></p><p id="9d3c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如KDoc中所记录的，添加<code class="du jn jo jp jq b">flowWithLifecycle</code>操作符的顺序很重要。在之前<em class="jr">应用的操作员，当生命周期低于<code class="du jn jo jp jq b">minActiveState</code>时<code class="du jn jo jp jq b">flowWithLifecycle</code>操作员将被取消。但是，在</em>之后应用<em class="jr">的操作员即使没有发送物品也不会被取消。</em></p><p id="90ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于最好奇的人来说，这个API名称将<code class="du jn jo jp jq b">Flow.flowOn(CoroutineContext)</code>操作符作为一个先例，因为<code class="du jn jo jp jq b">Flow.flowWithLifecycle</code>改变了用于收集上游流量的<code class="du jn jo jp jq b">CoroutineContext</code>，同时使下游不受影响。</p><h1 id="4f94" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我们应该增加一个额外的API吗？</h1><p id="53d2" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">假设我们已经有了<code class="du jn jo jp jq b">Lifecycle.repeatOnLifecycle</code>、<code class="du jn jo jp jq b">LifecycleOwner.repeatOnLifecycle</code>和<code class="du jn jo jp jq b">Flow.flowWithLifecycle</code>API。我们应该添加任何其他API吗？</p><p id="9931" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">新的API带来的混乱和它们解决的问题一样多。有多种方式支持不同的用例，最短路径很大程度上取决于周围的代码。可能适用于您的项目，可能不适用于其他人。</p><p id="51bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是为什么我们不想为所有可能的情况提供API，可用的API越多，开发者知道时<em class="jr">用什么</em>用什么<em class="jr">就越混乱。因此，我们决定只保留最底层的API。有时候，少即是多。</em></p><h1 id="8eeb" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">命名很重要(也很困难)</h1><p id="09dc" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">不仅仅是关于我们支持哪些用例，还有，如何命名它们！名称应该符合开发人员的期望，并遵循Kotlin协程惯例。例如:</p><ul class=""><li id="3aa2" class="li lj hs ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">如果API使用一个隐式的<code class="du jn jo jp jq b">CoroutineScope</code>(例如在<code class="du jn jo jp jq b">addRepeatingJob</code>中隐式使用的<code class="du jn jo jp jq b">lifecycleScope</code>)启动一个新的协同程序，这必须反映在名字中以避免错误的期望！在这种情况下，<code class="du jn jo jp jq b">launch</code>应该以某种方式包含在名称中。</li><li id="b1ff" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><code class="du jn jo jp jq b">collect</code>是暂停功能。如果不是一个挂起函数，不要在API名称前加前缀<code class="du jn jo jp jq b">collect</code>。</li></ul><blockquote class="jt ju jv"><p id="5bba" class="ip iq jr ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注意:</strong> Compose的<code class="du jn jo jp jq b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#(kotlinx.coroutines.flow.StateFlow).collectAsState(kotlin.coroutines.CoroutineContext)" rel="noopener ugc nofollow" target="_blank">collectAsState</a></code> API是一个特例，我们可以接受它的名字。不能将它与挂起函数混淆，因为在Compose中没有<code class="du jn jo jp jq b">@Composable suspend fun</code>这样的东西。</p></blockquote><p id="0252" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">甚至连<code class="du jn jo jp jq b">LifecycleOwner.addRepeatingJob</code> API都很难命名。因为它用<code class="du jn jo jp jq b">lifecycleScope</code>创建了新的协程，所以应该用<code class="du jn jo jp jq b">launch</code>作为前缀。然而，我们希望将协程在幕后使用的事实分开，因为它添加了一个新的生命周期观察者，这个名称与其他的<code class="du jn jo jp jq b">LifecycleOwner</code>API更加一致。</p><p id="cae8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个名字也多少受到了现有的<code class="du jn jo jp jq b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">LifecycleCoroutineScope.launchWhenX</a></code>暂停API的影响。由于<code class="du jn jo jp jq b">launchWhenStarted</code>和<code class="du jn jo jp jq b">repeatOnLifecycle(STARTED)</code>提供完全不同的功能(<code class="du jn jo jp jq b">launchWhenStarted</code>暂停协程的执行，而<code class="du jn jo jp jq b">repeatOnLifecycle</code>取消并重启一个新的协程)，如果新API的名称相似(例如，使用<code class="du jn jo jp jq b">launchWhenever</code>来重启API)，开发人员可能会混淆，甚至会在没有注意到的情况下互换使用它们。</p><h1 id="82e4" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">单线流集合</h1><p id="b639" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><code class="du jn jo jp jq b">LiveData</code>的<code class="du jn jo jp jq b">observe</code>功能具有生命周期意识，仅在生命周期开始时处理排放。如果您要从LiveData迁移到Kotlin流，您可能会认为用一行代码替换是个好主意！您可以删除样板代码，移植是简单的。</p><p id="cec2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，你可以像伊恩·莱克第一次尝试API时所做的那样去做。他创建了一个名为<code class="du jn jo jp jq b">collectIn</code>的便利包装器，如下所示(为了遵循上面讨论的命名约定，我将其重命名为<code class="du jn jo jp jq b">launchAndCollectIn</code>):</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="752f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以你可以像这样从用户界面调用它:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7038" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个包装器，在这个例子中看起来很好很简单，但是也有我们之前提到的关于<code class="du jn jo jp jq b">LifecycleOwner.addRepeatingJob</code>的问题。它不尊重调用上下文，在其他协程中使用可能很危险。再者，原来的名字真的有误导性:<code class="du jn jo jp jq b">collectIn</code>不是suspend函数！如前所述，开发者希望<code class="du jn jo jp jq b">collect</code>功能暂停。也许，这个包装器更好的名字是<code class="du jn jo jp jq b">Flow.launchAndCollectIn</code>，以防止不良使用。</p><h1 id="42c0" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">包装丢失</h1><p id="95e1" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><code class="du jn jo jp jq b">repeatOnLifecycle</code>必须与片段中的<code class="du jn jo jp jq b">viewLifecycleOwner</code>一起使用。在开源Google I/O应用程序中，<a class="ae js" href="https://github.com/google/iosched" rel="noopener ugc nofollow" target="_blank"> iosched </a>项目，团队决定创建一个包装器，以避免片段中API的错误使用，该片段具有非常明确的API名称:<code class="du jn jo jp jq b"><a class="ae js" href="https://github.com/google/iosched/blob/main/mobile/src/main/java/com/google/samples/apps/iosched/util/UiUtils.kt#L60" rel="noopener ugc nofollow" target="_blank">Fragment.launchAndRepeatWithViewLifecycle</a></code>。</p><blockquote class="jt ju jv"><p id="d160" class="ip iq jr ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注意:</strong>实现非常类似于<code class="du jn jo jp jq b">addRepeatingJob</code> API。当使用库的<code class="du jn jo jp jq b">alpha01</code>版本编写时，在<code class="du jn jo jp jq b">alpha02</code>中添加的<code class="du jn jo jp jq b">repeatOnLifecycle</code> API lint检查还没有到位。</p></blockquote><h1 id="7ac9" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">你需要包装纸吗？</h1><p id="cbe1" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">如果您需要在<code class="du jn jo jp jq b">repeatOnLifecycle</code> API之上创建包装器来适应您的应用程序中最常见的用例，问问自己是否真的需要它，以及为什么需要它。如果您确信并且想要继续，我建议您选择一个非常明确的API名称来清楚地定义包装器的行为，以避免误用。此外，非常清楚地记录它，以便新来者可以完全理解使用它的含义。</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><p id="12a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这篇博客文章能让你了解团队在决定如何处理<code class="du jn jo jp jq b">repeatOnLifecycle</code>API和我们可以在其上添加的潜在助手方法时的考虑。</p><p id="4318" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">再次感谢<a class="ae js" href="https://twitter.com/adamwp" rel="noopener ugc nofollow" target="_blank">亚当·鲍威尔</a>、<a class="ae js" href="https://twitter.com/wkalic" rel="noopener ugc nofollow" target="_blank">沃伊泰克·卡利斯基</a>、<a class="ae js" href="https://twitter.com/ianhlake" rel="noopener ugc nofollow" target="_blank">伊恩·莱克</a>和<a class="ae js" href="https://twitter.com/yigitboyar" rel="noopener ugc nofollow" target="_blank">伊吉特·博雅</a>给出反馈并讨论这些API的形状。</p></div></div>    
</body>
</html>