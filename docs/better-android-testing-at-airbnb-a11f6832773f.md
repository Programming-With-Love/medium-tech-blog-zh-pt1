# Airbnb 更好的 Android 测试——第 6 部分:一致的嘲笑

> 原文：<https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f?source=collection_archive---------4----------------------->

在 Airbnb Android 测试系列的第六部分，我们来看看剥落的常见来源以及如何减轻它们。

![](img/ef73738e28faaac4749f6787d18c8c7e.png)

在[的上一篇文章](/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b)中，我们详述了我们的测试框架实现。这是对我们运行测试所采取的方法的一个高层次的审视。然而，为了使框架尽可能的稳定，我们在框架中加入了许多小细节。本文详细介绍了其中最重要的几个。

# 持续嘲笑的障碍

与我们的测试框架的一场持久的战斗是最小化剥落的来源。这些可以以多种不同的方式表现出来，并导致诸如轻微的屏幕截图差异、不同的片段状态或虚假的崩溃。

由于我们使用了 Flank，这个问题变得更加复杂，它动态地将测试分配到碎片中。这意味着测试顺序是不断变化的。一次测试可能会使应用程序处于某种状态，这种状态会影响后面的测试，但由于测试顺序的不可预测性，这不会是一致的。

使用 Android 的 Test Orchestrator 可以帮助防止这些问题，但不幸的是，我们目前不能使用它，因为它使我们的测试时间延长了七倍。相反，我们采取手动清除测试之间共享状态的方法，并尽力防止内存泄漏，这可能会导致许多测试运行后崩溃。

下面我们介绍一些我们遇到的片状剥落问题，以及我们如何解决它们。总的来说，我们发现有必要让所有的产品特性都使用相同的模式和架构，这样就可以在底层工具中一次修复缺陷，从而实现可扩展的解决方案。这可能需要在普通 API 周围提供一个包装器，以加强它们是如何被使用或模仿的。

## 异步代码

有许多异步执行代码的方法，工程师可能会选择做一些他们特性中不可预知的事情。例如，异步代码的常用工具有 RxJava、Kotlin 协同例程、AsyncTasks、Executors，甚至手动创建和管理线程。任何定制的方法都不可能被测试框架所控制。通常这是可以的，因为片段 UI 应该被冻结到不可更改的模仿状态，但是偶尔异步代码会导致意想不到的副作用。

为了将意外副作用的可能性降至最低，我们提供了自己的函数作为执行异步代码的访问点，并鼓励工程师使用这些函数。这允许测试框架阻止代码运行，或者检测代码何时完成。

例如，MvRx 使用名为“ ***execute*** ”的扩展函数来订阅 RxJava Observables。MvRx 嘲讽系统允许“ ***执行*** ”的行为被改变，使得可观察对象永远不会被订阅。

此外，我们使用依赖注入将测试协程范围注入到我们的视图模型中，这样协程就不会实际运行。

在这两种情况下，我们都可以报告一个可观察的或协同程序被执行以响应点击，因此相应的细节显示在最终的交互报告中。

## 视图中的缓存状态

Android View 类经常缓存数据以提高性能。例如，如果视图不认为自己是“脏的”，则 draw 调用可能什么也不做，并且度量细节可以被缓存，以便如果视图没有改变，后续的度量过程不必重新计算任何东西。当我们需要强制布局活动以显示整个 RecyclerView，然后将所有内容绘制到自定义画布上时，这些缓存在屏幕截图测试中可能会有问题。例如，ConstraintLayout 有一个测量缓存，导致我们的强制屏幕截图布局无法按预期显示。

我们的解决方案是遍历视图层次结构，并在所有视图上调用***【invalidate()***和***request layout()***。这保证了它们为我们的屏幕截图正确布局，并且它们完全将自己绘制到我们的自定义画布上。

## 共享偏好

如果一个模仿改变了共享的偏好，它会影响后面的模仿。Android Test Orchestrator 也不能解决这个问题，因为我们的框架在一次测试中运行多个模拟。解决方案很简单，在每次模拟之后，让测试框架明确共享的偏好。这可以扩展到任何其他类型的存储，如缓存、本地文件或数据库。

## 日期

充分模仿日期对于减少测试的白点是至关重要的。日期本来就不可靠，因为 UI 代码通常引用当前时间。由于测试以不断变化的日期值重新运行，屏幕截图可以显示不断更新的文本，如果任何参数包含日期，交互报告也会受到影响。

这里唯一的解决方案是能够模拟 Date 框架，以便获取当前日期和时间的调用返回一致的模拟值。在 Airbnb，我们使用 JodaTime，包装在一个自定义的内部 API 中，隐藏了 JodaTime 的实现细节。这允许我们拦截和模拟任何对今天的***()***)或***()***的调用。

## 抽屉

对我们来说，一个反复出现的问题是屏幕截图的差异，这是由于从 drawable resources 加载的图标中存在细微的像素差异。出于性能原因，Android 维护了一个从资源加载的 drawables 缓存，底层位图可以在多个位置共享。由于我们不断变化的测试顺序，我们在测试中遇到的已经缓存的位图并不一致，缓存的版本可能会有所不同。

在一个案例中，问题是由修改 drawable 位图的代码引起的——将其更改为对 drawable 调用 mutate 首先防止缓存版本被更改并修复了剥落。由于这个原因，您应该小心地在共享位图上调用 mutate，但是我们无法使用这种方法来解决所有的可绘制性剥落问题。

我们能够通过在每次截图后强制清除缓存来解决剥落问题。没有明确公开的 API 来实现这一点，所以我们使用一种方法，这种方法利用了缓存在不兼容的配置更改时被清除的事实，我们可以像这样强制:

请注意，这种方法并不理想，它使用了受限制和不推荐使用的 API，并且依赖于对这些函数的实现细节的理解。我们现在只在 API 28 上测试，目前它很好地满足了我们的需求，但可能需要在未来进行调整。

## 内存不足异常

这些崩溃有两个潜在的原因:

1.  被测代码中的内存泄漏
2.  截屏过程中位图的低效管理。

为了最小化内存泄漏，我们将每个测试片段的目标持续时间保持在三分钟，以最小化在单个过程中运行的测试数量。此外，我们运行泄漏金丝雀来检测和报告泄漏。

在截图库中，我们可能需要捕捉长达 40，000 像素的位图。为了做到这一点，我们在所有截图中重复使用相同的位图，如果需要的话，回收并创建一个新的更大的位图。我们还在清单中启用了大堆的情况下运行应用程序。

## 延迟运行

我们发现特性偶尔会用 ***处理程序#postDelay*** 执行可运行的回调。一个常见的用例是强调一些 UI 动画，比如在确认消息显示后等待完成一个活动。虽然我们能够检测到主线程何时空闲(如前所述)，但是这种空闲检测不能应用于稍后提交运行的 Runnables，所以我们没有办法解释延迟的代码。

在这种情况下，我们让功能代码在需要延迟回调时调用包装函数。当测试框架处于活动状态时，这个包装器立即执行 runnable。这种包装方法的另一个好处是，我们提供了一个更符合 Kotlin 习惯的函数，比如***fragment . post(delay ms:Number = 0，callback: () - > Unit)*** 。

注意，在我们基于状态的架构中，理想情况下，UI 不会执行状态中没有跟踪的任意动作。然而，有时动画需要这样做，这是实现基本 UI 行为的最简单的方法。只要 UI 足够健壮，能够从可能中断已发布回调的配置更改中恢复，这就没问题。

## 非嘲笑状态

为了使屏幕行为具有确定性和可控性，屏幕应该只使用来自 ViewModel 状态的数据。乍一看，这似乎很简单，但我们偶尔会遇到违反的情况。如果该片段引用了任何注入的依赖项、可能访问单例的静态方法调用或可变的操作系统级调用(如获取设备区域设置),就会发生这种情况。

在我们的应用程序中，我们仍然有一些遗留系统是通过静态方法而不是依赖注入来访问的，这些系统通常被错误地访问。除了增加测试碎片的可能性，像这样滥用状态模式也意味着测试框架没有测试丢失数据的变化。Lint 规则有助于防止像这样的反模式用法，而带有依赖注入的良好项目架构可以强制实施最佳实践。

## 图像加载

显示图像的 UI 必须异步加载这些位图，这对测试来说是个问题。虽然加载图像是理想的，因为它充分测试了图像加载代码和行为，但它很麻烦，原因有几个:

*   测试框架必须能够检测所有图像何时加载。
*   图像加载可以有几种状态，如加载占位符、增量缩略图、失败资源和最终成功状态。我们不能简单地分别测试所有这些，或者简单地区分它们。
*   如果图像是从网络加载的，那么有可能由于网络问题而出现零星故障，从而导致碎片。
*   等待图像加载会增加测试时间。
*   即使我们允许加载图像，当截屏时，我们的测试框架会同步显示完整的活动，包括所有 RecyclerView 项目，这些项目可能最初没有显示。在这种情况下，我们不能等待新布局视图中的图像被加载，因为截图过程是同步发生的。

在我们的应用程序中，我们通过覆盖任何图像加载请求，而不是强制插入同步加载的本地可绘制资源来进行妥协。这有以下好处:

*   在截图中显示实际图像，而不是空白点
*   介绍一些图像加载行为，如 ImageView scaleType
*   同步工作，因此不需要等待图像加载的复杂性

虽然这个解决方案并不完美，但对我们来说是一个很好的妥协。此外，我们仍然允许屏幕通过一组映射到不同本地测试资产的测试 URL 来加载模拟中的不同图像。Mock state 可以选择使用哪些图像 URL 来改变截图中加载的图像类型，这有助于提高截图的质量。

这种方法是可行的，因为我们有一个所有功能都使用的集中式自定义 ImageView 体系结构。这使得嘲弄发生在我们的图像基础设施内的单一位置，对产品工程师来说完全不透明。

最后，我们的 JSON 报告捕获了在 ImageView 上设置的 url，所以即使我们没有截屏结果图片，我们仍然测试片段加载了预期的 url。

## Webview 嘲讽

网络视图面临着与图像视图相似的问题。加载内容的网络请求不稳定，很难准确等待。此外，加载的内容不受我们的控制，可能会随时更改截图位图。

因此，在我们的测试中，我们禁止所有的网页浏览者加载内容。这是通过将 Android WebView 包装在我们自己的自定义视图中来实现的，这样我们就可以在一个中心位置模拟它。

同样，像 ImageViews 一样，我们的 JSON 报告捕获要加载的 url，以及其他数据，如用户代理、标题和请求类型。这有助于验证比截图更多的数据。

## RecyclerView 预取

默认情况下，当 UI 线程在帧之间空闲时，RecyclerView 的 LinearLayoutManager 会预取其视口之外的屏幕视图。我们发现这可能会导致片状剥落，因为如果一个视图是由系统完全布局的，那么它的行为可能会不同于由我们的截屏系统同步布局的情况。值得注意的是，在第一种情况下，动画将 100%完成，但在第二种情况下，动画将仅处于开始状态。

此外，一般来说，我们发现最好禁用那些行为不一致的系统。在这种情况下，预取可能会发生，也可能不会发生，这取决于我们在截图之前空闲了多长时间。

相反，我们禁用这种行为；在测试活动布局一个片段后，它遍历 RecyclerView 实例的视图层次结构，并通过***setitempeffetchenabled(false)***禁用所有 LayoutManagers 上的预取。

# 下一步:CI 设置

本文展示了一系列常见的缺陷来源，以及我们如何在测试框架中从根本上消除它们。

接下来，[在我们的最后一篇文章](/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f)中，我们将介绍当工程师修改代码时，我们的测试是如何在 CI 上自动生成和运行的。

## 系列索引

这是关于 Airbnb 测试的七篇系列文章。

第 1 部分— [测试原理和模拟系统](/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a)

第 2 部分— [使用 MvRx 和 Happo 进行截图测试](/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab)

第 3 部分— [自动化交互测试](/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4)

第 4 部分— [单元测试框架视图模型](/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8)

第 5 部分— [我们自动化测试框架的架构](/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b)

**第六部分(本文)** — [一致嘲讽的障碍](/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f)

第 7 部分— [测试生成和 CI 配置](/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f)

## 我们在招人！

想和我们一起在这些和其他大规模的 Android 项目上合作吗？Airbnb 正在全公司招聘几个 Android 工程师职位！有关当前空缺，请参见[https://careers.airbnb.com](https://careers.airbnb.com/)。