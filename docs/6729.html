<html>
<head>
<title>How to code in Python: good and bad practices of coding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python编码:用Python编码的好与坏的实践</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-code-in-python-good-and-bad-practices-of-coding-in-python-e320bd581a3a?source=collection_archive---------0-----------------------#2019-10-28">https://medium.com/quick-code/how-to-code-in-python-good-and-bad-practices-of-coding-in-python-e320bd581a3a?source=collection_archive---------0-----------------------#2019-10-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a4f2c6c96876fa2a2a79e3a3d541b377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbWpmvknQSrX1wuVBAj1vQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — Programming Online Courses</a></figcaption></figure><p id="ed4f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发表于:<a class="ae it" href="https://www.blog.duomly.com/good-and-bad-practices-of-coding-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/good-and-bad-practices-of-coding-in-python/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="2df8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python是一种强调可读性的高级多范式编程语言。它是按照被称为<strong class="iw hi">Python之禅</strong>或<strong class="iw hi"> PEP 20 </strong>的规则开发、维护和经常使用的。</p><p id="55e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文展示了几个您可能经常遇到的用Python编码的好的和坏的实践的例子。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="16ba" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用解包编写简洁的代码</h1><p id="9e74" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">打包和解包是强大的Python特性。您可以使用解包来为变量赋值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ed41" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; a, b = 2, 'my-string'<br/>&gt;&gt;&gt; a<br/>2<br/>&gt;&gt;&gt; b<br/>'my-string'</strong></span></pre><p id="da2a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以利用这种行为来实现整个计算机编程世界中最简洁、最优雅的变量交换:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e836" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; a, b = b, a</strong><br/><strong class="lh hi">&gt;&gt;&gt; a</strong><br/><strong class="lh hi">'my-string'</strong><br/><strong class="lh hi">&gt;&gt;&gt; b</strong><br/><strong class="lh hi">2</strong></span></pre><p id="dea8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">太棒了。<br/>在更复杂的情况下，解包可用于多个变量的赋值。例如，您可以这样赋值:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="575e" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = (1, 2, 4, 8, 16)<br/>&gt;&gt;&gt; a = x[0]<br/>&gt;&gt;&gt; b = x[1]<br/>&gt;&gt;&gt; c = x[2]<br/>&gt;&gt;&gt; d = x[3]<br/>&gt;&gt;&gt; e = x[4]<br/>&gt;&gt;&gt; a, b, c, d, e<br/>(1, 2, 4, 8, 16)</strong></span></pre><p id="c801" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，您可以使用一种更简洁、更具可读性的方法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="876b" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; a, b, c, d, e = x</strong><br/><strong class="lh hi">&gt;&gt;&gt; a, b, c, d, e</strong><br/><strong class="lh hi">(1, 2, 4, 8, 16)</strong></span></pre><p id="d4a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很酷，对吧？但它甚至可以更酷:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6f50" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; a, *y, e = x</strong><br/><strong class="lh hi">&gt;&gt;&gt; a, e, y</strong><br/><strong class="lh hi">(1, 16, [2, 4, 8])</strong></span></pre><p id="af17" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">重点是带*的变量收集了没有赋给别人的值。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="37d7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用链接编写简洁的代码</h1><p id="b098" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">Python允许您链接比较操作。因此，您不必使用and来检查两个或多个比较是否为真:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7819" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = 4</strong><br/><strong class="lh hi">&gt;&gt;&gt; x &gt;= 2 and x &lt;= 8</strong><br/><strong class="lh hi">True</strong></span></pre><p id="e6de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相反，你可以像数学家一样，用更简洁的形式来写:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d971" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; 2 &lt;= x &lt;= 8</strong><br/><strong class="lh hi">True</strong><br/><strong class="lh hi">&gt;&gt;&gt; 2 &lt;= x &lt;= 3</strong><br/><strong class="lh hi">False</strong></span></pre><p id="ef9f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python也支持链式赋值。所以，如果你想给多个变量赋予相同的值，你可以用一种简单的方法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="65ec" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = 2</strong><br/><strong class="lh hi">&gt;&gt;&gt; y = 2</strong><br/><strong class="lh hi">&gt;&gt;&gt; z = 2</strong></span></pre><p id="af77" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一种更优雅的方式是使用解包:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ceb3" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x, y, z = 2, 2, 2</strong></span></pre><p id="fa56" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，使用链式分配，事情会变得更好:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9d41" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = y = z = 2</strong><br/><strong class="lh hi">&gt;&gt;&gt; x, y, z</strong><br/><strong class="lh hi">(2, 2, 2)</strong></span></pre><p id="594d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当你的值可变时要小心！所有变量都引用同一个实例。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="f7fb" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">检查无</h1><p id="53ba" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">在Python中，None是一个特殊且唯一的对象。它有一个类似的目的，就像类C语言中的null。</p><p id="fdac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以用比较运算符==和来检查变量是否引用了它！=:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="be82" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x, y = 2, None</strong><br/><strong class="lh hi">&gt;&gt;&gt; x == None</strong><br/><strong class="lh hi">False</strong><br/><strong class="lh hi">&gt;&gt;&gt; y == None</strong><br/><strong class="lh hi">True</strong><br/><strong class="lh hi">&gt;&gt;&gt; x != None</strong><br/><strong class="lh hi">True</strong><br/><strong class="lh hi">&gt;&gt;&gt; y != None</strong><br/><strong class="lh hi">False</strong></span></pre><p id="e7af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，一种更巧妙、更可取的方法是使用is和not:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d63d" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x is None</strong><br/><strong class="lh hi">False</strong><br/><strong class="lh hi">&gt;&gt;&gt; y is None</strong><br/><strong class="lh hi">True</strong><br/><strong class="lh hi">&gt;&gt;&gt; x is not None</strong><br/><strong class="lh hi">True</strong><br/><strong class="lh hi">&gt;&gt;&gt; y is not None</strong><br/><strong class="lh hi">False</strong></span></pre><p id="bdd9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，您应该更喜欢使用is not结构x not None，而不是可读性较差的替代结构not (x is None)。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="e76d" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">迭代序列和映射</h1><p id="ed73" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">您可以通过几种方式在Python中实现迭代和for循环。Python提供了一些内置的类来促进它。</p><p id="ebb9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">几乎在所有情况下，您都可以使用该范围来获得产生整数的迭代器:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="182b" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = [1, 2, 4, 8, 16]</strong><br/><strong class="lh hi">&gt;&gt;&gt; for i in range(len(x)):</strong><br/><strong class="lh hi">...     print(x[i])</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">8</strong><br/><strong class="lh hi">16</strong></span></pre><p id="92d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，有一种更好的方法来迭代序列:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="37bf" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for item in x:</strong><br/><strong class="lh hi">...     print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">8</strong><br/><strong class="lh hi">16</strong></span></pre><p id="c70a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是如果你想以相反的顺序迭代呢？当然，范围也是一个选项:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2a71" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for i in range(len(x)-1, -1, -1):</strong><br/><strong class="lh hi">...     print(x[i])</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">16</strong><br/><strong class="lh hi">8</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">1</strong></span></pre><p id="81a2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">颠倒顺序是一种更优雅的方式:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="78bf" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for item in x[::-1]:</strong><br/><strong class="lh hi">...     print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">16</strong><br/><strong class="lh hi">8</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">1</strong></span></pre><p id="57e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Pythonic式的方法是使用reversed来获得一个迭代器，该迭代器以相反的顺序产生序列中的各项:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2260" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for item in reversed(x):</strong><br/><strong class="lh hi">...     print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">16</strong><br/><strong class="lh hi">8</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">1</strong></span></pre><p id="55ca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有时，您需要序列中的项目和相应的索引:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="cee9" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for i in range(len(x)):</strong><br/><strong class="lh hi">...     print(i, x[i])</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">0 1</strong><br/><strong class="lh hi">1 2</strong><br/><strong class="lh hi">2 4</strong><br/><strong class="lh hi">3 8</strong><br/><strong class="lh hi">4 16</strong></span></pre><p id="cca7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最好使用enumerate获得另一个迭代器，该迭代器产生带有索引和条目的元组:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7afe" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for i, item in enumerate(x):</strong><br/><strong class="lh hi">...     print(i, item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">0 1</strong><br/><strong class="lh hi">1 2</strong><br/><strong class="lh hi">2 4</strong><br/><strong class="lh hi">3 8</strong><br/><strong class="lh hi">4 16</strong></span></pre><p id="47cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">太酷了。但是如果你想迭代两个或更多的序列呢？当然，您可以再次使用该范围:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6a78" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; y = 'abcde'</strong><br/><strong class="lh hi">&gt;&gt;&gt; for i in range(len(x)):</strong><br/><strong class="lh hi">...     print(x[i], y[i])</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1 a</strong><br/><strong class="lh hi">2 b</strong><br/><strong class="lh hi">4 c</strong><br/><strong class="lh hi">8 d</strong><br/><strong class="lh hi">16 e</strong></span></pre><p id="71bc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，Python也提供了更好的解决方案。您可以应用zip并获取相应项目的元组:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a4d1" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for item in zip(x, y):</strong><br/><strong class="lh hi">...     print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">(1, 'a')</strong><br/><strong class="lh hi">(2, 'b')</strong><br/><strong class="lh hi">(4, 'c')</strong><br/><strong class="lh hi">(8, 'd')</strong><br/><strong class="lh hi">(16, 'e')</strong></span></pre><p id="cfcb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以将它与拆包结合起来:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="877a" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for x_item, y_item in zip(x, y):</strong><br/><strong class="lh hi">...     print(x_item, y_item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1 a</strong><br/><strong class="lh hi">2 b</strong><br/><strong class="lh hi">4 c</strong><br/><strong class="lh hi">8 d</strong><br/><strong class="lh hi">16 e</strong></span></pre><p id="42cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，范围是非常有用的。然而，在某些情况下(如上图所示),有更方便的选择。迭代一个字典产生它的键:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5c2e" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; z = {'a': 0, 'b': 1}</strong><br/><strong class="lh hi">&gt;&gt;&gt; for k in z:</strong><br/><strong class="lh hi">... print(k, z[k])</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">a 0</strong><br/><strong class="lh hi">b 1</strong></span></pre><p id="708b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，您可以应用方法。items()并获取带有键和相应值的元组:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9fff" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for k, v in z.items():</strong><br/><strong class="lh hi">...     print(k, v)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">a 0</strong><br/><strong class="lh hi">b 1</strong></span></pre><p id="1f54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您也可以使用这些方法。按键()和。values()来分别迭代键和值。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="f7ea" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">与零比较</h1><p id="3969" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">当您有数字数据，并且您需要检查数字是否等于零时，您可以但不是必须使用比较运算符==和！=:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="488a" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; x = (1, 2, 0, 3, 0, 4)</strong><br/><strong class="lh hi">&gt;&gt;&gt; for item in x:</strong><br/><strong class="lh hi">...     if item != 0:</strong><br/><strong class="lh hi">...         print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">3</strong><br/><strong class="lh hi">4</strong></span></pre><p id="dd6d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Pythonic式的方法是利用这样一个事实:在布尔上下文中，零被解释为假，而所有其他数字都被认为是真:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1e78" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; bool(0)</strong><br/><strong class="lh hi">False</strong><br/><strong class="lh hi">&gt;&gt;&gt; bool(-1), bool(1), bool(20), bool(28.4)</strong><br/><strong class="lh hi">(True, True, True, True)</strong></span></pre><p id="1609" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">记住这一点，你可以只使用如果项目，而不是如果项目！= 0:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1f0f" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; for item in x:</strong><br/><strong class="lh hi">...     if item:</strong><br/><strong class="lh hi">...         print(item)</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">1</strong><br/><strong class="lh hi">2</strong><br/><strong class="lh hi">3</strong><br/><strong class="lh hi">4</strong></span></pre><p id="f2be" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以遵循相同的逻辑，使用if not item代替if item == 0。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="5f5a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">避免可变的可选参数</h1><p id="7b9f" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">Python有一个非常灵活的为函数和方法提供参数的系统。可选参数是该选项的一部分。但是要小心:你通常不想使用可变的可选参数。考虑下面的例子:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f748" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; def f(value, seq=[]):</strong><br/><strong class="lh hi">...     seq.append(value)</strong><br/><strong class="lh hi">...     return seq</strong></span></pre><p id="b7d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">乍一看是这样的，如果不提供seq，f()会在一个空列表中追加一个值，并返回类似于[value]的内容:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9298" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; f(value=2)</strong><br/><strong class="lh hi">[2]</strong></span></pre><p id="021c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看起来不错，对吧？不要！考虑下面的例子:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6307" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; f(value=4)</strong><br/><strong class="lh hi">[2, 4]</strong><br/><strong class="lh hi">&gt;&gt;&gt; f(value=8)</strong><br/><strong class="lh hi">[2, 4, 8]</strong><br/><strong class="lh hi">&gt;&gt;&gt; f(value=16)</strong><br/><strong class="lh hi">[2, 4, 8, 16]</strong></span></pre><p id="2b43" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">惊讶吗？迷茫？如果你是，你不是唯一一个。<br/>似乎每次调用函数时，可选参数(本例中为list)的实例都是相同的。也许有时你会想要上面的代码做什么。然而，更有可能的是，您需要避免这种情况。你可以用一些额外的逻辑来避免这种情况。其中一个方法是这样的:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8294" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; def f(value, seq=None):</strong><br/><strong class="lh hi">...     if seq is None:</strong><br/><strong class="lh hi">...         seq = []</strong><br/><strong class="lh hi">...     seq.append(value)</strong><br/><strong class="lh hi">...     return seq</strong></span></pre><p id="01da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更简短的版本是:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a89a" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; def f(value, seq=None):</strong><br/><strong class="lh hi">...     if not seq:</strong><br/><strong class="lh hi">...         seq = []</strong><br/><strong class="lh hi">...     seq.append(value)</strong><br/><strong class="lh hi">...     return seq</strong></span></pre><p id="2363" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，你会得到不同的行为:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="112d" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; f(value=2)</strong><br/><strong class="lh hi">[2]</strong><br/><strong class="lh hi">&gt;&gt;&gt; f(value=4)</strong><br/><strong class="lh hi">[4]</strong><br/><strong class="lh hi">&gt;&gt;&gt; f(value=8)</strong><br/><strong class="lh hi">[8]</strong><br/><strong class="lh hi">&gt;&gt;&gt; f(value=16)</strong><br/><strong class="lh hi">[16]</strong></span></pre><p id="2ec7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在大多数情况下，这是一个人想要的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="9a0e" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">避免传统的Getters和Setters</h1><p id="746b" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">Python允许像C++和Java一样定义getter和setter方法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="70b8" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; class C:</strong><br/><strong class="lh hi">...     def get_x(self):</strong><br/><strong class="lh hi">...         return self.__x</strong><br/><strong class="lh hi">...     def set_x(self, value):</strong><br/><strong class="lh hi">...         self.__x = value</strong></span></pre><p id="0b95" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是如何使用它们来获取和设置对象的状态:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="bac9" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; c = C()</strong><br/><strong class="lh hi">&gt;&gt;&gt; c.set_x(2)</strong><br/><strong class="lh hi">&gt;&gt;&gt; c.get_x()</strong><br/><strong class="lh hi">2</strong></span></pre><p id="215f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在某些情况下，这是完成工作的最佳方式。然而，定义和使用属性通常更优雅，尤其是在简单的情况下:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8396" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; class C:</strong><br/><strong class="lh hi">...     @property</strong><br/><strong class="lh hi">...     def x(self):</strong><br/><strong class="lh hi">...         return self.__x</strong><br/><strong class="lh hi">...     @x.setter</strong><br/><strong class="lh hi">...     def x(self, value):</strong><br/><strong class="lh hi">...         self.__x = value</strong></span></pre><p id="90d0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">属性被认为比传统的getters和setters更具Pythonic风格。您可以像在C#中一样使用它们，也就是说，与普通数据属性一样:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5e06" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; c = C()</strong><br/><strong class="lh hi">&gt;&gt;&gt; c.x = 2</strong><br/><strong class="lh hi">&gt;&gt;&gt; c.x</strong><br/><strong class="lh hi">2</strong></span></pre><p id="1b07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以，一般来说，尽可能使用属性，在必要时使用类似C++的getters和setters是一个好习惯。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="25a7" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">避免访问受保护的类成员</h1><p id="0997" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">Python没有真正的私有类成员。然而，有一个约定是，你不应该在成员实例之外访问或修改以下划线(_)开头的成员。它们不能保证保留现有的行为。</p><p id="b5be" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，考虑代码:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e499" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; class C:</strong><br/><strong class="lh hi">...     def __init__(self, *args):</strong><br/><strong class="lh hi">...         self.x, self._y, self.__z = args</strong><br/><strong class="lh hi">... </strong><br/><strong class="lh hi">&gt;&gt;&gt; c = C(1, 2, 4)</strong></span></pre><p id="0120" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">C类的实例有三个数据成员:。x，。_y，还有。_C__z。如果一个成员的名字以双下划线(dunder)开头，它会被修改。这就是为什么你有？_C__z而不是。__z. <br/>现在访问或者修改都挺OK的。直接x:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9118" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; c.x  # OK</strong><br/><strong class="lh hi">1</strong></span></pre><p id="730d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您还可以访问或修改。_y，但这被认为是一种不好的做法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2046" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; c._y  # Possible, but a bad practice!</strong><br/><strong class="lh hi">2</strong></span></pre><p id="dac9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你不能进入。__z，因为它已经损坏，但您可以访问或修改。_C__z:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b03c" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; c.__z # Error!</strong><br/><strong class="lh hi">Traceback (most recent call last):</strong><br/><strong class="lh hi">File "", line 1, in </strong><br/><strong class="lh hi">AttributeError: 'C' object has no attribute '__z'</strong><br/><strong class="lh hi">&gt;&gt;&gt; c._C__z # Possible, but even worse!</strong><br/><strong class="lh hi">4</strong><br/><strong class="lh hi">&gt;&gt;&gt;</strong></span></pre><p id="d0aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你应该避免这样做。该类的作者可能会以下划线开头来告诉您“不要使用它”。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="318f" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用上下文管理器释放资源</h1><p id="8b4c" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">有时需要编写代码来正确管理资源。在处理文件、数据库连接或其他具有非托管资源的实体时，经常会出现这种情况。例如，您可以打开并处理一个文件:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4303" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; my_file = open('filename.csv', 'w')</strong><br/><strong class="lh hi">&gt;&gt;&gt; # do something with `my_file`</strong></span></pre><p id="4f34" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要正确管理内存，您需要在完成作业后关闭该文件:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0d0f" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; my_file = open('filename.csv', 'w')<br/>&gt;&gt;&gt; # do something with `my_file and`<br/>&gt;&gt;&gt; my_file.close()</strong></span></pre><p id="7d8a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这样做总比不做好。但是，如果在处理您的文件时出现异常，该怎么办呢？那么my_file.close()永远不会执行。您可以使用异常处理语法或上下文管理器来处理这个问题。第二种方法是将代码放在带有块的中:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e24e" class="ll ka hh lh b fi lm ln l lo lp"><strong class="lh hi">&gt;&gt;&gt; with open('filename.csv', 'w') as my_file:</strong><br/><strong class="lh hi">...     # do something with `my_file`</strong></span></pre><p id="ce07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用with块意味着特殊方法。__输入_ _()和。__exit__()被调用，即使在异常情况下也是如此。这些方法应该照顾到资源。通过结合上下文管理器和异常处理，您可以实现特别健壮的结构。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="b7e5" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">风格建议</h1><p id="5580" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">Python代码应该优雅、简洁、易读。应该很美。</p><p id="ed3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于如何编写漂亮的Python代码的终极资源是Python代码的<strong class="iw hi">风格指南</strong>或<strong class="iw hi"> PEP 8 </strong>。如果你想用Python编码，你绝对应该读一读。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="8c9a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="cd7c" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">本文就如何编写更高效、更易读、更简洁的代码给出了几个建议。简而言之，它展示了如何编写Pythonic代码。另外，PEP 8提供了Python代码的风格指南，PEP 20代表了Python语言的原理。</p><p id="1721" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">享受编写Pythonic式的、有用的、漂亮的代码吧！</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/2bebe9fe48fb99c5d1c4456e97533030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5SfHeLRaGv3R2TzVAO_yw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — Programming Online Courses</a></figcaption></figure><p id="40ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="0126" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章是我们的队友米尔科准备的。</p></div></div>    
</body>
</html>