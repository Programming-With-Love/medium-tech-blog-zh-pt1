<html>
<head>
<title>Effective Java in Kotlin, obsolete items thanks to Kotlin (items 3, 4, 16, 40, 61 from 3rd edition)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中有效的Java，由于Kotlin而过时的项目(第三版中的项目3、4、16、40、61)</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-java-in-kotlin-obsolete-items-thanks-to-kotlin-items-3-4-16-40-61-from-3rd-edition-31952da308f4?source=collection_archive---------1-----------------------#2018-07-23">https://blog.kotlin-academy.com/effective-java-in-kotlin-obsolete-items-thanks-to-kotlin-items-3-4-16-40-61-from-3rd-edition-31952da308f4?source=collection_archive---------1-----------------------#2018-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/5fb16677021941c3d9fcac2201f3f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDO4n2-X33Ld-o4iDb3pWQ.png"/></div></div></figure><div class=""/><p id="3320" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Kotlin是对Java的巨大改进。它是在已知Java主要缺陷的情况下设计的，因此它可以一劳永逸地解决许多问题。让我们讨论一下来自约书亚·布洛赫的<a class="ae kt" href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997" rel="noopener ugc nofollow" target="_blank">有效的Java书</a>中的一些观点，因为我们使用了科特林，这些观点不再适用。</p><h2 id="ca34" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">第3项:用私有构造函数或枚举类型强制singleton属性</h2><p id="678c" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">该项的目的是确保单例不会有一个以上的实例。这本书展示了几个如何做的好模式。它在Kotlin中不适用，因为我们有对单例模式的内置支持，称为<em class="ls">对象声明</em>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8501" class="ku kv iy ly b gy mc md l me mf">object ThisIsSingleton {<br/>    val prop = 10<br/>    fun method() = 20<br/>}</span><span id="ea85" class="ku kv iy ly b gy mg md l me mf">// Usage<br/>print(ThisIsSingleton.prop) // 10<br/>print(ThisIsSingleton.method()) // 20</span></pre><p id="0e60" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它不仅更容易使用和声明，而且是绝对安全的。实际上，Kotlin在幕后使用了Effective Java模式中首次描述的正确的单例声明。</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mh"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h2 id="dd16" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">第4项:用私有构造函数强制实现非可实现性</h2><p id="b779" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这一点是Java不允许顶级函数，所以所有这样的函数都作为静态成员放在util类中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8758" class="ku kv iy ly b gy mc md l me mf">// Java<br/>class StringUtils {<br/>    public static String trim(s: String) { /*...*/ }<br/>}</span></pre><p id="a1cc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这在科特林没有意义，因为它给了我们更好的选择。直接对等的是顶级函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="81f2" class="ku kv iy ly b gy mc md l me mf">fun trim(s: String): String { /*...*/}</span></pre><p id="a548" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管在这种情况下我们宁愿定义顶级扩展函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c9d5" class="ku kv iy ly b gy mc md l me mf">fun String.trim(): String { /*...*/}</span></pre><p id="09a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两者都在JVM中被编译成类中的静态方法，该方法不能被初始化。</p><p id="5356" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法是对象声明:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d884" class="ku kv iy ly b gy mc md l me mf">object StringUtils {<br/>    fun trim(s: String): String { /*...*/}<br/>}</span></pre><p id="ad0d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以初始化对象声明，但这是我们可以使用的一个设计好的行为:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="55fa" class="ku kv iy ly b gy mc md l me mf"><strong class="ly iz">interface </strong>CarFactory {<br/>    <strong class="ly iz">val prize</strong>: Int<br/>    <strong class="ly iz">fun </strong>makeCar(): Car<br/>}<br/><br/><strong class="ly iz">object </strong>Fiat126PFactory: CarFactory {<br/>    <strong class="ly iz">override val prize</strong>: Int = 500<br/>    <strong class="ly iz">override fun </strong>makeCar(): Car = <em class="ls">TODO</em>()<br/>}<br/><br/><strong class="ly iz">object </strong>OpelAstraFactory: CarFactory {<br/>    <strong class="ly iz">override val prize</strong>: Int = 2_500<br/>    <strong class="ly iz">override fun </strong>makeCar(): Car = <em class="ls">TODO</em>()<br/>}<br/><br/><strong class="ly iz">object </strong>FerrariFactory: CarFactory {<br/>    <strong class="ly iz">override val prize</strong>: Int = 500_000<br/>    <strong class="ly iz">override fun </strong>makeCar(): Car = <em class="ls">TODO</em>()<br/>}<br/><br/><strong class="ly iz">val </strong><em class="ls">factories </em>= <em class="ls">listOf</em>(<br/>    Fiat126PFactory, <br/>    OpelAstraFactory, <br/>    FerrariFactory<br/>)<br/><strong class="ly iz">val </strong><em class="ls">cheapestCar </em>= <em class="ls">factories</em>.<em class="ls">minBy </em><strong class="ly iz">{ it</strong>.<strong class="ly iz">prize }</strong>?.makeCar()</span></pre><h2 id="2934" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">第16条:在公共类中，使用访问器方法，而不是公共字段</h2><p id="f0c9" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这是对Java最明显的改进。嗯，在Java中我们有<strong class="jx iz">字段</strong>，而在Kotlin中我们有<strong class="jx iz">属性</strong>。它们看起来几乎一样，但是关键的区别在于，对于Kotlin属性，我们总是可以设置自定义setter。这意味着它们被封装。为了在Java中实现这一点，我们需要使用field、getter和setter。我们来看一些例子。以下是科特林的财产:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4b2e" class="ku kv iy ly b gy mc md l me mf">var name: String = "Marcin Moskala"</span></pre><p id="e743" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相当于下面的Java字段和访问器:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4a01" class="ku kv iy ly b gy mc md l me mf">// Java<br/>@NotNull<br/><strong class="ly iz">private </strong>String <em class="ls">name </em>= <strong class="ly iz">"Marcin Moskala"</strong>;<br/><br/>@NotNull<br/><strong class="ly iz">public </strong>String getName() {<br/>   <strong class="ly iz">return </strong><em class="ls">name</em>;<br/>}<br/><br/><strong class="ly iz">public void </strong>setName(@NotNull String name) {<br/>   Intrinsics.<em class="ls">checkParameterIsNotNull</em>(var0, <strong class="ly iz">"&lt;set-?&gt;"</strong>);<br/>   <strong class="ly iz">this</strong>.<em class="ls">name </em>= name;<br/>}</span></pre><p id="c861" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个属性用法实际上都在使用setters和getters。我们总是可以设置自定义的setters和getters:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8e05" class="ku kv iy ly b gy mc md l me mf"><strong class="ly iz">var </strong><em class="ls">name</em>: String = <strong class="ly iz">"Marcin Moskala"<br/>    get</strong>() = <strong class="ly iz">field</strong>.<em class="ls">trim</em>()<br/>    <strong class="ly iz">set</strong>(value) {<br/>        <strong class="ly iz">if</strong>(value.<em class="ls">isNotEmpty</em>())<br/>            <strong class="ly iz">field </strong>= value<br/>    }</span></pre><p id="24d4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">会编译成这样:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="cb00" class="ku kv iy ly b gy mc md l me mf">// Java<br/>@NotNull<br/><strong class="ly iz">private </strong>String <em class="ls">name </em>= <strong class="ly iz">"Marcin Moskala"</strong>;<br/><br/>@NotNull<br/><strong class="ly iz">public </strong>String getName() {<br/>   <strong class="ly iz">return </strong>StringsKt.<em class="ls">trim</em>(<em class="ls">name</em>).toString();<br/>}<br/><br/><strong class="ly iz">public void </strong>setName(@NotNull String value) {<br/>   <strong class="ly iz">if </strong>(value.length() &gt; 0) {<br/>      <em class="ls">name </em>= value;<br/>   }<br/>}</span></pre><p id="4d71" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，Kotlin确保了有效Java所建议的行为，很难绕过它。我们总是可以改变属性setter和getter，而不改变Kotlin中的用法。</p><h2 id="59b7" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">第40项:始终使用覆盖注释</strong></h2><p id="7cc8" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">与Java <code class="fe mi mj mk ly b">Override</code>注释不同，<code class="fe mi mj mk ly b">override</code>修饰符在Kotlin中是必需的。这是这本书建议的顶峰。</p><h2 id="f50e" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">第61项:比起装箱的原语，更喜欢原语类型</strong></h2><p id="8ed2" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">你在科特林见过原始类型吗？当我阅读编译的Kotlin代码时，我经常看到它们。关键是Kotlin中的每个类型都像一个装箱的类型，但是只要有可能，Kotlin编译器就在幕后使用原语。这意味着只要有可能，Kotlin <code class="fe mi mj mk ly b">Int</code>就是<code class="fe mi mj mk ly b">int</code>，当需要一些OOP特性时(比如可空性或泛型的用法)，就是<code class="fe mi mj mk ly b">Integer</code>。有人可能会考虑特定的<code class="fe mi mj mk ly b">Int</code>用法来允许编译器在幕后使用原语，但我认为这绝对是一个可怕的想法。潜在的性能和内存改进将是次要的，而代码中引入的混乱将是实质性的。我能想到的唯一合理的情况是，当我们需要对一组原语进行操作时。我在另一篇文章的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/effective-kotlin-use-arrays-with-primitives-for-performance-critical-processing-297283ed1f90">中用<code class="fe mi mj mk ly b">Integer</code>代替<code class="fe mi mj mk ly b">int</code>的案例一起描述过。现在只要记住你不需要担心Kotlin中的原语，因为Kotlin编译器会为你努力工作并优化你的代码。</a></p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><a href="https://www.kt.academy/"><div class="gh gi mh"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h1 id="37f4" class="ml kv iy bd kw mm mn mo kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb bi translated">摘要</h1><p id="dcc6" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">Kotlin引入了一些特性，使得优秀的编程变得更加容易。这就是为什么一些有效的Java项目已经过时，我们不再需要担心它们了。也有许多项目仍然有效，但Kotlin <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/effective-java-in-kotlin-item-2-consider-a-builder-when-faced-with-many-constructor-parameters-1927e69608e1">使它们更容易应用</a>或<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/effective-java-in-kotlin-item-1-consider-static-factory-methods-instead-of-constructors-8d0d7b5814b2">引入了更多的可能性</a>。在下一部分，我们将讨论书中更多的条目。还有我的一套有效的科特林法则。我将在下一本书中介绍它们，但我也在<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="https://blog.kotlin-academy.com/effective-kotlin/home">单独的文章</a>中分享了其中一些。</p><h1 id="178f" class="ml kv iy bd kw mm mn mo kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb bi translated">有效科特林</h1><p id="a490" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这篇文章是“有效的科特林”系列的一部分，与我将要出版的书有关。您会发现Kotlin中有一组可读性、可伸缩性和性能的最佳实践:</p><div class="im in gp gr io nc"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iz gy z fp nh fr fs ni fu fw ix bi translated">有效科特林</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">这本书对好的实践进行了深入的分析，包括官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">leanpub.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq iu nc"/></div></div></a></div><p id="ebcc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并使我们更快地发布它，<a class="ae kt" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用此链接并订阅</a>。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="ed97" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae kt" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="ccff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为您带来关于<a class="ae kt" href="https://blog.kotlin-academy.com/" rel="noopener ugc nofollow" target="_blank"> Kt的最新重大新闻。学院</a>、<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅快讯</a>、<a class="ae kt" href="https://twitter.com/kot_academy" rel="noopener ugc nofollow" target="_blank">观察推特</a>关注。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Twitter上引用我，用<a class="ae kt" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。使用以下链接订阅时事通讯:</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mh"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>