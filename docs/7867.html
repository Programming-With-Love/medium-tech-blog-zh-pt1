<html>
<head>
<title>Building Secure Docker Images - 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建安全的Docker映像- 101</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/building-secure-docker-images-101-3769b760ebfa?source=collection_archive---------0-----------------------#2020-04-02">https://medium.com/walmartglobaltech/building-secure-docker-images-101-3769b760ebfa?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0ed7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker容器使得软件的分发更加容易，并且简化了系统上的资源共享。默认情况下或用户自定义时，容器映像配置中的漏洞会导致安全事件。</p><p id="780d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文总结了构建安全Docker映像的基本步骤。那些使用Docker图像的人会对本文感兴趣，这些图像要么是现成的，要么是在流行的基础图像上构建自定义层。本文将逐步引导您了解构建安全Docker映像的基本安全最佳实践，并评估现成的基础映像。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/ee82a8830b4a272cbbf370cc59675750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exs5pcBYF-Q32T_zdUcBNQ.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image Source <a class="ae js" href="https://pixabay.com/photos/container-cargo-freight-harbor-489933/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com</a></figcaption></figure><h2 id="2181" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak"> 1。作为非根用户运行容器</strong></h2><p id="2380" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><code class="du kt ku kv kw b">root</code>是Docker容器中的默认用户。</p><p id="600f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果在启动容器时没有指定用户，默认情况下，它将作为映像中设置的用户(docker文件中的最后一个<code class="du kt ku kv kw b">USER</code>命令)或从父映像文件继承的用户(由docker文件中的<code class="du kt ku kv kw b">FROM</code>命令指定)运行。</p><p id="4129" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果用户既没有在启动容器时被指定，也没有出现在映像中，那么容器将作为<code class="du kt ku kv kw b">root</code> (uid 0)运行。</p><p id="dde5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">建议创建一个非root用户来运行容器的第一个进程。除此之外，必须删除任何不需要的用户。</p><p id="e7e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行以下命令找出用户名/用户id。如果返回一个空白，这意味着容器作为根运行。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="39cb" class="jt ju hh kw b fi lb lc l ld le">docker ps — quiet — all | xargs docker inspect — format ‘{{ .Id }}: User={{ .Config.User }}’</span></pre><p id="7959" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行图像时，使用<code class="du kt ku kv kw b">USER</code>命令设置用户，以及docker文件中其后的任何<code class="du kt ku kv kw b">RUN</code>、<code class="du kt ku kv kw b">CMD</code>和<code class="du kt ku kv kw b">ENTRYPOINT</code>指令。</p><p id="9618" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du kt ku kv kw b">DOCKER HISTORY</code>检查图像，查看用户是否设置运行命令</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="b250" class="jt ju hh kw b fi lb lc l ld le">docker history &lt;Image Name/ID&gt;</span></pre><h2 id="7efd" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">2.从映像中删除不必要的包/软件</h2><p id="9b12" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在Docker映像中包含不必要的包不仅会增大映像的大小，还会增加容器的攻击面。必须仔细检查所有Docker映像中已安装的包，并且必须只包括容器中服务运行所需的包。</p><p id="af00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">人们可以通过使用Alpine、BusyBox等极简的基础图像来开始构建他们的Docker图像。</p><p id="4c05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要列出容器中安装的所有软件包，请运行以下命令:</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="823f" class="jt ju hh kw b fi lb lc l ld le">docker exec &lt;CONTAINER_ID&gt; apk info</span></pre><p id="4ef7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述命令专用于<code class="du kt ku kv kw b">apk</code>包管理器。根据您的映像包管理器，必须修改上面的命令。</p><p id="9970" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还可以考虑在生产环境中使用映像之前删除软件包安装程序。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lf"><img src="../Images/3588bd66a694a768a98a3a6db1071db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mg6Ii8ibJPomegYj1tn8Ag.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Image Source https:/<a class="ae js" href="https://pixabay.com/photos/hamburg-port-of-hamburg-3021820/" rel="noopener ugc nofollow" target="_blank">/</a>pixabay.com</figcaption></figure><h2 id="0e4f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">3.扫描并重建映像以包含安全补丁</h2><p id="f12c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">无论您是从头开始构建Docker映像，还是在第三方映像的基础上构建映像，作为持续集成过程的一部分，对映像进行漏洞扫描是非常重要的。这包括扫描包含的包、二进制文件、库、文件等。针对一个或多个众所周知的漏洞数据库。</p><p id="fce8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有许多流行的开源Docker扫描工具可用。一些最受欢迎的是<a class="ae js" href="https://github.com/anchore/anchore-engine" rel="noopener ugc nofollow" target="_blank"> Anchore-Engine </a>、<a class="ae js" href="https://coreos.com/clair/" rel="noopener ugc nofollow" target="_blank"> CoreOs-Clair </a>、<a class="ae js" href="https://github.com/eliasgranderubio/dagda" rel="noopener ugc nofollow" target="_blank"> Dagda </a>、<a class="ae js" href="https://csrc.nist.gov/projects/security-content-automation-protocol" rel="noopener ugc nofollow" target="_blank"> Open-SCAP </a>等。</p><h2 id="6f95" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">4.启用Docker内容信任(DCT)</h2><p id="bced" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Docker内容信任(DCT)使用数字签名来验证从远程Docker注册表中提取的图像的完整性。使用DCT，图像发布者，无论是个人还是组织，都可以在他们的图像上签名。图像的消费者可以通过验证数字签名来验证图像的完整性，以确保图像没有被篡改。</p><p id="ba54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果启用了DCT，<code class="du kt ku kv kw b">pull</code>、<code class="du kt ku kv kw b">run</code>和<code class="du kt ku kv kw b">build</code>，指令将仅适用于可信(签名)映像。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="4b84" class="jt ju hh kw b fi lb lc l ld le">echo $DOCKER_CONTENT_TRUST</span></pre><p id="30f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">确保上述命令的输出为1，因为它表示DCT已启用。默认情况下，禁用DCT。要启用DCT，请运行以下命令。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="9280" class="jt ju hh kw b fi lb lc l ld le">export DOCKER_CONTENT_TRUST=1</span></pre><p id="1b34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">DCT对于构建安全的Docker映像非常重要，因为它确保了基本映像及其发布者身份的完整性。如果出于某种原因，您希望在拉取、运行或构建映像时禁用DCT，那么值设置为false的<em class="lg"> - disable content-trust </em>标志可能会派上用场。</p><h2 id="061c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">5.在Dockerfile中使用复制而不是添加</h2><p id="2dd4" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><code class="du kt ku kv kw b">COPY</code>和<code class="du kt ku kv kw b">ADD</code>指令在功能上非常相似。这两条指令都可以用来将本地文件复制到容器映像的文件系统中。<code class="du kt ku kv kw b">ADD</code>指令具有更多功能，如本地tar文件提取和远程URL获取。</p><p id="cbca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Dockerfile文件中使用<code class="du kt ku kv kw b">ADD</code>指令会带来不经扫描就从远程URL添加恶意文件的风险。</p><p id="44e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，<code class="du kt ku kv kw b">ADD</code>指令的最佳用途是将tar归档文件复制到映像文件系统中，并自动提取它们。只要有可能，必须使用<code class="du kt ku kv kw b">COPY</code>代替<code class="du kt ku kv kw b">ADD</code>指令。</p><p id="2b70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用户可以通过使用<code class="du kt ku kv kw b">DOCKER HISTORY</code>命令来检查图像，以检查在构建图像时<code class="du kt ku kv kw b">ADD</code>命令的使用。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="7ccc" class="jt ju hh kw b fi lb lc l ld le">docker history &lt;Image Name/ID&gt;</span></pre><h2 id="5149" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">6.不要在Dockerfile中存储任何秘密</h2><p id="3377" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">密码、API密钥、私有密钥和其他秘密决不能成为other文件的一部分。Dockerfile中的秘密很容易被像<code class="du kt ku kv kw b">DOCKER HISTORY</code>这样的简单命令暴露，一旦暴露就可能被对手利用。</p><p id="31e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Dockerfile永远不应该被用来传递秘密。要确保docker文件中没有秘密，一个简单的方法是使用<code class="du kt ku kv kw b">DOCKER HISTORY</code>命令并仔细检查它的内容。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="5e1c" class="jt ju hh kw b fi lb lc l ld le">docker history &lt;Image Name/ID&gt;</span></pre><h2 id="bd91" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">7.安装经过验证的软件包并使用可信基础映像</h2><p id="700d" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">仅从受信任的资料库安装软件包。除此之外，使用校验和和数字签名来验证下载包的真实性和完整性。</p><p id="c2ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du kt ku kv kw b">FROM</code>指令时，请务必使用标签。让我们深入研究一下这个建议。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="2e84" class="jt ju hh kw b fi lb lc l ld le">FROM alpine</span></pre><p id="9fcb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的命令是不好的，因为它总是拉最新的标签，这是经常变化的，也可能是不稳定的。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="ad3b" class="jt ju hh kw b fi lb lc l ld le">FROM alpine:3.11</span></pre><p id="a0bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的命令更好，因为它将基础映像固定到某个版本。人们仍然可以期待它的变化，包括小的更新和安全修复。如果想每次都使用相同的图像，那么他们可以通过<code class="du kt ku kv kw b">FROM</code>指令使用摘要。使用摘要还可以防止图像被篡改和损坏。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="120d" class="jt ju hh kw b fi lb lc l ld le">FROM alpine@sha256:ddba4d27a7ffc3f86dd6c2f92041af252a1f23a8 e742c90e6e1297bfa1bc0c45</span></pre><p id="d9ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，就像下载软件包时的基本映像一样，使用校验和和数字签名检查软件包的完整性和真实性。如果通过不安全的通道(HTTP)下载包，这将保护包免受意外损坏和MITM。</p><h2 id="b0cb" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">8.从映像中删除setuid和setgid权限</h2><p id="2300" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><code class="du kt ku kv kw b">setuid</code>(执行时设置用户ID)是Unix中一种特殊的权限类型，它允许用户以提升的权限执行某些程序。当设置了可执行文件的<code class="du kt ku kv kw b">setuid</code>权限时，用户可以使用与拥有该文件的<a class="ae js" href="https://www.computerhope.com/unix/uchown.htm" rel="noopener ugc nofollow" target="_blank">或</a>用户相匹配的访问级别来执行该程序。</p><p id="0244" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kt ku kv kw b">setgid</code>(执行时设置组ID)与<code class="du kt ku kv kw b">setuid</code>类似，唯一的区别是——当具有setgid权限的可执行文件运行时，它就像该文件所属的同一个组的成员一样运行。</p><p id="cede" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从二进制文件中删除<code class="du kt ku kv kw b">setuid</code>和<code class="du kt ku kv kw b">setgid</code>权限可以防止它们被滥用于特权提升攻击。</p><p id="fb8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要查找Docker映像中设置了<code class="du kt ku kv kw b">setuid</code>和<code class="du kt ku kv kw b">setgid</code>权限的所有可执行文件，请运行以下命令:</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="517e" class="jt ju hh kw b fi lb lc l ld le">docker run &lt;Image Name/ID&gt; find / -perm +6000 -type f -exec ls -ld {} \; 2&gt; /dev/null</span></pre><p id="3f96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">映像的维护者必须仔细检查作为上述命令的输出返回的所有文件的列表，然后必须从所有不需要的可执行文件中删除<code class="du kt ku kv kw b">setuid</code>和<code class="du kt ku kv kw b">setgid</code>权限。</p><p id="5f18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过在Dockerfile文件中包含以下内容，可执行二进制文件也可以在构建映像时<strong class="ig hi">缺省</strong>。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="ca46" class="jt ju hh kw b fi lb lc l ld le">FROM alpine:3.11<br/> <br/>RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true</span></pre><h2 id="597a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">9.小心使用Dockerfile中的更新指令</h2><p id="4cbf" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如果您在Docker文件中使用像<code class="du kt ku kv kw b">apt-get update</code>或<code class="du kt ku kv kw b">apk update</code>(取决于基本映像和包管理器)这样的包更新指令，请确保它们不会单独出现在一个Docker文件行中。</p><p id="0840" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果包更新指令出现在docker文件的一行中，那么将使用相同的缓存更新层。这将阻止任何新的更新成为后续构建的一部分。</p><p id="ea73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要减轻此问题，请检查您的docker文件并删除任何单独出现的更新指令。如果您无权访问docker文件，您可以使用<code class="du kt ku kv kw b">DOCKER HISTORY</code>命令来验证没有单独的更新指令。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="9fea" class="jt ju hh kw b fi lb lc l ld le">docker history &lt;Image Name/ID&gt;</span></pre><p id="8edf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你也可以使用你的<code class="du kt ku kv kw b">--no-cache</code>标志来消除任何缓存层，同时建立Docker图像。</p><h2 id="54b2" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">10.将运行状况检查添加到Docker映像</h2><p id="a54b" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><code class="du kt ku kv kw b">HEALTHCHECK</code>指令可用于检查集装箱是否仍在运行。如果Docker映像指定了运行状况检查，则除了正常状态之外，映像还将具有运行状况。健康状态最初为<code class="du kt ku kv kw b">starting</code>。每当健康检查通过，它就变成<code class="du kt ku kv kw b">healthy</code>(无论它之前处于什么状态)。连续失败一定次数后，变为<code class="du kt ku kv kw b">unhealthy</code>。</p><p id="49b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于集装箱的健康状况，码头工人可以供应新的集装箱来替换不健康的集装箱。</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="f09a" class="jt ju hh kw b fi lb lc l ld le">HEALTHCHECK --interval=5m --timeout=3s \<br/> CMD curl <a class="ae js" href="https://localhost:8443/version" rel="noopener ugc nofollow" target="_blank">https://localhost:8443/version</a> -k || exit 1</span></pre><p id="c3cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将上述<code class="du kt ku kv kw b">HEALTCHCHECK</code>指令包含到Docker文件将每五分钟检查一次在端口8443上运行的web服务器是否能够在三秒钟内提供版本API。</p><p id="1b5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可用性是安全性的三大支柱之一(另外两个是机密性和完整性)，而<code class="du kt ku kv kw b">HEALTHCHECK</code>指令可以用来确保Docker容器中运行的服务始终运行。</p><p id="1e93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要确保Docker映像中存在<code class="du kt ku kv kw b">HEALTHCHECK</code>指令，请运行以下命令:</p><pre class="jd je jf jg fd kx kw ky kz aw la bi"><span id="251a" class="jt ju hh kw b fi lb lc l ld le">docker inspect --format='{{ .Config.Healthcheck }}' &lt;Image Name/ID&gt;</span></pre></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="1627" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">参考资料:</h2><p id="37a2" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices/</a></p><p id="682a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【https://docs.docker.com/engine/reference/run/#user T2】号</p><p id="782f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【https://hub.docker.com/_/alpine T4】</p><p id="1489" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://pixabay.com/photos/hamburg-port-of-hamburg-3021820/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/photos/hamburg-port-of-hamburg-3021820/</a></p><p id="5899" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/engine/security/trust/content_trust/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/security/trust/content _ trust/</a></p><p id="1430" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/engine/reference/commandline/cli/#environment-variables" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/command line/CLI/#环境变量</a></p><p id="5954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices/# add-or-copy</a></p><p id="889c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits" rel="noopener ugc nofollow" target="_blank">https://Linux config . org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits</a></p><p id="4970" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/engine/reference/builder/#healthcheck" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/builder/# health check</a></p><p id="e75b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://docs.docker.com/compliance/cis/docker_ce/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compliance/cis/docker_ce/</a></p></div></div>    
</body>
</html>