<html>
<head>
<title>Always Be Closing: The Tale of a Go Resource Leak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总是被关闭:一个Go资源泄漏的故事</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/always-be-closing-3d5fda0e00da?source=collection_archive---------0-----------------------#2017-07-11">https://medium.com/square-corner-blog/always-be-closing-3d5fda0e00da?source=collection_archive---------0-----------------------#2017-07-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="6476" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="e973" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">这是一个关于Square的一个Go服务发生资源泄漏的故事，以及发现根本原因的过程。面对尖锐而神秘的系统指标，我们使用了各种标准的和自制的工具来发现我们的一个核心内部框架中的一个微妙的错误。</p><p id="d0e5" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">今年早些时候，我们的一个Go服务开始使用明显更多的内存，打破了稳定的内存使用状态和可预测的垃圾收集模式。与此同时，CPU的使用率也在上升。这个特定的服务通常使用大约200 MB的内存，但是这个数字很快就增长到了几GB。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/45790d90302aa51346abd78566ec147c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/0*CselbLpC1KKSPqu7."/></div></figure><p id="a112" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">经过大量调查，发现对于大量请求，错误的组合导致服务将每个请求的元数据保留了近17个小时，而不是几毫秒。最终，有两个根本原因，这两个原因都被另一个服务中一个看似良性的配置错误逗乐了。虽然只有一个服务受到影响，但我们的许多其他Go服务都可能受到这个bug的影响。</p><p id="2164" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这篇文章首先解释了我们遇到的错误，然后叙述了我们采取的各种调查步骤，其中一些步骤比其他步骤更有成效。</p><h1 id="3bbe" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">根本原因和经验教训</h1><p id="dc1a" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">最终，根本原因是由于不正确地使用了Go的<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/context/#Context" rel="noopener ugc nofollow" target="_blank">Context</a></code>类型。在Square，我们有一个定制的框架来处理传入的请求并分派给处理函数。这个框架代码创建了有截止日期的<code class="du ld le lf lg b">Context</code>，但是在请求完成后，没有取消<code class="du ld le lf lg b">Context</code>来释放相关资源。这导致堆上每个<code class="du ld le lf lg b">Context</code>对象的生命周期超过了其相关请求的生命周期。</p><p id="03c3" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这个根本原因被另一个服务中的一个配置更改所触动，该服务无意中将其客户端请求超时设置为60，000 <em class="lh">秒</em>，而不是预期的60，000 <em class="lh">毫秒</em>。这个客户端错误配置导致它的每个请求的<code class="du ld le lf lg b">Context</code>被有问题的服务器保留了60，000秒(16.7小时)，而不是几毫秒。</p><h2 id="929e" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">围棋语境:快速入门</h2><p id="f205" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">在Go中，<code class="du ld le lf lg b">Context</code>是一个接口，用作传递单个请求或操作的不可变元数据的一般方式。</p><p id="c3a1" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">一个<code class="du ld le lf lg b">Context</code>由一个键-值对创建，可以被另一个<code class="du ld le lf lg b">Context</code>包装以添加或覆盖数据。外部/包装/子<code class="du ld le lf lg b">Context</code>可以访问其包装/父<code class="du ld le lf lg b">Context</code>的数据，但反之亦然。</p><p id="ce6d" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这里有一个简单的例子来说明<code class="du ld le lf lg b">Context</code>是如何产生的:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="086b" class="li kb hh lg b fi ma mb l mc md">rootCtx := context.Background() // Returns a singleton</span><span id="b72a" class="li kb hh lg b fi me mb l mc md">// a is a child of rootCtx<br/>a := context.WithValue(rootCtx, "location", "San Francisco") </span><span id="d743" class="li kb hh lg b fi me mb l mc md">// b is a child of a<br/>b := context.WithValue(a, "weather", "foggy")</span><span id="56be" class="li kb hh lg b fi me mb l mc md">// c is also a child of a and is unrelated to b<br/>c := context.WithValue(a, "weather", "cloudy")</span><span id="5396" class="li kb hh lg b fi me mb l mc md">// d is a child of c and overrides c's "weather" value<br/>d := context.WithValue(c, "weather", "sunny")<br/> <br/>fmt.Printf("location=%v weather=%v\n",<br/>    a.Value("location"), a.Value("weather"))<br/>fmt.Printf("location=%v weather=%v\n",<br/>    b.Value("location"), b.Value("weather"))<br/>fmt.Printf("location=%v weather=%v\n",<br/>    c.Value("location"), c.Value("weather"))<br/>fmt.Printf("location=%v weather=%v\n",<br/>    d.Value("location"), d.Value("weather")) <br/> <br/>// Output:<br/>location=San Francisco weather=&lt;nil&gt;<br/>location=San Francisco weather=foggy<br/>location=San Francisco weather=cloudy<br/>location=San Francisco weather=sunny</span></pre><p id="9329" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">示例中的<code class="du ld le lf lg b">Context</code>之间的关系如下所示:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mf"><img src="../Images/044df64d7f7719d86f09b5411917aa01.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*AphuRKYBzK7OdZZacVAQWg.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx">Contexts point to a parent, inheriting or overriding values.</figcaption></figure><p id="083f" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">除了存储键值数据之外，<code class="du ld le lf lg b">Context</code>还可以创建相关的挂钟截止时间。当一个带有截止日期的<code class="du ld le lf lg b">Context</code>被创建时，它注册一个回调函数，在截止日期过后将上下文标记为取消。这个回调函数由Go运行时内部调度。</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="518b" class="li kb hh lg b fi ma mb l mc md">// context.WithTimeout schedules a timer to cancel the context.<br/>// The deadline for ctx will be the 5 seconds from the current<br/>// wall clock time.<br/>ctx, cancelCtx := context.WithTimeout(<br/>    context.Background(), 5*time.Second)<br/>defer cancelCtx()</span><span id="bc9a" class="li kb hh lg b fi me mb l mc md">// ... some amount of time passes ...</span><span id="de4c" class="li kb hh lg b fi me mb l mc md">if ctx.Err() == nil {<br/>    fmt.Println("The context is not done yet.")<br/>    // ... do work ...<br/>} else {<br/>    // The context either timed out or cancelCtx() was called.<br/>    fmt.Println("The context is done. Skipping work.")<br/>}</span></pre><p id="1387" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">重要的是，定时器的回调函数保持对要取消的<code class="du ld le lf lg b">Context</code>的引用。如果应用程序代码没有显式取消<code class="du ld le lf lg b">Context</code>，运行时定时器将保持设置，并且<code class="du ld le lf lg b">Context</code>将保持在内存中，直到定时器触发。</p><p id="3b56" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这是我们的核心问题:我们的一些框架代码没有明确取消它正在创建并传递给处理程序代码的<code class="du ld le lf lg b">Context</code>。</p><p id="9553" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">举例来说，框架代码本质上是这样做的:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="f969" class="li kb hh lg b fi ma mb l mc md">func (s *Server) handleRequest(req *Request, conn *Connection) {<br/>    // Create a context with a deadline an hour in the future.<br/>    ctx, _ := context.WithTimeout(context.Background(), 1*time.Hour)</span><span id="d3e5" class="li kb hh lg b fi me mb l mc md">    // Attach metadata to the ctx using a helper function.<br/>    ctx = s.contextWithMetadata(ctx, req)</span><span id="2505" class="li kb hh lg b fi me mb l mc md">    // Deserialize the request and delegate to a handler.<br/>    reqProto := deserialize(req)<br/>    if respProto, err := s.callHandler(ctx, reqProto); err != nil {<br/>        conn.WriteError(err)<br/>    } else {<br/>        conn.WriteResponse(respProto)<br/>    }</span><span id="31eb" class="li kb hh lg b fi me mb l mc md">    // Even though this method returns quickly, ctx is retained<br/>    // in memory for an hour since the pending deadline timer holds<br/>    // a reference to it. Only after the timer fires can the ctx<br/>    // be garbage collected.<br/>}</span></pre><p id="3e6b" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">使用<code class="du ld le lf lg b">Context</code>的正确方法是，当相关操作——在我们的例子中是请求处理器——完成时，总是取消它们。根据经验，任何创建新的<code class="du ld le lf lg b">Context</code>的代码都应该确保它被取消。</p><p id="e43c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">鉴于上面的错误代码片段，实际的代码修复很简单:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="bcaa" class="li kb hh lg b fi ma mb l mc md">func (s *Server) handleRequest(req *Request, conn *Connection) {<br/>    // Create a context with a deadline an hour in the future.<br/>    ctx, cancelCtx :=<br/>        context.WithTimeout(context.Background(), 1*time.Hour)<br/>    // Use defer in case of panics or returning early.<br/>    defer cancelCtx()</span><span id="8361" class="li kb hh lg b fi me mb l mc md">    // ... The rest of the method is the same ...</span><span id="e2f7" class="li kb hh lg b fi me mb l mc md">    // Right after this method returns, cancelCtx() is called,<br/>    // allowing ctx to be garbage collected.<br/>}</span></pre><blockquote class="mk ml mm"><p id="985d" class="iq ir lh is b it jn iv iw ix jo iz ja mn jp jd je mo jq jh ji mp jr jl jm io ha bi translated">额外的阅读:<code class="du ld le lf lg b">Context</code>实现使用<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/time/#AfterFunc" rel="noopener ugc nofollow" target="_blank">timer.AfterFunc</a></code>来调度截止时间计时器，并使用<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/time/#Timer.Stop" rel="noopener ugc nofollow" target="_blank">timer.(*Timer).Stop</a></code>方法在<code class="du ld le lf lg b">Context</code>被取消时清除该计时器。查看一下<a class="ae ip" href="https://golang.org/src/context/context.go#L369" rel="noopener ugc nofollow" target="_blank">上下文。转到</a>源代码，看看定时器是如何创建和使用的。在内部，Go运行时使用一个堆来管理所有未完成的计时器。其实现见<a class="ae ip" href="https://golang.org/src/runtime/time.go" rel="noopener ugc nofollow" target="_blank"> runtime/time.go </a>源代码。</p></blockquote><h2 id="e525" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">经验教训</h2><p id="5a41" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated"><strong class="is hi">尽可能总是回滚</strong>。这与其说是一个教训，不如说是一条被忽视的格言。当我们开始调查这个问题时，我们做的第一件事就是寻找在性能下降的同时发生的其他变化。虽然在几天内发生了一些有趣的变化，但是客户机超时配置的变化在时间方面有很好的相关性。尽管几名工程师在最初的审查中审查了配置更改，并且在这次调查中再次审查了配置更改，但每个人都认为它们无关紧要(“我们只是稍微改变了超时时间，没什么大不了的！”).</p><p id="d2f2" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">考虑到变更和事件之间的时间间隔，以及回滚客户端配置变更的成本非常低，我们应该立即回滚超时变更。这不会修复根本原因，但有助于确定进一步调查的位置。</p><p id="84cb" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated"><strong class="is hi">围棋工具上的空白让调查变得困难</strong>。调试这个问题被Go工具中的一个明显的缺口所阻碍，如果我们的代码在JVM上运行，我们就不会面临这个问题。所有迹象都表明这个问题是一个相当典型的内存泄漏，但是Go并没有真正的工具来转储和分析堆。虽然<a class="ae ip" href="https://golang.org/pkg/runtime/pprof/" rel="noopener ugc nofollow" target="_blank"> pprof </a>工具对于发现一些内存问题很有用，并且在这种情况下给出了一些有用的提示，但是它是有限的:它给出了关于对象被分配到哪里的统计信息，但是没有给出是什么在保留它们。</p><h1 id="2656" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">调查</h1><p id="88f4" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">这篇文章的其余部分大致按照时间顺序回顾了调查，并对事后看来是错误或误导的观察结果进行了一些评论。</p><p id="1068" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">总的进展如下。</p><ol class=""><li id="0eba" class="mq mr hh is b it jn ix jo jb ms jf mt jj mu io mv mw mx my bi translated">寻找与受影响的系统、其相关系统和硬件相关的代码和环境更改。</li><li id="f7eb" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io mv mw mx my bi translated">深入研究GC日志。</li><li id="c1bf" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io mv mw mx my bi translated">使用pprof分析堆。</li><li id="145a" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io mv mw mx my bi translated">尝试使用运行时堆转储方法和自主开发的工具进行更深入的堆分析。</li><li id="6871" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io mv mw mx my bi translated">在canary主机上试验不同的补丁，使用运行时GC挂钩来缩小保留对象的范围。</li><li id="e46b" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io mv mw mx my bi translated">搞定！</li></ol><p id="5cc3" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">第四步和第五步需要的黑客攻击最多，但最终也是最有成效的。</p><h2 id="69da" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">步骤1:寻找相关的变更</h2><p id="427a" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">首先，我们列出了观察到的变化:</p><ul class=""><li id="3bf1" class="mq mr hh is b it jn ix jo jb ms jf mt jj mu io ne mw mx my bi translated">内存使用量突然攀升，从不到200 MB增加到3–6 GB。</li><li id="7ade" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">内存使用持续攀升，但似乎趋于平稳。进程没有耗尽内存，也没有被操作系统终止。<em class="lh">事后看来，这很有意义，因为当17个小时后</em> <code class="du ld le lf lg b"><em class="lh">Context</em></code> <em class="lh">清理计时器启动时，泄漏的对象最终被GCed。</em></li><li id="4c7a" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">之前可预测的GC运行速度显著下降。</li><li id="346c" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">持续较高的CPU使用率。</li></ul><p id="4427" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">我们还列出了没有改变的内容:</p><ul class=""><li id="e588" class="mq mr hh is b it jn ix jo jb ms jf mt jj mu io ne mw mx my bi translated">对该服务的请求没有出现高峰。</li><li id="5066" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">最近没有部署该服务。</li><li id="a4b3" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">没有依赖关系的服务的相关部署。</li><li id="ae7c" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">没有调用服务的相关部署。<em class="lh">这一观察结果是不正确的，因为客户端超时变化最终是相互关联的。</em></li></ul><h2 id="0eb5" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">步骤2:深入研究GC日志</h2><p id="7422" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">因为我们看到了令人担忧的GC模式，所以我们决定从查看GC日志开始，找出任何奇怪的行为。阅读这些日志的主要收获是，尽管我们的堆不断增长，垃圾收集并没有花费太多的时间；每次GC运行都很短，并且只释放少量内存。</p><p id="1bec" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">除此之外，这一步对于更好地理解Go的GC日志格式是一个有用的练习，所以让我们看一下我们遇到的一个片段:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="a813" class="li kb hh lg b fi ma mb l mc md">GC forced</span><span id="d7ab" class="li kb hh lg b fi me mb l mc md">gc 848 @78217.082s 0%: 0.050+6819+3.3 ms clock, 0.10+0/3412/9164+6.6 ms cpu, 2474-&gt;2504-&gt;1908 MB, 3818 MB goal, 2 P</span></pre><p id="8083" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">以下是如何解释第一行的组成部分:</p><ul class=""><li id="7cdc" class="mq mr hh is b it jn ix jo jb ms jf mt jj mu io ne mw mx my bi translated"><code class="du ld le lf lg b">848</code>:这是进程开始以来的第848次垃圾收集。</li><li id="b4af" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">78217.082s</code>:此时进程已经运行了78217.082秒。</li><li id="e1a0" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">0%</code>。大约0%的进程总时间花在了GC上。</li><li id="d360" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">0.050+6819+3.3 ms clock, 0.10+0/3412/9164+6.6 ms cpu</code>:三个GC阶段中每个阶段花费的时间:stop-the-world扫描、并发标记和扫描以及stop-the-world标记终止。</li><li id="c311" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">2474-&gt;2504-&gt;1908 MB</code>:GC前和GC后的堆大小，以及活堆大小。Go过度分配堆，所以在这种情况下，Go对象只使用了分配的2504 MB堆中的1908 MB。</li><li id="f640" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">3818 MB goal</code>:垃圾收集器将开始下一次运行的堆大小。这是由当前GC运行后的堆大小和<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/runtime/#hdr-Environment_Variables" rel="noopener ugc nofollow" target="_blank">GOGC</a></code>环境变量决定的，后者的默认值为100，表示自上次GC以来新分配的数据与现有数据的比率。这种情况下目标背后的计算:1908 MB+(1908 MB *<code class="du ld le lf lg b">GOGC</code>/100)≈3818 MB。</li><li id="b2c5" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">2</code>:垃圾收集器使用的处理器数量。</li></ul><p id="0d7c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">垃圾收集器的清道夫也有一些额外的日志:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="647a" class="li kb hh lg b fi ma mb l mc md">scvg521: 0 MB released</span><span id="7a44" class="li kb hh lg b fi me mb l mc md">scvg521: inuse: 2543, idle: 339, sys: 2883, released: 186, consumed: 2696 (MB)</span></pre><p id="474f" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">清道夫将未使用的内存释放回系统，真正释放内存。</p><p id="29af" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">让我们来解释清道夫的输出:</p><ul class=""><li id="1502" class="mq mr hh is b it jn ix jo jb ms jf mt jj mu io ne mw mx my bi translated"><code class="du ld le lf lg b">0 MB released</code>:没有内存返回系统。</li><li id="0cb6" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">inuse: 2543</code> : Go已经为其堆分配了2543 MB的内存，其中可能包括未使用的内存和死对象。</li><li id="4c2b" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">idle: 339</code> : 339 MB内存，以前包含可访问的对象，但现在不再包含。</li><li id="d449" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated">操作系统已经请求了2883 MB。</li><li id="0370" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">released: 186</code> : 186 MB内存被释放回操作系统。</li><li id="9994" class="mq mr hh is b it mz ix na jb nb jf nc jj nd io ne mw mx my bi translated"><code class="du ld le lf lg b">consumed: 2696</code> : 2696 MB已经被操作系统分配给Go。</li></ul><h2 id="3441" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">步骤3:用pprof分析堆</h2><p id="d8b2" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">有了内存泄漏的证据，我们决定使用pprof来缩小内存泄漏代码的范围。Pprof是一个标准的Go工具，用于转储、探索和可视化关于Go应用程序的内存和CPU使用的统计数据。使用pprof，您可以分析单个转储，也可以分析两个不同转储之间的差异。后者有助于在应用程序稳定运行后发现变化。</p><p id="c97b" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">我们的Go应用程序具有内部HTTP端点来为pprof检索数据，因此我们使用它来获取正在运行的进程的转储:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="3411" class="li kb hh lg b fi ma mb l mc md">curl -sk <a class="ae ip" href="https://our-service:12345/debug/pprof/head" rel="noopener ugc nofollow" target="_blank">https://our-service:12345/debug/pprof/hea</a>p &gt; heap.out</span></pre><p id="2a5c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">一旦我们有了一个转储，我们就能够使用pprof来显示哪些方法分配了最多的数据。这是我们运行的命令之一，它显示了分配最多未释放内存的函数。</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="d564" class="li kb hh lg b fi ma mb l mc md"># pprof takes both the binary of the app (service_binary in this<br/># case) and the dump (heap.out) as arguments.<br/>go tool pprof -runtime --inuse_space service_binary heap.out</span><span id="f832" class="li kb hh lg b fi me mb l mc md"><br/>(pprof) top</span><span id="5c8e" class="li kb hh lg b fi me mb l mc md">1473.20MB of 1884.53MB total (78.17%)</span><span id="f1f7" class="li kb hh lg b fi me mb l mc md">Dropped 1264 nodes (cum &lt;= 9.42MB)</span><span id="753f" class="li kb hh lg b fi me mb l mc md">Showing top 10 nodes out of 77 (cum &gt;= 73.50MB)</span><span id="58ed" class="li kb hh lg b fi me mb l mc md">flat  flat%   sum%        cum   cum%<br/>286.02MB 15.18% 15.18%   561.10MB 29.77%  context.WithDeadline<br/>242.57MB 12.87% 28.05%   524.09MB 27.81%  square/up/xp/sakeutil.NewClientContextWithTimeout<br/>224.52MB 11.91% 39.96%   224.52MB 11.91%  square/up/tracing.appendTiming<br/>152.01MB  8.07% 48.03%   152.01MB  8.07%  runtime.rawstringtmp<br/>128.54MB  6.82% 54.85%  1444.29MB 76.64%  square/up/sake/server.(*Server).handleRequest<br/>122.02MB  6.47% 61.32%   122.02MB  6.47%  square/up/vendor/stash.corp.squareup.com/go/protobuf.git/proto.(*Buffer).DecodeRawBytes<br/>85.51MB  4.54% 65.86%    87.07MB  4.62%  runtime.mapassign1<br/>80MB     4.25% 70.11%    93.56MB  4.96%  time.AfterFunc<br/>78.51MB  4.17% 74.27%   182.02MB  9.66%  context.WithCancel<br/>73.50MB  3.90% 78.17%    73.50MB  3.90%  context.WithValue</span></pre><p id="e97c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这些行中的每一行都表明在特定函数中创建的对象使用了多少内存。不过，重要的是要注意，这仅表明对象是在哪里创建的，而不是仍然保留对它们的引用的内容。</p><p id="baa8" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">仔细观察，处理所有传入请求的方法负责许多保留的对象，至少是间接的:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="8c2d" class="li kb hh lg b fi ma mb l mc md">128.54MB  6.82% 54.85%  1444.29MB 76.64%  square/up/sake/server.(*Server).handleRequest</span></pre><p id="2a34" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这一行表示<code class="du ld le lf lg b">handleRequest</code>创建了128 MB(堆的6.82%)仍然可访问的对象。此外，<code class="du ld le lf lg b">handleRequest</code> plus方法可以从它那里获得1.4 GB的对象。在正常状态下，这两个数字最多只有几十MB。</p><p id="8ea3" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">当我们第一次看到这些数据时，我们正确地假设请求处理代码正在泄漏对象。我们还注意到，尽管保留了大量的<code class="du ld le lf lg b">Context</code>对象，但是请求消息没有被保留。然而，我们仍然不明白这一点的根本原因。事后看来，我们也可以注意到在<code class="du ld le lf lg b">time.AfterFunc</code>内部分配94 MB内存是不寻常的，并进一步探究。</p><h2 id="088a" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">步骤4:堆转储分析</h2><p id="5d32" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">此时，我们决定另辟蹊径。</p><p id="7585" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">虽然pprof向我们暗示了request <code class="du ld le lf lg b">Context</code>数据正在泄漏，但它没有指出泄漏的原因以及是什么在控制着它们。许多语言都有工具来转储应用程序的堆，分析和遍历对象图——例如，如果这是一个Java应用程序，我们会很高兴地启动<a class="ae ip" href="http://www.eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank"> Eclipse内存分析器</a>。不幸的是，Go不是这些语言中的一种。</p><p id="6b38" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">丰富的堆转储支持非常有用。通过遍历从保留对象到根对象的路径，可以更容易地找到对象没有被垃圾收集的原因。在这种情况下，我们希望找到一种保存大量请求相关数据的数据结构，我怀疑拥有一个真正的堆分析器工具会大大减少我们调试的时间。</p><p id="fe7c" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">虽然Go不支持探索堆，但是它在<code class="du ld le lf lg b">runtime/debug</code>包中有一个非官方的方法，用于生成类似堆转储的东西:<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/runtime/debug/#WriteHeapDump" rel="noopener ugc nofollow" target="_blank">debug.WriteHeapDump</a></code>。这个函数以二进制格式输出正在运行的进程的一些低级堆状态。Golang wiki有<a class="ae ip" href="https://github.com/golang/go/wiki/heapdump15" rel="noopener ugc nofollow" target="_blank">格式的不完整文档</a>，所以我们最终不得不阅读<code class="du ld le lf lg b">WriteHeapDump</code>源代码来理解它。</p><p id="bc45" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated"><code class="du ld le lf lg b">WriteHeapDump</code>的输出有一个巨大的缺点:它实际上转储了每个对象的原始字节以及一个位集，该位集指示这些字节中的哪些字表示指向其他对象的指针。它省略了有关类型的任何数据，包括类型的名称。</p><p id="acca" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在没有类型的情况下遍历一个对象图是非常乏味的，而且在大多数情况下是不可能的。我们发现找到明显的字符串并通过引用对象反向工作是推断对象类型的唯一方法。即使这样也需要知道Go如何在内存中表示核心数据结构，比如切片和地图。</p><blockquote class="mk ml mm"><p id="39df" class="iq ir lh is b it jn iv iw ix jo iz ja mn jp jd je mo jq jh ji mp jr jl jm io ha bi translated">旁白:Go维护者已经参与了关于为堆分析构建适当支持的讨论，所以希望工具很快会变得更好。<a class="ae ip" href="https://github.com/golang/proposal/blob/master/design/16410-heap-viewer.md" rel="noopener ugc nofollow" target="_blank">这个请求</a>和<a class="ae ip" href="https://github.com/golang/go/issues/16410" rel="noopener ugc nofollow" target="_blank">这个相关的讨论</a>有一些脉络。</p></blockquote><p id="7722" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这是弃尸的样子。下面的每个字段行代表内存中的一个字，当一个字代表一个指针时，有些链接到其他对象。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es nf"><img src="../Images/dde0d3f2d73203ac15b9687b7965c2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/0*4VWjS85DdkXSkcWe."/></div><figcaption class="mg mh et er es mi mj bd b be z dx">A visual representation of a heap dump object, courtesy of <a class="ae ip" href="https://github.com/golang/go/wiki/heapdump14" rel="noopener ugc nofollow" target="_blank">heapdump14</a>. This represents a struct of a specific Protocol Buffer message but determining that was a chore.</figcaption></figure><p id="48ae" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">上面的图片来自一个开源项目，<a class="ae ip" href="https://github.com/golang/go/wiki/heapdump14" rel="noopener ugc nofollow" target="_blank"> heapdump14 </a>，它大约是在Go 1.4版本编写的。较旧的Go运行时在堆中包含了更详细的类型信息，但是随着运行时在较新版本的Go中的发展，可用元数据的数量已经减少了。我们决定尝试使用这个工具来更好地理解堆对象图；让它运行需要将<a class="ae ip" href="https://github.com/randall77/heapdump14/compare/master...fjl:master.patch" rel="noopener ugc nofollow" target="_blank">这个补丁</a>应用到工具的源代码中，然后编写一个我们自己的额外补丁。</p><p id="b2d2" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">通过heapdump14遍历图形后，我们确定上图中的对象是如下所示类型的实例:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="aa73" class="li kb hh lg b fi ma mb l mc md">type SomeProtoMessage struct {<br/>    FirstField       *string<br/>    SomeBytes        []byte<br/>    XXX_unrecognized []byte<br/>}</span></pre><p id="f6ce" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">图像中的“64_PPSSP”是heapdump14的类型名称。该数字由工具随机选择，但对于该类型是唯一的。<code class="du ld le lf lg b">PPSSP</code>表示对象中每个词的类型:[指针，指针，标量，标量，指针]。根据上图，对象是7个单词，其中每个字段行代表一个单词。这不是<code class="du ld le lf lg b">PPSSP</code>建议的5；不清楚这个名称是如何形成的，也不清楚为什么转储类型有7个字，而不是预期的3个字(一个用于指针，两个用于切片)。</p><blockquote class="mk ml mm"><p id="1847" class="iq ir lh is b it jn iv iw ix jo iz ja mn jp jd je mo jq jh ji mp jr jl jm io ha bi translated">Failed tangent:我们试图编写一个工具来遍历从我们的应用程序入口点可到达的所有类型，并为每种类型打印出一个heapdump14兼容的类型签名。我们无法在合理的时间内成功做到这一点，因此放弃了努力。好的一面是，我们学到了一些如何使用标准库在解析的不同阶段检查Go程序的源代码。</p></blockquote><h2 id="f4d4" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">第四步1/2:并不是所有的都失去了</h2><p id="cae5" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">虽然遍历堆最终是失败的，但这种努力并不完全失败。我们注意到堆中的字符串是一些类型被保留的有用提示——在我们的例子中尤其有用，因为对服务器的请求包含大量字符串。</p><p id="d929" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">考虑到这一点，我们编写了一个简单的工具来提取堆中常见字符串的计数。它还对Square的RPC框架用来表示请求id的不同格式的字符串进行计数。</p><p id="3a4f" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">以下输出示例表明，大部分保留的数据与来自单个服务的请求相关，即超时配置错误的服务。</p><p id="86d1" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">输出的第一行显示了堆中请求id的计数——表明有多少请求在内存中仍有一些相关数据。</p><p id="5a55" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">剩余的行首先输出一个计数，然后是<code class="du ld le lf lg b">(p)</code>(如果计数是针对协议缓冲区消息中编码的字符串),最后是字符串本身，用反斜杠括起来。例如，<code class="du ld le lf lg b">995090 (p) `application/x-protobuf`</code>，意味着协议缓冲区字符串<code class="du ld le lf lg b">application/x-protobuf</code>在堆中出现了995090次。</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="8e72" class="li kb hh lg b fi ma mb l mc md"># Each request has a unique string ID in a uniform format.<br/># The following count shows lots of request ID strings in the heap.<br/>Request ID counts: 1492947</span><span id="b64a" class="li kb hh lg b fi me mb l mc md"># The format of each following line is:<br/># count [(p) if protocol buffer string] `string in heap`</span><span id="3ead" class="li kb hh lg b fi me mb l mc md">995090 (p)     `application/x-protobuf`</span><span id="b95f" class="li kb hh lg b fi me mb l mc md"># Although the service has many different callers, only the name of<br/># the service with the misconfigured timeout shows up a lot.<br/>497548         `the-misconfigured-calling-service`<br/>497545 (p)     `Content-Length`<br/>497545 (p)     `Accept`</span><span id="8f36" class="li kb hh lg b fi me mb l mc md"># The bad timeout value included in requests.<br/>497545 (p)     `60000`</span><span id="b0b9" class="li kb hh lg b fi me mb l mc md">497545 (p)     `X-Request-Deadline`</span></pre><p id="ba0a" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">事后看来，我们真的应该在这一点上回滚违规的调用服务，但不幸的是我们没有这样做。</p><h2 id="b036" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">步骤5:试验终结器</h2><p id="6573" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">在这一点上，我们想要解决的谜团是为什么只有来自特定服务的请求会导致泄漏。我们使用了一些hacky Go运行时技巧来帮助，并最终解决了所有问题。</p><p id="29d8" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">为了确定被保留的特定对象的特征，我们求助于Go的<code class="du ld le lf lg b"><a class="ae ip" href="https://golang.org/pkg/runtime/#SetFinalizer" rel="noopener ugc nofollow" target="_blank">runtime.SetFinalizer</a></code>函数。这个函数指示Go运行时在垃圾收集对象之前立即执行回调。设置回调很容易，尽管我不建议在实际的生产代码中使用它:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="9283" class="li kb hh lg b fi ma mb l mc md">heapObject := new(string)</span><span id="d459" class="li kb hh lg b fi me mb l mc md">runtime.SetFinalizer(heapObject, func(theObject *string) {<br/>    // heapObject/theObject is about to be garbage collected.<br/>    fmt.Println("bye!")<br/>})</span></pre><p id="875d" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">考虑到<code class="du ld le lf lg b">SetFinalizer</code>,我们为一小组类型设置了终结器，并让我们的服务器偶尔记录每个类型被创建和被垃圾收集的次数。跟踪<code class="du ld le lf lg b">Context</code> s的代码大致如下:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="2204" class="li kb hh lg b fi ma mb l mc md">var (<br/>    contextNumber       int64<br/>    contextsOutstanding int64<br/>)</span><span id="8b92" class="li kb hh lg b fi me mb l mc md">func requestHandler(...) {<br/>    ctx, _ := context_helper.NewContext(timeout)</span><span id="5c0c" class="li kb hh lg b fi me mb l mc md">    // To help debug, use a counter to link allocation and<br/>    // and finalizer log messages.<br/>    ctxNumber := atomic.AddInt64(&amp;contextNumber, 1)</span><span id="80dd" class="li kb hh lg b fi me mb l mc md">    // Keep a count of reachable Context objects.<br/>    ctxOutstanding := atomic.AddInt64(&amp;contextsOutstanding, 1)</span><span id="365a" class="li kb hh lg b fi me mb l mc md">    glog.Infof("gc-investigation: action=alloc type=Context " +<br/>       "id=%d outstanding=%d",<br/>       ctxNumber, ctxOutstanding)</span><span id="efb6" class="li kb hh lg b fi me mb l mc md">    runtime.SetFinalizer(ctx, func(r context.Context) {<br/>        ctxOutstanding := atomic.AddInt64(&amp;contextsOutstanding, -1)<br/>        glog.Infof("gc-investigation: action=finalize " +<br/>            "type=Context id=%d outstanding=%d",<br/>            ctxNumber, ctxOutstanding)<br/>    })</span><span id="93a2" class="li kb hh lg b fi me mb l mc md">    // ...<br/>}</span></pre><p id="3361" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这个日志记录的输出清楚地表明，一些<code class="du ld le lf lg b">Context</code>没有被GCed，但是请求对象被GCed。未偿还债务的数量持续上升。在下面的代码片段中，在进程生命周期中分配的162，573个<code class="du ld le lf lg b">Context</code>中，有4，920个留在内存中。</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="27d9" class="li kb hh lg b fi ma mb l mc md">2017-04-21 23:42:21,919257 INFO [4] [server.go:635] gc-investigation: action=finalize type=Context id=162573 outstanding=4920</span></pre><h2 id="1ad5" class="li kb hh bd kc lj lk ll kg lm ln lo kk jb lp lq ko jf lr ls ks jj lt lu kw lv bi translated">把所有的放在一起</h2><p id="2cd6" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">至此，我们知道了<code class="du ld le lf lg b">Context</code>正在泄漏，以及那些<code class="du ld le lf lg b">Context</code>是在哪里产生的。我们重读了<code class="du ld le lf lg b">Context</code>文档并浏览了它的源代码，以便更好地理解它是如何实现的。这让我们看到了它对<code class="du ld le lf lg b">time.AfterFunc</code>的使用，以及它如何与运行时交互。然后，我们形成了一个假设，即这些计时器回调是泄漏的。对我们的服务器框架源代码的更彻底的阅读很快证实了这一点。</p><p id="733a" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">最后，修复是对我们的请求处理程序框架代码的一个非常简单的更改:</p><pre class="jt ju jv jw fd lw lg lx ly aw lz bi"><span id="bbf5" class="li kb hh lg b fi ma mb l mc md">// Before<br/>func requestHandler(...) {<br/>    ctx, _ := context_helper.NewContext(timeout)</span><span id="668d" class="li kb hh lg b fi me mb l mc md">    // ...<br/>}</span><span id="fde6" class="li kb hh lg b fi me mb l mc md">// After<br/>func requestHandler(...) {<br/>    ctx, cancelCtx := context_helper.NewContext(timeout)<br/>    defer cancelCtx() // &lt;-- Oops!</span><span id="ab5d" class="li kb hh lg b fi me mb l mc md">    // ...<br/>}</span></pre><p id="4002" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这修复了我们在服务中发现的问题。由于该框架由其他内部Go应用程序共享，因此该修复也可以保护它们免受行为不端的客户端的攻击。</p><h1 id="a36e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">回首</h1><p id="1874" class="pw-post-body-paragraph iq ir hh is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm io ha bi translated">回顾整个磨难重申了一些关键工程实践的重要性。</p><p id="ac2f" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">一个是Go关于不忽略返回错误和清除函数的约定是有充分理由的，不应该被随意忽略。鉴于<code class="du ld le lf lg b">Context</code>文档清楚地说明了它释放资源，最初的框架代码不应该忽略与<code class="du ld le lf lg b">Context</code> s相关联的<code class="du ld le lf lg b">CancelFunc</code>。我认为任何包含清除和错误返回值的代码都是例外，应该有清晰的文档记录。</p><p id="2034" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">另一种做法是，当代码与相关系统中的问题密切相关时，毫不犹豫地回滚代码。这样做的成本很低，但可能有助于缩小bug的触发范围。在这种特殊情况下，我们可以节省大量调试时间。</p><p id="6746" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">最后，除了调试之外，我们喜欢学习更多关于Go内部的各个部分以及围绕它们的工具生态系统。</p></div></div>    
</body>
</html>