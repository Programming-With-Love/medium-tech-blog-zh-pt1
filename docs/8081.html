<html>
<head>
<title>Deep Learning Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习揭开神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/deep-learning-demystified-693a2d7ec79e?source=collection_archive---------0-----------------------#2021-11-19">https://medium.com/walmartglobaltech/deep-learning-demystified-693a2d7ec79e?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3690" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从优化到深度学习</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/a892d8a91b01691bbaabca7603ddbdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*JsAQvamT2W2IIrEuMjLnHw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">DL in 1 equation: <em class="jo">N</em> — a deep model, <em class="jo">θ</em> — its parameters, D — data, T — targets for supervision which can be external labels (supervised learning) or data themselves (unsupervised learning)</figcaption></figure><h1 id="10bd" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.介绍</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kn"><img src="../Images/cb8cd1edd61ec29d32adce4e905911a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlNHzKNKNPDky4Wi6V0oNw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">(<a class="ae ks" href="http://www.rackwise.com/" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="7b8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如今，神经网络以其规模而自豪:数百层、数万亿个参数和复杂的微结构。早在今年1月，谷歌的<a class="ae ks" href="https://towardsdatascience.com/google-switch-transformers-scaling-to-trillion-parameter-models-with-constant-computational-costs-806fd145923d" rel="noopener" target="_blank">开关变压器</a>就创下了人工智能语言模型1.6T参数的新记录(比去年发布的OpenAI的<a class="ae ks" href="https://www.techradar.com/news/microsoft-deploys-gpt-3-to-let-devs-code-using-everyday-language" rel="noopener ugc nofollow" target="_blank"> GPT-3模型</a>中的175B参数大8倍)。最近，随着BAAI的<a class="ae ks" href="https://towardsdatascience.com/gpt-3-scared-you-meet-wu-dao-2-0-a-monster-of-1-75-trillion-parameters-832cd83db484" rel="noopener" target="_blank">五刀2.0 </a>模型的发布，这个记录再次被设定为1.7T。听起来很有趣，但是有点吓人，对吧？你并不孤单。如果你是一个人工智能爱好者谁是热切地成为熟悉这个否则势在必行的技术，这个博客是为你。</p><p id="0938" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是通过将深度学习(DL)与微积分的一些基本概念联系起来，揭开无意中出现的困境的神秘面纱，让它在你看来更有吸引力，而不是令人望而生畏。最后，您需要带回家的关于DL的所有信息都被总结成了三个备忘单。你永远不会害怕那些巨大的人工智能模型，因为你知道不管它们有多复杂，它们都可以归结为你拥有的三张桌子。</p><h1 id="f6ec" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.最佳化</h1><p id="1ed2" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">首先要知道的是，深度学习(通常是机器学习)只是通过成本函数优化进行参数估计的另一个用例。如果您仍然有疑问，请查看顶部的等式——这就是DL的全部内容。它说的是，深层模型可以被认为是一个函数<em class="ky"> N、</em>通过<em class="ky"> θ、</em>参数化，给定输入数据<em class="ky"> d </em>，生成输出<em class="ky"> N </em> ( <em class="ky"> d </em>)。训练是指通过使用多对数据-目标(<em class="ky"> d </em>、<em class="ky"> t </em>)将<em class="ky"> N </em> ( <em class="ky"> d </em>)与已知目标<em class="ky"> t </em>进行比较，找到<em class="ky"> θ </em>。差异<em class="ky">又名</em>错误<em class="ky">N</em>(<em class="ky">D</em>)-<em class="ky">t</em>)在整个数据集<em class="ky"> D </em>和目标集<em class="ky">t</em>之间聚合。最佳解<em class="ky"> θ* </em>对应于使总错误最小的解。多亏了两个神奇的符号<em class="ky"> N </em>和<em class="ky"> θ </em>，DL周围所有可怕的东西都被围了起来<em class="ky">。</em></p><p id="5b12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本节的剩余部分，我将更详细地讨论函数优化，从简单的类型到适合表达深度神经网络(DNN)的更复杂的类型。</p><p id="e011" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.1单变量函数优化</strong></p><p id="ffc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">先说最简单的情况——单变量函数——<em class="ky">y</em>=<em class="ky">f</em>(<em class="ky">x</em>)。假设<em class="ky"> f </em>的导数不为零，即<em class="ky">f’</em>(<em class="ky">x</em>)≠0(一会儿就知道为什么需要这个条件)。我们的目标是找到它的根(其中<em class="ky"> f </em> ( <em class="ky"> x </em> )=0)。</p><p id="ac7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个例子是<em class="ky">f</em>(<em class="ky">x</em>)=<em class="ky">x</em>谁的答案比较猥琐:<em class="ky"> x </em> =0。作为理解后面章节的准备，让我们把它作为一个优化问题来解决。我们采取以下步骤:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kz"><img src="../Images/0328e25441781908dc652e159ba4afe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*ADcHFZrkR2nlvUHxymEcdw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 2.1 Shape of the cost function C(f(x))=x²/2</figcaption></figure><ol class=""><li id="732c" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated">构造一个<strong class="ig hi">代价函数</strong><em class="ky">C</em>(<em class="ky">f</em>)=<em class="ky">f</em>(<em class="ky">x</em>)/2这是最简单的<a class="ae ks" href="https://en.wikipedia.org/wiki/Convex_function" rel="noopener ugc nofollow" target="_blank">凸函数</a>并保证单个最小值。</li><li id="8dc8" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">对新构建的成本函数执行<strong class="ig hi">梯度下降</strong> (GD)。当<em class="ky"> f </em> ( <em class="ky"> x </em>)是复杂函数时，直接优化<em class="ky"> C </em> ( <em class="ky"> f </em>)很难。在这种情况下，迭代梯度下降是一种方法。诀窍是用它的一阶泰勒展开式来近似<em class="ky">f</em>(<em class="ky">x</em>):<em class="ky">f</em>(<em class="ky">x<em class="ky">f</em>(<em class="ky">x</em>₀)+<em class="ky">f’</em>(<em class="ky">x</em>₀)(<em class="ky">x</em>-<em class="ky">x</em>₀)，即然后我们不求解<em class="ky"> f </em> ( <em class="ky"> x </em> )=0，而是求解<em class="ky">f</em>(<em class="ky">x</em>₀)+<em class="ky">f’</em>(<em class="ky">x</em>₀)(<em class="ky">x</em>-<em class="ky">x</em>₀)=0.找到的<em class="ky"> x </em>成为下一次迭代的<em class="ky"> x </em> ₀，并且该过程一直重复，直到达到最小值。下面是算法，</em></li></ol><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lo"><img src="../Images/695fe2ff2beebc2b9eee42b7f2c4a3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Xe9TYKVKwjGIUDI-iEYXA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Univariate function optimization by Gradient Descent. Start from a initial guess x0. Iteratively update it with the calculated ▵x until convergence.</figcaption></figure><p id="4980" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当迭代停止时，最后一个<em class="ky"> xₜ </em>就是寻找的根。这里注意三个细节:</p><ul class=""><li id="85d1" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lp lg lh li bi translated">使用▵ <em class="ky"> θ i </em> s代替<em class="ky"> - </em> ▵ <em class="ky"> x </em>，以与神经网络的典型参数表示一致。</li><li id="eaeb" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">导数<em class="ky">f’</em>(<em class="ky">x</em>)不必要地同时出现在分子和分母中。当处理更复杂的函数类型时，其中导数的概念变为梯度，原因将很快变得清楚。</li><li id="90b2" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">因为<em class="ky">f’</em>(<em class="ky">x</em>)出现在分母中，所以它不能为零，这就是条件<em class="ky">f’</em>(<em class="ky">x</em>)≠0的原因。</li></ul></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="6f04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">问题</strong>:我们怎么知道<em class="ky"> C </em>的最小值与<em class="ky"> f( </em> x <em class="ky"> ) </em>的根相同？</p><p id="667c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">答</strong>:已知作为凸函数，<em class="ky"> C </em>的最小值在其<a class="ae ks" href="https://en.wikipedia.org/wiki/Stationary_point" rel="noopener ugc nofollow" target="_blank">驻点</a>—<em class="ky">C’</em>s导数消失的地方。遵循导数计算规则:<em class="ky">C '(f)</em>=<em class="ky">f(</em>x<em class="ky">f '(</em>x<em class="ky">)。这样C'(f) </em> = <em class="ky"> 0导致f(x)=0 s </em>因为<em class="ky">f '(x)</em>≦<em class="ky">0</em>。换句话说，新构建的成本函数为我们指出了原始问题的相同解决方案。</p></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kz"><img src="../Images/57b028a0ca2014aa72005fced42becdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*4FbMoVVi4sdM1hiHjOaQBA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 2.2 GD example. Green triangles: x sequence; red circles: f(x) sequence; dashed red lines: tangent lines at the data points.</figcaption></figure><p id="eabc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图2.2显示了最小化上述成本函数时的梯度下降。在这种情况下，▵<em class="ky">θ= f</em>(<em class="ky">x</em>)/<em class="ky">f’</em>(<em class="ky">x</em>)<em class="ky">= x</em>/2，这意味着每一次迭代都将之前找到的根减半。从<em class="ky"> x </em> =2开始，接下来的值是<em class="ky"> x </em> =1，0.5，0.25，…等等。在10次迭代中，<em class="ky"> x </em>达到1/1⁰ ~1e-3，代价<em class="ky"> C </em>降低到7.63e-6。请注意，每条红色虚线的斜率，相当于成本函数在矩的根<em class="ky"> x </em>处的导数或梯度，在此过程中保持下降(因此得名梯度下降)。</p><p id="8bda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.2多元函数优化</strong></p><p id="0a66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">顾名思义，多元函数涉及多个变量。他们长得像<em class="ky"> f </em> ( <em class="ky"> x </em> ₀，<em class="ky"> x </em> ₁，…，<em class="ky"> xₙ </em>)。有时它们被写成向量形式<em class="ky"> f </em> ( <em class="ky"> X </em>)其中<em class="ky"> X </em> =[ <em class="ky"> x </em> ₀，<em class="ky"> x </em> ₁，……，<em class="ky"> xₙ </em>。由于<em class="ky"> X </em>是多维的，单个方程<em class="ky"> f </em> ( <em class="ky"> X </em> )=0不足以解决问题。而是需要<em class="ky"> m </em> ≥ <em class="ky"> n </em>个方程，即<em class="ky"> f </em> ₀( <em class="ky"> X </em> )=0，<em class="ky"> f </em> ₁( <em class="ky"> X </em> )=0，…，<em class="ky"> fₘ </em> ( <em class="ky"> X </em> )=0。定义<em class="ky"> F </em> =[ <em class="ky"> f </em> ₀，<em class="ky"> f </em> ₁，……，<em class="ky"> fₘ </em> ]一个向量函数，以及【0】<em class="ky">ₘ=</em>【0，0，…，0】，<em class="ky"> m </em>零点<em class="ky">一个向量。</em>与一元情形类似，多元求根问题<em class="ky">f</em>(<em class="ky">x</em>)=【0】<em class="ky">ₘ</em>通过代价函数<em class="ky">c</em>(<em class="ky">f</em>(<em class="ky">x</em>)=(<em class="ky">f</em>)/2转化为优化问题，其中符号<em class="ky"/></p><p id="14a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有人想知道一元导数的多元等价物是什么。这是一个名为<strong class="ig hi">雅可比矩阵</strong>的矩阵，定义如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lx"><img src="../Images/e1290aff2e092c5f9ebdb38fd2a4244f.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*IhDwwRjxmnoasDbPug1Pag.png"/></div></figure><p id="2d2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中▽<em class="ky">fᵢ</em>(<em class="ky">x</em>)=[<em class="ky">fᵢ</em>'(<em class="ky">x</em>₀)，<em class="ky"> fᵢ </em> '( <em class="ky"> x </em> ₁)，…，<em class="ky"> fᵢ' </em> ( <em class="ky"> xₙ </em> )]为第I个函数的梯度<em class="ky"> fᵢ </em> w.r.t .变量将所有这些梯度向量叠加在一起就形成了雅可比矩阵。</p><p id="1f81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在单变量情况的类似操作之后，多变量优化过程给出如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ly"><img src="../Images/cbd41fdb602e0b989b3f33c645f84ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GnzIVwT5V0VEoH-Tx5zPA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Multivariate function optimization by GD. Notice the resemblance to the univariate case.</figcaption></figure><p id="b56d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面可以注意到一些有趣的事情。首先，从结构上来说，单变量和多变量过程是完全一样的。第二，就像前面要求<em class="ky"> f' </em> ( <em class="ky"> x </em> )≠0一样，<em class="ky">j</em>(<em class="ky">x</em>)<em class="ky">ᵗj</em>(<em class="ky">x</em>)必须满秩，即<em class="ky"> J </em> ( <em class="ky"> X </em>)不能消失。第三，适应可以通过以下互换来完成:</p><ul class=""><li id="b523" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lp lg lh li bi translated"><em class="ky"> x → X </em></li><li id="0162" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated"><em class="ky"> f→F </em></li><li id="d0f1" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated"><em class="ky">f</em>'(<em class="ky">x</em>)<em class="ky">→j</em>(<em class="ky">x</em>)或其转置<em class="ky">j</em>(<em class="ky">x</em>)<em class="ky">ᵗ</em></li><li id="12f3" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated"><em class="ky">1/(f</em>'(<em class="ky">x</em>)<em class="ky">f</em>'(<em class="ky">x</em>)<em class="ky">→</em><em class="ky">j</em>(<em class="ky">x</em>)<em class="ky">ᵗj</em>(<em class="ky">x</em>)</li></ul><p id="d64e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图2.3演示了最小化一个二元函数<em class="ky">f</em>(<em class="ky">x</em>)=<em class="ky">x</em>₀+<em class="ky">x</em>₁的梯度下降，从顶部位置开始，到底部中心结束。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lz"><img src="../Images/a9eb158f6ab47540cf0a28da4cb90aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*ZLKQ_xm2qaCCOQ-m.gif"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 2.3 GD of function <em class="jo">x</em>₀²+<em class="jo">x</em>₁², starting from (-2,2), ending at (0,0), following the red trajectory. (<a class="ae ks" rel="noopener" href="/analytics-vidhya/gradient-descent-part-2-the-math-c23060a96a13">Source</a>)</figcaption></figure></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="0fe9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ky">以运动为例</em> </strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ma"><img src="../Images/dd67476239829c0c5eb2ab77cfe46c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*dSm7-wguryoFFNmntSSgWA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">A 3D point can be recovered from a connection — multiple 2D image pixels connected to that point. (<a class="ae ks" href="https://ww2.mathworks.cn/help/vision/ug/structure-from-motion.html" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="120f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个经典的计算机视觉问题是从运动中得到结构，即从移动摄像机(运动)的多个图像中找到一个点(结构)的3D坐标。左图是从三幅2D图像的连接中恢复出杯把上一点<em class="ky"> X </em>(即<em class="ky"> n </em> =3)的三维坐标(<em class="ky"> x </em>、<em class="ky"> y </em>、<em class="ky"> z </em>)。</p><p id="9beb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">已知摄像机投影矩阵<em class="ky"> Pᵢ </em>和该点的二维图像像素(<em class="ky"> uᵢ </em>、<em class="ky"> vᵢ </em>)、<em class="ky"> i </em> =1，2，3，等式为<em class="ky"> PᵢX </em> =( <em class="ky"> uᵢ </em>、<em class="ky"> vᵢ </em>)，或者等价地<em class="ky"> PᵢX- </em> ( <em class="ky"> uᵢ </em>、<em class="ky"> v每个图像提供2个等式。三幅图像总共提供6个等式，因此<em class="ky"> m </em> =6。优化问题是:</em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mb"><img src="../Images/605548fc4162340f5925f977b9d560fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*qec7-5pFgiYN16mVJLnZWg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Cost function of an example SFM problem: 6 equations, 3 unknowns.</figcaption></figure><p id="da54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般来说，有了<em class="ky"> a </em>未知摄像机和<em class="ky"> b </em>未知点，假设所有的点都在所有摄像机中被观测到，那么就有2个<em class="ky"> ab </em>方程和6个<em class="ky"> a </em> +3个<em class="ky"> b </em>未知量。当and <em class="ky"> m </em>和<em class="ky"> n </em>足够大时，方程比未知数多。因此梯度下降可以找到解决方案。人们可以想象拍摄许多建筑物的照片并恢复其完整的3D结构。</p><blockquote class="mc md me"><p id="752f" class="ie if ky ig b ih ii ij ik il im in io mf iq ir is mg iu iv iw mh iy iz ja jb ha bi translated">在这个项目中，我们考虑从网上获取的图像中重建整个城市的问题。我们的目标是建立一个并行分布式系统，从Flickr.com下载与一个城市相关的所有图像，比如说罗马。下载后，它匹配这些图像以找到共同点，并使用这些信息来计算城市的三维结构和拍摄这些图像的相机的姿态。所有这些都要在一天内完成。</p></blockquote><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx"><a class="ae ks" href="https://grail.cs.washington.edu/rome/" rel="noopener ugc nofollow" target="_blank">Building Rome In a Day</a> — Point cloud reconstruction of the Colosseum. Triangles show camera positions.</figcaption></figure></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="b599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.3随机梯度下降(SGD) </strong></p><p id="1916" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">梯度下降有两个缺点:</p><ol class=""><li id="d1f2" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated">它要求(函数的)非零梯度，这在复杂函数的情况下很难保证。否则在计算过程中会出现数值不稳定性。</li><li id="6db9" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">求逆<em class="ky">j</em>(<em class="ky">x</em>)<em class="ky">ᵗj</em>(<em class="ky">x</em>)耗时(复杂度O( <em class="ky"> mn </em> + <em class="ky"> n </em>))，esp。当<em class="ky"> m </em>时，<em class="ky"> n </em>是当代神经网络中的巨大数字。</li></ol><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mk"><img src="../Images/a652c3f55bead9adbd2e3dae97dadac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M3HsGFOAvKueOSoh.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 2.4 Comparison between GD and SGD (s<a class="ae ks" href="https://wikidocs.net/3413" rel="noopener ugc nofollow" target="_blank">ource</a>): Colored curves indicate contour lines of the cost function. SGD shows a zig-zag pattern and often settles at a suboptimal solution. But it is computationally much more efficient.</figcaption></figure><p id="2778" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然有计算技巧来处理第一个问题，但第二个问题需要新的技术。其中，随机梯度下降法应用最为广泛。这个想法是把矩阵求逆取出来，用一个叫做<strong class="ig hi">学习率</strong>的非零标量代替(一般写成<em class="ky"> ⍺ </em>)。由于现在更新向量▵ <em class="ky"> X </em>不再是最优的，所以选择小的<em class="ky"> ⍺ </em> ( &lt; 0.01)来限制不良更新的损害，希望它们可以被后面的更新纠正。图2.4是SGD的一个示例，其中收敛轨迹显示为之字形。在实践中，有一些方法可以减轻这种次优性，这将很快给出。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ml"><img src="../Images/0ebe3463d6afc95275875482e452538c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*fhUNrBAflVpBR3N8RGrTKA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">SGD: matrix inversion and multiplication replaced by a scalar learning rate</figcaption></figure><p id="b707" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2.4小批量SGD </strong></p><p id="67d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使消除了逆，计算矩阵向量乘法<em class="ky">j</em>(<em class="ky">x</em>)<em class="ky">ᵗf</em>(<em class="ky">x</em>)—o(<em class="ky">Mn</em>)—的复杂度仍然很高，因为两个<em class="ky"> m，n </em>都可能很大。这由<strong class="ig hi">小批量SGD </strong>解决，它仅使用总<em class="ky"> m </em>方程式中的一小部分，称为<em class="ky">小批量</em>，用<em class="ky"> B </em>表示。理论上<em class="ky"> B </em>可以小到1，即一次一个方程。在实践中，它是根据资源可用性(如内存和GPU核心)来选择的。以随机顺序选择小批量，不重复，一个接一个地运行，直到消耗完所有方程式。每次完整运行被称为一个<strong class="ig hi">时期</strong>。增加一个外部循环来执行多个时期，随着越来越接近根，学习率降低。下面是小批量新币:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/85f62a460a4468e6026610c2c4b17802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*mSosC4B4tkYZs633Yu19mg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Mini-batch SGD: small batch size allows for many epochs of partial optimizations</figcaption></figure><p id="f056" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">小批量SGD的成功来自于<em class="ky"> B </em>的小得多的尺寸，这允许运行许多次局部优化以达到最终的解决方案。如果硬件允许，也可以并行执行多个批处理，从而获得更快的速度。</p><h1 id="5367" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.深度学习</h1><p id="31a8" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">随着函数优化的引入，从这一节开始，我开始描述它是如何用于深度学习的。请记住，现在深度学习很大程度上意味着神经网络训练。此外，人们很难找到任何不深的有用的神经网络。至此，两个短语— <em class="ky">深度学习</em>和<em class="ky">神经网络— </em>可以互换使用。监督学习和非监督学习都不会被区分，因为本质上两者都被认为是由成本函数指导的神经网络训练。</p><p id="b338" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.1神经网络作为复合函数</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mn"><img src="../Images/37823052a47cd797f20aa59b5e81cd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*05D_inbzDAFcFNMqd2f3wg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 3.1 A two-layer neural network: 3 input, 2 hidden layers, 1 output</figcaption></figure><p id="b5fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图3.1左侧是一个简单的神经网络，有3个输入(红色)，两个隐藏的神经元层(蓝色)和1个输出层(绿色)。圆圈代表神经元。每个都有激活功能。两个相邻层之间的箭头表示突触，这些突触具有权重并被编码到矩阵中，该矩阵将值从输入神经元转换到输出。下面是同一网络的功能视图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mo"><img src="../Images/b8a0b32154b6a02c07071827ef391d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPnu8Fx-g2lziNyKONv3qA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 3.2 Functional picture of the same neural network above</figcaption></figure><p id="913d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">具体来说，数据输入<em class="ky"> X </em>是一个三维向量。<em class="ky"> W </em> ₁是一个4✕3矩阵(注意输入的列和输出的行)，<em class="ky"> W </em> ₂和<em class="ky"> W </em> ₃分别是4✕4和1✕4.<em class="ky"> F </em> ₁和<em class="ky"> F </em> ₂都是4元向量函数，称为激活函数。₃是一元元素。成本函数<em class="ky"> C </em>也是1元的。</p></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="782b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ky">表象的概括</em> </strong></p><p id="d96f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有人可能会问:<em class="ky">CNN</em>(卷积神经网络)在哪里？</p><p id="6fa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">答</strong>:实际上CNN只是上述结构的一个特例，其中变换矩阵<em class="ky"> W </em>为对角带状形式。每行的非零元素构成卷积核。</p><p id="3c95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个问题是:<em class="ky">CNN的图片怎么样</em>？</p><p id="751d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">答</strong>:同样是上面的特例。人们可以把2D图像想象成一个扁平1D矢量。然后可以将图像卷积核编码到<em class="ky"> W </em>的行中。</p><p id="a413" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，还有一个问题:<em class="ky">偏见术语</em>在哪里？</p><p id="c963" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">回答</strong>:那可以用计算机图形学中很常见的齐次坐标的概念来处理——在每个矢量函数的末尾附加一个值为1的常数激活函数。</p></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="cb6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在到了<strong class="ig hi">第一个</strong>有趣的点——把神经网络写成复合函数。以下是一些例子:</p><ul class=""><li id="d258" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lp lg lh li bi translated">单层—<em class="ky">C</em>(<em class="ky">F</em>(<em class="ky">WX</em>))</li><li id="e013" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">两层—<em class="ky">c</em>(<em class="ky">f</em>₂(<em class="ky">w</em>₂<em class="ky">f</em>₁(<em class="ky">w</em>₁<em class="ky">x</em>))</li><li id="b6b9" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">三层—<em class="ky">c</em>(<em class="ky">f</em>₃(<em class="ky">w</em>₃<em class="ky">f</em>₂(<em class="ky">w</em>₂<em class="ky">f</em>₁(<em class="ky">w</em>₁<em class="ky">x</em>))</li><li id="1529" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated"><em class="ky"> L </em>层—<em class="ky">c</em>(<em class="ky">fₗ</em>(<em class="ky">wₗfₗ</em>-₁(…(<em class="ky">w</em>₂<em class="ky">f</em>₁(<em class="ky">w</em>₁<em class="ky">x</em>))))</li></ul><p id="aa8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对这种复合函数的评估是从里到外进行的。例如，<em class="ky">c</em>(<em class="ky">f</em>₂(<em class="ky">w</em>₂<em class="ky">f</em>₁(<em class="ky">w</em>₁<em class="ky">x</em>))意味着<em class="ky"> X </em>首先与<em class="ky"> W </em> ₁相乘，然后被馈送到激活功能<em class="ky"> F </em> ₁.其结果乘以<em class="ky"> W </em> ₂，并馈送到₂.的<em class="ky"> F </em>最后，后者被馈送到成本函数<em class="ky"> C </em>。</p><p id="3056" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，神经网络被写成一个复合函数，在应用SGD(或小批量SGD)求解之前，只需要导出一种计算网络参数或矩阵权重的梯度的方法。但在此之前，需要一些必要的工具，即向量外积和元素积。</p></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="f315" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ky">矢量外积</em> </strong></p><p id="b36c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我用一个例子来说明什么是外部产品。给定两个向量<em class="ky"> A </em> =[ <em class="ky"> a </em> ₁、<em class="ky"> a </em> ₂、<em class="ky"> a </em> ₃】和<em class="ky"> B </em> =[ <em class="ky"> b </em> ₁、<em class="ky"> b </em> ₂]，它们的外积⊗是这样构造的:将第一个向量作为一列，第二个向量作为一行，将它们组合成一个按元素乘法的矩阵。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mp"><img src="../Images/88f21f102246c62984e9ff56b4037dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*doegJlGqSl-elUVClsf-sg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">|<em class="jo">A</em>|=<em class="jo">m,</em> |<em class="jo">B</em>|=<em class="jo">n. O</em>uter product A⊗B is a matrix of size <em class="jo">m</em>x<em class="jo">n</em></figcaption></figure><p id="e199" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ky">矢素积</em> </strong></p><p id="2e47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它被定义在两个相同长度的向量之间。输出也是相同的长度。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mq"><img src="../Images/d95a03231c382ba947bc8c8646262a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*in2cFA4RxnQIKt2kXNwQxA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">|<em class="jo">A</em>| = |<em class="jo">B</em>|. Element product A⨀B is a vector of the same length</figcaption></figure></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="eac0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.2神经网络梯度-链式法则</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mr"><img src="../Images/49b20f299e822fbcdec8443bf2f84011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Zsnvga44W5XXPmxqXIZHw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 3.3 A double layer network</figcaption></figure><p id="47bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在是第二个<strong class="ig hi">有趣的也是这个博客最重要的一点——链式法则——它允许计算成本函数w.r.t .任何参数的部分梯度。例如:图3.3中，参数为两个矩阵<em class="ky"> V </em>和<em class="ky"> W </em>。成本函数为<em class="ky"> C </em>。链式法则允许计算;<em class="ky"> Cᵥ、</em>ψ、<em class="ky"> C𝓌 </em>、部分梯度的<em class="ky"> C </em>对比<em class="ky"> V </em>和<em class="ky"> W </em>。</strong></p><p id="362c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在不太深入技术细节的情况下，让我们先看看结果。请注意元素产品和外部产品在这里是如何使用的。要注意的第二件事是公式的递归性质，这是后面要介绍的反向传播的基础。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ms"><img src="../Images/4eb2d729f3e31892bc2b46e5d0431465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlEjt9uM-ksrRgDsbbw-hw.png"/></div></div></figure><p id="3743" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在神经网络上下文中理解链式规则时，一个关键概念是<em class="ky">错误传播</em>。在网络训练期间，首先将输出与目标进行比较，并确定它们的差ψ;<em class="ky">C =</em>输出-目标，然后将其传播到输入，以计算在反向过程中遇到的参数梯度。</p><p id="3164" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考图3.3，想象一下▽ <em class="ky"> C </em>的第一个逆止点就在<em class="ky">f</em>那里，它变成了<em class="ky"> ϵ </em> ₁=▽ <em class="ky"> F </em> ☉▽ <em class="ky"> C </em>。偏渐变是▽ <em class="ky"> C𝓌=ϵ </em> ₁⊗ <em class="ky"> Gᵗ.</em>在<em class="ky"> G </em>正前方的第二个逆止点，误差变为<em class="ky">ϵ</em>₂=▽<em class="ky">g</em>☉[<em class="ky">wᵗϵ</em>₁】给出部分坡度<em class="ky"> Cᵥ=ϵ </em> ₂⊗ <em class="ky"> Xᵗ.</em></p><p id="2011" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般<em class="ky"> N- </em>层网络的链式法则总结如下。关于推导的更多细节可以在这个优秀的<a class="ae ks" href="http://neuralnetworksanddeeplearning.com/chap2.html" rel="noopener ugc nofollow" target="_blank">教程</a>中找到。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mt"><img src="../Images/0468f1313e155616db947a912954e971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pVQWv5VwvCjCqYQ404LYw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Chain rule of a general L-layer neural network</figcaption></figure><p id="d2ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.3反向传播</strong></p><p id="92c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定一般的链式法则，不难得到用于网络梯度计算的反向传播方法，这是这里的第三个有趣的事情。在向前传递期间，所有层输出和激活渐变都被缓存。在反向传播步骤中，误差首先通过权重矩阵的转置进行变换，然后通过前一层的激活函数的梯度进行缩放。之后，获得部分参数梯度作为更新的误差向量和缓存的输出之间的外积。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mu"><img src="../Images/a3490c2439177db1d49c02836bf6f313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*90yiPCLg-sxcEMblbgUyLQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Forward and backward propagation based on chain rule</figcaption></figure><p id="1ccd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3.4使用小批量SGD训练神经网络</strong></p><p id="850d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在手头有了训练神经网络的所有工具:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mv"><img src="../Images/5a34e09179772cb677462998091ecd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oa4-g8WrTEp6p9_sc_WT0Q.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Neural network training using Mini-batch SGD</figcaption></figure><p id="7e85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图3.4是典型的SGD成本降低曲线。这种波动与图2.4所示轨迹中的锯齿形一致。出现这种情况是有原因的。如何处理这一缺陷引出了下一个主题，即提高基于SGD的培训的性能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mw"><img src="../Images/39b289ea200f26856271c451178db664.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*7qMeSEXuNl1U4jiu.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 3.4 SGD convergence curve (<a class="ae ks" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" rel="noopener ugc nofollow" target="_blank">source</a>) — fluctuation as a result of gradient step zip-zag</figcaption></figure><h1 id="c58b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.优化者</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mx"><img src="../Images/18849a45c90a3e162a9572a04728cb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9kIpPSrUEeEfmdzh"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 4.1 Wiggling appears in a uneven error surface (<a class="ae ks" href="https://machinelearningnotepad.wordpress.com/2018/04/15/gradient-descent/" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure><p id="ed00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SGD的波动行为是因为极高维度成本函数的误差曲面一点也不均匀。图4.1中的图像展示了梯度不均匀性导致阶跃波动的现象。显然，更新步骤<em class="ky"> ⍺▽⍬ </em>需要在学习速率或方向上或者两者上进行修改。这是本节介绍的不同优化器的工作。完整的在线教程可以在这里找到<a class="ae ks" href="https://ruder.io/optimizing-gradient-descent/index.html#rmsprop" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="01e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4.1动量</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es my"><img src="../Images/01f30627d1caabde6fcfcc3cea7542bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*YALWhHxOJje4h8DyyZWEcQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 4.2 Momentum uses historical average of gradients as update direction as shown by the smooth blue trajectory (<a class="ae ks" href="https://www.programmersought.com/article/46834640604/" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure><p id="f624" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前面的分析所示，SGD面临一些挑战:</p><ul class=""><li id="40ad" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lp lg lh li bi translated">如果使用小的学习率，收敛速度很慢</li><li id="328b" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">如果采用较大的学习速率，收敛会出现波动甚至发散</li><li id="197e" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lp lg lh li bi translated">此外，必须处理梯度接近零的鞍点，这意味着迭代更新停止在局部最小值。</li></ul><p id="6006" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个想法实际上很简单——用所有历史梯度的平均值替换当前梯度。平均值像低通滤波一样平滑波动。与此同时，鞍点被<strong class="ig hi">动量</strong>超越(该方法因此得名)。动量的积累由<em class="ky">vₜ</em>+₁<em class="ky">=βv</em>ₜ<em class="ky">+</em>(1<em class="ky">-β</em>)▽<em class="ky">c𝓌</em>完成，其中<em class="ky"> β </em>为衰减因子。<em class="ky"> β </em>通常设置为0.9或更大的值，这意味着在每一步，90%或更多的更新来自动量。电流梯度仅贡献10%或更少。在鞍点，即使梯度为0，更新仍以先前动量的90%继续。一旦鞍点通过，新的梯度变得可用，训练获得新的速度。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mz"><img src="../Images/c39e376b328a3c0494afb55b4c187035.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*1jGWgjW5lFH_s36oGIMP0Q.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Update formulae of Momentum via historical gradient average</figcaption></figure><p id="74ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.2阿达格拉德</p><p id="0986" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">动量只改变方向分量<em class="ky"> ▽⍬ </em>而不改变学习速率。有时，希望采用每个参数的速率，使得较稀疏的参数(较平坦的误差区域)比不太稀疏的参数移动得更快。这是由AdaGrad(对于T21 Grad)通过添加与每个渐变的相应分量的累积长度成反比的每参数缩放来实现的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es na"><img src="../Images/6f383dcec0e194208746ef3e61df78b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*u8bcErUfaQK_70uginu33g.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Update formulae of AdaGrad — index i loops through each component of W. <em class="jo">ϵ is a small number to avoid division by zero, </em>usually on the order of 1e−8.</figcaption></figure><p id="8880" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的等式中，分母上的累积试图达到动量的历史平均值的类似效果。</p><p id="56ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AdaGrad的好处之一是，它消除了定期调整学习率<em class="ky"> ⍺ </em>的需要。大多数实现使用默认值0.01，并在整个时期保持不变。</p><p id="8b1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.3 RMSProp </p><p id="a968" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AdaGrad的主要弱点是它在分母中积累平方梯度——它在训练过程中不断增长——导致学习率收缩，最终变得无穷小，此时训练无法再前进。rms Prop(<strong class="ig hi">R</strong>oot<strong class="ig hi">M</strong>ean<strong class="ig hi">S</strong>quare<strong class="ig hi">Prop</strong>agation)通过限制过去渐变的窗口大小来解决这一缺陷。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nb"><img src="../Images/dede5873fbad317bcc8b1ee637350a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*ft9yDwNpSxbJIsYahwFxNQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Update formulae of RMSProp via the introduction of a decay factor, similar to that of Momentum</figcaption></figure><p id="8593" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它以一种巧妙的方式实现了这种效果，而没有通过使用衰减因子显式存储多个梯度，就像在动量中一样。由于<em class="ky"> β &lt; </em> 1，经过许多步骤后，更早的动量的累积重量变得如此之小，以至于它们的贡献实际上可以忽略，有点像软窗。RMSProp继承了动量的历史平均和AdaGrad的每个参数的缩放，因此具有两者的优点。</p><p id="7c4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4.4亚当</strong></p><p id="121f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，<strong class="ig hi"> Ada </strong>感受性<strong class="ig hi"> M </strong>矩估计结合了所有先前方法的优点，即衰减、动量和每参数缩放。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nc"><img src="../Images/bcabe698e68891caa60984a333d3b5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*tx_rqanEL1u5qLZz5_L4_A.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Update formulae of Adam</figcaption></figure><p id="3811" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于<em class="ky"> V </em>和<em class="ky"> E </em>被初始化为0向量，初始更新步长可能太小，尤其是当学习率很小时(即<em class="ky"> β </em> ₁和<em class="ky"> β </em> ₂接近1)。上面的两个中间等式旨在抵消这种影响。在早期阶段，当<em class="ky"> t </em>较小时，1/(1- <em class="ky"> β </em> ₁ <em class="ky"> ᵗ </em>)和1/(1- <em class="ky"> β </em> ₂ <em class="ky"> ᵗ </em>相对较大。因此<em class="ky"> V </em>和<em class="ky"> E </em>都被放大。在后期阶段，两个标度都接近1，从而将校正减少到几乎为零。建议的缺省值为:₁<em class="ky">β</em>0.9，₂<em class="ky">β</em>0.999，ϵ<em class="ky">1e 8</em>。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nd"><img src="../Images/dfd070447b10eb08ac150a90bac750d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*4sKuIMwIkPyw8uOcTQdERg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Fig. 4.3 Comparison of multiple optimizer’s performances (<a class="ae ks" href="https://www.fast.ai/2018/07/02/adam-weight-decay/" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="0192" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">右边的图4.3是刚刚介绍的一些优化器的比较。说明亚当的表现最好。特别是，在本地SGD中看到的波动在这里大大缓解。</p><h1 id="9c9d" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.所有关于DL的数学都在三个表格中</h1><p id="2c1f" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">这篇博客旨在剥离关于深度学习的令人费解且有时令人生畏的观点。它建立了从基本微积分概念，即导数和梯度到最新的DL算法的联系。它解释了为什么使用小批量SGD来代替简单梯度下降，以及优化器的设计背后的动机，这些优化器改善了训练性能，一次解决一个问题。最后，更简单的是，这里涉及到的所有关于DL的数学知识都被打包到下面的三个表格中，供你带走。</p><p id="25fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5.1功能优化</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ne"><img src="../Images/39b49c4d120189917d97188ae42ace2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWLnTsg1LTJ7v_KUAA1dOw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Notice the change from derivative to Jacobian, and appearances of mini-batch and learning rate.</figcaption></figure><p id="4624" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5.2反向传播</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nf"><img src="../Images/12f00204bc6a0029a4f4826cac5b484c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRKid0CfnC5N3L6JN85C5w.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Notice the use of caching in the forward pass for the later back-propagation, and the elegant structure.</figcaption></figure><p id="32a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5.3优化器</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ng"><img src="../Images/2f590f66c0eb006b82502ab6b9549b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBNwtO6opSDLK4Oty1iXXw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Notice the migration of the formulae (left to right) and recall what issue each aims to address.</figcaption></figure></div></div>    
</body>
</html>