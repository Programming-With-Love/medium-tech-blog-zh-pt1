<html>
<head>
<title>Parallel Processing in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的并行处理</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/parallel-processing-in-java-4a6c19e79570?source=collection_archive---------1-----------------------#2022-09-14">https://medium.com/walmartglobaltech/parallel-processing-in-java-4a6c19e79570?source=collection_archive---------1-----------------------#2022-09-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2295f8547acc020294dd06ba6bf32769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBnccfnM1j0XlDPpVnFapA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo Credit: <a class="ae it" href="https://pixabay.com/illustrations/man-office-businessman-business-1633667/" rel="noopener ugc nofollow" target="_blank">SerenaWong</a></figcaption></figure><p id="b2ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按需执行计算，同时在不到一秒的时间内从多个其他系统获取和聚合数据是我们一直想要做的事情。为了解决这个问题，我们求助于Java。</p><p id="3249" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们寻找用Java同时执行许多任务的最佳方式的过程中，我们评估和比较了各种选择。我们通过执行概念验证(POC)来进行我们的研究，使用每种类型进行大约600次HTTP调用。</p><p id="74cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们深入观察之前，让我们先检查一下我们探索的产品。</p><h1 id="3e51" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">顺序处理Java并行流</strong></h1><p id="b6f5" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">顺序处理是执行任务最直接的方式，其中一个调用接一个调用。这种方法花费的时间最多。</p><h1 id="d03c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> Java并行流</strong></h1><p id="4187" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Java并行流Java 8中引入的并行流可以同时处理大型数据集上的任务。当使用并行流时，Java runtime将一个任务分成多个子任务流，并在每个子任务流上并行执行。并行流使用ForkJoinPool，它合并了来自commonPool()的线程。默认情况下，线程池的大小等于逻辑CPU核心数减一。但是，也可以使用特定的系统属性进行自定义设置。</p><p id="328a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">并行流使用</strong></p><p id="44ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在以下情况下，考虑使用并行流:</p><ul class=""><li id="7ad3" class="kv kw hh iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">这项任务比数据分割和线程管理的开销更昂贵</li><li id="386c" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">有足够的数据可以处理</li><li id="cb49" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">每个数据点所需的计算量足够大(NQ模型)</li></ul><p id="bc7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">平行流副作用</strong></p><p id="9fe4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">并行流不能保证处理的顺序，所以只有当处理不需要按照一定的顺序执行时才应该使用并行流。当并行流用于执行阻塞或长时间运行的操作时，公共ForkJoin池的所有线程都将被占用，这将影响需要公共池的其他任务。</p><h1 id="4b9b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">可完成的未来</strong></h1><p id="d937" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">CompletableFuture是Java Future的扩展，可用于异步执行任务。使用CompletableFuture允许用户在一个单独的线程上执行一个任务，然后该线程将通知主线程发生的变化和任务的新状态。其思想是CompletableFuture被设计成允许用户执行一个长时间运行的任务(T1 ),而其他任务在主线程上并行执行。因此，该系统是有益的，因为它消除了其他同时运行的任务被主任务阻塞的问题，这将减少总的执行时间。</p><p id="99c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想执行一个任务并且不需要返回任何东西，使用runAsync() API，它返回一个CompletableFuture <void>。但是，如果您需要返回一些东西，请使用supplyAsync()，它接受Supplier <t>并在调用get()方法时返回T。</t></void></p><p id="ff9a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">默认情况下，CompletableFuture使用相同的ForkJoinPool和commonPool()作为并行流，但是可以向runAsync()/supplyAsync()方法提供自定义线程池。</p><p id="4364" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Completable Future还支持回调，一旦控制在将来完成时返回到主线程，就可以使用回调来执行某些操作。</p><h1 id="f73e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">比较</strong> <strong class="ak">祭品</strong></h1><p id="dde2" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们使用每种技术创建了600个HTTP GET请求，以比较完成任务的性能、开销和时间。这是我们的发现。</p><p id="fc44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与顺序处理相比，我们发现使用commonPool()的并行流可以减少89%的时间。此外，使用25个线程的自定义线程池将时间减少到customPool所需时间的一半。</p><p id="c8f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在对同一任务使用Completable Future时看到了类似的趋势，使用定制线程池()时时间减少了96%，使用commonPool()时时间减少了86%。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/e2e96873d8afbf145b39a7a8d69e483c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CHUuwzmwUyYIax8yMqQ-w.png"/></div></div></figure><p id="b21f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">参考文献</strong></p><ol class=""><li id="a6fe" class="kv kw hh iw b ix iy jb jc jf kx jj ky jn kz jr lo lb lc ld bi translated"><a class="ae it" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/concurrent/completablefuture . html</a></li><li id="d479" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr lo lb lc ld bi translated"><a class="ae it" href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/collections/streams/parallelism . html</a></li><li id="deef" class="kv kw hh iw b ix le jb lf jf lg jj lh jn li jr lo lb lc ld bi translated"><a class="ae it" href="https://xperti.io/blogs/java-parallel-stream-when-to-use/" rel="noopener ugc nofollow" target="_blank">https://xperti.io/blogs/java-parallel-stream-when-to-use/</a></li></ol></div></div>    
</body>
</html>