# Swift 中的通用类型

> 原文：<https://medium.com/globant/generic-type-in-swift-c37c993080e3?source=collection_archive---------0----------------------->

![](img/baef93888b956b99e10c83bfffbf2430.png)

If you are also thinking same let’s demystify the usage of generic type.

泛型代码使您的代码具有灵活性和可重用性，可以处理任何类型的代码。它避免了重复和抽象的表达方式。

以下是我们将在本教程中涉及的主题:

*   类函数
*   泛型类、结构
*   通用枚举
*   带约束的类属
*   作为关联类型的协议
*   关联类型的 where 子句

## **通用函数:**

显示所有类型的多态性的函数。

*   您可以通过在尖括号<t>中提供一个类型占位符来定义通用函数。</t>
*   你可以用任何东西来代替 T，例如:类型、数据类型等等。无论你想要什么。例如**func**print array<Type>(集合:[类型])

看看[苹果文档](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)中给出的注释👇

> 注意:
> 总是给类型参数大写字母名称(比如 T 和 MyTypeParameter ),以表明它们是一个*类型*的占位符，而不是值。

*   您可以使用类型 T 来指示在调用该方法时将传入该方法的参数的类型。
*   **printArray** 方法通过对 **int** 数组和 **string** 数组的类型推断来识别类型。

您可以声明多个泛型类型，这些类型在调用时可以不同，如下所示:

## **泛型类，结构:**

泛型类或结构可以用泛型类型定义，泛型类型可以是一种属性类型。

例如:
你可以定义泛型**公司**通过在用尖括号括起来的结构或类名后面添加泛型类型作为<行业>。

## **通用枚举**

就像 struct 或 class enum 可以定义为泛型一样。请检查下面的示例**模型**通用类型如何与**响应**案例相关联

在上面的例子中，您可以看到泛型代码的强大之处，其中一个代码库作为**serveresponsetype**enum 为所有的 **Model** 类型工作，这些类型作为。定义的响应案例。

## **带约束的类属:**

我们可以在函数、类、结构或枚举中定义泛型类型的任何地方添加约束。

在下面👇是用约束声明泛型占位符的语法:

**通用占位符:约束** //约束可以是任何**类**或**协议**

例如**T:has shable**

这个声明意味着，泛型类型参数继承自一个特定的类或者符合一个协议或者协议组合。

协议组合的示例如下:

1.  可比较的，
2.  文件处理协议:文件读取协议，文件写入协议

所以我们可以像下面这样使用这些成分:

**T:可比较的&可比的**

**T:文件处理协议**

让我们看看下面的例子 1，我们正在添加约束条件，以便**公司**可以与必须确认**行业身份**协议的**行业**类型相关联。

示例 1:

示例 2:

在下面的例子中，我们向服务器响应添加了一个约束，使其必须具有 **id** 。

> 注:可识别是 swift 中预定义的协议，此处仅作为示例，以便有一个清晰的理解。

由于**服务**没有确认**可识别的**协议，所以在将它作为值传递给**服务器响应类型**时。**响应**会提示如下编译时错误:

> **编译时错误:**通用枚举“服务器响应类型”要求“服务”符合“可识别”

## **作为关联类型的协议**

我们不能像在函数、类、结构或枚举中声明一样，在协议中直接定义泛型类型占位符。还有另一种方法将泛型类型定义为协议的占位符，即**关联类型。**

语法:

这里 **GenericPlaceholder** 可以是我们喜欢的任何东西，只要把它指定为泛型类型。并且 **GenericPlaceholder** 可以在协议中的任何方法、属性或下标声明中作为参数类型使用。

**GenericPlaceholder** 也可以添加约束。

例如**关联类型**通用占位符:**可比**

在下面的示例协议**中，可识别的**用通用类型 **IDType** 声明变量 id，其中 id 将是类型 **IDType** 。

可以通过以下任何一种方式进行确认:

在第一段代码中，编译器根据类型推断自动识别出 **id** 的类型，并将 **IDType** 视为结构产品的 **Int** 。

在第二个代码片段中，更多的是为了可读性，并指示编译器处理这种类型的相关方法、属性、下标等。你可以用编译器的自动修正功能来测试它。

## **关联类型的 Where 子句**

为了对关联类型添加更多要求，我们可以使用 where 子句。它的语法是

让我们来看看这个例子:
让我们假设在不同的城市有一个不同的仓库的需求，每个仓库可以包含某种类型的产品，并且每个仓库知道这个特定产品的所有分支。所以让我们借助泛型找到这个问题的解决方案。

## 何去何从:

如果你更好奇的话，可以去查一下我在本教程中没有提到的 Generic 的下列高级用法。你可以通过苹果的文档丰富的网站 [Swift 编程语言指南](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)来学习它们。

*   [扩展一个通用类型](https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID185)
*   [具有通用函数的 where 子句](https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID192)
*   [带有通用 Where 子句的扩展](https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553)
*   [通用下标](https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID558)