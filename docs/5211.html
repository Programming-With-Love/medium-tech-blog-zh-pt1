<html>
<head>
<title>Build widgets in Mendix with React Part 4— ArcGIS Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React在Mendix中构建微件第4部分ArcGIS地图</h1>
<blockquote>原文：<a href="https://medium.com/mendix/build-widgets-in-mendix-with-react-part-4-arcgis-maps-1eb44777f0c3?source=collection_archive---------5-----------------------#2022-10-20">https://medium.com/mendix/build-widgets-in-mendix-with-react-part-4-arcgis-maps-1eb44777f0c3?source=collection_archive---------5-----------------------#2022-10-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f742" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在这篇博客中，我们将使用ArcGIS Javascript API在我们的微件中构建一些地图，并在此过程中学习一些历史知识。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/988fe307401332dc03050ef4027e67dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ki5siWavxdiUqJG8BrwCA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Build widgets in Mendix with React Part 4 — ArcGIS Maps</figcaption></figure><h2 id="f0b5" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">Mendix是排名第一的低代码平台，它的主要优势之一是它提供的可扩展性。您可以使用React合并很酷的第三方库并扩展您的应用程序。</h2><p id="d696" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">这是一个多部分系列的第4篇博客，之前的博客可以在这里找到:</p><div class="lp lq fm fo lr ls"><a rel="noopener follow" target="_blank" href="/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">使用React在Mendix中构建小部件—第1部分—颜色计数器</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">Mendix是一个低代码平台，让制造商更快地交付价值并轻松构建应用程序。和门迪克斯一起…</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg jt ls"/></div></div></a></div><div class="lp lq fm fo lr ls"><a rel="noopener follow" target="_blank" href="/mendix/build-widgets-in-mendix-with-react-part-2-timer-b65c720b34e3"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">使用React在Mendix中构建小部件第2部分—计时器</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">Mendix使制造商能够通过可插拔小部件框架使用React扩展他们的应用程序。</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">medium.com</p></div></div><div class="mb l"><div class="mh l md me mf mb mg jt ls"/></div></div></a></div><div class="lp lq fm fo lr ls"><a rel="noopener follow" target="_blank" href="/mendix/build-widgets-in-mendix-with-react-part-3-kanban-2598aa71444d"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">使用React第3部分——看板在Mendix中构建部件</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">Mendix是排名第一的低代码平台，它使开发者开发应用程序的速度大大快于…</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">medium.com</p></div></div><div class="mb l"><div class="mi l md me mf mb mg jt ls"/></div></div></a></div><h2 id="fde1" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">我们在建造什么</h2><p id="e217" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">最近，<a class="mj mk gr" href="https://medium.com/u/b43844a7f8d5?source=post_page-----1eb44777f0c3--------------------------------" rel="noopener" target="_blank"> Ivo Sturm </a>写了一篇关于从Dojo转换一个现有的ArcGIS widget到React的博客。</p><p id="bfdb" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我认为<strong class="bd mq">从头开始构建一个简单版本的ArcGIS地图小工具</strong>会很有趣。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/a692a282e010439577d912e40c74544c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNlK3NwAnJIkRtq7JcZbEA.png"/></div></div></figure><h2 id="6bb2" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">开始</h2><p id="ee76" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">正如到目前为止所有的可插拔部件博客一样，我们从运行<code class="eh ms mt mu mv b">yo @mendix/widget arcGISMap</code>和<a class="ae mw" rel="noopener" href="/mendix/build-widgets-in-mendix-with-react-part-1-colour-counter-f1e400c3cdff">建立一个测试Mendix项目</a>来开始<strong class="bd mq">搭建我们的部件</strong>。</p><p id="6941" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">让我们从安装ArcGIS Javascript API的npm包开始</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="d081" class="jz ka hu mv b fv nb nc l nd ne">npm install @arcgis/core<!-- --> </span></pre><p id="dba2" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">ArcGIS是一个在线地理信息系统，允许您显示地图和添加图层来显示各种信息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/8745375ec40a3d418a28d78781447588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYOeglXLJ6-H30lKfSNiPQ.png"/></div></div></figure><p id="0124" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">为了访问完整的服务<a class="ae mw" href="https://developers.arcgis.com/documentation/mapping-apis-and-services/get-started/" rel="noopener ugc nofollow" target="_blank">,您需要注册并创建一个访问令牌</a>,但是对于我们的简单示例，我们可以继续进行。</p><h2 id="d411" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">入门指南</h2><p id="e6fd" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">查看<a class="ae mw" href="https://developers.arcgis.com/javascript/latest/display-a-map/#create-a-map-view" rel="noopener ugc nofollow" target="_blank">文档</a>我们可以更新我们的代码，得到两个文件:</p><p id="e46c" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><strong class="bd mq">一个家长</strong></p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="1f20" class="jz ka hu mv b fv nb nc l nd ne">import { ReactElement, createElement } from "react";<br/>import { MapComponent } from "./components/Map";<br/>import { ArcGISMapBlogContainerProps } from "../typings/ArcGISMapBlogProps";<br/>import "./ui/ArcGISMapBlog.css";</span><span id="b393" class="jz ka hu mv b fv ng nc l nd ne">export function ArcGISMapBlog(props: ArcGISMapBlogContainerProps): ReactElement {<br/>    return &lt;MapComponent basemap={props.basemap} /&gt;;<br/>}</span></pre><p id="2bb0" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><strong class="bd mq">还有一个孩子</strong></p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="3ee4" class="jz ka hu mv b fv nb nc l nd ne">import { ReactElement, createElement, useEffect, useRef } from "react";<br/>import Map from "<a class="ae mw" href="http://twitter.com/arcgis/core" rel="noopener ugc nofollow" target="_blank">@arcgis/core</a>/Map";<br/>import MapView from "<a class="ae mw" href="http://twitter.com/arcgis/core" rel="noopener ugc nofollow" target="_blank">@arcgis/core</a>/views/MapView";<br/>import Legend from "<a class="ae mw" href="http://twitter.com/arcgis/core" rel="noopener ugc nofollow" target="_blank">@arcgis/core</a>/widgets/Legend";</span><span id="ddbe" class="jz ka hu mv b fv ng nc l nd ne">export interface MapProps {<br/>    basemap: string;<br/>}</span><span id="2624" class="jz ka hu mv b fv ng nc l nd ne">export function MapComponent({ basemap }: MapProps): ReactElement {<br/>    const mapDiv = useRef(null);</span><span id="5343" class="jz ka hu mv b fv ng nc l nd ne">useEffect(() =&gt; {<br/>        if (mapDiv.current) {<br/>            MountMap(basemap);<br/>        }<br/>    }, [basemap]);</span><span id="ccdc" class="jz ka hu mv b fv ng nc l nd ne">const MountMap = (basemap: string): MapView =&gt; {<br/>        const legend = new Legend();<br/>        const map = new Map({ basemap });<br/>        const view = new MapView({<br/>            map,<br/>            center: [0.029, 51.256], // Longitude, latitude<br/>            zoom: 10, // Zoom level<br/>            container: mapDiv.current as unknown as HTMLDivElement <br/>        });</span><span id="dcce" class="jz ka hu mv b fv ng nc l nd ne">        legend.view = view;<br/>        view.ui.add(legend, "bottom-right");<br/>        return view;<br/>    };</span><span id="23c9" class="jz ka hu mv b fv ng nc l nd ne">return &lt;div id="viewDiv" ref={mapDiv} style={{height: "500px"}}/&gt;;<br/>}</span></pre><p id="c799" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">让我们<strong class="bd mq">也从ArcGIS </strong>导入样式表，这样我们可以让我们的小部件看起来更好，更改您的UI/{widgetName}。css至:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="66fd" class="jz ka hu mv b fv nb nc l nd ne">@import "https://js.arcgis.com/4.24/@arcgis/core/assets/esri/themes/dark/main.css";</span></pre><p id="83b1" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">现在我们用<code class="eh ms mt mu mv b">npm run build</code>构建我们的小部件……我们得到一个错误:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="2c41" class="jz ka hu mv b fv nb nc l nd ne">[!] Error: Invalid value for option "output.file" - when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option.</span></pre><p id="a51b" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">那么我们如何解决这个问题呢？为了解释，我们需要后退几步…</p><h2 id="0930" class="jz ka hu bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">Javascript简史</h2><blockquote class="nh ni nj"><p id="05cd" class="kx ky nk bd b kz ml iv lb lc mm iy le nl mn lg lh nm mo lj lk nn mp lm ln lo hn dt translated">下一部分是Javascript的简史，给出了解决方案的背景，如果您对此不感兴趣，可以跳过并继续这个例子</p></blockquote><p id="2563" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">开始的时候…</p><p id="3c11" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">Javascript是由Brendan Eich在1995年发明的，在开发的最初几年，它主要用于独立的脚本任务。随着JS开始在应用程序中被更多地使用，管理代码变得更加困难。JS通常以更复杂的方式跨多个脚本使用，这不可避免地会导致函数和名称冲突。</p><p id="4f2b" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">因此，引入了模块概念，这意味着可以在一个封闭的地方编写代码供内部使用，而不用担心在其他地方发生冲突，并且还允许开发人员将大型代码库分解为小的独立部分，从而更容易编写和维护。</p><p id="8775" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">第一次尝试解决这个问题是用<strong class="bd mq">立即调用函数表达式(life)</strong>，它本质上只是将每个文件包装在一个函数中，将变量和函数保存在一个文件中，在那个作用域而不是全局作用域。</p><p id="7423" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><code class="eh ms mt mu mv b">(function() {// Your code }) ();</code></p><p id="c88d" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">这种方法仍然有许多问题，包括缺乏依赖性解析和全局名称空间的污染。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff no"><img src="../Images/ad20f0c761685f1539eac46b57b2e32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*LEhYXTDHIIIY1mJy.jpg"/></div></figure><p id="e074" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">随着时间的推移，出现了3种独立的(且相互竞争的)模块规格:</p><ul class=""><li id="593c" class="np nq hu bd b kz ml lc mm kk nr ko ns ks nt lo nu nv nw nx dt translated"><strong class="bd mq">CommonJS</strong>——仍然广泛用于服务器端JS的节点中，通过它的<code class="eh ms mt mu mv b">require()</code>和<code class="eh ms mt mu mv b">module.exports</code>语法很容易识别</li><li id="0640" class="np nq hu bd b kz ny lc nz kk oa ko ob ks oc lo nu nv nw nx dt translated"><strong class="bd mq"> AMD </strong> —异步模块定义，早期从CommonJS拆分。关键区别在于AMD允许互不依赖的模块异步加载(都在名字里！)</li><li id="e54f" class="np nq hu bd b kz ny lc nz kk oa ko ob ks oc lo nu nv nw nx dt translated"><strong class="bd mq"> UMD </strong> —通用模块定义，支持其他两种模块规范以及“旧式”的“全局”变量定义</li></ul><p id="f356" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">这一切都非常复杂…所以有些好消息。自2015年和ES6发布以来，<strong class="bd mq">模块已经在Javascript语言</strong>中得到支持。这给了我们在代码中一直使用的可爱而简单的<code class="eh ms mt mu mv b">import</code>和<code class="eh ms mt mu mv b">export</code>语法。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff od"><img src="../Images/0d6b1fff47f2d9ab12ad0251d3c51f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ln2Fsb4h3Sa3afR.jpg"/></div></div></figure><p id="51e6" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">那么为什么要上历史课呢？嗯，当我们写代码时，我们需要能够处理所有这些模块类型，这就是捆绑器的用武之地。</p><h1 id="5ebc" class="oe ka hu bd kb of og oh kf oi oj ok kj ja ol jb kn jd om je kr jg on jh kv oo dt translated">Bundlers</h1><p id="2c06" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">捆绑器允许你在编译时<strong class="bd mq">编译你的代码</strong>，<strong class="bd mq">处理你的依赖</strong>，<strong class="bd mq">提供一个兼容的连接文件</strong>。常见的解决方案包括<strong class="bd mq"> Webpack </strong>(用于Mendix 8小部件)和<strong class="bd mq"> rollup </strong>(用于Mendix 9小部件)</p><p id="9911" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">这允许您使用现代ES6特性(如果您喜欢，甚至可以使用Typescript)模块化地编写代码，然后生成一个优化的文件(或一组文件)提供给浏览器。</p><p id="0509" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">这很好，但是一些浏览器还不支持ES6，所以他们不能对这些编译好的文件做任何事情。为了修复这个<strong class="bd mq">,我们可以使用一个Transpiler </strong>,比如<strong class="bd mq"> Babel </strong>,以一种可以阅读的格式将它提供给网页。</p><p id="a115" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">所以回到我们的部件…</p></div><div class="ab cl op oq hb or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="hn ho hp hq hr"><p id="da51" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">可插拔小部件框架需要您为Mendix应用程序开发React组件所需的所有工具。这包括:</p><ul class=""><li id="970d" class="np nq hu bd b kz ml lc mm kk nr ko ns ks nt lo nu nv nw nx dt translated"><strong class="bd mq"> npm </strong> —轻松安装和管理第三方软件包的软件包管理器</li><li id="2ad8" class="np nq hu bd b kz ny lc nz kk oa ko ob ks oc lo nu nv nw nx dt translated"><strong class="bd mq">roll up</strong>——一个捆绑器，它允许你模块化地编写你的代码，然后把它捆绑在一个小的包里</li><li id="287e" class="np nq hu bd b kz ny lc nz kk oa ko ob ks oc lo nu nv nw nx dt translated">babel——一个transpiler，它将JS转换成一种可以被旧浏览器(和Studio Pro)阅读的格式</li></ul><p id="dcab" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">那么我们的错误是什么意思呢？</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="e9ad" class="jz ka hu mv b fv nb nc l nd ne">[!] Error: Invalid value for option "output.file" - when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option.</span></pre><p id="4e93" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">对于每个小部件项目，我们使用@mendix/pluggable-widget-tools库提供的汇总配置。</p><blockquote class="nh ni nj"><p id="b641" class="kx ky nk bd b kz ml iv lb lc mm iy le nl mn lg lh nm mo lj lk nn mp lm ln lo hn dt translated">这可以在以下文件中找到:</p><p id="af9b" class="kx ky nk bd b kz ml iv lb lc mm iy le nl mn lg lh nm mo lj lk nn mp lm ln lo hn dt translated"><strong class="bd mq">node _ modules/@ mendix/pluggable-widget-tools/configs . roll up . config . js .</strong></p></blockquote><p id="bc90" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">在这个配置中，我们<strong class="bd mq">告诉我们的小部件将编译好的JS放到一个文件中</strong>。同时，我们正在使用的<strong class="bd mq"> ArcGIS npm库</strong>提供了块中的<strong class="bd mq">动态导入，默认情况下<strong class="bd mq"> rollup希望将这些块作为单独的文件发布到目录</strong>中。</strong></p><p id="3783" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">要解决这个问题，我们只需要按照错误中所说的去做，然后<strong class="bd mq">设置inlineDynamicImports选项</strong>，这将把所有内容都放入一个文件中。我们可以更改可插拔小部件库中的rollup.config.js文件，但这是一个非常糟糕的想法，因为它不可维护，并且会创建非常难以阅读和调试的代码。幸运的是<strong class="bd mq"> Mendix有内置功能来设置我们自己的汇总配置</strong>。</p><p id="01e0" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我们需要<strong class="bd mq">在根小部件目录中创建一个名为r <strong class="bd mq"> ollup.config.js </strong>的文件</strong>。然后，我们添加以下JS代码来更改小部件的构建方式:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="eabc" class="jz ka hu mv b fv nb nc l nd ne">export default args =&gt; {<br/>    const result = args.configDefaultConfig;<br/>    console.warn ('Custom roll up')<br/>    return result.map((config) =&gt; {<br/>                config.output.inlineDynamicImports = true<br/>                console.warn ("Set dynamic imports")<br/>                return config;<br/>    });<br/>};</span></pre><p id="9af2" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">所以我们再次运行<code class="eh ms mt mu mv b">npm run build</code>，得到一个新的错误:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="a8f7" class="jz ka hu mv b fv nb nc l nd ne">FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory</span></pre><p id="c19b" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">原来构建过程需要更多的内存。我可以通过运行</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="73ee" class="jz ka hu mv b fv nb nc l nd ne">export NODE_OPTIONS=--max_old_space_size=5120</span></pre><p id="8eed" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">如果我们重建，那么我们的小部件现在编译。</p></div><div class="ab cl op oq hb or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="hn ho hp hq hr"><p id="f8e5" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我们的bundler可以帮助我们创建单个文件，这样它们就可以很容易地被浏览器读取。</p><p id="d836" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">Rollup还做了一些非常聪明的事情，叫做<strong class="bd mq">树摇动</strong>:这涉及到在你的代码和<strong class="bd mq">中构建一个<strong class="bd mq">依赖树的映像，只包括实际需要的代码</strong>。这在使用大型库时特别有用，可以避免将大量未使用的代码加载到浏览器中。这种树抖动是Mendix在Mendix 8和9之间从webpack切换到rollup的关键因素之一。</strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ow"><img src="../Images/d518cd65bd0c2c71f61fa557aa7bd228.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*VtrgoyahncJ234G8.gif"/></div></figure><p id="eb79" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">捆扎机还附带了一大堆其他功能，以插件的形式出现。在这篇博客中，我想做的最后一件事是讨论一个非常常见的用例，即必须修改小部件的汇总配置</p><h1 id="c656" class="oe ka hu bd kb of og oh kf oi oj ok kj ja ol jb kn jd om je kr jg on jh kv oo dt translated">提供您的小部件需要的文件</h1><p id="3024" class="pw-post-body-paragraph kx ky hu bd b kz la iv lb lc ld iy le kk lf lg lh ko li lj lk ks ll lm ln lo hn dt translated">ArcGIS通过<strong class="bd mq">内容交付网络(CDN) </strong>交付创建地图所需的文件。但是，可能会有<strong class="bd mq">个实例，您希望保留</strong> <strong class="bd mq">并在您的小部件</strong>中管理这些文件，这可能是由于您组织内的防火墙设置。幸运的是，ArcGIS Javascript API使这成为可能。</p><p id="f96c" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">首先要做的是更新我们的代码，告诉API我们将在本地管理我们的资产。为此，我们只需更新容器组件，使其包含:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="4814" class="jz ka hu mv b fv nb nc l nd ne">import esriConfig from "<a class="ae mw" href="http://twitter.com/arcgis/core" rel="noopener ugc nofollow" target="_blank">@arcgis/core</a>/config.js";</span><span id="4e38" class="jz ka hu mv b fv ng nc l nd ne">export function ArcGISMapBlog(props: ArcGISMapBlogContainerProps): ReactElement {<br/>    esriConfig.assetsPath = "./widgets/mendix/arcgismapblog/assets";<br/>    return &lt;MapComponent basemap={props.basemap} /&gt;;<br/>}</span></pre><p id="cd2f" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">接下来，我们需要<strong class="bd mq">更新</strong>我们的<strong class="bd mq">汇总</strong>到<strong class="bd mq">从我们的节点模块中获取我们</strong>需要的文件，然后<strong class="bd mq">把它们放到我们的小部件</strong> mpk中。</p><p id="46d6" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">要做到这一点，我们可以<strong class="bd mq">使用汇总复制插件</strong>(什么都有插件)，首先，我们需要安装它</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="32e4" class="jz ka hu mv b fv nb nc l nd ne">npm i rollup-plugin-copy —save-dev </span></pre><p id="f1a8" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我们使用<code class="eh ms mt mu mv b">—save-dev</code>命令，因为它是一个只有在开发时才需要的依赖项。然后，我们将rollup.config.js更新为:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="b4c7" class="jz ka hu mv b fv nb nc l nd ne">import copy from "rollup-plugin-copy";<br/>export default args =&gt; {<br/>    const result = args.configDefaultConfig;<br/>    console.warn ('Custom roll up')<br/>    return result.map((config) =&gt; {<br/>                config.output.inlineDynamicImports = true<br/>                console.warn ("Set dynamic imports")<br/>                const plugins = config.plugins || []<br/>                config.plugins = [<br/>                    ...plugins,<br/>                    copy({<br/>                        targets: { src:"node_modules/@arcgis/core/assets", dest:"dist/tmp/widgets/mendix/arcgismapblog" }]</span><span id="6f97" class="jz ka hu mv b fv ng nc l nd ne">}),<br/>                ]  <br/>                return config;<br/>    });<br/>};</span></pre><p id="9072" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">这个<strong class="bd mq">从ArcGIS npm包中获取“assets”</strong>文件夹，然后<strong class="bd mq">将其放入我们的dist/tmp文件夹</strong>，这是最终压缩以创建我们的mpk的内容。然后，当我们运行我们的应用程序时，小部件mpk的内容被提供给<strong class="bd mq">。/widgets/{ your organization name }/{ yourWidgetName }</strong>。</p><p id="767e" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">为了看到这一点，让我们运行命令来构建我们的小部件</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="35fa" class="jz ka hu mv b fv nb nc l nd ne">npm run build</span></pre><p id="e0e8" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">然后我们可以重新运行我们的应用程序。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ox"><img src="../Images/7a003df43a4ad2803e4fd0db2dce51c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YGKygT3y96vxsbg4pW3Ww.png"/></div></div></figure><p id="bb4e" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">如果我们打开我们的部署目录，我们可以看到微件提供给资产文件夹，如果我们在chrome开发工具中检查我们的页面源，我们可以看到ArcGIS web assembly文件提供给浏览器以确保我们的地图工作</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/02c4badde1b80371dc1fcdfb009146e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*hxC8T5MeFMaN925ucwO90A.png"/></div></figure></div><div class="ab cl op oq hb or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="hn ho hp hq hr"><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oz"><img src="../Images/d43073ccce008e3f4d76d3aa05e2905f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-E3chfzm0lJkObjX.png"/></div></div></figure><p id="1b11" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我们没有更新我们的CSS来使用本地文件。为此，我们只需将文件更新为:</p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="fb07" class="jz ka hu mv b fv nb nc l nd ne">@import "../assets/esri/themes/dark/main.css";</span></pre><p id="a886" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">简单…有点…</p><p id="ac4c" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">如果您使用的是9 . 13 . 2或更低版本的<strong class="bd mq">插件工具，并且您使用的是Windows，那么您的<strong class="bd mq">字体将无法正确导入</strong>。rollup.config.js中需要以下代码来修复导入:</strong></p><pre class="jk jl jm jn fq mx mv my mz aw na dt"><span id="79b9" class="jz ka hu mv b fv nb nc l nd ne">import postcssUrl from "postcss-url";</span><span id="6601" class="jz ka hu mv b fv ng nc l nd ne">const cssUrlTransform = asset =&gt; {<br/>    const outWidgetDirForwardSlash = outWidgetDir.replace(/\\/g, "/")<br/>    return asset.url.startsWith(`${assetsDirName}/`) ? `${outWidgetDirForwardSlash}/${asset.url}` : asset.url;<br/>}</span><span id="653d" class="jz ka hu mv b fv ng nc l nd ne">export default args =&gt; {<br/>    const result = args.configDefaultConfig;<br/>    console.warn ('Custom roll up')<br/>    return result.map((config) =&gt; {<br/>                config.output.inlineDynamicImports = true<br/>                console.warn ("Set dynamic imports")<br/>                const plugins = config.plugins || []<br/>                config.plugins = [<br/>                    ...plugins,<br/>                    postcssUrl (cssUrlTransform)</span><span id="d08e" class="jz ka hu mv b fv ng nc l nd ne">]  <br/>                return config;<br/>    });<br/>};</span></pre><p id="3cf1" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">然后运行<code class="eh ms mt mu mv b">npm install postcss-url --save-dev</code>。您的小部件现在将呈现图标。</p></div><div class="ab cl op oq hb or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="hn ho hp hq hr"><p id="fc3c" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我们完了。</p><p id="7d11" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">ArcGIS API包含了许多令人惊叹的功能，我鼓励您去探索它。要查看它能做什么的一个很好的例子，请查看Ivo Sturm的小部件:</p><div class="lp lq fm fo lr ls"><a href="https://github.com/ivosturm/ArcGIS-React" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">GitHub - ivosturm/ArcGIS-React:基于React的新的改进的ArcGIS微件</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">基于React、Mendix可插拔微件API和最新的ArcGIS API(4.22/02-2022)1 . 0 . 0版的新ArcGIS微件…</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">github.com</p></div></div><div class="mb l"><div class="pa l md me mf mb mg jt ls"/></div></div></a></div><p id="5445" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">我的ArcGIS微件的报告可在以下位置找到:</p><div class="lp lq fm fo lr ls"><a href="https://github.com/joe-robertson-mx/arcGISMapBlog" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab ej"><div class="lu ab lv cl cj lw"><h2 class="bd hv fv z el lx eo ep ly er et ht dt translated">GitHub -乔-罗伯逊-mx/arcGISMapBlog</h2><div class="lz l"><h3 class="bd b fv z el lx eo ep ly er et ek translated">通过在GitHub上创建一个帐户，为joe-robertson-mx/arcGISMapBlog开发做出贡献。</h3></div><div class="ma l"><p class="bd b gc z el lx eo ep ly er et ek translated">github.com</p></div></div><div class="mb l"><div class="pb l md me mf mb mg jt ls"/></div></div></a></div><p id="f558" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated">在我的下一篇文章中，我们将利用我们对rollup的理解在我们的Mendix应用程序中运行WebAssembly，到时见！</p></div><div class="ab cl op oq hb or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="hn ho hp hq hr"><p id="b7b0" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><em class="nk">来自发布者- </em></p><p id="e518" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><em class="nk">如果你喜欢这篇文章，你可以在我们的</em> <a class="ae mw" href="https://medium.com/mendix" rel="noopener"> <em class="nk">媒体页面</em> </a> <em class="nk">找到更多类似的文章。对于精彩的视频和直播会话，您可以前往</em><a class="ae mw" href="https://www.mendix.com/live/" rel="noopener ugc nofollow" target="_blank"><em class="nk">MxLive</em></a><em class="nk">或我们的社区</em><a class="ae mw" href="https://www.youtube.com/c/MendixCommunity/community" rel="noopener ugc nofollow" target="_blank"><em class="nk">Youtube PAG</em></a><em class="nk">e .</em></p><p id="a61f" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><em class="nk">希望入门的创客，可以注册一个</em> <a class="ae mw" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="nk">免费账号</em> </a> <em class="nk">，通过我们的</em> <a class="ae mw" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="nk">学苑</em> </a> <em class="nk">获得即时学习。</em></p><p id="946f" class="pw-post-body-paragraph kx ky hu bd b kz ml iv lb lc mm iy le kk mn lg lh ko mo lj lk ks mp lm ln lo hn dt translated"><em class="nk">有兴趣加入我们的社区吗？加入我们的</em> <a class="ae mw" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="nk">松弛社区频道</em> </a> <em class="nk">。</em></p></div></div>    
</body>
</html>