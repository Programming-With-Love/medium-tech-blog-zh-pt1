<html>
<head>
<title>In-sprint test automation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冲刺阶段测试自动化</h1>
<blockquote>原文：<a href="https://medium.com/globant/in-sprint-test-automation-ff0d0af473?source=collection_archive---------0-----------------------#2020-11-26">https://medium.com/globant/in-sprint-test-automation-ff0d0af473?source=collection_archive---------0-----------------------#2020-11-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="85e8" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="85e7" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">随着敏捷方法变得非常普遍，测试自动化在软件开发中也变得越来越重要。测试自动化在许多方面增强了软件开发。如果测试自动化以相同的开发周期完成，那么回归也可以在下一个sprint的第一次构建中执行。因此，我们将收到快速的反馈，每一个建设和质量将在检查始终。</p><p id="d70d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">UI测试自动化通常需要相当多的时间和精力来编写脚本。它包括测试场景分析、编码、代码审查、执行和稳定。我们经常发现很难在特性开发的同一个冲刺阶段完成所有这些活动。因此，产品团队在N+1冲刺中决定测试自动化，其中N是特性开发的冲刺次数。由于UI测试自动化是自动化和维护成本最高的一种，让我们看看如何在相同的开发冲刺阶段实现UI测试自动化。</p><h1 id="50e2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">带有next Sprint UI测试自动化的常规Sprint模型</h1><p id="569d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让我们来看一个sprint模型，在这个模型中，UI测试自动化是在特性开发之后的Sprint中完成的。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/2d619007b951ead481643f3113afe47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pXT7D_JYn_g3uxiB"/></div></div></figure><p id="8adf" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如上表所示，在一个Sprint中对这些用户场景进行特性开发和手工测试，在下一个Sprint中对相同场景进行自动化测试。</p><h1 id="11bf" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Sprint内的自动化工作进度</h1><p id="c3c9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让我们考虑一个敏捷项目，其中Sprint的节奏是2周。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/6154d0857c9154b2c80b62fbf8c9708d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n_jIntP7kM5LyIsq"/></div></div></figure><h1 id="fa16" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">冲刺测试自动化:挑战</h1><p id="6672" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因此，如果我们将上述自动化方法与开发Sprint对应起来，我们将会看到挑战。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/2a04aa6d93b0b8550abe8681ba174d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8YOJjc0xL0KrF-Ee"/></div></div></figure><p id="72f3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这里，如果我们观察上面的模型，我们会发现大多数测试自动化步骤都依赖于手工测试人员或者开发团队。</p><ol class=""><li id="2747" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz kw kx ky kz bi translated">前两个步骤被阻塞，因为在sprint开始时，手动测试用例还没有准备好。通常，手动创建测试用例需要4-5天。</li><li id="3bd1" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">第三步受阻，因为开发团队尚未准备好页面。</li><li id="9660" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">9号和10号也是因为同样的原因被封。</li><li id="ae28" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">由于上述阻碍，剩余步骤无法执行。</li></ol><p id="b122" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">所以自动化团队会被别人封杀，需要等待。</p><h1 id="e943" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">成功的关键因素</h1><ul class=""><li id="5b6b" class="kr ks hh je b jf jg jj jk jn lf jr lg jv lh jz li kx ky kz bi translated"><strong class="je hi">敏捷团队游戏</strong></li></ul><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lj"><img src="../Images/bf9ab60f3ff8da79a0116491d6fb2a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t2lzgdux1VENEPDJ"/></div></div></figure><p id="8323" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">正如没有团队的支持，“梅西”一个人无法进球一样，质量是每个人的责任。如果团队决定进行测试自动化并从中获益，那么所有的涉众都需要为之努力。以下是一些关于如何计划这一活动的建议:</p><ol class=""><li id="2a4c" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz kw kx ky kz bi translated">设计团队应该准备好线框或模型屏幕，并在开发团队在开发冲刺阶段选择它们之前获得批准。</li><li id="797c" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">BA应该以一种可以在Sprint中开发的方式创建用户故事，给QA和自动化留出足够的时间来完成。</li><li id="9eec" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">开发团队不应该在冲刺的最后一天完成故事。</li><li id="56c5" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">测试自动化团队应该能够访问开发存储库，以便他们能够检出特性分支，并在本地部署以观察新元素和屏幕。</li><li id="9403" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">手动测试工程师应该在Sprint的早期完成测试设计。</li><li id="08c8" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">测试自动化工程师应该足够精通在Sprint的早期开始自动化任务。</li></ol><ul class=""><li id="9125" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated"><strong class="je hi">策划</strong></li></ul><p id="9b44" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">围绕测试自动化的适当规划是成功的另一个关键标准。计划应该围绕自动化候选人的识别、自动化覆盖率、团队规模、开发人员与测试自动化工程师的比例。此外，测试工程师需要有一个合适的入职计划。大多数情况下，我们观察到当有相当多的功能准备好的时候，测试自动化工程师就加入了团队。所以团队已经积压了很多工作，所以永远无法在同一个sprint中实现测试自动化。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lk"><img src="../Images/636433f8a442f111a805bc62d32a2725.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*GMVTI4I05YmmiVDD"/></div></figure><p id="e43a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">一个好的回归测试套件不仅仅是关于UI测试，还包括后端测试。自动化团队不应该试图自动化所有的UI测试用例。应根据以下3个参数选择自动化候选。</p><ul class=""><li id="7234" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated">测试用例覆盖的业务重要性</li><li id="30cc" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated">我们需要多久测试一次这个场景</li><li id="ed0c" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated">自动化可行性。</li></ul><p id="b0c7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">以上3个参数应该被认为是自动化测试用例选择的与门。因此测试满足所有条件，并且将被考虑自动化。</p><p id="c56c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">所以回归测试套件应该是UI和后端测试的良好组合，以确保良好的覆盖率。与后端测试相比，UI测试的成本很高，在执行过程中需要更多的时间。</p><ul class=""><li id="9bd7" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated"><strong class="je hi">国防部和国防部的必备规则</strong></li></ul><p id="4c94" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当我们与其他团队讨论依赖性时，我们应该相应地在DoR和DoD中添加条款。下面的子句应该在那里。</p><p id="9ec9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">多尔:</strong></p><ul class=""><li id="f586" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated">用户故事应附有最终的线框/VD。</li><li id="aa9b" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated">完成该功能的所有UI组件都应该准备好了。</li></ul><p id="8dd7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">国防部</strong></p><ul class=""><li id="ebe8" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated">所有高价值(如P1、P2)场景的自动化。</li><li id="7518" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated">管道中所有自动化测试用例的执行。</li><li id="2928" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated">现有自动化回归套件的完整运行。</li><li id="650d" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz li kx ky kz bi translated"><strong class="je hi">冲刺模式</strong></li></ul><p id="8791" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为了适应上面讨论的所有要点，我们需要Sprint中的自动化测试脚本流程。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/c94444731d4bb411b207241d0f36e0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lof9owD3LXGM_S06"/></div></div></figure><p id="c2fb" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这个修改过的方法中，任务被分成三个部分，我们重新安排了上述传统sprint方法的步骤。括号中提到的数字是以前的步骤索引，因此传统方法的步骤4成为该方法的第一步。这有助于从sprint的第一天开始测试自动化任务。</p><p id="facc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这里，我们认为最终的视觉设计，互动设计和线框准备就绪。第一部分是创建页面对象结构，带有定位器和相应页面动作的占位符。此外，如果需要任何新的实用程序，可以创建。这应该由领导进行审查和合并，以确保结构和实用程序是正确的。</p><p id="afef" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在下一部分中，我们期望手动测试团队准备好手动测试用例。因此自动化团队可以开始识别潜在的自动化测试用例。经过筛选的测试可以编码。当页面对象准备就绪时，流程就可以完成了。此时，我们只能模拟测试，而不是实际执行。我们还没有添加定位器，该功能也没有准备好和部署。所有的代码都应该由负责人或相关团队成员进行审查和合并</p><p id="acff" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在最后阶段，我们期望该特性至少在开发人员的本地分支中已经准备好，或者已经部署好进行测试。如果该特性具有本地分支，我们可以将它部署到本地主机中，并从应用程序中识别实际的定位器。一旦实际的定位器就位，测试就可以稳定地进行了。那么自动化工程师最需要解决的是在执行过程中观察到的问题。在几次执行之后，测试应该是稳定的。然后最后要审核合并。</p><p id="6609" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这种方法中，工程师不必等到应用程序开发完成后才开始自动化代码。</p><ul class=""><li id="da8d" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz li kx ky kz bi translated"><strong class="je hi">自动化框架设计</strong></li></ul><p id="b976" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">框架设计应该高效地支持上述Sprint策略。传统的页面对象模型设计使用了更多的定位器，因此，它减慢了开发速度。</p><p id="85ec" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在大多数情况下，UI应用程序开发采用基于组件的方法。在这种方法中，开发人员创建小单元的UI元素，并在整个应用程序中重用它们。此外，它们组合UI元素来创建更复杂的可重用元素。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/b30ff97714eab8b056fa6ecf488ed585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HjEDGiZMOfJw0nVV"/></div></div></figure><p id="beb8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为了开发自动化框架，我们必须采用相同的方法。我们将创建主要元素的类型，然后组合这些元素来生成可重用的复合UI元素，而不是向页面添加元素。主元素可以是任何小的可重用UI元素。例如自定义按钮、选项按钮、标题等。</p><p id="ebf4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们用下面的例子来理解这个概念(参考:<a class="ae ll" href="https://www.codecademy.com/catalog" rel="noopener ugc nofollow" target="_blank"> codecademy </a>)。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/ea5f05bab9f97ddbdfc6ea773a2ef160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KFpfrIC876SUBmdN"/></div></div></figure><p id="9295" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里我们可以看到截图中的三种模式。这些模式如下</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lm"><img src="../Images/858065c723b49b2facdacf2939ae2ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*_kPtr-jg9oujdIe5"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ln"><img src="../Images/fd0b9f3ef8cafed713403dd784ed1ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*Pshx96XzhA48sUl4"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lm"><img src="../Images/2aa325424ff9070c9474adaa9509d627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*nsiWowBOPE-ZBpeI"/></div></figure><p id="8284" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这些是我们的复合组件。只有文本被更改以生成类型的新元素。所以这三个将是我们的复合组件类。我们将向构造函数提供文本值，以根据需要生成每种类型的元素。</p><p id="6c1b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来，让我们确定主要元素。以下Ui元素是我们示例中的主要元素。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lo"><img src="../Images/d4b6ca4afcf5b38633d3779d8903acdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/0*pwXXuFABZIQ_a3nW"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lp"><img src="../Images/ae46e651b54b5ab4a650e508c3001a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/0*x6ZuXbZVCyJQ2U9Q"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lq"><img src="../Images/a8b7e3afa7630cdb73397fa81c1bfe11.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/0*BFKFXQann6EKjDvp"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lr"><img src="../Images/dc4932d0b5f381346db31ca429ef9cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/0*NPKNmSjRjUmiDOV5"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ls"><img src="../Images/ae4ba96a1ab6b990457d6b8c78a5e42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/0*128mJtL-nqLtu8pm"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lt"><img src="../Images/3d12a1c7167bc061ea598b1843ea412a.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/0*IKBX1oQN4RhFyW3s"/></div></figure><p id="9e73" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这些元素用于创建复合元素。这些将是我们主要元素的课程。复合元素类将拥有这些类的一个实例。</p><p id="2269" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">一旦我们准备好了主要和次要元素类，它们将被添加到页面类中以生成页面对象结构。</p><h1 id="b003" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">摘要</h1><p id="cd0e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在Sprints中，如果我们正确地遵循上面的步骤，自动化是可以实现的。领导者必须承担主要责任，有效地推动团队努力。自动化工程师应该对框架及其组件有适当的了解。尽管测试自动化工程师需要投入大部分精力，但最终，这是一场团队游戏。项目团队的所有成员都需要相互支持才能成功。</p></div></div>    
</body>
</html>