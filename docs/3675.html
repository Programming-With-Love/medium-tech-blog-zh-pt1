<html>
<head>
<title>A short (and simple) introduction to algorithm profiling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法分析的简短介绍</h1>
<blockquote>原文：<a href="https://medium.com/globant/a-short-an-simple-introduction-to-algorithm-profiling-26176f5ce0f3?source=collection_archive---------0-----------------------#2021-05-14">https://medium.com/globant/a-short-an-simple-introduction-to-algorithm-profiling-26176f5ce0f3?source=collection_archive---------0-----------------------#2021-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/78582cc187d1d5ed8ed20cc4be269d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5lxJOGsyaoownOw2qVAsw.jpeg"/></div></div></figure><div class=""/><p id="7d33" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将了解概要分析的概念，并将看到一个Python示例，展示如何将低效的算法转换为高效的算法。最后，我们将思考软件开发过程中涉及的不同角色如何影响应用程序的性能。</p><h1 id="260e" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">简而言之，什么是剖析？</h1><p id="3390" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">形式定义表明<em class="kq">剖析是一种动态程序分析的形式，例如，测量程序的空间(内存)或时间复杂度，特定指令的使用，或者函数调用的频率和持续时间。最常见的是，分析信息有助于程序优化。</em></p><p id="d06e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以在源代码级别或可执行对象级别检测分析，有多种技术可以做到这一点，例如基于事件的、统计的、检测的和模拟的方法。我们现在将看到一种特殊的方法来利用它，而不是假装完全覆盖它。</p><h1 id="89cd" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战:变形算法</h1><p id="29af" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">让我们用一个由<a class="ae kr" href="https://projecteuler.net/problem=2" rel="noopener ugc nofollow" target="_blank">项目Euler </a>提出的问题来说明概要分析的一个可能的应用:</p><blockquote class="ks kt ku"><p id="051f" class="ip iq kq ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi translated">斐波纳契数列中的每一个新项都是通过将前两项相加而生成的。从1和2开始，前10项将是:</p><p id="3f7b" class="ip iq kq ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p id="35d8" class="ip iq kq ir b is it iu iv iw ix iy iz kv jb jc jd kw jf jg jh kx jj jk jl jm ha bi translated">考虑斐波纳契数列中数值不超过四百万的项，找出偶数项的总和</p></blockquote><p id="bcc8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好的。可以说，这种问题并不是你在日常生活中会经常发现的。但这是一个有趣的挑战，无论你是程序员(创建最有效的算法)还是测试员(设计适当的测试用例来评估算法的效率)。我们继续。</p><p id="ce38" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">斐波那契的继承具有递归性；因此，对于一个程序员来说，在第一个实例中这样做似乎是合理的。以下代码(用Python 3编写)为这个问题提供了正确的结果:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="e067" class="lh jo hs ld b fi li lj l lk ll">''' COMMENT: This function calculates the Fibonacci value for an integer number. As can be seen, if input parameter is 0, return value is 0; if input value is 1, return value is 1 (both trivial cases). For any integer greater than 1, result will be the sum of values returned by the fibonacci function called two times (recursively) using the two immediate preceding numbers '''</span><span id="f739" class="lh jo hs ld b fi lm lj l lk ll">def fibonacci(x):</span><span id="913c" class="lh jo hs ld b fi lm lj l lk ll">   if x == 0:</span><span id="c80c" class="lh jo hs ld b fi lm lj l lk ll">      return 0 --- trivial case</span><span id="2ce9" class="lh jo hs ld b fi lm lj l lk ll">   if x == 1:</span><span id="4ca2" class="lh jo hs ld b fi lm lj l lk ll">      return 1 --- trivial case</span><span id="4a05" class="lh jo hs ld b fi lm lj l lk ll">   return fibonacci(x-1) + fibonacci(x-2) --- double recursive call</span><span id="2db3" class="lh jo hs ld b fi lm lj l lk ll">''' COMMENT: This function implements a while cycle that will analyze for each integer number (starting in 1) the corresponding fibonacci value and then will check if this result is even'''</span><span id="48fa" class="lh jo hs ld b fi lm lj l lk ll">def mainFunction():</span><span id="e141" class="lh jo hs ld b fi lm lj l lk ll">    fibSum = 0</span><span id="c435" class="lh jo hs ld b fi lm lj l lk ll">    fibValue = 0</span><span id="67d2" class="lh jo hs ld b fi lm lj l lk ll">    index = 1</span><span id="4fbd" class="lh jo hs ld b fi lm lj l lk ll">    while fibValue &lt; 40000000:   ---- while cycle from 1 to 40000000</span><span id="1f21" class="lh jo hs ld b fi lm lj l lk ll">        fibValue = fibonacci(index) ---- calculate fibonacci value</span><span id="826f" class="lh jo hs ld b fi lm lj l lk ll">        if fibValue % 2 == 0:    ---- check if result value is even</span><span id="0237" class="lh jo hs ld b fi lm lj l lk ll">            fibSum += fibValue     ---- accumulate value</span><span id="cf36" class="lh jo hs ld b fi lm lj l lk ll">        index += 1</span><span id="c9da" class="lh jo hs ld b fi lm lj l lk ll">    print(fibSum)</span><span id="80c4" class="lh jo hs ld b fi lm lj l lk ll">''' COMMENT: This section calls mainFunction explained above '''</span><span id="e59b" class="lh jo hs ld b fi lm lj l lk ll">if __name__ = "__main__":</span><span id="3928" class="lh jo hs ld b fi lm lj l lk ll">    mainFunction()</span></pre><p id="1b05" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，函数“fibonacci”使用双重递归，因此要计算特定索引的Fibonacci值，需要为其两个前置值中的每一个调用相同的函数，依此类推……此外，对每个值执行“mod”操作，以计算它是否是偶数。</p><p id="66bf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了评估这个算法的性能，我们将从命令行使用名为“cProfile”的Python库对它进行分析。</p><p id="6e43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kq">$ python-m cProfile even Fibonacci . py</em></p><p id="092c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将获得这样的输出:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ln"><img src="../Images/81d6c87f647b685d06e8d278450171f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rV-MGnWpzcSPu9SqVLUhw.png"/></div></div></figure><p id="658d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们获得时间，在我的计算机(处理器2.6 GHz，16MB RAM)中是14.848秒，如cProfile生成的摘要报告所示:</p><p id="e72b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kq"> 48315601个函数调用(39个原语调用)耗时14.848秒</em></p><p id="b85b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们看看输出中的第三个条目，以获得更多的详细信息:</p><p id="ac70" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kq">n调用总时间百分比累计时间百分比文件名:行号(函数)</em></p><p id="7766" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">…</p><p id="7526" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kq">48315596/34 14.848 0.000 14.848 0.437 even Fibonacci . py:2(Fibonacci)</em></p><p id="6427" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">…</p><p id="c646" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以看出，大部分处理时间和最大数量的调用发生在递归函数“fibonacci”上，它被调用了48，000，000次！我们在斜线后面看到的数字34指的是原始调用，即那些没有被递归引入的调用。</p><h1 id="0604" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们能帮助它做得更好吗？</h1><p id="a5b4" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">剖析库向我们揭示了我们代码中的一个大弱点。因此，是时候跳出框框，寻找更有效的方法了。让我们通过仔细研究斐波那契数列的行为来更深入地分析这个问题。</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/d98d07be306941663c586aee7eb2ac6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmJ2dBApvrGcZfT5_IqdeA.png"/></div></div></figure><p id="099f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以观察到，有一种模式表明，在两个奇数(A，B)之后是一个<strong class="ir ht">偶数</strong> (C)，接下来的两个<strong class="ir ht">奇数</strong>可以通过将前面的每个奇数加到最后一个偶数上来获得，依此类推……因此，我们可以用这种非递归方式重新编写代码。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="1402" class="lh jo hs ld b fi li lj l lk ll">''' COMMENT: This reformulated function doesn't use any kind of recursion'''</span><span id="c41e" class="lh jo hs ld b fi lm lj l lk ll">def mainFunction():</span><span id="f153" class="lh jo hs ld b fi lm lj l lk ll">    limit = 40000000</span><span id="85bd" class="lh jo hs ld b fi lm lj l lk ll">    sum = 0</span><span id="a40c" class="lh jo hs ld b fi lm lj l lk ll">    a = 1</span><span id="097b" class="lh jo hs ld b fi lm lj l lk ll">    b = 1</span><span id="b31c" class="lh jo hs ld b fi lm lj l lk ll">    c = a+b</span><span id="7459" class="lh jo hs ld b fi lm lj l lk ll">    while c &lt; limit:</span><span id="761d" class="lh jo hs ld b fi lm lj l lk ll">        sum+=c         --- accumulate result</span><span id="9542" class="lh jo hs ld b fi lm lj l lk ll">        a = b+c          --- calculate first next odd</span><span id="729a" class="lh jo hs ld b fi lm lj l lk ll">        b = c+a          --- calculate second next odd</span><span id="4791" class="lh jo hs ld b fi lm lj l lk ll">        c = a+b          --- calculate the even</span><span id="00d9" class="lh jo hs ld b fi lm lj l lk ll">    print(sum)</span><span id="dc04" class="lh jo hs ld b fi lm lj l lk ll">''' COMMENT: This section calls mainFunction explained above '''</span><span id="7f1c" class="lh jo hs ld b fi lm lj l lk ll">if __name__ = "__main__":</span><span id="67e3" class="lh jo hs ld b fi lm lj l lk ll">    mainFunction()</span></pre><p id="2022" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样我们就消除了递归，除此之外，我们不再检查每个值是否都是偶数。当对这个新代码进行概要分析时，我们会得到这样的结果:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/4a30baff9b44557e385542f4292e2046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5V50QYyEvmYpgJFoxAt14g.png"/></div></div></figure><p id="f062" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，我们已经将呼叫数量从数百万减少到5个，处理时间从14秒以上减少到几乎为零。</p><h1 id="30bb" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">总结一下(但这还没有结束……)</h1><ul class=""><li id="37dc" class="lq lr hs ir b is kl iw km ja ls je lt ji lu jm lv lw lx ly bi translated">如果你是一个开发者，剖析当然可以帮助你开发更好的算法。通过对属于你的类和组件的函数进行单独的分析，你会发现你的代码中的弱点和需要改进的地方，并且会减少QA团队“开发”的数量</li><li id="6b90" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">如果您是一名功能性QA，您当然可以通过设计使用不同值的测试用例，并根据您提供的输入参数检查性能如何提高或降低，来帮助检测由低效算法产生的潜在性能问题。如果极限值不是400万而是800万，你想一想我们的例子的递归版本需要多长时间？或者更大？(*)</li><li id="ccb4" class="lq lr hs ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">如果您是一名负载和性能测试人员，前面的几点同样适用于您。这表明，很多时候性能问题并不一定与并发性和作用于应用程序的工作负载有关，而是可以通过应用单一测试来检测。根本原因并不总是与基础设施/架构相关，推荐的解决方案也不总是“更多RAM、更多处理器、更多服务器”。如果您能够利用一个好的APM，使您能够在代码级别进行概要分析，请不要犹豫使用它。</li></ul><p id="10af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(*)可怕的是，处理时间跃升至180秒，呼叫次数超过5.35亿次！</p></div></div>    
</body>
</html>