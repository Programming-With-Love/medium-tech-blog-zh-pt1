<html>
<head>
<title>Open sourcing ptracer, a syscall-tracing library for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开源ptracer，一个用于Python的系统调用跟踪库</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/open-sourcing-ptracer-a-syscall-tracing-library-for-python-b0fe0d91105d?source=collection_archive---------0-----------------------#2017-11-17">https://medium.com/pinterest-engineering/open-sourcing-ptracer-a-syscall-tracing-library-for-python-b0fe0d91105d?source=collection_archive---------0-----------------------#2017-11-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7772" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Elvis Pranskevichus，Pinterest工程师，核心体验</p><p id="099f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让Pinterest变得更快、更可靠是我们工程团队的一贯目标，更有效地利用硬件资源是这一努力的主要部分。提高效率和可靠性需要良好的诊断工具。这就是为什么今天我们要发布我们最新的跟踪工具，<a class="ae jc" href="https://github.com/pinterest/ptracer" rel="noopener ugc nofollow" target="_blank"> ptracer，</a>它在Python程序中提供细粒度的系统调用跟踪。在本帖中，我们将介绍Pinterest代码库的背景，为什么我们需要一个更好的追踪器，以及ptracer如何帮助解决某些工程问题。</p><h2 id="38c1" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">背景</h2><p id="8a28" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Pinterest由一个大型Python代码库提供支持。传统上，从CPU利用率的角度来看，运行Python服务器最有效的方法是生成多个工作进程(工作进程的数量通常接近CPU核心的总数)。多进程无共享架构安全高效，没有GIL或其他与多线程编程相关的问题。这就是为什么多进程配置是Pinterest的首选运行方式。</p><p id="460e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，使用多个进程是有代价的——增加内存使用。在大型代码库中，仅分配给Python代码对象和字符串的内存就可以达到数百兆字节，应用程序数据也需要类似的数量。几十个工作人员的总内存使用量可能会很快失控。</p><p id="ccd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值得注意的是，工人之间的大部分数据是相同的，比如Python代码对象和其他静态位。减少内存使用的解决方案是让工作进程共享这些数据。谢天谢地，有一种方法可以做到这一点。</p><p id="99e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在POSIX系统中，通过调用<a class="ae jc" href="https://en.wikipedia.org/wiki/Fork_(system_call)" rel="noopener ugc nofollow" target="_blank"> fork() </a>系统调用来创建新的进程，这将创建一个与调用进程几乎相同的副本。最重要的是，进程的内存不会立即被物理复制。相反，父进程和子进程之间共享的所有内存页面都标记有特殊的写入时复制位，该位仅在内存页面被其中一个进程修改时才触发复制。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/202a1eb0a3e36b99ef6c5cbf6f736e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l2RK_qMJyCu6vM-7L1Tcg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Figure 1. Memory sharing in forked processes</figcaption></figure><p id="36a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">工作进程以近乎完美的内存共享开始，但会逐渐偏离。</p><p id="2168" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python程序中内存差异的主要来源是引用计数。在CPython中，每个Python对象都由一个结构表示，该结构包含一个引用计数器，每当引用该对象时，该计数器就会递增。因此，在Python中，仅仅<em class="kt">访问</em>一个对象就足以触发内存页面复制。</p><p id="da1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似地，CPython垃圾收集器在每个被跟踪的Python对象中维护一个特殊的记录，并在收集运行时修改该记录。后一个问题有补救措施，Python 3.7将以<a class="ae jc" href="https://docs.python.org/3.7/library/gc.html#gc.freeze" rel="noopener ugc nofollow" target="_blank"> gc.freeze() </a>调用的形式提供标准解决方案。</p><p id="d87e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管有这些限制，大部分内存可以保持共享，从而带来显著的总体节省。</p><h2 id="5b63" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">从超级服务器到叉式服务器</h2><p id="f880" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">像supervisord这样的外部进程管理器对它所运行的程序知之甚少，它产生了几乎不共享内存的独立进程。为了利用fork()的优势，Python程序本身必须在最合适的时候调用它——就在服务器开始接受连接之前和所有共享代码和数据加载之后。</p><p id="175a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了内存，fork()创建的子进程还与其父进程和兄弟进程共享所有打开的文件描述符。文件描述符包括文件中的当前偏移量，在进程间共享它会导致交叉读写(大多数程序不会预料到这一点并会失败)。</p><p id="fd39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题通常的解决方案是在fork()在子进程中返回后，立即关闭所有文件描述符(除了stdin、stdout和stderr)。在我们的例子中，这是行不通的，因为打开该文件的代码可能依赖于它继续被打开。相反，当我们调用fork()来产生workers时，我们必须确保没有文件或套接字处于打开状态。</p><p id="e628" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">手动查找所有打开文件而不关闭它们的位置是一项令人生畏的任务。在像我们这样的大型代码库中，这是完全不可能的，尤其是考虑到我们所依赖的众多第三方模块。此外，解决这个问题一次是不够的。我们需要确保新代码不会引入回归。</p><p id="9998" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题唯一可行的解决方案是自动化检查，并将它们合并到回归测试套件中。为此，我们需要一种机制来跟踪程序并拦截所有创建新文件描述符的系统调用。</p><p id="2074" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包括Linux在内的许多系统都有<a class="ae jc" href="https://en.wikipedia.org/wiki/Ptrace" rel="noopener ugc nofollow" target="_blank"> ptrace() </a>系统调用，它允许跟踪和中断其他进程的执行。像gdb这样的调试器使用它以及古老的strace工具。但是我们不能简单地使用strace。虽然它确实报告了某个文件被打开或关闭的事实，但它没有显示出<em class="kt">在程序中的什么地方</em>发生了这种情况，这使得寻找该位置变得不必要的困难。</p><p id="3ce5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是为什么我们开发了自己的追踪器来解决这个问题。</p><h2 id="18ac" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">ptracer</h2><p id="83a7" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">ptracer是一个使Python程序中跟踪系统调用变得简单的模块。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="28fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在幕后，ptracer使用线程和子进程的组合来实现上述功能。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kw"><img src="../Images/847d094852e4490e53c5a2fbd6ee88ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HO75RSK92H5wFyR5BSfprw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Figure 2. ptracer architecture</figcaption></figure><p id="b888" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当进入ptracer上下文时，ptracer会生成一个新线程，在该线程中将执行syscall回调，此外还有另一个线程用于从给定线程中提取Python回溯。它还产生了一个执行实际跟踪的子进程。</p><p id="21c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每当跟踪子进程检测到正在进行系统调用时，它会根据指定的过滤器(如果有)检查syscall。如果系统调用与过滤器匹配，则调用回溯线程来提取调用堆栈，调用堆栈附加到syscall记录并放入队列中。为syscall队列中的每个项目调用回调。</p><h2 id="ae10" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">解决打开文件预分叉问题()</h2><p id="981c" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">使用ptracer，我们现在能够可靠地找到留下未关闭文件的代码位置。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ku kv l"/></div></figure><h2 id="e3d8" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">未来的工作</h2><p id="1af4" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">ptracer不限于跟踪与文件相关的系统调用。在Pinterest，我们使用非阻塞I/O模型，让可靠地识别阻塞调用及其延迟成为可能是我们的下一个目标。</p><p id="8702" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们欢迎任何问题、反馈和请求。对于我们所有的开源项目，请查看我们的GitHub。</p><p id="bfb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kt">鸣谢:我要感谢尤里·塞利万诺夫、乔恩·帕里斯、萨姆·梅德和乔·戈登对这个项目的帮助和反馈。</em></p></div></div>    
</body>
</html>