<html>
<head>
<title>Debug Node.js Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试Node.js依赖项</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/debug-nodejs-dependencies-51eb40f484ec?source=collection_archive---------5-----------------------#2019-02-05">https://medium.com/walmartglobaltech/debug-nodejs-dependencies-51eb40f484ec?source=collection_archive---------5-----------------------#2019-02-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4dd63ada22085f5513ae7c0a69a2cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICM4rLgFgB1-98zpPInTqg.jpeg"/></div></div></figure><p id="9d0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated"><span class="l jo jp jq bm jr js jt ju jv di">在</span> Node.js开发中，你有没有在一个已知工作的app上做了全新的<code class="du jw jx jy jz b">npm install</code>却发现它开始失败？根据我们的经验，我们偶尔会遇到这个问题。原因是由于一个常见的惯例，我们使用<code class="du jw jx jy jz b">^</code>或<code class="du jw jx jy jz b">~</code>为我们所依赖的包指定一个<a class="ae ka" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">永远</a>的范围。例如，<code class="du jw jx jy jz b">^1.0.0</code>意味着任何版本的<code class="du jw jx jy jz b">1</code>，比如<code class="du jw jx jy jz b">1.1.0</code>或<code class="du jw jx jy jz b">1.2.1</code>。</p><p id="d821" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，如果一个应用程序有一个依赖关系<code class="du jw jx jy jz b">X@^1.0.0</code>并引入当前版本<code class="du jw jx jy jz b">1.1.0</code>，但是<code class="du jw jx jy jz b">X</code>的所有者发布了一个新版本<code class="du jw jx jy jz b">1.2.0</code>，一个新的<code class="du jw jx jy jz b">npm install</code>将引入新版本。大多数情况下(比如99%)这是没问题的，但偶尔它不起作用，你的应用程序开始失败。</p><p id="599d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有时您对更新了哪些包有一个相当好的想法，并且很容易弄清楚，但是其他时候您可能甚至没有意识到您的问题是由于正在更新的下游依赖项引起的，并且您可能会挠头几个小时。虽然使用锁文件可以更好地控制这种情况，但偶尔当您更新锁时，这种情况仍然会发生。通常我们一次更新一个锁，但仍然可能导致从它的下游获得新的锁，或者有时我们可能希望对整个锁文件进行刷新。</p><p id="e6f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我支持数百名Node.js开发人员的日常工作中，我有时不得不调试这个问题。这是一个从Node.js早期就存在的常见问题。在实行依赖锁文件之前，我们习惯于依赖<code class="du jw jx jy jz b">npm-shrinkwrap.json</code>并使用精确版本，而不是<code class="du jw jx jy jz b">package.json</code>中的<a class="ae ka" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> semver </a>。</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><p id="4df9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们最近的事件是由于<code class="du jw jx jy jz b">webpack</code>从版本<code class="du jw jx jy jz b">4.28.4</code>更新到<code class="du jw jx jy jz b">4.29.0</code>。这个问题本身影响了很多人，因为<code class="du jw jx jy jz b">webpack</code>非常受欢迎，这里<a class="ae ka" href="https://github.com/webpack/webpack/issues/8656" rel="noopener ugc nofollow" target="_blank">正在讨论</a>。事实证明，这是由于npm中的一个<code class="du jw jx jy jz b"><a class="ae ka" href="https://github.com/webpack/webpack/issues/8656#issuecomment-456010969" rel="noopener ugc nofollow" target="_blank">peerDependencies</a></code> <a class="ae ka" href="https://github.com/webpack/webpack/issues/8656#issuecomment-456010969" rel="noopener ugc nofollow" target="_blank">相关bug </a>。</p><p id="c482" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在一个大型应用程序中独立遇到了这个问题。它拉进了很多发育完全的包<code class="du jw jx jy jz b">npm install</code>。当应用程序第一次开始失败时，我们不知道出了什么问题。</p><p id="7a41" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用babel和动态导入语法插件来传输我们的动态导入代码。由于我们得到了一个与动态导入相关的语法错误，我们查看了明显的疑点，如我们的babel配置和动态语法插件。经过一些健全性检查后，我们确认babel肯定仍在加载插件，所以我们很困惑，而且我们没有立即意识到原因是下游依赖，因为我们自己做了很多更改。</p><p id="86d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在查看提交历史记录后，我们发现问题发生在一个分支中，该分支的提交已知是有效的，因为它的PR是绿色的，这时我们开始意识到原因是下游包得到了更新。</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><p id="f961" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这对于我们来说并不陌生，我们有一套标准的程序来调试它。在此之前，我将介绍一下<a class="ae ka" href="https://www.npmjs.com/package/fyn" rel="noopener ugc nofollow" target="_blank"> fyn </a>，这是我编写的一个节点包管理器，它从经验和工具发展而来，有助于Node.js中的开发和调试。我将讨论<a class="ae ka" href="https://www.npmjs.com/package/fyn" rel="noopener ugc nofollow" target="_blank"> fyn </a>的一些独特特性如何帮助找出有问题的包。</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><p id="8b8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">隔离有问题的包的通常方法是首先找到哪些包已经更新。为此，我们过去依赖于<code class="du jw jx jy jz b">npm-shrinkwrap.json</code>，现在依赖于<code class="du jw jx jy jz b">package-lock.json</code>，这是定期提交的。我们会<code class="du jw jx jy jz b">npm install</code>两个不同的<code class="du jw jx jy jz b">node_modules</code>，一个有已知的工作锁，另一个没有。然后我们有定制的工具来比较两个<code class="du jw jx jy jz b">node_modules</code>中的包，并显示那些不同的包。然而，这样做的问题是，我们通常只在发布时保留锁文件，并且我们并不总是在我们想要的确切时间拥有锁文件。</p><p id="7782" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的事件中，我们知道commit在1/14通过了PR，但是锁文件更老。虽然我们可以使用那个锁文件，但是如果能够从1月14日开始减少需要更新的包的数量就更好了。这就是fyn中锁时间戳特性得以实现的原因。</p><p id="6042" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我做了没有任何锁的<code class="du jw jx jy jz b">fyn install --lock-time=1/14/2019</code>，得到了一个只发布到2019年1月14日的包的<code class="du jw jx jy jz b">node_modules</code>。接下来，我不带锁地运行<code class="du jw jx jy jz b">fyn install</code>来获取所有最新的包。现在我可以比较它们了。</p><p id="41d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不过在我继续之前，我想指出，因为在这个事件中，原因是一个npm错误，通常我们可能无法用<code class="du jw jx jy jz b">fyn</code>重现它，但巧合的是<code class="du jw jx jy jz b">fyn</code>有类似的错误行为，所以这是可能的，或者至少更容易。然而，如果原因与npm无关，那么用<code class="du jw jx jy jz b">fyn</code>调试它将是一样的。</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><p id="10b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">拿<code class="du jw jx jy jz b">node_modules</code>和fyn对比其实很简单。我们甚至不需要保存两个不同的<code class="du jw jx jy jz b">node_modules</code>副本，因为fyn的锁文件可以直接区分，得到非常可读的结果。</p><p id="8125" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的事件中，仅仅一周多一点的时间我们就得到20多个更新包。有些是我们的内部包，但大多数是公共包，不直接依赖于我们的应用程序，特别是一半是巴别塔包:</p><figure class="kj kk kl km fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ki"><img src="../Images/c81624a12925f0a2a51e963cd7509d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3Aw3FJ_78koAgbbokOZUQ.png"/></div></div></figure><p id="c54a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">灯泡在我头顶上亮了起来，我心想:“中大奖了！”。我立即更新了fyn的锁文件，将这些包设置为旧版本，并期待着好的结果，但可惜的是，结果并非如此。幸运的是，只有大约10个其他包，大多数显然是不相关的，然后我注意到webpack更新了:</p><figure class="kj kk kl km fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/dcda3d3ba9b8736348641a1701ee9596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBRh1jb9w964YbhRHRrPkQ.png"/></div></div></figure><p id="dc46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那是最有可能相关的包裹。果然，用<a class="ae ka" href="https://www.npmjs.com/package/fyn" rel="noopener ugc nofollow" target="_blank"> fyn </a>更新后，错误没了。厉害！</p></div><div class="ab cl kb kc go kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="ha hb hc hd he"><p id="ae65" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从这个问题浮出水面，webpack的作者很快就找到了原因，并且<a class="ae ka" href="https://github.com/npm/cli/pull/147" rel="noopener ugc nofollow" target="_blank">提交了一份PR在npm </a>中修复了它，这和往常一样令人印象深刻。</p><p id="991a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我写这篇文章是为了讨论Node.js中一个常见的依赖相关问题，以及我如何使用<a class="ae ka" href="https://www.npmjs.com/package/fyn" rel="noopener ugc nofollow" target="_blank"> fyn </a>来帮助我进行调试。<a class="ae ka" href="https://www.npmjs.com/package/fyn" rel="noopener ugc nofollow" target="_blank"> fyn </a>是我在编写帮助管理<code class="du jw jx jy jz b">node_modules</code>和依赖关系的工具方面的经验和各种尝试的累积结果，我最终投入了数百个小时来组装一个功能齐全的节点包管理器，以提高生产率和效率。</p><p id="28b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果这里讨论的主题对你有意义，并且你有相关的经验或者有你自己的技巧和工具可以分享，那么请留下你的评论。我很想听听你的想法。</p><p id="65be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">哦，最后一件事，我正在<a class="ko kp ge" href="https://medium.com/u/c884135151a4?source=post_page-----51eb40f484ec--------------------------------" rel="noopener" target="_blank">沃尔玛实验室</a>聘请JavaScript专家，从事Node.js/ReactJS以及任何与平台、基础设施、网络和云相关的工作。我们也做bash，如果你对TypeScript感兴趣的话，这将会非常令人兴奋。如果你感兴趣，请打电话给我。</p></div></div>    
</body>
</html>