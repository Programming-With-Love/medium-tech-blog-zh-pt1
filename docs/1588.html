<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison (Part 7): MVI Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和rx Java——异步比较(第7部分):MVI项目</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-7-mvi-project-f763fdd5070e?source=collection_archive---------4-----------------------#2018-08-02">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-7-mvi-project-f763fdd5070e?source=collection_archive---------4-----------------------#2018-08-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/328da11c1868169f4d69714b364c8094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hc4D9XS9pJYcq2_o3LYFGQ.png"/></div></div></figure><div class=""/><h1 id="4308" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="90ba" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这个博客系列中，我比较了<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>和<a class="ae kl" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，因为它们都试图解决Android开发中的一个常见问题:<strong class="jp ht">异步编程</strong>。在上一篇文章中，我们完成了这两个库与本系列前一部分的主题比较，现在是时候将我们学到的一切付诸实践了。</p><blockquote class="km"><p id="2ba9" class="kn ko hs bd kp kq kr ks kt ku kv kk dx translated">让我们用我们所学的知识建立一个MVI项目！</p></blockquote><h1 id="f180" class="ip iq hs bd ir is it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm bi translated">Android应用程序</h1><p id="4347" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在本文中，我们将构建一个Android应用程序，它将计算一个数字的斐波那契数列，并可以选择性地告诉您一个关于该数字的有趣事实。</p><p id="48d5" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">我们将使用一个名为<a class="ae kl" href="http://numbersapi.com/#42" rel="noopener ugc nofollow" target="_blank">numbersapi.com</a>的公共API发出一个网络请求来计算这个数字的有趣事实。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es le"><img src="../Images/0ecda6cd30bba72ffae9fe9d41a2dfe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x4X8UdTb4rprySVUi2_kg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">App screenshots</figcaption></figure><p id="a577" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">计算斐波那契和获取有趣的事实是两个并行运行的任务，只有当两个请求都到来时，我们才会向用户显示信息。这是为了防止用户勾选“告诉我一个有趣的事实”复选框。</p><h2 id="cfc5" class="ln iq hs bd ir lo lp lq iv lr ls lt iz jy lu lv jd kc lw lx jh kg ly lz jl ma bi translated">应用程序变体—项目</h2><p id="387e" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们有三种项目变体可用:</p><ol class=""><li id="cb54" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk mg mh mi mj bi translated">纯协程。</li><li id="eb21" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">纯RxJava。</li><li id="acb4" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">协同程序/RxJava互操作。一些部分将在RxJava中完成，并将被协程使用(也可能是其他方式)。</li></ol><div class="hg hh ez fb hi mp"><a href="https://github.com/manuelvicnt/MathCoroutines" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd ht fi z dy mu ea eb mv ed ef hr bi translated">manuelvicnt/MathCoroutines</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">这是一个带有数学例子的协同程序的例子</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ho mp"/></div></div></a></div><div class="hg hh ez fb hi mp"><a href="https://github.com/manuelvicnt/MathRxJava" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd ht fi z dy mu ea eb mv ed ef hr bi translated">manuelvicnt/MathRxJava</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">这是一个带有数学例子的RxJava的例子</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd ho mp"/></div></div></a></div><div class="hg hh ez fb hi mp"><a href="https://github.com/manuelvicnt/MathRxCoroutines" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd ht fi z dy mu ea eb mv ed ef hr bi translated">manuelvicnt/MathRxCoroutines</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">这是一个将RxJava和协同程序集成到一个数学例子中的例子</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="nf l na nb nc my nd ho mp"/></div></div></a></div><blockquote class="ng nh ni"><p id="955f" class="jn jo nj jp b jq kz js jt ju la jw jx nk lb ka kb nl lc ke kf nm ld ki kj kk ha bi translated">免责声明:这段代码可能并不完美。请注意高层次的概述，而不是您已经知道如何解决的细节:)</p></blockquote><h2 id="ccfa" class="ln iq hs bd ir lo lp lq iv lr ls lt iz jy lu lv jd kc lw lx jh kg ly lz jl ma bi translated">应用概述</h2><p id="87bf" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将使用<a class="ae kl" href="http://hannesdorfmann.com/android/model-view-intent" rel="noopener ugc nofollow" target="_blank"> MVI模式</a>和<a class="ae kl" href="https://developer.android.com/topic/libraries/architecture/" rel="noopener ugc nofollow" target="_blank">架构组件视图模型</a>。</p><ul class=""><li id="ce98" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk nn mh mi mj bi translated"><strong class="jp ht"> MVI </strong>帮助我们构建一个关注点清晰分离的应用程序，并以一种简单的方式维护其状态。</li><li id="87c9" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">我们将使用<strong class="jp ht">架构组件视图模型</strong>来管理配置更改，并能够轻松恢复状态。</li></ul><p id="4809" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">幸存的配置更改是每个Android开发者的痛点。不久前，我发现自己正在写一篇关于这个的文章。简而言之，我们希望应用程序的状态在用户旋转屏幕后继续显示。见下面截图:</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es no"><img src="../Images/30e21deb543c8f8dec545eca7ad31a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNCxkxPgnO55r9xciaVjkw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">The app can restore state after a configuration change</figcaption></figure><h1 id="1dd4" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">MVI建筑</h1><p id="c8d5" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将遵循MVI模式如下:</p><p id="1b2f" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">用户将与应用程序进行交互。视图将对其做出反应，并通过UserAction将用户输入传递给视图模型。ViewModel将处理该动作，并通过ViewState与视图进行通信。然后，视图将呈现新的状态，用户将看到它。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es np"><img src="../Images/5c78dc8b51ca2643b27d5ae51fd496e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U21B60RVEqbggYEXbrk__w.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">App MVI Architecture</figcaption></figure><p id="4641" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">如您所见，这里发生了两次通信:</p><ol class=""><li id="fb3f" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk mg mh mi mj bi translated"><strong class="jp ht">视图- &gt;视图模型</strong>带用户动作。ViewModel需要监听视图事件，并能够对它们做出反应。</li><li id="95d1" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ht"> ViewModel - &gt;用ViewState查看</strong>。视图需要监听ViewModel事件，并能够对它们做出反应。</li></ol><p id="cddd" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">我们需要两个实体/对象来管理这种通信。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nq"><img src="../Images/8c4614dc77e8c02236c1a81f90d3c2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgfv51DkoXuG_gNQAVoENg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">MVI Architecture communication points</figcaption></figure><h1 id="02aa" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">RxJava中的MVI</h1><p id="7008" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们想到的第一件事可能是使用主题。为什么是主题？我们想要一个即使没有观察者监听事件也能存活的<strong class="jp ht">热可观察物</strong>，并且能够向多个观察者广播这些事件。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nr"><img src="../Images/0177b53339ef8884208133ffc6c4a4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U92CHFIcvg2Tcotar7YLDQ.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">We can use Subjects for the View &lt;-&gt; ViewModel communication</figcaption></figure><p id="cadf" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">视图模型可以有一个<code class="du ns nt nu nv b">userActionSubject</code>和一个<code class="du ns nt nu nv b">viewStateSubject</code>。</p><ol class=""><li id="17f5" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk mg mh mi mj bi translated">视图调用<code class="du ns nt nu nv b">userActionSubject</code>上的<code class="du ns nt nu nv b">onNext</code>向视图模型发送事件。ViewModel在初始化时订阅它。这个主题可以是<code class="du ns nt nu nv b">PublishSubject</code>类型。</li><li id="5a27" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">ViewModel调用<code class="du ns nt nu nv b">userStateSubject</code>上的<code class="du ns nt nu nv b">onNext</code>向视图发送事件。每当它对用户可见时，视图就订阅它(我们可以在<code class="du ns nt nu nv b">onStart</code>中注册)。<strong class="jp ht">这个主体应该是</strong>类型的<code class="du ns nt nu nv b"><strong class="jp ht">BehaviorSubject</strong></code>。我们需要一个<code class="du ns nt nu nv b">BehaviorSubject</code>，因为我们希望视图在配置更改后自动接收ViewModel发送的最新视图状态。当这种情况发生时，视图将再次订阅同一个主题，主题将发出它发送的最后一个状态。这样，视图就可以恢复它原来的视图状态。</li></ol><p id="2b7f" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">处理UserAction的所有逻辑都发生在对<code class="du ns nt nu nv b">userActionSubject</code>的订阅中。在代码内部，视图模型将调用<code class="du ns nt nu nv b">userStateSubject</code>上的<code class="du ns nt nu nv b">onNext</code>来与视图通信。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nw"><img src="../Images/c70561d318cb60a1b23cb9abb29b9f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSXdZ0glsYNxX2BOO06XOw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">RxJava ViewModel part of the implementation</figcaption></figure><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nx"><img src="../Images/ba6d7406f4f755df42b3b48cd3ef7351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfgjNC0SxsMOBvVvQtHVAw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">RxJava View part of the implementation</figcaption></figure><p id="76bb" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">如果你意识到在之前的图像中我们说过一个主题不是最佳的。让我澄清这一点。ViewModel创建了一个Subject，但是它不应该将它公开为Subject对象。</p><ol class=""><li id="a783" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk mg mh mi mj bi translated">在第一个场景中，视图不应该能够调用<code class="du ns nt nu nv b">onComplete</code>。如果发生了这种情况，这个主题就没用了，之后就不会再有交流了。我们可以使用Jake Wharton的RxRelay库和PublishRelay库。</li><li id="99bf" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在这种情况下，视图不需要向ViewModel发送事件，它只需要向Subject注册。我们可以<strong class="jp ht">公开一个可观察的</strong>并保护视图模型，而不是公开一个主题。</li></ol><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oa"><img src="../Images/662e92ae78deeff8cdc01ad7a534f4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlbrBZQ4eQKxkJowni8Umg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Better implementations of the RxJava MVI Architecture</figcaption></figure><h2 id="af12" class="ln iq hs bd ir lo lp lq iv lr ls lt iz jy lu lv jd kc lw lx jh kg ly lz jl ma bi translated"><strong class="ak">小心… </strong></h2><ul class=""><li id="08dd" class="mb mc hs jp b jq jr ju jv jy ob kc oc kg od kk nn mh mi mj bi translated">ViewModel订阅了<code class="du ns nt nu nv b">Schedulers.computation()</code>上的<code class="du ns nt nu nv b">userActionSubject</code>，我们需要在后台进行处理。</li><li id="cb22" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">ViewModel清理ViewModel库提供的<code class="du ns nt nu nv b">onCleared</code>方法中的主题。</li><li id="a9ba" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">视图观察<code class="du ns nt nu nv b">AndroidSchedulers.mainThread()</code>日的<code class="du ns nt nu nv b">viewStateSubject</code>事件。</li><li id="0d3b" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">视图开始在<code class="du ns nt nu nv b">onStart</code>中监听<code class="du ns nt nu nv b">viewStateSubject</code>，并在<code class="du ns nt nu nv b">onStop</code>中处理订阅。</li></ul><h1 id="0c3c" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">穿着花冠的MVI</h1><p id="9968" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们现在需要用协程实现我们在RxJava中编程的相同行为。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oe"><img src="../Images/5eaf796b2c169a158fe1e4974dce9d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9qvd2bxCdIUITCblYbPog.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">We can use Actors and Channels for the View &lt;-&gt; ViewModel communication</figcaption></figure><p id="4245" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">如果我们使用主题来实现RxJava，<strong class="jp ht">我们可以使用通道来实现协程一</strong>。在本系列的第三部分中，我们看到它们在功能上是相似的。</p><ol class=""><li id="2f6a" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk mg mh mi mj bi translated">对于View -&gt; ViewModel通信，我们可以使用<code class="du ns nt nu nv b"><strong class="jp ht">Actor</strong></code>。显然，我们希望在后台处理用户操作，所以我们需要一个协程。对于这个用例，ViewModel不需要在这个通道中发回任何东西；它将只监听视图发送的事件。出于所有这些原因，Actor是理想的候选:协程+只能接收事件的通道。参与者将在后台一次处理一个用户操作。</li><li id="27eb" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">对于ViewModel -&gt;视图通信，ViewModel创建一个<code class="du ns nt nu nv b"><strong class="jp ht">ConflatedBroadcastChannel</strong></code>。如果我们在RxJava中使用<code class="du ns nt nu nv b">BehaviorSubject</code>来回复新订阅事件，那么我们在协程中使用了<code class="du ns nt nu nv b">ConflatedBroadcastChannel</code>。完全出于同样的原因，所以我们可以在配置更改后生存下来，并且可以恢复状态。</li></ol><p id="1d1e" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">Actor中的挂起代码将处理用户操作，并将事件发送给<code class="du ns nt nu nv b">ConflatedBroadcastChannel</code>。</p><h2 id="5885" class="ln iq hs bd ir lo lp lq iv lr ls lt iz jy lu lv jd kc lw lx jh kg ly lz jl ma bi translated">当心…</h2><ul class=""><li id="64e7" class="mb mc hs jp b jq jr ju jv jy ob kc oc kg od kk nn mh mi mj bi translated">ViewModel在公共池上运行Actor。</li><li id="cd34" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">ViewModel关闭<code class="du ns nt nu nv b">onCleared</code> ViewModel方法中的<code class="du ns nt nu nv b">viewStateChannel</code>和<code class="du ns nt nu nv b">userActionActor</code>。</li><li id="cf3e" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">视图使用<code class="du ns nt nu nv b">launch(parentJob + CommonPool)</code>创建一个新的协同程序，开始监听带有<code class="du ns nt nu nv b">consumeEach</code>扩展函数的<code class="du ns nt nu nv b">viewStateChannel</code>。在这段代码中，我们调用了<code class="du ns nt nu nv b">withContext(UI)</code>,以便在Android UI主线程上处理事件。</li><li id="d328" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">视图开始监听<code class="du ns nt nu nv b">onStart</code>方法中的ViewModel事件，并取消<code class="du ns nt nu nv b">onStop</code>中协程的作业。</li></ul><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es of"><img src="../Images/448562084fc24c4833973ac43371e0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cV_VnPppAby6FKdL_qMiuA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Coroutines Actor implementation</figcaption></figure><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es og"><img src="../Images/95f2ce024bb80c41a5d1015bd69ce132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yb6zB79xIlG12nfjVX-jxA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx">Coroutines listenViewModel View implementation</figcaption></figure><h1 id="e3e6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="2421" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是关于如何使用RxJava和协程实现MVI项目的高级概述。我们没有时间讨论项目中的其他一些概念，但我认为值得一提的是:</p><ul class=""><li id="3bac" class="mb mc hs jp b jq kz ju la jy md kc me kg mf kk nn mh mi mj bi translated">协同程序项目中的Zip操作符实现。</li><li id="f914" class="mb mc hs jp b jq mk ju ml jy mm kc mn kg mo kk nn mh mi mj bi translated">互操作项目中协同例程和RxJava之间的互操作。</li></ul><p id="4f09" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">感谢阅读，</p><p id="d2eb" class="pw-post-body-paragraph jn jo hs jp b jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg ld ki kj kk ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>