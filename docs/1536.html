<html>
<head>
<title>Dagger &amp; Android Thoughts: Dependency Injection in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dagger和Android思想:Android中的依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/dagger-android-thoughts-dependency-injection-in-android-d50e799affe3?source=collection_archive---------0-----------------------#2018-03-28">https://medium.com/capital-one-tech/dagger-android-thoughts-dependency-injection-in-android-d50e799affe3?source=collection_archive---------0-----------------------#2018-03-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/28681e9815cf7fa717729f9abfd91b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-I_37Tok_vAw_a0EDGhHQ.png"/></div></div></figure><div class=""/><p id="ec12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我一直在研究关于<a class="ae jn" href="https://google.github.io/dagger/android" rel="noopener ugc nofollow" target="_blank"> Dagger &amp; Android </a>的问题，看看我是否应该开始在我的项目中使用它。但是在我开始之前，这里有一些关于这篇文章的背景。</p><p id="f569" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> <em class="jo">编辑4/2/18 </em> </strong>:本文专门谈<code class="du jp jq jr js b">dagger.android</code> <a class="ae jn" href="https://google.github.io/dagger/api/2.14/dagger/android/package-summary.html" rel="noopener ugc nofollow" target="_blank">包</a>，而不是把匕首笼统地说成安卓的阿迪解决方案。</p><p id="d242" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> <em class="jo">编辑8/8/18 </em> </strong>:社区的想法不多，目前正在调查中。我将很快更新更多的信息。毕竟，有可能让Dagger Android与多个组件层一起工作。</p><h1 id="82f0" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">这篇文章是写给谁的？</h1><ul class=""><li id="ee75" class="kr ks hs ir b is kt iw ku ja kv je kw ji kx jm ky kz la lb bi translated">你知道Android中的<a class="ae jn" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。</li><li id="bb9d" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">你知道如何使用匕首2。</li><li id="bdf9" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">你听说过<a class="ae jn" href="https://google.github.io/dagger/android" rel="noopener ugc nofollow" target="_blank"> Dagger &amp; Android </a>但是不确定你是否应该使用它，它的好处是什么。</li></ul><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3f5276828165f5d13e4c2e79dbd2d6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMiRgJ9gFu00nAonlRqibQ.png"/></div></div></figure><h1 id="4e5e" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Dagger和Android的优势</h1><p id="ba21" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated"><em class="jo">来自Dagger文档</em> —许多Android框架类都是由操作系统自己实例化的，比如Activity和Fragment。您必须在生命周期方法中执行成员注入，这会导致一些问题:</p><ul class=""><li id="5e5d" class="kr ks hs ir b is it iw ix ja lo je lp ji lq jm ky kz la lb bi translated">复制粘贴代码使得以后很难重构。</li><li id="cbf0" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">它要求请求注入的类型知道它的注入器。</li></ul><blockquote class="lr ls lt"><p id="ce2e" class="ip iq jo ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">Dagger Android Injections提供了一种在Android中使用Dagger简化依赖注入的方法</p></blockquote><h1 id="8b17" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">放弃</h1><p id="b333" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">这篇文章是基于我对<a class="ae jn" href="https://github.com/google/dagger/releases/tag/2.15" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">匕首&amp;安卓v2.15 </strong> </a>如何工作的理解。</p><p id="9cca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Dagger Github上有一个公开的问题来澄清这一点。我期待着从Google或Dagger那里得到消息，在未来的版本中包含这个功能。</p><div class="hg hh ez fb hi lx"><a href="https://github.com/google/dagger/issues/1087" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd ht fi z dy mc ea eb md ed ef hr bi translated">匕首安卓多层次(子)组件问题#1087谷歌/匕首</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">我想知道使用Dagger Android是否可能有不同级别的组件或子组件。想法是…</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ho lx"/></div></div></a></div><h1 id="f5f4" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我应该什么时候使用它？</h1><p id="16e9" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">从我的角度来看，对于小型项目来说，这是一个非常好的解决方案，但是由于一些原因，我认为它在大型应用程序中不能很好地扩展。</p><h2 id="209d" class="mm ju hs bd jv mn mo mp jz mq mr ms kd ja mt mu kh je mv mw kl ji mx my kp mz bi translated">大型应用程序的潜在缺点</h2><ul class=""><li id="5c69" class="kr ks hs ir b is kt iw ku ja kv je kw ji kx jm ky kz la lb bi translated">所有子组件都从ApplicationComponent扩展而来。</li><li id="a80b" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">由于上述原因，所有的组件都需要声明它们使用的模块，而不能正确地将它们提取出来并模块化。只有一个抽象层次。</li><li id="c1f9" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">任何使用DI的Android类都需要在ApplicationComponent中声明。</li><li id="e77c" class="kr ks hs ir b is lc iw ld ja le je lf ji lg jm ky kz la lb bi translated">测试需要用测试实例复制整个结构，这意味着对模拟没有太多的控制。</li></ul><blockquote class="lr ls lt"><p id="fdee" class="ip iq jo ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">在我看来，所有这些都是一个大型应用程序中的危险信号。一个大的应用程序应该以一种更加可组合的方式构建，能够将公共逻辑提取到可重用的组件中。</p></blockquote><figure class="lh li lj lk fd hj er es paragraph-image"><div class="er es na"><img src="../Images/cca27e5c46303624606756c68d5cabf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*OBIsXKwr5H4maOR9tqhMbQ.png"/></div></figure><p id="0f83" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">如果以上几点对你的用例很重要，Dagger &amp; Android可能不适合你。</strong></p><p id="e7f1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> <em class="jo">然而，匕首&amp;安卓也有用武之地。</em> </strong></p><h1 id="9e92" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">常见用例</h1><p id="6c3f" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">如果你使用Dagger &amp; Android，只有一个功能和两个屏幕的图形会是什么样子？</p><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/a139e6f6327224492304ab83eea9e0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPPWuwwn1i9tTHhKHykETA.png"/></div></div><figcaption class="nc nd et er es ne nf bd b be z dx">Dagger &amp; Android Graph</figcaption></figure><blockquote class="lr ls lt"><p id="1002" class="ip iq jo ir b is it iu iv iw ix iy iz lu jb jc jd lv jf jg jh lw jj jk jl jm ha bi translated">Dagger &amp; Android不允许你拥有公共(子)组件，这使得构建和重用代码更加困难。</p></blockquote><p id="2fc2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那张图表不成比例。你能想象它有八个功能，每个功能有三个屏幕吗？</p><p id="940d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我更希望有一个基于Dagger的定制解决方案，具有更好的、更少出错的结构，允许我们尽可能多地重用代码。像这样的东西呢？</p><figure class="lh li lj lk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ng"><img src="../Images/3029f8a386479f45111d8617d1e6eaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYuZg2uTfYHbDTEoTNNrrw.png"/></div></div><figcaption class="nc nd et er es ne nf bd b be z dx">Custom solution Graph</figcaption></figure><h1 id="6ff1" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Dagger &amp; Android生成的代码</h1><p id="b003" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">让我们来看看Dagger &amp; Android在引擎盖下是如何工作的。要注入一个活动，你唯一要做的就是:</p><pre class="lh li lj lk fd nh js ni nj aw nk bi"><span id="3f9c" class="mm ju hs js b fi nl nm l nn no"><strong class="js ht">AndroidInjection.inject(this)</strong></span></pre><h2 id="4b27" class="mm ju hs bd jv mn mo mp jz mq mr ms kd ja mt mu kh je mv mw kl ji mx my kp mz bi translated">1.什么是男性注射？</h2><pre class="lh li lj lk fd nh js ni nj aw nk bi"><span id="b795" class="mm ju hs js b fi nl nm l nn no">public static void inject(Activity activity) {<br/>  <em class="jo">checkNotNull</em>(activity, "activity");<br/>  Application application = activity.getApplication();</span><span id="92e6" class="mm ju hs js b fi np nm l nn no"><strong class="js ht">// GET THE APPLICATION OBJECT. IF IT IS NOT INSTANCE OF <br/>// HASACTIVITYINJECTOR THEN THROW AN ERROR</strong><br/>  if (!(application instanceof HasActivityInjector)) {<br/>    throw new RuntimeException(<br/>        String.<em class="jo">format</em>(<br/>            "%s does not implement %s",<br/>            application.getClass().getCanonicalName(),<br/>            HasActivityInjector.class.getCanonicalName()));<br/>  }</span><span id="1851" class="mm ju hs js b fi np nm l nn no"><strong class="js ht">// GET THE ANDROID INJECTOR THAT ATTACHES SUBCOMPONENT AND ACTIVITY</strong><br/>  AndroidInjector&lt;Activity&gt; activityInjector =<br/>      ((HasActivityInjector) application).activityInjector();<br/>  <em class="jo">checkNotNull</em>(activityInjector, "%s.activityInjector() returned null", application.getClass());</span><span id="291f" class="mm ju hs js b fi np nm l nn no"><strong class="js ht">// INJECT IT</strong><br/>  activityInjector.inject(activity);<br/>}</span></pre><h2 id="0958" class="mm ju hs bd jv mn mo mp jz mq mr ms kd ja mt mu kh je mv mw kl ji mx my kp mz bi translated">2.它如何知道使用哪个子组件构建器？</h2><p id="df16" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">当您在附加到ApplicationComponent的模块中将活动与其生成器进行映射时，代码如下:</p><pre class="lh li lj lk fd nh js ni nj aw nk bi"><span id="3d87" class="mm ju hs js b fi nl nm l nn no"><strong class="js ht">@Module</strong><br/>abstract class ActivityBuilder {<br/><br/>    @Binds<br/>    @IntoMap<br/><strong class="js ht">    @ActivityKey(MainActivity::class)<br/></strong>    abstract fun <strong class="js ht">bindMainActivity(builder:MainSubcomponent.Builder)</strong>:<br/>            AndroidInjector.Factory&lt;out Activity&gt;<br/><br/>}</span></pre><p id="030d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在您生成的<strong class="ir ht"><em class="jo">DaggerApplicationComponent.java</em></strong>类中，它将活动与您之前定义的构建器的实例绑定在一起。</p><pre class="lh li lj lk fd nh js ni nj aw nk bi"><span id="ac4a" class="mm ju hs js b fi nl nm l nn no">private Map&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;<br/>    getMapOfClassOfAndProviderOfFactoryOf() {<br/>  return MapBuilder<br/>      .&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;<br/>          <em class="jo">newMapBuilder</em>(1)<br/><strong class="js ht">      .put(MainActivity.class, (Provider) mainSubcomponentBuilderProvider)<br/></strong>      .build();<br/>}</span></pre><h2 id="f7ec" class="mm ju hs bd jv mn mo mp jz mq mr ms kd ja mt mu kh je mv mw kl ji mx my kp mz bi translated">3.将构建器注入到班级中</h2><p id="b653" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">当您调用<em class="jo"> inject </em>时，它将调用第二步中定义的构建器实现实例上的inject方法。</p><h1 id="d3a6" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="d561" class="pw-post-body-paragraph ip iq hs ir b is kt iu iv iw ku iy iz ja ll jc jd je lm jg jh ji ln jk jl jm ha bi translated">再次重申上面提到的观点:这篇文章是基于我的研究、阅读和实验。</p><p id="22dc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在决定Dagger &amp; Android是否适合你的项目之前，我建议你自己做一些研究。</p></div><div class="ab cl nq nr go ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ha hb hc hd he"><p id="a10f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你想知道更多关于匕首的事吗？看看这篇关于Android 中<strong class="ir ht">幸存配置变化的文章。</strong></p><div class="hg hh ez fb hi lx"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/surviving-configuration-changes-using-dagger-b08042f67092"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd ht fi z dy mc ea eb md ed ef hr bi translated">使用Dagger幸存的配置更改</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">自己动手！</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">medium.com</p></div></div><div class="mg l"><div class="nx l mi mj mk mg ml ho lx"/></div></div></a></div><p id="fc04" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢阅读，</p><p id="315c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>