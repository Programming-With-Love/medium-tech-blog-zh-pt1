# 具有 12 因素应用和微服务架构的容器就绪型应用

> 原文：<https://medium.com/capital-one-tech/container-ready-applications-with-twelve-factor-app-and-microservices-architecture-16af683a767f?source=collection_archive---------1----------------------->

![](img/215a6c59a2780ff4aa5a33294569edd7.png)

# 您的应用程序容器准备好了吗？(TL；博士)

在过去的几个月里，我已经帮助了几个团队迁移到容器，并且对容器应用程序就绪意味着什么有了一些了解。当应用程序使用微服务架构和十二因素应用程序方法构建时，容器应用程序就绪性变得更加容易，即使这意味着重构。

# 原生容器—从最终目标开始

对于应用程序，Salil Deshpande 已经将 Container Native 定义为:

*1。将容器视为基础设施的一级单元的软件(例如，与将物理机或虚拟机视为一级单元相对)。*

*2。不只是在容器中、容器上或容器周围“碰巧工作”的软件，而是专门为容器设计的软件*

对我来说， ***有目的地为容器设计*** 意味着从应用需求和设计的开始，到实现和交付，容器是应用计算的原子单元。简而言之，工程师从一开始就知道应用程序将(1)作为容器运行,( 2)在容器编排层(AWS ECS/Fargate、Kubernetes 等)中运行。).这就引出了一个问题，*“我们如何设计在容器和容器编排层中运行的应用程序？”*

# 单片与微服务

我们都听说过[微服务架构](https://www.amazon.com/Microservice-Architecture-Aligning-Principles-Practices/dp/1491956259)(或者至少我们现在应该听说过)，以及它是一种比单栈整体方法更好的应用设计方法。

回顾一下，应用程序是分层构建的。在典型应用中，这些层是:

*   **展示** —负责处理请求和响应
*   **业务逻辑** —负责执行应用程序的工作流和业务逻辑
*   **数据访问** —负责从/向数据存储读取/写入数据
*   **应用集成** —负责与其他后台服务的集成

# 巨石

在整体架构中，应用程序被部署为包含所有层的单个包或二进制文件。这乍一看似乎很简单，尤其是对于测试和部署。然而，单片可能非常大和复杂，这可能导致部署和性能问题。变革也很难整体管理；不管哪一层需要改变，整个整体都需要接触、重新部署和测试。这引入了更大的回归边界和爆炸半径。单片设计也阻止了[步伐分层应用策略。](https://www.gartner.com/binaries/content/assets/events/keywords/applications/apn30/pace-layered-applications-research-report.pdf)

> **注意:**当单片应用程序层被分成多个包或二进制文件时，半单片体系结构就存在了，但并不是完全使用微服务体系结构构建的。

试图将一个整体容器化通常是困难的，并且常常导致更大的复杂性。一般来说，容器应该用来简化开发人员的生活。增加复杂性是违反直觉的；在许多情况下，必须对 monoliths 进行重构，以充分利用容器化。

# 微服务

微服务架构(MSA)是首选，而不是单片。在 MSA 中，单一的应用程序被转换成互连服务的较小应用程序。MSA 有很多好处，但我最喜欢的是:

*   MSA 将应用程序分解成一组可管理的服务，这些服务的开发速度更快，也更容易理解和维护。
*   MSA 使每个服务能够由专注于该服务的团队独立开发。
*   MSA 通过应用步伐分层策略促进新技术的采用。
*   MSA 松散地耦合服务。
*   MSA 致力于促进松散耦合和水平可伸缩性的数据隔离。

当考虑将容器作为应用程序的计算单元时，坚持原子服务并保持部署工件(映像和容器)较小是有意义的。拥抱 MSA 帮助你到达那里。

# 十二因素应用程序方法

[十二要素应用程序方法](https://12factor.net/)用于产生软件即服务(SaaS)，这是在大多数现代应用程序中使用的开发方法。它是由 Adam Wiggins 和 Heroku 的开发团队设计的。十二因素 App 的重要特征是:

*   为安装自动化使用声明式格式，以最小化新开发人员加入项目的时间和成本。
*   与底层操作系统签订清晰的合同，在执行环境之间提供最大的可移植性。
*   适合在现代云平台上部署，无需服务器和系统管理。
*   最大限度地减少开发和生产之间的差异，实现持续部署以获得最大的灵活性。
*   能够在不对工具、架构或开发实践进行重大更改的情况下进行扩展。

# 分解因素

虽然所有十二个因素都很重要，但在我看来，有些因素对容器和微服务来说比其他因素更重要。

## **依赖关系**

根据*依赖*因素，应用*“显式声明并隔离依赖关系”*，不依赖*“隐式存在系统级包”*。不依赖系统工具或包使应用程序能够实现松耦合，这是 MSA 所期望的。此外，声明和隔离依赖关系有助于*并发*因素实现水平分区和可伸缩性。

## 配置

*Config* 因子支持使用环境变量来代替配置文件或代码常量用于配置数据和凭证。这也有助于避免基于环境对环境变量进行分组的不良做法。将 config 存储在环境中允许环境变量充当"*粒度控制"*"，彼此独立。这些控制允许 CI/CD 管道的最后一英里在部署和运行时更精细地控制应用程序配置。容器运行时和编排层提供了在实例化容器时注入这些环境变量的机制。总体效果是去中心化和去耦合配置。

## 日志

根据*日志*因子*“一个 12 因子的应用从不关心它输出流的路由或存储。”*对于容器化的应用程序，这意味着应用程序记录到 *stdout* 。这样做允许应用程序部署在多个编排层中，而不必在每个环境中构建特殊的日志记录。相反，这些应用依赖于统一的日志和数据收集层实现，如内置于底层编排层的 [FluentD](https://www.fluentd.org/) 。重用编排层提供的免费服务(如日志记录)是一种成功的容器化模式，它消除了团队重复这些常见任务的需要。

> Kevin Hoffman 在他的书《超越 12 因素应用程序的*中提供了关于最初的 12 因素的更多细节，推动了一个共同的理解，我们作为一个从业者社区可以分享以消除混乱并更清楚地交流。然后，他引入了额外的因素"*，这些因素应该是任何将在云中运行的应用程序都要考虑的。

# 互补方法

在不深入研究 MSA 和十二因素 App 方法论的情况下，重要的是要认识到 MSA 和十二因素 App 是互补的。例如，*数据隔离*，作为 MSA 的一部分，促进了松散耦合和水平可伸缩性。这种弹性(快速启动和平稳关闭)是十二因素应用程序可处置性因素导致应用程序健壮性的一部分。

MSA 规定了如何设计具有互连服务的应用程序，防止可部署单元和回归边界变得过大，并允许步伐分层。十二因素 App 方法规定了消除[无差别的繁重工作](https://www.cio.co.nz/article/466635/amazon_cto_stop_spending_money_undifferentiated_heavy_lifting_/)所需的原子应用单元(或服务)的特征。这使得应用程序可以利用部署环境提供的服务，比如像 Kubernetes 这样的容器编排层。

# 集装箱准备就绪

容器就绪的应用程序占用空间小，并利用编排层提供的免费服务，如日志记录、联合安全性和指标收集。它们是原子的和健壮的计算单元，可以根据弹性进行划分。无论应用程序从一开始就被设计为容器原生的，还是被重构为容器就绪的，采用 MSA 和十二因素应用程序方法都可以部署到现代容器编排层中。

# 相关:

*   [征服库伯涅特斯](/capital-one-tech/conquering-statefulness-on-kubernetes-26336d5f4f17)
*   [为动态应用程序使用 Kubernetes ConfigMap 资源](/capital-one-tech/using-kubernetes-configmap-resources-for-dynamic-apps-9e23ef589121)
*   [使用 Terraform 部署多个环境](/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622)
*   [策略通过开放策略代理启用 Kubernetes】](/capital-one-tech/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203)

*披露声明:这些观点是作者的观点。除非本帖中另有说明，否则 Capital One 不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为 2018 首都一。*