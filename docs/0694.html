<html>
<head>
<title>All about Preferences DataStore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于首选项数据存储的所有信息</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/all-about-preferences-datastore-cc7995679334?source=collection_archive---------0-----------------------#2022-01-24">https://medium.com/androiddevelopers/all-about-preferences-datastore-cc7995679334?source=collection_archive---------0-----------------------#2022-01-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b6b4fbababc3e21bb09fb33126f1ce92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtNu7pmbt3WEA213SW9p9Q.png"/></div></div></figure><div class=""/><p id="e5e4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将看看<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-preferences" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">偏好数据存储</strong> </a>，两个<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore" rel="noopener ugc nofollow" target="_blank">数据存储</a>实现之一。我们将讨论如何<strong class="ir ht">创建它，读取和写入数据，以及如何处理异常</strong>，希望所有这些都能为您提供足够的信息来决定它是否是您应用程序的正确选择。</p><p id="ba8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Preferences DataStore使用<strong class="ir ht">键值对</strong>来存储较小的数据集，而无需预先定义模式。这可能会让你想起<code class="du jo jp jq jr b">SharedPreferences</code>，但只是在它构建你的数据模型的方式上。数据存储相对于其前身有多种优势。请随意快速跳回我们之前的<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"><strong class="ir ht"/></a><strong class="ir ht"/>，看看我们在那里做的详细对比。接下来，除非另有说明，我们将把<code class="du jo jp jq jr b">Preferences DataStore</code>简称为<code class="du jo jp jq jr b">Preferences</code>。</p><p id="702b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快速回顾一下:</p><ul class=""><li id="f312" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated">提供一个完全异步的API来检索和保存数据，使用Kotlin协同程序的能力</li><li id="86b9" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><strong class="ir ht">不提供现成的同步支持</strong>——它直接避免做任何阻塞UI线程的工作</li><li id="353c" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">依赖于Flow的内部错误信号机制，允许您在读取或写入数据时安全地捕获和处理异常</li><li id="7373" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">在<strong class="ir ht">原子读-修改-写</strong>操作中以事务方式处理数据更新，提供强大的<a class="ae jn" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>保证</li><li id="cd53" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">支持<strong class="ir ht">简单快速的数据迁移</strong></li><li id="0094" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">希望<strong class="ir ht">在<strong class="ir ht">改动最小</strong>的情况下将</strong>从<code class="du jo jp jq jr b">SharedPreferences</code>快速迁移，并且在没有全类型安全的情况下也有足够的自信？选择<strong class="ir ht">首选项</strong>而不是Proto</li></ul><p id="57f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们深入一些代码，了解应该如何实现首选项。</p><p id="1ddf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用<a class="ae jn" href="https://github.com/googlecodelabs/android-datastore/tree/preferences_datastore" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Preferences DataStore</strong></a>codelab代码。如果您对更具实践性的实现方法感兴趣，我们真的鼓励您自己完成<a class="ae jn" href="https://developer.android.com/codelabs/android-preferences-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">使用首选项数据存储库</strong> </a> codelab。</p><p id="d238" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个示例应用程序显示了一个任务列表，用户可以选择按照任务的完成状态进行过滤，或者按照优先级和截止日期进行排序。我们希望存储他们的选择——一个用于已完成任务的<strong class="ir ht">布尔值</strong>和一个用于数据存储的<strong class="ir ht">排序顺序枚举</strong>。</p><h1 id="449b" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">相关性设置</h1><p id="8b0c" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">让我们从添加必要的依赖项开始:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b213" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">💡</strong>快速提示——如果您想缩小您的构建，请确保向您的<code class="du jo jp jq jr b">proguard-rules.pro</code>文件添加一个额外的规则，以防止您的字段被删除:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="cf37" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">创建首选项数据存储</h1><p id="d62f" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">您通过一个<code class="du jo jp jq jr b">DataStore&lt;Preferences&gt;</code>实例与保存在数据存储中的数据进行交互。<code class="du jo jp jq jr b">DataStore</code>是一个允许访问持久化信息的接口。<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/preferences/core/Preferences" rel="noopener ugc nofollow" target="_blank"> Preferences </a>是一个类似于通用映射的抽象类，专门用于数据存储的Preferences实现，以跟踪数据的键值对。我们在讨论写数据的时候会谈到它的<code class="du jo jp jq jr b">MutablePreferences</code>子类。</p><p id="f234" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要创建这个实例，建议使用委托<code class="du jo jp jq jr b">preferencesDataStore</code>并传递一个强制的<code class="du jo jp jq jr b">name</code>参数。这个委托是一个<a class="ae jn" href="https://kotlinlang.org/docs/extensions.html#extension-properties" rel="noopener ugc nofollow" target="_blank"> Kotlin扩展属性</a>，它的接收方类型必须是<code class="du jo jp jq jr b">Context</code>的一个实例，随后需要构造<code class="du jo jp jq jr b">File</code>对象，数据存储在这里存储数据:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5f5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您不应该为一个给定的文件创建多个数据存储实例，<strong class="ir ht">因为这样做会破坏所有的数据存储功能。</strong>因此，您可以在Kotlin文件的顶层添加一次委托构造，并在整个应用程序中使用它，以便将其作为<strong class="ir ht"> singleton </strong>传递。在后面的文章中，我们将看到如何通过依赖注入来实现这一点。</p><h2 id="cbd7" class="lp kh hs bd ki lq lr ls km lt lu lv kq ja lw lx ku je ly lz ky ji ma mb lc mc bi translated">定义键</h2><p id="f512" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">DataStore为不同的数据类型提供了一种快速构造键的方法，比如<code class="du jo jp jq jr b">booleanPreferencesKey</code>、<code class="du jo jp jq jr b">intPreferencesKey</code>等等——您只需要将<strong class="ir ht">键名</strong>作为值传递。虽然这确实对数据类型施加了一些约束，但是请记住<strong class="ir ht">它并没有提供明确的类型安全</strong>。通过指定某种类型的首选项，我们希望得到最好的结果，并依赖于我们的假设，即<strong class="ir ht">某种类型的值将被返回</strong>。如果你觉得你的代码在某种程度上可以安全地处理这个问题，请放心地继续使用Preferences。如果没有，可以考虑使用Preferences的兄弟，<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-typed" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto DataStore</strong></a>，因为它提供了<strong class="ir ht">全类型安全</strong>。</p><p id="f83a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们应用程序的<code class="du jo jp jq jr b"><a class="ae jn" href="https://github.com/googlecodelabs/android-datastore/blob/preferences_datastore/app/src/main/java/com/codelab/android/datastore/data/UserPreferencesRepository.kt" rel="noopener ugc nofollow" target="_blank">UserPreferencesRepository</a></code>中，我们指定了构建持久化数据的键值对所需的所有键:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="7321" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">读取数据</h1><p id="cf01" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">为了读取存储的数据，在<code class="du jo jp jq jr b">UserPreferencesRepository</code>中，我们从<code class="du jo jp jq jr b">dataStore.data</code>暴露一个<code class="du jo jp jq jr b">Flow&lt;Preferences&gt;</code>。这提供了对<strong class="ir ht">最新保存状态</strong>和<strong class="ir ht">的有效访问，并随着每次更改</strong>而发出。使用Kotlin数据类，我们可以观察任何排放并将提供的DataStore <code class="du jo jp jq jr b">Preferences</code>对象转换成我们自己的<code class="du jo jp jq jr b">UserPreferences</code>模型，只使用我们感兴趣的<strong class="ir ht">键值对</strong>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0c85" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当试图从磁盘中读取时，该流将总是发出一个值或者<strong class="ir ht">抛出一个异常</strong>。我们将在后面的章节中研究异常处理。DataStore还确保工作总是在<code class="du jo jp jq jr b"><strong class="ir ht">Dispatchers.IO</strong></code>上执行，因此您的UI线程不会被阻塞。</p><p id="1e28" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">🚨<strong class="ir ht">不要创建任何缓存存储库</strong>来镜像您的首选项数据的当前状态。这样做会使DataStore对数据一致性的保证失效。如果您需要数据的单个快照，而不订阅进一步的流发射，则首选使用<code class="du jo jp jq jr b"><strong class="ir ht">dataStore.data.</strong><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">first()</strong></a></code>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="4117" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">写入数据</h1><p id="3f5c" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">对于写数据，我们将使用一个暂停<code class="du jo jp jq jr b">DataStore&lt;Preferences&gt;.edit(transform: suspend (MutablePreferences) -&gt; Unit) </code>函数。让我们来分解一下:</p><ul class=""><li id="dcf3" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">DataStore&lt;Preferences&gt;</code>接口——我们目前使用数据存储作为具体的<code class="du jo jp jq jr b">Preferences</code>实现</li><li id="2828" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">transform: suspend (MutablePreferences) -&gt; Unit</code> —一个暂停块，用于将指定的更改应用到我们的持久化数据</li><li id="0bba" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">MutablePreferences </code>—<code class="du jo jp jq jr b">Preferences</code>的一个可变子类，类似于<code class="du jo jp jq jr b">MutableMap</code>，允许我们对键值对进行修改</li></ul><p id="471f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，我们将更改我们的<code class="du jo jp jq jr b">SHOW_COMPLETED</code>标志:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9ac8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑数据是在<a class="ae jn" href="https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">原子读-修改-写操作</strong> </a>中以事务方式完成的。这意味着数据处理操作的特定顺序保证了<strong class="ir ht">一致性</strong>和<strong class="ir ht">防止竞争情况</strong>，在此期间，数据被其他线程锁定。只有在<code class="du jo jp jq jr b">transform</code>和<code class="du jo jp jq jr b">edit</code>协程成功完成后，数据才会持久保存到磁盘，并且<code class="du jo jp jq jr b">datastore.data</code>流会反映更新。</p><p id="0e39" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">🚨请记住，这是更改数据存储状态的唯一方式。保留一个<code class="du jo jp jq jr b">MutablePreferences</code>引用并在<code class="du jo jp jq jr b">transform</code>完成<strong class="ir ht">后手动改变它不会改变数据存储中的持久化数据</strong>，所以你不应该试图在<code class="du jo jp jq jr b">transform</code>块之外修改<code class="du jo jp jq jr b">MutablePreferences</code>。</p><p id="ea06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果写入操作由于任何原因失败，事务将被中止并引发异常。</p><h1 id="d334" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">从SharedPreferences迁移</h1><p id="1764" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">如果您之前在应用程序中使用过<code class="du jo jp jq jr b">SharedPreferences</code>，并且想要安全地将其数据传输到偏好设置，您可以使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/migrations/SharedPreferencesMigration" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">SharedPreferencesMigration</strong></a></code>。它需要一个上下文、<code class="du jo jp jq jr b">SharedPreferences</code>名称和一组您希望迁移的可选键(或者只保留默认的<strong class="ir ht"/><code class="du jo jp jq jr b"><strong class="ir ht">MIGRATE_ALL_KEYS</strong></code><strong class="ir ht">值</strong>)。</p><p id="ec9f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看<code class="du jo jp jq jr b">SharedPreferencesMigration</code>的实现，您会看到一个<code class="du jo jp jq jr b">getMigrationFunction()</code>，它负责获取所有需要的、存储的键-值对，然后使用<strong class="ir ht">相同的键</strong>将它们添加到首选项中。通过<code class="du jo jp jq jr b">preferencesDataStore</code>委托的<code class="du jo jp jq jr b">produceMigrations</code>参数将<code class="du jo jp jq jr b">SharedPreferencesMigration</code>传递给<strong class="ir ht">轻松迁移</strong>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5e0c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">produceMigrations</code>将确保<code class="du jo jp jq jr b">getMigrationFunction()</code>在对数据存储库的任何潜在数据访问之前运行<strong class="ir ht">。这意味着您的迁移<strong class="ir ht">必须在DataStore发出任何进一步的值之前和开始对数据进行任何新的更改之前已经成功</strong>。一旦成功迁移，就可以安全地停止使用<code class="du jo jp jq jr b">SharedPreferences</code>，因为键只被<strong class="ir ht">迁移一次</strong>，然后<strong class="ir ht">从<code class="du jo jp jq jr b">SharedPreferences</code>中移除</strong>。</strong></p><p id="ba5d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">produceMigrations</code>接受<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/core/DataMigration" rel="noopener ugc nofollow" target="_blank">DataMigration</a></code>的列表。我们将在后面的章节中看到如何将它用于其他类型的数据迁移。如果你不需要迁移，你可以忽略它，因为它已经有了一个默认的<strong class="ir ht"/><code class="du jo jp jq jr b"><strong class="ir ht">listOf()</strong></code><strong class="ir ht"/>。</p><h1 id="c680" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">异常处理</h1><p id="7766" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">与<code class="du jo jp jq jr b">SharedPreferences</code>相比，DataStore的一个主要优势是其用于捕获和处理异常的<strong class="ir ht">简洁机制</strong>。虽然<code class="du jo jp jq jr b">SharedPreferences</code>将解析错误作为运行时异常抛出，为意外的、未捕获的崩溃留出了空间，但是当读/写数据发生错误时，数据存储抛出<code class="du jo jp jq jr b"><strong class="ir ht">IOException</strong></code>。</p><p id="8dad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以通过在<code class="du jo jp jq jr b">map()</code>和发射<code class="du jo jp jq jr b">emptyPreferences()</code>之前使用<code class="du jo jp jq jr b">catch()</code>流操作符来安全地处理这个问题:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b955" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者用简单的<code class="du jo jp jq jr b">try-catch</code>块书写:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="819a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果抛出了不同类型的异常，最好重新抛出。</p><h1 id="8ae1" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">待续</h1><p id="a751" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我们已经介绍了<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-preferences" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">数据存储的首选项</strong> </a>实现——何时以及如何使用它来读写数据，如何处理错误以及如何从<code class="du jo jp jq jr b">SharedPreferences</code>迁移。在下一篇文章中，我们将讨论与<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-typed" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto DataStore</strong></a>实现相同的主题，所以不要走开。</p><p id="cfec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在这里找到我们的Jetpack数据存储系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack数据存储简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">数据存储和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c">数据存储和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c">数据存储和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa">数据存储和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8">数据存储和测试</a></p></div></div>    
</body>
</html>