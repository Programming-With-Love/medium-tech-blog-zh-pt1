<html>
<head>
<title>Layouts, Attributes, and you</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布局、属性和您</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/layouts-attributes-and-you-9e5a4b4fe32c?source=collection_archive---------1-----------------------#2016-01-21">https://medium.com/androiddevelopers/layouts-attributes-and-you-9e5a4b4fe32c?source=collection_archive---------1-----------------------#2016-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/255022de7643310ba796c3877f742e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyeYIFdYPsES5b-mlbdaPg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">This took a surprisingly long time to write out</figcaption></figure><div class=""/><p id="732d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">那个古老的问题:</p><blockquote class="jr"><p id="0339" class="js jt hw bd ju jv jw jx jy jz ka jq dx translated">我应该使用什么样的布局？</p></blockquote><p id="d1c0" class="pw-post-body-paragraph it iu hw iv b iw kc iy iz ja kd jc jd je ke jg jh ji kf jk jl jm kg jo jp jq ha bi translated">了解你脑海中的画面(或者设计师给你的线框)如何转化为实际的布局和视图，是每个Android开发人员都可以从中受益的关键技能之一。</p><figure class="kh ki kj kk fd hj"><div class="bz dy l di"><div class="kl km l"/></div></figure><h1 id="ace3" class="kn ko hw bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">什么是布局？</h1><p id="74c9" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">只要浏览developer.android.com的布局，你会发现大量的类以“布局”结尾。他们都有什么共同点？它们都是<a class="ae kb" href="http://developer.android.com/reference/android/view/ViewGroup.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq">视图组</em> </a>的子类——一个<a class="ae kb" href="http://developer.android.com/reference/android/view/View.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq">视图</em> </a>，支持添加子视图(俗称子视图)。</p><p id="4465" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如您所料，视图组的主要职责之一是布置这些子视图:选择每个视图的大小(“度量”阶段)，并将视图放置在视图组中(“布局”阶段)。</p><blockquote class="lr ls lt"><p id="c687" class="it iu lq iv b iw ix iy iz ja jb jc jd lu jf jg jh lv jj jk jl lw jn jo jp jq ha bi translated"><strong class="iv hx">注意</strong>:这并不是说这就是一个视图组的全部职责。它当然可以有自己的自定义行为，自己画东西，添加自己的孩子。例如<a class="ae kb" href="http://developer.android.com/reference/android/support/v7/widget/Toolbar.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="hw">工具栏</em> </a>，除了支持子视图之外，还有相当多的内置功能。</p></blockquote><p id="2042" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此，如果您正在寻找一种特定的子视图布局方式，选择正确的布局将会起到很大的作用，这并不奇怪。错误的布局可能会使某个模式无法实现或执行得很糟糕，而另一个布局可能会简化事情。</p><h1 id="f99e" class="kn ko hw bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">布局_属性</h1><p id="c531" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">现在，就像任何视图一样，视图组可以使用XML属性，如<em class="lq"> LinearLayout </em>的<em class="lq"> android:orientation </em>，来改变它们如何布局它们的子视图，但这些是影响每个子视图的全局变化。为了逐个子视图进行更改，布局使用了一种不同的机制，即添加到<strong class="iv hx">子视图</strong>中的<em class="lq">布局_ </em>属性。这些属性是不同的，因为<strong class="iv hx"> <em class="lq"> layout_ </em>属性是父视图组</strong>的指令，而不是视图本身的指令。让我们从我写的<a class="ae kb" href="https://plus.google.com/+IanLake/posts/Hepj6KynZD5?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">前一篇专业技巧</a>中举个例子:</p><pre class="kh ki kj kk fd lx ly lz ma aw mb bi"><span id="c82c" class="mc ko hw ly b fi md me l mf mg">&lt;android.support.design.widget.AppBarLayout&gt;<br/>  &lt;android.support.v7.widget.Toolbar<br/>    app:layout_scrollFlags="scroll|enterAlways" /&gt;<br/>&lt;/android.support.design.widget.AppBarLayout &gt;</span></pre><p id="68f6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你查看<em class="lq">工具栏</em>，你不会发现任何关于<em class="lq"> layout_scrollFlags </em>的内容。如果你查看<a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/AppBarLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> AppBarLayout </em> </a>，你也不会找到任何东西。那些<em class="lq"> layout_ </em>属性实际上存储在<a class="ae kb" href="http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> LayoutParams </em> </a>(具体来说，在本例中是<a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/AppBarLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> AppBarLayout。LayoutParams </em> </a>子类)。当附加到父视图时，每个视图都有自己的LayoutParams，作为父视图组想要跟踪的基本内容的存储位置。默认情况下，这只是一个宽度和高度(您几乎在每个视图中都可以看到的<em class="lq"> layout_width </em>和<em class="lq"> layout_height </em>)，但是每个视图组都有机会在它们自己的LayoutParams子类中声明新的属性(如文档中的<a class="ae kb" href="http://developer.android.com/guide/topics/ui/declaring-layout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#layout-params" rel="noopener ugc nofollow" target="_blank">所述)。</a></p><blockquote class="lr ls lt"><p id="48c4" class="it iu lq iv b iw ix iy iz ja jb jc jd lu jf jg jh lv jj jk jl lw jn jo jp jq ha bi translated"><strong class="iv hx">注意:</strong>这也是为什么从XML膨胀视图而不包括父视图(即，在<a class="ae kb" href="http://developer.android.com/reference/android/view/LayoutInflater.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#inflate%28int,%20android.view.ViewGroup,%20boolean%29" rel="noopener ugc nofollow" target="_blank"><em class="hw">layoutinflate . inflate()</em></a><em class="hw">)</em>是一个可怕的想法的首要原因——没有任何父视图，就没有人来解析和创建正确的<em class="hw"> LayoutParams </em>对象，实际上<strong class="iv hx">意味着所有这些属性都被丢弃了</strong> —可能不是您想要的。</p></blockquote><h1 id="fcda" class="kn ko hw bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">常见的Android布局</h1><p id="55b0" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">仅仅了解文档中解释的<em class="lq"> LayoutParams </em>和<em class="lq"> layout_ </em>属性可能足以帮助您选择正确的布局，但是快速总结一下也无妨。</p><h2 id="3730" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">线性布局</h2><p id="5f97" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated"><a class="ae kb" href="http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> LinearLayout </em> </a>人生有一个目标:把孩子排成单行或单列(取决于其<a class="ae kb" href="http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#attr_android:orientation" rel="noopener ugc nofollow" target="_blank"><em class="lq">Android:orientation</em></a>是<a class="ae kb" href="http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#HORIZONTAL" rel="noopener ugc nofollow" target="_blank">横</a>还是<a class="ae kb" href="http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#VERTICAL" rel="noopener ugc nofollow" target="_blank">竖</a>)。</p><p id="f5d7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，即使只有一个焦点，它仍然有一个锦囊妙计，即<a class="ae kb" href="http://developer.android.com/guide/topics/ui/layout/linear.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#Weight" rel="noopener ugc nofollow" target="_blank"> layout_weight </a>属性，该属性允许子元素扩展其大小以填充剩余的空间——如果您有几个<em class="lq"> wrap_content </em>元素和其他几个需要尽可能多的空间的元素，这很有用。</p><h2 id="cbde" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">框架布局</h2><p id="d774" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated"><a class="ae kb" href="http://developer.android.com/reference/android/widget/FrameLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> FrameLayout </em> </a>与<em class="lq"> LinearLayout </em>相比有很大的不同:这里所有的子元素都被绘制成一个堆栈——不管有没有重叠。对定位的唯一控制是<a class="ae kb" href="http://developer.android.com/reference/android/widget/FrameLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#attr_android:layout_gravity" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> layout_gravity </em> </a>属性——将子对象推向一侧或在<em class="lq"> FrameLayout </em>内居中。</p><h2 id="83ee" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">相对布局</h2><p id="c435" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated"><a class="ae kb" href="http://developer.android.com/reference/android/widget/RelativeLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="lq">relative layout</em></a>远没有前面两个那么简单:一看<a class="ae kb" href="http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> RelativeLayout。LayoutParams </em> </a>显示了大量的属性，这些属性都集中在相对于<em class="lq"> RelativeLayout </em>的边缘或中心的<a class="ae kb" href="http://developer.android.com/guide/topics/ui/layout/relative.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#Position" rel="noopener ugc nofollow" target="_blank">定位子节点</a>(实际上类似于<em class="lq"> FrameLayout </em>)，而且还相对于彼此——比如说，一个子节点<a class="ae kb" href="http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#attr_android:layout_below" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> layout_below </em> </a>另一个子节点。</p><p id="272f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这有一个非常非常强大的优势(将任意的孩子彼此关联起来)，但是<a class="ae kb" href="https://www.youtube.com/watch?v=dB3_vgS-Uqo?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">注意你的表现</a>！</p><h2 id="dff4" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">PercentFrameLayout和PercentRelativeLayout</h2><p id="fd9e" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">作为<a class="ae kb" href="https://plus.google.com/+AndroidDevelopers/posts/C8oaLunpEEj?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">百分比支持库</a>的成员，<a class="ae kb" href="http://developer.android.com/reference/android/support/percent/PercentFrameLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="lq">Percent frame layout</em></a>和<a class="ae kb" href="http://developer.android.com/reference/android/support/percent/PercentRelativeLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="lq">Percent relative layout</em></a>添加到它们的名称中，并添加了基于百分比的尺寸和边距，允许您使用<em class="lq">layout _ width Percent = " 50% "</em>来代替猜测适当的<em class="lq"> layout_width </em>必须是什么。</p><p id="ce0a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它们还包含一个最令人兴奋的特性:<a class="ae kb" href="https://plus.google.com/+AndroidDevelopers/posts/ZQS29a5yroK?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">纵横比支持</a>，使得只声明一个维度(高度或宽度)并基于一个固定的纵横比成为可能。即使一个维度是<em class="lq"> wrap_content </em>或<em class="lq"> match_parent </em>也是如此！</p><h2 id="753f" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">网格布局</h2><p id="d3c1" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated"><a class="ae kb" href="http://developer.android.com/reference/android/support/v7/widget/GridLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> GridLayout </em> </a>在2011<a class="ae kb" href="http://android-developers.blogspot.com/2011/11/new-layout-widgets-space-and-gridlayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"/>的冰激凌三明治中被引入，但也作为其自身<a class="ae kb" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#v7-gridlayout" rel="noopener ugc nofollow" target="_blank">支持库</a>的一部分可用(以支持回到API 7)。旨在将项目放置在任意行和列中，并支持与LinearLayout相同的权重，它允许您在很大程度上扁平化视图层次结构，同时避免一些影响<em class="lq"> RelativeLayout </em>性能的复杂元素排列。</p><p id="b273" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">与大多数布局不同，<strong class="iv hx"> <em class="lq"> GridLayout </em>不要求每个视图都有<em class="lq"> layout_height </em>和<em class="lq">layout _ width</em></strong>——列和行(以及它们包含的子元素)根据各自的<a class="ae kb" href="http://developer.android.com/reference/android/support/v7/widget/GridLayout.Alignment.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq">对齐方式</em> </a>按需增长和收缩。我强烈建议阅读一下<a class="ae kb" href="http://developer.android.com/reference/android/support/v7/widget/GridLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> GridLayout。LayoutParams </em> </a>文档和<a class="ae kb" href="http://android-developers.blogspot.com/2011/11/new-layout-widgets-space-and-gridlayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">博客文章</a>(注意它是在<em class="lq"> GridLayout </em>获得<em class="lq"> layout_weight </em>属性之前写的)如果你想深入研究这个组件。</p><h2 id="5dea" class="mc ko hw bd kp mh mi mj kt mk ml mm kx je mn mo lb ji mp mq lf jm mr ms lj mt bi translated">坐标布局</h2><p id="87a4" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated"><a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="lq">coordinator layout</em></a>是<a class="ae kb" href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android设计支持库</a>的一部分，是<em class="lq"> FrameLayout </em>的子类，因此继承了其使用<em class="lq"> layout_gravity </em>来定位子对象，但也包含了一个<a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq">行为</em> </a>的概念。</p><p id="86d5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过使用类上的<a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.DefaultBehavior.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> @DefaultBehavior </em> </a>注释、使用<em class="lq"> layout_behavior </em>属性或者使用<a class="ae kb" href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.LayoutParams.html?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog#setBehavior%28android.support.design.widget.CoordinatorLayout.Behavior%29" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> setBehavior() </em> </a>将<em class="lq">行为</em>附加到视图允许<em class="lq">行为</em>拦截底层视图之前的所有内容:度量、布局、嵌套滚动、触摸事件、对指定从属视图的更改以及窗口插入。</p><p id="a58d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要深入了解行为，请查看用CoordinatorLayout行为 拦截一切的<a class="ae kb" rel="noopener" href="/google-developers/intercepting-everything-with-coordinatorlayout-behaviors-8c6adc140c26?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog"> <em class="lq">帖子。</em></a></p><h1 id="3d91" class="kn ko hw bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">布局，布局，布局</h1><p id="f8f7" class="pw-post-body-paragraph it iu hw iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">即使只有上面描述的几个布局，您也可以构建一个丰富的UI，既高性能又易于维护。下一次你在纠结于一个特定的布局时，考虑后退一步，看看是否有更简单的方法来使用不同的布局，或者构建你自己的自定义布局(并承担由此带来的责任——并非无关紧要)是否是最好的方法。</p><p id="4f11" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">无论哪种方式，都使用正确的布局和#BuildBetterApps的正确的<em class="lq"> layout_ </em>属性</p><p id="8a8a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">关注<a class="ae kb" href="https://plus.google.com/collection/sLR0p?utm_campaign=android_series_layoutattributes_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集</a>了解更多！</p><figure class="kh ki kj kk fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mu"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>