<html>
<head>
<title>Kotlin Programmer Dictionary: Function Type vs Function literal vs Lambda expression vs Anonymous function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin程序员词典:函数类型vs函数文字vs Lambda表达式vs匿名函数</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e?source=collection_archive---------0-----------------------#2017-12-21">https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e?source=collection_archive---------0-----------------------#2017-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a206f2ee01089b85197e338e8a3c2fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tXYK-s41WuaQX-LZ.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Yes, this article is introducing terms that are connected to functional programming in Kotlin</figcaption></figure><p id="a1cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在科特林，职能是<em class="kt">一等公民</em>。这意味着函数可以赋给变量，作为参数传递或者从另一个函数返回。虽然Kotlin是静态类型的，但要实现这一点，函数需要有一个类型。它存在并且被称为<strong class="jx io">函数类型</strong>。这里有几个例子:</p><ul class=""><li id="a86f" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe ld le lf lg b">()-&gt;Unit</code>—不返回任何有用信息(<code class="fe ld le lf lg b">Unit</code>)且不带参数的函数类型。</li><li id="0329" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><code class="fe ld le lf lg b">(Int)-&gt;Int</code> —返回<code class="fe ld le lf lg b">Int</code>并接受类型<code class="fe ld le lf lg b">Int</code>的单参数的函数类型。</li><li id="89d0" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><code class="fe ld le lf lg b">()-&gt;()-&gt;Unit</code> —返回另一个不返回任何有用信息的函数的函数类型(<code class="fe ld le lf lg b">Unit</code>)。两个函数都没有参数。</li></ul><p id="f852" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">函数类型</strong>只是一个接口的语法糖，但是接口不能显式使用。然而，我们可以像使用接口一样使用<strong class="jx io">函数类型</strong>，包括将它们用作<a class="ae lm" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">类型参数</a>或实现它们:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="d661" class="lv lw in lg b gy lx ly l lz ma"><strong class="lg io">class </strong>MyFunction: ()-&gt;Unit {<br/><br/>    <strong class="lg io">override fun </strong>invoke() {<br/>        <em class="kt">println</em>(<strong class="lg io">"I am called"</strong>)<br/>    }<br/>}<br/><br/><strong class="lg io">fun </strong>main(args: Array&lt;String&gt;) {<br/>    <strong class="lg io">val </strong>function = MyFunction()<br/>    function() <em class="kt">// Prints: I am called<br/></em>}</span></pre><p id="69f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以使用它们来键入局部变量、<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性</a>或<a class="ae lm" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">参数</a>:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="0bdc" class="lv lw in lg b gy lx ly l lz ma">val greet: <!-- -->()-&gt;Unit<br/>val square: (Int)-&gt;Int<br/>val producePrinter: ()-&gt;()-&gt;Unit</span></pre><p id="0587" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上变量都不包含任何值。让我们指定一些。提供函数的最简单方法是使用引用实际函数的<strong class="jx io">函数引用</strong>。这是它的使用方法:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="86c9" class="lv lw in lg b gy lx ly l lz ma">fun greetFunction() {<br/>    println("Hello")<br/>}</span><span id="b313" class="lv lw in lg b gy mb ly l lz ma">val greet = ::greetFunction</span></pre><p id="98a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数引用就是反射的一个例子。它返回对该函数的引用，该函数还实现了一个表示<strong class="jx io">函数类型</strong>的接口。这就是为什么它可以这样使用。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi jk"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><p id="133b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提供函数的另一种方法是使用<strong class="jx io">函数字面量</strong>。一般来说，编程中的<strong class="jx io">文字</strong>是一种语法糖，用于表示该语言认为特别重要的某些类型的值。因此<strong class="jx io">函数文字</strong>是一种特殊的符号，用于简化函数的定义。Kotlin中有两种类型的<strong class="jx io">函数文字</strong>:</p><ul class=""><li id="f2bb" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">λ表达式</strong></li><li id="f631" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><strong class="jx io">匿名功能</strong></li></ul><p id="6afe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Lambda表达式</strong>是定义函数的一种简称。让我们用它来填充上面的变量:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="418a" class="lv lw in lg b gy lx ly l lz ma">val greet: <!-- -->()-&gt;Unit = { println("Hello") }<br/>val square: (Int)-&gt;Int = { x -&gt; x * x }<br/>val producePrinter: ()-&gt;()-&gt;Unit = { { println("I am printing") } }</span><span id="8b36" class="lv lw in lg b gy mb ly l lz ma">// Usage<br/>greet() // Prints: Hello<br/>println(<!-- -->square<!-- -->(2)) // Prints: 4<br/>producePrinter()() // Prints: I am printing</span></pre><p id="49bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，<code class="fe ld le lf lg b">square</code>中的参数类型是从<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性</a>类型中推断出来的。我们可以改为显式地键入它，然后可以从lambda表达式中推断出属性类型。类似地，在<code class="fe ld le lf lg b">greet</code>和<code class="fe ld le lf lg b">producePrinter</code>中缺少论证就足以推断出财产类型:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="91d2" class="lv lw in lg b gy lx ly l lz ma">val greet<!-- --> = { println("Hello") }<br/>val square = { x: Int -&gt; x * x }<br/>val producePrinter = { { println("I am printing") } }</span></pre><p id="159a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">匿名函数</strong>是定义函数的另一种方法。让我们用它来填充变量:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="fe61" class="lv lw in lg b gy lx ly l lz ma">val greet: <!-- -->()-&gt;Unit = fun() { println("Hello") }<br/>val square: (Int)-&gt;Int = fun(x) = x * x<br/>val producePrinter: ()-&gt;()-&gt;Unit = fun() = fun() { println("I am printing") }</span></pre><p id="9033" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以类似地推断属性类型:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="fad2" class="lv lw in lg b gy lx ly l lz ma">val greet<!-- --> = fun() { println("Hello") }<br/>val square = fun(x: Int) = x * x<br/>val producePrinter = fun() = fun() { println("I am printing") }</span></pre><p id="456e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所见，<strong class="jx io"> lambda表达式</strong>和<strong class="jx io">匿名函数</strong>非常相似。为什么要区分？一般来说，最大的区别是<strong class="jx io">匿名函数</strong>更加显式。当我们使用它们的时候就更清楚了，返回值需要被明确地指定。<strong class="jx io"> Lambda表达式</strong>返回其主体或<code class="fe ld le lf lg b">Unit</code>中最后一条语句的值。无标签退货在这里不起作用:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="a0e4" class="lv lw in lg b gy lx ly l lz ma">val getMessage = { response: Response -&gt;<br/>    if(response.code !in 200..299) {<br/>        return "Error" // Error! Not allowed<br/>    }<br/>    response.message<br/>}</span></pre><p id="9e1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须使用带标签的return在最后一个语句之前完成λ表达式:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="1417" class="lv lw in lg b gy lx ly l lz ma"><strong class="lg io">val </strong><em class="kt">getMessage </em>= lambda@ <strong class="lg io">{ </strong>response: Response <strong class="lg io">-&gt;<br/>    if</strong>(response.<em class="kt">code </em><strong class="lg io">!in </strong>200..299) {<br/>        <strong class="lg io">return</strong>@lambda <strong class="lg io">"Error"</strong><em class="kt"><br/>    </em>}<br/>    response.<em class="kt">message<br/></em><strong class="lg io">}</strong></span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><a href="https://learningdriven.fun/"><div class="gh gi jk"><img src="../Images/6755245656f3be202e1b99349aba4423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS3hpI-naOu-GxrgpBSyDQ.png"/></div></a></figure><p id="6ad0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">匿名函数</strong>的行为类似于普通函数，返回类型和返回语句都需要显式:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="ea0c" class="lv lw in lg b gy lx ly l lz ma"><strong class="lg io">val </strong><em class="kt">getMessage </em>= <strong class="lg io">fun</strong>(response: Response): String {<br/>    <strong class="lg io">if</strong>(response.<em class="kt">code </em><strong class="lg io">!in </strong>200..299) {<br/>        <strong class="lg io">return "Error" </strong><em class="kt">// Returns from getMessage<br/>    </em>}<br/>    <strong class="lg io">return </strong>response.<em class="kt">message<br/></em>}</span></pre><p id="0e38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，这些符号可以互换使用，但是当我们需要不止一次地使用return时，最好使用匿名函数。对于只有一个表达式的小函数，应该首选Lambda表达式。虽然有些情况下使用匿名函数会更好。我们都知道常见的困惑:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="9ad1" class="lv lw in lg b gy lx ly l lz ma">fun greet() = { println("Hello") }</span><span id="7a25" class="lv lw in lg b gy mb ly l lz ma">greet() // What does it print?</span></pre><p id="f662" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回答是“没有，因为<code class="fe ld le lf lg b">greet</code>返回函数而不是打印任何东西”。现在请注意，如果用户使用<strong class="jx io">匿名函数</strong>而不是<strong class="jx io"> lambda表达式</strong>，答案将是多么明显:</p><pre class="ln lo lp lq gt lr lg ls lt aw lu bi"><span id="b28e" class="lv lw in lg b gy lx ly l lz ma">fun greet() = fun() { println("Hello") }</span></pre><p id="44c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，匿名函数更好，因为它更显式。类似地，当我们想要强调最后一个语句是返回类型时，我们应该使用匿名函数。在这些情况下，我们更喜欢匿名函数给我们的显式方式。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="d74a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本帖是<a class="ae lm" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第十一部分。要了解最新的新部件，只需关注这个媒体或<a class="ae lm" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，记得<a class="ae lm" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我随时欢迎咨询</a>。</p><p id="43b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mj"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><a class="ae lm" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="1953" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="2a4f" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="d41a" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性对字段</a></li><li id="84df" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类对类型对对象</a></li><li id="795a" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="7a6f" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="c987" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收器类型与接收器对象</a></li><li id="47f7" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="b38d" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="8672" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs方差</a></li><li id="cb4f" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="2e53" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组合</a></li></ul><figure class="ln lo lp lq gt jo gh gi paragraph-image"><a href="https://kt.academy/workshop"><div class="gh gi mk"><img src="../Images/3a56ace9079f060f9ee79ad3ed6b6756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxsEmnZGeKgLuGPFgNaLzA.png"/></div></a></figure><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>