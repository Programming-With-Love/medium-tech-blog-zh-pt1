<html>
<head>
<title>Using Ruby Classes to Implement a Game of BlackJack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ruby类实现21点游戏</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/using-ruby-classes-to-implement-a-game-of-blackjack-535a786c417?source=collection_archive---------2-----------------------#2019-08-26">https://medium.com/quick-code/using-ruby-classes-to-implement-a-game-of-blackjack-535a786c417?source=collection_archive---------2-----------------------#2019-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8024" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ruby是一种面向对象的编程语言，这意味着它有类和对象。类是我们用来定义对象的属性和行为的模型。这方面的例子有很多，比如汽车是一个具有品牌、型号和颜色等属性的对象，以及drive()和break()等行为。汽车的类别决定了使用的型号，例如，一个单独的对象将是我的红色本田思域。驱动(假)</p><p id="c227" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更好地说明这一点，我将举一个我在最近的课堂项目中使用的例子:为一副52张牌设计一个数据结构，使用类来实现21点。在Gayle Laakmann McDowell的第六版《破解编码面试》中，我也看到了这是一个用于工作面试的编码挑战的例子，所以说这是一个流行的例子是一种保守的说法。</p><p id="8c7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个游戏有两个部分。第一个是为玩家、卡牌和卡片设置类。第二个是实际的游戏逻辑，包括终端提示和基于用户输入或输赢场景运行的if语句。出于本文的目的，我将把重点放在设置类上。</p><p id="f1bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我创建的第一个类是“Player”。我最初是通过创建“玩家”和“庄家”类开始的，但很快意识到这是多余的。</p><p id="7861" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用了“attr_accessor”，这是一个Ruby方法，它允许我在程序的其他地方更新这些对象的某些属性(名字、手牌、资金和总数)。</p><p id="271f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“def initialize”是一个函数，它允许我使用提供的属性基于这个模型创建一个新的对象。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2385a798105ab2f9a0f9274e4c7edc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sFmymzSujpghs_4i9syQw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Player Class — creates a new player</figcaption></figure><p id="3f67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，“名称”将是用户提供的名称(或我创建的默认名称)，“手牌”将是一个空数组，我们稍后可以将卡对象推入其中，“资金”将是玩家当前拥有的钱数(他们每手牌可以赢钱和输钱)，“总数”将是玩家手牌的总价值。我们稍后将需要这个值来决定赢的情况:有一手总价值不超过21的最高牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/e3f8d8098d732d9d2500ace8304ebbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*6B_aYwJp-v1tj4JZmmJZqw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Created two players</figcaption></figure><p id="db93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，我首先创建了一个手空(空数组)的人类玩家，银行中有$100，总手值为0。</p><p id="62b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还创建了一个空手(空数组)的电脑玩家，银行里有$10000，总手值为0。</p><p id="d348" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">他们空手怎么玩？不用担心，还记得attr_accessor吗？这意味着我们可以在以后更新这些属性。</p><p id="0e71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们要创建我们的卡片类。这将是我们用来生成具有脸、花色和价值属性的个别牌的内容(记住，我们需要知道牌的价值来计算玩家手牌的总价值)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/b8a363a6b8358e963071710bd0d33034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*N_h0yLrQQdjM0YO8SvTbvQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Card Class — Creates A New Card</figcaption></figure><p id="2c32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以现在我们有了“卡”类，我们可以开始生成新的卡，就像我们对玩家做的那样，对吗？</p><p id="dd59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嗯，没那么简单。我们需要生成52张牌，有13个等级，每个等级四张，每种花色一张。想象一下，如果我必须手动创建每张卡，那会有多乏味？谢天谢地，我不用。我可以创建另一个名为Deck的类来为我们生成这些卡片，然后使用该类来初始化我的卡片对象。每张牌实际上都是在创建一副牌时创建的，并从该副牌继承其属性。</p><p id="51ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在是有挑战性的部分，初始化甲板。我首先简单地创建了三个数组:一个用于牌面，一个用于花色，还有一个空数组用于存放初始化后的所有牌。</p><p id="1321" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能会注意到，对于faces数组，我有一个前面带星号的数字范围。如果你像我一样是Ruby新手，你可能对这个方法不熟悉，但是它叫做“splat ”,非常棒！<a class="ae jc" href="https://www.honeybadger.io/blog/ruby-splat-array-manipulation-destructuring/" rel="noopener ugc nofollow" target="_blank">它有许多用途</a>，其中之一是将一系列数字分解成单独的列表项。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/cb7d4b7d6bcc047e2919d034ed475ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP9FmmOlf70pD7xTJ2iE9g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Create a class “Deck”</figcaption></figure><p id="2d60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们需要创建我们的一副牌，但我们需要确保每种面值有四张牌，每副牌中有一种花色。我们可以通过迭代每个面，然后对每个面，迭代每个花色(循环中的循环)来实现这一点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/965c7d23238be87d5358bdba2004cb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJqKlH9NHLCyrOh_9jDvMg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Loop through faces, then loop through suits</figcaption></figure><p id="b82c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们遍历每个面值时，我还包含了一个if语句来根据面值确定卡的价值。如果面是一个数字或整数，我们希望值等于该数字。Ace的值应该是11(对于特殊情况，我们可以稍后将该值更改为1)。其他每张脸牌(国王、王后和j)的值都是10。</p><p id="a269" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，对于每张脸，我们还将循环四种花色并创建一张新牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/24814ed0cf1b8a3b48f1759614613f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*qZxbImSecLso7Xw41GVgUg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx">Pushing the newly created card into the cards array</figcaption></figure><p id="e859" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">认识语法吗？我们创建新卡的方式与创建新玩家的方式相同，只是这一次我们是在一个循环中完成的，所以这一行代码将运行52次并生成52个卡对象。我们使用这些&lt;</p><p id="927b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了自己的牌组，我们希望其中的牌被随机化。在真正的纸牌游戏中，我们会洗牌。在Ruby中，我们可以用@cards.shuffle来洗牌！(结尾的感叹号表示原对象将被永久转化。)很酷吧？</p><p id="c9e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们如何将这些牌发给我们的玩家，并有效地将这些牌添加到他们的牌组中？</p><p id="6457" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我使用了两个协同工作的函数，一个在名为“deal”的Deck类中，另一个在名为“generate_card”的Card类中。</p><p id="734d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们先浏览一下生成卡功能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jy"><img src="../Images/0cbc0fa4673bf32e9d3a5647e15658ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMMWZ3iTX3DtqBPsQbHk7w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Function created to generate a card</figcaption></figure><p id="cfac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让这个函数正常工作，我需要首先知道谁在收卡，所以我需要一个名为“player”的参数。</p><p id="7029" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用与前面相同的语法，我将创建一张有脸、花色和值的新卡(我将从牌组中收到)。</p><p id="41f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我将把新卡推到指定玩家的手中</p><p id="2bb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当我添加新卡时，我需要更新玩家手牌的总值。我只是让总数等于原来的总数加上新卡的价值。我也可以这样写(player.total += new_card.value)。</p><p id="6244" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我将在我的Deck类的deal函数中调用这个函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/b425c6c36b25a23eb7fbef3d7afabb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sNaowTwHYt2CUJdN0fDrA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Creating a deal function to remove a card from the deck and add the card to the player hand</figcaption></figure><p id="d988" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">发牌函数需要两个参数，发牌的牌数和发牌的玩家。我本可以在游戏逻辑中按照需要的次数调用这个函数，而不是获取发牌的数量，但是这样写有点枯燥。</p><p id="c191" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用了Ruby的shift方法，该方法从数组中移除第一个项目并返回该项目，以有效地从牌叠中取出一张牌，并将其放在玩家手中。我在这里调用了generate_card函数，用我从牌组中取出的牌的属性为玩家创建新的牌。</p><p id="bba6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">num.times将决定这种情况发生的次数。</p><p id="8fce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我在游戏逻辑中如何调用这个函数的例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/afce3e24327f462b5fce7e2eb5005916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDG1k_2dL9a0XzX74mFGOw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Examples of the deal function used in the gameplay logic</figcaption></figure><p id="8b5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我用deck.deal(2，人类)给人类玩家发了两张牌。然后我可以参考下面的卡片，索引为0和1。我使用deck.deal(2，computer)来处理计算机卡，然后向玩家展示其中一张。</p><p id="e31f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后来，我使用了一些逻辑，允许玩家“打”牌或增加更多的牌，但这非常简单，因为我可以使用相同的deck.deal()函数。</p><p id="47e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望你喜欢这篇关于如何用Ruby类设置21点游戏的教程。将来我可能会写第二部分来讨论实际的游戏性和控制台提示。</p></div></div>    
</body>
</html>