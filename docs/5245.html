<html>
<head>
<title>KVM + iSCSI Part II: PCI-Passthrough a Virtual Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KVM + iSCSI第二部分:PCI-通过虚拟函数</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/kvm-iscsi-part-ii-pci-passthrough-a-virtual-function-1fbc1ed40311?source=collection_archive---------1-----------------------#2017-05-19">https://medium.com/oracledevs/kvm-iscsi-part-ii-pci-passthrough-a-virtual-function-1fbc1ed40311?source=collection_archive---------1-----------------------#2017-05-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c95d042d04591298a9f717b124f13cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzRcGgGROF9E2MZALh-_Dw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Image copyright <a class="ae hu" href="https://www.flickr.com/photos/ibm_media/" rel="noopener ugc nofollow" target="_blank">ibmphoto24</a> <a class="ae hu" href="https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode" rel="noopener ugc nofollow" target="_blank">CC-BY-NC-ND</a></figcaption></figure><div class=""/><div class=""><h2 id="08f5" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">先决条件</h2></div><p id="9214" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">首先，确保完成<a class="ae hu" rel="noopener" href="/@vishvananda/kvm-iscsi-part-i-iscsi-boot-with-ipxe-f533f2666075">第一部分</a>，设定你的iSCSI目标。为了遵循本教程，您将需要一些额外的东西:</p><ul class=""><li id="6473" class="ki kj hx jo b jp jq js jt jv kk jz kl kd km kh kn ko kp kq bi translated">一个<a class="ae hu" href="http://blog.scottlowe.org/2009/12/02/what-is-sr-iov/" rel="noopener ugc nofollow" target="_blank"> SR-IOV </a>能力的网卡。</li><li id="da6b" class="ki kj hx jo b jp kr js ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><a class="ae hu" href="https://www.techwalla.com/articles/how-to-enable-iommu-bios" rel="noopener ugc nofollow" target="_blank"> IOMMU在BIOS中启用</a></li><li id="dd49" class="ki kj hx jo b jp kr js ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><a class="ae hu" href="https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF#Setting_up_IOMMU" rel="noopener ugc nofollow" target="_blank">在内核命令行中启用IOMMU】</a></li><li id="50e8" class="ki kj hx jo b jp kr js ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><a class="ae hu" href="http://ipxe.org/download" rel="noopener ugc nofollow" target="_blank"> iPXE构建先决条件已安装</a></li></ul><h2 id="eb34" class="kw kx hx bd ky kz la lb lc ld le lf lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">设置虚拟功能</h2><p id="18e3" class="pw-post-body-paragraph jm jn hx jo b jp lr iy jr js ls jb ju jv lt jx jy jz lu kb kc kd lv kf kg kh ha bi translated">我们必须做的第一件事是确保您启用了虚函数。<code class="du lw lx ly lz b">PARENT</code>是支持虚拟功能的物理设备的名称。以下命令适用于英特尔网卡。您可能需要查阅卡的手册，以了解如何在卡上设置虚拟功能:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="881d" class="kw kx hx lz b fi mi mj l mk ml">PARENT=ens2f0 # make sure to replace this with your NIC<br/>echo 4 | sudo tee /sys/class/net/$PARENT/device/sriov_numvfs</span></pre><p id="6e92" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在为下一系列命令设置几个bash变量:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="9233" class="kw kx hx lz b fi mi mj l mk ml">PCI=$(basename $(readlink /sys/class/net/$PARENT/device/virtfn0))<br/>DRIVER=$(lspci -v -s $PCI | grep modules | awk '{print $NF}')<br/>VENDOR=$(cat /sys/class/net/$PARENT/device/virtfn0/vendor)<br/>DEVICE=$(cat /sys/class/net/$PARENT/device/virtfn0/device)</span></pre><p id="6a92" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">接下来，将虚拟函数绑定到vfio_pci驱动程序:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="7531" class="kw kx hx lz b fi mi mj l mk ml">sudo modprobe vfio_pci<br/>echo $PCI | sudo tee /sys/bus/pci/drivers/$DRIVER/unbind<br/>echo ${VENDOR##*x} ${DEVICE##*x} \<br/>&gt; /sys/bus/pci/drivers/vfio-pci/new_id<br/>echo $PCI | sudo tee /sys/bus/pci/drivers/vfio-pci/bind</span></pre><h2 id="41d2" class="kw kx hx bd ky kz la lb lc ld le lf lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">重新配置虚拟网络</h2><p id="0951" class="pw-post-body-paragraph jm jn hx jo b jp lr iy jr js ls jb ju jv lt jx jy jz lu kb kc kd lv kf kg kh ha bi translated">将虚拟功能放在它自己的vlan上，这样您就不必担心虚拟机管理程序流量了:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="8ec1" class="kw kx hx lz b fi mi mj l mk ml">sudo ip link $PARENT set vf 0 vlan 10<br/>sudo ip link add vlan10 link $PARENT type vlan id 10<br/>sudo ip link set up vlan10<br/>sudo ip link set master virbr0 vlan10</span></pre><p id="70dd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">将虚拟机管理程序ip从网桥移动到vlan设备上:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="b31a" class="kw kx hx lz b fi mi mj l mk ml">sudo ip addr del 192.168.10.1/24 dev virbr0<br/>sudo ip addr add 192.168.10.1/24 dev vlan10</span></pre><p id="dcd2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您可能会发现流量无法在虚拟功能和虚拟机管理程序vlan设备之间正常传输。如果发生这种情况，您可以告诉设备将数据包传输到交换机，并让交换机将它们环回:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="95ac" class="kw kx hx lz b fi mi mj l mk ml">sudo bridge link set dev $PARENT hwmode vepa</span></pre><p id="db53" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请注意，只有当交换机设置为传输vlan 10且端口安全关闭时，上述操作才有效。</p><h2 id="bdfa" class="kw kx hx bd ky kz la lb lc ld le lf lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">启动来宾</h2><p id="77a1" class="pw-post-body-paragraph jm jn hx jo b jp lr iy jr js ls jb ju jv lt jx jy jz lu kb kc kd lv kf kg kh ha bi translated">此时，您应该能够成功地将虚拟函数传递给guest虚拟机:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="d2e3" class="kw kx hx lz b fi mi mj l mk ml">sudo qemu-system-x86_64 \<br/>-smp cpus=2 \<br/>-display vnc=0.0.0.0:0 \<br/>-boot order=n \<br/>-net none \<br/>-device vfio-pci,host=$PCI</span></pre><p id="044d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是，如果您连接到vnc控制台，您会注意到没有iPXE。您的网络设备没有预建的ipxe rom。</p><h2 id="db13" class="kw kx hx bd ky kz la lb lc ld le lf lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">构建iPXE</h2><p id="7330" class="pw-post-body-paragraph jm jn hx jo b jp lr iy jr js ls jb ju jv lt jx jy jz lu kb kc kd lv kf kg kh ha bi translated">您将不得不从源代码构建iPXE，所以抓住它:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="66e2" class="kw kx hx lz b fi mi mj l mk ml">git clone git://git.ipxe.org/ipxe.git<br/>cd ipxe</span></pre><p id="b875" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为您是自己构建的，所以可以嵌入一个脚本来避免捕捉iPXE提示符和手动键入命令:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="a7e2" class="kw kx hx lz b fi mi mj l mk ml">cat &gt; script.ipxe &lt;&lt; "EOF"<br/>ifopen net0<br/>set net0/ip 192.168.10.10<br/>set net0/netmask 255.255.255.0<br/>sanboot iscsi:192.168.10.1::::iqn.2016-01.com.example:cirros<br/>EOF</span></pre><p id="631a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用针对特定虚函数的脚本构建一个rom:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="13f7" class="kw kx hx lz b fi mi mj l mk ml">ID=${VENDOR##*x}${DEVICE##*x}<br/>export EMBED=$PWD/script.ipxe<br/>(cd src &amp;&amp; make bin/$ID.rom)</span></pre><p id="1985" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果出现错误，ipxe可能不支持您的网卡。您可以使用通用网络驱动程序(undionly)来代替:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="2403" class="kw kx hx lz b fi mi mj l mk ml">(cd src &amp;&amp; make bin/undionly.rom)</span></pre><h1 id="dfdc" class="mm kx hx bd ky mn mo mp lc mq mr ms lg jd mt je lj jg mu jh lm jj mv jk lp mw bi translated">使用自定义iPXE启动</h1><p id="23f7" class="pw-post-body-paragraph jm jn hx jo b jp lr iy jr js ls jb ju jv lt jx jy jz lu kb kc kd lv kf kg kh ha bi translated">使用自定义ipxe映像再次启动qemu:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="f930" class="kw kx hx lz b fi mi mj l mk ml">sudo qemu-system-x86_64 \<br/>-smp cpus=2 \<br/>-display vnc=0.0.0.0:0 \<br/>-boot order=n \<br/>-net none \<br/>-device vfio-pci,host=$PCI,romfile=$PWD/src/bin/$ID.rom</span></pre><p id="ed8d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您被迫使用通用网络驱动程序，您可能需要使用稍微不同的命令行来指定它:</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="ed8b" class="kw kx hx lz b fi mi mj l mk ml">sudo qemu-system-x86_64 \<br/>-smp cpus=2 \<br/>-display vnc=0.0.0.0:0 \<br/>-boot order=n \<br/>-net none \<br/>-device vfio-pci,host=$PCI \<br/>-option-rom $PWD/src/bin/undionly.rom</span></pre><p id="80ad" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">无论哪种情况，您都应该看到网络设备自动配置自己并引导cirros映像。恭喜你，你已经使用超快的虚拟函数通过网络启动了一个虚拟机！</p></div></div>    
</body>
</html>