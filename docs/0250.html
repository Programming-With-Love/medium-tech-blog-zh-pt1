<html>
<head>
<title>#SmallerAPK, Part 8: Native libraries, open from APK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">#SmallerAPK，第8部分:本地图书馆，在APK开放</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/smallerapk-part-8-native-libraries-open-from-apk-fc22713861ff?source=collection_archive---------4-----------------------#2016-02-19">https://medium.com/androiddevelopers/smallerapk-part-8-native-libraries-open-from-apk-fc22713861ff?source=collection_archive---------4-----------------------#2016-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/16742a27007b85054b45771a39fbd376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OvLVi-G5Ldze7Novm7M0w.jpeg"/></div></div></figure><div class=""/><p id="2309" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使只添加一个本地库，也会显著增加应用程序的大小。如果您的应用程序使用任何本地库(即有。所以文件在你的APK)，这篇文章是给你的。</p><p id="1c29" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有各种各样的C/C++编译技术和标志可以使您的。所以文件更小，但我不会在本文中讨论本机构建，因为这是一个广泛且非常高级的主题，每个特定的情况都需要特殊处理。另外，你可能会被编译。所以只有文件，不能访问源代码，你对它们的大小无能为力。相反，我将向您展示一个将磁盘空间使用量减半的奇怪技巧！不，真的…继续读:)</p><p id="1d6f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本系列的第1部分中，我<a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-1-anatomy-of-an-apk-da83c25e7003#3e57">提到过</a>拥有原生库最大的空间浪费来自于压缩的事实。所以文件在安装时从APK复制到用户的<em class="jo">/数据</em>分区。原件不会从APK中删除(因为我们不能从已签名的apk中删除文件，记得吗？).因此，它们占据了设备上两倍的空间。</p><p id="4e75" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从Android 6.0(棉花糖)开始，你可以在你的<em class="jo"> &lt;应用&gt; </em>上设置一个新的标志:</p><h2 id="ddfe" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">AndroidManifest.xml</h2><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="d3f0" class="jp jq hs kp b fi kt ku l kv kw">&lt;application<br/>   android:extractNativeLibs=”false”<br/>   ...<br/>&gt;</span></pre><p id="7aed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将从根本上防止系统创建。所以归档并修复<em class="jo"> System.loadLibrary </em>调用，这样它就可以直接从APK中找到并打开本地库，不需要您修改代码。</p><p id="ed9c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不过，这需要一些重要的先决条件，这也是事情变得更加复杂的地方:</p><ol class=""><li id="71fa" class="kx ky hs ir b is it iw ix ja kz je la ji lb jm lc ld le lf bi translated">的。因此APK <strong class="ir ht">中的文件不能被压缩</strong>——它们必须被存储。</li><li id="9a1a" class="kx ky hs ir b is lg iw lh ja li je lj ji lk jm lc ld le lf bi translated">的。所以文件<strong class="ir ht">必须使用<em class="jo"> zipalign -p 4 </em>进行页面对齐</strong></li></ol><p id="75c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">从Android Studio 2.2 Preview 2和最新的构建工具开始，构建过程将自动在APK中存储未压缩和页面对齐的原生库。</strong></p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><p id="0c50" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看保持原生库未压缩对文件和下载大小有什么影响:</p><h2 id="4934" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">初始下载大小</h2><p id="475b" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">应该大致相同。这怎么可能呢？Play Store在向用户设备发送APK文件时实际上使用了自己的压缩技术。根据你的特定库的可压缩性，下载的大小可能<strong class="ir ht">大致相同</strong>或者稍微大一点。</p><h2 id="30d9" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">更新大小</h2><p id="c6df" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">应该是<strong class="ir ht">比</strong>小。Play Store使用一种称为“增量更新”的机制向现有用户提供新版本的应用程序。它会计算新APK和安装在设备上的APK之间的差异，并只发送在设备上重建最终APK所需的二进制差异。</p><p id="6a4b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让原生库解压缩实际上有助于Play使用的算法计算更优(即更小)的增量。这些增量补丁文件将被额外压缩以便交付。</p><h2 id="0838" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">设备上的大小</h2><p id="c949" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">棉花糖在设备上的总尺寸将比大<strong class="ir ht">小。但是，旧的Android版本不能识别android:extractNativeLibs标志，并且总是复制出。所以文件。由于使用这种技术而浪费的额外空间量是压缩和未压缩之间的差异。所以归档吧。</strong></p></div></div>    
</body>
</html>