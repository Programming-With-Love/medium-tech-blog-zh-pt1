<html>
<head>
<title>Effective Kotlin: Prefer Sequence for big collections with more than one processing step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Effective Kotlin:对于具有多个处理步骤的大集合，首选序列</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf?source=collection_archive---------1-----------------------#2018-05-14">https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf?source=collection_archive---------1-----------------------#2018-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/27cc1e4967b79c221644db2e75f5f1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N07Drb_JIyv-RuqGM_ugfw.jpeg"/></div></div></figure><div class=""/><p id="8560" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是<a class="ae kt" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank">有效的科特林书</a>的一部分。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://kt.academy/book"><div class="gh gi ku"><img src="../Images/56fe36430f5dfa2ed144c5425f96c2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1uvVX7ObbmLbb__N9eBKw.png"/></div></a></figure><p id="3598" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">人们经常会忽略<code class="fe kz la lb lc b">Iterable</code>和<code class="fe kz la lb lc b">Sequence</code>的区别。这是可以理解的，因为它们的定义几乎完全相同:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="829e" class="lh li iy lc b gy lj lk l ll lm"><strong class="lc iz">interface </strong>Iterable&lt;<strong class="lc iz">out </strong>T&gt; {<br/>    <strong class="lc iz">operator fun </strong>iterator(): Iterator&lt;T&gt;<br/>}</span><span id="9238" class="lh li iy lc b gy ln lk l ll lm"><strong class="lc iz">interface </strong>Sequence&lt;<strong class="lc iz">out </strong>T&gt; {<br/>    <strong class="lc iz">operator fun </strong>iterator(): Iterator&lt;T&gt;<br/>}</span></pre><p id="fa9b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以说它们之间唯一形式上的区别就是名字。虽然<code class="fe kz la lb lc b">Iterable</code>和<code class="fe kz la lb lc b">Sequence</code>与完全不同的用法相关联(具有不同的契约)，所以它们几乎所有的处理功能都以不同的方式工作。<code class="fe kz la lb lc b">Sequences</code>很懒，所以用于<code class="fe kz la lb lc b">Sequence</code>处理的中间函数不做任何计算。相反，它们返回一个新的<code class="fe kz la lb lc b">Sequence</code>,用新的操作修饰前一个。所有这些计算都在类似<code class="fe kz la lb lc b">toList</code>或<code class="fe kz la lb lc b">count</code>的终端操作中进行评估。另一方面，Iterable processing在每一步都返回一个类似于<code class="fe kz la lb lc b">List</code>的集合。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="f73a" class="lh li iy lc b gy lj lk l ll lm">public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(<br/>   predicate: (T) -&gt; Boolean<br/>): List&lt;T&gt; {<br/>   return filterTo(ArrayList&lt;T&gt;(), predicate)<br/>}</span><span id="f8ca" class="lh li iy lc b gy ln lk l ll lm">public fun &lt;T&gt; Sequence&lt;T&gt;.filter(<br/>   predicate: (T) -&gt; Boolean<br/>): Sequence&lt;T&gt; {<br/>   return FilteringSequence(this, true, predicate)<br/>}</span></pre><blockquote class="lo"><p id="cbd8" class="lp lq iy bd lr ls lt lu lv lw lx ks dk translated"><code class="fe kz la lb lc b">Sequence filter</code>是一个中间操作，所以它不做任何计算，而是用新的处理步骤修饰序列。计算在类似<code class="fe kz la lb lc b">toList</code>的终端操作中完成。</p></blockquote><p id="5d48" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">因此，集合处理操作一旦被使用就会被调用。<code class="fe kz la lb lc b">Sequence </code>处理功能直到终端操作(返回除<code class="fe kz la lb lc b">Sequence</code>以外的其他内容的操作)才被调用。例如，对于<code class="fe kz la lb lc b">Sequence</code>，<code class="fe kz la lb lc b">filter</code>是一个中间操作，所以它不做任何计算，而是用新的处理步骤来修饰序列。计算在类似<code class="fe kz la lb lc b">toList</code>的终端操作中完成。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi md"><img src="../Images/98facd20d43e83a553980155e1c06e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-RusFxfTLCnd_6c9T7FSw.png"/></div></div></figure><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="72a8" class="lh li iy lc b gy lj lk l ll lm">val seq = sequenceOf(1,2,3)<br/>val filtered = seq.filter { print("f$it "); it % 2 == 1 }<br/>println(filtered)  // FilteringSequence@...</span><span id="10f0" class="lh li iy lc b gy ln lk l ll lm">val asList = filtered.toList() // f1 f2 f3<br/>println(asList) // [1, 3]</span><span id="1389" class="lh li iy lc b gy ln lk l ll lm">val list = listOf(1,2,3)<br/>val listFiltered = list<br/>  .filter { print("f$it "); it % 2 == 1 } // f1 f2 f3<br/>println(listFiltered) // [1, 3]</span></pre><p id="e500" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin中，序列是惰性的，这有几个重要的优点:</p><ul class=""><li id="4577" class="me mf iy jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">它们保持自然的操作顺序</li><li id="3dfa" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">他们做最少的手术</li><li id="9b44" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">它们可以是无限的</li><li id="76b9" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">他们不需要在每一步都创建集合</li></ul><p id="b14a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面就一个一个的说说那些优势吧。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://learningdriven.fun/"><div class="gh gi ms"><img src="../Images/6755245656f3be202e1b99349aba4423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS3hpI-naOu-GxrgpBSyDQ.png"/></div></a></figure><h2 id="5e83" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">秩序很重要</h2><p id="7827" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">由于iterable和sequence处理的实现方式不同，它们的操作顺序也不同。在序列处理中，我们获取第一个元素并应用所有操作，然后获取下一个元素，依此类推。我们将称之为逐元素或懒惰顺序。在可迭代处理中，我们采用第一个操作，并将其应用于整个集合，然后移动到下一个操作，依此类推..我们称之为循序渐进或急切订单。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="db68" class="lh li iy lc b gy lj lk l ll lm">sequenceOf(1,2,3)<br/>       .filter { print("F$it, "); it % 2 == 1 }<br/>       .map { print("M$it, "); it * 2 }<br/>       .forEach { print("E$it, ") } // Prints: F1, M1, E2, F2, F3, M3, E6,</span><span id="277e" class="lh li iy lc b gy ln lk l ll lm">listOf(1,2,3)<br/>       .filter { print("F$it, "); it % 2 == 1 }<br/>       .map { print("M$it, "); it * 2 }<br/>       .forEach { print("E$it, ") } // Prints: F1, F2, F3, M1, M3, E2, E6,</span></pre><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi np"><img src="../Images/04d0821320d9c6e80bb219a06a24cb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOU6EpfI_Mu48GveIdx3nQ.png"/></div></div></figure><p id="3396" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，如果我们要在没有任何集合处理函数的情况下实现这些操作，而是使用传统的循环和条件，我们将像在序列处理中一样，对元素进行逐个排序:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="e5a6" class="lh li iy lc b gy lj lk l ll lm">for (e in listOf(1,2,3)) {<br/>   print("F$e, ")<br/>   if(e % 2 == 1) {<br/>       print("M$e, ")<br/>       val mapped = e * 2<br/>       print("E$mapped, ")<br/>   }<br/>}<br/>// Prints: F1, M1, E2, F2, F3, M3, E6,</span></pre><p id="e5e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在序列处理中使用的逐个元素的顺序更加自然。它还为低级编译器优化打开了大门——序列处理可以针对基本循环和条件进行优化。也许在未来，它会是。</p><h2 id="f3c3" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">序列执行最少的操作</h2><p id="01fd" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">通常，我们不需要在每一步都处理整个集合来产生结果。假设我们有一个集合，有几百万个元素，经过处理后，只需要取前10个。为什么要处理所有其他元素？Iterable处理没有中间操作的概念，所以整个集合被处理，就好像它将在每个操作中被返回一样。序列不需要这样做，因此它们将执行获得结果所需的最少数量的操作。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nq"><img src="../Images/312d6eb7da83e39c9332b0b7efdbc5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihe141Wbe9YHcebtCrpgTg.png"/></div></div></figure><p id="855d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看这个例子，我们有几个处理步骤，我们用<code class="fe kz la lb lc b">find</code>结束我们的处理:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="d74d" class="lh li iy lc b gy lj lk l ll lm">(1..10).asSequence()<br/>   .filter { print("F$it, "); it % 2 == 1 }<br/>   .map { print("M$it, "); it * 2 }<br/>   .find { it &gt; 5 }<br/>// Prints: F1, M1, F2, F3, M3,</span><span id="aeb9" class="lh li iy lc b gy ln lk l ll lm">(1..10)<br/>   .filter { print("F$it, "); it % 2 == 1 }<br/>   .map { print("M$it, "); it * 2 }<br/>   .find { it &gt; 5 }<br/>// Prints: F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, M1, M3, M5, M7, M9,</span></pre><p id="2612" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我们有一些中间处理步骤，并且我们的终端操作不一定需要迭代所有元素时，使用序列很可能对您的处理性能更好。所有这些看起来与标准的收集处理几乎相同。这种操作的例子有<code class="fe kz la lb lc b">first</code>、<code class="fe kz la lb lc b">find</code>、<code class="fe kz la lb lc b">take</code>、<code class="fe kz la lb lc b">any</code>、<code class="fe kz la lb lc b">all</code>、<code class="fe kz la lb lc b">none</code>或<code class="fe kz la lb lc b">indexOf</code>。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://kt.academy/"><div class="gh gi ms"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h2 id="22e0" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">序列可以是无限的</h2><p id="f20e" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">感谢序列按需处理的事实，我们可以拥有无限的序列。创建无限序列的典型方法是使用像<code class="fe kz la lb lc b">generateSequence</code>或<code class="fe kz la lb lc b">sequence</code>这样的序列发生器。第一个需要第一个元素和一个指定如何计算下一个元素的函数:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="4aff" class="lh li iy lc b gy lj lk l ll lm">generateSequence(1) { it + 1 }<br/>       .map { it * 2 }<br/>       .take(10)<br/>       .forEach { print("$it, ") }<br/>// Prints: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,</span></pre><p id="ffd3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个提到的序列生成器——<code class="fe kz la lb lc b">sequence</code>——使用一个暂停函数(协程)按需生成下一个数字。每当我们请求下一个数字时，序列生成器就会运行，直到使用<code class="fe kz la lb lc b">yield</code>产生一个值。然后执行停止，直到我们要求另一个数字。下面是下一个斐波那契数列的无限列表:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="422f" class="lh li iy lc b gy lj lk l ll lm">val fibonacci = sequence {<br/>   yield(1)<br/>   var current = 1<br/>   var prev = 1<br/>   while (true) {<br/>       yield(current)<br/>       val temp = prev<br/>       prev = current<br/>       current += temp<br/>   }<br/>}</span><span id="4a2e" class="lh li iy lc b gy ln lk l ll lm">print(fibonacci.take(10).toList()) <br/>// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></pre><p id="c81f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，无限序列在某些时候需要有限数量的元素。我们不能在无穷大上迭代。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="231c" class="lh li iy lc b gy lj lk l ll lm">print(fibonacci.toList()) // Runs forever</span></pre><p id="7a2c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们要么需要使用类似<code class="fe kz la lb lc b">take</code>的操作来限制它们，要么需要使用不需要所有元素的终端操作，例如<code class="fe kz la lb lc b">first</code>、<code class="fe kz la lb lc b">find</code>、<code class="fe kz la lb lc b">any</code>、<code class="fe kz la lb lc b">all</code>、<code class="fe kz la lb lc b">none</code>或<code class="fe kz la lb lc b">indexOf</code>。基本上，这些操作都是序列更有效的操作，因为它们不需要处理所有的元素。尽管请注意，对于大多数这些操作，很容易陷入无限循环。<code class="fe kz la lb lc b">any</code>只能返回<code class="fe kz la lb lc b">true</code>或者永远运行。类似地,<code class="fe kz la lb lc b">all</code>和<code class="fe kz la lb lc b">none</code>只能在无限集合上返回<code class="fe kz la lb lc b">false</code>。因此，我们通常要么通过<code class="fe kz la lb lc b">take</code>限制元素的数量，要么使用<code class="fe kz la lb lc b">first</code>只要求第一个元素。</p><h2 id="300f" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">序列不会在每个处理步骤都创建集合</h2><p id="9f84" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">标准集合处理函数在每一步都返回一个新的集合。最常见的是一个<code class="fe kz la lb lc b">List</code>。这可能是一个优势——在每一点之后，我们都有一些东西可以使用或储存。但这是有代价的。每一步都需要创建这样的集合并用数据填充。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="069e" class="lh li iy lc b gy lj lk l ll lm">numbers<br/>   .filter { it % 10 == 0 } // 1 collection here<br/>   .map { it * 2 } // 1 collection here<br/>   .sum() <br/>// In total, 2 collections created under the hood</span><span id="3d18" class="lh li iy lc b gy ln lk l ll lm">numbers<br/>   .asSequence()<br/>   .filter { it % 10 == 0 }<br/>   .map { it * 2 }<br/>   .sum() <br/>// No collections created</span></pre><p id="34cc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个问题，尤其是当我们处理大的或沉重的集合时。让我们从一个极端但常见的例子开始:文件读取。文件可能有千兆字节重。在每个处理步骤中分配集合中的所有数据将是对内存的巨大浪费。这就是为什么默认情况下我们使用序列来处理文件。</p><p id="6a4e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个例子，让我们分析一下芝加哥市的犯罪。这座城市，像许多其他城市一样，在互联网上共享了自2001年以来发生在那里的所有犯罪的数据库(你可以在www.data.cityofchicago.org<a class="ae kt" href="http://www.data.cityofchicago.org" rel="noopener ugc nofollow" target="_blank">的</a>找到这个数据库)。该数据集目前超过1.53 GB。假设我们的任务是找出有多少犯罪描述中有大麻。这是一个使用集合处理的简单解决方案的样子(<code class="fe kz la lb lc b">readLines</code>返回<code class="fe kz la lb lc b">List&lt;String&gt;</code>):</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="0bff" class="lh li iy lc b gy lj lk l ll lm">// BAD SOLUTION, DO NOT USE COLLECTIONS FOR <br/>// POSSIBLY BIG FILES<br/>File("ChicagoCrimes.csv").readLines()<br/>   .drop(1) // Drop descriptions of the columns<br/>   .mapNotNull { it.split(",").getOrNull(6) } <br/>    // Find description<br/>   .filter { "CANNABIS" in it } <br/>   .count()<br/>   .let(::println)</span></pre><p id="a40a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我电脑上的结果是<code class="fe kz la lb lc b">OutOfMemoryError</code>。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="0dac" class="lh li iy lc b gy lj lk l ll lm">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></pre><p id="5c25" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">难怪。我们创建一个集合，然后我们有3个中间处理步骤，总共4个集合。其中3个包含该数据文件的大部分，需要1.53 GB，因此它们都需要消耗4.59 GB以上。这是对内存的巨大浪费。正确的实现应该包括使用一个序列，我们使用函数<code class="fe kz la lb lc b">useLines</code>来实现，它总是在一行上操作:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="27c1" class="lh li iy lc b gy lj lk l ll lm">File("ChicagoCrimes.csv").useLines { lines -&gt;<br/>// The type of `lines` is Sequence&lt;String&gt;<br/>   lines<br/>       .drop(1) // Drop descriptions of the columns<br/>       .mapNotNull { it.split(",").getOrNull(6) } <br/>       // Find description<br/>       .filter { "CANNABIS" in it } <br/>       .count()<br/>       .let { println(it) } // 318185</span></pre><p id="dbce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了比较两种方法的效率，我做了另一个实验，通过删除我不需要的列来减小数据集的大小。通过这种方式，我实现了CrimeData.csv文件，其中包含相同的罪行，但大小只有728 MB。然后我做了同样的处理。在第一个实现中，使用集合处理，大约需要13秒；而第二个，使用序列，大约4.5s。正如你所看到的，对较大的文件使用序列不仅是为了内存，也是为了性能。</p><p id="3ebc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然一个集合不需要很重。事实上，在每一个步骤中，我们都在创建一个新的集合，这本身也是一种成本，当我们处理具有大量元素的集合时，这种成本就会显现出来。差别并不大——主要是因为经过许多步骤后创建的集合被初始化为预期的大小，所以当我们添加元素时，我们只需将它们放在下一个位置。这种差异仍然很大，这也是为什么我们应该<strong class="jx iz">更喜欢对具有多个处理步骤</strong>的大集合使用Sequence的主要原因。</p><p id="d431" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我说的“大收藏”指的是很多元素和非常重的收藏。它可能是一个包含数万个元素的整数列表。它也可能是一个只有几个字符串的列表，但是每个字符串都很长，以至于它们都需要很多兆字节的数据。这些情况并不常见，但有时会发生。</p><p id="d4cb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于一个处理步骤，我指的是不止一个用于集合处理的函数。所以如果你比较这两个函数:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="0b3d" class="lh li iy lc b gy lj lk l ll lm">fun singleStepListProcessing(): List&lt;Product&gt; {<br/>   return productsList.filter { it.bought }<br/>}</span><span id="b084" class="lh li iy lc b gy ln lk l ll lm">fun singleStepSequenceProcessing(): List&lt;Product&gt; {<br/>   return productsList.asSequence()<br/>           .filter { it.bought }<br/>           .toList()<br/>}</span></pre><p id="6a9f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到性能几乎没有差别(实际上简单的列表处理更快，因为它的<code class="fe kz la lb lc b">filter</code>函数是内联的)。虽然当您比较具有多个处理步骤的函数时，比如下面的函数，它们使用了<code class="fe kz la lb lc b">filter</code>和<code class="fe kz la lb lc b">map</code>，但是对于更大的集合来说，这种差异是显而易见的。为了看出区别，让我们比较一下5000种产品的典型加工与两个和三个加工步骤:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="5270" class="lh li iy lc b gy lj lk l ll lm">fun twoStepListProcessing(): List&lt;Double&gt; {<br/>   return productsList<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>}</span><span id="c6e4" class="lh li iy lc b gy ln lk l ll lm">fun twoStepSequenceProcessing(): List&lt;Double&gt; {<br/>   return productsList.asSequence()<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>           .toList()<br/>}</span><span id="0e2f" class="lh li iy lc b gy ln lk l ll lm">fun threeStepListProcessing(): Double {<br/>   return productsList<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>           .average()<br/>}</span><span id="423c" class="lh li iy lc b gy ln lk l ll lm">fun threeStepSequenceProcessing(): Double {<br/>   return productsList.asSequence()<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>           .average()<br/>}</span></pre><p id="353d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面你可以看到在MacBook Pro(处理器2.6 GHz英特尔酷睿i7，内存16 GB 1600 MHz DDR3)上对5000个产品的平均结果<code class="fe kz la lb lc b">productsList</code>:</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="37c9" class="lh li iy lc b gy lj lk l ll lm">twoStepListProcessing                        81 095 ns<br/>twoStepSequenceProcessing                    55 685 ns<br/>twoStepListProcessingAndAcumulate            83 307 ns<br/>twoStepSequenceProcessingAndAcumulate         6 928 ns</span></pre><p id="df95" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很难预测我们应该期待什么样的性能改进。根据我的观察，在包含多个步骤的典型集合处理中，对于至少几千个元素，我们可以预期大约20–40%的性能提升。</p><h2 id="353c" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">什么时候序列不是更快？</h2><p id="6167" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">在一些操作中，我们不能从序列的使用中获益，因为我们必须对整个集合进行操作。<code class="fe kz la lb lc b">sorted</code>是Kotlin stdlib中的一个例子(目前是唯一的例子)。<code class="fe kz la lb lc b">sorted</code>使用最佳实现:它将<code class="fe kz la lb lc b">Sequence</code>累积到<code class="fe kz la lb lc b">List</code>中，然后使用Java stdlib中的<code class="fe kz la lb lc b">sort</code>。缺点是，如果我们将其与在<code class="fe kz la lb lc b">Collection</code>上的相同处理进行比较，这个累加过程需要一些额外的时间(尽管如果Iterable不是一个<code class="fe kz la lb lc b">Collection</code>或数组，那么差异并不显著，因为它也需要被累加)。</p><p id="2ffa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<code class="fe kz la lb lc b">Sequence</code>应该有类似于<code class="fe kz la lb lc b">sorted</code>的方法，这是有争议的，因为具有要求所有元素计算下一个元素的方法的序列只是部分懒惰的(当我们需要获得第一个元素时进行评估),并且不适用于无限序列。添加它是因为它是一个受欢迎的功能，并且以这种方式使用它要容易得多。尽管Kotlin开发人员应该记得它的缺陷，尤其是它不能用于无限序列。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="161a" class="lh li iy lc b gy lj lk l ll lm">generateSequence(0) { it + 1 }.take(10).sorted().toList() <br/>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br/>generateSequence(0) { it + 1 }.sorted().take(10).toList() <br/>// Infinite time. Does not return.</span></pre><p id="32a6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">sorted</code>是<code class="fe kz la lb lc b">Collection</code>比<code class="fe kz la lb lc b">Sequence</code>更快的加工步骤的一个罕见例子。尽管如此，当我们执行一些处理步骤和单个排序函数(或者其他需要在整个集合上工作的函数)时，我们可以期待使用序列处理来提高性能。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="7fb3" class="lh li iy lc b gy lj lk l ll lm">// Benchmarking measurement result: 150 482 ns<br/>fun productsSortAndProcessingList(): Double {<br/>   return productsList<br/>           .sortedBy { it.price }<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>           .average()<br/>}</span><span id="9f94" class="lh li iy lc b gy ln lk l ll lm">// Benchmarking measurement result: 96 811 ns<br/>fun productsSortAndProcessingSequence(): Double {<br/>   return productsList.asSequence()<br/>           .sortedBy { it.price }<br/>           .filter { it.bought }<br/>           .map { it.price }<br/>           .average()<br/>}</span></pre><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi ms"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h2 id="8720" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">Java流呢？</h2><p id="b24f" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">Java 8引入了流来支持集合处理。它们的行为和外观与科特林序列相似。</p><pre class="kv kw kx ky gt ld lc le lf aw lg bi"><span id="8f6a" class="lh li iy lc b gy lj lk l ll lm">productsList.asSequence()<br/>       .filter { it.bought }<br/>       .map { it.price }<br/>       .average()</span><span id="95c2" class="lh li iy lc b gy ln lk l ll lm">productsList.stream()<br/>       .filter { it.bought }<br/>       .mapToDouble { it.price }<br/>       .average()<br/>       .orElse(0.0)</span></pre><p id="0682" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java 8流是懒惰的，在最后(终端)处理步骤中收集。Java流和Kotlin序列之间的三大区别如下:</p><ul class=""><li id="d875" class="me mf iy jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">Kotlin序列有更多的处理函数(因为它们被定义为扩展函数),并且它们通常更容易使用(这是因为Kotlin序列是在Java流已经被使用时设计的——例如，我们可以使用<code class="fe kz la lb lc b">toList()</code>而不是<code class="fe kz la lb lc b">collect(Collectors.toList())</code>来收集)</li><li id="0b59" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">Java流处理可以使用并行函数在并行模式下启动。当我们拥有一台拥有多个经常未使用的内核的机器时(这在当今很常见)，这可以给我们带来巨大的性能提升。尽管要小心使用，因为这个特性有已知的缺陷(问题来自他们使用的公共join-fork线程池。因此，一个进程可能会阻塞另一个进程。还有一个问题是单个元素处理会阻塞其他元素。点击这里了解更多:【https://dzone.com/articles/think-twice-using-java-8<a class="ae kt" href="https://dzone.com/articles/think-twice-using-java-8" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="e3c1" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">Kotlin序列可用于通用模块、Kotlin/JVM、Kotlin/JS和Kotlin/Native模块。Java流只能在Kotlin/JVM中传输，并且只能在JVM版本至少为8时传输。</li></ul><p id="fdd9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，当我们不使用并行模式时，很难给出一个简单的答案，Java流和Kotlin序列哪个效率更高。我的建议是很少使用Java流，只在计算量大的处理中使用，这样可以从并行模式中获益。否则，使用Kotlin stdlib函数来获得一个可以在不同平台或公共模块上使用的同构且干净的代码。</p><h2 id="5455" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">科特林序列调试</h2><p id="895c" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">Kotlin Sequence和Java Stream都支持帮助我们调试每一步的元素流。对于Java流，它需要一个名为“Java流调试器”的插件。Kotlin Sequences也需要名为“Kotlin Sequence Debugger”的插件，尽管现在这个功能已经集成到Kotlin插件中。以下屏幕显示了每个步骤的序列处理:</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/539b690f4538419e1f91e83a5a31492d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y81fLS3QA7wpElomnE7fiw.png"/></div></div></figure><h2 id="9d7f" class="lh li iy bd mt mu mv dn mw mx my dp mz kg na nb nc kk nd ne nf ko ng nh ni nj bi translated">摘要</h2><p id="89a5" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">集合和序列处理非常相似，都支持几乎相同的处理方法。然而，这两者之间有着重要的区别。序列处理更难，因为我们通常将元素保存在集合中，因此更改集合需要转换到序列，并且通常还需要转换回所需的集合。序列是懒惰的，这带来了一些重要的优势:</p><ul class=""><li id="3f83" class="me mf iy jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">它们保持自然的操作顺序</li><li id="4022" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">他们做最少的手术</li><li id="331d" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">它们可以是无限的</li><li id="9f5c" class="me mf iy jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">他们不需要在每一步都创建集合</li></ul><p id="b656" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，它们更适合处理较重的物体或具有多个处理步骤的较大集合。Kotlin Sequence Debugger也支持序列，它可以通过可视化元素的处理方式来帮助我们。序列不能取代经典的集合处理。您应该只在有充分理由的时候才使用它们，并且您将获得显著的性能优化。</p><h1 id="d0a6" class="ns li iy bd mt nt nu nv mw nw nx ny mz nz oa ob nc oc od oe nf of og oh ni oi bi translated">有效科特林</h1><p id="2643" class="pw-post-body-paragraph jv jw iy jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">这是关于有效科特林的第三篇文章。当我们看到兴趣，我们将出版下一部分。在卡帕头。学院我们也在研究关于这个主题的书:</p><div class="im in gp gr io oj"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iz gy z fp oo fr fs op fu fw ix bi translated">有效科特林</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这本书对官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">leanpub.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox iu oj"/></div></div></a></div><p id="c48d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并使我们更快地发布它，<a class="ae kt" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用此链接并订阅</a>。</p></div><div class="ab cl oy oz hr pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ig ih ii ij ik"><p id="ccff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae kt" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="1fa6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kt" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Twitter上引用我，用<a class="ae kt" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。使用以下链接订阅时事通讯:</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ms"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx iz">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p></div></div>    
</body>
</html>