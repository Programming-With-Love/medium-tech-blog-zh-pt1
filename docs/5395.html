<html>
<head>
<title>Oracle Offline Persistence Toolkit — Simple GET Response Example with JET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle离线持久性工具包—使用JET的简单GET响应示例</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracle-offline-persistence-toolkit-simple-get-response-example-with-jet-d98580783ac3?source=collection_archive---------0-----------------------#2018-01-28">https://medium.com/oracledevs/oracle-offline-persistence-toolkit-simple-get-response-example-with-jet-d98580783ac3?source=collection_archive---------0-----------------------#2018-01-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2a16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有来自Oracle的新工具，可以帮助简化JS应用程序的离线逻辑实现。在这篇文章中，我将介绍如何在Oracle JET中使用Oracle离线持久性工具包。然而离线持久性并不仅仅局限于JET的使用，这个工具包可以在NPM上获得，并且可以与其他JS解决方案集成。</p><p id="1105" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我应该强调——离线工具包的主要作用是让移动混合应用能够离线工作。在我看来，工具包的使用不止于此。当互联网连接可用，但后端服务器关闭时，它可以使用户继续工作。从技术上讲，在这种情况下，用户将保持在线，但实际上应用程序将被中断——后端对REST调用没有响应。离线持久性工具包可以帮助解决这种情况——用户可以继续使用本地缓存，直到后端关闭。</p><p id="4eb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想了解offline toolkit如何工作以及如何使用其API，请前往<a class="ae jc" href="https://github.com/oracle/offline-persistence-toolkit" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a> —查看readme，将其添加到你的JET应用程序，并尝试运行/测试。实践是学习新事物的最好方式。</p><p id="e880" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将分享一些提示和样本应用程序。</p><p id="f9b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据readme，首先您应该添加来自NPM的离线持久性工具包和PouchDB模块。在JET应用程序目录中运行以下命令:</p><ol class=""><li id="c9e9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">npm安装@ Oracle/offline-persistence-toolkit</li></ol><p id="3134" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.npm安装pouchdb pouchdb-查找</p><p id="8935" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，您应该遵循四个简单的配置步骤，并使JET app能够访问离线工具包API。</p><p id="8941" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤1 </strong>(标准，添加任何附加模块时)</p><p id="bc45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"> main.js </strong>中添加新添加模块的路径需要块:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/1f32bb5c79d6692ebd21bbf9c02a9108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DFvm087tguPk322sKgU7Q.png"/></div></div></figure><p id="f37c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤2 </strong>(标准，添加任何附加模块时)</p><p id="d57c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"> main-release-paths.js </strong>中添加新添加模块的路径:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jy"><img src="../Images/964f681153b45113a2466722901ec96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGy03tBWHPvQE2MRpZCMfg.png"/></div></div></figure><p id="28b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤3 </strong>(标准，添加任何附加模块时)</p><p id="6cf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">添加的模块不会被自动复制到构建目录。我们需要在<strong class="ig hi"> oraclejet-build.js </strong>中定义复制。模块应该转到构建目录。如果您需要从给定的文件夹和子文件夹中复制文件，请使用** for src:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/f83cb3daee1ba9cbf038dc08baf582db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAUvynxjKNUH4Okx5ORNoQ.png"/></div></div></figure><p id="396c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">构建内容位于<strong class="ig hi"> web </strong>目录下。离线工具包和PouchDB模块应复制到构建目录:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ka"><img src="../Images/de54b0fa5bec5d5c4c705840d36bea6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*0iiUKXhRuYQ5K_04ONUDPw.png"/></div></figure><p id="29e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤4 </strong>初始化窗口。main.js中的PouchDB变量:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/978e6256f224a7cd6acf7d01f00d1354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IOjAXep4dJolfeLWbe3jA.png"/></div></div></figure><p id="b66c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">配置已经完成，现在我们可以使用离线持久性工具包API了。添加持久性存储管理器和其他模块:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/1baef70e6fbf96803cf8a42fa1235650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DIC0dX5LDgz8CaWfqiD8w.png"/></div></div></figure><p id="c445" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最简单的选择是依赖离线工具包中的默认获取监听器。我们需要注册存储工厂，并映射我们希望用持久性管理器缓存的端点。当后端可用时—调用将转到后端，响应将被缓存。下一次，后端不可用—将从缓存中提取数据。如果端点被配置为监听，则工具包会拦截HTTP(-S)请求并存储响应:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/6f526b51a6070e0680a3211f7c950620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kA7bp1OH3QXyh3mzr2uWw.png"/></div></div></figure><p id="c668" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我正在用JET的简单员工休息端点调用测试离线工具包。工具包允许成功执行这个调用，即使没有后端或连接(当然，如果相同的调用以前至少执行过一次):</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/ad0c0a7f0ff23d847e2ced7e246de4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7CtpaGO3IweSPgknhiQWQ.png"/></div></div></figure><p id="ee91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">UI部分很简单——读取数据时显示列表:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kf"><img src="../Images/e471a76b403da30ae47875e8123d46f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ep3rIPmV2yHscq2hSm22Rw.png"/></div></div></figure><p id="65dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据已获取，我们在线:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kg"><img src="../Images/7240fd95cc4cb5dc8e36e93fac3ae593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0ZUaht9EjzekAIo8Dhlfg.png"/></div></div></figure><p id="1b25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果REST响应不包括Cache-Control头，离线工具包将工作。确保在响应中没有设置缓存控制头:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kh"><img src="../Images/1a7c7bb59b46f65581d4f640751c44f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*GtMttwyKZrCydhM_c4O1AA.png"/></div></figure><p id="bfca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ADF BC REST默认设置缓存控制头，您可以在过滤器类中删除它(在ADF BC REST应用程序中定义):</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ki"><img src="../Images/cd57426613032c79954efd9e6042ebcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YN6VauJSTIi6-1ZPwzo-FQ.png"/></div></div></figure><p id="1b66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我将我的连接转为离线，单击Get List按钮— JS调用REST，没有出现网络错误，而是成功执行，并通过离线工具包功能从缓存中返回数据:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kj"><img src="../Images/863c24dc00e40220fc65f9b323f8b328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3-Pbm3mpKtyDpMC-d3p3g.png"/></div></div></figure><p id="0089" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您应该打开网络呼叫的详细信息并检查发起方。您将看到所有映射到离线端点的调用都通过persistenceManager.js:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kk"><img src="../Images/123cfadc72d3af7c30f03da2f909251d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*XXel9HXlgYuzdB3QQHQxZw.png"/></div></figure><p id="e9b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们再核实一下——也许我们被骗了？删除代码中的离线工具包注册API，然后重新运行应用程序:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kl"><img src="../Images/98b83b25421e08e20ca52135c5e558a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cpy5dPBc4-Mn8lFJ0gmAEg.png"/></div></div></figure><p id="7e94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如预期—收到网络错误，提取失败。这证明了—离线工具包有效:)</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es km"><img src="../Images/c388bdf331bfe27bf0c2066a5db3aa70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geQG3WDyDkq_Gq9Gyutrtw.png"/></div></div></figure><p id="2bcb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/persistencejetapp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上可以获得带有离线工具包配置的示例JET应用程序(运行<em class="kn"> ojet恢复</em>和<em class="kn"> ojet服务</em>)。</p></div><div class="ab cl ko kp go kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ha hb hc hd he"><p id="8002" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kn">原载于2018年1月28日</em><a class="ae jc" href="https://andrejusb.blogspot.lt/2018/01/oracle-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank"><em class="kn">andrejusb.blogspot.com</em></a><em class="kn">。</em></p></div></div>    
</body>
</html>