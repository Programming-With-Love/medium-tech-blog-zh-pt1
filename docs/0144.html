<html>
<head>
<title>ts-migrate: A Tool for Migrating to TypeScript at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ts-migrate:大规模迁移到TypeScript的工具</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/ts-migrate-a-tool-for-migrating-to-typescript-at-scale-cd23bfeb5cc?source=collection_archive---------0-----------------------#2020-08-18">https://medium.com/airbnb-engineering/ts-migrate-a-tool-for-migrating-to-typescript-at-scale-cd23bfeb5cc?source=collection_archive---------0-----------------------#2020-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b82e2119dfbe1086032931fdcb3ceee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoJ8oPWhp2gr7CIGQPDqLA.jpeg"/></div></div></figure><p id="221d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">TypeScript是Airbnb前端web开发的官方语言。然而，采用TypeScript和迁移包含数千个JavaScript文件的成熟代码库的过程并不是一天就能完成的。TypeScript的采用经历了最初的提议、多个团队的采用、测试阶段以及最终作为Airbnb前端开发的官方语言的过程。在Brie Bunge 的这个<a class="ae jn" href="https://www.youtube.com/watch?v=P-J9Eg7hJwE" rel="noopener ugc nofollow" target="_blank">演讲中，你可以了解更多关于我们如何大规模采用TypeScript的信息。</a></p><h1 id="2eef" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">迁移策略</h1><p id="3054" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">大规模迁移是一项复杂的任务，我们探索了从JavaScript迁移到TypeScript的几种选择:</p><p id="dd26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 1)混合迁移策略。</strong>逐个文件地部分迁移，修复类型错误，并重复直到整个项目被迁移。<a class="ae jn" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs" rel="noopener ugc nofollow" target="_blank"> <em class="kr"> allowJS </em> </a> config选项允许我们让TypeScript和JavaScript文件在项目中并存，这使得这种方法成为可能！</p><p id="de58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在混合迁移策略中，我们不必暂停开发，可以一个文件一个文件地逐步迁移。虽然，在大范围内，这个过程可能需要很长时间。此外，还需要对来自组织不同部门的工程师进行培训。</p><p id="4139" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2)全进迁移！</strong>取一个JavaScript或部分TypeScript项目，完全转换。我们需要添加一些<code class="du ks kt ku kv b">any</code>类型和<code class="du ks kt ku kv b">@ts-ignore</code>注释，这样项目编译时不会出错，但是随着时间的推移，我们可以用更具描述性的类型来替换它们。</p><p id="cc5d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选择全方位迁移策略有几大优势:</p><ul class=""><li id="0bcd" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated"><strong class="ir hi">跨项目的一致性:</strong>完全迁移将保证每个文件的状态都是相同的，工程师不需要记住他们可以在哪里使用TypeScript特性，以及编译器将在哪里防止基本错误。</li><li id="a267" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><strong class="ir hi">只修复一种类型比修复文件容易得多:</strong>修复整个文件可能非常复杂，因为文件可能有多个依赖项。对于混合迁移，更难跟踪迁移的实际进度和文件的状态。</li></ul><p id="1e89" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来全包迁移是这里的明显赢家！但是执行大型成熟代码库的整体迁移的过程是一个沉重而复杂的问题。为了解决这个问题，我们决定使用代码修改脚本— <a class="ae jn" rel="noopener" href="/@cpojer/effective-javascript-codemods-5a6686bb46fb"> codemods </a>！通过我们最初的手动迁移到TypeScript的过程，我们认识到可以自动化的重复操作。我们为这些步骤中的每一步制作了codemods，并将它们合并到总体迁移管道中。</p><p id="d046" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据我们的经验，不能100%保证自动迁移会产生一个完全没有错误的项目，但是我们发现下面列出的步骤组合在最终迁移到一个没有错误的TypeScript项目时给了我们最好的结果。通过使用codemods，我们能够在一天之内将包含50，000多行代码和1，000多个文件的项目从JavaScript转换为TypeScript！</p><p id="ba58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于这个管道，我们创建了一个名为“ts-migrate”的工具:</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/84251992436b4850a6143294d7025371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHIAaUc2dL6mrBF1T_H96g.png"/></div></div></figure><p id="de45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Airbnb，我们使用<a class="ae jn" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>作为我们前端代码库的重要部分。这就是为什么codemods的某些部分与基于React的概念相关。ts-migrate可以通过额外的配置和测试与其他框架或库一起使用。</p><h1 id="a7d7" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">迁移过程的步骤</h1><p id="4532" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">让我们浏览一下将项目从JavaScript迁移到TypeScript所需的主要步骤，以及这些步骤是如何实现的:</p><p id="6ab8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)每个TypeScript项目的第一部分是创建一个<code class="du ks kt ku kv b"><a class="ae jn" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" rel="noopener ugc nofollow" target="_blank">tsconfig.json</a></code>文件，如果需要的话，ts-migrate可以完成这项工作。有一个默认的配置文件模板和一个验证检查，帮助我们确保所有项目的配置是一致的。下面是一个基本配置的示例:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ebd4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)一旦<code class="du ks kt ku kv b">tsconfig.json</code>文件就绪，下一步就是将源代码文件的文件扩展名从<code class="du ks kt ku kv b">.js/.jsx</code>更改为<code class="du ks kt ku kv b">.ts/.tsx</code>。这一步的自动化非常容易，并且也消除了大量的手工工作。</p><p id="ab60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)下一步是运行codemods！我们称之为“插件”。ts-migrate的插件是可以通过TypeScript语言服务器访问附加信息的codemods。插件接受一个字符串作为输入，并产生一个更新的字符串作为输出。jscodeshift、TypeScript API、字符串替换或其他AST修改工具可用于增强代码转换。</p><p id="d7e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在每一步之后，我们检查Git历史中是否有任何未决的更改，并提交它们。这有助于将迁移请求拆分成更容易理解的提交，还可以跟踪文件重命名。</p><h1 id="8b52" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">ts-migrate包概述</h1><p id="eecc" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们将ts-migrate分成3个包:</p><ul class=""><li id="4ade" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate" rel="noopener ugc nofollow" target="_blank"> ts-migrate </a></li><li id="777f" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate-server" rel="noopener ugc nofollow" target="_blank"> ts-migrate-server </a></li><li id="f2e8" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate-plugins" rel="noopener ugc nofollow" target="_blank">ts-迁移-插件</a></li></ul><p id="a52d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这样做，我们能够将转换逻辑从核心流道中分离出来，并为不同的目的创建多个配置。目前，我们有两种主要的配置:<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate/cli.ts#L99" rel="noopener ugc nofollow" target="_blank">迁移</a>和<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate/cli.ts#L174" rel="noopener ugc nofollow" target="_blank">重燃</a>。</p><p id="b4d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然迁移配置的目标是从JavaScript迁移到TypeScript，但reignore的目的是通过简单地忽略所有错误来使项目可编译。当一个人有一个大的代码库并且正在执行如下任务时，Reignore是有用的:</p><ul class=""><li id="8a1f" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">升级TypeScript版本</li><li id="d140" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">对代码库进行重大更改或重构</li><li id="6f90" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">改进一些常用库的类型</li></ul><p id="71ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，即使有一些我们不想立即处理的错误，我们也可以迁移项目。它使得类型脚本或库的更新容易得多。</p><p id="909b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两种配置都在ts-migrate-server上运行，该服务器由两部分组成:</p><ul class=""><li id="5ba5" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/forkTSServer.ts" rel="noopener ugc nofollow" target="_blank"> TSServer </a>:这部分非常类似于VSCode编辑器<a class="ae jn" href="https://github.com/Microsoft/vscode/blob/dfafad3a00f02469b644c76613d08716b8b31d8d/extensions/typescript-language-features/src/tsServer/server.ts#L139" rel="noopener ugc nofollow" target="_blank">为编辑器和语言服务器之间的通信所做的</a>。TypeScript语言服务器的一个新实例作为一个单独的进程运行，开发工具使用<a class="ae jn" href="https://microsoft.github.io/language-server-protocol/" rel="noopener ugc nofollow" target="_blank">语言协议</a>与服务器通信。</li><li id="0571" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L16" rel="noopener ugc nofollow" target="_blank">迁移运行器</a>:运行并协调迁移过程。它需要以下参数:</li></ul><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="126c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它执行以下操作:</p><ol class=""><li id="fd64" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lr lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L19" rel="noopener ugc nofollow" target="_blank">解析tsconfig.json </a>。</li><li id="8d1a" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lr lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L54" rel="noopener ugc nofollow" target="_blank">创造。ts源文件</a>。</li><li id="4bbc" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lr lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L103" rel="noopener ugc nofollow" target="_blank">将每个文件</a>发送到TypeScript语言服务器进行诊断。编译器为我们提供了三种类型的诊断:<code class="du ks kt ku kv b">semanticDiagnostics</code>、<code class="du ks kt ku kv b">syntacticDiagnostics</code>和<code class="du ks kt ku kv b">suggestionDiagnostics</code>。我们使用这些诊断来寻找源代码中有问题的地方。根据唯一的诊断代码和行号，我们可以确定问题的潜在类型，并进行必要的代码修改。</li><li id="cd07" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lr lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L135" rel="noopener ugc nofollow" target="_blank">运行</a>每个文件上的所有插件。如果文本由于插件执行而改变，我们<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-server/src/migrate/index.ts#L147" rel="noopener ugc nofollow" target="_blank">更新原始文件</a>的内容，并通知TypeScript语言服务器文件已经改变。</li></ol><p id="6f4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src/index.ts#L19" rel="noopener ugc nofollow" target="_blank">示例包</a>或<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate/cli.ts#L96" rel="noopener ugc nofollow" target="_blank">主包</a>中找到ts-migrate-server用法的示例。ts-migrate-example还包含插件的基本<a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src" rel="noopener ugc nofollow" target="_blank">示例。它们分为三大类:</a></p><ul class=""><li id="7a2d" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src/example-plugin-jscodeshift.ts" rel="noopener ugc nofollow" target="_blank">基于jscodeshift的</a></li><li id="228c" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src/example-plugin-ts.ts" rel="noopener ugc nofollow" target="_blank">基于类型脚本抽象语法树(AST)的</a></li><li id="4a6d" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src/example-plugin-text.ts" rel="noopener ugc nofollow" target="_blank">基于文本的</a></li></ul><p id="9520" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">存储库中有一组示例来演示如何构建各种简单的插件，以及如何将它们与ts-migrate-server结合使用。下面是一个示例<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-example/src/index.ts#L18" rel="noopener ugc nofollow" target="_blank">迁移管道</a>，它转换以下代码:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="5ac6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">变成:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="529b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，ts-migrate进行了3次转换:</p><ol class=""><li id="3c76" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lr lc ld le bi translated">反转所有标识符<em class="kr"> </em> <code class="du ks kt ku kv b">first -&gt; tsrif</code></li><li id="92a7" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lr lc ld le bi translated">在函数声明中增加了类型<code class="du ks kt ku kv b">function tlum(tsrif, dnoces) -&gt; function tlum(tsrif: number, dnoces: number): number</code></li><li id="9c5f" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lr lc ld le bi translated">插入<code class="du ks kt ku kv b">console.log(‘args:${arguments}’);</code></li></ol><h1 id="473e" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">通用插件</h1><p id="a135" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">真实世界的插件位于一个单独的包中— <a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate-plugins" rel="noopener ugc nofollow" target="_blank"> ts-migrate-plugins </a>。让我们来看看其中的一些。我们有两个基于jscodeshift的插件:<em class="kr"> explicitAnyPlugin </em>和<em class="kr">declareMissingClassPropertiesPlugin</em>。jscodeshift 是一个使用<a class="ae jn" href="https://github.com/benjamn/recast" rel="noopener ugc nofollow" target="_blank">重铸</a>包将AST转换回字符串的工具。通过使用<code class="du ks kt ku kv b">toSource()</code>函数，我们可以直接更新我们文件的源代码。</p><p id="7462" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/explicit-any.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">explicitAnyPlugin</em></a>背后的主要思想在于从TypeScript语言服务器中提取所有语义诊断错误以及行号。然后，我们需要在诊断中指定的行上添加<code class="du ks kt ku kv b">any</code>类型。这种方法允许我们解决错误，因为添加一个<code class="du ks kt ku kv b">any</code>类型可以修复编译错误。</p><p id="365a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="1622" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="f59b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/declare-missing-class-properties.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">declareMissingClassPropertiesPlugin</em></a>用代码<code class="du ks kt ku kv b">2339</code> ( <a class="ae jn" href="https://github.com/microsoft/TypeScript/blob/20ecbb0f46105ccaead2970f6ef23188955e023e/src/compiler/diagnosticMessages.json#L1348-L1351" rel="noopener ugc nofollow" target="_blank">你能猜出这个代码是什么意思吗？</a>)并且如果它可以找到缺少标识符的类声明，插件将使用<code class="du ks kt ku kv b">any</code>类型注释将它们添加到类体中。从名字就可以看出，这个codemod只适用于<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6类</a>。</p><p id="1117" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一类插件是基于TypeScript AST的插件。通过解析AST，我们可以在源文件中生成以下类型的更新数组:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="577a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生成更新后，剩下的唯一事情就是以相反的顺序应用更改。如果通过这些操作的结果，我们收到新的文本，我们更新源文件。让我们来看几个基于AST的插件:<em class="kr">striptsignorplugin</em>和<em class="kr">hoistClassStaticsPlugin</em>。</p><p id="95ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/strip-ts-ignore.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">stripTSIgnorePlugin</em></a><em class="kr"/>是迁移管道中的第一个插件。它从文件中删除所有的<code class="du ks kt ku kv b">@ts-ignore</code>实例。如果我们将一个JavaScript项目转换成TypeScript，这个插件不会做任何事情。然而，如果是部分TypeScript项目(在Airbnb，我们有几个项目处于这种状态)，这是必不可少的第一步。只有在删除了<code class="du ks kt ku kv b">@ts-ignore</code>注释之后，TypeScript编译器才会发出所有需要解决的诊断错误。</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="e4ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">转化为:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="86c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">移除<code class="du ks kt ku kv b">@ts-ignore</code>注释后，我们运行<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/hoist-class-statics.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">hoistClassStaticsPlugin</em></a>。这个插件检查文件中所有的类声明。它决定我们是否可以提升标识符或表达式，并决定一个赋值是否已经被提升到一个类。</p><p id="e53f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了能够快速迭代并防止回归，我们为每个插件和<a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate-server/tests/commands/migrate" rel="noopener ugc nofollow" target="_blank"> ts-migrate </a>添加了一系列单元测试<a class="ae jn" href="https://github.com/airbnb/ts-migrate/tree/master/packages/ts-migrate-plugins/tests/src" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="ce45" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">React相关插件</h1><p id="e95b" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/react-props.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">reactpropslugin</em></a>将类型信息从PropTypes转换为TypeScript props类型定义。<em class="kr"> </em>基于<a class="ae jn" href="https://twitter.com/mohsen____" rel="noopener ugc nofollow" target="_blank">穆赫森·阿兹米</a>写的牛逼<a class="ae jn" href="https://github.com/lyft/react-javascript-to-typescript-transform" rel="noopener ugc nofollow" target="_blank">工具</a>。我们只需要在包含至少一个React组件的<code class="du ks kt ku kv b">.tsx</code>文件上运行这个插件。<em class="kr"> reactPropsPlugin </em>寻找所有的<code class="du ks kt ku kv b">PropTypes</code>声明，并试图通过使用AST和简单的正则表达式(如<code class="du ks kt ku kv b">/number/</code>)或更复杂的情况(如<code class="du ks kt ku kv b"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/utils/react-props.ts#L237" rel="noopener ugc nofollow" target="_blank">/objectOf$/</a></code>)来解析它们。当一个React组件(无论是函数还是类)被检测到时，它会被转换成一个具有新的props类型的组件:<code class="du ks kt ku kv b">type Props = {…};</code>。</p><p id="b287" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/react-default-props.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">reactDefaultPropsPlugin</em></a>覆盖了React组件的<a class="ae jn" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank"> defaultProps </a>模式。我们使用一种特殊的类型来表示带有默认值的属性:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="1f21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们试图找到默认的props声明，并将它们与上一步生成的组件props类型合并。</p><p id="087e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">状态和生命周期</a>的概念在React生态系统中相当常见。我们在两个插件中解决了它们。如果一个组件是有状态的，<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/react-class-state.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">reactClassStatePlugin</em></a>生成一个新的<code class="du ks kt ku kv b">type State = any;</code>，<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/react-class-lifecycle-methods.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">reactClassLifecycleMethodsPlugin</em></a>用适当的类型标注组件生命周期方法。这些插件的功能可以扩展，包括用更具描述性的类型替换<code class="du ks kt ku kv b">any</code>的能力。</p><p id="6bbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于状态和道具，还有更多改进和更好的类型支持的空间。然而，作为一个起点，这个功能被证明是足够的。我们也不包括<a class="ae jn" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>，因为在移植的开始，我们的代码库使用了React的旧版本。</p><h1 id="3e11" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">确保成功的项目编译</h1><p id="343f" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们的目标是获得一个具有基本类型覆盖的编译TypeScript项目，它不会导致应用程序运行时行为的改变。</p><p id="dbf2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在所有转换和代码修改之后，我们的代码可能会有不一致的格式，一些lint检查可能会失败。我们的前端代码库依赖于更漂亮的eslint设置— <a class="ae jn" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>用于自动格式化代码，而<a class="ae jn" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>确保代码遵循最佳实践。因此，我们可以通过从我们的<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/fe1b6021783b1ef5c4b8fa310b96a44779cc77bd/packages/ts-migrate-plugins/src/plugins/eslint-fix.ts" rel="noopener ugc nofollow" target="_blank">插件</a>运行eslint-appearlier来快速修复前面步骤可能引入的任何格式问题。</p><p id="fcfb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">迁移管道的最后一部分确保解决所有的TypeScript编译冲突。为了检测和修复潜在的错误，<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/e163ea39a8bd62105773625236f9b4098883c4f3/packages/ts-migrate-plugins/src/plugins/ts-ignore.ts" rel="noopener ugc nofollow" target="_blank"><em class="kr">tsIgnorePlugin</em></a>使用行号进行语义诊断，并插入<code class="du ks kt ku kv b">@ts-ignore</code>注释和有用的解释，例如:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="b011" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还增加了对JSX语法的支持:</p><figure class="ll lm ln lo fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="c5c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在注释中包含有意义的错误消息可以更容易地修复问题和重新访问需要注意的代码。这些注释，结合<code class="du ks kt ku kv b">$TSFixMe</code>，允许我们收集关于代码质量的有用数据，并识别潜在的有问题的代码区域。</p><p id="98ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后但同样重要的是，我们需要运行eslint-fix插件两次。一旦在<em class="kr"> tsIgnorePlugin </em>之前给定的格式可能会影响我们将在哪里得到编译器错误。并且再次在<em class="kr"> tsIgnorePlugin、</em>之后，因为插入<code class="du ks kt ku kv b">@ts-ignore</code>注释可能会引入新的格式错误。</p><h1 id="8387" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="e103" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们的迁移故事是一个正在进行的工作:我们有一些仍然在JavaScript中的遗留项目，我们的代码库中仍然有大量的<code class="du ks kt ku kv b">$TSFixMe</code>和<code class="du ks kt ku kv b">@ts-ignore</code>注释。</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/cf44bbe05d4a27c5ee722b79ceeaedd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*92yvYPXXY_QhXuR-"/></div></div></figure><p id="f580" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，使用ts-migrate大大加快了我们的迁移过程和生产效率。工程师能够专注于打字改进，而不是手动逐个文件地迁移。目前，我们600万行前端monorepo的大约86%已经转换为TypeScript，我们有望在今年年底实现95%的转换。</p><p id="2693" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以查看ts-migrate，并在<a class="ae jn" href="https://github.com/airbnb/ts-migrate" rel="noopener ugc nofollow" target="_blank"> Github库</a>的主包中找到关于如何安装和运行ts-migrate的说明。如果您发现任何<a class="ae jn" href="https://github.com/airbnb/ts-migrate/issues" rel="noopener ugc nofollow" target="_blank">问题</a>或有改进的想法，我们欢迎您的<a class="ae jn" href="https://github.com/airbnb/ts-migrate/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">贡献</a>！</p><p id="e77f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">非常感谢Brie Bunge，他是Airbnb TypeScript的幕后推手和ts-migrate的创始人。感谢<a class="ae jn" href="https://twitter.com/lencioni" rel="noopener ugc nofollow" target="_blank"> Joe Lencioni </a>帮助我们在Airbnb采用TypeScript，并改进了我们的TypeScript基础设施和工具。特别感谢<a class="ae jn" href="https://twitter.com/sachselliot" rel="noopener ugc nofollow" target="_blank">埃利奥特·萨克斯</a>和<a class="ae jn" href="https://github.com/jjjjhhhhhh" rel="noopener ugc nofollow" target="_blank">约翰·海特科</a>为ts-migrate做出的贡献。感谢一路上提供反馈和帮助的所有人！</p></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><h1 id="3c2d" class="jo jp hh bd jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh me kj kk kl bi translated">脚注</h1><p id="9280" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们想记下我们在迁移过程中发现的一些可能有用的事情:</p><ul class=""><li id="68e6" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">TypeScript的3.7版本引入了<code class="du ks kt ku kv b"><a class="ae jn" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#ts-nocheck-in-typescript-files" rel="noopener ugc nofollow" target="_blank">@ts-nocheck</a></code>注释，可以在TypeScript文件的顶部添加这些注释来禁用语义检查。我们没有使用这个注释，因为它不支持前面的<code class="du ks kt ku kv b">.ts/.tsx</code>文件，但是它也是迁移过程中一个很好的中间阶段助手。</li><li id="d8a9" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">TypeScript的3.9版本引入了<code class="du ks kt ku kv b"><a class="ae jn" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments" rel="noopener ugc nofollow" target="_blank">@ts-expect-error</a></code>注释。当一行以<code class="du ks kt ku kv b">@ts-expect-error</code>注释为前缀时，TypeScript将禁止报告该错误。如果没有错误，TypeScript会报告说<code class="du ks kt ku kv b">@ts-expect-error</code>不是必需的。在Airbnb代码库中，我们改用了<code class="du ks kt ku kv b">@ts-expect-error</code>注释，而不是<code class="du ks kt ku kv b">@ts-ignore</code>。</li></ul><p id="2840" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[1]: <code class="du ks kt ku kv b">@ts-ignore</code>注释允许我们告诉编译器忽略下一行的错误。</p><p id="6b4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[2]:我们为<code class="du ks kt ku kv b">any</code>类型— <code class="du ks kt ku kv b">$TSFixMe</code>和函数类型— <code class="du ks kt ku kv b">$TSFixMeFunction = (…args: any[]) =&gt; any;</code>引入了自定义别名。尽管最佳实践是避免使用<code class="du ks kt ku kv b">any</code>类型，但是使用它帮助我们简化了迁移过程，并且明确了哪些类型应该被重新访问。</p></div></div>    
</body>
</html>