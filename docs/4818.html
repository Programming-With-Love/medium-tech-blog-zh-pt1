<html>
<head>
<title>Testing common modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试通用模块</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/testing-common-modules-66b39d641617?source=collection_archive---------5-----------------------#2018-01-29">https://blog.kotlin-academy.com/testing-common-modules-66b39d641617?source=collection_archive---------5-----------------------#2018-01-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2d00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在具有<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd">良好架构</a>的Kotlin多平台项目中，我们在<code class="fe kj kk kl km b">common-client</code>公共模块中拥有完整的业务逻辑。这样，它可以在客户端之间共享。</p><p id="b54e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事情是<strong class="jm io">业务逻辑需要被单元测试</strong>并且公共模块测试不像常规模块测试。在本文中，我将展示这不仅是可能的，而且非常方便，这要感谢Kotlin团队给我们的工具。</p><p id="60a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将学习来自Kt的例子。学院申请。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/1fe5615bb242294907539b9aebde1211.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*3g2kjA1U9HyZKOWz.jpg"/></div></figure><h1 id="a884" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">工具</h1><p id="86e6" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了支持通用模块单元测试，Kotlin团队制作了<code class="fe kj kk kl km b">kotlin.test</code>库。要使用它，我们需要将以下依赖项添加到您的公共模块<code class="fe kj kk kl km b">build.gradle</code>:(添加到<code class="fe kj kk kl km b">common-client</code>)</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="5003" class="mc kw in km b gy md me l mf mg"><strong class="km io">testCompile</strong> "org.jetbrains.kotlin:kotlin-test-common:$kotlin_version" <br/><strong class="km io">testCompile</strong> "org.jetbrains.kotlin:kotlin-test-annotations-common:$kotlin_version"</span></pre><p id="072f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你有了它，你就可以在这个模块中编写测试了。这里有一个例子:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="b992" class="mc kw in km b gy md me l mf mg">@Test<br/><strong class="km io">fun </strong>twoSideConversionTest() {<br/>    <strong class="km io">val </strong>dateFormatted = <strong class="km io">"2018-10-12T12:00:01"<br/>    </strong><em class="mh">assertEquals</em>(<br/>        dateFormatted, <br/>        dateFormatted.<em class="mh">parseDate</em>().toDateFormatString()<br/>    )<br/>}</span></pre><p id="3ca5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，我们使用<code class="fe kj kk kl km b">@Test</code>注释来标记测试用例。类似于JUnit中的。您还可以使用其他注释:</p><ul class=""><li id="65d5" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">@Test</code> —用于测试标记功能。</li><li id="7ca1" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">@BeforeTest </code> —标记函数，以便在类中每次测试之前调用它。</li><li id="7a99" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">@AfterTest</code> —标记函数，以便在类中的每个测试之后调用它。</li><li id="9b5b" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">@Ignore</code> —标记忽略已定义的测试。</li></ul><p id="2dd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以使用一些预定义的函数来生成断言:</p><ul class=""><li id="1f9c" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">assertTrue</code>/<code class="fe kj kk kl km b">assertFalse</code>—断言谓词为真。</li><li id="1384" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">assertEquals</code> / <code class="fe kj kk kl km b">assertNotEquals</code> —断言两个值相等(使用相等运算符<code class="fe kj kk kl km b">==</code>检查)</li><li id="11b7" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">assertSame</code>/<code class="fe kj kk kl km b">assertNotSame</code>—断言两个值在引用上相等(使用引用相等运算符<code class="fe kj kk kl km b">===</code>进行检查)</li><li id="2fc9" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">assertNull</code> / <code class="fe kj kk kl km b">assertNotNull</code> —断言值等于<code class="fe kj kk kl km b">null</code>。</li><li id="ff6e" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">assertFails</code> / <code class="fe kj kk kl km b">assertFailsWith</code> —断言代码块返回它应该返回的异常。</li><li id="b93a" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">expect</code> —断言功能块返回预期值。</li><li id="c3aa" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe kj kk kl km b">fail</code> —用于标记在测试执行期间不应该运行的代码部分。</li></ul><p id="4fcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几乎所有上述函数都接受值(<code class="fe kj kk kl km b">assertTrue(users.number == 1)</code>)或函数(<code class="fe kj kk kl km b">assertTrue { users.number == 1 }</code>)。</p><p id="d4b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上述函数，我们可以很容易地为我们的业务逻辑编写单元测试。但是，如果公共模块本身并不例外，并且需要被编译到某个平台(JVM、JS或Native)上，这是如何运行的呢？答案是我们实际上需要在平台模块上运行测试(<code class="fe kj kk kl km b">common-client-js</code>和<code class="fe kj kk kl km b">common-client-jvm</code>)。这就是为什么我们还需要向平台模块添加额外的依赖项。在JVM平台中添加以下依赖项:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="62cb" class="mc kw in km b gy md me l mf mg"><strong class="km io">testCompile</strong> "org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version"    <strong class="km io">testCompile</strong> "org.jetbrains.kotlin:kotlin-test:$kotlin_version"</span></pre><p id="eb6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在您可以使用<code class="fe kj kk kl km b">common-client-jvm</code>上的test命令在JVM上运行测试:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="c227" class="mc kw in km b gy md me l mf mg">./gradlew :common-client-jvm:test</span></pre><p id="e043" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript测试目前还不是现成的，它需要更多的配置。检查<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/cc090bb5acaa7e26fc26952a4c6b6290e5612c5c/common-client-js/build.gradle" rel="noopener ugc nofollow" target="_blank">该配置</a>。这接近于使用<a class="ae ki" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha框架</a>进行单元测试的最低配置。设置完成后，您可以使用Gradle运行测试:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="72e1" class="mc kw in km b gy md me l mf mg">./gradlew :common-client-js:test</span></pre><p id="45b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，在所有平台上运行测试非常重要。这是因为它们有不同的实现，它们可以有不同的实际声明，所以测试在单个平台上通过并不意味着它们也可以在其他平台上运行。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/3947aac7408c1b3caf1e021b1eb2da2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lwak3GPnx61OBrNj.jpg"/></div></div></figure><h1 id="fb78" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">命名测试</h1><p id="cb15" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">用完全描述性的名称来命名测试真的很好。比如这个例子:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="41bd" class="mc kw in km b gy md me l mf mg">@Test<br/><strong class="km io">fun </strong>`When onCreate, loads and displays list of news`() {<br/>    <strong class="km io">val </strong>view = NewsView()<br/>    overrideNewsRepository <strong class="km io">{ </strong>NewsData(<strong class="km io">FAKE_NEWS_LIST_1</strong>) <strong class="km io">}<br/>    val </strong>presenter = NewsPresenter(view)<br/>    <em class="mh">// When<br/>    </em>presenter.onCreate()<br/>    <em class="mh">// Then<br/>    assertEquals</em>(<strong class="km io">FAKE_NEWS_LIST_1</strong>, view.<strong class="km io">newsList</strong>)<br/>    view.assertNoErrors()<br/>}</span><span id="be5c" class="mc kw in km b gy nb me l mf mg">@Test<br/><strong class="km io">fun </strong>`BasePresenter is cancelling all jobs during onDestroy`() {<br/>    <strong class="km io">val </strong>jobs = (1..10).<em class="mh">map </em><strong class="km io">{ </strong>makeJob() <strong class="km io">}<br/>    val </strong>presenter = <strong class="km io">object </strong>: BasePresenter() {<br/>        <strong class="km io">fun </strong>addJobs(jobs: List&lt;Job&gt;) {<br/>            <strong class="km io">this</strong>.<strong class="km io">jobs </strong>+= jobs<br/>        }<br/>    }<br/>    presenter.addJobs(jobs)<br/>    <em class="mh">// When<br/>    </em>presenter.onDestroy()<br/>    <em class="mh">// Then<br/>    assertTrue</em>(jobs.<em class="mh">all </em><strong class="km io">{ it</strong>.<strong class="km io">cancelled }</strong>)<br/>}</span></pre><p id="3b9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">唯一的问题是JavaScript不允许这样的名字，一旦我们试图在JS模块中运行它，就会得到一个错误。有一个简单的解决方案:Kotlin/JS提供了注释<code class="fe kj kk kl km b">JsName</code>，可以用来在编译后的代码中指定函数的实际名称。它是Kotlin/JS注释，所以不能在公共模块中使用。虽然，我们可以在公共模块<code class="fe kj kk kl km b">common-client</code>的测试源中定义预期的声明:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="bbaf" class="mc kw in km b gy md me l mf mg"><strong class="km io">expect annotation class </strong>JsName <strong class="km io">constructor</strong>(<strong class="km io">val name</strong>: String)</span></pre><p id="5405" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe kj kk kl km b">common-client-js</code>模块上做<code class="fe kj kk kl km b">kotlin.js.JsName</code>注释:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="3560" class="mc kw in km b gy md me l mf mg"><strong class="km io">actual typealias </strong>JsName = kotlin.js.JsName</span></pre><p id="ff1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">定义一些将在<code class="fe kj kk kl km b">common-client-js</code>上被忽略的注释:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="88b0" class="mc kw in km b gy md me l mf mg"><strong class="km io">actual annotation class </strong>JsName <strong class="km io">actual constructor</strong>(<br/>    <strong class="km io">actual val name</strong>: String<br/>)</span></pre><p id="6175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们需要注释我们的测试:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="e910" class="mc kw in km b gy md me l mf mg">@JsName(<strong class="km io">"gettingAndDisplayingTest"</strong>)<br/>@Test<br/><strong class="km io">fun </strong>`When onCreate, loads and displays list of news`() {<br/>    // ...<br/>}</span><span id="ba2a" class="mc kw in km b gy nb me l mf mg">@JsName(<strong class="km io">"cancellingJobTest"</strong>)<br/>@Test<br/><strong class="km io">fun </strong>`BasePresenter is cancelling all jobs during onDestroy`() {<br/>    // ...<br/>}</span></pre><p id="c3d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这样的声明，我们可以自由地在两个平台上运行我们的测试。由于这一点，我们的测试报告将显示全名。JVM和JS都适用！这是我从摩卡发来的报道的标题:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="0906" class="mc kw in km b gy md me l mf mg">BasePresenterUnitTest<br/>  ✓ BasePresenter is canceling all jobs during onDestroy<br/>DateTimeUnitTest<br/>  ✓ Two-way conversion should give the same result<br/>  ✓ Ordering is correct after parse<br/>FeedbackPresenterUnitTest<br/>  ✓ Sends all data provided in form<br/>  ✓ When sending feedback, loader is displayed<br/>  ✓ When repository returns error, it is shown on view<br/>  ✓ After data are sent, view is switching back to news list</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/7fa02f190f5212e33748dc81a36a38f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*OkdqrZYlvjBPmbmF.jpg"/></div></figure><h1 id="0ef3" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">异步单元测试</h1><p id="e12b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">有时我们需要阻塞当前线程一段时间，以检查是否有其他进程发生。我们在<code class="fe kj kk kl km b">PeriodicCaller</code>测试中就有这样的情况。这个类假定每隔给定的毫秒数调用一次提供的函数。下面是它的实际实现:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="113c" class="mc kw in km b gy md me l mf mg"><strong class="km io">class </strong>PeriodicCallerImpl : PeriodicCaller {<br/>  <strong class="km io">override fun </strong>start(timeMillis: Long, callback: () -&gt; Unit): Job { <br/>    <strong class="km io">return</strong> <em class="mh">launchUI </em><strong class="km io">{<br/>      while </strong>(<strong class="km io">true</strong>) {<br/>        <em class="mh">delay</em>(timeMillis)<br/>        callback()<br/>      }<br/>    <strong class="km io">}<br/>  }<br/>}</strong></span></pre><p id="9339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们怎么知道它是如何工作的呢？一个简单的解决方案是设置它每隔50毫秒调用一个函数，等待1秒，检查函数是否被调用了大约20次。下面是以下测试的实现:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="02eb" class="mc kw in km b gy md me l mf mg">@Test<br/><strong class="km io">fun </strong>`Periodic caller for 50ms is called around 20 times during 1 second`() = <em class="mh">runBlocking </em><strong class="km io">{<br/>  val </strong>caller = PeriodicCaller.PeriodicCallerImpl()<br/>  <strong class="km io">var </strong>count = 0<br/>  <strong class="km io">val </strong>job = caller.start(50) <strong class="km io">{ </strong>count++ <strong class="km io">}<br/>  </strong><em class="mh">delay</em>(1000)<br/>  job.cancel()<br/>  <em class="mh">assertTrue</em>(count <strong class="km io">in </strong>18..22)<br/><strong class="km io">}</strong></span></pre><p id="d598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是如何工作的？首先，我们在协程中运行我们的测试，这意味着<code class="fe kj kk kl km b">delay</code>不是<code class="fe kj kk kl km b">Thread.delay</code>，它不会停止线程。相反，它挂起了协程(你可以在这里阅读<a class="ae ki" href="https://kotlinlang.org/docs/reference/coroutines.html#blocking-vs-suspending" rel="noopener ugc nofollow" target="_blank">关于差异的</a>)。虽然，如果我们使用<code class="fe kj kk kl km b">launch</code>或者<code class="fe kj kk kl km b">runBlocking</code>，那么测试执行将在第一次断言之前完成。<code class="fe kj kk kl km b">runBlocking</code>是一种非常特殊的协程生成器，一旦协程被挂起，它就会阻塞线程。(我想这听起来真的很复杂，但是当你理解协程是如何工作的时候就不复杂了。很快我将为Kt写更多关于协程的文章。学院，所以<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/new-series-and-channels-346f1a4a4420">订阅</a>如果你想得到通知。)</p><p id="0bd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的测试非常适合Kotlin/JVM。更大的问题是Kotlin/JS。原因是JavaScript是单线程的，这一个线程不能被阻塞。如果没有阻塞，我们无法在延迟时间结束之前阻止测试结束。这看起来像帕特，但科特林团队提供了解决方案。</p><p id="2f48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在本期中看到的，Kotlin团队正计划支持暂停测试。他们还提供了一个变通方法:我们可以为Kotlin/JVM创建一个使用<code class="fe kj kk kl km b">runBlocking</code>的函数，并为Kotlin/JS返回JavaScript <code class="fe kj kk kl km b">Promise</code>。有些框架对待<code class="fe kj kk kl km b">Promise</code>就像挂起测试一样，比如<a class="ae ki" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>，<code class="fe kj kk kl km b">Promise</code>里面的代码可以自由挂起，测试会一直等到结束。要实现它，我们需要下面的预期声明:(你可以在<code class="fe kj kk kl km b">common-client</code>的<code class="fe kj kk kl km b">test</code>源集中定义它)</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="f31e" class="mc kw in km b gy md me l mf mg"><strong class="km io">expect fun </strong>&lt;T&gt; runTest(block: <strong class="km io">suspend </strong>() -&gt; T)</span></pre><p id="e60d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是它对JVM的实际声明:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="fb59" class="mc kw in km b gy md me l mf mg"><strong class="km io">actual fun </strong>&lt;T&gt; runTest(block: <strong class="km io">suspend </strong>() -&gt; T) {<br/>    <em class="mh">runBlocking </em><strong class="km io">{ </strong>block() <strong class="km io">}<br/></strong>}</span></pre><p id="3c8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是它对JS的实际声明:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="9ae1" class="mc kw in km b gy md me l mf mg"><strong class="km io">actual fun </strong>&lt;T&gt; runTest(block: <strong class="km io">suspend </strong>() -&gt; T): <strong class="km io">dynamic <br/>    </strong>= <em class="mh">promise </em><strong class="km io">{ </strong>block() <strong class="km io">}</strong></span></pre><p id="1ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，我们使用了<code class="fe kj kk kl km b">dynamic</code>来欺骗预期的声明。它期望得到<code class="fe kj kk kl km b">Unit</code>，但是在Kotlin/JS中可以返回<code class="fe kj kk kl km b">dynamic</code>，尽管它实际上是<code class="fe kj kk kl km b">Promise</code>。</p><p id="3910" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们需要使用这个函数来包围整个测试，它将在JVM和JS测试中正确工作:</p><pre class="ko kp kq kr gt ly km lz ma aw mb bi"><span id="61aa" class="mc kw in km b gy md me l mf mg">@Test<br/>@JsName(<strong class="km io">"numberOfCallsInTimeTest"</strong>)<br/><strong class="km io">fun </strong>`Periodic caller for 50ms is called around 20 times during 1 second`() = <em class="mh">runTest </em><strong class="km io">{<br/>    val </strong>caller = PeriodicCaller.PeriodicCallerImpl()<br/>    <strong class="km io">var </strong>count = 0<br/>    <strong class="km io">val </strong>job = caller.start(50) <strong class="km io">{ </strong>count++ <strong class="km io">}<br/>    </strong><em class="mh">delay</em>(1000)<br/>    job.cancel()<br/>    <em class="mh">assertTrue</em>(count <strong class="km io">in </strong>18..22)<br/><strong class="km io">}</strong></span></pre><p id="c781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样我们就可以轻松地编写多平台并发测试。</p><h1 id="8898" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">摘要</h1><p id="ce73" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如你所见，通用模块单元测试已经非常成熟了。很快我们将向您展示如何在公共模块中使用全功能的模仿库<a class="ae ki" href="http://mockk.io/" rel="noopener ugc nofollow" target="_blank">mock</a>。现在，我们可以自信地说，你可以单元测试一切。在本文中，我向您展示了如何做到:</p><ul class=""><li id="24cc" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated">使用<code class="fe kj kk kl km b">kotlin.test</code>注释和函数来改进测试。</li><li id="10ac" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">使用Kotlin描述性函数名，使测试更容易理解。</li><li id="0bd2" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">实现并发测试。</li></ul><p id="c603" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查一下<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp" rel="noopener ugc nofollow" target="_blank"> Kt。学院应用项目及其测试</a>。请随意试验它们，并添加一些新的测试。我们很乐意接受您的贡献或给您反馈:)</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h2 id="2f8c" class="mc kw in bd kx nk nl dn lb nm nn dp lf jv no np lj jz nq nr ln kd ns nt lr nu bi translated">学到了什么？单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="2eda" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你认为这很重要，与他人分享。</p><p id="1239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要Kotlin工作室吗？访问我们的网站,看看我们能为您做些什么。</p><p id="3f31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要感谢Oleksiy Pylypenko对这篇文章的校对。</p><p id="a413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这个主题的下一篇文章将在Kt上发表。学院，所以记得订阅。也可以关注<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">我的推特</a> ( <a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @marcinmoskala </a>)或者Kt。学院推特(<a class="ae ki" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">@ ktdotsacademy</a>)。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nv"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nw"><img src="../Images/77f73b2843c7321d074810231e681255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oKagsKgwb58Hot8vtthl3g.gif"/></div></div></figure></div></div>    
</body>
</html>