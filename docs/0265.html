<html>
<head>
<title>Android Data Binding: The Big Event</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:大事件</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-the-big-event-2697089dd0d7?source=collection_archive---------0-----------------------#2016-07-22">https://medium.com/androiddevelopers/android-data-binding-the-big-event-2697089dd0d7?source=collection_archive---------0-----------------------#2016-07-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="224f" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">你甚至不需要打扮</h2></div><p id="9fa1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在以前的文章中，我写了如何从AndroId应用程序中消除findViewById，以及在某些情况下完全消除对视图id的需求的T2。我在那些文章中没有明确提到的一件事是如何处理事件监听器，比如<a class="ae js" href="https://developer.android.com/reference/android/view/View.OnClickListener.html" rel="noopener ugc nofollow" target="_blank">视图的OnClickListener </a>和<a class="ae js" href="https://developer.android.com/reference/android/text/TextWatcher.html" rel="noopener ugc nofollow" target="_blank">文本视图的TextWatcher </a>。</p><p id="caa9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android数据绑定提供了三种机制来在布局文件中设置事件监听器，您可以选择最方便的一种。与标准的Android onClick属性不同，没有一个事件数据绑定机制使用反射，因此无论您选择哪种机制，性能都很好。</p><h2 id="603b" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">监听器对象</h2><p id="645e" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">对于任何带有使用set*调用(与add*调用相反)的侦听器的视图，您可以将侦听器对象绑定到属性。例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="64ba" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">View <em class="lg">android:onClickListener="@{callbacks.clickListener}" </em>...</strong>/&gt;</span></pre><p id="c2b0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中侦听器是用getter或公共字段定义的，如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f170" class="jt ju hh ky b fi lc ld l le lf"><strong class="ky hi">public class </strong>Callbacks {<br/>    <strong class="ky hi">public </strong>View.OnClickListener <strong class="ky hi">clickListener</strong>;<br/>}</span></pre><p id="0ce7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里也有一个捷径，在这里“监听器”被剥离了:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3287" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">View <em class="lg">android:onClick="@{listeners.clickListener}" </em>...</strong>/&gt;</span></pre><p id="8905" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您的应用程序已经使用侦听器对象时，就使用与侦听器对象的绑定，但是在大多数情况下，您将使用另外两种方法中的一种。</p><h2 id="bd93" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">方法引用</h2><p id="794d" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">通过方法引用，您可以将一个方法单独挂接到任何事件侦听器方法。任何静态或实例方法都可以使用，只要它与侦听器中的参数和返回类型相同。例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7435" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">EditText<br/>    <em class="lg">android:afterTextChanged="@{callbacks::nameChanged}"</em> ...</strong>/&gt;</span></pre><p id="59a1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中回调有一个如下声明的nameChanged方法:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="72f4" class="jt ju hh ky b fi lc ld l le lf"><strong class="ky hi">public class </strong>Callbacks {<br/>    <strong class="ky hi">public void </strong>nameChanged(Editable editable) {<br/>        <em class="lg">//...<br/>    </em>}<br/>}</span></pre><p id="f787" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所使用的属性位于“android”名称空间中，并且与侦听器中的方法名称相匹配。</p><p id="8340" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然不建议这样做，但是您也可以在绑定中执行一些逻辑操作:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9b77" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">EditText android:afterTextChanged=<br/>    "@{user.hasName?callbacks::nameChanged:callbacks::idChanged}"<br/>    ...</strong>/&gt;</span></pre><p id="b9cd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在大多数情况下，最好将逻辑放在被调用的方法中。当您可以向方法传递额外的信息时，这就变得容易多了(就像上面的user)。你可以用lambda表达式做到这一点。</p><h2 id="900f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">λ表达式</h2><p id="c0e5" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">您可以提供一个lambda表达式，并向您的方法传递您想要的任何参数。例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b2ed" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">EditText<br/> <em class="lg">android:afterTextChanged="@{(e)-&gt;callbacks.textChanged(user, e)}"</em><br/> ... </strong>/&gt;</span></pre><p id="3152" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">textChanged方法接受传递的参数:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="04d4" class="jt ju hh ky b fi lc ld l le lf"><strong class="ky hi">public class </strong>Callbacks {<br/>    <strong class="ky hi">public void </strong>textChanged(User user, Editable editable) {<br/>        <strong class="ky hi">if </strong>(user.hasName()) {<br/>            <em class="lg">//...<br/>        </em>} <strong class="ky hi">else </strong>{<br/>            <em class="lg">//...<br/>        </em>}<br/>    }<br/>}</span></pre><p id="6857" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您不需要来自侦听器的任何参数，可以使用以下语法删除它们:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="57ae" class="jt ju hh ky b fi lc ld l le lf">&lt;<strong class="ky hi">EditText<br/> <em class="lg">android:afterTextChanged="@{()-&gt;callbacks.textChanged(user)}"</em><br/> ... </strong>/&gt;</span></pre><p id="df46" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是你不能只拿走其中的一部分——要么全部拿走，要么一个都不拿走。</p><p id="12ec" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在方法引用和lambda表达式之间，表达式求值的时间也不同。对于方法引用，表达式在绑定时计算。对于lambda表达式，它在事件发生时进行计算。</p><p id="32c4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，假设还没有设置回调变量。使用方法引用时，表达式的计算结果为null，并且不会设置任何侦听器。对于lambda表达式，总是设置一个侦听器，并在事件引发时计算表达式。通常这没多大关系，但是当有返回值时，将返回默认的Java值，而不是没有调用。例如:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6311" class="jt ju hh ky b fi lc ld l le lf"><strong class="ky hi">&lt;View android:onLongClick=”@{()-&gt;callbacks.longClick()}” …/&gt;</strong></span></pre><p id="1666" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当回调为空时，返回false。在这种错误情况下，您可以使用更长的表达式来返回您希望返回的类型:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f961" class="jt ju hh ky b fi lc ld l le lf"><strong class="ky hi">&lt;View android:onLongClick=”@{()-&gt;callbacks == null ? true : callbacks.longClick()}” …/&gt;</strong></span></pre><p id="e110" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过确保没有空表达式求值，您通常可以完全避免这种情况。</p><p id="2276" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Lambda表达式可以在与方法引用相同的属性上使用，因此您可以轻松地在它们之间切换。</p><h2 id="90b1" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">用哪个？</h2><p id="c0c0" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">最灵活的机制是lambda表达式，它允许您为回调提供与事件侦听器不同的参数。</p><p id="282b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在许多情况下，您的回调将采用与listener方法中给出的参数完全相同的参数。在这种情况下，方法引用提供了更短的语法，也更容易阅读。</p><p id="6eb8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您正在转换以使用Android数据绑定的应用程序中，您可能已经在视图上设置了监听器对象。您可以将侦听器作为变量传递给布局，并将其分配给视图。</p></div></div>    
</body>
</html>