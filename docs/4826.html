<html>
<head>
<title>Effective Java in Kotlin, item 1: Consider static factory methods instead of constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的有效Java，第1项:考虑静态工厂方法而不是构造函数</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-java-in-kotlin-item-1-consider-static-factory-methods-instead-of-constructors-8d0d7b5814b2?source=collection_archive---------0-----------------------#2018-03-19">https://blog.kotlin-academy.com/effective-java-in-kotlin-item-1-consider-static-factory-methods-instead-of-constructors-8d0d7b5814b2?source=collection_archive---------0-----------------------#2018-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b8558491605d09f0defae812304c8b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TK0OVpVdn0ahVnVLFJzwQ.png"/></div></div></figure><div class=""/><p id="4223" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">更新:</strong> <a class="ae kt" href="https://kt.academy/article/ek-factory-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">这里的</strong> </a> <strong class="jx iz">是本文的最新版本。</strong></p><p id="0e60" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997" rel="noopener ugc nofollow" target="_blank"> <em class="ku">有效的Java</em></a>Joshua Bloch的书是关于Java开发的最重要的书籍之一。我经常引用它，可能这就是为什么我经常被要求说或写更多关于它的东西。我还注意到人们对它们与科特林的关系很感兴趣。这就是为什么我决定在Kot上用Kotlin来逐一描述它们。学院博客。只要看到读者有兴趣，我就继续；)</p><p id="6da2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是来自<em class="ku">有效Java </em>的第一条规则:</p><blockquote class="kv"><p id="34a4" class="kw kx iy bd ky kz la lb lc ld le ks dk translated"><em class="lf">考虑静态工厂方法，而不是构造函数</em>。</p></blockquote><p id="40ef" class="pw-post-body-paragraph jv jw iy jx b jy lg ka kb kc lh ke kf kg li ki kj kk lj km kn ko lk kq kr ks ig bi translated">让我们来探索一下。</p><h1 id="a32e" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">图书提醒</h1><p id="107b" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">高效Java的第一条规则声称，开发人员应该更多地考虑使用静态工厂方法，而不是构造函数。静态工厂方法是用于产生对象实例的静态方法。下面是一些静态工厂方法用法的Java示例:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a29a" class="mx lm iy mt b gy my mz l na nb">Boolean trueBoolean = Boolean.valueOf(true);<br/>String number = String.<em class="ku">valueOf</em>(12);<br/>List&lt;Integer&gt; list = Arrays.<em class="ku">asList</em>(1, 2, 4);</span></pre><p id="71b0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">静态工厂方法是构造函数的一个非常强大的替代方法。以下是它们的一些优势:</p><ul class=""><li id="f370" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated">与构造函数不同，它们有名字。名字解释了一个对象是如何被创建的，有哪些自变量。比如说你看到下面这段代码:<code class="fe nl nm nn mt b">new ArrayList(3)</code>。你能猜出<code class="fe nl nm nn mt b">3</code>是什么意思吗？它应该是数组的第一个元素还是列表的第一个元素？肯定不是不言自明的。在这种情况下，一个名字，比如<code class="fe nl nm nn mt b">ArrayList.withSize(3)</code>，就能消除所有的困惑。这是一个名字非常有用的例子:它解释了对象创建的参数或特征。命名的另一个原因是它解决了具有相同参数类型的构造函数之间的冲突。</li><li id="cb6f" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated">与构造函数不同，它们不需要在每次被调用时创建一个新的对象。当我们使用静态工厂方法时，我们可以包含缓存机制来优化对象创建。这样我们可以提高对象创建的性能。我们还可以定义静态工厂方法，如果对象不能被创建，它将返回<code class="fe nl nm nn mt b">null</code>，就像当<code class="fe nl nm nn mt b">Connection</code>由于某种原因不能被创建时，它将返回<code class="fe nl nm nn mt b">null</code>。</li><li id="636a" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated"><strong class="jx iz">与构造函数不同，它们可以返回其返回类型的任何子类型的对象。</strong>这可以用来为不同的情况提供更好的对象。当我们想在一个接口后面隐藏一个实际的对象时，这一点尤其重要。例如，在Kotlin中，所有集合都隐藏在接口后面。这很重要，因为不同的平台有不同的类。当我们使用<code class="fe nl nm nn mt b">listOf(1,2,3)</code>时，那么我们在Kotlin/JVM上运行时就有了<code class="fe nl nm nn mt b">ArrayList</code>。同一个调用将返回Kotlin/JS上的JavaScript数组。这是一种优化，但不是问题，因为两种类型都实现了科特林<code class="fe nl nm nn mt b">List</code>接口。<code class="fe nl nm nn mt b">listOf</code>返回类型为<code class="fe nl nm nn mt b">List</code>，这是我们正在操作的界面。对于我们来说，引擎盖下的实际类型通常并不重要。类似地，在任何静态工厂方法中，我们可以返回不同的类型，甚至改变类型的实际实现，只要它们隐藏在某个被指定为静态工厂方法返回类型的超类型或接口之后，一切都没问题。</li><li id="e2e9" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated"><strong class="jx iz">它们减少了创建参数化类型实例的冗长。与Kotlin相比，这更像是Java问题，因为Kotlin有更好的类型推理。关键是当我们调用一个构造函数时，我们必须指定参数类型，即使它们非常明显。当调用静态工厂方法时，可以避免使用参数类型。</strong></li></ul><p id="bfdc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些都是支持静态工厂方法使用的有力论据，但是Joshua Bloch也指出了一些缺点:</p><ul class=""><li id="cccc" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated"><strong class="jx iz">它们不能在子类构造中使用。</strong>在子类构造中，我们需要使用超类构造函数。我们不能使用静态工厂方法。</li><li id="4bde" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated"><strong class="jx iz">它们不容易与其他静态方法区分开来。</strong>例外有:<code class="fe nl nm nn mt b">valueOf</code>、<code class="fe nl nm nn mt b">of</code>、<code class="fe nl nm nn mt b">getInstance</code>、<code class="fe nl nm nn mt b">newInstance</code>、<code class="fe nl nm nn mt b">getType</code>和<code class="fe nl nm nn mt b">newType</code>。这些是不同类型的静态工厂方法的通用名称。</li></ul><p id="3c2c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个论证之后，直观的结论是，用于构造一个对象的函数与对象结构或构造有很强的联系，应该被指定为一个构造函数。另一方面，当构造与对象结构没有直接联系时，那么它很可能应该使用静态方法来定义。</p><p id="e6a2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们去科特林吧。当我在学习Kotlin的时候，我有一种感觉，有人正在设计它，而他的眼前有一本<em class="ku">有效的Java </em>书。它回答了书中描述的大多数Java问题。科特林还改变了工厂方法的实现方式。我们来分析一下。</p><h1 id="d0d1" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">伙伴工厂法</h1><p id="a3b6" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">Kotlin不允许静态方法。Java静态工厂方法的类似物通常被称为<em class="ku">伴生工厂方法</em>。它是放在伴随对象中的工厂方法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6335" class="mx lm iy mt b gy my mz l na nb">class MyList {<br/>    //...</span><span id="e2bc" class="mx lm iy mt b gy nt mz l na nb">    companion object {<br/>        fun of(vararg i: Int) { /*...*/ }<br/>    }<br/>}</span></pre><p id="384e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法与静态工厂方法的用法相同:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6503" class="mx lm iy mt b gy my mz l na nb">MyList.of(1,2,3,4)</span></pre><p id="5315" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">隐藏的伙伴对象实际上是单例类。这个事实有一个很大的好处:伴随对象可以扩展其他类。这样我们可以实现多个通用工厂方法，并为它们提供不同的类。我最常见的例子是<code class="fe nl nm nn mt b">Provider</code> class，我用它来代替DI。我有以下课程:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="aac4" class="mx lm iy mt b gy my mz l na nb">abstract class Provider&lt;T&gt; {</span><span id="a48a" class="mx lm iy mt b gy nt mz l na nb">     var original: T? = null<br/>     var mocked: T? = null</span><span id="202d" class="mx lm iy mt b gy nt mz l na nb">     abstract fun create(): T</span><span id="2412" class="mx lm iy mt b gy nt mz l na nb">     fun get(): T = mocked ?: original ?: create()<br/>           .apply { original = this }</span><span id="62e2" class="mx lm iy mt b gy nt mz l na nb">     fun lazyGet(): Lazy&lt;T&gt; = lazy { get() }<br/>}</span></pre><p id="b22b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于不同的元素，我只需要指定创建函数:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bea7" class="mx lm iy mt b gy my mz l na nb">interface UserRepository {<br/>    fun getUser(): User</span><span id="28bc" class="mx lm iy mt b gy nt mz l na nb">    companion object: Provider&lt;UserRepository&gt; {<br/>        override fun create() = UserRepositoryImpl()<br/>    }<br/>}</span></pre><p id="04b4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这样的定义，我可以通过<code class="fe nl nm nn mt b">UserReposiroty.get()</code>或<code class="fe nl nm nn mt b">val user by UserRepository.lazyGet()</code>在所有代码中得到这个库。我还可以通过<code class="fe nl nm nn mt b">UserRepository.mocked = object: UserRepository { /*...*/ }</code>指定不同的测试或模拟实现。</p><p id="ffc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是Java的一大优势，在Java中，所有的SFM(静态工厂方法)都必须在每个对象中手工实现。另一个仍然被低估的重用工厂方法的方法是使用接口委托。我们可以这样使用上面的例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e477" class="mx lm iy mt b gy my mz l na nb">interface Dependency&lt;T&gt; {<br/>    var mocked: T?<br/>    fun get(): T<br/>    fun lazyGet(): Lazy&lt;T&gt; = lazy { get() }<br/>}</span><span id="0ce4" class="mx lm iy mt b gy nt mz l na nb">abstract class Provider&lt;T&gt;(val init: ()-&gt;T): Dependency&lt;T&gt; {<br/>    var original: T? = null<br/>    override var mocked: T? = null<br/>     <br/>    override fun get(): T = mocked ?: original ?: init()<br/>          .apply { original = this }<br/>}</span><span id="a029" class="mx lm iy mt b gy nt mz l na nb">interface UserRepository {<br/>    fun getUser(): User</span><span id="93fa" class="mx lm iy mt b gy nt mz l na nb">    companion object: Dependency&lt;UserRepository&gt; by Provider({<br/>        UserRepositoryImpl() <br/>    }) <br/>}</span></pre><p id="d2c5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法是相同的，但是请注意，使用接口委托，我们可以在单个伴随对象中从不同的类获得工厂方法，并且我们只获得接口中指定的功能(根据<em class="ku">接口分离原则</em>，什么是好的)。关于接口委托<a class="ae kt" href="https://www.youtube.com/watch?v=8QgWSIaa_QU" rel="noopener ugc nofollow" target="_blank">的更多信息，请点击</a>。</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="https://kt.academy/"><div class="gh gi nu"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h1 id="6985" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">扩展工厂方法</h1><p id="cb99" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">注意工厂方法被放在伴随对象中而不是被定义为静态方法的另一个优点:我们可以为伴随对象定义扩展函数。因此，如果我们想将<em class="ku">伴生工厂方法</em>添加到外部库中定义的Kotlin类，我们仍然可以这样做(只要它定义了任何伴生对象):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="78f1" class="mx lm iy mt b gy my mz l na nb">interface Tool {<br/>   companion object { … }<br/>}</span><span id="82f5" class="mx lm iy mt b gy nt mz l na nb">fun Tool.Companion.createBigTool(…) : BigTool { … }</span></pre><p id="798d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，当伴随对象被命名为:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5fb6" class="mx lm iy mt b gy my mz l na nb">interface Tool {<br/>   companion object Factory { … }<br/>}</span><span id="78d0" class="mx lm iy mt b gy nt mz l na nb">fun Tool.Factory.createBigTool(…) : BigTool { … }</span></pre><p id="cc8b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是让我们从代码内部共享外部库的强大可能性。AFAIK Kotlin是目前唯一给出这种可能性的语言。</p><h1 id="30fc" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">顶级功能</h1><p id="3052" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">在Kotlin中常见的是，我们定义一个顶级函数，而不是CFM ( <em class="ku">伴随对象工厂方法</em>)。一些常见的例子有<code class="fe nl nm nn mt b">listOf</code>、<code class="fe nl nm nn mt b">setOf</code>和<code class="fe nl nm nn mt b">mapOf</code>。类似地，库设计者正在指定用于创建对象的顶级函数。它们被广泛使用。例如，在Android中，我们传统上定义一个函数来创建<code class="fe nl nm nn mt b">Activity</code> <code class="fe nl nm nn mt b">Intent</code>作为静态方法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8562" class="mx lm iy mt b gy my mz l na nb">// Java<br/>class MainActivity extends Activity {<br/>    static Intent getIntent(Context context) {<br/>        return new Intent(context, MainActivity.class);<br/>    }<br/>}</span></pre><p id="299b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin Anko库中，我们可以使用具体化类型的顶级函数<code class="fe nl nm nn mt b">intentFor</code>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e24b" class="mx lm iy mt b gy my mz l na nb">intentFor&lt;MainActivity&gt;()</span></pre><p id="9f7a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种解决方案的问题是，虽然公共顶级函数随处可见，但很容易丢弃用户IDE提示。更大的问题开始于当某人创建顶级函数时，这些函数的名字没有直接指出它不是一个方法。</p><p id="3b20" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用顶级函数创建对象对于小而常用的对象来说是一个完美的选择，比如<code class="fe nl nm nn mt b">List</code>或<code class="fe nl nm nn mt b">Map</code>，因为<code class="fe nl nm nn mt b">listOf(1,2,3)</code>比<code class="fe nl nm nn mt b">List.of(1,2,3)</code>更简单，可读性更好(尽管看起来很相似)。虽然公共顶级函数需要小心谨慎地使用。</p><h1 id="075f" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">假构造函数</h1><p id="a49e" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">Kotlin中的构造函数的工作方式类似于顶级函数:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="23df" class="mx lm iy mt b gy my mz l na nb">class A()</span><span id="e70a" class="mx lm iy mt b gy nt mz l na nb">val a = A()</span></pre><p id="c5e2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们的引用也与顶级函数相同:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="387b" class="mx lm iy mt b gy my mz l na nb">val aReference = ::A</span></pre><p id="252b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类构造函数和函数在使用上的唯一区别是函数不是从大写字母开始的。虽然技术上他们可以。这个事实被用在不同的地方，包括科特林标准图书馆。<code class="fe nl nm nn mt b">List</code>和<code class="fe nl nm nn mt b">MutableList</code>是接口，它们不能有构造函数，但是Kotlin开发者希望允许下面的<code class="fe nl nm nn mt b">List</code>构造:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a134" class="mx lm iy mt b gy my mz l na nb">List(3) { "$it" } // same as listOf("0", "1", "2")</span></pre><p id="f819" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么以下函数包含在<em class="ku"> Collections.kt </em>中(从Kotlin 1.1开始):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2cd7" class="mx lm iy mt b gy my mz l na nb"><strong class="mt iz">public inline fun </strong>&lt;T&gt; List(size: Int, init: (index: Int) -&gt; T): List&lt;T&gt; = <em class="ku">MutableList</em>(size, init)<br/><em class="ku"><br/></em><strong class="mt iz">public inline fun </strong>&lt;T&gt; MutableList(size: Int, init: (index: Int) -&gt; T): MutableList&lt;T&gt; {<br/>    <strong class="mt iz">val </strong>list = ArrayList&lt;T&gt;(size)<br/>    <em class="ku">repeat</em>(size) <strong class="mt iz">{ </strong>index <strong class="mt iz">-&gt; </strong>list.add(init(index)) <strong class="mt iz">}<br/>    return </strong>list<br/>}</span></pre><p id="2bb1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们的外观和行为都像构造函数。许多开发人员没有意识到他们是幕后的顶级功能。同时，它们具有SFM的一些优点:它们可以返回类型的子类型，并且不需要每次都创建对象。他们也没有构造函数的要求。例如，二级构造函数需要立即调用主构造函数或超类的构造函数。当我们使用伪构造函数时，我们可以推迟构造函数的使用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4fdb" class="mx lm iy mt b gy my mz l na nb">fun ListView(config: Config) : ListView {<br/>    val items = … // Here we read items from config<br/>    return ListView(items) // We call actual constructor<br/>}</span></pre><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi nu"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="cc44" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">顶级功能和范围</h1><p id="09c2" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">我们可能希望在类外创建工厂方法的另一个原因是，我们希望在某个特定的范围内使用它。比如当我们只在某个特定的类或文件中需要工厂方法时。</p><p id="eef5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有些人可能会认为这种用法可能会引起误解，因为对象创建范围通常与这个类可见性范围相关联。所有这些可能性都是表达意图的有力工具，需要明智地使用。虽然对象创建的具体方式包含了关于它的信息，并且在某些上下文中使用这种可能性是非常有益的。</p><h1 id="ef49" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">主要构造函数</h1><p id="9ec3" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">Kotlin引入了名为<em class="ku">主构造函数</em>的伟大特性。Kotlin类中只能有一个主构造函数，但它们比Java中已知的构造函数强大得多(在Kotlin中这些构造函数被称为<em class="ku">二级</em>)。主构造函数<a class="ae kt" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">参数</a>可以在类创建时使用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e523" class="mx lm iy mt b gy my mz l na nb">class Student(name: String, surname: String) {<br/>    val fullName = "$name $surname"<br/>}</span></pre><p id="353d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，这些参数可以直接定义为属性:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c9f6" class="mx lm iy mt b gy my mz l na nb">class Student(val name: String, val surname: String) {<br/>    val fullName <br/>        get() = "$name $surname"<br/>}</span></pre><p id="05e0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应该清楚的是，主构造函数与类的创建有着紧密的联系。注意，当我们使用带有默认参数的主构造函数时，我们不需要<a class="ae kt" href="http://codethataint.com/blog/telescoping-constructor-pattern-java/" rel="noopener ugc nofollow" target="_blank">伸缩构造函数</a>。由于所有这些，主构造函数被经常使用(在我的项目中创建的数百个类中，我发现只有少数没有主构造函数)，而次构造函数很少使用。这太棒了。我认为这是应该的。主构造函数与类结构和初始化有很强的联系，因此当我们应该定义构造函数而不是工厂方法时，它非常适合。对于其他情况，我们很可能应该使用伙伴对象工厂方法或顶级函数，而不是二级构造函数。</p><h1 id="8337" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建对象的其他方法</h1><p id="cc79" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">Kotlin出色的工厂方法并不是Kotlin改进对象创建的唯一例子。在下一篇文章中，我们将描述Kotlin如何改进builder模式。例如，包含了多种优化，允许使用DSL创建对象:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5467" class="mx lm iy mt b gy my mz l na nb">val dialog = alertDialog {<br/>    title = "Hey, you!"<br/>    message = "You want to read more about Kotlin?"<br/>    setPositiveButton { makeMoreArticlesForReader() }<br/>    setNegativeButton { startBeingSad() }<br/>}</span></pre><p id="3183" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我记住了。在本文中，我最初只描述了静态工厂方法的直接替代方法，因为这是高效Java的第一项内容。与这本书相关的其他令人敬畏的Kotlin特性将在下一篇文章中描述。如果你想得到通知，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅简讯</a>。</p><h1 id="d6ea" class="ll lm iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="4fa4" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">虽然Kotlin在对象创建方面做了很多改变，但是静态工厂方法的有效Java参数仍然是当前的。发生变化的是Kotlin排除了静态成员方法，取而代之的是我们可以使用具有SFM优势的替代方法:</p><ul class=""><li id="6b58" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated">伙伴工厂法</li><li id="75d5" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated">顶级功能</li><li id="ab60" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated">假构造者</li><li id="2b11" class="nc nd iy jx b jy no kc np kg nq kk nr ko ns ks nh ni nj nk bi translated">扩展工厂方法</li></ul><p id="1dd3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们中的每一种都在不同的情况下使用，并且它们相对于Java SFM都有不同的优势。</p><p id="1e55" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般规则是，在大多数情况下，我们创建对象所需要的只是一个主构造函数，默认情况下，它与类结构和创建相关联。当我们需要其他的类构造方法时，我们最有可能使用一些SFM的替代方法。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="ac87" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一部分:</p><div class="im in gp gr io oc"><a rel="noopener  ugc nofollow" target="_blank" href="/effective-java-in-kotlin-item-2-consider-a-builder-when-faced-with-many-constructor-parameters-1927e69608e1"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iz gy z fp oh fr fs oi fu fw ix bi translated">Kotlin中的有效Java，第2项:考虑一个面临许多构造函数参数的构建器</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">这一条对Java程序员影响很大。当我们处理…的不同变体时，这种情况并不少见</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq iu oc"/></div></div></a></div></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="7cc8" class="ll lm iy bd ln lo or lq lr ls os lu lv lw ot ly lz ma ou mc md me ov mg mh mi bi translated">有效科特林</h1><p id="2643" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">这是第一篇关于有效科特林的文章。当我们看到兴趣，我们将出版下一部分。在卡帕头。学院我们也在研究关于这个主题的书:</p><div class="im in gp gr io oc"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iz gy z fp oh fr fs oi fu fw ix bi translated">有效科特林</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">这本书对官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">leanpub.com</p></div></div><div class="ol l"><div class="ow l on oo op ol oq iu oc"/></div></div></a></div><p id="c48d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并让我们更快地发布它，<a class="ae kt" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用链接并订阅</a>。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="237a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae kt" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="ccff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kt" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Twitter上引用我，用<a class="ae kt" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。</p><p id="3af9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要感谢<a class="ae kt" href="https://twitter.com/orangy" rel="noopener ugc nofollow" target="_blank"> Ilya Ryzhenkov </a>的更正和重要建议。有些例子也是他的。伊利亚，你让这个帖子变得更好；)</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ox"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx iz">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oy"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>