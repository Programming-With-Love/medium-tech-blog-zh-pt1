<html>
<head>
<title>Spantastic text styling with Spans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带跨度的文本样式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568?source=collection_archive---------0-----------------------#2018-03-29">https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568?source=collection_archive---------0-----------------------#2018-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/632bf5e6c77c2ecd040db01256566738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_91P4pyi4_V0xUX89YXMyg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="61b5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要在Android中样式化文本，使用spans！改变一些字符的颜色，使它们可点击，缩放文本的大小，甚至用跨度画自定义的项目符号。跨度可以改变<code class="du js jt ju jv b">TextPaint</code>属性，在<code class="du js jt ju jv b">Canvas</code>上绘图，甚至改变文本布局和影响行高等元素。跨度是可以附加到文本和从文本分离的标记对象；它们可以应用于整段或部分文本。</p><p id="61a9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看如何使用跨度，开箱即用的跨度是什么，如何轻松创建自己的跨度，以及最后如何测试跨度:</p><p id="93a2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#b0e9" rel="noopener ugc nofollow">Android中的样式文本</a></p><p id="425d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#d5d9" rel="noopener ugc nofollow">应用跨度</a></p><p id="8037" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#149b" rel="noopener ugc nofollow">框架跨度</a></p><ul class=""><li id="086a" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated"><a class="ae hu" href="#f6db" rel="noopener ugc nofollow">外观vs度量影响跨度</a></li><li id="130a" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><a class="ae hu" href="#1861" rel="noopener ugc nofollow">字符vs段落影响跨度</a></li></ul><p id="d283" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#7657" rel="noopener ugc nofollow">创建自定义跨度</a></p><p id="49a4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#e345" rel="noopener ugc nofollow">测试自定义跨度实现</a></p><p id="5740" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="#eef0" rel="noopener ugc nofollow">测试跨度用途</a></p><h1 id="b0e9" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">Android中的文本样式</h1><p id="1993" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">Android提供了几种样式化文本的方法:</p><ul class=""><li id="0db1" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated"><strong class="iw hy">单一样式</strong> —该样式适用于文本视图显示的整个文本</li><li id="2f5b" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><strong class="iw hy">多样式</strong>——在字符或段落级别，几种样式可以应用于一个文本</li></ul><p id="d73f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">单一样式</strong>意味着使用XML属性或<a class="ae hu" href="https://developer.android.com/guide/topics/ui/look-and-feel/themes.html" rel="noopener ugc nofollow" target="_blank">样式和主题</a>对TextView的整个内容进行样式化。这种方法是一种简单的解决方案，可以从XML开始工作，但是不允许对部分文本进行样式化。比如通过设置<code class="du js jt ju jv b">textStyle=”bold”</code>，整个文字会加粗；不能只定义特定的字符加粗。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="5fed" class="lv kl hx jv b fi lw lx l ly lz">&lt;TextView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <strong class="jv hy">android:textSize="32sp"<br/>    android:textStyle="bold"</strong>/&gt;</span></pre><p id="dc0d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">多样式</strong>意味着给同一文本添加几种样式。例如，将一个单词设为斜体，另一个单词设为粗体。多风格可以实现使用HTML标签，跨度或处理画布上的自定义文本绘制。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/bf5e0d1b4f580cceea0d44196a240691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3hnVPTJP5Hv4Jduo."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Left: Single style text. TextView with textSize=”32sp” and textStyle=”bold”. Right: Multi style text. Text with </em><code class="du js jt ju jv b"><em class="mb">ForegroundColorSpan</em></code><em class="mb">, StyleSpan(ITALIC), ScaleXSpan(1.5f), StrikethroughSpan.</em></figcaption></figure><p id="b504" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">HTML标签是简单问题的简单解决方案，比如使文本加粗、倾斜，甚至显示项目符号。要样式化包含HTML标签的文本，调用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String,%20int)" rel="noopener ugc nofollow" target="_blank">Html.fromHtml</a></code>方法。在引擎盖下，HTML格式被转换成spans。请注意，<code class="du js jt ju jv b">Html</code>类并不支持所有的HTML标签和css样式，比如让项目符号变成另一种颜色。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="d626" class="lv kl hx jv b fi lw lx l ly lz">val text = "My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"<br/>myTextView.text = <strong class="jv hy">Html.fromHtml(text)</strong></span></pre><p id="0b1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您有平台默认不支持的样式需求时，您可以手动地在画布上绘制文本，比如沿着弯曲的路径书写文本。</p><p id="8f23" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> Spans </strong>允许你实现多样式的文本和更精细的定制。例如，您可以通过应用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/BulletSpan.html" rel="noopener ugc nofollow" target="_blank">BulletSpan</a></code>将文本段落定义为具有项目符号。您可以自定义文本边距和项目符号之间的间距以及项目符号的颜色。从Android P开始，你甚至可以<a class="ae hu" href="https://developer.android.com/reference/android/text/style/BulletSpan.html#BulletSpan(int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank">设置弹点的半径</a>。您还可以为span创建一个自定义实现。查看下面的“创建自定义跨度”部分，了解如何操作。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="0939" class="lv kl hx jv b fi lw lx l ly lz">val spannable = SpannableString("My text \nbullet one\nbullet two")</span><span id="3bf8" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>    BulletPointSpan(gapWidthPx, accentColor),<br/>    /* start index */ 9, /* end index */ 18,<br/>    Spannable.<em class="md">SPAN_EXCLUSIVE_EXCLUSIVE</em>)</span><span id="d103" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>     BulletPointSpan(gapWidthPx, accentColor),<br/>     /* start index */ 20, /* end index */ spannable.length,<br/>     Spannable.<em class="md">SPAN_EXCLUSIVE_EXCLUSIVE</em>)</span><span id="4a08" class="lv kl hx jv b fi mc lx l ly lz">myTextView.<em class="md">text </em>= spannable</span></pre><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/8bb099ce708f21f2d987c0ce3a5231ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z7VsMx891rPMRhiY."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Left: Using HTML tags. Center: Using BulletSpan with default bullet size. Right: Using BulletSpan on Android P or custom implementation.</em></figcaption></figure><p id="7b5c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以结合单一风格和多种风格。您可以将应用于TextView的样式视为“基本”样式。跨度文字样式应用于基本样式的“顶部”,并将覆盖基本样式。例如，当将<code class="du js jt ju jv b">textColor=”@color.blue”</code>属性设置为TextView并对文本的前4个字符应用<code class="du js jt ju jv b">ForegroundColorSpan(Color.PINK)</code>时，前4个字符将使用span设置的粉色，文本的其余部分使用TextView属性设置的颜色。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="f3c6" class="lv kl hx jv b fi lw lx l ly lz">&lt;TextView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <strong class="jv hy">android:textColor="@color/blue"</strong>/&gt;</span><span id="085c" class="lv kl hx jv b fi mc lx l ly lz">val spannable = SpannableString(“Text styling”)<br/>spannable.setSpan(<br/>     <strong class="jv hy">ForegroundColorSpan(Color.PINK)</strong>, <br/>     0, 4, <br/>     Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span><span id="ef21" class="lv kl hx jv b fi mc lx l ly lz">myTextView.text = spannable</span></pre><figure class="ln lo lp lq fd hj er es paragraph-image"><div class="er es me"><img src="../Images/52306a9c463a70908a5c8faef065eaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*JIWZ3OBz2PHdo9Grt0lBnw.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Combining TextView with XML attributes and text with spans</em></figcaption></figure><h1 id="d5d9" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">应用跨度</h1><p id="121e" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">使用跨度时，您将使用以下类别之一:<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/SpannedString.html" rel="noopener ugc nofollow" target="_blank">SpannedString</a></code>、<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/SpannableString.html" rel="noopener ugc nofollow" target="_blank">SpannableString</a></code>或<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html" rel="noopener ugc nofollow" target="_blank">SpannableStringBuilder</a></code>。它们之间的区别在于文本或标记对象是可变的还是不可变的，以及它们使用的内部结构:<code class="du js jt ju jv b">SpannedString</code>和<code class="du js jt ju jv b">SpannableString</code>使用线性数组来记录增加的跨度，而<code class="du js jt ju jv b">SpannableStringBuilder</code>使用<a class="ae hu" href="https://en.wikipedia.org/wiki/Interval_tree" rel="noopener ugc nofollow" target="_blank">间隔树</a>。</p><p id="9cd9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是如何决定使用哪一个:</p><ul class=""><li id="6f57" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated">仅<strong class="iw hy">读取而不设置</strong>文本或跨度？&gt;-<code class="du js jt ju jv b">SpannedString</code></li><li id="ce51" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><strong class="iw hy">设置文本和跨度</strong>？- &gt; <code class="du js jt ju jv b">SpannableStringBuilder</code></li><li id="ad56" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">设置一个<strong class="iw hy">小跨度数</strong> ( &lt; ~10)？- &gt; <code class="du js jt ju jv b">SpannableString</code></li><li id="0d02" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">设置一个<strong class="iw hy">更大的跨距数</strong>(&gt;~ 10)——&gt;-T9】</li></ul><p id="9be2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，如果您正在处理一个不变的文本，但是您想要将范围附加到该文本，您应该使用<code class="du js jt ju jv b">SpannableString</code>。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="513b" class="lv kl hx jv b fi lw lx l ly lz">╔════════════════════════╦══════════════╦════════════════╗<br/>║ <strong class="jv hy">Class</strong>                  ║ <strong class="jv hy">Mutable Text</strong> ║ <strong class="jv hy">Mutable Markup</strong> ║<br/>╠════════════════════════╬══════════════╬════════════════╣<br/>║ SpannedString          ║      no      ║       no       ║<br/>║ SpannableString        ║      no      ║      yes       ║<br/>║ SpannableStringBuilder ║     yes      ║      yes       ║<br/>╚════════════════════════╩══════════════╩════════════════╝</span></pre><p id="6b6e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有这些类都扩展了<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html" rel="noopener ugc nofollow" target="_blank">Spanned</a></code>接口，但是具有可变标记的类(<code class="du js jt ju jv b">SpannableString</code>和<code class="du js jt ju jv b">SpannableStringBuilder</code>)也从<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.html" rel="noopener ugc nofollow" target="_blank">Spannable</a></code>扩展而来。</p><p id="19e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html" rel="noopener ugc nofollow" target="_blank">Spanned</a></code> - &gt;带有不可变标记的不可变文本</p><p id="d59d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.html" rel="noopener ugc nofollow" target="_blank">Spannable</a></code>(扩展<code class="du js jt ju jv b">Spanned</code> )- &gt;带有可变标记的不可变文本</p><p id="b9c4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过调用<code class="du js jt ju jv b">Spannable</code>对象上的<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.html#setSpan(java.lang.Object,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank">setSpan(Object what, int start, int end, int flags)</a></code>来应用跨度。<code class="du js jt ju jv b">what</code>对象是文本中从开始到结束索引应用的标记。该标志标记该范围是否应该扩展以包含在其起点或终点插入的文本。不管设置了哪个标志，只要文本插入的位置大于起点但小于终点，范围就会自动扩展。</p><p id="a82d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，设置一个<code class="du js jt ju jv b">ForegroundColorSpan</code>可以这样做:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="adc1" class="lv kl hx jv b fi lw lx l ly lz">val spannable = SpannableStringBuilder(“Text is spantastic!”)</span><span id="1bf2" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>     ForegroundColorSpan(Color.RED), <br/>     8, 12, <br/>     Spannable.SPAN_EXCLUSIVE_INCLUSIVE)</span></pre><p id="cd62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为跨度是使用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html#SPAN_EXCLUSIVE_EXCLUSIVE" rel="noopener ugc nofollow" target="_blank">SPAN_EXCLUSIVE_<strong class="iw hy">INCLUSIVE</strong></a></code>标志设置的，所以当在跨度末尾插入文本时，它将被扩展以包括新的文本:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="75fa" class="lv kl hx jv b fi lw lx l ly lz">val spannable = SpannableStringBuilder(“Text is spantastic!”)</span><span id="ce91" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>     ForegroundColorSpan(Color.RED), <br/>     /* start index */ 8, <strong class="jv hy">/* end index */ 12</strong>, <br/>     Spannable.SPAN_EXCLUSIVE_<strong class="jv hy">INCLUSIVE</strong>)</span><span id="8d58" class="lv kl hx jv b fi mc lx l ly lz"><strong class="jv hy">spannable.insert(12, “(&amp; fon)”)</strong></span></pre><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/7431042b0e8ef1da3ee652465fb8eb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bq7PnfvDBcm1CjK7."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Left: Text with ForegroundColorSpan. Right: Text with ForegroundColorSpan and Spannable.SPAN_EXCLUSIVE_INCLUSIVE</em></figcaption></figure><p id="4eba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果span设置了<code class="du js jt ju jv b">Spannable.SPAN_EXCLUSIVE_EXCLUSIVE</code>标志，在span末尾插入文本将不会修改span的结束索引。</p><p id="9462" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以将多个跨度组合并附加到同一个文本段。例如，粗体和红色的文本可以这样构造:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="372c" class="lv kl hx jv b fi lw lx l ly lz">val spannable = SpannableString(“Text is spantastic!”)</span><span id="f0eb" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>     ForegroundColorSpan(Color.RED), <br/>     8, 12, <br/>     Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span><span id="8288" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>     StyleSpan(BOLD), <br/>     8, spannable.length, <br/>     Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span></pre><figure class="ln lo lp lq fd hj er es paragraph-image"><div class="er es me"><img src="../Images/e0ec22024acfb776bb152001931b8696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*8PXOuMO_daAGDsnIlADruw.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Text with multiple spans: ForegroundColorSpan(Color.RED) and StyleSpan(BOLD)</em></figcaption></figure><h1 id="149b" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">框架跨度</h1><p id="7603" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">Android框架定义了几个接口和抽象类，它们在测量和渲染时被检查。这些类拥有允许span访问像<code class="du js jt ju jv b">TextPaint</code>或<code class="du js jt ju jv b">Canvas</code>这样的对象的方法。</p><p id="730d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android框架在<a class="ae hu" href="https://developer.android.com/reference/android/text/style/package-summary.html" rel="noopener ugc nofollow" target="_blank"> android.text.style </a>包中提供了20+span，对主要接口和抽象类进行子类化。我们可以用几种方式对跨度进行分类:</p><ul class=""><li id="c566" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated">基于span是仅改变外观还是也改变文本度量/布局</li><li id="dc86" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">基于它们是在字符级还是在段落级影响文本</li></ul><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mf"><img src="../Images/224a2706790d97f424332ab71a603bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3qvv1i8lbceOxq0P."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Span categories: character vs paragraph, appearance vs metric</em></figcaption></figure><h2 id="f6db" class="lv kl hx bd km mg mh mi kq mj mk ml ku jf mm mn ky jj mo mp lc jn mq mr lg ms bi translated"><strong class="ak">外观vs度量影响跨度</strong></h2><p id="767a" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">第一类影响字符级文本，改变它们的外观:文本或背景颜色、下划线、删除线等。，它触发重绘而不会导致文本的重新布局。这些跨度实现<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/UpdateAppearance.html" rel="noopener ugc nofollow" target="_blank">UpdateAppearance</a></code>并扩展<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/CharacterStyle.html" rel="noopener ugc nofollow" target="_blank">CharacterStyle</a></code>。<code class="du js jt ju jv b">CharacterStyle</code>子类通过提供更新<code class="du js jt ju jv b">TextPaint</code>的访问来定义如何绘制文本。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/12cd1f23fad1ec08b4603a9c04224351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gwmWCXpJfDVV5Kcn."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Appearance affecting spans</em></figcaption></figure><p id="eabb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">度量影响</strong>跨度修改文本度量和布局，因此观察跨度变化的对象将重新测量文本以获得正确的布局和渲染。</p><p id="39d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，影响文本大小的跨度将需要重新测量和布局，以及重新绘图。这些跨度通常扩展了<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/MetricAffectingSpan.html" rel="noopener ugc nofollow" target="_blank">MetricAffectingSpan</a></code>级。这个抽象类通过提供对<code class="du js jt ju jv b">TextPaint</code>的访问，允许子类定义跨度如何影响文本测量。由于<code class="du js jt ju jv b">MetricAffectingSpan</code>扩展了<code class="du js jt ju jv b">CharacterSpan</code>，子类在字符级别影响文本的外观。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/c545897e03d64136cf705475c673258d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Eq0RoZ20n7bWk_eu."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Metric affecting spans</em></figcaption></figure><p id="e758" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可能总是想用文本和标记重新创建<code class="du js jt ju jv b">CharSequence</code>并调用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank">TextView.setText(CharSequence)</a></code>。但是这几乎总是会触发重新测量和重新绘制布局以及创建额外的对象。为了减少性能影响，用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(int,%20android.widget.TextView.BufferType)" rel="noopener ugc nofollow" target="_blank">TextView.setText(Spannable, BufferType.SPANNABLE)</a></code>设置文本，然后当需要修改跨度时，通过将<code class="du js jt ju jv b">TextView.getText()</code>转换为<code class="du js jt ju jv b">Spannable</code>从TextView中检索<code class="du js jt ju jv b">Spannable</code>对象。我们将在下一篇文章中更详细地介绍<code class="du js jt ju jv b">TextView.setText</code>和不同的性能优化。</p><p id="0eb3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，考虑下面这样设置和检索的<code class="du js jt ju jv b">Spannable</code>对象:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="b449" class="lv kl hx jv b fi lw lx l ly lz">val spannableString = SpannableString(“Spantastic text”)</span><span id="1d62" class="lv kl hx jv b fi mc lx l ly lz">// setting the text as a Spannable<br/><strong class="jv hy">textView.setText(spannableString, BufferType.SPANNABLE)</strong></span><span id="4c6c" class="lv kl hx jv b fi mc lx l ly lz">// later getting the instance of the text object held <br/>// by the TextView<br/>// this can can be cast to Spannable only because we set it as a<br/>// BufferType.SPANNABLE before<br/>val spannableText = <strong class="jv hy">textView.text as Spannable</strong></span></pre><p id="e64f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，当我们在<code class="du js jt ju jv b">spannableText</code>上设置跨度时，我们不需要再次调用<code class="du js jt ju jv b">textView.setText</code>，因为我们直接修改了由<code class="du js jt ju jv b">TextView</code>持有的<code class="du js jt ju jv b">CharSequence</code>对象的实例。</p><p id="8cbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们设置不同的跨度时，会发生以下情况:</p><p id="7cf8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">案例1:外观影响跨度</strong></p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="7f2a" class="lv kl hx jv b fi lw lx l ly lz">spannableText.setSpan(<br/>     ForegroundColorSpan(colorAccent), <br/>     0, 4, <br/>     Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span></pre><p id="8c31" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于我们附加了一个影响跨度的外观，<code class="du js jt ju jv b">TextView.onDraw</code>被调用而不是<code class="du js jt ju jv b">TextView.onLayout</code>。文本被重绘，但宽度和高度将保持不变。</p><p id="c509" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">案例2:影响跨度的度量</strong></p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="6f9e" class="lv kl hx jv b fi lw lx l ly lz">spannableText.setSpan(<br/>     RelativeSizeSpan(2f), <br/>     0, 4, <br/>     Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span></pre><p id="39a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/RelativeSizeSpan.html" rel="noopener ugc nofollow" target="_blank">RelativeSizeSpan</a></code>改变了文本的大小，所以文本的宽度和高度以及文本的布局都可以改变(例如，一个特定的单词现在可能会进入下一行，而<code class="du js jt ju jv b">TextView</code>的大小不会改变)。<code class="du js jt ju jv b">TextView</code>需要计算新的大小，因此调用<code class="du js jt ju jv b">onMeasure</code>和<code class="du js jt ju jv b">onLayout</code>。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/b196c7dd0809b9d9a2bc3035a4b6150c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Li86sQd6bpmNDWu9."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Left: ForegroundColorSpan — appearance affecting span. Right: RelativeSizeSpan — metric affecting span</em></figcaption></figure><h2 id="1861" class="lv kl hx bd km mg mh mi kq mj mk ml ku jf mm mn ky jj mo mp lc jn mq mr lg ms bi translated"><strong class="ak">字符vs段落影响跨度</strong></h2><p id="5c30" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">跨度可以在字符级别影响文本，更新背景颜色、样式或大小等元素，也可以在段落级别影响文本，改变整个文本块的对齐方式或边距。根据所需的样式，扳手可以延伸<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/CharacterStyle.html" rel="noopener ugc nofollow" target="_blank">CharacterStyle</a></code>或执行<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/ParagraphStyle.html" rel="noopener ugc nofollow" target="_blank">ParagraphStyle</a></code>。延伸<code class="du js jt ju jv b">ParagraphStyle</code>的跨度必须从单个段落的第一个字符连接到最后一个字符，否则跨度将不会显示。在Android上，段落是基于新行(<code class="du js jt ju jv b">\n</code>)字符定义的。</p><figure class="ln lo lp lq fd hj er es paragraph-image"><div class="er es mu"><img src="../Images/d534ef4d4978fde8fd2deb426e9b28ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*iK2M43udyG0m5Ic5."/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">On Android paragraphs are defined based on new line (‘\n’) character.</em></figcaption></figure><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/c6ea67c83d95a8f5a15530e7626fb7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CLKvPQz5xETA6Y84."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Paragraph affecting spans</em></figcaption></figure><p id="7a12" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，像<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/BackgroundColorSpan.html" rel="noopener ugc nofollow" target="_blank">BackgroundColorSpan</a></code>这样的<code class="du js jt ju jv b">CharacterStyle</code>跨度可以附加到文本中的任何字符。在这里，我们将它从第5个字符附加到第8个字符:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="fec0" class="lv kl hx jv b fi lw lx l ly lz">val spannable = SpannableString(“Text is<strong class="jv hy">\n</strong>spantastic”)</span><span id="f595" class="lv kl hx jv b fi mc lx l ly lz">spannable.setSpan(<br/>    BackgroundColorSpan(color),<br/>    5, 8,<br/>    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span></pre><p id="56a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个<code class="du js jt ju jv b">ParagraphStyle</code>跨度，像<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/QuoteSpan.html" rel="noopener ugc nofollow" target="_blank">QuoteSpan</a></code>一样，只能从一个段落的开头开始附加，否则行和文本边距不会出现。例如，“<em class="md">文本是</em><strong class="iw hy"><em class="md">\ n</em></strong><em class="md">spantastic</em>”在文本的第8个字符上包含一个新行，因此我们可以将<code class="du js jt ju jv b">QuoteSpan</code>附加到它上面，并且只对从那里开始的段落进行样式化。如果我们将span附加到0或8以外的任何位置，文本将根本不会被样式化。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="60fb" class="lv kl hx jv b fi lw lx l ly lz">spannable.setSpan(<br/>    QuoteSpan(color), <br/>    8, text.length, <br/>    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)</span></pre><figure class="ln lo lp lq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/c1ed90dcbb17c6eb8a79668ca2fa2992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J_YIdoh9-gXTQB5X."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mb">Left: BackgroundColorSpan — character affecting span. Right: QuoteSpan — paragraph affecting span</em></figcaption></figure><h1 id="7657" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建自定义跨度</h1><p id="4f98" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">当实现你自己的范围时，你将需要决定你的范围是否影响字符或段落级别的文本，以及它是否也影响布局或仅仅是文本的外观。但是，在从头开始编写您自己的实现之前，请检查您是否可以使用框架跨度中提供的功能。</p><p id="4cae" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="md">TL；博士:</em></p><ul class=""><li id="ce59" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated"><em class="md">影响文字处于</em> <strong class="iw hy"> <em class="md">字符级</em> </strong> <em class="md"> - &gt; </em> <code class="du js jt ju jv b"><em class="md">CharacterStyle</em></code></li><li id="c0f2" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><em class="md">影响文字在</em> <strong class="iw hy"> <em class="md">段落层次</em> </strong> <em class="md"> - &gt; </em> <code class="du js jt ju jv b"><em class="md">ParagraphStyle</em></code></li><li id="6709" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><em class="md">影响</em> <strong class="iw hy"> <em class="md">文字外观</em> </strong> <em class="md"> - &gt; </em> <code class="du js jt ju jv b"><em class="md">UpdateAppearance</em></code></li><li id="95c8" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated"><em class="md">影响</em> <strong class="iw hy"> <em class="md">文字度量</em> </strong> <em class="md"> - &gt; </em> <code class="du js jt ju jv b"><em class="md">UpdateLayout</em></code></li></ul><p id="d620" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们需要实现一个span，允许以一定的比例增加文本的大小，比如<code class="du js jt ju jv b">RelativeSizeSpan</code>，并设置文本的颜色，比如<code class="du js jt ju jv b">ForegroundColorSpan</code>。为此，我们可以扩展<code class="du js jt ju jv b">RelativeSizeSpan</code>，因为它为<code class="du js jt ju jv b">updateDrawState</code>和<code class="du js jt ju jv b">updateMeasureState</code>提供了回调，我们可以覆盖绘制状态回调并设置<code class="du js jt ju jv b">TextPaint</code>的颜色。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="891e" class="lv kl hx jv b fi lw lx l ly lz">class RelativeSizeColorSpan(<br/>    @ColorInt private val color: Int,<br/>    size: Float<br/>) : RelativeSizeSpan(size) {</span><span id="2d2f" class="lv kl hx jv b fi mc lx l ly lz">    <strong class="jv hy">override fun updateDrawState(textPaint: TextPaint?) </strong>{<br/>         super.updateDrawState(ds)<br/>         textPaint?.color = color<br/>    }<br/>}</span></pre><p id="cb6d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意:将<code class="du js jt ju jv b">RelativeSizeSpan</code>和<code class="du js jt ju jv b">ForegroundColorSpan</code>应用于同一文本可以达到相同的效果。</p><h1 id="e345" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">测试自定义跨度实现</h1><p id="d3fb" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">测试跨度意味着检查TextPaint上是否确实进行了预期的修改，或者是否在画布上绘制了正确的元素。例如，考虑将指定大小和颜色的项目符号添加到段落的span的自定义实现，以及左边距和项目符号之间的间隙。参见<a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/TextStyling-Kotlin/app/src/main/java/com/android/example/text/styling/renderer/spans/BulletPointSpan.kt" rel="noopener ugc nofollow" target="_blank"> android-text示例</a>中的实现。为了测试这个类，实现一个AndroidJUnit测试，检查:</p><ul class=""><li id="e7bb" class="jw jx hx iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated">在画布上画一个特定大小的圆</li><li id="3d17" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">如果跨度没有附加到文本，则不会绘制任何内容</li><li id="2815" class="jw jx hx iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">根据构造函数参数值设置正确的边距</li></ul><p id="becc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">测试画布交互可以通过模仿画布来完成，将模仿的对象传递给<code class="du js jt ju jv b">drawLeadingMargin</code>方法，并验证是否使用正确的参数调用了正确的方法。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="59bb" class="lv kl hx jv b fi lw lx l ly lz">val canvas = mock(Canvas::class.<em class="md">java</em>)<br/>val paint = mock(Paint::class.<em class="md">java</em>)<br/>val text = SpannableString("text")<br/><br/>@Test fun drawLeadingMargin() {<br/>    val x = 10<br/>    val dir = 15<br/>    val top = 5<br/>    val bottom = 7<br/>    val color = Color.<em class="md">RED</em></span><span id="41ab" class="lv kl hx jv b fi mc lx l ly lz"><em class="md">    </em>// Given a span that is set on a text<br/>    val span = BulletPointSpan(<em class="md">GAP_WIDTH</em>, color)<br/>    text.setSpan(span, 0, 2, Spanned.<em class="md">SPAN_EXCLUSIVE_EXCLUSIVE</em>)</span><span id="aee3" class="lv kl hx jv b fi mc lx l ly lz">    // When the leading margin is drawn<br/>    span.drawLeadingMargin(canvas, paint, x, dir, top, 0, bottom,<br/>            text, 0, 0, true, mock(Layout::class.<em class="md">java</em>))</span><span id="51ab" class="lv kl hx jv b fi mc lx l ly lz">    // Check that the correct canvas and paint methods are called, <br/>    //in the correct order<br/>    val inOrder = inOrder(canvas, paint)</span><span id="f007" class="lv kl hx jv b fi mc lx l ly lz">    // bullet point paint color is the one we set<br/>    inOrder.verify(paint).<em class="md">color </em>= color<br/>    inOrder.verify(paint).<em class="md">style </em>= eq&lt;Paint.Style&gt;(Paint.Style.FILL)</span><span id="6ed7" class="lv kl hx jv b fi mc lx l ly lz">    // a circle with the correct size is drawn <br/>    // at the correct location<br/>    val xCoordinate = <em class="md">GAP_WIDTH</em>.toFloat() + x.toFloat()<br/>    +dir * BulletPointSpan.DEFAULT_BULLET_RADIUS<br/>    val yCoord = (top + bottom) / 2f</span><span id="812a" class="lv kl hx jv b fi mc lx l ly lz">    inOrder.verify(canvas)<br/>           .drawCircle(<br/>                eq(xCoordinate),<br/>                eq(yCoord), <br/>                eq(BulletPointSpan.DEFAULT_BULLET_RADIUS), <br/>                eq(paint))<br/>    verify(canvas, never()).save()<br/>    verify(canvas, never()).translate(<br/>               eq(xCoordinate), <br/>               eq(yCoordinate))<br/>}</span></pre><p id="6ee2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看<code class="du js jt ju jv b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/TextStyling-Kotlin/app/src/androidTest/java/com/android/example/text/styling/renderer/spans/BulletPointSpanTest.kt" rel="noopener ugc nofollow" target="_blank">BulletPointSpanTest</a></code>中的其余测试。</p><h1 id="eef0" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">测试跨越使用</h1><p id="951f" class="pw-post-body-paragraph iu iv hx iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated"><code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html" rel="noopener ugc nofollow" target="_blank">Spanned</a></code>接口允许从文本中设置和检索跨度。通过实施Android JUnit测试，检查是否在正确的位置添加了正确的跨度。在<a class="ae hu" href="https://github.com/googlesamples/android-text" rel="noopener ugc nofollow" target="_blank"> android文本示例</a>中，我们将项目符号标记转换为项目符号。这是通过将<code class="du js jt ju jv b">BulletPointSpans</code>附加到文本的正确位置来实现的。以下是测试方法:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="8a54" class="lv kl hx jv b fi lw lx l ly lz">@Test fun textWithBulletPoints() {<br/>val result = builder.markdownToSpans(“Points\n* one\n+ two”)</span><span id="98e4" class="lv kl hx jv b fi mc lx l ly lz">// check that the markup tags are removed<br/>assertEquals(“Points\none\ntwo”, result.toString())</span><span id="0dd6" class="lv kl hx jv b fi mc lx l ly lz">// get all the spans attached to the SpannedString<br/>val spans = result.getSpans&lt;Any&gt;(0, result.length, Any::class.java)assertEquals(2, spans.size.toLong())</span><span id="e992" class="lv kl hx jv b fi mc lx l ly lz">// check that the span is indeed a BulletPointSpan<br/>val bulletSpan = spans[0] as BulletPointSpan</span><span id="5b8e" class="lv kl hx jv b fi mc lx l ly lz">// check that the start and end indexes are the expected ones<br/>assertEquals(7, result.getSpanStart(bulletSpan).toLong())<br/>assertEquals(11, result.getSpanEnd(bulletSpan).toLong())</span><span id="21d0" class="lv kl hx jv b fi mc lx l ly lz">val bulletSpan2 = spans[1] as BulletPointSpan<br/>assertEquals(11, result.getSpanStart(bulletSpan2).toLong())<br/>assertEquals(14, result.getSpanEnd(bulletSpan2).toLong())<br/>}</span></pre><p id="ba79" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看<code class="du js jt ju jv b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/TextStyling-Kotlin/app/src/androidTest/java/com/android/example/text/styling/renderer/MarkdownBuilderTest.kt" rel="noopener ugc nofollow" target="_blank">MarkdownBuilderTest</a></code>获得更多测试示例。</p><blockquote class="mv mw mx"><p id="df24" class="iu iv md iw b ix iy iz ja jb jc jd je my jg jh ji mz jk jl jm na jo jp jq jr ha bi translated">注意:如果您需要迭代测试之外的跨度，请使用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html#nextSpanTransition(int,%20int,%20java.lang.Class)" rel="noopener ugc nofollow" target="_blank">Spanned#nextSpanTransition</a></code>而不是<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spanned.html#getSpans(int,%20int,%20java.lang.Class%3CT%3E)" rel="noopener ugc nofollow" target="_blank">Spanned#getSpans</a></code>,因为这样性能更好。</p></blockquote></div><div class="ab cl nb nc go nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ha hb hc hd he"><p id="d31f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">跨度是一个强大的概念，深深嵌入在文本呈现功能中。他们可以访问像<code class="du js jt ju jv b">TextPaint</code>和<code class="du js jt ju jv b">Canvas</code>这样的组件，这些组件允许在Android上高度定制文本样式。在Android P中，我们在框架跨度中添加了大量的文档，所以在实现你自己的之前，先看看有什么可用的。</p><p id="5fa2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在以后的文章中，我们将会告诉你更多关于spans是如何工作的，以及如何以一种高性能的方式使用它们。例如，你需要使用<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/TextView.html#setText(java.lang.CharSequence,%20android.widget.TextView.BufferType)" rel="noopener ugc nofollow" target="_blank">textView.setText(CharSequence, BufferType)</a></code>或<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Spannable.Factory.html" rel="noopener ugc nofollow" target="_blank">Spannable.Factory</a></code>。至于原因，敬请关注！</p><blockquote class="mv mw mx"><p id="5c34" class="iu iv md iw b ix iy iz ja jb jc jd je my jg jh ji mz jk jl jm na jo jp jq jr ha bi translated">非常感谢Siyamed Sinir、Clara Bayarri和Nick Butcher。</p></blockquote></div></div>    
</body>
</html>