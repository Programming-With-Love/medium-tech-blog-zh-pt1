<html>
<head>
<title>AppCompat — Age of the vectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AppCompat —载体的年龄</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/appcompat-v23-2-age-of-the-vectors-91cbafa87c88?source=collection_archive---------0-----------------------#2016-02-24">https://medium.com/androiddevelopers/appcompat-v23-2-age-of-the-vectors-91cbafa87c88?source=collection_archive---------0-----------------------#2016-02-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/30b9021cb9af21a976a36cb0646c9ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24YlhdTwYACMeYeucAKMMg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://flic.kr/p/mKQ2JR" rel="noopener ugc nofollow" target="_blank">rulers</a> by Dean Hochman</figcaption></figure><p id="99a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如你在支持库23.2.0 <a class="ae it" href="http://android-developers.blogspot.co.uk/2016/02/android-support-library-232.html" rel="noopener ugc nofollow" target="_blank">博客文章</a>中看到的，我们现在在支持库中有兼容的矢量可绘制实现:VectorDrawableCompat和动画VectorDrawableCompat。</p><p id="439a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些是作为独立的功能块实现的。正如我们所知，开发人员希望从参考资料中使用它们，我们已经在AppCompat中直接添加了对矢量绘图的支持。</p><p id="a1a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种整合有多种原因，包括:</p><ul class=""><li id="6f8e" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">允许开发者在所有运行Android 2.1及以上版本的设备上轻松使用<vector> drawables。</vector></li><li id="c151" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">允许AppCompat自己使用矢量绘图。这本身就从AppCompat的AAR中削减了约70KB(约9%)。这听起来并不多，但对于所有设备上使用AppCompat的所有应用程序来说，节省是复合的。储存和运输成本的节省很快就会累积起来。</li></ul><p id="e754" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第二点很重要。即使您自己不使用compat vector功能，您也需要像使用它一样关注这篇文章，因为AppCompat需要它。</strong></p><h2 id="9513" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">重要的事情先来</h2><p id="a211" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">VectorDrawableCompat依赖于aapt中的一些功能，这些功能告诉它保留<vector>使用的任何最近添加的属性id，以便它们可以在v21之前被引用。这是通过aapt标志开启的(下面会提到)。</vector></p><p id="c3ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果未启用此标志，在运行KitKat或更低版本的设备上运行应用程序时，您会看到以下错误(或类似错误):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6497" class="kg kh hh ll b fi lp lq l lr ls">Caused by: android.content.res.Resources$NotFoundException: File res/drawable-v19/abc_ic_ab_back_material.xml from drawable resource ID #0x7f020016<br/> at android.content.res.Resources.loadDrawable(Resources.java:2097)<br/> at android.content.res.Resources.getDrawable(Resources.java:700)<br/> ...</span></pre><h2 id="9028" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">启用标志</h2><p id="472d" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">我猜你们大多数人都会使用Gradle，所以让我们快速浏览一下。</p><p id="b623" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你使用的是Gradle插件的2.0或更高版本，我们有一个方便的快捷方式来启用一切:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5676" class="kg kh hh ll b fi lp lq l lr ls">android {<br/>  defaultConfig {<br/>    <strong class="ll hi">vectorDrawables.useSupportLibrary = true</strong><br/>  }<br/>}</span></pre><p id="e218" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您尚未更新，并且正在使用Gradle插件的1.5.0或更低版本，您需要将以下内容添加到您的应用程序的build.gradle中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="26f2" class="kg kh hh ll b fi lp lq l lr ls">android {<br/>  defaultConfig {<br/>    // Stops the Gradle plugin’s automatic rasterization of vectors<br/>    generatedDensities = []<br/>  }</span><span id="a941" class="kg kh hh ll b fi lt lq l lr ls">  // Flag to tell aapt to keep the attribute ids around<br/>  aaptOptions {<br/>    additionalParameters "<strong class="ll hi">--no-version-vectors</strong>"<br/>  }<br/>}</span></pre><h2 id="fa32" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">如何在我的应用程序中使用我自己的矢量资源？</h2><p id="6c31" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">在我们开始之前，有一些事情需要注意。使用AppCompat时，VectorDrawableCompat仅在API 20及以下版本上使用。这意味着当在API 21和更高版本上运行时，您将使用框架的VectorDrawable类。这与VectorDrawableCompat上的create()API略有不同，后者仍然使用API v21+上的框架实现，但通过一个代理对象。</p><p id="ae5c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对，所以你想在你的应用中使用矢量资源，你的minSdkVersion &lt; 21。太好了！首先检查资产是否在API 21+设备上工作，就像完整性检查一样。</p><h2 id="f340" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">好的，它工作了，那么我如何使用它呢？</h2><p id="24cf" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">有两种方法可以在AppCompat中使用矢量资源，这可以追溯到API 7+:</p><h2 id="b90b" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">AppCompatImageView</h2><p id="1adf" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">所以你可能知道AppCompat“注入”了它自己的小部件来代替许多框架小部件。这允许它执行着色和其他后台的事情。我们还通过新的<strong class="iw hi"> app:srcCompat </strong>属性添加了对VectorDrawableCompat的支持。它旨在取代<strong class="iw hi"> android:src </strong>，你也可以安全地将它用于非矢量资产。</p><p id="b6fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有一个我们在AppCompat中实际使用的矢量资产示例:</p><p id="80d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">RES/draw able/IC _ search . XML</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1027" class="kg kh hh ll b fi lp lq l lr ls">&lt;vector xmlns:android="..."<br/>        android:width="24dp"<br/>        android:height="24dp"<br/>        android:viewportWidth="24.0"<br/>        android:viewportHeight="24.0"<br/>        android:tint="?attr/colorControlNormal"&gt;</span><span id="bc4d" class="kg kh hh ll b fi lt lq l lr ls">    &lt;path<br/>        android:pathData="..."<br/>        android:fillColor="@android:color/white"/&gt;</span><span id="8329" class="kg kh hh ll b fi lt lq l lr ls">&lt;/vector&gt;</span></pre><p id="b583" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用此drawable，ImageView声明示例如下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="63b3" class="kg kh hh ll b fi lp lq l lr ls">&lt;ImageView<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    <strong class="ll hi">app:srcCompat</strong>="@drawable/ic_search"/&gt;</span></pre><p id="a070" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您也可以在运行时设置它:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="05f7" class="kg kh hh ll b fi lp lq l lr ls">ImageView iv = (ImageView) findViewById(...);<br/>iv.setImageResource(R.drawable.ic_search);</span></pre><p id="230f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相同的属性和调用也适用于ImageButton。</p><h2 id="5a7a" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">“神奇”的方式</h2><blockquote class="lu lv lw"><p id="6dbb" class="iu iv lx iw b ix iy iz ja jb jc jd je ly jg jh ji lz jk jl jm ma jo jp jq jr ha bi translated"><strong class="iw hi">首先，这个功能最初是在23.2.0中发布的，但后来我们发现了一些内存使用和配置更新问题，所以我们在23.3.0中删除了它。在23.4.0 </strong>(技术上是一个修复版本)<strong class="iw hi">中，我们重新添加了相同的功能，但是在一个标志后面，您需要手动启用它。</strong></p></blockquote><p id="1801" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想重新启用此功能，只需将它放在您活动的顶部:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="282f" class="kg kh hh ll b fi lp lq l lr ls">static {<br/>    AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);<br/>}</span></pre><p id="e41f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">剩下的这个岗位<em class="lx">可能</em>接着工作。</p><p id="f3fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi">—</p><p id="b438" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">AppCompat可以从框架中截取<em class="lx">一些</em>可提取的膨胀。这使得您可以使用矢量资产的所有标准属性，一切都可以正常工作。</p><p id="603e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以让我告诉你什么可能有效:</p><p id="0b66" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">DrawableContainers引用其他只包含一个向量资源的drawables资源。</p><p id="ed1b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，引用其他包含向量的文件的StateListDrawable。</p><p id="4d2b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">RES/drawable/state _ list _ icon . XML</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6547" class="kg kh hh ll b fi lp lq l lr ls">&lt;selector xmlns:android="..."&gt;<br/>    &lt;item android:state_checked="true"   <br/>            android:drawable="@drawable/checked_icon" /&gt;<br/>    &lt;item android:drawable="@drawable/icon" /&gt;<br/>&lt;/selector&gt;</span></pre><p id="d558" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">RES/drawable/checked _ icon . XML</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="77ad" class="kg kh hh ll b fi lp lq l lr ls">&lt;vector xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:width="32dp"<br/>    android:viewportWidth="32"<br/>    android:height="32dp"<br/>    android:viewportHeight="32"&gt;<br/> <br/>    ...<br/> <br/>&lt;/vector&gt;</span></pre><p id="a035" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，您可以在大多数地方使用可绘制的状态列表:</p><p id="ace4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为TextView的复合drawable:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2874" class="kg kh hh ll b fi lp lq l lr ls">&lt;TextView<br/>    android:drawableLeft="@drawable/state_list_icon" /&gt;</span></pre><p id="8968" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为单选按钮的按钮:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="baa3" class="kg kh hh ll b fi lp lq l lr ls">&lt;RadioButton<br/>    android:button="@drawable/state_list_icon" /&gt;</span></pre><p id="5b73" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为ImageView的src:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7e07" class="kg kh hh ll b fi lp lq l lr ls">&lt;ImageView<br/>    android:src="@drawable/state_list_icon" /&gt;</span></pre><p id="18e7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不一定要用StateListDrawable。它还可以处理InsetDrawable、LayerDrawable、LevelListDrawable和RotateDrawable容器。唯一的规则是向量需要在一个单独的文件中。</p><h2 id="2433" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">动画向量呢？</h2><p id="c6c3" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">到目前为止，我们只讨论了“静态”矢量绘图。所以我们来谈谈动画向量。它们的工作方式非常相似，但是它们只在API v11+上可用。如果您试图在运行API 10或更低版本的设备上加载<animated-vector>,那么系统将返回“null ”,并且不会显示任何内容。</animated-vector></p><p id="815f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在&lt; API 21的平台上运行时，动画向量可以做的事情也有一些限制。以下是目前在这些平台上无法运行的内容:</p><ul class=""><li id="86d4" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">路径变形(路径类型评估器)。这用于将一条路径变形为另一条路径。</li><li id="9469" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">路径插值。这用于定义灵活的插值器(表示为路径),而不是系统定义的线性插值器。</li><li id="cd66" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">沿着路径移动。这个很少用。几何体对象可以沿着任意路径四处移动。</li></ul><p id="1efe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总之，基于你的应用将要运行的平台，动画师声明必须是有效的和功能性的。</p><h2 id="c47e" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">“魔法之路”是如何运作的？</h2><p id="8abc" class="pw-post-body-paragraph iu iv hh iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">如果您对这是如何实现的不感兴趣，或者胃口不好，您可以跳过这一步。😷</p><p id="e7c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">目前在Android平台中还没有办法从资源中使用定制的可绘制实现。因此，下面的方法不起作用:</p><p id="ddf3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">RES/drawable/my _ awesome _ drawable . XML</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="651a" class="kg kh hh ll b fi lp lq l lr ls">&lt;my.package.SuperAwesomeDrawable xmlns:app="..."<br/>    app:customAttr1="32dp"<br/>    app:customAttr2="32dp"&gt;<br/> <br/>    ...<br/> <br/>&lt;/my.package.SuperAwesomeDrawable&gt;</span></pre><p id="7aaf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">重复一下:之前的代码<strong class="iw hi">现在不能用了。</strong></p><p id="fc86" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以你可能会问我们是如何让自定义的drawables在AppCompat中工作的？在API 19及以下版本的Android drawable系统中有一个鲜为人知的漏洞，该漏洞已被妥善保存以备不时之需。</p><p id="6c77" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不过，首先，有一点背景<em class="lx">(我真的应该做一个关于这个的演讲，自我提醒)</em>。当你在一个资源上设置属性时，通过一个对获取样式属性()的调用，它表现为实现视图的一个<a class="ae it" href="https://developer.android.com/reference/android/content/res/TypedArray.html" rel="noopener ugc nofollow" target="_blank">类型数组</a>实例。那个通话链被安全锁定，没有办法挂钩进去(相信我，我试过)。TypedArray是final，所以我们不能从它扩展。</p><p id="0c4f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我前面提到的漏洞(实际上是API 21中修复的一个bug)是这样一个事实:大多数DrawableContainer实现从对Resources.getDrawable()的调用中获取它们的子Drawable，而不是直接从TypedArray中获取。</p><p id="f9c0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，以下是kitkat-release中<a class="ae it" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/kitkat-release/graphics/java/android/graphics/drawable/InsetDrawable.java" rel="noopener ugc nofollow" target="_blank"> InsetDrawable </a>的摘录:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a359" class="kg kh hh ll b fi lp lq l lr ls">Resources r = ...;</span><span id="40f3" class="kg kh hh ll b fi lt lq l lr ls">int drawableRes =<br/>     a.getResourceId(android.R.styleable.InsetDrawable_drawable, 0);        </span><span id="9bcd" class="kg kh hh ll b fi lt lq l lr ls">if (drawableRes != 0) {<br/>    dr = r.getDrawable(drawableRes);<br/>}</span></pre><p id="1f28" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，Resources <strong class="iw hi">是</strong>我们可以挂钩的东西，但是实际实现起来有点笨拙。</p><p id="3191" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们必须创建一个覆盖getDrawable()调用的资源包装器。为了这篇博文的目的，我们称它为ResourcesWrapper。它的getDrawable()首先检查AppCompat自己的内部Drawable管理器是否有任何自定义的drawable处理。如果AppCompat不想处理，就交给框架处理。</p><p id="d025" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我们有了资源包装器，但是我们现在需要一种方法让视图使用它。我们通过ContextWrapper来实现这一点，context wrapper从getResources()返回我们的ResourcesWrapper实例之一。然后我们需要让所有的视图都使用我们的新上下文。我们通过两种方式做到这一点:</p><ol class=""><li id="a890" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr mb jy jz ka bi translated">每个AppCompat小部件(AppCompatImageView等)都在构造函数中包装了它所提供的上下文。</li><li id="d24c" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr mb jy jz ka bi translated">AppCompat的内部视图膨胀器为每个膨胀的视图提供一个ContextWrappers。</li></ol><p id="a4d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好玩吧？正如我所说的，这些都是实现细节，所以如果你不理解也不用担心。我知道你们中的一些人喜欢知道这类事情。</p></div></div>    
</body>
</html>