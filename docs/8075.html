<html>
<head>
<title>Understanding the worker ants of Spring Aspect Oriented Programming: Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Spring面向方面编程的工蚁:代理</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/understanding-the-worker-ants-of-spring-aop-proxies-902208881493?source=collection_archive---------0-----------------------#2021-11-05">https://medium.com/walmartglobaltech/understanding-the-worker-ants-of-spring-aop-proxies-902208881493?source=collection_archive---------0-----------------------#2021-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3210ac71eb8302526a8901d6f58d7fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSCm-IXwmYYScsdau_L77w.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@i__prabir?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Prabir Kashyap</a> on <a class="ae it" href="https://unsplash.com/s/photos/ants?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="iu iv iw"><p id="9bff" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi"> <em class="hh">“如果你希望你的代码易于编写，那就让它易于阅读。”—罗伯特·c·马丁，干净的代码</em>T3】</strong></p></blockquote><p id="09c7" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">在主要业务逻辑和其他横切关注点之间有一个清晰的分离对于干净和可读的代码是必不可少的。安全性和事务管理之类的问题并不是您手头的核心任务。将这些与业务代码纠缠在一起会导致与核心功能的严重耦合，如果它们失败，可能会受到影响。作为一名程序员，我坚定了袖手旁观的这一信念:</p><p id="3530" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi"> <em class="iz">“不要离开肮脏的代码库……快跑！!"</em> </strong></p><p id="1c69" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">面向方面编程(AOP) </strong>是你工具箱中的一个很好的工具，可以满足那些与你的核心功能无关的需求。它允许您在不修改代码本身的情况下向现有代码添加行为。AOP通过提供另一种实现模块化和减少代码混乱的方法来补充OOP。Spring有自己的AOP框架，在概念上很容易理解，是解决企业Java应用程序中大多数问题的优秀解决方案。</p><p id="078a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">在本文中，我们将解开AOP黑匣子内部的秘密，以充分发挥其真正的力量，并突出其局限性。如果您不熟悉AOP文献，可以在这里浏览一下<a class="ae it" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-introduction-defn" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7050" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">代理和运行时编织</h1><p id="b2d3" class="pw-post-body-paragraph ix iy hh ja b jb kx jd je jf ky jh ji jw kz jl jm jx la jp jq jy lb jt ju jv ha bi translated">一个<strong class="ja hi">代理</strong>是AOP框架为了实现方面契约而创建的一个对象。简而言之，它是一个bean实例的包装器，维护对象的接口，并可选地添加额外的行为。Spring使用代理自动地添加额外的行为，而不需要修改现有的代码。这可以通过以下两种方式实现:</p><ol class=""><li id="582f" class="lc ld hh ja b jb jc jf jg jw le jx lf jy lg jv lh li lj lk bi translated">JDK动态代理——Spring AOP默认使用JDK动态代理，它可以代理任何接口(或接口集)。只要目标对象实现了一个接口，就会使用JDK动态代理。</li><li id="30c5" class="lc ld hh ja b jb ll jf lm jw ln jx lo jy lp jv lh li lj lk bi translated">CGLIB代理—如果业务对象不实现任何接口，则默认情况下使用。</li></ol><p id="a25e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">因为代理位于对象的调用者和真实对象本身之间，所以它可以在目标对象被调用之前和之后做一些事情，从而充当Spring AOP的工作蚂蚁。</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/73d1ffdef93e2d4490ceb6992b52b7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlhKkus6DoFVkQUx2iWIVg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Spring AOP Process (<a class="ae it" href="https://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="f73a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">目标对象在运行时被代理有效地包装起来。当Spring确定一个bean被一个或多个方面通知时，它会为该bean生成一个代理来拦截方法调用，并确保通知按需运行。目标类实例在应用程序启动期间或运行时的任何其他时间，在它被使用之前，被改变成代理。这叫做<strong class="ja hi">运行时编织</strong>。任何对目标方法的调用都相应地被目标代理类截获，以执行任何合适的通知。</p><h1 id="b8db" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">代理诉讼</h1><p id="d233" class="pw-post-body-paragraph ix iy hh ja b jb kx jd je jf ky jh ji jw kz jl jm jx la jp jq jy lb jt ju jv ha bi translated">考虑这个例子，对于Logger方面的创建，它记录了用@Loggable注释的每个方法所花费的时间</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://gist.github.com/srishtikohli99/460884b5513b360f82cde5619b311895" rel="noopener ugc nofollow" target="_blank">Source Code</a></figcaption></figure><p id="7029" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这会产生以下输出:</p><pre class="lr ls lt lu fd lx ly lz ma aw mb bi"><span id="5c23" class="mc ka hh ly b fi md me l mf mg">test method called<br/>testUtil method called<br/>Execution time for Test.test :: 18 ms<br/><strong class="ly hi">Out of Test</strong><br/>testUtil method called<br/>Execution time for Test.testUtil :: 0 ms</span></pre><p id="7560" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">当spring确定一个或多个方面通知了<code class="du mh mi mj ly b"><em class="iz">Test</em></code> bean时，它会自动生成一个代理来拦截所有方法调用，并在需要时执行任何相关的通知。但是，从输出中可以观察到，<code class="du mh mi mj ly b"><em class="iz">test</em></code>方法中的<code class="du mh mi mj ly b"><em class="iz">pojo.testUtil()</em></code> <em class="iz"> </em>调用记录了方法执行时间，而<code class="du mh mi mj ly b"><em class="iz">this.testUtil()</em></code>调用没有记录。为什么？这是因为后者不是由代理截获的，而是由实际的目标类截获的。因此，建议永远不会被触发。让我们看看实际发生了什么，以便更好地理解。</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/f7171a1319eb522523862a9a01a80763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ezq15AYpw6dpN4tQkgp_eA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Around advice UML call diagram</figcaption></figure><p id="bb51" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">目的地为<code class="du mh mi mj ly b"><em class="iz">Pojo</em></code> bean的<code class="du mh mi mj ly b"><em class="iz">pojo.test()</em></code>调用由代理接收，然后调用通知方法。然后，around通知直接调用目标方法。一旦调用最终到达目标对象，它可能对自身(这里是<code class="du mh mi mj ly b"><em class="iz">this.testUtil()</em></code>)进行的任何方法调用都将针对<code class="du mh mi mj ly b"><em class="iz">this</em></code>引用而不是代理进行调用。</p><p id="974a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">因此，<strong class="ja hi">自调用不会导致相关的通知运行。</strong></p><p id="5966" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">注意:</strong>类上的<em class="iz"> @Aspect </em>注释将其标记为一个方面，因此将其从自动代理中排除。因此，<strong class="ja hi">在Spring AOP中，方面本身不可能成为来自其他方面的建议的目标。</strong></p><h1 id="8e3e" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">性能影响</h1><p id="9958" class="pw-post-body-paragraph ix iy hh ja b jb kx jd je jf ky jh ji jw kz jl jm jx la jp jq jy lb jt ju jv ha bi translated">因为代理是在调用代码和目标对象之间添加的中间物，所以引入一些开销就不足为奇了。值得注意的是，这个开销是<strong class="ja hi">固定的</strong>。无论普通方法的执行时间如何，代理调用都会增加固定的延迟。实际问题是，我们应该关心这种延迟吗？是也不是！</p><ol class=""><li id="617d" class="lc ld hh ja b jb jc jf jg jw le jx lf jy lg jv lh li lj lk bi translated">如果额外的行为本身比代理机制本身具有更大的性能影响(如缓存或事务管理)，那么开销似乎可以忽略不计。然而，如果行为是细粒度的，并且需要应用于大量的对象(比如记录每个方法)，那么开销就不再是微不足道的了。</li><li id="d3f8" class="lc ld hh ja b jb ll jf lm jw ln jx lo jy lp jv lh li lj lk bi translated">另一个关注点是一个请求中涉及的代理对象的数量。如果一个请求涉及到对数百或数千个代理方法的调用，那么开销就变得很大，不能忽略。</li></ol><p id="35a6" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">对于这些使用基于代理的系统无法解决需求的罕见场景，最好使用<strong class="ja hi">字节码编织</strong>。字节码编织带类和方面，产生编织<em class="iz">。类</em>文件作为输出。由于方面被直接编织到代码中，这提供了更好的性能，但是与Spring AOP相比更难实现。</p><h1 id="d1fa" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">总结</h1><p id="20d1" class="pw-post-body-paragraph ix iy hh ja b jb kx jd je jf ky jh ji jw kz jl jm jx la jp jq jy lb jt ju jv ha bi translated">为了充分发挥Spring AOP的潜力，掌握Spring AOP是<strong class="ja hi">基于代理的</strong>这一事实至关重要。代理包装了一个对象，并透明地添加了额外的行为来满足多种关注。它有很大的好处，如增强代码可读性，简化结构和集中管理。代理确实有性能方面的副作用，但是在大多数情况下这是无关紧要的。</p><h1 id="63fe" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><div class="ml mm ez fb mn mo"><a href="https://docs.spring.io/spring-framework/docs/2.5.x/reference/aop.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hi fi z dy mt ea eb mu ed ef hg bi translated">第六章。用Spring进行面向方面编程</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">面向方面编程(AOP)通过提供另一种思维方式来补充面向对象编程(OOP)</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">docs.spring.io</p></div></div><div class="mx l"><div class="my l mz na nb mx nc in mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://learning.oreilly.com/library/view/pivotal-certified-professional/9781484251362/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hi fi z dy mt ea eb mu ed ef hg bi translated">pivotal Certified Professional Core Spring 5开发者考试:使用Spring Framework 5的学习指南</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">通过Core Spring的Pivotal认证专家考试，基于最新的Spring Framework 5，使用源代码…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">learning.oreilly.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc in mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://spring.io/blog/2007/07/19/debunking-myths-proxies-impact-performance/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hi fi z dy mt ea eb mu ed ef hg bi translated">揭穿神话:代理影响性能</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">在最近的一篇博客文章中，Marc Logemann谈到了代理性能的主题。在他的条目中，他要求一个白色的…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">spring.io</p></div></div></div></a></div></div></div>    
</body>
</html>