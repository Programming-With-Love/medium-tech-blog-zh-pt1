<html>
<head>
<title>Understanding Kotlin contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解科特林合同</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/understanding-kotlin-contracts-f255ded41ef2?source=collection_archive---------0-----------------------#2019-01-07">https://blog.kotlin-academy.com/understanding-kotlin-contracts-f255ded41ef2?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ec92ec5694e1b8d299c4c2c2f9f95a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RLOdn8PEWTTfjEPj.jpg"/></div></div></figure><div class=""/><p id="1098" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从Kotlin 1.3开始，我们可以享受新的、神秘的特性——kot Lin契约。从使用的角度来看，它们看起来就像是作为函数的第一条语句的一段代码:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi kt"><img src="../Images/1a19dd8a67f5b4b76c77dd5fccdc7cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlvPYx6-rzJUd_CkzytGXg.png"/></div></div></figure><p id="4978" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管在编译过程中，整个块都消失了。这是因为契约构建器函数是一个具有空体的内联函数:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ky"><img src="../Images/1b0abf674b6aa6ea8b02c673c7b59b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zyxXsKtbGvrCRFEESIBJA.png"/></div></div></figure><p id="2bd6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来很疯狂，但这是我们想要的行为。Kotlin契约是与编译器通信的一种方式，否则它们只会在编译后扰乱和减慢我们的代码。它们可以包含不同种类的信息，每一种都可以改善Kotlin的编程体验。让我们看看怎么做。</p><p id="6ee3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文基于对<a class="ae kz" href="http://kt.academy/" rel="noopener ugc nofollow" target="_blank"> Kt的更新。学院</a>我之前介绍过的科特林工作坊。因为已经使用了Kotlin 1.3，所以我们在教授新引入的特性时，只是给出了一个关于版本要求的警告。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><a href="https://www.kt.academy/workshop/refactoringToPatterns"><div class="gh gi la"><img src="../Images/62520e901df6820dab70ac182f9613ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyoUl26C3O3OEdhpbEuN0A.png"/></div></a></figure><h1 id="73a0" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是合同？</h1><p id="e7a1" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">传统上，契约只是要求真实的表达。像科特林<code class="fe me mf mg mh b">require</code>:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/08b1011811830417f894ca1466e28d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hijwHTaJgyYAKnw5vCqGqg.png"/></div></div></figure><p id="9343" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">他们在那里陈述一些无法用其他方式检查的需求。例如，在C++模板<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929">中，类型参数</a>可以是任何东西。这就是为什么契约说只允许具有具体方法或字段的类型。所以合同主要是开发商的信息。</p><p id="3b1f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种信息在科特林我们称之为需求。Kotlin契约是为了与编译器交流，而不是与开发人员交流。Kotlin团队指定了两种对编译器有意义的消息:</p><ul class=""><li id="301d" class="mj mk iy jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">我们从一个参数中调用一个函数多少次</li><li id="3dde" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">函数返回某个值这一事实的含义</li></ul><p id="98bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来详细看看，这些合同的后果是什么。</p><h1 id="05ec" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们从一个参数中调用一个函数多少次</h1><p id="2769" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">我们声明一个函数被<code class="fe me mf mg mh b">callsInPlace</code>块和<code class="fe me mf mg mh b">InvocationKind</code>调用了多少次:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mx"><img src="../Images/b4d5dc1bc8dbfa89fba00e5ff8a01f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiNzylyvm3CyreWSQ0T_uw.png"/></div></div></figure><p id="22d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有四种可能的调用类型:</p><ul class=""><li id="2e09" class="mj mk iy jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">最多一次</li><li id="f5a2" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">至少一次</li><li id="711e" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">正好_一次</li><li id="9a78" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">未知的</li></ul><p id="e5e2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们都允许不同类型的行为。首先，当我们知道lambda表达式中的代码只被调用一次时，我们知道可以在那里初始化变量:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0c60b7a1eb25e28b93d8fb64961da4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*tzCp6AeKhA2cm0X-F-oqbw.png"/></div></figure><p id="2c73" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它对任何其他类型的调用都不起作用，因为它们要么不能保证变量将被初始化(<code class="fe me mf mg mh b">AT_MOST_ONCE</code>和<code class="fe me mf mg mh b">UNKNOWN</code>)，要么可能试图重新初始化<code class="fe me mf mg mh b">val</code> ( <code class="fe me mf mg mh b">AT_LEAST_ONCE</code>)</p><p id="be21" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想要初始化/设置<code class="fe me mf mg mh b">var</code>，我们可以在lambda初始化<code class="fe me mf mg mh b">EXACTLY_ONCE</code>和<code class="fe me mf mg mh b">AT_LEAST_ONCE</code>时都这样做:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mz"><img src="../Images/861336fe74bcea58e630341468c5afb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHS7eickahwwBu3FeIJV_Q.png"/></div></div></figure><p id="448b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也支持警告。块中至少被调用一次的代码可以被视为函数的一部分。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi na"><img src="../Images/22c63451d7eff4b604991c88ed0d7a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*r-v-9IkERoXZroAlCASmSA.png"/></div></figure><p id="280d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重点是，如果在块中使用return，则在块后没有必要使用return:</p><pre class="ku kv kw kx gt nb mh nc nd aw ne bi"><span id="ba50" class="nf lc iy mh b gy ng nh l ni nj"><strong class="mh iz">fun </strong>makeDialog(): Dialog {<br/>    DialogBuilder().apply <strong class="mh iz">{<br/>        </strong>title = <strong class="mh iz">"Alert"<br/>        </strong>setPositiveButton(<strong class="mh iz">"OK"</strong>, <strong class="mh iz">{ </strong><em class="nk">/**/ </em><strong class="mh iz">}</strong>)<br/>        setNegativeButton(<strong class="mh iz">"Cancel"</strong>, <strong class="mh iz">{ </strong><em class="nk">/**/ </em><strong class="mh iz">}</strong>)<br/>        <strong class="mh iz">return </strong>create()<br/>    <strong class="mh iz">}</strong><br/><strong class="mh iz">}</strong></span></pre><p id="ad22" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，下表总结了每种调用类型的这3种功能:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nl"><img src="../Images/03daf99e3a9725bacc117e430c10db22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYR6Hq__3vODsz82D68FGg.png"/></div></div></figure><figure class="ku kv kw kx gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi la"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="def5" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数返回某个值这一事实的含义</h1><p id="81b8" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">这种功能的一个很好的例子是<code class="fe me mf mg mh b">Collection&lt;T&gt;?.isNullOrEmpty</code>函数。传统上，我们可以用它来检查集合是否为null或空，但它不能智能转换这个变量。现在是了，多亏了科特林的合同。函数声明如下所示:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/b4ba5351d1663641895ad0654bc78c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Yd57CUvjW9D4JKZUfc_QQ.png"/></div></div></figure><p id="3455" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">合同规定，如果函数返回false，则接收方不为null。根据这些信息，如果编译器知道函数返回false，它会智能转换变量:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/033dcdeb46074756a97bd127a83627c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHT-501luo5wCgvSIVMD-Q.png"/></div></div></figure><p id="033d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此功能也可用于实现类型的智能转换:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi no"><img src="../Images/95e4e957102048723fc4c74e81938d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZmdZJMLQH35bQFlDNgZbw.png"/></div></div></figure><p id="1f16" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在只允许true/false返回值，这满足了大多数情况。虽然也许有一天我们将能够交流不同结果的含义。</p><h1 id="4ac3" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">是全部吗？</h1><p id="0608" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">是的，暂时的。我希望Kotlin协程能够进步，让我们表达更多关于函数的信息。例如，如果我们可以说将调用一个或另一个函数，我们可以涵盖更多类型的回调:</p><pre class="ku kv kw kx gt nb mh nc nd aw ne bi"><span id="5bc8" class="nf lc iy mh b gy ng nh l ni nj"><strong class="mh iz">suspend fun </strong>getUserId(): Int? {<br/>    getUser(<br/>       onSuccess = <strong class="mh iz">{ return </strong>it.<em class="nk">id </em><strong class="mh iz">}</strong>,<br/>       onError = <strong class="mh iz">{ return null }<br/>    </strong>)<br/>}</span></pre><p id="4b0b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，更强大的效果推理可能是有用的。虽然，现在，这只是一厢情愿的想法。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><a href="https://blog.kotlin-academy.com/write-for-kotlin-academy-abebd70937ce"><div class="gh gi la"><img src="../Images/87c508a2627eaa3d0e472518952dc75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoIe6R-7DJyXGh8tYeqjA.jpeg"/></div></a></figure><h1 id="1cbd" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="27f9" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">Kotlin契约引入了重要的改进，尤其是对标准库函数的改进。除了语言和编译器之间的合作，这些改进是无法通过其他方式实现的。他们给了我们更智能的编译器，所以更好的编程体验。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="376c" class="nf lc iy bd ld nw nx dn lh ny nz dp ll kg oa ob lp kk oc od lt ko oe of lx og bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="5260" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae kz" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="2ae5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kz" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi la"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>