<html>
<head>
<title>Dependency Injection Using Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot的依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/edureka/what-is-dependency-injection-5006b53af782?source=collection_archive---------0-----------------------#2019-07-02">https://medium.com/edureka/what-is-dependency-injection-5006b53af782?source=collection_archive---------0-----------------------#2019-07-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/aa429c8dc0a7036ebc23c0b245690fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*g-9gmebUPFBVW-XGjuQJhg.png"/></div><figcaption class="il im et er es in io bd b be z dx">Dependency Injection — Edureka</figcaption></figure><p id="86e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在一个我们每天都在使用编程语言的世界里，我们所有人都倾向于寻找方法和技巧来使我们的生活变得简单。依赖注入就是这样一种技术，它旨在通过提供对另一个对象的依赖来帮助开发人员轻松编码。在这篇关于什么是依赖注入的文章中，我将帮助您详细理解这项技术。</p><p id="5a11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文将涵盖以下主题:</p><ul class=""><li id="bb41" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">依赖注入简介</li><li id="05f4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">控制反转</li><li id="3017" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">依赖注入的类型</li><li id="1b09" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">依赖注入的好处</li><li id="840c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用Spring Boot实现依赖注入</li></ul><p id="a314" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，就从这篇文章开始吧。</p><h1 id="6033" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是依赖注入？</h1><p id="3641" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">依赖注入是一个对象提供另一个对象的依赖的能力。</p><p id="50f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我很确定，你可能不理解上面的技术定义。所以，让我为你澄清困惑。</p><p id="0410" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你听到依赖这个词时，你会想到什么？</p><p id="16f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很明显，有些东西依赖于其他东西的支持，对吗？</p><p id="02bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，这是相同的，在编程的情况下也是如此。</p><p id="1290" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编程中的依赖是一种方法，其中一个类使用另一个类的特定功能。因此，举例来说，如果你考虑两个类A和B，并且说类A使用类B的功能，那么它暗示类A具有对类B的依赖性。现在，如果你用Java编码，那么你必须知道，你必须在类A使用对象之前创建类B的实例。</p><p id="bb98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，如果我现在必须为你定义依赖注入，那么为其他类创建一个对象并让该类直接使用依赖的过程就叫做依赖注入。它主要涉及三个类别:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es le"><img src="../Images/cb339c6f9a65923e4f98309479508a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*muhJboMa1mrwDDjRiTopAQ.png"/></div></figure><ul class=""><li id="0c68" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">客户端类:</strong>这是依赖类，依赖于服务类。</li><li id="2b59" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">服务类:</strong>这个类为客户端类提供服务。</li><li id="bcf2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">注入器类:</strong>这个类负责将服务类对象注入到客户端类中</li></ul><p id="5529" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您已经理解了什么是依赖注入，接下来让我带您了解依赖注入所基于的原则。</p><h1 id="4bab" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">控制反转</h1><p id="5cf8" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">正如我上面提到的，控制反转是依赖注入的一个原则。此外，顾名思义，控制反转基本上是用来反转一个类的不同种类的附加责任，而不是主要责任。</p><p id="1d82" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我必须用更简单的术语来解释你，那就考虑一个例子，你有烹饪的能力。根据国际奥委会的原则，你可以颠倒控制，所以你可以直接从外面订购，而不是烹饪食物，你可以在家门口收到食物。因此，食物送到你家门口的过程被称为控制倒置。</p><p id="e23e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你不必自己做饭，相反，你可以点餐，让送餐员为你送餐。这样，你就不必顾及额外的责任，只需专注于主要工作。</p><p id="bddb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您已经知道了依赖注入背后的原理，让我带您了解一下依赖注入的类型。</p><h1 id="13fb" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">依赖注入的类型</h1><p id="b2cf" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">依赖注入主要有三种类型:</p><ul class=""><li id="3bef" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">构造器注入:</strong>在这种类型的注入中，注入器通过客户端类构造器提供依赖。</li><li id="020c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> Setter注入/属性注入:</strong>在这种类型的注入中，注入器方法将依赖注入到客户端公开的Setter方法中。</li><li id="6387" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">接口注入:</strong>在这种类型的注入中，注入器使用接口来提供对客户端类的依赖。客户端必须实现一个接口，该接口将公开一个接受依赖关系的setter方法。</li></ul><p id="c770" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，我希望您已经理解了这样一个事实，即依赖注入负责创建对象，理解哪些类需要这些对象，并最终为这些类提供对象。因此，在这一点上，让我们接下来看看依赖注入的好处。</p><h1 id="30ca" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">依赖注入的好处</h1><p id="5da7" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在我列出依赖注入的好处之前，让我向您解释一下在行业层面上进行这种注入的必要性，以帮助您更好地理解这些好处。</p><p id="6630" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑一个场景，其中有一个电子邮件类，它的唯一职责是处理收到的电子邮件。现在，这个类将拥有诸如“收件人电子邮件地址”、“发件人电子邮件地址”、“电子邮件的主题和正文”等对象。</p><p id="a308" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果公司想要保存文本和音频消息，您认为这个类可以保存消息吗？</p><p id="bc21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，答案是否定的？</p><p id="1cff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是因为，Email类不能处理文本和音频消息的参数。在这种情况下，您必须重新创建该类。现在，重新创建类是一件相当麻烦的工作，尤其是如果您必须定期这么做的话。相反，如果您使用依赖注入，您可以在运行时更改对象。所以，用这种方法，你不需要重新创建类，这在很多方面对你有帮助。</p><p id="9694" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，如果我必须总结依赖注入的好处，那么下面是这些好处:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lj"><img src="../Images/a88ca6dd7eab37f40be66c7d93abc5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*-zuBGvf7HkAJQGFs2dn24g.png"/></div></figure><p id="8f15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，现在你知道了依赖注入的好处，让我们向前看，看看如何使用Spring Boot实现依赖注入。</p><h1 id="8f92" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何使用Spring Boot实现DI？</h1><p id="b2c5" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated"><strong class="ir hi">步骤1: </strong>打开您的<strong class="ir hi"> Eclipse IDE </strong>，通过右键单击并选择<strong class="ir hi"> Spring Starter项目</strong>来创建一个<strong class="ir hi"> Spring Boot应用程序</strong>。然后提及项目名称并点击<strong class="ir hi">完成</strong>。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lk"><img src="../Images/de3ce04ae1397bd1503512ad6c785cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*hhIyzmsj9pMevDEUb68w8A.png"/></div></figure><p id="7eda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要获得Spring Starter项目，您必须从Eclipse Marketplace安装Spring Tool Suite。</p><p id="8d85" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您将自动看到一个应用程序文件创建如下。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/eab40e1c46659993e1d32239e984a91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*jnGsWYxQPtlT2bj-OneNhg.png"/></div></figure><p id="be06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第二步:</strong>接下来，在同一个包中创建一个类。为此，右键单击file - &gt;选择<strong class="ir hi">类</strong>并提及<strong class="ir hi">类名。</strong>然后点击<strong class="ir hi">完成</strong>。这将创建一个<strong class="ir hi">类</strong>文件。在这里，我创建了一个客户类。参考下文。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/e9db96941d50b701697c02f6a32465e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUEBJGWM6HBhu8_7H5CqkQ.png"/></div></div></figure><p id="e5a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第三步:之后，让我们为这个类添加一些属性。因此，假设我们包括<em class="lr">客户ID、客户名称</em>和<em class="lr">课程名称。</em>下面提一下代码。</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="bd40" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo; //package name<br/> <br/>public class Customers {<br/>private int custid;<br/>private String custname;<br/>private String coursename;<br/> <br/>}</span></pre><p id="e07c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤3.1: </strong>一旦你完成了，你必须<strong class="ir hi">为这些属性生成Getter和Setter方法</strong>。为此，选择这些属性并单击右键。然后选择<strong class="ir hi">源</strong>-&gt;-<strong class="ir hi">生成Getter和Setter方法。</strong></p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/9bc4a8c4a06700f5de821e16ff631264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*zlCWOTLMvVrok05sbbINCw.png"/></div></figure><p id="4786" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，您的代码应该如下所示:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="ecfa" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo;<br/> <br/>public class Customers {<br/>private int custid;<br/>private String custname;<br/>private String coursename;<br/> <br/>public int getCustid() {<br/>return custid;<br/>}<br/>public void setCustid(int custid) {<br/>this.custid = custid;<br/>}<br/>public String getCustname() {<br/>return custname;<br/>}<br/>public void setCustname(String custname) {<br/>this.custname = custname;<br/>}<br/>public String getCoursename() {<br/>return coursename;<br/>}<br/>public void setCoursename(String coursename) {<br/>this.coursename = coursename;<br/>}<br/>}</span></pre><p id="5d2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lr">现在，考虑一个场景，您必须为客户创建一个对象，但您不想手动完成。在这种情况下，您将不得不使用依赖注入，以便在您需要时获取对象。</em> </strong></p><p id="03b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，接下来让我们看看如何才能达到同样的效果。</p><p id="be3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第四步:</strong>首先，将<strong class="ir hi">应用类文件</strong>中的<strong class="ir hi">运行行</strong>修改为:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="b6a5" class="lx kc hh lt b fi ly lz l ma mb">ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);</span></pre><p id="63b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:如果你得到一个错误，输入如下:</strong></p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="bcee" class="lx kc hh lt b fi ly lz l ma mb">import org.springframework.boot.SpringApplication; <br/>import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext;</span></pre><p id="f5f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面这行代码将在执行时返回一个对象。现在将下面的代码添加到应用程序文件中。</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="0ca8" class="lx kc hh lt b fi ly lz l ma mb">customers c = context.getBean(customers.class);</span></pre><p id="4cfd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面一行告诉编译器返回customer类的一个对象。参考下文。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es md"><img src="../Images/a43c8e2f5001a79d1c00432e99dc8bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz6uW52u5b5kl_POwT-mcw.png"/></div></div></figure><p id="7d66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4.1: </strong>现在，要检查它是否工作，您<strong class="ir hi">可以返回到客户类</strong>并添加一个方法，如下所示:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="6d4a" class="lx kc hh lt b fi ly lz l ma mb">public void display()<br/> <br/>{<br/> <br/>System.out.println("Object Returned Successfully");<br/> <br/>}</span></pre><p id="6cff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该方法将在成功执行时显示输出“对象成功返回”。</p><p id="a9e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第4.2步:</strong>接下来，你要回到申请文件，提及以下内容:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="079f" class="lx kc hh lt b fi ly lz l ma mb">c.display();</span></pre><p id="3821" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，您就可以通过引用display方法来调用Customers类的对象。到目前为止，应用程序类的代码见下图:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/a8edf7064dfb863cda073b0a51135357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*eal0qpvjSZbn44VsmKyc2w.png"/></div></figure><p id="d0ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果您执行这个项目，您将会看到一个<strong class="ir hi">异常，没有类型</strong>的合格bean。<em class="lr">这是因为您定义的客户类不是Spring Bean，即不是Spring对象。</em>参考下文。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es me"><img src="../Images/4b311ba5cda52a513fac2eb554c9b978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*u2oRTSNL8NC15DMS7WQ6Xg.png"/></div></figure><p id="90d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4.3: </strong>因此，为了告诉Spring容器，我们需要一个customer类的对象。为此，您需要在Customer类中提到<strong class="ir hi">@组件注释</strong>。Customers类中的代码应该如下所示:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="252c" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo;<br/> <br/>import org.springframework.stereotype.Component;<br/><a class="ae mf" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a><br/>public class Customers {<br/>private int custid;<br/>private String custname;<br/>private String coursename;<br/> <br/>public int getCustid() {<br/>return custid;<br/>}<br/>public void setCustid(int custid) {<br/>this.custid = custid;<br/>}<br/>public String getCustname() {<br/>return custname;<br/>}<br/>public void setCustname(String custname) {<br/>this.custname = custname;<br/>}<br/>public String getCoursename() {<br/>return coursename;<br/>}<br/>public void setCoursename(String coursename) {<br/>this.coursename = coursename;<br/>}<br/>public void display()<br/> <br/>{<br/>System.out.println("Object Returned Successfully");<br/> <br/>}<br/>}</span></pre><p id="f79d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，当你提到客户<strong class="ir hi">c = context . get bean(customers . class)；</strong>编译器将检查容器中是否有可用的客户bean。</p><p id="929a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果Bean是可用的，那么Spring框架会在应用程序中注入customer对象。所以，基本上，这个对象是由Spring框架创建的，可以在应用程序中进一步使用。</p><p id="b10e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，如果我现在执行这个项目，您将看到Object成功返回的输出。参考下文。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/9ee1230ac7ba3a911f565e6e5871b509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*jCylxe8ANA50cDEoCH_3mg.png"/></div></figure><p id="a14d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是你实现依赖注入的基本方法。T9】</p><p id="6290" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">示例:使用自动连线注释的依赖注入</strong></p><p id="76c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望你已经理解了依赖注入在Spring Boot是如何工作的。现在，让我们扩展这个例子，进一步看看在Spring Boot中一个依赖于另一个类的类是如何使用那个类的功能的。</p><p id="d986" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤1: </strong>通过再次<strong class="ir hi">右击包</strong>并通过选择<strong class="ir hi">新建- &gt;类，创建一个新的<strong class="ir hi">类文件</strong>。</strong>现在，按如下方式提及类名，并点击<strong class="ir hi">完成。</strong></p><p id="ee49" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，让我们为这个类添加一些属性。所以，让我们说，我们包括<em class="lr"> TechID，Techname。</em>下面提一下代码。</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="6726" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo;<br/>public class Technologies {<br/>private int techid;<br/>private String techname;<br/>}</span></pre><p id="5209" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤2.1: </strong>一旦你完成了这些，右键点击文件，为这些属性生成<strong class="ir hi"> Getter和Setter方法</strong>，然后选择<strong class="ir hi"> Source - &gt; Generate Getter和Setter方法。</strong></p><p id="18bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤3: </strong>现在，让我们说，我们必须创建一个打印“<strong class="ir hi">成功的</strong>”的方法。为此，请提及代码:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="8500" class="lx kc hh lt b fi ly lz l ma mb">public void tech()<br/>{<br/>System.out.println(" Successful");<br/>}</span></pre><p id="a55f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，您的代码应该如下所示:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="d745" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo;<br/> <br/>public class Technologies {<br/>private int techid;<br/>private String techname;<br/>public int getTechid() {<br/>return techid;<br/>}<br/>public void setTechid(int techid) {<br/>this.techid = techid;<br/>}<br/>public String getTechname() {<br/>return techname;<br/>}<br/>public void setTechname(String techname) {<br/>this.techname = techname;<br/>}<br/>public void tech()<br/> <br/>{<br/> <br/>System.out.println(" Successful");<br/> <br/>}<br/>}</span></pre><p id="c722" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4: </strong>现在，要调用<strong class="ir hi">客户类</strong>中的<strong class="ir hi"> tech()方法</strong>，您必须创建一个technologies类的对象。因此，在customers类中提到下面一行代码:</p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="8a9d" class="lx kc hh lt b fi ly lz l ma mb">private Technologies techdetail;</span></pre><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/1a79550b951cb4559f6e51939bce5baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0JlgVsDre5TmhC95EHE3A.png"/></div></div></figure><p id="4b86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">步骤4.1: </strong>一旦完成，通过<strong class="ir hi">右键单击文件</strong>，然后选择<strong class="ir hi">源- &gt;生成Getter和Setter方法，为这些属性生成<strong class="ir hi"> Getter和Setter方法</strong>。</strong></p><p id="50d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第五步:</strong>接下来要使用<strong class="ir hi"> tech()方法</strong>，就不得不提一下<strong class="ir hi">tech detail . tech()；</strong>客户类别的<strong class="ir hi">显示方式下。此外，为了确保techdetail对象被实例化，请提及<strong class="ir hi">@组件注释</strong>是<strong class="ir hi">技术类。</strong>参考下文。</strong></p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/d4dd103a92fff6de6444c85414dc1228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pq7lsHvc7XwjE-eC24OYTw.png"/></div></div></figure><p id="624d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当您执行这个项目时，您将看到一个<strong class="ir hi">空指针异常</strong>。这是因为现在<strong class="ir hi"> <em class="lr">客户类依赖于技术类，但它不知道技术类</em> </strong>的存在。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/96eea15ded90ba19c72777d9a87aa294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*8PS6KDS4AHca4ecs2RvzXA.png"/></div></figure><p id="8388" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lr">因此，为了使客户能够识别技术类，您必须在客户类中插入</em><strong class="ir hi"><em class="lr">@ Autowired annotation</em></strong><em class="lr">。客户类的最终代码应该如下:</em></p><pre class="lf lg lh li fd ls lt lu lv aw lw bi"><span id="cb33" class="lx kc hh lt b fi ly lz l ma mb">package com.example.demo;<br/> <br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.stereotype.Component;<br/><a class="ae mf" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a><br/>public class Customers {<br/>private int custid;<br/>private String custname;<br/>private String coursename;<br/><a class="ae mf" href="http://twitter.com/Autowired" rel="noopener ugc nofollow" target="_blank">@Autowired</a><br/>private Technologies techdetail;<br/> <br/>public Technologies getTechdetail() {<br/>return techdetail;<br/>}<br/>public void setTechdetail(Technologies techdetail) {<br/>this.techdetail = techdetail;<br/>}<br/>public int getCustid() {<br/>return custid;<br/>}<br/>public void setCustid(int custid) {<br/>this.custid = custid;<br/>}<br/>public String getCustname() {<br/>return custname;<br/>}<br/>public void setCustname(String custname) {<br/>this.custname = custname;<br/>}<br/>public String getCoursename() {<br/>return coursename;<br/>}<br/>public void setCoursename(String coursename) {<br/>this.coursename = coursename;<br/>}<br/>public void display()<br/> <br/>{<br/> <br/>System.out.println("Object Returned Successfully");<br/>techdetail.tech();<br/> <br/>}<br/>}</span></pre><p id="f749" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦您执行了这些文件，您将看到Object成功返回的输出，这意味着我们已经完成了对类的依赖。参考下文。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/85b66bec0f9c49b34b94a0e6fead981c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*pNNbgtrjaVz65NQhtlP_YA.png"/></div></figure><p id="ab57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到此为止，我们结束了这篇文章。</p><p id="9322" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="aa27" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Java的各个方面。</p><blockquote class="mj mk ml"><p id="8fd5" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">1.<a class="ae mf" rel="noopener" href="/edureka/object-oriented-programming-b29cfd50eca0">面向对象编程</a></p><p id="5052" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">2.<a class="ae mf" rel="noopener" href="/edureka/inheritance-in-java-f638d3ed559e">Java中的继承</a></p><p id="d05a" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">3.<a class="ae mf" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b">Java中的多态性</a></p><p id="de4e" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">4.<a class="ae mf" rel="noopener" href="/edureka/java-abstraction-d2d790c09037">Java中的抽象</a></p><p id="558e" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">5.<a class="ae mf" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> Java字符串</a></p><p id="5f17" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">6.<a class="ae mf" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> Java数组</a></p><p id="6701" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">7.<a class="ae mf" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> Java集合</a></p><p id="705d" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">8.<a class="ae mf" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> Java线程</a></p><p id="a737" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">9.<a class="ae mf" rel="noopener" href="/edureka/java-servlets-62f583d69c7e">Java servlet简介</a></p><p id="48aa" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">10.<a class="ae mf" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> Servlet和JSP教程</a></p><p id="3435" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">11.<a class="ae mf" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c">Java中的异常处理</a></p><p id="2792" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">12.<a class="ae mf" rel="noopener" href="/edureka/advanced-java-tutorial-f6ebac5175ec">高级Java教程</a></p><p id="6ff4" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">13.<a class="ae mf" rel="noopener" href="/edureka/java-interview-questions-1d59b9c53973"> Java面试问题</a></p><p id="30cb" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">14.<a class="ae mf" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> Java程序</a></p><p id="2f61" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">15.<a class="ae mf" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04">科特林vs Java </a></p><p id="8f38" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">16.<a class="ae mf" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> Java教程</a></p><p id="873a" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">17.<a class="ae mf" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7">在Java中可比</a></p><p id="dd5d" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">18.<a class="ae mf" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39">十大Java框架</a></p><p id="31f0" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">19.<a class="ae mf" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> Java反射API </a></p><p id="7bad" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">20.<a class="ae mf" rel="noopener" href="/edureka/pattern-programs-in-java-f33186c711c8">Java中的30大模式</a></p><p id="8480" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">21.<a class="ae mf" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c">核心Java备忘单</a></p><p id="025f" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">22.<a class="ae mf" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0">Java中的套接字编程</a></p><p id="854f" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">23.<a class="ae mf" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> Java OOP备忘单</a></p><p id="04ae" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">24.<a class="ae mf" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb">Java中的注释</a></p><p id="5b31" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">25.<a class="ae mf" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17">Java中的图书管理系统项目</a></p><p id="c2bf" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">26.<a class="ae mf" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5">Java中的树</a></p><p id="cf26" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">27.<a class="ae mf" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368">Java中的机器学习</a></p><p id="02c7" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">28.<a class="ae mf" rel="noopener" href="/edureka/data-structures-algorithms-in-java-d27e915db1c5">Java中的顶级数据结构&amp;算法</a></p><p id="cb21" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">29.<a class="ae mf" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> Java开发者技能</a></p><p id="333d" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">30.<a class="ae mf" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d">前55个Servlet面试问题</a></p><p id="43c4" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">31.<a class="ae mf" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"> </a> <a class="ae mf" rel="noopener" href="/edureka/java-projects-db51097281e3">顶级Java项目</a></p><p id="3658" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">32.<a class="ae mf" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> Java字符串备忘单</a></p><p id="86f9" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">33.<a class="ae mf" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3">Java中的嵌套类</a></p><p id="61d2" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">34.<a class="ae mf" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> Java集合面试问答</a></p><p id="fe2a" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">35.<a class="ae mf" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中如何处理死锁？</a></p><p id="c7b4" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">36.<a class="ae mf" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e">你需要知道的50大Java集合面试问题</a></p><p id="1484" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">37.<a class="ae mf" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf">Java中的字符串池是什么概念？</a></p><p id="1d18" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">38.<a class="ae mf" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95">C、C++和Java有什么区别？</a></p><p id="5559" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">39.<a class="ae mf" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a">Java中的回文——如何检查一个数字或字符串？</a></p><p id="c5d0" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">40.<a class="ae mf" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e">你需要知道的顶级MVC面试问答</a></p><p id="91d4" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">41.<a class="ae mf" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0">Java编程语言的十大应用</a></p><p id="998d" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">42.<a class="ae mf" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中的死锁</a></p><p id="55cf" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">43.<a class="ae mf" rel="noopener" href="/edureka/java-sqrt-method-59354a700571">Java中的平方和平方根</a></p><p id="8681" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">44.<a class="ae mf" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1">Java中的类型转换</a></p><p id="cd56" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">45.<a class="ae mf" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a">Java中的运算符及其类型</a></p><p id="ce4a" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">46.<a class="ae mf" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc">Java中的析构函数</a></p><p id="b499" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">47.<a class="ae mf" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3">爪哇的二分搜索法</a></p><p id="db1c" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">48.<a class="ae mf" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684">Java中的MVC架构</a></p><p id="c56f" class="ip iq lr ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">49.<a class="ae mf" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8">冬眠面试问答</a></p></blockquote></div><div class="ab cl mp mq go mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ha hb hc hd he"><p id="2e12" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lr">原载于2019年7月2日</em><a class="ae mf" href="https://www.edureka.co/blog/what-is-dependency-injection/" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://www.edureka.co</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>