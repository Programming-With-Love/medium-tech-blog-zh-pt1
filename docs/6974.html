<html>
<head>
<title>Collection Framework: Quick Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">收集框架:快速指南</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/collection-framework-quick-guide-e9dbb21f940a?source=collection_archive---------0-----------------------#2021-08-21">https://medium.com/quick-code/collection-framework-quick-guide-e9dbb21f940a?source=collection_archive---------0-----------------------#2021-08-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5143" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java中的集合框架是接口和类的集合，它提供了存储和操作一组对象的架构，有助于高效地处理数据。</p><p id="033e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">集合接口封装了不同类型的集合，如下图所示。这些接口允许他们独立操作。下图中显示的接口是Java集合框架的基础。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/79fd70904e6b85453484e75b8b66fac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNsunqoRafiOc9VY7zHtbQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Collection Interface</figcaption></figure><p id="b7f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">集合表示一组称为元素的对象，由集合接口中的一组类实现。有些允许重复元素，而有些则不允许。每个集合都有一些默认方法。</p><h1 id="83e0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">列表界面</h1><p id="612b" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">列表是一个有序集合，它是集合接口的子接口。List接口由类ArrayList、LinkedList、Vector和Stack实现。</p><h2 id="cb04" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">数组列表</h2><p id="4b36" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">ArrayList是List接口的一个可调整大小的数组实现。存储在列表中的元素可以被随机访问。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="9845" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">链接列表</h2><p id="b95e" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">LinkedList是集合接口的实现。它在内部使用一个双向链表来存储元素。使用指针和地址来链接元素。我们不必在插入或删除后移动元素，所以插入和删除更容易。使用链表的一个小缺点是元素不能被直接访问，要访问一个元素我们需要从头开始。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="c34c" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">矢量</h2><p id="9784" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Vector是一个动态数组实现，意味着它是一个可增长的对象。它可以根据数组列表的需要而增长或收缩。唯一的区别是vector是同步的，因此它很少在非线程环境中使用。因为是同步的，所以在添加、搜索、删除和更新元素时，可以观察到较差的性能</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="61a9" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">堆</h2><p id="8779" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Stack是vector的子类。它用后进先出的方法实现了堆栈数据结构。栈的实现和向量一样，但是有额外的操作，比如<strong class="ig hi">推</strong>和<strong class="ig hi">弹出</strong>。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="e8e1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">队列接口</h1><p id="1e30" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">QueueInterface保持先进先出的顺序(FIFO)。这是一个功能有限的有序列表，你可以在列表的末尾插入元素，在列表的开头删除元素，也就是说，它遵循FIFO规则。有各种子类，让我们谈谈优先级队列。</p><h2 id="6b42" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">优先级队列</h2><p id="c9c6" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">它是队列接口的实现，用于根据优先级处理对象。它不允许空值。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="a3b6" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">SetInterface</h1><p id="7756" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">java.util包中存在Set接口。它是扩展集合框架的对象的无序集合，最多允许一个空值，并且不存储重复值。</p><h2 id="8bfd" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">哈希特</h2><p id="2323" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">HashSet是Set接口的一个实现。因为它实现了set接口，所以不允许出现重复值。HashSet的底层数据结构是Hashtable。它还实现了<strong class="ig hi">可序列化的</strong>和<strong class="ig hi">可克隆的</strong>接口。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="553d" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">LinkedHashSet</h2><p id="c618" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">LinkedHashSet是HashSet的有序版本。这个实现与HashSet的不同之处在于，它维护一个贯穿所有条目的双向链表。这个链表定义了迭代排序，即元素被插入到集合中的顺序(<em class="ll">插入顺序</em>)。允许空元素</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="5024" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">分类集合</h2><p id="6b83" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">SortedSet接口是集合接口中Set接口的实现。该方法继承了SetInterface的特性，并添加了以排序方式存储所有元素的特性。</p><h2 id="30c7" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">树集</h2><p id="16e7" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">TreeSet是集合接口的实现，也是集合接口的子集。然而，在树集中的访问和检索是快速的。TreeSet中的元素按升序存储。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fd0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个故事只是给你提供一个集合框架的基本概述。但是为了详细阅读它们，oracle文档是最好的参考。</p></div></div>    
</body>
</html>