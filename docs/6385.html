<html>
<head>
<title>Hashsets vs Binary Search Trees: Speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表vs二分搜索法树:速度</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/hashsets-vs-binary-search-trees-speed-aa86853f7c63?source=collection_archive---------0-----------------------#2018-01-26">https://medium.com/quick-code/hashsets-vs-binary-search-trees-speed-aa86853f7c63?source=collection_archive---------0-----------------------#2018-01-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="5be0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我读了一些关于二分搜索法树以及它们是如何被设计成快速搜索的，这让我很好奇。与这些树中的一个相比，从一个简单的hashset中查找结果如何。</p><p id="900b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们更好地定义这个问题:</p><p id="4882" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">给定一个长度为n的数据结构&lt;int&gt;——在这个结构中找到一个已知值并推断出这个结构中不存在一个值需要多长时间。</strong></p><p id="e733" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">考虑一个长度为5的数组:</p><p id="c305" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">[1，2，3，4，5] —找到数组中的值4并发现6不在数组中需要多长时间。</p><p id="9720" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一场精彩的老对决是找到答案的唯一方法*</p><p id="a5b4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">*除了谷歌、书籍、互联网、同事和任何知道如何编程的人。</p><h1 id="0f8a" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">竞争者:</h1><p id="00ee" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">不起眼的<strong class="in hi">阵作为对照组</strong>。</p><p id="e536" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">哈希集&lt; int &gt; </strong> —因为我们在这个实验中只使用整数，所以我们将使用哈希集(一个字典，其中key == Hashed(value))</p><p id="5a1a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">二叉查找树</strong> —不是中的内置数据类型。Net相对容易创建，并以快速搜索著称</p><h1 id="a928" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">搜索树:</h1><p id="ea87" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">BST不是我们在日常编程中使用的数据结构，所以这里简单介绍一下我是如何创建我的BST的。</p><p id="35e6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">BST是节点的集合(见下文)。每个节点都有一个值，并且不超过两个其他节点—左侧和右侧。小于父节点的每个子节点存储在左侧，大于父节点的每个子节点存储在右侧。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es km"><img src="../Images/9b721c17f665ecd7885c7a48367856e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*k4FNRTyCr7yjmJ_nmkLCTg.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">A BST</figcaption></figure><p id="f530" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用BST的优点是，您不必遍历整个数据结构来查找值或执行某种排序算法。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es ky"><img src="../Images/262a86f4feb03e7ebf6d6619cb73f1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*mTI9VKOBxWZLAjR4oRli-g.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">A Node on the tree</figcaption></figure><p id="7332" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用递归函数创建树相对简单:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es kz"><img src="../Images/2d9d26bb07dd274ca76119410b93a51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*3Vd6DhQKleB96Tl_NjMFkA.png"/></div></figure><p id="ec1d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这叫作像这样:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es la"><img src="../Images/cfdd8242d95f250a9e06b7bb2a09179b.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*a_2GDxXFjrlqkx9oq7dnkA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">Setting up the tree</figcaption></figure><p id="4177" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里值得一提的是，我知道这段代码的效率有多低。我们最终还是会枚举整个数组，递归也会占用内存，但是请记住，我们在这里测试查找的速度，所以我们暂时忽略这个问题。</p><p id="5eea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要在BST上搜索一个值，我们只需:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es lb"><img src="../Images/31f52b7dee74cf4f72f9f08712fa1409.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*9LKoOSfmDS2RwkGCdjSEBQ.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx">Searching algorithm</figcaption></figure><p id="f018" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了做这个实验，我创建了一个样本数据集:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es lc"><img src="../Images/ef546aa8352813b93829dee2493a6bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*8c5VkT_hUhMqdviSvljCIw.png"/></div></figure><p id="ba28" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">数组中间的值和数组末尾的值是我们要搜索的值，以及一个不存在的变量(1000001)。</p><p id="7e77" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了公平起见，我在数组中使用了从200k整数开始的Log10(n)标度。</p><h1 id="0545" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">结果是:</h1><p id="dff8" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">所以我不得不记录滴答的结果，因为无论你如何努力，在8核4Ghz处理器上做这个操作永远不会慢。</p><p id="4d01" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">结果显示…平局。多么乏味。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es ld"><img src="../Images/6fe7004fcd7d1ffa26a39df813de1b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*oESw6mR1U_1BN4CstIyiVA.png"/></div></figure><p id="6497" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">可以预见，数组搜索时间以O(n)的方式与数据集的大小成比例。然而，二叉查找树算法和哈希表。Contains()方法似乎花费了相同的时间。</p><p id="bf69" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最初，我对BST算法的性能感到惊讶。但仔细想想，终究不是那么令人惊讶。</p><p id="4122" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">节点上的FindValue方法将调用Log2(n)的最大值，其中n是初始样本大小(因为这是BST的最大深度)。</p><p id="df81" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请参见下表:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es le"><img src="../Images/220f1517463b7b0d3765095a2fd387b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*MF4ZNz3PsDNP_C0V0LJFuw.png"/></div></figure><p id="2e0f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将样本中的项目数量增加10倍只需要额外的3-4次方法调用，这实际上等于根本不需要时间。伟大的结果。</p><p id="339a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这意味着它和hashset查找一样高效，速度快得惊人！</p><p id="3c66" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在我们宣布二叉查找树胜利之前，这个实现(显然远非完美)拥有的内存是hashset的近10倍，创建它需要的时间也是hashset的近10倍。我怀疑，虽然无数小时的研究已经投入到精炼和完善散列表中，大约45分钟用于创建我的二叉查找树。</p><p id="edf7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">仍然:</p><p id="ce65" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">哈希集1–0英国夏令时</p></div></div>    
</body>
</html>