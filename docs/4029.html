<html>
<head>
<title>Redis Cache Implementation with NodeJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NodeJs实现Redis缓存</h1>
<blockquote>原文：<a href="https://medium.com/globant/redis-cache-implementation-with-nodejs-6925f29eb70e?source=collection_archive---------0-----------------------#2022-11-21">https://medium.com/globant/redis-cache-implementation-with-nodejs-6925f29eb70e?source=collection_archive---------0-----------------------#2022-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="6877" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">NODEJS系列</h2><div class=""/><figure class="ev ex io ip iq ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es in"><img src="../Images/e0912944d5cb8a9d13f12a0114113bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StIOFWQx7i6fxDQkiTTBow.png"/></div></div></figure><p id="472e" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在本文中，我们将研究Redis缓存，并探索是什么让它变得如此之快。此外，我们将展示如何使用Redis。此外，我们将观察如何在Windows计算机上安装Redis并运行一些基本的Redis命令。我们还将讨论使用代码片段和测试结果，通过NodeJs以编程方式使用Redis。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="3a9c" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis是什么？</h1><p id="b720" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated"><a class="ae lg" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>，代表<strong class="ja hr">远程词典服务器</strong>，是一个内存数据库。计算机的工作内存(RAM)是Redis运行的地方。因此，它的工作效率更高。Redis是一个无模式数据库，存储带有键值对的JSON对象，很像NoSQL数据库。构建模式和初始化数据库不需要时间。因此，它可以更快地执行应用程序测试。快速测试可以提高开发效率。</p><p id="886b" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">另一方面，Redis是不稳定的。考虑到如果你的系统突然出现故障，Redis里面的东西都会丢失。但是，我们可以复制Redis来创建数据备份，确保即使Redis主实例停止运行，副本也将继续运行并包含数据。Redis经常被用作缓存来提高应用程序的性能。Redis可以存储我们经常访问的数据，或者需要大量的计算时间。将来，如果需要的话，我们可以快速访问这些数据。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="3d53" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">是什么让Redis这么快？</h1><p id="e217" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated"><em class="lh">我们想知道Redis作为单线程怎么会这么快。</em></p><p id="8efd" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">Redis是内存数据库这一事实是其速度的主要因素。纯内存读取提供了快速的读/写速度和快速的响应时间，前提是您存储的数据不能大于内存。</p><p id="a260" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">IO多路复用的使用是第二个理由。Redis主要使用单线程。然而，由于IO多路复用，操作系统允许单个线程同时等待多个打开的套接字连接。单线程设计可能不会使用当前硬件中的所有CPU核心。因此，对于某些工作负载来说，在一台服务器上运行许多Redis实例以利用更多CPU内核是一种标准做法。</p><p id="d03d" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">采用高效的底层数据结构是第三个理由。由于Redis是内存数据库，它可以使用许多有效的底层数据结构，如<a class="ae lg" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank"> LinkedList </a>、<a class="ae lg" href="https://en.wikipedia.org/wiki/Skip_list" rel="noopener ugc nofollow" target="_blank"> SkipList </a>、<a class="ae lg" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank"> HashTable </a>、<a class="ae lg" href="https://redis.com/ebook/part-2-core-concepts/01chapter-9-reducing-memory-use/9-1-short-structures/9-1-1-the-ziplist-representation/" rel="noopener ugc nofollow" target="_blank"> ZipList </a>、<a class="ae lg" href="http://blog.wjin.org/posts/redis-internal-data-structure-sds.html" rel="noopener ugc nofollow" target="_blank"> SDS </a>和<a class="ae lg" href="http://blog.wjin.org/posts/redis-internal-data-structure-intset.html" rel="noopener ugc nofollow" target="_blank"> IntSet </a>，而不必担心如何高效地将它们保存到磁盘。</p><figure class="lj lk ll lm fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es li"><img src="../Images/f384d2c6fd4c19b9d79928fadceedcf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0I9z15x4ramAdiTZj2vvg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx"><strong class="bd kf">Illustration showing IO Multiplexing, Single Threaded Execution &amp; Redis Data Structure</strong> (Credits: Alex Xu)</figcaption></figure></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="9cb8" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis缓存是如何工作的？</h1><p id="252a" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">当客户机请求数据时，服务器首先在Redis缓存中搜索合适的键。如果这个键存在于Redis缓存中，那么就发生了<strong class="ja hr">缓存命中</strong>，用户将收到缓存的数据。如果Redis缓存中缺少这个键，这是一个<strong class="ja hr">缓存缺失</strong>，服务器将通过REST APIs从数据库或第三方资源中检索最新的信息。</p><figure class="lj lk ll lm fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es in"><img src="../Images/ab823451a594a4732512a48b16a8d400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdvNQWoaHhc1UY4Y10R93w.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Redis caching Illustration</figcaption></figure></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="430d" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Windows上的Redis安装</h1><p id="f671" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">我们可以使用Linux的Windows子系统在Windows上安装Redis缓存。遵循以下步骤。</p><ol class=""><li id="cf8a" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv lw lx ly lz bi translated">在管理员模式下打开命令提示符</li><li id="b47e" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">运行<code class="du mf mg mh mi b">wsl — install</code>命令在Windows中安装Windows Subsystem for Linux (WSL)。</li><li id="b988" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">重新启动系统以查看更改。</li><li id="42f2" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">为您的Linux系统设置一个新的用户名和密码。</li><li id="011d" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">启动Linux终端。</li><li id="814c" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">使用命令安装Redis】后跟<code class="du mf mg mh mi b">sudo apt-get install redis</code></li><li id="f633" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">使用<code class="du mf mg mh mi b">redis-server</code>命令启动Redis服务器。</li><li id="5e81" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">通过运行<code class="du mf mg mh mi b">redis-cli</code>命令打开Redis CLI</li></ol><p id="ea98" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">默认情况下，Redis服务器从<strong class="ja hr"> 127.0.0.1:6379 </strong>开始，并将所有内容存储为<strong class="ja hr">字符串</strong>。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="f4d4" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis Keys命令</h1><p id="9e16" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">Redis提供了以下基本命令来对键执行各种操作。</p><ul class=""><li id="ead4" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">SET key value</code>，<em class="lh">设置键值对。</em></li><li id="9ae4" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">GET key</code>，<em class="lh">获取给定键的值。</em></li><li id="5cf5" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">DEL key</code>，<em class="lh">删除给定的键。</em></li><li id="8388" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">EXISTS key</code>、<em class="lh">检查一个键是否存在。</em></li><li id="b43f" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated">找到所有匹配特定模式的键。</li><li id="eb74" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">flushall</code>，<em class="lh">删除Redis里面的一切。</em></li><li id="49c2" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">SETEX key seconds value</code>、<em class="lh">设置给定秒数后过期的键值。</em></li><li id="65f8" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">ttl key</code>，<em class="lh">返回一个密钥剩余的到期时间。</em></li></ul><p id="68ef" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">下面的代码片段演示了这些命令的用法和输出。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="3890" class="mo ke hh mi b be mp mq l mr ms">chikku@DESKTOP-21GGVDA:~$ redis-cli<br/>127.0.0.1:6379&gt; set firstName Luke<br/>OK<br/>127.0.0.1:6379&gt; set lastName Antony<br/>OK<br/>127.0.0.1:6379&gt; set age 32<br/>OK<br/>127.0.0.1:6379&gt; set email luke@gmail.com<br/>OK<br/>127.0.0.1:6379&gt; get email<br/>"luke@gmail.com"<br/>127.0.0.1:6379&gt; keys *<br/>"age"<br/>"lastName"<br/>"email"<br/>"firstName"<br/>127.0.0.1:6379&gt; exists email<br/>(integer)1<br/>127.0.0.1:6379&gt; del email<br/>(integer)1<br/>127.0.0.1:6379&gt; exists email<br/>(integer)0<br/>127.0.0.1:6379&gt; keys *<br/>"age"<br/>"lastName"<br/>"firstName"<br/>127.0.0.1:6379&gt; setex city 10 Bangalore<br/>OK<br/>127.0.0.1:6379&gt; keys *<br/>"age"<br/>"lastName"<br/>"firstName"<br/>"city"<br/>127.0.0.1:6379&gt; ttl city<br/>(integer)4<br/>127.0.0.1:6379&gt; ttl city<br/>(integer)3<br/>127.0.0.1:6379&gt; ttl city<br/>(integer)2<br/>127.0.0.1:6379&gt; ttl city<br/>(integer)1<br/>127.0.0.1:6379&gt; ttl city<br/>(integer)-2<br/>127.0.0.1:6379&gt; keys *<br/>"age"<br/>"lastName"<br/>"firstName"<br/>127.0.0.1:6379&gt; flushall<br/>OK<br/>127.0.0.1:6379&gt; keys *<br/>(empty list or set)</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="4196" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis列表命令</h1><p id="5647" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">Redis列表是简单的字符串列表。在Redis列表中，我们可以在列表的头部或尾部添加元素。命令如下所示。</p><ul class=""><li id="7d8d" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">lpush key value</code>，<em class="lh">将元素推到数组的最左端。</em></li><li id="820f" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">rpush key value</code>，<em class="lh">将元素推到数组的最右端。</em></li><li id="0417" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">lrange key startIndex stopIndex</code>、<em class="lh">显示开始和停止索引之间的元素列表</em></li><li id="1ca9" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">lpop key</code>，<em class="lh">弹出数组最左边的元素。</em></li><li id="5440" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">rpop key</code>，<em class="lh">弹出数组最右边的元素。</em></li></ul><p id="f9b1" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">下面的代码片段显示了Redis list命令的使用和输出。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="c9d0" class="mo ke hh mi b be mp mq l mr ms">chikku@DESKTOP-21GGVDA:~$ redis-cli<br/>127.0.0.1:6379&gt; lpush colors red<br/>(integer)1<br/>127.0.0.1:6379&gt; lrange colors 0 1<br/>"red"<br/>127.0.0.1:6379&gt; lpush colors blue<br/>(integer)2<br/>127.0.0.1:6379&gt; lrange colors 0 2<br/>"blue"<br/>"red"<br/>127.0.0.1:6379&gt; rpush colors green<br/>(integer)3<br/>127.0.0.1:6379&gt; lrange colors 0 3<br/>"blue"<br/>"red"<br/>"green"<br/>127.0.0.1:6379&gt; lpop colors<br/>"blue"<br/>127.0.0.1:6379&gt; lrange colors 0 2<br/>"red"<br/>"green"<br/>127.0.0.1:6379&gt; rpop colors<br/>"green"<br/>127.0.0.1:6379&gt; lrange colors 0 2<br/>"red"<br/>127.0.0.1:6379&gt;</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="cead" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis Set命令</h1><p id="e30f" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">与数组不同，集合中的每个元素都是唯一的。可以使用索引来检索数组中的元素，但这在集合中是不允许的，因为它需要键。与保持其插入顺序的数组相反，集合是没有顺序的。集合中的项目出现的顺序无法预测。Set命令如下所示。</p><ul class=""><li id="c155" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">sadd key member</code>，<em class="lh">向集合中添加成员。</em></li><li id="95e2" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">smembers key</code>，<em class="lh">显示给定集合的成员。</em></li><li id="538c" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">srem key member</code>，<em class="lh">从集合中删除给定成员。</em></li></ul><p id="48fd" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">Redis Set命令的用法和结果如下所示。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="1c72" class="mo ke hh mi b be mp mq l mr ms">chikku@DESKTOP-21GGVDA:~$ redis-cli<br/>127.0.0.1:6379&gt; sadd fruits Apple Orange Grapes Mango<br/>(integer)4<br/>127.0.0.1:6379&gt; smembers fruits<br/>"Mango"<br/>"Grapes"<br/>"Orange"<br/>"Apple"<br/>127.0.0.1:6379&gt; srem fruits Grapes<br/>(integer)1<br/>127.0.0.1:6379&gt; smembers fruits<br/>"Mango"<br/>"Orange"<br/>"Apple"<br/>127.0.0.1:6379&gt;</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="9776" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Redis哈希命令</h1><p id="e8ae" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">哈希允许您在单个键中存储键值对。下面列出了哈希命令。</p><ul class=""><li id="104c" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">hset key field value</code>，<em class="lh">将一个键值对设置为一个hash。</em></li><li id="3842" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">hget key field</code>，<em class="lh">获取一个哈希字段的值。</em></li><li id="3192" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">hgetall key</code>，<em class="lh">获取一个hash的所有键值对。</em></li><li id="7bcd" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">hdel key field</code>，<em class="lh">从哈希中删除给定字段。</em></li><li id="fea9" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">hexists key field</code>，c <em class="lh">检查hash中是否存在该字段。</em></li></ul><p id="3b7f" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">下面列出了Redis Hash命令的用法和结果。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="2c49" class="mo ke hh mi b be mp mq l mr ms">chikku@DESKTOP-21GGVDA:~$ redis-cli<br/>127.0.0.1:6379&gt; hset address city Bangalore<br/>(integer)1<br/>127.0.0.1:6379&gt; hset address state Karnataka<br/>(integer)1<br/>127.0.0.1:6379&gt; hset address country India<br/>(integer)1<br/>127.0.0.1:6379&gt; hget address city<br/>"Bangalore"<br/>127.0.0.1:6379&gt;hgetall address<br/>"city"<br/>"Bangalore"<br/>"state"<br/>"Karnataka"<br/>"country"<br/>"India"<br/>127.0.0.1:6379&gt;hexists address city<br/>(integer)1<br/>127.0.0.1:6379&gt;hdel address city<br/>(integer)1<br/>127.0.0.1:6379&gt;hexists address city<br/>(integer)0<br/>127.0.0.1:6379&gt;hgetall address<br/>"state"<br/>"Karnataka"<br/>"country"<br/>"India"<br/>127.0.0.1:6379&gt;</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="65dd" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用Nodejs的Redis缓存</h1><p id="fffb" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">我们正在创建一个带有GET和POST端点的Express应用程序。我们使用外部的假REST API(<em class="lh">jsonplaceholder.typicode.com/posts</em>)来获取帖子列表并创建新帖子。</p><p id="6b9b" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">按照以下步骤设置应用程序。</p><ol class=""><li id="65f3" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv lw lx ly lz bi translated">用<code class="du mf mg mh mi b">npm init -y</code>命令创建package.json。</li><li id="61b6" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">安装Express应用程序所需的所有依赖项，如下所示:</li></ol><pre class="lj lk ll lm fd mk mi mt mu aw mv bi"><span id="2a26" class="mw ke hh mi b fi mx my l mr ms">npm i express dotenv axios body-parser</span></pre><p id="ced6" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">2.使用<code class="du mf mg mh mi b">npm i ioredis</code>安装Redis依赖项</p><p id="ac23" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">3.您的package.json文件应该包含以下内容。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="a408" class="mo ke hh mi b be mp mq l mz ms">{<br/>  "name": "redis-setup",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "node index.js"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "axios": "^1.1.3",<br/>    "body-parser": "^1.20.1",<br/>    "dotenv": "^16.0.3",<br/>    "express": "^4.18.2",<br/>    "ioredis": "^5.2.3"<br/>  }<br/>}</span></pre><p id="22ad" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">4.在<em class="lh">中增加Redis <code class="du mf mg mh mi b">host</code>、<code class="du mf mg mh mi b">port</code>、<code class="du mf mg mh mi b">ttl</code>(生存时间)和<code class="du mf mg mh mi b">timeout</code>。env </em>文件。<em class="lh">。env </em>文件还包括一个可选的REST API URL，用于Redis演示的目的。</p><p id="5cbd" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">下面的代码片段列出了<em class="lh">的内容。env </em>文件。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="d9a9" class="mo ke hh mi b be mp mq l mr ms">REDIS_HOST = 127.0.0.1<br/>REDIS_PORT = 6379<br/>REDIS_TTL = 30<br/>REDIS_TIMEOUT = 5000<br/>BASE_URL = https://jsonplaceholder.typicode.com/posts</span></pre><p id="c032" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">5.在下面给出的<em class="lh"> index.js </em>文件中启动您的服务器。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="289c" class="mo ke hh mi b be mp mq l mz ms">require('dotenv').config();<br/>const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/><br/>app.use(bodyParser.json());<br/><br/>app.listen(8000, () =&gt; {<br/>    console.log('server started!');<br/>});</span></pre><p id="8f24" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">6.创建一个包含以下内容的<em class="lh"> caching.js </em>文件:</p><ul class=""><li id="a1c0" class="lr ls hh ja b jb jc jf jg jj lt jn lu jr lv jv mj lx ly lz bi translated">带有<code class="du mf mg mh mi b">host</code>、<code class="du mf mg mh mi b">port</code>和<code class="du mf mg mh mi b">commandTimeout</code>的Redis实例。如果命令没有在指定的毫秒内返回回复，将会抛出“命令超时”错误。</li><li id="6733" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">set()</code>设置缓存键值对过期的方法。在设置之前，数据应该被字符串化，因为Redis值总是字符串。</li><li id="8e21" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">get()</code>检索键值对的方法。</li><li id="69b6" class="lr ls hh ja b jb ma jf mb jj mc jn md jr me jv mj lx ly lz bi translated"><code class="du mf mg mh mi b">del() </code>清除缓存键的方法。</li></ul><p id="0268" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">下面添加了<em class="lh"> caching.js </em>的代码片段供您参考。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="79c9" class="mo ke hh mi b be mp mq l mz ms">const Redis = require("ioredis");<br/>const { REDIS_HOST, REDIS_PORT, REDIS_TTL, REDIS_TIMEOUT } = process.env;<br/><br/>let redis;<br/><br/>// Create a Redis instance<br/>(async () =&gt; {<br/>    redis = new Redis({<br/>        host: REDIS_HOST,<br/>        port: REDIS_PORT,<br/>        commandTimeout: REDIS_TIMEOUT<br/>    });<br/>    redis.on("error", (err) =&gt; {<br/>        console.log(err);<br/>    });<br/>})();<br/><br/>// Get key data from Redis cache<br/>async function getCache(key) {<br/>    try {<br/>        const cacheData = await redis.get(key);<br/>        return cacheData;<br/>    } catch (err) {<br/>        return null;<br/>    }<br/>}<br/><br/>// Set Redis cache Key with a given expiry<br/>function setCache(key, data, ttl = REDIS_TTL) {<br/>    try {<br/>        redis.set(key, JSON.stringify(data), "EX", ttl);<br/>    } catch (err) {<br/>        return null;<br/>    }<br/>}<br/><br/>// Remove given Redis cache key<br/>function removeCache(key) {<br/>    try {<br/>        redis.del(key);<br/>    } catch (err) {<br/>        return null;<br/>    }<br/>}<br/><br/>module.exports = { getCache, setCache, removeCache };</span></pre><h2 id="080c" class="mw ke hh bd kf na nb nc kj nd ne nf kn jj ng nh kr jn ni nj kv jr nk nl kz hn bi translated">带缓存的GET方法</h2><p id="b833" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">我们正在创建一个GET端点<code class="du mf mg mh mi b">/getAll</code>来从外部API获取所有的帖子。我们需要选择一个唯一的缓存键来存储这些值。此外，通过调用<code class="du mf mg mh mi b">getCache(key)</code>方法，我们将确定缓存键是否已经被赋值。如果在缓存中找到关键字，用户将收到缓存的数据，这称为<strong class="ja hr">缓存命中</strong>。如果在缓存中没有找到关键字，则认为是<strong class="ja hr">缓存未命中</strong>，将从REST API中获取数据，并调用<code class="du mf mg mh mi b">setCache(key, data)</code>方法来设置值。参考下面的代码片段来创建GET端点。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="ebc3" class="mo ke hh mi b be mp mq l mz ms">require('dotenv').config();<br/>const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const axios = require('axios');<br/>const { getCache, setCache } = require('./caching');<br/>const app = express();<br/><br/>const { BASE_URL } = process.env;<br/>const cacheKey = `getAll/posts`;<br/><br/>//Middleware<br/>app.use(bodyParser.json());<br/><br/>//GET Posts<br/>app.get('/getAll', async (req, res, next) =&gt; {<br/>    try{<br/>        const response = {};<br/>        const cacheData = await getCache(cacheKey);<br/>        if(cacheData) {<br/>            response['message'] = 'cache hit';<br/>            response['posts'] = JSON.parse(cacheData);<br/>        }else {<br/>            const result = await axios.get(BASE_URL);<br/>            const { data } = result;<br/>            response['message'] = 'cache miss';<br/>            response['posts'] = data;<br/>            setCache(cacheKey, data);<br/>        }<br/>        res.status(200).send(response);<br/>    }catch(err) {<br/>        res.status(400).send(err);<br/>    }<br/>})<br/><br/>app.listen(8000, () =&gt; {<br/>    console.log('server started!');<br/>});</span></pre><h2 id="b61a" class="mw ke hh bd kf na nb nc kj nd ne nf kn jj ng nh kr jn ni nj kv jr nk nl kz hn bi translated">缓存前GET方法的结果</h2><p id="a133" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">为了测试我们的GET端点，我们使用了Postman工具。发送GET请求以获取结果。下图显示了缓存前获取帖子的结果。</p><figure class="lj lk ll lm fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nm"><img src="../Images/0eda5ad433d54fd49e2b93a0204679ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dk4YF8_GXtJEBTHEZx2CUQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">GET Method Test Result before caching</figcaption></figure><p id="d99c" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">一个新的关键字将被添加到Redis缓存中。我们可以通过检查如下的键来识别Redis上新添加的键。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="73f9" class="mo ke hh mi b be mp mq l mr ms">127.0.0.1:6379&gt; keys *<br/>1)"getAll/posts"<br/>127.0.0.1:6379</span></pre><h2 id="0577" class="mw ke hh bd kf na nb nc kj nd ne nf kn jj ng nh kr jn ni nj kv jr nk nl kz hn bi translated">缓存后GET方法的结果</h2><p id="58b7" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">一旦在Redis中设置了缓存键，就再次发送GET请求以获取结果。数据将从Redis缓存中提取。下图显示了缓存后获取帖子的Postman结果。</p><figure class="lj lk ll lm fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nm"><img src="../Images/96dd55564ff42cce2652c477bc635a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4Ypq3g-cLl7GS2Hvfw4yw.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">GET Method Test Result after caching</figcaption></figure><p id="6378" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">您可以通过仔细观察Postman测试结果来检测性能差异。使用Redis缓存后，响应时间显著减少。</p><h2 id="c84f" class="mw ke hh bd kf na nb nc kj nd ne nf kn jj ng nh kr jn ni nj kv jr nk nl kz hn bi translated">带缓存的POST方法</h2><p id="0189" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">我们正在创建一个post端点<code class="du mf mg mh mi b">/create</code>来向外部API添加一个新的POST。数据在<code class="du mf mg mh mi b">req.body</code>内部传递。添加新帖子时，应该清除已经为帖子结果设置的Redis键。<code class="du mf mg mh mi b">removeCache()</code>方法会做到这一点。通过这样做，可以防止数据不一致。参考下面的代码片段来创建POST端点。</p><pre class="lj lk ll lm fd mk mi ml bn mm mn bi"><span id="d344" class="mo ke hh mi b be mp mq l mz ms">require('dotenv').config();<br/>const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const axios = require('axios');<br/>const { removeCache } = require('./caching');<br/>const app = express();<br/><br/>const { BASE_URL } = process.env;<br/>const cacheKey = `getAll/posts`;<br/><br/>//Middleware<br/>app.use(bodyParser.json());<br/><br/>//Create new post<br/>app.post('/create', async(req, res, next) =&gt; {<br/>    try{<br/>        const response = await axios.post(BASE_URL, req.body);<br/>        if(response) {<br/>            const { data: posts } = response;<br/>            removeCache(cacheKey);<br/>            res.status(201).send(posts);<br/>        }<br/>    }catch(err) {<br/>        res.status(400).send(err);<br/>    }<br/>});<br/><br/>app.listen(8000, () =&gt; {<br/>    console.log('server started!');<br/>});</span></pre><h2 id="1cd6" class="mw ke hh bd kf na nb nc kj nd ne nf kn jj ng nh kr jn ni nj kv jr nk nl kz hn bi translated">POST方法的结果</h2><p id="e077" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">在Postman工具中发送POST请求。POST请求的主体作为JSON发送。下图显示了创建post API的结果。</p><figure class="lj lk ll lm fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nn"><img src="../Images/1f00bebaa8e21cc07e4953980a1a11d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_gy-1vWZGh8L6wpBMbgZg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">POST Method Test Result in Postman</figcaption></figure><p id="abd3" class="pw-post-body-paragraph iy iz hh ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">创建新帖子时会删除Redis键。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="044e" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="64c1" class="pw-post-body-paragraph iy iz hh ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv ha bi translated">到目前为止，NodeJs的Redis缓存利用率一直是我们讨论的主题。使用Redis作为缓存，通过最大限度地减少访问速度较慢的底层存储层的需求，提高了数据检索性能。Redis在单线程中工作，但它仍然是一个快速的内存数据库。</p></div></div>    
</body>
</html>