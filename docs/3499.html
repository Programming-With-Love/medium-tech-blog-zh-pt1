<html>
<head>
<title>Computer Numbers and Illogical Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机数字和不合逻辑的代码？</h1>
<blockquote>原文：<a href="https://medium.com/globant/computer-numbers-and-illogical-code-dd2510ecde83?source=collection_archive---------0-----------------------#2020-09-17">https://medium.com/globant/computer-numbers-and-illogical-code-dd2510ecde83?source=collection_archive---------0-----------------------#2020-09-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cc59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个简短有趣的算法揭示了JavaScript(以及一般计算机)如何在内部表示数字的细节。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/0bd1741a5c454bac3225a77c8aabe64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7mTUqxJ9Dl9Zro8-"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@photoart2018?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Buchanan</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8033" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你开始编程时，你迟早会意识到数学性质并不总是满足于计算机数学，一些意想不到的结果会突然出现。例如，你会认为两个正数相加应该产生一个更大的正数，不是吗？然而，情况并非总是如此…</p><p id="ca5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将检查一个相当简单(并且完全有效)的算法，它包括四个看起来非常不合逻辑的语句，这将引导我们更好地理解计算机内部数字表示的某些方面。</p><h1 id="a8bb" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">一个无止境的算法？</h1><p id="f2a8" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">“算法”这个词意味着一种必须停止的方法:如果你运行一个算法，它最终必须结束，已经计算了一些东西。(如果你的方法不一定能计算出预期的结果，那么可以称之为“启发式”。)但是如果代码永远不会停止，那么它将毫无用处！在这篇文章中，我们将看到一些代码，似乎是在最后一类，有几个可疑的指令，但实际上工作，即使不清楚如何或为什么！</p><p id="1a80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的算法是我们将要分析的算法；你能发现它所有令人担忧的地方吗？顺便说一下，不要担心这是JavaScript代码；您还可以对其稍加修改，以在Java、Python或C++中运行。我已经突出了麻烦的部分。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="554f" class="lb ju hh kx b fi lc ld l le lf">let v = 1;<br/>while (<strong class="kx hi">(v + 1) - v === 1</strong>) { // <em class="lg">always true, so an infinite loop?</em><br/>    v = v * 2;<br/>}</span><span id="f4bf" class="lb ju hh kx b fi lh ld l le lf">let d = 1;<br/>while (<strong class="kx hi">(v + d) === v</strong>) {     // <em class="lg">always false?</em><br/>    d = d * 2;<br/>}</span><span id="a6e8" class="lb ju hh kx b fi lh ld l le lf">const b = <strong class="kx hi">(v + d) - v</strong>;      // <em class="lg">isn't this just d ?<br/></em>console.log(b);             // <em class="lg">what's this?</em></span><span id="b2ce" class="lb ju hh kx b fi lh ld l le lf">let p = 0;<br/>let e = 1;<br/>while (<strong class="kx hi">(1 + e) !== 1</strong>) {     // <em class="lg">another infinite loop?</em><br/>    p = p + 1;<br/>    e = e / b;<br/>}<br/>console.log(p);             // <em class="lg">what's this?</em></span></pre><p id="1907" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看所有奇怪的部分…</p><ul class=""><li id="de40" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">第一个循环在<code class="du lr ls lt kx b">(v+1)-v</code>等于<code class="du lr ls lt kx b">1</code>时运行……但这不总是正确的吗？而且，那样的话，这岂不是一个无限循环？</li><li id="9cd8" class="li lj hh ig b ih lu il lv ip lw it lx ix ly jb ln lo lp lq bi translated">当<code class="du lr ls lt kx b">(v+d)</code>不同于<code class="du lr ls lt kx b">v</code>时，第二个循环停止……但是既然<code class="du lr ls lt kx b">d</code>不为零，情况不总是这样吗？然后，循环永远不会被执行？</li><li id="b922" class="li lj hh ig b ih lu il lv ip lw it lx ix ly jb ln lo lp lq bi translated">我们计算出<code class="du lr ls lt kx b">b</code>是<code class="du lr ls lt kx b">(v+d)</code>和<code class="du lr ls lt kx b">v</code>之差……那不就是简单的<code class="du lr ls lt kx b">d</code>吗？为什么不直接用后者？</li><li id="f456" class="li lj hh ig b ih lu il lv ip lw it lx ix ly jb ln lo lp lq bi translated">最后，当<code class="du lr ls lt kx b">(1+e)</code>不同于<code class="du lr ls lt kx b">1</code>时，最后一个循环继续执行……这难道不是给定的吗，因为<code class="du lr ls lt kx b">e</code>不是零？那么，这里不是还有一个无限循环吗？</li></ul><p id="5a2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解释以上所有的“怪异”需要了解计算机是如何做数学和内部表示数字的，我们现在就去做。</p><h1 id="2655" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">代表数字</h1><p id="5112" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">当我们处理实数(即非整数)时，所有内部表示都可以包括最大小数位数；无限精确是不可能的。在内部，一个数被表示为一对(<em class="lg">尾数，指数</em>)满足</p><blockquote class="lz"><p id="4801" class="ma mb hh bd mc md me mf mg mh mi jb dx translated">数字=尾数×(基数的幂)</p></blockquote><p id="1b50" class="pw-post-body-paragraph ie if hh ig b ih mj ij ik il mk in io ip ml ir is it mm iv iw ix mn iz ja jb ha bi translated">此外，除非数字是零，否则尾数是介于0和1之间的数字，选择介于之间，因此其第一个数字不是零，并且具有固定的位数；假设是4。让我们暂时假设基数是10，所以我们有一台十进制计算机。像229这样的数字在内部表示为0。<strong class="ig hi"> 2290 </strong> ×10 <strong class="ig hi"> </strong>，或者就这一对(2290，3)。尾数和指数可能都是负数，但这些细节不会影响我们的算法。</p><blockquote class="mo mp mq"><p id="0d62" class="ie if lg ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated">更多名称:这种数字表示法被称为<em class="hh">科学记数法</em>，因为它在科学中的常见用法，或者被称为<em class="hh">浮点</em>，因为小数点总是移动到第一个非零数字的左边，从而相应地调整指数。尾数也被称为<em class="hh">有效数</em>，以避免与对数的<a class="ae js" href="https://en.wikipedia.org/wiki/Common_logarithm#Mantissa_and_characteristic" rel="noopener ugc nofollow" target="_blank">尾数</a>相混淆。</p></blockquote><p id="ed75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从前面的段落中得到的关键信息是，数字不是精确表示的，而是具有有限的精度。如果一个数字需要的位数多于可用的位数，那么最没有意义的位数将被直接砍掉。这种行为是“打破”数学规则的行为，允许我们的算法从内部数字表示系统中嗅出属性，正如我们将看到的。</p><h1 id="4c3a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">理解算法:第一次循环</h1><p id="3b78" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">有了这些定义，我们的第一个循环会怎样呢？在开始时，我们将变量<code class="du lr ls lt kx b">v</code>设为1，并重复加倍，直到<code class="du lr ls lt kx b">v+1</code>不等于<code class="du lr ls lt kx b">v</code>。下表显示了循环是如何进行的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mu"><img src="../Images/565af25d0262e9ce4ed0299ea629429c.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*Q-Oqm9eGpsPp3nS95Pa8gQ.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Our first iteration: we double v until v+1 equals v</figcaption></figure><p id="213d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到了16384会怎么样？尾数没有足够的精度，所以只保留了四个更有意义的数字:在我们的模型中，<code class="du lr ls lt kx b">v</code>实际上会变成16380。甚至更多:如果我们给<code class="du lr ls lt kx b">v</code>加1，结果仍然是16380；我们现在知道，一旦<code class="du lr ls lt kx b">v</code>变得足够大，足以“丢弃”它的个位数，我们的“无限循环”实际上将会结束……第一个谜，解决了！</p><p id="fae3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们转向第二个循环:我们从1开始<code class="du lr ls lt kx b">d</code>，重复它直到<code class="du lr ls lt kx b">v+d</code>不再等于<code class="du lr ls lt kx b">v</code>。这里的关键是<code class="du lr ls lt kx b">v+d</code>的新值将是16390，因为在16380和16390之间没有中间值，因为只存储了四个有效数字。在我们的例子中，将实现改变的值将是<code class="du lr ls lt kx b">d</code> =8(如果应用了舍入)或者<code class="du lr ls lt kx b">d</code> =16(如果没有进行舍入)，但是在任何情况下<code class="du lr ls lt kx b">v+d</code>都将是16390。</p><p id="985e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，<code class="du lr ls lt kx b">b=(v+d)-v</code>的值是多少呢？当<code class="du lr ls lt kx b">v</code>增长时，内部数字最终会丢失其单位数字，所以现在连续值之间的最小差值是十进制数字中的1…所以如果我们使用十进制数学，那么<code class="du lr ls lt kx b">b</code>等于10，更一般地说，答案总是“<code class="du lr ls lt kx b">b</code> <em class="lg">是数字</em>的内部基数”；整洁！</p><h1 id="2a6d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">理解算法:最后一个循环</h1><p id="b0d2" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们现在知道了我们计算的第一个结果:我们能够确定数字内部表示的基础。现在让我们处理算法的第二部分，它包括一个循环；给你，作为提醒。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="c4d9" class="lb ju hh kx b fi lc ld l le lf">let p = 0;<br/>let e = 1;<br/>while (<strong class="kx hi">(1 + e) !== 1</strong>) {     // <em class="lg">another infinite loop?</em><br/>    p = p + 1;<br/>    e = e / b;<br/>}<br/>console.log(p);             // <em class="lg">what's this?</em></span></pre><p id="2aba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一节中，循环中的思想是让变量增长得太多，以至于“丢失”了它的单元的数字。这里的概念是使一个变量变得很小，以至于在求和时不会被“注意到”。让我们把这说得更清楚些。如果我们从1开始<code class="du lr ls lt kx b">e</code>，然后一次又一次地除以<code class="du lr ls lt kx b">b</code>(在我们的例子中是10)，最终<code class="du lr ls lt kx b">1+e</code>将等于1，因为加数太小了；没有足够的尾数数字始终表示精确的总和。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mv"><img src="../Images/292df3c552ec091a71044657e35cc393.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*gIUrGeJv2PnY5Nas8yvXvg.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Our last iteration: we reduce e until 1+e equals 1</figcaption></figure><p id="7377" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么这里<code class="du lr ls lt kx b">p</code>的最终值是什么？简单地说，它显示了尾数的位数:在我们的例子中，我们可以验证我们的数字表示有4位数的尾数。我们现在知道了描述数字内部表示的两个细节:用什么基数写，尾数有多少位。我们能进一步了解内部表示吗？</p><h1 id="ca73" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">了解更多信息</h1><p id="149f" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">通过给我们的算法增加一些代码，我们可以得到更多的关于计算机数字的表示。例如，指数的极限是什么？我们可以用下面的额外逻辑找到。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="899a" class="lb ju hh kx b fi lc ld l le lf">let aMax = 1;<br/>let nMax = 0;<br/>while (aMax !== Infinity) {<br/>  aMax = aMax * b;<br/>  nMax = nMax + 1;<br/>}</span><span id="e940" class="lb ju hh kx b fi lh ld l le lf">console.log(nMax - 1);</span></pre><p id="6a2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们从1开始，继续乘以基数，我们最终会达到一个足够高的值，这个值不适合我们的数值表示。(在JavaScript中，这个特别大的值应该是<code class="du lr ls lt kx b">Infinity</code>)。类似的逻辑让我们找到最低的指数；这里我们除以基数，直到一个数变得很小，以至于它变成零，因为不可能用所用的精度来表示它。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="11dd" class="lb ju hh kx b fi lc ld l le lf">aMin = 1;<br/>nMin = 0;<br/>while (aMin !== 0) {<br/>  aMin = aMin / b;<br/>  nMin = nMin - 1;<br/>}</span><span id="3123" class="lb ju hh kx b fi lh ld l le lf">console.log(nMin + 1);</span></pre><p id="1874" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，有一种可能性，即使数字以固定的精度表示，内部运算也可能使用更多的数字(额外的精度),然后舍入得到更精确的结果。我们如何检测到这一点？我们只需要一句俏皮话。</p><pre class="jd je jf jg fd kw kx ky kz aw la bi"><span id="be09" class="lb ju hh kx b fi lc ld l le lf">const r = (v + (b - 1)) &gt; v;</span><span id="ee9a" class="lb ju hh kx b fi lh ld l le lf">console.log(r);</span></pre><p id="65ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个想法可以追溯到我们发现我们的表示的基础的时候:在我们的例子中，那时我们有<code class="du lr ls lt kx b">v</code>等于16380。如果应用了额外的数字和舍入，那么加9(比10小一，数字的基数)应该得到16390；否则，单位的9位数将被简单地截断。如果我们测试将<code class="du lr ls lt kx b">b-1</code>加到<code class="du lr ls lt kx b">v</code>是否真的产生了更大的值，我们就有办法决定是否使用了额外的精度。</p><h1 id="f9e7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">运行算法</h1><p id="f858" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">好了，现在我们知道了原始算法，加上它的扩展，是做什么的…运行它怎么样？我用JavaScript(node . js，版本14.3.0)做了这个，得到了</p><ul class=""><li id="ed2e" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated"><code class="du lr ls lt kx b">b=2</code>，所以JavaScript使用二进制表示，而不是我们例子中的十进制，并且</li><li id="e7e9" class="li lj hh ig b ih lu il lv ip lw it lx ix ly jb ln lo lp lq bi translated"><code class="du lr ls lt kx b">p=53</code>，所以尾数有53位，大致相当于16位小数有效位数。</li></ul><blockquote class="mo mp mq"><p id="1319" class="ie if lg ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated"><code class="du lr ls lt kx b">v</code>的最终值是9007199254740992，比<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank"> JavaScript的</a> <code class="du lr ls lt kx b">Number.MAX_SAFE_INTEGER</code>多1。在这种情况下，“安全”意味着不损失精度的内部表示——正如我们所看到的！JavaScript <a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger" rel="noopener ugc nofollow" target="_blank">还包括</a> <code class="du lr ls lt kx b">Number.isSafeInteger()</code>来检查一个数字是否可以在不丢失数字的情况下被表示。</p></blockquote><p id="d502" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">指数的极限是什么？我们得到最大指数是1023，根据标准也是正确的。对于最小指数我们得到了不同的结果，-1074:为什么？似乎对于非常小的数字，尾数可以小于0.1(它的起始数字是零)，所以你可以表示更小的值，尽管由于有效数字较少，精度较低。</p><p id="22fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，对于我们代码中的最后一个测试，碰巧没有额外的精度可用；最终结果是一个<code class="du lr ls lt kx b">false</code>值。</p><blockquote class="mo mp mq"><p id="e673" class="ie if lg ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated">我们的结果符合<a class="ae js" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank"> IEEE 754标准</a>、<a class="ae js" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">双精度浮点</a>格式；还可以查看ECMA-262现行标准<a class="ae js" href="https://www.ecma-international.org/ecma-262/11.0/index.html#sec-terms-and-definitions-number-value" rel="noopener ugc nofollow" target="_blank">第4.3.20节<em class="hh">数值</em> </a>。</p></blockquote><p id="bef1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据可用的文档，许多其他语言也遵循IEEE 754标准，这可以通过实现上面的简单算法并在不同的环境中运行它来检查。</p><h1 id="26f5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="7e0f" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们已经看到了如何通过运行一个似乎充满了无限循环和不合逻辑的代码的奇怪算法来确定浮点数表示的实现方面…这是一种学习编程语言内部细节的有趣方式！</p></div></div>    
</body>
</html>