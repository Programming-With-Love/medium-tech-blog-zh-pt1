<html>
<head>
<title>A few facts about Companion objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于伴随物体的一些事实</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/a-few-facts-about-companion-objects-37e18429b725?source=collection_archive---------1-----------------------#2018-03-28">https://blog.kotlin-academy.com/a-few-facts-about-companion-objects-37e18429b725?source=collection_archive---------1-----------------------#2018-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fdb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kotlin给Java开发人员带来的最大变化之一是没有了<em class="ki"> static </em>修饰符。与Java相反，Kotlin类并不真正允许你声明静态字段或方法。相反，您必须在您的类中添加一个<em class="ki">伴随对象</em>来包装所有这些静态引用:这种差异可能看起来很小，但是它有一些值得注意的含义。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/4b4c91d33a09bc9b59976891ec4cb943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*30NOIQCkH0VwFTuHa7OPxg.png"/></div></figure><p id="485b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，伴随对象是实际对象的单一实例。实际上，你可以在你的类中声明一个singleton，并像处理同伴一样处理它。<strong class="jm io">这意味着在实践中，你并不局限于用一个静态对象来收集你所有的静态属性！</strong>伴随的<em class="ki">关键字</em>只不过是一个快捷方式，允许您通过类名访问该对象的内容(或者，如果您在特定的类中，则完全删除类名，只使用方法或属性名)。就编译而言，下面的<em class="ki"> testCompanion() </em>方法里面的三行都是有效语句。</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="f920" class="kw kx in ks b gy ky kz l la lb">class TopLevelClass {<br/><br/>    companion object {<br/>        fun doSomeStuff() {<br/>            ...<br/>        }<br/>    }<br/><br/>    object FakeCompanion {<br/>        fun doOtherStuff() {<br/>            ...<br/>        }<br/>    }<br/>}<br/><br/>fun testCompanion() {<br/>    <strong class="ks io">TopLevelClass.doSomeStuff()<br/>    TopLevelClass.Companion.doSomeStuff()<br/>    TopLevelClass.FakeCompanion.doOtherStuff()</strong><br/>}</span></pre><p id="b816" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">公平地说，<em class="ki">伴随的</em>关键字也提供了更多的选项，尤其是与Java互操作性相关的选项。如果您尝试在Java类中编写相同的测试代码，结果会略有不同:</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="7332" class="kw kx in ks b gy ky kz l la lb">public void testCompanion() {<br/>    TopLevelClass.<em class="ki">Companion</em>.doSomeStuff();<br/>    TopLevelClass.FakeCompanion.<em class="ki">INSTANCE</em>.doOtherStuff();<br/>}</span></pre><p id="dfa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">区别在于:<em class="ki">同伴</em>在Java代码中作为静态成员公开(它是一个对象实例，尽管大写字母C容易让人误解),而<em class="ki"> FakeCompanion </em>是指我们的第二个单例对象的类名。在第二种情况下，我们需要使用它的<em class="ki"> INSTANCE </em>属性来实际访问Java中的实例(您可以通过使用IntelliJ或Android Studio中的<em class="ki">“Show Kotlin Bytecode”</em>菜单来轻松检查这一点，并点击“反编译”按钮来比较相应的Java代码)。</p><p id="e648" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这两种情况下(来自Kotlin或Java)，使用companion对象比使用fake对象允许更短的语法。此外，由于一些注释，您可以让编译器生成一些快捷方式，以便于在Java代码中使用Kotlin companion的内容。</p><p id="c0fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，告诉编译器不要生成getters和setters，而是使用Java字段。在伴随对象的上下文中，副作用是您所标记的字段将不在该伴随对象中，而是封闭Java类的静态字段。从Kotlin的角度来看，这没有任何区别，但是如果您查看生成的字节码，您会注意到companion对象及其成员都是在与封闭类的静态成员相同的级别上声明的。</p><p id="241f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个有用的注释是<em class="ki"> @JvmStatic。这个注释允许你访问你的同伴对象中声明的方法，作为你的封闭类的静态方法。但是要小心:在这种情况下，方法不会移出伴随对象。编译器只是添加了一个<strong class="jm io">额外的静态方法</strong>到类中，这个类又委托给了<em class="ki">的同伴</em>对象(如果你在属性上使用注释，额外的静态getters和setters将在封闭类中生成)。</em></p><p id="7932" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以这个简单的Kotlin类为例:</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="1084" class="kw kx in ks b gy ky kz l la lb">class MyClass {<br/>    companion object {<br/>        <strong class="ks io">@JvmStatic</strong><br/>        fun aStaticFunction() {}<br/>    }<br/>}</span></pre><p id="a3b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是相应的Java代码(简化的摘录，完整的反编译代码要冗长得多):</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="8eb8" class="kw kx in ks b gy ky kz l la lb">public class MyClass {</span><span id="3b78" class="kw kx in ks b gy lc kz l la lb">    public static final MyClass.Companion <em class="ki">Companion </em>= new MyClass.Companion();</span><span id="2784" class="kw kx in ks b gy lc kz l la lb">    <strong class="ks io">fun aStaticFunction() {<br/>        Companion.aStaticFunction();<br/>    }</strong></span><span id="c3bd" class="kw kx in ks b gy lc kz l la lb">    public static final class Companion {<br/>         public final void aStaticFunction() {}<br/>    }<br/>}</span></pre><p id="f2dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个非常细微的差别，但在某些特殊情况下可能是个问题。以Dagger模块为例。当定义一个Dagger模块时，<a class="ae ld" href="https://medium.com/square-corner-blog/keeping-the-daggers-sharp-%EF%B8%8F-230b3191c3f#792c" rel="noopener">你可以使用静态方法来提高性能</a>，但是如果你选择这样做，如果你的模块包含静态方法之外的任何东西，编译将会失败。由于Kotlin在您的类中包含了静态方法，但也保留了静态伴随对象，因此您无法以这种方式编写只包含静态方法的Kotlin类。</p><p id="8a3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是不要太快放弃！这并不意味着您不能这样做，只是它采用了一种稍微不同的方法:在这种特殊的情况下，<strong class="jm io">您可以用Kotlin singleton的静态方法替换Java类(使用<em class="ki">对象</em>而不是<em class="ki">类</em>，并在每个方法上使用<em class="ki"> @JvmStatic </em>注释</strong>，如下例所示:在这种情况下，生成的字节码不再显示任何伴随对象，静态方法被附加到该类。</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="0da6" class="kw kx in ks b gy ky kz l la lb">@Module<br/><strong class="ks io">object</strong> MyModule {<br/><br/>    @Provides<br/>    @Singleton<br/>    <strong class="ks io">@JvmStatic</strong><br/>    fun provideSomething(anObject: MyObject): MyInterface {<br/>        return myObject<br/>    }<br/>}</span></pre><p id="2f24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你意识到一个伴随对象只是单例对象的一个特例时，这又一次变得有意义了。适用于一方的往往也适用于另一方，反之亦然。但是这至少表明，与许多人认为的相反，<strong class="jm io">你不一定需要一个伴随对象来拥有静态方法或字段</strong>。你甚至根本不需要一个对象！只需考虑顶级函数或常量:它们将编译为生成类的静态成员(默认情况下，文件名为<em class="ki"> MyFile.kt </em>，文件名为<em class="ki"> MyFileKt </em>)。</p><p id="650a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们开始偏离本帖最初的主题，所以让我们回到伴侣对象。既然您已经理解了伴随对象本身就是对象，那么您应该意识到它提供了更多的可能性，比如继承和多态。</p><p id="ab56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着您的伴随对象不必是没有类型或父对象的匿名对象。它不仅可以有父类，甚至可以实现接口并有名字！不需要叫陪伴。这就是为什么你可以这样写一个<em class="ki">可打包的</em>类:</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="cfdf" class="kw kx in ks b gy ky kz l la lb">class ParcelableClass() : Parcelable {<br/><br/>    constructor(parcel: Parcel) : this()<br/><br/>    override fun writeToParcel(parcel: Parcel, flags: Int) {}<br/><br/>    override fun describeContents() = 0<br/><br/>    <strong class="ks io">companion object CREATOR : Parcelable.Creator&lt;ParcelableClass&gt;</strong> {<br/>        override fun createFromParcel(parcel: Parcel): ParcelableClass = ParcelableClass(parcel)<br/><br/>        override fun newArray(size: Int): Array&lt;ParcelableClass?&gt; = <em class="ki">arrayOfNulls</em>(size)<br/>    }<br/>}</span></pre><p id="27ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，伴随对象被命名为<em class="ki">创建者</em>，它实现了Android <em class="ki"> Parcelable。Creator </em>接口，它允许遵守<em class="ki"> Parcelable </em>约定，同时比在带有<em class="ki"> @JvmField </em>注释的伴随对象中添加Creator对象更加清晰(您保存了一个注释和一个缩进级别)。诚然，Kotlin引入了<em class="ki"> @Parcelize </em>注释来省去那些样板代码，但这不是本文的重点…</p><p id="8fe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了更简洁，如果你的伙伴对象可以实现接口，它甚至可以使用委托来实现:</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="1b04" class="kw kx in ks b gy ky kz l la lb">class MyObject {<br/><br/>    companion object : <strong class="ks io">Runnable by MyRunnable()</strong></span><span id="593e" class="kw kx in ks b gy lc kz l la lb">}</span></pre><p id="a2b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将允许您同时向几个对象添加静态方法！注意，在这种情况下，伴随对象甚至不需要主体，因为它是由委托提供的(它从来不需要，但是一个完全空的伴随对象有什么意义呢？)…</p><p id="de69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是，您可以为同伴对象创建扩展！这意味着您可以向现有类添加静态方法或属性，如下例所示:</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="d5df" class="kw kx in ks b gy ky kz l la lb">class MyObject {<br/><br/>    companion object<br/><br/>    fun useCompanionExtension() {<br/>        <em class="ki">someExtension</em>()<br/>    }<br/><br/>}<br/><br/>fun MyObject.Companion.someExtension() {}</span></pre><p id="de0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种事有什么意义？我真的不知道。虽然<a class="ae ld" href="https://medium.com/@marcinmoskala?source=user_popover" rel="noopener"> Marcin Moskala </a>建议使用这个特性来<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/effective-java-in-kotlin-item-1-consider-static-factory-methods-instead-of-constructors-8d0d7b5814b2#6985">向类</a>添加工厂扩展。</p><p id="dae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总而言之，伴随对象不仅仅是缺少静态修饰符的人的一种变通方法:</p><ul class=""><li id="ec81" class="le lf in jm b jn jo jr js jv lg jz lh kd li kh lj lk ll lm bi translated">它们是真正的Kotlin对象，具有完整的名称和类型，以及一些额外的功能。</li><li id="ea40" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated">它们甚至不需要静态成员或方法。单例对象或顶级函数还有其他选项。</li></ul><p id="4533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和大多数事情一样，Kotlin意味着你的设计过程有一点点改变，但是与Java相比，它并没有真正限制你的选择。如果说有什么不同的话，那就是通过提供一些新的、更干净的选择，让它们变得开放了一些。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="2ae5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ld" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ld" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在媒体上关注我们。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi lz"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p></div></div>    
</body>
</html>