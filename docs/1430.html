<html>
<head>
<title>Performance Testing of Event-Driven Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动的微服务的性能测试</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/performance-testing-of-event-driven-microservices-f5de74305985?source=collection_archive---------0-----------------------#2017-02-15">https://medium.com/capital-one-tech/performance-testing-of-event-driven-microservices-f5de74305985?source=collection_archive---------0-----------------------#2017-02-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d49f2c153c1068e10e459fc99337ccdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXyhuu3yzz7USXwGtDwERA.png"/></div></div></figure><p id="ab17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们回到软件开发的早期…</p><p id="a2a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">…对交付同类最佳产品的追求以及日益激烈的竞争导致了软件开发周期的加快。这些周期几乎没有时间考虑构建复杂的整体应用程序的影响。随着不断发展，这些应用程序的复杂性不断增加，维护变得越来越困难…</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="206d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快进到现在。技术专家已经亲身经历了构建如此复杂的整体应用程序的陷阱。问题包括但不限于:</p><ul class=""><li id="6e03" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated">大型的monoliths很难维护，追踪软件错误也成为一项乏味的任务。</li><li id="67fb" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><em class="kd">他们共享公共图书馆。库的更新或添加会导致依赖性问题，如果处理不当，会产生不一致的系统。这也可能需要重新启动整个系统来进行更新，从而导致停机时间增加。</em></li><li id="1788" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><em class="kd">对开发者来说，Monoliths代表了一种技术锁定，因为它们被绑定到最初应用的软件语言和框架上。</em></li><li id="78af" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated">单体限制了可扩展性。由于资源的复杂性和依赖性，创建多个实例来处理传入流量的常用策略在这里可能不起作用。</li></ul><p id="8151" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">渐渐地，基于更小更易维护的服务来构建软件应用程序的需求被发现了。这导致了<a class="ae kj" href="http://www.pwc.com/us/en/technology-forecast/2014/cloud-computing/features/microservices.html" rel="noopener ugc nofollow" target="_blank">反单体模式</a>，基于微服务的架构就是其中之一。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kk"><img src="../Images/1f9d611af9a169cac3103e3344d5ef80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-unB-qKX3MjqtmISea7rdg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">The evolution of code and software development</figcaption></figure><h1 id="0874" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是基于微服务的架构？</h1><p id="4f24" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">微服务是一个<em class="kd">“通过消息交互的最小独立进程。”</em>这可以是更细粒度和面向任务的，这意味着微服务通常更小、专用、可独立部署、更易于测试、可伸缩、可维护，并且可以利用分布式架构<strong class="ir hi">。</strong></p><p id="2815" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个微服务架构就变成了<a class="ae kj" href="https://arxiv.org/pdf/1606.04036v1.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="kd"/></strong><em class="kd">一个分布式的应用，它的所有流程都是微服务，更小、独立、专用、可独立部署、可测试、可扩展、可维护。</em><strong class="ir hi"><em class="kd"/></strong></a></p><p id="44b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于微服务的架构是最近对面向服务架构(SOA)的扩展。然而，一个关键的区别是，SOA更关注可重用性和隔离，而基于微服务的架构更关注用系统替换大型应用程序，这些系统可以增量发展，并且更容易使用较小的服务进行管理。</p><p id="260a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kd">这篇之前的Capital One DevExchange文章</em> <a class="ae kj" href="https://developer.capitalone.com/blog-post/delivering-microservices-for-enterprise-with-devops/" rel="noopener ugc nofollow" target="_blank"> <em class="kd">通过DevOps </em> </a> <em class="kd">为企业提供微服务，从企业的角度深入剖析了微服务架构。</em></p><p id="df44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，微服务具有智能端点，并且是事件驱动的；即<strong class="ir hi">基于一个事件，它们接收一个请求，处理它，并相应地生成一个响应</strong>。具有HTTP端点的微服务很少向外部应用程序公开API。从应用程序的角度来看，一个应用程序由许多微服务组成，每个微服务在一个协调良好、松散耦合的服务集系统中执行一个专门的任务。</p><p id="464b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是这提出了一个问题:<strong class="ir hi">“如何测试一个事件驱动的微服务，它没有HTTP端点，并且不能从任何web界面直接访问？”</strong></p><h1 id="6dff" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">微服务在行动</h1><p id="42ff" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">如今，电子商务、金融、医疗保健和多个其他领域的应用都在使用基于微服务的架构。让我们举例说明微服务在金融领域的工作方式。</p><p id="7f53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑一个涉及各种组件和接口的货币转账交易，比如web应用程序、REST API、微服务、消息代理和NoSQL数据库。</p><p id="b472" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.用户登录到web应用程序</p><p id="8e33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.用户执行交易</p><p id="11b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.消息被发送到消息代理的<em class="kd">事务启动</em>主题</p><p id="850f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4.所有订阅的队列都接收消息，而<em class="kd"> RECORDCREATOR </em>微服务——监听其中一个队列——分析消息</p><p id="5a1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5.在数据库中创建一个事务，并向消息代理的记录创建主题发送消息</p><p id="20b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">6.文件创建者微服务然后提取消息并生成数据文件</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/d0d36b87a217d8498d7832a6d1a9d101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLMY6dgc3n2oftd01a-pig.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">User transaction flow in a microservice based architecture</figcaption></figure><h1 id="3a0b" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何对微服务进行功能测试</h1><p id="ab5b" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">在开始性能测试之前，让我们先检查一种对微服务进行功能测试的方法。</p><p id="f4fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的例子来看，每个微服务都是在事件发生时触发的，所有的交互都是基于消息的。对于一个测试记录创建者微服务的质量工程师来说，<strong class="ir hi">向消息代理发送一条消息，并验证插入到NoSQL数据库中的数据。</strong>这证实了微服务的功能性！</p><p id="f9d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果微服务的唯一功能是向其他队列发送消息，那么为同一个主题订阅多个队列。使用一个专用于预期功能的队列和另一个“测试队列”来检查消息是否由消息代理转发。</p><h1 id="63c2" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何测试微服务的性能</h1><p id="c8f1" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">微服务的功能测试保证了预期需求的质量。然而，一款同类最佳的应用要经过<strong class="ir hi">功能、性能<em class="kd">和</em>安全测试</strong>。此外，在基于微服务的架构中，需要对应用的所有单个组件进行性能测试，包括微服务、API、数据库、web应用以及整个应用。这些单独组件的性能测试为应用程序的整体性能奠定了基础。</p><p id="338f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看如何对事件驱动的微服务进行性能测试。以下是<em class="kd"> RECORDCREATOR </em>微服务性能测试中涉及的组件和工具列表:</p><h2 id="1e39" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated"><strong class="ak">组件:</strong></h2><p id="e6c6" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">亚马逊社交网络/SQS，NoSQL数据库</p><h2 id="3e09" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated"><strong class="ak">工具:</strong></h2><ul class=""><li id="fc5d" class="ju jv hh ir b is lr iw ls ja ml je mm ji mn jm jz ka kb kc bi translated"><strong class="ir hi"> JMeter </strong> —一个java应用程序，旨在加载测试功能行为并测量被测应用程序的性能。</li><li id="08db" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><strong class="ir hi"> influxDB </strong> —一个开源的<a class="ae kj" href="https://en.wikipedia.org/wiki/Time_series_database" rel="noopener ugc nofollow" target="_blank">时间序列数据库</a>。</li><li id="97e0" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated">Grafana——这是一个<a class="ae kj" href="http://grafana.org/" rel="noopener ugc nofollow" target="_blank">开源度量分析&amp;可视化套件</a>。它最常用于可视化基础设施和应用程序分析的时间序列数据。</li><li id="fb3b" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><strong class="ir hi">cloud watch—</strong>Amazon cloud watch是一项针对AWS云资源和运行在AWS上的应用程序的监控服务。</li></ul><h2 id="fb98" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated"><strong class="ak">范围:</strong></h2><p id="b561" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">性能测试包括各种各样的测试。包括但不限于负荷试验、压力试验、浸泡试验等。然而，在本例中，我们将在一段固定的时间内执行负载测试，以了解微服务的<strong class="ir hi">吞吐量</strong>(即处理的消息)。</p><h2 id="10a2" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated"><strong class="ak">假设</strong>:</h2><p id="19fa" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">1.微服务部署在AWS EC2实例上，并为EC2实例和SQS队列启用了CloudWatch监控。</p><p id="1ca3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.消息大小符合SQS消息大小的要求。</p><p id="01a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.亚马逊SQS订阅了有效的社交网络主题。</p><p id="f358" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4.测试在独立的AWS EC2实例上执行。</p><p id="62cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5.influxDB实例可用，并且influxdb.conf文件中的参数被更新以支持Graphite作为输入源。</p><p id="875c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">6.Grafana仪表板实例可用。</p><h2 id="a933" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated"><strong class="ak">测试设置:</strong></h2><p id="2a62" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">为了测试一个<em class="kd"> RECORDCREATOR </em>微服务的性能，使用JMeter向Amazon SNS topic发送大量消息。然后借助SQS指标来计算服务吞吐量，例如来自亚马逊CloudWatch的<em class="kd"> NumberOfMessagesSent、NumberOfMessagesDeleted、approximaturenumberof messages visible</em>，以及基于来自亚马逊SQS的消息和在NoSQL数据库中创建的交易的时间戳差异的<em class="kd">响应时间</em>指标。这里需要注意的一点是，只有当微服务在其可见性超时到期之前处理并确认消息时，有效消息才会从SQS中删除。</p><p id="63f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为参考，亚马逊简单队列服务的CloudWatch <a class="ae kj" href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/sqs-metricscollected.html" rel="noopener ugc nofollow" target="_blank">指标定义如下:</a></p><ul class=""><li id="af49" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated"><strong class="ir hi"> NumberOfMessagesSent — </strong>添加到队列中的消息数。</li><li id="947a" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><strong class="ir hi">number of messages deleted—</strong>从队列中删除的消息数。</li><li id="c9bc" class="ju jv hh ir b is ke iw kf ja kg je kh ji ki jm jz ka kb kc bi translated"><strong class="ir hi">approximatuenumberofmessages visible—</strong>可从队列中检索的消息数。</li></ul><h2 id="d547" class="lx ku hh bd kv ly lz ma kz mb mc md ld ja me mf lh je mg mh ll ji mi mj lp mk bi translated">步骤:</h2><p id="acd4" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated"><strong class="ir hi"> 1。</strong>创建一个接受transactionId并向Amazon SNS主题发送消息的Java类。</p><p id="dcee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2。</strong>用AbstractJavaSamplerClient扩展这个Java类，使之兼容JMeter的Java请求采样器。</p><p id="84a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3。</strong>现在，将这个java文件转换成一个jar文件，放在JMeter安装目录的lib/ext文件夹中。此外，将依赖的jar文件放在同一个目录中，尤其是。基于程序文件中指定的导入的jar文件。</p><p id="ac7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 4。</strong>打开JMeter并创建一个新的测试计划。向计划中添加一个线程组，因为这有助于我们配置用户(线程)数量、测试执行持续时间和循环计数。</p><p id="4fa5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 5。</strong>给线程组添加一个随机变量组件。这有助于创建唯一的transactionId。</p><p id="d123" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">6。添加JavaRequest Sampler，并从类名下拉列表中选择jar文件(在步骤3中创建)中的类名。将transactionId(在步骤5中创建)作为参数传递给类文件。</p><p id="7290" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">7。向JavaRequest Sampler添加一个后端监听器，并选择实现为GraphiteBackendListenerClient(JMeter&gt;2.9)。配置参数并将其指向influxDB实例。这有助于我们将时间序列指标保存到influxDB，然后在Grafana仪表板上查看。</p><p id="9504" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 8。</strong>要执行固定时间的负载测试，在线程组中，选择线程数为6，持续时间为1200秒，循环计数为forever。</p><p id="fc5b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 9。</strong>执行测试，它将在所需的SQS队列中填充消息，该队列订阅了Java类中指定的SNS主题。</p><p id="3b44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 10。</strong>打开CloudWatch，监控队列。(如果您正在测试的微服务处于活动状态，它应该会处理所有传入的消息)。</p><p id="5a3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">11。通过创建一个仪表板，我们可以在Grafana中看到实时结果，该仪表板从influxDb和CloudWatch中获取时间序列指标。</p><p id="6d8f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过JMeter，我们不断地向SNS主题发送消息，这些消息被转发到SQS队列。监听所需队列的微服务分析传入的消息，并完成预期的任务。一旦任务完成，它将确认消息，消息将从队列中删除。<strong class="ir hi">来自AWS CloudWatch的NumberOfMessagesDeleted </strong>指标为我们提供了微服务的<strong class="ir hi">吞吐量</strong>。</p><h1 id="f169" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">性能测试可视化</h1><p id="8d1c" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">在Grafana实例中添加CloudWatch和influxDB作为数据源。JMeter结果通过Graphite listener和来自AWS的CloudWatch指标发送到influxDB，然后通过配置必要的面板在Grafana仪表板上查看。诸如<strong class="ir hi">线程数量</strong>等指标是从influxDB配置的，其他指标诸如<strong class="ir hi"> NumberOfMessagesSent、NumberOfMessagesDeleted、approximatenumberofmessages visible、EC2 CPUUtilization、ECS CPUUtilization和来自CloudWatch的ECS MemoryUtilization </strong>。</p><p id="fb53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在服务器上安装Jolokia插件，并发送JVM指标以了解系统行为，包括但不限于性能测试期间的<strong class="ir hi">堆内存使用量</strong>、<strong class="ir hi">服务线程</strong>、T20】计数。这一附加功能使得在Grafana仪表板上查看echo系统的实时性能成为可能。请注意，AWS CloudWatch每5分钟向Grafana dashboard发送一次指标。要以1分钟为周期发送度量数据，需要启用对实例的详细监控。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/3343ffb4416ae4e143d8ad05be2c5714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuJRSdgGUVNqVgX6roPTBg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Grafana panel indicating number of JMeter Threads</figcaption></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/5f056e21e67d541a62d9a3e7581860a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6exhb80aMAem8mgIan-GVw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Grafana panel indicating number of messages sent, deleted and visible in AWS SQS</figcaption></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/2eee2fadd245a60017d89dd0a2cc3ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R5iFQKw6l2_wH0PIRqMDA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Grafana panels indicating total messages sent and service throughput</figcaption></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/c80009aae4e536e35f2144c6a2490f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeS4-ZIrE5eo3RpVsNdYng.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Grafana panels indicating CPU utilization and memory utilization</figcaption></figure><p id="8bd4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">需要遵循类似的方法来测试任何监听队列并写入数据库的微服务。</p><p id="d74a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">性能测试也可以在Docker容器中完成，并集成到微服务CI/CD管道中，以促进微服务的独立可部署、可测试和可扩展功能。</p><h1 id="d40b" class="kt ku hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="92c1" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">基于微服务的架构正在发展，开发人员正在接受这种变化。不断增长的业务需求和竞争需要一流的产品，这使得基于微服务的应用的功能和性能测试比以往任何时候都更加重要。基于事件的微服务依赖于事件，只要能够触发事件并验证预期行为，这些微服务就是可测试的。每个微服务都需要经过全面的性能测试和验证，以确定应用的稳定性和弹性。这确保了微服务可以处理大量的事件流量，并且该应用可以成为一流的产品。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><figure class="kl km kn ko fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/microservices/home"><div class="er es mr"><img src="../Images/a9f346eff65776bdedf685617e2c446d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2JclrB8CYu03pOGCn4TCw.jpeg"/></div></a></figure></div></div>    
</body>
</html>