<html>
<head>
<title>Using Machine Learning and Open Source BPM in a Reactive Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在反应式微服务架构中使用机器学习和开源BPM</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962?source=collection_archive---------3-----------------------#2018-08-01">https://medium.com/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962?source=collection_archive---------3-----------------------#2018-08-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/37fdaf2fe813fc915e40dc9701f8d065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhZzFhR-xW45FagL9_BsNA.jpeg"/></div></div></figure><p id="17ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">机器学习正在改变世界。无人驾驶汽车、对话式虚拟助手以及通过面部识别办理登机手续是我们前进方向的几个例子。在这些例子中，机器学习正在自动化人脑过去已经完成的过程，例如如何识别图像和处理语言。</p><p id="efbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这也延伸到世界各地的公司用来经营他们的业务的过程。业务流程通常是自动化的大好机会，<a class="ae jn" rel="noopener" href="/capital-one-developers/comparing-and-contrasting-open-source-bpm-projects-196833f23391?source=user_profile---------4-------------------">开源BPM产品</a>可以帮助解决这个问题。将开源BPM和机器学习结合在一起，可以将自动化带到另一个层次。</p><p id="78c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，机器学习可以用于提供建议，这些建议可以改善业务流程中的决策。但是我们如何在一个<a class="ae jn" rel="noopener" href="/capital-one-developers/microservices-when-to-react-vs-orchestrate-c6b18308a14c">反应式微服务架构</a>中集成机器学习和开源BPM呢？我们希望我们的服务是小型的，专注于做好一件事，同时是分离的和可独立部署的。在本文中，我们将讨论使用机器学习、开源BPM和反应式微服务来实现这一目标的集成模式。</p><h1 id="f566" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">机器学习背景</h1><p id="dedc" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">首先，让我们从提供机器学习的快速背景开始。它真的是人工智能(AI)的一种类型。下面是一个时间表历史，说明了我们将走过的不同阶段。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/914f8262957f98f5044ae10d70e103f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvGHk0xgb9IW-aPKf2I-ow.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Diagram credit Patrick Wagstrom</figcaption></figure><p id="d5e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">人工智能始于20世纪50年代的T4专家系统。这些系统包含由人类编程的if/then逻辑。后来，机器学习软件的早期形式专注于线性回归、树、时间序列回归和无监督学习。在20世纪80年代，<a class="ae jn" href="https://en.wikipedia.org/wiki/Artificial_neural_network" rel="noopener ugc nofollow" target="_blank">神经网络</a>机器学习开始出现。在过去的25年里，机器学习软件有了很大的进步，其中大部分已经开源。</p><p id="2c95" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过云计算获得计算能力也变得更加便宜和快捷。H2O是一个开源内存大数据机器学习平台的例子。它提供了多种算法(如<a class="ae jn" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank">广义线性模型</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">随机森林</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Gradient_boosting" rel="noopener ugc nofollow" target="_blank">梯度提升机</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析</a>等)。)用于训练机器学习模型以及生成显示所生成模型的准确性和性能的度量。</p><p id="1b6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">H2O还将生成一个可部署的工件，您可以将它包含在您的项目中，比如POJO (Plain Old Java Object)或者MOJO ( Model ObJect，Optimized)工件。当POJO达到大小限制或需要更高的性能时，通常会使用MOJO。</p><p id="e5ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">机器学习需要理解的下一个关键概念是两个高级类别——监督和非监督。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/943e8cf02283d6df32bf1209220425bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qV1MC2GY4pTMr1inSYOkGA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Diagram credit Patrick Wagstrom</figcaption></figure><p id="5833" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="la">受监督的</em>是您标注数据并在数据集中包含特征和目标变量的地方。该目标变量表示您想要预测的数据元素，而特征是可用于预测目标的数据元素。目标变量在过去记录的数据集中提供，算法使用这些特征来确定如何预测所提供的目标变量。<em class="la">无监督</em>是你不标注你的数据(不提供目标)，而是让软件去找关系。它通常通过将相似的数据分组在一起来实现这一点。</p><p id="f5d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这两种情况，提供尽可能多的数据总是好的，因此机器学习软件可以尽可能准确。此外，确保数据无论如何都不会有偏差也很重要，否则模型就会有偏差。有了机器学习，模型只和数据一样好。</p><h1 id="622f" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">将机器学习集成到反应式微服务中</h1><p id="6098" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在，您已经对机器学习有了一些了解，让我们来讨论它如何与微服务、反应式架构和开源BPM集成。到现在为止，你们可能都听说过<a class="ae jn" href="https://developer.capitalone.com/blog-post/delivering-microservices-for-enterprise-with-devops/" rel="noopener ugc nofollow" target="_blank">微服务</a>及其优势。</p><blockquote class="lb lc ld"><p id="9b69" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated">查看我以前的博客，了解更多关于<a class="ae jn" rel="noopener" href="/capital-one-developers/microservices-when-to-react-vs-orchestrate-c6b18308a14c">反应式架构</a>和<a class="ae jn" rel="noopener" href="/capital-one-developers/comparing-and-contrasting-open-source-bpm-projects-196833f23391">开源BPM </a>的信息。</p></blockquote><p id="6868" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先让我们谈谈用例。设想一个场景，其中您有一个业务流程，该流程可能涉及某种程度的人工工作流以及系统API调用。机器学习可以用来帮助减少用户的工作流程。它还可以用来为用户提供额外的信息，以便做出更好的决策。</p><p id="0ce3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从设计的角度来看，您通常希望保持您的开源BPM业务流程轻便，并让它专注于它擅长做的事情。否则，您很快就会得到一个单一的应用程序。因此，让BPM专注于工作流，让外部服务专注于工作。</p><blockquote class="lb lc ld"><p id="6c78" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated">为了帮助实现这一点，您可以利用Kafka作为集成机制。【http://kafka.apache.org/ T4】</p></blockquote><p id="1111" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kafka是一个分布式流平台，可以用作反应式微服务架构中的事件流。微服务被提前预编程，以对Kafka中出现的特定事件做出反应。Kafka本身速度快，吞吐量高，LinkedIn证明了这一点，他们用它每天处理数十亿笔交易。在许多体系结构中，它也经常用于背压，充当生产者和消费者之间的缓冲，允许消费者以他们期望的速率读取。它还具有可配置的持久性，可用于微服务架构中的事件重放。这使得微服务能够在停机时弥补任何可能丢失的记录。</p><p id="7e72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我最近构建的一个概念验证(与来自Red Hat的David Murphy一起)使用了开源BPM工具Red Hat Process Automation Manager(PAM)的原生Kafka扩展。<em class="la"> (Red Hat PAM是Red Hat BPM Suite的新名称，两者都基于社区项目</em> <a class="ae jn" href="http://www.jbpm.org/" rel="noopener ugc nofollow" target="_blank"> <em class="la"> jBPM </em> </a> <em class="la">的老分支。)</em>扩展Red Hat PAM与Kafka集成，使业务流程能够直接生产和消费Kafka主题的事件。为了实现这一点，我们在Red Hat PAM中为Kafka创建了一个定制的工作项处理程序，以及<a class="ae jn" href="https://gitlab.com/murph83/kie-server-kafka" rel="noopener ugc nofollow" target="_blank"> Kie服务器扩展</a>(由Red Hat的David Murphy开发)。工作项处理程序创建一个Kafka服务任务，可以在业务流程中使用该任务来生成Kafka。Kie服务器扩展更新使用来自Kafka的事件，进行一些解析，然后将这些事件作为信号事件发送给业务流程。下面是说明Kie服务器扩展的示例图，它基于BPM Suite 6.2的旧版本，并利用了EJB结构。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/190bae999d852fd7ae37bdcd2ff7dbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVRV__ZlDXeqDaYBZ8sYlg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Diagram credit David Murphy</figcaption></figure><p id="bb84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Red Hat PAM 7.0中，架构看起来像这样，它删除了EJB构造并使用事件发射器概念:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/4cdf2834c88261ed78a844969deb2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4JmIzS0cwuSGUzVWtL0-Q.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Diagram credit David Murphy</figcaption></figure><blockquote class="lb lc ld"><p id="215f" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated">您可以在此处找到旧版本的源代码:</p><p id="bf4a" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><a class="ae jn" href="https://gitlab.com/murph83/kie-server-kafka" rel="noopener ugc nofollow" target="_blank">墨菲/基-服务器-卡夫卡<br/><em class="hh">GitLab.com</em>gitlab.com</a></p></blockquote><p id="b1af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在将Red Hat PAM连接到Kafka之后，您可以编写一个业务流程来为Kafka生成将触发外部微服务的事件。这使得Red Hat PAM只需管理工作流，并让外部微服务完成工作。</p><p id="8797" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这遵循了<a class="ae jn" rel="noopener" href="/capital-one-developers/microservices-when-to-react-vs-orchestrate-c6b18308a14c">“混合—和协调器之间的反应以驱动流”</a>模式。下面是总体概念验证的架构图:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div class="er es lj"><img src="../Images/2251550ab9157cbeec2d8073e06ed6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*nGGgFUuQqblWn7Pk6wQHgA.png"/></div></figure><p id="eeb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们更详细地看一下这个概念证明。您可以在下面找到它的源代码:</p><blockquote class="lb lc ld"><p id="aebc" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><a class="ae jn" href="https://github.com/andy9876/MachineLearningReactiveBPM" rel="noopener ugc nofollow" target="_blank">Andy 9876/machineellingreactivebpm<br/><em class="hh">machineellingreactivebpm—Red Hat Session s 1506演示:使用机器学习，Red Hat JBoss BPM套件，以及…</em>github.com</a></p></blockquote><p id="fad9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在这个例子中实现的一个重要概念是命令和事件。命令是需要做的事情，而事件是过去已经发生的事情。</p><p id="6600" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为协调者，Red Hat PAM向Kafka发出命令，外部微服务使用这些命令，进行一些处理，然后产生事件，这些事件由另一个微服务或Red Hat PAM使用。在这个概念验证中，我们有两个微服务。一个用于计算特征，另一个用于执行H2O模型。</p><p id="b606" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有意将它们分开，以便在需要时可以单独扩展。这两者都被部署为dockerized Java JARs，利用Kafka API消费和生产Kafka。对于H2O模型，它使用分布式随机森林算法在来自<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的样本信用卡欺诈检测数据集上进行训练。它包括28个十进制特征，以及时间、交易金额和一个指示交易是欺诈(1)还是非欺诈(0)的类变量。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/9c293177e45b813e150695dd651acce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BSaMbgC5mOlvlny97F0Tw.png"/></div></div></figure><p id="4319" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们通过将H2O生成的POJO导入到我们的java项目中，将其集成到我们的Java微服务中:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="0123" class="lq jp hh lm b fi lr ls l lt lu">import com.decisioning.drf_c79982d1_29c6_47bd_8950_897ba97ba737;</span></pre><p id="e01a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们编写了一些包装器代码来创建模型的实例化:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="a906" class="lq jp hh lm b fi lr ls l lt lu">hex.genmodel.GenModel rawModel = null;</span><span id="84fb" class="lq jp hh lm b fi lv ls l lt lu">rawModel = (hex.genmodel.GenModel) new drf_c79982d1_29c6_47bd_8950_897ba97ba737();     </span><span id="e9cb" class="lq jp hh lm b fi lv ls l lt lu">EasyPredictModelWrapper model = new EasyPredictModelWrapper(rawModel);</span><span id="6248" class="lq jp hh lm b fi lv ls l lt lu">RowData row = new RowData();</span></pre><p id="9ba2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将输入变量映射到row对象，该对象是RowData类的一个实例:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="3b42" class="lq jp hh lm b fi lr ls l lt lu">row.put("Time", time);</span><span id="a872" class="lq jp hh lm b fi lv ls l lt lu">row.put("V1", v1);</span><span id="3caa" class="lq jp hh lm b fi lv ls l lt lu">row.put("V2", v2);</span><span id="9bb9" class="lq jp hh lm b fi lv ls l lt lu">row.put("V3", v3);</span><span id="cd22" class="lq jp hh lm b fi lv ls l lt lu">row.put("V4", v4);</span><span id="68fe" class="lq jp hh lm b fi lv ls l lt lu">row.put("V5", v5);</span><span id="89ca" class="lq jp hh lm b fi lv ls l lt lu">row.put("V6", v6);</span><span id="606d" class="lq jp hh lm b fi lv ls l lt lu">row.put("V7", v7);</span><span id="ec95" class="lq jp hh lm b fi lv ls l lt lu">row.put("V8", v8);</span><span id="1af1" class="lq jp hh lm b fi lv ls l lt lu">row.put("V9", v9);</span><span id="66df" class="lq jp hh lm b fi lv ls l lt lu">row.put("V10", v10);</span><span id="ae97" class="lq jp hh lm b fi lv ls l lt lu">row.put("V11", v11);</span><span id="125a" class="lq jp hh lm b fi lv ls l lt lu">row.put("V12", v12);</span><span id="b188" class="lq jp hh lm b fi lv ls l lt lu">row.put("V13", v13);</span><span id="8c76" class="lq jp hh lm b fi lv ls l lt lu">row.put("V14", v14);</span><span id="c3d1" class="lq jp hh lm b fi lv ls l lt lu">row.put("V15", v15);</span><span id="3d22" class="lq jp hh lm b fi lv ls l lt lu">row.put("V16", v16);</span><span id="32df" class="lq jp hh lm b fi lv ls l lt lu">row.put("V17", v17);</span><span id="4e87" class="lq jp hh lm b fi lv ls l lt lu">row.put("V18", v18);</span><span id="1e47" class="lq jp hh lm b fi lv ls l lt lu">row.put("V19", v19);</span><span id="9ed7" class="lq jp hh lm b fi lv ls l lt lu">row.put("V20", v20);</span><span id="b680" class="lq jp hh lm b fi lv ls l lt lu">row.put("V21", v21);</span><span id="57c9" class="lq jp hh lm b fi lv ls l lt lu">row.put("V22", v22);</span><span id="de88" class="lq jp hh lm b fi lv ls l lt lu">row.put("V23", v23);</span><span id="57b4" class="lq jp hh lm b fi lv ls l lt lu">row.put("V24", v24);</span><span id="0c86" class="lq jp hh lm b fi lv ls l lt lu">row.put("V25", v25);</span><span id="8898" class="lq jp hh lm b fi lv ls l lt lu">row.put("V26", v26);</span><span id="24a1" class="lq jp hh lm b fi lv ls l lt lu">row.put("V27", v27);</span><span id="8161" class="lq jp hh lm b fi lv ls l lt lu">row.put("V28", v28);</span><span id="017e" class="lq jp hh lm b fi lv ls l lt lu">row.put("Amount", amount);</span></pre><p id="7705" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们执行模型:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="c8b7" class="lq jp hh lm b fi lr ls l lt lu">BinomialModelPrediction p = null;</span><span id="2a91" class="lq jp hh lm b fi lv ls l lt lu">   try {</span><span id="cd41" class="lq jp hh lm b fi lv ls l lt lu">         p = model.predictBinomial(row);</span><span id="4103" class="lq jp hh lm b fi lv ls l lt lu">       } catch (PredictException e) {</span><span id="4bc1" class="lq jp hh lm b fi lv ls l lt lu">          e.printStackTrace();</span><span id="49bf" class="lq jp hh lm b fi lv ls l lt lu">       }</span></pre><p id="df43" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后写出p.label的内容(1表示欺诈，0表示非欺诈)和p.classProbability以获得结果:(下面的JSON是硬编码的，用于示例目的)</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="9928" class="lq jp hh lm b fi lr ls l lt lu">//if the H2o model thinks its fraud, return Fraudulent Transaction</span><span id="1fd0" class="lq jp hh lm b fi lv ls l lt lu">if (p.label.equalsIgnoreCase("1"))</span><span id="40d6" class="lq jp hh lm b fi lv ls l lt lu">   line = "{\"id\":\"" + appid + "\",\"action\": \"Fraudulent Transaction\",\"data\": {\"timestamp\": \"" + ts + "\"},\"p.label\":\"" + p.label + "\",\"p.classProbability\":\"," + p.classProbabilities[0] + "\"}";</span><span id="c71e" class="lq jp hh lm b fi lv ls l lt lu">else  //if h2o model does not think its fraud, return Transaction OK</span><span id="e14d" class="lq jp hh lm b fi lv ls l lt lu">   line = "{\"id\":\"" + appid + "\",\"action\": \"Transaction OK\",\"data\": {\"timestamp\": \"" + ts + "\"},\"p.label\":\"" + p.label + "\",\"p.classProbability\":\"," + p.classProbabilities[0] + "\"}";</span><span id="a96b" class="lq jp hh lm b fi lv ls l lt lu">return line;</span></pre><p id="b6ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们更深入地了解红帽PAM盒子。在本例中，Red Hat PAM正在执行一个业务流程，该流程正在侦听由Kie服务器扩展处理的来自Kafka的信号事件(用圆圈中的三角形表示)。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/214eb13658a096c780b325c52ff09587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NeR0ilbFBX-YgE85Qsiww.png"/></div></div></figure><p id="401f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Calc Features任务是我们创建的Kafka服务任务，它使您能够直接为Kafka主题生成消息。它需要三个输入。KafkaKey、值(要写入Kafka的数据)和要生成的主题。在本例中，它写入card.transaction主题，并作为命令发送“Calc Features”的值(这是appInit变量中的内容)。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/cab3bc8cd4455f8c8a71ed73c3b0c8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95Lj6LMsIXhEYnG1FaQqzA.png"/></div></div></figure><p id="9b93" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这在卡夫卡的主题中表现为:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="d1a3" class="lq jp hh lm b fi lr ls l lt lu">{“id”: “b0e0193b-9c2c-46d0–8dfe-12d2ac88adf3”,”action”: “Calc Features”}</span></pre><p id="14ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，Calc Features微服务被编程为当它在Kafka中看到具有“Calc Features”动作的事件时做出反应。它计算28个不同的数字特征，然后将它们写回卡夫卡:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="4b54" class="lq jp hh lm b fi lr ls l lt lu">{“id”:”b0e0193b-9c2c-46d0–8dfe-12d2ac88adf3",”action”: “Features Calculated”,”data”: {“timestamp”: “2018–07–10 16:38:52.578”, “time”: “7891”, “v1”: “-1.585505367”, “v2”: “-3.261584548”,”v3": “-4.137421983”,”v4": “2.357096252”,”v5": “-1.405043314”,”v6": “-1.879437193”,”v7": “-3.513686871”,”v8": “1.515606746”,”v9": “-1.207166361”,”v10": “-6.234561332”,”v11": “5.450746067”,”v12": “-7.333714067”,”v13": “1.361193324”,”v14": “-6.608068252”,”v15": “-0.481069425”,”v16": “-2.60247787”,”v17": “-4.835112052”,”v18": “-0.553026089”,”v19": “0.351948943”,”v20": “0.315957259”,”v21": “0.501543149”,”v22": “-0.546868812”,”v23": “-0.076583636”,”v24": “-0.425550367”,”v25": “0.123644186”,”v26": “0.321984539”,”v27": “0.264028161”,”v28": “0.13281672”,”amount”: “1”}}}</span></pre><p id="4b8b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行模型微服务被编程为当它看到计算的特征时做出反应，然后执行H2O模型并写回模型的输出，并指示交易是否可以:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="7730" class="lq jp hh lm b fi lr ls l lt lu">{“id”:”703d2ff8–9a60–43f6–8d76–0065ec3528a0",”action”: “Transaction OK”,”data”: {“timestamp”: “2018–07–10 16:38:44.633”},”p.label”:”0",”p.classProbability”:”,0.40568148708343504"}</span></pre><p id="619b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者如果是欺诈交易:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="ebab" class="lq jp hh lm b fi lr ls l lt lu">{“id”:”b0e0193b-9c2c-46d0–8dfe-12d2ac88adf3",”action”: “Fraudulent Transaction”,”data”: {“timestamp”: “2018–07–10 16:38:52.591”},”p.label”:”1",”p.classProbability”:”,0.022"}</span></pre><p id="cf1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Red Hat PAM有一个信号事件，用于查找OK或欺诈交易值，并结束该过程或写回Kafka，指示需要进一步评估:</p><pre class="ks kt ku kv fd ll lm ln lo aw lp bi"><span id="4fbc" class="lq jp hh lm b fi lr ls l lt lu">{“id”: “b0e0193b-9c2c-46d0–8dfe-12d2ac88adf3”,”action”: “Evaluate Fraud”}</span></pre><p id="d2d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个帮助说明流程的序列图:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/fc5136364eb0138d9c8d6aee76b65d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtzYd5S1ZY-r-tFx0XstSw.png"/></div></div></figure><p id="acf2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用REST服务，我们可以看到Red Hat PAM中工作流所采用的整体路径:</p><p id="7a73" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="http://IP:port/kieserver/services/rest/server/containers/CardKafka/images/processes/instances/instance#" rel="noopener ugc nofollow" target="_blank">http://IP:port/kieserver/services/rest/server/containers/card Kafka/images/processes/instances/instance #</a></p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/f201674a77d3e4e508fa02347cd5ede7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZ8kqctWGdpJHPC7vJGTJQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Request Fraud Evaluation Workflow Path</figcaption></figure><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/cfb73d8eba61be775c2aa578dc273eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FphFvp0xWi8AAnwKPIhchw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Transaction OK workflow path</figcaption></figure><h1 id="9769" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="e9ba" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">总之，这个概念验证提供了一个工作示例，说明如何在反应式微服务架构中集成机器学习，同时还集成了开源BPM。如果将BPM作为混合协调器模式来实现，这里有一些重要的事情需要考虑:</p><blockquote class="lb lc ld"><p id="b082" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> ●应用协调器模式:</em></p><p id="0611" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> 1。存在异步处理的同步块。</em></p><p id="f82a" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> 2。有必要在设计时和运行时查看整个端到端业务流程。</em></p><p id="f7fe" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> 3。需要尽可能地去耦合，以消除依赖性。</em></p><p id="c0cc" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> ●协调器可以是单点故障。确保它值得权衡并简化您的架构。评估主动/主动(应用程序和数据库层)的多部署。</em></p><p id="523f" class="ip iq la ir b is it iu iv iw ix iy iz le jb jc jd lf jf jg jh lg jj jk jl jm ha bi translated"><em class="hh"> ●利用事件中的关联id来拼凑不同的事件。</em></p></blockquote><p id="3437" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这篇博客对你有所帮助。您可以在这里找到概念验证<a class="ae jn" href="https://youtu.be/hrDPirhjCSQ" rel="noopener ugc nofollow" target="_blank">的现场演示。我要感谢RedHat的David Murphy对本博客的贡献。谢谢！</a></p><figure class="ks kt ku kv fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/microservices/home"><div class="er es mb"><img src="../Images/a9f346eff65776bdedf685617e2c446d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2JclrB8CYu03pOGCn4TCw.jpeg"/></div></a></figure></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="0f72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="la">披露声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>