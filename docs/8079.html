<html>
<head>
<title>3A framework = f(Spring Boot custom filters + Aspect Programming)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3A框架= f(Spring Boot自定义过滤器+方面编程)</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/3a-framework-f-spring-boot-custom-filters-aspect-programming-3d9e8223f222?source=collection_archive---------0-----------------------#2021-11-17">https://medium.com/walmartglobaltech/3a-framework-f-spring-boot-custom-filters-aspect-programming-3d9e8223f222?source=collection_archive---------0-----------------------#2021-11-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8385" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">认证</em> </strong> <em class="jc">，</em> <strong class="ig hi"> <em class="jc">授权</em> </strong> <em class="jc">和</em> <strong class="ig hi"> <em class="jc">记账(3A) </em> </strong>是现在任何应用开发过程中最需要的部分。任何具有这三个A特征的框架都将能够控制处理中涉及的任何计算资源的访问、权限和责任。</p><p id="642a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个博客中，我们将重点关注在<strong class="ig hi"> Spring Boot </strong>库的帮助下，用<strong class="ig hi"> <em class="jc"> AAA </em> </strong>能力开发框架所需要的概念。对于<strong class="ig hi"><em class="jc"/></strong><em class="jc">身份验证和</em> <strong class="ig hi"> <em class="jc">身份验证</em> </strong> <em class="jc">身份验证</em>，我们将演练利用<em class="jc"/><strong class="ig hi"><em class="jc">Spring Security</em></strong><em class="jc"/>库开发一个自定义安全过滤器，对于<strong class="ig hi"><em class="jc">A</em></strong><em class="jc">udit</em>日志，我们将重点关注</p><h1 id="0356" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak"> <em class="kb">认证和授权—自定义安全与Spring安全</em> </strong></h1><p id="31d0" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">在我们深入探讨该主题之前，有几个基本概念可供快速参考:</p><ul class=""><li id="deab" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb km kn ko kp bi translated"><strong class="ig hi"> <em class="jc">认证</em> </strong>:通常使用密码和用户名或SSO令牌来验证用户对其身份所做声明的过程。</li><li id="d9bf" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated"><strong class="ig hi"> <em class="jc">授权</em> </strong>:根据用户所拥有的角色，为用户提供执行某项任务/活动的权限的过程。</li><li id="bbd3" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb km kn ko kp bi translated"><strong class="ig hi"> <em class="jc"> Servlet过滤器</em></strong>:Servlet是一个运行在Web服务器上的程序，它接收并响应来自客户端的请求，通常通过HTTP。Filter <strong class="ig hi"> <em class="jc"> </em> </strong>是一个可以转换请求或响应的头和内容(或两者)的对象。</li></ul><p id="49aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<strong class="ig hi"> Spring Security </strong>库来开发认证和授权框架。需要使用不记名令牌来验证和授权用户使用计算资源。下面是身份验证和授权的高级流程图，第一步是验证SSO令牌，然后根据成功的验证获取用户信息，然后检查所需的AD组，用户应该属于哪个AD组才能访问和使用资源。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/7c7f0953eeb73b2c3366b47a6053f840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSasdaMm2Og7QTOTLyBrhQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Flowchart for Authentication &amp; Authorization</figcaption></figure><p id="c1dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在来看一下<strong class="ig hi"> Spring Security </strong>库，<strong class="ig hi"> Spring Boot </strong>在<strong class="ig hi"> Spring Security </strong>库和<strong class="ig hi"> Spring Security </strong>的帮助下提供安全性，Spring Security 是一个servlet过滤器的集合，它允许在请求和响应分别到达Spring控制器和客户端之前进行监控、处理。</p><p id="e75b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Spring应用程序基本上是一个servlet，即<strong class="ig hi"><em class="jc">dispatcher servlet</em></strong>，它将每个请求重定向到<strong class="ig hi"><em class="jc">@ rest Controllers</em></strong>或<strong class="ig hi"> <em class="jc"> @Controllers </em> </strong>。而不幸的是<strong class="ig hi"><em class="jc">dispatcher servlet</em></strong>没有任何安全机制。因此，应该有一些辅助的支持机制，用于在未经认证和未经授权的请求到达目标之前对其进行限制，这就是<strong class="ig hi"> Spring Security </strong>库通过对传入的请求和响应提供<strong class="ig hi"> <em class="jc">过滤器</em> </strong>来提供帮助的地方。它还允许在<strong class="ig hi"> Spring Boot </strong>应用程序中编写和配置自定义安全过滤器，以在每个传入请求到达<strong class="ig hi"> DispatcherServlet </strong>之前对其进行过滤。</p><p id="b6e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">安全过滤器的简单实现的小快照如下:</p><pre class="kw kx ky kz fd ll lm ln lo aw lp bi"><span id="e748" class="lq je hh lm b fi lr ls l lt lu"><strong class="lm hi"><em class="jc">public class RequestAndResponseFilter extends GenericFilterBean {</em></strong> <br/>    <strong class="lm hi"><em class="jc">@Override</em></strong> <br/>    <strong class="lm hi"><em class="jc">protected void doFilter(HttpServletRequest</em></strong><em class="jc"> request, </em><strong class="lm hi"><em class="jc">HttpServletResponse</em></strong><em class="jc"> response, </em><strong class="lm hi"><em class="jc">FilterChain</em></strong><em class="jc"> chain</em><strong class="lm hi"><em class="jc">) throws IOException, ServletException {</em></strong> <br/>        <br/>        <strong class="lm hi"><em class="jc">Token token = request.getHeaders("Token");</em></strong>  // (1) <br/>  <br/>        // checking if valid token is passed</span><span id="cdd0" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">if (Authenticated(token) == false) {</em></strong>  // (2)</span><span id="9e67" class="lq je hh lm b fi lv ls l lt lu">            // when token passed is invalid we would send HTTP 401 response to the user  <br/>           <em class="jc"> </em><strong class="lm hi"><em class="jc">response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</em></strong> // HTTP 401. <br/>        <br/>            <strong class="lm hi"><em class="jc">return;</em> </strong><br/>        <strong class="lm hi">}</strong></span><span id="b7eb" class="lq je hh lm b fi lv ls l lt lu">       // since token passed in the request is valid, fetch the required info of user <br/>       <strong class="lm hi"><em class="jc">UserInfo user = FetchUserInformation("token");</em></strong> // (3)</span><span id="7e91" class="lq je hh lm b fi lv ls l lt lu">       // checking for required AD-Group of which user should be part of <br/>      <em class="jc"> </em><strong class="lm hi"><em class="jc">if (Authorized(user) == false) {</em></strong> // (4)</span><span id="920a" class="lq je hh lm b fi lv ls l lt lu">            // user is not part of the AD-Group <br/>            <strong class="lm hi"><em class="jc">response.setStatus(HttpServletResponse.SC_FORBIDDEN);</em></strong> // HTTP 403 <br/>           <em class="jc"> </em><strong class="lm hi"><em class="jc">return;</em></strong><em class="jc"> </em><br/>        <strong class="lm hi"><em class="jc">}</em></strong></span><span id="c462" class="lq je hh lm b fi lv ls l lt lu">        // Setting up authentication for authorized user <br/>       <em class="jc"> </em><strong class="lm hi"><em class="jc">CustomAuthentication authentication = new CustomAuthentication(userId, name,email);</em></strong> // (5)<br/>            <br/>        <strong class="lm hi"><em class="jc">SecurityContextHolder.<br/>getContext().setAuthentication(authentication);</em></strong> // (6)</span><span id="c282" class="lq je hh lm b fi lv ls l lt lu">        //  request is allowed to Dispatcher servlet <br/>       <em class="jc"> </em><strong class="lm hi"><em class="jc">chain.doFilter(request, response);</em></strong> // (7)</span><span id="3887" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">}</em></strong></span><span id="f978" class="lq je hh lm b fi lv ls l lt lu"><strong class="lm hi"><em class="jc">private UserInfo fetchUserInformation (Token</em></strong> <em class="jc">token</em><strong class="lm hi"><em class="jc">) {</em></strong> <br/>        // getting all information of user for setting security context and the user authorization</span><span id="8aa2" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">return userInfo;</em></strong> <br/>    <strong class="lm hi"><em class="jc">}</em></strong></span><span id="a741" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">private boolean Authenticated(Token</em></strong> <em class="jc">token</em><strong class="lm hi"><em class="jc">) {</em></strong></span><span id="8805" class="lq je hh lm b fi lv ls l lt lu">        // verifying the to the databases</span><span id="3ebe" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">return false;</em></strong> <br/>    <strong class="lm hi">}</strong></span><span id="9f00" class="lq je hh lm b fi lv ls l lt lu">   <strong class="lm hi"> <em class="jc">private boolean Authorized(UserInfo</em></strong> <em class="jc">user</em><strong class="lm hi"><em class="jc">) {</em></strong></span><span id="7343" class="lq je hh lm b fi lv ls l lt lu">        // checking for required AD-Group.</span><span id="4de6" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">return false;</em></strong></span><span id="87ac" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">}</em></strong></span><span id="39dd" class="lq je hh lm b fi lv ls l lt lu"><strong class="lm hi"><em class="jc">}</em></strong></span></pre><p id="06d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤:</strong></p><ol class=""><li id="9545" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lw kn ko kp bi translated">从请求中提取令牌。</li><li id="f1f5" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">从数据库验证令牌的有效性。</li><li id="fdcf" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">身份验证成功后，从数据库中获取重要的用户信息。</li><li id="082a" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">检查所需的广告组，用户应该是其中的一部分。</li><li id="facc" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">CustomAuthentication是实现由<strong class="ig hi"> Spring Boot </strong>提供的认证接口的类。认证接口由<strong class="ig hi"> Spring Security </strong>库提供，用于存储用户的基本信息，如用户名、密码和角色。</li><li id="becb" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated"><strong class="ig hi"><em class="jc">Security context holder</em></strong>和<strong class="ig hi"> <em class="jc"> SecurityContext </em> </strong>是安全库提供的两个重要类。<strong class="ig hi"><em class="jc">security context</em></strong>保存经过认证的用户信息。因此，要获得关于用户的信息，我们需要找到<strong class="ig hi"><em class="jc">security context</em></strong>。现在，<strong class="ig hi"><em class="jc">security context holder</em></strong>是一个使用ThreadLocal对象来存储<strong class="ig hi"><em class="jc">security context</em></strong>的类。在这里，我们试图将经过认证和授权的用户的<strong class="ig hi"><em class="jc">security context</em></strong>设置为<strong class="ig hi"><em class="jc">security context holder</em></strong>，这样我们就可以在将来需要的时候获得用户的信息。</li><li id="be51" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">允许请求进入过滤器链，然后进入<strong class="ig hi"> DispatcherServlet </strong>，进而进入控制器。</li></ol><p id="0731" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">过滤器链</em> : </strong>在<strong class="ig hi"> Spring Boot </strong>应用中，使用<strong class="ig hi">弹簧安全</strong>每个请求通过15个安全过滤器，以链式方式排列。这个概念被称为滤波器链。</p><p id="6bf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，为了配置<strong class="ig hi"> Spring Security </strong>，即我们希望对哪些端点认证每个请求，以及我们希望对哪些端点允许每个请求等等；我们需要一个具有以下属性的类:</p><ol class=""><li id="714f" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lw kn ko kp bi translated"><strong class="ig hi"><em class="jc">enable web security</em></strong>注释，用于允许Spring找到这个类并将其应用到全局web安全。</li><li id="b149" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">扩展<strong class="ig hi"><em class="jc">web securityconfigureradapter</em></strong>以使用提供的配置方法，通过这些方法可以定义要保护哪个端点。</li></ol><p id="180a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个简单的<strong class="ig hi"><em class="jc">web securityconfigureradapter</em></strong>看起来像是:</p><pre class="kw kx ky kz fd ll lm ln lo aw lp bi"><span id="0fc5" class="lq je hh lm b fi lr ls l lt lu"><strong class="lm hi"><em class="jc">@Configuration</em></strong><br/><strong class="lm hi"><em class="jc">@EnableWebSecurity</em></strong> // (1)<br/><strong class="lm hi"><em class="jc">public class CongurationForSecurity extends WebSecurityConfigurerAdapter { </em></strong>// (1)</span><span id="9cba" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">@Override</em></strong><br/>    <strong class="lm hi"><em class="jc">protected void configure(HttpSecurity</em></strong> <em class="jc">http</em><strong class="lm hi"><em class="jc">) throws Exception {</em></strong> //(2)</span><span id="18bc" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">http<br/>        .authorizeRequests()<br/>        .antMatchers("/").permitAll()</em></strong>    //(3)<br/>        <strong class="lm hi"><em class="jc">.anyRequest().authenticated();</em></strong>  // (4)</span><span id="9a3e" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">}</em></strong><br/><strong class="lm hi"><em class="jc">}</em></strong></span></pre><p id="41d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤:</strong></p><ol class=""><li id="881b" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lw kn ko kp bi translated">用<strong class="ig hi"><em class="jc">@ Configuration</em></strong><strong class="ig hi"><em class="jc">@ enable web security</em></strong>和extending<strong class="ig hi"><em class="jc">WebSecurityConfigurerAdapter</em></strong>注释的简单类。</li><li id="bb84" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">覆盖<strong class="ig hi"><em class="jc">configure(http security http)</em></strong>方法来指定过滤器处理请求的规则。</li><li id="8528" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">所有对URI<strong class="ig hi">"/</strong>的请求都被允许。</li><li id="b3a1" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">除了<strong class="ig hi"><em class="jc">”/</em></strong>之外的任何其他请求都应该被认证。</li></ol><p id="07c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的应用程序中，我们已经完成了自定义<strong class="ig hi"> A </strong>认证和<strong class="ig hi"> A </strong>授权机制的开发。现在，让我们进入下一部分，开发我们应用程序的<strong class="ig hi"> A </strong>会计特性。</p><h1 id="b218" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">弹簧面向方面编程</strong></h1><p id="1a9d" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">我们使用了<strong class="ig hi"> <em class="jc">面向方面编程</em> </strong>来开发一个框架，它可以为我们提供访问日志的能力，而不干扰任何主要功能代码。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lx"><img src="../Images/3592b176ef1a04c809ee2759ee8d3559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*epI3r1qd83CFrDGFwka6Ww.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Audit Aspect</figcaption></figure><p id="470e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">面向方面编程</em> </strong>是一种范例，它使我们能够以不同于<strong class="ig hi"> OOP </strong>的方式来思考程序结构。<strong class="ig hi"> <em class="jc"> AOP </em> </strong>中模块化的单位是<strong class="ig hi"> <em class="jc">方面</em> </strong> <em class="jc"> </em>像<strong class="ig hi"> <em class="jc">类</em> </strong>是为了<strong class="ig hi"> <em class="jc"> OOP </em> </strong>。方面提供了动态添加横切关注点的方法。</p><p id="b9e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们关注什么是<strong class="ig hi"><em class="jc"/></strong><strong class="ig hi"/>交叉关注点，但首先让我们理解<strong class="ig hi"> <em class="jc">关注点</em> : </strong>它是我们希望在应用程序的特定模块中拥有的行为，它可以被定义为我们希望实现的功能。关注有两种类型:</p><ol class=""><li id="54db" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lw kn ko kp bi translated"><strong class="ig hi"> <em class="jc">核心关注:</em> </strong>模块的主要功能</li><li id="5df6" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated"><strong class="ig hi"> <em class="jc">横切关注点:</em> </strong>次要需求的功能，适用于整个应用，如日志、安全等，每个模块都需要。</li></ol><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ly"><img src="../Images/1d998c6eca795ac79a30b61e8ac35d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS3XmV4NZvyEJoIvYGQ7Cg.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Core Concerns &amp; Cross-Cutting Concerns</figcaption></figure><p id="50b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这张图片显示了应用程序分解成的模块。每个模块的主要重点是提供核心服务。然而，这些模块中的每一个都需要辅助功能，例如日志记录和安全性。这些辅助功能是跨领域的问题。</p><p id="e97d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我们的主要焦点是为<strong class="ig hi"> <em class="jc">审计日志</em> </strong>实现方面。日志方面的过于简化的实现:</p><pre class="kw kx ky kz fd ll lm ln lo aw lp bi"><span id="089f" class="lq je hh lm b fi lr ls l lt lu"><strong class="lm hi"><em class="jc">@Aspect</em></strong> // — — — — — — — (1)<br/><strong class="lm hi"><em class="jc">@Component</em></strong><br/><strong class="lm hi"><em class="jc">public class CustomAspectForAuditLog {</em></strong></span><span id="517e" class="lq je hh lm b fi lv ls l lt lu">    //Pointcut containing all the classed annotates with Service and RestController</span><span id="d68d" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">@Pointcut("within(@org.springframework.stereotype.Service *)" +" || within(@org.springframework.web.bind.annotation.RestController *)")</em></strong> // — — — — — — — (2)<br/>    <strong class="lm hi"><em class="jc">public void pointcutBasedOnAnnotation() {</em></strong></span><span id="d761" class="lq je hh lm b fi lv ls l lt lu">        // Pointcut methods are empty, since it’s for containing the joinpoint.</span><span id="71db" class="lq je hh lm b fi lv ls l lt lu">     <strong class="lm hi"><em class="jc">}</em></strong></span><span id="55e1" class="lq je hh lm b fi lv ls l lt lu">     //Pointcut based on packages<br/>     <strong class="lm hi"><em class="jc">@Pointcut("within(com.wlamartlabs.springExample.service.*)" +" || within(com.walmartlabs.springExample.controller.*)")</em></strong> // — — — — — — (3)<br/>     <strong class="lm hi"><em class="jc">public void pointcutBasedOnPackage() {</em></strong></span><span id="c0f6" class="lq je hh lm b fi lv ls l lt lu">         // Pointcut methods are empty, since it’s for containing the joinpoint.</span><span id="d246" class="lq je hh lm b fi lv ls l lt lu">     <strong class="lm hi"><em class="jc">}</em></strong></span><span id="0a70" class="lq je hh lm b fi lv ls l lt lu">    //Advice for dealing Exception thrown by controller.<br/>    <strong class="lm hi"><em class="jc">@AfterThrowing(pointcut = "pointcutBasedOnPackage() &amp;&amp; pointcutBasedOnAnnotation()", throwing = "exception")</em></strong> // — — — — — — — (4)<br/>    <strong class="lm hi"><em class="jc">public void handlingErrorFromController(JoinPoint joinPoint, Throwable exception) {</em></strong></span><span id="b6f7" class="lq je hh lm b fi lv ls l lt lu">    // implementation dealing with the exception thrown</span><span id="3d8c" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">}</em></strong></span><span id="0fba" class="lq je hh lm b fi lv ls l lt lu">    //Advice for dealing the request while entering and exiting the controller<br/>    <strong class="lm hi"><em class="jc">@Around("pointcutBasedOnPackage () &amp;&amp; pointcutBasedOnAnnotation ()")</em></strong> // — — — — — — — (4)<br/>    <strong class="lm hi"><em class="jc">public Object prepareAuditLog(ProceedingJoinPoint joinPoint) throws Throwable {</em></strong></span><span id="6d12" class="lq je hh lm b fi lv ls l lt lu">        // operation before entering controller method</span><span id="9247" class="lq je hh lm b fi lv ls l lt lu">        // Useful info can be extracted for Audit</span><span id="6742" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">Object result = joinPoint.proceed();</em></strong>// — — — — — — — (5)</span><span id="45ab" class="lq je hh lm b fi lv ls l lt lu">        // operation after exiting from controller method</span><span id="333a" class="lq je hh lm b fi lv ls l lt lu">        // Useful info can be extracted for Audit</span><span id="8326" class="lq je hh lm b fi lv ls l lt lu">        <strong class="lm hi"><em class="jc">return result;</em></strong></span><span id="4296" class="lq je hh lm b fi lv ls l lt lu">    <strong class="lm hi"><em class="jc">}</em></strong></span><span id="9c63" class="lq je hh lm b fi lv ls l lt lu"><strong class="lm hi"><em class="jc">}</em></strong></span></pre><ol class=""><li id="a3a9" class="kh ki hh ig b ih ii il im ip kj it kk ix kl jb lw kn ko kp bi translated">用<strong class="ig hi"> <em class="jc"> @Aspect </em> </strong>注释的Java类，用于将该类声明为横切关注点的实现。连接方面和被通知对象的过程是在加载时完成的。</li><li id="2992" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">为了理解<strong class="ig hi"> <em class="jc">切入点</em> </strong>，我们需要了解一下<strong class="ig hi"> <em class="jc">连接点</em> </strong>。<strong class="ig hi"> <em class="jc">连接点</em> </strong>是应用程序的<strong class="ig hi"> <em class="jc">程序执行</em> </strong> <em class="jc"> </em>中的候选点，可以插入一个方面。这个点可以是一个被调用的方法，也可以是一个被抛出的异常。在这些点上，方面代码可以插入到应用程序的正常流程中，以添加新的特性。既然在每个代码点都应用方面代码不好或者说不可行，那么就选择一组<strong class="ig hi"><em class="jc"/></strong>，称之为<strong class="ig hi"> <em class="jc">切入点</em> </strong>。从示例代码中，所有标注了<strong class="ig hi"> <em class="jc"> @Repository </em> </strong>、<strong class="ig hi"> <em class="jc"> @Service </em> </strong>和<strong class="ig hi"><em class="jc">@ rest controller</em></strong>的类都被选择作为连接点。</li><li id="2b39" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">切入点也可以通过定义应用程序中的包名来定义。</li><li id="e88f" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated">为了理解<strong class="ig hi"><em class="jc">@后抛</em> </strong>和<strong class="ig hi"><em class="jc">@前后</em> </strong>，我们需要知道什么是<strong class="ig hi"> <em class="jc">忠告</em> </strong>。<strong class="ig hi"> <em class="jc">建议</em> </strong>被定义为方面在特定连接点采取的行动。有五个建议，即:之前，之后，周围，抛后和后返回。</li></ol><p id="bea0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们简要讨论一下各种建议:</p><p id="c2cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">a.<strong class="ig hi"><em class="jc"/>之前:</strong>在连接点之前执行的建议。</p><p id="b362" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">b.<strong class="ig hi"><em class="jc"/>之后:</strong>在连接点之后执行的建议连接点要么成功执行，要么出现异常。</p><p id="02b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">c.<strong class="ig hi"> <em class="jc">运行后</em> : </strong>只有连接点无异常成功执行时才执行的建议。</p><p id="204b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">d.<strong class="ig hi"> <em class="jc">抛出后</em> : </strong>如果连接点因抛出异常而退出时执行的通知。</p><p id="992c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">e.<strong class="ig hi"> <em class="jc">围绕</em> : </strong>这是最有力的建议，它围绕着连接点。Around advice可以在方法调用前后执行自定义行为。</p><p id="547b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.在<strong class="ig hi"> <em class="jc">周围建议</em></strong><strong class="ig hi"/>允许执行<strong class="ig hi"> <em class="jc">连接点</em> </strong>的决定，是在程序员手中。<strong class="ig hi"> <em class="jc"> proceed() </em> </strong>方法允许<strong class="ig hi"> <em class="jc">连接点</em> </strong>被执行，并返回连接点返回的对象。</p><p id="9d49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了对方面编程结构有一个完整清晰的了解，我们可以参考下图。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lz"><img src="../Images/edf62f560fce32d38b53b8740fe40d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gs3sBSsuWr7sVMqF0-S2bw.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Aspect Oriented Paradigm Representation</figcaption></figure><h1 id="8ff2" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="2c42" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">我们使用<strong class="ig hi"> Spring Boot </strong>的<strong class="ig hi"> Spring Security </strong>库开发了一个定制的<strong class="ig hi">过滤器</strong>，它有用于<strong class="ig hi"> A </strong>认证和<strong class="ig hi"> A </strong>授权的定制方法。并且我们还使用<strong class="ig hi"> <em class="jc">【面向方面编程</em> </strong>开发了<em class="jc">方面</em> ，使<strong class="ig hi">在应用<em class="jc">中有了</em></strong>记账功能。因此，在<strong class="ig hi"> Spring Boot </strong>库的帮助下，我们实现了理解开发具有<strong class="ig hi"> <em class="jc"> AAA </em> </strong>能力的应用程序所需的概念的目标。</p><h1 id="dfec" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考</h1><ol class=""><li id="3806" class="kh ki hh ig b ih kc il kd ip ma it mb ix mc jb lw kn ko kp bi translated"><a class="ae md" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-security/site/docs/current/reference/html 5/</a></li><li id="6754" class="kh ki hh ig b ih kq il kr ip ks it kt ix ku jb lw kn ko kp bi translated"><a class="ae md" href="https://docs.spring.io/spring-framework/docs/2.5.x/reference/aop.html" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-framework/docs/2.5 . x/reference/AOP . html</a></li></ol></div></div>    
</body>
</html>