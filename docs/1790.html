<html>
<head>
<title>When To Use GraphQL and How It Compares to REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用GraphQL以及它与REST相比如何</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/when-to-use-graphql-and-how-it-compares-to-rest-632afc621160?source=collection_archive---------0-----------------------#2021-05-04">https://medium.com/capital-one-tech/when-to-use-graphql-and-how-it-compares-to-rest-632afc621160?source=collection_archive---------0-----------------------#2021-05-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="2784" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">GraphQL作为新的BFF(后端对前端)、AWS Appsync和Apollo服务器</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/834f9d47f4a45b624283c3ab7e8528ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPwzXfger1AEYO4EmcXouA.png"/></div></div></figure><p id="8180" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在过去的十年中，许多组织采用微服务来支持他们的网站、移动应用和桌面应用。也许你已经看过一些<a class="ae ke" rel="noopener" href="/capital-one-tech/search?q=microservices"> Capital One关于我们微服务之旅</a>的文章。在这种架构风格中，随着所有业务逻辑转移到服务器端，出现了一些显著的变化和趋势，包括构建一次API，然后跨渠道重用它们的理念。</p><h1 id="449d" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">跨渠道直接重用Web APIs的限制和挑战</h1><p id="8396" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">跨多个渠道(如web、移动、桌面、物联网等)重用相同的API。会带来一些挑战。</p><p id="9599" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在下面展示的场景中，客户端与后端微服务紧密耦合。很多时间被浪费在试图找出调用哪个API，集成到所有后端服务，然后与多个团队协调上。此外，这增加了客户端的复杂性，并增加了出错和停机的可能性。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/1ce9b6d1e6313e02a44d503752372ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f90G6oEXH8HfGJ_a"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><a class="ae ke" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern" rel="noopener ugc nofollow" target="_blank"><em class="lh">“Direct Client-To-Microservice communication Architecture”</em></a><em class="lh"> from Microsoft .NET Docs is licensed under </em><a class="ae ke" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank"><em class="lh">CC BY 4.0</em></a><em class="lh">.</em></figcaption></figure><p id="d661" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，对于移动等渠道，集成为web构建的API会导致网络带宽瓶颈和内存限制。这个问题也被称为<a class="ae ke" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> <em class="li">过度提取</em></a>——即获取比客户端实际需要的更多的信息。</p><p id="2ffa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，由于微服务环境的分布式性质，这些客户端还会遇到第二个问题，在微服务环境中，用户需要在单个屏幕上看到的数据可能会分散在多个微服务中。因此，移动应用程序必须与多个后端集成，并进行多次网络调用来获取加载屏幕所需的数据。更糟糕的是，这些调用需要按顺序执行。这可能会影响性能并降低屏幕加载时间。</p><p id="c389" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面的例子显示了多个REST调用，这些调用需要按顺序进行，以从应用程序加载特定用户的关注者及其提要。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/9614b663c705144b117e4c1d1ad52dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SDdkNBJi38BCJ2Xo"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><em class="lh">Sequential calls from client apps to backend Microservices from </em><a class="ae ke" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank"><em class="lh">GraphQL is the better REST</em></a><strong class="bd kh"><em class="lh"> </em></strong><em class="lh">Copyright Graphcool. Licensed under the </em><a class="ae ke" href="https://github.com/howtographql/howtographql/blob/master/LICENSE.txt" rel="noopener ugc nofollow" target="_blank"><em class="lh">MIT license</em></a><em class="lh">.</em></figcaption></figure><h1 id="af2c" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">通过体验API和BFF克服挑战</h1><p id="4846" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">为了克服上述所有挑战，采用了一些设计模式，如<a class="ae ke" href="https://blogs.mulesoft.com/api-integration/strategy/experience-api-ownership/" rel="noopener ugc nofollow" target="_blank">体验API</a>或<a class="ae ke" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends" rel="noopener ugc nofollow" target="_blank">前端后端(BFF) </a>。</p><p id="80d7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">API体验层位于现有API之上，允许每个UI团队为其特定的应用程序或设备优化API体验。顾名思义，后端对前端(BFF)是每个UI界面的独立后端，它针对前端进行了优化，而不用担心影响其他前端体验。</p><p id="1827" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这看起来有点像下图。BFF上的单个定制端点聚合来自多个微服务的数据，过滤移动通道所需的数据，然后仅返回必要的数据。这不仅减少了客户端和后端之间的网络往返，还提供了抽象。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/78f0b6be443047b8bd9d58c21a0e897c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gdZQZyb-U6yoV463"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">Multiple Backends for FrontEnd supporting different clients</figcaption></figure><p id="4276" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在想象一下，多个BFF或Experience APIss支持一个移动应用，包括维护多个应用所需的每个BFF或Experience API的不同变体。很多，对吧？大量的维护工作包括为每个客户端调整和优化这些功能、处理故障恢复、断路器实现等。此外，如果前端的视图发生变化，这些API也会不断变化。</p><p id="4200" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这也会导致不同BFF之间的代码重复。例如，一个移动团队可能甚至没有意识到web团队为一个相似的流构建了另一个BFF。或者，假设您的组织中有一个计划，要将您的API与Alexa等智能设备集成，或者最终为苹果或三星手表开发一个应用程序。是不是又要为他们打造新的体验API？嗯，我想知道是否有更好的方法来处理多个客户…</p><h1 id="e5e2" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">一种新的选择——使用GraphQL来改进架构</h1><h2 id="f813" class="lk kg hh bd kh ll lm ln kl lo lp lq kp jr lr ls kr jv lt lu kt jz lv lw kv lx bi translated">GraphQL是什么？</h2><p id="ffb1" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">GraphQL是API的查询语言，也是执行这些查询的运行时。它于2012年在脸书开发，并于2015年公开。GraphQL被认为是REST的替代方案，因为它旨在使API开发更快、更灵活，以处理不断变化的客户端需求。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/a5f4b4f92efebbadc51c0b56c506ebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RkohQAKbCAMxhH4g"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">GraphQL supporting multiple clients</figcaption></figure><h2 id="ed75" class="lk kg hh bd kh ll lm ln kl lo lp lq kp jr lr ls kr jv lt lu kt jz lv lw kv lx bi translated">使用GraphQL有什么好处？</h2><p id="048d" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">GraphQL提供了以下好处:</p><p id="cdd6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 1。对客户端的灵活性</strong> —使用GraphQL，移动等客户端可以准确地查询他们需要的信息，而服务器将只响应这些数据。<em class="li">也就是说，相对于服务器，客户端指定服务器需要响应什么数据，从而避免了REST的溢出问题。</em>想象一下这对移动有多有用，尤其是在网速很慢的情况下。</p><p id="c38a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用GraphQL，客户端只需进行一次API调用就可以获取所需的信息。这减少了集成开销并提高了网络性能。不再有客户端连接或错误处理。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/abe7c183560739b6f706ac98cf2e1529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iPgwymibXsOzJnu4"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><em class="lh">“GraphQL” from </em><a class="ae ke" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://graphql.org/</em></a><em class="lh"> is licensed under CC BY 3.0.</em></figcaption></figure><p id="0c5d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 2。API开发人员的灵活性</strong> — GraphQL节省了API开发人员在编排层中构建自定义端点或为所有可能的查询组合体验API所需的工作，因为您可以使用相同的端点和模式在客户端上构建不同的页面视图。此外，我们可以重用这个聚合逻辑来支持具有不同查询需求的不同客户端，而不是为每个客户端构建单独的BFF。这简化了需要维护的编排层。</p><p id="9cb8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 3。版本控制</strong> —使用GraphQL，更容易知道API中的哪些字段被哪些客户端使用，哪些没有被使用。利用这些信息，API开发人员可以更加自信地对现有的API进行修改。这意味着当删除某些未使用的字段或添加新的字段或类型时，您不需要实现新的版本。API可以保持增长，客户不必担心升级到最新版本。这和休息有着天壤之别。</p><p id="4b46" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 4。文档&amp;模式</strong> — GraphQL使用一个强类型的<a class="ae ke" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式</a>来验证查询。通过GraphQL <a class="ae ke" href="https://graphql.org/learn/introspection/" rel="noopener ugc nofollow" target="_blank">自省</a>，可以请求模式并知道支持什么查询；这可以用来自动生成文档。此外，像<a class="ae ke" href="https://www.gatsbyjs.com/docs/how-to/querying-data/running-queries-with-graphiql/" rel="noopener ugc nofollow" target="_blank"> GraphiQL </a>这样的工具可以帮助您直观地探索数据图表，并帮助您创作和向服务器提交GraphiQL查询。在REST API中，这种文档必须使用Swagger或其他机制显式创建。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/52a7e9a502dbef51318651df7c60d9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5bZ4u5ktKGnNIcdy"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><a class="ae ke" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank"><em class="lh">GraphQL query.</em></a></figcaption></figure><p id="cc6c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您还可以指定模式中哪些字段可以为空。<em class="li">也就是说，如果获取某些字段时出现错误，其他字段仍然可以在响应中返回。</em></p><h1 id="2183" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">GraphQL实现</h1><p id="2d80" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">GraphQL拥有丰富的语言支持，并且有几种<a class="ae ke" href="https://graphql.org/code/" rel="noopener ugc nofollow" target="_blank"> GraphQL服务器</a>实现可用。</p><h2 id="d70a" class="lk kg hh bd kh ll lm ln kl lo lp lq kp jr lr ls kr jv lt lu kt jz lv lw kv lx bi translated">Apollo服务器和GraphQL</h2><p id="2cba" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated"><a class="ae ke" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> Apollo </a> Server是GraphQL规范的一个流行的开源实现。使用Apollo平台，您可以通过连接数据源或外部API来构建、查询和管理您的数据图。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lz"><img src="../Images/61f1c512a5986c104f772a3d441b2ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*OAuyjvUi2fABuX2M"/></div><figcaption class="ld le et er es lf lg bd b be z dx"><a class="ae ke" href="https://www.apollographql.com/docs/intro/platform/" rel="noopener ugc nofollow" target="_blank"><em class="lh">Apollo Server</em></a><em class="lh"> from the Apollo Server documentation. Copyright Meteor Development Group, Inc. Licensed under the </em><a class="ae ke" href="https://github.com/apollographql/apollo/blob/main/LICENSE" rel="noopener ugc nofollow" target="_blank"><em class="lh">MIT license</em></a><em class="lh">.</em></figcaption></figure><p id="a028" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">该平台由一个JavaScript GraphQL服务器组成，您可以在其中定义模式和解析器函数。它还包含一个JavaScript Apollo客户端组件，可以与React、Angular或Vue框架一起使用。还支持iOS和Android客户端组件。</p><p id="ee6b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Apollo客户端的特性可以在查询结果到达或改变时直接更新UI组件，并从UI组件声明性地定义查询。<a class="ae ke" href="https://blog.bitsrc.io/should-i-use-apollo-for-graphql-936129de72fe" rel="noopener ugc nofollow" target="_blank">这里</a>是一篇关于为什么要用Apollo的好文章。</p><h2 id="4dfa" class="lk kg hh bd kh ll lm ln kl lo lp lq kp jr lr ls kr jv lt lu kt jz lv lw kv lx bi translated">AWS AppSync和GraphQL</h2><p id="af21" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">2019年，AWS发布了<a class="ae ke" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a>，这是一个完全托管的服务，用于构建GraphQL APIs。它可以组合来自多个数据源、API和Lambda函数的数据，与缓存集成以获得更快的性能。AppSync管理基于负载的GraphQL执行引擎的自动缩放。它还与Cloudwatch集成。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/a43f7a804c9401f2184ca8a8728a049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AFJruo6kGeBORKAq"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><em class="lh">AppSync</em><a class="ae ke" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"><em class="lh"> </em></a><em class="lh">Resolvers calling backend Microservices as taken from the </em><a class="ae ke" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"><em class="lh">AWS AppSync documentation</em></a></figcaption></figure><p id="9ef3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可以使用Lambda作为解析器函数，并将这些函数的所有权分离给最了解如何获取数据的团队。这些功能甚至可以存在于多个AWS账户中。</p><h1 id="ea2b" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">GraphQL中的查询执行</h1><p id="ebf5" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">客户机提供的查询在GraphQL服务器上执行。服务器解析查询，根据模式进行验证，最后将执行传递给解析器函数。</p><p id="8b4e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们来看看查询执行所面临的一些挑战。</p><h2 id="47bb" class="lk kg hh bd kh ll lm ln kl lo lp lq kp jr lr ls kr jv lt lu kt jz lv lw kv lx bi translated">GraphQL中查询执行的挑战</h2><p id="8f9a" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated"><strong class="jk hi"> <em class="li"> 1。防止昂贵查询的安全控制</em> </strong></p><p id="4a7c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">GraphQL为客户提供了查询所需信息的控制权，从而简化了事情。然而，这意味着客户端可能会通过在服务器上进行大量数据库调用来请求一些资源密集型的东西。</p><p id="0d1b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是因为GraphQL为GraphQL模式中的每个字段执行一个解析函数。<a class="ae ke" href="https://www.howtographql.com/advanced/4-security/" rel="noopener ugc nofollow" target="_blank">可以使用技术</a>，例如在执行查询之前设置查询超时或分析最大查询深度，或者预先分析查询复杂性。</p><p id="9e73" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">GraphQL需要注意的另一个细微差别是，基于API请求数量的节流并不是一个好的因素，因为单个请求可能会导致多个查询。</p><p id="9f84" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="li"> 2。解析器功能、批处理和性能</em>和</strong></p><p id="8e53" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">GraphQL模式中的每个字段都映射到一个<strong class="jk hi">解析器</strong>函数，该函数具有获取数据的业务逻辑。解析器可以通过调用另一个API或从数据库或缓存等获取数据。GraphQL也有一个称为默认解析器的东西，所以您不必为每个字段指定一个解析器。如果指定的字段没有解析器，GraphQL将在父解析器中查找该字段名。</p><p id="651b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与REST相比，使用GraphQL的性能成本并不明显。即使客户端通过GraphQL使用单个API调用获取信息，API开发人员仍然需要警惕通过进行大量后端数据库调用而将<em class="li">溢出</em>转移到服务器端的可能性。</p><p id="1f7f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">了解如何构造解析器以及从哪里获取数据(父对象和子对象)的复杂性是提高性能的关键。这里有一个有趣的<a class="ae ke" rel="noopener" href="/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55">博客</a>，它解释了查询解析是如何工作的，以及一些关于GraphQL解析器的最佳实践。</p><h1 id="7405" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">结论</h1><p id="2311" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">有很多GraphQL和REST的比较，也有关于GraphQL取代REST的讨论。REST得到了很好的证明，GraphQL是一个相当新的和不断发展的东西，它在许多组织中的采用正在迅速增长。与任何其他新技术一样，GraphQL也有一个学习曲线。GraphQL带来了许多好处和一些挑战；应对这些挑战的解决方案正在有效构建。</p><p id="2cf3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我看来，在客户端需要像移动设备一样灵活地一次性获取最少数据的场景中，或者在客户端需求快速变化并且您希望最小化服务器端开销的场景中，GraphQL提供了大量的价值。对于在REST之上构建组织API来说，这也是一个巨大的好处，因为您需要在REST之上支持各种各样的客户端。</p><p id="ab7a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是，如果您没有这样的需求，并且有简单的API，静态的、简单的查询需求，那么与REST相比，GraphQL会增加不必要的复杂性。</p><p id="80c6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">【几何头像照片】由<a class="ae ke" href="https://www.freepik.com/rawpixel-com" rel="noopener ugc nofollow" target="_blank"><em class="li">rawpixel.com</em></a><em class="li">上</em><a class="ae ke" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"><em class="li">www.freepik.com</em></a></p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="0d88" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="li">披露声明:2021资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>