<html>
<head>
<title>Decoding Apache Flume and Its Capabilities to Automate Data Transfer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码Apache Flume及其自动化数据传输的能力</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/decoding-apache-flume-and-its-capabilities-to-automate-data-transfer-500b9ee651d3?source=collection_archive---------6-----------------------#2022-04-26">https://medium.com/walmartglobaltech/decoding-apache-flume-and-its-capabilities-to-automate-data-transfer-500b9ee651d3?source=collection_archive---------6-----------------------#2022-04-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c7b9a36f1ac01ea118184cd3b35cdaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVcJzj25ueBeZy4njT9f6A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo Credit: <a class="ae it" href="https://pixabay.com/vectors/pixel-cells-download-data-transfer-3947910/" rel="noopener ugc nofollow" target="_blank">manfredsteger</a></figcaption></figure><p id="c1f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将不同来源的数据移动到一个存储库中进行消费是非常耗时和复杂的。当我的团队遇到这个问题时，我们求助于开源项目Apache Flume来自动化数据传输过程。</p><p id="179a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Apache Flume使我们能够通过简单地编辑一个配置文件，自动地从遗留的Informix数据库、ActiveMQ、IBM MQ、MAAS、Kafka和其他来源<em class="js"> </em>中转移数据。在本文中，我们将解码Apache Flume，并分享我们的一些经验，以帮助您更好地利用Apache Flume的功能。</p><h1 id="53cf" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">阿帕奇水槽概述</strong></h1><p id="ccb5" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">Flume是一个分布式的、可靠的、可用的数据收集服务，用于从事件源收集、聚合和移动大量数据到目的地。</p><p id="955b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">水槽代理是一个JVM进程，它有三个组件:水槽源、水槽通道和水槽。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/e04de9eba492efc02468c5d0bd6409a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRvUmxD-ROcaIQKLQ_-wLw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Flume Components</figcaption></figure><ul class=""><li id="61d5" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated">在上图中，事件源生成的事件被Flume Source消耗。</li><li id="7854" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">Flume Source接收一个事件，并将其存储在一个或多个通道中。channel充当一个存储，它保存事件，直到它被Flume Sink使用。</li><li id="71bd" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">Flume Sink从通道中移除事件，并将其存储在外部目的地(例如，HDFS)。</li></ul><h1 id="ede4" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">使用卡夫卡频道的优势</strong></h1><p id="c699" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">Apache Flume还支持Kafka通道，该通道需要单独安装，用于存储事件。</p><p id="5f40" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Kafka通道可用于多种场景:</p><ol class=""><li id="2136" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lp lh li lj bi translated"><strong class="iw hi">带水槽源和水槽:</strong>它为事件提供了一个可靠且高度可用的通道。</li><li id="822f" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lp lh li lj bi translated"><strong class="iw hi">有Flume source和interceptor，但没有sink: </strong>它允许将Flume事件写入Kafka主题，供其他应用程序使用。</li><li id="bf7a" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lp lh li lj bi translated"><strong class="iw hi">有Flume sink，但没有source: </strong>这是一种从Kafka向Flume sink发送事件的低延迟、容错方式，如HDFS、HBase或Elastic Search。</li></ol><p id="0135" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flume使用事务方法来保证事件的可靠交付。它使用两个独立的事务，分别负责从源到通道和从通道到接收器的事件传递。该事务有两个特征:成功的提交和失败的回滚。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/774ccd2a88faeb7743e7a917248ee960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*a01iQyGgD7_L8NtiM1JlOA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Picture Credit: <a class="ae it" href="https://blogs.apache.org/flume/entry/flume_ng_architecture" rel="noopener ugc nofollow" target="_blank">Flume Event Transaction</a></figcaption></figure><p id="7a78" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了<strong class="iw hi">可靠性</strong>和<strong class="iw hi"> </strong>在事务失败和回滚的情况下保证零数据丢失，需要根据源配置Flume。</p><ul class=""><li id="c15c" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><strong class="iw hi"> Kafka Source: </strong>通过为Kafka Source主题配置消费者组，这确保了在事务失败的情况下指针不会向前移动。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/ae99eaf8344769eb3ba60cce6fe23234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzAaWVqaAxmPluRzfrxGsQ.png"/></div></div></figure><ul class=""><li id="0e1c" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><strong class="iw hi"> JMS源:</strong>如果源类型是队列，则可以配置死信队列以确保零数据丢失和可恢复性。对于主题，需要在JMS源中定义以下属性:</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/c1375f7a4b4906c0faa10cedda551b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEPbAyuC8ywPtjT0YnDcpw.png"/></div></div></figure><ul class=""><li id="3a1a" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><strong class="iw hi">定制JDBC源:</strong>在定制源(例如，JDBC)的情况下，在成功提交的情况下，可以维护和更新最后成功读取last_change_ts的相应表。</li></ul><h1 id="6b61" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">可用性</strong></h1><p id="4fd8" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">为了确保高可用性和低事件延迟，Apache Flume需要启动并运行，并且能够在流程关闭时自我恢复。</p><p id="3b44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是一些确保Flume高可用性的技巧:</p><ul class=""><li id="0512" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated">将Flume代理启动命令配置为supervisord(进程管理系统，负责在自己调用时启动子程序，响应来自客户端的命令，并重新启动崩溃或退出的子进程)中的子进程。</li><li id="83fa" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">如果整个Flume JVM停止运行，上述要点可以解决任何问题。然而，由于Flume JVM有<em class="js"> n </em>个代理，为了确保所有代理都启动并运行，可以使用JMX在Flume代理级别进行监控。</li><li id="4b4a" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">可以解析Flume代理日志，并且可以在日志监控工具中为任何异常设置警报。</li></ul><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/285842cfadcbe78cd08524fa5d70ce91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEWVmraASAkIhogtuCcxLw.png"/></div></div></figure><p id="452d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Apache Flume的Supervisord配置文件示例:</p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="2702" class="lz ju hh lv b fi ma mb l mc md">[program:flumetask-agent-1]</span><span id="97eb" class="lz ju hh lv b fi me mb l mc md">command=/home/flume/apache-flume-1.9.0-bin/scripts/flume-agent.sh agent-1 8080<br/>autostart=true<br/>autorestart=true<br/>startretries=3<br/>stderr_logfile=/home/flume/apache-flume-1.9.0-bin/conf/agent-1/flumetest-supervisor-agent-1.err.log<br/>stdout_logfile=/home/flume/apache-flume-1.9.0-bin/conf/agent-1/flumetest-supervisor-agent-1.out.log<br/>user=flumeuser<br/>logfile_maxbytes=10MB<br/>logfile_backups=0-bash-4.2$</span></pre><p id="da87" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的配置文件中，命令键指向脚本文件“flume-agent.sh ”,该文件将在flume进程退出时运行。</p><h1 id="8460" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">监控</strong></h1><p id="1e86" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">对于监控，Apache Flume报告了JMX指标。可以用不同的形式(例如JSON)来报告度量，并且可以编写任何其他定制的监视类来轮询平台MBean服务器并将其发送到报告服务器。</p><p id="4e97" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于JSON报告，需要将以下属性添加到Flume代理启动命令中:</p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="d769" class="lz ju hh lv b fi ma mb l mc md">-Dflume.monitoring.type=http -Dflume.monitoring.port=34545</span></pre><p id="b0fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在将讨论如何将JMX指标用于监控目的。</p><p id="d924" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">活动性检查:</strong></p><p id="f058" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Get调用可以在<strong class="iw hi">http://&lt;% FlumeServerIP %&gt;:&lt;% FlumeMonitoringPort %&gt;/metrics</strong>(用于HTTP报告)<strong class="iw hi"> </strong>上进行，如果API返回200 OK以外的任何内容，则意味着需要查看Flume代理配置和日志。</p><p id="f911" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用JMX指标:</strong></p><p id="b182" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如上所述，Flume为每个组件(源、通道和汇)报告多种类型的JMX度量。指标定义如下:</p><p id="52aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">来源指标:</strong></p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/183c7bdd84126b95132ac45e2f5b6d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyqQeAANBRCaU4csPTLrtw.png"/></div></div></figure><p id="2744" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">渠道指标:</strong></p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/c4f71485901528962c43b521c5d1d7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWk_ZGGSf7F3S6f6oW6WZw.png"/></div></div></figure><p id="4605" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">汇指标:</strong></p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/5b57b5f165d3122720a03c960982833c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGDKg8CbxF334QuUwLPohA.png"/></div></div></figure><p id="c190" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述指标特定于组件类型(源、通道和接收器),可以多种方式使用:</p><p id="e2a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">1.要确定单个水槽组件而不是整个流程是否存在问题，可以使用度量标准。</p><p id="d431" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个组件的指标都以键值的方式报告。例如，关键是“来源”。”并且该值将是包含源指标的JSON。</p><p id="2b93" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">警报应用程序可以获得指标的API响应，并检查每个组件是否存在原子活动性。</p><p id="3a5e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">示例指标:</strong></p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="2da4" class="lz ju hh lv b fi ma mb l mc md"><strong class="lv hi">{</strong></span><span id="3704" class="lz ju hh lv b fi me mb l mc md">"CHANNEL.fileChannel"<strong class="lv hi">:{</strong>"EventPutSuccessCount"<strong class="lv hi">:</strong>"468085"<strong class="lv hi">,</strong></span><span id="be17" class="lz ju hh lv b fi me mb l mc md">"Type"<strong class="lv hi">:</strong>"CHANNEL"<strong class="lv hi">,</strong></span><span id="f35f" class="lz ju hh lv b fi me mb l mc md">"StopTime"<strong class="lv hi">:</strong>"0"<strong class="lv hi">,</strong></span><span id="595a" class="lz ju hh lv b fi me mb l mc md">"EventPutAttemptCount"<strong class="lv hi">:</strong>"468086"<strong class="lv hi">,</strong></span><span id="7bb3" class="lz ju hh lv b fi me mb l mc md">"ChannelSize"<strong class="lv hi">:</strong>"233428"<strong class="lv hi">,</strong></span><span id="175a" class="lz ju hh lv b fi me mb l mc md">"StartTime"<strong class="lv hi">:</strong>"1344882233070"<strong class="lv hi">,</strong></span><span id="4e14" class="lz ju hh lv b fi me mb l mc md">"EventTakeSuccessCount"<strong class="lv hi">:</strong>"458200"<strong class="lv hi">,</strong></span><span id="73d0" class="lz ju hh lv b fi me mb l mc md">"ChannelCapacity"<strong class="lv hi">:</strong>"600000"<strong class="lv hi">,</strong></span><span id="3fe0" class="lz ju hh lv b fi me mb l mc md">"EventTakeAttemptCount"<strong class="lv hi">:</strong>"458288"<strong class="lv hi">},</strong></span><span id="7e37" class="lz ju hh lv b fi me mb l mc md">"CHANNEL.memChannel"<strong class="lv hi">:{</strong>"EventPutSuccessCount"<strong class="lv hi">:</strong>"22948908"<strong class="lv hi">,</strong></span><span id="1983" class="lz ju hh lv b fi me mb l mc md">"Type"<strong class="lv hi">:</strong>"CHANNEL"<strong class="lv hi">,</strong></span><span id="c220" class="lz ju hh lv b fi me mb l mc md">"StopTime"<strong class="lv hi">:</strong>"0"<strong class="lv hi">,</strong></span><span id="a352" class="lz ju hh lv b fi me mb l mc md">"EventPutAttemptCount"<strong class="lv hi">:</strong>"22948908"<strong class="lv hi">,</strong></span><span id="8966" class="lz ju hh lv b fi me mb l mc md">"ChannelSize"<strong class="lv hi">:</strong>"5"<strong class="lv hi">,</strong></span><span id="dff8" class="lz ju hh lv b fi me mb l mc md">"StartTime"<strong class="lv hi">:</strong>"1344882209413"<strong class="lv hi">,</strong></span><span id="7cf8" class="lz ju hh lv b fi me mb l mc md">"EventTakeSuccessCount"<strong class="lv hi">:</strong>"22948900"<strong class="lv hi">,</strong></span><span id="f0ce" class="lz ju hh lv b fi me mb l mc md">"ChannelCapacity"<strong class="lv hi">:</strong>"100"<strong class="lv hi">,</strong></span><span id="00aa" class="lz ju hh lv b fi me mb l mc md">"EventTakeAttemptCount"<strong class="lv hi">:</strong>"22948908"<strong class="lv hi">}</strong></span><span id="581f" class="lz ju hh lv b fi me mb l mc md"><strong class="lv hi">}</strong></span></pre><p id="68b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.正如我们所知，用户通常可以定义源和接收器之间的多跳，因此为了将事件延迟保持在最低水平，可以使用源度量设置警报延迟。</p><p id="5d23" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">(EventReceivedCount—EventAcceptedCount)给出源未标记成功提交的事件数。阈值可以保持在该值上，如果超过阈值，就会发出警报。</p><h1 id="bf0d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">可扩展性</strong></h1><p id="ced8" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">Apache Flume是<strong class="iw hi">水平可伸缩的</strong>，这意味着多个代理可以被配置为连接到同一个源，并且可以为每个代理指定相似的数据流。</p><p id="e4e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使单个代理达到最大吞吐量，可以进行以下调整。</p><p id="cc03" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">配料:</strong></p><p id="53a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flume成批地从数据源读取数据，对于该批数据，要么完成成功的提交，要么完成失败的回滚。</p><p id="c7b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以调整源和接收器中的参数<strong class="iw hi"> batchSize </strong>和<strong class="iw hi"> batchDurationMillis </strong>来增加吞吐量。调整后的值取决于所用的源/宿类型和所需的事件延迟。</p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="d595" class="lz ju hh lv b fi ma mb l mc md"><em class="js">&lt;agent_name&gt;.sinks.&lt;sink_name&gt;.batchSize = 10000<br/>&lt;agent_name&gt;.sinks.&lt;sink_name&gt;.batchDurationMillis = 10000</em></span></pre><p id="adf4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于Flume Kafka Source，可以为多个Flume代理配置同一个消费者组，这样每个代理将读取一个主题的一组唯一的分区。</p><p id="2ee2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果瓶颈不在源头，渠道/汇点无法赶上摄入吞吐量，那么可以使用以下策略。</p><p id="9eb5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">多水槽-多通道:</strong></p><p id="7307" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个源可以连接多个通道，一个接收器可以连接到每个通道。Flume提供了两种类型的通道选择器(复制或多路复用)，可以编写自定义的通道选择器来均匀地将事件分配给通道并平衡负载。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/3774d4f0fad2b6ff487c8f17b254a33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doI8Im9P0X-AzPza_4CBvw.png"/></div></div></figure><h1 id="b3ac" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">部署管道</strong></h1><p id="509e" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">使用名为flume-ng的shell脚本启动flume代理，该脚本位于Flume分布的bin目录中。Flume代理名称、配置目录和配置文件是启动代理所需的强制参数。</p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="38b8" class="lz ju hh lv b fi ma mb l mc md">$ bin/flume-ng agent -n $agent_name -c conf -f conf/flume-conf.properties.template</span></pre><p id="25ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了涵盖可靠性和可恢复性方面，并为部署编写自定义Flume组件，需要以下附加步骤:</p><ul class=""><li id="b8f3" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated">为每个Flume代理配置supervisor.d</li><li id="103b" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">配置用于启用JMX JSON报告的参数</li><li id="abed" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">在部署期间，将所需的jar添加到Flume lib文件夹中，以便自定义代码能够工作</li><li id="4218" class="lb lc hh iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">在一台机器上启动多个水槽代理</li></ul><p id="e27f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下脚本在Flume部署过程中负责上述步骤:</p><pre class="kx ky kz la fd lu lv lw lx aw ly bi"><span id="83a0" class="lz ju hh lv b fi ma mb l mc md">cd /home/flume<br/>echo "Validating supervisord installation" &gt;&gt; $FLUME_DEPLOY_LOG</span><span id="c38a" class="lz ju hh lv b fi me mb l mc md">supervisor_pid='ps -aef | grep java | grep supervisor | grep -v grep | awk '{print$2}''<em class="js">;  //Check if supervisord is installed or not</em></span><span id="f2ef" class="lz ju hh lv b fi me mb l mc md">if [ $supervisor_pid -gt 0 ]; then<br/>echo "Supervisord already installed" &gt;&gt; $FLUME _DEPLOY_LOG<br/>echo "Stopping supervisord to configure flume" &gt;&gt; $FLUME _DEPLOY_LOG<br/>sudo systemctl stop supervisord<br/>else<br/>echo "Installing supervisord" &gt;&gt; $FLUME_DEPLOY_LOG<br/>sudo yum -y install supervisor<br/>fi</span><span id="3c5d" class="lz ju hh lv b fi me mb l mc md">echo "Killing existing flume agents:" &gt;&gt; $FLUME_DEPLOY_LOG <em class="js">//Step to kill any current agent and do fresh deployment<br/></em>for pid in `ps -aef | grep flume | awk '{print $2}'`<br/>do<br/>kill -9 $pid<br/>done;</span><span id="00a7" class="lz ju hh lv b fi me mb l mc md">echo "Copying Flume:" &gt;&gt; $FLUME_DEPLOY_LOG<br/>cp /home/flume/current/flume-$FLUME_VERSION/apache-flume-1.9.0-bin.tar /home/flume</span><span id="bfff" class="lz ju hh lv b fi me mb l mc md">echo "Unzip Flume Tar:" &gt;&gt; $FLUME_DEPLOY_LOG<br/>tar xf apache-flume-1.9.0-bin.tar<br/>echo "Copy jars and scripts to flume:" &gt;&gt; $FLUME_DEPLOY_LOG    <em class="js">//Step which take care to copy additional jars and any script to the flume folder</em></span><span id="7e98" class="lz ju hh lv b fi me mb l mc md">cd /home/flume/current/flume-$FLUME_VERSION<br/>rm -f $FLUME_HOME/lib/flume-*.jar  //Remove any previous jar<br/>cp *.jar $FLUME_HOME/lib/<br/>cd bin<br/>cp *.sh $FLUME_HOME/scripts</span><span id="21f8" class="lz ju hh lv b fi me mb l mc md">echo "Configuring Supervisord" &gt;&gt; $FLUME_DEPLOY_LOG<br/>sudo rm -rf /etc/supervisord.d/*</span><span id="e66e" class="lz ju hh lv b fi me mb l mc md">echo "Copying supervisor supervisord configs to /etc/supervisord.d" &gt;&gt; $FLUME_DEPLOY_LOG</span><span id="6714" class="lz ju hh lv b fi me mb l mc md">export port=8079<br/>for agent in $(echo ${FLUME_AGENT_NAME} | sed "s/,/ /g") <em class="js">//Loop to deploy supervisord for each flume  agent<br/></em>do<br/>cd /home/flume/apache-flume-1.9.0-bin/conf<br/>mkdir ${agent}<br/>cd ${agent}<br/>cp /home/flume/apache-flume-1.9.0-bin/conf/log4j.properties .<br/>mkdir logs<br/>export port=$((port+1))<br/>sudo cp /home/flume/current/flume-$FLUME_VERSION/bin/flume-supervisor.ini.template /etc/supervisord.d/flume-supervisor.$agent.ini<br/>sudo sed -i 's/agentName/'"${agent}"'/g' /etc/supervisord.d/flume-supervisor.$agent.ini<br/>sudo sed -i 's/portNum/'"${port}"'/g' /etc/supervisord.d/flume-supervisor.$agent.ini</span><span id="82b9" class="lz ju hh lv b fi me mb l mc md">echo "Copied supervisor ini for agent name : $agent" &gt;&gt; $FLUME_DEPLOY_LOG<br/>done<br/>echo "Starting supervisord" &gt;&gt; $FLUME_DEPLOY_LOG<br/>sudo systemctl enable supervisord<br/>sudo systemctl start supervisord</span></pre><p id="cbd1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意:所有的部署日志都被写到变量$FLUME_DEPLOY_LOG中指定的位置。</p></div></div>    
</body>
</html>