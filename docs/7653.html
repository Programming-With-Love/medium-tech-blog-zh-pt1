<html>
<head>
<title>Accelerate Web Test Automation, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Web测试自动化，第2部分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/accelerate-web-test-automation-part-2-bd5833fa01b4?source=collection_archive---------5-----------------------#2016-11-04">https://medium.com/walmartglobaltech/accelerate-web-test-automation-part-2-bd5833fa01b4?source=collection_archive---------5-----------------------#2016-11-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f9d275731f9233c0c109e6e352874f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcqInLCkKO5JKg6uGAE0aw.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo Credit: <a class="ae hu" href="https://pixabay.com/en/rocket-launch-rocket-take-off-nasa-67646/" rel="noopener ugc nofollow" target="_blank">WikiImages</a></figcaption></figure><div class=""/><p id="5ead" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae hu" rel="noopener" href="/walmartlabs/accelerate-web-test-automation-part-1-e574f31938d1"> <strong class="iw hy">加速web测试自动化，第1部分</strong> </a>中，我们已经讨论了如何通过异步调用来检查元素是否可操作，从而将Web测试自动化的性能提高了<strong class="iw hy"> 31.7% </strong>。</p><p id="de3c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我们将介绍一些其他的性能改进，以减少注入JavaScript的昂贵方法调用的数量。</p><h1 id="0854" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">返祖</h1><p id="b372" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在第1部分中，我们介绍了JavaScript注入作为我们构建的库的核心概念(<a class="ae hu" href="https://github.com/TestArmada/nightwatch-extra" rel="noopener ugc nofollow" target="_blank">https://github.com/TestArmada/nightwatch-extra</a>)。选择jQuery作为第一个注入的JavaScript是因为它完美的浏览器兼容性。创建自己的JavaScript元素检测库的一个常见问题是验证其浏览器兼容性的成本。有时它太复杂(或者在某种程度上不可能)以至于不能为你需要的所有浏览器工作。jQuery很好地解决了这个问题。</p><p id="c16e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">多亏了jQuery，我们不用担心浏览器的兼容性。越来越多易于使用和用户友好的命令和断言是基于JavaScript注入机制创建的。我们的顾客对图书馆很满意。我们也很高兴看到这个库被越来越多的用户采用。</p><h1 id="55f5" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">不完美</h1><p id="cc31" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">很长一段时间以来，我们一直在使用jQuery享受生活。不幸的是，每个硬币都有两面。就功能而言，jQuery无疑是完美的。但是我们有点担心压缩jQuery文件的大小(<strong class="iw hy"> 84KB，</strong>3 . 1 . 0版)。</p><p id="0e1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个84KB的大小对于桌面浏览器来说并不是问题。Selenium对注入的JavaScript的大小没有任何限制，所以一切都很完美。然而，同样的规则不适用于移动浏览器。S <a class="ae hu" href="http://selendroid.io/" rel="noopener ugc nofollow" target="_blank"> elendroid </a>的字符串参数有一个大小限制，即<strong class="iw hy"> 65KB </strong>。为了使相同的库适用于移动浏览器，我们必须将一个JavaScript注入调用分成两个调用，以便每次字符串的大小都在<strong class="iw hy"> 65KB </strong>的限制内。</p><p id="fde9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，为了使我们的库与移动自动化兼容，JavaScript注入请求的数量增加了一倍。现在是调整一些东西时候了。</p><h1 id="8684" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">替代方案</h1><p id="ebee" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在对如何将JavaScript注入调用的数量减少到一个做出任何结论之前，我们需要知道jQuery在我们的库中真正做了什么。</p><p id="a10f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">jQuery是一个丰富的JavaScript库，但是我们只使用了其中的1%。我们所需要的是jQuery伪函数，它们丰富了CSS3选择器，如<em class="kv"> :visible </em> , <em class="kv"> :eq(n) </em>等。嗯，你应该知道jQuery已经剥离了它的CSS选择器，并把它放到了一个单独的库Sizzlejs(【https://sizzlejs.com/】T4)中。</p><p id="dce8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Sizzlejs很整洁。才<strong class="iw hy"> 19KB </strong>(压缩版2.3.1)。如果我们可以证明Sizzlejs对于我们的情况足够好，那么<strong class="iw hy"> 84KB </strong> -to- <strong class="iw hy"> 19KB </strong>的改变不仅减少了JavaScript注入调用的数量，还可以加快注入速度。JavaScript注入调用的速度确实与注入的字符串大小有关，如果用户的网络连接速度较慢，速度可能会加快。</p><h2 id="efa8" class="kw jt hx bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">代码检查</h2><p id="280e" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在是时候检查我们的代码了。我们想在这里检查两件事:</p><ol class=""><li id="bc28" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">如果我们使用的所有jQuery伪都在Sizzlejs中有效。</li><li id="6ef1" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">如果我们使用任何jQuery伪代码来操作html元素，比如点击或者移动光标到一个元素。</li></ol><p id="d3c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果相当令人鼓舞</p><ol class=""><li id="5cbe" class="lk ll hx iw b ix iy jb jc jf lm jj ln jn lo jr lp lq lr ls bi translated">Sizzlejs不支持两个jQuery伪函数<em class="kv">:可见</em>和<em class="kv">:隐藏</em>。然而，它们很容易被定制的伪代码移植到Sizzlejs中。</li><li id="034a" class="lk ll hx iw b ix lt jb lu jf lv jj lw jn lx jr lp lq lr ls bi translated">没有使用任何jQuery伪代码来操作html元素。我们依靠Selenium方法来进行元素操作。</li></ol><h2 id="4b88" class="kw jt hx bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">代码更改</h2><p id="bbb2" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们需要做的唯一改变是将jQuery中的<em class="kv">:可见</em>和<em class="kv">:隐藏</em>的实现移植到Sizzlejs中。代码示例:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="355c" class="kw jt hx md b fi mh mi l mj mk">sizzleRef.selectors.pseudos.visible =<br/> function (elem) {<br/>   return elem.offsetWidth &gt; 0 <br/>          || elem.offsetHeight &gt; 0 <br/>          || elem.getClientRects().length &gt; 0;<br/> };</span><span id="7e0f" class="kw jt hx md b fi ml mi l mj mk">sizzleRef.selectors.pseudos.hidden =<br/>  function (elem) {<br/>    return !sizzle.selectors.pseudos.visible(elem);<br/>  };</span></pre><h1 id="da90" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">更多改进</h1><h2 id="aca1" class="kw jt hx bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">改进一</h2><p id="d800" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在，我们准备从jQuery迁移到Sizzlejs。http调用的数量已经成功地恢复为1。用户不会感觉到任何不同，因为迁移是无缝的。</p><p id="f96d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，我们能改进更多吗？</p><p id="8ba7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们曾经每次都评估注入的jQuery，以确保jQuery在被使用之前总是存在，方法是执行<em class="kv"> eval() </em>。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="35ce" class="kw jt hx md b fi mh mi l mj mk">var executeSizzlejs = function(jQuerySource){</span><span id="edaf" class="kw jt hx md b fi ml mi l mj mk">// jQuerySource is the string containing compressed jQuery.min.js<br/>  eval(jQuerySource);<br/>}</span></pre><p id="a1df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，<em class="kv"> eval() </em>有点慢。我们调用的eval() 越多，js注入就会越慢。</p><p id="5bc6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然jQuery中使用Sizzlejs作为选择器，那么是不是说如果目标页面内置了jQuery就完全不需要注入了呢？答案是<strong class="iw hy">是的</strong>。查看以下代码:</p><blockquote class="mm mn mo"><p id="1256" class="iu iv kv iw b ix iy iz ja jb jc jd je mp jg jh ji mq jk jl jm mr jo jp jq jr ha bi translated"><a class="ae hu" href="https://github.com/jquery/jquery/blob/master/src/selector-sizzle.js#L8" rel="noopener ugc nofollow" target="_blank">https://github . com/jquery/jquery/blob/master/src/selector-sizzle . js # L8</a></p></blockquote><p id="9b4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">说到这里，我们甚至可以完全避免运行<em class="kv"> eval() </em>。代码示例:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="b713" class="kw jt hx md b fi mh mi l mj mk">if (window.jQuery) {<br/>  sizzleRef = window.jQuery.find;<br/>}</span></pre><h2 id="1389" class="kw jt hx bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">改进二</h2><p id="3995" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们的大多数web测试自动化命令和断言都是在同一个页面上执行的。与上面的<strong class="iw hy">改进一</strong>类似，如果在页面上检测到Sizzlejs，则不需要再次注入或评估它，因为页面只有在刷新时才会重新加载。</p><h2 id="b4a6" class="kw jt hx bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">完成改进</h2><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="d061" class="kw jt hx md b fi mh mi l mj mk">if (window.Sizzle) {<br/>  // if Sizzlejs is found on page<br/>  sizzleRef = window.Sizzle;<br/>} else if (window.jQuery) {<br/>  // if jQuery is found on page<br/>  sizzleRef = window.jQuery.find;<br/>} else {<br/>  // if none is found on page<br/>  eval(pSizzleSource);<br/>  sizzleRef = Sizzle;<br/>  sizzleRef.noConflict();<br/>  sizzleRef.selectors.pseudos.visible =<br/>    function (elem) {<br/>      return elem.offsetWidth &gt; 0 <br/>             || elem.offsetHeight &gt; 0 <br/>             || elem.getClientRects().length &gt; 0;<br/>    };<br/>  sizzleRef.selectors.pseudos.hidden =<br/>    function (elem) {<br/>      return !sizzle.selectors.pseudos.visible(elem);<br/>    };<br/>  window.Sizzle = sizzleRef;<br/>}</span></pre><p id="4515" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完整的代码可以在这里找到:</p><blockquote class="mm mn mo"><p id="fca9" class="iu iv kv iw b ix iy iz ja jb jc jd je mp jg jh ji mq jk jl jm mr jo jp jq jr ha bi translated"><a class="ae hu" href="https://github.com/TestArmada/nightwatch-extra/blob/master/lib/injections/js-injection.js" rel="noopener ugc nofollow" target="_blank">https://github . com/testar mada/night watch-extra/blob/master/lib/injections/js-injection . js</a></p></blockquote><h1 id="0286" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="3bdf" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">通过本文中的性能改进，我们已经成功地移除了一些不必要的http调用，并尽可能多地将页面上昂贵的javascript <em class="kv"> eval() </em>用于javascript注入。请在评论里给我留言，分享你的经历。也欢迎对该系列的任何评论。如果你想让我为这篇文章写点什么，请告诉我。</p><p id="f2f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们仍在学习和成长。和我们在一起。</p><p id="76f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kv">未完待续……</em></p></div></div>    
</body>
</html>