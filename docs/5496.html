<html>
<head>
<title>Custom grammar to query JSON with Antlr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Antlr查询JSON的自定义语法</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/custom-grammar-to-query-json-with-antlr-28d4e684bad6?source=collection_archive---------0-----------------------#2018-09-08">https://medium.com/oracledevs/custom-grammar-to-query-json-with-antlr-28d4e684bad6?source=collection_archive---------0-----------------------#2018-09-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/137f23adb3f60e4b95be2f1f88b99618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2qurgQ7FUmchSlrgmWtaA.png"/></div></div></figure><p id="a637" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated">ntlr是一个强大的工具，可以用来创建形式语言。对语言的形式化至关重要的是符号和规则，也称为语法。使用<a class="ae jw" href="http://www.antlr.org/" rel="noopener ugc nofollow" target="_blank"> Antlr </a>，定义定制语法并生成相关的解析器和词法分析器是一个简单的过程。Antlr的运行时支持给定字符流的标记化和这些标记的解析。它提供了遍历生成的解析树和应用定制逻辑的机制。让我们使用这个工具，创建一个定制的语法来查询JSON。我们的最终目标是能够编写如下所示的查询:</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="602f" class="kg kh hh kc b fi ki kj l kk kl">bpi.current.code <strong class="kc hi">eq</strong> "USD" <strong class="kc hi">and</strong> bpi.current.rate <strong class="kc hi">gt</strong> 650.60</span></pre><p id="f113" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了创造一种新的语法，必须定义语法的规则。让我们通过创建一个名为“JsonQuery.g4”的文件来实现这一点。然后，我们可以开始编写允许我们查询JSON的语法规则。以下是片段:</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="d17a" class="kg kh hh kc b fi ki kj l kk kl"><strong class="kc hi">grammar </strong>JsonQuery;<br/><br/>query<br/>   : SP? '(' query ')'                              #parenExp<br/>   | query SP LOGICAL_OPERATOR SP query             #logicalExp<br/>   | attrPath SP 'pr'                               #presentExp<br/>   | attrPath SP op=( 'eq' | 'ne' ) SP value        #compareExp<br/><br/>   ;<br/><br/>LOGICAL_OPERATOR<br/>   : 'and' | 'or'<br/>   ;<br/><br/>EQ : 'eq' ;<br/>NE : 'ne' ;<br/><br/>attrPath<br/>   : ATTRNAME subAttr?<br/>   ;<br/><br/>subAttr<br/>   : '.' attrPath<br/>   ;<br/><br/>ATTRNAME<br/>   : ALPHA ATTR_NAME_CHAR* ;<br/><br/><strong class="kc hi">fragment </strong>ATTR_NAME_CHAR<br/>   : '-' | '_' | ':' | DIGIT | ALPHA<br/>   ;</span></pre><p id="8e5c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在这里浏览整套规则<a class="ae jw" href="https://github.com/udaychandra/antlr-json-query/blob/master/src/main/antlr/ud/antlr/json/JsonQuery.g4" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1d1a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Antlr要求我们在创建语法时遵循一定的惯例。首先，文件应该包含一个标题，标题名应该与保存语法的文件名相匹配。Antlr识别两种类型的规则——解析器规则和词法分析器规则。解析器规则必须以小写字母开头，词法分析器规则必须以大写字母开头。在上面的代码片段中,“query”是一个解析器规则,“EQ”是一个词法分析器规则。像为“查询”解析器规则定义的规则替换可以使用“#”操作符来标记(例如:“#parenExp”)。当我们遍历解析树时，标记替代项将触发更精确的事件。正如我之前提到的，Antlr非常通用，提供了大量的特性，从定义规则、生成解析器、词法分析器、监听器和访问者到非贪婪子规则，以及处理优先级和左递归的方法。</p><p id="94b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Antlr还提供了IDE插件，可以用来创建和可视化语法。我们可以根据我们的语法快速测试样本表达式，并预览生成的解析树。下面是基于我们之前编写的JSON查询表达式生成的解析树的视图:</p><figure class="jx jy jz ka fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es km"><img src="../Images/2269941753dc8ec339decd864f24a859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6njPNSaQW3-_lwz8qu8cg.png"/></div></div></figure><p id="f646" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了查询JSON的工作语法，让我们把注意力转向创建一个Java程序和实现一个查询引擎。该引擎将基于给定的查询表达式遍历生成的解析树，根据指定的JSON对象对其进行评估，并返回一个布尔值来指示查询是否匹配。让我们使用gradle来创建我们的项目。下面是启用Antlr插件及其依赖项的相关gradle构建文件:</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="1530" class="kg kh hh kc b fi ki kj l kk kl">plugins {<br/>    id "antlr"<br/>}<br/><br/>dependencies {<br/>    antlr "org.antlr:antlr4:4.7"<br/>}<br/><br/>generateGrammarSource {<br/>    arguments += ["-visitor"]<br/>}</span></pre><p id="d679" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，Antlr可以配置为生成一个侦听器类或一个访问者类——两种解析树遍历机制。我们将使用访问者机制遍历解析树并评估查询表达式。Antlr的gradle插件将根据我们的语法生成定义lexer、parser和visitor类的源代码。我们可以简单地扩展生成的抽象类，并实现相关的定制逻辑来计算JSON查询表达式。下面是JsonQueryEvaluator类的一个片段:</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="6c92" class="kg kh hh kc b fi ki kj l kk kl">public class JsonQueryEvaluator<br/>        extends JsonQueryBaseVisitor&lt;Boolean&gt; {<br/><br/>    @Override<br/>    public Boolean visitParenExp(ParenExpContext ctx) {<br/>        Boolean result = visit(ctx.filter());<br/>        return ctx.NOT() != null ? !result : result;<br/>    }<br/><br/>    @Override<br/>    public Boolean visitLogicalExp(LogicalExpContext ctx) {<br/>        Boolean leftExp = visit(ctx.filter(0));<br/><br/>        if (OR.equals(ctx.LOGICAL_OPERATOR().getText())) {<br/>            // Short circuit "or"<br/>            return leftExp;<br/><br/>        } else {<br/>            return leftExp &amp;&amp; visit(ctx.filter(1));<br/>        }<br/>    }<br/>    ...<br/>}</span></pre><p id="5b82" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，访问者方法名称是如何基于我们在语法中指定的标签生成的。这使我们能够针对给定的JSON对象评估解析器规则的各种备选方案。如果我们没有使用标签，我们将被迫使用许多if-else或switch语句来实现相同的功能。</p><p id="9360" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了一个定制的评估器，让我们创建查询引擎类。它的工作是将表达式流式传输到lexer，标记该流，生成相应的解析树，然后遍历解析树，根据JSON对象计算表达式。下面是JsonQueryEngine类的一个片段:</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="f8e3" class="kg kh hh kc b fi ki kj l kk kl">public class JsonQueryEngine {<br/><br/>    public boolean execute(String expression, JsonObject item) {<br/>        if (StringUtils.<em class="kn">isNotBlank</em>(expression)) {<br/><br/>            CharStream stream = CharStreams<br/>                    .<em class="kn">fromString</em>(expression.trim());<br/>            <br/>            QueryLexer lexer = new QueryLexer(stream);<br/>            CommonTokenStream tokens = new CommonTokenStream(lexer);<br/>            QueryParser parser = new QueryParser(tokens);<br/><br/>            ParseTree parseTree = parser.query();<br/>            JsonQueryEvaluator evaluator =<br/>                    new JsonQueryEvaluator(item);<br/><br/>            return evaluator.visit(parseTree)<br/><br/>        } else {<br/>            ...<br/>        }<br/>    }<br/>    ...<br/>}</span></pre><p id="505f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就这样了，伙计们。我们现在有了一个定制的语法，可以用来在编写测试时断言JSON对象中的条件。当然，在优化语法和解析逻辑方面还有改进的空间。前往<a class="ae jw" href="https://github.com/udaychandra/antlr-json-query" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获取源代码并进行实验。编码快乐！</p></div></div>    
</body>
</html>