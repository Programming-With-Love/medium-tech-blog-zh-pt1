<html>
<head>
<title>Creating a random instance of any class in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin中创建任意类的随机实例</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/creating-a-random-instance-of-any-class-in-kotlin-b6168655b64a?source=collection_archive---------1-----------------------#2019-02-11">https://blog.kotlin-academy.com/creating-a-random-instance-of-any-class-in-kotlin-b6168655b64a?source=collection_archive---------1-----------------------#2019-02-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8e545e98243e64473148c319e5799a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ydyZicAfdxHYvDrL0G87Q.jpeg"/></div></div></figure><div class=""/><p id="555b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们上一次<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/advent-of-kotlin-week-4-mocking-cde699ec9963">kot Lin出现的时候，</a>有一个特别棘手的时刻，我们必须为测试目的创建任何类的实例。这不是一项容易的任务。不同的类以不同的方式创建。它们可能有需要其他对象的构造函数。让我们看看如何创建一个随机类——一个使用random构造函数创建的实例，我们向它传递随机数据。</p><p id="3fcb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将以TDD的方式(测试驱动开发)一步一步来做。</p><p id="6859" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始之前，本文需要一些关于Kotlin的经验。如果你是这个世界的新成员，这可能会很难。如果你想学习科特林，你可以加入我们的<a class="ae kt" href="https://kt.academy" rel="noopener ugc nofollow" target="_blank">工作坊</a>。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://www.kt.academy/workshop/refactoringToCleanCode"><div class="gh gi ku"><img src="../Images/d6ba3dcb5a3de1b3ff65f2512976b60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bQv2PrHMPzjWkWZ1hjAkw.png"/></div></a></figure><h2 id="1515" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">步骤1:具有空构造函数的类</h2><p id="3db1" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">具有空构造函数的类是最简单的情况，因为我们需要做的就是使用这个构造函数。我们期望的是，当一个类的构造函数中没有任何参数时，我们可以使用我们的函数来创建它:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6036" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，<code class="fe lz ma mb mc b">makeRandomInstance</code>需要知道<code class="fe lz ma mb mc b">A</code>的类型。为了不删除它，我们需要具体化这个<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929">类型参数</a>:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="da2a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们可以使用<code class="fe lz ma mb mc b">T::<strong class="jx iz">class</strong></code>引用类。在JVM中，从空构造函数创建实例很容易。我们可以只使用<code class="fe lz ma mb mc b">newInstance</code>:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6665" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法有效，但是只在JVM上有效。为了实现通用，我们需要使用Kotlin反射:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5715" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码中发生的事情是，我们首先引用类(<code class="fe lz ma mb mc b">T::class</code>)，然后获取包含该类提供的所有构造函数的<code class="fe lz ma mb mc b">constructors</code>属性。从这些构造函数中，我们取一个没有参数的。最后，我们调用这个构造函数，这样我们就创建了一个<code class="fe lz ma mb mc b">T</code>的实例。</p><h2 id="0ccd" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">第二步:更多参数</h2><p id="d2fc" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当我们拥有更多参数时，一切都会变得更具挑战性:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="ffab" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，如果没有构造函数，我们将抛出一个错误。</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="104c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决它，我们先从找到一个参数个数最少的构造函数并使用它开始。然后，为了创建每个参数，我们将循环使用<code class="fe lz ma mb mc b">makeRandomInstance</code>。尽管要使用它，我们需要传递参数类型。为了找到它，我们可以检查在这个构造函数中声明为参数的内容。我们接受一个参数，询问它的类型，然后接受它的分类器。如果这不是一个泛型类型，那么它将是我们可以递归使用的<code class="fe lz ma mb mc b">KClass</code>的一个实例，因为它与<code class="fe lz ma mb mc b">T::class</code>相同。我们将在后面讨论处理泛型类型。现在，我们需要提取一个单独的函数，并向其传递一个类型:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6274" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这对我们有用，但是如果某个构造函数不能用，而另一个可以用呢？</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7ff0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最简单的答案是，我们应该迭代地寻找一个我们可以使用的构造函数:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0faa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们不在乎使用哪一个，因为我们需要一个随机的实例。稍后，我们还将随机化我们尝试构造函数的顺序。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi ku"><img src="../Images/3860f92ecd05def9ec2568695cfc2895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVLi_vixkafibx_Rzo19dg.jpeg"/></div></a></figure><h2 id="38b0" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">第三步:原语</h2><figure class="kv kw kx ky gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi md"><img src="../Images/09c791664c291feb5b7dedb1f710b8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEaAvARMnZP336PUEaqKcg.jpeg"/></div></div></figure><p id="a744" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有些类型不是通过构造函数创建的，也不受函数支持。原始人！为了简化，我只包括了最重要的:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="360c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要单独的方法来创建它们。我们可以使用<code class="fe lz ma mb mc b">Random</code>创建随机实例:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="bf6e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它也适用于通过构造函数传递原语的类:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h1 id="2c43" class="me la iy bd lb mf mg mh le mi mj mk lh ml mm mn lk mo mp mq ln mr ms mt lq mu bi translated">停止</h1><p id="a1b0" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这是我想阻止你们大多数人的一点。我们的实现已经支持大多数类型，这应该会让您有所了解。在这之后，我们需要进入泛型的世界，事情变得更加糟糕。我们需要开始使用黑客和特定于平台的反射。这是因为泛型在JVM中是有问题的。它们是在Java 5 (J2SE 5.0)中引入的，并不真正存在于JVM字节码中。所以Java中的泛型类型在编译时会被删除。有一些小技巧可以参考，但并不美，也不完美。这就是为什么我鼓励你在理解了随机类创建背后的逻辑之后，停止在这个令人满意的解决方案上。如果你愿意留下来，让我们深入泛型。</p><h1 id="e9ab" class="me la iy bd lb mf mg mh le mi mj mk lh ml mm mn lk mo mp mq ln mr ms mt lq mu bi translated">步骤4:标准接口</h1><p id="a850" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有许多我们操作的接口，甚至不知道在引擎盖下是什么类。比如说<code class="fe lz ma mb mc b">List</code>或者<code class="fe lz ma mb mc b">Map</code>。我们使用<code class="fe lz ma mb mc b">listOf</code>或<code class="fe lz ma mb mc b">mapOf</code>创建它们，我们不需要知道它真正返回什么，只要它是<code class="fe lz ma mb mc b">List</code>或<code class="fe lz ma mb mc b">Map</code>的实例。因为它们经常被使用，所以我们也需要支持这些接口:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="410e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还应该支持需要这些集合作为构造函数参数的类:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="26d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想知道为什么<code class="fe lz ma mb mc b">B</code>在类外被声明，那是因为<a class="ae kt" href="https://youtrack.jetbrains.net/issue/KT-29029" rel="noopener ugc nofollow" target="_blank">这个错误</a>。</p><p id="73e3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们不想要空集合。我们希望他们有一些价值观。有一个问题。标准集合是泛型类型。为了填充它们，我们需要生成关联到它们的<a class="ae kt" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">类型参数</a>的实例。为此，我们需要知道那些<a class="ae kt" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">类型的参数</a>！但是类型在JVM中被删除了。诀窍是采用类型引用。它本身不受支持，但Alexander Udalov实现了一个解决方案。以下是<code class="fe lz ma mb mc b">getKType</code>功能的链接:</p><blockquote class="mv"><p id="a496" class="mw mx iy bd my mz na nb nc nd ne ks dk translated"><a class="ae kt" href="https://gist.github.com/udalov/bb6f398c2e643ee69586356fdd67e9b1" rel="noopener ugc nofollow" target="_blank">链接到getKType实现</a></p></blockquote><p id="a2c3" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">有了这些，我们就可以引用类型，然后用它来获取类型或参数。</p><p id="33d6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">限制是这个函数不支持可空类型，所以我们根本不会产生空值。</p><p id="f3cc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，这种类型现在只用于集合。这就是我们如何添加对创建大小从0到10的随机集合的支持:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="66f9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，当我们创建列表或映射时，我们使用<code class="fe lz ma mb mc b">KType</code>来获取泛型类型，然后递归地创建实例。</p><figure class="kv kw kx ky gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi ku"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><h2 id="e868" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">步骤5:泛型类型</h2><p id="66af" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们也开始支持泛型类型:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="f7cf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题在于，当构造函数参数是泛型类型时，它不是具体的类，而是类型参数:</p><pre class="kv kw kx ky gt nk mc nl nm aw nn bi"><span id="3078" class="kz la iy mc b gy no np l nq nr">class A&lt;T&gt;(t: T)</span></pre><p id="9e82" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么当我们取它的分类器时，它不是一个<code class="fe lz ma mb mc b">KClass</code>，而是一个<code class="fe lz ma mb mc b">KTypeParameter</code>。因此，在前面的实现中，我们将在以下方面出错:</p><pre class="kv kw kx ky gt nk mc nl nm aw nn bi"><span id="4f42" class="kz la iy mc b gy no np l nq nr">paramType.<strong class="mc iz">classifier as </strong>KClass&lt;*&gt;</span></pre><p id="d2e2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，我们需要添加对<code class="fe lz ma mb mc b">KTypeParameter</code>的支持。类型参数没有任何关于传递的类型参数的信息。它试图告诉我们传递给<code class="fe lz ma mb mc b">A</code>的是什么类型，只知道<code class="fe lz ma mb mc b">A</code>是如何定义的。在哪里可以找到这些信息？一般类型的！问题是在类类型中，你知道例如<code class="fe lz ma mb mc b">A&lt;String&gt;</code>中的类型参数是<code class="fe lz ma mb mc b">String</code>，但是我们不知道与这个类型参数关联的类型参数的名称是什么。这就是为什么我们也需要一个通用的类引用。使用这3个，我们可以使用类型参数引用来获得一个名称，使用这个名称和类引用来告诉我们要从哪个位置获取类型实参，最后使用这个位置获取具体的类型实参，并使用这个实参类型:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h2 id="681b" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">步骤6:随机化、配置和抛光</h2><p id="ef70" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们努力使这些实例更加随机。尽管这意味着什么？是否意味着一个随机列表应该有一个从0到<code class="fe lz ma mb mc b">Int.<strong class="jx iz">MAX_VALUE</strong></code>的随机长度？我们生产的绳子的长度应该是多少？这些问题没有明确的答案。让我们让用户通过配置一些属性来决定。我们将让用户配置应该使用的长度和对象(如果需要的话):</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0e5b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1ccb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还应该让用户设置具体的<code class="fe lz ma mb mc b">Random</code>。多亏了它，我们才能做这样的测试:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="bc9c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了不将这个随机和配置作为参数传递，我决定将所有助手函数包装到一个类中。这是最终的实现和测试:</p><figure class="kv kw kx ky gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7d38" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可能支持更原始的类型或集合。它可能支持数组。更多的东西可以配置。虽然这些都是细节。此时，您应该完全知道如何添加所有这些元素。您还应该对Kotlin反射有更多的了解。它既不容易也不高效，但是正如你所看到的，最终，我们可以用它做几乎任何事情。</p><h1 id="5763" class="me la iy bd lb mf mg mh le mi mj mk lh ml mm mn lk mo mp mq ln mr ms mt lq mu bi translated">关于研讨会的思考</h1><p id="ac61" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在<a class="ae kt" href="http://kt.academy/" rel="noopener ugc nofollow" target="_blank"> Kt。学院</a>我们在全球范围内举办Kotlin研讨会。反射的基础知识包含在关于pure Kotlin的标准研讨会或后端开发人员的<a class="ae kt" href="http://kt.academy/Kotlin_in_Backend.html" rel="noopener ugc nofollow" target="_blank"> Kotlin中。如果你已经在你的公司使用了反射，请告诉我，我们可以在Kotlin反射中讨论逻辑和类。</a></p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h2 id="6427" class="kz la iy bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="2ae5" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kt" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p></div></div>    
</body>
</html>