<html>
<head>
<title>How to create simple image recognition with Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python创建简单的图像识别？</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/how-to-create-simple-image-recognition-with-python-684398edab2e?source=collection_archive---------0-----------------------#2019-05-28">https://medium.com/duomly-blockchain-online-courses/how-to-create-simple-image-recognition-with-python-684398edab2e?source=collection_archive---------0-----------------------#2019-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7e173a7e2ceadacb27a29c935e6369c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcQt38zdn1c2tsbiqwLAvw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">www.duomly.com — programming online courses</a></figcaption></figure><p id="2b8a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发布于:<a class="ae it" href="https://www.blog.duomly.com/how-to-create-image-recognition-with-python/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/how-to-create-image-recognition-with-python/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="080f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">图像识别是最普遍的机器学习类问题之一。它旨在训练机器像人一样识别图像。</p><p id="9cd4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更准确地说，图像识别属于监督学习问题组，即分类问题。</p><p id="323f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文介绍了一种相对简单的训练神经网络识别数字的方法。这种方法使用普通的前馈神经网络。使用其他技术可以进一步提高模型的准确性。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="c0ff" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">创建基本模型</h2><p id="7199" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">创建基本模型时，您至少应该做以下五件事:</p><ol class=""><li id="1ac1" class="kz la hh iw b ix iy jb jc jf lb jj lc jn ld jr le lf lg lh bi translated"><strong class="iw hi">导入模块、类和函数</strong>。在本文中，我们将使用<strong class="iw hi"> Keras </strong>库来处理神经网络，使用<strong class="iw hi"> scikit-learn </strong>来获取和准备数据。</li><li id="1fc0" class="kz la hh iw b ix li jb lj jf lk jj ll jn lm jr le lf lg lh bi translated"><strong class="iw hi">加载数据</strong>。这篇文章展示了如何识别手写的数字。来自sklearn.datasets的函数load_digits()提供了1797个观察值。每个观察值有64个特征，代表1797张8像素高、8像素宽的图片的像素。每个特征可以在0-16的范围内，取决于它的灰度。输出代表正确的数字，可以是0-9范围内的整数值。</li><li id="9057" class="kz la hh iw b ix li jb lj jf lk jj ll jn lm jr le lf lg lh bi translated"><strong class="iw hi">转换和分割数据</strong>。我们首先需要对输出进行二进制化，也就是说，将每个输出作为值为0和1的向量。然后，我们必须将整个数据集分成训练集和测试集。最后，我们将输入标准化。</li><li id="58cb" class="kz la hh iw b ix li jb lj jf lk jj ll jn lm jr le lf lg lh bi translated"><strong class="iw hi">创建分类模型并训练(fit) </strong>。最简单的模型有一个未显式添加的输入层、一个隐藏层和一个输出层。我们使用训练集来训练我们的神经网络。</li><li id="1ab9" class="kz la hh iw b ix li jb lj jf lk jj ll jn lm jr le lf lg lh bi translated"><strong class="iw hi">测试分类模型</strong>。最后，我们使用测试集测试网络的性能。</li></ol><p id="c8d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码如下所示:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="b20b" class="jz ka hh ls b fi lw lx l ly lz"># 1. Import modules, classes and functions<br/>import keras<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from sklearn.datasets import load_digits<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import LabelBinarizer, StandardScaler</span><span id="85c2" class="jz ka hh ls b fi ma lx l ly lz"># 2. Load data<br/>x, y = load_digits(n_class=10, return_X_y=True)<br/><br/># 3. Transform and split data<br/># Create the binary output<br/>tr = LabelBinarizer(neg_label=0, pos_label=1, sparse_output=False)<br/>y = tr.fit_transform(y)<br/># Split train and test data<br/>x_train, x_test, y_train, y_test =\<br/>    train_test_split(x, y, test_size=0.3, random_state=0)<br/># Standardize the input<br/>sc = StandardScaler()<br/>x_train, x_test = sc.fit_transform(x_train), sc.transform(x_test)<br/><br/># 4. Create the classification model and train (fit) it<br/>cl = Sequential()<br/># Add the hidden layer<br/>cl.add(Dense(units=500, activation='relu', use_bias=True,<br/>             kernel_initializer='uniform', bias_initializer='zeros',<br/>             input_shape=(x_train.shape[1],)))<br/># Add the output layer<br/>cl.add(Dense(units=10, activation='softmax', use_bias=True,<br/>             kernel_initializer='uniform', bias_initializer='zeros'))<br/># Compile the classification model<br/>cl.compile(loss='categorical_crossentropy', optimizer='adam',<br/>           metrics=['accuracy'])<br/># Fit (train) the classification model<br/>cl.fit(x_train, y_train, epochs=100, batch_size=10)<br/><br/># 5. Test the classification model<br/>result = cl.evaluate(x_test, y_test, batch_size=128)<br/>for i in range(2):<br/>    print(f'{cl.metrics_names[i]}: {result[i]}')</span></pre><p id="59bc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以看到，模型的准确率大约是97.8 %。结果可能有所不同！</p><p id="f7dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用超参数，并更改隐藏层中的单元数、优化器、训练的代数数、批次大小等，尝试进一步提高网络的准确性。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="7d9e" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">让网络更深</h2><p id="981c" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">深度神经网络有不止一个隐藏层。添加隐藏层可能会提高准确性。代码与前一种情况几乎相同，只是增加了一条语句来添加另一个隐藏层:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1031" class="jz ka hh ls b fi lw lx l ly lz"># 1. Import modules, classes and functions<br/>import keras<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from sklearn.datasets import load_digits<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import LabelBinarizer, StandardScaler<br/><br/># 2. Load data<br/>x, y = load_digits(n_class=10, return_X_y=True)<br/><br/># 3. Transform and split data<br/># Create the binary output<br/>tr = LabelBinarizer(neg_label=0, pos_label=1, sparse_output=False)<br/>y = tr.fit_transform(y)<br/># Split train and test data<br/>x_train, x_test, y_train, y_test =\<br/>    train_test_split(x, y, test_size=0.3, random_state=0)<br/># Standardize the input<br/>sc = StandardScaler()<br/>x_train, x_test = sc.fit_transform(x_train), sc.transform(x_test)<br/><br/># 4. Create the classification model and train (fit) it<br/>cl = Sequential()<br/># Add the first hidden layer<br/>cl.add(Dense(units=500, activation='relu', use_bias=True,<br/>             kernel_initializer='uniform', bias_initializer='zeros',<br/>             input_shape=(x_train.shape[1],)))<br/># Add the second hidden layer<br/>cl.add(Dense(units=500, activation='relu', use_bias=True,<br/>             kernel_initializer='uniform', bias_initializer='zeros',<br/>             input_shape=(x_train.shape[1],)))<br/># Add the output layer<br/>cl.add(Dense(units=10, activation='softmax', use_bias=True,<br/>             kernel_initializer='uniform', bias_initializer='zeros'))<br/># Compile the classification model<br/>cl.compile(loss='categorical_crossentropy', optimizer='adam',<br/>           metrics=['accuracy'])<br/># Fit (train) the classification model<br/>cl.fit(x_train, y_train, epochs=100, batch_size=10)<br/><br/># 5. Test the classification model<br/>result = cl.evaluate(x_test, y_test, batch_size=128)<br/>for i in range(2):<br/>    print(f'{cl.metrics_names[i]}: {result[i]}')</span></pre><p id="1b7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">准确率略有提高，达到98.3 %。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="77d2" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">卷积神经网络和其他改进</h2><p id="a416" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">图像识别问题的解决往往比我们在这里获得的精度更高。改进用于图像识别的网络的一种方法是通过添加卷积和汇集层，形成卷积神经网络。</p><p id="4c04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，可以使用某种正规化，作为辍学。</p><p id="ddbf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有关如何使用Keras实现这一点的更多信息，您可以查看Keras的官方文档。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="d728" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">结论</h2><p id="6f20" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated">本文介绍了如何使用Python及其机器学习库Keras和scikit-learn实现图像识别。图像识别是监督学习，即分类任务。</p><p id="f017" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这仅仅是开始，还有许多技术可以提高所给出的分类模型的准确性。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d5ee4c5640193ff931b57af57d9cd1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VTFJp7Yhh3Ky9Fm2dj-8w.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">www.duomly.com — programming online courses</a></figcaption></figure><p id="7e18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="e417" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">内容由我们的队友米尔科提供。</p></div></div>    
</body>
</html>