<html>
<head>
<title>Animating brush Text coloring in Compose 🖌️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合成🖌️中的动画笔刷文本着色</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/animating-brush-text-coloring-in-compose-%EF%B8%8F-26ae99d9b402?source=collection_archive---------0-----------------------#2022-08-01">https://medium.com/androiddevelopers/animating-brush-text-coloring-in-compose-%EF%B8%8F-26ae99d9b402?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d871039693c95492fe7d3961ec5e6eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fEDrtJES1CQEVlyI7WjgQ.png"/></div></div></figure><div class=""/><p id="878a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Compose中给你的文本添加渐变后，现在是时候给它添加动画了！</p><p id="fb35" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章建立在使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">Brush</a></code> API的文本样式之上，并合成<a class="ae jr" href="https://developer.android.com/jetpack/compose/animation" rel="noopener ugc nofollow" target="_blank">动画</a>！确保你熟悉这些概念。在这篇博文<a class="ae jr" rel="noopener" href="/androiddevelopers/brushing-up-on-compose-text-coloring-84d7d70dd8fa">中，我们在这里</a>讨论了使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank">Brush</a></code> API的所有集成。</p><h1 id="b679" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">糖果棒闪光效果</h1><p id="e3fe" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们想在文本中为渐变实现一个糖果棒效果。按照我们的设计，渐变中的颜色应该从文本的左上角连续移动到右下角:</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/1d7a5ec895343c70efacc2d16c8bfb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9zn6MLbLsyVF5K_-"/></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">Candy cane animation with tileMode mirror</em></figcaption></figure><p id="e9c6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush#linearGradient(kotlin.Array,androidx.compose.ui.geometry.Offset,androidx.compose.ui.geometry.Offset,androidx.compose.ui.graphics.TileMode)" rel="noopener ugc nofollow" target="_blank">linearGradient</a></code>来创建渐变，沿着给定的<code class="du jn jo jp jq b">start</code>和<code class="du jn jo jp jq b">end</code>坐标放置颜色。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="0617" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于线性渐变的工作方式，坐标定义了线性画笔绘画的区域和角度。在我们的示例中，如果您按照下图所述定义一个区域，画笔描边将被对角裁剪，这很容易看出画笔大小是否小于绘图区域:</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lh"><img src="../Images/4b65306f87fe3f0ac36c43251d28be49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jCdpU73IWrVUoPKk"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx">Linear gradient with <code class="du jn jo jp jq b">start</code> in (0,0) and <code class="du jn jo jp jq b">end</code> in (n,m) coordinates</figcaption></figure><p id="fa2f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，实现这个动画的一个想法是在绘图区域的一小部分制作<code class="du jn jo jp jq b">start</code>和<code class="du jn jo jp jq b">end</code>坐标的动画，然后重复这个序列。</p><p id="812e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以定义一个无限过渡，并使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#(androidx.compose.animation.core.InfiniteTransition).animateFloat(kotlin.Float,kotlin.Float,androidx.compose.animation.core.InfiniteRepeatableSpec)" rel="noopener ugc nofollow" target="_blank">animateFloat</a></code>将一个从0f到至少两倍于你的字体大小的像素值动画化。因为在这种情况下我们不知道绘制区域的大小，所以我们使用字体大小作为定位点，它直接关系到绘制文本的区域。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d1fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们可以使用这个动画偏移，使渐变在画布的特定区域移动，然后在剩余的可用空间中重复这个序列。这是没有重复的第一步的样子:</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/1d70b7153a0ad641a26e9dd3a3f8ca52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*qH1bIAPMNkGjvdb8"/></div></figure><p id="b0ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以创建线性渐变画笔，使用动画偏移配置绘图区域的<code class="du jn jo jp jq b">start</code>和<code class="du jn jo jp jq b">end</code>坐标，并将其应用于文本。我们从(0，0)坐标开始，然后向上移动，直到我们定义的偏移量。</p><p id="5afc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了重复序列和创造连续性的效果，我们可以使用<code class="du jn jo jp jq b">tileMode</code> <code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Mirror()" rel="noopener ugc nofollow" target="_blank">mirror</a></code>。所以代码看起来像这样:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9e62" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！您已经实现了糖果棒效果，适用于任何文本大小和密度的设备。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/1d7a5ec895343c70efacc2d16c8bfb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9zn6MLbLsyVF5K_-"/></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">Candy cane animation with tileMode mirror</em></figcaption></figure><blockquote class="li lj lk"><p id="3ebe" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">您可以通过调整偏移的<code class="du jn jo jp jq b">targetValue</code>和渐变的<code class="du jn jo jp jq b">offset</code>参数来创建其他类型的效果(例如更快的过渡或更粗的渐变)。</p></blockquote><h1 id="5779" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">来回闪光效果</h1><p id="171b" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">接下来，我们有一个新的动画，由一个来回摇摆的渐变组成。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/4275a84f0e59ba6bfd8db16d4bd52fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*73QFASfFtoJtlkNH"/></div></figure><p id="81aa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在前面的例子中，我们使用了<code class="du jn jo jp jq b">currentFontSizePx</code>来估计动画的面积有多大，使用这个估计就足以达到我们想要的效果。但有时，我们可能想知道文本或绘图区域所占的确切大小。要访问这个大小(也是笔刷大小)，我们可以创建一个自定义笔刷，就像我们在<a class="ae jr" rel="noopener" href="/androiddevelopers/brushing-up-on-compose-text-coloring-84d7d70dd8fa">上一篇文章</a>的<strong class="ir ht"> <em class="ll">自定义笔刷</em> </strong>部分所做的那样。</p><p id="9d5e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以开始考虑如何绘制渐变移动的第一遍，坐标是动画<code class="du jn jo jp jq b">offset</code>和绘图区域的宽度和高度的函数。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/0140404b7381001ea4763e1d21b447c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*OY82MFyiVqsrClMn"/></div></figure><p id="634d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们定义一个无限过渡，动画范围从0f到1f。我们可以配置<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/RepeatMode#Reverse" rel="noopener ugc nofollow" target="_blank">RepeatMode.Reverse</a></code>，这样渐变可以画成向一个方向移动，然后反方向移动。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4b26" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于渐变模式，我们可以使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#LinearGradientShader(androidx.compose.ui.geometry.Offset,androidx.compose.ui.geometry.Offset,kotlin.collections.List,kotlin.collections.List,androidx.compose.ui.graphics.TileMode)" rel="noopener ugc nofollow" target="_blank">LinearGradientShader</a></code>方法创建一个线性渐变画笔。和以前一样，从和到表示画笔将要绘制的坐标。</p><p id="47a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以定义<code class="du jn jo jp jq b">widthOffset</code>和<code class="du jn jo jp jq b">heightOffset</code>变量，根据动画偏移量缩放宽度和高度。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="2467" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们可以使用<code class="du jn jo jp jq b">tileMode</code> <code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/TileMode#Mirror()" rel="noopener ugc nofollow" target="_blank">mirror</a></code>来填充绘图空间与反梯度允许来回移动的效果。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/5f9e589c6c87f21133fe572bcf48efcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AXCURQxXuTBdkonV"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">In between key frames without mirror effect</em></figcaption></figure><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/6358c121c2c87b9e8ff6e18940f5ca69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N2zKUk4reE_pCfEr"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">In between key frames with mirror effect</em></figcaption></figure><p id="15c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们将新笔刷设置为<code class="du jn jo jp jq b">Text</code>。代码可能看起来像这样:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="66a1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)" rel="noopener ugc nofollow" target="_blank">remember</a></code>函数来允许在<code class="du jn jo jp jq b">offset</code>改变时进行重组。这是必要的，因为由于<code class="du jn jo jp jq b"><a class="ae jr" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui-text/src/androidMain/kotlin/androidx/compose/ui/text/platform/AndroidTextPaint.android.kt?q=AndroidTextPaint%20" rel="noopener ugc nofollow" target="_blank">AndroidTextPaint</a></code>中的<a class="ae jr" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui-text/src/androidMain/kotlin/androidx/compose/ui/text/platform/AndroidTextPaint.android.kt;l=92" rel="noopener ugc nofollow" target="_blank">内部</a>优化，如果笔刷或其直接参数没有改变，则不会安排重组。在这种情况下，笔刷保持不变，改变的是<code class="du jn jo jp jq b">LinearGradientShader</code>的参数。</p><p id="4a12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你就完成了，你已经完成了✨.上方的设计</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div class="er es kv"><img src="../Images/4275a84f0e59ba6bfd8db16d4bd52fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*73QFASfFtoJtlkNH"/></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">Rocking animation with tileMode mirror</em></figcaption></figure><h1 id="cda4" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">概述</h1><p id="0ff4" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">你已经学习了如何使用不同的<code class="du jn jo jp jq b">Brush</code>API和一些技术来制作你的渐变颜色。</p><p id="63f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在您的应用中尝试一下，如果您遇到任何问题，请在<a class="ae jr" href="https://issuetracker.google.com/issues/new?component=779818&amp;template=1371638" rel="noopener ugc nofollow" target="_blank">我们的问题跟踪器</a>上提交一个错误，让我们知道。</p><p id="5577" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快乐作曲！👋</p></div><div class="ab cl lr ls go lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ha hb hc hd he"><p id="5060" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ll">本文由Jetpack撰写文本团队的</em><a class="ae jr" href="http://twitter.com/halilozercan" rel="noopener ugc nofollow" target="_blank"><em class="ll">Halil zercan</em></a><em class="ll">合作撰写。感谢DevRel团队中的</em> <a class="ae jr" href="https://twitter.com/riggaroo" rel="noopener ugc nofollow" target="_blank"> <em class="ll">丽贝卡·弗兰克斯</em> </a> <em class="ll">和</em> <a class="ae jr" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"> <em class="ll">弗洛里纳·芒特内斯库</em> </a> <em class="ll">对他们的全面审查。</em></p></div></div>    
</body>
</html>