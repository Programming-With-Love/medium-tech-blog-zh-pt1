<html>
<head>
<title>Abstraction &amp; Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象与构成</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6?source=collection_archive---------0-----------------------#2018-02-28">https://medium.com/javascript-scene/abstraction-composition-cb2849d5bdd6?source=collection_archive---------0-----------------------#2018-02-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="62a6" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi">注:</strong>这是《作曲软件》系列的一部分<strong class="iz hi">s</strong><a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">T5】(现在一本书！) </a>从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae jv" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">买书</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">索引</a>|<a class="ae jv" rel="noopener" href="/javascript-scene/curry-and-function-composition-2c208d774983">|&lt;上一张</a> | <a class="ae jv" rel="noopener" href="/javascript-scene/abstract-data-types-and-the-software-crisis-671ea7fc72e7">下一张&gt; </a></p></blockquote><p id="1d55" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我在软件开发方面越成熟，我就越重视基础知识——当我还是初学者时，这些知识看起来微不足道，但现在随着经验的积累，它们具有深远的意义。</p><blockquote class="it iu iv"><p id="33d9" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“在空手道武术中[……]黑带的骄傲象征是佩戴足够长的时间，以便染料褪色为白色，以象征回到初学者状态。”~约翰·梅达，<a class="ae jv" href="https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref=as_li_ss_tl?ie=UTF8&amp;qid=1516330765&amp;sr=8-1&amp;keywords=the+laws+of+simplicity&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=287b1d3357fa799ce7563584e098c5d8" rel="noopener ugc nofollow" target="_blank">《简约法则:设计、技术、商业、生活》</a></p></blockquote><p id="2905" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">根据谷歌词典，抽象是“独立于事物的关联、属性或具体伴随物来考虑事物的过程”。</p><p id="2722" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">抽象这个词来自拉丁语动词<em class="iy"> abstrahere </em>，意思是“抽离”。我喜欢这种洞察力。抽象是关于移除事物的——但是我们移除的是什么，目的是什么？</p><p id="227e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">有时我喜欢将单词翻译成其他语言，然后再翻译回英语，以获得我们在英语中不常想到的其他联想。当我把“抽象”翻译成意第绪语再翻译回来时，结果是“心不在焉”。我也喜欢这个。一个心不在焉的人在自动驾驶仪上运行，没有积极地思考他们在做什么…只是在做。</p><p id="d9ba" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">抽象让我们安全地自动驾驶。所有的软件都是自动化的。如果有足够的时间，你在电脑上做的任何事情，你都可以用纸、墨水和信鸽来做。软件只是处理那些手工处理起来太耗时的小细节。</p><p id="3aea" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">所有的软件都是抽象的，隐藏了所有的艰苦工作和无脑的细节，而我们却从中获益。</p><p id="2bdf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">许多软件过程被一次又一次地重复。如果在问题分解阶段，我们决定一遍又一遍地重新实现重复的东西，那将需要很多不必要的工作。至少这是愚蠢的。在许多情况下，这是不切实际的。</p><p id="86ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">相反，我们通过编写某种组件(函数、模块、类等等)，给它一个名字(身份)，并尽可能多次地重用它来消除重复。</p><p id="3963" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">分解的过程就是抽象的过程。成功的抽象意味着结果是一组独立有用且可重组的组件。由此我们得到了软件架构的一个重要原则:</p><p id="4fe7" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">软件解决方案应该可以分解成它们的组成部分，并且可以重新组合成新的解决方案，而不需要改变内部组件实现的细节。</p><h1 id="b012" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">抽象是简化的行为</h1><blockquote class="it iu iv"><p id="0532" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">"简单就是减去明显的东西，加上有意义的东西."~约翰·梅达，<a class="ae jv" href="https://www.amazon.com/Laws-Simplicity-Design-Technology-Business/dp/0262134721/ref=as_li_ss_tl?ie=UTF8&amp;qid=1516330765&amp;sr=8-1&amp;keywords=the+laws+of+simplicity&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=287b1d3357fa799ce7563584e098c5d8" rel="noopener ugc nofollow" target="_blank">《简约法则:设计、技术、商业、生活》</a></p></blockquote><p id="ada6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">抽象过程有两个主要部分:</p><ul class=""><li id="b070" class="kx ky hh iz b ja jb je jf jw kz jx la jy lb ju lc ld le lf bi translated"><strong class="iz hi">概括</strong>是在重复的模式中寻找<em class="iy">相似性</em>(明显的)并将相似性隐藏在抽象背后的过程。</li><li id="df7c" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated"><strong class="iz hi">专门化</strong>是使用抽象的过程，只为每个用例提供<em class="iy">不同的</em>(有意义的)。</li></ul><p id="8a8b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">抽象是提取概念的潜在本质的过程。通过探索不同领域的不同问题之间的共同点，我们学会了如何跳出我们的思维定势，从不同的角度看待问题。当我们看到一个问题的本质时，我们发现一个好的解决方案可能适用于许多其他问题。如果我们很好地编写解决方案，我们可以从根本上降低应用程序的复杂性。</p><blockquote class="it iu iv"><p id="43c8" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">"如果你以深刻的觉知触摸一件事物，你就触摸了一切."~一行禅师</p></blockquote><p id="26a6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个原则可以用来从根本上减少构建应用程序所需的代码。</p><h1 id="c9da" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">软件中的抽象</h1><p id="95e1" class="pw-post-body-paragraph iw ix hh iz b ja ll jc jd je lm jg jh jw ln jk jl jx lo jo jp jy lp js jt ju ha bi translated">软件中的抽象有多种形式:</p><ul class=""><li id="8042" class="kx ky hh iz b ja jb je jf jw kz jx la jy lb ju lc ld le lf bi translated">算法</li><li id="b07c" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">数据结构</li><li id="b706" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">模块</li><li id="22ae" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">班级</li><li id="9dab" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">结构</li></ul><p id="75ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我个人最喜欢的是:</p><blockquote class="it iu iv"><p id="7a1e" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“有时候，优雅的实现只是一个函数。不是方法。不是一个班。不是框架。只是一个功能。”~约翰·卡马克(Id软件，Oculus VR)</p></blockquote><p id="5410" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">函数是很好的抽象，因为它们拥有良好抽象所必需的品质:</p><ul class=""><li id="20d5" class="kx ky hh iz b ja jb je jf jw kz jx la jy lb ju lc ld le lf bi translated"><strong class="iz hi">身份</strong> —为其指定名称并在不同的上下文中重用它的能力。</li><li id="3fda" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated"><strong class="iz hi">组合</strong> —将简单函数组合成更复杂函数的能力。</li></ul><h1 id="65be" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">通过构图进行抽象</h1><p id="dafe" class="pw-post-body-paragraph iw ix hh iz b ja ll jc jd je lm jg jh jw ln jk jl jx lo jo jp jy lp js jt ju ha bi translated">软件中最有用的抽象函数是<em class="iy">纯函数</em>，它们与数学中的函数共享模块化特征。在数学中，给定相同输入的函数将总是返回相同的输出。可以把函数看作输入和输出之间的关系。给定一些输入<code class="du lq lr ls lt b">A</code>，函数<code class="du lq lr ls lt b">f</code>将产生<code class="du lq lr ls lt b">B</code>作为输出。你可以说<code class="du lq lr ls lt b">f</code>定义了<code class="du lq lr ls lt b">A</code>和<code class="du lq lr ls lt b">B</code>之间的关系:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="bbdc" class="mc ka hh lt b fi md me l mf mg">f: A -&gt; B</span></pre><p id="0051" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">同样，我们可以定义另一个函数<code class="du lq lr ls lt b">g</code>，它定义了<code class="du lq lr ls lt b">B</code>和<code class="du lq lr ls lt b">C</code>之间的关系:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="010d" class="mc ka hh lt b fi md me l mf mg">g: B -&gt; C</span></pre><p id="a6ab" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个<em class="iy">意味着</em>另一个函数<code class="du lq lr ls lt b">h</code>，它定义了从<code class="du lq lr ls lt b">A</code>到<code class="du lq lr ls lt b">C</code>的直接关系:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="9000" class="mc ka hh lt b fi md me l mf mg">h: A -&gt; C</span></pre><p id="62dd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这些关系构成了问题空间的结构，而您在应用程序中组合函数的方式构成了应用程序的结构。</p><p id="57d1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">好的抽象通过隐藏结构来简化，同样的方式<code class="du lq lr ls lt b">h</code>将<code class="du lq lr ls lt b">A -&gt; B -&gt; C</code>减少到<code class="du lq lr ls lt b">A -&gt; C</code>。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/3f8a6fa4d04ec20036701f93af73ff36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFTKDgI0kT878E97K14V1A.png"/></div></div></figure><h1 id="7151" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">如何用更少的代码做更多的事情</h1><p id="8cdf" class="pw-post-body-paragraph iw ix hh iz b ja ll jc jd je lm jg jh jw ln jk jl jx lo jo jp jy lp js jt ju ha bi translated">抽象是用更少的代码做更多事情的关键。例如，假设您有一个简单地将两个数字相加的函数:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="c817" class="mc ka hh lt b fi md me l mf mg">const add = (a, b) =&gt; a + b;</span></pre><p id="47a5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">但是您经常使用它来增加，那么固定其中一个数字可能是有意义的:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="07cb" class="mc ka hh lt b fi md me l mf mg">const a = add(1, 1);<br/>const b = add(a, 1);<br/>const c = add(b, 1);<br/>// ...</span></pre><p id="a2a2" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">我们可以使用add函数:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="a71b" class="mc ka hh lt b fi md me l mf mg">const add = a =&gt; b =&gt; a + b;</span></pre><p id="12ed" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">然后创建一个部分应用程序，将函数应用于它的第一个参数，并返回一个接受下一个参数的新函数:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="ccb2" class="mc ka hh lt b fi md me l mf mg">const inc = add(1);</span></pre><p id="2ba5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">现在，当我们需要增加<code class="du lq lr ls lt b">1</code>时，我们可以使用<code class="du lq lr ls lt b">inc</code>而不是<code class="du lq lr ls lt b">add</code>，这减少了所需的代码:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="7866" class="mc ka hh lt b fi md me l mf mg">const a = inc(1);<br/>const b = inc(a);<br/>const c = inc(b);<br/>// ...</span></pre><p id="df7d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">在这种情况下，<code class="du lq lr ls lt b">inc</code>只是一个<em class="iy">的专门</em>版本的add。所有的抽象函数都是抽象的。事实上，所有高阶函数都是一般化的，您可以通过传递一个或多个参数来专门化它们。</p><p id="79c9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">例如，<code class="du lq lr ls lt b">Array.prototype.map()</code>是一个高阶函数，它抽象了将函数应用于数组的每个元素的思想，以便返回一个新的处理值数组。我们可以将<code class="du lq lr ls lt b">map</code>写成一个可定制的函数来使这一点更加明显:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="96e9" class="mc ka hh lt b fi md me l mf mg">const map = f =&gt; arr =&gt; arr.map(f);</span></pre><p id="a85b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">这个版本的<code class="du lq lr ls lt b">map</code>接受专门化的函数，然后返回一个它自己的专门化版本，接受要处理的数组:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="ec02" class="mc ka hh lt b fi md me l mf mg">const f = n =&gt; n * 2;</span><span id="937b" class="mc ka hh lt b fi mi me l mf mg">const doubleAll = map(f);<br/>const doubled = doubleAll([1, 2, 3]);<br/>// =&gt; [2, 4, 6]</span></pre><p id="ce57" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">注意，<code class="du lq lr ls lt b">doubleAll</code>的定义只需要少量代码:<code class="du lq lr ls lt b">map(f)</code>——就是这样！这就是全部的定义。从有用的抽象概念开始，我们可以用很少的新代码构建相当复杂的行为。</p><h1 id="251b" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="6785" class="pw-post-body-paragraph iw ix hh iz b ja ll jc jd je lm jg jh jw ln jk jl jx lo jo jp jy lp js jt ju ha bi translated">软件开发人员的整个职业生涯都在创建和构建抽象——许多人没有很好地掌握抽象或构建的基础。</p><p id="9048" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">当你创建抽象时，你应该深思熟虑，并且你应该意识到已经为你所用的好的抽象(比如总是有用的<code class="du lq lr ls lt b">map</code>、<code class="du lq lr ls lt b">filter</code>和<code class="du lq lr ls lt b">reduce</code>)。学会识别好的抽象的特征:</p><ul class=""><li id="6162" class="kx ky hh iz b ja jb je jf jw kz jx la jy lb ju lc ld le lf bi translated">简单的</li><li id="ae22" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">简明的</li><li id="1fcb" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">可重复使用的</li><li id="3598" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">自主的</li><li id="32b5" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">可分解的</li><li id="50ae" class="kx ky hh iz b ja lg je lh jw li jx lj jy lk ju lc ld le lf bi translated">可重组的</li></ul><h1 id="9a86" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">在EricElliottJS.com了解更多信息</h1><p id="d76c" class="pw-post-body-paragraph iw ix hh iz b ja ll jc jd je lm jg jh jw ln jk jl jx lo jo jp jy lp js jt ju ha bi translated">《抽象与构成》可以作为视频课程提供给EricElliottJS.com的成员。如果你还不是会员，今天就注册吧。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es mj"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">是</em> <a class="ae jv" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【编程JavaScript应用】</em> </a> <em class="iy"> (O'Reilly)的作者，也是软件导师平台</em><a class="ae jv" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人。他为Adobe Systems的</em><strong class="iz hi"><em class="iy">Adobe Systems</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">Zumba Fitness</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">华尔街日报</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">ESPN</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">BBC</em></strong><em class="iy">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh jw jj jk jl jx jn jo jp jy jr js jt ju ha bi translated">他在远离任何地方的地方和世界上最美丽的女人一起工作。</p></div></div>    
</body>
</html>