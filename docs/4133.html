<html>
<head>
<title>Building HandsUp: an OS real-time Q&amp;A App using GraphQL and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建HandsUp:一个使用GraphQL和React的操作系统实时问答应用</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/building-handsup-an-os-real-time-voting-app-using-graphql-and-react-b2b7dcd0e136?source=collection_archive---------1-----------------------#2017-05-17">https://medium.com/google-developer-experts/building-handsup-an-os-real-time-voting-app-using-graphql-and-react-b2b7dcd0e136?source=collection_archive---------1-----------------------#2017-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="dc29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用GraphQL订阅、阿波罗客户端1.0和Auth0</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/eb1d0f5480a902eb909ee5ce9af8d1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9qSGqoUsRHcpKVWYA7kPg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Original from a <a class="ae js" href="https://twitter.com/maryshlikhota/status/854086134212722688" rel="noopener ugc nofollow" target="_blank">tweet</a> by <a class="ae js" href="https://twitter.com/maryshlikhota" rel="noopener ugc nofollow" target="_blank">@maryshlikhota</a></figcaption></figure><p id="255f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将看看使用<a class="ae js" href="https://facebook.github.io/graphql" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"/></a><strong class="ig hi"/>和<strong class="ig hi"> </strong> React构建一个开源实时问答应用程序的所有步骤。</p><ul class=""><li id="ed25" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><strong class="ig hi">解决方案架构</strong> : <a class="ae js" href="#ddf8" rel="noopener ugc nofollow"> HandsUp App </a></li><li id="2892" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi"> GraphQL服务器</strong> : <a class="ae js" href="#dae9" rel="noopener ugc nofollow">使用Graphcool CLI </a>创建它</li><li id="45e1" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">阿波罗客户端</strong> : <a class="ae js" href="#af11" rel="noopener ugc nofollow">引导设置</a>和<a class="ae js" href="#87f1" rel="noopener ugc nofollow">反应集成</a></li><li id="14ee" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">查询</strong> : <a class="ae js" href="#cbe2" rel="noopener ugc nofollow">显示问题</a></li><li id="338f" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">突变</strong> : <a class="ae js" href="#5534" rel="noopener ugc nofollow">投票</a>和<a class="ae js" href="#0d10" rel="noopener ugc nofollow">跟踪投票使用投票</a></li><li id="211c" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">认证用户</strong> : <a class="ae js" href="#f00a" rel="noopener ugc nofollow"> Auth0设置</a>，<a class="ae js" href="#8c5f" rel="noopener ugc nofollow">反应集成</a>，<a class="ae js" href="#0dbc" rel="noopener ugc nofollow"> Graphcool用户集成</a>和<a class="ae js" href="#e513" rel="noopener ugc nofollow">显示登录用户</a></li><li id="35d8" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">订阅</strong> : <a class="ae js" href="#fda8" rel="noopener ugc nofollow">添加新问题</a>和<a class="ae js" href="#ae13" rel="noopener ugc nofollow">订阅它们</a></li></ul><p id="c829" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个应用程序将允许活动的参与者提问(如果登录的话)，并为最有趣的问题投票。</p><p id="a39f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在下面看到最终的结果</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kh"><img src="../Images/bd92f90c2472867e01d59d1be0174ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*0geehkjJ9RDUhc6NywHtVA.gif"/></div></figure><p id="e5a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有用户都可以对问题进行投票，增加了问题的重要性。为了添加新问题，用户必须登录。随着新问题和投票的记录，用户也会得到更新。活动组织者可以利用所有这些信息在活动期间进行问答或小组讨论。</p><p id="0384" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以在<a class="ae js" href="https://github.com/gsans/handsup-react" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中访问最终解决方案。</p><p id="77d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>的我的feed中找到最新的GraphQL内容。</p><h1 id="ddf8" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">解决方案架构:HandsUp应用程序</h1><p id="cd90" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">为了实现这些特性，我们将使用<strong class="ig hi"> GraphQL </strong>。这也是为了展示我们如何通过使用订阅来使用它的实时特性。</p><p id="8362" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于<strong class="ig hi"> GraphQL </strong>和<strong class="ig hi"> Apollo客户端</strong>的介绍，你可以阅读这篇博文。</p><div class="ll lm ez fb ln lo"><a rel="noopener follow" target="_blank" href="/google-developer-experts/graphql-and-the-amazing-apollo-client-fe57e162a70c"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hi fi z dy lt ea eb lu ed ef hg bi translated">GraphQL和神奇的阿波罗客户端</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">探索使用React和Angular构建的应用程序</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">medium.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jm lo"/></div></div></a></div><p id="bdd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在服务器端，我们将使用<a class="ae js" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Graphcool </strong> </a>作为我们的<strong class="ig hi"> GraphQL服务器</strong>。</p><p id="8b86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在客户端，我们将使用<a class="ae js" href="https://github.com/apollostack/apollo-client" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Apollo客户端</strong> </a> <strong class="ig hi"> </strong>作为我们在<strong class="ig hi"> React </strong>和<strong class="ig hi"> GraphQL服务器</strong>之间的桥梁。我们将使用<a class="ae js" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Auth0 </strong> </a>以便用户可以使用他们的社交账户登录我们的应用程序。</p><p id="2996" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后我们会添加<strong class="ig hi"> GraphQL </strong> <strong class="ig hi">订阅</strong>实现新问题的实时更新。</p><p id="da46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参见下面的架构概述:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es md"><img src="../Images/f0a94b12e1cadc097f0f853718089319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQuV2y3sghLVHC1eoYKhIg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Building blocks for our real-time voting Application</figcaption></figure><h1 id="dae9" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">创建GraphQL服务器</h1><p id="03cb" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">让我们开始创建我们的GraphQL服务器。这听起来可能令人望而生畏，但是使用Graphcool CLI ，<strong class="ig hi"> </strong>是非常简单的。在进行下一步之前，继续<a class="ae js" href="https://console.graph.cool/signup" rel="noopener ugc nofollow" target="_blank">并注册</a>。</p><p id="6c7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用<strong class="ig hi"> Graphcool CLI </strong>来创建我们的<strong class="ig hi">数据模型</strong>(模式)。运行这些命令安装CLI并创建新项目。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="4777" class="mj kj hh mf b fi mk ml l mm mn">npm install --global graphcool<br/>graphcool init</span></pre><p id="feb3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按照屏幕上的指示操作，记住先从<a class="ae js" href="https://console.graph.cool/signup" rel="noopener ugc nofollow" target="_blank">注册</a>。这将创建<strong class="ig hi"> GraphQL服务器</strong>来托管我们的数据。初始模式是自动生成的。更新在<strong class="ig hi"> init </strong>命令期间创建的<code class="du mo mp mq mf b">project.graphcool</code>文件，使用最新的可用模式<a class="ae js" href="https://raw.githubusercontent.com/gsans/handsup-react/master/src/HandsUp.schema" rel="noopener ugc nofollow" target="_blank">这里</a>并运行下面的命令。第一个将更新模式。你可以用第二个来打开<strong class="ig hi"> Graphcool控制台</strong>。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="6cee" class="mj kj hh mf b fi mk ml l mm mn">graphcool push<br/>graphcool console</span></pre><blockquote class="mr ms mt"><p id="0009" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">注意:随着更多的特性被添加到项目中，最新的模式可能包括更多的字段和类型</p></blockquote><p id="c83e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们将在本文中使用的最终数据模型<strong class="ig hi">。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es my"><img src="../Images/e726e3f8591d359198cfe00027705a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnPZzWRiPwAKKIq7wgNQkQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Graph View in Graphcool Console</figcaption></figure><p id="d64d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦您对GraphQL更加熟悉，您可能想要创建自己的<strong class="ig hi"> GraphQL服务器</strong>。那完全没问题。阅读Jonas Helfer 的这篇博文了解更多信息。</p><h1 id="c8ab" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">阿波罗客户端</h1><p id="f87c" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated"><strong class="ig hi"> Apollo Client </strong>是一个框架无关的GraphQL客户端，它可以帮助您获取数据，并使您的客户端状态与服务器保持同步。</p><blockquote class="nb"><p id="0276" class="nc nd hh bd ne nf ng nh ni nj nk jb dx translated">安装<a class="ae js" href="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm" rel="noopener ugc nofollow" target="_blank"> Apollo客户端开发工具</a>以获得更好的开发体验</p></blockquote><h2 id="af11" class="mj kj hh bd kk nl nm nn ko no np nq ks ip nr ns kw it nt nu la ix nv nw le nx bi translated">自举设置</h2><p id="9e41" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">为了设置<strong class="ig hi"> Apollo客户端</strong>，我们需要向我们的项目添加一些依赖项。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="790c" class="mj kj hh mf b fi mk ml l mm mn">npm install --save apollo-client react-apollo graphql-tag</span></pre><p id="e162" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将安装运行GraphQL查询所需的依赖项。我们将创建一个单独的文件<code class="du mo mp mq mf b">client.js</code>来保存我们的<strong class="ig hi"> Apollo客户端</strong>设置。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="a91e" class="mj kj hh mf b fi mk ml l mm mn">// src/client.js<br/>import ApolloClient, { createNetworkInterface } from 'apollo-client'</span><span id="6e6e" class="mj kj hh mf b fi ny ml l mm mn">const networkInterface = createNetworkInterface({<br/>  uri: '<a class="ae js" href="https://api.graph.cool/simple/v1/cj1132nbg4pwk0138d8ummhiq'" rel="noopener ugc nofollow" target="_blank"><strong class="mf hi">https://api.graph.cool/simple/v1/YOUR_KEY_HERE</strong>'</a>,<br/>  dataIdFromObject: record =&gt; record.id,<br/>})</span><span id="e31e" class="mj kj hh mf b fi ny ml l mm mn">export const client = new <strong class="mf hi">ApolloClient</strong>({<br/>  networkInterface,<br/>})</span></pre><blockquote class="mr ms mt"><p id="e692" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">为了获得您的<strong class="ig hi">密钥</strong>，您可以使用<strong class="ig hi"> Graphcool CLI </strong>运行<code class="du mo mp mq mf b">graphcool endpoints</code>。</p></blockquote><p id="f909" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从<code class="du mo mp mq mf b">react-apollo</code>我们将使用<strong class="ig hi"> ApolloProvider，</strong>一个自举期间的高阶组件。我们需要使用相同名称的属性来传递我们刚刚设置的<strong class="ig hi">客户端</strong>。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="e75d" class="mj kj hh mf b fi mk ml l mm mn">// src/app.js<br/>import { <strong class="mf hi">ApolloProvider</strong> } from 'react-apollo'<br/>import { <strong class="mf hi">client</strong> } from './client'</span><span id="ad1d" class="mj kj hh mf b fi ny ml l mm mn">render(<br/>  <strong class="mf hi">&lt;ApolloProvider client={client}&gt;</strong><br/>    &lt;HashRouter&gt;<br/>      <strong class="mf hi">&lt;Route path='/' component={HandsUpApp} /&gt;</strong><br/>    &lt;/HashRouter&gt;<br/>  <strong class="mf hi">&lt;/ApolloProvider&gt;</strong>,<br/>  document.getElementById('root')<br/>)</span></pre><p id="5c26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们只需要一条指向主要组件的路线。</p><h2 id="87f1" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">反应积分</h2><p id="468c" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">每当我们需要使用GraphQL时，我们将使用下面的模式来扩展我们的组件</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="34c3" class="mj kj hh mf b fi mk ml l mm mn">import {<strong class="mf hi">graphql</strong>} from 'react-apollo'<br/>import {QUERY_OPERATION} from './graphql/query.operation.gql'</span><span id="a774" class="mj kj hh mf b fi ny ml l mm mn">class Component extends React.Component {}<br/>const withOperation = <strong class="mf hi">graphql</strong>(QUERY_OPERATION, {options})<br/>export default withOperation(Component)</span></pre><p id="9d1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过这样做，我们可以轻松地扩展我们的组件，添加特定的<strong class="ig hi"> GraphQL属性</strong> (props)，然后我们可以使用这些属性与我们的<strong class="ig hi"> GraphQL服务器</strong>进行交互。</p><blockquote class="mr ms mt"><p id="da8b" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">为了导入<code class="du mo mp mq mf b">.graphql</code>或<code class="du mo mp mq mf b">.gql</code>扩展，需要对你的webpack配置进行一些设置。检查<a class="ae js" href="http://dev.apollodata.com/react/webpack.html" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">graph QL-tag/loader</strong></a>。主要的好处是避免在客户端处理<strong class="ig hi"> GraphQL AST </strong>(抽象语法树)而不是使用<strong class="ig hi"> gql`query` </strong>。</p></blockquote><h1 id="cbe2" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">显示问题</h1><p id="523c" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们将从处理问题所需的数据模型开始。这将是一个新的类型命名为<strong class="ig hi">问题</strong>。你可以在下面看到一个简化的定义。每个问题都有一个id、一个正文和创建时间。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="9bd7" class="mj kj hh mf b fi mk ml l mm mn">type <strong class="mf hi">Question</strong> {<br/>  id: ID!<br/>  body: String!<br/>  createdAt: DateTime!<br/>}</span></pre><p id="2789" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了处理问题列表，我们创建了<strong class="ig hi">问题列表</strong>和<strong class="ig hi">问题</strong>组件。请参见下面简化的伪html版本:</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="758e" class="mj kj hh mf b fi mk ml l mm mn">// src/components/QuestionList.js<br/>&lt;QuestionList <strong class="mf hi">questions</strong>={questionList}&gt;<br/>  &lt;ul&gt;<br/>    &lt;Question <strong class="mf hi">key={question.id}</strong> question={question}&gt;<br/>      &lt;li&gt;{<strong class="mf hi">question.body</strong>}&lt;/li&gt;<br/>    &lt;/Question&gt;<br/>    ...<br/>  &lt;/ul&gt;<br/>&lt;/QuestionList&gt;</span></pre><p id="b4be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的代码片段中，我们定义了一个查询来获取所有可用的问题。<strong class="ig hi">问题片段</strong>将允许我们在其他查询和/或变体中引用相同的问题字段。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="f158" class="mj kj hh mf b fi mk ml l mm mn">query questions {<br/>  allQuestions { <br/>    ...<strong class="mf hi">question</strong><br/>  }<br/>}</span><span id="fa24" class="mj kj hh mf b fi ny ml l mm mn">fragment <strong class="mf hi">question</strong> on Question {<br/>  id <br/>  body <br/>  createdAt  <br/>}</span></pre><h1 id="5534" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">投票</h1><p id="b519" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">在活动期间从观众那里获得问题是关键，但对于大型活动来说，可能会有一些时间限制，因此获得关于哪些问题最受欢迎的反馈可能是有用的。我们可以通过允许与会者投票来实现这一点。</p><p id="0d9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要用另一种类型的投票来扩展我们的模型。每一票都将与一个问题相关联。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="a113" class="mj kj hh mf b fi mk ml l mm mn">type <strong class="mf hi">Vote</strong> {<br/>  id: ID!<br/>  createdAt: DateTime!<br/>  <strong class="mf hi">question: Question</strong><br/>}</span></pre><p id="89c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看投票突变是什么样子的:</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="1c54" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/Vote.mutation.gql<br/>mutation createVote($question: ID!) {<br/>  createVote(questionId: $question) { <br/>    id <br/>  }<br/>}</span></pre><p id="55f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种变异将使用问题id创建一个新条目。让我们看看如何将这种变化融入到我们的应用中。我们将扩展<strong class="ig hi">问题</strong>组件，用一个新的突变来呈现一个问题</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="3821" class="mj kj hh mf b fi mk ml l mm mn">// src/components/Question.js<br/>const withVote = graphql(CREATE_VOTE_MUTATION,<br/>  {<br/>    props: ({ ownProps, mutate }) =&gt; ({<br/>      <strong class="mf hi">vote(id) {<br/>        return mutate({<br/>          variables: { question: id },<br/>        })<br/>      },</strong><br/>    }),<br/>  },<br/>)</span><span id="82ec" class="mj kj hh mf b fi ny ml l mm mn">export default withVote(Question)</span></pre><p id="9083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将扩展props对象以包含一个<code class="du mo mp mq mf b">vote(id)</code>函数，该函数调用mutate并通过在variables属性内传递问题id来传递问题id。</p><p id="da02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi">问题</strong>组件中，当用户点击该问题的投票按钮时，我们将触发这种变异。注意我们是如何使用<strong class="ig hi">乐观UI </strong>的，通过改变状态来立即应用改变。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="7307" class="mj kj hh mf b fi mk ml l mm mn">// src/components/Question.js<br/>class <strong class="mf hi">Question</strong> extends React.Component {<br/>  onSubmit() {<br/>    this.setState({ votes: this.state.votes+1 })<br/>    <strong class="mf hi">this.props.vote(this.props.question.id)</strong><br/>  }<br/>  // &lt;button onClick={e =&gt; this.onSubmit()}&gt;&lt;/button&gt;<br/>}</span></pre><h2 id="0d10" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">跟踪投票信息</h2><p id="ee08" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">到目前为止，我们介绍了如何为一个问题添加新的投票，但我们没有介绍如何为所有问题保持所有这些数据的更新。</p><p id="05fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了做到这一点，我们将使用Graphcool的一个名为<strong class="ig hi"> Aggregations </strong>的优秀特性。这个特性允许我们保持每个问题的当前投票数，而不需要做任何额外的编码！对于每种类型，Graphcool都创建了一个额外的类型，我们可以使用它来访问这些数据，在我们的例子中，这就是<code class="du mo mp mq mf b">_votesMeta</code>。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="6c2c" class="mj kj hh mf b fi mk ml l mm mn">query questions {<br/>  allQuestions { <br/>    ...<strong class="mf hi">question</strong><br/>  }<br/>}</span><span id="213d" class="mj kj hh mf b fi ny ml l mm mn">fragment <strong class="mf hi">question</strong> on Question {<br/>  id <br/>  body <br/>  createdAt  <br/>  <strong class="mf hi">_votesMeta { count }</strong><br/>}</span></pre><p id="927d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们看一下问题片段，可以看到一些新的字段<code class="du mo mp mq mf b">_votesMeta</code><strong class="ig hi"/><strong class="ig hi"/><code class="du mo mp mq mf b">count</code>。这将允许我们收集关于特定问题有多少投票的信息。</p><h2 id="2c85" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">问题投票</h2><p id="cd1b" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们讲述了如何跟踪新的投票，以及如何检索当前的投票数。但是我们没有介绍如何在我们的UI中获得新的更新。</p><p id="b245" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了显示投票信息，我们将设置一个轮询，以便按照固定的时间表获取这些信息。这是一种避免过度提取的折衷方法。实时同步投票会给大型活动带来不必要的流量。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="45a1" class="mj kj hh mf b fi mk ml l mm mn">// src/components/QuestionList.js<br/>const withQuestions = graphql(QUESTIONS_QUERY,<br/>  {<br/>    <strong class="mf hi">options: { pollInterval: POLLING_TIME },</strong><br/>    props: ({ data }) =&gt; {<br/>      return {<br/>        questions: data.allQuestions,<br/>      }<br/>    },<br/>  },<br/>)</span><span id="b2fb" class="mj kj hh mf b fi ny ml l mm mn">export default withQuestions(QuestionList)</span></pre><p id="2b39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过使用轮询，我们可以确保所有用户每隔几秒钟就可以获得最新的聚合信息。由于这些信息可能不完全准确，我们将投票总数替换为类似体积的显示。条形越多，问题的票数就越多，遵循指数函数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es oe"><img src="../Images/e60603d73eddd25913cdcfce48d3fafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B90voh9cn38BzcxfyYOGaw.png"/></div></div></figure><h1 id="f00a" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用Auth0验证用户</h1><h2 id="9ead" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">Auth0设置</h2><p id="c78a" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated"><strong class="ig hi">在<a class="ae js" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0网站</a>注册</strong>并创建新的<strong class="ig hi"> SPA客户端</strong>。我们将使用这个SPA客户端从React应用程序访问Auth0服务。</p><p id="c0c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以关注这个<a class="ae js" href="https://auth0.com/docs/quickstart/spa/react/00-getting-started" rel="noopener ugc nofollow" target="_blank">博客</a>了解更多关于如何设置一个Auth0账户以及如何获得<code class="du mo mp mq mf b">CLIENT_ID</code>和<code class="du mo mp mq mf b">DOMAIN</code>的细节。</p><p id="f11f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了处理用户登录和会话管理，我们创建了<strong class="ig hi">授权</strong>服务。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="fb81" class="mj kj hh mf b fi mk ml l mm mn">// src/services/Authorisation.js<br/>export default class Authorisation {<br/>  constructor() {<br/>    this.lock = new Auth0Lock(<strong class="mf hi">CLIENT_ID</strong>, <strong class="mf hi">DOMAIN</strong>, {<br/>      auth: {<br/>        responseType: 'id_token',<br/>        params: { scope: 'openid email' },<br/>        <strong class="mf hi">redirect: false,</strong><br/>      },<br/>    })<br/>    this.lock.on('authenticated', this.doAuthentication.bind(this))<br/>  }</span><span id="3a0e" class="mj kj hh mf b fi ny ml l mm mn">  authenticate() {<br/>    this.lock.show()<br/>  }<br/>}</span></pre><p id="bdec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的代码来看，我们使用<code class="du mo mp mq mf b">Auth0Lock</code>来提供一个很好的用户界面，让用户完成登录的所有步骤。这是使用没有重定向的覆盖弹出窗口的设置。在设置了<code class="du mo mp mq mf b">Auth0Lock</code>实例之后，我们为<code class="du mo mp mq mf b">authenticated</code>事件注册了一个回调。为了显示这个锁定弹出窗口，我们创建了一个单独的<code class="du mo mp mq mf b">authenticate</code>方法。</p><p id="3e51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看一旦用户登录并且触发了<code class="du mo mp mq mf b">authenticated</code>事件会发生什么。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="14e8" class="mj kj hh mf b fi mk ml l mm mn">// src/services/Authorisation.js<br/>doAuthentication(authResult) {<br/>  if (!this.profile) {<br/>    <strong class="mf hi">this.auth0IdToken = authResult.idToken</strong><br/>    <strong class="mf hi">this.lock.getProfile</strong>(authResult.idToken, (error, profile) =&gt; {<br/>      if (error) {<br/>        this.auth0IdToken = null<br/>        this.profile = null<br/>      } else {<br/>        <strong class="mf hi">this.profile = profile</strong><br/>      }<br/>    })<br/>  }<br/>}</span></pre><p id="f3cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们做的第一件事是将<code class="du mo mp mq mf b">auth0IdToken</code>存储在<strong class="ig hi">本地存储</strong>中，为了方便起见，它被包装在一个getter和setter中</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="7e5d" class="mj kj hh mf b fi mk ml l mm mn">// src/services/Authorisation.js<br/><strong class="mf hi">get auth0IdToken()</strong> {<br/>  return localStorage.getItem('auth0IdToken')<br/>}<br/><strong class="mf hi">set auth0IdToken(value)</strong> {<br/>  if (value) {<br/>    localStorage.setItem('auth0IdToken', value)<br/>  } else {<br/>    localStorage.removeItem('auth0IdToken')<br/>  }<br/>}</span></pre><p id="efd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们将尝试使用此令牌访问用户配置文件。这是一个异步操作，因此我们传递一个回调，并使用相同的方法将其存储在localStorage中。如果有任何错误，我们只是清除用户信息。</p><h2 id="8c5f" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">与React集成</h2><p id="b3fe" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">为了将其与我们的应用程序集成，我们将使用一个<em class="mu">高阶组件</em>，它将沿着组件树向下传递<code class="du mo mp mq mf b">Authorisation</code>类实例引用。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="8ec8" class="mj kj hh mf b fi mk ml l mm mn">// src/app.js<br/>const auth = <strong class="mf hi">new Authorisation()</strong></span><span id="f3cc" class="mj kj hh mf b fi ny ml l mm mn">class HandsUpAppWrapper extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;HandsUpApp <strong class="mf hi">auth={auth}</strong> {...this.props} /&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="6bf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当与我们的<strong class="ig hi"> GraphQL服务器</strong>通信时，我们可以使用<code class="du mo mp mq mf b">auth0IdToken</code>进行授权。为了整合两者，我们可以使用一个中间件来添加所需的头。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="3b0c" class="mj kj hh mf b fi mk ml l mm mn">// src/client.js<br/>networkInterface.use([{ <br/>  applyMiddleware(req, next) {<br/>    if (localStorage.getItem('auth0IdToken')) {<br/>      if (!req.options.headers) {<br/>        req.options.headers = {}<br/>      }<br/>      req.options.headers.authorization =<br/>        `Bearer <strong class="mf hi">${localStorage.getItem('auth0IdToken')}</strong>`<br/>    }<br/>    next()<br/>  },<br/>}])</span></pre><p id="71d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦有了这个设置，我们就可以配置特定的查询，只允许授权用户执行它们。</p><h2 id="0dbc" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated"><strong class="ak"> Graphcool用户集成</strong></h2><p id="0a22" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">为了使用我们模型中的用户信息，我们需要通过使用Graphcool提供的<code class="du mo mp mq mf b">createUser</code>变异来注册新用户。最重要的字段是Auth0提供的idToken。剩下的字段将允许我们显示用户个人资料图片和用户名。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="8fca" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/CreateUser.mutation.gql<br/>mutation createUser(<br/><strong class="mf hi">  $idToken: String!, </strong><br/>  $name: String!,<br/>  $username: String!,<br/>  $pictureUrl: String!<br/>){<br/>  createUser(<br/>    authProvider: {<br/><strong class="mf hi">      auth0: {<br/>        idToken: $idToken<br/>      }</strong><br/>    }, <br/>    name: $name,<br/>    username: $username,<br/>    pictureUrl: $pictureUrl<br/>  ) {<br/>    <strong class="mf hi">id</strong><br/>  }<br/>}</span></pre><p id="3292" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意底部的<code class="du mo mp mq mf b">id</code>字段。见下图<strong class="ig hi">用户</strong>类型的简化版本。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="74f1" class="mj kj hh mf b fi mk ml l mm mn">type User {<br/>  id: ID!                   # graphcool internal id<br/>  auth0UserId: String       # auth0 idToken<br/>  name: String<br/>  username: String<br/>  pictureUrl: String<br/>  createdAt: DateTime!<br/>  questions: [Question!]!<br/>}</span></pre><p id="4c40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用它来更改问题突变，以便包括登录的用户。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="0eed" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/CreateQuestion.mutation.gql<br/>#import "./Question.fragment.gql"</span><span id="5b56" class="mj kj hh mf b fi ny ml l mm mn">mutation addQuestion($body: String!, <strong class="mf hi">$user: ID!</strong>) {<br/>  createQuestion(body: $body, <strong class="mf hi">userId: $user</strong>) { <br/>    ...question<br/>  }<br/>}</span></pre><h2 id="5d8b" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">问题。显示用户数据</h2><p id="26a4" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">因为我们在查询和变异中使用相同的问题片段，所以我们可以简单地扩展它来获取新的字段</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="578e" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/Question.fragment.gql<br/>fragment question on Question {<br/>  <strong class="mf hi">user { id username pictureUrl } </strong><br/>}</span></pre><h2 id="e513" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">显示登录的用户</h2><p id="bea5" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">一旦我们从Auth0获得了用户信息，我们就可以使用<strong class="ig hi">授权</strong>服务向我们的组件提供这些信息。</p><p id="4fdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了显示登录的用户，我们将创建一个<strong class="ig hi"> Profile </strong>组件，并将其放在我们的<strong class="ig hi"> TopNavigation </strong>组件中。这将是一个纯粹的依赖于<code class="du mo mp mq mf b">profile</code>和<code class="du mo mp mq mf b">isLogged</code>道具的组件。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="7876" class="mj kj hh mf b fi mk ml l mm mn">// src/components/TopNavigation.js<br/>&lt;Profile <br/>  profile={this.props.auth.profile}<br/>  isLogged={this.props.isLogged}<br/>/&gt;</span></pre><p id="c857" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该组件导致一个简单的实现。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="6b1e" class="mj kj hh mf b fi mk ml l mm mn">// src/components/Profile.js<br/>class Profile extends React.Component {</span><span id="7421" class="mj kj hh mf b fi ny ml l mm mn">  render() {<br/>    if (!this.props.isLogged) {<br/>      return null<br/>    }</span><span id="0931" class="mj kj hh mf b fi ny ml l mm mn">    return (<br/>      &lt;div className='profile'&gt;<br/>        &lt;img src={this.props.profile.picture} /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><h1 id="fda8" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">添加新问题</h1><p id="19eb" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">到目前为止，我们已经介绍了匿名用户的所有特性。任何有权访问我们的应用程序的人都可以按照问题列表进行投票。让我们为与会者添加添加新问题的选项。</p><p id="cd32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参见下面的变异查询来创建一个新问题。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="7ccd" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/CreateQuestion.mutation.gql<br/>#import "./Question.fragment.gql"</span><span id="1872" class="mj kj hh mf b fi ny ml l mm mn">mutation addQuestion($body: String!, $user: ID!) {<br/>  createQuestion(body: $body, userId: $user) { <br/>    ...<strong class="mf hi">question</strong><br/>  }<br/>}</span></pre><p id="5ecc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用登录用户创建一个问题，并将其链接到系统中的注册用户。</p><p id="d92b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何将这个突变查询集成到<strong class="ig hi"> AddQuestion </strong>组件中</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="faa2" class="mj kj hh mf b fi mk ml l mm mn">// src/components/AddQuestion.js<br/>class AddQuestion extends React.Component {</span><span id="0ae4" class="mj kj hh mf b fi ny ml l mm mn">  <strong class="mf hi">onSubmit</strong>(event) {<br/>    event.preventDefault()<br/>    this.props<br/>      .<strong class="mf hi">addQuestion</strong>(this.input.value, this.props.auth.userId)<br/>  }</span><span id="7543" class="mj kj hh mf b fi ny ml l mm mn">  render() {<br/>    return (<br/>      &lt;form <strong class="mf hi">onSubmit={e =&gt; this.onSubmit(e)}</strong>&gt;<br/>        &lt;input ref={node =&gt; (this.input = node)} /&gt;<br/>        &lt;button <strong class="mf hi">type='submit'</strong>&gt;Send&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    )<br/>  }<br/>}</span><span id="d394" class="mj kj hh mf b fi ny ml l mm mn"><strong class="mf hi">const withAddQuestion = graphql(CREATE_QUESTION_MUTATION, {...})</strong></span><span id="34bf" class="mj kj hh mf b fi ny ml l mm mn">export default <strong class="mf hi">withAddQuestion</strong>(AddQuestion)</span></pre><p id="d5ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码中，我们可以看到如何将<code class="du mo mp mq mf b">onSubmit</code>表单事件链接到传递输入值和当前登录用户的<code class="du mo mp mq mf b">addQuestion</code>。</p><blockquote class="mr ms mt"><p id="c55a" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">注意我们是如何通过使用<a class="ae js" href="https://facebook.github.io/react/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> ref属性</strong> </a> <strong class="ig hi"> </strong>回调来访问底层输入元素的。</p></blockquote><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="706e" class="mj kj hh mf b fi mk ml l mm mn">// src/components/AddQuestion.js<br/>const withAddQuestion = graphql(CREATE_QUESTION_MUTATION,<br/>  {<br/>    props: ({ mutate }) =&gt; ({<br/>      <strong class="mf hi">addQuestion(body, id)</strong> {<br/>        return mutate({<br/>          <strong class="mf hi">variables: { body: body, user: id },</strong><br/>          updateQueries: {<br/>            questions: (state, { mutationResult }) =&gt; {<br/>              let newQuestion = <strong class="mf hi">mutationResult.data.createQuestion</strong><br/>              return update(state, <strong class="mf hi">{<br/>                allQuestions: {<br/>                  $push: [newQuestion],<br/>                 },<br/>              }</strong>)<br/>            },<br/>          },<br/>        })<br/>      },<br/>    }),<br/>  },<br/>)</span></pre><p id="bce4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个实例中，我们将<code class="du mo mp mq mf b">addQuestion</code>函数作为一个新属性(prop)添加到我们的组件中。我们将调用<code class="du mo mp mq mf b">mutate</code>，将问题主体和用户id作为<code class="du mo mp mq mf b">variables</code>传递。<strong class="ig hi"> </strong>当突变返回结果时<code class="du mo mp mq mf b">updateQueries</code>将执行。然后我们可以通过使用<code class="du mo mp mq mf b">mutationResult</code> <strong class="ig hi"> </strong>来访问结果，并返回新的状态。</p><p id="2821" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了避免增加副作用，我们使用了<code class="du mo mp mq mf b">immutability-helper</code>库。你可以在这里了解它的语法<a class="ae js" href="https://facebook.github.io/react/docs/update.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="78a2" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">设置订阅</h1><p id="22c9" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">为了访问实时特性，我们需要为Apollo客户端添加订阅支持。请确保运行此命令</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="d473" class="mj kj hh mf b fi mk ml l mm mn">npm install — save subscriptions-transport-ws</span></pre><h2 id="c724" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">Apollo客户端订阅设置(client.js)</h2><p id="5d46" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们还需要一个来自Graphcool的独立端点来访问服务器上的订阅。</p><blockquote class="mr ms mt"><p id="78d0" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">为了获得您的<strong class="ig hi">订阅</strong> <strong class="ig hi">密钥</strong>，您可以使用<strong class="ig hi"> Graphcool CLI </strong>运行<code class="du mo mp mq mf b"><em class="hh">graphcool endpoints</em></code>。</p></blockquote><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="e7ca" class="mj kj hh mf b fi mk ml l mm mn">// src/client.js<br/>import { SubscriptionClient, addGraphQLSubscriptions } from 'subscriptions-transport-ws'</span><span id="8260" class="mj kj hh mf b fi ny ml l mm mn">const <strong class="mf hi">wsClient</strong> = new SubscriptionClient('<strong class="mf hi">wss://subscriptions.graph.cool/v1/YOUR_KEY_HERE</strong>', {<br/>  reconnect: true,<br/>})</span><span id="42cf" class="mj kj hh mf b fi ny ml l mm mn">const networkInterfaceWithSubscriptions = addGraphQLSubscriptions(<br/>  networkInterface,<br/>  <strong class="mf hi">wsClient</strong><br/>)</span><span id="b76b" class="mj kj hh mf b fi ny ml l mm mn">export const client = new ApolloClient({<br/>  networkInterface: networkInterfaceWithSubscriptions,<br/>})</span></pre><p id="8e3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码中，我们使用您的端点设置了<code class="du mo mp mq mf b">SubscriptionClient</code>。我们激活了<code class="du mo mp mq mf b">reconnect</code>标志，因此客户端将从传输故障中正常恢复。最后，我们扩展了当前的网络接口，以包括订阅客户端。</p><h2 id="ae13" class="mj kj hh bd kk nl nz nn ko no oa nq ks ip ob ns kw it oc nu la ix od nw le nx bi translated">订阅新问题</h2><p id="ebf8" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们的应用程序的一个关键特性是所有与会者实时共享新问题，因此每个人都可以了解它们并投票。</p><p id="00db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来看看我们的订阅查询:</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="7501" class="mj kj hh mf b fi mk ml l mm mn">// src/graphql/Questions.subscription.gql<br/>#import "./Question.fragment.gql"</span><span id="e3d1" class="mj kj hh mf b fi ny ml l mm mn">subscription {<br/>  <strong class="mf hi">Question</strong>(filter: { mutation_in: [<strong class="mf hi">CREATED</strong>] }) {<br/>    node {<br/>      <strong class="mf hi">...question</strong><br/>    }<br/>  }<br/>}</span></pre><p id="a4ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">订阅的语法需要一个<strong class="ig hi">类型</strong>和一个我们感兴趣的<strong class="ig hi">操作列表</strong>:创建、更新或删除。在上面的代码中，我们订阅了新的<strong class="ig hi">问题</strong>。因此，对于每个新问题，我们将收到一条消息(节点),其中包含问题片段中定义的所有字段。</p><p id="4062" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何将这个订阅与显示问题列表的<strong class="ig hi"> QuestionsList </strong>组件集成在一起。</p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="45ae" class="mj kj hh mf b fi mk ml l mm mn">// src/components/QuestionList.js<br/>class QuestionList extends React.Component {</span><span id="2b16" class="mj kj hh mf b fi ny ml l mm mn">  componentWillMount() {<br/>    <strong class="mf hi">this.props.subscribeToNewQuestions()</strong><br/>  }</span><span id="8c4b" class="mj kj hh mf b fi ny ml l mm mn">  render() {...}<br/>}<br/>const withQuestions = graphql(QUESTIONS_QUERY, {...})<br/><strong class="mf hi">const withSubscription = graphql(QUESTIONS_QUERY, {...})</strong></span><span id="d1de" class="mj kj hh mf b fi ny ml l mm mn">export default <strong class="mf hi">withSubscription(</strong>withQuestions(QuestionList)<strong class="mf hi">)</strong></span></pre><p id="d64e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用与之前相同的模式扩展了<strong class="ig hi"> QuestionList </strong>组件，增加了新的订阅。注意我们是如何使用<code class="du mo mp mq mf b">componentWillMount</code>来触发订阅的。参见<strong class="ig hi">下面<code class="du mo mp mq mf b">subscribeToNewQuestions</code> <strong class="ig hi"> </strong>的代码。</strong></p><pre class="jd je jf jg fd me mf mg mh aw mi bi"><span id="c3a4" class="mj kj hh mf b fi mk ml l mm mn">// src/components/QuestionList.js<br/>const <strong class="mf hi">withSubscription</strong> = graphql(QUESTIONS_QUERY,<br/>  {<br/>    props: ({ data: { subscribeToMore } }) =&gt; ({<br/>      <strong class="mf hi">subscribeToNewQuestions</strong>() {<br/>        return subscribeToMore({<br/>          document: QUESTIONS_SUBSCRIPTION,<br/>          updateQuery: (state, { subscriptionData }) =&gt; {<br/>            const newQuestion = <strong class="mf hi">subscriptionData.data.Question.node</strong><br/>            if (!isDuplicate(newQuestion.id, state.allQuestions)) {<br/>              return update(state, <strong class="mf hi">{<br/>                allQuestions: {<br/>                  $push: [newQuestion],<br/>                },<br/>              }</strong>)<br/>            }<br/>          },<br/>        })<br/>      },<br/>    }),<br/>  },<br/>)</span></pre><p id="e8db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在用<code class="du mo mp mq mf b">subscribeToMore</code> <strong class="ig hi"> </strong>来定义我们的<code class="du mo mp mq mf b">updateQuery</code>。这将在我们每次从订阅查询<code class="du mo mp mq mf b">QUESTIONS_SUBSCRIPTION</code>收到消息时执行。</p><p id="c511" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用<code class="du mo mp mq mf b">subscriptionData</code>属性获得新的问题数据。<code class="du mo mp mq mf b">updateQuery</code>的输出应该是包含新问题的新状态。</p><p id="d599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了避免增加副作用，我们使用了<code class="du mo mp mq mf b">immutability-helper</code>库。你可以在这里了解它的语法<a class="ae js" href="https://facebook.github.io/react/docs/update.html" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="mr ms mt"><p id="d680" class="ie if mu ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">因为我们使用了乐观用户界面，所以我们需要检查重复项，以避免用户添加问题时出现重复条目。</p></blockquote><p id="3c4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在<a class="ae js" href="https://github.com/gsans/handsup-react" rel="noopener ugc nofollow" target="_blank"> GitHub </a>访问最终解决方案。</p><p id="0dd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那都是乡亲们！有什么问题吗？感谢阅读！在<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank">@ gerardsans</a>ping我</p><div class="ll lm ez fb ln lo"><a href="https://www.meetup.com/GraphQL-London" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hi fi z dy lt ea eb lu ed ef hg bi translated">GraphQL伦敦社区</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">欢迎来到我们的社区。我们的热情是GraphQL。加入我们吧！🚀</h3></div></div><div class="lx l"><div class="of l lz ma mb lx mc jm lo"/></div></div></a></div><h1 id="bf96" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">进一步阅读</h1><ul class=""><li id="be2e" class="jt ju hh ig b ih lg il lh ip og it oh ix oi jb jy jz ka kb bi translated">Graphcool。<a class="ae js" href="https://www.graph.cool/docs/tutorials/quickstart-1-thaeghi8ro" rel="noopener ugc nofollow" target="_blank">在5分钟内建立一个GraphQL后端</a></li><li id="c0b9" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">Auth0。【React和Apollo的Auth0用户认证</li><li id="0480" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">Auth0。<a class="ae js" href="https://auth0.com/docs/quickstart/spa/react/00-getting-started" rel="noopener ugc nofollow" target="_blank"> Auth0 — React入门</a></li><li id="6885" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">Auth0。<a class="ae js" href="https://auth0.com/docs/connections/social/google" rel="noopener ugc nofollow" target="_blank">将您的应用程序连接到谷歌</a></li><li id="1025" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">Auth0。<a class="ae js" href="https://auth0.com/docs/connections/social/twitter" rel="noopener ugc nofollow" target="_blank">将你的应用程序连接到Twitter </a></li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><a href="https://twitter.com/intent/user?screen_name=gerardsans"><div class="er es md"><img src="../Images/abefda0aa7864742686ec7f7fdffe2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1tQhWBuVOdzR7OAGvyd8Q.png"/></div></a></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es oj"><img src="../Images/ef1b14f76f03946cded8575743defacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlOAY--DgRyOZD6AyK87uw.jpeg"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/67b37e5d672384f0953563450fca0029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uNeEFxYiwJq8RfiDCsI-Xg.gif"/></div></div></figure></div></div>    
</body>
</html>