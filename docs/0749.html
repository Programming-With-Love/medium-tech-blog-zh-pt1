<html>
<head>
<title>Monitoring App Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控应用性能</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/monitoring-app-performance-ebf9af4ebe36?source=collection_archive---------0-----------------------#2022-08-29">https://medium.com/androiddevelopers/monitoring-app-performance-ebf9af4ebe36?source=collection_archive---------0-----------------------#2022-08-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ab11b9758619c2739fff6ab18a23ca8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GW7g7T1qx_Adm2D-"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration by Claudia Sanchez</figcaption></figure><p id="7c2d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这篇关于监控性能的MAD技能文章中，我将指导您了解最佳实践，并提供关于可用于监控应用程序性能的工具的指导。</p><blockquote class="jr"><p id="dfb7" class="js jt hh bd ju jv jw jx jy jz ka jq dx translated">监控绩效可以验证绩效是否朝着正确的方向发展。</p></blockquote><p id="d898" class="pw-post-body-paragraph it iu hh iv b iw kb iy iz ja kc jc jd je kd jg jh ji ke jk jl jm kf jo jp jq ha bi translated">应用性能既可以在应用发布前<em class="kg">在实验室环境中监控</em>，也可以在用户安装了<em class="kg">并积极使用应用</em>时在现场监控。</p><p id="b8cb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这篇文章的内容也可以在YouTube上找到</p><figure class="kh ki kj kk fd ii"><div class="bz dy l di"><div class="kl km l"/></div></figure><h1 id="8cb2" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">实验室监控</h1><p id="3fed" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">这里收集的性能数据是非常宝贵的，因为你可以了解一个应用在击中用户之前是如何执行<em class="kg">的。这有助于您限制可能的业务影响和对用户的总体影响。实验室收集的数据可用作<strong class="iv hi">通过/不通过</strong>信号。如果性能指标在两个版本之间恶化，您可以使用这些作为理由来推迟一个版本或者阻止发布一个特性。</em></p><h2 id="c547" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">连续累计</h2><p id="905e" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">由于持续集成(CI)，您还可以有更快的周转时间。有各种CI服务器和服务可用，我不会在这里进行比较。</p><p id="74b4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过使用CI管道，您可以在每次提交到达发布分支时启动基准测试套件，或者甚至在它合并到您的主分支之前。通过这种方式，您可以比较不同版本之间的性能，并在指标超过您决定的阈值时发出红色警报。</p><p id="7591" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">确保在真实设备上运行基准测试。您可以使用在物理设备上提供测试的提供商，如<a class="ae me" href="https://firebase.google.com/products/test-lab" rel="noopener ugc nofollow" target="_blank"> Firebase测试实验室</a>，而不是维护您自己的本地设备池进行测试。</p><p id="d4f5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Firebase Test Lab保持设备连接和最新，因此您不必投资本地测试设备设置。您可以使用脚本接口在每次构建时运行基准测试，并持续查看结果。</p><h2 id="e1f2" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">阶梯拟合</h2><p id="b651" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">无论您是选择在本地设备上运行基准测试还是通过云提供商运行基准测试，发现回归有时都很棘手。为了自动化报告，您必须为您认为重要的每个指标设置阈值，然后将其与之前运行的基准进行比较。<strong class="iv hi">你会看到性能波动</strong>。有些构建可能完成得更快，有些可能完成得更慢。要发现基准测试运行时间的增加是否是代码的回归，需要比较两个以上的版本。</p><p id="b0a3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们的公共AndroidX持续集成管道中，我们过去曾面临过这个问题，并提出了一个可行的解决方案。</p><p id="2a76" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们不是将一个构建与之前的进行比较，而是累积一定数量的构建，并在代码库发生变化之前和之后进行比较。</p><p id="f748" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然这可能需要少量的构建来发现回归，但是这种方法非常可靠，伸缩性也很好，即使涉及到数百个库和工程师。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/11e0550336e217c3ad75388600676e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ACwPFx9kTl6aWvnf"/></div></div></figure><p id="da79" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在Chris Craik关于用基准测试对抗回归的文章中，他准确地描述了step fitting如何在我们的代码库中工作，以及如何将它集成到您的持续集成管道中。</p><p id="2d39" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">简短的版本是:</p><ul class=""><li id="d302" class="mg mh hh iv b iw ix ja jb je mi ji mj jm mk jq ml mm mn mo bi translated">编写宏基准测试</li><li id="4385" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">在真实设备上运行它们</li><li id="a00b" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">收集和存储输出指标</li><li id="8b4c" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">运行步长拟合算法</li></ul><p id="bb21" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以在这篇文章中读到关于阶梯拟合的所有细节</p><div class="mu mv ez fb mw mx"><a rel="noopener follow" target="_blank" href="/androiddevelopers/fighting-regressions-with-benchmarks-in-ci-6ea9a14b5c71"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hi fi z dy nc ea eb nd ed ef hg bi translated">用CI中的基准来对抗衰退</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">了解如何使用Jetpack Benchmark来捕捉Android应用程序中的性能衰退，以免其继续发展…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl in mx"/></div></div></a></div><h1 id="2ab3" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">现场监测</h1><p id="6abe" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">一旦用户开始使用应用，您就可以通过生产中的现场监控来监控应用的性能。</p><h2 id="8918" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">Android生命体征</h2><p id="f313" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">监控生产指标最简单的方法是查看Android生命指标提供的数据。Android Vitals提供了您已安装用户群的匿名和聚合数据，以及同行基准，因此您可以将您的应用与其他应用进行比较。要使用Android Vitals，你不需要对你的应用程序代码做任何修改。只需将它上传到谷歌Play商店，剩下的我们会处理。</p><p id="f7cc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Android Vitals为您提供以下指标</p><ul class=""><li id="50f5" class="mg mh hh iv b iw ix ja jb je mi ji mj jm mk jq ml mm mn mo bi translated">应用启动时间</li><li id="1bf4" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">慢速和冻结帧</li><li id="83da" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">无响应的活动</li><li id="9b52" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">猛撞</li><li id="1e58" class="mg mh hh iv b iw mp ja mq je mr ji ms jm mt jq ml mm mn mo bi translated">更多</li></ul><p id="7313" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以比较你的应用在不同设备类别中的表现，如Android操作系统版本、可用内存、CPU速度等。</p><blockquote class="jr"><p id="715e" class="js jt hh bd ju jv jw jx jy jz ka jq dx translated">定期检查Android Vitals提供的数据，看看哪些地方可以改进，这很有价值。</p></blockquote><h2 id="2f26" class="lq ko hh bd kp lr nm lt kt lu nn lw kx je no ly lb ji np ma lf jm nq mc lj md bi translated">Firebase性能监控</h2><p id="6f2e" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">如果你想了解更多的细节，<a class="ae me" href="https://firebase.google.com/docs/perf-mon" rel="noopener ugc nofollow" target="_blank"> Firebase性能监控</a>已经为你报道。</p><p id="5986" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过将gradle插件添加到您的应用程序中，您可以看到有关冷启动时间、缓慢和抖动帧的大致来源以及网络请求持续时间的信息。所有这些数据都被报告到<a class="ae me" href="https://console.firebase.google.com/?hl=de" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>中。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="e0e3" class="lq ko hh ns b fi nw nx l ny nz">plugins {<br/>  id(...)<br/>  id("com.google.firebase.firebase-perf") version "$version"<br/>}</span></pre><p id="f181" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用Firebase性能监控，您甚至可以获得更具体的数据。首先添加库依赖项。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="3bb0" class="lq ko hh ns b fi nw nx l ny nz">dependencies {<br/>  implementation("com.google.firebase:firebase-perf")<br/>}</span></pre><p id="069a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后，您可以为您的应用程序中的任何代码添加您自己的<strong class="iv hi">跟踪点。这里我们跟踪数据何时被加载。</strong></p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="3887" class="lq ko hh ns b fi nw nx l ny nz">Firebase.performance.newTrace(LOAD_DATA).trace {<br/>  loadRemote()<br/>  loadFromCache()<br/>}</span></pre><p id="97d5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过使用Kotlin扩展跟踪函数，可以包装加载数据的调用点。这是跨越多个方法调用的快速方法。</p><p id="62dd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">或者，您可以在方法上使用<code class="du oa ob oc ns b">AddTrace</code>注释。这为您提供了一种方法，可以在每次调用一个方法时跟踪它，然后将其报告给Firebase控制台。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="68da" class="lq ko hh ns b fi nw nx l ny nz">@AddTrace(name = "loadRemote", enabled = true)<br/>private fun loadRemote() { ... }</span></pre><blockquote class="jr"><p id="6a0a" class="js jt hh bd ju jv od oe of og oh jq dx translated">我们正在不断扩展与性能相关的Jetpack库套件。</p></blockquote><h2 id="b803" class="lq ko hh bd kp lr nm lt kt lu nn lw kx je no ly lb ji np ma lf jm nq mc lj md bi translated">JankStats</h2><p id="c048" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">我们已经发布了<a class="ae me" href="https://developer.android.com/topic/performance/jankstats" rel="noopener ugc nofollow" target="_blank"> JankStats库</a>,它能够收集janky帧以及元数据，例如用户如何到达必须丢弃帧的状态。将依赖项添加到应用程序的构建文件后，通过调用<code class="du oa ob oc ns b">createAndTrack</code>将<code class="du oa ob oc ns b">JankStats</code>安装到活动窗口中。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="e938" class="lq ko hh ns b fi nw nx l ny nz">override fun onCreate(savedInstanceState: Bundle?) {<br/>  super.onCreate(savedInstanceState)<br/>    JankStats.createAndTrack(window) { frameData -&gt;<br/>    if (frameData.isJank) {<br/>      logAndAddToReportingQueue()<br/>    }<br/>  }<br/>}</span></pre><p id="faf9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当一个帧被库启发式算法认为是恶作剧时，您可以记录它并将其添加到您的报告队列中。</p><p id="690e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">JankStats在一个<code class="du oa ob oc ns b">PerformanceMetricsState</code>对象中为你保留状态。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="8c94" class="lq ko hh ns b fi nw nx l ny nz">PerformanceMetricsState.getHolderForHierarchy(localView)</span></pre><p id="dd89" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这里，您可以添加和删除键值对中的状态。</p><pre class="kh ki kj kk fd nr ns nt nu aw nv bi"><span id="d1c0" class="lq ko hh ns b fi nw nx l ny nz">metricsHolder.state?.putState(<br/>  "Interests:TabState",<br/>  "${tabState.currentIndex}"<br/>)<br/>metricsHolder.state?.removeState(“Interests:TabState”)</span></pre><p id="75cf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这使您能够添加元数据，如导航目的地，这使您更容易再现用户最初是如何到达janky帧的。</p><p id="c8b5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要查看JankStats的更多实际用法，<strong class="iv hi">请查看Android中的</strong><a class="ae me" href="https://github.com/android/nowinandroid" rel="noopener ugc nofollow" target="_blank"><strong class="iv hi">Now</strong></a><strong class="iv hi">示例</strong>，其中我们在关键区域添加了jank跟踪代码，例如滚动作者列表或for you页面。</p><h1 id="04a2" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">这是所有的乡亲</h1><p id="12b2" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">我们关于性能的第二个MAD技能系列到此结束。我们已经向您展示了<a class="ae me" rel="noopener" href="/androiddevelopers/important-performance-metrics-c7dacf018eb3">重要的性能指标</a>以及如何<a class="ae me" rel="noopener" href="/androiddevelopers/inspecting-performance-95b76477a3d7">检查</a>、<a class="ae me" rel="noopener" href="/androiddevelopers/improving-performance-with-baseline-profiles-fdd0db0d8cc6">改进</a>以及围绕应用启动和流畅运行体验监控应用和库性能。</p><blockquote class="jr"><p id="98e7" class="js jt hh bd ju jv jw jx jy jz ka jq dx translated">如果你还没有，去为你的应用程序创建一个<a class="ae me" rel="noopener" href="/androiddevelopers/improving-performance-with-baseline-profiles-fdd0db0d8cc6">基线配置文件</a>。这是让你的应用运行更快更流畅的快捷方式。</p></blockquote><p id="afdb" class="pw-post-body-paragraph it iu hh iv b iw kb iy iz ja kc jc jd je kd jg jh ji ke jk jl jm kf jo jp jq ha bi translated">我们知道，在谈论性能时，还有更多的内容需要讨论。虽然我们没有时间涵盖本系列中的所有内容，但我们会继续向开发人员指南和示例中添加更多内容。</p><p id="5cb3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，确保在视频评论或Twitter上提出你的问题，使用<a class="ae me" href="https://twitter.com/search?q=%23MADPerfQA" rel="noopener ugc nofollow" target="_blank"> #MADPerfQA </a>在9月1日的问答环节中直接从致力于Android性能的工程师那里获得答案。</p><p id="eeaf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">查看我们之前关于性能调试的MAD技能系列，了解如何检查代码中发生的事情。</p><figure class="kh ki kj kk fd ii"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Performance Debugging</figcaption></figure><p id="fcce" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">去看看我们改进的开发者文档，我们已经用MAD指南更新了它。</p><p id="9bce" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要获得更详细的代码，请查看GitHub上的<a class="ae me" href="http://github.com/android/performance-samples" rel="noopener ugc nofollow" target="_blank">示例</a>。并参加<a class="ae me" href="https://goo.gle/baseline-profiles-codelab" rel="noopener ugc nofollow" target="_blank">宏观基准测试代码实验室</a>或<a class="ae me" href="https://goo.gle/baseline-profiles-codelab" rel="noopener ugc nofollow" target="_blank">基准配置文件代码实验室</a>的实践指导。</p></div></div>    
</body>
</html>