<html>
<head>
<title>A new Angular Service Worker — creating automatic progressive web apps. Part 2: practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个新的角度服务工作者——创建自动渐进式web应用程序。第2部分:实践</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-2-practice-3221471269a1?source=collection_archive---------0-----------------------#2017-11-04">https://medium.com/google-developer-experts/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-2-practice-3221471269a1?source=collection_archive---------0-----------------------#2017-11-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/519a75f522613345fa60a30cdc58351a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSADmhmxHcd4sr-TpZRZNw.png"/></div></div></figure><blockquote class="ip iq ir"><p id="5ab7" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">公告:<a class="ae jr" href="https://www.angularconnect.com/2017/sessions/#s-662" rel="noopener ugc nofollow" target="_blank">我将于11月7日星期二在伦敦AngularConnect会议上介绍Angular服务人员</a>。如果你想在现场视频流中跟随我，请在你的日历上标记:格林威治时间上午11:20(紧接主题演讲之后)，主舞台。</p></blockquote><p id="c725" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">距离<a class="ae jr" rel="noopener" href="/@webmaxru/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-1-theory-37d7d7647cc7">这篇文章的第一部分</a>发表还有一段时间，这种停顿是有意的——在最初出现之后，只有在几个候选版本发布之后，该功能才可以投入实际使用。现在Angular 5发布了，Angular Service Worker(以下简称NGSW)已经准备好接受探索了。</p><p id="b1c4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们将再次使用我们的<strong class="iv hi">p water</strong>——微型Twitter客户端。源代码在GitHub (分支<code class="du jv jw jx jy b">ngsw</code>)上可用<a class="ae jr" href="https://github.com/webmaxru/pwatter" rel="noopener ugc nofollow" target="_blank">。此外，我们需要一个简单的后端来提供tweet feed和处理推送通知。GitHub </a>上也有源代码和详细的设置说明<a class="ae jr" href="https://github.com/webmaxru/pwa-workshop-api" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ea0e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">因为这是一种实用的方法，所以让我们为PWA定义一些要求:</p><ul class=""><li id="6215" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">离线和在线模式下立即启动:我们需要一个<strong class="iv hi">应用程序外壳</strong>来实现这一点。</li><li id="b709" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">我们有一些<strong class="iv hi">外部文件</strong>(带有材质图标的网络字体)作为应用程序外壳的一部分。“外部”是指这些资源不是我们的<code class="du jv jw jx jy b">dist</code>文件夹的一部分。</li><li id="87ed" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">API调用的优化网络(<strong class="iv hi">运行时缓存</strong>):我们可以在离线期间提供一些早期访问的数据，也可以通过提供这些缓存数据而不是网络往返来加速在线模式。</li><li id="9e60" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated"><strong class="iv hi">推送通知</strong>:订阅通知并显示通知。客户端应用程序必须提供启动订阅流的功能，并将订阅对象传递到后端(我们总是将订阅存储在后端)。另外，我们的后端会在每次有人发关于“javascript”的推文时生成一条推送消息，所以Angular Service Worker应该会得到这个事件并显示一条消息。让我们也添加一些额外的功能。首先，让我们给用户取消订阅web推送通知的可能性。其次，让我们演示一下，除了将通知显示为通知弹出窗口之外，我们还可以将通知传播到客户端应用程序。</li><li id="78ba" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">应用程序外壳应该有常规的PWAs“stale-while-re validate”<strong class="iv hi">更新流程</strong>:如果可能的话，我们总是提供最新的缓存版本(几乎立即显示<em class="iu"/>)。同时，服务人员检查是否有更新版本的应用程序外壳。如果是，我们下载并缓存这个版本，以便在下一次应用程序运行时使用。此外，我们可能希望询问用户是否希望立即用应用程序重新加载当前选项卡。</li></ul><p id="0401" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">让我们一点一点来，但首先，我们必须做一些关于角CLI状态的笔记。</p><h1 id="211c" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Angular服务人员的Angular CLI支持(即将推出)</h1><p id="c7d5" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">目前，我们发布了Angular CLI 1.5。不幸的是，目前还没有NGSW支持，计划在1.6中推出。但是通过探索相应的拉请求(<a class="ae jr" href="https://github.com/angular/angular-cli/pull/8080" rel="noopener ugc nofollow" target="_blank">到CLI </a>和<a class="ae jr" href="https://github.com/angular/devkit/pull/235" rel="noopener ugc nofollow" target="_blank">到DevKit </a>)，我们可以很容易地理解它的外观和主要功能的再现。让我们看看最近的未来。</p><h2 id="9c8c" class="lq ko hh bd kp lr ls lt kt lu lv lw kx js lx ly lb jt lz ma lf ju mb mc lj md bi translated">服务人员的新应用</h2><p id="c940" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">该命令将如下所示:</p><p id="d602" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><code class="du jv jw jx jy b">ng new myApp --service-worker</code>(或使用别名— <code class="du jv jw jx jy b">-sw</code>)</p><p id="6925" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">有了这个服务工作者标志，Angular CLI 1.6将为我们实现一些自动化:</p><ol class=""><li id="4448" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq me kf kg kh bi translated">将安装角度服务人员包</li><li id="c1df" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq me kf kg kh bi translated">将启用对NGSW的构建支持</li><li id="c032" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq me kf kg kh bi translated">NGSW将为您的申请注册</li><li id="0e9b" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq me kf kg kh bi translated">将使用一些智能默认值创建NGSW配置文件</li></ol><p id="bbe4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">无论如何，即使在CLI 1.6发布之后，知道如何重现这些步骤也是很好的，因为我们必须手动执行它们来为现有的应用程序添加NGSW支持。我们去给PWAtter添加Angular Service Worker吧。</p><h2 id="9689" class="lq ko hh bd kp lr ls lt kt lu lv lw kx js lx ly lb jt lz ma lf ju mb mc lj md bi translated">将Angular Service Worker添加到现有应用程序</h2><p id="cf8b" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">让我们从上面手动执行同样的4个步骤:</p><ol class=""><li id="9c04" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq me kf kg kh bi translated"><strong class="iv hi">安装NGSW </strong></li></ol><p id="8ef1" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><code class="du jv jw jx jy b">npm install @angular/service-worker --save</code></p><p id="961e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi"> 2。启用构建支持(仅适用于Angular CLI 1.6，请参见下面的通知)</strong></p><p id="fb94" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><code class="du jv jw jx jy b">ng set apps.0.serviceWorker=true</code></p><p id="3be4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">或者在<code class="du jv jw jx jy b">.angular-cli.json</code>文件中手动添加/编辑该参数。</p><blockquote class="ip iq ir"><p id="02cd" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">重要！目前，当我们使用Angular CLI 1.5时，请确保<code class="du jv jw jx jy b">.angular-cli.json</code>中的<strong class="iv hi">没有</strong>这个属性，这会导致构建错误。请参阅下面的如何在Angular CLI 1.5中模拟此步骤。</p></blockquote><p id="b58a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi"> 3。在您的<code class="du jv jw jx jy b">AppModule</code>中注册NGSW </strong>。这是它在Angular CLI 1.6中的外观:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="dfee" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi"> 4。创建NGSW配置文件</strong>(默认名称为<code class="du jv jw jx jy b">src/ngsw-config.json</code>)。以下是Angular CLI 1.6将生成的默认内容(您可以在<a class="ae jr" rel="noopener" href="/@webmaxru/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-1-theory-37d7d7647cc7">上一篇文章</a>中找到关于该配置文件格式的更多详细信息):</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="d48e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">目前，在使用Angular CLI 1.5时，我们还必须模拟来自步骤2的构建支持。实际上，除了<code class="du jv jw jx jy b">ng build --prod</code>命令之外，还有2个额外的动作需要执行(为了使用NGSW，使用生产版本是很重要的！):</p><p id="537c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">使用NGSW CLI <code class="du jv jw jx jy b">ngsw-config</code>基于NGSW配置文件<code class="du jv jw jx jy b">src/ngsw-config.json</code>生成NGSW控制(清单)文件 <code class="du jv jw jx jy b">ngsw.json</code>。你可以在<a class="ae jr" rel="noopener" href="/@webmaxru/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-1-theory-37d7d7647cc7">之前的文章</a>中找到这个小工具的更多细节。</p><p id="f427" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi"> 2.2将NGSW本身</strong>从<code class="du jv jw jx jy b">npm_modules</code>包文件夹复制到我们的<code class="du jv jw jx jy b">dist</code>文件夹。</p><p id="1621" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">要使用一个简单的命令来生成支持NGSW的生产版本，让我们添加一些npm脚本:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="d210" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在，如果我们运行<code class="du jv jw jx jy b">npm run build-prod-ngsw</code>，我们将在<code class="du jv jw jx jy b">dist</code>文件夹中拥有Angular PWA。可选地，我们可以通过运行<code class="du jv jw jx jy b">npm run serve-prod-ngsw</code>使用最简单的<code class="du jv jw jx jy b">http-server</code>来服务它。</p><blockquote class="ip iq ir"><p id="8d7d" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">重要！不要使用<code class="du jv jw jx jy b">ng serve</code>来测试您的角度维修工人。此开发服务器不是为与PWA流协作而设计的。始终构建应用程序的生产版本，并使用任何静态web服务器从您的分布式文件夹中提供它。</p></blockquote><h1 id="cd10" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">应用程序外壳</h1><p id="c938" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">如果我们执行上述动作并运行<code class="du jv jw jx jy b">npm run build-prod-ngsw</code>——默认形式的角度PWA已经准备好了！部署应用程序或者使用任何静态web服务器在本地运行它(在我的例子中是<code class="du jv jw jx jy b">http-server</code>包，您运行<code class="du jv jw jx jy b">npm run serve-prod-ngsw</code>来构建和服务)。你会看到下图:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/1f9bbeb6c9be8e24a274c0ef6cb10e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqggBeu1a0PnwcNpPZpsfg.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">PWAtter — tiny Angular 5 app</figcaption></figure><p id="ccc3" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在该检查离线模式了！为此，我们将使用Chrome DevTools:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/b5cfbea4c91e1e464f9027bc553a4cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/1*8L2wvZCUop2AklIhOhwNKg.gif"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Emulating offline mode using Chrome DevTools</figcaption></figure><blockquote class="ip iq ir"><p id="e15c" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">重要通知:Chrome v62和早期版本可能会错误地处理离线切换，从而允许服务人员向网络发送一些请求。为了模拟更接近真实的离线模式，我推荐使用Chrome Canary(目前是v64)。Chrome Canary也有更好的缓存用户界面，允许我们看到存储的HTTP响应的内容。</p></blockquote><p id="25e1" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们离线后，应用程序还在工作。为什么？因为NGSW缓存了配置文件的<code class="du jv jw jx jy b">assetGroups</code>部分中列出的所有资源，现在它负责从缓存存储中为这些资源提供服务，缓存存储现在充满了记录:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/51d2d87879e5ccd3acbc874a5b0f755e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuG8FiPIKjgsEDp_pvA9kg.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Service Worker is registered and active</figcaption></figure><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/47ab16f82b5e6da5adc0b08ab4bbb019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9cjBfajBRN5f5RCOgZp7g.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">We can view the content of cached response (available only in Chrome Canary at the moment)</figcaption></figure><p id="0d62" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">NGSW使用高速缓存存储HTTP响应数据和一些元数据来处理版本控制:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/e8d45f82ba78e15f03d8c998dfbd42a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpYA2yc8-gB37CtyNNiuDA.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Types of the storages by NGSW</figcaption></figure><ul class=""><li id="b2df" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">后缀为<code class="du jv jw jx jy b">:cache</code>的条目—实际的HTTP响应。</li><li id="1139" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">带后缀<code class="du jv jw jx jy b">:meta</code>的条目——存储版本元信息。以后这种存储的数据可能会被移动到<code class="du jv jw jx jy b">indexedDB</code>。</li></ul><blockquote class="ip iq ir"><p id="8af7" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">提示:如果让DevTools保持打开状态，那么在服务工作者端的每个操作之后，缓存存储部分中的条目很可能不会自动更新。如果您希望查看实际数据，请右键单击并选择刷新缓存。</p></blockquote><p id="5764" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">但是这个应用程序看起来很奇怪:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/63f437aed33cf93dbc95185dd1c62e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_0QxZq0gN6oRneDle5JBw.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">No webfont icons</figcaption></figure><p id="5eeb" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">没错。NGSW配置文件的默认形式对于我们的例子来说是不够的，因为我们使用了材料图标webfont。显然，这些资源(对应的CSS和WOFF2文件)没有被NGSW缓存，但是我们可以通过在默认的<code class="du jv jw jx jy b">app</code>和<code class="du jv jw jx jy b">assets</code>组之外再给<code class="du jv jw jx jy b">assetGroups</code>添加一个组来轻松修复它。姑且称之为<code class="du jv jw jx jy b">fonts</code>:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="7250" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">使用globs语法指定这些资源是有意义的，因为字体文件的确切URL可能会随时间而改变，以支持webfont版本控制。另外，您可能会注意到，一方面我们既没有指定<code class="du jv jw jx jy b">installMode</code>也没有指定<code class="du jv jw jx jy b">updateMode.</code>，因为这是默认值，所以在生成的NGSW控制文件中两者都将被设置为<code class="du jv jw jx jy b">prefetch </code>。另一方面，它们只有在被请求后才会被缓存，因为<code class="du jv jw jx jy b">urls</code>的细节——列出资源的方式。</p><p id="4e63" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们重建、运行并切换到离线模式后，我们将看到应用程序的正常状态，所有图标都在原位。</p><p id="3674" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在缓存存储中，我们将看到两个新条目:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/0a2bb82d5656b78afda14183a7a12caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNCs2NViSiCxCzkfYTXdCw.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Storages generated by NGSW</figcaption></figure><p id="8d4a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们甚至可以预览缓存的字体:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/1daefa79c84af6a2b5ffec9f2f9bf089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8atsa4zuuQ4IQRvBTAJ5Q.png"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Preview of the cached resource</figcaption></figure><p id="61a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">太棒了，我们有了完整的应用程序外壳，并且可以在离线模式下运行。我们的应用程序发送给API的请求(数据请求)呢？显然，我们不能预先缓存它们，因为我们不知道URL的确切列表。您可能会问:但是我们可以在globs上使用相同的思想，就像我们申请外部资源缓存一样:<code class="du jv jw jx jy b">assetGroups / resources / urls / { https://our-backend.com/api/** }</code>。从技术上讲，这将缓存这些响应，但这会破坏应用程序外壳的更新流程。NGSW配置文件的<code class="du jv jw jx jy b">assetGroups</code>和<code class="du jv jw jx jy b">dataGroups</code>(来自下一章)部分有一个基本的区别:</p><ul class=""><li id="412c" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated"><code class="du jv jw jx jy b">assetGroups</code>正在跟踪app [shell]版本。如果这些组中的一个或多个资源被更新，我们认为有一个新版本的应用程序可用，相应的更新流程开始(我们将很快看到这一点)</li><li id="ebbf" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated"><code class="du jv jw jx jy b">dataGroups</code>独立于app版本。它们使用自己的缓存策略进行缓存，这是处理我们的API响应的适当部分。</li></ul><p id="a451" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">让我们缓存我们的tweet feeds，以便离线访问和优化在线体验。</p><h1 id="c8b7" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">运行时缓存</h1><p id="5ee9" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">我决定对我的<code class="du jv jw jx jy b">/timeline</code> API端点使用网络优先策略，对<code class="du jv jw jx jy b">/favorites</code>端点使用缓存优先策略。<code class="du jv jw jx jy b">src/ngsw-config.json</code>中相应的设置如下所示:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="cf73" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">有一个定义NGSW行为的主开关:<code class="du jv jw jx jy b">cacheConfig / strategy</code>。对于网络优先战略，是<code class="du jv jw jx jy b">freshness</code>，对于缓存优先战略，是<code class="du jv jw jx jy b">performance</code>。你可以在我的<a class="ae jr" rel="noopener" href="/@webmaxru/a-new-angular-service-worker-creating-automatic-progressive-web-apps-part-1-theory-37d7d7647cc7">上一篇文章</a>中获得关于其余参数的更多细节。</p><p id="e23d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在构建，服务，点击<em class="iu">加载我的时间线</em>和<em class="iu">加载我的收藏夹</em>按钮获取并缓存API响应，切换到离线。你会看到推文也显示在那里！</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/56d043a6adcbf3a93699b1673b170d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YrSERNRlo6SdwK9B1ic5aw.gif"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Runtime caching in offline demo</figcaption></figure><p id="c387" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">您可能会注意到，对于<em class="iu">时间线</em>来说，NGSW正试图到达网络(日志中的红线)——这就是网络优先战略的工作方式。相比之下，通过点击<em class="iu">收藏夹</em>，我们只需从缓存中抓取数据。</p><p id="58c2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们提到的在线模式的优化呢？返回在线状态，点击<em class="iu">时间线</em> / <em class="iu">收藏夹</em>一次或两次。可以清楚地看到，<em class="iu">收藏夹</em>被立即加载，因为我们跳过了整个网络行程，从缓存中获取数据。如何指定缓存多长时间？使用<code class="du jv jw jx jy b">cacheConfig</code>部分中的设置——我们在那里有细粒度控制！</p><p id="cf7e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">太好了。NGSW在一些真正智能的网络优化方面帮了我们很多，只需要我们做一些JSON配置。像推送通知这样更复杂的PWA功能呢？</p><h1 id="827c" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">推送通知</h1><p id="8272" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">它们只是在NGSW中工作，不需要在配置文件中设置任何东西。我们只需在后端遵循一些简单的惯例来显示通知。但是让我们从头开始——用户对通知的订阅。我们可以在这里自由选择两个选项:</p><ul class=""><li id="7469" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">使用与Web Push API相关的JavaScript native <code class="du jv jw jx jy b">navigator['serviceWorker']</code>对象方法</li><li id="5d62" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">或者用<code class="du jv jw jx jy b">ServiceWorkerModule</code>的<code class="du jv jw jx jy b">SwPush</code>级。如果我们打开<a class="ae jr" href="https://angular.io/api/service-worker/SwPush" rel="noopener ugc nofollow" target="_blank"> SwPush API文档</a>，就有我们需要的<code class="du jv jw jx jy b">requestSubscription()</code>方法。</li></ul><p id="51fb" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当然，我们选择第二种方案。那么订阅流程将如下所示:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="bd2f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">关于此代码的一些说明:</p><ul class=""><li id="bc1e" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">我假设我们在应用程序配置中的某个地方有<a class="ae jr" href="https://developers.google.com/web/updates/2016/07/web-push-interop-wins" rel="noopener ugc nofollow" target="_blank"> VAPID </a>公钥(我为此创建了一个简单的<code class="du jv jw jx jy b">ConfigService</code>)。您可以在这里生成一个乏味的密钥对<a class="ae jr" href="https://web-push-codelab.glitch.me/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="c61c" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">为了简化代码，我将与后端的协商转移到另一个名为<code class="du jv jw jx jy b">pushService</code>的小服务中。你会在我的<a class="ae jr" href="https://github.com/webmaxru/pwatter" rel="noopener ugc nofollow" target="_blank">回购</a>(分支<code class="du jv jw jx jy b">ngsw</code>)中找到完整的工作源代码。</li></ul><p id="7354" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">让我们来看看结果:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/9174dfd613e0148379bca838086a6380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AgAV95fDRcTTb3J62qoA5A.gif"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Push subscription + notifications</figcaption></figure><p id="d761" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">厉害！订阅后我们收到了一堆通知(是的，人们在推特上非常活跃地谈论JavaScript)。</p><p id="55e9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">重要的是要知道，要让NGSW正确处理和显示通知，我们必须在后端遵循一些简单的<strong class="iv hi">约定</strong>:</p><ul class=""><li id="539e" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">我们直接发送通知数据，将send notification请求作为有效负载(NGSW不能稍后请求这个有效负载，这在一般情况下是可能的)。</li><li id="656a" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">我们在有效载荷的<code class="du jv jw jx jy b">notification</code>属性中发送这个数据对象。可能包含以下字段:<code class="du jv jw jx jy b">title</code> —通知标题(<em class="iu">必选</em>)，以及<a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification" rel="noopener ugc nofollow" target="_blank">通知对象规格</a>的<code class="du jv jw jx jy b">options</code>中的所有字段(但未被<code class="du jv jw jx jy b">options</code>容器包装)。这种物体的例子:</li></ul><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="f292" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">用<code class="du jv jw jx jy b">SwPush</code>类的方法我们还能实现什么？我们可以使用<code class="du jv jw jx jy b">subscription</code> observable获得有效订阅(例如开始退订流程):</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="20ea" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">此外，我们可以订阅<code class="du jv jw jx jy b">messages</code> observable，并在我们的应用程序中接收通知数据:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="b184" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">然后我们可以再填充一个tweet feed:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/2169daac1d4e5e3aa14854d86d071027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lPcfLZosyKvXNpD7sEzVrw.gif"/></div></div></figure><p id="73b6" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">底线:使用Angular Service Worker实现推送通知非常简单。</p><h1 id="287a" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">更新流程</h1><p id="6a80" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">现在让我们回到我们的应用程序外壳及其版本。NGSW到底是如何处理我们应用的更新的？</p><p id="4059" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">NGSW应用程序更新实施有两个核心原则:</p><ul class=""><li id="5710" class="jz ka hh iv b iw ix ja jb js kb jt kc ju kd jq ke kf kg kh bi translated">用户工作流不应被意外更新的应用程序中断。打开的浏览器标签中的应用程序版本将保持不变，直到标签关闭。</li><li id="0d06" class="jz ka hh iv b iw ki ja kj js kk jt kl ju km jq ke kf kg kh bi translated">NGSW应该保持应用程序的完整性。如果应用程序分布式中的任何单个文件被更新，我们会将整个相应的版本视为一个新版本。这样，我们可以确保我们的应用程序总是有一组一致的文件。</li></ul><p id="ab60" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们如何实现这些目标？</p><p id="dd3a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">让我们探索NGSW版本化的概念。所谓版本，我们指的是一组代表我们的应用程序的特定版本的资源。如果任何应用程序文件在构建过程中发生变化，NGSW控制(清单)文件<code class="du jv jw jx jy b">ngsw.json</code>将会不同(因为<code class="du jv jw jx jy b">assetGroups / resources / files</code>部分的计算散列和/或<code class="du jv jw jx jy b">assetGroups / resources / versionedFiles</code>部分的不同文件名)。基于此<code class="du jv jw jx jy b">ngsw.json</code>文件内容计算的应用版本的唯一标识符，我们将此哈希作为缓存存储名称的一部分。</p><p id="aa2b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">好了，我们用更新的NGSW清单文件部署了应用程序的新版本。在其启动期间，Angular Service Worker试图在查询字符串中使用缓存破坏者下载此<code class="du jv jw jx jy b">ngsw.json</code>,在DevTools的network选项卡中，它看起来像这样:</p><p id="ec2e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><a class="ae jr" href="http://127.0.0.1:8080/ngsw.json?ngsw-cache-bust=0.36217997891166953" rel="noopener ugc nofollow" target="_blank"> /ngsw.json？ngsw-cache-bust = 0.36217997891166953</a></p><p id="b711" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果这个文件与以前的不同，NGSW会处理它，并根据更新的配置预缓存资源。都是后台做的。</p><p id="57ee" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">但是这个新版本不会立即被激活，这意味着用户仍然会看到旧版本，直到他们重新加载下一页。这是一个众所周知的PWAs权衡。感谢服务人员，我们可以立即从缓存加载应用程序，但网络上可能有更新的版本…很可能你已经看到许多网站显示类似于"<em class="iu">的弹出窗口，有更新的版本可用，你想刷新吗？</em>”</p><p id="3d79" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们能使用NGSW组织同样的流程吗？是啊！在<code class="du jv jw jx jy b">ServiceWorkerModule</code>的<code class="du jv jw jx jy b">SwUpdate</code>类中，我们有这方面的一切。<a class="ae jr" href="https://angular.io/api/service-worker/SwUpdate" rel="noopener ugc nofollow" target="_blank">根据文档</a>，我们有一个可观察的<code class="du jv jw jx jy b">available</code>来满足我们的需求:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="bf58" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">结果是:</p><figure class="mf mg mh mi fd ii er es paragraph-image"><div class="er es mz"><img src="../Images/8bbcae05b28c6c7d3f2e3c5c0dd26710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/1*9oSUEVm7xAz6Q-rQw3VGGw.gif"/></div><figcaption class="mm mn et er es mo mp bd b be z dx">Update app version promt</figcaption></figure><blockquote class="ip iq ir"><p id="29c6" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">重要通知:当DevTools打开时，service worker从不停止/启动，而是一直在后台运行。由于NGSW在其启动时检查更新的控制文件，这种行为可能会中断NGSW更新流程。在测试这个特性之前，只需关闭DevTools。</p></blockquote><p id="cc9c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果我们希望组织自定义更新流程(如定期检查和/或强制激活)，在<code class="du jv jw jx jy b">SwUpdate</code>中有两种有用的方法:<code class="du jv jw jx jy b">checkForUpdate()</code>和<code class="du jv jw jx jy b">activateUpdate()</code>。您可以在PWAtter的<em class="iu">更新流程</em>选项卡中查看它们是如何工作的。代码如下:</p><figure class="mf mg mh mi fd ii"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h1 id="e324" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">下一步是什么？</h1><p id="508f" class="pw-post-body-paragraph is it hh iv b iw ll iy iz ja lm jc jd js ln jg jh jt lo jk jl ju lp jo jp jq ha bi translated">让我们在现实世界的应用程序中测试这个伟大的新特性！欢迎您申请新功能，并将bug提交到GitHub上的主要Angular repo。迟早我们会默认创建角PWA，就像<a class="ae jr" href="https://github.com/facebookincubator/create-react-app/issues/2398" rel="noopener ugc nofollow" target="_blank">发生在<code class="du jv jw jx jy b">create-react-app</code>启动器的</a>一样。</p><p id="ed4b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果您希望加入关于PWA的讨论，欢迎您参加有800多名开发人员参加的<a class="ae jr" href="https://join.slack.com/t/progressive-web-apps/shared_invite/enQtMjY0NDI2MjAxNTc1LWM4ZWYyNDZhNDRlZDUyNTk5YThhZGQwOWRhZTkwZjAwNTlhNzA3MzY0ZWM0NWQxZmVkZjJhNWEzNTZkYmQ3ZTY" rel="noopener ugc nofollow" target="_blank"> open PWA slack </a>。</p><p id="fc28" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我愿意为您在世界任何地方的会议、meeetup或公司举办渐进式网络应用/ Angular / Angular服务人员研讨会和/或会议，请通过<a class="ae jr" href="mailto:salnikov@gmail.com" rel="noopener ugc nofollow" target="_blank">salnikov@gmail.com</a>联系我。</p></div></div>    
</body>
</html>