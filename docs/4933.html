<html>
<head>
<title>Kotlin for Interviews — Part 5: Frequently Used Code Snippets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试用Kotlin第5部分:常用代码片段</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-for-interviews-part-5-frequently-used-code-snippets-444ad4d137f5?source=collection_archive---------0-----------------------#2020-11-10">https://blog.kotlin-academy.com/kotlin-for-interviews-part-5-frequently-used-code-snippets-444ad4d137f5?source=collection_archive---------0-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2e4bd2554e52fc95387737698b321eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_88Jukrh3Lx8aLKV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fabulu75?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabrice Villard</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="26ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Kotlin for Interviews的第5部分，在这个系列中，我回顾了在Android面试准备期间经常出现的Kotlin函数和代码片段。我还编辑了一个备忘单，涵盖了这个系列的所有5个部分，你可以在这里找到<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-cheatsheet-88a9831e9d55"/>。</p><p id="01a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到第1部分:通用数据类型<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-1-common-data-types-886ea1e40645">，</a>第2部分:集合函数<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-2-collection-functions-a4a488fa0a14">这里</a>，第3部分:数字和数学<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-3-numbers-and-math-786660295cea">这里</a>，第4部分:迭代<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-part-4-iteration-b176dee4f1ae">这里</a>。</p><p id="b016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一部分包括:</p><ul class=""><li id="54c0" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="#7ff6" rel="noopener ugc nofollow">以邻接表形式创建图形</a></li><li id="7140" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#41f6" rel="noopener ugc nofollow">广度优先搜索</a></li><li id="59ac" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#04fe" rel="noopener ugc nofollow">深度优先搜索</a></li><li id="c993" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#de2a" rel="noopener ugc nofollow">树遍历</a></li><li id="1f74" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="#a810" rel="noopener ugc nofollow">动态编程/记忆</a></li></ul><p id="f75e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将回顾我发现自己经常用于许多不同问题的代码块。例如，许多面试问题归结为深度优先搜索，我使用了基本的深度优先搜索代码片段的变体来解决它们。</p><h1 id="7ff6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">以邻接表形式创建图形</h1><p id="44f7" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">对于许多图形问题，你会得到一个节点对列表，其中第二个节点依赖于第一个节点(反之亦然，取决于你的访问者)。例如，看起来像[0，1]的对意味着要访问节点1，必须先访问0。然而，大多数图算法需要一个<a class="ae kc" href="https://www.geeksforgeeks.org/graph-and-its-representations/" rel="noopener ugc nofollow" target="_blank">邻接表表示</a>，所以这里有一个算法，它接受一个节点对列表，并将其转换成一个邻接表。</p><p id="8a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定这个样本输入:</p><p id="5c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">[[1, 2], [1, 3], [1, 4], [2, 4], [2, 5], [3, 6], [4, 3], [4,6], [4, 7], [5, 4], [5, 7], [7, 6]]</p><p id="534e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它代表了这个图表:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/004bdb0de011086cb5950ff439247012.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/0*rgGD2S73ez7BXF3p.gif"/></div></div></figure><p id="ed37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要创建以下邻接表:</p><p id="4281" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">[[1: [2, 4, 3]], [2: [4, 5]], [3: [6]], [4: [6, 7, 3]], [5: [4, 7]], [7: [6]]]</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8be0e1a0081cbb6556f7784ee1723b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/0*5sXb9IqIdUnslrrg.gif"/></div></figure><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="d234" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun createAdjacencyList(pairs: Array&lt;IntArray&gt;) {<br/>    val graph: HashMap&lt;Int, MutableList&lt;Int&gt;&gt; = <em class="ni">hashMapOf</em>()<br/>    pairs.<em class="ni">forEach </em>{ pair -&gt;<br/>        if (!graph.containsKey(pair[0])) {</strong><br/><em class="ni">            // If the current node isn't in the adjacency list yet, <br/>            // add it and create its dependency list starting with <br/>            // pair[1]</em><br/>            <strong class="mz ir">graph[pair[0]] = <em class="ni">mutableListOf</em>(pair[1])</strong><br/>        <strong class="mz ir">} else {</strong><br/><em class="ni">            // Otherwise, append pair[1] to its existing dependency  <br/>            // list.<br/>            </em><strong class="mz ir">val dependencies = graph[pair[0]]                 <br/>            dependencies.add(pair[1])<br/>            graph[pair[0]] = dependencies<br/>        }<br/>    }<br/>}</strong></span></pre><p id="85d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这个算法是针对有向图的。如果你被告知这个图是无向的——意思是对[0，1]仅仅意味着0和1之间有一条边——只要将<code class="fe nj nk nl mz b">pair[0]</code>和<code class="fe nj nk nl mz b">pair[1]</code>交换，重复<code class="fe nj nk nl mz b">forEach()</code>循环中的代码，这样图中的<code class="fe nj nk nl mz b">MutableList</code>代表所有相邻节点，而不仅仅是有向依赖。</p><h1 id="41f6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">广度优先搜索</h1><p id="f882" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">许多面试问题都需要遍历图形——从查找节点到检查循环，再到查找两个节点之间的路径长度。广度优先搜索是一种方法。该算法从图中的某个节点开始，在队列的帮助下，在移动到下一个深度级别的节点之前，探索当前深度的所有邻居节点。</p><p id="f276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个基本版本，遍历从第一个节点可到达的所有节点。您可以根据您正在解决的图形问题来修改它。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="3d8a" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun bfs(nodes: List&lt;List&lt;Int&gt;&gt;) {<br/>    val visited = BooleanArray(nodes.size) { false }<br/>    </strong><em class="ni">// Create a queue and add 0 to represent the index of the <br/>    // first node</em><strong class="mz ir"><br/>    val queue: MutableList&lt;Int&gt; = mutableListOf(0)<br/>    while (queue.isNotEmpty()) {<br/>        </strong><em class="ni">// Dequeue a node from queue</em><br/><strong class="mz ir">        val node = queue.removeAt(0)<br/>        </strong><em class="ni">// Add all of the node's unvisited neighbors to the queue</em><br/><strong class="mz ir">        if (!visited[node]) {<br/>            nodes[node].forEach {<br/>                queue.add(it)<br/>            }<br/>            </strong><em class="ni">// Mark the dequeued node as visited</em><strong class="mz ir"><br/>            visited[node] = true<br/>        }<br/>    }<br/>}</strong></span></pre><h1 id="04fe" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">深度优先搜索</h1><p id="b5d9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">深度优先搜索也可以用于图的遍历问题。该算法使用堆栈代替队列，在被迫回溯并扩展到其他节点之前，尽可能地探索当前节点分支。</p><p id="1695" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个递归版本，它依赖于函数调用堆栈，而不是显式的堆栈变量。您也可以使用堆栈变量编写算法的迭代版本。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="6674" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun dfs(nodes: List&lt;List&lt;Int&gt;&gt;) {<br/>    val visited = BooleanArray(nodes.size) { false }<br/>    helper(nodes, 0, visited)<br/>}<br/> <br/>fun helper(nodes: List&lt;List&lt;Int&gt;&gt;, node: Int, visited: BooleanArray){<br/>    visited[node] = true<br/>    nodes[node].forEach { <br/>        if (!visited[it]) {<br/>            helper(nodes, it, visited)<br/>        }<br/>    }<br/>}</strong></span></pre><h1 id="de2a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">树遍历</h1><p id="fe20" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">树问题在面试中很常见。一些例子是寻找两个节点的最低共同祖先，对树中所有节点的值求和，等等。</p><h2 id="af17" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">二叉树</h2><p id="210a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">二叉树是你在面试中最常见的树。二叉树的一个节点看起来像这样:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="799f" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">class Node(<br/>    var key: Int, <br/>    var left: Node? = null, <br/>    var right: Node? = null<br/>)</strong></span></pre><p id="f740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，不是所有的二叉树都是二分搜索法树，除非你的面试官确认，否则你不应该认为你得到了BST。如果二叉树也满足以下条件，则它只是一个BST:</p><ul class=""><li id="3333" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">节点的左子树只包含键小于该节点键的节点。</li><li id="ac35" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">节点的右边子树只包含键大于节点键的节点。</li><li id="cc9a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">左侧和右侧的子树都必须是二叉查找树。</li></ul><p id="404d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用这棵树(它不是BST！)举个例子:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/673d318de1fbbca2d051265b8fbf9e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*h1NH-OTJ8cfHdoHa2eyRSQ.png"/></div></figure><p id="e216" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用以下代码来构造它:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="4e2f" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">val node4 = Node(4)<br/>val node7 = Node(7)<br/>val node6 = Node(6, node4, node7)<br/>val node11 = Node(11)<br/>val node9 = Node(9, node6, node11)<br/>val node2 = Node(2)<br/>val node5 = Node(5)<br/>val node12 = Node(12, node2, node5)<br/>val node3 = Node(3, node12)<br/>val node1 = Node(1, node9, node3)</strong></span></pre><p id="1981" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个前序遍历的样子:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="c617" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun preOrder(n: Node?) {<br/>    n?.let { node -&gt;<br/>        print(node.key)<br/>        preOrder(node.left)<br/>        preOrder(node.right)<br/>    }<br/>}</strong></span><span id="1af2" class="nd lq iq mz b gy ny nf l ng nh"><strong class="mz ir">preOrder(node1)</strong> <em class="ni">// prints 1 9 6 4 7 11 3 12 2 5</em></span></pre><p id="1b19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个有序遍历的样子:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="fdff" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun inOrder(n: Node?) {<br/>    n?.let { node -&gt;<br/>        inOrder(node.left)<br/>        print(node.key)<br/>        inOrder(node.right)<br/>    }<br/>}</strong></span><span id="d60d" class="nd lq iq mz b gy ny nf l ng nh"><strong class="mz ir">inOrder(node1</strong>) <em class="ni">// prints 4 6 7 9 11 1 2 12 5 3</em></span></pre><p id="9ac2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是后序遍历的样子:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="f525" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun postOrder(n: Node?) {<br/>    n?.let { node -&gt;<br/>        postOrder(node.left)<br/>        postOrder(node.right)<br/>        print(node.key)<br/>    }<br/>}</strong></span><span id="6e90" class="nd lq iq mz b gy ny nf l ng nh"><strong class="mz ir">postOrder(node1)</strong> <em class="ni">// prints 4 7 6 11 9 2 5 12 3 1</em></span></pre><h2 id="e208" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">有多个孩子的树</h2><p id="21d6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">您还可能遇到有一系列子节点而不是左右节点的树。这种数据结构的一个例子是Android视图层次结构，其中每个视图可能有多个子视图。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="c915" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">class Node(var value: Int) {<br/>  val children: List&lt;Node&gt;<br/>}</strong></span></pre><p id="12a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，您必须在所有子节点上递归调用您的函数，代码如下所示:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="646a" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun traverse(node: Node) {<br/>    print(node.key)<br/>    node.children.forEach {<br/>        traverse(it)<br/>    }<br/>}</strong></span></pre><h1 id="a810" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">动态编程/记忆</h1><p id="a239" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">无论何时，当您最终得到一个具有相同输入的重复调用的递归算法时，您都可以使用动态编程来优化它。这个想法是将子问题的结果存储在一个表中，这样我们就不必在以后需要时重新计算它们。这将时间复杂度从指数降低到多项式。它可以使用迭代或递归来实现。</p><h2 id="9498" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">循环</h2><p id="edbd" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们从最小的<code class="fe nj nk nl mz b">i</code>开始，从那里填充结果表。我们在当前迭代中需要的每个子问题都应该已经解决了。在最后一次迭代中，我们求解<code class="fe nj nk nl mz b">i=n</code>并返回结果。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="df7b" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun fibonacci(n: Int): Int {</strong><br/>    <em class="ni">// Initialize an array to keep track of results of subproblems<br/>    // We'll use 0 as the placeholder initial value</em><br/>    <strong class="mz ir">val results = Array(n + 1) { 0 }<br/></strong><em class="ni">    // Set the base cases</em><strong class="mz ir"><br/>    results[1] = 1<br/>    results[2] = 1<br/>    for (i in 3..n) {<br/>        results[i] = results[i-1] + results[i-2]<br/>    }<br/>    return results[n]</strong><br/><strong class="mz ir">}</strong></span></pre><h2 id="093e" class="nd lq iq bd lr nm nn dn lv no np dp lz ko nq nr md ks ns nt mh kw nu nv ml nw bi translated">递归</h2><p id="4d62" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们从<code class="fe nj nk nl mz b">i = n</code>开始。如果我们当前迭代需要的子问题的结果已经存在于结果表中，我们可以使用它们。如果没有，我们将递归调用函数来求解它们并存储结果。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="e752" class="nd lq iq mz b gy ne nf l ng nh"><strong class="mz ir">fun fibonacci(n: Int): Int {<br/></strong><em class="ni">    // Initialize an array to keep track of results of subproblems<br/>    // We'll use 0 as the placeholder initial value</em><strong class="mz ir"><br/>    val results = Array(n + 1) { 0 } <br/>    </strong><em class="ni">// Set the base cases</em><strong class="mz ir"><br/>    results[1] = 1<br/>    results[2] = 1<br/>    return helper(n, results)<br/>}</strong></span><span id="cb7e" class="nd lq iq mz b gy ny nf l ng nh"><em class="ni">// Write a helper function that takes in the results array as an <br/>// argument</em><strong class="mz ir"><br/>fun helper(n: Int, results: Array&lt;Int&gt;): Int {<br/></strong><em class="ni">    // Check for the result of the subproblem you need in the <br/>    // results table first</em><strong class="mz ir"><br/>    val nMinusOne: Int = if (results[n-1] != 0) {<br/>        results[n-1]<br/>    } else {<br/></strong><em class="ni">        // Only make the recursive call to the subproblem if it's <br/>        // not in the results table yet</em><strong class="mz ir"><br/>        helper(n-1, results)<br/>    }<br/>    val nMinusTwo: Int = if (results[n-2] != 0) {<br/>        results[n-2]<br/>    } else {<br/>        helper(n-2, results)<br/>    }<br/></strong><em class="ni">    // Fill in the results table with the current results</em><strong class="mz ir"><br/>    results[n] = nMinusOne + nMinusTwo<br/>    return nMinusOne + nMinusTwo<br/>}</strong></span></pre><p id="8fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin for Interview系列到此结束。这里是<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/kotlin-for-interviews-cheatsheet-88a9831e9d55">链接到备忘单</a>再次涵盖所有5个部分。祝你面试好运！</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="4952" class="lp lq iq bd lr ls og lu lv lw oh ly lz ma oi mc md me oj mg mh mi ok mk ml mm bi translated">点击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="7b79" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kc" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kc" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在Medium上关注我们。</p><p id="93a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kc" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi ol"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>