<html>
<head>
<title>Backpressure in your Kotlin Flows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林流中的背压</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/backpressure-in-your-kotlin-flows-3eec980869c7?source=collection_archive---------0-----------------------#2021-02-12">https://medium.com/google-developer-experts/backpressure-in-your-kotlin-flows-3eec980869c7?source=collection_archive---------0-----------------------#2021-02-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="03ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我应该什么时候开始担心？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/8f232800c9f1751c16fc371e81f2e3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0hvpPdByCI9WN6bC"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CHUTTERSNAP</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f7b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在普通的Android应用程序中，你并不经常需要担心背压。事件一般不会在我们弱小的移动设备上扩展到背压变得重要的程度。不是说不可能，只是在我的经历中不常见。然而，正如我在我的<a class="ae js" href="https://nickskelton.medium.com/converting-firebase-api-callbacks-to-kotlin-flows-3eea87429ee9" rel="noopener">上一篇文章</a>中发现的那样，在对<code class="du jt ju jv jw b">callbackFlow</code>进行实验时，不仅是流中事件的规模，还有事件本身的结构和顺序，以及我们对它们将如何到达所做的假设，都可能导致与背压相关的错误。</p><h1 id="df3c" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是背压？</h1><p id="9673" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">你可能很熟悉的一个概念是“缓冲”。当试图将背压概念化时，这是一个很好的起点。每个开发人员都曾在某个时候与一个<code class="du jt ju jv jw b">File</code>交互过:创建了一个<code class="du jt ju jv jw b">ByteBuffer</code>和一个<code class="du jt ju jv jw b"> FileInputStream</code>，并设法将文件的字节流传输到一个<code class="du jt ju jv jw b">String </code>或什么东西中。流非常类似，只是它是一个事件流——事件可以保存任何类型的数据，包括字节。就像文件一样，如果你有一个流，你需要一个缓冲区，以防数据产生的速度比它被消耗的速度快…这就是背压的定义:当数据产生的速度比它被消耗的速度快。</p><p id="be66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，当人们在反应流环境中谈论背压时，他们通常谈论的是“背压策略”:</p><ul class=""><li id="4a35" class="lb lc hh ig b ih ii il im ip ld it le ix lf jb lg lh li lj bi translated">缓冲区有多大？(大小= 0，1，64，100000)</li><li id="3a8f" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">当缓冲区已满时，我们如何处理新事件？</li></ul><p id="0795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“不幸的是，没人知道什么是背压。你得自己去看。”</p><p id="444b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是时候下载代码来阅读本文的其余部分了:</p><div class="lp lq ez fb lr ls"><a href="https://github.com/shredderskelton/callbackflow" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hi fi z dy lx ea eb ly ed ef hg bi translated">shredderskelton/call回流</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">跟callbackFlow混在一起。创建一个帐户，为shredderskelton/call reflow的发展作出贡献…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">github.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg jm ls"/></div></div></a></div><p id="d87e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae js" href="https://nickskelton.medium.com/converting-firebase-api-callbacks-to-kotlin-flows-3eea87429ee9" rel="noopener">上一篇文章</a>中，我使用<code class="du jt ju jv jw b">callbackFlow</code>将一些Firebase回调转换为Kotlin流，并重点关注如何<em class="la">为我们的流产生</em>数据。直到我开始<em class="la">消耗</em>这些<em class="la"> </em>事件(在收集器上)的时候，我遇到了一个潜在的问题，徘徊到了背压。</p><p id="12c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:Firebase实现并不重要——我下面探讨的所有内容都是针对Kotlin流的。</p><h1 id="7deb" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么不只是<code class="du jt ju jv jw b">collect</code>？</h1><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4764" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">collectLatest</code>、<code class="du jt ju jv jw b">collect</code>或<code class="du jt ju jv jw b">collectIndexed</code>……选哪个？</p><p id="e0d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有为什么<code class="du jt ju jv jw b">collect()</code>都是红色的？</p><p id="3631" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我第一次遇到这个选择时，我对自己说，<code class="du jt ju jv jw b">collectLatest</code>听起来差不多是对的，我是对的。巧合吗？</p><p id="bdd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过选择<code class="du jt ju jv jw b">collectLatest</code>，我并不知道这一点，但我刚刚做出了一个关于我打算如何处理背压的决定。事实上，如果我们想深入了解，我实际上是被Flow的设计者谨慎地引导做出这个决定的——他们设计(并限制)了这些集合选项，以这样的方式引导我选择99%正确的选项。换句话说，他们做了可用性功课，发现大多数人只对收集“最新”事件感兴趣。</p><p id="32b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">collect()</code>是红色的，因为JetBrains强烈反对你使用它，但没有完全禁止它。这是为了给高级用户建议新用例的机会。来源注释/文档:</p><p id="efbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">此类限制可确保不违反上下文保留属性，并防止大多数与并发性、不一致的流调度程序和取消相关的开发人员错误</em></p><p id="7e48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">乍一看，<code class="du jt ju jv jw b">collectIndex()</code>似乎只有在您对每个事件的索引感兴趣时才有用，然而，还有一个重要的原因让您可能想要选择<code class="du jt ju jv jw b">collectIndex()</code>——它处理背压的方式与<code class="du jt ju jv jw b">collectLatest()</code>不同。稍后我会解释。</p><p id="a43d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们看看<code class="du jt ju jv jw b">collectLatest()</code>会发生什么</p><h1 id="370c" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">丢弃的数据包</h1><p id="7618" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">让我们模拟一些背压。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a8c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">delay(5000)</code>正在模拟一个收集器(也称为消费者或客户端，取决于您与谁交谈),它需要5秒钟来处理每个结果。回想一下，当我们<em class="la">消耗的</em>比我们<em class="la">生产的<em class="la">慢时，就会产生背压。</em>延期是为了夸大萎靡的消费者，制造一个超级慢热的催收员。</em></p><p id="2305" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，由于我们选择了<code class="du jt ju jv jw b">collectLatest</code>，我们是安全的，因为当另一个值被“提供”(也就是产生)时，<code class="du jt ju jv jw b">collectLatest</code>例程将有效地停止它正在做的事情，并使用<em class="la">最新的</em>结果重新开始。</p><p id="6d28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这有一个危险的副作用，即<code class="du jt ju jv jw b">updateScreen()</code>通常在最终发行前不会被调用。如果Firebase发送进度更新的频率超过每5秒，那么我们的UI将冻结，直到最后一次提供后5秒。不太好。</p><p id="d2ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此<code class="du jt ju jv jw b">collectLatest</code>对流程的内容做了一个重要的假设:提供给流程的最终价值是最重要的，我们真的不想错过它。</p><p id="5ae7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，如果“放弃”的结果也很重要呢？如果每次提供东西的时候<code class="du jt ju jv jw b">updateScreen()</code>都要叫<em class="la">真的很重要怎么办？</em></p><p id="d5a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们尝试使用不同的收集器，一个不会在新的报价到来时退出的收集器。让我们看看<code class="du jt ju jv jw b">collectIndexed</code>会发生什么，尽管我们对<code class="du jt ju jv jw b">index</code>并不感兴趣。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="bdde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个管用！我们对屏幕的所有更新都延迟了5秒，正如我们所料，<em class="la">和</em>最后一个值通过了ok。为什么？</p><p id="8b70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们已经告诉流程，我们对所有的<em class="la">产品感兴趣，而不仅仅是最新的<em class="la"/>…这是一个好的开始。但是为什么没有东西坏掉呢？</em></p><h1 id="f890" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">默认就可以了</h1><p id="d7ff" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">一切正常，因为<code class="du jt ju jv jw b">callbackFlow</code>的默认缓冲区大小是64。所以Firebase可以在<code class="du jt ju jv jw b">offer()</code>开始返回<code class="du jt ju jv jw b">false</code>之前进行64次提供(<code class="du jt ju jv jw b">false</code>表示缓冲区已满，提供失败)。</p><p id="e522" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于Firebase没有足够的“回调”来填充默认缓冲区，我决定模拟一次洪水。每次Firebase发送进度报告时，我都会给出50个相同的报价。终于有东西破了！</p><p id="5082" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，这一次，已经在流动的产品仍然存在。当缓冲区已满时，丢失的是“最新”的项目——这是一个重要的区别。如果流程中的最后一个产品很重要，不能错过，该怎么办？</p><p id="3d56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后你需要更多地控制你的背压和你接触这个重要的小流量算子的时间:</p><pre class="jd je jf jg fd mj jw mk ml aw mm bi"><span id="a731" class="mn jy hh jw b fi mo mp l mq mr">.buffer()</span></pre><p id="8d42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是所有与背压相关的东西的神奇操作符，试验起来非常有趣，因为它很容易上手和使用:</p><pre class="jd je jf jg fd mj jw mk ml aw mm bi"><span id="745b" class="mn jy hh jw b fi mo mp l mq mr">buffer(capacity: Int, onBufferOverflow: BufferOverflow)</span></pre><p id="be60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当缓冲区溢出时，JetBrains为我们提供了三个选项:</p><pre class="jd je jf jg fd mj jw mk ml aw mm bi"><span id="46ee" class="mn jy hh jw b fi mo mp l mq mr">public enum class BufferOverflow {<br/> <em class="la">  SUSPEND</em>,<br/> <em class="la">  DROP_OLDEST</em>,<br/> <em class="la">  DROP_LATEST<br/></em>}</span></pre><p id="0306" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jt ju jv jw b">DROP_OLDEST</code>和<code class="du jt ju jv jw b">DROP_LATEST</code>非常简单，<code class="du jt ju jv jw b">SUSPEND</code>很有趣。对于我们的<code class="du jt ju jv jw b">FileInputStream</code>类比，这可能意味着“停止从硬盘读取”。这在某些情况下可能是好的(当流式传输视频剪辑时，一旦媒体播放器缓冲区已满，就停止从服务器请求帧)，但在其他情况下可能是坏的(当从麦克风录制音频时，如果停止从麦克风获取数据，就会丢失正在发生的任何声音，并且音频会有间隙)。</p><h1 id="25f7" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">分手建议</h1><p id="45cd" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">如果Flow API本身的结构不够地道，那么源代码文档在Kotlin库中确实是首屈一指的。他们真的付出了很多努力来使文档简洁和有用。如果你不确定一个操作员做什么——按住CTRL键并花5分钟阅读半页手册。时间花得值。</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="0b84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇文章能帮助您为您的流量选择正确的背压策略，并理解背压为什么重要。</p><p id="e042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">非常感谢恩里克·洛佩斯·马斯和T2·弗洛里纳·芒特内斯库审阅本文。传奇。</p><p id="c57f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae js" href="https://twitter.com/nshred" rel="noopener ugc nofollow" target="_blank">推特</a>上给我留言——我张开双臂拥抱荣誉和胜利。</p></div></div>    
</body>
</html>