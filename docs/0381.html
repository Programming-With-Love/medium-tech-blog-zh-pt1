<html>
<head>
<title>Dependency injection in a multi module project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多模块项目中的依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/dependency-injection-in-a-multi-module-project-1a09511c14b7?source=collection_archive---------2-----------------------#2019-01-09">https://medium.com/androiddevelopers/dependency-injection-in-a-multi-module-project-1a09511c14b7?source=collection_archive---------2-----------------------#2019-01-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a026" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">将阿迪框架引入格子花呢的启示</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/10ffdda5fbb3f4e6dd3ef49f8c5ac7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yWf1DFEnYBWNmAvT"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Illustrated by <a class="ae jm" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><p id="246a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这不是一篇关于依赖注入的文章，也不是一篇关于为什么我们选择库X而不是库y的文章。</p><h1 id="ba75" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">我们的设置</h1><p id="de4e" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">在之前的一篇文章中，我写了关于格子花呢整体模块化的故事。</p><div class="lg lh ez fb li lj"><a rel="noopener follow" target="_blank" href="/androiddevelopers/a-patchwork-plaid-monolith-to-modularized-app-60235d9f212e"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hi fi z dy lo ea eb lp ed ef hg bi translated">拼布格子——从整体到模块化应用</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">我们如何和为什么模块化格子布和未来</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">medium.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jg lj"/></div></div></a></div><p id="84f5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我快速回顾一下从鸟瞰角度看格子花呢的样子。</p><p id="901e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们有一个<code class="du ly lz ma mb b">app</code>模块，它包含主要的启动器活动。还有几个动态特征模块(DFM)依赖于<code class="du ly lz ma mb b">app</code>模块。每个DFM包含至少一个仅与所讨论的特性相关的活动、代码和资源。</p><p id="b9d3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du ly lz ma mb b">app</code>模块依赖于<code class="du ly lz ma mb b">core</code>模块，后者包含共享代码和资源以及第三方库。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/c21ee1b1615ec3811bfdebe1a150ddc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VJS0y6-8fKBUHGhU"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Plaid’s module dependency graph</figcaption></figure><p id="9ed1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们开始模块化并引入Dagger作为依赖注入的主要参与者之前，Plaid的代码有几个类和函数，如下所示:</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="aa8e" class="mh kk hh mb b fi mi mj l mk ml">class DesignerNewsInjector {</span><span id="d3da" class="mh kk hh mb b fi mm mj l mk ml">    fun providesApi(...): DesignerNewsService { ... }</span><span id="9b8f" class="mh kk hh mb b fi mm mj l mk ml">}</span></pre><p id="7d6e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">虽然这是一个完美的解决方案，但是我们不得不手工编写大量的样板文件和管道代码。</p><p id="abfd" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">无论注射器需要什么，我们都必须在正确的点调用底层函数，在许多情况下要么是对象初始化，要么是<code class="du ly lz ma mb b">onCreate</code>。</p><h1 id="1bf0" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">非常简短的依赖注入介绍</h1><p id="57a6" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">依赖注入基本上意味着你不在你需要的地方创建对象，而是在别的地方创建。然后，对这些对象的引用可以传递到需要它们的类中。</p><p id="7d15" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这既可以手动完成，也可以通过许多库中的一个来完成。我们选择了匕首2。多亏了Dagger，我们所要做的就是获得一个可以使用的初始化服务:</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="f6ad" class="mh kk hh mb b fi mi mj l mk ml">@Inject lateinit var service: DesignerNewsService</span></pre><p id="dd4b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">服务的所有依赖项都可以作为参数传递给provides函数。为我们的依赖注入需求选择Dagger意味着我们的依赖图是在编译时创建的。在接下来的章节中，请记住这一点。</p><h1 id="38ba" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">我们将匕首引入格子的方法</h1><p id="f1a3" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">当我们决定将Dagger引入grid时，我们已经学到了一个宝贵的经验，这对于模块化来说尤其如此。</p><blockquote class="mn"><p id="67c2" class="mo mp hh bd mq mr ms mt mu mv mw ki dx translated">不要试图一次涵盖太多内容。</p></blockquote><p id="e262" class="pw-post-body-paragraph jn jo hh jp b jq mx ii js jt my il jv jw mz jy jz ka na kc kd ke nb kg kh ki ha bi translated">这意味着花一些时间来计算实现一个新特性所需的最小范围是值得的。然后我们在团队内部讨论这个MVP，看看我们是否在朝着正确的方向前进。坚持这种做法可以防止我们因为太大而无法有效地工作。这也允许我们在其他人继续工作的同时，在我们的代码库中逐步推出变更。</p><p id="027d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在Plaid中，我们使用已经被证实的<code class="du ly lz ma mb b">about</code>功能模块作为Dagger的游戏场。在这里，我们可以添加Dagger，而不会干扰其他模块或工作负载。你可以在这里找到<a class="ae jm" href="https://github.com/nickbutcher/plaid/commit/9310b6d4f100adff4e639456f58ac802b57d4b39" rel="noopener ugc nofollow" target="_blank">初始提交</a>。</p><h1 id="ec2c" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">依赖图</h1><p id="b3bf" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">当将依赖注入库引入到一个单一的应用程序中时，通常整个应用程序只有一个单一的依赖图。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nc"><img src="../Images/15152163f205a3df85347b9e48c5fbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfFPurM3MIKdGjL66Ko7Yw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Classic simplified dependency graph in a monolithic project</figcaption></figure><p id="6f79" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这使得组件之间能够共享依赖关系。在一些库中，为了避免冲突或者为注入目标提供特定的实现，可以限定依赖关系的范围。</p><h1 id="9e12" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">模块异常</h1><p id="cb40" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">对于模块化的应用程序，尤其是使用动态功能模块的应用程序，这是行不通的。让我们仔细看看应用程序和动态特性模块是如何相互依赖的。动态特征模块知道应用模块的存在。应用程序模块知道动态特性模块的存在，但是不能直接从该模块中执行代码。对于依赖注入，这意味着图必须被分成几部分。</p><p id="c5f7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">对于模块化的应用程序，简化的依赖图通常看起来像这样。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nd"><img src="../Images/2f8db9566f25a0ae2032da113c30171f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpO72oXxUIoraT_Abj_eoA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Modules have clear boundaries and are encapsulated within a DFM’s dependency graph</figcaption></figure><p id="63e5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">更具体地说，格子里的组成部分是这样的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/0d6303da443826bd97eef37e31d74a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*Ol8Cff81iw5JmqXWWnQ35A.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Plaid’s component landscape</figcaption></figure><p id="2f63" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">每个DFM都有自己的组件，以其所在的功能模块命名。通过<code class="du ly lz ma mb b">HomeComponent</code>的<code class="du ly lz ma mb b">app</code>模块也是如此。</p><p id="4f6c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">还有一个包含共享依赖项的组件。它位于<code class="du ly lz ma mb b">core</code>内，被称为<code class="du ly lz ma mb b">CoreComponent</code>。<code class="du ly lz ma mb b">CoreComponent</code>背后的主要思想是提供可以在整个应用程序中使用的对象。它结合了位于<code class="du ly lz ma mb b">core</code>库中的几个Dagger模块，可以在整个应用程序中重用。</p><p id="15ba" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，因为图是有向的，所以只有一种方法可以共享Dagger组件:<br/>DFM可以从应用程序模块访问Dagger组件。应用程序模块可以从它所依赖的库中访问组件。但不是反过来。</p><h1 id="5d86" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">跨模块边界共享组件</h1><p id="0e62" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">为了共享Dagger组件，需要使它们在整个应用程序中都是可访问的。在Plaid中，我们决定通过Application类访问我们的<code class="du ly lz ma mb b">CoreComponent</code>。</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="da11" class="mh kk hh mb b fi mi mj l mk ml">class PlaidApplication : Application() {</span><span id="4fcc" class="mh kk hh mb b fi mm mj l mk ml">  private val coreComponent: CoreComponent by lazy {<br/>    DaggerCoreComponent<br/>      .builder()<br/>      .markdownModule(MarkdownModule(resources.displayMetrics))<br/>      .build()<br/>  }</span><span id="8269" class="mh kk hh mb b fi mm mj l mk ml">  companion object {</span><span id="d981" class="mh kk hh mb b fi mm mj l mk ml">    @JvmStatic fun coreComponent(context: Context) =<br/>      (context.applicationContext as PlaidApplication).coreComponent<br/>  }<br/>}</span></pre><p id="f633" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">实例化的核心组件现在可以通过调用<code class="du ly lz ma mb b">PlaidApplication.coreComponent(context)</code>从应用程序中任何有可用上下文的地方访问。</p><p id="6e22" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用一个扩展函数使得对它的访问更加甜蜜:</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="1590" class="mh kk hh mb b fi mi mj l mk ml">fun Activity.coreComponent() = PlaidApplication.coreComponent(this)</span></pre><h1 id="70cb" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">组件中的组件</h1><p id="329e" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">要将<code class="du ly lz ma mb b">CoreComponent</code>合并到另一个组件中，有必要在创建组件时提供它。让我们看看这在<code class="du ly lz ma mb b"><a class="ae jm" href="https://github.com/nickbutcher/plaid/blob/master/search/src/main/java/io/plaidapp/search/dagger/SearchComponent.kt" rel="noopener ugc nofollow" target="_blank">SearchComponent</a></code>中是如何工作的:</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="1bea" class="mh kk hh mb b fi mi mj l mk ml">@Component(modules = [...], dependencies = [CoreComponent::class])<br/>interface SearchComponent {</span><span id="4e12" class="mh kk hh mb b fi mm mj l mk ml">  @Component.Builder<br/>  interface Builder {</span><span id="6632" class="mh kk hh mb b fi mm mj l mk ml">    fun coreComponent(coreComponent: CoreComponent): Builder<br/>    // modules<br/>  }<br/>}</span></pre><p id="b25a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在生成的<code class="du ly lz ma mb b">DaggerSearchComponent</code>初始化期间，我们这样设置<code class="du ly lz ma mb b">CoreComponent</code>:</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="132f" class="mh kk hh mb b fi mi mj l mk ml">DaggerSearchComponent.builder()<br/>  .coreComponent(activity.coreComponent())<br/>  // modules<br/>  .build()<br/>.inject(activity)</span></pre><p id="4a88" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里的技巧是将<code class="du ly lz ma mb b">CoreComponent</code>设置为<code class="du ly lz ma mb b">SearchComponent</code>的依赖项。</p><pre class="ix iy iz ja fd md mb me mf aw mg bi"><span id="3fd5" class="mh kk hh mb b fi mi mj l mk ml">@Component(<br/>    modules = [SearchModule::class],<br/>    dependencies = [CoreComponent::class]<br/>)<br/>interface SearchComponent : BaseActivityComponent&lt;SearchActivity&gt;</span></pre><p id="3c54" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du ly lz ma mb b">CoreComponent</code>是<code class="du ly lz ma mb b">SearchComponent</code>的依赖。当<code class="du ly lz ma mb b">CoreComponent</code>像上面一样作为<code class="du ly lz ma mb b">SearchComponent</code>的组件依赖被包含时，所有的<code class="du ly lz ma mb b">CoreComponent’s</code>方法都可以在<code class="du ly lz ma mb b">SearchComponent</code>或其他Dagger组件中使用，就像它们是<code class="du ly lz ma mb b">@Provides</code>方法一样。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nf"><img src="../Images/d1cf884f5bb88c523c75b694fa35b632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQ12g7x545uJfb6Y0KjjUw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Component dependencies with their respective modules (in green) providing implementations to SearchActivity</figcaption></figure><p id="faae" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这种方法的一个好处是<code class="du ly lz ma mb b">@Modules</code>不必在整个特性图中重复，而是可以通过<code class="du ly lz ma mb b">CoreComponent</code>或其绑定的模块透明地提供。</p><p id="628c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">例如，<code class="du ly lz ma mb b">CoreDataModule</code>被绑定在<code class="du ly lz ma mb b">CoreComponent</code>中，并在其中提供<code class="du ly lz ma mb b">Retrofit</code>。现在可以在任何包含了<code class="du ly lz ma mb b">CoreComponent</code>的组件中访问这个<code class="du ly lz ma mb b">Retrofit</code>实例。</p><h1 id="45f9" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">下一步是什么</h1><p id="aa30" class="pw-post-body-paragraph jn jo hh jp b jq lb ii js jt lc il jv jw ld jy jz ka le kc kd ke lf kg kh ki ha bi translated">读完这篇文章后，你会发现模块化你的应用程序也必须考虑依赖注入。引入的特征模块边界通过分离的依赖图反映在DI中。了解这些限制有助于为共享组件找到合适的位置。</p><p id="eede" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">您可以深入代码，看看我们是如何使用Dagger in Plaid解决依赖注入的。</p><p id="d68b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du ly lz ma mb b"><a class="ae jm" href="https://github.com/nickbutcher/plaid/blob/master/core/src/main/java/io/plaidapp/core/dagger/CoreComponent.kt" rel="noopener ugc nofollow" target="_blank">CoreComponent</a></code>是一个很好的起点，<code class="du ly lz ma mb b"><a class="ae jm" href="https://github.com/nickbutcher/plaid/blob/master/about/src/main/java/io/plaidapp/about/dagger/AboutComponent.kt" rel="noopener ugc nofollow" target="_blank">AboutComponent</a></code>也是，因为它没有太多的外部依赖性。</p></div></div>    
</body>
</html>