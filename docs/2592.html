<html>
<head>
<title>Indexing Pada Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Indexing Pada Database</h1>
<blockquote>原文：<a href="https://medium.easyread.co/indexing-pada-database-f532e60520ee?source=collection_archive---------1-----------------------#2021-08-22">https://medium.easyread.co/indexing-pada-database-f532e60520ee?source=collection_archive---------1-----------------------#2021-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ef9b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Apa itu indexing dan bagaimana penggunaannya?</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c762902ac7078ddd05baa9b68f96dbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eiOCZLDwuU9p2s1k.jpg"/></div></div></figure><p id="399a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Dalam dunia <em class="lk"> software development </em> mungkin kita sudah cukup sering mendengar kata index. <em class="lk"> Nah </em> , tapi kalau kalian masih belum pernah atau jarang mendengarnya maka artikel ini tepat untuk kalian.</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="a8dc" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Disclaimer</h1><p id="4a6a" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Pada topik kali ini, kita akan membahas indexing pada database mySQL. Untuk storage enginenya sendiri kita akan bahas penggunaannya pada InnoDB. Biasanya konsepnya sama dengan database lain, tetapi mungkin cara implementasi dan termsnya saja yang berbeda-beda. Untuk jenis index sendiri mungkin masih ada beberapa yang tidak dibahas, kita akan fokus ke beberapa yang paling sering dipakai saja.</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="7920" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Intro Boys</h1><p id="43cc" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Sebelum lanjut ke pembahasan berikutnya, mungkin kita coba jelaskan apa itu index dan kenapa kita membutuhkan index pada database.</p><p id="be00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mp mq mr ms b"><strong class="kq io">Kalau sudah pernah menggunakan index sebelumnya, mungkin bisa skip aja bagian ini bosku.</strong></code></p><p id="e2be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Kalau menurut kang wikipedi:</p><blockquote class="mt mu mv"><p id="eded" class="ko kp lk kq b kr ks jo kt ku kv jr kw mw ky kz la mx lc ld le my lg lh li lj ig bi translated"><strong class="kq io"> A database index </strong> is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure.</p></blockquote><p id="3656" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Sedangkan menurut kang mySQL di dokumentasi resminya:</p><blockquote class="mt mu mv"><p id="0f6d" class="ko kp lk kq b kr ks jo kt ku kv jr kw mw ky kz la mx lc ld le my lg lh li lj ig bi translated"><strong class="kq io"> Indexes </strong> are used to find rows with specific column values quickly</p></blockquote><p id="0cc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Dan jikalau kamu mencari penjelasan dari sumber lain, hasilnya pun pasti akan serupa. Kalau bahasa sederhananya ya <code class="fe mp mq mr ms b"><strong class="kq io">untuk mempercepat hasil query.</strong></code> Atau bisa dibilang, data yang sudah di index adalah <code class="fe mp mq mr ms b"><strong class="kq io">data yang sudah dikelompokkan dan sudah terurut.</strong></code> <strong class="kq io"> </strong> Kalau datanya sudah terurut, secara otamatis proses pencarian akan lebih cepat dari proses pencarian biasanya.</p><p id="fab1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Mungkin untuk aplikasi sederhana atau yang melakukan pengolahan dataset yang cenderung kecil, tanpa menggunakan index hasilnya juga udah lumayan. Tidak perlu menggunakan index. Tetapi bagaimana kalau ternyata aplikasinya harus berinteraksi dengan database dataset yang cukup besar. Atau ternyata aplikasi kecil tadi akhirnya menjadi besar dan penggunanya semakin banyak dan data yang di olah juga bertambah banyak? Tentu saja aplikasi akan menjadi lambat (lelet).</p><p id="99e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> Nah, </em> disinilah index datang untuk menyelamatkan.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/24806e2c34688401df67fcc47b469479.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*y8d140R5rBjX2_5TFau1eg.gif"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="282f" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">How Index Works</h1><p id="1110" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Sebelum pembahasan lebih lanjut, ada baiknya kita mengetahui dulu cara kerja index secara garis besar, lalu kita akan melanjutkan ke pembahasan yang lebih dalam. Untuk lebih mudah memahami si index ini, kita dapat mencoba memahaminya dengan analogi berikut .</p><p id="1ccb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Pada suatu pagi yang cerah di sebuah klinik, ada seorang pasien (Tono) yang ingin berobat. Seperti biasa, perawat (Tini) akan menanyakan tentang data diri si Tono dan mencari berkasi si Tono di lemari yang menyimpan data pasien.</p><p id="6458" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Karena data pasiennya ada sekitar 1000an, si Tini harus mencari data si Tono di data pasien satu persatu. Anggap saja untuk mencocokkan nama butuh waktu sekitar 1 detik. Jadi si ani butuh 16–17 menit hanya untuk nyari berkas saja kalau ternyata berkas Tono ada di urutan terakhir.</p><p id="84c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Untuk mengatasi hal ini, si Tini bisa melakukan pengelompokan data pasien berdasarkan abjad. Lalu mengurutkan data pasien berdasarkan nama. Kalau Tono datang lagi keesokan harinya, Tini bisa mencari langsung pada data yang sudah dikelompokkan di huruf <code class="fe mp mq mr ms b"><strong class="kq io">T</strong></code> dan mencari nama <code class="fe mp mq mr ms b"><strong class="kq io">Tono</strong></code> berdasarkan urutan. Karena berkas sudah terkelompok dan terurut, Tini hanya butuh beberapa detik saja untuk melakukan pencariannya.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/26e1b14c7b80ccdfc6726c99314173ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*kH7KmCg_6_lwz5_3.jpg"/></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="6ad1" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">How Index Implemented</h1><p id="7f50" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Untuk implementasi indexing, mySQL memiliki beberapa mekanisme. Yang paling sering digunakan adalah <strong class="kq io"> <em class="lk"> Btree (Balanced Tee) </em> </strong> <em class="lk"> , </em> <strong class="kq io"> <em class="lk"> RTREE </em> </strong> <em class="lk"> , </em> <strong class="kq io"> <em class="lk"> FULLTEXT </em> </strong> <em class="lk"> </em> dan <em class="lk"> </em> <strong class="kq io"> <em class="lk"> HASH </em> </strong> <em class="lk"> . </em> Tapi yang akan kita bahas hanya <em class="lk"> Btree </em> saja karena ini mekanisme yang paling populer dan paling sering digunakan.</p><p id="68db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Indexing menggunakan <em class="lk"> Btree </em> bisa sangat cepat karena <code class="fe mp mq mr ms b"><strong class="kq io">data index disimpan menggunakan data struktur <em class="lk">tree</em>, dan sudah <em class="lk">balance</em>.</strong></code> <strong class="kq io"> </strong> Jika datanya sudah balance maka database akan mampu mempercepat pencarian karena sudah bisa membatasi jumlah record yang harus dicari dan sudah tahu dimana record tersebut harus dicari.</p><p id="b646" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Jika belum terbiasa dengan konsep <em class="lk"> tree </em> , sederhananya struktur data <em class="lk"> tree </em> akan mempunyai <em class="lk"> root/parent node </em> atau element paling atas. Lalu punya <em class="lk"> sub tree </em> atau anak dari <em class="lk"> parentnya </em> tadi. <em class="lk"> Sub tree </em> sebelah kiri akan menyimpan data yang lebih kecil dan disebelah kanan merupakan data yang lebih besar.</p><p id="c19d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Jika contohnya parent adalah 100, maka jika punya anak dengan nilai 99 akan disimpan di sebelah kiri, dan jika punya anak dengan nilai 101 akan disimpan disebelah kanan. Mekanisme ini akan berlaku untuk keturunan dari substreenya tadi. Jadi dengan data struktur seperti ini, akan sangat mudah dan cepat untuk melakukan pencarian didalam pohon tersebut.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/709868328b208f5451de1088b5e450b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*litoqAg_GTpbeMln.gif"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/285ee47f803888e0419bf04bd871c0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l1heQmE3HrOg_2ZkKBqXCw.gif"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="0924" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Jenis-Jenis Index</h1><p id="a44f" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Pada mySQL, index ada beberapa jenis. Akan kita bahas satu per satu. Sebagai contoh, kita akan menggunakan table <em class="lk"> employee </em> dengan skema berikut:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/5696779af3877f029ba75d14b9e4c86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDJR7Vq9qJjKxj__qm0hbw.png"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h2 id="d10c" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Primary Index</h2><p id="ca18" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Diambil dari dokumentasi resminya :</p><blockquote class="mt mu mv"><p id="21e6" class="ko kp lk kq b kr ks jo kt ku kv jr kw mw ky kz la mx lc ld le my lg lh li lj ig bi translated">Each <code class="fe mp mq mr ms b"><strong class="kq io">InnoDB</strong></code> table has a special index called the clustered index that stores row data. Typically, the clustered index is synonymous with the primary key.</p></blockquote><p id="12ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Sesuai dengan sebutannya, primary index adalah jenis <code class="fe mp mq mr ms b"><strong class="kq io">index yang di buat menggunakan primary key pada table tersebut</strong>. </code> Index ini akan di generate secara otomatis oleh system pada saat kita membuat table tersebut. Inilah yang membuat semua <em class="lk"> query </em> yang menggunakan id pada where clause akan di eksekusi dengan sangat cepat.</p><p id="b5b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Primary keys menggunakan <code class="fe mp mq mr ms b"><strong class="kq io"> clustered index</strong></code> <strong class="kq io"> . </strong> Disebut clustered karena actual row data disimpan bersamaan dengan keynya (disimpan pada <em class="lk"> leaf </em> ). Jadi untuk read datanya pasti lebih cepat karena tidak perlu lagi get kemana-mana. Pada innoDB, clustered index merupakan si table itu sendiri, ini artinya si primary index adalah representasi dari si table itu sendiri. Karena inilah kita tidak bisa menghapus primary key index.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/54386ae30bae42739484c402d8e175ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*232wPbOxAu1iwxjUYeFwtw.png"/></div></div></figure><p id="3326" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Karena setiap kali kita melakukan insert kedalam database, artinya kita melakukan insert kedalam primary index, hal inilah yang membuat disarankannya penggunaan integer auto increment pada primary key (bukan varchar), agar performa pada saat insert bisa cepat karena urutannya sudah pasti (auto increment).</p><p id="258a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Untuk table ini memiliki total data sebanyak : <code class="fe mp mq mr ms b"><strong class="kq io">2.844.047 row</strong></code> sudah memakan size sekitar 200 MB.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/a21af0ca03b3ef6fb39e862c7ba90726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zp_cT3rVJkdMlW7YRwHyZw.png"/></div></div></figure><p id="343f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Jika kita melakukan query dengan menggunakan id pada where clausenya kita akan bisa mendapatkan hasil yang sangat cepat.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/28ee4c6340fe0b19024fd1962055845e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ss_rHeMqwDg7AKaIRgBgkw.png"/></div></div></figure><p id="e16b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Perhatikan pada kotak merah, mySQL bisa mendeteksi dengan menggunakan query tersebut, index <code class="fe mp mq mr ms b"><strong class="kq io">PRIMARY</strong></code> merupakan salah satu index yang available untuk digunakan dan pada saat eksekusinya, mySQL juga menggunakan index <code class="fe mp mq mr ms b"><strong class="kq io">PRIMARY</strong></code> saat melakukan query. Dengan menggunakan index ini, mySQL tidak perlu melakukan pencarian terhadap 2jt data, hanya perlu mengevaluasi 1 row saja, sudah mendapatkan hasil yang diinginkan.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/d35220be4a1c48571e10b88d2888501e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NIRNltkrkHerkzS5Ec4jg.png"/></div></div></figure><p id="b4d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Dari sekitar 2jt row, mySQL bisa mengembalikan hasilnya dalam waktu 0.3ms saja.</p><h2 id="d772" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Secondary Index</h2><p id="296a" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Berbeda dengan primary index, secondary index adalah <strong class="kq io"> </strong> <code class="fe mp mq mr ms b"><strong class="kq io">index yang harus dibuat secara manual</strong></code> . Index ini adalah semua index yang <code class="fe mp mq mr ms b"><strong class="kq io">tidak menggunakan primary key sebagai key pada index nya</strong>.</code></p><p id="2782" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Berbeda dengan primary index, secondary index tidak menyimpan row dari valuenya, tapi menyimpan si primary key pada leaf nya, dan menggunakan si primary key sebagai locator data nya.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/8ddc3587a8b9c7efd84d2ce34f8d846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVoYtdLWVFYOlV4KMNNawA.png"/></div></div></figure><p id="ddfa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ini akan menyebabkan kita butuh menduplikasi si primary key pada setiap secondary index. Karna duplikasi ini, maka sangat tidak disarankan kalau sebuah primary key itu varchar dan ukurannya besar, karna sudah pasti akan mempengaruhi storage si secondary index. Jadi jika melakukan akses data menggunakan secondary index, sebenarnya akan ada jump dari secondary index ke primary index dulu baru ke data aslinya.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/2c448c7f83e2cd0d70f515e5d05b69f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q24PF5xcgSB1P6IzMW2nBg.png"/></div></div></figure><p id="2db8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Biasanya index jenis ini digunakan karena adanya kebutuhan melakukan query secara terus menerus/cukup sering yang menggunakan spesifik column sebagai filternya. Misalnya query yang hanya menggunakan <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong></code> sebagai filternya karena kita ingin menampilkan data untuk 1 orang employee saja. <br/> Maka butuh menambahkan <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong></code> pada where clause nya.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/713db59bf9fd4f7951a33b90297a136b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvX2aXq4PcBucUGbuEJdUA.png"/></div></div></figure><p id="914d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Saat kita mencari <code class="fe mp mq mr ms b"><strong class="kq io">emp_no=100000,</strong></code> query time nya naik menjadi 802ms.</p><p id="2954" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Karena query ini cukup sering digunakan pada aplikasi atau query secara manuan, kita butuh menambahkan index pada column <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong>.</code> Untuk mempercepat query ini kita bisa menambahkan index baru pada column <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong></code> dengan query berikut:</p><pre class="kd ke kf kg gt nx ms ny nz aw oa bi"><span id="2a56" class="ne lt in ms b gy ob oc l od oe">ALTER TABLE `employees`.`employee` ADD INDEX `idx_emp_no` (`emp_no` ASC);</span></pre><p id="b957" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Setelah menambahkan index baru, lalu kita coba cek berapa storage yang dibutuhkan untuk 1 index yang baru kita tambahkan.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ef51b12517cc3c25039e17f1c928da69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*dmhens7xJ_beAaU4e1DABg.png"/></div></figure><p id="8913" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Untuk index yang baru saja kita buat memakan hampir 1/4 dari data aslinya. Sebagai catatan, pada (`emp_no` ASC), <code class="fe mp mq mr ms b"><strong class="kq io">ASC</strong></code> ini menunjukkan bahwa data yang disimpan pada index sudah <code class="fe mp mq mr ms b"><strong class="kq io">sorted secara ascending.</strong></code></p><p id="b01b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Itulah salah satu pertimbangan yang harus dipikirkan saat ingin membuat sebuah index baru. Karena cost nya yang cukup besar <code class="fe mp mq mr ms b">,</code> penambahan index pada setiap column sangat tidak disarankan.</p><p id="8a7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Setelah kita tambah lalu melakukan query ulang, kita akan mendapatkan hasil berikut.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/0fb704a3f2722599c35e6ea86a68fa2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1gcb0LkFx2ViEw_tO1isA.png"/></div></div></figure><p id="ac0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">durasinya berubah dari <code class="fe mp mq mr ms b"><strong class="kq io">0.802s</strong></code> menjadi <code class="fe mp mq mr ms b"><strong class="kq io">0.000031sec(0.03ms).</strong> </code> <br/> Perlu diperhatikan juga pada bagian <code class="fe mp mq mr ms b"><strong class="kq io">possible_keys</strong></code> dan <code class="fe mp mq mr ms b"><strong class="kq io">key</strong></code> , index yang baru saja dibuat dipertimbangkan dan juga digunakan oleh mySQL saat melakukan query. Perlu diperhatikan juga pada bagian rows, mySQL hanya perlu melakukan pengecekan terhadap <code class="fe mp mq mr ms b"><strong class="kq io">12 row </strong></code> saja, bukan lagi <code class="fe mp mq mr ms b"><strong class="kq io">2jt rows</strong></code> <strong class="kq io"> </strong> untuk mendapatkan hasil yang diinginkan.</p><h2 id="d228" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Composite Index</h2><p id="db5e" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Dibandingkan index lain, mungkin index ini adalah index yang paling sering digunakan. <strong class="kq io"> </strong> <code class="fe mp mq mr ms b"><strong class="kq io">Index ini memperbolehkan kita menggunakan beberapa column sekaligus</strong> </code> sebagai key (up to 16 keys). Index ini juga sering disebut sebagai <strong class="kq io"> <em class="lk"> Multi-column/Composite/Compound </em> </strong> index.</p><p id="4c70" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Let’s say kita membuat sebuah index dengan kombinasi dari 4 column - <code class="fe mp mq mr ms b"><strong class="kq io">col1</strong></code> , <code class="fe mp mq mr ms b"><strong class="kq io">col2</strong></code> , <code class="fe mp mq mr ms b"><strong class="kq io">col3</strong></code> , <code class="fe mp mq mr ms b"><strong class="kq io">col4</strong></code> . Hal yang perlu diperhatikan adalah : <code class="fe mp mq mr ms b"><strong class="kq io">urutan column pada index mempengaruhi bagaimana index menyimpan data dan mencari data</strong></code> . Dengan menggunakan composite index, kita bisa melakukan pencarian dengan index dengan where clause : <code class="fe mp mq mr ms b"><strong class="kq io">col1</strong></code> , <code class="fe mp mq mr ms b">(<strong class="kq io">col1</strong>, <strong class="kq io">col2</strong>)</code> , <code class="fe mp mq mr ms b">(<strong class="kq io">col1</strong>, <strong class="kq io">col2</strong>, <strong class="kq io">col3</strong>)</code> , <code class="fe mp mq mr ms b">(<strong class="kq io">col1</strong>, <strong class="kq io">col2</strong>, <strong class="kq io">col3</strong>, <strong class="kq io">col4</strong>)</code> .</p><p id="d85e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Kita boleh hanya menggunakan beberapa kolom saja pada index tersebut pada saat melakukan query, tapi syaratnya adalah, column yang ada pada urutan awal/sebelumnya pada waktu pembuatan index harus ikut digunakan. Misalnya jika ingin menggunakan index diatas, tapi hanya ingin menggunakan column <code class="fe mp mq mr ms b"><strong class="kq io">col3</strong></code> pada where clause, kita harus menyertakan <code class="fe mp mq mr ms b"><strong class="kq io">col1</strong></code> dan <code class="fe mp mq mr ms b"><strong class="kq io">col2</strong></code> pada where clause agar index bisa digunakan. Jika ingin menggunakan <code class="fe mp mq mr ms b"><strong class="kq io">col2</strong></code> saja, maka harus tetap menyertakan <code class="fe mp mq mr ms b"><strong class="kq io">col1</strong></code> pada where clause agar index bisa digunakan.</p><p id="cfeb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Pada composite index, index key akan di construct berdasarkan gabungan dari column yang digunakan pada index tersebut. Misal index yang dibetuk dari gabungan <code class="fe mp mq mr ms b"><strong class="kq io">(col1, col2, col3)</strong></code> akan membentuk key <code class="fe mp mq mr ms b"><strong class="kq io">col1col2col3</strong>.</code> Hal inilah yang menyebabkan <code class="fe mp mq mr ms b"><strong class="kq io">pencarian menggunakan index ini harus selalu mengikut sertakan prefix urutan awal/sebelumnya dalam where clause nya. </strong></code> <br/> Contoh jika melakukan pencarian pada : <code class="fe mp mq mr ms b"><strong class="kq io">index(col1,col2)</strong></code> <strong class="kq io"> <br/> </strong> where col1 = “a” - &gt; using index <br/> where col2 = “b” - &gt; not using index <br/> where col1 = “a” and col2 = “b” - &gt; using index</p><p id="7265" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">bisa diperhatikan bahwa untuk index (col1, col2), harus selalu menyertakan col1(prefix) dalam where clause nya agar index bisa mengenali karena key yang dibuat untuk index(col1,col2) adalah <code class="fe mp mq mr ms b"><strong class="kq io">col1col2</strong></code> .</p><p id="e0e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Jika kita callback lagi ke case kurir pada gedung di case sebelumnya, kita bisa membuat sebuah composite index untuk mempercepat query search yang sebelumnya :</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/eb3ef06fc4c62646847be0807d33f5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJKdu-ZzoIegqKIVtLZ1fw.png"/></div></div></figure><p id="6b79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Kalau hanya menggunakan nama saja sebagai parameter, mySQL harus melakukan pencarian terhadap 2jt lebih resultset.</p><p id="774f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Pada tahap ini kita akan menambahkan index baru dengan kombinasi <br/> lantai, ruangan. Harus diperhatikan bahwa <code class="fe mp mq mr ms b"><strong class="kq io">lantai</strong></code> sebagai prefix <code class="fe mp mq mr ms b"><strong class="kq io">harus selalu ada pada query</strong></code> <strong class="kq io"> </strong> agar index yang dibuat bisa digunakan.</p><pre class="kd ke kf kg gt nx ms ny nz aw oa bi"><span id="0be2" class="ne lt in ms b gy ob oc l od oe">ALTER TABLE `employees`.`employee` ADD INDEX `idx_lantai_ruangan` (`lantai` ASC, `ruangan` ASC);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/26fca0eec713950919d6225aa267562c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*_K8x_DS4U-si1XzKNxchtg.png"/></div></figure><p id="9eb2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">index yang baru dibuat ternyata memakan size yang lebih besar karna kita menggunakan gabungan lantai dan ruangan pada key nya.</p><p id="cadd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Owh ya untuk menggenerate table diatas kalian bisa gunakan script berikut:</p><pre class="kd ke kf kg gt nx ms ny nz aw oa bi"><span id="d6bf" class="ne lt in ms b gy ob oc l od oe">SELECT database_name, table_name, index_name,<br/>ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) size_in_mb<br/>FROM mysql.innodb_index_stats<br/>WHERE stat_name = ‘size’ AND index_name != ‘PRIMARY’<br/>and table_name = “employee”<br/>ORDER BY size_in_mb DESC;</span></pre><p id="477a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Harus diperhatikan tentang cara kerja composite index adalah <code class="fe mp mq mr ms b"><strong class="kq io">column yang digunakan akan di gabungkan lalu disimpan pada btree</strong>.</code> Pada saat melakukan pencarian, <code class="fe mp mq mr ms b"><strong class="kq io">parameter yang digunakan akan digabungkan dan dicocokkan untuk mencari data pada composite key pada index.</strong> </code> Karena hal ini lah urutan parameter pada where clause akan mempengaruhi hasil pencarian.</p><p id="7bc8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Sekarang jika kita menambahkan <code class="fe mp mq mr ms b"><strong class="kq io">lantai</strong></code> dan <code class="fe mp mq mr ms b"><strong class="kq io">ruangan</strong></code> pada where clause, kita akan mempermudah si mySQL karena sudah memperkecil scope data yang harus di cari. Dari 2jt hanya sisa sekitar 500k saja.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/5f73c638417bf9ad12e2ae9ed7034e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTRbWVCytA0gWysGsS2eNw.png"/></div></div></figure><p id="0076" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Untuk query diatas, mySQL masih memperbolehkan dan menggunakan <code class="fe mp mq mr ms b"><strong class="kq io">idx_lantai_ruangan</strong></code> dalam pencariannya. Sedangkan jika menggunakan column yang sesuai dengan index yang sudah dibuat, misalnya querynya tidak sesuai dengan index seperti query dibawah, maka mySQL terpaksa melakukan full table scan lagi.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/9312b97f861e0285763dadcaf0db076c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDBYslPRHlHJz705JNEkYw.png"/></div></div></figure><p id="c66a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">pada query tersebut, kita menggunakan parameter ruangan saja sebagai parameter di where clause diikutin first_name. Karena tidak sesuai urutan seperti pada urutan index pada saat dibuat, yang mana prefix lantai tidak digunakan, maka mySQL akan melakukan scan terhadap 2jt data. Tapi kalau query yang digunakan adalah <code class="fe mp mq mr ms b"><strong class="kq io">lantai</strong></code> dan <code class="fe mp mq mr ms b"><strong class="kq io">first_name</strong></code> maka index masih bisa dipakai karena masih mengikuti prefix dari index sebelumnya.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ol"><img src="../Images/0d339808d1051ed20bc0a8dc656bbfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5ewVM4AudoMSd5EXjATWQ.png"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h2 id="d70a" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Composite Index vs Multiple Secondary Index</h2><p id="2571" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Seletah melihat penggunaan composite index, ternyata fiturnya keren juga. Tapi ada batasan bahwa where clause nya harus sesuai dengan index yang digunakan. Cukup merepotkan memang. Kenapa tidak menggunakan secondary index aja? Buatin secondary index terhadap semua non primary column? hemm pertanyaan menarik.</p><p id="58a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Hal tersebut <code class="fe mp mq mr ms b"><strong class="kq io">bisa dilakukan. Tetapi tidak boleh alias tidak disarankan.</strong></code> Tiap kali kita membuat sebuah index, sebenarnya costnya juga lumayan. Seperti yang ditunjukkan sebelumnya, 1 index bisa makan storage hampir 1/4 dari data table aslinya. Jangan sampai karena semua <em class="lk"> query </em> ingin cepat, kita jadi membuat banyak index, yang jadinya bisa memakan storage berkali lipat dari ukuran table itu sendiri. Selain itu setiap kita melakukan operasi CRUD, si mySQL harus melakukan pengapdetan terhadap key ke semua index yang sudah ada.</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h2 id="6a8d" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">UNIQUE Key Index</h2><p id="4493" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Unique key index cukup berbeda dengan index yang lainnya. Index jenis ini digunakan untuk menjaga data integrity pada suatu table, dengan cara memastikan tidak ada data pada sebuah table yang dupicate entry, yang mengunakan satu atau beberapa non primary key column sebagai acuannya.</p><p id="cf59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Misalnya pada table employee tadi, kita ingin memastikan kalau tidak boleh ada 1 <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong></code> dan <code class="fe mp mq mr ms b"><strong class="kq io">from_date</strong></code> yang memiliki data yang sama. Yang artinya adalah tidak boleh ada employee yang mendapatkan gaji sebanyak 2 kali pada bulan yang sama. Maka kita bisa tambah index uniq berikut:</p><pre class="kd ke kf kg gt nx ms ny nz aw oa bi"><span id="7305" class="ne lt in ms b gy ob oc l od oe">ALTER TABLE `employees`.`employee` <br/>ADD UNIQUE INDEX `uniq_emp_no_from_date` (`emp_no` ASC, `from_date` ASC);</span></pre><p id="d2d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Jadi jika ada yang ingin menambahkan row baru dengan menggunakan nomor <code class="fe mp mq mr ms b"><strong class="kq io">emp_no</strong></code> dengan <code class="fe mp mq mr ms b"><strong class="kq io">from_date</strong></code> yang sudah digunakan sebelumnya, system akan menolak karnena akan mendeteksinya sebagai duplicate entry.</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="d5eb" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Index On Join Query</h1><p id="c01d" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Untuk query dari satu table udah cukup jelas nih, kita bisa ngandalin si index buat speed up query execution timenya. Pertanyaannya untuk query yang ada joinannya gimana ?</p><p id="fae2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Kalau query yang dilakukan membutuhkan join ke table lain, kita <code class="fe mp mq mr ms b"><strong class="kq io">harus memastikan query tersebut menggunakan join column yang sudah di index supaya waktunya itu nggk lama.</strong></code> Kalau tanpa index mySQL bakalan butuh <code class="fe mp mq mr ms b"><strong class="kq io">matching data satu persatu column joinan di table a dengan table joinan di table b.<br/></strong></code> Misal pada table query berikut kita melakukan query dan menggunakan last_name sebagai join column, querynya pasti akan melakukan full table scan dan memakan waktu lama:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/359b1868e264641fab4447dcf6455910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWIz31XJs2atffeLuZwWHQ.png"/></div></div></figure><p id="ba8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">sedangkan kalau kita ganti join column menjadi id, querynya bakalan cepat dan index akan digunakan.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi on"><img src="../Images/f82a8b053ac322d83b80f48d3a67f00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvpXk2UR6qLzJ3vha21gow.png"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="340d" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Order, Limit &amp; Grouping</h1><p id="3848" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Nah pertanyaannya, gimana nih kalau make order limit ama grouping ? Sama saja. <code class="fe mp mq mr ms b"><strong class="kq io">Semuanya bakalan butuh index kalau mau proses lebih cepat</strong>. </code> FYI, saat melakukan order, limit dan grouping, <code class="fe mp mq mr ms b"><strong class="kq io">mySQL akan melakukan operasi tersebut setelah melakukan query.</strong> </code> Namanya adalah <code class="fe mp mq mr ms b"><strong class="kq io">File Sort. </strong></code> Sort yang dilakukan setelah query. <code class="fe mp mq mr ms b"><strong class="kq io">Setelah melakukan fetch, data akan disimpan di buffer temp lalu di sort dan direturn hasilnya.</strong> </code> Jadi saat melakukan <code class="fe mp mq mr ms b"><strong class="kq io">limit</strong></code> <strong class="kq io"> , </strong> record yang di scan tetap aja banyak, lalu di limit setelah datanya di return.</p><p id="687d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Tapi kalau kalian melakukan operasi tersebut pada column yang sudah di index, hasilnya pasti lebih cepat daripada query yang biasanya</p><h1 id="d01c" class="ls lt in bd lu lv oo lx ly lz op mb mc jt oq ju me jw or jx mg jz os ka mi mj bi translated">Pros vs Cons</h1><p id="b4e9" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Setelah melakukan sedikit pembahasan diatas, kita bisa menyimpulkan beberapa pros dan cons yang akan kita dapatkan saat menggunakan index.</p><h2 id="8afa" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Pros :</h2><ol class=""><li id="7404" class="ot ou in kq b kr mk ku ml kx ov lb ow lf ox lj oy oz pa pb bi translated">Proses searching bisa jadi jauh lebih cepat.</li><li id="6a21" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Penggunaan query yang harus menyesuaikan dengan index yang sudah ada</li><li id="4272" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Proses sorting, order dan grouping bisa menggunakan index</li><li id="1c69" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Proses join bisa memanfaatkan index</li></ol><h2 id="6081" class="ne lt in bd lu nf ng dn ly nh ni dp mc kx nj nk me lb nl nm mg lf nn no mi np bi translated">Cons :</h2><ol class=""><li id="a91c" class="ot ou in kq b kr mk ku ml kx ov lb ow lf ox lj oy oz pa pb bi translated">Cost mahal. Seperti yang dicontohkan sebelumnya satu index bisa memakan storage hampir 1/4 dari data aslinya. Makin banyak index, makin banyak data. Kalau storage untuk index sudah mendekati atau lebih besar dari data aslinya, mungkin harus dipertimbangkan untuk menggunakan search engine yang lain saja. Misalnya elasticsearch atau solr.</li><li id="7d2e" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Proses CRUD yang akan memakan waktu. Hal ini dikarenakan karena tiap proses tersebut memungkinkan pengupdetan pada tiap index.</li></ol></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="8687" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Points To Take</h1><ol class=""><li id="8a50" class="ot ou in kq b kr mk ku ml kx ov lb ow lf ox lj oy oz pa pb bi translated">Gunakan index dengan bijak karena jumlah index berbanding lurus dengan cost dan performance</li><li id="859e" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Lebih baik melakukan update pada existing index jika memungkinkan daripada harus membuat baru. Untuk menghindari cost storage tambahan.</li><li id="6280" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Selalu gunakan integer bukan varchar pada primary key, karena pengguanaan integer pada saat saat pencarian di index jauh lebih cepat dibandingkan varchar.</li><li id="52f8" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Kalau sudah ada index pada column yang di cari, hasil dari query pada column itu sudah sorted. Tergantung dari indexnya apakah asc/desc</li><li id="1109" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated">Penggunaan query join yang benar akan mengurangi waktu pada pencarian.</li></ol><p id="1582" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Sekian yang bisa dibahas tentang index, sebenarnya masih banyak penjelasan yang sengaja di skip karena pembahasannya sudah cukup <em class="lk"> advance </em> dan kurang cocok kalau di buat disini semua. Kalau rame mungkin kita coba buat. <br/> Semoga bermanfaat. Skol.</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ph"><img src="../Images/2cec2f43cefd90981235c28173524786.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*PKuELjrGZPmtNeIt.gif"/></div></div></figure></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="bfff" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">Reference:</h1><ol class=""><li id="ad27" class="ot ou in kq b kr mk ku ml kx ov lb ow lf ox lj oy oz pa pb bi translated"><a class="ae pi" href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html" rel="noopener ugc nofollow" target="_blank"> Multiple-Column Indexes </a></li><li id="67c4" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated"><a class="ae pi" href="https://dev.mysql.com/doc/refman/8.0/en/show-index.html" rel="noopener ugc nofollow" target="_blank"> Show Index </a></li><li id="558f" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated"><a class="ae pi" href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" rel="noopener ugc nofollow" target="_blank"> Create Index </a></li><li id="f408" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated"><a class="ae pi" href="https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/" rel="noopener ugc nofollow" target="_blank"> An in-depth look at Database Indexing </a></li><li id="a2f8" class="ot ou in kq b kr pc ku pd kx pe lb pf lf pg lj oy oz pa pb bi translated"><a class="ae pi" href="https://stormanning.medium.com/mysql-indexing-101-660f3193dde1" rel="noopener"> MySQL Indexing 101 </a></li></ol></div></div>    
</body>
</html>