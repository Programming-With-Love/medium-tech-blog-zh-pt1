<html>
<head>
<title>Effective Java in Kotlin, item 2: Consider a builder when faced with many constructor parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的有效Java，第2项:考虑一个面临许多构造函数参数的构建器</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-java-in-kotlin-item-2-consider-a-builder-when-faced-with-many-constructor-parameters-1927e69608e1?source=collection_archive---------0-----------------------#2018-04-04">https://blog.kotlin-academy.com/effective-java-in-kotlin-item-2-consider-a-builder-when-faced-with-many-constructor-parameters-1927e69608e1?source=collection_archive---------0-----------------------#2018-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f37f7abadc153e28e0e8f9a37c2ff2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGFArrrbKJy2rfjyXNNwdA.png"/></div></div></figure><div class=""/><p id="4142" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一条对Java程序员影响很大。当我们处理对象创建的不同变体时，这种情况并不少见。在有效的Java中提出的伟大论点使得开发人员使用构建器而不是伸缩构造器模式。虽然科特林改变了很多——它给了我们更好的可能性。我们很快就会看到它；)</p><p id="0d59" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是来自<em class="kt">有效Java版本2 </em>的第二条规则:</p><blockquote class="ku"><p id="40ef" class="kv kw iy bd kx ky kz la lb lc ld ks dk translated">当面对许多构造函数时，使用构造函数</p></blockquote><p id="4f21" class="pw-post-body-paragraph jv jw iy jx b jy le ka kb kc lf ke kf kg lg ki kj kk lh km kn ko li kq kr ks ig bi translated">让我们来探索一下。</p><h1 id="a679" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">书中的提醒</h1><p id="1cf7" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">在Java中，用可选的构造函数参数定义对象的一种常见方式是使用伸缩构造函数模式。当我们使用伸缩构造器模式时，我们为我们可以使用的每个集合或参数定义一个单独的构造器。这是科特林的一个例子:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="41d8" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">class </strong>Dialog <strong class="mr iz">constructor</strong>(<br/>        <strong class="mr iz">val title</strong>: String,<br/>        <strong class="mr iz">val text</strong>: String?,<br/>        <strong class="mr iz">val onAccept</strong>: (() -&gt; Unit)?<br/>) {<br/>    constructor(title: String, text: String)<br/>        : this(title, text, null)</span><span id="6343" class="mv lk iy mr b gy na mx l my mz">    constructor(title: String)<br/>        : this(title, "")<br/>}</span><span id="3c2d" class="mv lk iy mr b gy na mx l my mz">// Usage<br/><strong class="mr iz">val </strong>dialog1 = Dialog(<strong class="mr iz">"Some title"</strong>, <strong class="mr iz">"Great dialog",</strong> <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}</strong>)</span><span id="9f67" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">val </strong>dialog2 = Dialog(<strong class="mr iz">"Another dialog"</strong>,<strong class="mr iz">"I have no buttons"</strong>)</span><span id="a85a" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">val </strong>dialog3 = Dialog(<strong class="mr iz">"Dialog with just a title"</strong>)</span></pre><p id="ab67" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常流行的Android例子是<a class="ae nb" href="https://www.intertech.com/Blog/android-custom-view-tutorial-part-1-combining-existing-views/" rel="noopener ugc nofollow" target="_blank">我们如何定义自定义视图</a>。</p><p id="3691" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管这种模式在JVM世界中很流行，但Effective Java认为对于更大或更复杂的对象，我们应该使用Builder模式。Builder首先以可读和简洁的方式收集参数，然后验证和实例化对象。这里有一个例子:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a0b8" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">class </strong>Dialog <strong class="mr iz">private constructor</strong>(<br/>        <strong class="mr iz">val title</strong>: String,<br/>        <strong class="mr iz">val text</strong>: String?,<br/>        <strong class="mr iz">val onAccept</strong>: (() -&gt; Unit)?<br/>) {</span><span id="d2fb" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">class </strong>Builder(<strong class="mr iz">val title</strong>: String) {<br/>        <strong class="mr iz">var text</strong>: String? = <strong class="mr iz">null<br/>        var onAccept</strong>: (() -&gt; Unit)? = <strong class="mr iz">null</strong></span><span id="8120" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">        fun </strong>setText(text: String?): Builder {<br/>            <strong class="mr iz">this</strong>.<strong class="mr iz">text </strong>= text<br/>            <strong class="mr iz">return this<br/>        </strong>}</span><span id="e0f6" class="mv lk iy mr b gy na mx l my mz">        <strong class="mr iz">fun </strong>setOnAccept(onAccept: (() -&gt; Unit)?): Builder {<br/>            <strong class="mr iz">this</strong>.<strong class="mr iz">onAccept </strong>= onAccept<br/>            <strong class="mr iz">return this<br/>        </strong>}</span><span id="fe94" class="mv lk iy mr b gy na mx l my mz">        <strong class="mr iz">fun </strong>build() = Dialog(<strong class="mr iz">title</strong>, <strong class="mr iz">text</strong>, <strong class="mr iz">onAccept</strong>)<br/>    }<br/>}</span><span id="fac3" class="mv lk iy mr b gy na mx l my mz">// Usage<br/><strong class="mr iz">val </strong>dialog1 = Dialog.Builder(<strong class="mr iz">"Some title"</strong>)<br/>        .setText(<strong class="mr iz">"Great dialog"</strong>)<br/>        .setOnAccept <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}<br/>        </strong>.build()</span><span id="fa19" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">val </strong>dialog2 = Dialog.Builder(<strong class="mr iz">"Another dialog"</strong>)<br/>        .setText(<strong class="mr iz">"I have no buttons"</strong>)<br/>        .build()</span><span id="f9db" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">val </strong>dialog3 = Dialog.Builder(<strong class="mr iz">"Dialog with just a title"</strong>).build()</span></pre><p id="e2dd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">声明和用法都比伸缩构造器模式大，但是builder有非常重要的优势:</p><ul class=""><li id="7c94" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated">参数是显式的，所以我们在设置参数时可以看到每个参数的名称。</li><li id="3901" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">我们可以按任何顺序设置参数。</li><li id="a15b" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">它更容易修改，因为当我们需要改变伸缩构造函数模式中的一些参数时，我们需要在所有允许它的构造函数中改变它。</li><li id="59d9" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">具有填充值的构建器可以像工厂一样使用。</li></ul><p id="d633" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们需要设置可选参数时，这些特性使得构建器模式更加明确，更有弹性，更适合大多数类。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi nq"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="8ea1" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">命名可选参数</h1><p id="d40e" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">这一章中我最喜欢的部分，摘自《有效的Java》第二版，如下所示:</p><blockquote class="ku"><p id="c7c7" class="kv kw iy bd kx ky kz la lb lc ld ks dk translated">构建器模式模拟Ada和Python中的命名可选参数。</p></blockquote><p id="1411" class="pw-post-body-paragraph jv jw iy jx b jy le ka kb kc lf ke kf kg lg ki kj kk lh km kn ko li kq kr ks ig bi translated">在Kotlin中，我们不需要模拟指定的可选参数，因为我们可以直接使用它们。在大多数情况下，可选参数比构建器更好。只需比较上面的构建器模式和下面命名的可选参数。声明和用法都更简洁，更有表现力:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c4db" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">class </strong>Dialog(<br/>        <strong class="mr iz">val title</strong>: String,<br/>        <strong class="mr iz">val text</strong>: String? = <strong class="mr iz">null</strong>,<br/>        <strong class="mr iz">val onAccept</strong>: (() -&gt; Unit)? = <strong class="mr iz">null<br/></strong>)</span><span id="9707" class="mv lk iy mr b gy na mx l my mz">// Usage<strong class="mr iz"><br/>val </strong>dialog1 = Dialog(<br/>        title = <strong class="mr iz">"Some title"</strong>,<br/>        text = <strong class="mr iz">"Great dialog"</strong>,<br/>        onAccept = <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}<br/></strong>)<br/><strong class="mr iz">val </strong>dialog2 = Dialog(<br/>        title = <strong class="mr iz">"Another dialog"</strong>,<br/>        text = <strong class="mr iz">"I have no buttons"<br/></strong>)<br/><strong class="mr iz">val </strong>dialog3 = Dialog(title = <strong class="mr iz">"Dialog with just a title"</strong>)</span></pre><p id="5ac6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">带有命名可选参数的构造函数具有构建器模式的大部分优点:</p><ul class=""><li id="99db" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated">参数是显式的，所以我们在设置参数时会为每个参数设置一个名称。</li><li id="b672" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">我们可以按任何顺序设置参数。</li><li id="1b00" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">它更容易修改(甚至比构建器模式更容易)</li></ul><p id="e54c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个简单的例子中，带有命名可选参数的构造函数看起来更好。但是如果不同的参数需要不同的创建变量呢？假设我们为不同的参数集创建不同的对话框类型。我们可以在builder中轻松解决这个问题:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8082" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">interface </strong>Dialog {<br/>    <strong class="mr iz">fun </strong>show()</span><span id="bcab" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">class </strong>Builder(<strong class="mr iz">val title</strong>: String) {<br/>        <strong class="mr iz">var text</strong>: String? = <strong class="mr iz">null<br/>        var onAccept</strong>: (() -&gt; Unit)? = <strong class="mr iz">null</strong></span><span id="994b" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">        fun </strong>setText(text: String?): Builder {<br/>            <strong class="mr iz">this</strong>.<strong class="mr iz">text </strong>= text<br/>            <strong class="mr iz">return this<br/>        </strong>}</span><span id="1bf2" class="mv lk iy mr b gy na mx l my mz">        <strong class="mr iz">fun </strong>setOnAccept(onAccept: (() -&gt; Unit)?): Builder {<br/>            <strong class="mr iz">this</strong>.<strong class="mr iz">onAccept </strong>= onAccept<br/>            <strong class="mr iz">return this<br/>        </strong>}</span><span id="dbc8" class="mv lk iy mr b gy na mx l my mz">        <strong class="mr iz">fun </strong>build(): Dialog = <strong class="mr iz">when </strong>{<br/>            <strong class="mr iz">text </strong>!= <strong class="mr iz">null </strong>&amp;&amp; <strong class="mr iz">onAccept </strong>!= <strong class="mr iz">null </strong>-&gt;<br/>                TitleTextAcceptationDialog(<strong class="mr iz">title</strong>, <strong class="mr iz">text</strong>!!, <strong class="mr iz">onAccept</strong>!!)<br/>            <strong class="mr iz">text </strong>!= <strong class="mr iz">null </strong>-&gt;<br/>                TitleTextDialog(<strong class="mr iz">title</strong>, <strong class="mr iz">text</strong>!!)<br/>            <strong class="mr iz">onAccept </strong>!= <strong class="mr iz">null </strong>-&gt;<br/>                TitleAcceptationDialog(<strong class="mr iz">title</strong>, <strong class="mr iz">onAccept</strong>!!)<br/>            <strong class="mr iz">else </strong>-&gt; TitleDialog(<strong class="mr iz">title</strong>)<br/>        }<br/>    }<br/>}</span><span id="d82f" class="mv lk iy mr b gy na mx l my mz"><em class="kt">// Usage<br/></em><strong class="mr iz">val </strong><em class="kt">dialog1 </em>= Dialog.Builder(<strong class="mr iz">"Some title"</strong>)<br/>        .setText(<strong class="mr iz">"Great dialog"</strong>)<br/>        .setOnAccept <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}<br/>        </strong>.build()<br/><strong class="mr iz">val </strong><em class="kt">dialog2 </em>= Dialog.Builder(<strong class="mr iz">"Another dialog"</strong>)<br/>        .setText(<strong class="mr iz">"I have no buttons"</strong>)<br/>        .build()<br/><strong class="mr iz">val </strong><em class="kt">dialog3 </em>= Dialog.Builder(<strong class="mr iz">"Dialog with just a title"</strong>).build()</span></pre><p id="4864" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们能使用命名的可选参数解决这类问题吗？是的，我们可以使用不同的构造函数或者使用工厂方法来达到相同的效果！以下是上述问题的示例解决方案:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e307" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">interface </strong>Dialog {<br/>    <strong class="mr iz">fun </strong>show()<br/>}</span><span id="8caf" class="mv lk iy mr b gy na mx l my mz"><strong class="mr iz">fun </strong>makeDialog(<br/>    title: String, <br/>    text: String? = <strong class="mr iz">null</strong>, <br/>    onAccept: (() -&gt; Unit)?<br/>): Dialog = <strong class="mr iz">when </strong>{<br/>    text != <strong class="mr iz">null </strong>&amp;&amp; onAccept != <strong class="mr iz">null </strong>-&gt; <br/>        TitleTextAcceptationDialog(title, text, onAccept)<br/>    text != <strong class="mr iz">null </strong>-&gt; <br/>        TitleTextDialog(title, text)<br/>    onAccept != <strong class="mr iz">null </strong>-&gt; <br/>        TitleAcceptationDialog(title, onAccept)<br/>    <strong class="mr iz">else </strong>-&gt; <br/>        TitleDialog(title)<br/>}</span><span id="6ff1" class="mv lk iy mr b gy na mx l my mz">// Usage<br/><strong class="mr iz">val </strong>dialog1 = makeDialog(<br/>        title = <strong class="mr iz">"Some title"</strong>,<br/>        text = <strong class="mr iz">"Great dialog"</strong>,<br/>        onAccept = <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}<br/></strong>)<br/><strong class="mr iz">val </strong>dialog2 = makeDialog(<br/>        title = <strong class="mr iz">"Another dialog"</strong>,<br/>        text = <strong class="mr iz">"I have no buttons"<br/></strong>)<br/><strong class="mr iz">val </strong>dialog3 = makeDialog(title = <strong class="mr iz">"Dialog with just a title"</strong>)</span></pre><p id="1e75" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们的另一个例子，我们再次看到命名参数优于构建器:</p><ul class=""><li id="7bc6" class="nc nd iy jx b jy jz kc kd kg ne kk nf ko ng ks nh ni nj nk bi translated">它更短——构造器或工厂方法比构建器模式更容易实现。我们不需要将每个可选参数的名称指定4次(作为属性、方法、参数和构造函数的名称)。类型不需要声明3次(在参数、属性和构造函数中)。这很重要，因为当我们想改变一些参数名时，我们只改变工厂方法中的一个声明，而不是改变4个假设相同的名字。</li><li id="89b0" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">更简洁——当你想知道一个对象是如何构造的，你只需要一个方法，而不是分散在整个构建器类中。物体是如何保持的？他们互动吗？当我们有大建筑商时，这些问题就不那么容易回答了。另一方面，类的创建通常在工厂方法上是清楚的。</li><li id="4b15" class="nc nd iy jx b jy nl kc nm kg nn kk no ko np ks nh ni nj nk bi translated">并发没有问题——这是一个罕见的问题，但是在Kotlin中函数参数总是不可变的，而在大多数构建器中属性是可变的。因此，对于构建器来说，实现线程安全的构建函数更加困难。</li></ul><p id="4b94" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建器模式的一个优点是带有填充参数的构建器可以作为工厂使用。虽然这是罕见的用法，所以这个优点是次要的。</p><p id="b765" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建器模式的另一个论点是，我们可以部分填充构建器，并进一步传递它。这样我们就可以定义方法来创建部分填充的构建器，我们仍然可以修改它(就像我们应用程序的默认对话框)。为了让构造函数或工厂方法具有类似的可能性，我们需要自动转换(在Kotlin中是可能的，但不会丢失名称和默认参数)。尽管这种对象创建方式非常罕见，并且通常也不是首选方式。如果我们想为应用程序定义默认对话框，我们可以使用函数创建它，并将所有定制元素作为可选参数传递。这种方法将对对话创建有更多的控制。</p><p id="431e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般规则是，在大多数情况下，命名的可选参数应该优先于生成器模式。虽然这不是Kotlin给我们的唯一的新的构建模式。另一个非常流行的是用于对象构造的DSL。我们来描述一下。</p><h1 id="fddb" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">用于对象构造的DSL</h1><p id="5aea" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">假设我们需要设置具有多个处理程序的侦听器。典型的类似Java的方法是使用对象表达式:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5901" class="mv lk iy mr b gy mw mx l my mz">taskNameView.addTextChangedListener(<strong class="mr iz">object </strong>: TextWatcher {<br/>    <strong class="mr iz">override fun </strong>afterTextChanged(s: Editable?) {<br/>        <em class="kt">// ...<br/>    </em>}</span><span id="7052" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">override fun </strong>beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {<br/>        <em class="kt">// ...<br/>    </em>}</span><span id="65a2" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">override fun </strong>onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {<br/>        <em class="kt">// no-op<br/>    </em>}<br/>})</span></pre><p id="90ef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法实际上并不方便，可以很容易地用更简洁的工厂方法替换，该方法带有指定的可选参数:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="38ff" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">fun </strong>makeTextWatcher(<br/>        afterTextChanged: ((s: Editable?) -&gt; Unit)? = <strong class="mr iz">null</strong>,<br/>        beforeTextChanged: ((s: CharSequence?, start: Int, count: Int, after: Int) -&gt; Unit)? = <strong class="mr iz">null</strong>,<br/>        onTextChanged: ((s: CharSequence?, start: Int, before: Int, count: Int) -&gt; Unit)? = <strong class="mr iz">null<br/></strong>) = <strong class="mr iz">object </strong>: TextWatcher {<br/>    <strong class="mr iz">override fun </strong>afterTextChanged(s: Editable?) {<br/>        afterTextChanged?.invoke(s)<br/>    }</span><span id="c714" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">override fun </strong>beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {<br/>        beforeTextChanged?.invoke(s, start, count, after)<br/>    }</span><span id="c6b9" class="mv lk iy mr b gy na mx l my mz">    <strong class="mr iz">override fun </strong>onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {<br/>        onTextChanged?.invoke(s, start, before, count)<br/>    }<br/>}</span><span id="7365" class="mv lk iy mr b gy na mx l my mz">// Usage<br/>taskNameView.addTextChangedListener(makeTextWatcher(<br/>        afterTextChanged = <strong class="mr iz">{ </strong>s <strong class="mr iz">-&gt;<br/>            </strong><em class="kt">// ..<br/>        </em><strong class="mr iz">}</strong>,<br/>        beforeTextChanged = <strong class="mr iz">{ </strong>s, start, count, after <strong class="mr iz">-&gt;<br/>            </strong><em class="kt">// ...<br/>        </em><strong class="mr iz">}<br/></strong>))</span></pre><p id="3cae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，我们可以很容易地改进它，直接定义一个扩展函数给<code class="fe nr ns nt mr b">TextView</code>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7f27" class="mv lk iy mr b gy mw mx l my mz">taskNameView.addTextChangedListener(<br/>    afterTextChanged = <strong class="mr iz">{ </strong>s <strong class="mr iz">-&gt;<br/>       </strong><em class="kt">// ..<br/>    </em><strong class="mr iz">}</strong>,<br/>    beforeTextChanged = <strong class="mr iz">{ </strong>s, start, count, after <strong class="mr iz">-&gt;<br/>       </strong><em class="kt">// ...<br/>    </em><strong class="mr iz">}<br/></strong>)</span></pre><p id="75bd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管我们可以进一步改进这种模式，并允许以下符号:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0807" class="mv lk iy mr b gy mw mx l my mz">taskNameView.addTextChangedListener <strong class="mr iz">{</strong><br/>    setAfterTextChanged <strong class="mr iz">{ </strong>s <strong class="mr iz">-&gt;<br/>       </strong><em class="kt">// ..<br/>    </em><strong class="mr iz">}</strong>,<br/>    setBeforeTextChanged <strong class="mr iz">{ </strong>s, start, count, after <strong class="mr iz">-&gt;<br/>       </strong><em class="kt">// ...<br/>    </em><strong class="mr iz">}<br/>}</strong></span></pre><p id="5eba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是DSL的一个简单例子。支持这种符号的函数可以在流行的Kotlin库中找到，比如<a class="ae nb" href="https://github.com/Kotlin/anko" rel="noopener ugc nofollow" target="_blank"> Anko </a>或<a class="ae nb" href="https://github.com/android/android-ktx" rel="noopener ugc nofollow" target="_blank"> Android-ktx </a>。例如，这就是我们如何在<a class="ae nb" href="https://github.com/Kotlin/anko" rel="noopener ugc nofollow" target="_blank"> Anko </a>中定义和显示警告对话框:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3560" class="mv lk iy mr b gy mw mx l my mz">alert("Hi, I'm Roy", "Have you tried turning it off and on again?"){<br/>    yesButton { toast("Oh…") }<br/>    noButton {}<br/>}.show()</span></pre><p id="64e7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是这种符号需要大量的声明来支持它们。这就是我们如何定义上面的<code class="fe nr ns nt mr b">addOnTextChangedListener</code>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5e48" class="mv lk iy mr b gy mw mx l my mz">fun TextView.addOnTextChangedListener(<br/>    config: TextWatcherConfiguration.() -&gt; Unit<br/>) {<br/>    val listener = TextWatcherConfiguration().apply { config() }<br/>    addTextChangedListener(listener)<br/>}</span><span id="1a49" class="mv lk iy mr b gy na mx l my mz">class TextWatcherConfiguration : TextWatcher {</span><span id="ba92" class="mv lk iy mr b gy na mx l my mz">    private var beforeTextChangedCallback: (BeforeTextChangedFunction)? = null<br/>    private var onTextChangedCallback: (OnTextChangedFunction)? = null<br/>    private var afterTextChangedCallback: (AfterTextChangedFunction)? = null</span><span id="c2ac" class="mv lk iy mr b gy na mx l my mz">    fun beforeTextChanged(callback: BeforeTextChangedFunction) {<br/>       beforeTextChangedCallback = callback<br/>    }</span><span id="e621" class="mv lk iy mr b gy na mx l my mz">    fun onTextChanged(callback: OnTextChangedFunction) {<br/>        onTextChangedCallback = callback<br/>    }</span><span id="2d5a" class="mv lk iy mr b gy na mx l my mz">    fun afterTextChanged(callback: AfterTextChangedFunction) {<br/>        afterTextChangedCallback = callback<br/>    }</span><span id="742e" class="mv lk iy mr b gy na mx l my mz">    override fun beforeTextChanged(<br/>        s: CharSequence, <br/>        start: Int, <br/>        count: Int, <br/>        after: Int<br/>    ) {<br/>        beforeTextChangedCallback?.invoke(s.toString(), start, count, after)<br/>    }</span><span id="bda4" class="mv lk iy mr b gy na mx l my mz">    override fun onTextChanged(<br/>         s: CharSequence, <br/>         start: Int, <br/>         before: Int, <br/>         count: Int<br/>    ) {<br/>        onTextChangedCallback?.invoke(s.toString(), start, before, count)<br/>    }</span><span id="d0b2" class="mv lk iy mr b gy na mx l my mz">    override fun afterTextChanged(s: Editable) {<br/>        afterTextChangedCallback?.invoke(s)<br/>    }<br/>}</span><span id="e149" class="mv lk iy mr b gy na mx l my mz">private typealias BeforeTextChangedFunction = <br/>    (text: String, start: Int, count: Int, after: Int) -&gt; Unit<br/>private typealias OnTextChangedFunction = <br/>    (text: String, start: Int, before: Int, count: Int) -&gt; Unit<br/>private typealias AfterTextChangedFunction = <br/>    (s: Editable) -&gt; Unit</span></pre><p id="e2fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为单一甚至两种用途作出这样的声明是不合理的。另一方面，当我们制作一个库时，这不是一个问题。这就是为什么在大多数情况下我们使用库中定义的DSL的原因。当我们定义它们时，它们是非常强大的。注意，在DSL内部，我们可以包含控制结构(<code class="fe nr ns nt mr b">if</code>、<code class="fe nr ns nt mr b">for</code>等)。)，定义变量等。这是一个使用DSL为<a class="ae nb" href="https://github.com/MarcinMoskala/KotlinAcademyApp" rel="noopener ugc nofollow" target="_blank"> Kt生成HTML的例子。学院门户</a>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8e0c" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">private fun </strong>RDOMBuilder&lt;DIV&gt;.authorDiv(<br/>    author: String?, <br/>    authorUrl: String?<br/>) {<br/>    author ?: <strong class="mr iz">return<br/>    </strong><em class="kt">div</em>(classes = <strong class="mr iz">"main-text multiline space-top"</strong>) <strong class="mr iz">{<br/>        </strong>+<strong class="mr iz">"Author: "<br/>        if </strong>(authorUrl.<em class="kt">isNullOrBlank</em>()) {<br/>            +author<br/>        } <strong class="mr iz">else </strong>{<br/>            <em class="kt">a</em>(href = authorUrl) <strong class="mr iz">{ </strong>+author <strong class="mr iz">}<br/>        </strong>}<br/>    <strong class="mr iz">}<br/></strong>}</span></pre><p id="2d5f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了声明之外，我们还在那里放置了指定如何定义这个元素的逻辑。这样，DSL通常比带有指定可选参数的构造函数或工厂方法更强大。它也更复杂，更难定义。</p><h1 id="e78d" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">当我们已经有了构建器时，简单的DSL</h1><p id="ea7f" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">在一些Android项目中可以观察到有趣的解决方案，其中开发人员实现了简化的DSL，重用了现有的构建器。</p><p id="3c27" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们使用来自提供builder作为创建方法的库(或框架)的对话框(假设它是用Java实现的):</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d22a" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">val </strong><em class="kt">dialog1 </em>= Dialog.Builder(<strong class="mr iz">"Some title"</strong>)<br/>        .setText(<strong class="mr iz">"Great dialog"</strong>)<br/>        .setOnAccept <strong class="mr iz">{ </strong>toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}<br/>        </strong>.build()</span></pre><p id="0cbc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们如何实现和使用非常简单的DSL构建器:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d53e" class="mv lk iy mr b gy mw mx l my mz"><strong class="mr iz">fun </strong>Dialog(title: String, init: Dialog.Builder.()-&gt;Unit) = <br/>    Dialog.Builder(title).apply(init).build()</span><span id="2c40" class="mv lk iy mr b gy na mx l my mz">// Usage<strong class="mr iz"><br/>val</strong> dialog1 = Dialog(<strong class="mr iz">"Some title"</strong>) {<br/>     text = <strong class="mr iz">"Great dialog"</strong><br/>     setOnAccept <strong class="mr iz">{</strong> toast(<strong class="mr iz">"I was clicked"</strong>) <strong class="mr iz">}</strong><br/>}</span></pre><p id="4cc8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(只有在Java中定义了这个方法，我们才能像属性一样设置<code class="fe nr ns nt mr b">text</code>。)</p><p id="61d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样我们就拥有了DSL的大部分优势和非常简单的声明。这也显示了DSL和builder模式有多少共同点。他们有相似的哲学，但是DSL就像是构建模式的下一个层次。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><a href="https://kt.academy/Android_Online_May.html"><div class="gh gi nq"><img src="../Images/87c508a2627eaa3d0e472518952dc75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoIe6R-7DJyXGh8tYeqjA.jpeg"/></div></a></figure><h1 id="bbf2" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="7fde" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">来自有效Java的参数在Kotlin中仍然有效，builder模式比以前的Java替代方案更合理。尽管Kotlin引入了通过名称指定参数并提供默认参数。由于这一点，我们有了更好的替代模式。Kotlin还提供了允许使用DSL的特性。定义良好的DSL甚至是更好的选择，因为它提供了更大的灵活性，并允许在对象定义中包含逻辑。</p><p id="fea1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义如何创建复杂的对象并不是一个简单的问题，它通常需要经验。虽然科特林给我们的可能性非常重要，它们积极地影响着科特林的发展。</p><h1 id="e2fc" class="lj lk iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">有效科特林</h1><p id="2643" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">这是第一篇关于有效科特林的文章。当我们看到兴趣，我们将出版下一部分。在Kot。学院我们也在研究关于这个主题的书:</p><div class="im in gp gr io nu"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iz gy z fp nz fr fs oa fu fw ix bi translated">有效科特林</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">这本书对官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">leanpub.com</p></div></div><div class="od l"><div class="oe l of og oh od oi iu nu"/></div></div></a></div><p id="e8fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并使我们更快地发布它，<a class="ae nb" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用此链接并订阅</a>。</p></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="1a80" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae nb" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="95a3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae nb" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae nb" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Twitter上引用我，用<a class="ae nb" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。</p><p id="5ae5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要感谢<a class="ae nb" href="https://twitter.com/orangy" rel="noopener ugc nofollow" target="_blank"> Ilya Ryzhenkov </a>的更正和重要建议。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi oq"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx iz">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p></div></div>    
</body>
</html>