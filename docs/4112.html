<html>
<head>
<title>You don’t have to use WeakReference to avoid memory leaks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您不必使用WeakReference来避免内存泄漏</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/weakreference-in-android-dd1e66b9be9d?source=collection_archive---------3-----------------------#2016-11-28">https://medium.com/google-developer-experts/weakreference-in-android-dd1e66b9be9d?source=collection_archive---------3-----------------------#2016-11-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/10cd373cc5bcc9422523da9656e198c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ndDeOO1vX68iWjjiBXZaQ.jpeg"/></div></div></figure><p id="b58c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我的一位同事最近提到，他们看到一个演示文稿说:</p><blockquote class="jo jp jq"><p id="2ac3" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn ha bi translated">如果你是一个Android开发者，并且不使用WeakReferences，那你就有问题了。</p></blockquote><p id="9d4d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我个人认为，这不仅是一个错误的论点，而且完全是误导。WeakReference应该是修复内存泄漏的最后手段。</p><p id="edb4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然后今天，我在谷歌开发者专家出版物上看到了由<a class="jv jw ge" href="https://medium.com/u/f08187f6a023?source=post_page-----dd1e66b9be9d--------------------------------" rel="noopener" target="_blank">Enrique lópez Maas</a>写的帖子</p><div class="jx jy ez fb jz ka"><a rel="noopener follow" target="_blank" href="/google-developer-experts/finally-understanding-how-references-work-in-android-and-java-26a0d9c92f83"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hi fi z dy kf ea eb kg ed ef hg bi translated">最终理解引用在Android和Java中是如何工作的</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">几周前，我参加了Mobiconf，这是我有幸参加的最好的移动开发者大会之一…</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">medium.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko io ka"/></div></div></a></div><p id="b793" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是一篇很好的文章，用例子总结了引用在Java中是如何工作的。</p><p id="faab" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这篇文章没有说我们必须使用<em class="jr"> WeakReference </em>，但也没有给出任何替代方案。我觉得我必须给出替代方案，以表明使用<em class="jr"> WeakReference并不是<strong class="is hi">必须</strong>的。</em></p><h2 id="3e13" class="kp kq hh bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj bi translated">如果你不使用WeakReference，你真的不会有任何问题。</h2><p id="ce48" class="pw-post-body-paragraph iq ir hh is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn ha bi translated">我认为，在所有可能的地方使用<em class="jr"> WeakReference </em>并不是最佳做法。使用<em class="jr"> WeakReference </em>来修复内存泄漏表明缺乏建模或架构。</p><p id="db59" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">尽管本文中给出的示例修复了潜在的内存泄漏，但是还有其他方法。我想给出几个实现的例子来避免当你有一个长时间运行的后台任务时的内存泄漏。</p><p id="bc9d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">使用<em class="jr"> AsyncTask </em>来避免内存泄漏的一个简单示例如下:</p><p id="fc11" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下面是我的<em class="jr">活动:</em></p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="81b9" class="kp kq hh lu b fi ly lz l ma mb">public class MainActivity extends Activity {</span><span id="cefd" class="kp kq hh lu b fi mc lz l ma mb">  private MyAsyncTask task;</span><span id="bfb5" class="kp kq hh lu b fi mc lz l ma mb">  @Override<br/>  protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    task = new MyAsyncTask();<br/>    task.setListener(createListener());<br/>    task.execute();<br/>  }</span><span id="b52e" class="kp kq hh lu b fi mc lz l ma mb">  @Override<br/>  protected void onDestroy() {<br/>    task.setListener(null);<br/>    super.onDestroy();<br/>  }</span><span id="1428" class="kp kq hh lu b fi mc lz l ma mb">  private MyAsyncTask.Listener createListener() {<br/>    return new MyAsyncTask.Listener() {</span><span id="fb56" class="kp kq hh lu b fi mc lz l ma mb">      @Override<br/>      public void onSuccess(Object object) {<br/>        // adapt contents<br/>      }<br/>    };<br/>  }<br/>}</span></pre><p id="e5d3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里是<em class="jr"> AsyncTask: </em></p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="4854" class="kp kq hh lu b fi ly lz l ma mb">class MyAsyncTask extends AsyncTask {</span><span id="eb04" class="kp kq hh lu b fi mc lz l ma mb">  private Listener listener;</span><span id="ae92" class="kp kq hh lu b fi mc lz l ma mb">  @Override<br/>  protected Object doInBackground(Object[] params) {<br/>    return doSomeStuff();<br/>  }</span><span id="fe07" class="kp kq hh lu b fi mc lz l ma mb">  private Object doSomeStuff() {<br/>    //do something to get result<br/>    return new Object();<br/>  }</span><span id="c9a5" class="kp kq hh lu b fi mc lz l ma mb">  @Override<br/>  protected void onPostExecute(Object object) {<br/>    if (listener != null) {<br/>      listener.onSuccess(object);<br/>    }<br/>  }</span><span id="46ce" class="kp kq hh lu b fi mc lz l ma mb">  public void setListener(Listener listener) {<br/>    this.listener = listener;<br/>  }</span><span id="b604" class="kp kq hh lu b fi mc lz l ma mb">  interface Listener {<br/>    void onSuccess(Object object);<br/>  }<br/>}</span></pre><p id="4d2f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这种实现当然是非常基本的，但我认为它足以展示另一种解决方案。</p></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="452e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里是另一个非常简单的RxJava实现，我们仍然没有WeakReference。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="c2e5" class="kp kq hh lu b fi ly lz l ma mb">public class MainActivity extends Activity {<br/><br/>  private Subscription subscription;<br/><br/>  @Override<br/>  protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/><br/>    subscription = Observable<br/>        .<em class="jr">fromCallable</em>(new Callable&lt;Object&gt;() {<br/>          @Override<br/>          public Object call() throws Exception {<br/>            return doSomeStuff();<br/>          }<br/>        })<br/>        .subscribeOn(Schedulers.<em class="jr">io</em>())<br/>        .observeOn(AndroidSchedulers.<em class="jr">mainThread</em>())<br/>        .subscribe(new Action1&lt;Object&gt;() {<br/>          @Override<br/>          public void call(Object o) {<br/>            // adapt contents<br/>          }<br/>        });<br/>  }<br/><br/>  private Object doSomeStuff() {<br/>    //do something to get result<br/>    return new Object();<br/>  }<br/><br/>  @Override<br/>  protected void onDestroy() {<br/>    subscription.unsubscribe();<br/>    super.onDestroy();<br/>  }<br/><br/>}</span></pre><p id="c84a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">请注意，如果我们不从<em class="jr">订阅中<em class="jr">取消</em>订阅，我们可能仍然会有内存泄漏。</em></p></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="4d53" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最后，我想举几个诺沃达的例子。它们是很好的学习资源。你可以猜到，他们没有任何<em class="jr"> WeakReference :) </em></p><div class="jx jy ez fb jz ka"><a href="https://github.com/novoda/bonfire-firebase-sample/" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hi fi z dy kf ea eb kg ed ef hg bi translated">诺沃达/篝火-燃烧基地-样本</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">一个讨论你最喜欢的表情符号的应用。这是一个用Firebase构建的示例应用程序。</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">github.com</p></div></div><div class="kj l"><div class="mk l kl km kn kj ko io ka"/></div></div></a></div><div class="jx jy ez fb jz ka"><a href="https://github.com/novoda/spikes/tree/master/Architecture/TodoApp/android" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hi fi z dy kf ea eb kg ed ef hg bi translated">诺沃达/斯派克</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">尖峰——想法和概念诞生和孵化的地方</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">github.com</p></div></div><div class="kj l"><div class="ml l kl km kn kj ko io ka"/></div></div></a></div></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="a885" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我相信经验法则(对我来说)是，如果类<strong class="is hi">是内部类，就让它们成为静态的</strong>。尤其是在后台长时间运行时。更好的是，我们可以将这些类移动到一个完整的类中。</p><p id="0dcb" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对长时间运行的操作使用非静态内部类总是不好的做法，不仅仅是在<em class="jr"> Android </em>中。</p></div></div>    
</body>
</html>