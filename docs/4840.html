<html>
<head>
<title>Effective Kotlin: Consider Arrays with primitives for performance critical processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Effective Kotlin:考虑使用具有原语的数组进行性能关键处理</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-kotlin-use-arrays-with-primitives-for-performance-critical-processing-297283ed1f90?source=collection_archive---------0-----------------------#2018-04-30">https://blog.kotlin-academy.com/effective-kotlin-use-arrays-with-primitives-for-performance-critical-processing-297283ed1f90?source=collection_archive---------0-----------------------#2018-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/a94b35ed8ccdbcf36e8b35935ef9d622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyb6KUiygbx-n-Gg4tkjxw.jpeg"/></div></div></figure><div class=""/><p id="9b70" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">科特林在幕后非常聪明。我们不能在Kotlin中声明原语，但是当我们不使用像对象这样的变量时，它们会被使用。例如，看下面的例子:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f410" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">var </strong>i = 10<br/>i = i * 2<br/><em class="li">println</em>(i)</span></pre><p id="a7a9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个声明使用了原语<code class="fe lj lk ll ky b">int</code>。这是它在Java中的表示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7997" class="lc ld iy ky b gy le lf l lg lh">// Java<strong class="ky iz"><br/>int </strong>i = 10;<br/>i = i * 2;<br/>System.<strong class="ky iz"><em class="li">out</em></strong>.println(i);</span></pre><p id="ed81" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个实现比使用<code class="fe lj lk ll ky b">Integer</code>的实现快多少？我们去看看。我们需要在Java中定义这两种方式:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6c02" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">public class </strong>PrimitivesJavaBenchmark {<br/><br/>    <strong class="ky iz">public int </strong>primitiveCount() {<br/>        <strong class="ky iz">int </strong>a = 1;<br/>        <strong class="ky iz">for </strong>(<strong class="ky iz">int </strong>i = 0; i &lt; 1_000_000; i++) {<br/>            a = a + i * 2;<br/>        }<br/>        <strong class="ky iz">return </strong>a;<br/>    }<br/><br/>    <strong class="ky iz">public </strong>Integer objectCount() {<br/>        Integer a = 1;<br/>        <strong class="ky iz">for </strong>(Integer i = 0; i &lt; 1_000_000; i++) {<br/>            a = a + i * 2;<br/>        }<br/>        <strong class="ky iz">return </strong>a;<br/>    }<br/>}</span></pre><p id="26b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您测量这两种方法的性能时，您会注意到一个巨大的差异。在我的机器中，使用<code class="fe lj lk ll ky b">Integer</code>的需要<em class="li"> 4 905 603 </em> ns，而使用原语的需要<em class="li"> 316 594 </em> ns ( <a class="ae lm" href="https://github.com/MarcinMoskala/effective-kotlin-tests/blob/master/src/main/java/org/kotlinacademy/PrimitivesJavaBenchmark.java" rel="noopener ugc nofollow" target="_blank">自己检查</a>)。这就少了15倍！这是一个巨大的差异！</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0e127b4573260b68db41e2eab634b7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXHBLO8pAQMgS1enWhWCCQ.jpeg"/></div></div></figure><p id="5847" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们怎么可能有这样的差异？图元比对象轻得多。它们只是内存中的一个数字。他们不需要OOP周围的一切。当你看到这种差异时，你应该感谢Kotlin尽可能使用原语，我们甚至不需要意识到这一点。尽管您应该知道有些事情会阻止编译器使用原语:</p><ul class=""><li id="c237" class="ln lo iy jx b jy jz kc kd kg lp kk lq ko lr ks ls lt lu lv bi translated">可空类型不能是基元。编译器是聪明的，当它致力于你不设置null时，它就使用原语。如果它不确定，那么它需要使用非原始类型。请记住，在代码的性能关键部分，这是可空性的额外成本。</li><li id="cf62" class="ln lo iy jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">基元不能用作泛型类型参数。</li></ul><p id="a0d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个问题尤其重要，因为我们很少有只处理数字的代码的性能关键部分，但我们经常有一个处理元素集合的部分。这是一个问题，因为每个泛型集合都使用非基元类型。例如:</p><ul class=""><li id="d904" class="ln lo iy jx b jy jz kc kd kg lp kk lq ko lr ks ls lt lu lv bi translated"><code class="fe lj lk ll ky b">List&lt;Int&gt;</code>相当于Java <code class="fe lj lk ll ky b">List&lt;Integer&gt;</code></li><li id="0b27" class="ln lo iy jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated"><code class="fe lj lk ll ky b">Set&lt;Double&gt;</code>相当于Java <code class="fe lj lk ll ky b">Set&lt;Double&gt;</code></li></ul><p id="401e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们需要对数字列表进行操作时，这个事实是一个很大的成本。虽然也有解决办法。有一个Java集合允许原语。那是什么？数组！</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="29cb" class="lc ld iy ky b gy le lf l lg lh">// Java<strong class="ky iz"><br/>int</strong>[] <strong class="ky iz">a </strong>= { 1,2,3,4 };</span></pre><p id="9486" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果在Java中可以使用带原语的数组，那么在Kotlin中也是可以的。为此，我们需要使用一种特殊的数组类型，用不同的原语来表示数组:<code class="fe lj lk ll ky b">IntArray</code>、<code class="fe lj lk ll ky b">LongArray</code>、<code class="fe lj lk ll ky b">ShortArray</code>、<code class="fe lj lk ll ky b">DoubleArray</code>、<code class="fe lj lk ll ky b">FloatArray</code>或<code class="fe lj lk ll ky b">CharArray</code>。让我们使用<code class="fe lj lk ll ky b">IntArray</code>并对比<code class="fe lj lk ll ky b">List&lt;Int&gt;</code>来看看对代码的影响:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="239c" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">open class </strong>InlineFilterBenchmark {<br/><br/>    <strong class="ky iz">lateinit var list</strong>: List&lt;Int&gt;<br/>    <strong class="ky iz">lateinit var array</strong>: IntArray<br/><br/>    @Setup<br/>    <strong class="ky iz">fun </strong>init() {<br/>        <strong class="ky iz">list </strong>= <em class="li">List</em>(1_000_000) <strong class="ky iz">{ it }<br/>        array </strong>= IntArray(1_000_000) <strong class="ky iz">{ it }<br/>    </strong>}<br/><br/><em class="li">    </em>@Benchmark<br/>    <strong class="ky iz">fun </strong>averageOnIntList(): Double {<br/>        <strong class="ky iz">return list</strong>.<em class="li">average</em>()<br/>    }<br/><br/><em class="li">    </em>@Benchmark<br/>    <strong class="ky iz">fun </strong>averageOnIntArray(): Double {<br/>        <strong class="ky iz">return array</strong>.<em class="li">average</em>()<br/>    }<br/>}</span></pre><p id="01c7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差别不是那么壮观，但总是看得见。例如，<code class="fe lj lk ll ky b">average</code>函数快了大约25%，这要归功于在幕后使用了原语(<a class="ae lm" href="https://github.com/MarcinMoskala/effective-kotlin-tests/blob/master/src/main/kotlin/org/kotlinacademy/PrimitiveArraysBenchmark.kt" rel="noopener ugc nofollow" target="_blank">自己看看</a>)。</p><p id="6eda" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具有原语的数组也比集合更轻。当你进行测量时，你会发现上面的<code class="fe lj lk ll ky b">IntArray</code> <em class="li"> </em>分配了400 000 016字节，而<code class="fe lj lk ll ky b">List&lt;Int&gt;</code>分配了2 000 006 944字节。是5倍多！</p><p id="72f7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，原语和带原语的数组可以用作代码中性能关键部分的优化。它们分配的内存更少，处理速度更快。尽管在大多数情况下，改进并不显著，不足以在默认情况下使用具有原语的数组来代替列表。列表更直观，也更常用，所以在大多数情况下我们应该使用列表。但是您应该记住这种优化，以防您需要优化一些性能关键部分。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mb"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="080d" class="mc ld iy bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">有效科特林</h1><p id="2643" class="pw-post-body-paragraph jv jw iy jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">这是关于有效科特林的第二篇文章。当我们看到有兴趣时，我们会发表下一部分，所以如果你想知道更多关于这个主题的内容，请让我们知道这篇文章。在卡帕头。学院我们也在研究关于这个主题的书:</p><div class="im in gp gr io ne"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iz gy z fp nj fr fs nk fu fw ix bi translated">有效科特林</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">这本书对好的实践进行了深入的分析，包括官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">leanpub.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns iu ne"/></div></div></a></div><p id="ebcc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并使我们更快地发布它，<a class="ae lm" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用此链接并订阅</a>。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="ed97" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？请访问我们的网站，看看我们能为您做些什么。</p><p id="ccff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae lm" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae lm" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在Twitter上引用我，请使用<a class="ae lm" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。使用以下链接订阅时事通讯:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi oa"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="4cad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx iz">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p></div></div>    
</body>
</html>