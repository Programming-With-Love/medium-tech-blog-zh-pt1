<html>
<head>
<title>iOS Bites — An Intro to Combine and the Reactive Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS Bites —组合和反应模式简介</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/ios-bites-an-intro-to-combine-and-the-reactive-pattern-24da924a6863?source=collection_archive---------1-----------------------#2020-01-15">https://medium.com/capital-one-tech/ios-bites-an-intro-to-combine-and-the-reactive-pattern-24da924a6863?source=collection_archive---------1-----------------------#2020-01-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/94342d6d103d0fb2ad88fb37b5e59fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mHyJ6OpaiZ8WahEk"/></div></div></figure><p id="da2b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你听说过深潜吗？iOS Bites是对iOS开发中的新概念和新方法的一系列简短探索</p><p id="2ab1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在今年由苹果主办的全球开发者大会上，一个为iOS开发者展示最新新兴技术的活动，我们许多人都对苹果向世界宣布他们的新<a class="ae jo" href="https://developer.apple.com/documentation/combine/" rel="noopener ugc nofollow" target="_blank">组合</a>框架感到惊讶。在此之前，苹果一直提倡在他们平台的应用程序开发中使用<a class="ae jo" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC模式</a>。现在他们似乎抛弃了这一点，代之以通常所说的<a class="ae jo" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应模式</a>。苹果是否用这种新的未经证实的模式取代了他们屡试不爽的编写应用程序的方式？</p><p id="10b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实上，没有什么比这更偏离事实了。反应模式是<a class="ae jo" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>和<a class="ae jo" href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank">迭代器模式</a>的组合，在<a class="ae jo" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>的良好帮助下，事情变得不那么冗长。自从SDK首次公开发布以来，观察者模式和迭代器都是iOS核心库的一部分。随着Objective-C中的<a class="ae jo" href="http://www.informit.com/blogs/blog.aspx?uk=Ask-Big-Nerd-Ranch-Blocks-in-Objective-C&amp;WT" rel="noopener ugc nofollow" target="_blank">闭包</a>的引入，函数式编程首次出现在iOS开发中，随着Swift编程语言的发布，函数式编程进入了自己的领域。</p><p id="240b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，从这个角度来看，反应式编程只是iOS开发进化的下一步。事实上，苹果的发布落后于社区赞助的库，如<a class="ae jo" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>，这是一个四年前实现的反应式编程，是<a class="ae jo" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react evex</a>库的一部分。但是这仍然留给我们一个问题— <em class="jn">反应式编程试图解决什么问题？</em></p><h1 id="1f36" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用反应式—一个简单的例子</h1><p id="fb1c" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">让我们以一个移动应用程序的常见用例为例，该应用程序使用来自API的数据在屏幕上显示信息。对于这个例子，我们将想象一个音乐平台，它托管一个API，该API返回关于用户播放列表的数据。当用户打开应用程序时，会看到他们的播放列表列表。点击一个，他们可以看到该播放列表的所有细节，如歌曲和艺术家。所有这些信息都会因各种因素而稍有延迟。其中一些因素，比如从数据库中检索信息需要多长时间，可以被最小化。其他问题，如网络拥塞，将一直存在，并且在很大程度上不可预测。</p><p id="f990" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们发起这个行动，我们将需要采取一些中间步骤。首先，我们需要显示一些指示器，表明一个不确定的调用正在发生，也就是我们正在进行一个网络调用。当网络调用返回时，我们需要显示检索到的数据，并从屏幕上删除该指示器。还需要考虑用户方面的错误状态和取消。</p><h1 id="ae38" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">典型方法</h1><p id="01ba" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">当前的实践表明，我们可以通过在应用程序启动时获取所有这些值，并在用户导航到该页面时显示它们，来尝试针对这些情况进行预优化。但是这让我们有可能显示过时的信息。此外，我们现在必须在整个应用程序中随身携带这些信息，或者将其存储在本地，这会带来潜在的安全风险。所以最佳情况是当用户需要时从服务器获取它。</p><h1 id="1bf9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">反应溶液</h1><p id="0e3a" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">进入联合收割机框架。Combine位于现有框架之上，将反应式编程引入iPhone开发。现有的框架结合使用的有:</p><ul class=""><li id="d8de" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated">目标/行动</li><li id="f442" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">通知中心</li><li id="a70d" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">URLSession</li><li id="a4cc" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">键值观察</li><li id="1eeb" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated">临时回电</li></ul><p id="5ff8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过将这些框架的使用“组合”成一个框架，开发人员可以降低网络和UI交互的复杂性。此外，大型团队将受益于苹果制定的标准，这对企业开发人员来说非常好。</p><p id="5215" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们的示例，我们需要了解三个关键的组合概念:</p><ul class=""><li id="943e" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi">发布者</strong> —在我们的示例中，发布者是网络层，它接收来自API的响应，并让任何订阅者知道数据已经可用。</li><li id="e40a" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">订户</strong> —订户知道数据已经可用。这个实例中的订户是显示用户播放列表信息的UI。</li><li id="1867" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">操作符</strong> —位于发布者和订阅者之间的是过滤和修改发布者推送的值的操作符。对于运营商来说，一个很好的用例是预取前十几个播放列表的附加元信息，以帮助进一步减少感知延迟。</li></ul><h1 id="ab56" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">联合行动</h1><p id="4acb" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">我们可以使用Xcode 11+中的Playgrounds在控制台上实现一个简单的版本。请注意，这是使用Xcode 11.2测试版构建的。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9ff5" class="lp jq hh ll b fi lq lr l ls lt">import Foundation</span><span id="aa4c" class="lp jq hh ll b fi lu lr l ls lt">let name = Notification.Name.init("timerFired")<br/>let publisher = NotificationCenter.default.publisher(for: name)</span><span id="185b" class="lp jq hh ll b fi lu lr l ls lt">Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { (timer) in<br/>    NotificationCenter.default.post(name: name, object: "First Event")<br/>}</span><span id="8332" class="lp jq hh ll b fi lu lr l ls lt">publisher<br/>    .receive(on: RunLoop.main)<br/>    .sink(receiveValue: {<br/>        print("Received event \($0)")<br/>    }<br/>)</span><span id="c97a" class="lp jq hh ll b fi lu lr l ls lt">let name3 = Notification.Name.init("timerFired3")<br/>let publisher3 = NotificationCenter.default.publisher(for: name3)</span><span id="4409" class="lp jq hh ll b fi lu lr l ls lt">Timer.scheduledTimer(withTimeInterval: 3, repeats: true) { (timer) in<br/>    NotificationCenter.default.post(name: name3, object: "Second Event")<br/>}</span><span id="523a" class="lp jq hh ll b fi lu lr l ls lt">publisher<br/>    .combineLatest(publisher3)<br/>    .receive(on: RunLoop.main)<br/>    .sink(receiveValue: {<br/>        print("Fired at \($0) and \($1)")<br/>    })</span></pre><p id="a326" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们运行这段代码时，我们会看到以下输出:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3254" class="lp jq hh ll b fi lq lr l ls lt">Received event name = timerFired, object = First Event<br/>Received event name = timerFired, object = First Event<br/>Received event name = timerFired, object = First Event<br/>Fired at name = timerFired, object = First Event, name = timerFired3, object = Second Event</span></pre><p id="1b4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个发布者每秒触发一次，我们将它的输出视为“接收到的事件”，而第二个发布者“在名称处触发”，每三秒触发一次。将这些发布者和订阅者与操作符combineLatest结合使用，我们可以看到如何使用Combine框架在异步触发事件的基础上快速构建应用程序。</p><h1 id="5abe" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">乐观UI</h1><p id="bbed" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">Combine的登陆正值一种新的设计模式开始在iOS领域崭露头角。进入<a class="ae jo" href="https://uxplanet.org/optimistic-1000-34d9eefe4c05" rel="noopener ugc nofollow" target="_blank">乐观的UI </a>它已经存在了一段时间，但是大部分都被开发者和用户忽略了。当谈到让应用程序感觉快速和响应时，不管网络延迟或其他瓶颈，设计发挥了巨大的作用。多年来，苹果一直在他们的<a class="ae jo" href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/launch-screen/" rel="noopener ugc nofollow" target="_blank"> HIG </a>中建议，对于启动屏幕，应用程序跳过传统的带有应用程序标志的加载屏幕，而是显示应用程序首屏的空白版本。对于乐观用户界面，这种模式适用于每一个可能出现延迟的屏幕。在反应模式的支持下，我们现在知道数据何时可用，因此我们可以更新UI。</p><p id="b7a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">“当你的应用程序启动时，启动屏幕会立即出现，并很快被应用程序的第一个屏幕取代，给人的印象是你的应用程序速度快、响应快。”</em></p><p id="e15e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用乐观用户界面的一个主要例子是iOS附带的Messages应用程序。当用户发送消息时，消息窗口会立即更新以包含新消息，即使用户在“发送”消息时可能是离线的。消息旁边有一个微调器，根据发布消息的网络调用的结果，微调器会在成功时消失，或者会以红色显示一条错误消息，如“未送达”。所有这些都发生在用户界面完全响应任何触摸的时候。这种模式也适用于任何收到的消息，当对方正在键入时，键入指示器会显示三个点。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/b403781f74fdb98990c9ddb5f38361ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YVz4xT6TfX7At1UO"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx">Optimistic UI in action in the Message app</figcaption></figure><h1 id="4575" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">骨架屏幕</h1><p id="ea15" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">乐观UI的一个流行实现是<a class="ae jo" href="https://www.lukew.com/ff/entry.asp?1797" rel="noopener ugc nofollow" target="_blank">框架屏幕</a>，最常见的用例是脸书提要。当启动应用程序时，不是看到一个微调器并等待信息下载完成后再显示内容，而是骨架屏幕显示大致对应于数据布局的块，通常带有微光效果。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/c9820a2f776e5d4de2dcf6d71c7c6f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*BtSm9-6cpRCsFMMy"/></div><figcaption class="lw lx et er es ly lz bd b be z dx">Skeleton screen with a shimmer</figcaption></figure><p id="0b05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这两种UI实现都依赖于数据被填充<em class="jn">最终被填充</em>，而不是立即被填充。它们与需要等待异步网络操作完成相吻合，同时也给人一种应用程序快速响应的印象。</p><p id="7d64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到我们的音乐平台的例子。有了新的编程和UI模式，我们可以更新体验以限制网络使用，同时使应用程序看起来快速响应。打开应用程序并进入播放列表页面后，会调用API来返回播放列表信息。同时，会显示一个显示播放列表轮廓的框架屏幕。一旦API调用返回，这个框架屏幕就会被替换为真正的数据，比如歌曲和艺术家。</p><h1 id="80a0" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">期货</h1><p id="cb3c" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">被动模式并不是使异步计算更容易理解的唯一尝试。<a class="ae jo" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">期货</a>，有时被称为承诺，也试图这样做。然而，这种模式往往会导致开发人员开始混合同步和异步函数，也就是所谓的<a class="ae jo" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" rel="noopener ugc nofollow" target="_blank">有色函数问题</a>。简而言之，虽然同步(蓝色)函数可以从异步(红色)函数调用，但异步函数只能从其他异步函数调用。同样，你的程序很可能采用<a class="ae jo" href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="noopener ugc nofollow" target="_blank">延续传递风格</a>，也就是<a class="ae jo" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>，这使得跟踪程序执行变得困难。</p><h1 id="3398" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="6e85" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">随着手机继续吞噬市场份额和眼球，消费者对快速响应应用的期望也将增加。响应式模式远非本月的特色，而是满足这一需求的一种成熟方法，苹果通过其Combine框架实现这一模式对于iOS开发者来说是令人鼓舞的一步。</p><h1 id="47d0" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">资源</h1><ul class=""><li id="4380" class="ks kt hh ir b is kn iw ko ja mb je mc ji md jm kx ky kz la bi translated"><a class="ae jo" href="https://developer.apple.com/videos/play/wwdc2019/722/" rel="noopener ugc nofollow" target="_blank">介绍联合收割机</a></li><li id="dbf8" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jo" href="https://developer.apple.com/videos/play/wwdc2019/721/" rel="noopener ugc nofollow" target="_blank">结合实际</a></li><li id="d17c" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jo" href="https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine" rel="noopener ugc nofollow" target="_blank">用联合收割机接收和处理事件</a></li><li id="1904" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jo" rel="noopener" href="/flawless-app-stories/problem-solving-with-combine-swift-4751885fda77">使用Combine Swift解决问题</a></li><li id="74e2" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jo" href="https://github.com/AvdLee/CombineSwiftPlayground" rel="noopener ugc nofollow" target="_blank">解释联合收割机框架概念的Swift游乐场</a></li></ul><h1 id="dad0" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">相关文章</h1><ul class=""><li id="6e93" class="ks kt hh ir b is kn iw ko ja mb je mc ji md jm kx ky kz la bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/ios-bites-an-intro-to-building-ar-experiences-with-reality-composer-8f891a333cab">iOS Bites——用Reality Composer构建AR体验简介</a></li></ul></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="75ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">披露声明:2020首创一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>