<html>
<head>
<title>Logging Selenium WebDriver Events for Pythonistas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Pythonistas记录Selenium WebDriver事件</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/logging-selenium-webdriver-events-for-pythonistas-59e347dc05ad?source=collection_archive---------2-----------------------#2022-01-18">https://medium.com/quick-code/logging-selenium-webdriver-events-for-pythonistas-59e347dc05ad?source=collection_archive---------2-----------------------#2022-01-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="53ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在自动化测试过程中记录事件有助于管理和维护测试驱动开发(TDD)。Selenium提供了一个API，允许实时监听测试执行期间发生的事件。在本文中，我们通过解释Python Selenium中的概念，扩展了以前为Java Selenium编写的<a class="ae jc" rel="noopener" href="/quick-code/understanding-webdriver-events-e58124575edd">中型文章</a>，并展示了如何利用这个API来记录Selenium事件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0d64e5a36a7c1107804239a5b76ac529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PF08lP-iD3-9l1YXhk8IWw.jpeg"/></div></div></figure><h2 id="1e72" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">什么是事件？</h2><p id="dfb6" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">事件是我们为了运行测试而采取的行动之一，包括:</p><ol class=""><li id="39c7" class="kp kq hh ig b ih ii il im ip kr it ks ix kt jb ku kv kw kx bi translated">寻找元素</li><li id="5daf" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">单击元素</li><li id="014a" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">发送文本和密钥</li></ol><p id="1661" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等等。</p><h2 id="20d7" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">为什么我们需要记录事件？</h2><p id="f046" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">日志记录可以简单地将整个测试会话记录在一个文件中，包括assert操作的结果，它可以指示哪些测试用例通过了，哪些测试用例失败了。因此，我们可以有一个清晰有用的测试报告，然后可以提交给开发团队。</p><h2 id="095b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">需要哪些API？</h2><p id="9a15" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">为了记录事件，首先，我们需要有一个API来定义每次执行某个Selenium驱动程序动作时执行的代码——例如，每当我们执行<code class="du ld le lf lg b">find_element</code>(即，将主代码与其他/辅助代码捆绑在一起；<em class="lh">参见下面的示意图</em>。每次执行Selenium代码时执行的代码可以是<em class="lh">日志</em>代码。因此，其次，我们还需要一个API(或几行代码)来记录或记录一些东西。<strong class="ig hi">日志记录简单地说就是将格式化的文本写入文件</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/40acd204ac5fded528cbccfb5fecf90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwlVUZRS8inMS7udQbN8Qw.png"/></div></div></figure><p id="5ba6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于第一个API，Selenium已经提供了可以通过<code class="du ld le lf lg b">from selenium.webdriver.support.events import EventFiringWebDriver</code>导入的类<code class="du ld le lf lg b">EventFiringWebDriver</code>。这个类用众所周知的<code class="du ld le lf lg b">webdriver</code>对象包装/捆绑了另一个<code class="du ld le lf lg b">AbstractEventListener</code>类型的对象。但是我们不直接使用<code class="du ld le lf lg b">AbstractEventListener</code>类，因为它是一个抽象/祖先类，需要继承才能使用(相当于Java中的接口)。因此，在通过<code class="du ld le lf lg b">from selenium.webdriver.support.events import AbstractEventListener</code>导入<code class="du ld le lf lg b">AbstractEventListener</code>类之后，我们需要从它继承一个类，在那里我们定义我们希望与<code class="du ld le lf lg b">webdriver</code>事件一起执行的任意代码。下面的代码块显示了对<code class="du ld le lf lg b">AbstractEventListener</code>的简单继承，它带有一个定义好的方法，一旦我们执行<code class="du ld le lf lg b">webdriver</code>的<code class="du ld le lf lg b">get</code>方法，这个方法就会被激活。</p><pre class="je jf jg jh fd lj lg lk ll aw lm bi"><span id="6253" class="jp jq hh lg b fi ln lo l lp lq">from selenium.webdriver.support.events import AbstractEventListener</span><span id="32f2" class="jp jq hh lg b fi lr lo l lp lq">class AnEventListener(<!-- -->AbstractEventListener):<br/>        def after_navigate_to(self, url, driver):<br/>                # Writing url to a file </span></pre><p id="078f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有许多标准的硬编码方法，需要在继承过程中全部或部分实现。例如，在上面的代码块中，我们看到在<code class="du ld le lf lg b">webdriver</code>的<code class="du ld le lf lg b">get</code>方法之后执行的<code class="du ld le lf lg b">after_navigate_to</code>方法。在这里可以看到与<code class="du ld le lf lg b">webdriver</code>方法<a class="ae jc" href="https://github.com/SeleniumHQ/selenium/blob/trunk/py/selenium/webdriver/support/abstract_event_listener.py" rel="noopener ugc nofollow" target="_blank">相连接的<code class="du ld le lf lg b">AbstractEventListener</code>方法的完整列表。</a></p><p id="9880" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们想要在继承的<code class="du ld le lf lg b">AbstractEventListener</code>中实现的标准方法中，我们定义了我们的日志动作。这样的日志记录动作可以来自另一个众所周知的Python包:<code class="du ld le lf lg b">logging</code>(使用<code class="du ld le lf lg b">logging</code>的例子见)。下面的代码块显示了一个<code class="du ld le lf lg b">logging</code>包的示例实现，它对于自动化测试来说已经足够好了。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="51ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们可以在我们的<code class="du ld le lf lg b">AbstractEventListener</code>实现中使用上面的<code class="du ld le lf lg b">logger</code>对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="lu lv lw"><p id="26a6" class="ie if lh ig b ih ii ij ik il im in io lx iq ir is ly iu iv iw lz iy iz ja jb ha bi translated">还有一个<code class="du ld le lf lg b">logging</code>的实现，可以用来制作漂亮的HTML报告(参见<a class="ae jc" href="https://gist.github.com/ColinDuquesnoy/8296508" rel="noopener ugc nofollow" target="_blank">这里的</a></p></blockquote><p id="3ee5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当我们的<code class="du ld le lf lg b">AnEventListener</code>类被定义时，我们只需要将它的一个对象，或者简单地将<code class="du ld le lf lg b">AnEventListener()</code>和一个<code class="du ld le lf lg b">webdriver</code>对象(比如说<code class="du ld le lf lg b">webdriver.Chrome()</code>)传递给类<code class="du ld le lf lg b">EventFiringWebDriver</code>来实例化一个新的或升级的<code class="du ld le lf lg b">webdriver</code>对象，该对象有一个额外的(包装的)API来监听它的所有方法。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="29e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个新的<code class="du ld le lf lg b">driver</code>将在文件<code class="du ld le lf lg b">report.log</code>中记录每个浏览过的网站。您可以对此进行扩展，并添加其他方法。例如，您可以考虑定义方法<code class="du ld le lf lg b">on_exception</code>，并通过<code class="du ld le lf lg b">logger.debug("exception message")</code>将所有异常作为debug打印到同一个文件中。</p></div></div>    
</body>
</html>