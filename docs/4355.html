<html>
<head>
<title>Exploring Jetpack Compose Canvas: the power of drawing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Jetpack合成画布:绘画的力量</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-jetpack-compose-canvas-the-power-of-drawing-8cc60815babe?source=collection_archive---------1-----------------------#2021-03-19">https://medium.com/google-developer-experts/exploring-jetpack-compose-canvas-the-power-of-drawing-8cc60815babe?source=collection_archive---------1-----------------------#2021-03-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/eff5d47f5e860d0e0d82d64e1c41ec2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_lY2xx-jO8vIxat0XH7qA.png"/></div></div></figure><p id="652b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我将分享我用Jetpack Compose使用Canvas的经验，Jetpack Compose是Google新推出的UI工具包。Android Dev Challenge #2让我有机会了解大量关于<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Canvas" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> Canvas </strong> </a>的事情，以及如何利用它以一种非常好的方式绘制形状或文本并制作动画。</p><p id="62c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数代码示例都基于下面的项目:</p><div class="jo jp ez fb jq jr"><a href="https://github.com/Oleur/TimePack-CountPose" rel="noopener  ugc nofollow" target="_blank"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hi fi z dy jw ea eb jx ed ef hg bi translated">Oleur/TimePack-CountPose</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">TimePack CountPose是一个计时器应用程序，用于展示Jetpack与Canvas Composable的合成动画。</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">github.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf in jr"/></div></div></a></div><blockquote class="kg kh ki"><p id="7632" class="ip iq kj ir b is it iu iv iw ix iy iz kk jb jc jd kl jf jg jh km jj jk jl jm ha bi translated">免责声明:代码示例基于Compose 1.0.0-beta02。API方法可能会在不久的将来发生变化。</p></blockquote><h1 id="910a" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用画布的第一步</h1><p id="7775" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">如果你熟悉Android视图画布的方法，你就不会迷失在Jetpack Compose的方法中。所有的函数名称都是相同的，其中一些甚至在处理<strong class="ir hi">路径</strong> API时更加明确，例如<strong class="ir hi">:<em class="kj">relativeQuadraticBezierTo()</em></strong>而不是<strong class="ir hi"> <em class="kj"> rQuadto() </em> </strong>来绘制一段路径。</p><p id="d19f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你不熟悉原生的Android Canvas，我强烈推荐你看一下丽贝卡弗兰克斯的这篇文章。</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/over-engineering/getting-started-with-drawing-on-the-android-canvas-621cf512f4c7"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hi fi z dy jw ea eb jx ed ef hg bi translated">在Android画布🖼上开始绘画</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">了解如何使用Android Canvas类</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="lq l kc kd ke ka kf in jr"/></div></div></a></div><p id="fd41" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于Jetpack Compose，有一个可组合组件，它是UI组件库的一部分，名为<strong class="ir hi"> Canvas </strong>，用于释放应用程序中的绘图能力。我们将画一个简单形状(圆形、弧形和矩形)的笑脸来展示它的能力。</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="9750" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">画布上的<strong class="ir hi"><em class="kj">onDraw</em></strong>lambda让我们可以访问<strong class="ir hi">绘图范围</strong>。这个范围允许我们在画布上画出任何我们想要的东西。记住画布的原点(<em class="kj"> x=0，y=0 </em>)位于左上角。</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/9ced71305bfddbcac31a5e981a61f8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ncG3mNvEQkEkxEMZ7fhAw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Canvas with x-y axis and origin at top left</figcaption></figure><p id="b5d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了绘制笑脸的头部，我们将使用笔画样式绘制一个圆。如果我们让样式为空，默认情况下它会被填充。所有绘制方法都接受一种<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Color" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">颜色</strong> </a>或一种<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Brush" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">画笔</strong> </a>(用于用颜色列表添加渐变)。为了设置半径，我们可以使用<strong class="ir hi">绘图范围</strong>提供的<strong class="ir hi"> <em class="kj">尺寸</em> </strong>访问当前绘图环境的尺寸，以便根据组件的尺寸计算可缩放的半径。中心属性接受一个<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/geometry/Offset" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">偏移</strong> </a> <strong class="ir hi"> </strong>来设置图形在画布中的位置。</p><p id="5f08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们用单色画出嘴巴的弧线，同样我们也画出眼睛的矩形。现在，我们笑脸可以显示在屏幕上了:</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/4b7e639e42a4a70e181695bad94bb842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4PLQXZbgsnhGfjFMZC1dg.png"/></div></div></figure><p id="ff7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<strong class="ir hi"> DrawScope </strong>中有很多方法可以在画布上绘图，下面是当前函数的一个例子:</p><ul class=""><li id="93c0" class="md me hh ir b is it iw ix ja mf je mg ji mh jm mi mj mk ml bi translated"><strong class="ir hi"><em class="kj">draw circle()</em></strong>//<em class="kj">在给定坐标处画一个圆</em></li><li id="246d" class="md me hh ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated"><strong class="ir hi"><em class="kj">draw arc()</em></strong>//<em class="kj">绘制一个缩放到适合给定矩形的圆弧</em></li><li id="a2a9" class="md me hh ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated"><strong class="ir hi"><em class="kj">draw image()</em></strong>//<em class="kj">在画布中绘制image bitmap</em></li><li id="4f8a" class="md me hh ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated"><strong class="ir hi"><em class="kj">draw points()</em></strong>//<em class="kj">绘制一系列点</em></li><li id="1ecb" class="md me hh ir b is mm iw mn ja mo je mp ji mq jm mi mj mk ml bi translated"><strong class="ir hi"><em class="kj">draw path()</em></strong>//<em class="kj">用给定的颜色绘制路径</em></li></ul><p id="2415" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还有更多…现在让我们看看如何将我们添加到画布上的图画制作成动画。</p><h1 id="f205" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">带画布的动画</h1><p id="1e53" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">现在我们已经有了基础，让我们看看如何进一步实现和动画更复杂的绘图。在Android开发挑战#2中，我决定开发一个波浪动画，它缓慢地转换到底部，具有动态的波浪宽度，在时间结束时变平。</p><p id="d382" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> DrawScope </strong>提供了一个非常好的API来直接制作画布的动画。您可以应用平移、旋转或缩放变换。对于计时器波动画，我们将进行实际的平移变换。</p><p id="7a21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们定义两种类型的<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationState" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a>来实现目标动画。首先，我们将一个无限动画设置在一个从0到1的浮点数上，以便通过<strong class="ir hi"><em class="kj">remember infinifountation()</em></strong>得到一个无限波浪效果。然后我们使用<strong class="ir hi"> <em class="kj"> animateFloat() </em> </strong>和相关的规范来公开动画的值。</p><p id="9862" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于所有有限的动画，我们将直接使用<strong class="ir hi"> AnimationState </strong>函数，如<strong class="ir hi"><em class="kj">animatefloatstate()、animateColorAsState()…</em></strong>来设置目标值和定义动画规格。</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="22f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经定义了动画状态，我们可以实现波浪动画了。为了绘制wave本身，我们将使用一个<a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Path" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">路径</strong> </a>，这将允许我们添加<strong class="ir hi">贝塞尔曲线段</strong>到我们的路径中，就像正弦函数一样。然后，一旦绘制完成，我们需要用<strong class="ir hi"> DrawScope </strong>提供的<strong class="ir hi"><em class="kj">translate()</em></strong>lambda对其进行包装，并传递AnimateState的值对顶部像素进行动画处理。</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="946f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是完整的动画！</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="mr lw l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Timer wave animation with Jetpack Compose Canvas</figcaption></figure><h1 id="9081" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用原生画布绘制文本</h1><p id="847b" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">目前，您不能直接在Jetpack撰写画布上绘制文本。为此，您必须从Android框架访问原生画布，以便在其上绘制一些文本。在Canvas组件的<strong class="ir hi"><em class="kj">onDraw</em></strong>lambda上，可以调用函数<strong class="ir hi"><em class="kj">drawinto Canvas</em></strong>用<strong class="ir hi"> nativeCanvas </strong>访问底层Canvas(如果可以复用一些你在之前的Android应用中实现的绘制逻辑，会很有帮助)。然后，你可以像<strong class="ir hi"> <em class="kj"> drawText() </em> </strong>或者<strong class="ir hi"> drawVertices() </strong>这样调用所有与原生画布相关的方法。</p><p id="984b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要对文本应用样式，必须使用<strong class="ir hi">绘制</strong>对象。由于我们使用的是原生画布，所以我们不能直接使用<strong class="ir hi"> <em class="kj"> drawText() </em> </strong>函数从Jetpack Compose中使用<strong class="ir hi"> Paint </strong>。为了获得一个本地画图实例，我们可以调用方法<strong class="ir hi"><em class="kj">asframework Paint()</em></strong>来处理一个<strong class="ir hi"> android.graphics.Paint </strong>。</p><p id="1d5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的代码片段展示了如何在本机画布上绘制一个简单的文本:</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="4afd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是它在示例应用程序上的样子:</p><figure class="lr ls lt lu fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/ba87c8150cd265f5e208e40e8515b0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*M0npWQhxJc_8w8GyDZyqVw.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Draw text with Jetpack Compose Canvas</figcaption></figure><p id="0256" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用所有的Jetpack合成画布变换(平移、旋转、缩放……)并将<strong class="ir hi"> <em class="kj"> drawIntoCanvas </em> </strong>包装，这样您就可以在所绘制的内容上添加动画。</p><figure class="lr ls lt lu fd ii"><div class="bz dy l di"><div class="lv lw l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Add transformations to the native canvas</figcaption></figure></div><div class="ab cl mt mu go mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ha hb hc hd he"><p id="4f89" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在画布上画画可能会开启许多设计的可能性！你可以很容易地添加简单的，但是如果你想实现复杂的路径绘制，你可能最终会实现复杂的数学算法。Jetpack Compose Canvas提供了很多功能，所以请明智地使用它。</p><p id="74b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">非常感谢<a class="ae jn" href="https://twitter.com/brwngrldev" rel="noopener ugc nofollow" target="_blank"> Annyce Davis </a>的评论和很好的反馈。👏</p><p id="184e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你有任何问题，请不要犹豫，在推特上联系我🤓</p></div></div>    
</body>
</html>