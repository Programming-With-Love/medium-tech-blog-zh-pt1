<html>
<head>
<title>Debugging Your Unit Test Suite in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python调试单元测试套件</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/debugging-your-unit-test-suite-in-python-94be31ae6eda?source=collection_archive---------1-----------------------#2022-02-09">https://medium.com/capital-one-tech/debugging-your-unit-test-suite-in-python-94be31ae6eda?source=collection_archive---------1-----------------------#2022-02-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="52cb" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">轻松修复单元测试中的错误并模拟组件——如何在pytest中使用Python调试器pdb</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/28d9360ef09cd1a65387c8a20293b8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wQqTxb3E-seuz85F.jpg"/></div></div></figure><p id="792d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你有没有发现编写单元测试比实际的业务逻辑更难？Python以使用简单的语言而闻名，但这并不总是扩展到单元测试；有些事情真的很难写测试。也许您正在测试的函数需要您 <a class="ae kf" href="https://docs.python.org/3/library/unittest.mock.html" rel="noopener ugc nofollow" target="_blank"> <em class="ke">模仿</em> </a> <em class="ke">出一堆东西，或者也许它输出一个复杂的数据结构，比如DataFrame，并且需要大量的断言来正确地指定想要的行为。</em></p><p id="f893" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">无论如何，不管你是软件工程师还是数据科学家，写这种类型的测试都没什么意思。即使在最好的情况下，编写单元测试也可能是一项单调乏味的工作，但是随着模拟等困难的增加，完成它们可能会花费很长时间。在最坏的情况下，您可能会发现自己在通过试错法进行编程——您认为您的代码是正确的，但是您的测试失败了，所以您只是不断调整测试代码并重新运行，直到它通过。</p><p id="4d38" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不用说，试错法是编写测试的糟糕方法。这需要很长时间，可能会将一些bug放到测试套件中，而不是防止它们。幸运的是，有一个非常通用的工具可以让这变得更容易:Python调试器<code class="du kg kh ki kj b">pdb</code>。如果您使用pytest来运行您的测试，它可以方便地与<code class="du kg kh ki kj b">pdb</code>集成。</p><p id="a0ce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这篇文章中，我将演示如何使用<code class="du kg kh ki kj b">pdb</code>和<a class="ae kf" href="https://docs.pytest.org/" rel="noopener ugc nofollow" target="_blank"> pytest </a>。首先，我将简要介绍调试器，以及它们与Jupyter等其他工具的比较。然后，我将转到一个模拟数据库连接的单元测试的工作示例。测试代码有一个令人困惑的错误，但是我们可以进入调试器来精确定位错误并解决问题——一个困难的问题变得容易了。</p><p id="42b5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，让我们开始吧！</p><h1 id="9c92" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">使用调试器的高级案例</h1><p id="6b45" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated"><code class="du kg kh ki kj b">pdb</code>是Python自带的基本调试器。它可以让你暂停一个正在运行的程序，检查变量值，打印输出，甚至进行实时修改。如果你从未使用过<code class="du kg kh ki kj b">pdb</code>，或者甚至没见过像Python这样的解释型语言需要调试器，那么它的杀手锏就是这个- <em class="ke">当遇到异常时，你可以进入一个交互式的环境，而不是让程序崩溃</em>，这也被称为事后调试。这让您可以准确地看到什么是坏的，什么是需要的，将令人沮丧的试错经验变成快速简单的练习。</p><p id="5fce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你在Jupyter或类似的环境中工作过，你可能已经习惯了打印东西和在出错后四处查看，但是<code class="du kg kh ki kj b">pdb</code>更进了一步。当Jupyter让你回到代码的顶层时，<code class="du kg kh ki kj b">pdb</code>会在出现异常的那一行暂停——当错误发生在函数调用深处时，这是一个无价的特性。</p><p id="02a6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设你调用了一个函数，这个函数调用了另一个函数，这个函数调用了另一个函数，这个函数遇到了一个错误，并给出了一个令人困惑的消息，可能是Python内核深处的某个东西，或者是像Pandas这样的库。实际的bug可能在这些中间步骤中的一个，而不是在顶部(您的初始代码行)或底部(库代码)。这就是为什么<code class="du kg kh ki kj b">pdb</code>也有方便的命令<code class="du kg kh ki kj b">up </code>和<code class="du kg kh ki kj b">down</code>，让你浏览调用堆栈，检查错误追溯的每个级别中的所有局部变量。</p><p id="75dc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">关于<code class="du kg kh ki kj b">pdb</code>更详细的介绍，我推荐<a class="ae kf" href="https://realpython.com/python-debugging-pdb/" rel="noopener ugc nofollow" target="_blank"> Nathan Jennings在Real Python的pdb教程</a>。对于Jupyter爱好者来说，尝试在一个异常后在下一个单元格中运行<code class="du kg kh ki kj b">%debug</code>。</p><h1 id="f1d8" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">使用pytest — pdb</h1><p id="87dd" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">如果您使用py test-pdb运行您的测试，它将在每次测试失败或出现某种错误时自动进入调试器。如果您喜欢在日常工作中使用REPL、IPython或Jupyter，那么您就会知道在尝试修复错误时，在交互式环境中使用它们是多么方便！Pytest有许多有助于编写单元测试的特性，但这是最通用的特性之一。</p><p id="eb78" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您想在特定的点开始调试，您也可以在感兴趣的点之前添加一个<code class="du kg kh ki kj b"><a class="ae kf" href="https://docs.python.org/3/library/functions.html#breakpoint" rel="noopener ugc nofollow" target="_blank">breakpoint()</a></code>行(在Python 3.7+中可用)。</p><p id="0f34" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦到达那里，您就可以使用所有常用的<a class="ae kf" href="https://docs.python.org/3/library/pdb.html#debugger-commands" rel="noopener ugc nofollow" target="_blank">调试器命令</a> — <code class="du kg kh ki kj b">break</code>、<code class="du kg kh ki kj b">step</code>、<code class="du kg kh ki kj b">next</code>、<code class="du kg kh ki kj b">return</code>、<code class="du kg kh ki kj b">up</code>、<code class="du kg kh ki kj b">down</code>、<code class="du kg kh ki kj b">continue</code>，以及您想要执行的任意Python代码。</p><p id="1563" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Ctrl+D或<code class="du kg kh ki kj b">exit</code>会让你退出调试器。</p><h1 id="7a38" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">示例—使用模拟数据库调试单元测试</h1><p id="af93" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">我发现使用pdb真正有用的一个地方是当我用模拟组件编写测试时。例如，我可能有一些查询数据库的函数，以便进行一些计算。实际上，我不想在单元测试中连接到数据库，因为那样会很慢，并且需要用户名和密码。相反，我可以模拟数据库连接并模拟查询结果。</p><h1 id="9603" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">编写业务逻辑和测试用例</h1><p id="ff27" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">让我们看看它在代码中会是什么样子——如果您想继续，请随意复制并粘贴这些代码片段，并在您的计算机上运行它们。</p><p id="5485" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，让我们勾画出我们的实际功能。我们使用<a class="ae kf" href="https://github.com/capitalone/locopy" rel="noopener ugc nofollow" target="_blank">Capital One开源项目locopy </a>来连接到我们的数据库，它提供了一个方便的<code class="du kg kh ki kj b">ContextManager</code>，我们可以使用<code class="du kg kh ki kj b">with</code>关键字来获得一个连接，这个连接会自动清理。万一你没有安装locopy，我们可以为<code class="du kg kh ki kj b">Database</code>定义一个存根类，让测试暂时运行。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="4294" class="ll kl hh kj b fi lm ln l lo lp"># my_pkg.py<br/>try:<br/>   from locopy import Database<br/>except (ImportError, ModuleNotFoundError):<br/>   class Database: pass<br/><br/>connection_params = {}<br/><br/>def refresh_views(purge_expired: bool = False):<br/>   with Database(**connection_params) as db:<br/>       db.execute("query1")<br/>       db.execute("query2")<br/><br/>       if purge_expired:<br/>           db.execute("query3")</span></pre><p id="98c2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所以我们的函数连接到数据库并运行一些查询(<code class="du kg kh ki kj b">query1</code>和<code class="du kg kh ki kj b">query2</code>)。如果我们设置了<code class="du kg kh ki kj b">purge_expired</code>标志，它也会运行<code class="du kg kh ki kj b">query3</code>。</p><p id="d904" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在让我们编写一个测试用例来确保<code class="du kg kh ki kj b">purge_expired</code>选项按预期工作。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="5e59" class="ll kl hh kj b fi lm ln l lo lp"># test_my_pkg.py<br/>from unittest.mock import patch<br/>import pytest<br/>from my_pkg import refresh_views<br/><br/>@patch("my_pkg.Database")<br/>def test_refresh_views(mock_Database):<br/>   mock_db = mock_Database()<br/><br/>   # make sure query3 isn't run<br/>   refresh_views(purge_expired=False)<br/>   with pytest.raises(AssertionError):<br/>       mock_db.execute.assert_called_with("query3")<br/><br/>   # make sure query3 _is_ run<br/>   refresh_views(purge_expired=True)<br/>   mock_db.execute.assert_called_with("query3")</span></pre><p id="2d62" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用unittest.mock中的<code class="du kg kh ki kj b">@patch</code>,我们可以在测试运行时用一个<code class="du kg kh ki kj b">MagicMock</code>实例替换<code class="du kg kh ki kj b">Database</code>类。如果您对它不熟悉，<code class="du kg kh ki kj b">MagicMock</code>提供了一个虚拟对象，它将假装拥有您需要的任何方法或属性(尽管默认情况下它们实际上不做任何事情)。在您的测试中，您可以检查mock以查看它的哪些方法被调用，或者提供它将代表您返回的测试数据。</p><p id="3c37" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，我们正在检查当我们设置<code class="du kg kh ki kj b">purge_expired=False</code>时<code class="du kg kh ki kj b">query3</code>不会被数据库执行，而当我们设置<code class="du kg kh ki kj b">purge_expired=True</code>时会被执行。</p><p id="692a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">模拟真的很方便，但是<code class="du kg kh ki kj b">MagicMock</code>与普通的Python对象很不一样，用它编程会很混乱。这是事实，因为我们通常只在单元测试环境中使用模拟，所以我们大多数人没有太多的实践经验。</p><p id="299d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">特别注意我们定义<code class="du kg kh ki kj b">mock_db</code>的方式，它应该匹配<code class="du kg kh ki kj b">refresh_views</code>中的变量<code class="du kg kh ki kj b">db</code>。<code class="du kg kh ki kj b">@patch</code>让我们用<code class="du kg kh ki kj b">mock_Database</code>替换<code class="du kg kh ki kj b">Database</code>类本身，但是我们没有直接使用这个类；我们正在使用它的一个实例。这意味着我们需要“实例化”我们的模拟，因此有了<code class="du kg kh ki kj b">mock_db = mock_Database()</code>。除了我们在原始代码中所做的每一个转换，我们都应该应用到mock中，这并没有什么特别的意义。</p><p id="67b4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在让我们运行我们的测试……我们得到一个错误。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="47ea" class="ll kl hh kj b fi lm ln l lo lp">@patch("my_pkg.Database")<br/>   def test_refresh_views(mock_Database):<br/>       mock_db = mock_Database()<br/><br/>       # make sure query3 isn't run<br/>       refresh_views(purge_expired=False)<br/>       with pytest.raises(AssertionError):<br/>           mock_db.execute.assert_called_with("query3")<br/><br/>       # make sure query3 _is_ run<br/>       refresh_views(purge_expired=True)<br/>&gt;      mock_db.execute.assert_called_with("query3")<br/><br/>E           AssertionError: expected call not found.<br/>E           Expected: execute('query3')<br/>E           Actual: not called.</span></pre><p id="1dfb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">太奇怪了。</p><h1 id="33d8" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">调试测试用例</h1><p id="081b" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">那么，我们的下一步是什么？mock可能会出很多问题——可能是<code class="du kg kh ki kj b">query3</code>从未被执行(也就是说，测试理所当然地失败了),补丁没有正常工作，或者也许我们没有在mock上完美地复制<code class="du kg kh ki kj b">Database</code>和<code class="du kg kh ki kj b">db</code>之间的所有步骤。</p><p id="9001" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，我的第一步是用<code class="du kg kh ki kj b">--pdb</code>选项重新运行测试，并开始查看。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="3869" class="ll kl hh kj b fi lm ln l lo lp">~/miniconda3/lib/python3.9/unittest/mock.py:898: AssertionError<br/>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entering PDB &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/><br/>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; PDB post_mortem (IO-capturing turned off) &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/>&gt; ~/miniconda3/lib/python3.9/unittest/mock.py(898)assert_called_with()<br/>-&gt; raise AssertionError(error_message)<br/>(Pdb)</span></pre><p id="fc08" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">回溯从库函数内部开始，所以我执行一次<code class="du kg kh ki kj b">up</code>来返回到我的测试代码。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="f1df" class="ll kl hh kj b fi lm ln l lo lp">(Pdb) up<br/>&gt; ~/dev/test_my_pkg.py(17)test_refresh_views()<br/>-&gt; mock_db.execute.assert_called_with("query3")</span></pre><p id="70f0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好了，现在我们可以检查一下mock_db了。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="ca13" class="ll kl hh kj b fi lm ln l lo lp">(Pdb) mock_db<br/></span><span id="92a5" class="ll kl hh kj b fi lq ln l lo lp">(Pdb) mock_db.execute<br/></span><span id="13dd" class="ll kl hh kj b fi lq ln l lo lp">(Pdb)</span></pre><p id="6c61" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以看到<code class="du kg kh ki kj b">mock_db</code>应该是一个<code class="du kg kh ki kj b">Database</code>实例。奇怪的是，execute方法似乎从来没有被调用过，因为它有一个空的调用列表。暂时退出调试器，让我们从实际的实现代码内部再试一次。我会在应该执行<code class="du kg kh ki kj b">query3</code>之前设置一个断点。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="64be" class="ll kl hh kj b fi lm ln l lo lp">def refresh_views(purge_expired: bool = False):<br/>   with Database(**connection_params) as db:<br/>       db.execute("query1")<br/>       db.execute("query2")<br/><br/>       if purge_expired:<br/>&gt;          breakpoint()<br/>           db.execute("query3")</span></pre><p id="d8d5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，当我们运行测试时，我们在这一行进入调试器。第一步是从内部看看<code class="du kg kh ki kj b">db</code>是什么样子——它到底是不是一个mock，如果是，在它上面调用了什么方法？</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="7d69" class="ll kl hh kj b fi lm ln l lo lp">&gt; ~/dev/my_pkg.py(16)refresh_views()<br/>-&gt; db.execute("query3")</span><span id="877d" class="ll kl hh kj b fi lq ln l lo lp">(Pdb) db</span></pre><p id="f301" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">马上就跳出来说<code class="du kg kh ki kj b">db</code> <em class="ke">是</em>一个嘲弄，但不仅仅是<code class="du kg kh ki kj b">Database()</code>而是<code class="du kg kh ki kj b">Database().__enter__()</code>。那是从哪里来的？</p><p id="88f7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">嗯，如果我们看看它的定义，我们会发现它来自一个<code class="du kg kh ki kj b">with</code>语句——这意味着它实际上是一个<code class="du kg kh ki kj b">ContextManager</code>。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="6781" class="ll kl hh kj b fi lm ln l lo lp">with Database(**connection_params) as db:</span></pre><p id="ce21" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">就我个人而言，我在Python中一直使用<code class="du kg kh ki kj b">with</code>语句，但通常不会创建自己的自定义<code class="du kg kh ki kj b">ContextManagers</code>。所以当我最初怀疑<code class="du kg kh ki kj b">with</code>语句时，我不记得用mock复制的确切语法了。</p><h1 id="977f" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">应用修复</h1><p id="528d" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">现在我们知道了问题，我们可以修复我们的测试代码了。我们可以手动复制数据库上的方法调用链…</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="1a14" class="ll kl hh kj b fi lm ln l lo lp">@patch("my_pkg.Database")<br/>def test_refresh_views(mock_Database):<br/>&gt;  mock_db = mock_Database().__enter__()<br/><br/>   # make sure query3 isn't run<br/>   refresh_views(purge_expired=False)<br/>   ...</span></pre><p id="74ce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">或者，我们可以用<code class="du kg kh ki kj b">with</code>来定义它，就像在业务逻辑中一样。非常直观。</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="4524" class="ll kl hh kj b fi lm ln l lo lp">@patch("my_pkg.Database")<br/>def test_refresh_views(mock_Database):<br/>&gt;  with mock_Database() as mock_db:<br/>       # make sure query3 isn't run<br/>       refresh_views(purge_expired=False)</span></pre><p id="fad7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在那个小小的编辑(和删除<code class="du kg kh ki kj b">breakpoint()</code>)之后，测试通过了！</p><pre class="ix iy iz ja fd lh kj li lj aw lk bi"><span id="67f2" class="ll kl hh kj b fi lm ln l lo lp">========================= 1 passed in 0.64s =========================</span></pre><p id="1e2a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果几年前你问我，我可能都不知道该在谷歌上搜索什么来解决这个问题。但是有了调试器，我可以毫不费力地马上解决这个问题。能够自助是一件很美好的事情！</p><h1 id="813b" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">包裹</h1><p id="b8b9" class="pw-post-body-paragraph ji jj hh jk b jl lc ii jn jo ld il jq jr le jt ju jv lf jx jy jz lg kb kc kd ha bi translated">当你可以亲自检查每个变量时，修复错误就容易多了，这同样适用于测试代码，就像它适用于其他任何东西一样。但是，即使您习惯于在Jupyter中闲逛，也不清楚如何在单元测试中应用同样的技术。更不用说，<code class="du kg kh ki kj b">MagicMock</code>的行为与普通Python对象如此不同，以至于很容易混淆。这就是<code class="du kg kh ki kj b">pytest --pdb</code>和<code class="du kg kh ki kj b">breakpoint()</code>的作用。</p><p id="c189" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，至少在编写单元测试时，要告别试错编程和无休止的谷歌搜索。有了这个技巧，你最沮丧的测试错误应该是小菜一碟。🎂</p></div><div class="ab cl lr ls go lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ha hb hc hd he"><p id="2438" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:2021首都一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="1a21" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">原载于</em><a class="ae kf" href="https://www.capitalone.com/tech/software-engineering/how-to-use-python-degugger-pdb/" rel="noopener ugc nofollow" target="_blank"><em class="ke">https://www.capitalone.com</em></a><em class="ke">。</em></p></div></div>    
</body>
</html>