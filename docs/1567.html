<html>
<head>
<title>Choosing Between Web APIs and Message Streaming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Web APIs和消息流之间选择</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/choosing-between-rest-web-apis-and-message-streaming-8e2f4813a058?source=collection_archive---------0-----------------------#2018-05-24">https://medium.com/capital-one-tech/choosing-between-rest-web-apis-and-message-streaming-8e2f4813a058?source=collection_archive---------0-----------------------#2018-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a7ce622f4b1c2a986959009f476a1487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG2F50f-WTByvZOSZU29iQ.png"/></div></div></figure><p id="67f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当面临多种选择时，开发人员如何构建API来知道哪一个适合他们的解决方案呢？在本文中，我将概述REST APIs和消息流的共同特征，以便开发人员能够更好地理解何时(以及何时不)使用它们。</p><h1 id="8545" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">基于REST的Web APIs的特征- </strong></h1><p id="9d3d" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">基于REST的web APIs在客户机(API消费者)和API服务器(后端)之间创建了一个对话。当我们在Capital One中构建基于REST的API时，我们使用HTTP作为我们的协议。我们的设计在很大程度上依赖于HTTP，从方法(例如GET、POST、PUT、PATCH、DELETE)到帮助我们在客户端和服务器之间通信的头(例如Authorization、Accept、Content-Type)。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/449157788a777b3472047b411289a4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*QMWflB9OjaZJxAi5UJx6eg.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a2d0" class="la jo hh kw b fi lb lc l ld le"><strong class="kw hi"><br/>GET /projects<br/> Accept: application/json</strong></span><span id="0b22" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">200 OK<br/> Content-Type: application/json</strong><br/> <br/> [<br/> { “Id”:”…”, “name”:”…” },<br/> { “Id”:”…”, “name”:”…” },<br/> { “Id”:”…”, “name”:”…” },<br/> …<br/> ]</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/26e33b796d5bff1c55e51628a829b3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*ufPuD7tW3oLjDY5hIWTP-Q.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7c60" class="la jo hh kw b fi lb lc l ld le">POST<strong class="kw hi">/projects<br/> Content-Type: application/json<br/> </strong>{ “name”:”…”, … }</span><span id="6537" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">201 Created<br/> Content-Type: application/json</strong><br/> <br/> { “Id”:”…”, “name”:”…”, … }</span></pre><p id="f918" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">客户端(或API消费者)是应用程序，它在需要时向API发送消息(即HTTP请求)。然后，服务器回复响应，其中包括一个状态代码，指示请求是处理成功(2xx错误代码)、由于客户端错误而失败(4xx错误代码)还是由于服务器错误而失败(5xx错误代码)。所有通信都从消费者流向API后端。</p><p id="1a06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们添加超媒体链接时，我们用一些可能对客户有帮助的附加信息来扩展对话:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/417d5053276dd3f3ed6e852f9a240a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*RKEuunpBwQVh4GTF-DHjIg.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1da0" class="la jo hh kw b fi lb lc l ld le"><strong class="kw hi">GET /projects/12345<br/> Accept: application/json</strong></span><span id="0860" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">200 OK<br/> Content-Type: application/json</strong><br/> <br/> { <br/> “name”:”…”, …,<br/> “_links”: {<br/> { ”self” :”/projects/1234” }, <br/> { “related_projects”: [<br/> { ”4567” :”/projects/4567” }, <br/> { ”8901” :”/projects/8901” }, <br/> { ”9012” :”/projects/9012” } <br/> ] <br/> }, <br/> { “members”: [<br/> { ”1” :”/users/1” }, <br/> { ”2” :”/users/2” }, <br/> { ”3” :”/users/3” }, <br/> { ”4” :”/users/4” }, <br/> { ”5” :”/users/5” } <br/> ] <br/> }<br/> }</span></pre><p id="58b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于REST的API有一组特定的特征，总结如下:</p><ul class=""><li id="1582" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir hi">请求/响应模型</strong> — API消费者向API服务器发送请求并接收响应。</li><li id="96ed" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">基于拉的交互</strong> — API消费者在需要数据或功能时发送API请求(例如，用户界面，在预先安排的时间)。</li><li id="a458" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">同步</strong> — API消费者在请求发送后收到响应。</li><li id="bbbe" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">多种内容类型</strong> —由于REST APIs是基于HTTP构建的，因此响应可以是JSON、XML或支持消费者需求所需的其他内容类型(例如CSV、PDF)。</li><li id="69e0" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">灵活的交互</strong>——基于可用的HTTP动词，消费者可以通过资源以多种方式与基于REST的API交互:查询/搜索、创建新资源、修改现有资源和删除资源。我们还可以通过将这些交互结合到更高层次的流程中来构建复杂的工作流。</li><li id="159c" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">缓存和并发协议支持</strong> — HTTP具有内置的缓存语义，允许在消费者和API服务器之间放置缓存服务器，以及用于并发控制的响应和eTags的缓存控制，以防止覆盖内容。</li><li id="484d" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">内部和外部访问</strong>—REST API可能仅限于合作伙伴或公共开发者内部使用或外部使用。</li></ul><blockquote class="lw"><p id="7982" class="lx ly hh bd lz ma mb mc md me mf jm dx translated">对于大多数解决方案，提供基于REST的API是一个很好的起点，允许任何应用程序或自动化脚本通过HTTP与您的API进行交互。</p></blockquote><h1 id="fe46" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk bi translated"><strong class="ak">消息流的特征</strong></h1><p id="88dc" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">与REST APIs不同，消息流更擅长在新消息到达时提供通知。订阅后，当有新消息时，会通知客户端:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/84916437b764bfab65e588e1a25681f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*W9MsRxTiJc_SAQvb6Zmhwg.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d68e" class="la jo hh kw b fi lb lc l ld le">POST<strong class="kw hi">/projects<br/> Content-Type: application/json<br/> </strong>{ “name”:”…”, … }</span><span id="65a7" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">201 Created<br/> Content-Type: application/json</strong><br/> </span></pre><p id="5563" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然客户端已经订阅了主题，那么当有新消息时，它将会收到通知。这可能是REST API处理来自web或移动应用程序的传入请求，然后将消息添加到消息流主题中以通知任何感兴趣的人的结果:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/40c1e678a79e12a116bb65c4e94d31f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*2C-PfgQn8Su_Fh-_67kKxQ.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8882" class="la jo hh kw b fi lb lc l ld le"><strong class="kw hi">&lt;&lt;publish message to project_messages:</strong></span><span id="600c" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">project created&gt;&gt;</strong></span><span id="7466" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">&lt;&lt;publish message to project_messages:</strong></span><span id="f8f8" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">project archived&gt;&gt;</strong></span><span id="9bd6" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">&lt;&lt;publish message to project_messages:</strong></span><span id="4d87" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">project updated&gt;&gt;</strong></span><span id="ee7a" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">&lt;&lt;notify client1234:</strong></span><span id="26e6" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">3 new messages&gt;&gt;</strong></span></pre><p id="9bce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意我们的谈话变得越来越有趣。现在，当事情发生变化或关键业务事件发生时，我们可以收到通知；而不需要修改和重新部署API来支持未来出现的新集成。这被称为<em class="ml">松耦合</em>，它帮助我们的系统以新的方式被使用，而消息的发起者甚至不知道当前和未来的订户。</p><p id="c0d0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">熟悉消息代理的人会意识到这很熟悉。消息代理和消息流的区别在于<em class="ml">消息流也允许我们按顺序重新访问过去的消息</em>:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mm"><img src="../Images/d7c6f793a77815eeda70e7fa90347afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*0JNy5FYBeTNrE8MwZ2GmgQ.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0d9a" class="la jo hh kw b fi lb lc l ld le"><strong class="kw hi">&lt;&lt;request last 12 messages from project_messages topic&gt;&gt;</strong></span><span id="f4b5" class="la jo hh kw b fi lf lc l ld le"><strong class="kw hi">&lt;&lt;retrieve and send last 12 messages from project_messages topic&gt;&gt;</strong></span></pre><p id="80c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们需要聚合值或执行我们以前没有意识到需要的新计算时，这个特性很有用。</p><blockquote class="lw"><p id="ba06" class="lx ly hh bd lz ma mn mo mp mq mr jm dx translated"><strong class="ak"> <em class="ms">注意——我们不能在请求消息时过滤消息或执行其他聚合查询——只有客户端在从主题请求消息后才能这样做。REST APIs比消息流更适合执行特殊查询。</em>T9】</strong></p></blockquote><p id="ff12" class="pw-post-body-paragraph ip iq hh ir b is mt iu iv iw mu iy iz ja mv jc jd je mw jg jh ji mx jk jl jm ha bi translated">正如您所发现的，消息流是一种不同于基于REST的API的交互风格。消息流的其他特征总结如下:</p><ul class=""><li id="6af1" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir hi">发布/订阅模型</strong> —应用程序或API向主题发布消息，该主题可能有零个、一个或多个订阅者，而不是请求/响应模型。</li><li id="9cbd" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">订阅者通知交互</strong> —当有新消息可用时，应用程序会收到通知，例如当数据被修改或有新数据可用时。</li><li id="e45b" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">异步</strong> —与REST APIs不同，没有各方之间复杂的协调，应用程序无法使用消息流提交请求和接收响应。</li><li id="f2f0" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">单一内容类型</strong> —在Capital One，我们的消息流建立在Avro之上，这是一种用于数据序列化的紧凑二进制格式。与HTTP不同，Avro不支持其他内容类型(例如CSV、PDF)。</li><li id="a07e" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">可回放性</strong> —在Capital One，我们的消息流建立在Kafka的基础上，订户可以按顺序重温和回放之前的消息。</li><li id="6746" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">没有缓存或并发协议支持</strong> —消息流不提供缓存语义、缓存控制或发布者和订阅者之间的并发控制。</li><li id="66b8" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">仅限内部访问</strong> —订户必须是组织内部的，不像HTTP可能会被外部化为合作伙伴或公共消费者。</li></ul><p id="7747" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">消息流提供了一些基于REST的API所没有的额外的通信选项——当新的数据或状态发生变化时基于推送的通知，以及重新访问流中过去的消息以执行新的计算或重新执行以前失败的逻辑的选项。当结合在一起时，REST-API使消费应用程序能够很容易地与HTTP API集成，而消息流允许消费者在不需要先检查REST API的情况下得到更改通知。这可能是一个强大的组合，可以满足当前存在的用例，同时允许未来处理新出现的用例，而无需修改现有系统来适应新的解决方案。</p><h1 id="0cc3" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">总结</strong></h1><p id="c262" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">正如您可能已经意识到的，在web API和消息流之间做出选择并不困难，只要您了解每一种的特性。REST APIs最适合请求/响应交互，其中客户端应用程序通过HTTP向API后端发送请求。消息流最适合在出现新数据或事件时发出通知，您可能希望对其采取措施。只是要确保用一种或多种方法来满足消费者的需求，为您的解决方案功能提供一个健壮的界面。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es my"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a></figure><p id="ce58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ml">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>