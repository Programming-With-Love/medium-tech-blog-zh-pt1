<html>
<head>
<title>Open Sourcing Lacinia, our GraphQL Library for Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开放源码Lacinia，我们针对Clojure的GraphQL库</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/open-sourcing-lacinia-our-graphql-library-for-clojure-96a4ce5fc7b8?source=collection_archive---------2-----------------------#2017-03-23">https://medium.com/walmartglobaltech/open-sourcing-lacinia-our-graphql-library-for-clojure-96a4ce5fc7b8?source=collection_archive---------2-----------------------#2017-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/46395b0ccc07cc41998cd497d0ff9015.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*17U-yzBfoMgkFpuawnmUnw.png"/></div><figcaption class="il im et er es in io bd b be z dx">GraphQL Logo Copyright © 2016 Facebook Inc. under BSD-3-Clause</figcaption></figure><p id="b38f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们很高兴为Clojure发布我们的GraphQL库<a class="ae jn" href="https://github.com/walmartlabs/lacinia" rel="noopener ugc nofollow" target="_blank"> Lacinia </a>！一年多来，我们一直在生产中为多种服务使用GraphQL。</p><p id="dc58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为发布的一部分，我们想讨论我们团队采用GraphQL的基本原理，我们面临的问题，GraphQL是如何解决这些问题的，以及我们今后的发展方向。</p><p id="4ff2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个非技术性的解释，说明为什么我们认为GraphQL是解决问题的好方法。有关Lacinia的文档，请参考<a class="ae jn" href="https://github.com/walmartlabs/lacinia" rel="noopener ugc nofollow" target="_blank"> Github存储库</a>。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h2 id="8f52" class="jv jw hh bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">我们的问题</h2><p id="d1cf" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们团队的主要职责之一是为沃尔玛和山姆会员店的客户提供直接从其iOS/Android智能手机或网络浏览器获取店内收据的完整历史的即时途径。我们对五千多家商店的每次购买和退货进行实时处理，每秒钟收到500张收据，在黑色星期五和整个假期期间，这个数字将翻两番。</p><p id="996e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最终，我们有了一个相当大的卡桑德拉数据库，里面有客户、收据以及联系他们的协会。我们的整个服务器端堆栈都是用Clojure编写的，旨在高效、可靠地为传入的数据提供服务。有关所有这些工作原理的一些幕后故事，请参阅Anthony Marcar在Clojure/West 2015上的演讲，<a class="ae jn" href="https://www.youtube.com/watch?v=av9Xi6CNqq4" rel="noopener ugc nofollow" target="_blank">clo jure At Scale At Walmart labs</a>。</p><p id="e885" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了尽我们所能为沃尔玛和山姆会员店的客户提供最好的服务，我们向公司内的许多团体提供大量数据。每个组织都有自己的需求和关注点，例如:</p><ul class=""><li id="68eb" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm la lb lc ld bi translated">移动应用程序团队只想要填充简洁视图所需的字段。他们关心的是收据的总购买价格、物品数量、日期和地点等。他们还需要通过后续电话获得更详细信息的能力。移动工程师需要优化的有效载荷和在设计过程中快速迭代的能力，而不需要等待后端的改变。任何发送到客户端的额外数据都是浪费带宽。</li><li id="66b6" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">开发网站的团队针对桌面网络浏览器提供了更丰富的购物体验。他们通常在更大的视野下工作，比移动应用团队更想获得更详细的信息。</li><li id="ba4e" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">其他团队通常有一两个他们需要回答的核心问题，并且希望能够查询我们的系统来找到这些特定的参数。例子包括储蓄捕捉器，如果客户在竞争对手的商店里有更低的价格，它会将购买的商品记入他们的贷方；以及客户保护系统，如果购买的商品以后被召回，它会通知客户。</li></ul><p id="0546" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些团队中的每一个对于需要访问的事务数据子集都有着非常不同的需求。让我们的数据易于消费，尤其是因为我们是一个工程师小组，这是一个传统REST API结构无法解决的核心挑战。</p><p id="5fc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着时间的推移，我们发现自己处于维护、扩展和记录API集合的尴尬境地，每个API最初都是为特定的用例构建的。这些API中的每一个都使用了不同的HTTP堆栈，配置也不同，并且在URL方案、查询参数等方面都有自己的特定约定，这是受它们创建时的实践的启发。较新的服务使用了<a class="ae jn" href="https://github.com/pedestal/pedestal" rel="noopener ugc nofollow" target="_blank">基座</a>和<a class="ae jn" href="https://github.com/stuartsierra/component" rel="noopener ugc nofollow" target="_blank">组件</a>；旧的服务使用环处理程序和分散的可变状态。</p><p id="ebe0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与此同时，我们有更多的团队对在我们的基础上构建服务感兴趣——这是一个好问题。发展这些现有的API是一个困难的问题。向JSON响应中添加一个新字段是有风险的，因为对于一些依赖于绑定到一组确切的已知键的响应的客户机来说，这可能会产生无法预料的后果。因为我们的服务利用了共享的内部库，所以对这些库中的一个进行更改可能会无意中改变另一个不相关的服务的行为。</p><p id="2193" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望能够自由地发展和改进我们的API，而不需要复杂的版本控制方案和复杂的迁移计划。我们需要能够自信地对支持代码进行更改，而不必担心在广泛的服务中未发现的副作用。作为后端团队，我们决定不再为产品团队做产品决策。相反，我们授权每个团队以最好地支持他们正在构建的特定产品的方式来查询我们的系统。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h2 id="9177" class="jv jw hh bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">解决方案</h2><p id="3069" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在脸书发表了关于GraphQL及其基本原理的会议演讲和文章后，我们相信这项技术将成为改进我们服务的一种优雅的方式。不过，有一个问题:我们是一个Clojure团队。当时GraphQL对Clojure还没有一个好的故事。幸运的是，GraphQL有一个健壮的规范，所以我们开始构建自己完全实现的实现— <a class="ae jn" href="https://github.com/walmartlabs/lacinia" rel="noopener ugc nofollow" target="_blank"> Lacinia </a>。</p><p id="7edb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">GraphQL规范对我们来说非常重要。我们的理念是，我们的库需要将GraphQL作为一种通用语言来使用和理解，并且已经建立了执行语义，但是我们正在努力寻找一种在Clojure生态系统中工作得最好的惯用解决方案。这种哲学的一个例子是尽可能数据驱动:声明GraphQL服务器功能的模式定义是用EDN编写的，并使用Clojure数据结构。用Clojure代码操作这种数据结构不仅受到支持，而且受到鼓励。</p><p id="fa3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同时，使用Clojure执行GraphQL查询非常自然。从本质上讲，GraphQL是一种非常功能化的方法:一个过滤和转换过程，从所有可能的数据开始，缩小到客户机请求的结果。Clojure对纯函数和持久数据结构的使用确保了这些操作的安全和高效。</p><p id="0b16" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在开发了Lacinia的内部版本后，我们能够抛弃几乎所有现有的API，并将当前和未来的客户端装载到我们的GraphQL服务上。当你在手机上打开你的沃尔玛商店收据，或访问<a class="ae jn" href="http://www.samsclub.com" rel="noopener ugc nofollow" target="_blank">samsclub.com</a>并在网上查看你的收据时，你正在接受Lacinia的服务。如果你使用<a class="ae jn" href="http://grocery.walmart.com/" rel="noopener ugc nofollow" target="_blank">沃尔玛超市</a>，你使用的是Lacinia。</p><p id="5b30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们围绕我们的数据模型设计我们的模式，客户可以简单地询问他们需要什么。当然，我们不可能知道<em class="lj">所有</em>可能的用例，但是当客户告诉我们他们不能查询他们想要的东西时，我们通常可以添加缺失的字段或关系，并在几分钟内部署它。通常，我们的内部数据模型已经包含了这些信息，只需要更新模式来公开新的字段。因为客户端控制他们看到的数据，所以向现有模式添加新的字段和类型总是安全的，并且总是向后兼容的。</p><p id="5c90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不仅如此，模式中的一切都可以通过自省完全发现和记录。我们服务于一个实例的<a class="ae jn" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank">图<em class="lj"> i </em> QL </a>(带有一个<em class="lj"> i </em>！)基于web的IDE:这允许其他团队的开发人员交互式地构建和执行查询。Lacinia自动实现GraphQL规范的自省部分；我们所要做的就是包含关于字段和类型的面向用户的文档。</p><p id="9d1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以前，在协助其他团队时，我们会抛出一些特别的curl命令，重现我们客户的问题总是一个挑战。今天，我们传递一个图<em class="lj"> i </em> QL链接，它可以包含整个查询——即时再现。</p><p id="a79e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数情况下，让一个新客户加入我们的服务只是给他们一个QL图的URL，他们可以快速地、交互式地勾画出他们的查询，并通过界面了解所有的字段和类型。如果他们有问题或疑问，他们可以将他们的疑问发送给我们。一个令人惊讶的分支是，作为该服务的开发者，我已经开始依赖Graph <em class="lj"> i </em> QL来完成我自己的日常工作流程:构建GraphQL查询比直接访问底层Cassandra数据库更快更容易。GraphQL之上的Graph <em class="lj"> i </em> QL构成了一个异常强大的工具。</p><p id="f477" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们认为clojure.spec是健壮的clojure系统的未来。Lacinia支持clojure.spec，并努力在整个过程中利用它。例如，自定义标量是使用conformers定义的。为了在Clojure 1.9迭代各种alpha版本时保持Clojure 1.8的稳定，我们引入了<a class="ae jn" href="https://github.com/tonsky/clojure-future-spec" rel="noopener ugc nofollow" target="_blank"> clojure-future-spec </a>，这是Clojure 1.9可用的各种clojure.spec特性的反向移植。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h2 id="2edd" class="jv jw hh bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">今后</h2><p id="80a5" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">从技术和文化的角度来看，GraphQL代表了我们系统的一个关键部分。沃尔玛是一个很大的地方，当我们让公司其他部门的人参与GraphQL时，他们有兴趣更多地了解我们在用它做什么，以及他们如何从我们的工作和经验中受益。我们很高兴能在开放的环境中继续开发Lacinia。Lacinia还没有完全符合发布的<a class="ae jn" href="https://facebook.github.io/graphql/" rel="noopener ugc nofollow" target="_blank">规范</a>，但是我们希望很快就能达到。我们渴望与社区合作，我们将愉快地接受和讨论任何问题或请求。</p><p id="03f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更多信息和技术文档，请访问<a class="ae jn" href="https://github.com/walmartlabs/lacinia" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p></div></div>    
</body>
</html>