<html>
<head>
<title>Hashicorp Vault on AWS with Auto Unseal and DynamoDB Backend Built with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上的Hashicorp Vault具有自动解封功能，DynamoDB后端由Terraform构建</h1>
<blockquote>原文：<a href="https://medium.com/version-1/hashicorp-vault-on-aws-with-auto-unseal-and-dynamodb-backend-built-with-terraform-e489cfe96097?source=collection_archive---------0-----------------------#2021-12-22">https://medium.com/version-1/hashicorp-vault-on-aws-with-auto-unseal-and-dynamodb-backend-built-with-terraform-e489cfe96097?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="4ecd" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">关于我自己</h1><p id="647c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我是为<a class="ae ka" href="https://www.version1.com/" rel="noopener ugc nofollow" target="_blank">版本1 </a>工作的DevOps工程师。我在2008年以Linux管理员和Oracle Applications DBA的身份加入了版本1。</p><p id="2813" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">第1版让所有员工都可以选择跳槽到其他内部角色，2019年，我决定尝试进入第1版数字和云团队，担任DevOps工程师。</p><p id="81f9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">为此，我开始学习一些主要的DevOps工具，如Terraform和Docker。我还获得了AWS认证解决方案架构师认证。</p><p id="3c67" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">因此，2020年1月，我从Linux和Oracle转到了DevOps，并且从未回头。</p><h1 id="64fb" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">目的</h1><p id="45ba" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">本文档的目的是展示如何在<a class="ae ka" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊Web服务</a>中运行单节点<a class="ae ka" href="https://www.hashicorp.com/products/vault" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>实例，使用<a class="ae ka" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> AWS DynamoDB </a>后端并使用<a class="ae ka" href="https://aws.amazon.com/kms/" rel="noopener ugc nofollow" target="_blank"> AWS密钥管理服务</a>在安装或重启时自动解封Vault。</p><h1 id="fa6c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么</h1><p id="5817" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当我需要在AWS中启用自动解封来实现Vault时，我花了一些时间来解决这个问题。我能找到的信息并不多。所以现在我有它的工作，为什么不分享它，希望它可以帮助一些人在AWS上安装他们的Vault。</p><h1 id="1a37" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我们将涵盖哪些内容</h1><p id="3de3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这将涵盖AWS上带有DynamoDB后端的单节点Vault实例。在生产中，很可能会有一个使用AWS自动扩展组和AWS负载平衡器的Vault集群，但这将使测试环境中的Vault运行变得更加复杂。</p><p id="602d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">因此，本指南将涵盖</p><ol class=""><li id="8844" class="kg kh hh je b jf kb jj kc jn ki jr kj jv kk jz kl km kn ko bi translated">创建EC2实例以运行vault。</li><li id="c98f" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">写入EC2用户数据以安装和配置vault。</li><li id="75d9" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">为保管库存储设置dynamodb后端。</li><li id="4c8e" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">演示从Terraform工作站、vault EC2实例和Vault web控制台登录到Vault。</li></ol><h1 id="9181" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">地形版本</h1><p id="4df0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">该代码已经在Terraform版本0.13、0.14、0.15和1.0中测试过，对于本指南，我将只使用Terraform 1.0。</p><h1 id="eb46" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我们开始吧</h1><p id="16d0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我假设您已经安装了Terraform，并使用Linux服务器进行开发。</p><p id="959e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这里下载源代码，然后我们将通过它是如何工作的。</p><p id="3788" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">创建一个目录，并从GitHub—<a class="ae ka" href="https://github.com/nicklunt/vault.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nicklunt/vault.git</a>下载这个库构建的源代码</p><p id="f00d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">将目录更改为新的保管库目录。这里创建一个SSH密钥，AWS将使用它来允许对AWS实例的SSH访问。这是我使用的方法</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bf9a" class="ld if hh kz b fi le lf l lg lh">ssh-keygen -y -f ~/.ssh/id_rsa &gt; public_key</span></pre><p id="a70b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这个public_key将在main.tf中被引用。</p><h1 id="2fd3" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建实例— main.tf</h1><p id="090b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">创建AWS密钥对，以便在Vault实例联机后允许我们访问它。</p><p id="d94c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这使用了我们刚刚创建的public_key。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="efc4" class="ld if hh kz b fi le lf l lg lh">resource “aws_key_pair” “ssh-keypair” {<br/> key_name = “ssh-keypair”<br/> public_key = file(var.ssh-key)<br/>}</span></pre><p id="9a1e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">main.tf文件也将创建实例，这里没有什么特别的，但是user_data是我们很快就会感兴趣的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9cdf" class="ld if hh kz b fi le lf l lg lh"><em class="li">resource “aws_instance” “vault” {<br/> ami = var.ami <br/> key_name = aws_key_pair.ssh-keypair.id<br/> instance_type = var.aws_instance_type<br/> subnet_id = aws_subnet.public-subnet.id <br/> vpc_security_group_ids = [aws_security_group.sg-vault.id]<br/> associate_public_ip_address = true<br/> iam_instance_profile = aws_iam_instance_profile.vault-kms-unseal.name<br/> user_data = data.template_file.userdata.rendered<br/> root_block_device {<br/> volume_size = var.root_volume_size<br/>}</em></span><span id="d5f3" class="ld if hh kz b fi lj lf l lg lh"><em class="li">tags = {<br/> Name = “Vault Server”<br/>}</em></span><span id="f752" class="ld if hh kz b fi lj lf l lg lh"><em class="li">depends_on = [aws_kms_key.vault-unseal-key,     aws_dynamodb_table.vault-table]<br/>}</em></span></pre><p id="3147" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">main.tf中的depends_on语句告诉Terraform在实例之前创建解封密钥和DynamoDB表，我们指定这一点是为了确保在安装Vault之前DynamoDB表和密钥都已准备好，否则，Vault安装将会失败，因为它需要DynamoDB来存储数据，并且需要KMS密钥来解封自身。</p><p id="ae25" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">aws_instance资源也引用main.tf中的aws_key_pair，因此我们可以SSH到实例。</p><p id="cd43" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在进入user_data和iam_instance_profile之前，让我们在线获取DynamoDB表。</p><p id="cb26" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">注意Vault的DynamoDB插件来自社区，没有得到Hashicorp的官方支持。</p><h1 id="51bd" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">DynamoDB后端— dynamodb.tf</h1><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3d33" class="ld if hh kz b fi le lf l lg lh">resource “aws_dynamodb_table” “vault-table” {<br/> name = var.dynamodb-table<br/> read_capacity = var.dynamo-read-write<br/> write_capacity = var.dynamo-read-write<br/> hash_key = “Path”<br/> range_key = “Key”<br/> attribute {<br/> name = “Path”<br/> type = “S”<br/> }</span><span id="4c97" class="ld if hh kz b fi lj lf l lg lh">attribute {<br/> name = “Key”<br/> type = “S”<br/>}</span><span id="20b7" class="ld if hh kz b fi lj lf l lg lh">tags = {<br/> Name = “vault-table”<br/> }<br/>}</span></pre><p id="1e07" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这就像为Vault创建一个DynamoDB表一样简单，这也是Vault使用DynamoDB作为后端所需要的。<br/><br/>hash _ key、range_key和属性都是vault本身需要的。</p><h1 id="ed37" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">开启保险库的KMS密钥— kms.tf</h1><p id="987e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">只需创建一个密钥</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5e12" class="ld if hh kz b fi le lf l lg lh"><em class="li">resource “aws_kms_key” “vault-unseal-key” {<br/> description = “KMS Key to unseal Vault”<br/> deletion_window_in_days = 7<br/>}</em></span></pre><h1 id="ef7a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">存储库根令牌和恢复密钥-secrets-manager . TF</h1><p id="6adb" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当Vault首次启动时，它会初始化并发出根令牌和解封密钥。<br/>我们将希望保持这些安全可靠，所以我们把它们放入AWS秘密管理器。<br/>此处的recovery_window_in_days设置为零，因此我们可以根据测试需要随时重新创建密码。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="035d" class="ld if hh kz b fi le lf l lg lh">resource “aws_secretsmanager_secret” “vault-root-token” {<br/> name = var.vault-root-token<br/> description = “Vault root token”<br/> # recovery set to 0 so we can recreate the secret as required for testing.<br/> recovery_window_in_days = 0</span><span id="9f5d" class="ld if hh kz b fi lj lf l lg lh"> tags = {<br/> Name = var.vault-root-token<br/> }<br/>}</span><span id="76b6" class="ld if hh kz b fi lj lf l lg lh">resource “aws_secretsmanager_secret” “vault-recovery-key” {<br/> name = var.vault-recovery-key<br/> description = “Vault recovery key”<br/> # recovery set to 0 so we can recreate the secret as required for testing.<br/> recovery_window_in_days = 0<br/> <br/>tags = {<br/> Name = var.vault-recovery-key<br/> }<br/>}</span></pre><h1 id="c312" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">用户数据-template/vault . sh . TPL</h1><p id="c179" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">实例user_data是使Vault正常工作的基础，并作为data.tf中的Terraform template_file引用，以填充＄{ variable } s。</p><p id="afe5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">下面描述了实例user_data中所需的一切。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9e12" class="ld if hh kz b fi le lf l lg lh"># Pull Vault from Hashicorp releases and unzip it ready for configuration</span><span id="6fc1" class="ld if hh kz b fi lj lf l lg lh">wget <a class="ae ka" href="https://releases.hashicorp.com/vault/1.7.3/vault_1.7.3_linux_amd64.zip" rel="noopener ugc nofollow" target="_blank">https://releases.hashicorp.com/vault/1.7.3/vault_1.7.3_linux_amd64.zip</a> -O /tmp/vault.zip</span><span id="0772" class="ld if hh kz b fi lj lf l lg lh">unzip /tmp/vault.zip -d /usr/bin/ &amp;&amp; rm -f /tmp/vault.zip</span><span id="ce46" class="ld if hh kz b fi lj lf l lg lh">wget <a class="ae ka" href="https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" rel="noopener ugc nofollow" target="_blank">https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64</a><br/>chmod +x jq-linux64<br/>mv jq-linux64 /usr/bin/jq</span><span id="204c" class="ld if hh kz b fi lj lf l lg lh"># Create a vault user and group<br/>groupadd --force --system vault<br/>if ! getent passwd vault &gt;/dev/null; then<br/> adduser --system --gid vault --no-create-home --comment “vault owner” --shell /bin/false vault &gt;/dev/null<br/>fi</span><span id="dae5" class="ld if hh kz b fi lj lf l lg lh"># A default profile for local vault address</span><span id="3b5a" class="ld if hh kz b fi lj lf l lg lh">cat &lt;&lt; EOF &gt; /etc/profile.d/vault.sh<br/>export VAULT_ADDR=http://127.0.0.1:8200<br/>EOF</span><span id="6b56" class="ld if hh kz b fi lj lf l lg lh"># Enable systemd on Amazon Linux for Vault</span><span id="c3a4" class="ld if hh kz b fi lj lf l lg lh">cat &gt; /usr/lib/systemd/system/vault.service &lt;&lt;-EOF<br/>[Unit]<br/>Description=Vault Service<br/>Requires=network-online.target<br/>After=network-online.target<br/>[Service]<br/>Restart=on-failure<br/>PermissionsStartOnly=true<br/>ExecStartPre=/sbin/setcap ‘cap_ipc_lock=+ep’ /bin/vault<br/>ExecStart=/bin/vault server -config /etc/vault/vault.conf<br/>ExecReload=/bin/kill -HUP $MAINPID<br/>KillSignal=SIGTERM<br/>User=vault<br/>Group=vault<br/>[Install]<br/>WantedBy=multi-user.target<br/>EOF</span><span id="360e" class="ld if hh kz b fi lj lf l lg lh"># Reload systemd and enable vault</span><span id="54e8" class="ld if hh kz b fi lj lf l lg lh">systemctl daemon-reload<br/>systemctl enable vault</span><span id="ff48" class="ld if hh kz b fi lj lf l lg lh"># Vault requires a config file, so here we create that config file, set ownership and permissions then start the Vault service.</span><span id="bc53" class="ld if hh kz b fi lj lf l lg lh">mkdir /etc/vault<br/>cat &gt; /etc/vault/vault.conf &lt;&lt;-EOF<br/>listener "tcp" {<br/>  address = "0.0.0.0:8200"<br/>  tls_disable = 1<br/>}<br/>ui = true<br/>storage "dynamodb" {<br/>  region = "${region}"<br/>  table = "${dynamodb-table}"<br/>  read_capacity = 3<br/>  write_capacity = 3<br/>}<br/>seal "awskms" {<br/>  region = "${region}"<br/>  kms_key_id = "${unseal-key}"<br/>}<br/>EOF</span><span id="2066" class="ld if hh kz b fi lj lf l lg lh">chown -R vault:vault /etc/vault<br/>chmod -R 0644 /etc/vault/*<br/>mkdir /var/log/vault<br/>chown vault:vault /var/log/vault<br/>systemctl start vault</span></pre><p id="719e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">配置文件将我们创建的DynamoDB表指定为后端，并将我们创建的AWS KMS键指定为解封Vault。</p><p id="6683" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这将检查Vault是否已经初始化，如果是，它将简单地检查实例是否可以使用其实例配置文件登录，然后用户数据脚本退出。</p><p id="71b6" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">否则，如果保险库未初始化，我们将对其进行初始化，并将根令牌和恢复密钥保存到AWS Secrets Manager。</p><p id="4329" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">继续处理用户数据。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="89d2" class="ld if hh kz b fi le lf l lg lh">export VAULT_ADDR=http://127.0.0.1:8200</span><span id="798a" class="ld if hh kz b fi lj lf l lg lh"># Check if vault is already initialised</span><span id="af71" class="ld if hh kz b fi lj lf l lg lh">INITIALIZED=$(curl $VAULT_ADDR/v1/sys/init | jq '.initialized')<br/>if [ "$${INITIALIZED}" != "true" ]; then<br/>  echo "[] Vault DB not initialised, initialising now"<br/>  ## Initialise vault and save token and unseal key<br/>  vault operator init -recovery-shares=1 -recovery-threshold=1 2&gt;&amp;1 | tee ~/vault-init-out.txt<br/>  echo “[] Vault status output”<br/>  vault status | tee -a ~/vault-status.txt<br/>  # Get the VAULT_TOKEN so we can interact with vault<br/>  export VAULT_TOKEN=$(grep '^Initial Root Token:' ~/vault-init-out.txt | awk '{print $NF}')</span><span id="2220" class="ld if hh kz b fi lj lf l lg lh">  # Get the unseal key<br/>  export RECOVERY_KEY=$(grep '^Recovery Key' ~/vault-init-out.txt | awk '{print $NF}')<br/>  # Save the root token and recovery key to aws secrets manager, then we can delete ~/vault-init-out.txt</span><span id="8e46" class="ld if hh kz b fi lj lf l lg lh">  # The secret resources have already been created by terraform (secrets-manager.tf)</span><span id="011d" class="ld if hh kz b fi lj lf l lg lh"> aws secretsmanager update-secret — secret-id ${secret_token_id} — secret-string "$${VAULT_TOKEN}" — region ${region}</span><span id="c781" class="ld if hh kz b fi lj lf l lg lh">  aws secretsmanager update-secret — secret-id ${secret_recovery_id} --secret-string "$${RECOVERY_KEY}" — region ${region}</span><span id="3d27" class="ld if hh kz b fi lj lf l lg lh">  # Remove the temp file which has the root token details<br/>  rm -f ~/vault-init-out.txt<br/>else<br/>  # Vault already initialised, which means the db is up which has our role, so login with that role, then exit this script.</span><span id="a1a6" class="ld if hh kz b fi lj lf l lg lh">  echo "[] Vault DB already initialised. Check we can login with aws method and exit"<br/>  vault login -method=aws role=admin<br/>  echo “[] Userdata finished.”<br/>  exit<br/>fi</span></pre><p id="ba14" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果保险库尚未初始化，上述If语句不会退出，用户数据将继续。<br/>它启用了Vault审计文件，启用了aws auth和kv secrets引擎。<br/>然后，它提取我们上传到S3的管理策略，并将该策略写入Vault，将该策略分配给Vault实例角色。</p><p id="d485" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">继续处理用户数据。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c750" class="ld if hh kz b fi le lf l lg lh"># Enable vault logging<br/>vault audit enable file file_path=/var/log/vault/vault.log</span><span id="e33c" class="ld if hh kz b fi lj lf l lg lh"># Enable the vault AWS and kv engine<br/>vault auth enable aws</span><span id="f004" class="ld if hh kz b fi lj lf l lg lh">vault secrets enable -path=secret -version=2 kv</span><span id="7f82" class="ld if hh kz b fi lj lf l lg lh"># Get the vault-admin-policy.hcl file that was uploaded to S3 in s3.tf<br/>aws s3 cp s3://${vault_bucket}/vault-admin-policy.hcl /var/tmp/</span><span id="1d6b" class="ld if hh kz b fi lj lf l lg lh"># Create the admin policy in vault<br/>vault policy write "admin-policy" /var/tmp/vault-admin-policy.hcl</span><span id="018a" class="ld if hh kz b fi lj lf l lg lh"># Give this instance admin privileges to vault, tied to this instances vault_instance_role.</span><span id="7b64" class="ld if hh kz b fi lj lf l lg lh">vault write \<br/>auth/aws/role/admin \<br/>auth_type=iam \<br/>policies=admin-policy \<br/>max_ttl=1h \<br/>bound_iam_principal_arn=${vault_instance_role}</span><span id="7526" class="ld if hh kz b fi lj lf l lg lh">echo "[] Userdata finished."</span></pre><p id="263b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这是Vault complete的user_data。在data.tf中查找传递到文件中的${variables}。</p><h1 id="ccda" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">用户数据模板文件— data.tf</h1><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="fac4" class="ld if hh kz b fi le lf l lg lh">data "template_file" "userdata" {<br/> template = file("${path.module}/templates/vault.sh.tpl")<br/> vars = {<br/>   region = var.region<br/>   dynamodb-table = var.dynamodb-table<br/>   unseal-key = aws_kms_key.vault-unseal-key.id<br/>   instance-role = aws_iam_role.vault-kms-unseal.name<br/>   vault_instance_role =  "arn:aws:iam:${var.region}:${var.account_id}:role/${aws_iam_role.vault-kms-unseal.name}"<br/>   vault_bucket = var.bucket_name<br/>   secret_token_id = aws_secretsmanager_secret.vault-root-token.id<br/>   secret_recovery_id = aws_secretsmanager_secret.vault-recovery-key.id<br/> }<br/>}</span></pre><h1 id="a0f1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">实例配置文件—实例配置文件. tf</h1><p id="e06c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如在Vault的用户数据中看到的，实例本身需要访问S3、秘密管理器、KMS和DynamoDB。我们创建一个IAM角色来满足这些要求，然后将其分配给main.tf中的Vault iam_instance_profile。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8ff2" class="ld if hh kz b fi le lf l lg lh">data “aws_iam_policy_document” “assume_role” {<br/>  statement {<br/>    effect = “Allow”<br/>    actions = [“sts:AssumeRole”]<br/>    principals {<br/>    type = “Service”<br/>    identifiers = [“ec2.amazonaws.com”]<br/>    }<br/>  }<br/>}</span><span id="87b2" class="ld if hh kz b fi lj lf l lg lh">data “aws_iam_policy_document” “vault-kms-unseal” {<br/>  statement {<br/>    sid = “VaultKMSUnseal”<br/>    effect = “Allow”<br/>    resources = [“*”]<br/>    actions = [<br/>      “kms:Encrypt”,<br/>      “kms:Decrypt”,<br/>      “kms:DescribeKey”<br/>    ]<br/>  }<br/>  statement {<br/>    sid = “VaultDynamoDB”<br/>    effect = “Allow”<br/>    resources = [aws_dynamodb_table.vault-table.arn]<br/>    actions = [<br/>      “dynamodb:DescribeLimits”,<br/>      “dynamodb:DescribeTimeToLive”,<br/>      “dynamodb:ListTagsOfResource”,<br/>      “dynamodb:DescribeReservedCapacityOfferings”,<br/>      “dynamodb:DescribeReservedCapacity”,<br/>      “dynamodb:ListTables”,<br/>      “dynamodb:BatchGetItem”,<br/>      “dynamodb:BatchWriteItem”,<br/>      “dynamodb:CreateTable”,<br/>      “dynamodb:DeleteItem”,<br/>      “dynamodb:GetItem”,<br/>      “dynamodb:GetRecords”,<br/>      “dynamodb:PutItem”,<br/>      “dynamodb:Query”,<br/>      “dynamodb:UpdateItem”,<br/>      “dynamodb:Scan”,<br/>      “dynamodb:DescribeTable”<br/>    ]<br/>  }<br/>  statement {<br/>    sid = “IAM”<br/>    effect = “Allow”<br/>    resources = [“*”]<br/>    actions = [<br/>      “iam:GetInstanceProfile”,<br/>      “iam:GetRole”,<br/>      “iam:CreateAccessKey”,<br/>      “iam:DeleteAccessKey”,<br/>      “iam:GetAccessKeyLastUsed”,<br/>      “iam:GetUser”,<br/>      “iam:ListAccessKeys”,<br/>      “iam:UpdateAccessKey”,<br/>      “sts:AssumeRole”<br/>    ]<br/>  }<br/>  statement {<br/>    sid = “S3”<br/>    effect = “Allow”<br/>    resources = [“arn:aws:s3:::${var.bucket_name}/*”]<br/>    actions = [<br/>      “s3:GetObject”<br/>    ]<br/>  }<br/>  statement {<br/>    sid = “SecretsManager”<br/>    effect = “Allow”<br/>    resources = [<br/>      aws_secretsmanager_secret.vault-root-token.id,         aws_secretsmanager_secret.vault-recovery-key.id<br/>    ]<br/>    actions = [<br/>      “secretsmanager:UpdateSecret”,<br/>      “secretsmanager:GetSecretValue”<br/>    ]<br/>  }<br/>}</span><span id="45e6" class="ld if hh kz b fi lj lf l lg lh">resource “aws_iam_role” “vault-kms-unseal” {<br/>  name = var.instance-role<br/>  assume_role_policy = data.aws_iam_policy_document.assume_role.json<br/>}</span><span id="42b8" class="ld if hh kz b fi lj lf l lg lh">resource “aws_iam_role_policy” “vault-kms-unseal” {<br/>  name = var.instance-role-policy<br/>  role = aws_iam_role.vault-kms-unseal.id<br/>  policy = data.aws_iam_policy_document.vault-kms-unseal.json<br/>}</span><span id="de92" class="ld if hh kz b fi lj lf l lg lh">resource “aws_iam_instance_profile” “vault-kms-unseal” {<br/>  name = var.instance-profile<br/>  role = aws_iam_role.vault-kms-unseal.name<br/>}</span></pre><h1 id="448d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">未包括在内</h1><p id="6ebe" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我没有在这里包括VPC设置，安全组，互联网网关和变量。tf，因为这篇文章是关于与地形的Vault。</p><p id="c0f7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要获得完整代码，请从<a class="ae ka" href="https://github.com/nicklunt/vault.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nicklunt/vault.git</a>下载，并更改variables.tf中的以下变量以适应您的环境。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0a36" class="ld if hh kz b fi le lf l lg lh"># Change region for your env<br/>variable “region” {<br/>  type = string<br/>  default = “eu-west-2”<br/>}</span><span id="9701" class="ld if hh kz b fi lj lf l lg lh"># Change this to your aws account<br/>variable “account_id” {<br/>  description = “AWS Account ID”<br/>  type = string<br/>  default = “01234567890”<br/>}</span><span id="25cf" class="ld if hh kz b fi lj lf l lg lh"># Change this to your external IP<br/>variable “my_ip” {<br/>  description = “my external IP address”<br/>  type = string<br/>  default = “aa.bb.cc.dd/32”<br/>}</span><span id="6008" class="ld if hh kz b fi lj lf l lg lh"># May need to change the AMI if not in eu-west-2<br/>variable “ami” {<br/>  description = “eu-west-2 Amazon Linux 2 AMI”<br/>  type = string<br/>  default = “ami-0a669382ea0feb73a”<br/>}</span><span id="9a06" class="ld if hh kz b fi lj lf l lg lh"># I’m using a small instance type for testing<br/>variable “aws_instance_type” {<br/>  description = “aws instance type”<br/>  type = string<br/>  default = “t2.micro”<br/>}</span><span id="a9a2" class="ld if hh kz b fi lj lf l lg lh"># Size of the OS volume<br/>variable “root_volume_size” {<br/>  description = “size of the os volume in GB”<br/>  type = string<br/>  default = “50”<br/>}</span><span id="83fa" class="ld if hh kz b fi lj lf l lg lh"># May need to change the bucket to something unique<br/>variable “bucket_name” {<br/>  description = “Bucket to upload any required files”<br/>  type = string<br/>  default = “vault-conf-bucket-01010101”<br/>}</span><span id="8b67" class="ld if hh kz b fi lj lf l lg lh"># If running terraform from linux, generate the ssh-key with<br/># $ cd &lt;vault terraform directory&gt;<br/># $ ssh-keygen -y -f ~/.ssh/id_rsa &gt; public_key<br/>variable “ssh-key” {<br/>  type = string<br/>  description = “File holding my public ssh key: ssh-keygen -y -f ~/.ssh/id_rsa &gt; public_key”<br/>  default = “public-key”<br/>}</span></pre><h1 id="51c5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">运行地形</h1><p id="1644" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在运行Terraform之前，请记住在与Terraform文件相同的目录中创建密钥，以便在构建实例后可以通过SSH连接到实例。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="fb59" class="ld if hh kz b fi le lf l lg lh">$ ssh-keygen -y -f ~/.ssh/id_rsa &gt; public_key<br/>$ terraform plan</span><span id="1e40" class="ld if hh kz b fi lj lf l lg lh"><em class="li">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:<br/>+ create<br/>&lt;= read (data resources)<br/>Plan: 18 to add, 0 to change, 0 to destroy.</em></span></pre><p id="9612" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">运行terraform apply以创建资源</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="eafe" class="ld if hh kz b fi le lf l lg lh">$ terraform apply -auto-approve</span><span id="f7b6" class="ld if hh kz b fi lj lf l lg lh"><em class="li">Apply complete! Resources: 18 added, 0 changed, 0 destroyed.</em></span><span id="ff5c" class="ld if hh kz b fi lj lf l lg lh"><em class="li">Outputs:<br/>Authenticate_to_vault = “vault login -method=aws role=admin”<br/>Connect_to_vault_UI = “http://123.123.123.123:8200"<br/>Connect_to_vault_instance = “ssh </em><a class="ae ka" href="mailto:ec2-user@35.177.126.83" rel="noopener ugc nofollow" target="_blank"><em class="li">ec2-user@</em></a><em class="li">123.123.123.123”</em></span></pre><p id="6ada" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">所以现在我们在AWS中运行Vault，使用DynamoDB作为后端，并且自动解封。</p><p id="eac2" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">让我们试着连接到它。</p><h1 id="f22f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">连接到保管库</h1><p id="42f2" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Terraform输出(outputs.tf)向我们展示了如何连接。</p><p id="bb62" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">从我们的开发站测试跳马</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ac8a" class="ld if hh kz b fi le lf l lg lh">$ export VAULT_ADDR=http://<em class="li">123.123.123.123</em>:8200<br/>$ vault status</span><span id="63ba" class="ld if hh kz b fi lj lf l lg lh">Key Value<br/>— — — -<br/>Recovery Seal Type shamir<br/>Initialized true<br/>Sealed false<br/>Total Recovery Shares 1<br/>Threshold 1<br/>Version 1.7.3<br/>Cluster Name vault-cluster-3a7ac91b<br/>Cluster ID 12f3f95e-4be3–75bb-735e-f4a485317b1d<br/>HA Enabled false</span></pre><p id="5d9d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">成功，我们可以看到保险库被初始化和解封。<br/> <br/>测试我们可以从我们的开发站进入<a class="ae ka" href="http://35.177.126.83:8200" rel="noopener ugc nofollow" target="_blank">http://</a><em class="li">123.123.123.123</em><a class="ae ka" href="http://35.177.126.83:8200" rel="noopener ugc nofollow" target="_blank">:8200</a>的金库UI</p><p id="924a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果您进入AWS Secrets Manager并搜索“vault-root-token”机密，您可以在此处使用它登录vault。</p><p id="b64d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">最后，让我们通过SSH访问Vault实例，并尝试使用实例概要文件登录Vault</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c1ec" class="ld if hh kz b fi le lf l lg lh">$ ssh ec2-user@<em class="li">123.123.123.123<br/></em>[ec2-user ~]$ vault login -method=aws role=admin</span><span id="05f5" class="ld if hh kz b fi lj lf l lg lh">Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run “vault login” again. Future Vault requests will automatically use this token.</span><span id="01c7" class="ld if hh kz b fi lj lf l lg lh">Key Value<br/>— — — -<br/>token s.BqtXOSb59vbBi9qyn52zEwRt<br/>token_accessor UY7sX672lOgZaxdZqYpJTKLO<br/>token_duration 1h<br/>token_renewable true<br/>token_policies [“admin-policy” “default”]<br/>identity_policies []<br/>policies [“admin-policy” “default”]<br/>token_meta_account_id 01234567890<br/>token_meta_auth_type iam<br/>token_meta_role_id ae364a87–95t7–84n7–5835–73h74b875</span></pre><p id="8025" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">更加成功！这证明Vault实例本身可以根据实例配置文件登录Vault。</p><h1 id="332c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">最后</h1><p id="c6e3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">希望这已经展示了如何在使用Terraform部署vault时自动解封Vault，虽然本指南中有相当多的代码，但实际的解封只是Vault配置文件中引用KMS密钥来解封自身的一节。</p><p id="b5f8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在制作过程中，我们会将跳马聚集在一个ASG中，前面是一个ELB。当然，让它运行HTTPS而不是HTTP。</p><p id="72d2" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果你有兴趣测试这一切，完整的代码可以在GitHub、<a class="ae ka" href="https://github.com/nicklunt/vault.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nicklunt/vault.git</a>获得，其中包括VPC、安全组等。只需更改variables.tf顶部注释良好的变量即可。</p><p id="6815" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">谢谢你读到这里，祝你好运。</p><figure class="ku kv kw kx fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/ae690eb6ceb40ff42b66ca9f4d81a16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDfmsKL-56ro_XYjfPc9WQ.jpeg"/></div></div></figure><p id="863d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">关于作者</strong> <br/>尼克·伦克是Version 1的DevOps工程师。</p></div></div>    
</body>
</html>