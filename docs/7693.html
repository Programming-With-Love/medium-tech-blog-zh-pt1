<html>
<head>
<title>Migrating Angular 1.x apps to React — The Hybrid Way!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迁移Angular 1.x应用程序以做出反应——混合方式！</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/migrating-angular-1-x-apps-to-react-the-hybrid-way-3267ccf33755?source=collection_archive---------1-----------------------#2017-11-15">https://medium.com/walmartglobaltech/migrating-angular-1-x-apps-to-react-the-hybrid-way-3267ccf33755?source=collection_archive---------1-----------------------#2017-11-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/41ab8ee6a7706ee09a447a3d85c9dbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kr1CH97hSShIdX_jZQEoQ.jpeg"/></div></figure><p id="701e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi jj translated"><span class="l jk jl jm bm jn jo jp jq jr di">在这个前端空间飞速发展的时代，当你完成研发、选择框架、构建应用并发布到生产环境时，它已经过时了，这很常见！与此同时，必须用全新的、明亮的和闪亮的概念验证来构建概念验证，看看它在您的用例中是否有意义或表现得更好。</span></p><p id="3f09" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于那些正在寻找将大型生产Angular应用程序迁移到React的策略，但由于将指令重新写入React组件的痛苦和耗时过程而无法继续前进的人来说，这篇文章非常有用。在这篇文章中，我将讨论一种混合方法，这种方法可以用来用React组件迭代地构建新特性，并在您现有的Angular应用程序或未来的React应用程序中使用它们。其思想是构造独立的React组件，并通过局部而不是全局使用<code class="du js jt ju jv b">ReactDOM.render</code>函数进行渲染。我采用这种方法将我们的web应用生态系统的前端从Angular 1.x逐步迁移到React。我还将讨论它背后的动机，Chrome JS profiler计算性能增益的实验，以及我为什么选择react。</p><p id="a262" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">给大家介绍一下我自己的背景，我是电子商务部门的首席全栈工程师。我们是一个由3-5名全栈工程师组成的小团队，构建并支持主要基于Node/Express/Angular 1.x栈构建的web应用生态系统。我们使用Webpack 2作为我们的任务运行器，用ES6编写的代码通过Babel传输到ES5。客户端是一个与节点层对话的angular SPA。节点层通过REST APIs与Couchbase DB和其他后端系统集成，JSON是数据交换格式。我们有大约25个前端可重复使用的角度自定义指令，在3个web应用程序之间共享。</p><p id="59ce" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，让我们来谈谈这种方法，它本质上使用了现有的ng控制器，并在其中嵌入了react视图。</p><h1 id="a6a6" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">混合动力的游戏</h1><p id="6dbf" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">这种方法的先决条件是您使用的角度路由器具有解耦的控制器和依赖关系。</p><p id="72e8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它独立于ES6，可以用ES5语法编写。</p><p id="6246" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">目标是在不同的路由调用上独立地呈现react或angular视图。如果是一个react视图，它应该能够利用在<code class="du js jt ju jv b">$rootScope</code>中定义的角度<code class="du js jt ju jv b">$scope</code>变量或属性，并且应该能够调用在<code class="du js jt ju jv b">$scope</code>中定义的事件处理程序</p><p id="89c2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是我的示例角度控制器，它呈现了一个反应视图</p><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es lb"><img src="../Images/085017f5f133c1c52490104babb2a7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*xNpRWvTutZDKT8i_i0GP6Q.png"/></div></figure><p id="80d5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里，控制器函数<code class="du js jt ju jv b">myController</code>实例化某些构造函数变量和函数，调用在<code class="du js jt ju jv b">myAngularServiceforAjaxCalls</code>中定义的<code class="du js jt ju jv b">getResults</code>函数。在成功回调中，<code class="du js jt ju jv b">$scope</code>由服务响应填充。</p><p id="ba58" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们移到第37行时，我的自定义<code class="du js jt ju jv b">render</code>函数调用<code class="du js jt ju jv b">ReactDOM.render</code>函数，这意味着我们现在在react上下文中，可以使用自定义react组件。快速调用——你需要用一个定制的渲染函数封装<code class="du js jt ju jv b">ReactDOM.render</code>,这样你只需在承诺完成后渲染你的react视图。</p><p id="e3c1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里要注意的另一件事是我将<code class="du js jt ju jv b">changePage</code>附加到<code class="du js jt ju jv b">$scope.</code>上，这是因为我想停留在有角度的<code class="du js jt ju jv b">$scope</code>上下文中。这也可以直接附加到您的函数上下文aka <code class="du js jt ju jv b">this</code>中。</p><p id="fd80" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我的纯react组件、<code class="du js jt ju jv b">WMPageHeader</code>、<code class="du js jt ju jv b">WMBreadcrumb</code>和<code class="du js jt ju jv b">WMGrid</code>被添加为控制器依赖项，因此它们可以在视图中调用，props可以用控制器范围的变量和对象填充。</p><p id="3dc3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是我的react组件的一个例子。正如您在这里看到的，没有任何角度依赖性，这意味着这些组件是100% react的，可以与任何其他react应用程序重用。这是这种方法的另一个优点。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/390256b84174b3331cd88c484ff993ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUzZ57p2Ik5a0L8srtyV4w.png"/></div></div></figure><p id="191d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，让我们来看看我们需要在主应用程序视图中进行的更改。在我的<code class="du js jt ju jv b">index.hbs</code>中，我简单地为我的react视图添加了一个id attr <code class="du js jt ju jv b">render-container</code>。<code class="du js jt ju jv b">data-ui-view</code>角度视图保持不变。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/edffafdbf98b80e4f726c62e206f5957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*ctVbJ6D8VUKZ7kyLEMQ36g.png"/></div></figure><p id="ce65" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是了。我们都完了！现在，我可以反复进行重写工作，只转换我的新特征/视图中需要的那些角度指令。一旦我实现了100%的转换，我就可以简单地抛弃我旧的角度指令，继续用react构建我的应用程序！</p><h1 id="4c37" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">动机</h1><p id="e993" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">当涉及到嵌套的作用域和观察器时，Angular 1.x在性能方面臭名昭著，这不是一个隐藏的事实。当您在开源指令的基础上构建定制指令时，这个问题变得更加突出。想象一下，这些指令组成了一个包含多个Ajax请求的视图。</p><p id="0227" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">也就是说，如果我没有发现React的好处，角度性能对我来说是很正常的。</p><h1 id="9836" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">性能增益</h1><p id="d246" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">作为一个实验，我决定采用应用程序最复杂的视图，并用React重新创建它。</p><p id="e455" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下是Chrome JS Profiler的观点:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lm"><img src="../Images/e5d1ec2446c303626896569ae922a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go93TtTBO7DMfwTh5QEKKg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Chrome JS Profiler results with Angular</figcaption></figure><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lr"><img src="../Images/8426da25f7c139a49ee2ba0fe25ff1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gshgrWo1jfGHEa4VwuNAIw.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Chrome JS Profiler results with React</figcaption></figure><p id="4e5d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">正如你在上面看到的，脚本减少了35.5%，渲染减少了62.5%，绘画减少了39%，视图渲染总共减少了1.5秒！</p><h1 id="7b8f" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我为什么选择React？</h1><p id="58ec" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">有明显的技术原因来尝试React。它使得DOM节点的渲染/重新渲染快如闪电。更不用说它革命性的虚拟DOM概念和只在需要时通过树差异机制更新真实DOM。</p><p id="84ad" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">此外，电极是基于React和哈比神构建的本土网络应用平台，最好有电极就绪的React组件，以便将来用它编写任何网络应用。</p><p id="17af" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">推特:@ ankuronweb</p></div></div>    
</body>
</html>