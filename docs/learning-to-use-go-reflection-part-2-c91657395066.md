# 学习使用 Go 反射—第 2 部分

> 原文：<https://medium.com/capital-one-tech/learning-to-use-go-reflection-part-2-c91657395066?source=collection_archive---------1----------------------->

## [在 Go 上连续贴 6 张](/@jon_43067)

![](img/dfd31d78696875f52fac861e50605748.png)

在[我的上一篇博客文章](/capital-one-developers/learning-to-use-go-reflection-822a0aed74b7)中，我们查看了 Go 的反射包，并快速演示了它的一些特性。不清楚的是这些功能何时会有用。我们用反射做的所有事情都可以在没有它的情况下实现——而且会更高效，更简洁。但是我们也知道，Go 团队不喜欢为了特性而包含特性。那么，反射能实现什么呢？

# 寻找我的倒影

好的，我们可以用反射做所有这些巧妙的技巧，但是我如何在日常程序中使用它们呢？

很大程度上，你不会。反射是一种在幕后使用的工具，它让通常不可能的事情成为可能。它隐藏在一些(如果不是大多数)库和工具的实现中。

如何判断一个库是否在使用反射？最大的提示是检查参数的类型。如果你调用一个带有类型 interface{}参数的函数，它很可能会使用反射来检查或改变参数的值。

[![](img/a94559d31aeb80a7fd55aff68f92d34c.png)](https://twitter.com/CapitalOneDevEx)

# 处理 JSON

反射最常见的用途是从文件或网络中封送和解封送数据。每当您为 JSON 或数据库映射指定 struct 标记时，您都依赖于反射。您正在调用填充 struct 实例的库，使用反射来分析 struct 标记和设置 struct 字段上的值。

让我们通过查看实现 JSON 解组的 Go 标准库内部的代码来看看这是如何实现的。

为了将 json 字符串中的值放入变量中，我们调用 JSON。解组功能。它接受两个参数。

*   包含 JSON 文本的类型是[]byte。
*   我们要填充的变量的类型是 interface{}。

这是我们的暗示，反射将要发生。

如果您深入研究代码，您会得到一个名为 unmarshal 的包私有方法。相关部分如下所示:

它使用反射来验证 v 是一种正确的变量，一个指针。如果是，则 v 的反射版本(称为 rv)被传递给 value 方法。

在跳过一些函数和方法之后，我们使用反射以不同的方式填充 rv，这取决于 JSON 是表示数组、对象还是文字。例如，在解析 JSON 对象时，标准库以多种方式使用反射。

反射用于测试它是否填充到 nil 接口{}:

或者如果它被填充到地图中:

并且在填充结构中的字段时使用反射:

这只是用于解码 JSON 的反射代码的一小部分。如果你想自己浏览这段代码，可以在围棋标准库中找到:[https://golang.org/src/encoding/json/decode.go](https://golang.org/src/encoding/json/decode.go)

# 记忆和短期记忆

填充数据结构是反射的一个用例。但是其他人呢？让我们尝试构建我们自己的库，它使用反射来实现一个使用*记忆化*的短期缓存。

如果您不熟悉这个术语，记忆化是函数式编程领域的一种技术。函数式编程语言倾向于强加某些规则。比如参数和变量往往是*不可变的*；它们在构造后不能更改。函数式编程语言也试图限制*副作用*。这是函数所做的事情的名称，但是这些事情在函数返回的值中是不可见的。

没有副作用是不可能有一个有用的程序的——因为它们包括像打印到屏幕上或写入文件或将数据放入数据库中这样的事情——但是一些副作用，如修改全局变量，会产生难以理解的程序。函数式编程的目标之一是让程序中的数据流变得更容易，这反过来也让理解程序实际上在做什么变得更容易。

这种编程风格还有其他一些好处。当您有一个输入参数和返回值都是不可变的函数并且该函数没有副作用时，您可以看到，使用相同的值对该函数的每次调用都将做完全相同的工作并返回完全相同的结果。如果你保存这些结果，就没有必要重复做这些工作。

这就把我们带到了记忆化。这很像函数级的缓存。记忆化是创建一个函数的过程，该函数包装了这些不变函数中的一个，缓存输入和输出值以避免做不必要的工作。当一个函数被记忆时，每组输入值只做一次。如果第二次传递相同的输入值，则从缓存中提取返回值，而不是重新计算。对于执行复杂或缓慢任务的函数，性能节省是巨大的。

现在，Go 可能不是一种函数式语言，但我们仍然可以应用其中的一些思想。这种编程风格有点限制性，但是避免修改输入和输出参数并最小化副作用会使您的程序更容易理解和维护。

与其永远缓存，不如让我们看一下短时间的缓存。这是微服务架构中非常常见的模式。以下是它有用的情况:

> 你有一个提供价值的服务，另一个使用这个价值。因为有一个网络调用来获取值，所以需要一些时间。这确实会降低整个系统的性能。当值不经常改变时，即使值过期几秒钟也没关系，临时缓存该值可以显著提高系统性能。如果我们能够避免额外的网络调用，并且在不对 API 进行大量修改的情况下实现缓存，那就太好了。

那么我们如何在 Go 中实现基于记忆的缓存呢？我们将使用反射做三件事:

*   确保输入类型是至少有一个输入参数和一个输出参数的函数。
*   创建一个全新的结构，它的字段类型与传入函数的输入参数类型相同。
*   制作一个输入参数和输出参数与传入函数匹配的全新函数。

我们还将引入另一个限制:输入参数必须都是*可比的*。在围棋中，可比较的类型是可以用==比较的类型。我们将使用一个映射来关联我们的输入值和输出值，Go 中的一个规则是映射的键必须是可比较的。这是有道理的。为了判断我们以前是否见过输入参数，我们需要能够检查它们是否相等。

幸运的是，在围棋中，只有四样东西没有可比性:

*   部分
*   地图
*   功能
*   包含切片、映射或函数类型字段的结构

让我们从缓存器函数的定义开始。看起来是这样的:

这做得不多，但至少我们知道我们要构建什么。让我们从填充反射检查开始，以确保我们有一个传递给我们的函数。

现在，我们需要构建用于保存输入参数的结构。在构建这个结构时，我们还将确保至少有一个输入参数、一个输出参数，并且所有的输入参数都是可比较的。

只剩下一步了，声明我们将用来保存输入和输出值的缓存的映射，并使用反射来生成我们的缓存函数:

就是这样！

让我们浏览一下这段代码。我们首先定义一个 outExp 类型来保存输出值和缓存值到期的时间。

然后我们声明一个映射 m，其中键是 interface{}，值是 outExp。选择这些类型是出于实际原因。正如我们在前面使用反射构建结构的例子中看到的，我们没有可以用来表示反射生成的结构的类型名。为了存储它的实例，我们必须使用 interface{}类型的变量。至于返回类型，当您使用反射调用函数时，返回类型是[]reflect.Value。这也是从传递到 reflect.MakeFunc 的闭包返回的值。为了避免复制值，我们只保留[]reflect。我们从反射函数调用中获取的值，并将其存储在我们的映射中。

在我们的闭包中，我们使用反射来构造自定义类型的新实例，并用运行时传递给函数的值填充它的字段。然后，我们检查 m 中是否已经有与该实例相等的内容。如果没有，或者如果有，但已经过期，我们调用包装的函数，将响应和过期时间存储在 ov 中，并将它存储在 m 中，并将自定义结构的实例作为键。然后，我们返回 ov.out 中存储的输入值。

就这样，我们编写了一个缓存器工厂函数，它将 Go 中的几乎所有函数包装在一个有时间限制的缓存中。

那么，我们如何使用这些代码呢？这里有一个简单的例子:

虽然真实的例子会进行数据库查找或 web 服务调用，但我们的示例函数只是休眠 100ms，然后将两个数字相加。由于 Go 没有泛型，我们需要将缓存的函数转换回正确的类型。因为我们还要检查错误，所以这需要几行代码将错误和缓存函数的接口{}表示放入变量中，然后将缓存实例转换为正确的类型。

如果我们运行这段代码，我们会看到如下数字:

```
$ go run cacher.go
got result 3 in 100.079405ms
got result 3 in 3.873µs
got result 3 in 561ns
got result 3 in 462ns
got result 3 in 398ns
got result 3 in 100.054602ms
```

我们第一次运行它需要 100 毫秒(加上一些开销)，在同一个 2 秒窗口内的后续调用需要几百纳秒。在 3 秒钟的停顿后，最后一次呼叫再次进行 100 毫秒。

你可以在 https://play.golang.org/p/GNXG4CpG-E 的围棋运动场看这段代码

# 你的新秘密武器

还有最后一件事需要注意。使用反射确实会对性能产生影响。如果您正在进行非常密集的数学计算或通过网络与外部服务对话，添加一层使用反射的代码不会产生显著的影响。然而，大多数代码都非常快。很有可能你代码中的大多数方法运行起来都不到几百纳秒。在这些情况下，当您使用反射和生成的函数增强代码时，您需要小心。这将会造成性能损失，您必须决定是否值得增加的功能带来更慢的性能和更复杂的代码。

这应该会让您体验到在 Go 中可以通过反射解决的各种问题。这不是一个你可以一直使用的解决方案，但是当你遇到一个看起来不可能的问题时，因为类型之间没有共性，或者因为数据是动态的，反射是你的秘密武器。

***披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则 Capital One 不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权是其各自所有者的所有权。本文为 2017 首都一。***

# 附加链接

[在不久的将来…](/capital-one-developers/in-the-not-too-distant-future-e2d0ad28e91)

[缓冲通道——它们有什么用？](/capital-one-developers/buffered-channels-in-go-what-are-they-good-for-43703871828)

[闭包是 Go 的泛型](/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5)

[在 Go 中构建无界通道](/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd)