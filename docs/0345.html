<html>
<head>
<title>#31DaysOfKotlin — Week 4 Recap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated"># 31日sOfKotlin —第4周回顾</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/31daysofkotlin-week-4-recap-d820089f8090?source=collection_archive---------6-----------------------#2018-04-26">https://medium.com/androiddevelopers/31daysofkotlin-week-4-recap-d820089f8090?source=collection_archive---------6-----------------------#2018-04-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c6a8873718f7a90cfe9166b18cd1e191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIiSOmdbaTKqZmUDCgq2Sg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="1706" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能和<a class="ae hu" href="https://github.com/android/android-ktx" rel="noopener ugc nofollow" target="_blank"> Android KTX </a>一起让我们的Android代码更加简洁、清晰和令人愉快。我们(<a class="ae hu" href="https://twitter.com/objcode" rel="noopener ugc nofollow" target="_blank"> @objcode </a>和<a class="ae hu" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"> @FMuntenescu </a>)开始了<a class="ae hu" href="https://twitter.com/search?q=%2331DaysOfKotlin" rel="noopener ugc nofollow" target="_blank"> #31DaysOfKotlin </a>系列，作为分享我们最喜欢的Kotlin和Android KTX功能的一种方式，并希望让更多的人像我们一样喜欢它。</p><p id="e02f" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">第四周学习了更多的语言基础知识，然后深入研究了Android KTX让你的代码更加简洁易读的一些方法。</p><p id="55f0" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">查看第1周、第2周和第3周的概要:</p><div class="hg hh ez fb hi jt"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-1-recap-fbd5a622ef86"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hy fi z dy jy ea eb jz ed ef hw bi translated"># 31日sOfKotlin —第1周回顾</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ho jt"/></div></div></a></div><div class="hg hh ez fb hi jt"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-2-recap-9eedcd18ef8"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hy fi z dy jy ea eb jz ed ef hw bi translated"># 31日sOfKotlin —第2周回顾</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="ki l ke kf kg kc kh ho jt"/></div></div></a></div><div class="hg hh ez fb hi jt"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-3-recap-20b20ca9e205"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hy fi z dy jy ea eb jz ed ef hw bi translated"># 31日sOfKotlin —第3周回顾</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kj l ke kf kg kc kh ho jt"/></div></div></a></div><h1 id="033f" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><em class="iu">第22天:从Java编程语言调用kot Lin</em></h1><p id="63b1" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">在同一个项目中使用Kotlin和Java？你有顶级函数或属性的类吗？默认情况下，编译器将类名生成为<code class="du ln lo lp lq b">YourFileKt</code>。通过用<code class="du ln lo lp lq b">@file:JvmName</code>注释文件来改变它。文档:<a class="ae hu" href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#package-level-functions" rel="noopener ugc nofollow" target="_blank">包级功能</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="1ec6" class="lz kl hx lq b fi ma mb l mc md">// File: ShapesGenerator.kt<br/>package com.shapes</span><span id="0b32" class="lz kl hx lq b fi me mb l mc md">fun generateSquare(): Square {…}<br/>fun generateTriangle(): Triangle {…}</span><span id="8f13" class="lz kl hx lq b fi me mb l mc md">// Java usage:<br/>Square square = ShapesGeneratorKt.generateSquare();</span><span id="2f68" class="lz kl hx lq b fi me mb l mc md">// File: ShapesGenerator.kt<br/>@file:JvmName(“ShapesGenerator”)<br/>package com.shapes</span><span id="b953" class="lz kl hx lq b fi me mb l mc md">fun generateSquare(): Square {…}<br/>fun generateTriangle(): Triangle {…}</span><span id="e432" class="lz kl hx lq b fi me mb l mc md">// Java usage:<br/>Square square = ShapesGenerator.generateSquare();</span></pre><h1 id="1b61" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第23天:具体化</h1><p id="3e2c" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">为了使具体化的概念具体化，一个例子是合适的:<code class="du ln lo lp lq b">Context.systemService()</code>在Android中，KTX使用具体化来通过泛型传递“真实”类型。不再给<code class="du ln lo lp lq b">getSystemService</code>过课！单据:<a class="ae hu" href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters" rel="noopener ugc nofollow" target="_blank">具体化类型参数</a></p><p id="069e" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Android KTX:<a class="ae hu" href="https://github.com/android/android-ktx/blob/master/src/main/java/androidx/core/content/Context.kt#L37" rel="noopener ugc nofollow" target="_blank">context . system service()</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="b712" class="lz kl hx lq b fi ma mb l mc md">// the old way<br/>val alarmManager =<br/>        context.getSystemService(AlarmManager::class.java)</span><span id="c6df" class="lz kl hx lq b fi me mb l mc md">// the reified way<br/>val alarmManager: AlarmManager = context.systemService()</span><span id="180e" class="lz kl hx lq b fi me mb l mc md">// the magic from Android KTX… with “real” type T<br/>inline fun &lt;reified T&gt; Context.systemService() =<br/>         getSystemService(T::class.java)</span></pre><h1 id="eaa0" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第24天:代表</h1><p id="eea2" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">用<code class="du ln lo lp lq b">by</code>将你的工作委托给另一个班级。使用类委托支持复合而不是继承，使用委托者属性重用属性访问器逻辑。单据:<a class="ae hu" href="https://kotlinlang.org/docs/reference/delegation.html" rel="noopener ugc nofollow" target="_blank">委托</a>和<a class="ae hu" href="http://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">委托属性</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="4be3" class="lz kl hx lq b fi ma mb l mc md">class MyAnimatingView : View( /* … */ ) {<br/>    // delegated property. <br/>    // Uses the getter and setter defined in InvalidateDelegate<br/>    var foregroundX by InvalidateDelegate(0f)<br/>}</span><span id="8d15" class="lz kl hx lq b fi me mb l mc md">// A View Delegate which invalidates<br/>// View.postInvalidateOnAnimation when set.<br/>class InvalidateDelegate&lt;T : Any&gt;(var value: T) {<br/>    operator fun getValue(thisRef: View, <br/>                          property: KProperty&lt;*&gt;) = value</span><span id="71b4" class="lz kl hx lq b fi me mb l mc md">    operator fun setValue(thisRef: View, <br/>                          property: KProperty&lt;*&gt;, value: T) {<br/>        this.value = value<br/>        thisRef.postInvalidateOnAnimation()<br/>    }<br/>}</span></pre><h1 id="08b4" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第25天:扩展功能</h1><p id="7234" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">没有更多的实用类！使用<code class="du ln lo lp lq b">extension functions</code>扩展一个类的功能。将您正在扩展的类的名称放在您正在添加的方法的名称之前。Doc: <a class="ae hu" href="https://kotlinlang.org/docs/reference/extensions.html#extension-functions" rel="noopener ugc nofollow" target="_blank">扩展功能</a></p><p id="fe02" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">扩展功能:</p><ul class=""><li id="52c8" class="mf mg hx ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">不是成员函数</li><li id="47ae" class="mf mg hx ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">不要以任何方式修改原始类</li><li id="d092" class="mf mg hx ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">在编译时由静态类型信息解析</li><li id="c430" class="mf mg hx ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">被编译成静态函数</li><li id="6449" class="mf mg hx ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">不要做多态性</li></ul><p id="e7d6" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">示例:<a class="ae hu" href="https://github.com/android/android-ktx/blob/master/src/main/java/androidx/core/net/Uri.kt#L36" rel="noopener ugc nofollow" target="_blank"> String.toUri() </a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="124f" class="lz kl hx lq b fi ma mb l mc md">// Extend String with toUri<br/>inline fun String.toUri(): Uri = Uri.parse(this)</span><span id="1d06" class="lz kl hx lq b fi me mb l mc md">// And call it on any String!<br/>val myUri = “www.developer.android.com".toUri()</span></pre><h1 id="5d60" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第26天:Drawable.toBitmap()简单转换</h1><p id="41a3" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">如果你曾经将一个<code class="du ln lo lp lq b">Drawable</code>转换成一个<code class="du ln lo lp lq b">Bitmap</code>，那么你知道你需要多少样板文件。</p><p id="1002" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Android KTX有一套很棒的函数，可以让你的代码在处理图形包中的类时更加简洁。文档:<a class="ae hu" href="https://github.com/android/android-ktx/tree/master/src/main/java/androidx/core/graphics" rel="noopener ugc nofollow" target="_blank">图形</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="25e0" class="lz kl hx lq b fi ma mb l mc md">// get a drawable from resources<br/>val myDrawable = ContextCompat.getDrawable(context, R.drawable.icon)</span><span id="bf83" class="lz kl hx lq b fi me mb l mc md">// convert the drawable to a bitmap<br/>val bitmap = myDrawable.toBitmap()</span></pre><h1 id="2a35" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第27天:序列、懒惰和生成器</h1><p id="2b56" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">序列是从来不存在的列表。一个<code class="du ln lo lp lq b">Sequence</code>是<code class="du ln lo lp lq b">Iterator</code>的表亲，一次懒洋洋地生成一个值。当使用<code class="du ln lo lp lq b">map</code>和<code class="du ln lo lp lq b">filter</code>时，这真的很重要——它们将创建序列，而不是为每一步复制列表！文档:<a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html" rel="noopener ugc nofollow" target="_blank">序列</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="4476" class="lz kl hx lq b fi ma mb l mc md">val sequence = List(50) { it * 5 }.asSequence()</span><span id="99b4" class="lz kl hx lq b fi me mb l mc md">sequence.map { it * 2 }         // lazy (iterate 1 element)<br/>        .filter { it % 3 == 0 } // lazy (iterate 1 element)<br/>        .map { it + 1 }         // lazy (iterate 1 element)<br/>        .toList()               // eager (make a new list)</span></pre><p id="8bec" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">您可以根据列表或通过指定下一个函数来生成序列。如果你从不终止一个序列，它可以无限长而不会耗尽内存。有了Kotlin中的协程，您还可以使用生成器！文件:<a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines.html#generators-api-in-kotlincoroutines" rel="noopener ugc nofollow" target="_blank">发电机</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="0c24" class="lz kl hx lq b fi ma mb l mc md">// make a sequence from a list<br/>list.asSequence().filter { it == “lazy” }</span><span id="6a39" class="lz kl hx lq b fi me mb l mc md">// or, reach infinity functionally<br/>val natural = generateSequence(1) { it + 1 }</span><span id="f3da" class="lz kl hx lq b fi me mb l mc md">// or, cooperate with coroutines<br/>val zeros = buildSequence {<br/>    while (true) {<br/>        yield (0)<br/>    }<br/>}</span></pre><h1 id="8a37" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第28天:轻松跨越</h1><p id="1f7f" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">强大但难以使用——这就是文本样式跨越API的感觉。</p><p id="4949" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Android KTX为一些最常见的跨度添加了扩展功能，并使API更易于使用。Android KTX:<a class="ae hu" href="https://github.com/android/android-ktx/blob/master/src/main/java/androidx/core/text/SpannableStringBuilder.kt" rel="noopener ugc nofollow" target="_blank">span启用字符串生成器</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="0ba8" class="lz kl hx lq b fi ma mb l mc md">val string = buildSpannedString {<br/>    append(“no styling text”)<br/>    bold {<br/>        append(“bold”)<br/>        italic { append(“bold and italic”) }<br/>    }<br/>    inSpans(RelativeSizeSpan(2f), QuoteSpan()){<br/>        append(“double sized quote text”)<br/>    }<br/>}</span></pre><h1 id="5825" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第29天:打包</h1><p id="dee4" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">喜欢<code class="du ln lo lp lq b">Parcelable</code>的速度，但不喜欢写那些代码？向<code class="du ln lo lp lq b">@Parcelize</code>问好。规格:<a class="ae hu" href="https://github.com/Kotlin/KEEP/blob/master/proposals/extensions/android-parcelable.md" rel="noopener ugc nofollow" target="_blank">打包</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="8b52" class="lz kl hx lq b fi ma mb l mc md">@Parcelize<br/>data class User(val name: String, val occupation: Work): Parcelable</span><span id="99d9" class="lz kl hx lq b fi me mb l mc md">// build.gradle<br/>androidExtensions {<br/>    //Enable experimental Kotlin features <br/>    // in gradle to enable Parcelize<br/>    experimental = true<br/>}</span></pre><h1 id="b772" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第30天:更新填充扩展</h1><p id="757f" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">用默认参数扩展现有API通常会让所有人都满意。Android KTX允许您使用默认参数设置视图一侧的填充。一个单行函数，节省了这么多代码！Android KTX:<a class="ae hu" href="https://github.com/android/android-ktx/blob/master/src/main/java/androidx/core/view/View.kt#L117" rel="noopener ugc nofollow" target="_blank">view . update padding</a></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="0a0d" class="lz kl hx lq b fi ma mb l mc md">view.updatePadding(left = newPadding)<br/>view.updatePadding(top = newPadding)<br/>view.updatePadding(right = newPadding)<br/>view.updatePadding(bottom = newPadding)<br/>view.updatePadding(top = newPadding, bottom = newPadding)</span></pre><h1 id="309f" class="kk kl hx bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">第31天:确定<code class="du ln lo lp lq b">run</code>、<code class="du ln lo lp lq b">let</code>、<code class="du ln lo lp lq b">with</code>、<code class="du ln lo lp lq b">apply</code></h1><p id="2af3" class="pw-post-body-paragraph iv iw hx ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js ha bi translated">让我们用一些标准的Kotlin函数来运行！简短而强大，<code class="du ln lo lp lq b">run</code>、<code class="du ln lo lp lq b">let</code>、<code class="du ln lo lp lq b">with</code>、<code class="du ln lo lp lq b">apply</code>都有一个接收者(<code class="du ln lo lp lq b">this</code>)，可能有一个自变量(<code class="du ln lo lp lq b">it</code>)，可能有一个返回值。看到不同之处了吗</p><p id="5f88" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><strong class="ix hy">运行</strong></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="23f8" class="lz kl hx lq b fi ma mb l mc md">val string = “a”<br/>val result = string.run {<br/>    // this = “a”<br/>    // it = not available<br/>    1 // Block return value<br/>    // result = 1<br/>}</span></pre><p id="9388" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><strong class="ix hy">让</strong></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="3fcc" class="lz kl hx lq b fi ma mb l mc md">val string = “a”<br/>val result = string.let {<br/>    // this = this@MyClass<br/>    // it = “a”<br/>    2 // Block return value<br/>    // result = 2<br/>}</span></pre><p id="1166" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><strong class="ix hy">同</strong></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="71cb" class="lz kl hx lq b fi ma mb l mc md">val string = “a”<br/>val result = with(string) {<br/>    // this = “a”<br/>    // it = not available<br/>    3 // Block return value<br/>    // result = 3<br/>}</span></pre><p id="92c3" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><strong class="ix hy">应用</strong></p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="d52e" class="lz kl hx lq b fi ma mb l mc md">val string = “a”<br/>val result = string.apply {<br/>    // this = “a”<br/>    // it = not available<br/>    4 // Block return value unused<br/>    // result = “a”<br/>}</span></pre><p id="e5d9" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">本周讨论了更多的语言特性，比如互操作、重排序和序列，然后我们继续讨论Android KTX，展示它帮助你编写简洁易读的代码的一些方法。为了结束这个系列，我们介绍了强大的Kotlin scope函数。</p><p id="2ce1" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">你已经开始使用科特林了吗？我们很想知道你还发现了哪些很棒的功能，以及你是如何在你的Android应用中使用它们的。</p><p id="20d9" class="pw-post-body-paragraph iv iw hx ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">再次感谢我们的评审:<a class="ae hu" href="https://twitter.com/JakeWharton" rel="noopener ugc nofollow" target="_blank">杰克</a>、<a class="ae hu" href="https://twitter.com/romainguy" rel="noopener ugc nofollow" target="_blank">罗曼</a>、<a class="ae hu" href="https://twitter.com/crafty" rel="noopener ugc nofollow" target="_blank">尼克</a>、<a class="ae hu" href="https://twitter.com/jmslau" rel="noopener ugc nofollow" target="_blank">詹姆斯</a>、<a class="ae hu" href="https://twitter.com/donturner" rel="noopener ugc nofollow" target="_blank">唐</a>以及我们的设计师:<a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">弗吉尼亚</a>。</p></div></div>    
</body>
</html>