<html>
<head>
<title>Abstracting Sharding with Vitess and Distributed Deadlocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象分片与Vitess和分布式死锁</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/abstracting-sharding-with-vitess-and-distributed-deadlocks-3128d7c8ffd1?source=collection_archive---------2-----------------------#2018-11-27">https://medium.com/square-corner-blog/abstracting-sharding-with-vitess-and-distributed-deadlocks-3128d7c8ffd1?source=collection_archive---------2-----------------------#2018-11-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/434ec9da8dac98a6235917a4d0c84ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12OUAr6PUbvVWu_9s9eOdQ.png"/></div></div></figure><blockquote class="ip iq ir"><p id="e8a3" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="5cfa" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对于Cash App来说，Vitess如此成功的一个主要原因是它从应用程序代码中抽象出了数据库分片。这允许我们共享数据库，而无需在应用程序中重写数千个事务。</p><p id="1929" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当应用程序在不同分片上的两个实体组上发出写操作时，Vitess将自动在所有分片上打开完成操作所需的事务。</p><p id="4d4c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这里有一个例子。假设爱丽丝住在碎片1上，鲍勃住在碎片2上:</p><figure class="jv jw jx jy fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="860f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这个特性有两个明显的缺点:</p><ol class=""><li id="acec" class="kb kc hh iv b iw ix ja jb js kd jt ke ju kf jq kg kh ki kj bi translated">原子性:如果第一个事务提交，第二个事务不能保证提交。默认是尽力而为的方法。我们仍然不得不重写任何处理资金流动的交易代码，因为我们不能承受一致性方面的任何损失。参见<a class="ae jr" rel="noopener" href="/square-corner-blog/remodeling-cash-app-payments-539e1f6c4276">杰西关于运动的帖子</a>了解我们是如何解决这个问题的。</li><li id="f4cc" class="kb kc hh iv b iw kk ja kl js km jt kn ju ko jq kg kh ki kj bi translated">所有的碎片一起提交，因此一个碎片上的任何锁都将被持有，直到所有其他碎片也提交。</li></ol><p id="96e7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们认为这种权衡是值得的，因为我们已经达到了我们的容量极限，并希望尽快碎片化。</p></div><div class="ab cl kp kq go kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ha hb hc hd he"><p id="af85" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们第一次分片后不久，我们看到了服务中的几次短暂中断。所有请求都会挂起一分钟，然后失败，但之后一切都会恢复正常。我们的指标显示了三个事实:Vitess事务池已满，QPS降至零，MySQL线程数激增。从我们的日志中，我们还看到Vitess在一分钟后就终止了事务。一旦池满了，一分钟内就不会有任何请求得到服务，从而导致停机。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/cc3d2c3efd20ab638e693d9e71359a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*AO0FkxJsaoxZMi_BPm3Emg.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Example MySQL thread count spike during an outage.</figcaption></figure><p id="e3eb" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">有更紧迫的容量问题，所以每个人都专注于分割成更多的碎片，我们希望有更多的碎片可以缓解这个问题。当我们达到16个碎片时，中断变得更加频繁，这成了我的首要任务。</p><p id="b06f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当查询挂起时，第一反应是查看锁定。MySQL在其<code class="du lb lc ld le b">information_schema</code>中提供了几个有用的表，特别是<code class="du lb lc ld le b">innodb_lock_waits</code>和<code class="du lb lc ld le b">innodb_trx</code>。由于这个问题是间歇性的，我们开始通过设置一个<code class="du lb lc ld le b">pt-stalk</code>进程来观察我们的数据库，并在MySQL线程数超过某个阈值时触发。</p><p id="353a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们使用这个查询来查看哪些事务正在运行，哪些事务被阻塞:</p><pre class="jv jw jx jy fd lf le lg lh aw li bi"><span id="b0ff" class="lj lk hh le b fi ll lm l ln lo">SELECT<br/> TIMESTAMPDIFF(SECOND, rt.trx_wait_started, NOW()) AS wait_time,<br/> rt.trx_query AS waiting_query,<br/> w.blocking_trx_id,<br/> bt.trx_query AS blocking_query<br/>FROM information_schema.innodb_lock_waits w<br/>JOIN information_schema.innodb_trx rt<br/> ON w.requesting_trx_id=rt.trx_id<br/>JOIN information_schema.innodb_trx bt<br/> ON w.blocking_trx_id=bt.trx_id;</span></pre><p id="b0fc" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">结果是数百个类似下面的<code class="du lb lc ld le b">insert</code>和<code class="du lb lc ld le b">update</code>查询:</p><pre class="jv jw jx jy fd lf le lg lh aw li bi"><span id="1dee" class="lj lk hh le b fi ll lm l ln lo">wait_time: 11<br/>waiting_query: update notifications set ...<br/>blocking_trx_id: 253762323865<br/>blocking_query: NULL</span></pre><p id="bd39" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><code class="du lb lc ld le b">innodb_lock_waits</code>表显示了阻塞事务，但是由于阻塞事务是空闲的，我们永远看不到它在运行什么查询，不幸的是MySQL没有显示事务先前执行的语句。</p><p id="6a92" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">由于Vitess保持事务打开，直到所有碎片都准备好提交，我有一种预感，空闲事务是那些保持打开，但等待另一个碎片上的工作完成的事务。如果以相反的顺序更新碎片，这可能会导致两个碎片之间的分布式死锁。考虑这个场景:</p><figure class="jv jw jx jy fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="f34c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">由于<code class="du lb lc ld le b">insert</code>查询持有锁，<code class="du lb lc ld le b">A</code>等待<code class="du lb lc ld le b">B</code>，而<code class="du lb lc ld le b">B</code>等待<code class="du lb lc ld le b">A</code>，这是一个死锁。对于普通死锁，MySQL通过检测两个事务中持有的锁的循环并中止其中一个事务来提供死锁预防。然而，在分布式死锁的情况下，每个数据库都不知道其他碎片上持有的锁，所以它不知道存在死锁，查询一直等到超时。</p><p id="a13c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">因为插入操作锁定了表的末尾，所以没有其他事务可以插入到两个分片上的这些表中，所有请求将迅速滚雪球，填满事务池并锁定整个服务。</p><p id="14df" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">修复方法是将应用程序级别的事务拆分为每个分片一个事务。上面的例子看起来像这样:</p><figure class="jv jw jx jy fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="e9d8" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当我们修复了最频繁的应用程序级事务以避免交叉碎片写入时，我们立即看到MySQL锁等待时间有了很大的改善，中断也消失了。</p><figure class="jv jw jx jy fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/ed1c344a3d172d1d553ae2ad70b18317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*EcIagooGVsKXTya1mt4U-w.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">MySQL lock waits increasing with shard count over a few months, then dropping off after the fix.</figcaption></figure></div><div class="ab cl kp kq go kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ha hb hc hd he"><p id="3065" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们被Vitess提供的抽象蒙蔽了双眼，没有意识到碎片之间持有的锁没有死锁检测。这凸显了从应用程序中抽象出分片，而没有仔细考虑锁在幕后如何工作的危险。</p><p id="081e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在可以理解为什么有更多的碎片会加剧这个问题了:使用多个碎片的可能性增加了，对大量客户执行更新需要更多的时间，持有锁的时间也更长了。</p><p id="1de9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们仍然认为这种权衡是值得的:死锁是几个月前shard的一个小代价，可以避免更大的停机。</p><p id="dc19" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这篇文章是Square<a class="ae jr" rel="noopener" href="/square-corner-blog/sharding-cash-10280fa3ef3b">Vitess系列</a>的一部分。</p></div></div>    
</body>
</html>