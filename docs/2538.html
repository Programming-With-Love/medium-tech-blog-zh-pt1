<html>
<head>
<title>Today I Learned: Golang Live-Reload for Development Using Docker Compose + Air</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今天我学习了:Golang Live-使用Docker Compose + Air为开发重新加载</h1>
<blockquote>原文：<a href="https://medium.easyread.co/today-i-learned-golang-live-reload-for-development-using-docker-compose-air-ecc688ee076?source=collection_archive---------0-----------------------#2020-09-23">https://medium.easyread.co/today-i-learned-golang-live-reload-for-development-using-docker-compose-air-ecc688ee076?source=collection_archive---------0-----------------------#2020-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f63c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">今天我学到了一些关于在开发中为Golang应用程序尝试实时重载的小事情。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fc20fba212bfeab4aa41e10b53157f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a6j_E_LMTNzXwwJ_"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jeremyperkins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Perkins</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b12a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，我试图为我的Golang应用程序创建一个实时重载。只是REST API的一个简单应用。</p><p id="d79f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">供您参考，<strong class="kv io"> <em class="lp">实时重新加载</em> </strong>是一种在每次文件更改时重新加载我们的应用程序的机制。因此它将与您的代码保持同步。我不确定这和热装弹是一样的。但是人们说实时重载是在文件改变时重新加载应用程序。和热重新加载，只会刷新更改的文件，而不会丢失应用程序的状态，所以它不会重新启动整个应用程序。</p><p id="c2c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样基于<a class="ae ks" href="https://stackoverflow.com/a/41429055/4075313" rel="noopener ugc nofollow" target="_blank">这个Stackoverflow的回答</a>，</p><blockquote class="lq lr ls"><p id="6aab" class="kt ku lp kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated"><strong class="kv io">实时重新加载</strong>当文件改变时，重新加载或刷新整个应用程序。例如，如果你在导航中深入四个链接并保存了更改，实时重新加载将重新启动应用程序，并将应用程序加载回初始路线。</p><p id="dfee" class="kt ku lp kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated"><strong class="kv io">热重装</strong>仅刷新已更改的文件，不会丢失应用的状态。例如，如果您导航到四个链接深处并保存了对某个样式的更改，则状态不会改变，但新样式会出现在页面上，而不必导航回您所在的页面，因为您仍在同一页面上。</p></blockquote><p id="c9a5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想，对于这篇文章，我可以说这是一个实时重新加载，因为我不确定我们是否能为Golang使用热重新加载。因为对于Golang来说，每一次改动，我们都需要从重新编译到重新运行，重新启动应用。所以最有可能的办法就是用直播重装，而不是热重装。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="69a1" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">背景</h1><p id="892e" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">不过在说细节之前，我想先说一下背景，为什么这么多年后我才学会这个实弹-重装？</p><p id="06d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经和Golang一起工作了3年，但是我从来没有在我的项目中使用过实时重载。这并不是因为我是一个无知的人，我确实想使用live-reload进行开发。</p><p id="63e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是对于Golang的情况，我有几个原因，为什么我没有使用它。</p><ul class=""><li id="2c4e" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated"><strong class="kv io"> Golang是一种编译型编程语言。</strong>我认为编译编程语言不可能实时重载。因为我们需要编译应用程序并运行它。嗯，从技术上来说，我没有错，甚至我们可以创建一个实时重新加载工具，来观察变化和重新编译应用程序(在远处，这是实时编译运行)</li><li id="cbe4" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated"><strong class="kv io"> Golang运行/构建速度非常快</strong>与市场上的任何编译编程语言相比，这也是我当时不考虑实时重载的原因之一。</li><li id="d95d" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">制作我自己的实时重装工具。嗯，这只是重新发明轮子，更不用说建造它所需要的时间是不值得的。甚至有时候当我在做一个更大的项目时，我会后悔没有开始制作自己的实时重载工具。</li><li id="8f7b" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated"><strong class="kv io">我试过一些工具，但对性能感到失望。</strong>实际上，我以前试过一次，我忘了是什么工具了，但那时候，它消耗了我很多笔记本电脑资源。它使我的笔记本电脑滞后。我也尝试过一些有实时重新加载功能的框架，但是每次我保存文件的时候都会消耗很多资源。这不但没有提高我的工作效率，反而因为笔记本电脑的滞后而让我压力更大。</li><li id="7f6f" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated"><strong class="kv io">我的项目相对来说依赖于小的依赖</strong>(库、框架、数据库、任何额外的层)，所以编译和运行应用程序在那时还不是问题。</li></ul><p id="00f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，现在我正在寻找一个实时重载功能，因为我的项目越来越大，依赖关系也越来越大。喜欢它依赖于Google Pubsub，Firebase，Mongo，Postgres，Redis，所有其他的库。只是启动app，需要时间。因此，当开发新功能时，只在本地运行它确实需要时间。那是我试图考虑使用实时重新加载来提高效率的时候。至少，减少了人工干预(如编译和构建应用程序)所需的时间。当你在LOL区域时，即使是毫秒也很重要。</p><p id="f9b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我有一些实时重新加载的标准，</p><ul class=""><li id="f153" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated">最重要的是，它没有让我的笔记本电脑滞后。性能是最重要的，我不想被一个滞后的笔记本电脑所困扰。我在使用一个具有实时重载功能的Go框架时有过糟糕的经历，这让我很沮丧。开始的时候，它工作得很好，但是后来当我频繁地修改时，它让我的笔记本电脑像地狱一样滞后。即使在编辑器中输入，它也会被延迟。</li><li id="58bb" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">可配置！我希望这些工具可以用我自己的设置进行实时重新加载配置。</li><li id="ad53" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">易于使用和携带。所以无论环境如何，每个人都可以使用它。总的来说，我会说，至少是dockerized。自从我知道docker现在已经成为工程师的标配工具。</li></ul><p id="0836" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基于这个标准，我试着在网上找到许多工具。我发现了一些好的工具，但是后来，我记得，我的同事为我们公司的内部项目使用了一个live reload。</p><p id="2cef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出于好奇，我尝试探索这个工具。它被命名为“空气”。资源库可以在这里找到，<a class="ae ks" href="https://github.com/cosmtrek/air" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> Air </strong> </a>。</p><h1 id="5abd" class="md me in bd mf mg no mi mj mk np mm mn jt nq ju mp jw nr jx mr jz ns ka mt mu bi translated">空中实弹</h1><p id="c3e0" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">第一印象，我感到怀疑，因为它就像另一个实时重新加载工具。我必须安装它，然后在我的项目中运行它。但是，当我查看Github回购协议时，他们提供的成功解决方案是，</p><ul class=""><li id="6db0" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated"><strong class="kv io">可配置。</strong>我可以根据需要配置我的设置。</li><li id="6c95" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated"><strong class="kv io">便携。</strong>由于它只是一个二进制文件，我可以用它来对接，并使它可移植。</li></ul><h2 id="b68b" class="nt me in bd mf nu nv dn mj nw nx dp mn lc ny nz mp lg oa ob mr lk oc od mt oe bi translated">设置我的实时重新加载环境</h2><p id="94c2" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">要使用Air live-reload工具，请参见Github存储库中的。但是对我来说，我使用Docker compose来管理我的live-reload开发环境。</p><p id="449f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我需要的是，</p><ul class=""><li id="2ae0" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated">我将开发的应用程序。</li><li id="eda1" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">在我的笔记本电脑上安装了docker。</li><li id="acf7" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">用于开发的docker文件。</li><li id="f375" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">docker-编写开发文件。</li><li id="17ba" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">自定义配置</li></ul><p id="4f48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以这个想法是，我将使用docker-compose来管理使用Air的实时重新加载。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/5816f972357394a3a6652136d5d2ff6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOHq_HZ75aRigVmZJ2zWog.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Live reload idea with Docker compose + Air</figcaption></figure><p id="f5f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1。制作开发用docker文件<br/> </strong>第一步是制作开发用docker文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2d3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">docker文件基本上只是下载安装Air二进制，并使其成为docker的入口点。</p><p id="0e96" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你从上面的docker文件中看到，你会看到这一行</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="1765" class="nt me in oj b gy on oo l op oq">RUN curl -fLo install.sh https://raw.githubusercontent.com/cosmtrek/air/master/install.sh \    &amp;&amp; chmod +x install.sh &amp;&amp; sh install.sh &amp;&amp; cp ./bin/air /bin/air</span></pre><p id="b70b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这只是为了获得安装脚本，然后运行它，并使其成为<code class="fe or os ot oj b"><strong class="kv io">/bin</strong></code>文件夹。</p><p id="fc7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，我们将为开发制作docker-compose文件。</p><p id="c10e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2。为开发制作Docker-Compose文件</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e651" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一步是基于前面的docker文件创建docker-compose。如您所见，在docker-compose文件中，我将dockerfile设置为<code class="fe or os ot oj b"><strong class="kv io">dev.Dockerfile</strong></code></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="90c2" class="nt me in oj b gy on oo l op oq">web:<br/>    build:<br/>      context: .<br/>      dockerfile: dev.Dockerfile</span></pre><p id="4526" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，另一件重要的事情是，我将卷链接设置为当前目录，</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="011d" class="nt me in oj b gy on oo l op oq">volumes:<br/>      - ./:/app</span></pre><p id="608a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着容器将使用我的当前目录，并将其附加到容器中的<code class="fe or os ot oj b"><strong class="kv io">/app</strong></code>。因此，如果我的目录中有任何更改，它也会更改容器中的文件。</p><p id="950f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 3。设置您的应用程序配置<br/> </strong>因为我们将进行实时重新加载，所以，我们还需要为我们的应用程序提供一个配置文件以便能够运行。配置文件可以不同，通常，人们使用ENV变量或<code class="fe or os ot oj b"><strong class="kv io">.env</strong></code>文件。或者只是一个配置文件，如<code class="fe or os ot oj b"><strong class="kv io">config.jso</strong>n</code>或<code class="fe or os ot oj b"><strong class="kv io">config.toml</strong></code>等。</p><p id="00a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想实时重新加载应用程序，您需要定义它。假设你需要运行应用程序，你需要什么配置。</p><p id="dbb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我的例子中，我将在本地创建一个名为<code class="fe or os ot oj b"><strong class="kv io">config.toml</strong></code>的文件</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="e897" class="nt me in oj b gy on oo l op oq">title="Configuration File for Menekel"<br/>debug=true<br/>contextTimeout="2"<br/>[server]<br/>  address= ":9090"<br/>[database]<br/>  host="mysql"<br/>  port="3306"<br/>  user="root"<br/>  pass="root"<br/>  name="article"</span></pre><p id="e046" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个配置也将被复制到容器中，因此我们将能够在容器中运行它。</p><p id="4dc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 4。设置空气配置</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e47a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一步是，创建空气配置。创建一个名为<code class="fe or os ot oj b"><strong class="kv io">.air.toml</strong></code>的新文件，然后根据需要进行配置。我将尝试从这里的配置中分解出任何重要的配置术语。</p><p id="a965" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> a. CMD语法</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2438" class="nt me in oj b gy on oo l op oq">[build]<br/>//...<br/><strong class="oj io">cmd = "go build -o ./tmp/app/engine app/main.go"</strong><br/>//....</span></pre><p id="47e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的粗体字是编译应用程序所需的命令。在我的情况下，我只是使用<code class="fe or os ot oj b"><strong class="kv io">go build -o ./tmp/app/engine app/main.go</strong></code>。所以如果你们想把它复制到应用程序中，确保构建命令是正确的。</p><p id="3439" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> b. BIN语法</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="5193" class="nt me in oj b gy on oo l op oq">[build]<br/>//....<br/><strong class="oj io">bin = "tmp/app"<br/>//....</strong></span></pre><p id="aaf5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的粗体文本只是编译后的二进制文件存在的目录。</p><p id="0700" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> c. FULL_BIN语法</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2846" class="nt me in oj b gy on oo l op oq">[build]<br/>//...<br/><strong class="oj io">full_bin = "./tmp/app/engine http"<br/>/...</strong></span></pre><p id="9cdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的下一个是你的应用程序编译后的启动方式。在我的例子中，要运行编译后的应用程序，我需要传递参数<code class="fe or os ot oj b"><strong class="kv io">http</strong></code>来确定我想要运行HTTP服务器。</p><p id="a87b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，如果您的应用程序不需要任何参数，您就不必添加任何额外的参数。</p><p id="7525" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您的应用程序使用ENV变量，您还需要像这样传递它，</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="a0c7" class="nt me in oj b gy on oo l op oq">full_bin = "<strong class="oj io">ENV1=mysql ENV2=localhost .</strong>/tmp/app/engine http<strong class="oj io">"</strong></span></pre><blockquote class="lq lr ls"><p id="a470" class="kt ku lp kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">技巧:<br/> -确保你的应用程序能够读取<code class="fe or os ot oj b"><strong class="kv io">.env</strong></code>文件，这样你就不必在Air config中列出所有的ENV。<br/> -使用配置文件，但承担后果。</p></blockquote><p id="55be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> d. INCLUDE_EXT和EXCLUDE_DIR语法</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2272" class="nt me in oj b gy on oo l op oq">[build]<br/>//...<br/><strong class="oj io">include_ext = ["go", "yaml"]</strong><br/><strong class="oj io">exclude_dir = ["tmp"]</strong><br/>//...</span></pre><p id="9964" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe or os ot oj b"><strong class="kv io">include_ext</strong></code>将会监视每一个列出扩展名的文件。如果项目中的任何文件有任何更改，都会触发Air重新编译应用程序。</p><p id="e4ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe or os ot oj b"><strong class="kv io">exclude_dir</strong></code>告诉我们，该目录上的任何更改都不会触发Air重新编译应用程序。</p><p id="178d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> e .延迟语法</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2916" class="nt me in oj b gy on oo l op oq">[build]<br/>//...<br/><strong class="oj io">delay = 1000 # ms</strong><br/>//...</span></pre><p id="0667" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时，我们可能会做太频繁的更改，所以为了减少即时构建每个保存的文件，我们可以添加一个延迟。所以它不会直接编译频繁改动的应用。这是非常有用的，因为编译和重新运行应用程序将消耗CPU，如果我们过于频繁地编译，将使我们的笔记本电脑滞后。有了这个，我们可以配置延迟来降低编译应用程序的速度。</p><p id="0189" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 5。最后一步:让一切运转起来。</strong></p><p id="5266" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一步是，您可以使用docker-compose运行应用程序，</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="be3f" class="nt me in oj b gy on oo l op oq"><strong class="oj io">$ docker-compose up -d</strong></span></pre><p id="dbd2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">检查你终端的日志，</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="9b39" class="nt me in oj b gy on oo l op oq"><strong class="oj io">$ docker-compose logs -f</strong></span></pre><p id="2089" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看这里的演示，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ou oh l"/></div></figure><h1 id="0500" class="md me in bd mf mg no mi mj mk np mm mn jt nq ju mp jw nr jx mr jz ns ka mt mu bi translated">结论</h1><p id="67a0" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">试过这个之后，至少我可以更快的找到工作。如果更改太频繁，我只需要在配置中添加延迟，这样就不会影响我的笔记本电脑资源。</p><p id="5793" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例子库可以在这里看到，<a class="ae ks" href="https://github.com/golangid/menekel" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">门克尔</strong> </a>，或者你可以检查这个<a class="ae ks" href="https://github.com/golangid/menekel/pull/4" rel="noopener ugc nofollow" target="_blank">公关</a>如果你想知道我做了什么改变，增加了实时重装。</p><p id="8479" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，如果你们有任何更好的想法，工具，让我知道，把评论放在下面，这样其他人也可以尝试。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="b64b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你们觉得这很有用，请鼓掌并分享，这样其他人也可以看到它，传播爱和知识。</p></div></div>    
</body>
</html>