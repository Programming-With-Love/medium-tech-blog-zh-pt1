<html>
<head>
<title>Let’s Encrypt &amp; App Engine, pt. 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们来加密&amp; App Engine，pt。2</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/lets-encrypt-app-engine-pt-2-832583ef6ce4?source=collection_archive---------8-----------------------#2017-09-29">https://medium.com/square-corner-blog/lets-encrypt-app-engine-pt-2-832583ef6ce4?source=collection_archive---------8-----------------------#2017-09-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="1d39" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">更简单的续订方法让我们在应用引擎站点上加密证书</h2></div><blockquote class="iw ix iy"><p id="7b43" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae jw" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="0123" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><em class="jb">关于使用</em> <a class="ae jw" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">的更多背景，让我们用 </a><a class="ae jw" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">谷歌的应用引擎</a> <em class="jb">加密 <em class="jb">，阅读原文</em> <a class="ae jw" rel="noopener" href="/square-corner-blog/setting-up-https-for-your-e-commerce-website-with-lets-encrypt-and-google-app-engine-465a866790b5">为你的网站设置https</a></em></p><p id="fe8a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">到了更新我的谷歌应用引擎加密证书的时候，我想看看我是否能改进这个过程。对于我的第一次尝试，我尝试了DNS验证方法。我为我的域更新了适当的<code class="du ka kb kc kd b">TXT</code>记录，但是要么不能正确地完成，要么没有足够的耐心让缓存完全刷新，所以我回到了良好的ol' https验证。当我决定在过程中增加更多的自动化时，这是一个很好的选择，现在你可以从我的工作中受益🙂。</p><h1 id="495e" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">配置文件</h1><p id="d621" class="pw-post-body-paragraph iz ja hh jc b jd kw ii jf jg kx il ji jx ky jl jm jy kz jp jq jz la jt ju jv ha bi translated">如果您在同一台机器上有几个不同的项目，您可能想要做的第一件事就是为每个项目创建一个关注点分离。一个简单的开始是向您的项目添加一个文件夹，以帮助维护每个项目的所有相关项。</p><pre class="lb lc ld le fd lf kd lg lh aw li bi"><span id="7327" class="lj kf hh kd b fi lk ll l lm ln">project/<br/>--...<br/>--letsencrypt/<br/>----logs/<br/>----config/<br/>----work/</span></pre><p id="6f0f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">每个文件夹都可以用来将“让我们加密”过程的不同方面登记到我的存储库中。我们还希望开始将我们的项目与一个配置文件相关联，而不是记住所有需要的不同标志和命令。最初，我的配置文件如下所示:</p><figure class="lb lc ld le fd lo"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="e822" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">现在我们可以运行<code class="du ka kb kc kd b">certbot --config ./cli.ini certonly</code>并直接进入将挑战响应上传到我的服务器的步骤。不幸的是，所有这些工作并没有使更新证书的过程变得更容易，只是使命令变得更短了。幸运的是，certbot有一些新的锦囊妙计。</p><h2 id="1209" class="lj kf hh bd kg lr ls lt kk lu lv lw ko jx lx ly kq jy lz ma ks jz mb mc ku md bi translated"><strong class="ak">带验证挂钩的自动化</strong></h2><p id="31ca" class="pw-post-body-paragraph iz ja hh jc b jd kw ii jf jg kx il ji jx ky jl jm jy kz jp jq jz la jt ju jv ha bi translated">Certbot有几个新特性，可以帮助在不同于服务于您的网站的机器上自动完成<code class="du ka kb kc kd b">manual</code>证书请求过程。这些特征是<code class="du ka kb kc kd b">--manual-auth-hook</code>和<code class="du ka kb kc kd b">--manual-cleanup-hook</code>标志。它们允许您指定shell脚本，这些脚本将使用作为环境变量包含的相关细节来运行。你可以在<a class="ae jw" href="https://certbot.eff.org/docs/using.html#pre-and-post-validation-hooks" rel="noopener ugc nofollow" target="_blank">官方用户指南</a>中阅读关于Certbot钩子的所有信息。</p><p id="157e" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">因为我们设置了对所有东西使用一个配置文件，所以让我们为我的新的前后验证挂钩添加几行代码。</p><pre class="lb lc ld le fd lf kd lg lh aw li bi"><span id="0f55" class="lj kf hh kd b fi lk ll l lm ln">#pre &amp; post validation hook:<br/>manual-auth-hook ../scripts/auth.sh<br/>manual-cleanup-hook ../scripts/cleanup.sh</span></pre><h2 id="d58e" class="lj kf hh bd kg lr ls lt kk lu lv lw ko jx lx ly kq jy lz ma ks jz mb mc ku md bi translated">授权. sh</h2><p id="2773" class="pw-post-body-paragraph iz ja hh jc b jd kw ii jf jg kx il ji jx ky jl jm jy kz jp jq jz la jt ju jv ha bi translated">这些脚本中的每一个都非常简单。auth脚本将添加适当的文件来满足url挑战(&amp; deploy my application)，而清理脚本将删除生成的文件。先来看<code class="du ka kb kc kd b">auth.sh</code>:</p><figure class="lb lc ld le fd lo"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ae75" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">第一行只是创建了一个小输出，告诉我文件在哪里被创建，第二行将<code class="du ka kb kc kd b">CERTBOT_VALIDATION</code>环境变量的内容放入一个以<code class="du ka kb kc kd b">CERBOT_TOKEN</code>环境变量命名的文件中。然后部署指定项目的App Engine应用程序。<code class="du ka kb kc kd b">--quiet</code>标志防止在最大程度自动化的过程中需要任何确认。</p><h2 id="2676" class="lj kf hh bd kg lr ls lt kk lu lv lw ko jx lx ly kq jy lz ma ks jz mb mc ku md bi translated">app.yaml</h2><p id="f94c" class="pw-post-body-paragraph iz ja hh jc b jd kw ii jf jg kx il ji jx ky jl jm jy kz jp jq jz la jt ju jv ha bi translated">如果在项目的<code class="du ka kb kc kd b">app.yaml</code>中设置了正确的文件处理程序，就很容易应对URL挑战:</p><pre class="lb lc ld le fd lf kd lg lh aw li bi"><span id="68af" class="lj kf hh kd b fi lk ll l lm ln">- url: /.well-known/acme-challenge/(.*)<br/>  static_files: letsencrypt/\1.txt<br/>  upload: letsencrypt/(.*\.txt)</span></pre><p id="6a94" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">任何在你的域名下发送的请求。众所周知的/acme-challenge，App Engine将寻找适当命名的文本文件并返回内容。</p><h2 id="f033" class="lj kf hh bd kg lr ls lt kk lu lv lw ko jx lx ly kq jy lz ma ks jz mb mc ku md bi translated">cleanup.sh</h2><pre class="lb lc ld le fd lf kd lg lh aw li bi"><span id="612a" class="lj kf hh kd b fi lk ll l lm ln">rm ../letsencrypt/*</span></pre><p id="7be3" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">验证之后，这个脚本只是清理文件，这样它们就不会破坏你的回购。</p><h2 id="5772" class="lj kf hh bd kg lr ls lt kk lu lv lw ko jx lx ly kq jy lz ma ks jz mb mc ku md bi translated">上传证书</h2><p id="8690" class="pw-post-body-paragraph iz ja hh jc b jd kw ii jf jg kx il ji jx ky jl jm jy kz jp jq jz la jt ju jv ha bi translated">一旦成功，您将获得一个<code class="du ka kb kc kd b">.pem</code>文件中的证书。您需要将它添加到应用引擎<code class="du ka kb kc kd b">PEM encoded X.509 public key certificate.</code>的<a class="ae jw" href="https://console.cloud.google.com/appengine/settings/certificates" rel="noopener ugc nofollow" target="_blank">证书页面</a>中。对于<code class="du ka kb kc kd b">Unencrypted PEM encoded RSA private key</code>，您首先需要修改私钥文件。您可能有一个RSA私钥，这对于openssl来说非常简单:</p><pre class="lb lc ld le fd lf kd lg lh aw li bi"><span id="c4f5" class="lj kf hh kd b fi lk ll l lm ln">sudo openssl rsa -inform pem -in ./config/live/yourdomain.com/privkey.pem -outform pem &gt; ./config/live/yourdomain.com/rsaprivatekey.pem</span></pre><p id="68c2" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">现在你可以上传你的新<code class="du ka kb kc kd b">rsaprivatekey.pem</code>并等待三个月直到你需要再次更新。😉</p><p id="68ac" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我希望你喜欢阅读我的应用引擎SSL冒险与让我们加密的第二部分！如果你有任何想法，或者在评论中提出改进的建议，请告诉我。</p></div></div>    
</body>
</html>