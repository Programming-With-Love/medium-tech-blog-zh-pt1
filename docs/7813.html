<html>
<head>
<title>Code Splitting: Virtues and challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码拆分:优点和挑战</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/code-splitting-virtues-and-challenges-ccab03bbc29d?source=collection_archive---------3-----------------------#2019-09-17">https://medium.com/walmartglobaltech/code-splitting-virtues-and-challenges-ccab03bbc29d?source=collection_archive---------3-----------------------#2019-09-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d5998ba1e898574cd587aef8f0c13981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okCGUrYHvcCte8IJCQgC6w.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image by Gerald Friedrich from Pixabay</figcaption></figure><p id="ba23" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">日常用户访问数百个网站，只停留几分钟。根据谷歌的研究，如果网页加载时间超过3秒，53%的访问会被放弃。哪怕只减少几分之一秒的网页加载时间也会带来收入的增加。</p><p id="5eed" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">随着React和Webpack的出现，将所有内容捆绑在一个包中并提供给用户已经成为一种常见的做法。这对第一次使用的用户有很大的负面影响，因为他们得到了大量未使用的代码。如果我们能够只交付与该场景相关的代码片段，我们就可以提高我们站点的性能。代码分割，如果做得正确，可以帮助实现这一点。</p><p id="f0a1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">两种主要的代码拆分方法是- <br/> 1 .反应慵懒悬疑<br/> 2。可加载组件</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="b5e4" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">反应慵懒而悬疑</h1><p id="a78d" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">这是React的官方方法。先说个例子。</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example — Single Bundle</figcaption></figure><p id="233c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">假设我们的<em class="li"> main.bundle.js </em>有两个组件Header和Filter。<em class="li"> HeaderComponent </em>呈现在每个页面上，但<em class="li"> FilterComponent却不是这样。</em>仅当<em class="li"> isFilterOpen </em>开关开启时才呈现。像这样的组件已经成熟，可以从主包中分离出来，形成自己的有条件加载的块。所以，我们分了吧。</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example — Bundle Splitting with React lazy and Suspense</figcaption></figure><p id="e74b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="li"> React.lazy() </em>需要一个调用动态导入()作为参数的函数。<a class="ae jr" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" rel="noopener ugc nofollow" target="_blank">动态导入由Webpack </a>处理。这个导入将我们的FilterComponent放在一个单独的块中，这将我们的<em class="li"> main.bundle </em>的大小减少了50 KB，并且<em class="li"> </em>返回一个<em class="li">承诺。React Lazy </em>仅当存在对React组件的需求时，才将这个<em class="li">承诺</em>解析为React组件，在我们的示例中，这个需求由<em class="li">is filterepon控制。</em></p><p id="5361" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当<em class="li">is filterepon</em>变为真时，可能需要一些时间来加载单独的块<em class="li">。对于这段时间间隔，我们需要回退内容作为填充，类似于加载屏幕。悬念在这里派上了用场。它需要一个后备道具作为填充。</em></p><p id="864d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">就是这样！你已经拆分了你的组件，但是等待你可能会遇到一个“页面闪烁”的问题。</p><p id="b91f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">React Lazy为代码分割提供了一个很好的接口，但遗憾的是它只有客户端支持。如果您对一个也进行服务器端渲染的网站使用React lazy，您会在网站加载时看到闪烁效果。这是因为React不知道水合所需的所有分割块，因此它丢失了由服务器端呈现创建的上下文。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es lj"><img src="../Images/663dc292cf65c799c3b091ffbb76bd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/1*brVOfoWdEpIqBAefBuQzzQ.gif"/></div></figure><p id="c7da" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果服务器可以提供关于在服务器端渲染期间使用的分割块的信息，并且如果我们可以让React hydration等待所有块加载，那么我们可以避免这种闪烁问题。这正是可加载组件为我们做的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="c456" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">可加载组件</h1><p id="9efa" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">如果你依赖于服务器端渲染，React建议使用<a class="ae jr" href="https://www.smooth-code.com/open-source/loadable-components/docs/server-side-rendering/" rel="noopener ugc nofollow" target="_blank">可加载组件</a>来拆分你的组件。可加载组件由四部分组成— <br/> 1。<a class="ae jr" href="https://www.npmjs.com/package/@loadable/component" rel="noopener ugc nofollow" target="_blank">可加载组件函数</a>，工作原理类似React.lazy. <br/> 2。<a class="ae jr" href="https://www.npmjs.com/package/@loadable/server" rel="noopener ugc nofollow" target="_blank">可加载服务器</a>与React DOM服务器<br/> 3协同工作。<a class="ae jr" href="https://www.npmjs.com/package/@loadable/babel-plugin" rel="noopener ugc nofollow" target="_blank">可加载的Babel插件</a>用于转换代码，以实现服务器上的同步加载和客户端上的异步加载。<br/> 4。<a class="ae jr" href="https://www.npmjs.com/package/@loadable/webpack-plugin" rel="noopener ugc nofollow" target="_blank">可加载的Webpack插件</a>生成一个扩展的stats文件，该文件包含传递给服务器端代码的所有分割块依赖关系的信息。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/db92a12bc23e7fc5bccaadc22bb7593d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKymmeLwh5N4is3Mus0Q-A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Sample — Loadable Stats file</figcaption></figure><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example — Bundle Splitting with Loadable Components</figcaption></figure><p id="3410" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的例子中，您可以看到React.lazy和可加载组件之间的相似性。除此之外，服务器端的渲染也需要修改，以增加对可加载组件的支持。</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example — Server-side rendering with Loadable Components</figcaption></figure><p id="5757" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如上所示，可加载组件从stats文件创建一个提取器。这个提取器为所需的块创建脚本标签，并在DOM中传递它们，如下所示。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ll"><img src="../Images/2e1ea1754f2c39d1d5c500a693cf9db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaqor5JTy42vBEGq7SD34w.png"/></div></div></figure><p id="05c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在信息在客户端可用，我们必须让我们的入口组件在水合之前等待这些块。该任务由<em class="li"> loadableReady() </em>函数处理。</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Example — Delaying hydration until Loadable Components is ready</figcaption></figure><p id="dadb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦加载了所需的块，就调用传递给<em class="li"> loadableReady() </em>的回调。这延迟了客户端主组件的水合，直到我们的状态与服务器端一致，解决了闪烁问题。</p><p id="d685" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们已经成功地创建了一个单独的块，但它是优化的吗？</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="3a9a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Webpack的分割块插件</h1><p id="21e3" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">不管您选择React Lazy还是Loadable，您的分割块并不总是不相交的集合。您的程序块很有可能包含重复的代码。这不但不会提高你的表现，反而会降低你的表现。</p><p id="053e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Webpack4有一个名为<a class="ae jr" href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="noopener ugc nofollow" target="_blank"> SplitChunksPlugin </a>的插件，可以用来删除重复代码。我不能在这篇博文中深入探究这个插件的细节，但是希望在以后的博文中会涉及到。在那之前，你可以阅读<a class="ae jr" href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="noopener ugc nofollow" target="_blank"> Webpack的文档</a>。</p><p id="121a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我希望这篇博客文章可以作为您代码拆分工作的一个良好起点。让我们共同减少互联网上的JS膨胀。开心分裂！</p></div></div>    
</body>
</html>