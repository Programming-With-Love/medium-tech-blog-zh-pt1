<html>
<head>
<title>Auto-commit and Before Commit Events — Food for thought</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动提交和提交前事件—引人深思</h1>
<blockquote>原文：<a href="https://medium.com/mendix/autocommit-and-before-commit-events-not-a-love-story-2dc70b3aad05?source=collection_archive---------0-----------------------#2020-06-12">https://medium.com/mendix/autocommit-and-before-commit-events-not-a-love-story-2dc70b3aad05?source=collection_archive---------0-----------------------#2020-06-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3327" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">我只是偶然发现了一些困难的事情。也许这篇文章可以帮助其他人不要碰到同样的问题。但是让我们重新开始。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/f1bcb46f98104cb9b845e5c38b794313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2rcXU-C02w2Cg-yl91LbA.png"/></div></div></figure><h1 id="70b8" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">典型的提交前模式</h1><p id="a171" class="pw-post-body-paragraph ir is hu bd b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hn dt translated">下面是一个我以前见过很多次的场景:</p><p id="a64c" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">如果数据记录的某个属性发生变化，就会触发一个动作。这方面的一个例子是一个具有状态的对象，每次状态改变时都应该创建一个通知。</p><p id="5c77" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">一个相当实用的模式是在提交前事件中从数据库中检索要提交的对象的旧状态，并将其与当前状态进行比较。如果检测到更改，将生成通知。</p><p id="3f5e" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">整个事情看起来会像这样:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ld"><img src="../Images/d613a9f26bd8e06070e27eb52a04e0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OMwrFXeayZu3IIvB.png"/></div></div></figure><p id="2a1d" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">只要这个Before Commit事件在数据库中更新对象之前运行，这就很好。不幸的是，这里的自动提交可能会碍事。</p><h1 id="0d6b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">Mendix自动提交功能</h1><p id="66b9" class="pw-post-body-paragraph ir is hu bd b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hn dt translated">Mendix努力帮助低代码开发人员尽可能保持数据的一致性。为此，有一个称为自动提交的特性。</p><p id="1e3c" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">如果在一个对象上设置了与另一个对象的关联，而该另一个对象此时在数据库中尚不存在，则自动提交该不存在的对象。这意味着开发人员不必担心设置了数据库中不存在的关联。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff le"><img src="../Images/35013973f651aecdc784e1ef45272b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/0*r0D_gNpZ28LGzJwJ.png"/></div></figure><p id="ebd4" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">如果在本例中，OtherEntity类型的对象被提交，该对象引用了Entity类型的未提交对象，则后者被自动提交。</p><h1 id="2c45" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">问题是</h1><p id="bdb8" class="pw-post-body-paragraph ir is hu bd b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hn dt translated">Mendix不会在自动提交期间触发事件。它只是将数据写入数据库。这很有用，因为开发人员没有触发提交。然而，<strong class="bd lf">存在一个风险，即提交前事件可能需要在提交</strong>之前运行(类似于上面描述的模式)。如果先前自动提交的对象再次被显式提交，则它已经在数据库中。新旧状态之间的比较不会产生有用的结果。</p><h1 id="5a1b" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">注意提交顺序</h1><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/a270bc88cd8ee0bc1364c24c4cfdcd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/0*JE6k7NURjdSw_T5a.png"/></div></figure><p id="999a" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">在此示例中，OtherEntity的提交导致实体的自动提交。只有在微流中提交实体时，才会触发实体上的Before Commit事件。此时，更改已经在数据库中。通知模式在任何情况下都会失败。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/c9ab40cbf847483e8ae9dd88c0ccbfa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*a3H0LynfIfi91VWB.png"/></div></figure><p id="b7e7" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated">在这种情况下，首先执行对实体的提交。通知模式按预期工作。没有自动提交。</p><h1 id="2167" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="9c58" class="pw-post-body-paragraph ir is hu bd b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hn dt translated">我学到了两件事</p><ol class=""><li id="e2aa" class="li lj hu bd b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq dt translated"><strong class="bd lf">对象提交的顺序很重要</strong>。不同的顺序会导致不同的结果。这里要做的最理想的事情是尽量防止订单自动提交。</li><li id="058f" class="li lj hu bd b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq dt translated">首先，由于这并不总是可能的(例如，3个或更多的对象可能以无法阻止自动提交的方式指向彼此)，所以在使用如上所述的模式时应该非常小心。如果你真的想确保在一个定义良好的数据集上执行某些动作，最好不要在提交前事件中执行这些动作，而是在提交对象的微流中执行。理想情况下是在自动提交发生之前。</li></ol></div><div class="ab cl lw lx hb ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="4b69" class="pw-post-body-paragraph ir is hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hn dt translated"><em class="md">原文于2020年6月12日</em> <a class="ae me" href="https://mendixandme.de/index.php/2020/06/12/autocommit-und-before-commit-events-keine-liebesgeschichte/?preview=true" rel="noopener ugc nofollow" target="_blank"> <em class="md">以德语发表https://mendixamme . de</em></a><em class="md">。</em></p></div></div>    
</body>
</html>