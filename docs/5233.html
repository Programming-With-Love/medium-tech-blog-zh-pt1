<html>
<head>
<title>Approximate Query Enhancements: 12 Things Developers Will Love About Oracle Database 12c Release 2 Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">近似查询增强:开发人员会喜欢的关于Oracle Database 12c第2版第6部分的12件事</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/approximate-query-enhancements-12-things-developers-will-love-about-oracle-database-12c-release-2-c4c94bb2615b?source=collection_archive---------6-----------------------#2016-11-10">https://medium.com/oracledevs/approximate-query-enhancements-12-things-developers-will-love-about-oracle-database-12c-release-2-c4c94bb2615b?source=collection_archive---------6-----------------------#2016-11-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="47d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您进行数据分析，您经常需要回答以下问题:</p><ul class=""><li id="1615" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">昨天有多少客户访问了我们的网站？</li><li id="9875" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">上个月我们卖了多少不同的产品？</li><li id="e0ae" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">上周数据库执行了多少条唯一的SQL语句？</li></ul><p id="d0fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好吧，也许最后一个只是我；)</p><p id="74ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论如何，这些问题通常只是进一步分析的起点。所以你只是想快速估算一下。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div class="er es jq"><img src="../Images/4dde32071682e998942d6a8e1526d7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*2CMj9rBTgd-0lnxC.jpg"/></div></figure><p id="7ba5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回答这些问题通常需要按照以下思路进行计数:</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="b1e5" class="kd ke hh jz b fi kf kg l kh ki">select count ( distinct customer_id ) from website_hits;</span></pre><p id="e2fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是这些查询可能需要很长时间才能运行！</p><p id="eb58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等待答案是令人沮丧的。但如果你是在为别人获取数据，那就更糟了。比如你的老板。他们需要开会的数据。一分钟后开始。您的查询至少需要十分钟。</p><p id="0bec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你的老板等不了那么久。他们现在需要一个答案！</p><p id="d751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，你只需要快速估计。毕竟，你的老板会把你的数字四舍五入到一两位有效数字。</p><p id="cd77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在12.1.0.2，我们推出了<a class="ae kj" href="http://docs.oracle.com/database/121/SQLRF/functions013.htm#SQLRF56900" rel="noopener ugc nofollow" target="_blank"> approx_count_distinct </a>。这将返回目标列中有多少不同值的估计值。这通常有超过99%的准确性，并且可能比精确结果快得多。</p><p id="3645" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这太酷了。但是要利用它，您需要更改您的代码！这可能是一项耗时的任务。尤其是因为大多数时候，您希望能够在精确结果和近似结果之间切换。所以简单的查找+替换是不可能的。相反，您必须传入一个标志来切换模式。</p><p id="4b57" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你是不同计数的大用户，这可能会有很多工作…</p><p id="97ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在12.2中我们引入了一个新参数，approximate _ for _ count _ distinct。将此设置为true，如下所示:</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="6d46" class="kd ke hh jz b fi kf kg l kh ki">alter session set approx_for_count_distinct = true;</span></pre><p id="e513" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle隐式地将所有计数差异转换为近似版本。</p><p id="f356" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">玩这个游戏时，您可能会注意到其他几个新参数:</p><ul class=""><li id="e3ce" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">聚合的近似值</li><li id="3ef0" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">大约百分位数</li></ul><p id="a0d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么这些都是关于什么的呢？</p><p id="787a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在12.2中，我们创建了一个新的函数，approximate _ percentile。这是percentile_disc和percentile_cont函数的近似版本。它和approx_count_distinct的概念是一样的，只是应用于这些函数。</p><p id="bc92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它的语法是:</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="c794" class="kd ke hh jz b fi kf kg l kh ki">approx_percentile ( <br/>  &lt;expression&gt; [ deterministic ], <br/>  [ ('ERROR_RATE' | 'CONFIDENCE') ] <br/>) within group ( order by &lt;expression&gt; )</span></pre><p id="3535" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，在approx_count_distinct上有几个额外的子句。</p><h1 id="398b" class="kk ke hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">确定性的</h1><p id="ff40" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">这定义了每次在相同的数据集上运行它时是否得到相同的结果。非确定性是默认值。也就是说你每次都会得到不同的答案。</p><p id="48b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在你可能想知道，“但是我为什么想要非确定性的结果呢？!"。嗯，有几个原因:</p><ul class=""><li id="f312" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">非确定性结果更快。</li><li id="1c19" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">您只能获得数值的确定性结果。</li></ul><p id="d21e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果你想在一个日期范围内得到10%的百分比，你必须采用非确定性。</p><p id="853e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是为非确定性结果节省的时间值得吗？</p><p id="270f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了找到答案，我使用<a class="ae kj" href="https://cloud.oracle.com/en_US/database/exadata-express/pricing" rel="noopener ugc nofollow" target="_blank"> Exadata Express云服务</a>创建了一个1600万行的表。然后比较以下精确、确定性和非确定性百分位数的运行时间:</p><pre class="jr js jt ju fd jy jz ka kb aw kc bi"><span id="bff7" class="kd ke hh jz b fi kf kg l kh ki">select percentile_disc(0.1) <br/>         within group (order by y) <br/>from   super_massive; </span><span id="c167" class="kd ke hh jz b fi lm kg l kh ki">select approx_percentile(0.1 deterministic) <br/>         within group (order by y) <br/>from   super_massive; </span><span id="1294" class="kd ke hh jz b fi lm kg l kh ki">select approx_percentile(0.1) <br/>         within group (order by y) <br/>from   super_massive;</span></pre><p id="1e8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">平均三次运行的时间，得出以下结果:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/35c939cdfcd0c9a456a8e48fe0d3fa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vMUQnHZTHdFKTzxB.png"/></div></div></figure><p id="4455" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">非确定性结果比确定性结果快大约5倍。比精确结果快了将近15倍！</p><p id="9c5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果你只需要一个估计值，你可以使用approx_percentile节省很多时间。</p><h1 id="920d" class="kk ke hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">错误率和置信度</h1><p id="c0ce" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">如果你得到的是估计数字，那就有问题了，结果的<em class="ls">有多准确？如果是99.9999%，那几乎可以肯定“足够好”。但是如果他们只有98%的准确率呢？还是95%？在某些时候，误差太大，你不能依赖估计，你会想切换回精确的计算。</em></p><p id="5749" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是要做到这一点，你需要知道错误是什么！</p><p id="1ba5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，请将ERROR_RATE或CONFIDENCE作为第二个参数进行传递。那么你会得到精度数字，而不是函数结果。自信是我们有多确定答案是正确的。错误率给出了不准确的程度。</p><p id="bf31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完美的发现近似有多好。</p><p id="c6e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有更多。</p><p id="9b14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你们当中的统计爱好者会知道中位数是百分位数的一个特例。所以还有一个approx_median函数可用。这与approx_percentile的工作方式相同。</p><p id="9ab5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么这些函数与参数approx_for_percentile有什么关系呢？</p><p id="c35c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle中有两个百分点函数，percentile_disc和percentile_cont。因此，您可以选择转换其中之一或两者都转换。以及是否以确定的方式这样做。这需要的值是:</p><ul class=""><li id="1836" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">所有确定性</li><li id="a454" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">百分位数_光盘确定性</li><li id="f102" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">百分比_cont确定性</li><li id="9b5c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">全部</li><li id="a2e6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">百分位_光盘</li><li id="b916" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">百分位_续</li><li id="53e4" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">没有人</li></ul></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><p id="0cd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【blogs.oracle.com】全文原载于2016年11月10日<a class="ae kj" href="https://blogs.oracle.com/sql/12-things-developers-will-love-about-oracle-database-12c-release-2" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p></div></div>    
</body>
</html>