<html>
<head>
<title>How we designed our Continuous Integration System to be more than 50% Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何设计持续集成系统，使其速度提高50%以上</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/how-we-designed-our-continuous-integration-system-to-be-more-than-50-faster-b70a59342fe2?source=collection_archive---------0-----------------------#2021-02-18">https://medium.com/pinterest-engineering/how-we-designed-our-continuous-integration-system-to-be-more-than-50-faster-b70a59342fe2?source=collection_archive---------0-----------------------#2021-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="bb44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Urvashi Reddy |工程生产力团队软件工程师</p><p id="061a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">今年早些时候，Pinterest的工程生产力团队发表了一篇名为</em> <a class="ae jd" rel="noopener" href="/pinterest-engineering/how-a-one-line-change-decreased-our-build-times-by-99-b98453265370"> <em class="jc">的博客，介绍了一行代码的改变如何将我们的克隆时间减少了99% </em> </a> <em class="jc">。在那篇文章中，我们描述了一个简单的Git配置如何在我们Pinterest最大的存储库中加快克隆速度。在本帖中，我们将讨论如何在为Pinterest的另一个主要存储库服务的CI中显著减少构建时间。剧透:这不是一行的变化！</em></p><p id="a4b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本博客涵盖的内容在BazelCon 2020上展示过。查看演示文稿</em> <a class="ae jd" href="https://opensourcelive.withgoogle.com/events/bazelcon2020/watch?talk=day1-talk4" rel="noopener ugc nofollow" target="_blank"> <em class="jc">使用Bazel查询设计语言不可知的CI</em></a><em class="jc">。</em></p><p id="7c09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">工程生产力团队的愿景是“建立一个开发者平台，激励开发者做最好的工作。”这个平台不可或缺的一部分是持续集成(CI)管道。CI管道负责验证代码变更并生成发布工件，这些工件可以部署到我们支持的连续交付平台之一。该公司有1000多名工程师，我们的团队面临着一个有趣的挑战，即提供可靠、快速的CI管道，为大规模的主要存储库提供服务。</p><p id="3856" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现这些目标，我们的团队做出了一些关键的设计选择:</p><ul class=""><li id="bb37" class="je jf hh ig b ih ii il im ip jg it jh ix ji jb jj jk jl jm bi translated">采用Bazel作为我们的构建工具</li><li id="333d" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">使用基于语言的monorepos</li><li id="c296" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">仅测试和发布变更的代码</li><li id="88aa" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">利用Bazel的构建文件作为CI和开发人员之间的契约</li><li id="8a9e" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">使用定制的Bazel规则创建发布抽象</li><li id="129e" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">尽可能并行工作</li></ul><h2 id="62e2" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">收养巴泽尔</h2><p id="f4ef" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">选择多语言的单一构建工具使我们的团队能够创建CI工作流，这些工作流可以应用于Pinterest上使用Bazel的任何存储库。由于Bazel的设计是封闭的，我们可以在CI中运行Bazel目标，而不需要配置或管理对主机的依赖。</p><h2 id="858c" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">基于语言的monorepos</h2><p id="9548" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">当代码被提交到存储库时，我们的CI管道被触发，这意味着每个存储库都有一个CI管道。为了限制我们必须管理的CI管道和存储库的数量，我们将我们的服务分组到每种语言的一个存储库中。</p><p id="3488" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你有兴趣了解以上两种选择，请查看我们团队的另一个BazelCon 2020演示，名为<a class="ae jd" href="https://opensourcelive.withgoogle.com/events/bazelcon2020/watch?talk=day2-talk2" rel="noopener ugc nofollow" target="_blank"> Pinterest的Monorepo之旅</a>。</p><h2 id="471e" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">仅测试和发布更改的代码</h2><p id="ace3" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在规模上，运行存储库中的每个目标是昂贵的。即使有了Bazel的缓存，用bazel test //…运行所有测试目标仍然意味着要花费时间来获取和加载目标的依赖项。这些对缓存的网络调用非常耗时，如果只运行最少的目标集，就可以完全避免。</p><p id="c2c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们monorepos中的服务在提交频率上有所不同。其中一些是每日贡献的，而另一些则是零星的。通过在CI中只运行受变更影响的内容，我们可以显著加快构建时间。</p><p id="f8d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，我们如何让最小的目标集运行呢？我们创建了一个名为build-collector的Golang CLI来报告在CI中运行的目标。CLI接收一组提交，并使用Bazel查询输出要运行的目标列表。CLI会查看已更改的文件，并运行适当的查询来查找受影响的目标。例如，如果更改了几个源代码文件，build-collector将运行以下查询:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/68b2c4fa1945d8b523db6db650db98f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVKTYYnJl1VjLP4sT0YEIg.png"/></div></div></figure><p id="1b97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的命令使用<a class="ae jd" href="https://docs.bazel.build/versions/master/query.html#rdeps" rel="noopener ugc nofollow" target="_blank"> rdeps </a>查询函数来查找源文件的反向依赖关系。输出是我们可以在CI中运行的目标列表。为了具体地获得测试目标，build-collector使用kind query函数用一个过滤器将上述内容包装起来:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/40a0f1d201b8d31830edb31cbf152574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASTp3YpZcCI7gzKhCpBJpw.png"/></div></div></figure><p id="fef1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:或者，可以使用<a class="ae jd" href="https://docs.bazel.build/versions/master/query.html#tests" rel="noopener ugc nofollow" target="_blank">测试</a>查询函数来过滤测试目标</p><p id="6db7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这只是构建收集器运行的查询的一种类型。查询的完整列表在<a class="ae jd" href="https://opensourcelive.withgoogle.com/events/bazelcon2020/watch?talk=day1-talk4" rel="noopener ugc nofollow" target="_blank"> <em class="jc">使用Bazel查询</em> </a>演示设计语言不可知CI中进行了说明。在这一点上，您可能想知道我们如何获得发布目标。当我们讨论我们的定制发布规则实现时，我们将在下面进一步讨论。</p><p id="299f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的CI脚本中，我们以下列方式调用build-collector:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lf"><img src="../Images/ba27aea0b6425854069246457e8bf530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYj0tYJPW9YveA2XEamOTg.png"/></div></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lg"><img src="../Images/4e900d680095b2ba3d81da840793bc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPrsxPnZZyyH9depdARueQ.png"/></div></div></figure><p id="61e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一个测试目标的构建收集器输出文件的例子。相同的JSON模式也用于发布目标。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lh"><img src="../Images/cbf8240e964bea5f2b6169b921d922b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUElfHZyK6luPtcthzsF2A.png"/></div></div></figure><p id="26e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">CI脚本解析build-collector输出的JSON文件，并在多个workers之间并行运行目标。</p><h2 id="f3b3" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">利用Bazel的构建文件作为CI和开发人员之间的契约</h2><p id="4c48" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们希望Pinterest工程师专注于功能工作，而不必学习太多关于如何设置CI的东西。考虑到我们还想在CI中运行最小的目标集，我们需要一种方式让开发人员交流哪些目标是本地开发的，以及他们的服务的哪些部分应该在CI中测试和发布。这就是Bazel构建文件派上用场的地方，因为它已经是开发人员定义测试和发布与他们的服务相关的工件的地方。开发人员在构建文件中遵循一些简单的约定，以便我们的CI可以准确地计算出要构建什么。</p><p id="99c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些惯例是:</p><ul class=""><li id="74e3" class="je jf hh ig b ih ii il im ip jg it jh ix ji jb jj jk jl jm bi translated">使用测试规则类型运行测试(标准Bazel实践)</li><li id="be47" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">使用Pinterest自定义发布规则来生成发布工件</li><li id="8ba8" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">使用no-ci等受支持的标记来指示管道中不应该运行的内容</li></ul><h2 id="672f" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">使用定制的Bazel规则创建发布抽象</h2><p id="49dc" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在Pinterest，我们支持发布到各个商店的许多不同的工件类型。例如，docker映像被发送到内部注册表，jar被发布到Artifactory，等等。为了支持这些工作流，我们为Pinterest的常见用例实施了自定义Bazel规则。定制规则帮助我们在基础设施上创建一个抽象。所有开发人员需要做的就是使用我们的自定义规则在构建文件中指出他们想要发布的内容。</p><p id="2c14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个常见的工作流是创建和发布docker图像，然后在部署到EC2或Kubernetes时引用这些图像。下面是一个例子，展示了工程师如何使用名为container_release的定制Bazel规则来让CI使他们的发布工件可用于部署。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lg"><img src="../Images/83eed6aad435c0eb74b23852ce7e0e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7T-2mWSeLJIEGLo03H60yw.png"/></div></div></figure><p id="165c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个示例构建文件中，该服务已经使用开源container_image规则创建了一个docker映像。使用定制的container_release规则，服务作者可以将docker映像发布到Pinterest注册中心，并指定哪些部署构件应该对我们的连续交付平台可用(EC2部署使用<a class="ae jd" href="https://github.com/pinterest/teletraan" rel="noopener ugc nofollow" target="_blank"> Teletraan </a>，Kubernetes工作负载使用<a class="ae jd" href="https://www.youtube.com/watch?v=KkKSoQBp2oQ" rel="noopener ugc nofollow" target="_blank"> Hermez </a>)。</p><p id="ccfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实施定制发布规则有几个好处:</p><ul class=""><li id="d26b" class="je jf hh ig b ih ii il im ip jg it jh ix ji jb jj jk jl jm bi translated">它为我们的开发人员抽象了基础设施层。他们不必知道部署工件的最终位置以及它们是如何被我们的CD平台消费的。</li><li id="92b8" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">开发人员通过受版本控制的代码来控制他们服务的哪些部分被发布</li><li id="8941" class="je jf hh ig b ih jn il jo ip jp it jq ix jr jb jj jk jl jm bi translated">我们可以通过控制在哪里发布工件来支持他们的发布工件的开发版本。</li></ul><p id="288c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一个好处是通过定制发布规则实现中的另一个发布抽象来实现的。每个Pinterest定制发布规则实际上是一个B <a class="ae jd" href="https://docs.bazel.build/versions/master/skylark/macros.html" rel="noopener ugc nofollow" target="_blank"> azel宏</a>，它生成两个定制发布规则:artifact_ci_release和artifact_dev_release。我们的开发人员不会直接看到这些规则或与之交互，但是我们的CI和本地开发工作流会使用它们来确保它们在正确的上下文中运行。例如，下面是Bazel查询构建收集器运行以获取源代码变更的发布目标:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/eb1bfd724af9e2403aded8fed02a4e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCX3U6ofJ-IjCmHPOd3oPg.png"/></div></div></figure><p id="3872" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在这里做的进一步优化是控制发布工件在artifact_*_release实现中运行的依赖顺序。例如，在我们发布引用它们的YAML文件之前，docker图像被发布到注册中心。这样做使得构建收集器中的查询逻辑快速而简单。</p><h2 id="2ee9" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">尽可能并行化</h2><p id="a5a1" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">为了确保我们的CI尽可能快地运行，我们希望尽可能地并行运行目标。我们目前通过我们称之为调度员模型来实现这一点。Dispatcher模型非常简单:我们计算出哪些目标需要在CI中运行，并将这些目标的执行分派给并行运行的workers。</p><p id="4d0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这在运行发布目标时有很大的好处。如果开发人员只关心从他们参与的几个服务中发布工件，他们不应该等待CI构建中的所有其他服务完成。独立和并行地运行发布目标为开发人员提供了他们准备好的发布工件。</p><h2 id="e155" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">拉式请求(PR)构建如何？</h2><p id="0462" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">每次创建新的拉动式请求时，我们的公关渠道都会启动CI运行。我们修补代码更改，并使用临时提交来传递给build-collector。这使得我们可以轻松地为PR构建重用相同的CI设置。唯一的区别是，我们不创建任何发布工件，而是通过运行Bazel build来检查发布目标是否可以编译。</p><h2 id="85a3" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">结果呢</h2><p id="d3ce" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">今年年初，我们在名为Optimus的回购中投资了上述设计选择。Optimus是一个monorepo，包含120多个java服务，并拥有我们在Pinterest的一些最重要的数据平台。Optimus及其CI渠道每月为300名活跃贡献者提供服务。</p><p id="72d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今年年初，我们没有使用build-collector，也没有使用Optimus中的发布规则抽象。代替那些事情的是，当代码发生变化时，我们在一个服务中运行所有的目标，并且我们有用于发布发布工件的粒度发布规则。当时，CI构建的P50时间为52分钟，P90时间为69分钟。在迁移到我们的新CI设计后，我们看到P50时间在一周内下降到19分钟，P90下降到49分钟。P50快2.7倍，P90快1.4倍！</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/9443b582453673fdc05475a18b31f9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOSp2xCMw7ufJMHM"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx"><em class="ln">Chart comparing build times the week before and after the CI migration</em></figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/6e0a54b32773449ff2490f486331c962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PlzEHE05M6SDzcPu"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx"><em class="ln">One month distribution of build times with the old CI</em></figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lp"><img src="../Images/76abfd34f6731908f524f067db8a1010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uMmMwBjLdl7a7oWz"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx"><em class="ln">One month distribution of build times with new CI</em></figcaption></figure><h1 id="a165" class="lq jt hh bd ju lr ls lt jy lu lv lw kc lx ly lz kf ma mb mc ki md me mf kl mg bi translated">学习</h1><p id="5097" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Bazel是一个强大的工具，我们可以利用它来创建一个持续集成平台，适用于Pinterest的各种用例。像build-collector和自定义发布规则这样的优化构建了平台的基础层，我们可以在此基础上创建更多增强功能，进一步提高CI构建的速度和健康状况。我们希望Bazel接下来研究的一些东西是:远程执行、概要分析和自动检测和排除不可靠测试的系统。</p></div></div>    
</body>
</html>