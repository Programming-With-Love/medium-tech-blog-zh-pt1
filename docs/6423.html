<html>
<head>
<title>How to Learn React #3 — Understand the Magic Behind React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何学习React #3 —理解React组件背后的魔力</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/lets-learn-react-chapter-3-components-components-components-3492f771d623?source=collection_archive---------7-----------------------#2018-02-04">https://medium.com/quick-code/lets-learn-react-chapter-3-components-components-components-3492f771d623?source=collection_archive---------7-----------------------#2018-02-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/169ddc681d5c7de65d9ffe77087409fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cx88IOHNXLLxt3VqlvN4Ig.png"/></div></div></figure><p id="b5b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" rel="noopener" href="/quick-code/lets-learn-react-chapter-2-what-the-hell-is-jsx-and-where-can-i-buy-it-5303a7db5117">前一章</a>中，我们谈到了JSX，我们修改了渲染方法。我们还提到了一点React组件。在这一章中，我们将更多地讨论组件，我们将利用它们并给我们的应用程序带来一点变化。因此，让我们打开我们的编辑器，做一些工作。首先，我们将在<em class="jo"> src </em>目录中创建<em class="jo">组件</em>目录，并将<em class="jo"> App.js </em>移动到其中。这个目录将包含我们所有的组件。我们移动了App.js，所以我感觉我们也需要改变index.js中的import语句。继续将index.js中的App组件的导入更改为<code class="du jp jq jr js b">import App from './components/App';</code>。更改后，应用程序应该编译成功。新项目树将如下所示。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div class="er es jt"><img src="../Images/b6c053c1fc7d7dd903e9ece606291030.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*7ezu0LvjYaQ5T_tp2KdwmA.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx">Project tree</figcaption></figure><p id="0ef8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在…我有一种感觉，App.js应该代表我们的应用程序。现在，它检查这是哪种类型的一天，并做一些日期名称的转换。我有点不喜欢它。我希望看到的只是一个简单的组件，其中包含了很多其他组件。假设我们对我们的App.js组件很满意，但是我们想称它为更好的组件，例如DayChecker。然后…我们想在我们的应用程序中使用日检查组件。好的，我不知道为什么，但这可以通过两步来实现。我们必须创建一个名为DayChecker的新组件，具有<em class="jo"> App.js </em>功能。然后，我们必须将该组件导入到我们的应用程序组件中并使用它。让我们做第一个。复制<em class="jo"> App.js </em>中的所有内容，在<em class="jo"> components </em>目录下创建一个名为<em class="jo"> DayChecker.js </em>的新文件，并将代码粘贴到其中。好吧，这很容易，但这不是我们想要的。我们现在需要做一些重命名。在<em class="jo"> DayChecker.js </em>中，将类从<em class="jo"> App </em>更改为<em class="jo"> DayChecker </em>，并将导出语句更改为导出<em class="jo"> DayChecker </em>。该文件应该如下所示</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="f06c" class="kg kh hh js b fi ki kj l kk kl">import React, { Component } from 'react';</span><span id="65fe" class="kg kh hh js b fi km kj l kk kl">class DayChecker extends Component {<br/>  getDayName(number) {<br/>    let days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];<br/>    return days[number];<br/>  }</span><span id="25e3" class="kg kh hh js b fi km kj l kk kl">render() {<br/>    // Get current date<br/>    let today = new Date().getDay();<br/>    // If it is weekday<br/>    if (today === 6 || today === 0)<br/>      return &lt;div&gt;Today is {this.getDayName(today)} - You can watch TV all day today&lt;/div&gt;;<br/>    // If it is weeken<br/>    return &lt;div&gt;Today is {this.getDayName(today)} - You should go to work today&lt;/div&gt;;<br/>  }<br/>}</span><span id="6c34" class="kg kh hh js b fi km kj l kk kl">export default DayChecker;</span></pre><p id="8544" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好吧…这是第一步。我知道这很容易。好的一面是，第二步更容易，也更有趣，因为我们要删除。在<em class="jo"> App.js </em>中删除所有内容，然后添加空的渲染方法。该文件将如下所示</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="f5c2" class="kg kh hh js b fi ki kj l kk kl">import React, { Component } from 'react';</span><span id="7776" class="kg kh hh js b fi km kj l kk kl">class App extends Component {<br/>  render() {<br/>    <br/>  }<br/>}</span><span id="dca8" class="kg kh hh js b fi km kj l kk kl">export default App;</span></pre><p id="d8df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将导入我们的日检查器组件。在<em class="jo"> App.js </em>的顶部添加导入语句<code class="du jp jq jr js b">import DayChecker from ‘./DayChecker’;</code>并在render里面返回它。该文件将如下所示</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="1435" class="kg kh hh js b fi ki kj l kk kl">import React, { Component } from 'react';<br/>import DayChecker from './DayChecker';</span><span id="b0f0" class="kg kh hh js b fi km kj l kk kl">class App extends Component {<br/>  render() {<br/>    return &lt;DayChecker /&gt;;<br/>  }<br/>}</span><span id="ab7e" class="kg kh hh js b fi km kj l kk kl">export default App;</span></pre><p id="f1ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好吧…我喜欢。现在我们的应用程序组件看起来更好了，所有关于检查日期的逻辑都在我们的DayChecker中。现在，React组件的好处是我们可以在应用程序中多次使用它们，所以当你编写一个组件时，考虑可重用性总是好的，因为你很可能会多次使用它。现在我们已经着火了，让我们创建另一个组件。我们称它为Header，它只会返回一个简单的标题</p><p id="e076" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jp jq jr js b">&lt;h2&gt;This app will tel you if you should work today&lt;/h2&gt;</code></p><p id="2cb6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我相信你，所以我不会在这里提供两步公式。如果你想自己尝试，不要向下滚动太多，因为那里有一个解决方案。好的，你可能创建了新的组件，它看起来像这样</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="cac7" class="kg kh hh js b fi ki kj l kk kl">import React, { Component } from 'react';</span><span id="1967" class="kg kh hh js b fi km kj l kk kl">class Header extends Component {<br/>  render() {<br/>    return &lt;h2&gt;This app will tel you if you should work today&lt;/h2&gt;;<br/>  }<br/>}</span><span id="ad1b" class="kg kh hh js b fi km kj l kk kl">export default Header;</span></pre><p id="e1ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后你导入并想要在我们的应用中渲染它，所以<em class="jo"> App.js </em>看起来像这样。</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="07a9" class="kg kh hh js b fi ki kj l kk kl">import React, { Component } from 'react';<br/>import DayChecker from './DayChecker';<br/>import Header from './Header';</span><span id="3f51" class="kg kh hh js b fi km kj l kk kl">class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;Header /&gt;<br/>      &lt;DayChecker /&gt;<br/>    );<br/>  }<br/>}</span><span id="1e6f" class="kg kh hh js b fi km kj l kk kl">export default App;</span></pre><p id="9908" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是现在我们得到了一个错误消息，说<strong class="ir hi">相邻的JSX元素必须用一个封闭标签包起来。【React是想告诉<em class="jo"> render </em>不应该返回多个元素。现在我们返回2。我们有两个选择来修复它。首先是将我们的2个组件包装在一个<code class="du jp jq jr js b">div</code>标签中。是的…就是这样，我们现在只返回一个元素。</strong></p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="f808" class="kg kh hh js b fi ki kj l kk kl">render() {<br/>    return (<br/>      &lt;div&gt;        <br/>        &lt;Header /&gt;<br/>        &lt;DayChecker /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="1876" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个是返回一个元素数组，我们可以这样做</p><pre class="ju jv jw jx fd kc js kd ke aw kf bi"><span id="7f06" class="kg kh hh js b fi ki kj l kk kl">render() {<br/>    return [<br/>      &lt;Header /&gt;,<br/>      &lt;DayChecker /&gt;<br/>    ];<br/>}</span></pre><p id="e3b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不知道你更喜欢哪个。我不是什么绿野仙踪，但我猜是第二部，因为它比较短。所以我们选那个。好的……干得不错。我想祝贺你到目前为止，也感谢你和我在一起。总结一下，我们创建了新的组件，并在我们的应用程序中使用它们。在下一章，我们将学习更多关于组件的知识。我将描述基于类的组件和功能组件之间的区别。敬请期待，保持谦逊，让我们准备好迎接下一章的隆隆声。干杯！</p></div></div>    
</body>
</html>