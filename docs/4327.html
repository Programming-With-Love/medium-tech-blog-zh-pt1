<html>
<head>
<title>Avoid backing properties for LiveData and StateFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免支持LiveData和StateFlow的属性</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/avoid-backing-properties-for-livedata-and-stateflow-706006c9867e?source=collection_archive---------0-----------------------#2021-01-12">https://medium.com/google-developer-experts/avoid-backing-properties-for-livedata-and-stateflow-706006c9867e?source=collection_archive---------0-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/65e785f18de90f05e608fc998243252e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-pzXHtf0_BBtplpDb257g.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://unsplash.com/photos/OopPIi_A428" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/OopPIi_A428</a></figcaption></figure><p id="a67d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你曾经使用过<code class="du js jt ju jv b"><a class="ae it" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>,你可能已经写了类似这样的代码:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="b75d" class="ke kf hh jv b fi kg kh l ki kj">class MyViewModel: ViewModel() {</span><span id="271b" class="ke kf hh jv b fi kk kh l ki kj"><strong class="jv hi">   val loading: LiveData&lt;Boolean&gt;<br/>       get() = _loading</strong></span><span id="7d29" class="ke kf hh jv b fi kk kh l ki kj"><strong class="jv hi">   private val _loading = MutableLiveData&lt;Boolean&gt;()</strong></span><span id="89e7" class="ke kf hh jv b fi kk kh l ki kj">}</span></pre><p id="399d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这似乎是当今开发人员公开一些不可变的<code class="du js jt ju jv b">LiveData</code>的典型方式，同时能够在我们将数据写入的实现中有一个可变的版本。</p><p id="201e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当我看到，甚至不得不写下这种代码时，我内心就有些畏缩。正如我在<a class="ae it" href="https://speakerdeck.com/dpreussler/take-your-kotlin-to-the-next-step-abandon-what-youve-learned-in-java" rel="noopener ugc nofollow" target="_blank">的一次演讲</a>中引用的，我们大脑中的这种感觉是真实的:</p><blockquote class="kl"><p id="6cc3" class="km kn hh bd ko kp kq kr ks kt ku jr dx translated"><a class="ae it" href="https://sciencephenomena.wordpress.com/2015/05/10/the-neurological-aspect-of-cringing/" rel="noopener ugc nofollow" target="_blank"> <em class="kv">社交失策激活大脑中的区域，[..]以前与身体疼痛有关。</em>T9】</a></p></blockquote><p id="6f3e" class="pw-post-body-paragraph iu iv hh iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">作为开发人员，我们知道这段代码有问题，对吗？这也感觉像我们在这里写手工getters和setters。</p><h1 id="6040" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">怎么了?</h1><p id="1a7b" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">我们可以从我们用于后台字段的前缀开始，尽管我们努力了很长时间来摆脱前缀，但我们在这里接受它！它甚至被写进了官方的编码惯例。</p><p id="78a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但即使我们给它重新命名，它仍然畏缩不前:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="70d7" class="ke kf hh jv b fi kg kh l ki kj">class MyViewModel: ViewModel() {</span><span id="e16b" class="ke kf hh jv b fi kk kh l ki kj">   val <strong class="jv hi">loading</strong>: LiveData&lt;Boolean&gt;<br/>       get() = <strong class="jv hi">mutableLoading</strong></span><span id="d769" class="ke kf hh jv b fi kk kh l ki kj">   private val <strong class="jv hi">mutableLoading</strong> = MutableLiveData&lt;Boolean&gt;()</span><span id="fd71" class="ke kf hh jv b fi kk kh l ki kj">}</span></pre><p id="30d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种重复感觉没必要！特别是如果你写了一些类似于ViewModel的东西，暴露了很多这样的问题，你会迷失在阅读这些重复的代码中。</p><h1 id="da77" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但只是LiveData？</h1><p id="4780" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">你可能会认为这只是<code class="du js jt ju jv b">LiveData</code>的专长，而这种结构的未来可能会更加有限。</p><p id="de80" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你就不会有这个问题。该语言通过一个私有setter支持这一点:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="ad8a" class="ke kf hh jv b fi kg kh l ki kj">var secret: String = "Secret"<br/>  <strong class="jv hi"> private set</strong></span></pre><p id="28d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是镇上来了一个新的小孩:<code class="du js jt ju jv b">StateFlow</code>需要同样的东西！请看来自Jetbrains官方博客<a class="ae it" href="https://blog.jetbrains.com/kotlin/2020/10/kotlinx-coroutines-1-4-0-introducing-stateflow-and-sharedflow/" rel="noopener ugc nofollow" target="_blank">的片段:</a></p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="0ac1" class="ke kf hh jv b fi kg kh l ki kj">class DownloadingModel {</span><span id="cc2b" class="ke kf hh jv b fi kk kh l ki kj"><strong class="jv hi">   private val _state</strong> = MutableStateFlow&lt;DownloadStatus&gt;(DownloadStatus.NOT_REQUESTED)</span><span id="7776" class="ke kf hh jv b fi kk kh l ki kj"><strong class="jv hi">   val state: StateFlow&lt;DownloadStatus&gt; get() = _state</strong></span></pre><p id="9198" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个问题讨论很多。有些人甚至建议改变科特林语来支持这一点！</p><p id="c71b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管这感觉就像我们想用大锤砸坚果或用大炮射麻雀或你们语言中的任何术语！</p><p id="c92d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">难道没有更微妙的东西来解决这个问题吗？</p><h1 id="caa7" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的实际目标是什么？</h1><p id="5565" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">我们希望将公共API从实际实现中分离出来，对吗？</p><p id="74ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">信不信由你，我们已经有了这方面的语言结构！叫<strong class="iw hi">接口</strong>！</p><p id="16f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管许多开发人员会定期为类似于<code class="du js jt ju jv b">Repositories</code>的类提取接口，但很少有人为<code class="du js jt ju jv b">ViewModels</code>提取接口。</p><p id="439a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是为什么呢？因为只有一个实现？也许视图模型是视图之前的最后一块积木，我们几乎不需要在测试中模拟它们？<br/>也许！但我们刚刚找到了另一个使用它们的好理由。</p><p id="2162" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于<code class="du js jt ju jv b">ViewModel</code>来说，抽象类会更容易，因为我们无论如何都需要扩展Google<code class="du js jt ju jv b">ViewModel</code>(如果你愿意，你可以使用接口)</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="2124" class="ke kf hh jv b fi kg kh l ki kj">abstract class MyViewModel: ViewModel() {<br/><strong class="jv hi">   abstract val loading: LiveData&lt;Boolean&gt;</strong><br/>}</span><span id="5f40" class="ke kf hh jv b fi kk kh l ki kj">class MyViewModelImpl: MyViewModel() {<br/><strong class="jv hi">   override val loading = MutableLiveData&lt;Boolean&gt;()</strong><br/>}</span></pre><p id="e3ad" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从ViewMode里面已经现了类型:<br/> <code class="du js jt ju jv b">override val loading: <strong class="iw hi">MutableLiveData&lt;Boolean&gt;</strong></code></p><p id="7dd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这被称为<a class="ae it" href="https://en.wikipedia.org/wiki/Covariant_return_type#:~:text=In%20object%2Doriented%20programming%2C%20a,is%20overridden%20in%20a%20subclass.&amp;text=This%20usually%20implies%20that%20the,type%20of%20the%20overridden%20method." rel="noopener ugc nofollow" target="_blank">协变返回类型</a>，其中实现返回比原始声明更具体的类型。现在好的一点是，我们可以从我们的实现中直接为我们的加载状态设置值:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="e334" class="ke kf hh jv b fi kg kh l ki kj">class MyViewModelImpl: MyViewModel() {<br/><strong class="jv hi">   </strong>override val loading = <strong class="jv hi">MutableLiveData</strong>&lt;Boolean&gt;()</span><span id="7a32" class="ke kf hh jv b fi kk kh l ki kj">   fun doSomeWork() {<br/>     // ...<br/><strong class="jv hi">     loading.value = true<br/></strong>  }<br/>}</span></pre><h1 id="77fe" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不是泄露细节吗？</h1><p id="d4e5" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">您可能会问，我们是否没有公开太多的实现细节？如果你直接使用<code class="du js jt ju jv b">MyViewModelImpl</code>(而不是抽象类)，你可以从外部写入<code class="du js jt ju jv b">loading</code>！</p><p id="b75c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">答案是<strong class="iw hi">不</strong>！</p><p id="9728" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">无论如何，除了创建这个类的人之外，没有人应该知道这件事！通常这是我们进行依赖注入的层，或者在<code class="du js jt ju jv b">ViewModels</code>的情况下，是<code class="du js jt ju jv b">ViewModelFactory</code>。尽量避免直接看到或创建实现。</p><p id="dbd2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，有人总是可以将接口向上转换为具体的类，但是也可以向上转换原始的<code class="du js jt ju jv b">loading</code>！</p><p id="b915" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里引用一个老的clean coders博客:</p><blockquote class="md me mf"><p id="dad9" class="iu iv mg iw b ix iy iz ja jb jc jd je mh jg jh ji mi jk jl jm mj jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="hh">谁会这么做？</em> </strong> <em class="hh"> <br/>我不知道。呃。坏人。</em></p><p id="7e34" class="iu iv mg iw b ix iy iz ja jb jc jd je mh jg jh ji mi jk jl jm mj jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="hh">你团队里有坏人吗？</em> </strong> <em class="hh"> <br/>没有但是。这感觉不安全。</em></p><p id="afde" class="iu iv mg iw b ix iy iz ja jb jc jd je mh jg jh ji mi jk jl jm mj jo jp jq jr ha bi translated">嗯，如果这是公共API的一部分，我同意你的观点。但是如果这只是我们团队使用的代码，那么…  </p></blockquote><p id="bd0c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果那些只是我们的同事，我们就不需要保护我们的代码免受不良行为者的攻击。我们的工作是确保API是清晰和干净的，所以用法是可以理解的！专注于防止错误，而不是滥用。</p><h1 id="0896" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">谷歌视图模型的细节</h1><p id="dc9d" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">Jetpack的视图模型有一些细节，让我们简单讨论一下在哪里使用抽象类。</p><p id="5a89" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你用Koin它的琐碎:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="a827" class="ke kf hh jv b fi kg kh l ki kj">private val<strong class="jv hi"> </strong>viewModel: <strong class="jv hi">MyViewModel by <em class="mg">viewModel</em>()</strong></span></pre><p id="9c7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您的模块中，您应该这样声明它:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="af32" class="ke kf hh jv b fi kg kh l ki kj">viewModel<strong class="jv hi">&lt;MyViewModel&gt;</strong> { <strong class="jv hi">MyViewModelImpl</strong>(...) }</span></pre><p id="6cea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当使用来自Ktx的代理时，事情有时会更棘手一些(比如测试)。<br/>如果您使用自定义提供程序，这很容易，例如可以通过Dagger注入:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="19e9" class="ke kf hh jv b fi kg kh l ki kj">@Inject lateinit var provider: <strong class="jv hi">MyViewModelProvider</strong><br/>private val viewModel: <strong class="jv hi">MyViewModel by <em class="mg">viewModels </em></strong>{ provider }</span></pre><p id="ceba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果使用通用工厂，这就不那么明显了:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="c63c" class="ke kf hh jv b fi kg kh l ki kj">@Inject lateinit var factory: <strong class="jv hi">ViewModelProvider.Factory</strong><br/>private val viewModel: <strong class="jv hi">MyViewModel by <em class="mg">viewModels</em></strong><em class="mg"> </em>{ factory }</span></pre><p id="2afb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你必须以某种方式告诉Dagger如何进行匹配。但是应该在你的模块中以正常的方式完成，你可以手动或者用<code class="du js jt ju jv b">@Bind</code>将<code class="du js jt ju jv b">MyViewModel</code>绑定到<code class="du js jt ju jv b">MyViewModelImpl</code>。这意味着更多的Dagger代码但ViewModel中的代码更少，这应该是值得的。当谈到Dagger时，有时如果它改善了你的整体架构，那么越多越好。专注于改进你每天阅读和工作的代码，而不是幕后的匕首设置。</p><h1 id="ee98" class="lb kf hh bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="ee4b" class="pw-post-body-paragraph iu iv hh iw b ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn mc jp jq jr ha bi translated">通过使用接口或抽象类，您不仅可以消除实现中的所有重复，还可以专注于功能。减少噪音对于干净和可重用的代码非常重要。</p><p id="cdaf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另外，你为你的用户创建了一个非常干净的API，这里有一个来自我正在做的一个小测验应用，使用Flow:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="265a" class="ke kf hh jv b fi kg kh l ki kj">abstract class GameViewModel: ViewModel() {<br/>    val nextQuestion: Flow&lt;String&gt;<br/>    val nextAnswers: Flow&lt;Answers&gt;<br/>    val loadingVisible: Flow&lt;Boolean&gt;<br/>    val score: Flow&lt;String&gt;<br/>    val gameOver: Flow&lt;Boolean&gt;<br/>}</span></pre><p id="80b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你回想一下用头文件编程的C语言，这就是我们当时的情况。清晰的对外接口，完美的封装。<br/>一门被遗忘的艺术有时……</p><p id="7089" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">PS:所有的荣誉都归于艾丹·麦克威廉姆斯，是他让我注意到了这一点！</p></div></div>    
</body>
</html>