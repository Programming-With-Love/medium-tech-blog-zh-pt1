<html>
<head>
<title>MLOps — Is it a Buzzword??? Part Two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MLOps——它是一个流行词吗？？？第二部分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/mlops-is-it-a-buzzword-part-2-5a8436fb3020?source=collection_archive---------3-----------------------#2021-07-30">https://medium.com/walmartglobaltech/mlops-is-it-a-buzzword-part-2-5a8436fb3020?source=collection_archive---------3-----------------------#2021-07-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/7c548746163861d779deea5a1661fde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*83P2vL_DclICIDZbrWNs7A.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Image : <a class="ae ip" href="https://cloudzone.io/wp-content/uploads/2021/05/kubeflow21.jpg" rel="noopener ugc nofollow" target="_blank">CloudZone</a></figcaption></figure><p id="3823" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">本文是三篇系列文章的第二篇，旨在使用GCP的托管Kubeflow管道实现MLOps。在<a class="ae ip" rel="noopener" href="/walmartglobaltech/mlops-is-it-a-buzzword-part-1-8573fe95290e">系列的第一部分</a>中，我们学习了MLOps、各种编排选项和Docker/Kubernetes的基础知识。</p><p id="553f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">本文将更多地关注构建<em class="jo"> Kubeflow管道，包括更多的编码示例。</em></p><p id="f98f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo">它将涵盖MLOps的一些原则，包括:</em></p><ul class=""><li id="b561" class="jp jq hh is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><em class="jo">可移植性/可扩展性</em></li><li id="7c13" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><em class="jo">工件跟踪</em></li><li id="c912" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><em class="jo">重复性/再现性</em></li></ul><p id="f3e6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> Kubeflow组件</strong></p><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kd"><img src="../Images/20e0a4bbb80d6a3b366091599c4f46a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1iVAcnNfJHgN5bU5m3BFA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Image by Author</figcaption></figure><p id="3128" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo">管道组件</em>是执行特定功能的自包含代码集。它有名称、参数、返回值和主体。容器提供了便携性、可重复性和封装性。下面我将范围限制在基于Python的组件上，以便进一步解释。</p><p id="e38a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">组件代码包含执行ML工作流中特定步骤所需的逻辑(可能是使用Spark的<em class="jo">数据提取/处理</em>或使用sklearn/TensorFlow的<em class="jo">模型训练</em>)。它只是一个用decorator <code class="du km kn ko kp b">kfp.v2.dsl.component</code>注释的纯Python函数。该组件应遵循以下规则:</p><ul class=""><li id="7d46" class="jp jq hh is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">它不应该使用在函数定义之外声明的任何代码。</li><li id="55a6" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Import语句必须添加到函数内部。</li><li id="81da" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">助手函数必须在这个函数中定义。</li></ul><p id="66f8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们从简单的Python组件的一个例子开始，它将两个数字相加并返回结果。</p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="a301" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">正如所观察到的，函数的所有参数和返回类型都必须有数据类型注释。它有助于支持输入/输出工件日志记录，这与MLOps的一个原则有关。</p><p id="9367" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><code class="du km kn ko kp b">@ component</code>将您的python函数转换为Kubeflow组件，它允许我们定义三个可选参数:</p><ul class=""><li id="995b" class="jp jq hh is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hi"> base_image </strong>:(可选)指定运行该函数的Docker容器图像。它也支持自定义图像。默认值是Python 3.9图像。</li><li id="1350" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hi">输出组件文件</strong>:(可选)将组件定义写入文件。您可以使用此文件与同事共享组件，或者在不同的管道中重用它。</li><li id="8edd" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hi"> packages_to_install </strong>:(可选)运行函数前要安装的版本化Python包列表。<em class="jo">建议创建一个定制映像，并预先安装所有需要的库。</em></li></ul><p id="45b1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下面是示例输出组件文件，如果用文件名指定了可选参数，将会生成该文件。它可以跨管道共享和重用。这只不过是一个带有一组指令的Dockerfile文件。</p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="2516" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">使用下面的方法，可以从yaml组件中重新创建<em class="jo"> Python组件</em>。</p><pre class="ke kf kg kh fd ks kp kt ku aw kv bi"><span id="5530" class="kw kx hh kp b fi ky kz l la lb">import kfp.components as comp<br/>comp.load_component_from_file("add_component.yaml")</span></pre><p id="b7cb" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">此外，使用这种方法，从airflow操作器迁移到Kubeflow组件相当简单。</p><pre class="ke kf kg kh fd ks kp kt ku aw kv bi"><span id="cfcd" class="kw kx hh kp b fi ky kz l la lb">comp.create_component_from_airflow_op()</span></pre><p id="6984" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们看一个稍微复杂一点的<em class="jo">组件</em>的例子。</p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="1f5d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">该组件接受两个输入，并使用组件代码中定义的帮助函数使用NumPy包来计算商和余数。这个组件代码返回了两个输出，一个是使用<em class="jo"> NamedTuple </em>显式定义的，另一个是使用工件类型的参数(<em class="jo">Output【Metrics】</em>)。</p><blockquote class="lc ld le"><p id="a74f" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn ha bi translated">如果你的函数输出是原始类型，返回类型可以是<em class="hh">类型注释</em>为“float”、“str”、“None”等。如果您的组件返回多个输出，您可以用<code class="du km kn ko kp b"><a class="ae ip" href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="noopener ugc nofollow" target="_blank">typing.NamedTuple</a></code>类型提示注释您的函数，并使用<code class="du km kn ko kp b"><a class="ae ip" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">collections.namedtuple</a></code>函数将您的函数的输出作为tuple的新子类返回。</p></blockquote><p id="00e4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">平均成分:</strong></p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="a606" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是我们管道中的最后一个组件，输出是类型为<code class="du km kn ko kp b">dataset</code>的<code class="du km kn ko kp b">artifacts</code>。工件代表大型或复杂的数据结构(<code class="du km kn ko kp b">dataset</code>或<code class="du km kn ko kp b">model</code>)。</p><p id="3a62" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">管道</strong></p><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es li"><img src="../Images/2499d521a66513f51c893bec02299b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5g19wju2o06efbZfu4Gqw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Image by Author</figcaption></figure><p id="1536" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在，组件已经准备好了，是时候构建管道了。</p><p id="41a4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">通过连接组件的输入/输出接口来创建管道。或者，您可以在管道任务上使用<em class="jo">之前/之后</em>方法。</p><p id="c456" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">组件输入和输出分为<em class="jo">参数</em>或<em class="jo">工件</em>(取决于它们的数据类型)，数据共享通过它们进行。</p><ul class=""><li id="23cf" class="jp jq hh is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">参数通过值传递到组件中，可以是以下任何类型:int、double、float、str或collections。它非常适合较小的数据(如果您想返回任何数字/字符串/字典或集合)。</li><li id="75c3" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">工件表示大型或复杂的数据结构，如数据集或模型，并作为对文件路径的引用传递到组件中。</li><li id="5c99" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">如果您有大量的字符串数据要传递给组件，比如一个JSON文件，那么将该输入或输出注释为一种类型的<a class="ae ip" href="https://github.com/kubeflow/pipelines/blob/master/sdk/python/kfp/dsl/io_types.py" rel="noopener ugc nofollow" target="_blank">工件</a>，比如<a class="ae ip" href="https://github.com/kubeflow/pipelines/blob/master/sdk/python/kfp/dsl/io_types.py" rel="noopener ugc nofollow" target="_blank">数据集</a>，让Kubeflow管道知道将其作为一个文件传递给组件。</li></ul><blockquote class="lc ld le"><p id="2832" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn ha bi translated">(如果你是从气流背景来的，可以和<em class="hh"> Xcom推</em>和<em class="hh">拉</em>操作有关。)</p></blockquote><p id="0a88" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">演示管道(</strong> <em class="jo">虚拟示例</em> <strong class="is hi"> ) </strong></p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="ceb2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><code class="du km kn ko kp b">kfp.dsl.pipeline</code>注释帮助你定义管道。它有三个参数名称、描述和pipeline_root。前两个是不言自明的。管道根是指您的项目可以访问的GCS或S3中的存储位置。样品位置应为<code class="du km kn ko kp b"> gs://my-project/your-folder/</code>。这是存储所有管道任务输出的位置。以下是该管道的虚拟流:</p><ul class=""><li id="a0b3" class="jp jq hh is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">将两个数相加并返回结果。</li><li id="4181" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">通过将add组件的输出传递给divide组件，将add组件与divide组件连接起来。</li><li id="4d70" class="jp jq hh is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用分割任务的“after”方法连接下一个组件。</li></ul><p id="543f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">编译并运行</strong></p><p id="c1f6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">一旦定义了管道，就可以编译生成yaml，直接上传到您的管道UI，或者您可以使用<code class="du km kn ko kp b"><em class="jo">kfp.client</em></code>或<code class="du km kn ko kp b">AIPlatformClient(GCP)</code>来触发您的管道。</p><figure class="ke kf kg kh fd ii"><div class="bz dy l di"><div class="kq kr l"/></div></figure><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lj"><img src="../Images/2d677d797bb567a70b24e52e85582bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7lYpYAPb26RmxmCko87kw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Image by Author</figcaption></figure><p id="a278" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里是使用GCP顶点人工智能运行的演示管道。在这里，我们使用简单的Python函数和Python一样的基本图像，但是根据你的需要，你可以使用Java/Scala或任何其他语言和适当的图像来编码单个组件。输出工件在这个管道中突出显示，这个管道不是一个组件，而是来自特定组件的工件。</p><figure class="ke kf kg kh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lk"><img src="../Images/7e7fc99afe9e9d615ea1fa2be2524a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bX0x74APV1HERBWhiReurA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Image by Author</figcaption></figure><blockquote class="lc ld le"><p id="244d" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn ha bi translated">我会在这里结束。在下一篇文章中，我们将讨论一个端到端的ML工作流实现。</p></blockquote><p id="e0cf" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我希望这篇文章对你有用，如果有用的话，考虑至少鼓掌50次。👏 :)</p></div></div>    
</body>
</html>