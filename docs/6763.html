<html>
<head>
<title>ES5 =&gt; ES6…A must-read if you wanna be a slayer😎 in JavaScript ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES5 = &gt; ES6…如果你想成为一名杀戮者，这是一本必读的书😎在JavaScript ES6中</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/es5-es6-a-must-read-if-you-wanna-be-a-slayer-in-javascript-es6-959a8215e252?source=collection_archive---------3-----------------------#2019-12-17">https://medium.com/quick-code/es5-es6-a-must-read-if-you-wanna-be-a-slayer-in-javascript-es6-959a8215e252?source=collection_archive---------3-----------------------#2019-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/39eb6ce9c835d1542006237fdc2622c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3JGD3I2DiqauhK2CTMLmw.jpeg"/></div></div></figure><p id="9f7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个JavaScript开发人员都会发现EcmaScript版本，每隔一两年就会有新的版本加入到语言中。</p><p id="0fe2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，当ES6在2015年推出时，JavaScript真正取得了长足的进步。</p><p id="3feb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将简要介绍ES6中的这些变化和新增功能。</p><p id="a098" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，准备好吧，伙计们，这趟旅程将会充满刺激和大量的JavaScript ES6。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="6ec8" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">箭头功能= &gt;</h1><p id="0d1e" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">创建箭头函数的语法类似于常规函数的语法，但有几处不同。</p><p id="426e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个区别是不再需要“function”关键字。<br/>第二个区别是在参数和函数体之间添加了箭头“= &gt;”。</p><p id="7edb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">示例::</strong></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="437f" class="lg jv hh lc b fi lh li l lj lk">const printMyName = (name) =&gt; {</span><span id="83f5" class="lg jv hh lc b fi ll li l lj lk">return `My name is ${name}`</span><span id="dd11" class="lg jv hh lc b fi ll li l lj lk">}</span><span id="9cf4" class="lg jv hh lc b fi ll li l lj lk">console.log(printMyName('Bhavishya')) // prints Bhavishya</span></pre><p id="77f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个箭头函数的简写语法，我们从函数定义中去掉了花括号。然后，我们将想要返回的表达式放在箭头的右边。<br/>对return关键字没有要求，因为我们添加的表达式是隐式返回的。</p><p id="620c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用简写语法编写上面的代码，</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="eb65" class="lg jv hh lc b fi lh li l lj lk">const printMyName = name =&gt; `My name is ${name}`</span><span id="5648" class="lg jv hh lc b fi ll li l lj lk">console.log(printMyName('Bhavishya')) // prints "Bhavishya"</span></pre><p id="bae2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">箭头函数不绑定<code class="du lm ln lo lc b">this</code>关键字。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="d99a" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">承诺</h1><p id="4db3" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">Promise是回调函数的替代方法，可以简化异步代码的管理。</p><p id="0fdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用<code class="du lm ln lo lc b">new</code>操作符创建一个承诺。<br/>它需要两个参数<code class="du lm ln lo lc b">reslove and reject</code>。一个承诺可以有三种状态之一:1 .待定2 .履行完毕3 .拒绝</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2dd0" class="lg jv hh lc b fi lh li l lj lk">const myPromise = new Promise((resolve, reject) =&gt; {</span><span id="972d" class="lg jv hh lc b fi ll li l lj lk">setTimeout(() =&gt; {</span><span id="8379" class="lg jv hh lc b fi ll li l lj lk">resolve('Example data')</span><span id="5b64" class="lg jv hh lc b fi ll li l lj lk">}, 2000)</span><span id="ed9a" class="lg jv hh lc b fi ll li l lj lk">})</span></pre><p id="87c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是在创建了一个<code class="du lm ln lo lc b">promise</code>之后，当通过调用承诺上的<code class="du lm ln lo lc b">then</code>来实现或拒绝承诺时，我们必须对数据做些什么。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="651d" class="lg jv hh lc b fi lh li l lj lk">// Using myPromise from above</span><span id="6c83" class="lg jv hh lc b fi ll li l lj lk">myPromise.then((data) =&gt; {</span><span id="6932" class="lg jv hh lc b fi ll li l lj lk">console.log(data) // prints "Example data"</span><span id="1525" class="lg jv hh lc b fi ll li l lj lk">}, (err) =&gt; {</span><span id="1c38" class="lg jv hh lc b fi ll li l lj lk">console.log(err)</span><span id="83a2" class="lg jv hh lc b fi ll li l lj lk">})</span></pre><p id="600e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，我们有基于承诺的<code class="du lm ln lo lc b">fetch</code>，它用于访问任何API，当它返回一个承诺时，从它返回的数据可以被其他承诺访问和进一步处理。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="973e" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">发电机</h1><p id="7217" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">生成器是一种特殊的函数，能够暂停自己，稍后恢复，允许其他代码同时运行。</p><p id="c983" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个函数可以阻止自己运行，并允许回调队列中的其他函数运行或执行。</p><p id="be68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一切都是用一个关键词完成的:<code class="du lm ln lo lc b">yield</code>。当生成器包含该关键字时，执行会暂停。</p><p id="ea69" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个生成器可以包含许多<code class="du lm ln lo lc b">yield</code>关键字，因此可以多次暂停，并且由<code class="du lm ln lo lc b">*function</code>关键字来标识。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="7eb6" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">让和const</h1><p id="31c1" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated"><code class="du lm ln lo lc b">var</code>传统上是<strong class="ir hi">函数作用域</strong>。</p><p id="512c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lm ln lo lc b">let</code>是一个新的变量声明，其作用域是<strong class="ir hi">块</strong>。</p><p id="956a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lm ln lo lc b">const</code>和<code class="du lm ln lo lc b">let</code>一样，但是<strong class="ir hi">是不可变的</strong>。</p><p id="8be0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更详细的解释可以参考我关于var，let，const的文章。</p><div class="lp lq ez fb lr ls"><a rel="noopener follow" target="_blank" href="/@bhavishya2107/javascript-es6-let-const-and-why-you-should-be-using-them-instead-of-var-11da9914c9a4"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hi fi z dy lx ea eb ly ed ef hg bi translated">JavaScript ES6: let &amp; const以及为什么应该使用它们而不是var。</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">ES6指的是ECMA脚本编程语言的版本6。ECMA脚本是JavaScript的标准化名称。</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg in ls"/></div></div></a></div></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="545e" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">模板文字</h1><p id="4efc" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">使用模板文字非常简单，它避免了用“+”号连接字符串或javaScript代码。</p><p id="4090" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用反勾号来初始化模板文字，每当我们想写JS时，我们使用语法${javaScript code}。</p><p id="f467" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这可以通过一个例子来理解，</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="d7aa" class="lg jv hh lc b fi lh li l lj lk">//function with no template literals</span><span id="306a" class="lg jv hh lc b fi ll li l lj lk">const myHobby = () =&gt; {<br/>let name = "Bhavishya"<br/>let hobby = "Travelling"<br/>return name + ' ' + 'loves' + ' ' + hobby<br/>}</span><span id="7704" class="lg jv hh lc b fi ll li l lj lk">myHobby() // "Bhavishya loves travelling"</span></pre><p id="2fc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们看一下模板文字的相同函数，</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="359d" class="lg jv hh lc b fi lh li l lj lk">//function with template literals</span><span id="c50c" class="lg jv hh lc b fi ll li l lj lk">const myHobby = () =&gt; {<br/>let name = "Bhavishya"<br/>let hobby = "Travelling"<br/>return `${name} loves ${hobby}`<br/>}</span><span id="c27b" class="lg jv hh lc b fi ll li l lj lk">myHobby() // "Bhavishya loves travelling"</span></pre></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="eda5" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">默认参数</h1><p id="6eca" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">现在，我们可以为函数中传递的参数分配默认参数。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="941d" class="lg jv hh lc b fi lh li l lj lk">var myfun = (name = 'Bhavishya', age = 24) =&gt; {</span><span id="af99" class="lg jv hh lc b fi ll li l lj lk">console.log(name,age)</span><span id="f434" class="lg jv hh lc b fi ll li l lj lk">}</span><span id="f8d9" class="lg jv hh lc b fi ll li l lj lk">myfun() // Bhavishya 24</span></pre></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="e602" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">数组和对象析构</h1><p id="76dc" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">析构使得将数组和对象赋给其他变量变得更加容易。</p><p id="b0a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">旧语法:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2b93" class="lg jv hh lc b fi lh li l lj lk">const obj = {<br/>name:"Bhavishya",<br/>age:24,<br/>country:"India"<br/>}</span><span id="eee4" class="lg jv hh lc b fi ll li l lj lk">let name = obj.name;<br/>let age = obj.age;<br/>let country = obj.country</span><span id="7fb8" class="lg jv hh lc b fi ll li l lj lk">console.log(name) // "Bhavishya"<br/>console.log(age) // 24<br/>console.log(country) // "India"</span></pre><p id="d404" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用ES6语法:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="e15a" class="lg jv hh lc b fi lh li l lj lk">const obj = {<br/>name:"Bhavishya",<br/>age:24,<br/>country:"India"<br/>}</span><span id="b5ce" class="lg jv hh lc b fi ll li l lj lk">let {name,age,country} = obj</span><span id="f32d" class="lg jv hh lc b fi ll li l lj lk">console.log(name) // "Bhavishya"<br/>console.log(age) // 24<br/>console.log(country) // "India"</span></pre><p id="5e36" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这类似于数组只需用方括号替换花括号。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8659" class="lg jv hh lc b fi lh li l lj lk">const arr = ["Bhavishya",24,"India"];</span><span id="df55" class="lg jv hh lc b fi ll li l lj lk">let [name,age,country] = arr</span><span id="a70b" class="lg jv hh lc b fi ll li l lj lk">console.log(name) // "Bhavishya"<br/>console.log(age) //24<br/>console.log(country) // "India"</span></pre></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="c7ab" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">剩余参数和扩散算子</h1><p id="9408" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">rest参数用于获取数组的参数或在函数中添加其他参数。</p><p id="a7da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的代码，</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8d1a" class="lg jv hh lc b fi lh li l lj lk">function myFun(a, b, ...manyMoreArgs) {</span><span id="f243" class="lg jv hh lc b fi ll li l lj lk">  console.log("a", a); <br/>  console.log("b", b);<br/>  console.log("manyMoreArgs", manyMoreArgs); </span><span id="8235" class="lg jv hh lc b fi ll li l lj lk">}<br/><br/>myFun("one", "two", "three", "four", "five", "six");<br/><br/>// Console Output:<br/>// a, one<br/>// b, two<br/>// manyMoreArgs, [three, four, five, six]</span></pre><p id="08ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，函数<code class="du lm ln lo lc b">myFun</code>控制传递给该函数的参数。<br/> <code class="du lm ln lo lc b">...manyMoreArgs</code>可以传递任意多的参数，并以参数数组的形式返回。</p><p id="b656" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">spread运算符的语法与rest参数相同，但是spread运算符接受数组本身，而不仅仅是参数。我们可以使用Spread参数来获取数组的值。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="d5db" class="lg jv hh lc b fi lh li l lj lk">const arr=['I','am','Bhavishya','Hi','Friends','How are you?'];<br/><br/>const Func=(...array)=&gt;{<br/>  return array;<br/>}<br/><br/>console.log(Func(arr));<br/><br/>//output  ['I','am','Bhavishya','Hi','Friends','How are you?']</span></pre></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="3123" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">班级</h1><p id="ecb9" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">2015年JavaScript引入了类。<br/>类是面向对象编程(OOP)的核心。它们使你的代码安全并被封装。使用类给你的代码一个好的结构，并保持它的组织性。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="4d7c" class="lg jv hh lc b fi lh li l lj lk">//Syntax<br/>class myClass {<br/>  constructor() {<br/>  }<br/>}</span></pre><p id="bc7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类是在类名前用关键字<code class="du lm ln lo lc b">class</code>声明的。</p><p id="99a0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个例子，</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="5609" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用<code class="du lm ln lo lc b">class</code>方法，并用关键字<code class="du lm ln lo lc b">new</code>为该类创建一个新实例。</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4a48" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要从另一个类继承，使用<code class="du lm ln lo lc b">extends</code>关键字，后跟您想要继承的类的名称。</p><figure class="kx ky kz la fd ii"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="911a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">圣母玛利亚，在一篇文章中可以消化这么多新特性。但是等等，ES6还有更多🤣你仍然需要知道更多关于完全杀戮和称呼你自己为ES6杀戮者的信息！！！</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/d2e0d4e436ac7fda56d54c31c0c26371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*O2Veo9nf8EZvK-08xdGYHA.jpeg"/></div></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="121f" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">地图和布景</h1><p id="72ff" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated"><strong class="ir hi"> Map </strong>和<strong class="ir hi"> Set </strong>(以及它们各自的垃圾收集<strong class="ir hi"> WeakMap </strong>和<strong class="ir hi"> WeakSet </strong>)是两种非常流行的数据结构的官方实现。</p><h1 id="a791" class="ju jv hh bd jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr bi translated">新的字符串方法</h1><p id="f12a" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">任何字符串值都有一些新的实例方法:</p><ul class=""><li id="25e4" class="mp mq hh ir b is it iw ix ja mr je ms ji mt jm mu mv mw mx bi translated"><code class="du lm ln lo lc b">repeat()</code>将字符串重复指定的次数:<code class="du lm ln lo lc b">'Ho'.repeat(3) //HoHoHo</code></li></ul><h1 id="68bc" class="ju jv hh bd jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr bi translated">新对象方法</h1><p id="51d1" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">ES6在对象名称空间下引入了几个静态方法:</p><ul class=""><li id="836a" class="mp mq hh ir b is it iw ix ja mr je ms ji mt jm mu mv mw mx bi translated"><code class="du lm ln lo lc b">Object.is()</code>判断两个值是否相同</li><li id="c9d9" class="mp mq hh ir b is my iw mz ja na je nb ji nc jm mu mv mw mx bi translated"><code class="du lm ln lo lc b">Object.assign()</code>用于浅层复制一个对象</li><li id="f7e5" class="mp mq hh ir b is my iw mz ja na je nb ji nc jm mu mv mw mx bi translated"><code class="du lm ln lo lc b">Object.setPrototypeOf</code>设置一个对象原型</li></ul></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="4097" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，就这样了<strong class="ir hi">谢谢各位！！！为了阅读我的文章，请让我知道你是否对我解释的文章或概念有任何疑问，请在底部写下回复。</strong></p><p id="d6b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在twitter上关注我，保持联系，让我知道你感到困难的其他领域，以便我阅读自己，并尝试用我的文章解释它。</p><p id="1494" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae nd" href="https://twitter.com/bhavishya2107" rel="noopener ugc nofollow" target="_blank">https://twitter.com/bhavishya2107</a></p><h1 id="8129" class="ju jv hh bd jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr bi translated">谢谢你！！！</h1><h2 id="533c" class="lg jv hh bd jw ne nf ng ka nh ni nj ke ja nk nl ki je nm nn km ji no np kq nq bi translated">掌声是受欢迎的🤗</h2><blockquote class="nr"><p id="040a" class="ns nt hh bd nu nv nw nx ny nz oa jm dx translated">不断学习，编码😎分享你的知识🤩</p></blockquote><h1 id="9804" class="ju jv hh bd jw jx mk jz ka kb ml kd ke kf ob kh ki kj oc kl km kn od kp kq kr bi translated">参考:</h1><ul class=""><li id="1c2e" class="mp mq hh ir b is ks iw kt ja oe je of ji og jm mu mv mw mx bi translated">Mozilla有非常有用的文档(加上他们的“自己尝试”选项非常适合实验):<br/><a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_2015_support_in_Mozilla" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/New _ in _ JavaScript/ECMAScript _ 2015 _ support _ in _ Mozilla</a></li></ul></div></div>    
</body>
</html>