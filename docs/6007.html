<html>
<head>
<title>Deploy Thanos Receive with native Oracle Cloud Object Storage on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上部署带有原生Oracle云对象存储的灭霸接收</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/deploy-thanos-receive-with-native-oci-object-storage-on-kubernetes-829326ea0bc6?source=collection_archive---------0-----------------------#2022-11-29">https://medium.com/oracledevs/deploy-thanos-receive-with-native-oci-object-storage-on-kubernetes-829326ea0bc6?source=collection_archive---------0-----------------------#2022-11-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/419eb2396075e8e18ffce881e3477165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEjju6gqmZCBGceFMULnsw.jpeg"/></div></div></figure><p id="b430" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" rel="noopener" href="/oracledevs/monitoring-multiple-oke-clusters-with-prometheus-thanos-and-grafana-part-2-77d2f0303ea0">之前的文章</a>中，我们部署了<a class="ae jn" href="https://thanos.io/" rel="noopener ugc nofollow" target="_blank">灭霸</a>作为<a class="ae jn" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>的高可用解决方案和长期存储解决方案。在这个过程中，我们使用sidecar模型将灭霸部署为Prometheus pod中的sidecar容器，以检索指标并将它们写入对象存储。</p><p id="2eb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将探讨两种替代方案:</p><ol class=""><li id="d03f" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">我们将使用灭霸接收模型直接从Prometheus接收指标数据。</li><li id="3852" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">我们还将使用<a class="ae jn" href="https://thanos.io/tip/thanos/storage.md/#oracle-cloud-infrastructure-object-storage" rel="noopener ugc nofollow" target="_blank">新的原生OCI对象存储集成</a>来存储TSDB数据。</li></ol><p id="1994" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个过程中，我们还将强调<a class="ae jn" href="https://github.com/oracle-terraform-modules/terraform-oci-oke" rel="noopener ugc nofollow" target="_blank"> terraform OKE模块</a>中的一个新特性，即使用已定义的标签。</p><p id="572f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们先来看看灭霸的新OCI对象存储是如何工作的。</p><h2 id="3af5" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">灭霸的OCI对象存储</h2><p id="8640" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">经过漫长的酝酿期，我们能够为灭霸项目提供OCI本地集成:</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7dea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这次成功的贡献有两个英雄:</p><ul class=""><li id="7524" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm li ju jv jw bi translated">Aaron Tam编写了大部分(如果不是全部)集成。</li><li id="b5aa" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">阿维·米勒。你知道你做了什么，我们很感激。</li></ul><p id="8154" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我敢肯定，你想知道为什么你应该使用原生集成时，S3接口工作得足够好。当配置灭霸的S3集成和OCI对象存储时，您基本上需要在对象存储配置中指定访问和密钥:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="9370" class="lo kd hh lk b be lp lq l lr ls">type: S3<br/>config:<br/>  bucket: "&lt;bucket_name&gt;"<br/>  endpoint: "&lt;object_storage_namespace&gt;.compat.objectstorage.&lt;region&gt;.oraclecloud.com"<br/>  region: "&lt;region&gt;"<br/>  aws_sdk_auth: false<br/>  access_key: "access_key"<br/>  insecure: false<br/>  signature_version2: false<br/>  secret_key: "secret_key"</span></pre><p id="d5c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，随着新的灭霸OCI集成，您有不同的身份验证选项。第一个也是最明显的一个是使用“原始”提供程序，您可以在其中指定密钥:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="0992" class="lo kd hh lk b be lp lq l lr ls">type: OCI<br/>config:<br/>  provider: "raw"<br/>  bucket: ""<br/>  compartment_ocid: ""<br/>  tenancy_ocid: ""<br/>  user_ocid: ""<br/>  region: ""<br/>  fingerprint: ""<br/>  privatekey: ""<br/>  passphrase: ""</span></pre><p id="959c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">今天，您必须直接指定它们。但是我们可以想象，在后续的改进版本中，这里指定的用于认证的参数可以改为来自秘密。所述秘密可以被加密存储在OCI保险库中，并且通过外部秘密操作器而不是来检索<a class="ae jn" rel="noopener" href="/oracledevs/using-the-external-secrets-operator-with-oci-kubernetes-and-oci-vault-6865f2e1fe35">。当这快乐的一天最终到来时，你可以轮换你的私人钥匙和指纹等。</a></p><p id="75fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">新OCI集成中的第二个也是更安全的选项是使用OCI <em class="lt"> instance_principal </em>。</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="4339" class="lo kd hh lk b be lp lq l lr ls">type: OCI<br/>config:<br/>  provider: "instance-principal"<br/>  bucket: "thanos"<br/>  compartment_ocid: "ocid1.compartment.oc1..a"</span></pre><p id="2f0e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">实例主体的工作前提是，因为您(或您的应用程序)将从一个计算实例进行一些API调用，所以您可以授权这个计算实例进行这些调用。通过这种方式，您不需要将您的密钥隐藏在秘密或文件中，也不需要使用这种原始的方法。要使用实例主体方法，您需要做两件事:</p><ol class=""><li id="137a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">创建一个动态组，以便计算实例成为其成员。</li><li id="80f7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">创建策略，为动态组提供必要的权限，以便与所需的任何OCI服务进行交互(以及在哪个级别)。</li></ol><p id="9790" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有几种方法可以指定此动态组成员资格:</p><ul class=""><li id="eef2" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm li ju jv jw bi translated">使用实例OCID，例如instance . id = ' ocid 1 . instance . oc1…'</li><li id="8aca" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">使用实例的隔离专区OCID，例如instance . compartment . id = ' ocid 1 . instance . oc1…'</li><li id="ce94" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">使用已定义的标签:标签。<tagnamespace>。<tagkey>。value = '【T2]'</tagkey></tagnamespace></li></ul><p id="64f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想进行测试，或者如果您的集群很小，但确实不可伸缩，您可以使用上面的第一个选项。第二个选项太宽泛，会使隔离专区中任何区域的任何实例成为这个动态组的成员，甚至是那些不属于您的集群的实例。您可以在开发人员环境中使用它——在那里您想要测试，并且您已经专门为您的开发环境创建了一个区间。</p><p id="f33e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当你排除那些不太好的选项时，剩下的，无论多么复杂，都将是你选择的解决方案。因此，使用已定义的标签是推荐的方法。在OKE设置中，只要您的worker节点具有必要的已定义标记，它们就会成为这个动态组的成员。我们稍后会更详细地讨论这个问题，但是现在请耐心听我说。</p><p id="0d3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦定义了组成员，我们就需要授予这个动态组对对象存储的访问权。您可以通过使用以下语句创建策略来实现这一点:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="f553" class="lo kd hh lk b be lp lq l lr ls">Allow dynamic-group thanos to manage buckets in compartment id ocid1.compartment.oc1..a<br/>Allow dynamic-group thanos to manage objects in compartment id ocid1.compartment.oc1..a</span></pre><p id="ad70" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，工作节点有足够的权限与OCI对象存储进行交互。但是我们不希望<em class="lt">所有的</em>工作者节点都成为这个动态组的一部分并拥有访问权。那么，我们如何施加这种限制，以便只有某些节点可以成功运行灭霸？让我们绕个小圈子，深入了解OKE节点池。</p><h2 id="86f6" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">OKE模块、节点池和定义的标记</h2><p id="e0f2" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">创建OKE (Kubernetes)集群时，可以使用节点池对工作节点进行分组和管理。节点池本质上是一组计算实例，它们与集群的工作节点具有相同的配置和功能。节点池中的计算实例具有相同的以下(但不限于)属性:</p><ul class=""><li id="694a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm li ju jv jw bi translated">Kubernetes版本</li><li id="dcca" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">用于设置工作节点的图像</li><li id="866c" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">计算形状，例如分配的OCPUs、内存和块卷的数量，以及是使用虚拟机还是裸机</li><li id="48f5" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">CPU架构，例如英特尔、AMD、ARM、GPU</li><li id="b729" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">节点标签</li><li id="5c02" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">自由形式和定义的标签</li></ul><p id="8a2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在OKE群集中，您可以有许多节点池，每个节点池都有自己的属性和大小，例如，下图显示了3个不同形状和大小的节点池，以满足混合性能工作负载要求:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/767916b05c7583b542cef8c3730ccbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1y93sVFtBfRWBAdhmlDC5A.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Multiple node pools with different shapes and sizes</figcaption></figure><p id="c6bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，您可以拥有混合体系结构的节点池，所有节点池都在同一个群集中:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/ae1ba1910df3c0fb0095eed29545df0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VA_Pw-sEUwCxgJR496YSGg.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Multiple node pools with different CPU architectures</figcaption></figure><p id="a249" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用标签，您可以<a class="ae jn" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-your-chosen-node" rel="noopener ugc nofollow" target="_blank">确保运行特定应用程序的特定pod位于最适合它们或最符合您需求的特定工作节点</a>。</p><p id="8ee6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将这两者结合起来，您可以实现专用的节点池，您可以通过<a class="ae jn" href="https://github.com/oracle-terraform-modules/terraform-oci-oke/blob/main/docs/cloudinit.adoc#specifying-a-cloud-init-script-for-specific-node-pools" rel="noopener ugc nofollow" target="_blank">特定于节点池的云初始化</a>对其进行进一步调优，例如:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/b763e974fcdc83f7c704bfed138fc2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09PGoLZ_1FSJc1mrBO3sxg.png"/></div></div></figure><p id="dd3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这种方式，您可以调整集群的规模，并限制使用昂贵的资源，如GPU节点或裸机(如果需要)。</p><p id="a8d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的用例中，我们希望进一步限制灭霸pod仅在特定节点池的工作节点上运行。为此，我们为节点池配置了已定义的标记。有了定义的标记，我们现在可以创建一个动态组，它具有对对象存储的实例主体访问权。</p><h2 id="9e81" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">理论够了，给我看看真正的东西</h2><p id="d688" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">让我们从创建已定义的标签开始。我们将在这里使用OCI控制台，但您也可以使用Terraform、CLI等来创建您的标签。在OCI控制台中搜索标记名称空间并创建一个:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/6a087271dd577782150fe6c1d156ff9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4gReHYjSjiYEwsoU0xwFg.png"/></div></div></figure><p id="2d2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在这里使用的是“cn”(cloud native的缩写)。单击标签并创建标签关键字定义:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/5f53cac928559187b4c99920d65b70b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfiJgVUYD2btuVQ7Laixwg.png"/></div></div></figure><p id="22b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用一个静态值，也可以进一步将其限制为一个特定的值列表。在这种情况下，我将使用标记键“role ”,它有一个静态值:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/7ba7304450c1938c3222ab0c9150ba80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud6CKb5l3d8BZCF6Hv_RdQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">tag keys</figcaption></figure><p id="1c92" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，在对象存储中创建一个名为“thanos”的桶，用于存储TSDB块。</p><h2 id="eada" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">创建OKE集群</h2><p id="0294" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">接下来，使用<a class="ae jn" href="https://github.com/oracle-terraform-modules/terraform-oci-oke" rel="noopener ugc nofollow" target="_blank"> Terraform oke模块</a>，使用变量输入文件terra form . TF vars(<a class="ae jn" href="https://github.com/oracle-terraform-modules/terraform-oci-oke/blob/main/terraform.tfvars.example" rel="noopener ugc nofollow" target="_blank">sample here</a>)创建几个节点池:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="b5ca" class="lo kd hh lk b be lp lq l lr ls">allow_worker_ssh_access      = true<br/>node_pools = {<br/>  np1 = {<br/>    shape                  = "VM.Standard.E4.Flex",<br/>    ocpus                  = 2,<br/>    memory                 = 32,<br/>    autoscale              = true,<br/>    node_pool_size         = 1,<br/>    max_node_pool_size     = 3,<br/>    boot_volume_size       = 150,<br/>    label                  = { app = "prometheus", pool = "np1" },<br/>    node_defined_tags      = { "cn.role" = "prometheus" }<br/>  }<br/>  np2 = {<br/>    shape                  = "VM.Standard.E4.Flex",<br/>    ocpus                  = 2,<br/>    memory                 = 32,<br/>    autoscale              = true,<br/>    node_pool_size         = 1,<br/>    max_node_pool_size     = 3,<br/>    boot_volume_size       = 150,<br/>    label                  = { app = "thanos", pool="np2"},<br/>    node_defined_tags      = { "cn.role" = "thanos" }<br/>  }<br/>}</span></pre><p id="a620" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还要将“allow_worker_ssh_access”设置为<em class="lt"> true </em>，这样我们可以稍后测试实例主体。运行Terraform apply创建集群和节点池。您可以稍后禁用此功能。</p><p id="6f9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从基础架构的角度来看，这是我们想要实现的目标:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/58b022b6556b582936dd8547eba6dc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zJ6DdK2Ffj-kAr34Jn1Aw.png"/></div></div></figure><p id="3a9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">普罗米修斯舱将在节点池1的工作节点上运行，灭霸舱将在节点池2的工作节点上运行。</p><p id="4296" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从功能角度来看，这就是我们想要实现的目标(在本文中，我们将跳过Nginx入口控制器和应用程序单元):</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/11d45555e95bd616b6cf1f1e02a423d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsM8FfjRe2Nyc9QHGFaUtA.png"/></div></div></figure><p id="dcea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望Prometheus使用它的<a class="ae jn" href="https://prometheus.io/docs/practices/remote_write/#remote-write-characteristics" rel="noopener ugc nofollow" target="_blank">远程写特性</a>将收集到的指标发送给灭霸接收器，后者再将其写入OCI对象存储。</p><p id="f672" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用OCI控制台检查节点池1中工作节点的Kubernetes标签:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/f86301765cc1251b5d2aab75d09d635d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7Y1o1pudSDZsQ0qpquGAg.png"/></div></div></figure><p id="fc38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在节点池2中:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/f50d256e8264798450bf41acf794fb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ze0bG-57BFRKyCRjqWr-eg.png"/></div></div></figure><h2 id="63ed" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">创建动态组和策略来访问对象存储</h2><p id="dd4d" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">创建动态组并设置以下规则:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="b092" class="lo kd hh lk b be lp lq l lr ls">tag.cn.role.value='thanos'</span></pre><p id="33a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/3e58c6a5752dabc991a11cc14415bceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aW_KI8UobuA8Y4JF-i_o5Q.png"/></div></div></figure><p id="5f3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，创建一个策略，授予动态组对对象存储的访问权限。该策略需要以下两个语句:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="b8dc" class="lo kd hh lk b be lp lq l lr ls">Allow dynamic-group thanos to manage buckets in compartment id ocid1.compartment.oc1..a<br/>Allow dynamic-group thanos to manage objects in compartment id ocid1.compartment.oc1..a</span></pre><p id="364a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对np2中的工作节点使用云shell或ssh，并安装OCI cli，以便可以测试实例主体:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="bb8e" class="lo kd hh lk b be lp lq l lr ls">sudo dnf install -y oracle-olcne-release-el8<br/>sudo dnf config-manager --disable ol8_olcne13<br/>sudo dnf config-manager --disable ol8_olcne14<br/>sudo dnf config-manager --enable ol8_olcne15<br/>sudo dnf install -y python3-oci-cli</span></pre><p id="2069" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将身份验证方法设置为instance_principal，并测试对对象存储的访问:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="a07d" class="lo kd hh lk b be lp lq l lr ls">export OCI_CLI_AUTH=instance_principal<br/>oci os bucket list --compartment-id ocid1.compartment.oc1..a --namespace-name &lt;object storage namespace&gt;</span></pre><p id="10cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在OCI控制台的租赁页面中找到对象存储命名空间。您应该会看到如下所示的内容:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="4545" class="lo kd hh lk b be lp lq l lr ls">{<br/>  "data": [<br/>    {<br/>      "compartment-id": "ocid1.compartment.oc1..aa",<br/>      "created-by": "",<br/>      "defined-tags": null,<br/>      "etag": "",<br/>      "freeform-tags": null,<br/>      "name": "thanos",<br/>      "namespace": "",<br/>      "time-created": ""<br/>    }<br/>  ]<br/>}</span></pre><p id="83ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您可以检索该存储桶，那么instance_principal正在节点池上工作，我们可以继续进行灭霸配置。如果您愿意，可以跳过这个测试，因为它的目的是说明实例主体。</p><h2 id="c3cf" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">部署灭霸</h2><p id="2cdd" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">登录到操作员主机或使用云外壳并创建一个命名空间:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="668f" class="lo kd hh lk b be lp lq l lr ls">kubectl create namespace monitoring</span></pre><p id="d92c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个名为storage.yaml的文件，并相应地填写隔离专区id值:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="4ea9" class="lo kd hh lk b be lp lq l lr ls">type: OCI<br/>config:<br/>  provider: "instance-principal"<br/>  bucket: "thanos"<br/>  compartment_ocid: "ocid1.compartment.oc1.."</span></pre><p id="ce75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，这是最低配置。您可以进一步配置其他参数。请参考<a class="ae jn" href="https://thanos.io/tip/thanos/storage.md/#oracle-cloud-infrastructure-object-storage" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="51f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，从中创造一个秘密:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="67a6" class="lo kd hh lk b be lp lq l lr ls">kubectl -n monitoring create secret generic thanos-objstore-config --from-file=objstore.yml=storage.yaml</span></pre><p id="96d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">添加比特纳米灭霸掌舵图表回购:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="7ebf" class="lo kd hh lk b be lp lq l lr ls">helm repo add bitnami https://charts.bitnami.com/bitnami</span></pre><p id="2403" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生成值清单文件:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="7872" class="lo kd hh lk b be lp lq l lr ls">helm show values bitnami/thanos &gt; thanos.yaml</span></pre><p id="9912" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑thanos.yaml文件并设置以下内容:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="126e" class="lo kd hh lk b be lp lq l lr ls">image<br/>  tag: 0.29.0<br/>existingObjstoreSecret: "thanos-objstore-config"    <br/>queryFrontend:<br/>  enabled: true<br/>bucketweb:<br/>  enabled: true<br/>compactor:<br/>  enabled: true<br/>storegateway:<br/>  enabled: true<br/>receive:<br/>  enabled: true</span></pre><p id="8c4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，我们还希望将灭霸pod限制到节点池2中的工作节点。为此，在thanos.yaml中查找所有的节点选择器，并按如下方式设置:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="6191" class="lo kd hh lk b be lp lq l lr ls">  nodeSelector:<br/>    app: thanos</span></pre><p id="185d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">nodeSelector将确保灭霸pods位于标签为<em class="lt"> app = "thanos" </em>的工作节点上，在本例中，工作节点位于节点池2中。这确保了灭霸pod可以使用实例主体方法来访问OCI对象存储。你问这个<em class="lt"> app = "thanos" </em>从哪里来？创建节点池时，我们将其设置为标签:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="5823" class="lo kd hh lk b be lp lq l lr ls">np2 = {<br/>    shape                  = "VM.Standard.E4.Flex",<br/>    ocpus                  = 2,<br/>    memory                 = 32,<br/>    autoscale              = true,<br/>    node_pool_size         = 1,<br/>    max_node_pool_size     = 3,<br/>    boot_volume_size       = 150,<br/>    label                  = { app = "thanos", pool="np2"},<br/>    node_defined_tags      = { "cn.role" = "thanos" }<br/>  }</span></pre><p id="7c23" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以部署灭霸:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="0508" class="lo kd hh lk b be lp lq l lr ls">helm install thanos bitnami/thanos --namespace monitoring -f thanos.yaml</span></pre><p id="6bf1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用标签查找thanos的节点池:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="b520" class="lo kd hh lk b be lp lq l lr ls">k get nodes --show-labels | grep app=thanos<br/>10.0.99.78     Ready    node    44m   v1.23.4   app=thanos,beta.kubernetes.io/arch=amd64,beta.kubernetes.io/instance-type=VM.Standard.E4.Flex,beta.kubernetes.io/os=linux</span></pre><p id="634c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们验证灭霸吊舱是否降落在正确的工作节点上:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="bd53" class="lo kd hh lk b be lp lq l lr ls">kubectl -n monitoring describe pod thanos-query-69854d896d-lrlzh<br/>Name:         thanos-query-69854d896d-lrlzh<br/>Namespace:    monitoring<br/>Priority:     0<br/>Node:         10.0.99.78/10.0.99.78</span></pre><p id="c663" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，检查豆荚。它们都应该已经成功启动:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="43a4" class="lo kd hh lk b be lp lq l lr ls">kubectl -n monitoring get pods<br/>NAME                                     READY   STATUS    RESTARTS   AGE<br/>thanos-bucketweb-846685d5df-wzgfs        1/1     Running   0          84s<br/>thanos-compactor-85c7cbf4c6-zslwb        1/1     Running   0          84s<br/>thanos-query-69854d896d-lrlzh            1/1     Running   0          84s<br/>thanos-query-frontend-86699dcbfb-pczxr   1/1     Running   0          84s<br/>thanos-receive-0                         1/1     Running   0          84s<br/>thanos-storegateway-0                    1/1     Running   0          84s</span></pre><p id="f10c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您希望更有选择性，真正需要实例主体访问的三个单元是那些将与对象存储交互的单元:</p><ul class=""><li id="46a4" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm li ju jv jw bi translated">压土机</li><li id="82bb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">接收</li><li id="8118" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">商店网关</li></ul><h2 id="f696" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">部署普罗米修斯</h2><p id="639f" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">我们将使用kube-prometheus-stack部署prometheus:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="d824" class="lo kd hh lk b be lp lq l lr ls">helm repo add kps https://prometheus-community.github.io/helm-charts</span></pre><p id="da43" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生成值清单文件:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="835d" class="lo kd hh lk b be lp lq l lr ls">helm show values kps/kube-prometheus-stack &gt; kps.yaml</span></pre><p id="35cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑kps.yaml文件并设置以下内容:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="a76d" class="lo kd hh lk b be lp lq l lr ls">prometheus<br/>  prometheusSpec<br/>    serviceMonitorSelectorNilUsesHelmValues: false<br/>    podMonitorSelectorNilUsesHelmValues: false<br/>    remoteWrite:<br/>     - url: http://thanos-receive.monitoring.svc.cluster.local:19291/api/v1/receive</span></pre><p id="d043" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们对灭霸所做的那样，找到节点选择器并进行设置，以确保Prometheus pods使用我们为节点池1指定的相同标签(app = "prometheus ")放置在节点池1中的工作节点上:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="afc8" class="lo kd hh lk b be lp lq l lr ls">    nodeSelector:<br/>      app: prometheus</span></pre><p id="abd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以部署普罗米修斯:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="dc0f" class="lo kd hh lk b be lp lq l lr ls">helm install prometheus kps/kube-prometheus-stack --namespace monitoring -f kps.yaml</span></pre><p id="0d81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">验证pod正在运行:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="eeb1" class="lo kd hh lk b be lp lq l lr ls">kubectl -n monitoring get pods<br/><br/>NAME                                                     READY   STATUS    RESTARTS       AGE<br/>alertmanager-prometheus-kube-prometheus-alertmanager-0   2/2     Running   1 (107s ago)   2m8s<br/>prometheus-grafana-66b6bf7789-249vn                      3/3     Running   0              2m22s<br/>prometheus-kube-prometheus-operator-549866c8dd-dbd88     1/1     Running   0              2m22s<br/>prometheus-kube-state-metrics-7944d98645-4q77n           1/1     Running   0              2m22s<br/>prometheus-prometheus-kube-prometheus-prometheus-0       2/2     Running   0              2m8s<br/>prometheus-prometheus-node-exporter-4jms5                1/1     Running   0              2m21s<br/>prometheus-prometheus-node-exporter-svbs4                1/1     Running   0              2m22s<br/>thanos-bucketweb-846685d5df-wzgfs                        1/1     Running   0              16m<br/>thanos-compactor-85c7cbf4c6-zslwb                        1/1     Running   0              16m<br/>thanos-query-69854d896d-lrlzh                            1/1     Running   0              16m<br/>thanos-query-frontend-86699dcbfb-pczxr                   1/1     Running   0              16m<br/>thanos-receive-0                                         1/1     Running   0              16m<br/>thanos-storegateway-0                                    1/1     Running   0              16m</span></pre><p id="7c2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看普罗米修斯的日志:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="ac62" class="lo kd hh lk b be lp lq l lr ls">kubectl -n monitoring logs -f prometheus-prometheus-kube-prometheus-prometheus-0<br/>ts=2022-11-29T12:07:30.244Z caller=main.go:543 level=info msg="Starting Prometheus Server" mode=server version="(version=2.39.1, branch=HEAD, revision=dcd6af9e0d56165c6f5c64ebbc1fae798d24933a)"<br/>ts=2022-11-29T12:07:30.244Z caller=main.go:548 level=info build_context="(go=go1.19.2, user=root@273d60c69592, date=20221007-15:57:09)"<br/>ts=2022-11-29T12:07:30.244Z caller=main.go:549 level=info host_details="(Linux 5.4.17-2136.310.7.1.el8uek.x86_64 #2 SMP Wed Aug 17 15:14:08 PDT 2022 x86_64 prometheus-prometheus-kube-prometheus-prometheus-0 (none))"<br/>ts=2022-11-29T12:07:30.244Z caller=main.go:550 level=info fd_limits="(soft=1048576, hard=1048576)"<br/>ts=2022-11-29T12:07:30.244Z caller=main.go:551 level=info vm_limits="(soft=unlimited, hard=unlimited)"<br/>ts=2022-11-29T12:07:30.246Z caller=web.go:559 level=info component=web msg="Start listening for connections" address=0.0.0.0:9090<br/>ts=2022-11-29T12:07:30.247Z caller=main.go:980 level=info msg="Starting TSDB ..."<br/>ts=2022-11-29T12:07:30.248Z caller=tls_config.go:231 level=info component=web msg="TLS is disabled." http2=false<br/>ts=2022-11-29T12:07:30.252Z caller=head.go:551 level=info component=tsdb msg="Replaying on-disk memory mappable chunks if any"<br/>ts=2022-11-29T12:07:30.252Z caller=head.go:595 level=info component=tsdb msg="On-disk memory mappable chunks replay completed" duration=2.955µs<br/>ts=2022-11-29T12:07:30.252Z caller=head.go:601 level=info component=tsdb msg="Replaying WAL, this may take a while"<br/>ts=2022-11-29T12:07:30.252Z caller=head.go:672 level=info component=tsdb msg="WAL segment loaded" segment=0 maxSegment=0<br/>ts=2022-11-29T12:07:30.252Z caller=head.go:709 level=info component=tsdb msg="WAL replay completed" checkpoint_replay_duration=24.287µs wal_replay_duration=264.923µs wbl_replay_duration=161ns total_replay_duration=316.331µs<br/>ts=2022-11-29T12:07:30.253Z caller=main.go:1001 level=info fs_type=XFS_SUPER_MAGIC<br/>ts=2022-11-29T12:07:30.253Z caller=main.go:1004 level=info msg="TSDB started"<br/>ts=2022-11-29T12:07:30.253Z caller=main.go:1184 level=info msg="Loading configuration file" filename=/etc/prometheus/config_out/prometheus.env.yaml<br/>ts=2022-11-29T12:07:30.261Z caller=dedupe.go:112 component=remote level=info remote_name=c6fe10 url=http://thanos-receive.monitoring.svc.cluster.local:19291/api/v1/receive msg="Starting WAL watcher" queue=c6fe10<br/>ts=2022-11-29T12:07:30.261Z caller=dedupe.go:112 component=remote level=info remote_name=c6fe10 url=http://thanos-receive.monitoring.svc.cluster.local:19291/api/v1/receive msg="Starting scraped metadata watcher"<br/>ts=2022-11-29T12:07:30.261Z caller=dedupe.go:112 component=remote level=info remote_name=c6fe10 url=http://thanos-receive.monitoring.svc.cluster.local:19291/api/v1/receive msg="Replaying WAL" queue=c6fe10<br/>ts=2022-11-29T12:07:30.261Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.261Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.262Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.262Z caller=kubernetes.go:326 level=info component="discovery manager notify" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.357Z caller=main.go:1221 level=info msg="Completed loading of configuration file" filename=/etc/prometheus/config_out/prometheus.env.yaml totalDuration=103.821285ms db_storage=1.363µs remote_storage=824.336µs web_handler=500ns query_engine=841ns scrape=325.239µs scrape_sd=1.202864ms notify=18.124µs notify_sd=425.578µs rules=94.403577ms tracing=6.311µs<br/>ts=2022-11-29T12:07:30.357Z caller=main.go:965 level=info msg="Server is ready to receive web requests."<br/>ts=2022-11-29T12:07:30.357Z caller=manager.go:943 level=info component="rule manager" msg="Starting rule manager..."<br/>ts=2022-11-29T12:07:30.387Z caller=main.go:1184 level=info msg="Loading configuration file" filename=/etc/prometheus/config_out/prometheus.env.yaml<br/>ts=2022-11-29T12:07:30.391Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.391Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.392Z caller=kubernetes.go:326 level=info component="discovery manager scrape" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.392Z caller=kubernetes.go:326 level=info component="discovery manager notify" discovery=kubernetes msg="Using pod service account via in-cluster config"<br/>ts=2022-11-29T12:07:30.471Z caller=main.go:1221 level=info msg="Completed loading of configuration file" filename=/etc/prometheus/config_out/prometheus.env.yaml totalDuration=84.211257ms db_storage=1.412µs remote_storage=78.379µs web_handler=300ns query_engine=942ns scrape=88.718µs scrape_sd=892.646µs notify=11.611µs notify_sd=229.146µs rules=78.660912ms tracing=6.243µs<br/>ts=2022-11-29T12:07:36.032Z caller=dedupe.go:112 component=remote level=info remote_name=c6fe10 url=http://thanos-receive.monitoring.svc.cluster.local:19291/api/v1/receive msg="Done replaying WAL" duration=5.771154497s</span></pre><p id="6c6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到普罗米修斯能够到达灭霸接收站。让我们几个小时后回来，当普罗米修斯开始发送TSDB块到灭霸接收:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="417c" class="lo kd hh lk b be lp lq l lr ls">ts=2022-11-29T15:07:34.926Z caller=compact.go:519 level=info component=tsdb msg="write block" mint=1669723651686 maxt=1669730400000 ulid=01GK1YVNABQ27EXKYSPZ7PAW7Q duration=323.274ms<br/>ts=2022-11-29T15:07:34.944Z caller=head.go:1192 level=info component=tsdb msg="Head GC completed" caller=truncateMemory duration=16.760054ms<br/>ts=2022-11-29T17:00:01.420Z caller=compact.go:519 level=info component=tsdb msg="write block" mint=1669730400427 maxt=1669737600000 ulid=01GK259HMD5R7ZYXNAN5Q2HT9B duration=382.941853ms<br/>ts=2022-11-29T17:00:01.439Z caller=head.go:1192 level=info component=tsdb msg="Head GC completed" caller=truncateMemory duration=18.006233ms<br/>ts=2022-11-29T19:00:01.443Z caller=compact.go:519 level=info component=tsdb msg="write block" mint=1669737600427 maxt=1669744800000 ulid=01GK2C58WCJBJD33MW1MSHBM4X duration=406.65534ms<br/>ts=2022-11-29T19:00:01.458Z caller=head.go:1192 level=info component=tsdb msg="Head GC completed" caller=truncateMemory duration=13.797336ms</span></pre><p id="b688" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在灭霸接收日志中，我们可以看到它将TSDB数据块上传到OCI对象存储:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="536d" class="lo kd hh lk b be lp lq l lr ls">level=info ts=2022-11-29T15:07:35.634586334Z caller=compact.go:519 component=receive component=multi-tsdb tenant=default-tenant msg="write block" mint=1669723651686 maxt=1669730400000 ulid=01GK1YVNY44QT5JNJM8SS4RWV1 duration=398.359924ms<br/>level=info ts=2022-11-29T15:07:35.656935812Z caller=head.go:1192 component=receive component=multi-tsdb tenant=default-tenant msg="Head GC completed" caller=truncateMemory duration=20.755986ms<br/>level=info ts=2022-11-29T15:07:52.64378284Z caller=shipper.go:334 component=receive component=multi-tsdb tenant=default-tenant msg="upload new block" id=01GK1YVNY44QT5JNJM8SS4RWV1<br/>level=info ts=2022-11-29T17:00:01.477942982Z caller=compact.go:519 component=receive component=multi-tsdb tenant=default-tenant msg="write block" mint=1669730400427 maxt=1669737600000 ulid=01GK259HKJBTJET2W57PG7CNDH duration=467.532064ms<br/>level=info ts=2022-11-29T17:00:01.501835652Z caller=head.go:1192 component=receive component=multi-tsdb tenant=default-tenant msg="Head GC completed" caller=truncateMemory duration=22.437929ms<br/>level=info ts=2022-11-29T17:00:22.584036806Z caller=shipper.go:334 component=receive component=multi-tsdb tenant=default-tenant msg="upload new block" id=01GK259HKJBTJET2W57PG7CNDH<br/>level=info ts=2022-11-29T19:00:01.523908074Z caller=compact.go:519 component=receive component=multi-tsdb tenant=default-tenant msg="write block" mint=1669737600427 maxt=1669744800000 ulid=01GK2C58W441B8RY8HTKNYT9DJ duration=495.405003ms<br/>level=info ts=2022-11-29T19:00:01.540641622Z caller=head.go:1192 component=receive component=multi-tsdb tenant=default-tenant msg="Head GC completed" caller=truncateMemory duration=14.962991ms<br/>level=info ts=2022-11-29T19:00:22.500773034Z caller=shipper.go:334 component=receive component=multi-tsdb tenant=default-tenant msg="upload new block" id=01GK2C58W441B8RY8HTKNYT9DJ</span></pre><p id="ba20" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，验证TSDB数据块是否已写入:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/e25d17441a41dc77c3b294344b1acab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llyMsMQMQWmcJzTK0ky_xA.png"/></div></div></figure><p id="7f59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这显示了灭霸接收和OCI对象存储之间使用新的OCI对象存储集成功能的成功集成。</p><h2 id="2fe8" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">使用Grafana访问</h2><p id="d64f" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">我们现在可以访问Grafana，查看我们的集群的运行情况。默认情况下，预装kube-prometheus-stack的Grafana将被配置为使用prometheus作为其默认数据源。由于灭霸查询使用了一个Prometheus兼容的API，我们只需要添加一个Prometheus类型的新数据源，并将其指向灭霸查询前端服务URL:</p><pre class="lc ld le lf fd lj lk ll bn lm ln bi"><span id="c3d2" class="lo kd hh lk b be lp lq l lr ls">http://thanos-query-frontend.monitoring:9090/</span></pre><p id="4c10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">确保灭霸数据源设置为默认数据源:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/9270205ef79349f6c77d942084d90518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNG1byDKvDKXYhpjHAILnA.png"/></div></div></figure><p id="c7b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">保存并测试以确保数据源正常工作。您现在可以查看预先构建的仪表板:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/a2f90e8c7ad2f3bc6b7220da70fa3272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqblwqiSyjfOR-Ia84Rxnw.png"/></div></div></figure><h2 id="b2d1" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">推荐</h2><ol class=""><li id="aad5" class="jo jp hh ir b is kx iw ky ja mk je ml ji mm jm jt ju jv jw bi translated">不要混淆标签和标记。Kubernetes使用标签来将pod分配给某些节点，而OCI使用标签来确定计算节点的动态组成员资格(是否)。</li><li id="c902" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">当通过策略向动态组分配权限时，请始终使用最小权限原则。在这种情况下，它将确保每个组件都有最低限度的安全权限去做它们应该做的事情，仅此而已。</li><li id="00a7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">灭霸附带了一些组件(sidecar、receive、Storegateway、Query、Query Frontend等)，可以部署在一些架构中(Sidecar、Receive)。当与基础架构/云相结合时，可以提供更多的部署选项。因此，请花时间了解每个组件的用途，以及如何最好地使用它们来确定最适合您的体系结构。不要随随便便地相信已经出版的东西。</li></ol><h2 id="cc02" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">摘要</h2><p id="5119" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在本文中，我们向您展示了三件主要的事情:</p><ol class=""><li id="f27f" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">如何使用新的OCI对象存储与灭霸集成，这两种身份验证方法来配置它们。</li><li id="a43d" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">如何配置和使用Prometheus远程写入将TSDB块发送到灭霸接收器，以及如何在带有OCI对象存储的OKE上使用它们。</li><li id="64fc" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">如何使用新定义的标记功能创建专门的节点池，如果您需要对工作节点上的某些OCI服务进行身份验证访问，如何使用实例主体功能来配置更受限制和更安全的访问。</li></ol><p id="3e91" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以上三者的结合开启了一个全新的监控机会领域:</p><ul class=""><li id="3297" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm li ju jv jw bi translated">现在，您可以拥有一个更加灵活的架构，可以同时监控在OCI不同地区运行的多个Kubernetes集群，或者从一个位置监控其他云提供商的集群。</li><li id="4b1a" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">您还可以监控私有数据中心中现有的Kubernetes集群，而无需在防火墙上打孔。相反，你可以让普罗米修斯直接将度量数据发送到灭霸接收器，该接收器可以在OCI本地或远程运行。</li><li id="85cd" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm li ju jv jw bi translated">您可以使用Prometheus监控任何类型的系统，而不需要整个Kubernetes集群。你所需要做的就是告诉普罗米修斯你的接收器在哪里运行，以及如何传送你的数据。想象一下运行在低功耗、低计算、低内存和低存储边缘的系统。您现在可以监控它们，并以更低的成本将它们的长期指标存储在OCI对象存储中。</li></ul><p id="58cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在以后的文章中，我们将探索其中的一些场景。同时，您还可以阅读Medallia(他也使用OCI)使用灭霸来监控40个数据中心的Kubernetes集群:</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="761a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我想借此机会再次感谢我的同事Aaron和Avi，感谢他们努力使OCI对象存储公司成为灭霸存储公司的一等公民。</p></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><p id="e3db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你对Oracle开发人员在他们的自然环境中发生的事情感到好奇，请加入我们的公共休闲频道！我们不介意成为你的鱼缸🐠</p></div></div>    
</body>
</html>