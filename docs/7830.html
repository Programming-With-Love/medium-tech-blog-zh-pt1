<html>
<head>
<title>Demystifying Functional Programming (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开函数式编程的神秘面纱(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/demystifying-functional-programming-part-1-eb4347d145d0?source=collection_archive---------5-----------------------#2019-12-13">https://medium.com/walmartglobaltech/demystifying-functional-programming-part-1-eb4347d145d0?source=collection_archive---------5-----------------------#2019-12-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/70d6de4850f9855226bcfce4174f5122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dxVgGDM76KHXiIKb"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image Credit: <a class="ae it" href="https://www.tes.com/lessons/oyJgbl4VmcFTag/function-notation" rel="noopener ugc nofollow" target="_blank">https://www.tes.com/lessons/oyJgbl4VmcFTag/function-notation</a></figcaption></figure><p id="7ada" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">函数式编程(FP)是一种只使用纯函数和不可变值编写软件应用程序的方法。或者说FP 是一种面向数学的方式来编写代码。<em class="js">那么，我说的纯函数是什么意思？</em></p><p id="7346" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">f(x)=&gt;x+1；</em>这是一个纯粹的函数，因为它将对相同的输入产生相同的输出，提供的次数与评估的次数一样多！</p><p id="7e7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个纯函数不会改变状态或者改变“外部世界”——函数范围之外的世界。</p><p id="8a26" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它不能依赖于任何隐藏状态或全局变量。函数的求值不应该引起任何副作用，比如可变对象的突变或者输出到I/O设备或者<em class="js">修改</em>函数范围之外的任何字段。并且它不修改其输入参数。</p><p id="c551" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总结一下——输出只靠输入+没有副作用！</p><p id="7dc9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在你可能会问，副作用是什么？在我们深入探讨“为什么是纯函数”之前，我们稍后再讨论这个问题。？</p><ul class=""><li id="045a" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">更容易证明f(x) =&gt; x * x，你可以通过函数的签名来判断它的大部分特性。</li><li id="53f0" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">更容易测试和调试，纯函数依赖于输入和算法，而不依赖于函数范围之外的参数(如全局变量)。</li></ul><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kh"><img src="../Images/af27e012841c330b27fd94614d162a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HPe2PLqjJGHEBx94"/></div></div></figure><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3015" class="kr ks hh kn b fi kt ku l kv kw">assert(pureFuncAgeAfter5years(25) == 30)</span></pre><p id="c3f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如你在上面一行中看到的，测试一个纯函数很容易，但是另一方面，不纯函数处理I/O，因此很难测试。再举一个不纯函数的例子。在下面的代码中，函数(calculateSum)与外界参数对话，因此变得难以测试，因为调用同一个函数两次，会导致不同的输出！即<em class="js"> 5 &amp; 10，</em> 5不等于10</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kx"><img src="../Images/534f30c4e94d23fccf099c79d2085193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rCeHgf5keZiKeuel"/></div></div></figure><ul class=""><li id="170c" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">更容易编写并发应用程序</li></ul><blockquote class="ky kz la"><p id="9b70" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">如果两个纯表达式之间没有数据依赖关系，则它们的顺序可以颠倒，或者它们可以并行执行，并且不会相互干扰(换句话说，任何纯表达式的计算都是线程安全的)</p></blockquote><ul class=""><li id="5c90" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">参考透明-</li></ul><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/a0c618f47bed52fcf70a259ac067f0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-rjladqQahGOqKz"/></div></div></figure><blockquote class="ky kz la"><p id="10cf" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">如果一个表达式可以用它的值替换而不改变程序的行为，那么它就是引用透明的。</p></blockquote><ul class=""><li id="609c" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">幂等的-对于一个给定值<em class="js">‘x’</em>它将产生相同的结果，无论它被调用多少次！</li></ul><blockquote class="ky kz la"><p id="c723" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">重新计算函数任意次都是安全的。</p></blockquote><ul class=""><li id="d9b6" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">惰性求值——求值被推迟到需要值的时候(在程序的某个地方调用)。有时候，删除我们不需要执行的东西是更好的优化。</li></ul><h1 id="ead7" class="lf ks hh bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">副作用</h1><p id="bbfa" class="pw-post-body-paragraph iu iv hh iw b ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn mg jp jq jr ha bi translated">副作用可能是需要并发性和并行性的错误！(这是一个相当苛刻的说法)</p><ol class=""><li id="5051" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr mh jz ka kb bi translated">print("Hello World") : <em class="js">立即写入控制台</em></li><li id="7e51" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr mh jz ka kb bi translated">stdln.readLine(): <em class="js">立即读取控制台</em></li><li id="ac3d" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr mh jz ka kb bi translated">System.nanoTime(): <em class="js">立即从JVM中检索当前时间</em></li><li id="3255" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr mh jz ka kb bi translated">Future(deteleDb): <em class="js">立即删除数据库</em></li></ol><p id="3de2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">他们的结果依赖于某种形式的隐藏I/O。</p><p id="d80f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是在编程世界中，我们不能忽视写入文件、从数据库读取或从控制台读取。如果一个程序在某个时候不与外界对话，它就没有任何意义！这就是IO单子发挥作用的地方，单子封装副作用并设计更优雅的程序。我将在下一部分讨论这个问题！但在此之前，我将讨论FP世界中不变性的需要。</p></div><div class="ab cl mi mj go mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ha hb hc hd he"><h1 id="1cff" class="lf ks hh bd lg lh mp lj lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb bi translated"><strong class="ak">参考文献:</strong></h1><blockquote class="ky kz la"><p id="7ac0" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">[1]: <a class="ae it" href="https://alvinalexander.com/scala/learning-functional-programming-in-scala-book" rel="noopener ugc nofollow" target="_blank">功能编程，简化</a></p><p id="ff02" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">[2]:<a class="ae it" href="https://en.wikipedia.org/wiki/Functional_programming#Pure_functions" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Functional _ programming # Pure _ functions</a></p></blockquote></div></div>    
</body>
</html>