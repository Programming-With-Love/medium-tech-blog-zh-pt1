<html>
<head>
<title>Open-sourcing PINCache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开源PINCache</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/open-sourcing-pincache-787c99925445?source=collection_archive---------2-----------------------#2015-02-25">https://medium.com/pinterest-engineering/open-sourcing-pincache-787c99925445?source=collection_archive---------2-----------------------#2015-02-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2cb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Garrett Moon | Pinterest iOS工程师，核心体验</p><p id="0159" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于Pinterest iOS应用程序下载并处理大量数据，我们使用缓存系统来缓存模型和图像，以避免蚕食我们Pinners(用户)的数据计划。很长一段时间，我们使用TMCache将gif、JPEGs和模型保存到内存和磁盘，但在生产中使用后，Pinners报告应用程序挂起。在将问题归咎于TMCache之后，我们重新设计了一个重要的部分并分叉了这个项目，这导致了我们新的开源缓存库，<a class="ae jc" href="https://github.com/pinterest/PINCache" rel="noopener ugc nofollow" target="_blank"> PINCache </a>，一个用于iOS和OSX的非死锁对象缓存。这是我们如何从僵局到分叉。</p><h2 id="1d46" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">使异步方法同步</h2><p id="b873" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">首先，我们确定了问题。TMCache具有本机异步方法，并使用一种通用模式来提供这些方法的同步版本:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="bb77" class="jd je hh ki b fi km kn l ko kp">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);<br/>[doWorkAsyncrounouslyAndCallback:^{<br/>	dispatch_semaphore_signal(semaphore);<br/>}];<br/>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span></pre><p id="49e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，这种模式有一个致命的缺陷，因为它阻塞了调用线程并等待来自调度队列的信号。但是当你打了一堆这样的电话会发生什么呢？线程饥饿。如果每个线程都在等待另一个操作完成，并且没有更多的线程可以执行，那么就会陷入死锁状态。</p><figure class="kd ke kf kg fd kr er es paragraph-image"><div class="er es kq"><img src="../Images/e0168b8543fb7e96334fc75a3810f413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UmVoMTg4N5RxaLrj.png"/></div></figure><h2 id="2efe" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">使同步方法异步</h2><p id="6c6b" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">显而易见的解决方案是使我们的“本地”方法同步，并为我们的异步版本包装dispatch_async。事实证明，这是解决TMCache问题的第一步。但是还有更多。TMCache使用一个串行队列来保护ivars并保证线程安全，根据<a class="ae jc" href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html" rel="noopener ugc nofollow" target="_blank">苹果公司关于从线程迁移到GCD的文档</a>，这是一个好主意。然而，这些文档中隐藏了一个小细节:“……只要您异步地将任务提交到一个串行队列，该队列就永远不会死锁。”言外之意，如果你想避免死锁，你不能同步访问一个用作资源锁的串行队列。这也是我们通过编写一个每次都会死锁TMCache的单元测试所观察到的:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="e4e6" class="jd je hh ki b fi km kn l ko kp">- (void)testDeadlocks<br/>{<br/>    NSString *key = @"key";<br/>    NSUInteger objectCount = 1000;<br/>    [self.cache setObject:[self image] forKey:key];<br/>    dispatch_queue_t testQueue = dispatch_queue_create("test queue", DISPATCH_QUEUE_CONCURRENT);<br/><br/>    NSLock *enumCountLock = [[NSLock alloc] init];<br/>    __block NSUInteger enumCount = 0;<br/>    dispatch_group_t group = dispatch_group_create();<br/>    for (NSUInteger idx = 0; idx &lt; objectCount; idx++) {<br/>        dispatch_group_async(group, testQueue, ^{<br/>            [self.cache objectForKey:key];<br/>            [enumCountLock lock];<br/>            enumCount++;<br/>            [enumCountLock unlock];<br/>        });<br/>    }<br/><br/>    dispatch_group_wait(group, [self timeout]);<br/>    STAssertTrue(objectCount == enumCount, @"was not able to fetch 1000 objects, possibly due to deadlock.");<br/>}</span></pre><h2 id="a315" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">回到信号量</h2><p id="0fff" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">如果我们想让同步方法在缓存中可用，我们必须保护我们的ivars，并用另一种机制保证线程安全。我们需要的是一把锁。标准锁会降低我们的性能，但是使用dispatch_semaphore有一个小小的<a class="ae jc" href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" rel="noopener ugc nofollow" target="_blank">优势</a>:</p><p id="c670" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku"/><a class="ae jc" href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" rel="noopener ugc nofollow" target="_blank"><em class="ku">只有在需要阻塞调用线程时，才会将信号量调用下发给内核。如果调用信号量不需要阻塞，就不会进行内核调用。</em></a><em class="ku"/></p><p id="e886" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么如何使用dispatch_semaphore作为锁呢？简单:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="c42b" class="jd je hh ki b fi km kn l ko kp">dispatch_semaphore_t lockSemaphore = dispatch_semaphore_create(1);<br/>//lock the lock:<br/>dispatch_semaphore_wait(lockSemaphore, DISPATCH_TIME_FOREVER);<br/>//do work inside lock<br/><br/>  ...<br/><br/>//unlock the lock:<br/>dispatch_semaphore_signal(lockSemaphore);</span></pre><figure class="kd ke kf kg fd kr er es paragraph-image"><div class="er es kq"><img src="../Images/65b3fc5c6c082545bb7c792bce70d590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*gG4KRj7dXCci7pxo.png"/></div></figure><p id="3af4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以这种方式使用信号量作为锁与我们在本文开头提到的常见模式的区别在于，我们不需要单独的线程来释放锁。</p><h2 id="21e0" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">介绍PINCache</h2><p id="de77" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在通过电子邮件与github的维护者进行了长时间的交谈后，他们决定放弃TMCache，因为他们不愿意在短时间内进行重大的架构变更。为了允许TMCache的现有用户退出我们所做的重大更改，我们决定分叉这个项目。以下是TMCache和PINCache的主要区别:</p><ul class=""><li id="70e2" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">PINCache类似于TMCache，因为它同时拥有内存缓存和磁盘缓存的实例。它将调用传播到每一个，首先依靠快速内存缓存，然后回到磁盘缓存。</li><li id="43e2" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">PINMemoryCache有同步的本地方法，异步版本包装它们。它使用dispatch_semaphore作为锁来保证线程安全。</li><li id="162b" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">PINDiskCache也有同步的本地方法，异步版本也简单地包装它们。</li><li id="14b9" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">PINDiskCache没有使用共享队列，而是提供了两种方法(一种异步方法和一种同步方法)来安全地操作文件:</li><li id="8397" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><code class="du lj lk ll ki b">lockFileAccessWhileExecutingBlock:(PINDiskCacheBlock)block synchronouslyLockFileAccessWhileExecutingBlock:(PINDiskCacheBlock)block;</code></li><li id="da95" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">另一个主要区别是PINDiskCache的多个实例独立运行。这可以提高性能，但是拥有两个同名的PINDiskCache实例不再安全。</li></ul><h2 id="ce38" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">用PINCache替换TMCache</h2><p id="6ea1" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">如果你在生产中有一个使用TMCache的应用程序，而你想切换到PINCache，那就有点麻烦了。首先，由于sharedQueue在PINDiskCache上不再可用，您将需要使用lockFileAccessWhileExecutingBlock:。其次，您需要将所有用户的磁盘缓存迁移到PINCache或清理它们。在初始化任何PINDiskCache或PINCache实例之前，只需在某处运行此代码片段:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="817c" class="jd je hh ki b fi km kn l ko kp">//migrate TMCache to PINCache<br/>- (void)migrateDiskCachesWithNames:(NSArray *)cacheNames<br/>{<br/>    //migrate TMCache to PINCache<br/>    NSString *rootPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];<br/>    for (NSString *cacheName in cacheNames) {<br/>        NSString *oldPathExtension = [NSString stringWithFormat:@"com.tumblr.TMDiskCache.%@", cacheName];<br/>        NSURL *oldCachePath = [NSURL fileURLWithPathComponents:@[rootPath, oldPathExtension]];<br/>        NSString *newPathExtension = [oldPathExtension stringByReplacingOccurrencesOfString:@"tumblr" withString:@"pinterest"];<br/>        newPathExtension = [newPathExtension stringByReplacingOccurrencesOfString:@"TMDiskCache" withString:@"PINDiskCache"];<br/>        NSURL *newCachePath = [NSURL fileURLWithPathComponents:@[rootPath, newPathExtension]];<br/>        if (oldCachePath &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:[oldCachePath path]]) {<br/>            NSError *error;<br/>            [[NSFileManager defaultManager] moveItemAtURL:oldCachePath toURL:newCachePath error:&amp;error];<br/>            if (error) {<br/>                [[NSFileManager defaultManager] removeItemAtURL:oldCachePath error:nil];<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="a9b7" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">促成PINCache</h2><p id="1a41" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们大量使用PINCache，希望它成为平台上最好的缓存库。记住这一点，我们欢迎拉请求和错误报告！我们承诺尽快解决这些问题。我们迫不及待地想看到你用它制作的令人敬畏的、高性能的、非死锁的应用程序！</p><p id="3ca0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku"> Garrett Moon是移动团队的iOS工程师。</em></p><p id="8d8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ku">获取Pinterest工程新闻和更新，关注我们的工程</em><a class="ae jc" href="https://www.pinterest.com/malorie/pinterest-engineering-news/" rel="noopener ugc nofollow" target="_blank"><em class="ku">Pinterest</em></a><em class="ku">，</em> <a class="ae jc" href="https://www.facebook.com/pinterestengineering" rel="noopener ugc nofollow" target="_blank"> <em class="ku">脸书</em> </a> <em class="ku">和</em><a class="ae jc" href="https://twitter.com/PinterestEng" rel="noopener ugc nofollow" target="_blank"><em class="ku">Twitter</em></a><em class="ku">。有兴趣加入团队吗？查看我们的</em> <a class="ae jc" href="https://about.pinterest.com/en/careers/engineering-product" rel="noopener ugc nofollow" target="_blank"> <em class="ku">招聘网站</em> </a> <em class="ku">。</em></p></div></div>    
</body>
</html>