<html>
<head>
<title>The recipe to break BigQuery down — and some ways to fix it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解BigQuery的方法——以及修复它的一些方法</h1>
<blockquote>原文：<a href="https://medium.com/globant/the-recipe-to-break-bigquery-down-and-some-ways-to-fix-it-c1c3c286f451?source=collection_archive---------0-----------------------#2021-10-05">https://medium.com/globant/the-recipe-to-break-bigquery-down-and-some-ways-to-fix-it-c1c3c286f451?source=collection_archive---------0-----------------------#2021-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fbd5e4ddebfeb5368e8a7c3fd82e20bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_0hjjA0qVcinDtf97MWyg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: <a class="ae it" href="https://pixabay.com/photos/ingredients-cooking-preparation-498199/" rel="noopener ugc nofollow" target="_blank">pixabay</a></figcaption></figure></div><div class="ab cl iu iv go iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="ha hb hc hd he"><blockquote class="jb jc jd"><p id="bc8e" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">收集数据是好的，存储数据是好的实践，但从数据中提取知识是一种强大的力量。</p></blockquote></div><div class="ab cl iu iv go iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="ha hb hc hd he"><p id="4a5f" class="pw-post-body-paragraph je jf hh jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc ha bi translated">在本文中，您将找到一些方法来探索和发现如何分解BigQuery。根据<a class="ae it" href="https://cloud.google.com/forrester-wave-cloud-data-warehouse-2021" rel="noopener ugc nofollow" target="_blank"> Forrester </a>的说法，BigQuery是最重要的无服务器、高度可扩展、经济高效的多云数据仓库。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es kg"><img src="../Images/09fc11bcf637ba6f1702fba908e3f67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*-Y3mEYwdgrV9UPrJIPL5Ug.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: <a class="ae it" href="https://cloud.google.com/forrester-wave-cloud-data-warehouse-2021" rel="noopener ugc nofollow" target="_blank">Forrester, via Google</a></figcaption></figure><p id="b4d4" class="pw-post-body-paragraph je jf hh jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc ha bi translated">“<em class="jg">能力越大，责任越大</em>”，正如他们所说，所以你需要知道一些重要的事情来使用BigQuery获得价值。很多人认为BigQuery是一个牢不可破的服务，你可以放心使用。像任何服务一样，你必须知道如何最好地利用它来挖掘它的全部潜力。我将展示什么是BigQuery，给你一个灾难性的解决方案，并给出一个有疯狂需求的假想场景，以及一些修复它的方法。</p><h1 id="2490" class="kl km hh bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">分解BigQuery的最好方法</h1><p id="267a" class="pw-post-body-paragraph je jf hh jh b ji lj jk jl jm lk jo jp kd ll js jt ke lm jw jx kf ln ka kb kc ha bi translated">为了执行查询，BigQuery创建一个“查询计划”来获取数据并估计所需的资源。但是，如果应用一些反模式，可能会破坏Bigquery。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/80a8ca0659b69abfbcfc30cde41eeab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*6qzINesmbdQKDe8068lgbA.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: <a class="ae it" href="https://memegenerator.net/instance/78286280/loses-their-minds-its-a-layer-8-error-everyone-loses-their-minds" rel="noopener ugc nofollow" target="_blank">Memegenerator</a></figcaption></figure><p id="7b60" class="pw-post-body-paragraph je jf hh jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc ha bi translated">前五个问题是:</p><ol class=""><li id="35ca" class="lp lq hh jh b ji jj jm jn kd lr ke ls kf lt kc lu lv lw lx bi translated"><strong class="jh hi">加入操作</strong>。创建查询计划时，它意味着连接，作业可能会失败或花费大量时间。主要原因是BigQuery不是一个<a class="ae it" href="https://en.wikipedia.org/wiki/Online_transaction_processing" rel="noopener ugc nofollow" target="_blank">在线事务处理(OLTP) </a>系统。相反，Bigquery有<a class="ae it" href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf" rel="noopener ugc nofollow" target="_blank"> Dremel </a>，它被设计为提供<a class="ae it" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank">在线分析处理(OLAP) </a>遵从性，这意味着如果您的数据是嵌套的并且<a class="ae it" href="https://en.wikipedia.org/wiki/Data_deduplication" rel="noopener ugc nofollow" target="_blank">非规范化的</a>，它最适合。如果需要连接，可能会导致查询速度问题。</li><li id="5899" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><a class="ae it" href="https://en.wikipedia.org/wiki/Skewness" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hi">数据偏斜</strong> </a> <strong class="jh hi">。</strong>如果您的数据分布不平衡(10%的唯一值代表90%的总记录),并且您想要执行聚合任务，那么性能问题可能会随之而来。对于这样的任务，查询计划将分配大量的片段，这需要更多的资源。BigQuery无法解决数据的统计分布问题。如果您不尝试根据数据的基数<a class="ae it" href="https://en.wikipedia.org/wiki/Cardinality_(data_modeling)" rel="noopener ugc nofollow" target="_blank">对查询进行分段，这可能意味着更高的成本和时间。</a></li><li id="3e92" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">通配符的用法。</strong> BigQuery面向列级。这意味着当您在一个<em class="jg"> SELECT </em>语句中使用通配符来获取所有列时，您可能会获得不必要的数据。换句话说，您创建了一个不必要的工作负载。</li><li id="6c35" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">用于查询的过滤器。</strong>不能在聚合操作中使用嵌套过滤器。否则，您不能在没有<a class="ae it" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">分区</a>或<a class="ae it" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">集群</a>设置的表格中使用过滤器。这是BigQuery中错误过滤器的两个例子，因为这对优化过程和有效提取没有影响。</li><li id="d92c" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">作为过滤器的子查询:</strong>当您使用一个查询过滤另一个查询时，您需要转到两个表。使用<a class="ae it" href="https://en.wikipedia.org/wiki/Static_variable" rel="noopener ugc nofollow" target="_blank">静态值</a>听起来可能不是最好的选择，但它绝对比<a class="ae it" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/subqueries" rel="noopener ugc nofollow" target="_blank">子查询</a>更好。BigQuery首先执行主查询，然后执行子查询，最后根据子查询的结果过滤主查询。但是，这最后一个阶段发生在<a class="ae it" href="https://cloud.google.com/blog/products/bigquery/in-memory-query-execution-in-google-bigquery" rel="noopener ugc nofollow" target="_blank">洗牌区</a>，这不是推荐的行为。</li></ol><h1 id="0940" class="kl km hh bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">假设情况</h1><p id="2f3b" class="pw-post-body-paragraph je jf hh jh b ji lj jk jl jm lk jo jp kd ll js jt ke lm jw jx kf ln ka kb kc ha bi translated">假设ABC公司需要创建几个查询来响应下面指定的业务需求。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/8ee59f564501d4cf5bb8088e873835c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*xlKFBDGi9XXJUvLK4_duyw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: <a class="ae it" href="https://www.pngarea.com/view/54d04d2f_men-graduation-hd-png-download/" rel="noopener ugc nofollow" target="_blank">pngarea</a></figcaption></figure><p id="22ae" class="pw-post-body-paragraph je jf hh jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc ha bi translated">该公司有以下要求:</p><ul class=""><li id="303e" class="lp lq hh jh b ji jj jm jn kd lr ke ls kf lt kc me lv lw lx bi translated">动态更改分区和群集字段。</li><li id="00c3" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc me lv lw lx bi translated">用很少的过滤器创建大型查询，而不是在聚合中使用嵌套条件。</li><li id="fcff" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc me lv lw lx bi translated">创建具有数据偏斜问题的交叉连接操作。</li><li id="938e" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc me lv lw lx bi translated">所有这些都有以下限制:因为资金问题，你只能使用1000个<a class="ae it" href="https://cloud.google.com/bigquery/docs/slots" rel="noopener ugc nofollow" target="_blank">插槽</a>。</li></ul><p id="f882" class="pw-post-body-paragraph je jf hh jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc ha bi translated">ABC公司试图自己解决上述需求，从而产生了打破BigQuery的完美方法:</p><ul class=""><li id="3daa" class="lp lq hh jh b ji jj jm jn kd lr ke ls kf lt kc me lv lw lx bi translated">他们创建了一个“测试查询”，期望得到1000个字段的结果，并(意外地)创建了一个超过100，000，000，000行的中间表。</li><li id="1c1b" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc me lv lw lx bi translated">该查询由998个具有嵌套条件的聚合组成。</li><li id="041f" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc me lv lw lx bi translated">这个查询由两个源表组成，左边的表有4，000，000行，右边的表有25，000行，两个表之间有一个交叉连接操作。</li></ul><h1 id="79f9" class="kl km hh bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">建议的方法</h1><p id="539d" class="pw-post-body-paragraph je jf hh jh b ji lj jk jl jm lk jo jp kd ll js jt ke lm jw jx kf ln ka kb kc ha bi translated">作为一名数据架构师，您可以按顺序通过以下建议来解决这一具有挑战性的需求:</p><ol class=""><li id="378d" class="lp lq hh jh b ji jj jm jn kd lr ke ls kf lt kc lu lv lw lx bi translated"><strong class="jh hi">执行数据分析。</strong>要理解数据，首先探索它是一个好主意。您可以考虑使用统计工具来确定每个事件的唯一索引，并找到正确的策略来对数据进行聚类，以解决相关的业务需求。</li><li id="ef8f" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">割裂问题。</strong> <a class="ae it" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分而治之策略</a>是解决大问题的最好方法……你不需要创建一个包含数百个复杂聚合的大查询。通过使用窗口类型、功能和其他相关主题来避免使用嵌套条件的聚合，每次构建查询。</li><li id="5e54" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">预处理您的数据。</strong>创建计划流程以清除重复事件，并尝试丢弃两个表之间有任何关系的事件。对于这种方法，您可以创建一个临时表来保存原始数据。</li><li id="7398" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">使用中间表。</strong>如果您有一个包含几个阶段的复杂查询，尝试将这个查询分成几个小步骤，并使用中间表(尽可能使用集群和分区)。使用这种策略，您可以有机会调整您的查询计划，并负责使用您的洗牌区。</li><li id="aa2d" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">处理数据倾斜。</strong>你可以试试<a class="ae it" href="https://en.wikipedia.org/wiki/Data_binning" rel="noopener ugc nofollow" target="_blank">逆势而为</a>的策略。分桶包括通过添加新的列键并在联接中使用它来重新分配数据。这种方法的主要缺点是，您的数据将在所有存储桶中被复制多次。您还可以尝试将高基数数据与低基数数据分开。当你采用这些策略时，主要的问题是得到一个<a class="ae it" href="https://cloud.google.com/bigquery/docs/best-practices-performance-compute#optimize_your_join_patterns" rel="noopener ugc nofollow" target="_blank">广播加入</a>作为结果。这是指某个插槽需要处理的数据块具有正确的大小，可以毫无延迟地解决操作。</li><li id="d333" class="lp lq hh jh b ji ly jm lz kd ma ke mb kf mc kc lu lv lw lx bi translated"><strong class="jh hi">了解</strong> <a class="ae it" href="https://cloud.google.com/bigquery/docs/information-schema-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hi">信息_模式</strong> </a> <strong class="jh hi">视图。</strong>始终在这个重要的系统提供的视图中检查每个日志，以调整您的策略，并找到解决您查询中瓶颈阶段的正确解决方案。</li></ol><h1 id="157e" class="kl km hh bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">最后</h1><p id="c91f" class="pw-post-body-paragraph je jf hh jh b ji lj jk jl jm lk jo jp kd ll js jt ke lm jw jx kf ln ka kb kc ha bi translated">是的，不遵循最佳实践和应用查询反模式可能会破坏BigQuery。您必须非常了解数据理论和产品特性，才能充分利用它的强大功能。BigQuery是一款优秀的产品，但就像世界上几乎所有的东西一样，它并不完美，也有局限性。在正确的人手中，BigQuery确实有正确的答案来解决您的数据问题，并从您的数据中提取所有价值。</p></div></div>    
</body>
</html>