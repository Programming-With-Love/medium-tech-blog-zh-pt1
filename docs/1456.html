<html>
<head>
<title>Bashing the Bash — Replacing Shell Scripts with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">猛烈抨击——用Python替换Shell脚本</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/bashing-the-bash-replacing-shell-scripts-with-python-d8d201bc0989?source=collection_archive---------0-----------------------#2017-07-19">https://medium.com/capital-one-tech/bashing-the-bash-replacing-shell-scripts-with-python-d8d201bc0989?source=collection_archive---------0-----------------------#2017-07-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4cbbf6998f99ec7a078a8da3cfe60801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAj_WWL97jnLh_beffmIEQ.png"/></div></div></figure><blockquote class="ip"><p id="dc52" class="iq ir hh bd is it iu iv iw ix iy iz dx translated">我们能谈谈你穿的旧帽衫吗？是的，它有一个模糊的标志和一个复杂的、对个人意义重大的故事。是的，它让你远离阳光。不过用胶带把口袋粘在一起似乎并不是最佳选择。肘部有个洞。那是什么污渍？如果你洗了它，还会剩下什么吗…</p></blockquote><p id="3201" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw iz ha bi translated">让我们承认，一个看起来像来自一个废弃网站的免费帽衫的应用程序并不能给人带来多少信心。应用程序的外观很重要，就像衣服一样。因此，许多软件都提供了炫目、奇特的体验，但我们都知道，软件不仅仅是看上去那么简单。在这个外表下，有用户看不到的处理层。有各种各样的纽扣、拉链、腰带和吊带来确保物品固定在一起。</p><p id="b04e" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">例如，技术操作人员(TechOps)必须启动服务器，确认它正在运行，停止服务器，可能备份数据，可能导出或导入数据。除了操作之外，开发(DevOps)人员还有一套用于集成和部署的工具。这个DevOps工具通常与shell脚本缝合在一起，以确保GitHub中的合并分支变成可部署的工件。</p><blockquote class="ip"><p id="7c9e" class="iq ir hh bd is it kc kd ke kf kg iz dx translated">那套漂亮的服装肯定是由许多独立的零件组装而成的。</p></blockquote><p id="19ed" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw iz ha bi translated">现在，你的连帽衫可能是万能的遮盖物——你可以在任何地方穿着它——就像外壳是将许多软件工具结合在一起的东西一样。虽然这是普遍现象，但它也是DevOps/TechOps中经常出现的问题之一。这是一个问题，因为我们经常滥用shell，把它当成一种编程语言。</p><p id="acf1" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">以下是一些关注点:</p><ul class=""><li id="a2e6" class="kh ki hh jc b jd jx jh jy jl kj jp kk jt kl iz km kn ko kp bi translated">语法可能晦涩难懂。我们都习惯了，但这并不意味着好。</li><li id="d5a8" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">很慢。虽然shell脚本的速度无关紧要，但是试图像编程语言一样使用shell会浪费系统资源。</li><li id="b1f4" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">我们经常会忽略剧本的关键特征。使用<strong class="jc hi"> <em class="kv"> $，检查程序的状态？</em> </strong>会被不小心漏掉，导致行为不一致。</li><li id="0a13" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">shell语言的唯一数据结构是字符串。有很多方法可以将字符串分解成单词。<strong class="jc hi"> <em class="kv"> expr </em> </strong>程序可以将字符串转换成数字进行运算。<strong class="jc hi"> <em class="kv">日期</em> </strong>程序允许一些日期操作，但是规则可能是模糊的。</li><li id="563b" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">单元测试并不容易。有一些像<a class="ae kw" href="https://github.com/sstephenson/bats" rel="noopener ugc nofollow" target="_blank"> Bats </a>这样的包可以帮助单元测试。像Python这样的语言有更强大的单元测试能力。</li></ul><p id="13d4" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated"><em class="kv">不是壳破了。shell不是一种完整的编程语言。它不能满足我们的所有需求。</em></p><h2 id="1af8" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">这就把我们带到了痛击</h2><p id="f089" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">bash-bashing的目的是减少shell的使用。无需太多实际工作，用Python代码替换shell脚本是很容易的。修改后的代码更容易阅读和维护，运行速度更快，并且可以有一个合适的单元测试套件。</p><p id="c178" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">因为shell代码非常常见，所以我将提供一些如何将遗留shell脚本翻译成Python的详细示例。我假设你对Python有点熟悉。这些例子将在Python 3.6中出现，包括像<strong class="jc hi"> <em class="kv"> pathlib </em> </strong>和f字符串这样的特性。如果你想跟随，考虑创建一个虚拟环境或使用<a class="ae kw" href="https://conda.io/docs/intro.html" rel="noopener ugc nofollow" target="_blank">康达</a>。</p><p id="4d9a" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">shell脚本示例是纯粹的bash，可以在bash运行的任何地方运行。设计模式适用于Windows当然，语法会有很大的不同。</p><h2 id="789e" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">世界真大</h2><p id="9802" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">在深入研究代码之前，我想对这个例子做一些界定。很容易举出Git hooks、Jenkins jobs或UrbanCode Deploy的例子。</p><p id="78be" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我认为这类例子有点太具体了；我想更广泛地了解一下shell脚本。我想把普通运动服和我们攀岩时可能穿的特殊装备区分开来。我的代码示例不是为特定的DevOps工具链定制的。</p><p id="9c65" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这种贝壳可用于各种各样的东西。我将使用一个示例，其中包含一些常见的操作系统级资源操作:</p><ul class=""><li id="1566" class="kh ki hh jc b jd jx jh jy jl kj jp kk jt kl iz km kn ko kp bi translated">读取配置文件</li><li id="b727" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">终止(和创建)进程</li><li id="eee4" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">做日期算术</li><li id="a215" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">创建(和删除)目录</li><li id="ec0a" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">运行应用程序</li><li id="7eb1" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">管理文件</li></ul><p id="fc61" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">除了管理操作系统资源，还有一些更高层次的考虑因素。这些考虑包括条件处理和对象迭代。我将展示一个迭代文件的例子，但是脚本也可以迭代文件中的进程甚至行。</p><p id="f30d" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">Shell脚本通常管理网络资源。这意味着通过<strong class="jc hi"> <em class="kv"> curl </em> </strong>和<strong class="jc hi"> <em class="kv"> wget </em> </strong>访问远程资源。使用这些程序使管理网络资源看起来更像运行应用程序和管理本地文件。正因为如此，我不会把网络资源当作一类独特的对象。</p><h2 id="020c" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">有代表性的剧本</h2><p id="dd8e" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">我有一个小shell脚本，其中包含一些不同资源操作的示例。该脚本操纵一些操作系统资源，并运行外部应用程序。<em class="kv">(没错，应用是偷偷用Python的。)</em></p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/217167c23dd00eb525de2c187ea86dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPZ3HhLwwC3V8iQQQIw2DA.png"/></div></div></figure><p id="05c5" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这个脚本似乎有四个重要步骤:</p><ol class=""><li id="334a" class="kh ki hh jc b jd jx jh jy jl kj jp kk jt kl iz mc kn ko kp bi translated">它会终止一个进程。这包括读取一个文件以获得一个进程id，然后执行<strong class="jc hi"><em class="kv">【PS】</em></strong>和<strong class="jc hi"> <em class="kv"> kill </em> </strong>命令。<strong class="jc hi"> <em class="kv"> example.pid </em> </strong>文件由其他进程创建，并由该脚本读取。如果文件没有任何内容，有一个逻辑路径来处理。如果文件根本不存在呢？</li><li id="f159" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz mc kn ko kp bi translated">它创建一个基于当前日期命名的目录。该目录将在后续步骤中使用。如果该目录已经存在，就会出现一条烦人的消息。这种掩蔽有问题吗？</li><li id="4dd5" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz mc kn ko kp bi translated">它运行一个分析程序。对于 循环来说，有一个令人困惑的<strong class="jc hi"> <em class="kv">，它只处理文件名排序列表中的一个文件。我将在下面深入探讨这个结构的细微差别。我将它作为使用Python时可以简化的算法的代表。</em></strong></li><li id="a76a" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz mc kn ko kp bi translated">最后，它将输出文件复制到第二个位置，名为<strong class="jc hi"> <em class="kv"> current.txt </em> </strong>。复制操作由if语句限定，该语句在替换另一个文件之前检查一个文件是否较新。</li></ol><p id="d7a8" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我强调短语“似乎有”,因为shell脚本可能有难以察觉的副作用。这个具体的例子清楚地说明了它创建的文件和目录以及它终止的进程。通常，shell背后的原始想法是让资源管理变得非常清晰。然而，这一理想在实践中并不总能实现。</p><blockquote class="ip"><p id="bcf6" class="iq ir hh bd is it kc kd ke kf kg iz dx translated">你可能会喜欢你的帽衫。但是有胶带把它粘在一起。</p></blockquote><p id="5d03" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw iz ha bi translated">shell晦涩的一个例子是当前工作目录的设置方式。<strong class="jc hi"> <em class="kv"> cd </em> </strong>命令足够清晰，但是在使用<strong class="jc hi"> <em class="kv"> () </em> </strong>的子shell存在的情况下，很难辨别嵌套shell调用的堆栈以及子shell退出时工作目录如何变化。</p><p id="8211" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">让我们把这个例子改写成可以进行单元测试的东西。我将从头开始，一步步深入细节。</p><h2 id="9d74" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">从顶部开始</h2><p id="6b39" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">我所说的“顶部”是指对脚本功能的高度概括。这个脚本看起来有四个步骤。下面是一些Python代码，它们反映了整体概要:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/35fc022b88d38d91e9de74d67716c231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qB-xB_EFOmw3WPWD0GraUA.png"/></div></div></figure><p id="137a" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我将这四个步骤理想化为独立的功能。这留下了实现每个功能的空间。我尽量避免做太多假设。实际上，我们通常对shell脚本的功能有更清晰的了解；这允许我们以一种更适合脚本意图的方式来定义函数。</p><h2 id="e3a1" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">从配置文件到流程管理</h2><p id="0229" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">shell的一个更有趣的特性是变量往往是全局的。但是，有一些例外和警告会导致shell脚本被破坏或行为不一致。这意味着像<strong class="jc hi"> <em class="kv"> PID_FILE </em> </strong>和<strong class="jc hi"> <em class="kv"> PID </em> </strong>这样的环境变量是一个步骤的<em class="kv">电位</em>输出和后续步骤的<em class="kv">电位</em>输入。很少清楚。</p><p id="0e5b" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">重写的一部分意味着识别在脚本的其他部分使用的全局变量。这在复杂的脚本中可能很困难。在这个例子中，很容易检查代码以确保这两个变量是有效的局部变量。</p><p id="66f0" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">重写的另一部分意味着识别更像配置参数而不是简单变量的东西。像文字目录和文件名这样的东西显然可以作为配置参数。还有其他可配置的项目，如搜索字符串和通配符模式，可能也需要被视为外部配置的一部分。我建议在参数化过程中慢慢来。</p><p id="2215" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我的建议是先让事情运转起来。以后再概括。</p><p id="4d43" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">下面是<strong class="jc hi"><em class="kv">kill _ process()</em></strong>函数的一个实现:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/029b639437b4ee4a87ef71047de60ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAFb79OKkUTa3xaSFg_tMA.png"/></div></div></figure><p id="1125" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我已经用基于<strong class="jc hi"> <em class="kv">的Pythonic习语【PID = PID FILE _ path . read _ text()</em></strong>的代码替换了read<strong class="jc hi"><em class="kv">PID&lt;$ PID _ FILE</em></strong>的shell的习语。原始的shell脚本没有关于文件格式的任何文档；我们还没有给Python添加文档。文件内容摘要是一个重要的补充。</p><p id="a606" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这里是shell和Python之间的另一个变化:shell使用字符串，但是Python<strong class="jc hi"><em class="kv">psutil</em></strong>库使用整数作为进程ID。这导致使用<strong class="jc hi"> <em class="kv"> int() </em> </strong>函数将字符串转换为整数。这也意味着当文件不包含PID的有效数字时，脚本需要做一些有用的事情。</p><p id="5832" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">如果文件有一个无效的PID，原始的shell脚本将会默默地做一些晦涩难懂的事情。试试运行<strong class="jc hi"> <em class="kv"> ps什么</em> </strong>或者<strong class="jc hi"> <em class="kv"> ps ick </em> </strong>自己看看这种不太明显的行为。</p><p id="e565" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">同样，如果找不到进程，<strong class="jc hi"> <em class="kv"> kill </em> </strong>命令会写一条消息。找不到进程时，脚本不停止；它悄悄地忽略了这个问题。也许这种情况真的不是问题。很难说初衷是什么。这是一个疏忽吗？还是故意的？</p><p id="29a6" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">无论是<strong class="jc hi"> <em class="kv"> ps </em> </strong>还是<strong class="jc hi"> <em class="kv"> kill </em> </strong>程序都在<strong class="jc hi"> <em class="kv">中设置了状态码$？</em> </strong>取值为1表示程序失败。省略对<strong class="jc hi"> <em class="kv">值的检查？</em> </strong>表示这些程序的成败被忽略。</p><p id="402b" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">与shell不同，当程序没有完成且状态代码为零时，Python会不断地抛出异常。我们的Python脚本必须处理这个异常，以明确各种类型的失败通常无关紧要。在示例中，Python代码编写了一条警告消息并继续处理。<strong class="jc hi"> <em class="kv"> pass </em> </strong>语句可以用来代替<strong class="jc hi"> <em class="kv"> print </em> </strong>函数来沉默异常。</p><p id="dd4b" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">注意，<strong class="jc hi"> <em class="kv"> psutil </em> </strong>包不是标准库的一部分。您需要单独安装它。</p><h2 id="64d5" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">创建目录</h2><p id="e726" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">下面是<strong class="jc hi"><em class="kv">make _ output()</em></strong>函数创建输出目录的实现:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/7f83a83deda3b01dfb2cc762497abfce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPDDQOBrg-LRTVkPq2WvAw.png"/></div></div></figure><p id="5ee5" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">shell的<strong class="jc hi"> <em class="kv"> date </em> </strong>程序用相对隐晦的语法做了很多事情。我写了一个简单的函数，它模拟了<strong class="jc hi"> <em class="kv"> date </em> </strong>程序的一个特性。很容易将其扩展为包含日期偏移功能。</p><p id="2767" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我在<strong class="jc hi"><em class="kv">make _ output _ dir()</em></strong>定义中包含了一个类型提示。这总结了该函数产生的返回值。如果你以前没有看过Python 3类型提示，我需要强调一下“提示”方面。它们根本不会改变运行时的行为。通过<strong class="jc hi"> <em class="kv"> mypy </em> </strong>程序(<a class="ae kw" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank">http://mypy-lang.org/</a>)有一个单独的质量检查，以确认类型提示都被一致地使用。</p><p id="bdfa" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这个函数利用了Python 3<strong class="jc hi"><em class="kv">path lib</em></strong>库。<strong class="jc hi"> <em class="kv"> output_dir </em> </strong>变量被称为“纯”路径——一条<em class="kv">可能</em>存在的潜在路径。它是由一个<strong class="jc hi"> <em class="kv">路径</em> </strong>对象和一个字符串构建的。/运算符从基础<strong class="jc hi"> <em class="kv">路径</em> </strong>对象构建复杂路径。</p><p id="e8f6" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">纯道建成后，<strong class="jc hi"> <em class="kv">。mkdir() </em> </strong>方法从纯路径创建一个实际路径。如果目录已经存在，使用<strong class="jc hi"> <em class="kv"> exist_ok </em> </strong>选项可以消除<strong class="jc hi"><em class="kv">FileExistsError</em></strong>异常。</p><p id="4d45" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在目录已经存在的情况下，遗留shell脚本会写一条错误消息。与此相反，Python代码是沉默的。如果重要的话，可以修改Python代码来模拟错误消息行为。省略<strong class="jc hi"> <em class="kv"> exist_ok=True </em> </strong>并通过打印一条<strong class="jc hi"> <em class="kv"> f"{output_dir} </em> </strong>:文件存在"消息来处理<strong class="jc hi"><em class="kv">filexistserror</em></strong>异常</p><p id="73e0" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">对源代码的搜索显示，<strong class="jc hi"> <em class="kv"> output_dir </em> </strong>变量的值在脚本的其他地方使用。因此，我将该值作为该函数的显式结果返回。</p><p id="eb3e" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">如果您是Python的新手，函数返回多个值是很容易的。在极少数情况下，shell脚本的一个步骤设置了多个需要返回的变量，只需在return语句中列出所有变量。</p><h2 id="fd18" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">传播变化</h2><p id="5fa5" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">当我第一次勾画脚本时，<strong class="jc hi"><em class="kv">make _ output _ dir()</em></strong>的签名没有参数也没有返回值。随着我深入挖掘细节，发现输出目录被<strong class="jc hi"><em class="kv">run _ analytics()</em></strong>和<strong class="jc hi"><em class="kv">copy _ to _ current()</em></strong>使用。返回值和参数的发现过程可能具有挑战性。在许多情况下，它包括单元测试失败，因为变量丢失。</p><p id="eaf3" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">更改<strong class="jc hi"> make_output_dir() </strong>函数意味着我还需要更改整个脚本。这里有一个版本，反映了每一步所需的所有变量:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/f58985f939c760284055fa22fee89a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EP5G7d8BBvf8aNKVmNhnqg.png"/></div></div></figure><p id="5609" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这个人为的例子没有涉及到很多用来传递值的环境变量。不要对现实世界脚本中的大量共享变量感到惊讶。在某些情况下，复制粘贴编程可能意味着在不同的步骤中重复使用变量名。</p><p id="3621" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">如果你回头看看<strong class="jc hi"><em class="kv">copy _ to _ current()</em></strong>代码块，它有两个全局变量:<strong class="jc hi"> <em class="kv"> output_dir </em> </strong>和<strong class="jc hi"> <em class="kv"> name </em> </strong>。但是，这些都是用来构建一个结果路径:<strong class="jc hi"><em class="kv">“$ {输出_目录}/summary _ $ {名称}。txt" </em> </strong>。我没有提供两个变量，而是做了微小的重新设计，从<strong class="jc hi"><em class="kv">run _ analytics()</em></strong>函数返回整个路径。</p><h2 id="e9c5" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">排序和搜索</h2><p id="525d" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">下一步，<strong class="jc hi"><em class="kv">run _ analytics()</em></strong>函数为特定的输入文件执行外部程序。下面是整体代码。我们先来看看文件名排序，然后我们来看看运行程序的<strong class="jc hi"> <em class="kv"> check_call() </em> </strong>函数。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/70003842de56be087ace6faca74bada1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7u4ElwZ57sC3YUVCRh1IQ.png"/></div></div></figure><p id="d8df" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">一个<strong class="jc hi"> <em class="kv">路径</em> </strong>对象的<strong class="jc hi"> <em class="kv"> glob() </em> </strong>方法枚举该目录中的所有文件。这就像在shell中使用任何引号之外的<strong class="jc hi"> <em class="kv"> * </em> </strong>。除了它是明确的。</p><p id="3dc6" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我在这段代码中保留了最初的外壳设计。有一个包含中断的循环。尚不清楚为什么这个循环首先会存在。但是，我遵循我的策略，先把事情做好，然后再推广。一旦我们有了单元测试，我们可以重写它来优化它。</p><p id="938b" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这段代码包含了一个shell中一些低效处理的例子。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/486e3c5412882a2c50afad2ee82c0e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzXyGZBttbGlYZ_RVpKd1Q.png"/></div></div></figure><p id="b26e" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">语法很简洁，但是它涉及到一个带有管道的子shell。流水线包括运行两个独立的程序，并将一个程序的输出通过管道传输到另一个程序的输入。虽然Linux做得很快，但它涉及的开销是可以避免的。</p><p id="2331" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在Python中，我们可以使用以下内容:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/4ce903a675409538788a835982fb752c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clryccfcJfa9XDAY8Wp1Mg.png"/></div></div></figure><p id="9375" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">虽然Python代码更高效，但它还有另一个巨大的优势。在Python中，处理复杂的排序键非常简单。</p><p id="d80e" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在shell中，我们经常会设计这样的排序管道:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/a0cf83bda0ec4de7c526699e2c99a0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XE581LGRycxPyOwThtNKlA.png"/></div></div></figure><p id="c321" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">第一个<strong class="jc hi"> <em class="kv"> sed </em> </strong>步骤从文件名中提取一些数值，以便用于排序。排序完成后，最后一个sed步骤会删除修饰。有时这是用<strong class="jc hi"> <em class="kv"> awk </em> </strong>完成的。不管怎样，都是杂乱的。</p><p id="3848" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在Python中，我们可以更简单地为<strong class="jc hi"> <em class="kv">函数提供一个key函数sorted() </em> </strong>函数。</p><p id="284d" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">例如，我们可能有文件名类似于<strong class="jc hi"><em class="kv">prefix _ yyyymmdd . ext</em></strong>的文件，我们希望按<strong class="jc hi"> <em class="kv"> _、</em> </strong>后面的日期而不是前缀进行排序。我们可以编写一个排序关键字函数，如下所示:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/272af6ae1faeb1f4efda1f3d768c3b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlFdR8NP6I9F9owcVdHECg.png"/></div></div></figure><p id="f8a1" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">该函数将提取文件名的词干，对其进行分区，并只返回文件名的<strong class="jc hi"> <em class="kv"> yyyymmdd </em> </strong>部分。这将是排序关键字。当然，我们可以在这里进行任何类型的字符串或数值计算，在这种不太可能的情况下，我们有非常复杂的排序规则。</p><p id="9490" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我们可以如下使用该键功能:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/cc3e3a42bc499353b757c018657d7018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTnE48-HEl6SXj-AjEBjWA.png"/></div></div></figure><p id="b07c" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这将应用对象到键的转换函数，从每个要排序的对象创建排序键。</p><p id="6938" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">优化？我们可以将for/break结构替换为:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/7b088c3da8b2d1bbd1d5e1406accd67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVuxKrRF5nnMVUSEjr4RcA.png"/></div></div></figure><p id="bda0" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这将从文件名的排序序列中取出一个项目。</p><p id="eef9" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这里有一个例子，用一些虚假的数据展示了这种事情是如何发生的。我将使用字符串而不是构造<strong class="jc hi"> <em class="kv">路径</em> </strong>对象。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/03fb30c63626e5494c6ec424ffc7c9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2hXSsKNH-cqU8t1U77bEA.png"/></div></div></figure><p id="7632" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">后缀字符串被从文件名中去掉；这些字符串用于排序时的关键字比较。下面是下一步可能的情况。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/dbfcfac28ca240db07effcc5e1897fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_yO2I677pXcj06LIJcZbw.png"/></div></div></figure><p id="2012" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这些按升序排序，其中<strong class="jc hi"> <em class="kv">反转=真</em> </strong>将切换键比较的意义。</p><h2 id="596e" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">运行程序</h2><p id="f6f2" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">Python和shell之间的一个巨大差异是shell隐式运行程序的方式。如果这一行的第一个单词不是shell的内置特性，那么这个名字会在OS <strong class="jc hi"> <em class="kv"> $PATH </em> </strong>中找到并作为程序执行。在Python中，子进程模块用于运行程序。这里用到的<strong class="jc hi"> <em class="kv"> check_call() </em> </strong>函数就是我用的。根据所需的精确行为，还有其他一些选择。</p><p id="a943" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">从最初的shell命令到Python的转换包括替换三个shell解析特性:</p><ul class=""><li id="9600" class="kh ki hh jc b jd jx jh jy jl kj jp kk jt kl iz km kn ko kp bi translated">一行shell代码被解析为基于空格和引号的单词。带引号的字符串被视为单个单词。shell提供了两种类型的引号来控制这个过程。对于Python，我在设计时将命令解析成一个单词列表。我们不必使用复杂的引用规则。相反，我们提供单词列表。<strong class="jc hi"> <em class="kv"> APP_NAME </em> </strong>变量中有一个静态列表。文件名被附加到这个单词列表上。</li><li id="b371" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">shell代码的每一行都被处理成“glob”文件名。任何<strong class="jc hi"> <em class="kv"> * </em> </strong>都被用作通配符文件规范。要打败这个特性，我们必须给<strong class="jc hi"> <em class="kv"> * </em> </strong>加上引号。在Python中，我用对一个<strong class="jc hi"> <em class="kv"> Path </em> </strong>对象的<strong class="jc hi"> <em class="kv"> glob() </em> </strong>方法的显式调用替换了shell的隐式globbing。<a class="ae kw" href="https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.glob" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.glob </a></li><li id="9b98" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated">在shell中，<strong class="jc hi"> <em class="kv"> &gt; </em> </strong>和<strong class="jc hi"> <em class="kv"> &lt; </em> </strong>重定向操作符用于将打开的文件连接到要执行的程序。在Python中，我显式地打开了文件。然后，我可以将打开的文件连接传递给<strong class="jc hi"> <em class="kv"> check_call() </em> </strong>函数，以映射到子进程stdout。</li></ul><p id="b149" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这个转换将简洁的shell命令<strong class="jc hi"><em class="kv">$ APP $ filename&gt;" $ { output _ dir }/summary _ $ { name }。txt" </em> </strong>在Python中变成这样:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/c634118cf3ca30fa0f5bd6cacaf43acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-GQK50td_x-k-5tIPyOvQ.png"/></div></div></figure><p id="44ae" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">首先，我使用一个<strong class="jc hi"> <em class="kv">路径</em> </strong>和<strong class="jc hi"> <em class="kv"> / </em> </strong>操作符构建了目标文件名。然后，我从<strong class="jc hi"> <em class="kv"> APP_NAME </em> </strong>和要处理的路径中构建了一个单词列表命令。打开目标文件后，我运行了生成的命令，标准输出指向打开的文件。</p><p id="bf0f" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated"><em class="kv">“嘿，等一下，”</em>你可能会说。"你只是从另一个Python脚本运行一个Python程序."</p><p id="8a23" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">说得好。您已经确定了脚本重写的下一个级别。我们可以将这些步骤合并到一个复合应用程序中，该应用程序导入原始的<strong class="jc hi"><em class="kv">module _ design _ analytics</em></strong>应用程序。使用<strong class="jc hi"> <em class="kv"> runpy </em> </strong>模块从这个脚本内部运行应用程序也是明智的。这些都是重要的潜在优化。</p><h2 id="8a54" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">检查修改时间和复制文件</h2><p id="4d58" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">最后一步是复制一个比目标文件新的文件。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/14922fff60e478277c92331d4e7eb324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhpZ_QNKlCtiQPFLiy-ILw.png"/></div></div></figure><p id="5afb" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">shell使用<strong class="jc hi"><em class="kv">【file-nt file】</em></strong>来比较两个文件的修改时间。我用一个非常显式的操作来替换它，以获得每个文件的<strong class="jc hi"> <em class="kv"> os.stat() </em> </strong>结构。然后我对比了一下修改时间，在每个OS状态结构内叫做<strong class="jc hi"> <em class="kv"> st_mtime </em> </strong>。</p><p id="0317" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">文件复制通过<strong class="jc hi"> <em class="kv"> shutil </em> </strong>模块完成。这有一个<strong class="jc hi"> <em class="kv"> copy2() </em> </strong>函数来复制数据以及元数据。在<strong class="jc hi"> <em class="kv"> shutil </em> </strong>模块中有替代方法，可以对如何处理元数据提供更多的控制。</p><h2 id="ca2c" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">进口货</h2><p id="a3fc" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">以下是该脚本导入的模块列表:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/4268b70b4acdf8e9a1cade0218813262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1wSJHe7gpVmCR2H-edtPQ.png"/></div></div></figure><p id="d159" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在某些情况下(即<strong class="jc hi"> <em class="kv"> datetime </em> </strong>，<strong class="jc hi"> <em class="kv"> shutil </em> </strong>)，我使用了整个模块。在其他情况下(即<strong class="jc hi"> <em class="kv"> pathlib </em> </strong>，<strong class="jc hi"> <em class="kv">子进程</em> </strong>)，我只导入了必要的特定类、函数或异常。我这样做是为了展示这两种风格。当一个类似<strong class="jc hi"> <em class="kv"> check_call() </em> </strong>的函数被导入时，那么这个名字就不需要任何限定。当一个像shutil这样的模块被导入时，这个函数需要这个模块作为一个明确的名称空间限定:shutil.copy2()。每种风格都有充分的理由。</p><p id="3e23" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">psutil不是标准库的一部分。它必须单独安装。</p><h2 id="79a1" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">测试</h2><p id="bf13" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">一旦有了一些——据称是——有效的代码，下一步就是创建单元测试。让测试驱动开发是一个很好的实践。理想情况下，我们会在shell脚本中为四个高级功能步骤编写单元测试。当我们不确定我们知道一个给定步骤所做的与后续步骤相关的所有事情时，这个理想很难实现。有很多全球性的共享状态需要理解。</p><p id="dfab" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">如果我们使用Python而不是shell，那么我们就有从头开始的优势。我们可以使用测试优先的开发技术。</p><p id="b51d" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">无论哪种情况，模拟我们的Python应用程序将要接触的操作系统级资源都是必不可少的。为此，我使用了<strong class="jc hi"> <em class="kv"> unittest.mock </em> </strong>库。为了构建合适的模拟对象，查看代码会有所帮助。一些测试专家称之为“白盒”测试，因为我正在为被测软件裁剪模拟对象。</p><p id="bba3" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">下面是对我们脚本的一个功能的代表性测试。这将测试<strong class="jc hi"><em class="kv">copy _ to _ current()</em></strong>函数的一个修改时间关系:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/a7a556faef848a90ce89ae9c562aad7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3rZgKEk_2LN1K5slYVpqA.png"/></div></div></figure><p id="f958" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">测试导入要测试的脚本；它有着<strong class="jc hi"> <em class="kv"> script.py </em> </strong>这个毫无想象力的名字。我对脚本执行的名称空间应用了两个补丁。</p><ul class=""><li id="8411" class="kh ki hh jc b jd jx jh jy jl kj jp kk jt kl iz km kn ko kp bi translated"><strong class="jc hi"> <em class="kv"> shutil </em> </strong>的导入被一个<strong class="jc hi"> <em class="kv"> Mock </em> </strong>对象替换。</li><li id="7559" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated"><strong class="jc hi">T21【pathlib】的导入。路径 </strong>被替换为<strong class="jc hi"> <em class="kv">嘲弄</em> </strong>对象，也是如此。</li></ul><p id="9302" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这两个模拟对象都成为测试函数的参数，所以我可以使用它们。当有多个<strong class="jc hi"><em class="kv">@ patch</em></strong>decorator时，注意参数名从内到外的排序。这是Python应用装饰器规则的结果。</p><p id="5d3c" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我还为<strong class="jc hi"> <em class="kv"> result_path </em> </strong>参数创建了一个mock，并将其赋给变量<strong class="jc hi"><em class="kv">mock _ result _ path</em></strong>。在这种情况下，我不是修补导入的名称，而是为函数提供一个参数。</p><p id="0944" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">测试中的函数使用如下代码</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/f195c465036cd4f8fbc8ef63af45edd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELSnRPYd1jt9pK_FyLD8Bw.png"/></div></div></figure><p id="8e3a" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">为了确保这将工作，我创建了一个<strong class="jc hi"> <em class="kv">统计</em> </strong>属性。这是一个带有<strong class="jc hi"> <em class="kv">返回值</em> </strong>的<strong class="jc hi"> <em class="kv">模拟</em> </strong>。返回值是一个带有<strong class="jc hi"> <em class="kv"> st_mtime </em> </strong>属性的<strong class="jc hi"> <em class="kv"> Mock </em> </strong>。我模仿了被测试代码所使用的行为。</p><p id="1a2e" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated"><strong class="jc hi"> <em class="kv"> mock_path </em> </strong>参数是<strong class="jc hi"> <em class="kv"> Path </em> </strong>类定义的替代。测试中的函数将使用如下代码:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/11ed14a21873ef0a35b5496675db4af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ut-VyuiU6LrameyQRYRddQ.png"/></div></div></figure><p id="d068" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我们期望模拟<strong class="jc hi"> <em class="kv">路径</em> </strong>将被评估一次以创建一个<strong class="jc hi"> <em class="kv">路径</em> </strong>对象。函数调用的默认行为是创建一个<strong class="jc hi"> <em class="kv">模拟</em> </strong>对象。测试可以用<strong class="jc hi"><em class="kv">mock _ path . return _ value</em></strong>引用创建的mock。根据被测代码，返回的<strong class="jc hi"> <em class="kv"> Mock </em> </strong>对象必须有一个<strong class="jc hi"> <em class="kv"> stat() </em> </strong>函数，该函数的结果必须有一个<strong class="jc hi"> <em class="kv"> st_mtime </em> </strong>属性。</p><p id="09b7" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">在这个测试语境下评价<strong class="jc hi"><em class="kv">script . copy _ to _ current()</em></strong>的时候，我有一堆期待。最重要的一个是<strong class="jc hi"> <em class="kv"> shutil.copy2 </em> </strong>会被调用。我将这一期望形式化为:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/ecff0893a16bf441d200abaf3e775b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6Hdm-QjnfW4wJiCkVQAeQ.png"/></div></div></figure><p id="1a80" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我也有兴趣确认每个参数调用了<strong class="jc hi"> <em class="kv"> stat() </em> </strong>方法。我可以把这个作为一个断言来补充。</p><p id="18a4" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">这里的要点是添加具有不同时间戳关系的测试来测试其他行为。<strong class="jc hi"> <em class="kv"> py.test </em> </strong>包可以找到并运行这些测试，因为它们有一致的名称模式。</p><h2 id="845f" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">后续步骤</h2><p id="95e2" class="pw-post-body-paragraph ja jb hh jc b jd ls jf jg jh lt jj jk jl lu jn jo jp lv jr js jt lw jv jw iz ha bi translated">当然，我们还没完。我还没有真正谈到日志或配置。这个脚本使用外部环境变量吗？一个配置文件？命令行参数？</p><p id="41d7" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">一些shell脚本使用<strong class="jc hi"> <em class="kv"> getopt </em> </strong>命令来解析选项。其他shell脚本使用<strong class="jc hi"> <em class="kv"> $0 </em> </strong>，<strong class="jc hi"> <em class="kv"> $1 </em> </strong>等。，以收集位置参数。这些特性中有很多可能被隐藏在脚本中，这使得发现脚本的真正用途和预期用途变得很困难。</p><p id="3e36" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">此外，还有另一轮优化的可能。如上所述，这个脚本运行一个Python程序。将应用程序和脚本组合成复合应用程序可能是合适的。</p><h2 id="c6f8" class="kx ky hh bd kz la lb lc ld le lf lg lh jl li lj lk jp ll lm ln jt lo lp lq lr bi translated">结论</h2><blockquote class="ip"><p id="9c39" class="iq ir hh bd is it kc kd ke kf kg iz dx translated">shell是一个原始的编程环境。它工作得很好，但是它不是一种非常复杂的语言。我认为这是一套1970年的休闲西装，可能由双面针织聚酯制成，带有对比鲜明的顶部缝线。你知道——约会。绝对不适合攀岩或者去海滩玩。</p></blockquote><p id="8749" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw iz ha bi translated">两个最大的问题是缺乏有用的数据结构和单元测试的困难。</p><p id="16cb" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我们不需要取消所有对外壳的使用。但是我们可以受益于将shell的使用减少到它特别擅长的几件事情上。我喜欢将shell脚本简化为几行代码，用来设置环境变量、建立当前工作目录和运行目标程序。</p><p id="9211" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">我们想要做的是用编程语言编写的代码取代复杂的外壳脚本，这种编程语言为我们提供了一系列丰富的数据结构。在许多情况下，我们可以找到大块的shell代码来进行计算，这是Python等编程语言的一个简单的内置特性。</p><p id="0cdb" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated">转向Python意味着我们可以利用更智能的数据结构。我们可以用一种摆脱字符串处理的方式来处理数字和日期。最精彩的部分？我们可以编写单元测试。对shell脚本的一个小改动不会破坏东西。相反，它会像应用程序的其他部分一样接受测试。我们可以满怀信心地将它投入生产，相信它会真正发挥作用。</p></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><p id="1a7c" class="pw-post-body-paragraph ja jb hh jc b jd jx jf jg jh jy jj jk jl jz jn jo jp ka jr js jt kb jv jw iz ha bi translated"><strong class="jc hi"> <em class="kv">声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2017首都一。</em> </strong></p><h1 id="acc9" class="mu ky hh bd kz mv mw mx ld my mz na lh nb nc nd lk ne nf ng ln nh ni nj lq nk bi translated">相关职位</h1><ul class=""><li id="b95f" class="kh ki hh jc b jd ls jh lt jl nl jp nm jt nn iz km kn ko kp bi translated"><a class="ae kw" rel="noopener" href="/capital-one-developers/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792">自动化NoSQL数据库构建</a></li><li id="1426" class="kh ki hh jc b jd kq jh kr jl ks jp kt jt ku iz km kn ko kp bi translated"><a class="ae kw" rel="noopener" href="/capital-one-developers/nosql-database-doesnt-mean-no-schema-a824d591034e"> NoSQL数据库并不意味着没有模式</a></li></ul></div></div>    
</body>
</html>