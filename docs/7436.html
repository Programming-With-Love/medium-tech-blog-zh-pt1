<html>
<head>
<title>Exploring the Machine Learning Model Lifecycle with Databricks and MLflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Databricks和MLflow探索机器学习模型的生命周期</h1>
<blockquote>原文：<a href="https://medium.com/version-1/exploring-the-machine-learning-model-lifecycle-with-databricks-and-mlflow-b7f82aad6fd7?source=collection_archive---------0-----------------------#2020-11-05">https://medium.com/version-1/exploring-the-machine-learning-model-lifecycle-with-databricks-and-mlflow-b7f82aad6fd7?source=collection_archive---------0-----------------------#2020-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/752ee331d2dcee27104cd61c5d483f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wY6X4Qe48ity0OXi"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="caf2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">开发和管理机器学习模型与传统的软件开发有很大的不同，也更加困难。挑战不仅出现在开发阶段，也出现在开发的生产阶段。这篇中期文章将探索机器学习模型周期以及我在使用这些模型时遇到的一些关键差异。</p><p id="de13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">传统软件和机器学习在开发阶段的差异可以概括为我们试图实现的目标、影响我们质量的因素以及我们使用的工具。</p><h1 id="cbb1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">主要差异</h1><p id="8733" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated"><strong class="iw hi">目标:</strong>传统软件开发的目标是满足规范，功能性的和非功能性的，确认一个应用是否满足需求是很直接的。在机器学习中，目标是随着时间的推移改善模型指标，因为模型性能的退化或改善意味着企业的损失或收益。这也意味着模型是不断变化的，永远不会真正完成- <strong class="iw hi">一个移动的目标。</strong></p><p id="240e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">质量</strong>:软件开发中的产品或应用的质量很大程度上取决于所产生的代码的质量。对于机器学习开发，质量取决于输入和训练数据，以及需要根据可用数据进行调整的超参数。</p><p id="5c51" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在软件开发中，团队通常会挑选一个添加了库的软件栈来实现目标。对于机器学习开发，几个堆栈、模型和算法可以组合成一个解决方案。深度学习栈可以与传统的ML库以及不同的语言相结合。</p><p id="e5f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">生产挑战:</strong>机器学习的生产挑战在产品上线后并没有减少，主要挑战与新数据、开发流程和模型生命周期的复杂性有关。</p><p id="bdee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">数据:</strong>机器学习的本质需要历史数据，随着时间的推移，数据也需要历史数据。一段时间后，积累的新数据成为历史数据，作为新数据获取的结果，产品面临着过时的风险，需要重新构建模型。</p><p id="e97c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与传统的软件开发相比，只要没有人接触它或更新它所依赖的系统，产品就会工作——产品的稳定性很少受到质疑。</p><p id="937b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">过程:</strong>开发机器学习模型的过程是一个复杂的过程，涉及几个具有不同技能的人。模型的设计由数据科学家管理，数据准备由数据工程师监督，最终产品的开发由应用程序开发人员处理。开发传统软件开发的过程通常由具有相似技能的同质开发人员组来处理。</p><h1 id="57aa" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">模型生命周期</h1><p id="64fb" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在机器学习模型管理中存在独特的挑战，例如结果和代码库修改控制的一致性、模型谱系、模型度量、超参数优化和模型分级。</p><p id="0bfc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在运行期间，我们需要运行的一致结果，以及运行和修改的历史记录。有了模型谱系，我们需要保持一个模型版本化系统，并将模型的版本化与模型产生的度量联系起来。希望存储用于记录和用于进一步自动化和分析的超参数。此外，我们希望对所有提到的功能进行编程访问，并在没有人工干预的情况下，在我们的代码中执行从测试到生产的模型阶段。</p><h1 id="9e4e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">ML管理平台</h1><p id="71cb" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">几年来，出现了许多ML管理平台来解决上述问题。有一些产品，如Airflow和Luigi，是通用的编排平台，还有一些更专业的平台，如Kuberflow和MLflow，专门从事机器学习编排。下一节将重点介绍Databricks和MLflow的结合，以及它们可能带来的好处。</p><h1 id="549c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">实验管理</h1><p id="619a" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated"><strong class="iw hi"> MLflow </strong>的支柱之一是实验跟踪。通过Databricks集成到Azure中，这允许我们记录和查询实验，管理代码库中的更改，跟踪输入数据，比较消耗的参数，发出的度量和产生的结果。</p><p id="31c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该组件允许我们跟踪实验执行、用于实验的超参数、产生的度量模型和实验产生的模型。我们可以用图形或编程的方式跟踪变化，也可以用编程的方式访问这个概念的所有属性。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/bd267802f733a36271bf754091b6209a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*bTXeIq1XT-bhY8xhDNLAxA.png"/></div></figure><p id="3983" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统的这一部分允许我们跟踪代码的版本，以及谁何时修改了代码，并允许我们在需要时恢复到所需的版本。代码库不存储在外部，对代码库的访问由Databricks和Azure security管理。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es la"><img src="../Images/5958f40433a9f8d33f5e2db3a0a5ad48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*h8XfbE8rRLDdf4LLGpHAcw.png"/></div></figure><p id="9160" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统的这一部分允许我们手动管理模型，我们可以根据指标比较模型，管理模型是否投入生产。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lb"><img src="../Images/87dc2c99ec10b83a743c1a72149805b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*0jhndFyiWGG7lyx9hJjW2w.png"/></div></figure><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/e111069988aad1fee3080e642d9c3146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*dXwl37L5V5tucV23Ev8KdA.png"/></div></figure><p id="aba7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在系统的这一部分，我们可以比较实验运行，并以编程方式手动评估哪些运行良好，哪些运行不良。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/a27f526972e1bb287c605af26a4faeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*8Z-8mBPtq9fYondNr8vVcw.png"/></div></figure><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/f40258ef3e34f2c6647d9fc34ae23e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*C8nnHBMY4m8_nlBJjbhiWA.png"/></div></figure><p id="7167" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">适用于系统的所有部分，所有功能、访问、修改和比较都可以在其他笔记本中以编程方式完成。</p><h1 id="c968" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">可重复执行</h1><p id="0bcb" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">MLflow的第二个支柱是引入一种以可重用方式打包数据科学代码的格式。其核心是定义良好的元数据，用于组织和描述代码，以允许自动化工具运行代码。该组件包括用于多种语言的API以及CLI接口，因此可以作为一个协调器将多个项目链接在一起。所有这些的潜在信息是，MLflow和Databricks构建了一种从Git repo获取代码和工件并在Databricks上运行它的简单方法。</p><h1 id="d71f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">模型包装</h1><p id="4a9e" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">目前很多机器学习库的厂商，比如TensorFlow，Sklearn，Spark等。使用专有格式存储数据。如果您不使用不同的框架来寻找最佳模型，这种方法可以很好地工作。然而，一旦使用不同的机器学习堆栈，互操作性的问题就会出现。为了减轻这一点，MLflow创建了一个包装器格式，支持大多数供应商和模型的抽象内部表示，以支持更通用的MLflow风格。在模型部署和生命周期的工业化道路上，模型表示的抽象是一个非常宝贵的举措，因为一周内我们可能会让Sklearn模式产生合理的结果，然后过一段时间，TensorFlow可能会产生更好的结果，但对于模型中的其他应用程序和产品更改变得透明和模型不可知。</p><h1 id="4cbf" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="5e6f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Azure、Databricks和MLflow的结合提供了一个出色的框架和一套工具来管理机器学习项目的许多方面，特别是模型生命周期的管理。总结Azure、Databricks和MLflow共生的可用功能:</p><p id="ae2a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">代码版本</strong> —集成到笔记本中的代码版本。</p><p id="f3f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">实验运行跟踪</strong>——实验持续存在并可搜索。</p><p id="f551" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">超参数跟踪</strong> —系统跟踪模型参数。</p><p id="10f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">模型指标跟踪</strong> —由系统跟踪的模型发出的指标。</p><p id="7cea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">模型跟踪</strong> —系统跟踪实验产生的模型。</p><p id="02f5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">程序化访问</strong> —我们可以程序化访问以上所有内容。</p><p id="9efe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">支持MLOps</strong>—允许协调多个项目。</p><p id="7f47" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">与格式无关的模型</strong> —生产的模型与供应商格式无关。</p><p id="505e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也许这三者的一个缺点是，Databricks和Azure是一个纯云解决方案，对一些人来说，这不是一个选项。然而，MLflow能够安装在Kubernetes和OpenShift平台上。</p><p id="f7db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这三者的第二个缺点是价格，如果你不小心使用它，成本会很快上升。幸运的是，Databricks中有自动关闭功能，允许您在特定的空闲时间后关闭集群。</p><p id="f6d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，要实现上面框架中现有的实验和模型跟踪功能，需要付出很大的努力。考虑到本概述只涉及了环境和可用功能的某些方面，可以肯定地说，这是一个值得投入时间的好产品。</p><p id="1c2b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">关于作者</strong></p><p id="50c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="le">亚历山大·苏沃罗夫是一名高级数据科学家和高级开发人员，自2019年以来一直在Version 1创新实验室工作。</em></p></div></div>    
</body>
</html>