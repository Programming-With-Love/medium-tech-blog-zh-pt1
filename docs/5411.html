<html>
<head>
<title>Get going with Project Fn on a remote Kubernetes Cluster from a Windows laptop–using Vagrant, VirtualBox, Docker, Helm and kubectl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Windows笔记本电脑的远程Kubernetes集群上开始使用Project Fn——使用vagger、VirtualBox、Docker、Helm和kubectl</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/get-going-with-project-fn-on-a-remote-kubernetes-cluster-from-a-windows-laptop-using-vagrant-2fd27489a2d9?source=collection_archive---------0-----------------------#2018-03-04">https://medium.com/oracledevs/get-going-with-project-fn-on-a-remote-kubernetes-cluster-from-a-windows-laptop-using-vagrant-2fd27489a2d9?source=collection_archive---------0-----------------------#2018-03-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/00952a65822f38a7996ac1bec7af291f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ep2xPcrNnLOlsmac."/></div></div></figure><p id="6acb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在本文中描述的挑战非常具体。我有一台Windows笔记本电脑。我可以访问远程Kubernetes集群(在Oracle云基础设施上)。我想创建Fn函数，并将它们部署到运行在Kubernetes(从现在开始是k8s)环境中的Fn服务器上，并且希望能够从我的笔记本电脑上执行运行在k8s上的函数。就是这样。</p><p id="0de1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将带您快速浏览一下我是如何实现这一点的:</p><ul class=""><li id="bfee" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">使用vagger来启动一个基于Debian Linux镜像的VirtualBox虚拟机，并安装Docker服务器。使用SSH进入虚拟机并安装Helm(一个Kubernetes包安装程序)——客户机(在VM中)和服务器(在k8s集群上称为Tiller)。还要在VM中安装kubectl。</li><li id="df76" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">然后在虚拟机中安装项目Fn。还将Fn安装到Kubernetes集群，使用Fn的Helm图表(这将创建一系列组成和运行Fn平台的Pods和服务)。</li><li id="9538" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">仍然在VM内部，创建一个新的Fn函数。然后，将这个函数部署到Kubernetes集群上的Fn服务器。从VM内部运行该函数——使用kubectl为本地调用到Kubernetes集群的请求设置端口转发。</li><li id="a9d9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">在Windows主机(笔记本电脑，在VM之外)上，我们还可以运行带有端口转发的kubectl，并在Kubernetes集群上调用Fn函数。</li><li id="e4a5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">最后，我将展示如何在外部IP地址上公开Kubernetes服务中的fn-api服务。注意:后者对于演示来说很好，但是在很大程度上牺牲了安全性。</li></ul><p id="3b4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总之，您将看到如何创建、部署和调用Fn函数——使用Windows笔记本电脑和远程Kubernetes集群作为函数的运行时环境。</p><p id="6a9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">起点:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/739f7f8fc44cb2c268dc40d244788c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XPTnHSY9LVXqvDRd."/></div></div></figure><p id="3ed7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一台运行Windows的笔记本电脑，安装了VirtualBox和vagger，还有一个远程的Kubernetes集群(可能在某个云端，比如我正在使用的Oracle容器引擎云，也可能是minikube)。</p><h1 id="c51c" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第一步:准备虚拟机</h1><p id="5047" class="pw-post-body-paragraph ip iq hh ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">创建一个流浪者文件——比如这个:<a class="ae li" href="https://github.com/lucasjellema/fn-on-kubernetes-from-docker-in-vagrant-vm-on-windows/blob/master/vagrantfile" rel="noopener ugc nofollow" target="_blank">https://github . com/lucasjellema/fn-on-kubernetes-from-docker-in-vagger-VM-on-windows/blob/master/vagger file</a>:</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="f408" class="lo kg hh lk b fi lp lq l lr ls">Vagrant.configure("2") do |config|<br/>  <br/>config.vm.provision "docker"</span><span id="2836" class="lo kg hh lk b fi lt lq l lr ls">config.vm.define "debiandockerhostvm"<br/># <a class="ae li" href="https://app.vagrantup.com/debian/boxes/jessie64" rel="noopener ugc nofollow" target="_blank">https://app.vagrantup.com/debian/boxes/jessie64</a><br/>config.vm.box = "debian/jessie64"<br/>config.vm.network "private_network", ip: "192.168.188.105"</span><span id="df45" class="lo kg hh lk b fi lt lq l lr ls">config.vm.synced_folder "./", "/vagrant", id: "vagrant-root",<br/>       owner: "vagrant",<br/>       group: "www-data",<br/>       mount_options: ["dmode=775,fmode=664"],<br/>       type: ""<br/>         <br/>config.vm.provider :virtualbox do |vb|<br/>   vb.name = "debiananddockerhostvm"<br/>   vb.memory = 4096<br/>   vb.cpus = 2<br/>   vb.customize ["modifyvm", :id, "--natdnshostresolver1","on"]<br/>   vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]<br/>end<br/>  <br/>end</span></pre><p id="cd8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个流浪文件将使用VirtualBox创建一个名为<em class="lu"> debiandockerhostvm </em>的虚拟机——基于VirtualBox镜像debian/jessie64。它将虚拟机暴露给IP地址为192.168.188.105的主机笔记本电脑(您可以安全地对此进行更改)。它将包含travel file的本地目录映射到VM中的/travel。这使得我们可以轻松地在Windows主机和Debian Linux虚拟机之间交换文件。指令“config . VM . provision”docker“”确保Docker被安装到虚拟机中。</p><p id="a1ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要实际创建VM，请打开一个命令行，并导航到包含该流浪者文件的目录。然后输入“向上流浪”。vagger开始运行并创建虚拟机，与VirtualBox APIs进行交互。创建虚拟机时，它会启动。</p><p id="579b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在同一个命令行中，使用“vagger ssh ”,您现在可以在VM中打开一个终端窗口。</p><p id="e14c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了进一步准备VM，我们需要安装Helm和kubectl。Helm安装在VM(客户机)和Kubernetes集群(Tiller服务器组件)中。</p><p id="277c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是在虚拟机内部执行的步骤(参见<a class="ae li" href="http://https//github.com/lucasjellema/fn-on-kubernetes-from-docker-in-vagrant-vm-on-windows/blob/master/step1-prepare-VM" rel="noopener ugc nofollow" target="_blank">步骤1 </a>):</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="d16e" class="lo kg hh lk b fi lp lq l lr ls">######## kubectl</span><span id="74aa" class="lo kg hh lk b fi lt lq l lr ls"># download and extract the kubectl binary <br/>curl -LO <a class="ae li" href="https://storage.googleapis.com/kubernetes-release/release/$(curl" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/kubernetes-release/release/$(curl</a> -s <a class="ae li" href="https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</a></span><span id="5aeb" class="lo kg hh lk b fi lt lq l lr ls"># set the executable flag for kubectl<br/>chmod +x ./kubectl</span><span id="c1a4" class="lo kg hh lk b fi lt lq l lr ls"># move the kubectl executable to the bin directory<br/>sudo mv ./kubectl /usr/local/bin/kubectl</span><span id="ff85" class="lo kg hh lk b fi lt lq l lr ls"># assuming that the kubeconfig file with details for Kubernetes cluster is available On the Windows Host:<br/># Copy the kubeconfig file to the directory that contains the Vagrantfile and from which vagrant up and vagrant ssh were performed<br/># note: this directory is mapped into the VM to directory /vagrant</span><span id="8046" class="lo kg hh lk b fi lt lq l lr ls">#Then in VM - set the proper Kubernetes configuration context: <br/>export KUBECONFIG=/vagrant/kubeconfig</span><span id="34ef" class="lo kg hh lk b fi lt lq l lr ls">#now inspect the succesful installation of kubectl and the correct connection to the Kubernetes cluster <br/>kubectl cluster-info</span><span id="dccb" class="lo kg hh lk b fi lt lq l lr ls">########  HELM<br/>#download the Helm installer<br/>curl -LO  <a class="ae li" href="https://kubernetes-helm.storage.googleapis.com/helm-v2.8.1-linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://kubernetes-helm.storage.googleapis.com/helm-v2.8.1-linux-amd64.tar.gz</a></span><span id="ab6c" class="lo kg hh lk b fi lt lq l lr ls">#extract the Helm executable from the archive<br/>tar -xzf helm-v2.8.1-linux-amd64.tar.gz</span><span id="9c0c" class="lo kg hh lk b fi lt lq l lr ls">#set the executable flag on the Helm executable<br/>sudo chmod +x  ./linux-amd64/helm</span><span id="1866" class="lo kg hh lk b fi lt lq l lr ls">#move the Helm executable to the bin directory - as helm<br/>sudo mv ./linux-amd64/helm /usr/local/bin/helm</span><span id="543b" class="lo kg hh lk b fi lt lq l lr ls">#test the successful installatin of helm<br/>helm version</span><span id="3d91" class="lo kg hh lk b fi lt lq l lr ls">###### Tiller</span><span id="9322" class="lo kg hh lk b fi lt lq l lr ls">#Helm has a server side companion, called Tiller, that should be installed into the Kubernetes cluster<br/># this is easily done by executing:<br/>helm init</span><span id="c13a" class="lo kg hh lk b fi lt lq l lr ls"># an easy test of the Helm/Tiller set up can be run (as described in the quickstart guide)<br/>helm repo update</span><span id="8290" class="lo kg hh lk b fi lt lq l lr ls">helm install stable/mysql</span><span id="a0d9" class="lo kg hh lk b fi lt lq l lr ls">helm list</span><span id="1250" class="lo kg hh lk b fi lt lq l lr ls"># now inspect in the Kubernetes Dashboard the Pod that should have been created for the MySQL Helm chart</span><span id="21db" class="lo kg hh lk b fi lt lq l lr ls"># clean up after yourself:<br/>helm delete &lt;name of the release of MySQL&gt;</span></pre><p id="df3e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完成这一步后，环境如下所示:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8e300f6ac22d57218e7414e57acc368e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hpx-JVrOVWmEbeuw."/></div></div></figure><h1 id="819d" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第二步:在VM和Kubernetes上安装项目Fn</h1><p id="8fe4" class="pw-post-body-paragraph ip iq hh ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">既然我们已经准备好了我们的虚拟机，我们可以继续将Project Fn命令行实用程序添加到虚拟机，并将Fn平台添加到Kubernetes集群。前者是简单的二进制文件的本地安装。后者是一个更简单的舵图安装。以下是您应该在虚拟机内部完成的步骤(另请参见<a class="ae li" href="https://github.com/lucasjellema/fn-on-kubernetes-from-docker-in-vagrant-vm-on-windows/blob/master/step2-install-fn" rel="noopener ugc nofollow" target="_blank">步骤2 </a>):</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="d60a" class="lo kg hh lk b fi lp lq l lr ls"># 1A. download and install Fn locally inside the VM<br/>curl -LSs <a class="ae li" href="https://raw.githubusercontent.com/fnproject/cli/master/install" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/fnproject/cli/master/install</a> | sh</span><span id="02d5" class="lo kg hh lk b fi lt lq l lr ls">#note: this previous statement failed for me; I went through the following steps as a workaround<br/># 1B. create install script<br/>curl -LSs <a class="ae li" href="https://raw.githubusercontent.com/fnproject/cli/master/install" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/fnproject/cli/master/install</a> &gt; inst<br/>all.sh<br/># make script executable<br/>chmod u+x install.sh<br/># execute script - as sudo<br/>sudo ./install.sh</span><span id="e3cd" class="lo kg hh lk b fi lt lq l lr ls"># 1C. and if that fails, you can manually manipulate the downloaded executable:<br/>sudo mv /tmp/fn_linux /usr/local/bin/fn<br/>sudo chmod +x /usr/local/bin/fn</span><span id="6172" class="lo kg hh lk b fi lt lq l lr ls"># 2. when the installation was done through one of the  methods listed, test the success by running  <br/>fn --version</span><span id="d2cb" class="lo kg hh lk b fi lt lq l lr ls"># 3. Server side installation of Fn to the Kubernetes Cluster<br/># details in <a class="ae li" href="https://github.com/fnproject/fn-helm" rel="noopener ugc nofollow" target="_blank">https://github.com/fnproject/fn-helm</a></span><span id="f8b8" class="lo kg hh lk b fi lt lq l lr ls"># Clone the GitHub repo with the Helm chart for fn; sources are downloaded into the fn-helm directory<br/>git clone <a class="ae li" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:fnproject/fn-helm.git &amp;&amp; cd fn-helm</span><span id="b82b" class="lo kg hh lk b fi lt lq l lr ls"># Install chart dependencies from requirements.yaml in the fn-helm directory:<br/>helm dep build fn</span><span id="d150" class="lo kg hh lk b fi lt lq l lr ls">#To install the Helm chart with the release name my-release into Kubernetes:<br/>helm install --name my-release fn</span><span id="71ae" class="lo kg hh lk b fi lt lq l lr ls"># to verify the cluster server side installation you could run the following statements:<br/>export KUBECONFIG=/vagrant/kubeconfig</span><span id="d2a2" class="lo kg hh lk b fi lt lq l lr ls">#list all pods for app my-release-fn<br/>kubectl get pods --namespace default -l "app=my-release-fn"</span></pre><p id="e45a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Fn安装完成后，可以看到如下所示的环境:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ffee702ec580b9eafc8a760a4d6d951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T-BxvQqmUC8f5uJQ."/></div></div></figure><p id="0933" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在Kubernetes仪表板中查看从舵图表中创建了什么:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5197df8b20eed8c9ff1943609b49a15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E0QOys3wHhEPIg5K."/></div></div></figure><p id="a9e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者在命令行上:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7d961a1c2f5ab40a5e928e9e983e54a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZ3cOYxplOm4Teng."/></div></div></figure><h1 id="9728" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第三步:创建、部署和运行Fn函数</h1><p id="5195" class="pw-post-body-paragraph ip iq hh ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我们现在有了一个准备运行的环境—客户端VM和服务器端Kubernetes集群—用于创建Fn功能—并随后部署和调用它们。</p><p id="644c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们来看一下这三个步骤，首先在Node中创建一个名为shipping-costs的新函数。</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="62a9" class="lo kg hh lk b fi lp lq l lr ls">docker login</span><span id="b429" class="lo kg hh lk b fi lt lq l lr ls">export FN_REGISTRY=lucasjellema</span><span id="1090" class="lo kg hh lk b fi lt lq l lr ls">mkdir shipping-costs</span><span id="ea3e" class="lo kg hh lk b fi lt lq l lr ls">cd shipping-costs</span><span id="f37d" class="lo kg hh lk b fi lt lq l lr ls">fn init --name shipping-costs --runtime  node</span><span id="3b10" class="lo kg hh lk b fi lt lq l lr ls"># this creates the starting point of the Node application (package.json and func.js) as well as the Fn meta data file (func.yaml)</span><span id="f77c" class="lo kg hh lk b fi lt lq l lr ls"># now edit the func.js file (and add dependencies to package.json if necessary)</span><span id="c428" class="lo kg hh lk b fi lt lq l lr ls">#The extremely simple implementation of func.js looks like this:<br/>var fdk=require('<a class="ae li" href="http://twitter.com/fnproject/fdk" rel="noopener ugc nofollow" target="_blank">@fnproject/fdk</a>');</span><span id="f957" class="lo kg hh lk b fi lt lq l lr ls">fdk.handle(function(input){<br/>  var name = 'World';<br/>  if (input.name) {<br/>    name = input.name;<br/>  }<br/>  response = {'message': 'Hello ' + name, 'input':input}<br/>  return response<br/>})</span><span id="6f8c" class="lo kg hh lk b fi lt lq l lr ls">#This function receives an input parameter (from a POST request this would be the body contents, typically a JSON document)<br/># the function returns a result, a JSON document with the message and the input document returned in its entirety</span></pre><p id="a98e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一步之后，该函数存在于VM中——而不是其他任何地方。Kubernetes上的Fn平台可能已经部署了其他一些功能。</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ba76d6668a0fd1ff0d48427b35002902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ua9Y-S8OskDg-aG1."/></div></div></figure><p id="6f61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个功能shipping-costs现在应该部署到K8S集群，因为这是我们的主要目标之一。</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="002c" class="lo kg hh lk b fi lp lq l lr ls">export KUBECONFIG=/vagrant/kubeconfig</span><span id="2b94" class="lo kg hh lk b fi lt lq l lr ls"># retrieve the name of the Pod running the Fn API<br/>kubectl get pods --namespace default -l "app=my-release-fn,role=fn-service" -o jsonpath="{.items[0].metadata.name}"</span><span id="c043" class="lo kg hh lk b fi lt lq l lr ls"># retrieve the name of the Pod running the Fn API and assign to environment variable POD_NAME<br/>export POD_NAME=$(kubectl get pods --namespace default -l "app=my-release-fn,role=fn-service" -o jsonpath="{.items[0].metadata.name}")<br/>echo $POD_NAME</span><span id="a401" class="lo kg hh lk b fi lt lq l lr ls"># set up kubectl port-forwarding; this ensures that any local requests to port 8080 are forwarded by kubectl to the pod specified in this command, on port 80<br/># this basically creates a shortcut or highway from the VM right into the heart of the K8S cluster; we can leverage this highway for deployment of the function<br/>kubectl port-forward --namespace default $POD_NAME 8080:80 &amp;</span><span id="bb00" class="lo kg hh lk b fi lt lq l lr ls">#now we inform Fn that deployment activities can be directed at port 8080 of the local host, effectively to the pod $POD_NAME on the K8S cluster<br/>export FN_API_URL=<a class="ae li" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a><br/>export FN_REGISTRY=lucasjellema<br/>docker login</span><span id="2370" class="lo kg hh lk b fi lt lq l lr ls">#perform the deployment of the function from the directory that contains the func.yaml file<br/>#functions are organized in applications; here the name of the application is set to soaring-clouds-app<br/>fn deploy --app soaring-clouds-app</span></pre><p id="85aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是部署在虚拟机终端窗口中的样子。(我省略了步骤:docker登录、设置FN_API_URL和设置FN_REGISTRY</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/913e7742daa222f767c42f6902c62de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1_wrDGQobKF1iQiS."/></div></div></figure><p id="c032" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在部署了函数shipping-costs之后，它现在存在于Kubernetes集群上——在fn-api Pod中(其中每个函数都运行一个docker容器):</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a88778709d9efe1caf29fcdca9bced7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bEcPMObTx1YTGzx0."/></div></div></figure><p id="cbc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要调用这些函数，有几个选项可用。可以从VM内部调用该函数，使用cURL到函数的端点——像以前一样利用kubectrl端口转发。我们还可以在笔记本电脑上应用kubectl端口转发——并使用任何可以调用HTTP端点的工具——比如Postman——来调用该函数。</p><p id="65d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们希望没有kubectl端口转发的客户机——甚至完全不了解Kubernetes集群——调用这个函数，也可以通过在K8S上为fn-api的服务公开一个外部IP来实现。</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0525719db9c96f9d66fb2c7a68d38b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mv6Krc5HmpYMmfTc."/></div></div></figure><p id="7f4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，让我们从VM中调用函数。</p><pre class="kb kc kd ke fd lj lk ll lm aw ln bi"><span id="416b" class="lo kg hh lk b fi lp lq l lr ls">export KUBECONFIG=/vagrant/kubeconfig</span><span id="35d2" class="lo kg hh lk b fi lt lq l lr ls"># retrieve the name of the Pod running the Fn API<br/>kubectl get pods --namespace default -l "app=my-release-fn,role=fn-service" -o jsonpath="{.items[0].metadata.name}"</span><span id="5166" class="lo kg hh lk b fi lt lq l lr ls"># retrieve the name of the Pod running the Fn API and assign to environment variable POD_NAME<br/>export POD_NAME=$(kubectl get pods --namespace default -l "app=my-release-fn,role=fn-service" -o jsonpath="{.items[0].metadata.name}")<br/>echo $POD_NAME</span><span id="1a4b" class="lo kg hh lk b fi lt lq l lr ls"># set up kubectl port-forwarding; this ensures that any local requests to port 8080 are forwarded by kubectl to the pod specified in this command, on port 80<br/># this basically creates a shortcut or highway from the VM right into the heart of the K8S cluster; we can leverage this highway for deployment of the function<br/>kubectl port-forward --namespace default $POD_NAME 8080:80 &amp;</span><span id="f037" class="lo kg hh lk b fi lt lq l lr ls">curl -X POST \<br/>  <a class="ae li" href="http://127.0.0.1:8080/r/soaring-clouds-app/shipping-costs" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/r/soaring-clouds-app/shipping-costs</a> \<br/>  -H 'Cache-Control: no-cache' \<br/>  -H 'Content-Type: application/json' \<br/>  -H 'Postman-Token: bb753f9f-9f63-46b8-85c1-8a1428a2bdca' \<br/>  -d '{"X":"Y"}'</span><span id="51eb" class="lo kg hh lk b fi lt lq l lr ls"># on the Windows laptop host<br/>set KUBECONFIG=c:\data\2018-soaring-keys\kubeconfig</span><span id="3442" class="lo kg hh lk b fi lt lq l lr ls">kubectl port-forward --namespace default &lt;name of pod&gt; 8080:80 &amp;</span><span id="e32d" class="lo kg hh lk b fi lt lq l lr ls">kubectl port-forward --namespace default my-release-fn-api-frsl5 8085:80 &amp;</span></pre><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/45335c18a3a9845a979dc3ef95e87874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0PbsbB9Q28IQiBxk."/></div></div></figure><p id="0f14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，尝试从笔记本电脑主机调用该函数。这假设在主机上我们有kubectl和kubeconfig文件，我们也在VM中使用它们。</p><p id="f80a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们必须设置KUBECONFIG环境变量来引用kubeconfig文件。然后，我们像在VM中一样设置kubectl端口转发，在本例中，将端口8085转发到用于Fn API的Kubernetes Pod。</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/92702910e5b5a2d739a43ce2b204d4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0oU2KrI_Z31g-Fot."/></div></div></figure><p id="e0ac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完成后，我们可以调用本地主机上的shipping-costs函数，port 8085:endpoint<a class="ae li" href="http://127.0.0.1:8085/r/soaring-clouds-app/shipping-costs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8085/r/sowing-clouds-app/shipping-costs</a></p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8391c91e4e58f7d5fc3038f671498119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p_BUUsQX37R4lHqF."/></div></div></figure><p id="c59a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这仍然需要客户端了解Kubernetes:拥有kubeconfig文件和kubectl客户端。我们可以让从任何地方直接调用Fn函数成为可能，而不需要使用kubectl。我们通过在Kubernetes上的Fn API服务上直接公开一个外部IP来做到这一点。</p><p id="2900" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最简单的方法是通过Kubernetes仪表板。</p><p id="c91c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行仪表板:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/2686a04b5398762c3e232d0694956429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*5cNrZIGqn9UE_sRt."/></div></figure><p id="2e0c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并在本地浏览器打开:<a class="ae li" href="http://127.0.0.1:8001/ui" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8001/ui </a>。</p><p id="5c54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑fn-api的服务配置:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f006c9885c7cd541a5536d38702c3cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVICEogBmB7PDus7."/></div></div></figure><p id="fe2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将类型ClusterIP更改为LoadBalancer。这指示Kubernetes对外公开该服务，并为其分配一个外部IP地址。单击更新以使更改生效。</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/9215203e25ae3a05f03a90423f2ecee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/0*V_Pwo5wbOg3A7X8a."/></div></figure><p id="d32b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">过一会儿，更改将被处理，我们可以为服务找到一个外部端点。</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fcfe34d5104a0a7da0754123abd498b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RG17rzyGWY9jP3Wb."/></div></div></figure><p id="bfba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们(以及任何拥有这个IP地址的人)可以直接使用这个外部IP地址调用Fn函数<em class="lu"> shipping-costs </em>:</p><figure class="kb kc kd ke fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e44f90e077dccfe5b732fff1ce0090f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1G-U2bCgWqBHNku."/></div></div></figure><h1 id="f978" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">摘要</h1><p id="588b" class="pw-post-body-paragraph ip iq hh ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">本文展示了如何从一台标准的Windows笔记本电脑开始——只有Virtual Box和vagger作为特殊组件。通过几个简单的、很大程度上自动化的步骤，我们创建了一个VM，它允许我们创建Fn函数并将这些函数部署到Kubernetes集群，我们还在该集群上部署了Fn服务器平台。本文提供了所有的源代码和脚本，并演示了如何创建、部署和调用特定的函数。</p><h1 id="0b9a" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">资源</h1><p id="6c15" class="pw-post-body-paragraph ip iq hh ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">本文来源于GitHub:<a class="ae li" href="https://github.com/lucasjellema/fn-on-kubernetes-from-docker-in-vagrant-vm-on-windows" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/fn-on-kubernetes-from-docker-in-vagger-VM-on-windows</a></p><p id="d85a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流浪汉主页:<a class="ae li" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">https://www.vagrantup.com/</a></p><p id="c53a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">VirtualBox主页:<a class="ae li" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank">https://www.virtualbox.org/</a></p><p id="da51" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">头盔快速入门:【https://docs.helm.sh/using_helm/#quickstart-guide】T2</p><p id="9d4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">' Kubernetes的Fn项目掌舵图—<a class="ae li" rel="noopener" href="/fnproject/fn-project-helm-chart-for-kubernetes-e97ded6f4f0c">https://medium . com/fn Project/fn-Project-Helm-Chart-for-Kubernetes-e 97 ded 6 f 4 f0c</a>'</p><p id="81bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">kubectl的安装说明—<a class="ae li" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-via-curl" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/tools/install-kube CTL/# install-kube CTL-binary-via-curl</a></p><p id="70f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">项目Fn —快速启动—<a class="ae li" href="https://github.com/fnproject/fn#quickstart" rel="noopener ugc nofollow" target="_blank">https://github.com/fnproject/fn#quickstart</a></p><p id="7efd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">带节点的Fn教程:<a class="ae li" href="https://github.com/fnproject/fn/tree/master/examples/tutorial/hello/node" rel="noopener ugc nofollow" target="_blank">https://github . com/Fn project/Fn/tree/master/examples/tutorial/hello/Node</a></p><p id="e439" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kubernetes —公开服务的外部IP地址—<a class="ae li" href="https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tutorials/stateless-application/expose-external-IP-address/</a></p><p id="d804" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用端口转发访问集群中的应用程序—<a class="ae li" href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/Access-application-Cluster/Port-forward-Access-application-Cluster/</a></p><p id="ea96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AMIS技术博客—Rapid first-steps with Fn—无服务器功能开源项目—<a class="ae li" href="https://technology.amis.nl/2017/10/19/rapid-first-few-steps-with-fn-open-source-project-for-serverless-functions/" rel="noopener ugc nofollow" target="_blank">https://Technology . AMIS . nl/2017/10/19/Rapid-first-steps-with-Fn—无服务器功能开源项目/ </a></p><p id="db9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AMIS技术博客—用Docker Host创建Debian VM使用vagger—自动包含Guest Additions—<a class="ae li" href="https://technology.amis.nl/2017/10/19/create-debian-vm-with-docker-host-using-vagrant-automatically-include-guest-additions/" rel="noopener ugc nofollow" target="_blank">https://Technology . AMIS . nl/2017/10/19/Create-Debian-VM-with-Docker-Host-using-vagger-automatically-include-Guest-Additions/</a></p><p id="85ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lu">原载于2018年3月4日</em><a class="ae li" href="https://technology.amis.nl/2018/03/04/get-going-with-project-fn-on-a-remote-kubernetes-cluster-from-a-windows-laptop-using-vagrant-virtualbox-docker-helm-and-kubectl/" rel="noopener ugc nofollow" target="_blank"><em class="lu">technology . amis . nl</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>