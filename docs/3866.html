<html>
<head>
<title>Spring Cloud Netflix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">春云网飞</h1>
<blockquote>原文：<a href="https://medium.com/globant/spring-cloud-netflix-d7db3b3c13e6?source=collection_archive---------0-----------------------#2022-04-20">https://medium.com/globant/spring-cloud-netflix-d7db3b3c13e6?source=collection_archive---------0-----------------------#2022-04-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c9fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Spring Cloud网飞通过自动配置和绑定到Spring环境和其他Spring编程模型习惯用法，为Spring Boot应用程序提供网飞OSS集成。通过一些简单的注释，您可以快速启用和配置应用程序中的通用模式，并使用久经考验的网飞组件构建大型分布式系统。提供的模式包括服务发现(Eureka)。</p><h1 id="3158" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是服务发现？</h1><p id="5e60" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">分布式系统通常包括大量相互通信以执行特定操作的服务。服务发现是一个服务动态发现另一个服务的网络位置(IP地址和端口)并与之通信的过程。</p><p id="8fcf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想象一个场景，其中一个REST服务(服务A)试图调用另一个REST服务(服务B)。为了发出请求，服务A需要知道服务b的网络位置(IP地址和端口)。在传统的SOA(面向服务的架构)生态系统中，服务的网络位置几乎不会改变，因为它们部署在本地数据中心。因此，您可以在配置文件中维护服务的网络位置，这些文件很少更新。例如，服务A可以在配置文件中维护服务B的IP地址和端口，并在发出请求时使用这些值。下图说明了这一流程。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/1d4dc5fba910e5463a48072100493468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSKU3ZVG5tA8dDjw4HdNqw.png"/></div></div></figure><p id="1346" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，这种方法在基于云的微服务架构中几乎是不可能的，原因如下。</p><p id="631e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">服务数量的增加:</strong>正如您所熟知的，微服务架构就是将一个个整体分解成细粒度的服务。这导致形成复杂通信网的服务数量增加。因此，一个服务很难在属性文件中维护它必须与之通信的所有其他服务的网络位置。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kr"><img src="../Images/7fbe383a92122e7fff767134eee8682b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Awv04wQKOfLUzhLp6222Jg.png"/></div></div></figure><p id="0b49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">动态分配网络位置:</strong>微服务一般部署在云端。云中的服务器实例具有动态分配的网络位置。此外，由于其自动扩展等基本功能，服务器在云中来去自如。每次在新实例中启动服务时，其网络位置都会发生变化。因此，很难在属性文件中维护特定微服务的目标IP地址和端口号，因为这些值往往会非常频繁地变化。</p><p id="c5a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些复杂性使得微服务需要更复杂的机制来动态发现其他微服务的网络位置以进行通信。结果引入了服务发现的概念。服务发现机制使用中央注册表来维护所有微服务的网络位置。如果由于某种原因，特定微服务的IP地址和端口号发生变化，新值将立即在注册表中重新注册。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ks"><img src="../Images/74e272744471fd3e84269681b27674d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UD6JAKZxutxGmuAsxDVbHA.png"/></div></div></figure><h1 id="0c22" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是春云尤里卡</h1><p id="4ab1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">Eureka是一个基于REST的服务，主要用于获取您想要与之通信的服务的信息。这个REST服务也被称为<strong class="ig hi">尤里卡服务器</strong>。在尤里卡服务器中注册以获取彼此信息的服务被称为<strong class="ig hi">尤里卡客户端</strong>。下图说明了Eureka客户端和服务器是如何结合在一起的。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kt"><img src="../Images/afc07ce591bfa56d745a784f195bff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBnYsXeuaSHQ53auwsFauQ.png"/></div></div></figure><h1 id="9c6e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">特征</h1><p id="ef47" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">春云网飞特色:</p><ul class=""><li id="e1bb" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">可以注册Eureka实例，客户机可以使用Spring管理的beans发现这些实例。</li></ul><p id="f82d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">网飞尤里卡</strong> <br/>尤里卡主要由主要部件组成，我们来看看都有哪些:<br/> <strong class="ig hi"> 1 .Eureka Server: </strong>它是一个包含所有客户端服务应用程序信息的应用程序。每个微服务都向Eureka服务器注册，Eureka知道每个端口和IP地址上运行的所有客户端应用程序。尤里卡服务器也被称为发现服务器。<br/> <strong class="ig hi"> 2。Eureka Client: </strong>这是实际的微服务，它向Eureka服务器注册，所以如果任何其他微服务想要Eureka客户端的地址，它们就会联系Eureka服务器。Eureka客户端的所有操作可能需要一段时间才能反映到Eureka服务器上，然后反映到其他Eureka客户端上</p><p id="0073" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">尤里卡服务器</strong></p><p id="162f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为服务注册实现一个Eureka服务器如下:</p><ol class=""><li id="f5fa" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb ld la lb lc bi translated">将spring-cloud-starter-网飞-尤里卡-服务器添加到依赖项中</li><li id="88fa" class="ku kv hh ig b ih le il lf ip lg it lh ix li jb ld la lb lc bi translated">在@ spring boot应用程序中启用Eureka服务器，方法是用@EnableEurekaServer对其进行注释</li><li id="ff12" class="ku kv hh ig b ih le il lf ip lg it lh ix li jb ld la lb lc bi translated">配置一些属性</li></ol><p id="163b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们一步一步来。</p><p id="63b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们将创建一个新的Maven项目，并将依赖项放入其中。注意，我们正在将spring-cloud-starter-parent导入到本教程中描述的所有项目中。</p><pre class="kg kh ki kj fd lj lk ll lm aw ln bi"><span id="520b" class="lo jd hh lk b fi lp lq l lr ls">&lt;dependencies&gt;<br/> &lt;dependency&gt;     <br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     <br/>  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-  server&lt;/artifactId&gt; <br/> &lt;/dependency&gt;  </span><span id="a1e5" class="lo jd hh lk b fi lt lq l lr ls">&lt;dependencies&gt;<br/>&lt;dependencyManagement&gt;     <br/> &lt;dependencies&gt;         <br/>&lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;             &lt;version&gt;Greenwich.RELEASE&lt;/version&gt;             <br/>&lt;type&gt;pom&lt;/type&gt;             <br/>&lt;scope&gt;import&lt;/scope&gt;         <br/>&lt;/dependency&gt;     <br/>&lt;/dependencies&gt;  <br/>&lt;/dependencyManagement&gt;</span></pre><p id="27dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们将创建主应用程序类:</p><pre class="kg kh ki kj fd lj lk ll lm aw ln bi"><span id="8750" class="lo jd hh lk b fi lp lq l lr ls">@SpringBootApplication <br/>@EnableEurekaServer <br/>public class <strong class="lk hi">EurekaServerApplication</strong> <br/>{     <br/>  public static void main(String[] args) {         SpringApplication.run(EurekaServerApplication.class, args);     <br/>  } <br/>}</span></pre><p id="26a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们将配置<em class="lu"> YAML </em>格式的属性，因此<em class="lu"> application.yml </em>将是我们的配置文件:</p><pre class="kg kh ki kj fd lj lk ll lm aw ln bi"><span id="e11b" class="lo jd hh lk b fi lp lq l lr ls">server:   <br/> port: 8761 <br/>eureka:   <br/> client:     <br/>  registerWithEureka: false     <br/>  fetchRegistry: false</span></pre><p id="d716" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">这里我们配置一个应用程序端口；尤里卡服务器的默认版本是<em class="lu"> 8761 </em>。我们告诉内置的<em class="lu"> Eureka客户端</em>不要向自己注册，因为我们的应用程序应该充当服务器。</strong></p><p id="cd96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们将浏览器指向<a class="ae lv" href="http://localhost:8761/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8761 </a>来查看<em class="lu"> Eureka </em>仪表板，稍后我们将在这里检查已注册的实例。</p><p id="ef1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">尤里卡客户端</strong></p><p id="31b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让一个<em class="lu"> @SpringBootApplication </em>能够感知发现，我们必须在我们的<em class="lu">类路径中包含一个<em class="lu"> Spring发现客户端</em>(例如，<a class="ae lv" href="https://search.maven.org/search?q=spring-cloud-starter-netflix-eureka-client" rel="noopener ugc nofollow" target="_blank"><em class="lu">Spring-cloud-starter-网飞-尤里卡-客户端</em> </a>)。</em></p><p id="589b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们需要用<em class="lu"> @EnableDiscoveryClient </em>或<em class="lu"> @EnableEurekaClient注释一个<em class="lu"> @Configuration </em>。</em>注意，如果我们在类路径上有<em class="lu">spring-cloud-starter-网飞-尤里卡-客户端</em>依赖，那么这个注释是可选的。</p><p id="53c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后者明确告诉Spring Boot使用Spring网飞尤里卡进行服务发现。为了给我们的客户端应用程序添加一些样本，我们还将在<em class="lu"> pom.xml </em>中包含<a class="ae lv" href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.springframework.boot%22%20AND%20a%3A%22spring-boot-starter-web%22" rel="noopener ugc nofollow" target="_blank"><em class="lu">spring-boot-starter-web</em></a>包，并实现一个<em class="lu"> REST </em>控制器。</p><p id="cc3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是首先，我们将添加依赖项。同样，我们可以让<em class="lu">spring-cloud-starter-parent</em>依赖关系来为我们计算工件版本:</p><pre class="kg kh ki kj fd lj lk ll lm aw ln bi"><span id="1831" class="lo jd hh lk b fi lp lq l lr ls">&lt;dependency&gt;     <br/>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     <br/>&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-starter&lt;/artifactId&gt; &lt;/dependency&gt; <br/>&lt;dependency&gt;     <br/>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     <br/>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; <br/>&lt;/dependency&gt;</span></pre><p id="d00f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们将实现主要的应用程序类:</p><pre class="kg kh ki kj fd lj lk ll lm aw ln bi"><span id="b75e" class="lo jd hh lk b fi lp lq l lr ls">@SpringBootApplication <br/>@RestController <br/>public class <strong class="lk hi">EurekaClientApplication</strong>{      <br/>@Autowired     <br/>@Lazy     <br/>private EurekaClient eurekaClient;      @Value("${spring.application.name}")     <br/>private String appName;      <br/>public static void <strong class="lk hi">main</strong>(String[] args) {          SpringApplication.run(EurekaClientApplication.class, args);     }      @Override     <br/>public String <strong class="lk hi">greeting</strong>() {         <br/>return String.format("Hello from '%s'!", eurekaClient.getApplication(appName).getName());<br/>} }<br/></span></pre><h1 id="b514" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="6ad2" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这篇文章的主要目的是向您介绍使用Eureka进行服务发现。在现实场景中，一个微服务生态系统可能有数千个部署在世界不同地区的服务。在这种情况下，只有一个Eureka集群可能不切实际。相反，我们将不得不在不同的地区部署多个Eureka集群，以最小化延迟并提高可用性。下图对此进行了说明。</p></div></div>    
</body>
</html>