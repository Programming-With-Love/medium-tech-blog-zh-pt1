<html>
<head>
<title>Tackling Multi-class Image Classification Problem with Transfer Learning using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用PyTorch迁移学习解决多类图像分类问题</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/tackling-multi-class-image-classification-problem-with-transfer-learning-using-pytorch-50150b215fb6?source=collection_archive---------1-----------------------#2021-02-08">https://medium.com/walmartglobaltech/tackling-multi-class-image-classification-problem-with-transfer-learning-using-pytorch-50150b215fb6?source=collection_archive---------1-----------------------#2021-02-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="939c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像分类是一个<a class="ae jc" href="https://towardsdatascience.com/a-brief-introduction-to-supervised-learning-54a3e3932590" rel="noopener" target="_blank"> <em class="jd">监督学习</em> </a>问题，可以通过训练模型识别图像来解决。这种分类的目的是识别和数字分析图像的特征。令人着迷的是，机器可以对甚至人类都难以分类的图像进行分类。图像分类在零售、医疗保健、安全、汽车工业等几乎每个领域都有应用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/ba61f6a64fe444d4be829f1c39d14cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*TtUj4NXZDrwGWy-VZwOMpQ.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" href="https://memegenerator.net/instance/68648391/ron-burgundy-classification-its-kind-of-a-big-deal" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="d014" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们将尝试解决一个图像分类问题，并推广解决类似问题的方法。由于我们的数据都是图像，解决这个问题的最好方法是建立一个卷积神经网络(<a class="ae jc" href="https://towardsdatascience.com/covolutional-neural-network-cb0883dd6529" rel="noopener" target="_blank"> <em class="jd"> CNN </em> </a>)。我们将在这里使用预先训练好的<a class="ae jc" href="https://towardsdatascience.com/understanding-and-visualizing-resnets-442284831be8" rel="noopener" target="_blank"> <em class="jd"> ResNet34 </em> </a>模型和PyTorch库开发我们自己的CNN，py torch库是一个非常流行的构建深度学习模型的库。</p><p id="1277" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我选择了取自Kaggle网站的<a class="ae jc" href="https://www.kaggle.com/puneet6060/intel-image-classification" rel="noopener ugc nofollow" target="_blank"> <em class="jd">英特尔图像分类数据集</em> </a>。你可以在<a class="ae jc" href="https://www.kaggle.com/datasets" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Kaggle </em> </a> <em class="jd">上找到很多这样有趣的数据集。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/f8a52a33b1b3a25db430c02838e2b5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*BB4zbrfKwvOnxG8V8NCc5A.png"/></div></figure><p id="2d7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开始解决这个问题之前，看看我们的数据集总是一个好主意。只需扫一眼，我们就可能在数据集中发现许多令人兴奋的发现或异常现象。这个数据集有25000个不同的标记图像，包括建筑物、森林、冰川、山脉、海洋和街道。我们将图像分为这6个不同的类别。大多数图像的大小为150 X 150像素。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h1 id="8b11" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">初始设置</h1><p id="5ff8" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">让我们从导入所有必需的库开始。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c319" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd"> Opendatasets </em>是一个开源库，可以轻松地将在线数据集保存到您的笔记本上。</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="1608" class="li jz hh le b fi lj lk l ll lm">od.download('https://www.kaggle.com/puneet6060/intel-image-classification')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/1100726b0090938c4952f44ff8ef74b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDuFUvqd7Vp-ZXVr7HTQXg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx">Distribution of Images</figcaption></figure><p id="4c4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们的图像在所有类别中的分布。所有图像都有自己的类别目录，并且图像的数量分布不均匀。</p><p id="2199" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们需要加载我们的数据，并对图像数据进行一些转换，使其对训练我们的模型更有用。你会在PyTorch中发现许多图像<a class="ae jc" href="https://pytorch.org/docs/stable/torchvision/transforms.html" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a>数据转换，但是我们将使用随机裁剪和随机水平翻转来很好地处理这个数据集。我们将所有图像的大小调整为128 X 128像素，并使用<a class="ae jc" href="https://arthurdouillard.com/post/normalization/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> imagenet预训练的stats </em> </a>对所有像素值进行归一化。我建议我们分批加载128个图像，以便在可用的计算能力下完成训练。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="49ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完成后，我们已经通过Pytorch数据加载器成功加载了我们的训练和验证数据，现在每个图像都将是一组使用imagenet预训练统计数据标准化的像素值。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h1 id="7e95" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">GPU实用程序</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/e8274d7e105ff7f1e05a4c411a9b2d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsRuMMLkJxNPA0Te4kHqdg.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" href="https://imgflip.com/i/4xck2o?herp=1612892899820" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="d4fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">卷积神经网络需要大量的计算能力来训练，因为所有图像的每个像素值都有大量的权重计算。如果我们用CPU工作，可能需要几个小时或几天来训练模型。但值得庆幸的是，在线平台如<a class="ae jc" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Kaggle </em> </a>或<a class="ae jc" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Google Colab </em> </a>为我们提供了免费的<a class="ae jc" href="https://blogs.nvidia.com/blog/2009/12/16/whats-the-difference-between-a-cpu-and-a-gpu/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> GPU </em> </a>设置，这大大提高了我们的训练时间。让我们创建一些有用的代码来将我们的数据推送到GPU。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="e4a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在已经创建了一个Python类DeviceLoader，它将检查GPU在环境中是否可用，并将数据移动到GPU。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><h1 id="d8bc" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">训练我们的模型</h1><p id="03ae" class="pw-post-body-paragraph ie if hh ig b ih kw ij ik il kx in io ip ky ir is it kz iv iw ix la iz ja jb ha bi translated">现在我们都准备好开始为我们的模型训练编码了。我们将使用一个预先训练好的模型<a class="ae jc" href="https://towardsdatascience.com/understanding-and-visualizing-resnets-442284831be8" rel="noopener" target="_blank"> ResNet34 </a>，该模型已经对具有1000个类别的图像数据进行了训练。为什么要用预先训练好的CNN模型？CNN的初始层仅训练低级和中级特征，例如边缘、线条、边界等。各种图像都包含这些特征。预先训练的CNN的这些特征使得它非常可重复使用。因此，使用这种已经在大量数据上训练过的预训练模型是有意义的，许多公司为此投入了大量资金。这就是所谓的迁移学习。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lt"><img src="../Images/c0b8fa9fe837f73b434ed423e336b368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*V_lnH58ZtxQyxXCqHYt6DQ.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" href="https://developer.nvidia.com/discover/convolutional-neural-network" rel="noopener ugc nofollow" target="_blank">Source</a>: How a CNN learns</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lu"><img src="../Images/36644c98923e23f0a946cd3e1ae94360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIY_8FE7dJaGk1kjU7iVSg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" rel="noopener" href="/analytics-vidhya/deep-learning-visualization-and-interpretation-of-neural-networks-2f3f82f501c5">Source</a>: Layer visualization</figcaption></figure><p id="eca9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用预训练模型，我们需要保持所有之前的层不变，只根据我们的用例更改最后一层。ResNet34已经在1000个图像类上进行了训练。我们的问题只有6个不同的图像类别(建筑物、森林、冰川、山脉、海洋和街道)。因此，我们将把ResNet34的最后一层修改为这6个类。迁移学习节省了工程师大量的培训时间和开发精力。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lv"><img src="../Images/0796aaee20e94d770983ae106e017c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehyqIuoXgThsSymZ4h5yFQ.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" href="https://laptrinhx.com/transfer-learning-with-deep-learning-machine-learning-techniques-1499149008/" rel="noopener ugc nofollow" target="_blank">Source</a>: Transfer Learning</figcaption></figure><p id="9104" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pytorch有一个<code class="du lw lx ly le b"><strong class="ig hi">nn.Module</strong></code>类，可以继承它来创建我们的模型类。我们将编写一些可重用的类<code class="du lw lx ly le b"><strong class="ig hi">ImageClassificationBase</strong></code> <strong class="ig hi"> </strong>，它由一些可用于任何模型的辅助函数组成。然后我们将创建我们的模型类<code class="du lw lx ly le b"><strong class="ig hi">MyModel</strong></code> <strong class="ig hi"> </strong>，它继承了ImageClassificationBase类，我们将在那里应用ResNet34的迁移学习。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9604" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们模型的最后一层现在已经从最初的1000个类变成了我们的6个类。如果最后需要的话，我们可以在模型中添加更多的层，但是这里一个线性层就可以了。</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="6dd0" class="li jz hh le b fi lj lk l ll lm">self.network.fc = nn.Linear(self.network.fc.in_features, num_classes)</span></pre><p id="40e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">万岁！我们现在已经使用迁移学习成功地创建了我们的CNN模型。此外，我们需要创建一个训练循环来评估我们的模型，改变超参数，如学习率、时期、设置优化器等。用于培训和验证。我们将在我们的拟合函数中添加一些正则化技术，如<em class="jd"> </em> <a class="ae jc" href="https://sgugger.github.io/the-1cycle-policy.html" rel="noopener ugc nofollow" target="_blank"> <em class="jd">【单周期学习率策略】</em></a><em class="jd"/><a class="ae jc" href="https://towardsdatascience.com/this-thing-called-weight-decay-a7cd4bcfccab" rel="noopener" target="_blank"><em class="jd">权重衰减</em></a><em class="jd"/><a class="ae jc" href="https://towardsdatascience.com/what-is-gradient-clipping-b8e815cdfb48" rel="noopener" target="_blank"><em class="jd">渐变裁剪</em> </a>来改进我们的模型训练。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="360c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这个，我们就为训练做好了一切准备。现在，我们只需要应用我们使用不同的超参数开发的函数，并将我们的模型训练到最佳状态。在使用不同的超参数进行几次迭代之后，该模型在10-15分钟内对验证数据进行训练，达到90%以上的准确度。这就是将迁移学习应用到您的模型并在GPU上处理它以快速达到良好精度的优势。这种方法对于不允许长时间等待培训的行业应用来说非常方便。</p><p id="48dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来看看我们的准确率、学习率以及用于训练和验证集的时期数的损失。数据可视化总是有助于更有效地理解数据。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lz"><img src="../Images/a6cde4c0a96a44ba6833113bd9b36301.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*x5e1CHIaRfdQ8hJBkJQ35g.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx">Rise in Accuracy</figcaption></figure><p id="6799" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有趣的是，由于随机权重的原因，准确度在开始时非常低，但仅在第二个时期就上升到70%。在变平之前，精确度最终提高到92%。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/018ab24e497ecabea52e976655ffccdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*Srmm7Qf6saTC-QvJk7FteQ.png"/></div></figure><p id="0bcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">验证损失在开始时表现出一些起伏，但接近结束时，它开始与训练损失合并。如果它偏离训练损失，那么这将暗示模型的<a class="ae jc" href="https://elitedatascience.com/overfitting-in-machine-learning" rel="noopener ugc nofollow" target="_blank"> <em class="jd">过度拟合</em> </a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mb"><img src="../Images/ca235a471092ac8997022703245c953d.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*V6fkSp67erLoj0tRAt8nYA.png"/></div></figure><p id="32c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用的正则化技术，即<a class="ae jc" href="https://sgugger.github.io/the-1cycle-policy.html" rel="noopener ugc nofollow" target="_blank"> O <em class="jd"> ne周期学习率策略</em> </a> <em class="jd"> </em>将初始批次数据的学习率提高到某一点，然后降低后续批次的学习率。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mc"><img src="../Images/81417c4b94dbdd38cdf59643f4f6f267.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*PqVOkfM-6xV2BaykzAjdeg.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx"><a class="ae jc" href="https://memegenerator.net/instance/63454089/you-just-activated-my-trap-card-looks-like-someone-just-trained-a-deep-neural-network" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="bf2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有最后一件事。我们需要看看我们的模型如何处理未标记的推理数据。我们在这里使用的Kaggle数据集已经有一个包含未标记图像的文件夹。我们来预测一下！我们将从推理集中随机选择图像，并将它们用于我们的预测。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es md"><img src="../Images/3c41d52c758c0d90e951874b6c45d627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*GZLZ0ms9hN6pWJ6e-hCFLA.png"/></div></figure><p id="4acd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的模型能够从推理集中预测所有类别的图像。</p><p id="4728" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">恭喜你！我们现在已经使用PyTorch库的迁移学习成功构建了一个CNN模型。使用这种方法，任何多类图像分类问题都可以在短时间内以良好的精度得到解决。</p></div></div>    
</body>
</html>