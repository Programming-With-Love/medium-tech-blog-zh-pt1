<html>
<head>
<title>Drawing a rounded corner background on text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在文本上绘制圆角背景</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/drawing-a-rounded-corner-background-on-text-5a610a95af5?source=collection_archive---------5-----------------------#2018-08-08">https://medium.com/androiddevelopers/drawing-a-rounded-corner-background-on-text-5a610a95af5?source=collection_archive---------5-----------------------#2018-08-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/316c35306202bc3700a3a825cbf95089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHjquSrfS6bNSjr_rsDSJw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="5d75" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们需要在文本上绘制一个<strong class="iw hy">圆角</strong>背景，支持以下情况:</p><ul class=""><li id="b74c" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">在<strong class="iw hy">上设置一行</strong>文本的背景</li></ul><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/d9a12ec5cc2e29d7f7be74e687d2029e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PWKx5cM1bjVjA1aW"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Text on one line with a rounded corner background</em></figcaption></figure><ul class=""><li id="2371" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">设置两行或多行上文本的背景</li></ul><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/c9a8faf8b21d9fa6c1386dec904e4292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sdYBIZugLh_DJFvu"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Text on multiple lines with a rounded corner background</em></figcaption></figure><ul class=""><li id="2e0e" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">在<strong class="iw hy">从右向左文本</strong>上设置背景</li></ul><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/d2303582300465ba42f82a32d618fce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yKM94GeuW34Z0_dK"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Right to left text with rounded corner background</em></figcaption></figure><p id="028e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们如何实现这一点？请继续阅读，或者直接跳到<a class="ae hu" href="https://github.com/googlesamples/android-text/tree/master/RoundedBackground-Kotlin" rel="noopener ugc nofollow" target="_blank">样本代码</a>。</p><h1 id="729b" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">跨越还是不跨越？这才是问题！</h1><p id="86ac" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">在<a class="ae hu" rel="noopener" href="/google-developers/spantastic-text-styling-with-spans-17b0c16b4568">之前的</a> <a class="ae hu" rel="noopener" href="/google-developers/underspanding-spans-1b91008b97e4">文章</a>中，我们已经讨论了文本的样式部分(甚至是<a class="ae hu" rel="noopener" href="/google-developers/styling-internationalized-text-in-android-f99759fb7b8f">国际化文本</a>)。该解决方案涉及使用框架或自定义跨度。虽然spans在很多情况下是一个很好的解决方案，但是它们也有一些限制，不适合我们的问题。外观跨度，像<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/BackgroundColorSpan" rel="noopener ugc nofollow" target="_blank">BackgroundColorSpan</a></code>，给我们访问<code class="du lk ll lm ln b">TextPaint</code>，允许我们改变元素，像文本的背景颜色，但是只能画纯色，不能控制元素，像圆角半径。</p><figure class="kc kd ke kf fd hj er es paragraph-image"><div class="er es lo"><img src="../Images/9947b365ab83ccd054dac34e79e3588d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*jPTOmlEs5d6MLtuV"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Text using a BackgroundColorSpan</em></figcaption></figure><p id="21ea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要和正文一起画一张图。我们可以实现一个自定义的<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/style/ReplacementSpan.html" rel="noopener ugc nofollow" target="_blank">ReplacementSpan</a></code>来自己绘制背景和文本。然而<code class="du lk ll lm ln b">ReplacementSpans</code>无法流入下一行，因此我们将无法支持多行背景。他们宁愿看起来像<a class="ae hu" href="https://material.io/design/components/chips.html" rel="noopener ugc nofollow" target="_blank">芯片</a>，材料设计组件，其中每个元素必须适合在一条线上。</p><p id="8614" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">跨越工作在<code class="du lk ll lm ln b">TextPaint</code>级别，而不是布局级别。因此，他们不知道文本开始和结束的行号，也不知道段落方向(从左到右或从右到左)</p><h1 id="d701" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">解决方案:自定义文本视图</h1><p id="10ac" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">根据文本的位置，我们需要绘制四种不同的drawables作为文本背景:</p><ul class=""><li id="383c" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">文本适合一行:我们只需要一个drawable</li><li id="c048" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">文本适合两行:我们需要为文本的开始和结束绘制</li><li id="8b44" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">文本跨越多行:我们需要为文本的开始，中间和结尾绘制。</li></ul><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/03f010c9c2911eba268694bd4769f6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XyponDkstQ3kYrCI"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">The four drawables that need to be drawn depending on the position of the text</em></figcaption></figure><p id="e8dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要定位背景，我们需要:</p><ul class=""><li id="a0a5" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">确定文本是否跨越多行</li><li id="1e6f" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">找到起点和终点</li><li id="e34d" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">根据段落方向找到开始和结束偏移量</li></ul><p id="eb37" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有这些都可以根据文本<a class="ae hu" href="https://developer.android.com/reference/android/text/Layout" rel="noopener ugc nofollow" target="_blank">布局</a>进行计算。为了渲染文本背后的背景，我们需要访问<code class="du lk ll lm ln b">Canvas</code>。一个定制的<code class="du lk ll lm ln b">TextView</code>可以访问所有必要的信息来定位和呈现可绘制内容。</p><p id="a1e2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的解决方案包括将问题分成4个部分，并创建单独处理它们的类:</p><ul class=""><li id="d838" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy">用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/android/text/Annotation" rel="noopener ugc nofollow" target="_blank">Annotation</a></code>跨度在XML资源中标记背景</strong>的位置，然后在代码中，我们计算<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/2831d91984f3e66104212be96aa9b1aba1c718ca/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgHelper.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgHelper</a></code>中的位置</li><li id="3662" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">提供背景<strong class="iw hy"> drawables </strong>作为TextView的<strong class="iw hy">属性</strong>—在<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/2831d91984f3e66104212be96aa9b1aba1c718ca/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgAttributeReader.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgAttributeReader</a></code>实现</li><li id="b032" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated"><strong class="iw hy">根据文本是跨<strong class="iw hy">一行还是多行</strong> — <code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgRenderer.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgRenderer</a></code>界面绘制</strong>及其实现:<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgRenderer.kt#L84" rel="noopener ugc nofollow" target="_blank">SingleLineRenderer</a></code>和<code class="du lk ll lm ln b"><a class="ae hu" href="http://MultiLineRenderer" rel="noopener ugc nofollow" target="_blank">MultiLineRenderer</a></code></li><li id="7b53" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">在<code class="du lk ll lm ln b">TextView</code> — <code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/RoundedBgTextView.kt" rel="noopener ugc nofollow" target="_blank">RoundedBgTextView</a></code>上支持<strong class="iw hy">自定义绘制</strong>，一个扩展了<code class="du lk ll lm ln b">AppCompatTextView</code>的类，在<code class="du lk ll lm ln b">TextRoundedBgAttributeReader</code>的帮助下读取属性，覆盖<code class="du lk ll lm ln b">onDraw</code>，在那里它使用<code class="du lk ll lm ln b">TextRoundedBgHelper</code>绘制背景。</li></ul><h1 id="cee5" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">找出应该在哪里绘制背景</h1><p id="bc22" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">我们在字符串资源中使用<code class="du lk ll lm ln b"><a class="ae hu" href="https://developer.android.com/reference/java/text/Annotation" rel="noopener ugc nofollow" target="_blank">Annotation</a></code> spans来指定应该有背景的文本部分。从本文的<a class="ae hu" rel="noopener" href="/google-developers/styling-internationalized-text-in-android-f99759fb7b8f">中找到更多关于使用注释范围的信息。</a></p><p id="0d51" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们创建了一个<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgHelper.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgHelper</a></code>类:</p><ul class=""><li id="7f4e" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">使我们能够根据文本方向定位背景:从左到右或从右到左</li><li id="e577" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">根据可绘制内容以及水平和垂直填充呈现背景</li></ul><p id="16bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgHelper.kt#L79" rel="noopener ugc nofollow" target="_blank">TextRoundedBgHelper.draw</a></code>方法中，对于文本中找到的每个<code class="du lk ll lm ln b">Annotation</code>跨度，我们获取跨度的开始和结束索引，找到每个跨度的行号，然后计算开始和结束字符偏移量(在行内)。然后，我们使用<code class="du lk ll lm ln b">TextRoundedBgRenderer</code>实现来渲染背景。</p><pre class="kc kd ke kf fd lv ln lw lx aw ly bi"><span id="7ee9" class="lz ki hx ln b fi ma mb l mc md">fun draw(canvas: Canvas, text: Spanned, layout: Layout) {<br/>    // ideally the calculations here should be cached since <br/>    // they are not cheap. However, proper<br/>    // invalidation of the cache is required whenever <br/>    // anything related to text has changed.<br/>    val spans = text.getSpans(0, text.<em class="me">length</em>, Annotation::class.<em class="me">java</em>)<br/>    spans.forEach <strong class="ln hy">{ </strong>span <strong class="ln hy">-&gt;<br/>        </strong>if (span.<em class="me">value</em>.equals("rounded")) {<br/>            val spanStart = text.getSpanStart(span)<br/>            val spanEnd = text.getSpanEnd(span)<br/>            val startLine = layout.getLineForOffset(spanStart)<br/>            val endLine = layout.getLineForOffset(spanEnd)<br/><br/>            // start can be on the left or on the right depending <br/>            // on the language direction.<br/>            val startOffset = (layout.getPrimaryHorizontal(spanStart)<br/>                + -1 * layout.getParagraphDirection(startLine) * horizontalPadding).toInt()<br/>            // end can be on the left or on the right depending <br/>            // on the language direction.<br/>            val endOffset = (layout.getPrimaryHorizontal(spanEnd)<br/>                + layout.getParagraphDirection(endLine) * horizontalPadding).toInt()<br/><br/>            val renderer = if (startLine == endLine) singleLineRenderer else multiLineRenderer<br/>            renderer.draw(canvas, layout, startLine, endLine, startOffset, endOffset)<br/>        }<br/>    <strong class="ln hy">}<br/></strong>}</span></pre><h1 id="b76d" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">提供可绘制的属性</h1><p id="ca57" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">为了在我们的应用程序中方便地为不同的<code class="du lk ll lm ln b">TextViews</code>提供drawables，我们<a class="ae hu" href="https://developer.android.com/training/custom-views/create-view#customattr" rel="noopener ugc nofollow" target="_blank">定义了</a> 4个对应于drawables的自定义属性和2个用于水平和垂直填充的属性。我们创建了一个从xml布局中读取这些属性的<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgAttributeReader.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgAttributeReader</a></code>类。</p><h1 id="dcec" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">使背景可绘制</h1><p id="d014" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">一旦我们有了可画的东西，我们就需要画它们。为此，我们需要知道:</p><ul class=""><li id="221e" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">背景的开始线和结束线</li><li id="6b35" class="js jt hx iw b ix lp jb lq jf lr jj ls jn lt jr jx jy jz ka bi translated">背景应该开始和结束的字符偏移量。</li></ul><p id="971d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们创建了一个抽象类<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgRenderer.kt" rel="noopener ugc nofollow" target="_blank">TextRoundedBgRenderer</a></code>，它知道如何计算线条的顶部和底部偏移量，但是公开了一个抽象的<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgRenderer.kt#L45" rel="noopener ugc nofollow" target="_blank">draw</a></code>函数:</p><pre class="kc kd ke kf fd lv ln lw lx aw ly bi"><span id="a322" class="lz ki hx ln b fi ma mb l mc md">abstract fun draw(<br/>    canvas: Canvas,<br/>    layout: Layout,<br/>    startLine: Int,<br/>    endLine: Int,<br/>    startOffset: Int,<br/>    endOffset: Int<br/>)</span></pre><p id="7625" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据文本是单行还是多行，<code class="du lk ll lm ln b">draw</code>函数将有不同的实现。这两个实现都基于相同的原理:基于顶部和底部的线条，设置可绘制对象的边界，并将其呈现在画布上。</p><p id="5a9a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单线实现只需要画一个drawable。</p><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/2e5d8bd2677948f799fcacca7cbeb3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HS6zOL8stqjTodpJ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Single line text</em></figcaption></figure><p id="efc2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">多行实现需要在第一行和最后一行分别绘制可绘制的行的开始和结束，然后对于中间的每一行，绘制可绘制的中间行。</p><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/0dac0d159e51db9517fe3acdd49b102a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tz3lRa59dixAI5LA"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kg">Multi-line text</em></figcaption></figure><h1 id="0cfb" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">支持在TextView上自定义绘图</h1><p id="5697" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">在让<code class="du lk ll lm ln b">TextView</code>绘制文本之前，我们扩展<code class="du lk ll lm ln b">AppCompatTextView</code>并覆盖<code class="du lk ll lm ln b">onDraw</code>来调用<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/TextRoundedBgHelper.kt#L79" rel="noopener ugc nofollow" target="_blank">TextRoundedBgHelper.draw</a></code>。</p><p id="4434" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">警告</strong>:我们的示例为每个<code class="du lk ll lm ln b">TextView.onDraw</code>方法调用进行所有的计算。如果你计划在你的应用中集成这个实现，我们强烈建议修改它并缓存在<code class="du lk ll lm ln b"><a class="ae hu" href="https://github.com/googlesamples/android-text/blob/master/RoundedBackground-Kotlin/lib/src/main/java/com/android/example/text/styling/roundedbg/RoundedBgTextView.kt#L52" rel="noopener ugc nofollow" target="_blank">TextRoundedBgHelper</a></code>中完成的计算。然后，确保每当与文本相关的任何内容(如文本颜色、大小或其他属性)发生变化时，都使缓存失效。</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="c17b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android文本API允许您非常自由地进行样式化。文本属性、样式、主题和跨度的简单样式化是可能的。通过控制<code class="du lk ll lm ln b">onDraw</code>方法并决定在<code class="du lk ll lm ln b">Canvas</code>上绘制什么以及如何绘制，可以实现复杂的定制样式。查看我们的示例，了解所有实现细节。</p><p id="fa6b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你需要定制什么样的文本样式<code class="du lk ll lm ln b">TextView</code>实现？你遇到了什么样的问题？在评论里告诉我们吧！</p></div></div>    
</body>
</html>