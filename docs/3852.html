<html>
<head>
<title>OAUTH 2.0: The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OAUTH 2.0:基础知识</h1>
<blockquote>原文：<a href="https://medium.com/globant/oauth-2-0-the-basics-340b5bcc7c7e?source=collection_archive---------0-----------------------#2022-04-05">https://medium.com/globant/oauth-2-0-the-basics-340b5bcc7c7e?source=collection_archive---------0-----------------------#2022-04-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a94c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated">网上有很多关于OAuth2.0和Open ID的资源。很多这些资源很难理解，可能是因为它们呈现的方式，或者是因为有时我们在试图形象化抽象概念时会遇到困难。在这篇文章中，我想用一些真实世界的类比来解释我认为对完全理解OAuth2.0最重要的想法，这样你就可以深入了解更多的技术资源。我们将涉及的基本概念是:</p><ul class=""><li id="147c" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">授权和身份验证的区别</li><li id="5add" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">什么是OAuth2.0</li><li id="703f" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OAuth2.0角色</li><li id="8192" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OAuth2.0授权类型和流程</li></ul><h1 id="4fd0" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="b179" class="jl jm hh ig b ih kx il ky ip kz it la ix lb jb jq jr js jt bi translated">身份验证是一个过程，其重点是识别您是谁。</li><li id="773e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授权是一个专注于确定你能做什么的过程。</li><li id="c226" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OpenID定义了一种处理OAuth认证的标准化方法。</li><li id="ad5e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OAuth是一个授权框架，其目标是代表用户向第三方应用程序提供对受限资源的访问</li><li id="10ca" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OAuth中有4个主要角色。资源所有者、客户端、授权服务器和资源服务器。</li><li id="f4c9" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">有两种类型的客户端:机密客户端和公共客户端。</li><li id="9486" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OAuth定义了4个授权流和1个扩展机制。</li><li id="2691" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授权代码流用授权代码交换访问和刷新令牌。它用于机密客户。</li><li id="8bad" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">公共客户端使用隐式授权。没有授权码，授权服务器不能返回刷新令牌，只能返回访问令牌。</li><li id="7e0a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授予资源所有者密码凭据意味着资源所有者与客户端共享其凭据。客户端将使用这些凭证来获取访问令牌。它应该只为资源所有者和客户端之间的高度信任关系实现。</li><li id="aa74" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">客户端凭证授权用于机器2机器通信(M2M)。在这个流中，客户端将其clientID和秘密发送给授权服务器。一旦授权服务器对客户端进行了身份验证，它就会返回一个访问令牌。它不应该返回刷新令牌。</li><li id="f1d1" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授权码和隐式授权流是基于重定向的流。</li></ul><h1 id="7511" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">授权和身份验证的区别</h1><p id="216e" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">区分认证和授权很重要，因为这将帮助我们理解OAuth2.0和OpenID之间的责任。简而言之，认证是指定如何识别您身份的过程。授权是一个过程，其重点是如何确定一旦通过身份验证，您可以做什么。</p><p id="34a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用一个例子来验证一下。</p><p id="da53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设你从亚马逊收到一个订单，但是这个订单到达了一个包裹寄存系统。一旦承运人离开您的包裹，系统会向您发送一个代码。你去更衣室，输入你的密码，然后你被要求在屏幕上签名。完成后，系统会打开其中一个储物柜，这样您就可以取回您的包裹。在本例中，您使用代码和签名进行身份验证，并被识别为客户端。当系统验证您的信息，认为您是客户，并授予您访问特定储物柜的权限时，就会发生授权。例如，系统管理员可能有一个特殊的代码，当验证通过时，允许他打开任何储物柜。</p><h1 id="c4f3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是OAuth 2.0</h1><p id="9658" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">OAuth是一个授权框架，其目标是代表用户向第三方应用程序提供对受限资源的访问，或者允许代表自己访问第三方。传统上，用户使用他们的凭据登录系统，但是如果第三方需要访问特定资源(如您公司的照片或电子邮件)，那么您必须向他们提供您的凭据。这是一个问题，因为你共享你的凭证，因此给你的帐户上的所有信息的完全访问权。这就像把你银行账户的密码交给财务顾问，因为他需要看你每年的银行对账单。通常，问题不在于恶意使用您的凭证，而在于将它们放在第三方的风险。在上面的例子中，如果财务顾问方面存在安全漏洞，您的信息就有可能被泄露。</p><p id="d28c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想象一下，他没有给你凭证，而是直接去银行要你的对账单。银行会给你回电，询问你是否同意顾问获取这些信息。如果你同意，银行会打印一份有效期为一周的表格，规定顾问只能检查你的对账单，然后交给他。这是OAuth通常做的事情。OAuth增加了一个授权层(在我们的例子中是银行),并在客户(财务顾问)和资源所有者(您)之间做出了明确的区分。它不使用资源所有者凭据来访问受保护的资源，而是在资源所有者批准后，为第三方生成一个可用于访问受保护资源的访问令牌(表单)。</p><p id="b6a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您检查OAuth定义，您可以看到它是一个授权框架，专注于保护资源访问，但是它没有讨论身份验证部分，因为这超出了它的范围。允许第三方检索与最终用户相关的简档信息以识别他们是由OpenID协议处理的过程。为了给出一点与OpenID相关的背景，我们需要记住OAuth是一个游戏改变者，并且很快被采用。这导致开发团队自己解决了身份验证部分，但是随着更多实现的建立，使用OAuth作为身份验证机制的误解发生了。为了缩小这个差距，OpenID被定义为认证协议，并被认为是OAuth的扩展。</p><p id="7591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们讨论的是ATM交互，OpenID角色将由要求PIN的ATM来表示。当银行找到你的账户时，系统会为你返回一个个性化的屏幕，可能会显示你的名字和你最后一次进入系统的日期。</p><h1 id="83f6" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">OAuth 2.0角色</h1><p id="4772" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">现在，我们更好地理解了身份验证与授权之间的区别以及OAuth和OpenID的角色，为了帮助我们更好地理解授权流程，我们可以看一下四个OAuth角色，如下所示:</p><ul class=""><li id="a9a5" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">资源所有者</li><li id="d571" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">资源服务器</li><li id="a867" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">客户</li><li id="88f4" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授权服务器</li></ul><h2 id="07c2" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">资源所有者</h2><p id="a02b" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">该角色通常与最终用户相关联，但也可以是能够授予受保护资源访问权限的任何实体。例如，如果资源是您的银行帐户，您将是资源所有者。</p><h2 id="ac13" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">资源服务器</h2><p id="caaa" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">资源服务器是托管受保护资源的服务器。在OAuth中，这个角色还处理访问请求。在我们的银行帐户示例中，银行将是资源服务器，因为它是拥有与您的帐户相关的所有信息的实体，并且可以处理对它的访问请求。</p><h2 id="2832" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">客户</h2><p id="f20f" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">客户端是一个第三方应用程序，它代表资源所有者尝试访问受保护的资源，但总是经过其授权。继续前面的例子，假设你向抵押贷款人申请贷款买房。他们需要访问你的一些账户信息，比如余额。作为帐户的所有者，您需要授权他们这样做，否则他们无法获取您的银行帐户信息。</p><p id="b1fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重要的是要知道OAuth定义了两种类型的客户端:机密客户端和公共客户端。</p><p id="8a56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">机密客户端是可以通过授权服务器进行安全身份验证的应用程序。这意味着这些应用程序可以以安全的方式保存凭据，而不会将它们暴露给未授权方。他们需要一个后端服务器来存储机密。</p><p id="fe72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相比之下，公共客户端是不能安全保存凭证的应用程序。这些应用程序不能保持凭证的机密性，因此它们不能使用注册的客户端。</p><h2 id="59f4" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">授权服务器</h2><p id="7a96" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">在资源所有者成功通过身份验证后，该服务器会为客户端生成具有所需授权的正确访问令牌。回到上面的抵押贷款情况，一旦你通过了银行的认证，并授权贷款人查看你的账户详情，银行将负责给予他们适当的访问权限。需要注意的是，您没有向贷方提供任何凭证，只授予了查看您的银行帐户的特定详细信息的权限。在OAuth中，授权以访问令牌(通常是JWT)的形式到达客户端。</p><p id="01a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">JWT或JSON Web令牌是一个紧凑的JSON对象，可以安全地传输，并且包含用JSON结构表示的声明。令牌内的信息是可信的，因为声明可以用消息认证码(MAC)进行数字签名、加密或保护。jwt的一个关键优势是它们可以在不联系任何第三方的情况下被验证。有关jwt的更多信息，请访问https://datatracker.ietf.org/doc/html/rfc7519<a class="ae lu" href="https://datatracker.ietf.org/doc/html/rfc7519" rel="noopener ugc nofollow" target="_blank"><em class="lt"/></a></p><p id="7dd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">授权服务器和资源服务器是同一个实体是很常见的，在我们的例子中，银行同时扮演这两个角色。</p><h1 id="59b3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">OAuth 2.0授权类型和流程</h1><p id="4717" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">客户端、授权服务器、资源所有者和资源服务器之间的交互称为授权流。在OAuth中，授权流根据客户端指定的授权机制的类型而变化。</p><p id="e825" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是OAuth定义的四种授权类型:</p><ul class=""><li id="0630" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">代码授权</li><li id="1e14" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">隐性资助</li><li id="a6bb" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授予资源所有者口令身份证明</li><li id="0ecf" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">客户端凭据授予</li></ul><p id="33a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OAuth还为授权许可提供了一种扩展机制。</p><p id="0e19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们想象一下下面的情况。</p><p id="9ddd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设你写完了一本书。在雇佣编辑之前，你需要先获得一些反馈。然后，你决定将你的书发布到XYZ网站上，让其他人阅读。当您访问WebApp时，系统会要求您从本地计算机或在线服务(如Google或Dropbox)添加图书。你选择使用谷歌，因为你的文档在硬盘里。登录后，会弹出一个窗口，告诉您该应用程序可以读取您的文档。你点击接受按钮，然后进入应用程序的用户界面，你可以从你的文档中选择你想要分享的文档。</p><p id="d9ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的例子描述了OAuth中的整个交互。为了更好地理解它，让我们从映射角色开始:</p><p id="70a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">资源所有者:我们，书的所有者</p><p id="20e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lt">客户端:</em>XYZ app</p><p id="5594" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lt">授权服务器:</em>谷歌</p><p id="a765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lt">资源服务器:</em>谷歌(驱动)</p><p id="1bb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在以下部分中，我们将详细介绍每个流程的交互:</p><h2 id="2c5f" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">代码授权</h2><p id="d7c2" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">代码授予授权流程是当今web应用程序中最常用的流程。在这个流中，客户端用授权令牌交换访问令牌。它通常用于具有服务器端组件的web应用程序，因为在流程的一部分中，客户端将与授权服务器交换其客户端秘密。这也是一个基于重定向的流程，因此客户端必须能够接收来自授权服务器的请求。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lv"><img src="../Images/21d85737fe547c7ed6de131e01fb6034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LSh4lYXHMbS_n4Ht"/></div></div></figure><p id="569e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下步骤描述了授权流程中的交换:</p><ol class=""><li id="69cb" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb mh jr js jt bi translated">我们打开XYZ网络应用程序，开始从谷歌共享文档。</li><li id="b308" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ应用程序请求谷歌授权。</li><li id="0599" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google将Web浏览器重定向到身份验证表单，这样我们就可以向Google服务器进行身份验证。</li><li id="a433" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">我们在表单中输入凭据，登录后，系统会询问我们即将授予XYZ WebApp的不同权限。认证请求被发送到Google。</li><li id="77dd" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">一旦通过认证，谷歌使用重定向URI向XYZ WebApp返回一个授权码。</li><li id="1d3e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ应用程序创建一个访问令牌请求，并将授权码作为请求的一部分发送出去。</li><li id="2173" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google验证访问令牌请求。在这一步中，Google必须确保授权码是发给经过身份验证的客户端的，并且该代码是有效的。</li><li id="1d51" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">将访问令牌返回给XYZ WebApp。</li><li id="4d98" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">通过访问令牌，XYZ WebApp从Google drive的API请求数据，并在请求头中发送令牌。</li><li id="08a5" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google drive API验证令牌并将信息返回给XYZ WebApp。</li></ol><p id="10c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个流程中有一些细节值得一提。</p><p id="2caa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在步骤2中，授权请求包括XYZ客户端ID、请求的范围和重定向URI，如果所有者允许访问，Google应该将浏览器重定向到该位置。对于步骤6中的请求，需要特别注意的是，客户端(XYZ WebApp)向授权服务器进行身份验证，因此请求包含clientID以及授权类型和授权代码。最后，在步骤7中，Google可以返回一个可选的刷新令牌，客户端可以用它来更新访问令牌。</p><h2 id="409c" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">隐性资助</h2><p id="8ed9" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">隐式授权流是为公共客户端创建的，比如单页面应用程序(SPA ),它缺少处理与其他系统交互的后端组件。这意味着当客户端发送授权请求时，访问令牌作为URL的一部分返回。客户端永远得不到授权码。建议不要再使用此流程，因为存在安全问题，如将访问令牌暴露在浏览器历史记录中。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mi"><img src="../Images/9ec176d67554789916d960f0eefad7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*El92STMBOG_cIQmX"/></div></div></figure><ol class=""><li id="ae23" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb mh jr js jt bi translated">我们打开XYZ网络应用程序，开始从谷歌共享文档。</li><li id="9e83" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ应用程序请求谷歌授权。</li><li id="b91b" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google将Web浏览器重定向到身份验证表单，这样我们就可以向Google服务器进行身份验证。</li><li id="5f8c" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">我们在表单中输入凭据，并向Google授权服务器提交登录请求。然后，我们被问及即将授予XYZ WebApp的不同权限。</li><li id="31a7" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">由于我们授予了访问权，Google授权服务器重定向回客户端。需要注意的是，重定向URI包含访问令牌。</li><li id="08ee" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ WebApp从Google drive的API请求数据，发送收到的访问令牌。</li><li id="dc3a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google drive API验证令牌并将信息返回给XYZ WebApp。</li></ol><p id="bad3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个流程与代码授予授权流程有几个不同之处:</p><ul class=""><li id="8a96" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">此流程中没有授权码交换。</li><li id="8d59" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">一旦授权服务器验证并确定所有者是否授权访问，就会返回访问令牌。</li><li id="e1d1" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">由于访问令牌是在重定向URI中返回的，因此不会颁发任何中间凭证。</li><li id="2421" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">授权服务器从不发送刷新令牌。</li></ul><p id="65b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管如此，就本书的例子而言，对于最终用户来说，流程实际上是相同的。</p><h2 id="652c" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">授予资源所有者口令身份证明</h2><p id="639e" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">当客户端和资源所有者(如操作系统)之间存在高度信任关系时，会使用此流程，因为客户端会要求资源所有者提供其凭证，通常是通过交互形式。它通常在迁移具有基本身份验证的旧客户端时使用，并且应该仅在基于重定向的流不可用时使用。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mj"><img src="../Images/80f84a53565552731749675fbb3f704e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*64EFnIklTN35BYUx"/></div></div></figure><ol class=""><li id="b7ea" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb mh jr js jt bi translated">我们打开XYZ WebApp，系统会要求我们使用凭据进行身份验证。</li><li id="0fbd" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ应用程序向Google授权服务器发送一个访问令牌请求，传递资源所有者的凭证。</li><li id="885e" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google授权服务器验证该请求。</li><li id="63f8" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google授权服务器对XYZ WebApp客户端进行身份验证，并发布一个访问令牌。</li><li id="9cc0" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">XYZ WebApp从Google drive的API请求数据，发送收到的访问令牌。</li><li id="aa3a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Google drive API验证令牌并将信息返回给XYZ WebApp。</li></ol><p id="d629" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们示例的上下文中，最大的区别是XYZ WebApp将预先要求我们提供凭据，然后将凭据连同授权请求一起传递给授权服务器，以换取令牌，而不是将我们重定向到授权服务器进行身份验证。这类似于几年前许多WebApps使用的旧的基本身份验证流程，但由于我们正在尝试授权第三方，基本身份验证应该作为最后手段使用。由于我们的凭证将与第三方共享，这是一种非常危险的做法，并且有很多安全隐患。这就是为什么不推荐这个流程，它只用于客户端和资源所有者之间的高度信任关系。</p><h2 id="3526" class="lf ka hh bd kb lg lh li kf lj lk ll kj ip lm ln kn it lo lp kr ix lq lr kv ls bi translated">客户端凭据授予</h2><p id="5399" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">在这个流中，客户端用自己的凭证请求授权。这意味着它将尝试使用自己的身份访问资源，而不是代表任何用户。这种类型的授权通常用于机器对机器的通信，如CLI、守护程序或服务，其中客户端ID和客户端密码被交换为访问令牌。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mk"><img src="../Images/88efdadce608b185a94c74657f8009f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L60IlUE5it4H6SHS"/></div></div></figure><p id="beee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个很好的例子是一个趋势服务，它每天连接到Twitter并查询十大趋势话题。在这个例子中，客户机向Twitter授权服务器注册，并获得客户机ID和客户机秘密。一旦服务运行，流程将如下所示:</p><ol class=""><li id="6f21" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb mh jr js jt bi translated">客户端发送一个身份验证请求，其中包括客户端Id和客户端密码以及正确的授权类型</li><li id="38f8" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">授权服务器验证凭证并对用户进行身份验证。身份验证也作为授权许可。</li><li id="d5fc" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">授权服务器返回访问令牌。不应发回任何刷新令牌。</li><li id="900a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">客户端调用受保护的Twitter API，发送收到的访问令牌。</li><li id="0d70" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb mh jr js jt bi translated">Twitter API验证令牌并将信息返回给客户端。</li></ol><p id="2dcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以看到，这类似于资源所有者密码凭据授权，但最大的区别是没有资源所有者凭据传递给第三方，而且通信发生在隐式授权的后端，因此很难篡改令牌。</p><p id="fbfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇文章易于理解，并为您提供了从事更详细的技术文档的必要信息。欲了解更多信息和详情，请访问:</p><ul class=""><li id="dd35" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated"><a class="ae lu" href="https://datatracker.ietf.org/doc/html/rfc6749" rel="noopener ugc nofollow" target="_blank">https://datatracker.ietf.org/doc/html/rfc6749</a>查看完整的OAuth2.0定义</li><li id="190a" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">OpenID规范的【https://openid.net/connect/】T2</li><li id="7f72" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">【https://datatracker.ietf.org/doc/html/rfc7519】为JWT标准。</li></ul></div></div>    
</body>
</html>