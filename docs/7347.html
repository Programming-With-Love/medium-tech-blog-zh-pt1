<html>
<head>
<title>Exploring Ruby 2.6: Enumerator, Hash, and Enumerable Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Ruby 2.6:枚举器、哈希和可枚举的变化</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/exploring-ruby-2-6-enumerator-hash-and-enumerable-changes-11ffa4b12eb9?source=collection_archive---------0-----------------------#2018-11-14">https://medium.com/square-corner-blog/exploring-ruby-2-6-enumerator-hash-and-enumerable-changes-11ffa4b12eb9?source=collection_archive---------0-----------------------#2018-11-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5ec1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">即将发布的ruby-2.6.0-preview3中尝试的新特性</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/507aad639b708915200d2ccc67274543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wBEt46mdsMmLa4vdUBOyw.png"/></div></div></figure><blockquote class="ji jj jk"><p id="4727" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ki" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="ae70" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">随着圣诞节的临近，我们将会看到越来越多的Ruby 2.6特性。其中有些讨论的不多，包括Enumerable和Enumerator，我发现那些变化特别有意思。让我们来看看。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es km"><img src="../Images/2284fa8f62759289509fd9434aaf135a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Y1YL2FrgkcXCnq30qT7Apw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx">Christmas is coming, and with it some fun new presents in Ruby!</figcaption></figure><h1 id="c7a3" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated">可枚举的#to_h</h1><p id="ad9c" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju kj ll jx jy kk lm kb kc kl ln kf kg kh ha bi translated">如果你在早期使用过Ruby，你可能会对<code class="du lo lp lq lr b">Hash[]</code>和它的用法很熟悉:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="c17e" class="lw ks hh lr b fi lx ly l lz ma">hash = { a: 1, b: 2 }<br/>Hash[hash.map { |k, v| [k, v + 1] }]<br/>=&gt; { a: 2, b: 3 }</span></pre><p id="5744" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">在2.x天，我们开始看到<code class="du lo lp lq lr b">Enumerable#to_h</code>:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="f7b1" class="lw ks hh lr b fi lx ly l lz ma">hash = { a: 1, b: 2 }<br/>hash.map { |k, v| [k, v + 1] }.to_h<br/>=&gt; { a: 2, b: 3 }</span></pre><p id="ffdf" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">这当然是一个更好的选择，但如果它更进一步呢？在Ruby 2.6+ <code class="du lo lp lq lr b">to_h</code>中会带一个功能相当类似map的块:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="49d4" class="lw ks hh lr b fi lx ly l lz ma">hash = { a: 1, b: 2 }<br/>hash.to_h { |k, v| [k, v + 1] }<br/>=&gt; { a: 2, b: 3 }</span></pre><p id="aeac" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">因为这是一个关于Enumerable的方法，所以我们也可以把它用在其他事情上，比如范围和数组:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="db80" class="lw ks hh lr b fi lx ly l lz ma">(1..5).to_h { |n| [n, n**2] }<br/>=&gt; {1=&gt;1, 2=&gt;4, 3=&gt;9, 4=&gt;16, 5=&gt;25}</span></pre><p id="4aeb" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">诚然，它不像<code class="du lo lp lq lr b">map</code>和<code class="du lo lp lq lr b">to_h</code>的组合那样明确，但它确实给了我们多一步来减少哈希转换代码。</p><h1 id="27db" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated">哈希#合并</h1><p id="32a1" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju kj ll jx jy kk lm kb kc kl ln kf kg kh ha bi translated">在Ruby的早期版本中，为了将多个散列合并在一起，您必须一次合并一个:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="c352" class="lw ks hh lr b fi lx ly l lz ma">h1.merge(h2).merge(h3).merge(h4)</span></pre><p id="1894" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">…或者可能使用double-splat将它们都视为一个大的内联散列:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="ff06" class="lw ks hh lr b fi lx ly l lz ma">h1.merge(**h2, **h3, **h4)</span></pre><p id="017a" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">…或者对于我们这些特别喜欢reduce的人来说，甚至有一种Ruby的味道！</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="aadf" class="lw ks hh lr b fi lx ly l lz ma">[h1, h2, h3, h4].reduce(&amp;:merge)</span></pre><p id="edf1" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">现在这些都工作了，但是有变化，这就是问题所在。Ruby 2.6为<code class="du lo lp lq lr b">Hash#merge</code>引入了可变参数:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="5b06" class="lw ks hh lr b fi lx ly l lz ma">h1.merge(h2, h3, h4)</span></pre><p id="3d54" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">请注意，这也适用于<code class="du lo lp lq lr b">Hash#merge!</code>和<code class="du lo lp lq lr b">Hash#update</code>。</p><h1 id="eb8f" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated">枚举器::算术序列</h1><p id="5fbf" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju kj ll jx jy kk lm kb kc kl ln kf kg kh ha bi translated">这个词很拗口——试着把它说五遍。如果你还没有打开你的REPL，那就打开吧。我们要尝试一些事情。</p><p id="df32" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">在2.6之前，如果你尝试这样做:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="58dd" class="lw ks hh lr b fi lx ly l lz ma">(1..100).step(3) == (1..100).step(3)</span></pre><p id="4d47" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">你会得到一个很好的机会。他们看起来一样，对吗？为什么不平等？</p><p id="e57d" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">结果核心团队同意了，所以他们创造了算术序列的概念来处理这个问题:</p><div class="mb mc ez fb md me"><a href="https://bugs.ruby-lang.org/issues/13904" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hi fi z dy mj ea eb mk ed ef hg bi translated">特性#13904:获取枚举器的原始信息- Ruby主干- Ruby问题跟踪…</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">红矿</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">bugs.ruby-lang.org</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms jg me"/></div></div></a></div><p id="4a6e" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">最大的问题是普查员没有真正的关于他们自己的内省信息，这意味着他们不太知道如何相互比较。</p><p id="6ca4" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">作为一个额外的好处，我们有更多的东西可以玩。主要是关键字，以使我们在创建步进枚举器时的意图更加明确:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="d72d" class="lw ks hh lr b fi lx ly l lz ma">(1..10).step(3) == 1.step(by: 3, to: 10)</span><span id="ab40" class="lw ks hh lr b fi mt ly l lz ma">1.step(by: 2, to: 10)<br/>=&gt; [1, 3, 5, 7, 9]</span><span id="a189" class="lw ks hh lr b fi mt ly l lz ma">(1..10).step(3)<br/>=&gt; [1, 4, 7]</span></pre><p id="33d7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们还发现了模运算符的一个新用途:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="66f8" class="lw ks hh lr b fi lx ly l lz ma">(1..100).step(3) == (1..100) % 3</span></pre><p id="4069" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">…尽管公平地说，我敢打赌，这一条将会比实际生产代码更频繁地用于code golf。</p><h1 id="daf7" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated">所有人现在在一起！</h1><p id="738d" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju kj ll jx jy kk lm kb kc kl ln kf kg kh ha bi translated">如果没有一个不可思议的、坦率地说是可怕的代码示例，这就不是一篇文章了。别害怕！我们得到了我们的老朋友FizzBuzz:</p><pre class="ix iy iz ja fd ls lr lt lu aw lv bi"><span id="a773" class="lw ks hh lr b fi lx ly l lz ma">def fizzbuzz(rules, range)<br/>  mappings = rules.map { |step, value|<br/>    (range % step).to_h { |n| [n, value || n] }<br/>  }</span><span id="8c0b" class="lw ks hh lr b fi mt ly l lz ma">  fizzbuzz_map = {}.merge(*mappings) { |_, old_value, new_value|<br/>    is_numeric = [old_value, new_value].any?(Numeric)<br/>    is_numeric ? new_value : old_value + new_value<br/>  }</span><span id="cd67" class="lw ks hh lr b fi mt ly l lz ma">  fizzbuzz_map.values<br/>end</span><span id="689d" class="lw ks hh lr b fi mt ly l lz ma">rules = {1 =&gt; nil, 3 =&gt; 'Fizz', 5 =&gt; 'Buzz'}<br/>range = (1..100)</span><span id="30b2" class="lw ks hh lr b fi mt ly l lz ma">puts fizzbuzz(rules, range)</span></pre><p id="8ff7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们在这里所做的是定义一个规则集，它使用一个散列来表示步进率(从范围中的最后一个数字开始要跳过多少个数字)和一个值。</p><p id="bf7f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">因为3和5的倍数有特殊的映射，所以我们在规则中这样说。这意味着当我们开始创建步长值时，它不会传递给语句<code class="du lo lp lq lr b">value || n</code>中的实际数值。</p><p id="3b17" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们的第一步是在给定的范围内转换每一个规则集，只选择能被给定步进率整除的数字。</p><p id="590e" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">关于<code class="du lo lp lq lr b">merge</code>的一个有趣的事情是，它可以使用一个块来公开这个键，以及在两个不同的哈希表中这个键的交叉值作为旧值和新值。利用这一点，我们可以决定“保留”哪个值。</p><p id="f5f3" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">我们总是假设字符串规则优先于基于数字的规则，如果已经有一个字符串，我们一定在那里找到了一个可以被15整除的数字。</p><p id="adf0" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">现在，这肯定是低效的，但仍然是一些新功能的有趣探索。</p><h1 id="19a7" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated">包扎</h1><p id="4c2b" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju kj ll jx jy kk lm kb kc kl ln kf kg kh ha bi translated">2.6中有很多有趣的新特性，其中很多甚至还没有出来。这只是一小部分，我们期待着看到其余的部分。</p><p id="0738" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju kj jw jx jy kk ka kb kc kl ke kf kg kh ha bi translated">感谢我的同事Square Shannon“haven wood”Skipper和我一起探索ruby-2.6.0-preview3的最新Ruby提交。我们在Square使用了大量的Ruby——在我们的Square Connect Ruby SDKs、我们维护的许多开源项目等等。我们热切期待Ruby 2.6的发布！</p></div></div>    
</body>
</html>