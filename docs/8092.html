<html>
<head>
<title>Modularization Using Graph-Style Serverless Pipeline Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图形式无服务器流水线框架的模块化</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/modularization-using-graph-style-serverless-pipeline-framework-fd41498c7769?source=collection_archive---------1-----------------------#2022-01-12">https://medium.com/walmartglobaltech/modularization-using-graph-style-serverless-pipeline-framework-fd41498c7769?source=collection_archive---------1-----------------------#2022-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9050" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据管道微服务设计小指南:第二部分</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/913ecda9c86079a61df5e65c6af3ea94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl2jZ1tgwrdgWFjtRXFcDA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo credit: Pixabay</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6a5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一部分<a class="ae jz" rel="noopener" href="/walmartglobaltech/modularization-using-python-and-docker-for-data-pipeline-1193bba7c207"> <strong class="ig hi">模块化使用Python和Docker进行数据管道</strong> </a>中，我提出了一个如何使用Docker来采用数据管道的框架。如果你还没看过，请点击上面的链接。</p><p id="3dea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如今，理解使用无服务器来降低成本并提高整个管道框架的规模是很重要的。那么，我们如何在我们的Python数据管道框架中采用无服务器集群或Dataproc呢？</p><p id="f580" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我将为Python展示一个新的<strong class="ig hi">图形风格的无服务器管道框架</strong>。它可以用于数据工程和机器学习工程。</p><h1 id="9b99" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">议程</h1><ul class=""><li id="c1d4" class="ky kz hh ig b ih la il lb ip lc it ld ix le jb lf lg lh li bi translated">挑战</li><li id="2c94" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">无服务器</li><li id="7545" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">图形风格的无服务器管道框架</li><li id="8387" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">例子</li><li id="8df6" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">摘要</li></ul></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="f036" class="ka kb hh bd kc kd lo kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ls kv kw kx bi translated">挑战</h1><ul class=""><li id="9737" class="ky kz hh ig b ih la il lb ip lc it ld ix le jb lf lg lh li bi translated">采用像DataProc这样的无服务器流程</li><li id="4b4b" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">降低编程效果——只需要关注逻辑</li><li id="6c8c" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">让管道对数据谱系更加清晰？</li><li id="fde1" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">让代码更具可读性？</li></ul><h1 id="6192" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">无服务器</h1><blockquote class="lt"><p id="6b75" class="lu lv hh bd lw lx ly lz ma mb mc jb dx translated">无服务器是一种云原生开发模型，允许开发人员构建和运行应用程序，而无需管理服务器。</p></blockquote><h1 id="fd3e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl md kn ko kp me kr ks kt mf kv kw kx bi translated">图形风格无服务器管道框架</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mg"><img src="../Images/98c4159c5e1dc65b50cf1b64086db3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82oORm7JYga914pU_achfA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 1. Infrastructure</figcaption></figure><p id="608b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了采用无服务器流程，我们需要为Python版本设计一个新的框架。让我们深入研究图1中的每个组件。</p><ul class=""><li id="ed3c" class="ky kz hh ig b ih ii il im ip mh it mi ix mj jb lf lg lh li bi translated"><strong class="ig hi"> <em class="mk"> Makefile / Looper </em> </strong>:我们用Makefile和Looper做来自GitHub的CICD进程。</li><li id="79e8" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi"><em class="mk">requirement . txt/init _ script . sh</em></strong>:这两个文件被airflow create cluster操作符用来初始化Dataproc集群。</li><li id="6209" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi"><em class="mk">workflow runner . py/demo _ prj . zip</em></strong>:这两个文件是气流提交操作员用来初始化工作流的。</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ml"><img src="../Images/a07e5242133de3fcb1d9f5a91289ad5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhrE0mxWiwjM5vm9kkflkg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 2. Framework Process</figcaption></figure><p id="9d17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于批处理流水线，这种方法可以满足无服务器的大部分要求。</p><p id="9d10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图2中，概述了要遵循的每个步骤。在示例部分，我们将深入探讨其中的大部分。</p><p id="d347" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个框架的另一个优点是图形风格的管道。对于大部分框架来说，它有一个DAG风格，但只是应用在第一层(上层)。例如，在图3中，大多数框架将提取器运行器、变压器1运行器、变压器2运行器和加载器运行器视为整个DAG中的节点。然而，对于更深的层次，他们只是把代码一行行或许多功能放在一起，使组件工作。在我们的新设计中，我们将水平和垂直级别都视为节点，如图3所示。我们将在示例部分看到更多的示例。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mm"><img src="../Images/6a937f1a458934e3fd8902942ad8dd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61Bqo9j4kBzHSUBKyHS6rg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 3. Framework Process — Graph Style</figcaption></figure><p id="2a67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图4中，我们可以发现使用这种新设计的好处。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mn"><img src="../Images/2f060c9890fb4b986bb1c882382ec606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wO4eDkLIpoxUJtwMKGhheA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 4. Benefits</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="88df" class="ka kb hh bd kc kd lo kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ls kv kw kx bi translated">例子</h1><p id="690d" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip mo ir is it mp iv iw ix mq iz ja jb ha bi translated">在这个例子中，我将浏览图2中已经讨论过的代码部分。这个ETL过程是读取CSV、删除重复数据和生成聚合。</p><p id="804e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。框架入口</strong></p><p id="4353" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">workflowRunner.py是我们框架的入口点。它定义了每一个工作流，并初始化了整个框架可以共享的spark。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="3fad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。工作流<br/> </strong>这是一个工作流，主要的函数是run()，所有其他的函数通过<em class="mk">装饰器连接在一起。在这种方法中，通过代码本身很容易理解数据谱系。</em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="341a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。组件/提取器、变压器、加载器<br/> </strong>提取器、变压器和加载器等所有其他组件的逻辑与工作流程相同。我们使用df_storage来存储所有需要在组件之间共享的变量。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="9099" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。CICD </strong></p><p id="4d91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们用Makefile压缩所有需要的代码，用looper做CICD。gcp_pip_install.sh用于安装集群下所有需要的包。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mr ms l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mr ms l"/></div></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="b17e" class="ka kb hh bd kc kd lo kf kg kh lp kj kk kl lq kn ko kp lr kr ks kt ls kv kw kx bi translated">摘要</h1><p id="b2a1" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip mo ir is it mp iv iw ix mq iz ja jb ha bi translated">这是无服务器数据管道微服务设计的又一个好方案。</p></div></div>    
</body>
</html>