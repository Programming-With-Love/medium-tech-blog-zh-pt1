<html>
<head>
<title>Busting Android performance myths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打破Android性能神话</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/busting-android-performance-myths-d85ae1d87f22?source=collection_archive---------0-----------------------#2020-09-29">https://medium.com/androiddevelopers/busting-android-performance-myths-d85ae1d87f22?source=collection_archive---------0-----------------------#2020-09-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d9c76d6f73eb3e4b0fde7cab1b4873ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sptV9J5Q2xTsG-Y9xZppw.png"/></div></div></figure><div class=""/><div class=""><h2 id="c14c" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">了解Android性能神话如何经得起考验</h2></div><p id="b6e5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">多年来，关于Android的性能出现了几个神话。虽然有些神话可能很有趣，但在寻找创建高性能Android应用程序时被送上了错误的方向，这一点也不好玩。</p><p id="48c9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这篇博文中，本着流言终结者的精神，我们将检验这些流言。为了打破神话，我们使用真实世界的例子和工具，你可以使用。我们关注主要的使用模式:作为开发者，你可能在你的应用中做的事情。有一个重要的警告，请记住，出于性能原因，在决定使用编码实践之前进行度量是非常重要的。也就是说，让我们打破一些神话。</p><h1 id="e7e3" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">误解1: Kotlin应用程序比Java应用程序更大更慢</h1><p id="203d" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Google Drive团队已经将他们的应用程序从Java转换为Kotlin。这一转换涉及170个文件中的16，000多行代码，涵盖了40多个构建目标。在团队监控的指标中，第一个是启动时间。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/47b40cabe0dc3cae0a8727ed953264c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HMsbHNNmEj0q1yrb"/></div></div></figure><p id="d729" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正如你所看到的，转换到科特林没有实质性的影响。</p><p id="7967" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">事实上，在整个基准测试套件中，团队没有观察到任何性能差异。他们确实看到了编译时间和编译代码大小的微小增加，但大约2%没有显著影响。</p><p id="7e91" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在好处方面，该团队实现了25%的代码行减少。他们的代码更干净，更清晰，也更容易维护。</p><p id="deeb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关于Kotlin需要注意的一点是，你可以也应该使用代码收缩工具，比如R8，它甚至有针对Kotlin的特定优化。</p><h1 id="eb6a" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">误解2:getter和setters很贵</h1><p id="451b" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">出于性能原因，一些开发人员选择公共字段，而不是使用setters和getters。通常的代码模式如下所示，getFoo作为我们的getter:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="97bd" class="lk ke hs lg b fi ll lm l ln lo">public class ToyClass {</span><span id="368a" class="lk ke hs lg b fi lp lm l ln lo">   public int foo;</span><span id="7712" class="lk ke hs lg b fi lp lm l ln lo">   public int getFoo() { return foo; }</span><span id="714d" class="lk ke hs lg b fi lp lm l ln lo">}</span><span id="bd32" class="lk ke hs lg b fi lp lm l ln lo">ToyClass tc = new ToyClass();</span></pre><p id="bf24" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们将其与使用公共字段tc.foo进行了比较，后者的代码打破了对象封装，直接访问字段。</p><p id="b3be" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们在装有Android 10的Pixel 3上使用<a class="ae lq" href="https://developer.android.com/studio/profile/benchmark" rel="noopener ugc nofollow" target="_blank"> Jetpack基准库</a>对此进行了基准测试。基准测试库提供了一种非常好的方法来轻松测试您的代码。该库的特点之一是它预先准备了代码，所以结果代表稳定的数字。</p><p id="c6a6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">那么，基准测试显示了什么？</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/ef693e1d2dd589ffe56139a9acbcb247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wbkp1A7_V8laRaRS"/></div></div></figure><p id="853e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">getter版本的性能与直接进入字段的版本一样好。这个结果并不令人惊讶，因为Android运行时(ART)在代码中内嵌了所有琐碎的访问方法。所以在JIT或AOT编译后执行的代码是一样的。事实上，当您在Kotlin中访问一个字段时——在本例中是TC . foo——您是在根据上下文使用getter或setter来访问该值。然而，因为我们内联了所有的访问器，所以ART已经涵盖了这里:在性能上没有区别。</p><p id="621a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您不使用Kotlin，除非您有充分的理由将字段公开，否则您不应该破坏良好的封装实践。隐藏你的类的私有数据是有用的，你不需要仅仅因为性能原因而暴露它。坚持使用getters和setters。</p><h1 id="b66e" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">误解3:lambda比内部类慢</h1><p id="7d99" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Lambdas是一种方便的语言构造，尤其是引入了流式API之后，它可以实现非常简洁的代码。</p><p id="2bfd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们来看一些代码，在这些代码中，我们对来自一个对象数组的一些内部字段的值求和。首先，通过map-reduce操作使用流式API。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4088" class="lk ke hs lg b fi ll lm l ln lo">ArrayList&lt;ToyClass&gt; array = build();</span><span id="79f1" class="lk ke hs lg b fi lp lm l ln lo">int sum = array.stream().map(tc -&gt; tc.foo).reduce(0, (a, b) -&gt; a + b);</span></pre><p id="5e66" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里，第一个lambda将对象转换为整数，第二个lambda将它产生的两个值相加。</p><p id="728f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这与为lambda表达式定义等价类形成对比。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="51cb" class="lk ke hs lg b fi ll lm l ln lo">ToyClassToInteger toyClassToInteger = new ToyClassToInteger();</span><span id="6ba1" class="lk ke hs lg b fi lp lm l ln lo">SumOp sumOp = new SumOp();</span><span id="fbcc" class="lk ke hs lg b fi lp lm l ln lo">int sum = array.stream().map(toyClassToInteger).reduce(0, sumOp);</span></pre><p id="57d1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有两个嵌套类:一个是toyClassToInteger，它将对象转换为整数，第二个是sum操作。</p><p id="17b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">显然，第一个例子，使用lambdas的例子，要优雅得多:大多数代码评审员可能会说使用第一个选项。</p><p id="4008" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是，性能差异呢？我们再次在装有Android 10的Pixel 3上使用Jetpack基准库，我们没有发现性能差异。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/dad8a197914f49b3ba7b966bcfd41cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UBNsamryvRy8Zgxe"/></div></div></figure><p id="42f9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从图中可以看出，我们还定义了一个顶级类，性能也没有什么不同。</p><p id="4f60" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">性能如此相似的原因是lambdas被翻译成匿名内部类。</p><p id="7f98" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以，不要写内部类，用lambda:它创建了更简洁、更干净的代码，你的代码审查员会喜欢的。</p><h1 id="dafb" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">误解4:分配对象是昂贵的，我应该使用池</h1><p id="0968" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Android使用最先进的内存分配和垃圾收集技术。几乎每个版本都改进了对象分配，如下图所示。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/89f0e0ab00322c30b7c984efceda5c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RP2kwLn9MbtPg6Ru"/></div></div></figure><p id="b5fd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">垃圾收集在各个版本之间也有了显著的改进。如今，垃圾收集对jank或app流畅度没有影响。下图显示了我们在Android 10中通过分代并发收集对短命对象的收集所做的改进。在新版本Android 11中也有明显的改进。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/e87a7fbcd2dd43773c458dea2b431250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2QorsoqRUJj0KhKt"/></div></div></figure><p id="46c2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在GC基准测试中，如H2，吞吐量大幅增加了170%以上，在真实应用中，如Google Sheets，吞吐量增加了68%。</p><p id="f8cd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">那么这如何影响编码选择，比如是否使用池来分配对象？</p><p id="30c8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您认为垃圾收集效率低，内存分配成本高，那么您会认为创建的垃圾越少，垃圾收集就越少。所以，不是每次使用时都创建新的对象，而是维护一个常用类型池，然后从那里获取对象？因此，您可能会实现如下内容:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3025" class="lk ke hs lg b fi ll lm l ln lo">Pool&lt;A&gt; pool[] = new Pool&lt;&gt;[50];</span><span id="52ba" class="lk ke hs lg b fi lp lm l ln lo">void foo() {</span><span id="7d18" class="lk ke hs lg b fi lp lm l ln lo">   A a = pool.acquire();</span><span id="28d4" class="lk ke hs lg b fi lp lm l ln lo">   …</span><span id="4b87" class="lk ke hs lg b fi lp lm l ln lo">   pool.release(a);</span><span id="3d63" class="lk ke hs lg b fi lp lm l ln lo">}</span></pre><p id="cdd9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里跳过了一些代码细节，但是您在代码中定义了一个池，从池中获取一个对象，并最终释放它。</p><p id="896a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了测试这一点，我们实现了微基准来测量两件事:从池中检索对象的标准分配的开销，以及CPU的开销，以确定垃圾收集是否会影响应用程序的性能。</p><p id="8d99" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这种情况下，我们使用了一个带有Android 10的Pixel 2 XL，在一个非常紧密的循环中运行了数千次分配代码。我们还通过添加额外的字段来模拟不同的对象大小，因为大小对象的性能可能不同。</p><p id="747b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，对象分配开销的结果是:</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/69086d096ea79b4705c6c147da06e1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uo_w_LzYAUiFrvax"/></div></div></figure><p id="e5eb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">其次，垃圾收集的CPU开销的结果是:</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/14dbac5136b6b25c363370178dae2950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UW6KyFWPOYpz7-xd"/></div></div></figure><p id="331b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以看到标准分配和对象池之间的差别很小。然而，当涉及到较大对象的垃圾收集时，池解决方案会稍微差一些。</p><p id="ee40" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种行为实际上是我们从垃圾收集中所期望的，因为通过汇集对象，您增加了应用程序的内存占用。突然，您占用了太多的内存，即使因为您正在共享对象而减少了垃圾收集调用的次数，每次垃圾收集调用的成本也会更高。这是因为垃圾收集器必须遍历更多的内存，以决定哪些仍然有效，哪些应该被收集。</p><p id="59d6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个流言被终结了吗？不完全是。对象池是否更高效取决于您的应用程序的需求。首先，不要忘记使用池的缺点，除了代码的复杂性:</p><ul class=""><li id="ef7a" class="lv lw hs jj b jk jl jn jo jq lx ju ly jy lz kc ma mb mc md bi translated">可能会占用更多内存</li><li id="58ae" class="lv lw hs jj b jk me jn mf jq mg ju mh jy mi kc ma mb mc md bi translated">冒着让对象存活超过所需时间的风险</li><li id="15f1" class="lv lw hs jj b jk me jn mf jq mg ju mh jy mi kc ma mb mc md bi translated">需要非常高效的池实现</li></ul><p id="30a3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是，池的方法对于大型或分配成本高的对象可能很有用。</p><p id="29a0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要记住的关键是在你选择之前要测试和衡量。</p><h1 id="c828" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">误解5:剖析我的可调试应用程序没问题</h1><p id="a54d" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">在你的应用程序可调试的时候对其进行剖析会非常方便，毕竟，你通常是在可调试模式下编码的。而且，即使debuggable中的剖析有点不准确，能够更快地迭代应该可以补偿。可惜没有。</p><p id="eb88" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了验证这个神话，我们查看了一些常见活动相关工作流的基准。结果如下图所示。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/2693c9f8ea0b287ccbcbaab7d58ed559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G3DDVYBx8-XegSHS"/></div></div></figure><p id="1724" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在一些测试中，比如反序列化，没有影响。然而，对于其他人来说，基准上有50%或更多的回归。我们甚至发现了慢了100%的例子。这是因为当你的代码可调试时，运行时很少对它进行优化，所以用户在生产设备上运行的代码是非常不同的。</p><p id="a8c2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在debuggable中进行评测的结果是，你可能会被误导到应用程序中的热点，并且可能会浪费时间优化一些不需要优化的东西。</p><h1 id="dd44" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">奇怪的事情</h1><p id="1139" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">我们现在要远离流言蜚语，把注意力转向一些更奇怪的事情。这些都不是我们可以打破的神话。相反，这些事情可能不会立即变得明显或容易分析，但结果可能会让你的世界天翻地覆。</p><h1 id="b274" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">陌生感1: Multidex:对我的app性能有影响吗？</h1><p id="2042" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">apk越来越大。他们已经很久没有适应传统dex规范的约束了。如果您的代码超出了方法计数限制，Multidex是您应该使用的解决方案。</p><p id="7ad6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">问题是，有多少方法是太多了？如果一个应用程序有大量的dex文件，会对性能产生影响吗？这可能不是因为您的应用程序太大，您可能只是想根据特性拆分dex文件以便于开发。</p><p id="20c4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了探究多个dex文件对性能的影响，我们使用了calculator应用程序。默认情况下，它是一个单一的dex文件应用程序。然后，我们根据它的包边界将它分割成五个dex文件，以模拟根据特性的分割。</p><p id="9e2a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，我们测试了性能的几个方面，从启动时间开始。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/93063e78f2204a984de55eb310aac5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*trjzpDOQpLbgFNvV"/></div></div></figure><p id="73c6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以分割dex文件在这里没有影响。对于其他应用程序，可能会有轻微的开销，这取决于几个因素:应用程序有多大以及它是如何分割的。然而，只要合理地分割dex文件，并且不添加数百个文件，对启动时间的影响应该是最小的。</p><p id="87e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">APK的大小和内存怎么样？</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/84055ae52f40b0459336efadb38400c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0-61ZDBsfpeWqsS6"/></div></div></figure><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/03ce8ba21a4e8e3cb7af76478a1aa183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fgW2o3w1ftMuFXKu"/></div></div></figure><p id="bfcd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正如你所看到的，APK大小和应用程序的运行时内存占用都略有增加。这是因为，当您将应用程序拆分为多个dex文件时，每个dex文件都有一些用于符号表和缓存的重复数据。</p><p id="51f3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是，您可以通过减少dex文件之间的依赖性来最小化这种增加。在我们的例子中，我们没有努力去减少它。如果我们试图最小化依赖，我们会期待R8和D8工具。这些工具自动分割dex文件，并帮助您避免常见的缺陷和最小化依赖性。例如，这些工具不会创建比所需更多的dex文件，也不会将所有的启动类放在主文件中。但是，如果您对dex文件进行自定义分割，请始终测量您要分割的内容。</p><h1 id="fabd" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">陌生感2:死代码</h1><p id="c69d" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">将运行时与ART这样的JIT编译器一起使用的好处之一是，运行时可以分析代码，然后优化它。有一种理论认为，如果代码没有被解释器/JIT系统分析，它可能也不会被执行。为了验证这一理论，我们检查了谷歌应用程序生成的艺术档案。我们发现很大一部分app代码没有被ART解释器-JIT系统分析。这表明许多代码实际上从未在设备上执行过。</p><p id="39cf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有几种类型的代码可能不会被分析:</p><ul class=""><li id="309d" class="lv lw hs jj b jk jl jn jo jq lx ju ly jy lz kc ma mb mc md bi translated">错误处理代码，希望不会经常执行。</li><li id="520d" class="lv lw hs jj b jk me jn mf jq mg ju mh jy mi kc ma mb mc md bi translated">向后兼容的代码，不能在所有设备上执行的代码，尤其不能在Android 5或更高版本的设备上执行。</li><li id="ec1c" class="lv lw hs jj b jk me jn mf jq mg ju mh jy mi kc ma mb mc md bi translated">不常用功能的代码。</li></ul><p id="6a47" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，我们看到的不对称分布强烈表明应用程序中可能存在大量不必要的代码。</p><p id="cd7a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">快速，简单，免费的方法来删除不必要的代码是缩小与R8。接下来，如果您还没有这样做，请将您的应用程序转换为使用<a class="ae lq" href="https://developer.android.com/guide/app-bundle" rel="noopener ugc nofollow" target="_blank"> Android应用程序捆绑包</a>并播放功能交付。它们允许您通过只安装被使用的特性来改善用户体验。</p><h1 id="3320" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">学习</h1><p id="402b" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">我们已经打破了许多关于Android性能的神话，但也看到，在某些情况下，事情并不明朗。因此，在选择复杂的优化或者甚至是打破良好编码实践的小优化之前，进行基准测试和测量是至关重要的。</p><p id="18f8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有很多工具可以帮助你衡量和决定什么最适合你的应用。例如，Android Studio有针对本机和非本机代码的分析器，它甚至有针对电池和网络使用的分析器。有工具可以挖掘得更深，比如Perfetto和Systrace。这些工具可以提供非常详细的视图，例如，在应用程序启动或执行过程中发生的情况。</p><p id="dc66" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Jetpack基准库消除了测量和基准测试的所有复杂性。我们强烈建议您在持续集成中使用它来跟踪性能，并在您添加更多功能时查看您的应用程序的行为。最后，同样重要的是，不要在调试模式下进行分析。</p><p id="8cfd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Java是Oracle和/或其附属公司的注册商标。</p></div></div>    
</body>
</html>