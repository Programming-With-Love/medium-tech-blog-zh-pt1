<html>
<head>
<title>What is `this`? The Inner Workings of JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是什么？JavaScript对象的内部工作方式</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a?source=collection_archive---------3-----------------------#2019-03-26">https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a?source=collection_archive---------3-----------------------#2019-03-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/df85d3dc93b07c6091cc725b0aff5939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-p49V6XkQRrvh5w4vauSg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><em class="it">Photo: Curious by Liliana Saeb (CC BY 2.0)</em></figcaption></figure><p id="50ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">JavaScript是一种多范例语言，支持面向对象编程和动态绑定。动态绑定是一个强大的概念，它允许JavaScript代码的结构在运行时改变，但这种额外的能力和灵活性是以一些混乱为代价的，而很多混乱都集中在JavaScript中的行为上。</p><h1 id="9734" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">动态绑定</h1><p id="2e51" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">动态绑定是确定在运行时而不是编译时调用的方法的过程。JavaScript通过<code class="du kv kw kx ky b">this</code>和原型链实现了这一点。特别是，方法中的<code class="du kv kw kx ky b">this</code>的含义是在运行时确定的，规则根据方法的定义而变化。</p><p id="06a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们玩一个游戏。我把这个游戏叫做“什么是<code class="du kv kw kx ky b">this</code>？”</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="e058" class="lh jt hh ky b fi li lj l lk ll">const a = {<br/>  a: 'a'<br/>};</span><span id="db14" class="lh jt hh ky b fi lm lj l lk ll">const obj = {<br/>  getThis: () =&gt; this,<br/>  getThis2 () {<br/>    return this;<br/>  }<br/>};</span><span id="c0c6" class="lh jt hh ky b fi lm lj l lk ll">obj.getThis3 = obj.getThis.bind(obj);<br/>obj.getThis4 = obj.getThis2.bind(obj);</span><span id="cc69" class="lh jt hh ky b fi lm lj l lk ll">const answers = [<br/>  1, obj.getThis(),<br/>  2, obj.getThis.call(a),<br/>  3, obj.getThis2(),<br/>  4, obj.getThis2.call(a),<br/>  5, obj.getThis3(),<br/>  6, obj.getThis3.call(a),<br/>  7, obj.getThis4(),<br/>  8, obj.getThis4.call(a),<br/>];</span></pre><p id="3964" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在你继续之前，写下你的答案。完成后，<code class="du kv kw kx ky b">console.log()</code>检查你的答案。你猜对了吗？</p><p id="dc5f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们从第一个案例开始，一步步往下。在ES6模块的上下文中，<code class="du kv kw kx ky b">obj.getThis()</code>返回<code class="du kv kw kx ky b">undefined</code>。在脚本标签中，它是<code class="du kv kw kx ky b">window</code>。在节点REPL，是<code class="du kv kw kx ky b">global</code>。</p><p id="9f34" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为什么？箭头函数永远不能有自己的<code class="du kv kw kx ky b">this</code>绑定。相反，它们总是委托给词法范围。在ES6模块的根作用域中，词法作用域将有一个未定义的<code class="du kv kw kx ky b">this</code>。<code class="du kv kw kx ky b">obj.getThis.call(a)</code>也是<code class="du kv kw kx ky b">undefined</code>，同理。对于箭头功能，<code class="du kv kw kx ky b">this</code>不能重新分配，即使有<code class="du kv kw kx ky b">.call()</code>或<code class="du kv kw kx ky b">.bind()</code>。它将总是委托给词法<code class="du kv kw kx ky b">this</code>。</p><p id="332f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du kv kw kx ky b">obj.getThis2()</code>通过正常的方法调用过程获得它的绑定。如果没有先前的<code class="du kv kw kx ky b">this</code>绑定，并且函数可以绑定<code class="du kv kw kx ky b">this</code>(即，它不是一个箭头函数)，那么<code class="du kv kw kx ky b">this</code>将绑定到使用<code class="du kv kw kx ky b">.</code>或<code class="du kv kw kx ky b">[squareBracket]</code>属性访问语法调用该方法的对象。</p><p id="aea5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有点棘手。方法调用一个带有给定的<code class="du kv kw kx ky b">this</code>值和可选参数的函数。换句话说，它从<code class="du kv kw kx ky b">.call()</code>参数中获取其<code class="du kv kw kx ky b">this</code>绑定，因此<code class="du kv kw kx ky b">obj.getThis2.call(a)</code>返回<code class="du kv kw kx ky b">a</code>对象。</p><p id="b482" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du kv kw kx ky b">obj.getThis3 = obj.getThis.bind(obj);</code>中，我们试图绑定一个箭头函数，我们已经确定这个函数不起作用，所以对于<code class="du kv kw kx ky b">obj.getThis3()</code>和<code class="du kv kw kx ky b">obj.getThis3.call(a)</code>，我们回到<code class="du kv kw kx ky b">undefined</code>(或<code class="du kv kw kx ky b">window</code>或<code class="du kv kw kx ky b">global</code>)。</p><p id="fb71" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以绑定常规方法，因此<code class="du kv kw kx ky b">obj.getThis4()</code>如预期的那样返回<code class="du kv kw kx ky b">obj</code>，并且因为它已经与<code class="du kv kw kx ky b">obj.getThis4 = obj.getThis2.bind(obj);</code>绑定，<code class="du kv kw kx ky b">obj.getThis4.call(a)</code>考虑第一次绑定并返回<code class="du kv kw kx ky b">obj</code>而不是<code class="du kv kw kx ky b">a</code>。</p><h1 id="f9d3" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">曲线球</h1><p id="d3e4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">同样的挑战，但是这一次，<code class="du kv kw kx ky b">class</code>使用了公共字段语法(在撰写本文时，<a class="ae ln" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank"> Stage 3 </a>，在Chrome中默认可用，使用<code class="du kv kw kx ky b">@babel/plugin-proposal-class-properties</code>):</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="982c" class="lh jt hh ky b fi li lj l lk ll">class Obj {<br/>  getThis = () =&gt; this<br/>  getThis2 () {<br/>    return this;<br/>  }<br/>}</span><span id="9dce" class="lh jt hh ky b fi lm lj l lk ll">const obj2 = new Obj();<br/>obj2.getThis3 = obj2.getThis.bind(obj2);<br/>obj2.getThis4 = obj2.getThis2.bind(obj2);</span><span id="6c04" class="lh jt hh ky b fi lm lj l lk ll">const answers = [<br/>  1, obj2.getThis(),<br/>  2, obj2.getThis.call(a),<br/>  3, obj2.getThis2(),<br/>  4, obj2.getThis2.call(a),<br/>  5, obj2.getThis3(),<br/>  6, obj2.getThis3.call(a),<br/>  7, obj2.getThis4(),<br/>  8, obj2.getThis4.call(a),<br/>];</span></pre><p id="3d7c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在你继续之前写下你的答案。</p><p id="3030" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">准备好了吗？</p><p id="bf38" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了<code class="du kv kw kx ky b">obj2.getThis2.call(a)</code>，这些都返回对象实例。异常返回<code class="du kv kw kx ky b">a</code>对象。箭头函数<em class="lo">仍然委托给词法</em> <code class="du kv kw kx ky b"><em class="lo">this</em></code> <em class="lo">。</em>区别在于词法<code class="du kv kw kx ky b">this</code>对于类属性是不同的。在幕后，该类属性赋值被编译成如下形式:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="3da6" class="lh jt hh ky b fi li lj l lk ll">class Obj {<br/>  constructor() {<br/>    this.getThis = () =&gt; this;<br/>  }<br/>...</span></pre><p id="7323" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">换句话说，箭头函数是在构造函数的上下文中定义的<em class="lo">。</em>既然是类，那么创建实例的唯一方法就是使用<code class="du kv kw kx ky b">new</code>关键字(省略<code class="du kv kw kx ky b">new</code>会抛出错误)。</p><p id="3e2f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关键字<code class="du kv kw kx ky b">new</code>做的最重要的事情之一是实例化一个新的对象实例，并在构造函数中将<code class="du kv kw kx ky b">this</code>绑定到它。这种行为，结合我们上面已经提到的其他行为，应该可以解释其余的。</p><h1 id="38d1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="46e5" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">你做得怎么样？你拿到了吗？很好地理解<code class="du kv kw kx ky b">this</code>在JavaScript中的行为将为您节省大量调试棘手问题的时间。如果你有任何一个答案错了，练习会对你有好处。玩这些例子，然后回来再次测试自己，直到你们都能通过测试，并向其他人解释为什么这些方法返回它们所返回的内容。</p><p id="7bf9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果这比你想象的要难，你并不孤单。我在这个话题上测试了相当多的开发者，我认为到目前为止只有一个开发者通过了测试。</p><p id="f820" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最初可以用<code class="du kv kw kx ky b">.call()</code>、<code class="du kv kw kx ky b">.bind()</code>或<code class="du kv kw kx ky b">.apply()</code>重定向的动态方法查找，随着<code class="du kv kw kx ky b">class</code>和arrow函数行为的加入，变得更加复杂。这可能有助于划分一点。请记住，arrow函数总是将<code class="du kv kw kx ky b">this</code>委托给词法范围，而<code class="du kv kw kx ky b">class</code> <code class="du kv kw kx ky b">this</code>实际上是词法范围内的构造函数。如果你对什么是<code class="du kv kw kx ky b">this</code>有疑问，记得使用你的调试器来验证对象是你认为的那样。</p><p id="5a56" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还要记住，在JavaScript中，不使用<code class="du kv kw kx ky b">this</code>也可以做很多事情。根据我的经验，几乎任何东西都可以用纯函数来重新实现，这些纯函数将它们所应用的所有参数作为显式参数(你可以把<code class="du kv kw kx ky b">this</code>看作是具有可变状态的隐式参数)。封装在纯函数中的逻辑是确定性的，这使得它更易测试，并且没有副作用，这意味着与操作<code class="du kv kw kx ky b">this</code>不同，你不太可能破坏任何其他东西。每一次你改变<code class="du kv kw kx ky b">this</code>，你就冒了依赖于<code class="du kv kw kx ky b">this</code>值的其他东西将被破坏的风险。</p><p id="cc41" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也就是说，<code class="du kv kw kx ky b">this</code>有时是有用的。例如，在大量对象之间共享方法。即使在函数式编程中，<code class="du kv kw kx ky b">this</code>也可以用来访问对象上的其他方法来实现代数派生，从而在现有代数的基础上构建新的代数。例如，一个通用的<code class="du kv kw kx ky b">.flatMap()</code>可以通过访问<code class="du kv kw kx ky b">this.map()</code>和<code class="du kv kw kx ky b">this.flatten()</code>得到:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="2871" class="lh jt hh ky b fi li lj l lk ll">flatMap (f) {<br/>  return this.map(f).flatten();<br/>}</span></pre></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><p id="32f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="lo"> Eric Elliott </em> </strong> <em class="lo">是一位分布式系统专家，著有《编写软件》</em><a class="ae ln" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"><em class="lo"/></a><em class="lo"/><a class="ae ln" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"><em class="lo">【编程JavaScript应用】</em> </a> <em class="lo">等书籍。作为</em><a class="ae ln" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="lo">devanywhere . io</em></a><em class="lo">的联合创始人，他教授开发人员远程工作和拥抱工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，并为Adobe Systems、</em> <strong class="iw hi"> <em class="lo">、Zumba Fitness、</em> </strong> <em class="lo"> </em> <strong class="iw hi"> <em class="lo">、华尔街日报、</em> </strong> <em class="lo"> </em> <strong class="iw hi"> 【T42、</strong><em class="lo"/><strong class="iw hi"><em class="lo">BBC、</em> </strong> <em class="lo">和顶级录音艺术家(包括</em> <strong class="iw hi"> <em class="lo"> Usher、弗兰克·奥申、Metallica</em></strong></p><p id="0b51" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>