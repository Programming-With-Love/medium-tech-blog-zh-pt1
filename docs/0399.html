<html>
<head>
<title>Coroutines on Android (part I): Getting the background</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的协同程序(第一部分):了解背景</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb?source=collection_archive---------0-----------------------#2019-04-30">https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb?source=collection_archive---------0-----------------------#2019-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a0be03964836145a1dc72cbfd017a28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K__YGB4eb12WKTRwpvAuhg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="819a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是关于在Android上使用协程的系列文章的一部分。这篇文章关注协程是如何工作的，以及它们解决了什么问题。</p><h2 id="3600" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">本系列的其他文章:</h2><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第二部分):入门</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">这是关于在Android上使用协程的系列文章的一部分。这一部分的重点是开始工作和保持…</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第三部分):实际工作</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">了解如何使用协程来完成实际工作，比如使用数据库或发出网络请求。</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><h1 id="205d" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">协程解决什么问题？</h1><p id="e080" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">Kotlin <a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协同程序</a>引入了一种新的并发方式，可以在Android上用来简化异步代码。虽然它们是kot Lin 1.3中的新内容，但协程的概念自编程语言诞生以来就一直存在。第一个探索使用协程的语言是1967年的<a class="ae hu" href="https://en.wikipedia.org/wiki/Simula" rel="noopener ugc nofollow" target="_blank"> Simula </a>。</p><p id="b0bc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在过去的几年中，协程越来越受欢迎，现在已经包含在许多流行的编程语言中，例如<a class="ae hu" href="https://javascript.info/async-await" rel="noopener ugc nofollow" target="_blank"> Javascript </a>、<a class="ae hu" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/" rel="noopener ugc nofollow" target="_blank"> C# </a>、<a class="ae hu" href="https://docs.python.org/3/library/asyncio-task.html" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae hu" href="https://ruby-doc.org/core-2.1.1/Fiber.html" rel="noopener ugc nofollow" target="_blank"> Ruby </a>和<a class="ae hu" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank"> Go </a>等等。Kotlin协程是基于已经被用于构建大型应用程序的既定概念。</p><p id="401d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，协程是两个问题的绝佳解决方案:</p><ol class=""><li id="77c4" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><strong class="iw hy">长时间运行的任务</strong>是花费太长时间阻塞主线程的任务。</li><li id="cf6e" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy"> Main-safety </strong>允许您确保任何挂起函数都可以从主线程调用。</li></ol><p id="30d6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们深入到每一个方面，看看协程如何帮助我们以一种更简洁的方式构建代码！</p><h1 id="ae4c" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">长期运行的任务</h1><p id="2d69" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">获取网页或与API交互都涉及发出网络请求。类似地，从数据库中读取或从磁盘中加载映像也涉及到读取文件。这类事情就是我所说的长时间运行的任务——对于你的应用程序来说，停止并等待它们需要太长的时间！</p><p id="eaa0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与网络请求相比，很难理解现代手机执行代码的速度有多快。在Pixel 2上，一个CPU周期需要不到0.0000000004秒，这个数字对人类来说很难理解。然而，如果你把一个网络请求想象成一眨眼，大约400毫秒(0.4秒)，就更容易理解CPU的运行速度。一眨眼的功夫，或者稍微慢一点的网络请求，CPU就能执行超过十亿个周期！</p><p id="e981" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，每个应用都有一个主线程，负责处理UI(如绘图视图)和协调用户交互。如果这个线程上有太多的工作发生，应用程序似乎会挂起或变慢，导致不良的用户体验。任何长时间运行的任务都应该在不阻塞主线程的情况下完成，这样你的应用就不会显示所谓的“jank”，比如冻结的动画，或者对触摸事件反应缓慢。</p><p id="ed31" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了在主线程之外执行网络请求，一种常见的模式是回调。回调提供了一个库的句柄，它可以用来在将来的某个时候回调你的代码。通过回调，获取developer.android.com可能如下所示:</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="5bd2" class="js jt hx mr b fi mv mw l mx my">class ViewModel: ViewModel() {<br/>   fun fetchDocs() {<br/>       get("developer.android.com") { result -&gt;<br/>           show(result)<br/>       }<br/>    }<br/>}</span></pre><p id="2678" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">即使从主线程调用<code class="du mz na nb mr b">get</code>，它也会使用另一个线程来执行网络请求。然后，一旦从网络获得结果，回调将在主线程上被调用。这是处理长时间运行任务的好方法，像<a class="ae hu" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改型</a>这样的库可以帮助你在不阻塞主线程的情况下发出网络请求。</p><h1 id="11a4" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">为长时间运行的任务使用协程</h1><p id="66b5" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">协程是一种简化用于管理像<code class="du mz na nb mr b">fetchDocs</code>这样的长时间运行任务的代码的方法。为了探究协程如何简化长时间运行任务的代码，让我们重写上面的回调示例来使用协程。</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="5a35" class="js jt hx mr b fi mv mw l mx my">// Dispatchers.Main<br/>suspend fun fetchDocs() {<br/>    // Dispatchers.Main<br/>    val result = get("developer.android.com")<br/>    // Dispatchers.Main<br/>    show(result)<br/>}</span><span id="a63c" class="js jt hx mr b fi nc mw l mx my">// look at this in the next section<br/>suspend fun get(url: String) = withContext(Dispatchers.IO){/*...*/}</span></pre><p id="8c7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这段代码不会阻塞主线程吗？它如何在不等待网络请求和阻塞的情况下从<code class="du mz na nb mr b">get</code>返回一个结果？原来协程为Kotlin提供了一种方法来执行这段代码，并且永远不会阻塞主线程。</p><p id="2222" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">协程通过添加两个新操作来构建常规函数。除了<strong class="iw hy"> invoke </strong>(或call)和<strong class="iw hy"> return </strong>之外，协程增加了<strong class="iw hy"> suspend </strong>和<strong class="iw hy"> resume </strong>。</p><ul class=""><li id="6b14" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr nd me mf mg bi translated"><strong class="iw hy">暂停</strong> —暂停当前协程的执行，保存所有局部变量</li><li id="6b36" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr nd me mf mg bi translated"><strong class="iw hy">恢复</strong> —从暂停的地方继续暂停的协程</li></ul><p id="3760" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个功能是Kotlin通过函数上的suspend关键字添加的。您只能从其他挂起函数调用挂起函数，或者通过使用像<code class="du mz na nb mr b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" rel="noopener ugc nofollow" target="_blank">launch</a></code>这样的协程构建器来启动一个新的协程。</p><blockquote class="ne"><p id="6ff5" class="nf ng hx bd nh ni nj nk nl nm nn jr dx translated">挂起和恢复工作一起代替回调。</p></blockquote><p id="5644" class="pw-post-body-paragraph iu iv hx iw b ix no iz ja jb np jd je jf nq jh ji jj nr jl jm jn ns jp jq jr ha bi translated">在上面的例子中，<code class="du mz na nb mr b">get</code>会在<strong class="iw hy">开始网络请求之前挂起</strong>协程。函数<code class="du mz na nb mr b">get</code>将仍然负责在主线程之外运行网络请求。然后，当网络请求完成时，它可以简单地<strong class="iw hy">恢复</strong>它挂起的协程，而不是调用回调来通知主线程。</p><figure class="mm mn mo mp fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nt"><img src="../Images/137e80a24c8beb00f43b1d09764a92aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U24_ZyMJKI_c2qMspCXxZw.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Animation showing how Kotlin implements suspend and resume to replace callbacks.</figcaption></figure><p id="278d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看看<code class="du mz na nb mr b">fetchDocs</code>是如何执行的，你就能明白<strong class="iw hy">如何挂起</strong>了。每当一个协程被挂起时，当前的堆栈帧(Kotlin用来跟踪哪个函数正在运行及其变量的地方)被复制并保存，以备后用。当<strong class="iw hy">恢复</strong>时，堆栈帧从其保存的位置复制回来，并再次开始运行。在动画中间——当主线程上的所有协程都被挂起时，主线程可以自由地更新屏幕和处理用户事件。挂起和恢复一起替换回调。相当整洁！</p><blockquote class="ne"><p id="559b" class="nf ng hx bd nh ni nj nk nl nm nn jr dx translated">当主线程上的所有协程被挂起时，主线程可以自由地做其他工作。</p></blockquote><p id="f97d" class="pw-post-body-paragraph iu iv hx iw b ix no iz ja jb np jd je jf nq jh ji jj nr jl jm jn ns jp jq jr ha bi translated">即使我们编写了看起来完全像阻塞网络请求的简单的顺序代码，协程将完全按照我们想要的方式运行我们的代码，并避免阻塞主线程！</p><p id="2825" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，让我们看看如何使用协程来保证主安全，并探索一下调度程序。</p><h1 id="5a09" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">使用协程的主安全</h1><p id="4bef" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在Kotlin协程中，从主线程调用写得好的挂起函数总是安全的。不管他们做什么，他们应该总是允许任何线程调用他们。</p><p id="f4de" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，我们在Android应用程序中做的很多事情在主线程上发生太慢了。网络请求、解析JSON、读取或写入数据库，甚至只是迭代大型列表。任何这些都有可能运行缓慢，导致用户可见的“jank ”,应该在主线程之外运行。</p><p id="af2c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用<code class="du mz na nb mr b">suspend</code>并没有告诉Kotlin在后台线程上运行一个函数。值得一提的是，协程将在主线程上运行。事实上，使用<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-coroutine-dispatcher/immediate.html" rel="noopener ugc nofollow" target="_blank">调度器确实是个好主意。Main.immediate </a>当启动一个协程来响应一个UI事件时——这样，如果你没有完成一个需要main-safety的长时间运行的任务，结果可以在下一帧中提供给用户。</p><blockquote class="ne"><p id="453d" class="nf ng hx bd nh ni nj nk nl nm nn jr dx translated">协程会在主线程上运行，挂起不代表后台。</p></blockquote><p id="f8c0" class="pw-post-body-paragraph iu iv hx iw b ix no iz ja jb np jd je jf nq jh ji jj nr jl jm jn ns jp jq jr ha bi translated">要让一个对主线程来说太慢的函数成为主安全的，你可以告诉Kotlin协同程序在<code class="du mz na nb mr b">Default</code>或<code class="du mz na nb mr b">IO</code>调度程序上执行工作。在Kotlin中，所有协程都必须运行在调度程序中——即使它们运行在主线程上。协程程序可以<strong class="iw hy">挂起</strong>自己，而调度程序知道如何<strong class="iw hy">恢复</strong>它们。</p><p id="cffe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了指定协程应该在哪里运行，Kotlin提供了三个<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">调度器</a>供您用于线程调度。</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="6469" class="js jt hx mr b fi mv mw l mx my"><strong class="mr hy">+-----------------------------------+<br/>|         Dispatchers.</strong><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" rel="noopener ugc nofollow" target="_blank"><strong class="mr hy">Main</strong></a><strong class="mr hy">          |<br/>+-----------------------------------+</strong><br/>| Main thread on Android, interact  |<br/>| with the UI and perform light     |<br/>| work                              |<br/>+-----------------------------------+<br/>| - Calling suspend functions       |<br/>| - Call UI functions               |<br/>| - Updating LiveData               |<br/>+-----------------------------------+<br/><br/><strong class="mr hy">+-----------------------------------+<br/>|          Dispatchers.</strong><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html" rel="noopener ugc nofollow" target="_blank"><strong class="mr hy">IO</strong></a><strong class="mr hy">           |<br/>+-----------------------------------+</strong><br/>| Optimized for disk and network IO |<br/>| off the main thread               |<br/>+-----------------------------------+<br/>| - Database*                       |<br/>| - Reading/writing files           |<br/>| - Networking**                    |<br/>+-----------------------------------+<br/><strong class="mr hy"><br/>+-----------------------------------+<br/>|        Dispatchers.</strong><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" rel="noopener ugc nofollow" target="_blank"><strong class="mr hy">Default</strong></a><strong class="mr hy">        |<br/>+-----------------------------------+</strong><br/>| Optimized for CPU intensive work  |<br/>| off the main thread               |<br/>+-----------------------------------+<br/>| - Sorting a list                  |<br/>| - Parsing JSON                    |<br/>| - DiffUtils                       |<br/>+-----------------------------------+</span></pre><p id="e17c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="nu"> * </em> <a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank"> <em class="nu">房间</em> </a> <em class="nu">使用</em> <a class="ae hu" rel="noopener" href="/androiddevelopers/room-coroutines-422b786dc4c5"> <em class="nu">暂停功能</em> </a> <em class="nu">、</em><a class="ae hu" rel="noopener" href="/androiddevelopers/room-rxjava-acb0cd4f3757"><em class="nu">rx Java</em></a><em class="nu">或</em><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata#use_livedata_with_room" rel="noopener ugc nofollow" target="_blank"><em class="nu">LiveData</em></a><em class="nu">将自动提供主安全。</em></p><p id="c4c5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="nu"> **网络库，如</em> <a class="ae hu" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank"> <em class="nu">改型</em> </a> <em class="nu">和</em> <a class="ae hu" href="https://developer.android.com/training/volley" rel="noopener ugc nofollow" target="_blank"> <em class="nu">凌空</em> </a> <em class="nu">管理它们自己的线程，当与Kotlin协程一起使用时，不需要在代码中显式主安全。</em></p><p id="559a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">继续上面的例子，让我们使用调度程序来定义<code class="du mz na nb mr b">get</code>函数。在<code class="du mz na nb mr b">get</code>的主体内部，您调用<code class="du mz na nb mr b">withContext(Dispatchers.IO)</code>来创建一个将在<code class="du mz na nb mr b">IO</code>调度程序上运行的块。您放入该块的任何代码将总是在<code class="du mz na nb mr b">IO</code>调度程序上<em class="nu">执行。由于<code class="du mz na nb mr b">withContext</code>本身是一个挂起函数，它将使用协程来提供主要的安全性。</em></p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="4609" class="js jt hx mr b fi mv mw l mx my">// Dispatchers.Main<br/>suspend fun fetchDocs() {<br/>    // Dispatchers.Main<br/>    val result = get("developer.android.com")<br/>    // Dispatchers.Main<br/>    show(result)<br/>}</span><span id="23ea" class="js jt hx mr b fi nc mw l mx my">// Dispatchers.Main<br/>suspend fun get(url: String) =<br/>    // Dispatchers.Main<br/>    withContext(Dispatchers.IO) {<br/>        // Dispatchers.IO<br/>        /* perform blocking network IO here */<br/>    }<br/>    // Dispatchers.Main</span></pre><p id="c1bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用协程，您可以通过细粒度的控制进行线程调度。因为<code class="du mz na nb mr b">withContext</code>允许您控制任何代码行在哪个线程上执行，而无需引入回调来返回结果，所以您可以将它应用于非常小的功能，比如从数据库读取数据或执行网络请求。所以一个好的做法是使用<code class="du mz na nb mr b">withContext</code>来确保每个函数都可以安全地在任何<code class="du mz na nb mr b">Dispatcher</code>上被调用，包括<code class="du mz na nb mr b">Main</code>——这样调用者就不必考虑执行函数需要什么线程。</p><p id="a1f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，<code class="du mz na nb mr b">fetchDocs</code>在主线程上执行，但是可以安全地调用<code class="du mz na nb mr b">get</code>，后者在后台执行网络请求。因为协程支持<strong class="iw hy">挂起</strong>和<strong class="iw hy">恢复</strong>，所以一旦<code class="du mz na nb mr b">withContext</code>块完成，主线程上的协程将恢复，并产生结果。</p><blockquote class="ne"><p id="fb6a" class="nf ng hx bd nh ni nj nk nl nm nn jr dx translated">写得好的挂起函数从主线程调用总是安全的(或者说是主安全的)。</p></blockquote><p id="5836" class="pw-post-body-paragraph iu iv hx iw b ix no iz ja jb np jd je jf nq jh ji jj nr jl jm jn ns jp jq jr ha bi translated">让每个挂起函数都是main-safe的确实是个好主意。如果它做了任何涉及磁盘、网络的事情，甚至只是使用了太多的CPU，使用<code class="du mz na nb mr b">withContext</code>使它从主线程调用变得安全。这是基于协程的库(如retrieval和Room)遵循的模式。如果您在整个代码库中遵循这种风格，您的代码将会更加简单，并且避免将线程问题与应用程序逻辑混淆。当一致遵循时，协程可以在主线程上自由启动，用简单的代码发出网络或数据库请求，同时保证用户不会看到“jank”。</p><h1 id="0e4b" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">withContext性能</h1><p id="c8f5" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在提供主安全方面，与回调或RxJava一样快。在某些情况下，甚至可以优化<code class="du mz na nb mr b">withContext</code>调用，而不仅仅是回调。如果一个函数将对一个数据库进行10次调用，你可以告诉Kotlin在所有10次调用的外围<code class="du mz na nb mr b">withContext</code>中切换一次。然后，即使数据库库将重复调用<code class="du mz na nb mr b">withContext</code>，它也将停留在同一个调度程序上，并遵循一条快速路径。此外，优化了<code class="du mz na nb mr b">Dispatchers.Default</code>和<code class="du mz na nb mr b">Dispatchers.IO</code>之间的切换，以尽可能避免线程切换。</p><h1 id="5b97" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">下一步是什么</h1><p id="3445" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在这篇文章中，我们探索了协程擅长解决什么问题。协程在编程语言中是一个非常古老的概念，最近变得流行起来，因为它们能够使与网络交互的代码更简单。</p><p id="86bc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android上，你可以用它们来解决两个真正常见的问题:</p><ol class=""><li id="33d5" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated">简化长时间运行任务的代码，比如从网络、磁盘读取数据，甚至解析大型JSON结果。</li><li id="2150" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">执行精确的main-safety，确保您永远不会意外地阻塞主线程，而不会使代码难以读写。</li></ol><p id="12c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一篇文章中，我们将探索它们如何适应Android，以跟踪你从屏幕上开始的所有工作！读一读:</p><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第二部分):入门</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">这是关于在Android上使用协程的系列文章的一部分。这一部分的重点是开始工作和保持…</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div></div></div>    
</body>
</html>