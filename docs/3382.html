<html>
<head>
<title>Single Thread Dart, What? — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单线镖，什么？—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/globant/single-thread-dart-what-ccbca2543ae9?source=collection_archive---------0-----------------------#2020-01-07">https://medium.com/globant/single-thread-dart-what-ccbca2543ae9?source=collection_archive---------0-----------------------#2020-01-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9bb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我知道你们中的一些人可能会对我说有Async Await和RxDart，所以不要担心兄弟。我完全投入其中，但是在阅读了很多为什么应用程序性能在Flutter中是强制性的之后，我知道Dart是一个单线程框架。</p><p id="4868" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Dart是一个单线程系统。有时我们很难使用它，因为现在每种语言都使用多线程系统，dart使用旧的概念，但它还没有结束，Dart仍在发展。采取这一点的主要原因是开始颤振隔离，但让我们首先检查为什么我们需要有隔离。</p><blockquote class="jc jd je"><p id="90fb" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><em class="hh">要点Dart一次执行一个操作，一个接一个，这意味着只要一个操作正在执行，它就不能被任何其他Dart代码中断。</em></p></blockquote><p id="196f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个默认的新flutter应用程序，它将创建一个增量计数器模板。</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="8363" class="js jt hh jo b fi ju jv l jw jx">@override<br/> Widget build(BuildContext context) {<br/>  return Scaffold(<br/>   appBar: AppBar(<br/>    title: Text(widget.title),<br/>   ),<br/>   body: Center(<br/>    child: Column(<br/>     mainAxisAlignment: MainAxisAlignment.center,<br/>     children: &lt;Widget&gt;[<br/>      CircularProgressIndicator(),<br/>      Text(<br/>       'You have pushed the button this many times:',<br/>      ),<br/>      Text(<br/>       '$_counter',<br/>       style: Theme.of(context).textTheme.display1,<br/>      ),<br/>     ],<br/>    ),<br/>   ),<br/>   floatingActionButton: FloatingActionButton(<br/>    onPressed: _incrementCounter,<br/>    tooltip: 'Increment',<br/>    child: Icon(Icons.add),<br/>   ), // This trailing comma makes auto-formatting nicer for build methods.<br/>  );<br/> }</span></pre><p id="010d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们增加了循环进度指示器，只是为了检查用户界面何时卡住或跳帧。让我们更新incrementCounter函数。</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="2651" class="js jt hh jo b fi ju jv l jw jx">void _incrementCounter() {<br/>  setState(() {<br/>   var string = Constants.str;<br/>   for(int index = 0;index &lt;10;index++) {<br/>    for (int i = 0; i &lt; string.length; i++) {<br/>     string += string[i];<br/>    }<br/>   }</span><span id="7a31" class="js jt hh jo b fi jy jv l jw jx">   _counter++;<br/>  });<br/> }</span></pre><p id="469e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击FAB按钮，圆形进度条停留一会儿，然后再次加载。这是由于主线程(或者我可以说主隔离，叶的主线程在这里颤振是主隔离)的沉重负担。嗯，你可能会说“啊！！这很简单，只需将这段代码放入一个异步函数中，然后从那里调用它,“嗯，这是正确的，但它不会工作。为什么？因为Dart基于事件循环机制工作，这意味着它为主线程或任何隔离线程创建事件，并基于事件优先级运行。</p><h2 id="9ba3" class="js jt hh bd jz ka kb kc kd ke kf kg kh ip ki kj kk it kl km kn ix ko kp kq kr bi translated">事件循环</h2><p id="3d3a" class="pw-post-body-paragraph ie if hh ig b ih ks ij ik il kt in io ip ku ir is it kv iv iw ix kw iz ja jb ha bi translated">事件循环有点像无限队列或循环，永远运行。示例:创建一个异步函数并调用它。在这个时间点上，事件循环包含的是这个信息序列。</p><ol class=""><li id="591a" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">返回该方法的输出，即Future</li><li id="c3b3" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">同步运行异步函数，直到第一个await关键字。</li><li id="cba1" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">等待异步函数完成并执行剩余代码。</li></ol><blockquote class="jc jd je"><p id="f7bb" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><em class="hh">异步方法不是并行执行的，而是遵循事件的常规顺序，也由事件循环处理。</em></p></blockquote><p id="44e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以如果我们有</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="274e" class="js jt hh jo b fi ju jv l jw jx">main(){<br/>  method1();<br/>  method2();<br/>}<br/>method1() async{<br/>  print("1");<br/>}<br/>method2() async{<br/>  Future((){<br/>    print("Future 2"); <br/>  });<br/>  print("2");<br/>}</span></pre><p id="1f43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出:</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="2c2b" class="js jt hh jo b fi ju jv l jw jx">1<br/>2<br/>Future 2</span></pre><p id="e444" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在主隔离中，事件循环包含的内容是这样的</p><ol class=""><li id="f655" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">呼叫方法1</li><li id="5df3" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">呼叫方法2</li><li id="36b0" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">从方法2添加未来事件</li><li id="97e0" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">执行打印语句</li><li id="7149" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">执行方法2中的未来事件</li></ol><p id="000c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么方法2的未来不在打印2之前运行？因为每个入口点都在事件循环内部，并且因为在那个时间点不需要期货，所以下一个序列将在期货之前执行。如果我们稍微调整一下代码，它会显示一个不同的结果。</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="ac28" class="js jt hh jo b fi ju jv l jw jx">method2() async{<br/>  await Future((){<br/>    print("Future 2"); <br/>  });<br/>  print("2");<br/>}</span></pre><p id="00e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在可以打印了</p><pre class="jj jk jl jm fd jn jo jp jq aw jr bi"><span id="b11e" class="js jt hh jo b fi ju jv l jw jx">1<br/>Future 2<br/>2</span></pre><p id="714f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为事件循环知道它需要在执行下一条语句之前等待结果。</p><blockquote class="jc jd je"><p id="529f" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated"><em class="hh">在执行main方法后，每次更改都必须通过事件循环来更新数据。因此，在构建Flutter应用程序时，你可能会感到UI滞后。像做IO操作或位图操作是一种CPU或磁盘处理，它需要在事件循环中花费大量时间，所以下一帧不会得到更新，用户界面将被卡住一段时间。检查</em> <code class="du ll lm ln jo b"><em class="hh">--profile</em></code> <em class="hh">标志以获得更多细节来检查flutter中的轮廓工具(将在后面的文章中介绍如何检查)。</em></p></blockquote><p id="68dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考链接:</p><ol class=""><li id="151c" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><a class="ae lo" href="https://www.youtube.com/watch?v=vl_AaCgudcY" rel="noopener ugc nofollow" target="_blank">从Flutter Devs中分离和事件循环介绍视频</a></li></ol><p id="9b71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">TLDR；</p><p id="231b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Flutter使用dart，dart使用事件循环，所以flutter也是单线程系统。这就是为什么我们必须避免在主线程上进行一些密集工作，比如写入文件或获取数据以及操作大型计算操作。</p><p id="773b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">继续阅读下面的第2部分。</p><div class="lp lq ez fb lr ls"><a rel="noopener follow" target="_blank" href="/@parthdave93/single-thread-dart-what-part-2-a5592bef5213"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hi fi z dy lx ea eb ly ed ef hg bi translated">单线镖，什么？—第二部分</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">Dart对异步功能使用隔离和事件循环，不要错过引导异步将在主线程上运行…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">medium.com</p></div></div></div></a></div><p id="0de9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你知道你可以按拍手吗👏按钮50次？你走得越高，我就越有动力为你们写更多的东西！</p><p id="ef69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你好，我是帕斯·戴夫。noob开发者和noob摄影师。你可以在<a class="ae lo" href="https://in.linkedin.com/in/parth-dave-907b8177" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我，或者在<a class="ae lo" href="https://github.com/parthdave93" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上跟踪我，或者在<a class="ae lo" href="https://twitter.com/the_parth_dave" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我？</p><p id="ed90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">祝你有一个愉快的飞行日！</p></div></div>    
</body>
</html>