<html>
<head>
<title>Cancellation in coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协同程序中的取消</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629?source=collection_archive---------0-----------------------#2020-03-11">https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629?source=collection_archive---------0-----------------------#2020-03-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/05e0b7a4fbd9022bff79291d6e0673b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GiGx7izt4tOtEiuh"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="5f61" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">协程中的取消和异常(下)</h2></div><p id="5b53" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在开发中，就像在生活中一样，我们知道避免做多余的工作很重要，因为这会浪费内存和精力。这个原则也适用于协程。您需要确保控制协程的生命周期，并在不再需要时取消它——这就是结构化并发所代表的。继续阅读，了解协程取消的来龙去脉。</p><p id="d97c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你喜欢看这个视频，可以看看我和Manuel Vivo在KotlinConf'19上关于协程取消和异常的演讲:</p><figure class="kk kl km kn fd hj"><div class="bz dy l di"><div class="ko kp l"/></div></figure><blockquote class="kq kr ks"><p id="b8fe" class="jm jn kt jo b jp jq iy jr js jt jb ju ku jw jx jy kv ka kb kc kw ke kf kg kh ha bi translated">⚠️为了毫无问题地理解文章的其余部分，阅读和理解系列文章的第一部分是必需的。</p></blockquote><div class="hg hh ez fb hi kx"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-first-things-first-e6187bf3bb21"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hy fi z dy lc ea eb ld ed ef hw bi translated">协程:先做最重要的事情</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">协同程序中的取消和异常(第一部分)</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ho kx"/></div></div></a></div><h1 id="e94a" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">呼叫取消</h1><p id="aae7" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">当启动多个协程时，跟踪它们或者单独取消每个协程会很痛苦。相反，我们可以依赖于取消启动协程的整个范围，因为这将取消创建的所有子协程:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="7ba5" class="mo ln hx mk b fi mp mq l mr ms">// assume we have a scope defined for this layer of the app</span><span id="4de7" class="mo ln hx mk b fi mt mq l mr ms">val job1 = scope.launch { … }<br/>val job2 = scope.launch { … }</span><span id="f1d8" class="mo ln hx mk b fi mt mq l mr ms"><strong class="mk hy">scope.cancel()</strong></span></pre><blockquote class="mu"><p id="6a2b" class="mv mw hx bd mx my mz na nb nc nd kh dx translated">取消范围会取消其子范围</p></blockquote><p id="5c19" class="pw-post-body-paragraph jm jn hx jo b jp ne iy jr js nf jb ju jv ng jx jy jz nh kb kc kd ni kf kg kh ha bi translated">有时，您可能只需要取消一个协程，这可能是对用户输入的一种反应。调用job1.cancel可以确保只有那个特定的协同例程被取消，而其他所有的兄弟例程不受影响:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="9620" class="mo ln hx mk b fi mp mq l mr ms">// assume we have a scope defined for this layer of the app</span><span id="f77e" class="mo ln hx mk b fi mt mq l mr ms">val job1 = scope.launch { … }<br/>val job2 = scope.launch { … }</span><span id="f558" class="mo ln hx mk b fi mt mq l mr ms">// First coroutine will be cancelled and the other one won’t be affected<br/><strong class="mk hy">job1.cancel()</strong></span></pre><blockquote class="mu"><p id="2895" class="mv mw hx bd mx my mz na nb nc nd kh dx translated">被取消的孩子不会影响其他兄弟姐妹</p></blockquote><p id="c7aa" class="pw-post-body-paragraph jm jn hx jo b jp ne iy jr js nf jb ju jv ng jx jy jz nh kb kc kd ni kf kg kh ha bi translated">协程通过抛出一个特殊的异常来处理取消:<code class="du nj nk nl mk b">CancellationException</code>。如果你想提供更多关于取消原因的细节，你可以在调用<code class="du nj nk nl mk b">.cancel</code>时提供一个<code class="du nj nk nl mk b">CancellationException</code>的实例，因为这是完整的方法签名:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="59a6" class="mo ln hx mk b fi mp mq l mr ms">fun cancel(cause: CancellationException? = null)</span></pre><p id="3e96" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您不提供自己的<code class="du nj nk nl mk b">CancellationException</code>实例，将会创建一个默认的<code class="du nj nk nl mk b">CancellationException</code>(完整代码<a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/JobSupport.kt#L612" rel="noopener ugc nofollow" target="_blank">在这里</a>):</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="40b5" class="mo ln hx mk b fi mp mq l mr ms">public override fun cancel(cause: CancellationException?) {<br/>    cancelInternal(cause ?: defaultCancellationException())<br/>}</span></pre><p id="4559" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为抛出了<code class="du nj nk nl mk b">CancellationException</code>，所以您将能够使用这种机制来处理协程取消。在下面的<em class="kt">处理取消副作用</em>部分有更多关于如何做的信息。</p><p id="8f35" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在幕后，子作业通过异常通知其父作业取消。父进程使用取消的原因来确定它是否需要处理异常。如果子代由于<code class="du nj nk nl mk b">CancellationException</code>而被取消，则父代不需要任何其他操作。</p><blockquote class="mu"><p id="68b4" class="mv mw hx bd mx my nm nn no np nq kh dx translated">⚠️Once如果你取消了一个作用域，你将不能在被取消的作用域中启动新的协程。</p></blockquote><p id="06de" class="pw-post-body-paragraph jm jn hx jo b jp ne iy jr js nf jb ju jv ng jx jy jz nh kb kc kd ni kf kg kh ha bi translated">如果你正在使用androidx KTX库，在大多数情况下你不会创建你自己的作用域，因此你不负责取消它们。如果你在一个<code class="du nj nk nl mk b">ViewModel</code>的范围内工作，使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope" rel="noopener ugc nofollow" target="_blank">viewModelScope</a></code>，或者，如果你想启动绑定到一个生命周期范围的协程，你可以使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#lifecyclescope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a></code>。<code class="du nj nk nl mk b">viewModelScope</code>和<code class="du nj nk nl mk b">lifecycleScope</code>都是在适当的时候被取消的<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineScope</a></code>对象。例如，<a class="ae hu" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">当ViewModel被清除</a>时，它取消在其作用域中启动的协程。</p><h1 id="00b1" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">为什么我的协程工作没有停止？</h1><p id="66c4" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">如果我们只是调用<code class="du nj nk nl mk b">cancel</code>，并不意味着协程工作就此停止。如果您正在执行一些相对较重的计算，比如从多个文件中读取，没有什么会自动阻止您的代码运行。</p><p id="ef5a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们举一个更简单的例子，看看会发生什么。假设我们需要使用协程每秒打印两次“Hello”。我们将让协程运行一会儿，然后取消它。实现的一个版本如下所示:</p><figure class="kk kl km kn fd hj"><div class="bz dy l di"><div class="nr kp l"/></div></figure><p id="7e15" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们一步一步来看看会发生什么。当调用<code class="du nj nk nl mk b">launch</code>时，我们在<strong class="jo hy">活动</strong>状态下创建一个新的协程。我们让协程运行1000毫秒。所以现在我们看到印刷的:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="79e8" class="mo ln hx mk b fi mp mq l mr ms">Hello 0<br/>Hello 1<br/>Hello 2</span></pre><p id="47e8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一旦<code class="du nj nk nl mk b">job.cancel</code>被调用，我们的协程就移动到<em class="kt">取消</em>状态。但是接下来，我们看到Hello 3和Hello 4被打印到终端。只有在工作完成后，协程才移动到<em class="kt">取消</em>状态。</p><p id="67e9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">调用cancel时，协程工作不会停止。相反，我们需要修改我们的代码，并定期检查协程是否处于活动状态。</p><blockquote class="mu"><p id="19f2" class="mv mw hx bd mx my nm nn no np nq kh dx translated">取消协程代码需要合作！</p></blockquote><h1 id="1b18" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd ns je ly jg nt jh ma jj nu jk mc md bi translated">使您的协同工作可取消</h1><p id="d69b" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">您需要确保您正在实现的所有协同工作都与取消相配合，因此您需要定期检查取消，或者在开始任何长时间运行的工作之前检查取消。例如，如果您正在从磁盘读取多个文件，在开始读取每个文件之前，请检查协程是否被取消。这样，当不再需要CPU密集型工作时，您可以避免这样做。</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="1891" class="mo ln hx mk b fi mp mq l mr ms">val job = launch {<br/>    for(file in files) {<br/>        // TODO check for cancellation<br/>        readFile(file)<br/>    }<br/>}</span></pre><p id="2070" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">从<code class="du nj nk nl mk b">kotlinx.coroutines</code>开始的所有暂停功能都可以取消:<code class="du nj nk nl mk b">withContext</code>、<code class="du nj nk nl mk b">delay</code>等。所以如果你正在使用它们中的任何一个，你不需要检查取消和停止执行或者抛出一个<code class="du nj nk nl mk b">CancellationException</code>。但是，如果您不使用它们，为了使您的协同程序代码具有协作性，我们有两种选择:</p><ul class=""><li id="0b42" class="nv nw hx jo b jp jq js jt jv nx jz ny kd nz kh oa ob oc od bi translated">检查<code class="du nj nk nl mk b">job.isActive</code>或<code class="du nj nk nl mk b">ensureActive()</code></li><li id="5cef" class="nv nw hx jo b jp oe js of jv og jz oh kd oi kh oa ob oc od bi translated">使用<code class="du nj nk nl mk b">yield()</code>让其他工作发生</li></ul><h1 id="20ed" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">检查作业的活动状态</h1><p id="df62" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">在我们的<code class="du nj nk nl mk b">while(i&lt;5)</code>中，有一个选项是为协程状态添加另一个检查:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="8823" class="mo ln hx mk b fi mp mq l mr ms">// Since we're in the launch block, we have access to job.isActive<br/>while (i &lt; 5 &amp;&amp; <strong class="mk hy">isActive</strong>)</span></pre><p id="00fa" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这意味着我们的工作应该只在协程活动时执行。这也意味着一旦我们离开了while，如果我们想做一些其他的动作，比如记录作业是否被取消，我们可以为<code class="du nj nk nl mk b">!isActive</code>添加一个检查，并在那里执行我们的动作。</p><p id="4bba" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">协程库提供了另一个有用的方法- <code class="du nj nk nl mk b">ensureActive()</code>。它的实现是:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="4912" class="mo ln hx mk b fi mp mq l mr ms">fun Job.ensureActive(): Unit {<br/>    if (!isActive) {<br/>         throw getCancellationException()<br/>    }<br/>}</span></pre><p id="4cee" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为如果作业不是活动的，这个方法会立即抛出，所以我们可以将它作为while循环中要做的第一件事:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="20da" class="mo ln hx mk b fi mp mq l mr ms">while (i &lt; 5) {<br/>    ensureActive()<br/>    …<br/>}</span></pre><p id="eb37" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">通过使用<code class="du nj nk nl mk b">ensureActive</code>，您避免了自己实现<code class="du nj nk nl mk b">isActive</code>所要求的if语句，减少了您需要编写的样板代码的数量，但是失去了执行任何其他动作(如日志记录)的灵活性。</p><h1 id="99b6" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">使用yield()让其他工作发生</h1><p id="e2d7" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">如果您正在做的工作1) CPU繁重，2)可能耗尽线程池，3)您希望允许线程做其他工作，而不必向线程池添加更多线程，那么使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html" rel="noopener ugc nofollow" target="_blank">yield()</a></code>。yield完成的第一个操作是检查完成情况，如果任务已经完成，则抛出<code class="du nj nk nl mk b">CancellationException</code>退出协程。<code class="du nj nk nl mk b">yield</code>可以是周期检查中调用的第一个函数，就像上面提到的<code class="du nj nk nl mk b">ensureActive()</code>一样。</p><h1 id="0f01" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">作业.加入与延期.等待取消</h1><p id="0484" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">等待协程结果有两种方式:从<code class="du nj nk nl mk b">launch</code>返回的作业可以调用<code class="du nj nk nl mk b">join</code>，从<code class="du nj nk nl mk b">async</code>返回的<code class="du nj nk nl mk b">Deferred</code>(T3的一种)可以调用<code class="du nj nk nl mk b">await</code></p><p id="6463" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">挂起协同程序，直到工作完成。与<code class="du nj nk nl mk b">job.cancel</code>一起，它的行为如你所料:</p><ul class=""><li id="15e1" class="nv nw hx jo b jp jq js jt jv nx jz ny kd nz kh oa ob oc od bi translated">如果你调用<code class="du nj nk nl mk b">job.cancel</code>然后<code class="du nj nk nl mk b">job.join</code>，协程将暂停直到任务完成。</li><li id="2e69" class="nv nw hx jo b jp oe js of jv og jz oh kd oi kh oa ob oc od bi translated">在<code class="du nj nk nl mk b">job.join</code>之后调用<code class="du nj nk nl mk b">job.cancel</code>没有效果，因为作业已经完成。</li></ul><p id="8571" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当您对协程的结果感兴趣时，可以使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html" rel="noopener ugc nofollow" target="_blank">Deferred</a></code>。当协程完成时，这个结果由<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html" rel="noopener ugc nofollow" target="_blank">Deferred.await</a></code>返回。<code class="du nj nk nl mk b">Deferred</code>是<code class="du nj nk nl mk b">Job</code>的一种，也可以取消。</p><p id="0ec4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在被<code class="du nj nk nl mk b">cancel</code> led的延迟上调用<code class="du nj nk nl mk b">await</code>会抛出一个<code class="du nj nk nl mk b">JobCancellationException</code>。</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="59c6" class="mo ln hx mk b fi mp mq l mr ms">val deferred = async { … }</span><span id="627d" class="mo ln hx mk b fi mt mq l mr ms">deferred.cancel()<br/>val result = deferred.await() // throws JobCancellationException!</span></pre><p id="2aa3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下面是我们得到这个异常的原因:<code class="du nj nk nl mk b">await</code>的作用是挂起协程，直到计算出结果；由于协程被取消，因此无法计算结果。因此，取消后调用await导致<code class="du nj nk nl mk b">JobCancellationException: Job was cancelled</code>。</p><p id="810c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">另一方面，如果你在<code class="du nj nk nl mk b">deferred.await</code>之后调用<code class="du nj nk nl mk b">deferred.cancel</code>，什么都不会发生，因为协程已经完成了。</p><h1 id="afd0" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">处理取消副作用</h1><p id="6484" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">比方说，当一个协程被取消时，您想要执行一个特定的动作:关闭您可能正在使用的任何资源，记录取消或者您想要执行的一些其他清理代码。有几种方法可以做到这一点:</p><h2 id="24a4" class="mo ln hx bd lo oj ok ol ls om on oo lw jv op oq ly jz or os ma kd ot ou mc ov bi translated">检查！isActive</h2><p id="2dfe" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">如果您定期检查<code class="du nj nk nl mk b">isActive</code>，那么一旦您脱离了while循环，您就可以清理资源。我们上面的代码可以更新为:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="b5be" class="mo ln hx mk b fi mp mq l mr ms">while (i &lt; 5 &amp;&amp; <strong class="mk hy">isActive</strong>) {<br/>    // print a message twice a second<br/>    if (…) {<br/>        println(“Hello ${i++}”)<br/>        nextPrintTime += 500L<br/>    }<br/>}</span><span id="5686" class="mo ln hx mk b fi mt mq l mr ms"><strong class="mk hy">// the coroutine work is completed so we can cleanup<br/>println(“Clean up!”)</strong></span></pre><p id="f64f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这里看它的作用<a class="ae hu" href="https://pl.kotl.in/loI9DaIYj" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="140b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所以现在，当协程不再活动时，<code class="du nj nk nl mk b">while</code>将会中断，我们可以进行清理了。</p><h2 id="34ef" class="mo ln hx bd lo oj ok ol ls om on oo lw jv op oq ly jz or os ma kd ot ou mc ov bi translated">最后试着接住</h2><p id="de10" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">因为当一个协程被取消时会抛出一个<code class="du nj nk nl mk b">CancellationException</code>,那么我们可以在<code class="du nj nk nl mk b">try/catch</code>和<code class="du nj nk nl mk b">finally</code>块中包装我们暂停的工作，我们可以实现我们的清理工作。</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="029c" class="mo ln hx mk b fi mp mq l mr ms">val job = launch {<br/>   try {<br/>      work()<br/>   } catch (e: CancellationException){<br/>      println(“Work cancelled!”)<br/>    <strong class="mk hy">} finally {<br/>      println(“Clean up!”)<br/>    }</strong><br/>}</span><span id="ee93" class="mo ln hx mk b fi mt mq l mr ms">delay(1000L)<br/>println(“Cancel!”)<br/>job.cancel()<br/>println(“Done!”)</span></pre><p id="b203" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是，如果我们需要执行的清理工作被挂起，上面的代码将不再工作，因为一旦协程处于取消状态，它就不能再挂起了。完整代码见<a class="ae hu" href="https://pl.kotl.in/wjPINnWfG" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><blockquote class="mu"><p id="ef7b" class="mv mw hx bd mx my nm nn no np nq kh dx translated">处于取消状态的协程不能挂起！</p></blockquote><p id="46ec" class="pw-post-body-paragraph jm jn hx jo b jp ne iy jr js nf jb ju jv ng jx jy jz nh kb kc kd ni kf kg kh ha bi translated">为了能够在一个协程被取消时调用<code class="du nj nk nl mk b">suspend</code>函数，我们将需要切换我们需要在<code class="du nj nk nl mk b">NonCancellable</code> <code class="du nj nk nl mk b">CoroutineContext</code>中完成的清理工作。这将允许代码暂停，并将使协程保持在<em class="kt">取消</em>状态，直到工作完成。</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="69fc" class="mo ln hx mk b fi mp mq l mr ms">val job = launch {<br/>   try {<br/>      work()<br/>   } catch (e: CancellationException){<br/>      println(“Work cancelled!”)<br/>    } finally {<strong class="mk hy"><br/>      withContext(NonCancellable)</strong>{<br/>         delay(1000L) // or some other suspend fun <br/>         println(“Cleanup done!”)<br/>      }<strong class="mk hy"><br/>    </strong>}<br/>}</span><span id="3023" class="mo ln hx mk b fi mt mq l mr ms">delay(1000L)<br/>println(“Cancel!”)<br/>job.cancel()<br/>println(“Done!”)</span></pre><p id="4fef" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">点击查看这在实践中是如何工作的<a class="ae hu" href="https://pl.kotl.in/ufZRQSa7o" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7331" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">suspendCancellableCoroutine和invokeOnCancellation</h1><p id="5b8e" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">如果您使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/suspend-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCoroutine</a></code>方法将回调转换为协程，那么最好使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>方法。取消时要做的工作可以使用<code class="du nj nk nl mk b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellable-continuation/invoke-on-cancellation.html" rel="noopener ugc nofollow" target="_blank">continuation.invokeOnCancellation</a></code>实现:</p><pre class="kk kl km kn fd mj mk ml mm aw mn bi"><span id="80ad" class="mo ln hx mk b fi mp mq l mr ms">suspend fun work() {<br/>   return suspendCancellableCoroutine { continuation -&gt;<br/>       continuation.invokeOnCancellation { <br/>          // do cleanup<br/>       }<br/>   // rest of the implementation<br/>}</span></pre></div><div class="ab cl ow ox go oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ha hb hc hd he"><p id="95d8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了实现结构化并发的好处，并确保我们不做不必要的工作，你需要确保你的代码也是可取消的。</p><p id="5afb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用Jetpack中定义的【T0:】或<code class="du nj nk nl mk b">lifecycleScope</code>，当它们的作用域完成时取消它们的工作。如果你正在创建你自己的<code class="du nj nk nl mk b">CoroutineScope</code>，确保你将它绑定到一个任务，并在需要时调用取消。</p><p id="0528" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">协程代码的取消需要协作，所以确保更新代码以检查取消是否懒惰，并避免做不必要的工作。</p><p id="dcb5" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">从这篇文章中找到更多关于不应该被取消的工作模式:</p><div class="hg hh ez fb hi kx"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hy fi z dy lc ea eb ld ed ef hw bi translated">不应该取消的工作的协程和模式</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">协同程序中的取消和异常(第四部分)</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">medium.com</p></div></div><div class="lg l"><div class="pd l li lj lk lg ll ho kx"/></div></div></a></div></div></div>    
</body>
</html>