<html>
<head>
<title>GraphQL vs REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与REST</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/graphql-vs-rest-f067a79c2230?source=collection_archive---------1-----------------------#2022-02-18">https://medium.com/walmartglobaltech/graphql-vs-rest-f067a79c2230?source=collection_archive---------1-----------------------#2022-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/81af48913e927bc62ed290fb0cb0c120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0_-mxdsJLAQI7NtJSaKDw.png"/></div></div></figure><div class=""/><div class=""><h2 id="1f2d" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">GraphQL概述</h2></div><p id="074f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">大多数人熟悉REST API，但可能不熟悉GraphQL。GraphQL是一种API查询语言，为获取数据提供了更大的灵活性和效率，可以优化RESTful API调用。它使程序员能够选择他们想要的请求类型，并且只从服务器获取特定的数据。由于它带来的好处，我们在沃尔玛附属团队中的许多应用程序都采用了GraphQL，而不是REST。</p><p id="e157" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">GraphQL有三种操作类型:<strong class="jj ht">查询</strong>、<strong class="jj ht">变异</strong>和<strong class="jj ht">订阅</strong></p><p id="c1a1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">查询和变异是最常用的。查询类型用于从服务器获取特定数据，而变异用于更改/更新服务器端数据。</p><p id="3794" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">下面的例子:</p><p id="0af2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> GraphQL请求</strong></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="7cd8" class="km kn hs ki b fi ko kp l kq kr">query {<br/>  nodeDetail (input: { nodeId: "144"}) {<br/>    id<br/>    distance<br/>    name<br/>    address {<br/>      state<br/>      city<br/>      postalCode<br/>    }<br/>  }<br/>}</span></pre><p id="6e09" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> GraphQL响应</strong></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a783" class="km kn hs ki b fi ko kp l kq kr">{<br/>  "data": {<br/>    "nodeDetail": {<br/>      "id": "144",<br/>      "distance": null,<br/>      "name": "Walmart Supercenter",<br/>      "address": {<br/>        "state": "AR",<br/>        "city": "FAYETTEVILLE",<br/>        "postalCode": "72704"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2dab" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">带有值的参数可以直接传递到查询中的输入字段，如上所示<em class="ks">输入:{ nodeId: "144"}，</em>您可以看到查询与结果具有相同的形状。服务器将只获取客户端请求的数据。</p><p id="9e9c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在上面的例子中，我们在查询字符串中写入参数。但是在大多数情况下，参数是动态的，所以我们使用另一个名为<em class="ks"> variables </em>的字段来传递动态参数。下面是一个使用变量的例子:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a11c" class="km kn hs ki b fi ko kp l kq kr">query nodeDetail($input: NodeIdInput!){<br/>  nodeDetail(input: $input){<br/>    id<br/>    distance<br/>    name<br/>    address {<br/>      state<br/>      city<br/>      postalCode<br/>    }<br/>  }<br/>}</span></pre><p id="ef1d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">变量</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="33b8" class="km kn hs ki b fi ko kp l kq kr">{"nodeId": "144"}</span></pre><p id="c2ec" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当从应用程序调用GraphQL API时，GraphQL的典型负载如下</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="16d3" class="km kn hs ki b fi ko kp l kq kr">{<br/>  "query": "SOME QUERY STRING",<br/>  "variables": {}<br/>}</span></pre><p id="388a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以，使用上面的例子，它将是</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b3bb" class="km kn hs ki b fi ko kp l kq kr">"query": "query nodeDetail($input: NodeIdInput!){<br/>  nodeDetail(input: $input){<br/>    id<br/>    distance<br/>    name<br/>    address {<br/>      state<br/>      city<br/>      postalCode<br/>    }<br/>  }<br/>}",<br/>"variables": {"input": {"nodeId": "144"}}</span></pre><h2 id="ef2c" class="km kn hs bd kt ku kv kw kx ky kz la lb jq lc ld le ju lf lg lh jy li lj lk ll bi translated">为什么选择GraphQL</h2><p id="98b8" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">现在我们对GraphQL有了一个基本的了解，让我们看看REST和GraphQL之间的主要区别。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/68b83617de5686e8a89f861657e67beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJ6KpiVvqJJYdIsWC43Fsg.png"/></div></div></figure><p id="afa2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">多次调用REST，单次调用GraphQL </strong></p><p id="3c60" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从下图中，您可以看到，使用REST API，您通常会通过查询多个端点来收集数据。例如，首先您需要查询<em class="ks"> /node/ &lt; id &gt; </em>来获取节点信息，然后要获取更多的地址信息，您需要调用第二个端点<em class="ks">/node/&lt;id&gt;/address</em>。然而，使用GraphQL，只需向服务器发送一个包含具体数据需求的查询，GraphQL服务器就会响应一个JSON对象，满足这些需求。</p><p id="1d2d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们的附属团队应用程序的一个例子是商店服务定位器API，它被40多个合作伙伴用来获取沃尔玛商店的相关信息。该服务必须调用多个内部服务来获取商店信息，即名称、距离等。，这可能会达到大约1.5秒的95%延迟，此外还有多种依赖关系和我们不需要的不必要数据。在切换到单个内部GraphQL API后，我们可以只指定我们需要的数据，延迟减少了10%,依赖性也降低了。</p><p id="d6b2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">从GraphQL </strong>获取REST API的特定数据时溢出或不足</p><p id="4a62" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为对于REST，客户端从服务器检索数据的唯一方式是通过点击返回固定结构化数据的端点。因此，很难设计API来为客户提供他们特定的数据需求。结果可能是it从服务器获取了客户需要的数据，例如，客户只想获取用户的姓名和电子邮件地址信息，但最终可能会获取更多不必要的信息，如送货地址或账单信息。或者它可能以欠取结束，例如用户需要商店的地址和基本的商店信息，如名称和距离，但必须首先使<em class="ks"> /node/ &lt; id &gt; </em>获得基本的商店信息，然后通过使<em class="ks">/node/&lt;id&gt;/address</em>获得附加的API来获得商店地址。</p><p id="fb9b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">灵活性和效率</strong></p><p id="e0a0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">至于性能，GraphQL在两个方面优于REST。REST API具有严格的数据结构，并且只设计为在命中固定数据时获取固定数据，而GraphQL更加灵活，因为您只需要请求所需的数据格式。GraphQL对移动应用和物联网设备等低资源设备很友好，这些设备可以添加到网络中，而不必担心新的端点和数据检索和处理的增强。此外，使用GraphQL，您可以通过一次调用获得数据，而REST API会过量或不足地获取数据。鉴于这些事实，GraphQL可以更加灵活和高效。</p><p id="650f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">graph QL与REST的比较</strong></p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/10aad4a405217ecbb3c6cb9ad38240c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2Ax1iMM-sQPIKqZZURydA.png"/></div></div></figure><h2 id="1ca4" class="km kn hs bd kt ku kv kw kx ky kz la lb jq lc ld le ju lf lg lh jy li lj lk ll bi translated">何时使用REST</h2><p id="8880" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">尽管GraphQL很棒，但是在某些用例中REST会是更好的选择</p><p id="f7c0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">缓存机制</strong></p><p id="6628" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，每个浏览器都提供了一个HTTP缓存的实现，可以很容易地发现两个资源是否相同，以避免重复获取。使用GraphQL时，没有办法获得给定对象的全局唯一标识符，因为我们对所有请求使用相同的URL。要在GraphQL上有缓存，你必须自己设置。但是REST可以实现缓存。</p><p id="7e6b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">服务对服务通信</strong></p><p id="be64" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">说到服务到服务的通信，REST由于其简单性而更受欢迎；服务通过HTTP直接并同步地相互通信，不需要任何额外的基础设施，这为开发人员提供了为特定业务需求定制API的灵活性。</p><p id="74bf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">监控和错误报告</strong></p><p id="d6ca" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以基于REST API响应的响应状态构建一个监控和警报系统。但是对于GraphQL，即使抛出错误，它也可能返回200个OK状态，并且所有错误都可能出现在errors数组中，不管它们是什么类型的错误，所以找到错误并不简单。例如，来自GraphQL的错误响应可能如下:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="c147" class="km kn hs ki b fi ko kp l kq kr"><strong class="ki ht">HTTP 200 OK</strong></span><span id="bd17" class="km kn hs ki b fi lt kp l kq kr"><strong class="ki ht">{errors: [ {message: ‘Internal Server Error’}]}</strong></span></pre><h2 id="67db" class="km kn hs bd kt ku kv kw kx ky kz la lb jq lc ld le ju lf lg lh jy li lj lk ll bi translated">结论</h2><p id="1bb0" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">本文主要对GraphQL进行简要介绍，并讨论GraphQL与REST相比的主要因素，以帮助您更好地理解它们。一般来说，两者各有所长，所以选择GraphQL还是REST取决于用例。GraphQL以其声明性和灵活的结构提供了许多优于REST的改进，然而，它并不适用于所有情况。例如，如果您计划开发移动应用程序，考虑到带宽使用，GraphQL是首选，而如果您的系统需要更健壮和更成熟的API，则应该选择REST。</p></div></div>    
</body>
</html>