<html>
<head>
<title>Serverless Computing with Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift进行无服务器计算</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/serverless-computing-with-swift-f515ff052919?source=collection_archive---------1-----------------------#2018-04-04">https://medium.com/capital-one-tech/serverless-computing-with-swift-f515ff052919?source=collection_archive---------1-----------------------#2018-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="06fc" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">第1部分:Swift和AWS Lambda</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/504bba8b9711cb89d59ce0d43c8b3721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yndw-YAeHODwR9Ur3nX40Q.png"/></div></div></figure><h1 id="24f0" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">为什么选择无服务器Swift？</h1><p id="4546" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">与无服务器计算是否值得追求的问题不同的一个问题是，为什么要在Swift中实施无服务器系统？</p><p id="a4ae" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">有三个主要原因使得Swift成为Lambda实现语言的良好候选。首先，Swift是一种强大的、健壮的、富于表现力的语言，旨在在各种各样的环境中高效工作，包括服务器端计算。就其本身而言，这并不是一个很大的区别，因为还有其他几种语言(Rust，Go)可以这样描述。然而，Swift提供了两种额外的可能性——利用现有开发人员资源的机会，以及在系统的多个层面共享代码的机会，特别是后端和移动客户端。</p><p id="4467" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">让我们考虑一个示例场景。</p><h1 id="89b4" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">一个例子</h1><p id="02d1" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">我已经决定成立一家初创公司——这是我能做的酵母，一家专注于美食面包的在线面包店。因为没有一个自尊的面包店会因为没有一个强大的云基础设施而死亡，所以我的首要任务是构建一个微服务来处理向客户发送收据。</p><p id="497f" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">具体来说，我想要一个服务，它的输入是要订购的商品列表。一个项目是面包的类型和数量；比如三个羊角面包。输入用JSON编码。输出是收据的字符串表示。它列出了每个订购项目、其小计以及整个订单的总计。目前，我不会担心把收据做得太漂亮。</p><p id="53a7" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">我从忽略网络和编写可以用作命令行工具的代码开始。首先，我将创建一个新目录，并使用Swift包管理器(SPM)创建一个Swift应用程序。请注意，应用程序将被命名为<em class="lb"> bru </em>。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="fab3" class="lh jj hh ld b fi li lj l lk ll">mkdir bru<br/>cd bru<br/>swift package init —type=executable</span></pre><p id="129c" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">现在，我指定数据类型。考虑到可重用性，我将它们定义在主应用程序之外的一个独立模块中。我创建了一个目录<em class="lb"> Sources/bruModels </em>，在这个目录中，我用下面的代码创建了文件<em class="lb"> Item.swift </em>、<em class="lb"> Order.swift </em>和<em class="lb"> Receipt.swift </em>(完整列表可在<a class="ae lm" href="https://gist.github.com/profburke/2e951f48542a9a1ff47051572d77584c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/prof Burke/2e 951 f 48542 a 9 a1 ff 47051572d 77584 c</a>获得):</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="05fb" class="lh jj hh ld b fi li lj l lk ll">// Item.swift</span><span id="09e0" class="lh jj hh ld b fi ln lj l lk ll">enum Style: String, Codable {<br/>  case croissant<br/>  case naan<br/>  case pumpernickel <br/>  case rye<br/>}<br/></span><span id="7de6" class="lh jj hh ld b fi ln lj l lk ll">struct Item: Codable {<br/>  let amount: Int<br/>  let style: Style<br/>}</span><span id="5d01" class="lh jj hh ld b fi ln lj l lk ll">// Order.swift</span><span id="425d" class="lh jj hh ld b fi ln lj l lk ll">struct Order: Codable {<br/>  public private(set) var items: [Item]</span><span id="0df7" class="lh jj hh ld b fi ln lj l lk ll">   …</span><span id="83cf" class="lh jj hh ld b fi ln lj l lk ll">}</span><span id="bd81" class="lh jj hh ld b fi ln lj l lk ll">// Receipt.swift</span><span id="0df1" class="lh jj hh ld b fi ln lj l lk ll">struct Receipt: Codable, CustomStringConvertible {</span><span id="b99e" class="lh jj hh ld b fi ln lj l lk ll">    …</span><span id="3739" class="lh jj hh ld b fi ln lj l lk ll">}</span></pre><p id="46ba" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">我依靠Swift 4中新的<a class="ae lm" href="http://swiftjson.guide/" rel="noopener ugc nofollow" target="_blank">可编码协议</a>来神奇地处理与JSON之间的数据转换。正确组合Swift、Codable和JSON有时会很棘手。但我会在另一篇博文中讨论可能存在的困难。对于这个例子，序列化很简单，我可以使用自动生成的序列化代码。</p><p id="41ae" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">指定了数据类型后，我转向订单处理。下面是驻留在<em class="lb"> Sources/bru </em>中的<em class="lb"> main.swift </em>:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="ada7" class="lh jj hh ld b fi li lj l lk ll">import Foundation<br/>import bruModels<br/>   <br/>let inData = FileHandle.standardInput.readDataToEndOfFile() <br/>let decoder = JSONDecoder()</span><span id="8a44" class="lh jj hh ld b fi ln lj l lk ll">func format(_ response: String, payload: String) -&gt;  String  {</span><span id="7162" class="lh jj hh ld b fi ln lj l lk ll">  let result = “{ \”response\” : \”\(response)\”, \”payload\” : \”\(payload)\” }”</span><span id="85f3" class="lh jj hh ld b fi ln lj l lk ll">  return result<br/>}<br/></span><span id="84dd" class="lh jj hh ld b fi ln lj l lk ll">do {<br/>  let order = try decoder.decode(Order.self, from: inputData)<br/>  let receipt = order.receipt()<br/>  print(format(“success”, payload: receipt.description))<br/>} catch {<br/>  print(format(“error”, payload: “In a real app, this would have useful information.”))<br/>}</span></pre><p id="2181" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">这段代码执行一个简单的输入到输出的转换。它接收一个JSON格式的项目数组，并使用Swift的<em class="lb"> JSONDecoder </em>对数据进行反序列化。然后，它调用<em class="lb">订单</em>类上的实例方法来创建收据，并将其发送到流程的标准输出。</p><p id="59d7" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">在构建程序之前，我需要对运行包初始化命令时自动生成的包清单文件<em class="lb"> Package.swift </em>做两个小的修改。我需要为<em class="lb"> bruModels </em>添加一个目标，并将这个新目标指定为主目标的依赖项。具体见完整列表(<a class="ae lm" href="https://gist.github.com/profburke/2e951f48542a9a1ff47051572d77584c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/prof Burke/2e 951 f 48542 a 9 a1 ff 47051572d 77584 c</a>)。</p><p id="9195" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">现在我编译如下:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="7aad" class="lh jj hh ld b fi li lj l lk ll">swift build</span></pre><p id="1731" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">接下来，我可以在命令行上测试它，方法是输入一些JSON，然后看看我得到了什么。创建一个文件，<em class="lb"> order.json </em>，内容如下:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="15b4" class="lh jj hh ld b fi li lj l lk ll">{“items” : [<br/>  { “style” : “naan”, “amount” : 2 },<br/>  { “style” : “rye”, “amount” : 3 },<br/>  { “style” : “croissant”, “amount” : 6 } ]<br/>}</span></pre><p id="8a0a" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">现在输入命令:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="dcc1" class="lh jj hh ld b fi li lj l lk ll">cat order.json | .build/debug/app</span></pre><p id="c7a3" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">果然，测试返回:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="e32e" class="lh jj hh ld b fi li lj l lk ll">{ “response” : “success”, “payload” :<br/>  “Receipt for Order on 2018–01–09 21:07:19 +0000<br/>   — — — — -<br/>   2 NAAN @ 0.87 = 1.74<br/>   3 RYE @ 0.62 = 1.86<br/>   6 CROISSANT @ 1.23 = 7.38<br/>   — — — — -<br/>   Total: 10.98“<br/>}</span></pre><p id="594f" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">正如我上面提到的，这不是最漂亮的输出，但它足够了。</p><p id="8efd" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">随着一个简单的测试成功，我宣布胜利，并继续下一步。</p><h1 id="2b20" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">Swift和AWS Lambda</h1><p id="7161" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">截至本文撰写之时(2018年1月)，Lambda支持JavaScript、Python、Java、C#和Go。很明显，斯威夫特不在名单上。但是不要害怕！AWS Lambda支持节点的<a class="ae lm" href="https://nodejs.org/api/child_process.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">子流程</em> </a>模块，我可以使用它来启动我的Lambda函数并与任意可执行文件交互。</p><p id="c3b7" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">我将编写一个简短的JavaScript函数，通常称为<em class="lb"> shim </em>，它将作为Lambda函数被调用。shim启动Swift可执行文件，捕获其输出，并将其作为Lambda调用的结果返回。</p><p id="b298" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">在上一节中，我已经决定忽略网络，将Swift程序作为命令行工具来编写。这个决定是值得的，因为这正是shim所需要的！</p><p id="6a36" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">代码如下:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="0d31" class="lh jj hh ld b fi li lj l lk ll">const spawnSync = require(‘child_process’).spawnSync;</span><span id="0880" class="lh jj hh ld b fi ln lj l lk ll">exports.handler = (event, context, callback) =&gt; {<br/>  const command = ‘libraries/ld-linux-x86–64.so.2’;<br/>  const childObject = spawnSync(command,<br/>   [“—library-path”, “libraries”, “./bru”],<br/>   {input: JSON.stringify(event)});</span><span id="0238" class="lh jj hh ld b fi ln lj l lk ll">  var stdout = childObject.stdout.toString(‘utf8’);<br/>  callback(null, stdout);<br/>};</span></pre><p id="899b" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">这段代码是做什么的？<em class="lb">子进程</em>库被导入，函数<em class="lb">处理程序</em>被导出。<em class="lb">处理程序</em>是Lambda函数。它启动一个新流程，并将<em class="lb">事件</em>作为新流程的标准输入。<em class="lb">处理程序</em>然后捕获流程的标准输出，作为Lambda函数的结果返回。</p><p id="c9ca" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">现在你可能已经明白了<em class="lb"> spawnSync </em>是启动一个新进程的节点函数。但是您可能期望它的<em class="lb">命令</em>参数是Swift可执行文件。不幸的是，事情没那么简单。</p><p id="c28f" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">相反，子进程运行Linux动态链接器(通常命名为<em class="lb"> ld.so </em>，尽管在本例中，我们使用符号链接的目标<em class="lb">LD-Linux-x86–64 . so . 2</em>)。什么是动态链接器？我引用一下(Linux)手册页:链接器“找到并加载一个程序需要的共享对象(共享库)，准备程序运行，然后运行它。”</p><p id="c162" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">但是为什么要采取这种鲁布·戈德堡式的方法呢？</p><h1 id="2c48" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">并发症</h1><p id="6ec4" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">Lambda函数在特定的AMI下运行，而那个AMI没有Swift编译器。因此，我需要使用支持Swift编译器的Linux版本来构建可执行文件，然后我必须安排可执行文件在Lambda的AMI上运行。</p><p id="84a8" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">为此，我用Swift可执行文件、JavaScript shim和运行Swift代码所需的所有必要的动态库创建了一个zip文件。zip文件被上传到AWS Lambda，一切就绪。</p><p id="7882" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">除此之外，如何收集所有正确的动态库呢？</p><p id="f433" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">这就是Docker的用武之地。Docker不是绝对必要的；我可以找到一个运行适当操作系统的备用机器，在那里编译我的Swift代码。但是使用Docker可以让我在Mac笔记本电脑上完成所有的开发工作。</p><p id="3503" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">通过选择合适的Docker映像，我们可以在Linux环境中轻松编译Swift应用程序，并收集必要的动态库。<a class="ae lm" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>有几个支持Swift编译器的Docker镜像可供选择。我选了一个叫<em class="lb">doctor impossible/swift 4 Ubuntu</em>的。以下命令将带我们完成必要的步骤:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="bc07" class="lh jj hh ld b fi li lj l lk ll">docker run -it -v “$(PWD):/bru” doctorimpossible/swift4ubuntu bash<br/>cd bru<br/>swift build -c release —build-path .build/native   <br/>mkdir -p .build/deploy/libraries</span></pre><p id="bc6c" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">这些命令有什么作用？</p><p id="a9b1" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">1.启动Docker映像，使<em class="lb"> bru </em>目录在我们的Docker容器中可用，并通过shell连接到我们的容器。</p><p id="f6b2" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">2.转到<em class="lb"> bru </em>目录。</p><p id="3799" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">3.使用指定的构建位置编译应用程序的发布版本。</p><p id="e24e" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">4.创建一个目录来放置所有必要的动态库。</p><p id="1241" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">最后，我需要识别运行Swift可执行文件所涉及的所有动态库。所以，最后一个有点复杂的咒语会起作用:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="4e74" class="lh jj hh ld b fi li lj l lk ll">ldd .build/native/release/bru<br/>    | grep so<br/>    | sed -e ‘/^[^\t]/ d’<br/>    | sed -e ‘s/\t//’<br/>    | sed -e ‘s/(0.*)//’<br/>    | xargs -i% cp % .build/deploy/libraries</span></pre><p id="2e57" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">首先，<em class="lb"> ldd </em>运行。这个实用程序列出了命令行上列出的可执行文件的所有动态依赖关系(<em class="lb"> ldd </em> <em class="lb">是列表动态依赖关系</em>的缩写)。在Linux上，动态库的文件扩展名是<em class="lb">。所以</em>。因此，为了安全起见，并防止来自<em class="lb"> ldd </em>的潜在噪声线路，其输出通过管道连接到<em class="lb"> grep </em>。然后，在几个简单的步骤中，我使用流编辑器<em class="lb"> sed </em>从每个剩余的行中删除所有多余的字符，这样我只剩下一个简单的文件路径。最后，路径列表通过管道传输到<em class="lb"> xargs </em>中，xargs 使用<em class="lb"> cp </em>将库复制到特定的目录中。</p><p id="0505" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">(<em class="lb">理论上应该可以静态编译Swift程序，这样就不需要寻找和捆绑所有的动态库了。然而，我还没能让它工作。)</em></p><p id="3428" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">收集了所有必要的动态库之后，所需要的就是用这些库、应用程序本身和JavaScript shim创建一个zip文件。因此，退出Docker(在命令提示符下键入‘exit ’),然后:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="2611" class="lh jj hh ld b fi li lj l lk ll">cd .build/deploy<br/>cp ../native/release/bru .<br/>cat &gt; index.js // paste in the JavaScript code listed above, then hit Control-D<br/>zip -r lambda.zip *</span></pre><p id="be38" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">现在，我上传<em class="lb"> lambda.zip </em>到AWS lambda，我将准备测试我的Lambda函数。如果安装了AWS命令行界面(CLI ),则创建Lambda函数的过程如下:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="2713" class="lh jj hh ld b fi li lj l lk ll">aws lambda create-function —function-name bru<br/>    —runtime nodejs6.10<br/>    —role &lt;your-lambda-execution-role&gt; <br/>    —handler index.handler<br/>    —zip-file fileb://lambda.zip</span></pre><p id="925d" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">将<your-lambda-execution-role>替换为具有执行Lambda函数的适当权限的IAM角色。</your-lambda-execution-role></p><p id="580d" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">使用CLI可以轻松测试新功能。记下示例部分中提到的文件<em class="lb"> order.json </em>的文件路径，然后输入以下命令:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="12f6" class="lh jj hh ld b fi li lj l lk ll">aws lambda invoke —function-name bru<br/>    —invocation-type RequestResponse<br/>    —log-type Tail<br/>    —payload file://&lt;path-to-order.json&gt;<br/>    outputfile.txt</span></pre><p id="eb68" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">如果一切顺利，您将看到一个JSON片段打印到您的终端上，其中包含字段<em class="lb"> StatusCode </em>(应该是200)和<em class="lb"> LogResult </em>。日志结果并不重要，但是如果您很好奇，您需要从base64编码中解码它。您的Swift程序创建的收据将保存在<em class="lb"> outputfile.txt </em>中。</p><p id="25d8" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">如果您愿意，可以使用AWS web控制台创建Lambda函数，上传zip文件，并测试该函数。由于zip文件相当大(25M)，你可能会得到一个警告，建议你通过亚马逊S3上传，但它会工作。</p><h1 id="f913" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">后续步骤</h1><p id="0ce4" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">安装并测试了Lambda函数之后，下一步就是将它集成到基础设施的其余部分。该功能是在Swift中实现的，这一事实与您系统的其余部分几乎无关。您可以将该功能放在Amazon的API网关后面，或者用任何标准的AWS触发器(如SNS主题、DynamoDB事件等)对其进行配置。</p><p id="8c62" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">更重要的是，理解了创建Swift Lambda函数背后的过程，并且着眼于减少单调乏味，您应该考虑自动化这个过程的方法。这样做的现有项目是Hexaville。虽然我没有使用过它，但我已经通读了代码，它看起来像一个可靠的方法。它还有一个额外的优势，就是提供了用于与DynamoDB交互和利用OAuth的Swift库。另一个值得研究的项目是<a class="ae lm" href="http://apex.run" rel="noopener ugc nofollow" target="_blank"> Apex </a>。尽管Apex目前不支持Swift，但它使您能够用Clojure、Rust和Go编写Lambda函数，并可能为Swift Lambda流程的改进提供有用的灵感来源。</p><p id="bf88" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated">如果您对无服务器系统感兴趣，但是正在寻找其他选择，请关注第2部分，在那里我将讨论如何将Swift与Apache OpenWhisk和IBM的Blue Mix结合使用。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="5d6a" class="pw-post-body-paragraph ka kb hh kc b kd kw ii kf kg kx il ki kj ky kl km kn kz kp kq kr la kt ku kv ha bi translated"><em class="lb">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>