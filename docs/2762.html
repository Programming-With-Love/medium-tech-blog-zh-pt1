<html>
<head>
<title>Solidity Tutorial - A Complete Guide To Start Your Journey In Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实教程-开始你的坚实之旅的完整指南</h1>
<blockquote>原文：<a href="https://medium.com/edureka/solidity-tutorial-ca49906bdd47?source=collection_archive---------3-----------------------#2018-02-28">https://medium.com/edureka/solidity-tutorial-ca49906bdd47?source=collection_archive---------3-----------------------#2018-02-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/1a3efa4917d8be46b4b8349f9e8b6888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*L0_0dWBir1FgWTMfhvHgRg.png"/></div><figcaption class="il im et er es in io bd b be z dx">Solidity Tutorial — Edureka</figcaption></figure><p id="a596" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇关于坚固性教程的文章展示了许多坚固性的特性。本教程假设您对以太坊虚拟机和编程有一定的了解。</p><p id="4216" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以太坊，世界计算机提供了一个非常强大的共享全球基础设施，使用一种叫做 <strong class="ir hi"> <em class="jn"> Solidity的编程语言来构建一个去中心化的应用程序。</em>T5】</strong></p><p id="6c03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇关于可靠性教程的文章涵盖了以下主题:</p><ol class=""><li id="0a53" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">什么是扎实？</li><li id="d0da" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">以太坊契约</li><li id="c93b" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">实体文件的布局</li><li id="86cb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">可靠性中的值类型</li><li id="93b2" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">经营者</li><li id="9c19" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">固体中的数据结构</li><li id="bda4" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">控制结构</li><li id="041a" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">功能</li><li id="ae73" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">遗产</li></ol><p id="bcd5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从坚固性的介绍开始我们的坚固性教程。</p><h1 id="6dbf" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是扎实？</h1><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/bb8664e21e68fcf1235555cbed1cdef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*60IahQq_FH_tFlYVFQagRQ.jpeg"/></div></figure><p id="121a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Ethereum Solidity是一种面向契约的高级语言，语法类似于JavaScript。</p><p id="e8a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Solidity是一个用来生成在EVM上执行的机器代码的工具。solidity编译器将高级代码分解成更简单的指令。</p><blockquote class="lf lg lh"><p id="add6" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><em class="hh">坚固性代码封装在</em> <strong class="ir hi"> <em class="hh">契约</em> </strong>中</p></blockquote><h1 id="07c4" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">以太坊契约</h1><p id="6c46" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">契约是以太坊的分散式应用程序的基本构件。所有的变量和功能都是合同的一部分，这是所有项目的起点。</p><p id="1dd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个名为<strong class="ir hi"> MyFirst </strong>的空契约如下所示:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="2bdc" class="lv kd hh lr b fi lw lx l ly lz">version pragma ^0.4.19;<br/>contract MyFirst{<br/>}</span></pre><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/cff5ac1e9b75ccbb08e19142e6c78d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*Xk8_SE9-RBTBv17Y85V93Q.jpeg"/></div></figure><p id="baf1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">坚持你的屏幕，因为接下来在我们的坚固性教程中，我们将开始编码…</p><h1 id="908b" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">实体文件的布局</h1><p id="853a" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">源文件可以包含任意数量的协定定义，包括指令和pragma指令。</p><h2 id="b363" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">版本杂注</strong></h2><p id="c25c" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">Version Pragma是特定代码应该使用的Solidity编译器版本的声明。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="3364" class="lv kd hh lr b fi lw lx l ly lz">version pragma ^0.4.00;</span></pre><blockquote class="lf lg lh"><p id="c39b" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>上面显示的源文件不能在早于0.4.0版本的编译器上编译，也不能在0.5.0版本的编译器上运行。</p></blockquote><h2 id="2a22" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">导入其他源文件</strong></h2><p id="886d" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">Ethereum Solidity支持与JavaScript中的导入语句非常相似的导入语句，尽管Solidity不知道“默认导出”的概念。</p><p id="d186" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在全局级别，您可以使用以下形式的import语句:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="9e77" class="lv kd hh lr b fi lw lx l ly lz">import "filename";</span></pre><p id="4548" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述语句将“filename”中的所有全局符号导入到当前的全局作用域中。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="5404" class="lv kd hh lr b fi lw lx l ly lz">import * as symbolName from "filename";</span></pre><p id="8b9d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">…创建一个新的全局符号<strong class="ir hi"> symbolName </strong>，其成员是来自“filename”的所有全局符号</p><h2 id="25d3" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">评论</strong></h2><p id="85b2" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">就像任何其他语言一样，<em class="jn">单行</em>和<em class="jn">多行</em>注释在Solidity上是可能的。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="4666" class="lv kd hh lr b fi lw lx l ly lz">// This is a single-line comment.<br/>/*<br/>This is a<br/>multi-line comment<br/>*/</span></pre><p id="5bd4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在我们继续我们的实体教程之前，你应该知道以太坊有三个区域可以储存物品。</p><ol class=""><li id="bb5b" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">存储:</strong>所有契约状态变量驻留的地方。每个契约都有自己的存储，并且在函数调用之间是持久的</li><li id="d092" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">内存:保存临时值，在(外部)函数调用之间被清除，使用起来更便宜</li><li id="27a7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">堆栈:保存小的局部变量，几乎可以免费使用，但是只能保存有限的值</li></ol><p id="da1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于几乎所有的类型，您不能指定它们应该存储在哪里，因为它们在每次使用时都会被复制。<br/> <br/>好了，现在你知道以太坊Solidity中的存储位置了，让我告诉你一般的值类型。</p><h1 id="d4db" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">可靠性中的值类型</h1><p id="e3c0" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">下列类型也称为值类型，因为这些类型的变量总是通过值传递。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mo"><img src="../Images/7c8192f291b61a51ea7db8c17536a62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQIZgaw4ip3TQvVveF72Lw.png"/></div></div></figure><h2 id="6710" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">布尔型</strong></h2><p id="abf5" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated"><em class="jn">关键词:布尔</em></p><p id="abf9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可能的值是常量，即<strong class="ir hi">真</strong>或<strong class="ir hi">假</strong></p><h2 id="909f" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">整数</strong></h2><p id="74ee" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated"><em class="jn">关键字:</em> int/uint(以8为步长的uint8至uint256(无符号8至256位)和int8至int256)</p><p id="ac1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">各种大小的有符号和无符号整数。</p><p id="bf38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例如:</strong></p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="58a3" class="lv kd hh lr b fi lw lx l ly lz">contract MySample{<br/>uint UnsignedInt =50;<br/>}</span></pre><p id="faec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的语句中，我们创建了一个名为<strong class="ir hi">的<strong class="ir hi">uint</strong>insigned int</strong>T58】将其设置为50。</p><h2 id="50e2" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">地址:</strong></h2><p id="d072" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated"><em class="jn">关键字:</em>地址</p><p id="a8d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">保存20字节的值(以太坊地址的大小)。地址类型也有<em class="jn">成员</em>，并作为所有契约的基础。</p><p id="ef2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">会员地址:余额&amp;转账</strong></p><p id="b567" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以使用属性<strong class="ir hi"> <em class="jn"> balance </em> </strong>查询地址的余额，并使用<strong class="ir hi"> <em class="jn"> transfer </em> </strong>功能向地址发送以太网。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="2c36" class="lv kd hh lr b fi lw lx l ly lz">address x = 0x123;<br/>address myAddress = this;<br/>if  (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt; = 10)<br/>x.transfer(10);</span></pre><h2 id="ec5e" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">琴弦:</strong></h2><p id="3918" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated"><em class="jn">关键字:</em>字符串文字用双引号或单引号<strong class="ir hi"> "foo" </strong>或<strong class="ir hi"> 'bar' </strong>书写。<br/> <br/>用于任意长度的UTF数据。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="e8af" class="lv kd hh lr b fi lw lx l ly lz">string language = "Solidity";</span></pre><p id="6b2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些值类型可以在包含运算符的表达式中相互交互。接下来，在我们的Solidity教程中，让我告诉你各种各样的操作符。</p><h1 id="1158" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">经营者</h1><p id="f2a7" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">solidity中的运算符与JavaScript中的相同。坚实度有四种类型的运算符:</p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mo"><img src="../Images/357476e164d920248ca03ee669afc29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9A8lyiTlzEZ4fSkFMvtHWg.png"/></div></div></figure><h2 id="2a12" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">算术运算符</strong></h2><p id="8c4d" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">坚实度有非常简单的数学运算。以下类似于大多数编程语言:</p><ul class=""><li id="7c09" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm mt ju jv jw bi translated">加法:<code class="du mu mv mw lr b"><strong class="ir hi">x + y</strong></code></li><li id="5e72" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm mt ju jv jw bi translated">减法:<code class="du mu mv mw lr b"><strong class="ir hi">x - y</strong></code></li><li id="c8a9" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm mt ju jv jw bi translated">乘法:<code class="du mu mv mw lr b"><strong class="ir hi">x * y</strong></code></li><li id="3257" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm mt ju jv jw bi translated">分部:<code class="du mu mv mw lr b"><strong class="ir hi">x / y</strong></code></li><li id="2840" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm mt ju jv jw bi translated">模数/余数:<code class="du mu mv mw lr b"><strong class="ir hi">x % y</strong></code></li></ul><p id="a553" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">坚固性也给你一个使用指数操作符的选项，如下所示:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="2295" class="lv kd hh lr b fi lw lx l ly lz">uint x = 10 **  3; // equal to 10^3 = 1000</span></pre><h2 id="337c" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">增量运算符</strong></h2><p id="910b" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">实度中的增量运算符:a++，a –, ++ a，–a，a+=1，a=a+1</p><p id="111f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">适用于其他编程语言的规则在可靠性上也是相似的。</p><h2 id="a72e" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">按位运算符:</strong></h2><p id="bbdf" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">以下是运算符:(按位或)' | '、(按位异或)、(按位求反)' ~ '、(按位右移)' &gt; '、(按位左移)'&lt;</p><h2 id="3e8e" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">逻辑运算符:</strong></h2><p id="525c" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">Solidity中的逻辑运算符:！(逻辑否定)，&amp;&amp;(逻辑与)，||(逻辑或)，==(相等)，！=(不相等)</p><p id="3767" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">举例:</strong></p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="7bf6" class="lv kd hh lr b fi lw lx l ly lz">contract operators {<br/>// Arithmetic Operators<br/>// +,-,*,/, %, **<br/>// Incremental Operators<br/>// a++, a--, a+=1, a=a+1,++a,--a;<br/>a=10;<br/>a= a++; //here, output will be 10, because the value is first returned and then then increment is done<br/>a=++a;<br/>//Logical Operators<br/>!, &amp;&amp;, ||, ==, !=<br/>isOwner = true &amp;&amp; false;<br/>var orValue= 0x02 | 0x01; // output would be 0x03<br/>//Bitwise Operators~,&gt;&gt;, &lt;&lt;;<br/>function Operators() {<br/>// Initialize state variables here}}</span></pre><p id="1a60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在有时需要更复杂的数据类型。为此，Solidity提供了<strong class="ir hi">结构。</strong></p><h1 id="ddd0" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">固体中的数据结构</h1><p id="ef49" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">可靠性提供了三种类型的数据结构:</p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mo"><img src="../Images/0f41ea3606ea3953dbc0171e4a4f8a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5py9W2z3CqDSU25hPaiVQ.png"/></div></div></figure><h2 id="dbae" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated">结构</h2><p id="533a" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">坚固性提供了一种以结构形式定义新类型的方法。结构是自定义的类型，可以将几个变量组合在一起。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="a19f" class="lv kd hh lr b fi lw lx l ly lz">pragma solidity ^0.4.0;<br/>contract Ballot {<br/>struct Voter { // Struct<br/>uint weight1, weight2, weight3;<br/>bool voted;<br/>address delegate1, delegate2, delegate3, delegate4;<br/>string name;<br/>uint vote1, vote2, vote3, vote4, vote5;<br/>uint height1, height2, height3   } }</span></pre><p id="17cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>结构只能有16个成员，超过这个数目可能会出现以下错误:堆栈太深。</p><p id="7275" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">结构允许您创建具有多个属性的更复杂的数据类型。</em></p><p id="c408" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果你需要收集一些东西，比如地址。嗯，就像大多数语言一样，Solidity也有数组。</p><h2 id="4e3c" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated">数组</h2><p id="0597" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">Solidity中的数组可以有一个编译时固定的大小，也可以是动态的。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="68a1" class="lv kd hh lr b fi lw lx l ly lz">uint[3] fixed;  //array of fixed length 3<br/>uint[] dynamic; //a dynamic array has no fixed size, it can keep growing</span></pre><p id="f76c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您还可以创建结构数组。使用先前创建的<strong class="ir hi">表决器</strong>结构:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="5b34" class="lv kd hh lr b fi lw lx l ly lz">Voter[] voting;</span></pre><p id="1c21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>将一个数组声明为public会自动为它创建一个getter方法。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="5b9e" class="lv kd hh lr b fi lw lx l ly lz">Voter[] public voting;</span></pre><h2 id="08db" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated">映射</h2><p id="a72c" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">映射可以看作是哈希表，它被虚拟地初始化，使得每个可能的键都存在，并被映射到一个字节表示全为零的值:一个类型的默认值。</p><p id="edb1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">映射被声明为:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="6a53" class="lv kd hh lr b fi lw lx l ly lz">Mapping(_Keytype =&gt; _ValueType )</span></pre><p id="6571" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong> _Keytype几乎可以是任何类型，除了动态大小数组、契约、枚举和结构。</p><p id="3480" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">举例:</strong></p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="c910" class="lv kd hh lr b fi lw lx l ly lz">contract MappingExample {<br/>mapping(address =&gt; uint) public balances;<br/>function update(uint newBalance) {<br/>balances[msg.sender] = newBalance;  }}<br/>contract MappingUser {<br/>function f() returns (uint) {<br/>MappingExample m = new MappingExample();<br/>m.update(100);<br/>return m.balances(this);<br/>}}</span></pre><h1 id="afe2" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">控制结构</h1><p id="c0bb" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">JavaScript中的大部分控制结构在Solidity中都有，除了switch和goto。</p><p id="cc3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">于是就有了<strong class="ir hi"> : if，else，while，do，for，break，continue，return，？:</strong>，带有从C或JavaScript已知的常用语义。</p><p id="2772" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>没有像C和JavaScript中那样的从非布尔到布尔的类型转换。</p><p id="4a78" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们看看这些控制结构是如何在Solidity中使用的。</p><p id="105d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例如:</strong></p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="691e" class="lv kd hh lr b fi lw lx l ly lz">contract ControlStructure {<br/>address public a;<br/>function ControlStructure&gt;){<br/>// if-else can be used like this<br/>if(input1==2)<br/>a=1;<br/>else<br/>a=0;<br/>// while can be used like this<br/>while(input1&gt;=0){<br/>if(input1==5)<br/>continue;<br/>input1=input1-1;<br/>a++;}<br/>// for loop can be used like this<br/>for(uint i=0;i&lt;=50;i++) { a++; if(a==4) break; } //do while can be used like this do { a--; } (while a&gt;0);<br/>// Conditional Operator can be used like this<br/>bool IsTrue = (a == 1)?true: false;<br/>/*will show an error because<br/>there is no type conversion from non-boolean to boolean<br/>*/<br/>if(1)<br/>{<br/>}</span></pre><p id="164e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续我们的Solidity教程博客，让我们讨论一下契约中代码的可执行单元。这些被称为<em class="jn">功能。</em></p><h1 id="23eb" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">功能</h1><p id="1c01" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">下面是如何在Solidity中声明一个函数。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="10be" class="lv kd hh lr b fi lw lx l ly lz">function sampleFunc(string name, uint amount) { <br/>}</span></pre><p id="7dd2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面声明的是一个空体函数，它接受两个参数:一个字符串和一个uint。</p><p id="3e0b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以像这样调用这个函数:</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="77c5" class="lv kd hh lr b fi lw lx l ly lz">sampleFunc("Shashank", 10000);</span></pre><p id="baea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">说到函数，Solidity还提供了<strong class="ir hi">函数修饰符。</strong></p><h2 id="c774" class="lv kd hh bd ke mb mc md ki me mf mg km ja mh mi kq je mj mk ku ji ml mm ky mn bi translated"><strong class="ak">功能修饰符</strong></h2><p id="e9fc" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">它用于轻松地更改函数的行为。这些条件甚至可以在进行函数调用之前进行检查，因为它们已经在智能合约的函数定义中声明了。</p><p id="cb6e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">举例:</strong>如果你想只通过函数的拥有者或创建者调用一个kill contract函数。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="6412" class="lv kd hh lr b fi lw lx l ly lz">contract FunctionModifiers{<br/>address public creator;<br/>function FunctionModifiers() {<br/>creator = msg.sender;}<br/>Modifier onlyCreator() {<br/>if(msg.sender!=creator){<br/>throw; }<br/>_; //resumes the function wherever the access modifier is used<br/>}<br/>function killContract() onlyCreator{ //function will not execute if an exception occurs<br/>self-destruct(creator); }}</span></pre><h1 id="3cb0" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">遗产</h1><p id="d220" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">Solidity通过复制包含多态性的代码来支持多重继承。</p><pre class="lb lc ld le fd lq lr ls lt aw lu bi"><span id="87e1" class="lv kd hh lr b fi lw lx l ly lz">contract Owned {<br/>address Owner ;<br/>function owned() {<br/>owner = msg.sender;<br/>}}<br/>contract Mortal is Owned {  // 'is' keyword is used for inheritance<br/>function kill(){<br/>self-destruct(owner);   }}<br/>contract User is Owned, Mortal //Multiple inheritance<br/>{<br/>string public UserName;<br/>function User(string _name){<br/>UserName = _name;<br/>}}</span></pre><p id="c6fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好的，我觉得上面讨论的概念已经足够让你开始使用可靠性编程了。</p><p id="95cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> Go码！！</strong></p><p id="e852" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">至此，我结束了这篇<em class="jn">坚实度教程</em>文章。我希望你喜欢阅读这个博客，并发现它的信息量。到目前为止，您一定已经很好地理解了什么是Solidity编程语言。现在开始练习吧。</p><p id="ec26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望你喜欢阅读这个博客，并发现它的信息量。如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释区块链的其他各个方面。</p><blockquote class="lf lg lh"><p id="f6cb" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">1.<a class="ae mx" rel="noopener" href="/edureka/blockchain-tutorial-d05f9c36b62b">区块链教程</a></p><p id="e656" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">2.<a class="ae mx" rel="noopener" href="/edureka/ethereum-tutorial-with-smart-contracts-db7f80175646">以太坊教程</a></p><p id="96b8" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">3.<a class="ae mx" rel="noopener" href="/edureka/ethereum-private-network-tutorial-22ef4119e4c3">以太坊专用网络</a></p><p id="71eb" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">4.什么是智能合约？</p><p id="2614" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">5.<a class="ae mx" rel="noopener" href="/edureka/developing-ethereum-dapps-with-truffle-7533289c8b2">松露以太坊教程</a></p><p id="fdb2" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">6.<a class="ae mx" rel="noopener" href="/edureka/ethereum-development-tools-7175503a1ac7">最好的以太坊开发工具</a></p><p id="5792" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">7.<a class="ae mx" rel="noopener" href="/edureka/hyperledger-fabric-184667460-edc184667460">大帐织物</a></p><p id="d817" class="ip iq jn ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">8.<a class="ae mx" rel="noopener" href="/edureka/hyperledger-vs-ethereum-bdc868e10817"> Hyperledge vs以太坊</a></p></blockquote></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="d1f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2018年2月28日</em><a class="ae mx" href="https://www.edureka.co/blog/solidity-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="jn">www.edureka.co</em></a><em class="jn">。</em></p></div></div>    
</body>
</html>