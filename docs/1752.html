<html>
<head>
<title>Generics are the Generics of Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">泛型是Go的泛型</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/generics-are-the-generics-of-go-3e0ef0cb9e04?source=collection_archive---------0-----------------------#2020-08-05">https://medium.com/capital-one-tech/generics-are-the-generics-of-go-3e0ef0cb9e04?source=collection_archive---------0-----------------------#2020-08-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9754" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Go可能很快就会包含它最受欢迎的功能</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/e690c0445680a8e4d857b9ecbabfe13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDEMBasJy-QS_YNmfAg_Qw.jpeg"/></div></div></figure><p id="c849" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大约三年前，我在为GitHub开发一个名为<a class="ae ke" href="https://github.com/capitalone/checks-out" rel="noopener ugc nofollow" target="_blank"> Checks-Out </a>的pull request approval manager。在构建集成层时，我遇到了一种情况，Go中的直接方法过于重复。理想的解决方案是使用泛型，但是它们不可用。</p><p id="4669" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，我发现在很多情况下，可以使用闭包来传递值。我在一篇<a class="ae ke" href="https://www.capitalone.com/tech/software-engineering/closures-are-the-generics-for-go/" rel="noopener ugc nofollow" target="_blank">博客文章</a>和一篇<a class="ae ke" href="https://www.youtube.com/watch?v=5IKcPMJXkKs" rel="noopener ugc nofollow" target="_blank">演讲</a>中描述了我对这个问题的体验和我的解决方案，这两篇文章都被称为闭包，是Go的泛型。</p><p id="921f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="kf">事情即将发生变化。</em></strong>Go团队发布了一篇<a class="ae ke" href="https://blog.golang.org/generics-next-step" rel="noopener ugc nofollow" target="_blank">博客文章</a>和一份<a class="ae ke" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md" rel="noopener ugc nofollow" target="_blank">草案规范</a>，描述了一个潜在的Go泛型实现。提议草案使用参数化类型来添加人们所要求的大多数泛型功能，而不改变Go的基本特征。</p><h1 id="2f6a" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">在Go中引入泛型</h1><p id="16ef" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated"><a class="ae ke" href="https://www.capitalone.com/tech/software-engineering/go-is-boring/" rel="noopener ugc nofollow" target="_blank"> Go是一种有意设计的小型语言，其设计偏好良好的工具性和可读性，而不是特性。</a>围棋团队也看重向后兼容性；旧代码应该继续工作，这样它可以被维护很多年。通用名草案就是考虑到这些目标而编写的。</p><p id="1ff7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将通过尝试最简单的情况来开始我们对Go泛型的研究:<em class="kf">一个用户定义的容器类型</em>。我们将使用一个链表作为我们的示例容器类型。下面是今天在Go中写一个的样子:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="1084" class="li kh hh le b fi lj lk l ll lm">type LinkedList struct {<br/>	value interface{}<br/>	next  *LinkedList<br/>}</span></pre><p id="0bb7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是使用泛型时的情况:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="da36" class="li kh hh le b fi lj lk l ll lm">type LinkedList[type T] struct {<br/>	value T<br/>	next  *LinkedList[T]<br/>}</span></pre><p id="69ba" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">将此类型更改为泛型类型需要三个小的改动:</p><ol class=""><li id="3ecc" class="ln lo hh jk b jl jm jo jp jr lp jv lq jz lr kd ls lt lu lv bi translated">将<code class="du lw lx ly le b">[type T]</code>放在类型名之后和结构文字之前。<code class="du lw lx ly le b">T</code>是一个名字，当我们的链表被使用时，我们将使用它作为任何类型的占位符。许多其他语言使用<code class="du lw lx ly le b">T</code>作为泛型类型的占位符类型名，很可能Go也会采用同样的习惯。如果需要引用同一类型或函数中的其他类型，请使用其他大写字母；我们一会儿就能看到。</li><li id="dbad" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd ls lt lu lv bi translated">使用<code class="du lw lx ly le b">T</code>代替<code class="du lw lx ly le b">interface{}</code>作为<code class="du lw lx ly le b">value</code>字段的类型。</li><li id="f600" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd ls lt lu lv bi translated">将<code class="du lw lx ly le b">next</code>指针的类型从<code class="du lw lx ly le b">*LinkedList</code>改为<code class="du lw lx ly le b">*LinkedList[T]</code>。使用泛型类型时，必须提供类型参数。省略它们是一个编译时错误。</li></ol><p id="3a38" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们写一些方法来使用我们的泛型类型。我们将从查找链表长度的方法开始:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="cf58" class="li kh hh le b fi lj lk l ll lm">func (ll *LinkedList[T]) Len() int {<br/>	count := 0<br/>	for node := ll; node != nil; node = node.next {<br/>		count++<br/>	}<br/>	return count<br/>}</span></pre><p id="10c0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">方法接收器使用<code class="du lw lx ly le b">*LinkedList[T]</code>而不是<code class="du lw lx ly le b">*LinkedList</code>，但是代码的其余部分与您在不使用泛型的情况下编写的代码是相同的。让我们编写一个引用参数化类型的方法:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="ebf7" class="li kh hh le b fi lj lk l ll lm">func (ll *LinkedList[T]) InsertAt(pos int, value T) *LinkedList[T] {<br/>	if ll == nil || pos &lt;= 0 {<br/>		return &amp;LinkedList[T]{<br/>			value: value,<br/>			next:  ll,<br/>		}<br/>	}<br/>	ll.next = ll.next.InsertAt(pos-1, value)<br/>	return ll<br/>}</span></pre><p id="08a8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个方法接受一个类型为<code class="du lw lx ly le b">[T]</code>的参数</p><p id="951c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">(这个方法不是插入链表的最有效的方法，但是它足够短，可以作为一个很好的例子。还要注意是安全的；如果您为插入索引传递0或负数，它将添加到链表中，如果您传递一个大于长度的数，它将简单地追加。)</p><p id="a409" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一些对我们的链表有用的附加方法:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="766a" class="li kh hh le b fi lj lk l ll lm">func (ll *LinkedList[T]) Append(value T) *LinkedList[T] {<br/>	return ll.InsertAt(ll.Len(), value)<br/>}</span><span id="d0f9" class="li kh hh le b fi me lk l ll lm">func (ll *LinkedList[T]) String() string {<br/>	if ll == nil {<br/>		return "nil"<br/>	}<br/>	return fmt.Sprintf("%v-&gt;%v", ll.value, ll.next.String())<br/>}</span></pre><p id="6d36" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们有了一些关于泛型类型的有用方法，让我们试一试:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="e0ca" class="li kh hh le b fi lj lk l ll lm">var head *LinkedList[string]<br/>head = head.Append("Hello")<br/>fmt.Println(head.String())<br/>fmt.Println(head.Len())<br/>head = head.Append("Hola")<br/>head = head.Append("हैलो")<br/>head = head.Append("こんにちは")<br/>head = head.Append("你好")<br/>fmt.Println(head.String())<br/>fmt.Println(head.Len())</span></pre><p id="6d67" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">(当传递一个值给<code class="du lw lx ly le b">fmt.Println</code>时，我们不需要显式调用<code class="du lw lx ly le b">String</code>，但是我想让它显式。更多信息见<a class="ae ke" href="https://tour.golang.org/methods/17" rel="noopener ugc nofollow" target="_blank">https://tour.golang.org/methods/17</a>。)</p><p id="a6ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这看起来与现有的Go代码完全一样，只有一个变化:当声明一个类型为<code class="du lw lx ly le b">*LinkedList</code>的变量时，我们提供了我们希望用于这个特定实例的类型。这段代码打印出来:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="5434" class="li kh hh le b fi lj lk l ll lm">Hello-&gt;nil<br/>1<br/>Hello-&gt;Hola-&gt;हैलो-&gt;こんにちは-&gt;你好-&gt;nil<br/>5</span></pre><p id="fe76" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们想使用不同类型的链表，我们只需在实例化不同的变量时提供不同的类型。如果我们有一个<code class="du lw lx ly le b">type Person</code>:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="29ad" class="li kh hh le b fi lj lk l ll lm">type Person struct {<br/>	Name string<br/>	Age  int<br/>}</span></pre><p id="5df3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以编写以下代码:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="8de7" class="li kh hh le b fi lj lk l ll lm">var peopleList *LinkedList[Person]<br/>peopleList = peopleList.Append(Person{"Fred", 23})<br/>peopleList = peopleList.Append(Person{"Joan", 30})<br/>fmt.Println(peopleList)</span></pre><p id="ae00" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它打印出:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="604e" class="li kh hh le b fi lj lk l ll lm">{Fred 23}-&gt;{Joan 30}-&gt;nil</span></pre><p id="4055" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如<a class="ae ke" href="https://play.golang.org/" rel="noopener ugc nofollow" target="_blank">Go Playground</a>允许你尝试当前的Go代码一样，Go团队已经把<a class="ae ke" href="https://go2goplay.golang.org/" rel="noopener ugc nofollow" target="_blank">变成了一个测试通用代码的新游戏场</a>。你可以在https://go2goplay.golang.org/p/OUX5OKRMqQw<a class="ae ke" href="https://go2goplay.golang.org/p/OUX5OKRMqQw" rel="noopener ugc nofollow" target="_blank">试试我们的链表。</a></p><p id="df96" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们尝试一些新的东西。我们将在链表中添加另一个方法来告诉我们一个特定的值是否在链表中:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="3b4a" class="li kh hh le b fi lj lk l ll lm">func (ll *LinkedList[T]) Contains(value T) bool {<br/>	for node := ll; node != nil; node = node.next {<br/>		if node.value == value {<br/>			return true<br/>		}<br/>	}<br/>	return false<br/>}</span></pre><p id="6786" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，这是行不通的。如果我们试图编译它，我们会得到错误:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="2573" class="li kh hh le b fi lj lk l ll lm">cannot compare node.value == value (operator == not defined for T)</span></pre><p id="ac48" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">问题是我们的占位符类型<code class="du lw lx ly le b">T</code>没有指定它能做什么。到目前为止，我们能做的就是存储和检索它。如果我们想做得更多，我们必须在<code class="du lw lx ly le b">T</code>上指定一些约束。</p><p id="5cc6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为很多(但不是全部！)Go类型可以使用<code class="du lw lx ly le b">==</code>和<code class="du lw lx ly le b">!=</code>进行比较，Go generics提案包括一个新的内置接口，名为<code class="du lw lx ly le b">comparable</code>。如果我们回到链表类型的定义，我们可以做一点小小的改变来支持<code class="du lw lx ly le b">==</code>:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="210d" class="li kh hh le b fi lj lk l ll lm">type LinkedList[type T comparable] struct {<br/>	value T<br/>	next  *LinkedList[T]<br/>}</span></pre><p id="611b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将接口<code class="du lw lx ly le b">comparable</code>添加到我们的类型参数定义子句中，现在我们可以使用<code class="du lw lx ly le b">==</code>在<code class="du lw lx ly le b">LinkedList</code>的方法中比较<code class="du lw lx ly le b">T</code>类型的变量。</p><p id="38b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用我们以前的数据，如果我们运行以下行:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="c6ab" class="li kh hh le b fi lj lk l ll lm">fmt.Println(head.Contains("Hello"))<br/>fmt.Println(head.Contains("Goodbye"))<br/>fmt.Println(peopleList.Contains(Person{"Joan", 30}))</span></pre><p id="4135" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您会得到以下结果:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="a8c2" class="li kh hh le b fi lj lk l ll lm">true<br/>false<br/>true</span></pre><p id="8b55" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你可以看到这段代码运行在<a class="ae ke" href="https://go2goplay.golang.org/p/dO7npX6IeaQ" rel="noopener ugc nofollow" target="_blank">https://go2goplay.golang.org/p/dO7npX6IeaQ</a>。</p><p id="8ec9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是，我们不能再给<code class="du lw lx ly le b">LinkedList</code>分配不可比较的类型。如果我们试图创建一个函数链表:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="6bf6" class="li kh hh le b fi lj lk l ll lm">var functionList *LinkedList[func()]<br/>functionList = functionList.Append(func() { fmt.Println("What about me?") })<br/>fmt.Println(functionList)</span></pre><p id="7081" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它将在编译时失败，并显示错误消息:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="ef86" class="li kh hh le b fi lj lk l ll lm">func() does not satisfy comparable</span></pre><p id="50d6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">除了泛型类型，您还可以编写泛型函数。对Go最常见的抱怨之一是，你不能编写一个函数来处理任何类型的切片。让我们写三个:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="aee2" class="li kh hh le b fi lj lk l ll lm">func Map[type T, E](in []T, f func(T) E) []E {<br/>	out := make([]E, len(in))<br/>	for i, v := range in {<br/>		out[i] = f(v)<br/>	}<br/>	return out<br/>}</span><span id="2439" class="li kh hh le b fi me lk l ll lm">func Reduce[type T, E](in []T, start E, f func(E, T) E) E {<br/>	out := start<br/>	for _, v := range in {<br/>		out = f(out, v)<br/>	}<br/>	return out<br/>}</span><span id="6bda" class="li kh hh le b fi me lk l ll lm">func Filter[type T](in []T, f func(T) bool) []T {<br/>	out := make([]T, 0, len(in))<br/>	for _, v := range in {<br/>		if f(v) {<br/>			out = append(out, v)<br/>		}<br/>	}<br/>	return out<br/>}</span></pre><p id="82e3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">就像泛型一样，泛型函数也有类型参数部分。对于函数，它出现在函数名和函数参数之间。对于<code class="du lw lx ly le b">Map</code>和<code class="du lw lx ly le b">Reduce</code>，我们在函数中使用了两个类型参数，都在类型参数部分声明，并用逗号分隔。如果类型是特定的，函数体与您使用的函数体是相同的；唯一不同的是，我们在<code class="du lw lx ly le b">Map</code>中将<code class="du lw lx ly le b">[]E</code>传递给<code class="du lw lx ly le b">make</code>，在<code class="du lw lx ly le b">Filter</code>中将<code class="du lw lx ly le b">[]T</code>传递给<code class="du lw lx ly le b">make</code>。</p><p id="c800" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们运行代码时:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="b499" class="li kh hh le b fi lj lk l ll lm">strings := []string{"1", "2", "Fred", "3"}<br/>numStrings := Filter(strings, func(s string) bool {<br/>	_, err := strconv.Atoi(s)<br/>	return err == nil<br/>})<br/>fmt.Println(numStrings)</span><span id="7cfb" class="li kh hh le b fi me lk l ll lm">nums := Map(numStrings, func(s string) int {<br/>	val, _ := strconv.Atoi(s)<br/>	return val<br/>})<br/>fmt.Println(nums)</span><span id="eefc" class="li kh hh le b fi me lk l ll lm">total := Reduce(nums, 0, func(start int, val int) int {<br/>	return start + val<br/>})<br/>fmt.Println(total)</span></pre><p id="23b1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们得到输出:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="505f" class="li kh hh le b fi lj lk l ll lm">1 2 3]<br/>[1 2 3]<br/>6</span></pre><p id="faf1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在https://go2goplay.golang.org/p/ek3QTecbSL3的<a class="ae ke" href="https://go2goplay.golang.org/p/ek3QTecbSL3" rel="noopener ugc nofollow" target="_blank">亲自尝试一下。</a></p><p id="2fa2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">需要注意的一点是:在调用函数时，我们没有明确指定类型。Go泛型使用类型推断来判断函数调用使用哪种类型。有些情况下这不起作用(比如用于返回类型的类型参数，而不是输入参数)。在这些情况下，您需要指定所有类型参数。</p><p id="0e8f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们试着写另一个通用函数。Go有一个<code class="du lw lx ly le b">math.Max</code>函数，比较两个<code class="du lw lx ly le b">float64</code>值并返回较大的一个。这样写是因为Go中几乎任何其他数值类型都可以转换为<code class="du lw lx ly le b">float64</code>进行比较(琐事时间:需要超过53位来表示其值的<code class="du lw lx ly le b">uint64</code>或<code class="du lw lx ly le b">int64</code>在转换为<code class="du lw lx ly le b">float64</code>时会失去精度)。来回转换是很难看的，所以让我们试着写一个通用函数来做这件事:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="667a" class="li kh hh le b fi lj lk l ll lm">func Max[type T](v1, v2 T) T {<br/>    if v1 &gt; v2 {<br/>        return v1<br/>    }<br/>    return v2<br/>}</span></pre><p id="dfc2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，如果我们试图编译这个函数，我们会得到一个错误:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="d65f" class="li kh hh le b fi lj lk l ll lm">cannot compare v1 &gt; v2 (operator &gt; not defined for T)</span></pre><p id="bd5d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这很像我们试图比较链表中的值时得到的错误，只是这次是使用了<code class="du lw lx ly le b">&gt;</code>操作符而不是<code class="du lw lx ly le b">==</code>。Go不打算提供一个内置接口来支持其他运营商。在这种情况下，我们必须使用<em class="kf">类型列表</em>编写自己的接口:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="d383" class="li kh hh le b fi lj lk l ll lm">type Ordered interface {<br/>    type string, int, int8, int16, int32, int64, float32, float64, uint, uint8, uint16, uint32, uintptr<br/>}</span><span id="4c6b" class="li kh hh le b fi me lk l ll lm">func Max[type T Ordered](v1, v2 T) T {<br/>    if v1 &gt; v2 {<br/>        return v1<br/>    }<br/>    return v2<br/>}</span></pre><p id="3918" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了使用操作符，我们声明一个接口并列出支持我们想要使用的操作符的类型。请注意，有效的操作符是适用于所列类型的所有类型的操作符。例如，使用<code class="du lw lx ly le b">Ordered</code>作为类型约束的通用函数或类型不能使用<code class="du lw lx ly le b">-</code>或<code class="du lw lx ly le b">*</code>，因为它们不是为<code class="du lw lx ly le b">string</code>定义的。</p><p id="7eae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">既然我们已经有了接口约束，我们可以将任何这些指定类型(或任何用户定义类型，其底层类型是这些类型之一)的实例传递到<code class="du lw lx ly le b">Max</code>:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="a562" class="li kh hh le b fi lj lk l ll lm">fmt.Println(Max(100, 200))<br/>fmt.Println(Max(3.5, 1.2))<br/>fmt.Println(Max("sheep", "goat"))</span></pre><p id="eb57" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这会产生以下输出:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="a25f" class="li kh hh le b fi lj lk l ll lm">200<br/>3.5<br/>sheep</span></pre><p id="a2f4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你可以在https://go2goplay.golang.org/p/g2N1Zjc4oBs亲自尝试一下。</p><p id="b6aa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">类型列表中指定的类型是<em class="kf">基础类型</em>。(参见<a class="ae ke" href="https://golang.org/ref/spec#Types" rel="noopener ugc nofollow" target="_blank">Go语言规范</a>中的定义)。这意味着下面的代码也可以工作:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="0cdd" class="li kh hh le b fi lj lk l ll lm">type MyInt int</span><span id="91a2" class="li kh hh le b fi me lk l ll lm">var a MyInt = 10<br/>var b MyInt = 20<br/>fmt.Println(Max(a,b))</span></pre><p id="0c2b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">老实说，我不喜欢类型列表。然而，它们提供了一种非常简洁的方式来指定哪些操作符是可用的。它们还允许您指定可以将哪些文字赋给泛型类型的变量。正如可用的操作符是类型列表中所有类型的操作符的交集一样，可以赋值的文字就是可以赋给所有列出的类型的文字。在<code class="du lw lx ly le b">Ordered</code>的情况下，您不能分配一个文本，因为没有可以同时分配给<code class="du lw lx ly le b">string</code>和任何数字类型的文本。</p><p id="b5ee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可以使用任何接口作为类型约束，而不仅仅是<code class="du lw lx ly le b">comparable</code>或带有类型列表的接口。用作类型约束的接口可以包含方法和类型列表。但是，不能将具有类型列表的接口用作常规接口类型。</p><p id="c0d7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">泛型方面的内容比我在这里介绍的要多得多。通读<a class="ae ke" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md" rel="noopener ugc nofollow" target="_blank">Go Generics Draft</a>(正式名称为<em class="kf">Type Parameters——Draft Design</em>)以查看关于设计草案的更多细节，它没有涵盖的内容，以及附加的示例代码。</p><h1 id="9e89" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">泛型与接口</h1><p id="301e" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">虽然Go重用接口的概念来实现泛型非常好，但它确实会导致一点混乱。问题是:<em class="kf">什么时候用泛型，什么时候用接口？</em></p><p id="4be5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在还为时尚早，所以模式还在开发中。有一些基本原则可能会被遵循。首要原则是什么都不做。如果您当前的代码使用接口，就不要去管它。把泛型留给那些不能单独用接口解决的情况:</p><ol class=""><li id="875d" class="ln lo hh jk b jl jm jo jp jr lp jv lq jz lr kd ls lt lu lv bi translated">如果你有一个容器类型，当泛型可用时，考虑切换到泛型。为需要反射的情况保存接口{}。</li><li id="5566" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd ls lt lu lv bi translated">如果您一直在编写函数的多种实现来处理不同的数值类型或切片类型，请切换到泛型。</li><li id="94d9" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd ls lt lu lv bi translated">如果你想写一个函数或者方法来创建一个新的实例，你需要使用泛型。</li></ol><p id="baff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">人们问的下一个问题是关于性能的。答案是:<em class="kf">暂时不用担心。</em>当前的原型工具使用的技术(将通用Go代码重写为标准Go代码)不会在任何产品发布中使用。有多种方法可以编译和实现泛型。一旦有了最终的工具，我们将能够看到权衡是什么。对于大多数程序来说，可能不会有显著的差别。</p><h1 id="a8d3" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">少了什么？</h1><p id="bb9d" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">如果你是一个语言极客，你可能知道其他语言中泛型的其他特性。他们中的许多人可能会被排除在Go的泛型之外。其中包括:</p><ul class=""><li id="8598" class="ln lo hh jk b jl jm jo jp jr lp jv lq jz lr kd mf lt lu lv bi translated">专门化(为特定类型提供泛型函数的特例实现)。</li><li id="171f" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd mf lt lu lv bi translated">元编程(编译时生成代码的代码)。</li><li id="8e70" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd mf lt lu lv bi translated">运算符方法(生成一个支持&gt;、*或Operator)等运算符的泛型类型)。</li><li id="a3bd" class="ln lo hh jk b jl lz jo ma jr mb jv mc jz md kd mf lt lu lv bi translated">Currying(通过指定一些参数化类型，基于泛型类型创建新的类型或函数)。</li></ul><h1 id="ad04" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">下一步是什么？</h1><p id="b851" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">泛型设计仍处于草案阶段；很可能会有进一步的调整。如果该设计成为一个提议，并且该提议被接受，那么包含泛型的最早版本可能是Go 1.17。</p><p id="6695" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在还为时尚早，但我对这种设计的前景感到兴奋。它增加了最需要的特性，而不会使语言变得更加复杂。有些人会对其他高级功能被遗漏感到失望，但这不是正确的做法。Go旨在成为一种易读、易学、易维护的简单语言。通过添加足够的泛型来解决最常见的问题，Go继续满足这一理想。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="7dad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>