<html>
<head>
<title>Jetpack Compose Interop: Using Compose in a RecyclerView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写互操作:在RecyclerView中使用撰写</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-compose-interop-using-compose-in-a-recyclerview-569c7ec7a583?source=collection_archive---------1-----------------------#2022-07-22">https://medium.com/androiddevelopers/jetpack-compose-interop-using-compose-in-a-recyclerview-569c7ec7a583?source=collection_archive---------1-----------------------#2022-07-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/13e6fec881c71b33a529f26f407ebe49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBNjsK7y35V05OKNQ2oIZg.png"/></div></div></figure><p id="17c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">TL；博士</strong></p><ul class=""><li id="d62e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><code class="du jw jx jy jz b">RecyclerView 1.3.0-alpha02</code>和<code class="du jw jx jy jz b">Compose UI 1.2.0-beta02</code>带来了RecyclerView中组件的开箱即用的高性能使用——不需要额外的代码！</li><li id="6c6b" class="jn jo hh ir b is ka iw kb ja kc je kd ji ke jm js jt ju jv bi translated">如果您之前已经在RecyclerView中实现了我们的编写指南，那么现在您应该删除这段代码。</li></ul><p id="9b21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在你的代码库中引入增量合成意味着你可以结束在<code class="du jw jx jy jz b">RecyclerView</code>中使用组件作为项目的情况。在组合UI版本<code class="du jw jx jy jz b">1.2.0-beta02</code>之前，当视图从窗口分离时，<code class="du jw jx jy jz b">ComposeView</code>的底层组合被处理。然而，在<code class="du jw jx jy jz b">RecyclerView</code>的上下文中，当项目移出/移出屏幕时，它们不断地从窗口分离/附着。不得不重复处理和重新创建组合的开销很大，并且会影响性能，尤其是在快速浏览列表时。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es kf"><img src="../Images/c7039b0b028c3b739720cfd100e910bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*_aKMg_MaJtKEEav4V1ws_w.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx">Compose used as items in a RecyclerView</figcaption></figure><p id="69ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从Compose UI版本1.2.0-beta02和RecyclerView版本1.3.0-alpha02开始，库使用的视图合成策略发生了变化:当视图从窗口中分离时，<strong class="ir hi">合成现在会被自动处理</strong>，除非 <strong class="ir hi">它是池容器的一部分，</strong>如RecyclerView。因此，当ComposeView被用作RecyclerView中的一个项目时，composables不再被释放，而是被重用。这种行为变化意味着您不需要做任何工作来正确处理这个问题。如果您已经实现了前面的指南，那么您应该在更新到最新的库之后删除它，因为它将覆盖改进的默认行为。</p><p id="7eed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您的实现应该是这样的:</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="cd83" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我将介绍为什么推荐以前的指南的背景，以及为什么我们建议您在使用上述版本(或更高版本)的RecyclerView和Compose时更新您的实现，以获得更好的滚动性能并简化您的代码。</p><h1 id="70d1" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">了解前面的默认合成策略:DisposeOnDetachedFromWindow</h1><p id="00bb" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">一个<code class="du jw jx jy jz b">ComposeView</code>的<code class="du jw jx jy jz b"><a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ViewCompositionStrategy" rel="noopener ugc nofollow" target="_blank">ViewCompositionStrategy</a></code>决定了什么时候应该释放底层组合。在Compose UI的<code class="du jw jx jy jz b">1.2.0-beta02</code>版本之前，这个值被配置为<code class="du jw jx jy jz b"><strong class="ir hi">DisposeOnDetachedFromWindow</strong></code>，每当视图从窗口分离时，它将释放组合。视上下文而定，视图可能会从窗口中分离出来，这种情况有多种，但通常情况下，这种情况会在底层容器离开屏幕或即将被销毁时发生。虽然这是您在大多数情况下想要的行为，但是在视图经常被分离并重新附加到窗口的情况下，例如在<code class="du jw jx jy jz b">RecyclerView</code>中，这种策略是次优的。频繁地处理和重新创建组合会损害滚动性能，尤其是在快速浏览列表时。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/f6f45904d3e6d845b30e9f0fffc1b5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*RtZFZdJVa5-Sxw-MSqSpfA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx">Attached/detached views in RecyclerView</figcaption></figure><p id="04e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了减轻这一点，<code class="du jw jx jy jz b">ComposeView</code>当底层视图被回收时，而不是当它从窗口分离时，可以通过处理来改善组合处理(注意，这仍然不是理想的情况，我们将在后面看到)。我们可以通过覆盖<code class="du jw jx jy jz b">RecyclerView.Adapter</code>类中的<code class="du jw jx jy jz b">onViewRecycled(ViewHolder)</code>方法来监听这个事件。根据该方法的<a class="ae lt" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onViewRecycled(VH)" rel="noopener ugc nofollow" target="_blank">文档</a>，当出现以下情况时，基础视图将被回收:</p><blockquote class="lv lw lx"><p id="0752" class="ip iq ly ir b is it iu iv iw ix iy iz lz jb jc jd ma jf jg jh mb jj jk jl jm ha bi translated">“…一个循环视图。LayoutManager决定不再需要将其附加到其父RecyclerView。这可能是因为它已不可见，或者一组缓存视图仍由附加到父RecyclerView的视图表示。如果项目视图绑定了大型或昂贵的数据，如大型位图，这可能是释放这些资源的好地方。</p></blockquote><p id="ceca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jw jx jy jz b">onViewRecycled(ViewHolder)</code>中，我们可以调用<code class="du jw jx jy jz b">ComposeView</code>上的<code class="du jw jx jy jz b">disposeComposition()</code>方法。这相当于前面指南的第一部分(如果您使用的是前面提到的Compose和<code class="du jw jx jy jz b">RecyclerView</code>版本，则不再推荐):</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="4e97" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，为了防止视图分离时<code class="du jw jx jy jz b">ComposeView</code>被释放，我们必须设置一个不同的<code class="du jw jx jy jz b">ViewCompositionStrategy</code>。具体来说，我们必须将它设置为<code class="du jw jx jy jz b">DisposeOnViewTreeLifecycleDestroyed</code>，这样当底层生命周期所有者被销毁时，组合将被处理掉。</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="54ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着这些改变，当一个项目视图分离时，<code class="du jw jx jy jz b">ComposeView’s</code>组合将不再被自动处理。所以，当你滚动列表时，我们应该能够看到<code class="du jw jx jy jz b">ComposeView</code>项被减少了。为了验证这一点，让我们假设一个<code class="du jw jx jy jz b">RecyclerView</code>中的每一项都由一个<code class="du jw jx jy jz b">ItemRow</code>可组合表示:</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/7feab7714a2d1452dbc6b085d2022115.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*tqeVwWlWIuwtGkazrZZ2Rw.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx">RecyclerView containing ItemRows</figcaption></figure><p id="2354" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个<code class="du jw jx jy jz b">ItemRow</code>被排版时，一个<code class="du jw jx jy jz b">DisposableEffect</code>也进入排版，当它进入时被用作打印机制，然后离开排版。在这种设置下，滚动会产生以下日志语句:</p><pre class="kg kh ki kj fd md jz me mf aw mg bi"><span id="9363" class="mh kr hh jz b fi mi mj l mk ml">16:06:12.840 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 0 composed</span><span id="4641" class="mh kr hh jz b fi mm mj l mk ml">16:06:12.970 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 1 composed</span><span id="f494" class="mh kr hh jz b fi mm mj l mk ml">16:06:13.047 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 2 composed</span><span id="d911" class="mh kr hh jz b fi mm mj l mk ml">16:06:13.119 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 3 composed</span><span id="a93c" class="mh kr hh jz b fi mm mj l mk ml">16:06:13.196 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 4 composed</span><span id="5a17" class="mh kr hh jz b fi mm mj l mk ml">16:06:17.922 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 5 composed</span><span id="4d9a" class="mh kr hh jz b fi mm mj l mk ml">16:06:19.033 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 6 composed</span><span id="2fca" class="mh kr hh jz b fi mm mj l mk ml">16:06:20.781 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 7 composed</span><span id="c723" class="mh kr hh jz b fi mm mj l mk ml">16:06:20.909 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 0 <strong class="jz hi">DISPOSED</strong></span><span id="1764" class="mh kr hh jz b fi mm mj l mk ml">16:06:23.482 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 8 composed</span><span id="b68b" class="mh kr hh jz b fi mm mj l mk ml">16:06:23.527 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 1 <strong class="jz hi">DISPOSED</strong></span><span id="0ca9" class="mh kr hh jz b fi mm mj l mk ml">16:06:23.678 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 9 composed</span><span id="4f30" class="mh kr hh jz b fi mm mj l mk ml">16:06:23.752 5619-5619/com.google.samples.app.rv D/ItemRow: ItemRow 2 <strong class="jz hi">DISPOSED</strong></span></pre><p id="9c33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们可以看到，由于容器<code class="du jw jx jy jz b">ComposeView</code>被回收，索引为0、1和2的<code class="du jw jx jy jz b">ItemRow’s</code>成分被处置。</p><p id="9908" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这些变化肯定是一种改进，但更好的行为应该是这样的:</p><blockquote class="lv lw lx"><p id="a1fc" class="ip iq ly ir b is it iu iv iw ix iy iz lz jb jc jd ma jf jg jh mb jj jk jl jm ha bi translated">当新数据被重新绑定到</p><p id="4381" class="ip iq ly ir b is it iu iv iw ix iy iz lz jb jc jd ma jf jg jh mb jj jk jl jm ha bi translated">适配器。此外，只有在可能的情况下才应该处理组合</p><p id="ef84" class="ip iq ly ir b is it iu iv iw ix iy iz lz jb jc jd ma jf jg jh mb jj jk jl jm ha bi translated">请确保不会再次使用“撰写视图”。</p></blockquote><p id="0d8d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">利用当前的解决方案，当组合物应该被处理时，它们也可能不被处理。具体来说，如果<code class="du jw jx jy jz b">RecyclerView</code>从窗口分离，但是包含的活动/片段生命周期仍然是活动的，则组合将不会被处置，导致组合尽管不再被需要但仍然是活动的。</p><p id="ed9c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以前可用的API没有办法绕过这些限制，这需要修改Compose和<code class="du jw jx jy jz b">RecyclerView</code>来改进这些行为。</p><h1 id="22dc" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">了解新的默认合成策略:DisposeOnDetachedFromWindowOrReleasedFromPool</h1><p id="81f3" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">为了支持在合适的时间处理组合，引入了新的策略<code class="du jw jx jy jz b"><a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool" rel="noopener ugc nofollow" target="_blank">ViewCompositionStrategy.DisposeOnDetachedFromWindowOrReleasedFromPool</a> </code>，并从组合UI的版本<code class="du jw jx jy jz b">1.2.0-beta02</code>开始，将其设置为<code class="du jw jx jy jz b">ComposeView</code>的新<a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ViewCompositionStrategy.Companion#Default()" rel="noopener ugc nofollow" target="_blank">默认</a> <code class="du jw jx jy jz b">ViewCompositionStrategy </code>。根据文件:</p><blockquote class="lv lw lx"><p id="ea81" class="ip iq ly ir b is it iu iv iw ix iy iz lz jb jc jd ma jf jg jh mb jj jk jl jm ha bi translated">当视图从窗口分离时，组合将被自动处理，除非它是<a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/customview/poolingcontainer/package-summary#(android.view.View).isPoolingContainer()" rel="noopener ugc nofollow" target="_blank">池容器</a>的一部分，如RecyclerView。当不在池容器中时，其行为与<a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ViewCompositionStrategy.DisposeOnDetachedFromWindow" rel="noopener ugc nofollow" target="_blank">DisposeOnDetachedFromWindow</a>完全相同。</p></blockquote><p id="04b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个新策略的行为与之前的默认策略完全一样；然而，它阻止了在<code class="du jw jx jy jz b">RecyclerView</code>的上下文中处理分离的视图，而这正是我们想要的。这引入了池容器的概念，当一个项应该释放它所拥有的任何资源时，池容器使通过项回收的类型能够进行通信。池容器的概念是在一个新的工件(<a class="ae lt" href="https://developer.android.com/reference/kotlin/androidx/customview/poolingcontainer/package-summary#(android.view.View).isPoolingContainer()" rel="noopener ugc nofollow" target="_blank">androidx . custom view . pooling container</a>)中实现的，组合UI和<code class="du jw jx jy jz b">RecyclerView</code>都依赖于这个工件。通过该构件提供的接口，<code class="du jw jx jy jz b">RecyclerView</code>可以在组合应该被优化处理时与组合进行通信，使得不再需要在<code class="du jw jx jy jz b">onViewRecycled(ViewHolder)</code>中手动处理组合。相反，当项目视图被丢弃时(例如，当<code class="du jw jx jy jz b">RecycledViewPool</code>已经满了时)或者当<code class="du jw jx jy jz b">RecyclerView</code>从窗口分离时，组合将被处置。这种实现比在<code class="du jw jx jy jz b">onViewRecycled(ViewHolder)</code>中处理组合更有效，因为它拥有更多关于<code class="du jw jx jy jz b">RecyclerView’s</code>项目生命周期的信息，从而减少了不必要的处理。</p><p id="2ffa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这个新的视图组合策略，使用相同的<code class="du jw jx jy jz b">ItemRow</code>组件作为<code class="du jw jx jy jz b">RecyclerView</code>中的项目，我们可以看到，当滚动列表时，组合不再被处理:</p><pre class="kg kh ki kj fd md jz me mf aw mg bi"><span id="c0ea" class="mh kr hh jz b fi mi mj l mk ml">16:17:27.699 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 0 composed</span><span id="1afe" class="mh kr hh jz b fi mm mj l mk ml">16:17:27.796 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 1 composed</span><span id="7d36" class="mh kr hh jz b fi mm mj l mk ml">16:17:27.850 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 2 composed</span><span id="23b9" class="mh kr hh jz b fi mm mj l mk ml">16:17:27.909 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 3 composed</span><span id="6ad2" class="mh kr hh jz b fi mm mj l mk ml">16:17:27.961 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 4 composed</span><span id="7dea" class="mh kr hh jz b fi mm mj l mk ml">16:17:31.747 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 5 composed</span><span id="e07d" class="mh kr hh jz b fi mm mj l mk ml">16:17:31.897 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 6 composed</span><span id="7acc" class="mh kr hh jz b fi mm mj l mk ml">16:17:32.313 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 7 composed</span><span id="1a6b" class="mh kr hh jz b fi mm mj l mk ml">16:17:33.061 6406-6406/com.google.samples.app.rv D/ItemRow: ItemRow 8 composed</span></pre><h1 id="f0be" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">记忆状态</h1><p id="6bd3" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">回收物品时，组合保持活动状态。这意味着即使在绑定新数据时，任何内部记忆的状态也将被记忆。例如，在类似ItemRow的RecyclerView中有一个LazyRow的场景中，当视图被回收时，滚动位置会被记住。在下面的屏幕截图中，注意第1行的滚动位置如何影响第10行的滚动位置。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/c0f2d781278063e29390cb0815317c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/1*jkCrEkHnfg2Agl32VcHE_g.gif"/></div><figcaption class="kk kl et er es km kn bd b be z dx">LazyRow scroll state remembered across item views.</figcaption></figure><p id="7f7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要防止这种行为，您有两种选择。</p><p id="e40d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选项1:如果可能，您应该<strong class="ir hi">将任何特定于项目的状态提升到适配器</strong>中。例如，<code class="du jw jx jy jz b">LazyRows</code>的<code class="du jw jx jy jz b">RecyclerView</code>可能有一个适配器，如下所示:</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="32d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个适配器的<code class="du jw jx jy jz b">onBindViewHolder</code>方法创建了<code class="du jw jx jy jz b">LazyListState</code>并将其设置在<code class="du jw jx jy jz b">AbstractComposeView</code>子类中。使用<code class="du jw jx jy jz b">mutableStateOf</code>将它存储在一个委托属性中，以确保<code class="du jw jx jy jz b">LazyRow</code>总是具有正确的状态。</p><p id="4459" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你不能提升状态，那么有一个更简单的方法。</p><p id="dc7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选项2: <strong class="ir hi">将任何具有</strong> <code class="du jw jx jy jz b"><strong class="ir hi">remembered</strong></code> <strong class="ir hi">状态的内容包装在一个</strong> <code class="du jw jx jy jz b"><strong class="ir hi">key</strong></code>中，传递一个(或多个)唯一标识该项的值(如果您的列表顺序从未改变，该位置将起作用)。当值改变时，这将导致键中的所有内容被完全重新创建，而没有任何现有的<code class="du jw jx jy jz b">remember</code> ed状态。你应该只对你的UI中有<code class="du jw jx jy jz b">remember</code> ed状态的部分这样做，因为这会导致重新创建组合的相关部分的性能损失。此外，这意味着当项目再次滚动到视图中时，您想要恢复的任何状态(例如<code class="du jw jx jy jz b">LazyRow</code> s的滚动位置)将在项目被回收时丢失。</p><p id="b245" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这种方法，ItemRow组件类似于:</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><h1 id="9712" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">分离项目的重新组合</h1><p id="6ed2" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">尽管被分离，组合物仍将保持活性。这意味着响应状态更改的重新组合(如动画)将继续运行。这可能会影响滚动性能，因此请确保在项目离开屏幕时停止活动动画。</p><p id="1934" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，假设您正在使用<code class="du jw jx jy jz b"><a class="ae lt" href="https://developer.android.com/jetpack/compose/animation#animatable" rel="noopener ugc nofollow" target="_blank">Animatable</a></code> API来制作<code class="du jw jx jy jz b">RecyclerView</code>项目的背景色动画。您可以将<code class="du jw jx jy jz b">Animatable</code>对象提升到项目视图，并在适配器<code class="du jw jx jy jz b"><a class="ae lt" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#onViewDetachedFromWindow(VH)" rel="noopener ugc nofollow" target="_blank">onViewDetachedFromWindow(ViewHolder)</a></code>方法中调用<code class="du jw jx jy jz b">stop()</code>，如下所示:</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><h1 id="b2fc" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">摘要</h1><p id="028a" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">为了利用在<code class="du jw jx jy jz b">RecyclerView</code>中使用Compose的改进，将您的依赖项至少更新到<code class="du jw jx jy jz b">RecyclerView</code>版本<code class="du jw jx jy jz b">1.3.0-alpha02</code> <strong class="ir hi">和</strong> Compose UI版本<code class="du jw jx jy jz b">1.2.0-beta02</code>。如果您之前遵循了我们的指导，<strong class="ir hi">请确保在视图被回收时也删除显式的</strong> <code class="du jw jx jy jz b"><strong class="ir hi">disposeComposition()</strong></code> <strong class="ir hi">调用，以及将</strong> <code class="du jw jx jy jz b"><strong class="ir hi">ViewCompositionStrategy</strong></code> <strong class="ir hi">设置为</strong> <code class="du jw jx jy jz b"><strong class="ir hi">DisposeOnViewTreeLifecycleDestroyed</strong></code>的代码。如果您在此过程中遇到任何问题，您可以在我们的公共<a class="ae lt" href="https://issuetracker.google.com/issues/new?component=612128" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>中提出问题。</p><p id="bbd1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还没有将您现有的基于视图的应用程序迁移到Compose并想了解更多信息吗？查看<a class="ae lt" href="https://developer.android.com/codelabs/jetpack-compose-migration#0" rel="noopener ugc nofollow" target="_blank">迁移到Jetpack Compose </a> Codelab和<a class="ae lt" href="https://github.com/android/sunflower" rel="noopener ugc nofollow" target="_blank"> Sunflower </a>示例应用程序，它们显示了视图和Compose同时使用。</p><p id="6b0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你有任何问题，欢迎在这个帖子上留下你的评论。同时，快乐写作！</p><p id="d99c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ly">以下帖子是与</em> <a class="ae lt" href="https://twitter.com/ryanmentley" rel="noopener ugc nofollow" target="_blank"> <em class="ly">瑞安·门特利</em> </a> <em class="ly">合作撰写的。感谢</em> <a class="ae lt" rel="noopener" href="/@florina.muntenescu"> <em class="ly">弗洛里纳</em></a><em class="ly"/><a class="ae lt" rel="noopener" href="/@riggaroo"><em class="ly">丽贝卡·弗兰克斯</em></a><em class="ly"/><a class="ae lt" rel="noopener" href="/@anomisSi"><em class="ly">新美乐股份公司·斯托亚诺维奇</em> </a> <em class="ly">的点评。</em></p></div></div>    
</body>
</html>