<html>
<head>
<title>Package visibility in Android 11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 11中的包可见性</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/package-visibility-in-android-11-cc857f221cd9?source=collection_archive---------1-----------------------#2020-06-30">https://medium.com/androiddevelopers/package-visibility-in-android-11-cc857f221cd9?source=collection_archive---------1-----------------------#2020-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/de14acf6439dcd8e0639d02dd4c04976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mzx-wzsHjrpKtCJjG0sXwA.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://dribbble.com/Molly_Hensley" rel="noopener ugc nofollow" target="_blank">Molly Hensley</a></figcaption></figure><div class=""/><p id="2a18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android 10和更早的版本中，应用程序可以使用类似<code class="du js jt ju jv b">queryIntentActivities()</code>的方法查询系统中已安装应用程序的完整列表。在大多数情况下，这远远超出了应用程序实现其功能所需的访问范围。随着我们对隐私的持续关注，我们将在Android 11上引入应用程序如何查询和与同一设备上安装的其他应用程序交互的变化。特别是，我们正在为特定设备上安装的应用程序列表提供更好的范围访问。</p><p id="989a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了对设备上已安装应用的访问提供更好的问责，默认情况下，针对Android 11 (API级别30)的应用将看到已安装应用的过滤列表。为了访问更广泛的已安装应用程序列表，应用程序可以指定他们需要查询和直接交互的应用程序的信息。这可以通过在Android清单中添加一个<code class="du js jt ju jv b">&lt;queries&gt;</code>元素来实现。</p><p id="a123" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于大多数<a class="ae hu" href="https://developer.android.com/preview/privacy/package-visibility#use-cases-not-affected" rel="noopener ugc nofollow" target="_blank">常见场景</a>，包括任何以<code class="du js jt ju jv b">startActivity()</code>开头的隐含意图，你不需要改变任何东西！对于<a class="ae hu" href="https://developer.android.com/preview/privacy/package-visibility-use-cases" rel="noopener ugc nofollow" target="_blank">其他场景</a>，比如直接从用户界面打开一个特定的第三方应用程序，开发者必须明确列出应用程序包名称或<a class="ae hu" href="https://developer.android.com/preview/privacy/package-visibility#intent-signature" rel="noopener ugc nofollow" target="_blank">意图过滤器签名</a>，如下所示:</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="dff1" class="ke kf hx jv b fi kg kh l ki kj">&lt;manifest package="com.example.game"&gt;<br/>  &lt;queries&gt;<br/>    &lt;!-- Specific apps you interact with, eg: --&gt;<br/>    &lt;package android:name="com.example.store" /&gt;<br/>    &lt;package android:name="com.example.service" /&gt;</span><span id="4fae" class="ke kf hx jv b fi kk kh l ki kj">    &lt;!--<br/>         Specific intents you query for,<br/>         eg: for a custom share UI<br/>    --&gt;<br/>    &lt;intent&gt;<br/>      &lt;action android:name="android.intent.action.SEND" /&gt;<br/>      &lt;data android:mimeType="image/jpeg" /&gt;<br/>    &lt;/intent&gt;<br/>  &lt;/queries&gt;<br/>  ...<br/>&lt;/manifest&gt;</span></pre><p id="d09a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您使用<a class="ae hu" href="https://developers.google.com/web/android/custom-tabs" rel="noopener ugc nofollow" target="_blank">自定义标签</a>打开URL，您可能会调用<code class="du js jt ju jv b">resolveActivity()</code>和<code class="du js jt ju jv b">queryIntentActivities()</code>来启动一个非浏览器应用程序(如果该URL有可用的话)。在Android 11中，有一种更好的方式来做到这一点，这避免了查询其他应用程序的需要:意图标志。当您使用这个标志调用<code class="du js jt ju jv b">startActivity()</code>时，如果浏览器已经启动，将会抛出一个<code class="du js jt ju jv b">ActivityNotFoundException</code>。发生这种情况时，您可以在自定义选项卡中打开URL。</p><pre class="jw jx jy jz fd ka jv kb kc aw kd bi"><span id="09b3" class="ke kf hx jv b fi kg kh l ki kj">try {<br/>  val intent = Intent(ACTION_VIEW, Uri.parse(url)).apply {<br/>    // The URL should either launch directly in a non-browser app<br/>    // (if it’s the default), or in the disambiguation dialog</span><span id="42e0" class="ke kf hx jv b fi kk kh l ki kj">    addCategory(CATEGORY_BROWSABLE)<br/>    flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_REQUIRE_NON_BROWSER<br/>  }</span><span id="31d3" class="ke kf hx jv b fi kk kh l ki kj">  startActivity(intent)<br/>} catch (e: ActivityNotFoundException) {<br/>  // Only browser apps are available, or a browser is the default app for this intent<br/>}</span></pre><p id="cb31" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在极少数情况下，您的应用程序可能需要查询设备上安装的所有应用程序或与之交互，而与它们包含的组件无关。为了允许你的应用程序看到所有其他已安装的应用程序，Android 11引入了<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/preview/privacy/package-visibility#all-apps" rel="noopener ugc nofollow" target="_blank">QUERY_ALL_PACKAGES</a></code>权限。在即将到来的Google Play政策更新中，寻找需要<code class="du js jt ju jv b">QUERY_ALL_PACKAGES</code>权限的应用程序的指南。</p><p id="bdf2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当目标是API等级30并且在你的应用中添加一个<code class="du js jt ju jv b">&lt;queries&gt;</code>元素时，使用最新发布的Android Gradle插件。很快，我们将发布旧版本Android Gradle插件的更新，以增加对该元素的支持。你可以在<a class="ae hu" href="https://developer.android.com/preview/privacy/package-visibility" rel="noopener ugc nofollow" target="_blank">开发者文档</a>中找到更多关于包可见性的信息和用例。</p></div></div>    
</body>
</html>