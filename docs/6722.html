<html>
<head>
<title>How to start with Spring WebFlux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Spring WebFlux开始</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-start-with-spring-webflux-dc79b55271bf?source=collection_archive---------0-----------------------#2019-10-13">https://medium.com/quick-code/how-to-start-with-spring-webflux-dc79b55271bf?source=collection_archive---------0-----------------------#2019-10-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="98c9" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Spring实现的反应式编程简介</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/cb8d926ffafd06b8240e9d3310764bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xMV7ASeERicKFYOL"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="9838" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">介绍</h1><p id="edcc" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">5.x.x版本实现了Spring Webflux项目，并将其包含在Spring Suite中。</p><p id="da3e" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">该框架的目标是促进Java反应式编程的发展，减少并发性，减少硬件需求。</p><p id="082f" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在这个故事中，我将通过一个简单的例子来介绍反应式编程的思想，并概述可能使用它的场景。</p><p id="e082" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi"> <em class="ln">走吧！</em>T3】</strong></p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="56fb" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">反应式编程</h1><p id="6642" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">反应式编程用于实现体系结构的非阻塞模型。决定使用反应式编程的web应用需要实现基于<strong class="ko hi">订阅</strong>和<strong class="ko hi">事件</strong>的逻辑。</p><p id="7486" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">web应用程序的流程现在变成了异步的，并在事件响应中做出反应。</p><p id="c940" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">架构师和开发人员需要记住这些概念，通过“<em class="ln">标准同步编程</em>”不同地设计方法或类。</p><p id="faef" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">反应式编程通常与功能性编程(<em class="ln">做什么和不做什么</em>)相关，功能性编程包含在非阻塞流的上下文中，并且是其先决条件。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="3823" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">简单的例子</h1><p id="0404" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">为了表示异步调用，我们将创建一个REST控制器来管理Mono和Flux对象，它包含在Reactor框架中，用于传输单个对象(Mono)或对象列表(Flux)。</p><p id="42e2" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">客户端将由另一个web应用程序和一个WebClient组成，也包含在Web Flux中，允许调用REST服务并订阅以等待它们的响应。</p><p id="8760" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">为了实现这个利用Spring Web Flux的例子，我们开始用<a class="ae jm" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>创建一个新的Java Spring Boot项目，它将包含所需的依赖项:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/ab193e7901d028884809a421cb6e2cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKWNOhh6jCS-nsFOLa6lhQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Configuration of the new Spring Project with the dependency of Spring Reactive Web</figcaption></figure><p id="e779" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">将项目导入到Eclipse中，我们就可以开始了。第一步是在Spring上下文中启用Web Flux，在控制器上引入注释<em class="ln"> @EnableWebFlux </em>:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Definition of the root class of the Spring Context</figcaption></figure><p id="e63b" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">第二步是实现REST控制器，它公开了两个示例方法，一个用于单声道，一个用于通量:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Rest Controller class with two examples of method</figcaption></figure><p id="3995" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">Mono类表示在服务器和客户端之间的通信中要交换的单个对象，而Flux类表示一个或多个对象的集合，即使有特定的延迟，这些对象也可以被推送给调用者。</p><p id="a54a" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这个类的目标，以及公开REST服务，是在反应式框架和应用程序较低层开发的软件之间创建一个解耦级别。</p><p id="b197" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">事实上，repository类与Web Flux框架或Reactor没有任何联系，因此，有可能将此框架也应用于现有项目(如有必要):</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Book repository class</figcaption></figure><p id="0f43" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在repository类中，我们添加了一个<em class="ln"> sleep </em>来模拟在测试阶段读取资源的延迟。</p><p id="95b2" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">最后一步是创建一个客户端Spring Boot应用程序，为了简单起见，只使用了一个控制器，在控制器中，我们将包含Web客户端和对两个REST服务的调用:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Client class with the examples of invocation of the reactive REST services</figcaption></figure><p id="3ecf" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">调用反应式REST服务的最少步骤是:</p><ul class=""><li id="a2f1" class="lr ls hh ko b kp li ks lj kv lt kz lu ld lv lh lw lx ly lz bi translated"><strong class="ko hi">初始化</strong><strong class="ko hi">Web客户端</strong>传递URL</li><li id="9b1f" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="ko hi">执行</strong>对服务的<strong class="ko hi">调用</strong>并预置<strong class="ko hi">检索</strong>响应的<strong class="ko hi">体</strong></li><li id="916b" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="ko hi">订阅</strong>到<strong class="ko hi">事件</strong></li></ul><p id="1b9c" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">服务的调用将与方法的执行同时执行，而响应中的事件管理将是异步的。</p><p id="0502" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">我们已经执行了实现的软件，我们看到“完成方法”日志是在检索事件之前执行的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/ffa25dd40590bd59ae4c16b60092b4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1auSyJN898Kh--0LiUIBQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Execution log of the Web Client</figcaption></figure><p id="e4f0" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">根据repository类中的超时设置，事件Mono和Flux在3 e 10秒后被推送。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="8ab9" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">利用场景</h1><p id="6bca" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">在Java应用程序的环境中，使用Web Flux框架是可取的，在Java应用程序的环境中，可以设想实现异步信息交换的机制，例如:</p><ul class=""><li id="47ef" class="lr ls hh ko b kp li ks lj kv lt kz lu ld lv lh lw lx ly lz bi translated"><strong class="ko hi">移动应用</strong>:在订阅事件时需要接收异步通知的移动应用中</li><li id="326c" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated">Web应用程序:一般来说，在接收事件通知而不阻塞软件执行的WEB应用程序中使用这个框架是明智的</li><li id="25eb" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="ko hi">并行和分布式计算</strong>:并行计算的web应用中，不需要阻塞主程序的执行，而是在被调用的服务完成后收集通知</li><li id="ce52" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="ko hi">消息驱动应用</strong>:在由消息交换驱动执行的应用中</li><li id="729e" class="lr ls hh ko b kp ma ks mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="ko hi">其他？</strong></li></ul><p id="b730" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这个新框架明显简化了<em class="ln">订阅和通知</em>的范例，特别是对于REST web服务，并且打开了Java编程的大门，以一种新的方式来思考和实现web应用程序。</p><p id="5e7d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi"> <em class="ln">感谢您的宝贵时间！</em> </strong></p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="adf8" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi">参考</strong>:弹簧网<a class="ae jm" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" rel="noopener ugc nofollow" target="_blank">参考</a>和<a class="ae jm" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">电抗器</a></p><p id="6522" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi"> GitHub </strong>:项目<a class="ae jm" href="https://github.com/Mamix84/medium/tree/master/SpringWebFluxExample" rel="noopener ugc nofollow" target="_blank"> SpringWebFluxExample </a>和<a class="ae jm" href="https://github.com/Mamix84/medium/tree/master/SpringWebFluxClientExample" rel="noopener ugc nofollow" target="_blank">spring web flux client example</a></p></div></div>    
</body>
</html>