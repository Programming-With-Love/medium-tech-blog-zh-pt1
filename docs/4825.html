<html>
<head>
<title>The character of Kotlin: Conciseness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的性格:简洁</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/the-character-of-kotlin-conciseness-2c70bc141985?source=collection_archive---------5-----------------------#2018-02-28">https://blog.kotlin-academy.com/the-character-of-kotlin-conciseness-2c70bc141985?source=collection_archive---------5-----------------------#2018-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8d22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇文章中，我已经解释了为什么科特林像钢铁侠。现在我想继续这个比喻，展现科特林的简洁。</p><p id="4c78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在漫威宇宙中，自从钢铁侠诞生以来，其他国家都在尝试制作自己的版本。如果你比较真实的钢铁侠和复制它的微弱尝试，你可以看到他的宇航服小得多，但更强大。看看在现实世界中重现钢铁侠的尝试有多大:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="9f71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">钢铁侠的强大之处在于，它不是一艘飞船，也不是一辆坦克，相反，它是简洁而又强大的结构。每一个额外的元素都是成本，因为它需要移动、供电和维护。由于钢铁侠的服装很小，托尼·斯塔克可以轻松击败使用更多能量和资源的巨大飞船。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kq"><img src="../Images/0634ea4049eacba48716f611edefa315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zraaVmKizGZmhIbNhwYXA.png"/></div></div></figure><p id="7e35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也是Kotlin的一个巨大的威力:它是高度简洁的语言。让我们来看看支持它的一些重要特性。</p><h1 id="b636" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">班级创建</h1><p id="2d74" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">让我们讨论如何定义数据模型。我们需要定义一个有id，名字，姓氏和年龄的用户。这是我们在Java中定义它的方式:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="adbe" class="mf ky in mb b gy mg mh l mi mj">// Java <br/><strong class="mb io">public class </strong>User {<br/>    <strong class="mb io">private int id</strong>;<br/>    <strong class="mb io">private </strong>String <strong class="mb io">name</strong>;<br/>    <strong class="mb io">private </strong>String <strong class="mb io">surname</strong>;<br/>    <strong class="mb io">private int age</strong>;<br/><br/>    <strong class="mb io">public </strong>User(<strong class="mb io">int </strong>id, String name, String surname, <strong class="mb io">int </strong>age) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">id </strong>= id;<br/>        <strong class="mb io">this</strong>.<strong class="mb io">name </strong>= name;<br/>        <strong class="mb io">this</strong>.<strong class="mb io">surname </strong>= surname;<br/>        <strong class="mb io">this</strong>.<strong class="mb io">age </strong>= age;<br/>    }<br/><br/>    <strong class="mb io">public int </strong>getId() {<br/>        <strong class="mb io">return id</strong>;<br/>    }<br/><br/>    <strong class="mb io">public void </strong>setId(<strong class="mb io">int </strong>id) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">id </strong>= id;<br/>    }<br/><br/>    <strong class="mb io">public </strong>String getName() {<br/>        <strong class="mb io">return name</strong>;<br/>    }<br/><br/>    <strong class="mb io">public void </strong>setName(String name) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">name </strong>= name;<br/>    }<br/><br/>    <strong class="mb io">public </strong>String getSurname() {<br/>        <strong class="mb io">return surname</strong>;<br/>    }<br/><br/>    <strong class="mb io">public void </strong>setSurname(String surname) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">surname </strong>= surname;<br/>    }<br/><br/>    <strong class="mb io">public int </strong>getAge() {<br/>        <strong class="mb io">return age</strong>;<br/>    }<br/><br/>    <strong class="mb io">public void </strong>setAge(<strong class="mb io">int </strong>age) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">age </strong>= age;<br/>    }<br/>}</span></pre><p id="5c1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是Kotlin中相同类的外观:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="d9b1" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User(<br/>        <strong class="mb io">var id</strong>: Int,<br/>        <strong class="mb io">var name</strong>: String,<br/>        <strong class="mb io">var surname</strong>: String,<br/>        <strong class="mb io">var age</strong>: Int<br/>)</span></pre><p id="8a10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来不可能？然而，我们仍然有构造函数、封装字段等。科特林哲学的一部分是，普通的事情应该简单。定义数据模型真的很常见，所以Kotlin被设计成支持它也就不足为奇了。让我们一步一步地分析过渡。</p><p id="2ee7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们不需要setters和getters，因为它们是<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">内置属性</a>。我们总是可以改变物业服务或设定价值的方式:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="8e36" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">var </strong><em class="mk">name</em>: String = <strong class="mb io">""<br/>    get</strong>() = <strong class="mb io">field</strong>.<em class="mk">toUpperCase</em>()<br/>    <strong class="mb io">set</strong>(value) {<br/>        <strong class="mb io">if</strong>(value.<em class="mk">isNotBlank</em>()) {<br/>            <strong class="mb io">field </strong>= value<br/>        }<br/>    }</span></pre><p id="c9b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，Java类User的直接等效将如下所示:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="2911" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User {<br/>    <strong class="mb io">var id</strong>: Int<br/>    <strong class="mb io">var name</strong>: String<br/>    <strong class="mb io">var surname</strong>: String<br/>    <strong class="mb io">var age</strong>: Int<br/>    <br/>    <strong class="mb io">constructor</strong>(id: Int, name: String, surname: String, age: Int) {<br/>        <strong class="mb io">this</strong>.<strong class="mb io">id </strong>= id<br/>        <strong class="mb io">this</strong>.<strong class="mb io">name </strong>= name<br/>        <strong class="mb io">this</strong>.<strong class="mb io">surname </strong>= surname<br/>        <strong class="mb io">this</strong>.<strong class="mb io">age </strong>= age<br/>    }<br/>}</span></pre><p id="bbb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为对象有一种主要的构造方式是很常见的，所以Kotlin引入了称为主构造函数的特性。基本上，是在类名之后定义的构造函数指定了在类创建期间可以使用的字段。这是我们在课堂上使用它的方法:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="a732" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User(id: Int, name: String, surname: String, age: Int) {<br/>    <strong class="mb io">var id</strong>: Int = id<br/>    <strong class="mb io">var name</strong>: String = name<br/>    <strong class="mb io">var surname</strong>: String = surname<br/>    <strong class="mb io">var age</strong>: Int = age<br/>}</span></pre><p id="1a4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一个重要的改进是属性值经常通过主构造函数传递。这就是为什么Kotlin提出了更简洁的符号，允许在主构造函数中定义属性。当我们使用它时，我们有我们的最终符号:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="9e9f" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User(<br/>        <strong class="mb io">var id</strong>: Int,<br/>        <strong class="mb io">var name</strong>: String,<br/>        <strong class="mb io">var surname</strong>: String,<br/>        <strong class="mb io">var age</strong>: Int<br/>)</span></pre><p id="8405" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们不需要一步一步的做这个过渡。IDE可以为我们做到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml kp l"/></div></figure><p id="17c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会问“如果我需要定义其他构造函数怎么办？”。例如，假设我们想要一个不传递id的构造函数，但是我们想要它自动生成。我们可以使用普通的构造函数(在Kotlin中称为“secondary”)来实现:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="8cdd" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User(<br/>        <strong class="mb io">var id</strong>: Int, <br/>        <strong class="mb io">var name</strong>: String, <br/>        <strong class="mb io">var surname</strong>: String, <br/>        <strong class="mb io">var age</strong>: Int<br/>) {<br/><br/>    <strong class="mb io">constructor</strong>(name: String, surname: String, age: Int):<br/>            <strong class="mb io">this</strong>(UsersRepo.getNextId(), name, surname, age)<br/>}</span></pre><p id="b077" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以为该属性提供默认值:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="699a" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>User(<br/>        <strong class="mb io">var name</strong>: String,<br/>        <strong class="mb io">var surname</strong>: String,<br/>        <strong class="mb io">var age</strong>: Int,<br/>        <strong class="mb io">var id</strong>: Int = UsersRepo.getNextId()<br/>)</span></pre><p id="7d8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我把它移到最后一个位置，这样用户就可以通过<code class="fe mm mn mo mb b">User("Marcin", "Moskala", 25)</code>创建一个对象。如果没有它，如果我们想省略第一个参数<code class="fe mm mn mo mb b">User(name = "Marcin", surname = "Moskala", age = 25)</code>，我们将不得不使用命名参数语法。</p><p id="749b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这一点，你可以注意到我们不需要使用<code class="fe mm mn mo mb b">new</code>关键字来使用构造函数。也代表了科特林的简洁，想想也有道理。构造函数就像一个创建对象的函数，在Kotlin中它被当作一个函数。如果引用构造函数，其实就是实现函数接口。这意味着它确实是一个函数。这就是我们如何使用构造函数引用将字符串列表映射到对象列表:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="2810" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">class </strong>Person(<strong class="mb io">val name</strong>: String)<br/><strong class="mb io">val </strong>names = <em class="mk">listOf</em>(<strong class="mb io">"Tony"</strong>, <strong class="mb io">"Bruce"</strong>)<br/><strong class="mb io">val </strong>persons = names.<em class="mk">map</em>(::Person) // Person(<strong class="mb io">"Tony"</strong>), Person(<strong class="mb io">"Bruce"</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi mp"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h1 id="e3ac" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数据修改器</h1><p id="1bb7" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这并不是Kotlin高度提高简洁性的特性的终结。在像Java这样的面向对象语言中，我们经常需要定义表示一些数据的对象。以上类，<code class="fe mm mn mo mb b">User</code>就是一个完美的例子。当我们有一些用户时，我们希望对他们进行一些操作，比如在集合中保存他们，比较他们或者显示他们的数据以便调试。这就是为什么定义一组函数是一种非常常见的模式，它允许:</p><ul class=""><li id="1864" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated"><code class="fe mm mn mo mb b">toString</code> —用于显示对象或在调试期间以更清晰的方式表示对象。</li><li id="b49a" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><code class="fe mm mn mo mb b">equals</code> —用于检查两个对象中的数据是否相同，也需要将一个对象保留在<code class="fe mm mn mo mb b">Set</code>上或者调用<code class="fe mm mn mo mb b">distinct</code>方法。</li><li id="20ad" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><code class="fe mm mn mo mb b">hashCode</code> —需要将对象保存在不同种类的集合中，如<code class="fe mm mn mo mb b">HashMap</code>或<code class="fe mm mn mo mb b">HashSet</code>。</li></ul><p id="3672" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些函数经常被添加到类中，因此IDEA IntelliJ对它们有特殊的支持:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml kp l"/></div></figure><p id="aed7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">科特林让它变得更加简单。你所需要做的就是在一个类前添加数据修饰符:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="9017" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">data class </strong>User(<br/>        <strong class="mb io">var name</strong>: String,<br/>        <strong class="mb io">var surname</strong>: String,<br/>        <strong class="mb io">var age</strong>: Int,<br/>        <strong class="mb io">var id</strong>: Int = UsersRepo.getNextId()<br/>)</span></pre><p id="9470" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了它，您可以使用上面列出的方法:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="32bf" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">data class </strong>User(<strong class="mb io">var name</strong>: String?, <strong class="mb io">var surname</strong>: String?, <strong class="mb io">var age</strong>: Int)</span><span id="1991" class="mf ky in mb b gy ne mh l mi mj"><strong class="mb io">val </strong>user = User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 24)<br/><em class="mk">println</em>(user) <em class="mk">// Prints: User("Marcin", "Moskala", 24)<br/>println</em>(user.toString()) <em class="mk">// Prints: User("Marcin", "Moskala", 24)</em></span><span id="016c" class="mf ky in mb b gy ne mh l mi mj"><em class="mk">println</em>(user.equals(User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 24))) <em class="mk">// Prints: True<br/>println</em>(user.equals(User(<strong class="mb io">"Maciej"</strong>, <strong class="mb io">"Moskala"</strong>, 26))) <em class="mk">// Prints: False</em></span><span id="5b14" class="mf ky in mb b gy ne mh l mi mj"><em class="mk">println</em>(user.hashCode()) <em class="mk">// Prints: 184607782<br/>println</em>(user.hashCode()) <em class="mk">// Prints: 184607782</em></span></pre><p id="eb31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo mb b">data</code>修改器还创建了两个更重要的特性。首先，它允许对象解构:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="397b" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">val </strong>user = User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 24)<br/><strong class="mb io">val </strong>(name, surname, age) = user<br/><em class="mk">print</em>(<strong class="mb io">"$</strong>name <strong class="mb io">$</strong>surname<strong class="mb io"> of age $</strong>age<strong class="mb io">"</strong>) <em class="mk">// Marcin Moskala of age 24</em></span></pre><p id="30d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，数据类可以像元组一样使用，我们并不真正需要原生元组支持。<code class="fe mm mn mo mb b">data</code>修改器给出的另一个方法是<code class="fe mm mn mo mb b">copy</code>。它创建具体值已更改的新实例:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="b151" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">val </strong>user = User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 25)<br/><strong class="mb io">val </strong>user2 = user.copy(name = <strong class="mb io">"Maciej"</strong>, age =  27)<br/>user.<strong class="mb io">age </strong>= 26</span><span id="632f" class="mf ky in mb b gy ne mh l mi mj"><em class="mk">print</em>(user) <em class="mk">// User(name=Marcin, surname=Moskala, age=26)<br/>print</em>(user2) <em class="mk">// User(name=Maciej, surname=Moskala, age=27)</em></span></pre><p id="3c1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个特性非常重要，因为有了它，我们可以很容易地使对象成为不可变的，并且我们可以很容易地用改变的属性制作副本。当我们用函数式风格编程时，这是非常有用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://blog.kotlin-academy.com/write-for-kotlin-academy-abebd70937ce"><div class="gh gi mp"><img src="../Images/87c508a2627eaa3d0e472518952dc75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoIe6R-7DJyXGh8tYeqjA.jpeg"/></div></a></figure><h1 id="32e3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">经营者</h1><p id="b117" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">另一个提高简洁性和可读性的特性是<a class="ae ki" href="https://kotlinlang.org/docs/reference/operator-overloading.html" rel="noopener ugc nofollow" target="_blank">操作符重载</a>。基本上我们更喜欢用<code class="fe mm mn mo mb b">==</code>而不是<code class="fe mm mn mo mb b">equals</code>的方法。它可读性更强，也更简洁。加法和更多其他运算符也是如此。这就是为什么Kotlin制定了一个约定，即具有具体名称的函数可以像操作符一样使用。例如，我们可以使用<code class="fe mm mn mo mb b">==</code>而不是<code class="fe mm mn mo mb b">equals</code>来比较数据类对象:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="7659" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">val </strong>user = User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 25)</span><span id="7277" class="mf ky in mb b gy ne mh l mi mj"><em class="mk">println</em>(user == User(<strong class="mb io">"Marcin"</strong>, <strong class="mb io">"Moskala"</strong>, 24)) <em class="mk">// Prints: True<br/>println</em>(user == User(<strong class="mb io">"Maciej"</strong>, <strong class="mb io">"Moskala"</strong>, 26)) <em class="mk">// Prints: False</em></span></pre><p id="0ad1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举个更大的例子，假设我们需要一个表示复数的类。这就是我们如何用一些基本运算符来定义它:</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="8814" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">data class </strong>Complex(<strong class="mb io">val real</strong>: Double, <strong class="mb io">val img</strong>: Double) {<br/><br/>    <strong class="mb io">operator fun </strong>plus(i: Double) <br/>        = Complex(<strong class="mb io">real </strong>+ i, <strong class="mb io">img</strong>)<br/><br/>    <strong class="mb io">operator fun </strong>plus(c: Complex) <br/>        = Complex(<strong class="mb io">real </strong>+ c.<strong class="mb io">real</strong>, <strong class="mb io">img </strong>+ c.<strong class="mb io">img</strong>)<br/><br/>    <strong class="mb io">operator fun </strong>times(i: Double) <br/>        = Complex(<strong class="mb io">real </strong>* i, <strong class="mb io">img </strong>* i)<br/><br/>    <strong class="mb io">operator fun </strong>times(c: Complex) <br/>        = Complex(<strong class="mb io">real </strong>* c.<strong class="mb io">real </strong>- <strong class="mb io">img </strong>* c.<strong class="mb io">img</strong>, <strong class="mb io">real </strong>* c.<strong class="mb io">img </strong>+ <strong class="mb io">img </strong>* c.<strong class="mb io">real</strong>)<br/>}</span><span id="7501" class="mf ky in mb b gy ne mh l mi mj">// Usage<strong class="mb io"><br/>val </strong>c1 = Complex(1.0, 2.0)<br/><strong class="mb io">val </strong>c2 = Complex(2.0, 3.0)<br/><em class="mk">println</em>(c1 + 1.0) <em class="mk">// Prints: Complex(real=2.0, img=2.0)<br/>println</em>(c1 + c2) <em class="mk">// Prints: Complex(real=3.0, img=5.0)<br/>println</em>(c1 * 2.0) <em class="mk">// Prints: Complex(real=2.0, img=4.0)<br/>println</em>(c1 * c2) <em class="mk">// Prints: Complex(real=-4.0, img=7.0)</em></span></pre><p id="a1f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种符号简单、简洁，可读性很强。就像整个科特林一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6c4b257603bed9784ec1a6c399eb5cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/0*ux-hgSyo6BHM5ljV."/></div></figure></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="90b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要Kotlin工作室吗？请访问我们的网站，看看我们能为您做些什么。</p><p id="6199" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ki" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ki" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="a227" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Twitter上引用我，用<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mp"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><p id="5ebf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kq"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>