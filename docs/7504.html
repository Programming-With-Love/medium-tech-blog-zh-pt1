<html>
<head>
<title>Multi-Branch CodePipeline Strategy with Event-Driven Architecture and AWS CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有事件驱动架构和AWS CDK的多分支代码管道策略</h1>
<blockquote>原文：<a href="https://medium.com/version-1/multi-branch-codepipeline-strategy-with-event-driven-architecture-and-aws-cdk-fbe0095f0730?source=collection_archive---------0-----------------------#2021-11-10">https://medium.com/version-1/multi-branch-codepipeline-strategy-with-event-driven-architecture-and-aws-cdk-fbe0095f0730?source=collection_archive---------0-----------------------#2021-11-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ddfd1ae05a923514e69bc3361b29b070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tJ321gowxyNLT47d"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="37fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在AWS的<a class="ae it" href="https://aws.amazon.com/blogs/devops/multi-branch-codepipeline-strategy-with-event-driven-architecture/" rel="noopener ugc nofollow" target="_blank">具有事件驱动架构的多分支代码管道策略</a>博客中，CloudWatch事件用于触发Lambda函数，该函数从预定义的Cloudformation模板提供管道。这允许使用GitFlow分支策略，开发人员可以在存储库上创建特性分支，它们各自的管道将被自动创建。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es js"><img src="../Images/cd2f151e8d98a98cd1c1f1d06ab43b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*EeE82OlGLNAeOizXkqatLQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">AWS’s multi-branch CodePipeline strategy with event-driven architecture</figcaption></figure><p id="48b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于这种方法的更多讨论和示例，请参见企业快速入门的无服务器CICD<a class="ae it" href="https://aws.amazon.com/quickstart/architecture/serverless-cicd-for-enterprise/" rel="noopener ugc nofollow" target="_blank">此处</a>。然而，这篇博客描述了这种方法的演变。它着眼于用Typescript和AWS CDK实现该策略，并用Codebuild和AWS CDK命令替换Lambda和Cloudformation阶段。</p><blockquote class="jx jy jz"><p id="6aed" class="iu iv ka iw b ix iy iz ja jb jc jd je kb jg jh ji kc jk jl jm kd jo jp jq jr ha bi translated">相关阅读:<a class="ae it" href="https://www.version1.com/it-service/digital-services/modernise-with-aws/" rel="noopener ugc nofollow" target="_blank">为什么您必须更新您现有的应用程序以实现更大的创新和灵活性</a></p></blockquote><h1 id="6a73" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第一步。创建存储库和新的分支规则</h1><p id="3da1" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">首先，创建一个Codecommit存储库，并为新分支添加一个规则。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="4958" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第二步。创建CDK代码构建项目</h1><p id="9d1e" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">接下来，为附加到上面存储库的规则创建一个目标Codebuild项目。引用的环境变量($REPO，$BRANCH)都是由Cloudwatch规则有效负载提供的，稍后将对其进行设置。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="39fe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，Buildspec还包含对git-credential-helper的引用，它为Codebuild提供了一种在构建时克隆我们的存储库的方法。</p><p id="31a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了完成这个代码构建步骤，Codebuild角色需要几个额外的策略语句。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a56b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我们添加策略声明，以便从新的存储库中提取代码，并且我们还允许Codebuild角色承担CDK部署和发布角色。这些角色是在CDK引导流程中创建的。</p><h1 id="a130" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第三步。将代码构建目标添加到规则中</h1><p id="2c85" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">随着存储库、分支规则和目标Codebuild项目的创建，我们现在可以将它们连接在一起。我们通过将Codebuild项目作为目标添加到规则中来实现这一点。</p><p id="fdb1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的关键要点是，如何通过使用Cloudwatch事件数据作为目标CDK Codebuild项目的有效载荷，使规则变得动态。在<code class="du lj lk ll lm b">environmentVariablesOverride</code>中指定的变量可由Codebuild项目访问，这些变量用于在<code class="du lj lk ll lm b">cdk deploy</code>命令之前克隆和检出相关的存储库和分支。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="091d" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第四步。部署</h1><p id="f9d6" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">使用<code class="du lj lk ll lm b">cdk deploy</code>将项目部署到您的AWS帐户中。部署完成后，将您的CDK <strong class="iw hi">管道</strong>项目推进到新的存储库中。在存储库中创建一个分支，并检查所有的连接是否正确:</p><ul class=""><li id="b77f" class="ln lo hh iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">新的分支将导致触发Cloudwatch规则/事件。</li><li id="00c5" class="ln lo hh iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">在CodeBuild中，您应该看到动态管道项目开始，检查环境变量以确保正确的repo和分支在那里。</li><li id="1021" class="ln lo hh iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">CodeBuild项目将克隆您的存储库，并检查您刚刚创建的分支。然后，它将尝试使用<code class="du lj lk ll lm b">cdk deploy</code>部署项目。</li><li id="f31f" class="ln lo hh iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">CodeBuild项目完成后，检查CodePipeline以确保您的管道在那里并且正在运行。它的来源应该是您创建的新分支。</li></ul><h1 id="5131" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">动态管道</h1><p id="d8bb" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">这种方法的一个强大特性是为<code class="du lj lk ll lm b">cdk deploy</code>命令使用上下文参数。通过使用<code class="du lj lk ll lm b">-c</code>，例如<code class="du lj lk ll lm b">-c branch=$BRANCH</code>，可以向您的CDK应用程序提供上下文参数。这为部署您的CDK管道项目提供了很大的灵活性。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="af53" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">管道源代码可以读取上下文变量，并根据其值生成不同的模板。例如:</p><ul class=""><li id="6dec" class="ln lo hh iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">如果branch的上下文参数以“release”开始，synth一个发布管道类，它通过手动批准步骤将角色分配给多个帐户。</li><li id="9cb8" class="ln lo hh iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">在所有其他情况下，假设分支是一个功能，并使用仅部署到开发帐户的功能管道。</li></ul><h1 id="0bed" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">关键指针</h1><p id="bf0d" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">请注意，在上面的动态管道应用程序示例中，我们使用分支名称来设置<strong class="iw hi"> stackName </strong>属性。如果您希望在一个帐户中拥有<strong class="iw hi">多个管道实例，这是非常必要的。此属性覆盖默认堆栈名称，如果没有此属性，您的Codebuild cdk部署步骤将在每次运行时更新相同的堆栈，而不管哪个分支触发了它。</strong></p><p id="214d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另外，请注意，如果您正在命名您的资源，并且在同一个帐户中创建了多个堆栈，您可能会遇到冲突。我删除了对我的资源的可选命名属性的所有引用，并让CDK框架为它们分配惟一的标识符。在必须提供名称的情况下(例如警报)，一个选项是重用上下文分支变量作为前缀。</p><h1 id="5d34" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">包裹</h1><p id="2b9b" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">在这篇博客中，我们研究了CDK管道应用程序的自动化部署，避免了对新分支的手动<code class="du lj lk ll lm b">cdk deploy</code>命令的需求。我们还研究了如何使用事件环境变量来提供动态代码构建和管道应用程序。</p></div></div>    
</body>
</html>