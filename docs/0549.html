<html>
<head>
<title>Under the hood of Jetpack Compose — part 2 of 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose的引擎盖下—第2部分，共2部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd?source=collection_archive---------1-----------------------#2020-08-28">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd?source=collection_archive---------1-----------------------#2020-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d8af56e5a09ed627b162438b7259b488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5janNWE3oy04YK_eoZxAw.png"/></div></div></figure><div class=""/><div class=""><h2 id="2ec1" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">在作曲的引擎盖下</h2></div><p id="55b0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是两篇关于撰写的文章中的第二篇。在第一篇文章中，我解释了Compose的好处，Compose解决的挑战，我们一些设计决策背后的原因，以及这些如何帮助应用程序开发人员。此外，我还讨论了Compose的心理模型，您应该如何考虑您在Compose中编写的代码，以及您应该如何设计您的API。</p><p id="59f3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在我要看看Compose是如何工作的。但是在我开始之前，我想强调理解Compose是如何实现的<em class="kd">并不是使用Compose </em>所必需的。接下来纯粹是为了满足你的求知欲。</p><h1 id="d5ab" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated"><strong class="ak">@ Composable是什么意思？</strong></h1><p id="0fa0" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">如果您看过Compose，您可能会在许多代码示例中看到@Composable注释。需要注意的重要一点是，Compose是<em class="kd">而不是</em>注释处理器。Compose在Kotlin的类型检查和代码生成阶段借助Kotlin编译器插件工作:使用compose不需要注释处理器。</p><p id="b525" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个注释更像是一个语言关键字。一个很好的类比是Kotlin的suspend关键字。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1280" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Kotlin的suspend关键字作用于函数类型:你可以有一个suspend、lambda或type的函数声明。Compose以同样的方式工作:它可以改变函数类型。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5e47" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里重要的一点是，当您用@Composable注释一个函数类型时，您正在改变它的类型:没有注释的同一个函数类型与被注释的类型不兼容。此外，挂起函数需要调用上下文，这意味着您只能在另一个挂起函数内部调用挂起函数。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d2ad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Composable的工作方式也是一样的。这是因为有一个调用上下文对象，我们需要通过所有的调用线程。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="9c3e" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">执行模型</h1><p id="501a" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">那么，我们正在传递的调用上下文是什么，为什么我们需要这么做？</p><p id="527a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们称这个物体为“作曲家”。Composer的实现包含一个与<a class="ae lh" href="https://en.wikipedia.org/wiki/Gap_buffer" rel="noopener ugc nofollow" target="_blank">间隙缓冲区</a>密切相关的数据结构。这种数据结构通常在文本编辑器中使用。</p><p id="c1e7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">间隔缓冲区表示具有当前索引或光标的集合。它是在内存中用平面数组实现的。该平面数组大于它所代表的数据集合，未使用的空间称为间隙。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es li"><img src="../Images/bd63eb4012ae0ff1e81376c4e7a600cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0GgJdY76c_Kz0hs-"/></div></div></figure><p id="0454" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，一个正在执行的可组合层次结构可以调用这个数据结构并向其中插入内容。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/47dc2690a607ec8fba555a2660dff25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4JJ1bDFfJYtpL96B"/></div></div></figure><p id="d226" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们想象一下，我们已经完成了层次结构的执行。在某些时候，我们会重新创作一些东西。因此，我们将光标重置到数组的顶部，然后再次执行。当我们执行时，我们可以查看数据，什么也不做或更新值。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/b8cefebd76c6d5c1abc78a37e571e565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*teYGDHH5HGvaFQQa"/></div></div></figure><p id="f208" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们可能认为UI的结构已经发生了变化，想要进行插入。此时，我们将间隙移动到当前位置。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/740640c2529826a9f9840e1c6dd4510e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cSQX5tAFDpSScpkA"/></div></div></figure><p id="0b5c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，我们可以做插页了。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/d82e2d35c02a27f65ffe41ae6eb603e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ur0n0gAvzrkKvwwz"/></div></div></figure><p id="a733" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关于这个数据结构，需要理解的重要一点是，除了移动间隙之外，所有的操作——获取、移动、插入和删除——都是常数时间操作。移动间隙是O(n)。我们选择这种数据结构的原因是因为我们打赌，一般来说，ui不会很大地改变结构。当我们有动态用户界面时，它们在<em class="kd">值</em>方面会发生变化，但在结构上不会经常变化。当它们确实改变它们的结构时，它们通常会大块地改变，所以进行这种O(n) gap移动是一种合理的权衡。</p><p id="5b0a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们看一个计数器的例子。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1400" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是我们要写的代码，但是让我们看看编译器是做什么的。</p><p id="a0b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当编译器看到可组合注释时，它会插入额外的参数并调用函数体。</p><p id="6078" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，编译器向composer.start方法添加一个调用，并向其传递一个编译时生成的密钥整数。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c985" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">编译器还将composer对象传递给函数体中的所有可组合调用。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f5a4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当该编写器执行时，它执行以下操作:</p><ul class=""><li id="0d89" class="lm ln hs jj b jk jl jn jo jq lo ju lp jy lq kc lr ls lt lu bi translated">Composer.start被调用并存储一个组对象</li><li id="66c7" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc lr ls lt lu bi translated">记住插入一个组对象</li><li id="8cfc" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc lr ls lt lu bi translated">存储mutableStateOf返回的值，即状态实例。</li><li id="03d2" class="lm ln hs jj b jk lv jn lw jq lx ju ly jy lz kc lr ls lt lu bi translated">按钮存储一个组，后跟它的每个参数。</li></ul><p id="bc99" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后我们到达composer.end</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/6947bf9fb9dadae31cb42fd671d15be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YLC9MOQOjxLXLicw"/></div></div></figure><p id="7331" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该数据结构现在保存了合成中的所有对象，即按执行顺序排列的整个树，有效地实现了树的深度优先遍历。</p><p id="009c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，所有这些组对象都占据了很大的空间，那么它们有什么用呢？这些组对象用于管理动态UI中可能发生的移动和插入。编译器知道改变UI结构的代码是什么样子，所以它可以有条件地插入那些组。大多数时候，编译器不需要它们，所以它不会在槽表中插入那么多组。为了说明这一点，请看下面的条件逻辑。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="232e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个composable中，getData函数返回一些结果，并在一种情况下呈现可组合的加载，在另一种情况下呈现头和主体。编译器为if语句的每个分支插入单独的键。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1c61" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设这段代码第一次执行时，结果为空。这将在间隙数组中插入一个组，加载屏幕运行。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/934a8daec656b6cbf2d0f28836eaa182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CnP4GnP1Pdp20fXY"/></div></div></figure><p id="87e8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">函数第二次运行时，让我们假设result不再为null，这样if语句的第二个分支就会执行。这就是有趣的地方。</p><p id="a2ad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对composer.start的调用有一个键为456的组。编译器看到123的槽表中的组不匹配，所以现在它知道UI在结构上发生了变化。</p><p id="a859" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，编译器将该间隙移动到当前光标位置，并在原来的UI上扩展该间隙，有效地消除了它。</p><p id="b816" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此时，代码正常执行，新的UI——标题和主体——被插入。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/e3c59f4f858ad95dbd39b227165f4234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MRV0u6EkCAqgM4xp"/></div></div></figure><p id="01e6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这种情况下，if语句的开销是槽表中的一个槽条目。通过插入这个组，我们在UI中有了任意的控制流，使编译器能够管理它，并在执行UI时调用这个类似缓存的数据结构。</p><p id="0ab0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个概念就是我们所说的位置记忆化，这是一个从零开始构建的概念。</p><h1 id="8b90" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated"><strong class="ak">位置记忆</strong></h1><p id="8054" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">通常，我们有全局记忆，这意味着编译器根据函数的输入缓存函数的结果。为了说明位置记忆的一个例子，以这个执行计算的可组合函数为例。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1889" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该函数接受一个字符串项列表和一个查询，然后对该列表执行过滤计算。我们可以将这种计算包装在对memory的调用中:memory是知道如何调用槽表的东西。remember查看项目并将列表和查询存储在slot表中。然后运行过滤器计算，并在传回结果之前记住存储结果。</p><p id="3178" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该函数第二次执行时，remember会查看传入的新值，并将它们与旧值进行比较。如果两者都没有改变，则跳过过滤操作，返回先前的结果。这就是位置记忆。</p><p id="5339" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有趣的是，这个操作非常便宜:编译器只需存储一次以前的调用。这种计算可以发生在你的整个UI中，因为你是按位置存储的，所以它只存储那个位置的数据。</p><p id="63b8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是记忆函数的特征，它可以接受任意数量的输入，然后是一个计算函数。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f9f8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是这里有一个有趣的退化情况，当输入为零时。我们能做的事情之一就是故意误用这个API。我们可以记忆一个故意不纯的计算，比如Math.random。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="827a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你在全球记忆化的情况下这样做，那就没有意义了。但是，随着位置记忆化，它最终呈现出一种新的语义。每次我们在可组合的层次结构中使用App时，都会返回一个新的Math.random值。然而，每次composable重新组合，它将是相同的<em class="kd">math . random返回值。这产生了持续，而持续产生了<em class="kd">状态</em>。</em></p><h1 id="41f5" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated"><strong class="ak">存储参数</strong></h1><p id="7a7f" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">为了说明如何存储可组合函数的参数，让我们以一个Google Composable为例，它接受一个数字，调用一个可组合地址，并呈现一个地址。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="458a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Compose将可组合函数的参数存储在插槽表中。如果是这种情况，看看上面的例子，我们会看到一些冗余:在地址调用中添加的“Mountain View”和“CA”会再次存储在底层的文本调用中，因此这些字符串会被存储两次..</p><p id="b74a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们可以通过在编译器级别向可组合函数添加静态参数来消除这种冗余。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="eebb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这种情况下，静态参数是一个位字段，指示运行时是否知道参数没有改变。如果已知一个参数不会改变，那么就没有必要存储它。因此，在这个Google示例中，编译器传递了一个位字段，表示没有任何参数会改变。</p><p id="8046" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，在Address中，编译器可以做同样的事情，并将其传递到文本中。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="01fd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种按位逻辑很难读懂，也很混乱，但是我们不需要理解这一点:编译器擅长这个，人类不擅长。</p><p id="6c1f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在谷歌的例子中，我们看到有冗余信息，但这里也有常数。事实证明，我们也不需要存储它们。因此，整个层次结构由number参数决定，这是编译器需要存储的唯一的<em class="kd">值。</em></p><p id="59b2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正因为如此，我们可以更进一步，生成理解这个数字是唯一要改变的东西的代码。这段代码可以这样工作，如果一个数字没有改变，函数的主体将被完全跳过，我们可以指示编写器将它的当前索引移动到函数执行时的位置。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="e38b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">作曲者知道将执行快进多远，以便在需要的地方继续执行。</p><h1 id="4821" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated"><strong class="ak">重组</strong></h1><p id="fc68" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">为了解释重组是如何工作的，让我们回到反例。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6a94" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">编译器为此计数器创建的生成代码有composer.start和compose.end。每当计数器执行时，运行时都知道当它调用count.value时，它正在读取appmodel实例的属性。在运行时，无论何时调用compose.end，我们都可以选择返回值。</p><figure class="lb lc ld le fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b58d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，我们可以用lambda对该值调用updateScope方法，告诉运行时如果需要，如何重新启动这个可组合组件。这相当于LiveData以其他方式接收的lambda。问号在这里的原因——它可以为空的原因——是因为，如果我们在计数器执行期间不读取任何模型对象，就没有理由教运行时如何更新它，因为我们知道它永远不会更新。</p><h1 id="0c7b" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated"><strong class="ak">关闭思路</strong></h1><p id="866e" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">重要的是要记住，这些细节中的大部分只是实现细节。可组合函数具有与标准Kotlin函数不同的行为和功能，有时理解它们是如何实现的会很有帮助，但是虽然行为和功能不会改变，但实现可能会改变。</p><p id="7dfd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">同样，compose编译器能够生成在某些情况下更有效的代码。随着时间的推移，我们希望这些优化得到改善。</p></div></div>    
</body>
</html>