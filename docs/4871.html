<html>
<head>
<title>Advent of Kotlin, week 2: Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的出现，第2周:依赖注入</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/advent-of-kotlin-week-2-dependency-injection-351f615da2e1?source=collection_archive---------3-----------------------#2018-12-02">https://blog.kotlin-academy.com/advent-of-kotlin-week-2-dependency-injection-351f615da2e1?source=collection_archive---------3-----------------------#2018-12-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fbc1092c7f6a72a7545d108e4fbcdae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zdIF0gLzTNnV4WVUKOpbw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Created by Macrovector — Freepik.com</figcaption></figure><p id="cfdd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是科特林挑战来临的第二周。上周我们收到了许多申请，我们可以继续了解更多令人惊奇的事情。这个挑战的所有具体规则你都可以在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/the-advent-of-kotlin-2018-week-1-229e442a143">上一篇文章</a>中找到。</p><p id="f472" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Kotlin，这种相对年轻的语言，已经拥有了种类繁多的依赖注入库(举几个例子:<a class="ae kx" href="https://github.com/InsertKoinIO/koin" rel="noopener ugc nofollow" target="_blank"> Koin </a>、<a class="ae kx" href="https://github.com/Kodein-Framework/Kodein-DI/" rel="noopener ugc nofollow" target="_blank"> KodeinDI </a>、<a class="ae kx" href="https://github.com/kohesive/injekt" rel="noopener ugc nofollow" target="_blank"> Injekt </a>、<a class="ae kx" href="https://github.com/traversals/kapsule" rel="noopener ugc nofollow" target="_blank"> Kapsule </a>)。我完全理解。在Java或JS中实现这种模式是非常具有挑战性的，而在Kotlin中这是一个美好而愉快的挑战。这就是为什么本周我们都要实现一个简单的DI库。这个任务将帮助我们了解一些不太为人所知的Kotlin特性，练习DSL创建，并让我们了解这些库是如何工作的。</p><p id="9c10" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意:我们不会使用注释处理，严格来说，我们将实现资源加载器，而不是依赖注入，与所有注意到的库一样。</p><p id="0f48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你对DI概念不熟悉，<a class="ae kx" href="https://www.youtube.com/watch?v=IKD2-MAkXyQ" rel="noopener ugc nofollow" target="_blank">这里有一个简短的介绍</a>，<a class="ae kx" href="https://www.youtube.com/watch?v=OvqPGaj3C58" rel="noopener ugc nofollow" target="_blank">这里有一个Salomon Brys的演示</a>，而<a class="ae kx" href="http://square.github.io/dagger/" rel="noopener ugc nofollow" target="_blank">这里有一个匕首般的解释，以为我DI最初几年前</a>。</p><h1 id="1e7c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">类别创建者注册表</h1><p id="80ca" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">关键部分是注射。我们应该允许直接或延迟注入:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8612" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">(这只是一个例子。您可以用不同的方式命名这些函数，并且可以在某个对象上调用它们，而不是将它们定义为顶级函数。)</p><p id="ac5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那些注入函数怎么可能知道属性类型呢？由于类型推断:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="be81" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们额外使这个函数内联，并且它的类型参数具体化时，我们将能够对它进行操作，就像我们有一个真实的类型一样:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9530" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这样，您可以从所有类创建者的注册表中本地化类型。这个注册表看起来会是什么样子？最简单的方法是制作一些映射，将一个类名与创建者方法相关联:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f030" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请记住，属性可以有一个可空类型。那么它应该如何行动呢？自己决定。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mh"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="137d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数字式用户线路</h1><p id="3e57" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">为了使注入成为可能，我们首先需要指定应该如何创建每种类型。这通常是使用一些DSL来完成的。例如，这是来自<a class="ae kx" href="https://github.com/InsertKoinIO/koin" rel="noopener ugc nofollow" target="_blank"> Koin </a>的一个例子:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="df51" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里有一个来自<a class="ae kx" href="https://github.com/InsertKoinIO/koin" rel="noopener ugc nofollow" target="_blank"> Kodein </a>的例子:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fa24" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里有一个来自Injekt的例子:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ebd0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是你的决定，你想如何DSL看起来像和行为。注意还有一个区别，有些库有一个全局寄存器，而有些库允许有许多寄存器，并在其中一个上使用注入。这两种方法都很好，但是最好设置两个默认寄存器，并且有可能指定不同的模块。</p><h1 id="82c8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">工作</h1><p id="491d" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">进行简单的依赖注入，并展示一些使用示例。可以通过<a class="ae kx" href="https://github.com/InsertKoinIO/koin" rel="noopener ugc nofollow" target="_blank"> Koin </a>、<a class="ae kx" href="https://github.com/Kodein-Framework/Kodein-DI/" rel="noopener ugc nofollow" target="_blank"> KodeinDI </a>、<a class="ae kx" href="https://github.com/kohesive/injekt" rel="noopener ugc nofollow" target="_blank"> Injekt </a>、<a class="ae kx" href="https://github.com/traversals/kapsule" rel="noopener ugc nofollow" target="_blank"> Kapsule </a>来启发。做一个你喜欢使用的依赖注入。玩得开心:)</p><p id="26b2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，发布您的实现(例如在Github或Github Gist上)并在Twitter上与标签#AdventOfKotlin18共享，或者发送到contact@kt.academy。通过发送到那里，您允许我们发布此代码和您的全名。我们将在下周日(12月9日)在这里公布最佳解决方案和一些荣誉奖，并附上作者姓名或昵称。</p><h1 id="e855" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">评论结束</h1><p id="7ee8" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">你应该在你的项目中实现你自己的DI吗？答案是:视情况而定，但在大多数情况下并非如此。在你的项目中实现它会给你更多的自由。另一方面，对于新开发人员来说，使用成熟且经过测试的解决方案更安全、更方便。这也是我一般推荐这个选项的原因。在最坏的情况下，所有这些框架都非常相似，当您使用项目范围的replace with Regex时，迁移会很顺利。测试过；)</p><h1 id="4356" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结果</h1><p id="1c3f" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们收到了许多优秀的作品，每一件都代表了它的风格和品味。以下是几个例子:</p><p id="bc35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Balázs Németh提出了一个<a class="ae kx" href="https://bitbucket.org/nbali75/di/src/master/" rel="noopener ugc nofollow" target="_blank">久经考验、干净且非常强大的解决方案</a>。</p><p id="8430" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">克里斯蒂安·福赫斯发了一个<a class="ae kx" href="https://github.com/fuchsch1234/AdventOfKotlin2018/blob/master/src/main/kotlin/adventofkotlin/week2/Injector.kt" rel="noopener ugc nofollow" target="_blank">非常简短简洁的解决方案</a>。</p><p id="127e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Timothy Earley发了一个<a class="ae kx" href="https://gitlab.com/TimothyEarley/advent-of-kotlin-2018/tree/master/week2" rel="noopener ugc nofollow" target="_blank">原创的并且更加面向OOP的</a>解决方案。</p><p id="34dd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">何塞·伊格纳西奥·阿辛·波佐发来了一个简洁、干净、经过测试的解决方案(<a class="ae kx" href="https://stackoverflow.com/users/6783451/jose-ignacio-acin-pozo" rel="noopener ugc nofollow" target="_blank"> SO </a>，<a class="ae kx" href="https://github.com/Ganet" rel="noopener ugc nofollow" target="_blank"> Github </a>)。</p><p id="d641" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我决定选择由<a class="ae kx" href="https://github.com/olivierperez" rel="noopener ugc nofollow" target="_blank"> Olivier Perez </a>提出的解决方案，他不仅做出了令人敬畏的injection和DSL，而且<a class="ae kx" href="https://github.com/olivierperez/AdventOfCode2018/tree/master/src/main/kotlin/fr/o80/week2" rel="noopener ugc nofollow" target="_blank">还在Github </a>上记录了一切。以下是他在推特上的投稿:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mi mg l"/></div></figure><p id="2874" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们非常喜欢的几个附加元素:</p><ul class=""><li id="3720" class="mj mk in kb b kc kd kg kh kk ml ko mm ks mn kw mo mp mq mr bi translated">不同种类的工厂——每次创建一个新实例，每个模块一次或所有模块一次。</li><li id="4993" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">他使用了<code class="fe mx my mz na b">InjectionDsl</code>注释，这是他的<a class="ae kx" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/index.html" rel="noopener ugc nofollow" target="_blank"> DSL标记</a>。它防止在内部lambda表达式中使用InjectModule块中的方法。</li><li id="4a27" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">创建类来表示不同种类的生成器(而不是收集不同种类的lambda表达式)。</li><li id="27e7" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">DSL中未声明类型时的特殊错误消息。</li></ul><p id="71a1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们来分析一下。进样位于模块中。以下是惰性注射和正常注射的例子:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="68bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">他实施了不同种类的注射:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="80aa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单实用的用法，但是代码呢？这是一样清楚！下面是DSL的定义:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c633" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于那些不熟悉DSL的人来说，模块块是一个带有接收者的lambda表达式。这意味着<code class="fe mx my mz na b">module</code>后面的括号是一个lambda表达式，但是就像在扩展函数中，扩展对象是接收者，所以我们可以使用<code class="fe mx my mz na b">this</code>来访问它。在这个解决方案中，lambda expression也有一个不同的接收器。在这种情况下，接收器类型为<code class="fe mx my mz na b">InjectModule</code>。得益于此，我们可以直接使用来自<code class="fe mx my mz na b">InjectModule</code>的所有方法，如<code class="fe mx my mz na b">factory</code>、<code class="fe mx my mz na b">scope</code>或<code class="fe mx my mz na b">singleton</code>。这些方法在<code class="fe mx my mz na b">InjectModule</code>的实例上被调用，它们修改它的内部状态——在本例中是通过添加新的方法来创建一个对象。然后我们需要得到一个对象。我们使用以下方法:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="10cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个很好的解决方案，我推荐给任何想了解DSL工作原理的人。这不是一个简单的挑战，每个解决它的人都是赢家。恭喜你！</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h2 id="d6c8" class="ni kz in bd la nj nk dn le nl nm dp li kk nn no lm ko np nq lq ks nr ns lu nt bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="5260" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">你需要Kotlin工作室吗？请访问我们的网站,看看我们能为您做些什么。</p><p id="2ae5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">了解卡帕头最新的重大新闻。学院、<a class="ae kx" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>、<a class="ae kx" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mh"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>