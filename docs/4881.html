<html>
<head>
<title>The beauty of Kotlin typing system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林打字系统之美</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/the-beauty-of-kotlin-typing-system-7a2804fe6cf0?source=collection_archive---------1-----------------------#2019-03-04">https://blog.kotlin-academy.com/the-beauty-of-kotlin-typing-system-7a2804fe6cf0?source=collection_archive---------1-----------------------#2019-03-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/4b4de18deae6e1b4da6195d25ad7db6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eXBePb2oLVPxHyocCNmlw.jpeg"/></div></div></figure><div class=""/><p id="b879" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Kotlin打字系统的设计令人惊叹。它为我们提供了非常舒适的可空性支持、类型推断、通用保护等等。例如:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="83ea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将揭示许多科特林魔术。我总是喜欢在我的研讨会上谈论它，因为我看到了它是如何被设计出来的惊人之美，所有这些部分都完美地结合在一起，给我们带来了很好的编程体验。还有一些有用的提示，如何在不同的情况下使用打字系统。享受:)</p><h1 id="566d" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">常规类型层次结构</h1><p id="d73f" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">假设您定义了一个类<code class="fe md me mf mg b">Customer</code>。这个类生成两种类型:可空版本<code class="fe md me mf mg b">Customer?</code>和不可空版本<code class="fe md me mf mg b">Customer</code>。他们之间是什么关系？</p><p id="7bda" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，nullable不能直接使用。需要首先将其解包为不可空。另一方面，non-nullable也可以用作nullable:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="18a3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论如何，不可空可以作为可空使用。这是可能的，因为这两种类型之间存在联系。可空类型是不可空的超类型。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mh"><img src="../Images/8b97f58bf5a693b3249383413b2a6473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJ2T7vqysCQcfmDxAmyWlg.png"/></div></div></figure><p id="328c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin类型层次结构中还有一些更有趣的事实。这是一张图中的整个层次结构:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/97072cf4cb3c37af675180a76923a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcLD-4s5DwBJ4uDQ1RJ8mA.png"/></div></div></figure><p id="57a3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以注意到两个有趣的元素:</p><ul class=""><li id="5435" class="mj mk iy jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">所有类型都有一个超类型</li><li id="41ff" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">所有类型都有一个子类型</li></ul><h1 id="0678" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">所有类型的超类型:<code class="fe md me mf mg b">Any?</code></h1><p id="c57b" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">每个不可空类型都有一个名为<code class="fe md me mf mg b">Any</code>的超类型。分别地，它唯一的超类型是<code class="fe md me mf mg b">Any?</code>，它是包括nullable在内的所有类型的超类型。所有类的超类的概念在Java中是已知的，在Java中我们有<code class="fe md me mf mg b">Object</code>。<code class="fe md me mf mg b">Any?</code>同样可以用来表示我们正在接受任何事情:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">println from the stdlib</figcaption></figure><p id="630e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管您可能也注意到了，如果您只想要不可空的类型，您可以使用<code class="fe md me mf mg b">Any</code>。这一事实被广泛用于泛型，表明我们只接受不可空的类型参数<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929">:</a></p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">notNull delegate from the stdlib.</figcaption></figure><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Example from <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/creating-a-random-instance-of-any-class-in-kotlin-b6168655b64a">the previous article</a></figcaption></figure><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://kt.academy/workshop/reactForBeginners"><div class="gh gi nb"><img src="../Images/aa657bf6c44322311e9f15042f9db74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wHK4zA22P8kTISJy6QLIA.png"/></div></a></figure><h1 id="0ca8" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">所有类型的子类型:无</h1><p id="fce2" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在科特林，所有类型都有一个亚型——<code class="fe md me mf mg b">Nothing</code>。它可以被视为任何类型，尽管没有实例是<code class="fe md me mf mg b">Nothing</code>。当我开始讲授它时，它对大多数开发人员来说都是新事物。我们为什么需要这样的东西？</p><p id="8597" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从一个更简单的问题开始:为什么将<code class="fe md me mf mg b">Nothing</code>声明为返回类型有意义？停止阅读一分钟，想一想。</p><p id="f300" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有<code class="fe md me mf mg b">Nothing</code>的实例，所以我们不能返回它。但是我们有没有其他方法来逃避一个函数呢？嗯，有一个。我们可以在不返回任何东西的情况下对函数进行转义。我们可以抛出一个异常。事实证明，<code class="fe md me mf mg b">throw</code>声明的返回类型是<code class="fe md me mf mg b">Nothing</code>。这里我们将<code class="fe md me mf mg b">Nothing</code>声明为返回类型，以抛出异常:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="f808" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意结果，因为<code class="fe md me mf mg b">Nothing</code>是所有类型的子类型。假设你有一个返回<code class="fe md me mf mg b">String</code>或<code class="fe md me mf mg b">Nothing</code>的if条件。推断的类型应该是什么？<code class="fe md me mf mg b">String</code>和<code class="fe md me mf mg b">Nothing</code>最接近的超类型，也就是<code class="fe md me mf mg b">String</code>。这就是为什么这里的<code class="fe md me mf mg b">data</code>推断类型是<code class="fe md me mf mg b">String</code>:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="cd01" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数也可以用在许多其他的上下文中。例如，我们可以在Elvis操作符的右侧使用它:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="eedb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Elvis运算符的约定是，推断的返回类型是左侧的不可空版本，并且是右侧最接近的超类型。左边是<code class="fe md me mf mg b">String?</code>，它的不可空版本是<code class="fe md me mf mg b">String</code>。右边是<code class="fe md me mf mg b">Nothing</code>。<code class="fe md me mf mg b">String</code>和<code class="fe md me mf mg b">Nothing</code>的关闭超类型是<code class="fe md me mf mg b">String</code>，因为<code class="fe md me mf mg b">Nothing</code>是包括<code class="fe md me mf mg b">String</code>在内的所有类型的子类型。</p><p id="e09c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同理，我们可以在右侧抛出一个错误:它声明的返回类型是<code class="fe md me mf mg b">Nothing</code>。</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="50c8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，我们可以在控制结构上使用throw，它可以用作<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0">表达式</a>:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h1 id="d738" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">单位在哪里？</h1><p id="52e7" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我经常被问到此时<code class="fe md me mf mg b">Unit</code>在哪里。从打字系统的角度来看，这没什么特别的。它只是一个<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象声明</a> (singleton)，在类型系统中，像所有其他类型一样，它是<code class="fe md me mf mg b">Any</code>的子类型和<code class="fe md me mf mg b">Nothing</code>的超类型。</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">How Unit is defined</figcaption></figure><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/ae88604ac94978796e7abca89b2d5228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1vv9e3r1RvxovEMkc3UfQ.png"/></div></div></figure><h1 id="8b6c" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">当代码不可达时。</h1><p id="75dc" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">当一个元素将<code class="fe md me mf mg b">Nothing</code>声明为返回类型时，意味着其后的一切都是不可达的。一定是这样，因为没有<code class="fe md me mf mg b">Nothing</code>的实例。这就是为什么当我们使用<code class="fe md me mf mg b">fail</code>或throw时，这些表达式之后的所有内容都是不可及的:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/31d6595547fc71a6a87bfac7ce25d200.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*TLRA3sUNBvQeehQFBoopmA.png"/></div></figure><p id="c0c9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以将所有内容放在左侧，并且不需要使用return语句:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/516ce72093be6e474d930c6555f2fe21.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*K5tOLSbk7ZN1uLZVP760Ag.png"/></div></figure><p id="c461" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个事实经常被返回<code class="fe md me mf mg b">Nothing</code>、<code class="fe md me mf mg b">TODO</code>的最流行的函数使用:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="c1b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我给出要实现的功能时，我经常在<a class="ae kz" href="http://kt.academy/" rel="noopener ugc nofollow" target="_blank">我的工作室</a>的任务中使用它:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="edbb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管throw不是唯一一个没有声明任何东西作为返回类型的构造。你能猜出第二个是什么吗？</p><p id="7a88" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是<code class="fe md me mf mg b">return</code>。Return从一个函数返回，所以在一个<code class="fe md me mf mg b">return</code>之后的一切都是不可到达的。它对函数进行了转义，所以我们可以说在这个函数内部，它不返回任何东西。这与<code class="fe md me mf mg b">throw</code>是一致的，这就是打字系统如何知道<code class="fe md me mf mg b">return</code>之后的一切都是不可到达的。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6d8aef3bbedd3b9e880147730018b554.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*c9s_cBtqcixesI2D3hQdzQ.png"/></div></figure><p id="468b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于同样的原因，我们可以在各种控制结构中使用<code class="fe md me mf mg b">return</code>:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0552" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，这最终解释了为什么我们可以在Elvis操作符的右侧使用<code class="fe md me mf mg b">return</code>:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi nb"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="18ed" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">null的类型</h1><p id="a218" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">假设你声明了一个变量或者一个列表，你把它的值设置为<code class="fe md me mf mg b">null</code>，但是你忘了声明一个类型。因此，您会看到以下错误:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/197139b78e5026b90f813c0b3426c8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyFeHx62JOfjZbiEaUIG0A.png"/></div></div></figure><p id="5008" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">能解释一下吗？花点时间想一想。</p><p id="a970" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种错误的原因是，当我们不声明变量或属性类型时，将从右侧获取类型。这里就是这么回事，类型竟然是<code class="fe md me mf mg b">Nothing?</code>。所以你可以看到<code class="fe md me mf mg b">null</code>的类型是<code class="fe md me mf mg b">Nothing?</code>。这是为什么呢？</p><p id="4f5a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从注意到<code class="fe md me mf mg b">null</code>是<code class="fe md me mf mg b">Nothing?</code>唯一可能的实例开始。没有类型为<code class="fe md me mf mg b">Nothing</code>的对象，任何类型的可空版本都可以是<code class="fe md me mf mg b">null</code>。因此当我们看到<code class="fe md me mf mg b">Nothing?</code>时，我们可以确定只有<code class="fe md me mf mg b">null</code>会在那里。当我们希望属性delegate只在顶层使用时，就会用到这个事实，这里的<code class="fe md me mf mg b">thisRef</code>是<code class="fe md me mf mg b">null</code>:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="6b93" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一件要注意的事情是，它给了我们完美的类型推断。再看一下键入层次结构:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/97072cf4cb3c37af675180a76923a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcLD-4s5DwBJ4uDQ1RJ8mA.png"/></div></div></figure><p id="0971" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在想想<code class="fe md me mf mg b">a</code>和<code class="fe md me mf mg b">b</code>的推断类型是什么:</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="9a90" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe md me mf mg b">if</code>中，我们从两个分支中搜索最接近的超类型。<code class="fe md me mf mg b">String</code>和<code class="fe md me mf mg b">Nothing?</code>最接近的超类型是<code class="fe md me mf mg b">String?</code>。关于<code class="fe md me mf mg b">when</code>也是如此:<code class="fe md me mf mg b">String</code>、<code class="fe md me mf mg b">String</code>、<code class="fe md me mf mg b">Nothing?</code>最接近的超类型是<code class="fe md me mf mg b">String?</code>。一切都有道理。</p><p id="d44e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于同样的原因，每当我们需要<code class="fe md me mf mg b">String?</code>时，我们可以通过<code class="fe md me mf mg b">String</code>或<code class="fe md me mf mg b">null</code>，也就是<code class="fe md me mf mg b">Nothing?</code>。当你看一看类型层次结构时，这一点就很清楚了。那是<code class="fe md me mf mg b">String?</code>的两个亚型。</p><figure class="kt ku kv kw gt ip"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h1 id="cd05" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="f353" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在这篇文章中，我展示了一些事实:</p><ul class=""><li id="b8da" class="mj mk iy jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">每个类都生成一个可空和不可空的类型</li><li id="f01d" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">可空类型是不可空类型的超类型</li><li id="9301" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">所有类型的超类型是<code class="fe md me mf mg b">Any?</code></li><li id="3412" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">不可空类型的超类型是<code class="fe md me mf mg b">Any</code></li><li id="f1b7" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">所有类型的子类型<code class="fe md me mf mg b">Nothing</code></li><li id="c68e" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">所有可空类型的子类型<code class="fe md me mf mg b">Nothing?</code></li><li id="b04b" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">当函数声明<code class="fe md me mf mg b">Nothing</code>为返回类型时，意味着它将无限抛出一个错误或有趣</li><li id="ad89" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated"><code class="fe md me mf mg b">throw</code>和<code class="fe md me mf mg b">return</code>都声明<code class="fe md me mf mg b">Nothing</code>为返回类型</li><li id="6852" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">当一个表达式将<code class="fe md me mf mg b">Nothing</code>声明为返回类型时，在那之后执行的所有东西都是不可访问的</li><li id="fb30" class="mj mk iy jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated"><code class="fe md me mf mg b">null</code>的类型是<code class="fe md me mf mg b">Nothing?</code>，这给了我们预期的类型推断，并且由于这个原因<code class="fe md me mf mg b">null</code>可以在预期可空类型的任何时候使用。</li></ul><p id="4b39" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要记住的图片是Kotlin类型层次的图解:</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/97072cf4cb3c37af675180a76923a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcLD-4s5DwBJ4uDQ1RJ8mA.png"/></div></div></figure></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h2 id="d15c" class="no lb iy bd lc np nq dn lg nr ns dp lk kg nt nu lo kk nv nw ls ko nx ny lw nz bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="2ae5" class="pw-post-body-paragraph jv jw iy jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kz" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>关注我们medium。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi nb"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>