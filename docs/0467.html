<html>
<head>
<title>Sealed with a class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用类密封</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/sealed-with-a-class-a906f28ab7b5?source=collection_archive---------0-----------------------#2020-03-03">https://medium.com/androiddevelopers/sealed-with-a-class-a906f28ab7b5?source=collection_archive---------0-----------------------#2020-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7dbdff2f6243de6e06b0425e311eb83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QpP21pn8EmDouGf0jAK_Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="1def" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇—密封类</h2></div><p id="de78" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通常我们需要表现有限的可能性；一个web请求要么成功，要么失败，一个<code class="du kd ke kf kg b">User</code>只能是一个专业用户或者一个标准用户。</p><p id="60e1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了对此建模，我们可以使用一个<code class="du kd ke kf kg b">enum</code>，但是这有很多限制。枚举类只允许每个值有一个实例，不能对每个类型编码更多的信息，例如一个<code class="du kd ke kf kg b">Error</code>事例有一个关联的<code class="du kd ke kf kg b">Exception</code>属性。</p><p id="8215" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以使用一个抽象类和一些扩展，但是这失去了枚举带来的有限类型集的优势。<a class="ae kh" href="https://kotlinlang.org/docs/reference/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">密封类</a>提供了两个世界的精华:抽象类的自由表示和枚举类型的受限集合。请继续阅读，了解更多关于密封类的信息，或者，如果您喜欢视频，请点击此处查看:</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="km kn l"/></div></figure><h1 id="8268" class="ko kp hs bd kq kr ks kt ku kv kw kx ky iy kz iz la jb lb jc lc je ld jf le lf bi translated">密封类的基础</h1><p id="6f31" class="pw-post-body-paragraph jh ji hs jj b jk lg it jm jn lh iw jp jq li js jt ju lj jw jx jy lk ka kb kc ha bi translated">像抽象类一样，密封类允许您表示层次结构。子类可以是任何类型的类:一个数据类，一个<a class="ae kh" href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" rel="noopener ugc nofollow" target="_blank">对象</a>，一个常规类，甚至是另一个密封类。与抽象类不同，您必须在同一个文件中或者作为嵌套类来定义这些层次结构。</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="3e49" class="lp kp hs kg b fi lq lr l ls lt">// Result.kt</span><span id="7ef7" class="lp kp hs kg b fi lu lr l ls lt">sealed class Result&lt;out T : Any&gt; {<br/>    data class Success&lt;out T : Any&gt;(val data: T) : Result&lt;T&gt;()<br/>    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()<br/>}</span></pre><p id="a714" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">试图将密封类扩展到定义它的文件之外会产生编译错误:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="bc0e" class="lp kp hs kg b fi lq lr l ls lt"><em class="lv">Cannot access ‘&lt;init&gt;’: it is private in Result</em></span></pre><h1 id="9bbc" class="ko kp hs bd kq kr ks kt ku kv kw kx ky iy kz iz la jb lb jc lc je ld jf le lf bi translated">忘了一根树枝？</h1><p id="062f" class="pw-post-body-paragraph jh ji hs jj b jk lg it jm jn lh iw jp jq li js jt ju lj jw jx jy lk ka kb kc ha bi translated">我们通常希望处理所有可能的类型:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="91f0" class="lp kp hs kg b fi lq lr l ls lt">when(result) {<br/>    is Result.Success -&gt; { }<br/>    is Result.Error -&gt; { }<br/>}</span></pre><p id="10d0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是如果有人加了一种新型的<code class="du kd ke kf kg b">Result</code> : <code class="du kd ke kf kg b">InProgress</code>呢:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="2c8d" class="lp kp hs kg b fi lq lr l ls lt">sealed class Result&lt;out T : Any&gt; {<br/>    data class Success&lt;out T : Any&gt;(val data: T) : Result&lt;T&gt;()<br/>    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()<br/>    <strong class="kg ht">object InProgress : Result&lt;Nothing&gt;()<br/></strong>}</span></pre><p id="30c9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果一个分支没有被覆盖，编译器会给我们一个错误，而不是依靠我们的内存或IDE搜索来确保所有when用法都处理新类。当像if语句一样，只需要我们通过产生一个编译器错误来覆盖所有选项(也就是详尽的)时，它就像一个表达式:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="4b44" class="lp kp hs kg b fi lq lr l ls lt">val action = when(result) {<br/>    is Result.Success -&gt; { }<br/>    is Result.Error -&gt; { }<br/>}</span></pre><p id="9cc8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="lv">当表达式必须详尽时，添加必要的“正在进行中”分支或else分支，而不是</em></p><p id="66fe" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">即使我们使用when作为语句，也要获得这种漂亮的好处，添加这个helper扩展属性:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="2109" class="lp kp hs kg b fi lq lr l ls lt">val &lt;T&gt; T.exhaustive: T<br/>    get() = this</span></pre><p id="b4d6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以现在，通过添加<code class="du kd ke kf kg b">.exhaustive</code>，如果一个分支丢失了，编译器将给出我们之前看到的同样的错误。</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="e3f1" class="lp kp hs kg b fi lq lr l ls lt">when(result){<br/>    is Result.Success -&gt; { }<br/>    is Result.Error -&gt; { }<br/>}.exhaustive</span></pre><h1 id="8a0a" class="ko kp hs bd kq kr ks kt ku kv kw kx ky iy kz iz la jb lb jc lc je ld jf le lf bi translated">IDE自动完成</h1><p id="c93e" class="pw-post-body-paragraph jh ji hs jj b jk lg it jm jn lh iw jp jq li js jt ju lj jw jx jy lk ka kb kc ha bi translated">由于密封类的所有子类型都是已知的，IDE可以为我们填充when语句的所有可能的分支:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es lw"><img src="../Images/1de7a7923d33888e0644d6434c310144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*RXZgvne3pvshhurs"/></div></figure><p id="fb08" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个特性在更复杂的密封类层次结构中大放异彩，因为IDE可以识别所有分支:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="1b11" class="lp kp hs kg b fi lq lr l ls lt">sealed class Result&lt;out T : Any&gt; {<br/>  data class Success&lt;out T : Any&gt;(val data: T) : Result&lt;T&gt;()<br/>  <strong class="kg ht">sealed class Error(val exception: Exception) : Result&lt;Nothing&gt;() {<br/>     class RecoverableError(exception: Exception) : Error(exception)<br/>     class NonRecoverableError(exception: Exception) : <br/>                                               Error(exception)<br/>  }<br/>  </strong>object InProgress : Result&lt;Nothing&gt;()<br/>}</span></pre><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es lx"><img src="../Images/f28930dfe4b669a2ec0747d1bb1220c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*lfsvqtYcp83aszsQ"/></div></figure><p id="8659" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是不能用抽象类实现的功能类型，因为编译器不知道继承层次；因此，IDE无法生成分支。</p><h1 id="4569" class="ko kp hs bd kq kr ks kt ku kv kw kx ky iy kz iz la jb lb jc lc je ld jf le lf bi translated">在后台</h1><p id="33d5" class="pw-post-body-paragraph jh ji hs jj b jk lg it jm jn lh iw jp jq li js jt ju lj jw jx jy lk ka kb kc ha bi translated">那么是什么让密封类有这样的行为呢？让我们看看反编译的Java代码中发生了什么:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="6eb7" class="lp kp hs kg b fi lq lr l ls lt">sealed class Result<br/>data class Success(val data: Any) : Result()<br/>data class Error(val exception: Exception) : Result()</span><span id="abf8" class="lp kp hs kg b fi lu lr l ls lt">@Metadata(<br/>…<br/>d2 = {“Lio/testapp/Result;”, “T”, “”, “()V”, <strong class="kg ht">“Error”, “Success”</strong>, “Lio/testapp/Result$Success;”, “Lio/testapp/Result$Error;” …}<br/>)</span><span id="4f39" class="lp kp hs kg b fi lu lr l ls lt">public abstract class Result {<br/>    private Result() {}<br/>    // $FF: synthetic method<br/>    public Result(DefaultConstructorMarker $constructor_marker) {<br/>        this();<br/>    }<br/>}</span></pre><p id="59b9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">密封类的元数据保存了子类的列表，允许编译器在需要的地方使用这些信息。</p><p id="5fc1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kd ke kf kg b">Result</code>被实现为一个抽象类，有两个构造函数:</p><ul class=""><li id="d5a5" class="ly lz hs jj b jk jl jn jo jq ma ju mb jy mc kc md me mf mg bi translated">私有默认构造函数</li><li id="ac42" class="ly lz hs jj b jk mh jn mi jq mj ju mk jy ml kc md me mf mg bi translated">只能由Kotlin编译器使用的合成构造函数</li></ul><p id="14bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以，这意味着没有其他类可以直接调用构造函数。如果我们查看Success类的反编译代码，我们会看到它调用合成构造函数:</p><pre class="ki kj kk kl fd ll kg lm ln aw lo bi"><span id="1f8d" class="lp kp hs kg b fi lq lr l ls lt">public final class Success extends Result {<br/>    @NotNull<br/>    private final Object data<br/>    <br/>    public Success(@NotNull Object data) {<br/>      <br/>       <strong class="kg ht">super((DefaultConstructorMarker)null);<br/>       </strong>this.data = data;<br/>    }</span></pre></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="51a5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">开始使用密封类来建模受限的类层次结构，允许编译器和IDE帮助您避免类型错误。</p></div></div>    
</body>
</html>