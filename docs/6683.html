<html>
<head>
<title>Prim’s algorithm with Numpy arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Numpy数组实现Prim算法</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/prims-algorithm-with-numpy-arrays-a9ea3d3f112a?source=collection_archive---------2-----------------------#2019-08-27">https://medium.com/quick-code/prims-algorithm-with-numpy-arrays-a9ea3d3f112a?source=collection_archive---------2-----------------------#2019-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="4704" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">普里姆算法</h1><p id="837c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><a class="ae ka" href="https://en.wikipedia.org/wiki/Prim's_algorithm" rel="noopener ugc nofollow" target="_blank">普里姆的算法</a>和克鲁斯卡尔的算法是一种贪婪算法，为一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Weighted_graph" rel="noopener ugc nofollow" target="_blank">加权的</a> <a class="ae ka" href="https://en.wikipedia.org/wiki/Undirected_graph" rel="noopener ugc nofollow" target="_blank">无向图</a>寻找一棵<a class="ae ka" href="https://en.wikipedia.org/wiki/Minimum_spanning_tree" rel="noopener ugc nofollow" target="_blank">最小生成树</a>。</p><p id="b232" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一些教程描述了这个问题和算法。我想引用<a class="ae ka" href="https://coderbyte.com/algorithm/find-minimum-spanning-tree-using-prims-algorithm" rel="noopener ugc nofollow" target="_blank">这个</a>作为比较，因为我使用了那里描述的python实现。</p><p id="1ee1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">Prim算法的伪代码是:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="73fb" class="kp if hh kl b fi kq kr l ks kt">00 Let's represent the vertices of the graph with <strong class="kl hi">V</strong>, the vertices of<br/>   the spanning tree with <strong class="kl hi">X</strong>, and the edges of the tree with <strong class="kl hi">E </strong>and <br/>   the weight of an edge e is <strong class="kl hi">w</strong>(e).<br/>01 Select a random vertex <strong class="kl hi">v</strong>.<br/>02 Initialize the variables as: X:={v}, Y=V-X, E={}<br/>03 <strong class="kl hi">while </strong>X != V <strong class="kl hi">do</strong>:<br/>04     Select e{x,y} edge of the graph where x ∈ X, y ∈ Y<br/>       and w(e) is minimal.<br/>05     X:=X ∪ {y}; E:=E ∪ {(x,y)}; Y:=Y-y<br/>06 Return with the (X,E) tree</span></pre><p id="c04c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">前面提到的实现使用邻接矩阵和lop。python代码见<a class="ae ka" href="https://coderbyte.com/algorithm/find-minimum-spanning-tree-using-prims-algorithm" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="acf5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Numpy实现</h1><p id="6ccb" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个实现使用numpy数组操作。在每次迭代中，它用<code class="du ku kv kw kl b">np.isin()</code>和<code class="du ku kv kw kl b">np.not_equal()</code>搜索边(<strong class="je hi"> e </strong>)之间，并用<code class="du ku kv kw kl b">np.argmin()</code>找到最小权重。</p><figure class="kg kh ki kj fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="71de" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">numpy <code class="du ku kv kw kl b">isin()</code>函数不能处理集合，因此，每次都必须进行转换。但是，由于列表和集合元素移除之间的性能差异，它仍然是首选方法。</p><h1 id="f6c9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">测试图表</h1><p id="577b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了测试实现的性能，我使用了两种类型的图:随机加权树和随机加权完全图。</p><p id="2ce5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">具有<em class="la"> V </em>个顶点的随机加权树具有<em class="la"> V-1条</em>边(并且最终生成树是原始树)。</p><p id="97d0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">具有<em class="la"> V </em>个顶点的完全图在每对节点之间有一条边，因此它有<em class="la"> V(V-1)/2 </em>条边。</p><figure class="kg kh ki kj fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="a0ec" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">小树和完全图(V=10):</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f992" class="kp if hh kl b fi kq kr l ks kt">Tree:<br/>Prim with numpy arrays:                   0.0007793903350830078<br/>Prim with adjacency matrix and for loops: 0.00010991096496582031<br/>Complete graph:<br/>Prim with numpy arrays:                   0.0007245540618896484<br/>Prim with adjacency matrix and for loops: 0.00020265579223632812</span></pre><p id="c6a2" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">中等树和完全图(V=100):</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6139" class="kp if hh kl b fi kq kr l ks kt">Tree:<br/>Prim with numpy arrays:                   0.01504063606262207<br/>Prim with adjacency matrix and for loops: 0.004843235015869141<br/>Complete graph:<br/>Prim with numpy arrays:                   0.05809807777404785<br/>Prim with adjacency matrix and for loops: 0.1437060832977295</span></pre><p id="7fa8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">大树和完整图(V=500):</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="e7ff" class="kp if hh kl b fi kq kr l ks kt">Tree:<br/>Prim with numpy arrays:                   0.08289432525634766<br/>Prim with adjacency matrix and for loops: 0.28101420402526855<br/>Complete graph:<br/>Prim with numpy arrays:                    7.81583309173584<br/>Prim with adjacency matrix and for loops: 13.361848592758179</span></pre><p id="8fe3" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">最后，测试图显示了两种实现的可伸缩性:</p><figure class="kg kh ki kj fd kx er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/3f07ae16f4ef1f08a94a406a533e72f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1IfQUpF9-V07iktyAVBDQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">Timing tests of the two implementation</figcaption></figure></div></div>    
</body>
</html>