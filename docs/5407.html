<html>
<head>
<title>Oracle JET Web Applications — Automating Build, Package and Deploy (to Application Container Cloud) using a Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle JET Web应用程序—使用Docker容器自动构建、打包和部署(到应用程序容器云)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracle-jet-web-applications-automating-build-package-and-deploy-to-application-container-cloud-9293989794ca?source=collection_archive---------0-----------------------#2018-02-26">https://medium.com/oracledevs/oracle-jet-web-applications-automating-build-package-and-deploy-to-application-container-cloud-9293989794ca?source=collection_archive---------0-----------------------#2018-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="39fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文的核心信息是Oracle JET应用程序从源代码提交到Oracle Application Container Cloud上正在运行的应用程序的流程自动化，如下图所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/20dfc62cb8ff9662d716423ada16f673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/0*OJfQ52a5WFabdm7U."/></div></div></figure><p id="4af0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将描述“黑盒”的内部(图中实际上是浅蓝色)，在这里为Oracle JET应用程序进行构建、打包和部署。</p><p id="e5ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">方法概述:响应代码提交，启动Docker容器。该容器包含执行必要操作所需的所有工具，包括实际运行这些操作的脚本。当应用程序被部署后(或者结果包被存储在工件存储库中)，容器可以被停止。这种方法非常干净——在构建过程中创建的中间产品会随着容器一起消失。为下一次迭代启动一个新容器。</p><p id="0c3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:在我的环境中，端到端的构建和部署流程大约需要2到3分钟。对于简单的开发人员往返来说，这显然是可怕的，但是对于共享云环境的这种“正式”发布来说，这实际上是完全可以接受的。这种方法和本文在很大程度上受到Abhishek Gupta(他撰写了许多非常有价值的文章，主要围绕微服务和Oracle PaaS服务，如应用程序容器云)在Medium上发表的文章<a class="ae jo" rel="noopener" href="/oracledevs/quick-start-docker-ized-paas-service-manager-cli-f54eaf4ebcc7">的启发。</a></p><p id="5dc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:本文主要关注JET应用程序到应用程序容器云的最终部署。然而，修改(实际上是简化)构建容器，不将最终的ZIP文件部署到应用程序容器云，而是将文件推送到工件存储库或部署到其他类型的运行时平台，这是非常简单的。获取ZIP文件并使用该文件创建一个新的Docker容器并不难，该容器可以部署在Kubernetes集群或任何Docker运行时(如Oracle Container Cloud)上。</p><p id="38a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码——包括一个示例JET应用程序——在这个GitHub repo中:<a class="ae jo" href="https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequel" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/webshop-portal-through-the-cloud-native-sequel</a>。</p><p id="3591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在本文中描述的步骤是:</p><ul class=""><li id="741d" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">准备将执行构建-打包-部署操作的Docker容器</li><li id="f10a" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">准备Oracle JET应用程序——从本地运行的、仅供开发人员使用的客户端web应用程序转变为具有服务器端平台的独立可运行企业web应用程序(带Express的节点)</li><li id="7827" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">创建构建脚本，该脚本将在容器内运行，并通过可用的工具编排动作，将源一直带到云</li><li id="7741" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">把所有的放在一起</li></ul><h1 id="5ccf" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.准备将执行构建-打包-部署操作的Docker容器</h1><p id="b662" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">第一步是Docker容器的组成。对于这一步，我很好地利用了Abhishek的文章和他在那篇文章中提出的dockerfile。我用构建Oracle JET应用程序所需的工具补充了Abhishek的docker文件。</p><p id="50cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker容器将包含的内容以及将它放在一起的步骤的可视化演示如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/98ae8f45464f7868833f8d08702b621f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yqrt8tCIKvSjSuT7."/></div></div></figure><blockquote class="lh li lj"><p id="aa5d" class="ie if lk ig b ih ii ij ik il im in io ll iq ir is lm iu iv iw ln iy iz ja jb ha bi translated"><em class="hh">注意:通过一个Docker文件完全烘焙Docker容器映像是很有趣的——而且以Docker文件的形式分享创建Docker容器映像的指令当然也很方便。然而，当通过Docker文件实现自动化的步骤很复杂时，有一个简单的替代方法:通过Docker文件构建尽可能多的容器。然后运行容器，并通过手动步骤完成它。最后，当容器完成您需要它做的事情时，您可以将容器的状态提交为您的可重用容器映像。也许在这一点上，如果您觉得维护映像将是一项频繁重复的任务，您可以尝试用一些手动步骤来扩展Docker文件。</em></p></blockquote><p id="6056" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我最后整理的Docker构建文件。关键步骤:</p><ul class=""><li id="0290" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">容器基于“python:3.6.2-alpine3.6”镜像；这样做主要是因为PSM (Oracle PaaS服务管理器命令行工具需要Python运行时环境)</li><li id="cefc" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">Alpine Linux的apk包管理器被多次用于向映像添加所需的包；它增加了curl、zip、nodejs、nodejs-npm、bash、git和openssh</li><li id="a0f2" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">下载并安装Oracle PSM命令行工具(一个Python应用程序)</li><li id="96a4" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">为目标身份域和用户设置PSM</li><li id="f986" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">安装将用于构建JET web应用程序的Oracle JET命令行工具</li><li id="58a3" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">复制将要执行的脚本build-app.sh，以运行端到端的构建-打包-部署流程</li></ul><pre class="jd je jf jg fd lo lp lq lr aw ls bi"><span id="46c1" class="lt ke hh lp b fi lu lv l lw lx"># extended from <a class="ae jo" rel="noopener" href="/oracledevs/quick-start-docker-ized-paas-service-manager-cli-f54eaf4ebcc7">https://medium.com/oracledevs/quick-start-docker-ized-paas-service-manager-cli-f54eaf4ebcc7</a> <br/># added npm, ojet-cli and git </span><span id="2180" class="lt ke hh lp b fi ly lv l lw lx">FROM python:3.6.2-alpine3.6 <br/>ARG USERNAME <br/>ARG PASSWORD <br/>ARG IDENTITY_DOMAIN <br/>ARG PSM_USERNAME <br/>ARG PSM_PASSWORD <br/>ARG PSM_REGION <br/>ARG PSM_OUTPUT </span><span id="b99e" class="lt ke hh lp b fi ly lv l lw lx">WORKDIR "/oracle-cloud-psm-cli/" </span><span id="744c" class="lt ke hh lp b fi ly lv l lw lx">RUN apk add --update curl &amp;&amp; <br/>\ rm -rf /var/cache/apk/* </span><span id="4010" class="lt ke hh lp b fi ly lv l lw lx">RUN curl -X GET -u $USERNAME:$PASSWORD -H X-ID-TENANT-NAME:$IDENTITY_DOMAIN <a class="ae jo" href="https://psm.us.oraclecloud.com/paas/core/api/v1.1/cli/$IDENTITY_DOMAIN/client" rel="noopener ugc nofollow" target="_blank">https://psm.us.oraclecloud.com/paas/core/api/v1.1/cli/$IDENTITY_DOMAIN/client</a> -o psmcli.zip &amp;&amp; <br/>\ pip3 install -U psmcli.zip <br/>COPY psm-setup-payload.json </span><span id="2b7e" class="lt ke hh lp b fi ly lv l lw lx">RUN psm setup -c psm-setup-payload.json <br/>RUN apk add --update nodejs nodejs-npm <br/>RUN apk add --update zip <br/>RUN npm install -g @oracle/ojet-cli <br/>RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add --no-cache bash git openssh <br/>COPY build-app.sh . </span><span id="a160" class="lt ke hh lp b fi ly lv l lw lx">CMD ["/bin/sh"]</span></pre><p id="a28b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用以下命令构建容器:</p><blockquote class="lh li lj"><p id="d7cf" class="ie if lk ig b ih ii ij ik il im in io ll iq ir is lm iu iv iw ln iy iz ja jb ha bi translated"><em class="hh">docker build–build-arg USERNAME = "您的ACC cloud USERNAME "-build-arg PASSWORD = " ACC cloud PASSWORD "-build-arg IDENTITY _ DOMAIN = "您的身份域"-build-arg PSM _ REGION = " us "-build-arg PSM _ OUTPUT = " JSON "-t PSM-CLI。</em></p></blockquote><p id="60f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设这个命令在docker文件所在的目录中运行。</p><p id="aaa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将创建一个容器并将其标记为image <em class="lk"> psm-cli </em>。当这个命令完成时，您可以通过运行“docker images”找到容器映像。随后，您可以运行基于映像的容器:“docker run–RM-it PSM-CLI”</p><h1 id="56e5" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.准备Oracle JET应用程序</h1><p id="7c44" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">在开发JET (4.x)应用程序时，我们通常使用Oracle JET CLI——这是一个命令行工具，可以帮助我们快速启动新的应用程序、创建复合组件、在本地提供应用程序，因为我们正在将应用程序开发到一个浏览器，它可以即时更新任何文件更改。JET CLI还用于构建要发布的应用程序。这一步的结果是在浏览器中运行JET应用程序所需的完整文件集。为了真正向最终用户提供JET应用程序，它必须由“web服务”平台组件提供服务，例如nginx或Python、Java或Node中的后端。通常，JET应用程序需要一些服务器端设施，服务于静态JET应用程序资源的后端也可以提供这些设施。出于这个原因，我选择了一个JET服务后端，我可以很容易地利用这些服务器端设施；对我来说，这是当前节点。</p><p id="6d4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了为本文讨论的管道中构建的JET应用程序创建一个自运行的JET应用程序，我添加了一个简单的节点&amp; Express后端。</p><p id="3c69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经使用npm创建了一个新的节点应用程序(npm init jet-on-node)。接下来我创建了目录bin和文件www 。该文件是服务于JET应用程序的节点应用程序的主入口点；它将大部分工作委托给从这个节点应用程序的根路径/jet-on-node中的文件app.js加载的模块app。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lz"><img src="../Images/61b5fef6f2530fc6b1324e5f4746d2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*UMx9KgoCWWlndbnl."/></div></figure><p id="d2d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">浏览器可以访问的所有静态资源(包括JET应用程序)都放在文件夹/jet-on-node/public中。<a class="ae jo" href="https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequel/blob/master/jet-on-node/app.js" rel="noopener ugc nofollow" target="_blank">模块app </a>通过Express定义了对公共资源的请求(不是由URL路径处理程序之一处理的请求)通过服务来自目录/public的资源来处理。Module app可以处理其他HTTP请求——例如来自JET应用程序的请求——它还可以实现服务器发送事件或WebSockets的后端。当前is处理对路径“/about”的REST GET请求，该请求返回应用程序的一些关键数据:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/8bd1fc3024eace06fe7f083248050410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e0lev_Vh4yuT8wUv."/></div></div></figure><p id="00ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在最终应用程序的构建过程中，我们将使用“npm install”来添加服务器端所需的节点模块。</p><p id="fb60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">至此，我们已经用一个简单的JET应用程序登陆平台扩展了我们的代码库，该平台可以在运行时为应用程序提供服务。剩下的工作就是将/web目录下的所有内容复制到jet-on-node/public文件夹中。然后，我们可以使用目录jet-on-node中的“npm start”来运行应用程序。这将执行package.json文件中的启动脚本，该文件被定义为“node”。/bin/www”。</p><h1 id="8d16" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">3.创建将在容器内部运行并编排操作的构建脚本</h1><p id="bff7" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">JET构建容器可用。JET应用程序可以从Git存储库中获得(在我的例子中是在GitHub中)。现在，要在应用程序容器云上运行应用程序，需要执行许多步骤。第一步如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/a5ad633a0f83e8237374ff3cafadadde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nsh0gz-jXpByRwOu."/></div></div></figure><p id="6601" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.克隆包含JET应用程序的Git repo(或者获取最新的源代码或特定的标记)</p><p id="6a52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.通过运行npm install，安装JET应用程序所需的所有模块</p><p id="03cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.使用Oracle JET命令行实用程序来构建要发布的应用程序:ojet build–release</p><p id="dbe0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一步之后，所有运行时工件——包括JET库——都在/web目录中。接下来的这些步骤将这些工件转化为一个运行的应用程序:</p><p id="5db3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.将/web的内容复制到/jet-on-node/public</p><p id="7204" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.通过在jet-on-node目录中运行npm install，安装服务器端节点应用程序所需的模块</p><p id="9c2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.为/jet-node目录中的所有工件创建一个zip文件——包括jet应用程序及其服务器端后端节点应用程序。这个zip文件是JET应用程序的发布工件。因此，它可以被推送到工件存储库或部署到其他平台。</p><p id="097e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.使用psm命令行界面(Oracle PaaS Service Manager CLI)将zip文件部署到应用程序容器云，psm已经在创建构建容器期间为其进行了配置。</p><p id="22df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:jet-on-node根目录中的manifest.json和deployment.json文件为PSM和应用程序容器云提供了有关该应用程序运行时设置的说明，包括节点的运行时版本、启动应用程序的命令、每个实例的运行时内存、实例数量以及要传递给应用程序的环境变量的值。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ma"><img src="../Images/dfeaf7305ef64987eaedb89d089ca364.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/0*CxrcBk6F88mozN6h."/></div></figure><p id="4c3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">shell-script build-app.sh(您可能必须使用“chmod u+x build-app.sh”显式地使该脚本可执行)执行上述步骤(尽管可能不是以最佳方式——请随意微调和改进，并让我知道它)。</p><pre class="jd je jf jg fd lo lp lq lr aw ls bi"><span id="81b5" class="lt ke hh lp b fi lu lv l lw lx">#git clone <a class="ae jo" href="https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequel" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequel</a> <br/>cd webshop-portal-soaring-through-the-cloud-native-sequel <br/>git pull <br/>wait <br/>npm install <br/>wait <br/>ojet build --release <br/>wait <br/>cp -a ./web/. ./jet-on-node/public <br/>wait <br/>cd jet-on-node <br/>wait <br/>npm install <br/>wait <br/>zip -r webshop.zip . <br/>wait <br/>cd /oracle-cloud-psm-cli/webshop-portal-soaring-through-the-cloud-native-sequel/jet-on-node <br/>psm accs push -n SoaringWebshopPortal -r node -s hourly -d deployment.json -p webshop.zip</span></pre><p id="4a41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在JET应用程序最新版本发布期间，构建容器中的端到端流程现在可以描述如下:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/14f7d6913b45455f2b87e7ca612a5bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1z2JX1xvqDZSXXym."/></div></div></figure><h1 id="44db" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">4.把所有的放在一起</h1><p id="a9db" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">我现在将尝试演示这一切是如何一起工作的。为了做到这一点，我将详细介绍这些步骤，并用屏幕截图来说明:</p><ul class=""><li id="101e" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">在JET应用程序中进行更改</li><li id="b9bd" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">提交并推送更改(到GitHub)</li><li id="3dd0" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">运行Docker构建容器psm-cli</li><li id="f7cb" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">运行脚本build-app.sh</li><li id="00a2" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">等待大约三分钟(检查构建容器中的输出和ACC控制台中的应用程序状态)</li><li id="3758" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">访问更新的Web应用程序</li></ul><p id="a0c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序的起点:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mb"><img src="../Images/97f052bafc20b16e4d22ef17b8b93594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*-gZCs6kP4ipeWaTs."/></div></figure><p id="576e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.做出改变</p><p id="36ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图标旁边的词“购物篮”似乎是多余的，我将删除它。而且我会增加版本号，从1.2.0版到1.2.1版。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/d3e1f16228cb2006d30238caf9c350f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eBMqLK2RLULtn-Gg."/></div></div></figure><p id="de62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.提交并推送更改(到GitHub)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mc"><img src="../Images/8de5ca4b5290a846c55d166cae9c6a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/0*oHlH1-IMRrnq4irb."/></div></figure><p id="58ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GitHub接受了更改:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/49bb348c07162b7b0311f51c8e61b747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9e_xzxL3ncSTjqQ5."/></div></div></figure><p id="1180" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.运行Docker构建容器psm-cli</p><p id="8024" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行Docker Quickstart终端(我在Windows上)并执行:“Docker run–RM-it PSM-CLI”</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es md"><img src="../Images/becf1baf24bd3c61cd3142b13edd042c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*66K0Vkwjgf6IRRQ4."/></div></figure><p id="c204" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，我缺少一点自动化。我需要采取的手动步骤(只是第一次)是克隆JET应用程序的Git存储库:</p><blockquote class="lh li lj"><p id="e238" class="ie if lk ig b ih ii ij ik il im in io ll iq ir is lm iu iv iw ln iy iz ja jb ha bi translated"><em class="hh"> git克隆</em><a class="ae jo" href="https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequelCloning" rel="noopener ugc nofollow" target="_blank"><em class="hh">https://github . com/lucasjellema/webshop-portal-through-the-cloud-native-sequel cloning</em></a></p></blockquote><p id="98ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并移动到创建的目录</p><blockquote class="lh li lj"><p id="95e0" class="ie if lk ig b ih ii ij ik il im in io ll iq ir is lm iu iv iw ln iy iz ja jb ha bi translated"><em class="hh"> cd网店-门户网站-穿越云端-原生-续集/ </em></p></blockquote><p id="e1e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并使文件build-app.sh可执行:</p><blockquote class="lh li lj"><p id="8f8b" class="ie if lk ig b ih ii ij ik il im in io ll iq ir is lm iu iv iw ln iy iz ja jb ha bi translated"><em class="hh"> chmod u+x build-app.sh </em></p></blockquote><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/b9934c25ee3fa1ed204b080bc6ca9542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_CJK3pZsPaaNbwM."/></div></div></figure><p id="d48d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:只要容器保持运行，我只需要运行“git pull”和”。/build-app.sh ",用于JET应用程序的每次更新。下一步是在GitHub存储库中配置一个由相关提交触发的web钩子。</p><p id="a0c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.运行脚本build-app.sh</p><p id="1dfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">。/build-app.sh</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/e57bc20597f2b9892bdfeda1720c083e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5WYQsbLETrKJPWeu."/></div></div></figure><p id="07be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等待大约三分钟(检查构建容器中的输出</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es me"><img src="../Images/22be3fdd01037b6058225e0ad51b694d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*DZiyegYykiHKQP77."/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/eb840c5956b5bff0cdac8f5ae0708fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fjECYxmR6Cb17Xa6."/></div></div></figure><p id="c4bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和ACC控制台中的应用状态)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/77662b25e61ccd7f8faf042240ab8b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s0xwJkfd5TlfCasR."/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mf"><img src="../Images/43a83eb5d84b46d3467ff9ddb500237f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/0*9G87M61gnfy6ZxFz."/></div></figure><p id="f5f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.访问更新的Web应用程序</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mg"><img src="../Images/548c3ef5977a6ec9ddb9265d670c82d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*YhhzJFHmZyUklOoo."/></div></figure><p id="f7e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您所看到的，在提交和推送更改之后，我只需运行一个简单的命令行命令就可以完全重建和重新部署应用程序。停止Docker容器后，构建过程不会留下任何痕迹。我可以轻松地与我的团队成员共享容器映像，以构建相同的应用程序或更新构建其他或附加的JET应用程序。</p><h1 id="18c5" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">资源</h1><p id="9832" class="pw-post-body-paragraph ie if hh ig b ih lb ij ik il lc in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">Abhishek Gupta的励志文章:<a class="ae jo" rel="noopener" href="/oracledevs/quick-start-docker-ized-paas-service-manager-cli-f54eaf4ebcc7">https://medium . com/Oracle devs/quick-start-docker-ized-PAAs-service-manager-CLI-f 54 EAF 4 ebcc 7</a></p><p id="6d9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码——包括一个示例JET应用程序——在这个GitHub repo中:<a class="ae jo" href="https://github.com/lucasjellema/webshop-portal-soaring-through-the-cloud-native-sequel" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/webshop-portal-through-the-cloud-native-sequel</a>。</p><p id="6fd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle JET命令行界面:<a class="ae jo" href="https://github.com/oracle/ojet-cli" rel="noopener ugc nofollow" target="_blank">https://github.com/oracle/ojet-cli</a></p><p id="74b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle PSM (PaaS服务管理器)CLI上的文档:<a class="ae jo" href="https://docs.oracle.com/en/cloud/paas/java-cloud/pscli/abouit-paas-service-manager-command-line-interface.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/cloud/PaaS/Java-cloud/PS CLI/abouit-PaaS-Service-Manager-command-line-interface . html</a></p><p id="9166" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Node &amp; Express教程第二部分:创建骨架网站:<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/skeleton_website" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Learn/Server-side/Express _ Nodejs/skeleton _ website</a></p><p id="1c90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用快递服务公共文件—【https://expressjs.com/en/starter/static-files.html T4】</p><p id="71b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle应用容器云的文档:<a class="ae jo" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/dvcjv/getting-started-oracle-application-container-cloud-service.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/Cloud/PAAs/app-Container-Cloud/dvcjv/getting-started-Oracle-Application-Container-Cloud-service . html</a></p><p id="7a4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lk">原载于2018年2月26日</em><a class="ae jo" href="https://technology.amis.nl/2018/02/26/oracle-jet-web-applications-automating-build-package-and-deploy-to-application-container-cloud-using-a-docker-container/" rel="noopener ugc nofollow" target="_blank"><em class="lk">technology . amis . nl</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>