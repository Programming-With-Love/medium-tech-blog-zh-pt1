<html>
<head>
<title>Hexagonal Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">六角形建筑</h1>
<blockquote>原文：<a href="https://medium.com/globant/hexagonal-architecture-aec75fc0ed64?source=collection_archive---------0-----------------------#2020-10-14">https://medium.com/globant/hexagonal-architecture-aec75fc0ed64?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="aa21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们中的许多人，尤其是那些从事过大型项目的人，都知道做出改变有多难。这是因为通常它会影响其他代码。这些问题不仅适用于重构，在引入特性时也是如此。这些改变需要时间和金钱。</p><p id="01d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以说这是由于糟糕的设计、缺乏好的测试套件、紧张的发布时间表，甚至是团队和团队成员之间低效的协作。</p><p id="1b62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显然没有完美的解决方案，但是你可以从一开始就为不同的情况做好准备。</p><p id="c4e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个架构模式通过描述一组概念和规则来展示如何解决这些问题。它引入了灵活性和构建可靠测试套件的方法。</p><h1 id="6599" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">背景</h1><p id="94a9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">六边形体系结构是一种分层体系结构，它描述了常见问题的最佳实践。</p><p id="4389" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这并不新鲜，它是由阿利斯泰尔·考克伯恩在2005年推出的，并且在过去的几年里势头越来越猛。</p><p id="c39f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们很多人都知道Clean Architecture和Onion Architecture，它们是几年后由不同作者引入的变体。</p><p id="8e9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">六边形图形用于表示组件之间的不同示例，这与它具有6个边无关。其作者给出的正式名称实际上叫做端口和适配器架构。奇怪的是有一个“八角建筑”，也很有意思。</p><p id="06e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它工作得很好，特别是在大的应用程序上，但是对于短期的或者不会增长的小项目来说，它可能是一种过度的杀戮。它最适合于从许多来源获取数据和/或知道数据会变化的项目。</p><p id="6d96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它不依赖于框架或协议。</p><p id="abe2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更改输入和输出的影响很小，几乎不需要重写代码。</p><p id="b01b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">层模式和六边形模式的区别之一是UI组件被视为一个外部系统，可以随时交换。</p><p id="620e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它与<a class="ae kf" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank"> DDD </a>不一样，但它们可以相互补充。</p><h1 id="535a" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">目的</h1><blockquote class="kg kh ki"><p id="7928" class="ie if kj ig b ih ii ij ik il im in io kk iq ir is kl iu iv iw km iy iz ja jb ha bi translated"><a class="ae kf" href="https://alistair.cockburn.us/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank"> <em class="hh">允许一个应用同样由用户、程序、自动化测试或批处理脚本驱动，并且独立于其最终运行时设备和数据库进行开发和测试。</em> </a></p></blockquote><p id="0dbe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据以上所述，我们可以推断六边形架构将让您构建一个高度可维护的应用程序，减少您的技术债务，并从一开始就轻松地进行集成。</p><h1 id="4ffb" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">体系结构</h1><p id="dae8" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">六边形架构实际上很容易理解和实现。</p><p id="8216" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们继续看一个六角形建筑的基本视觉表现。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/963ced75cc5d8f2f330e461799ac45a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUrteJkuZK-YeZIOgjYAHA.png"/></div></div></figure><p id="4fdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所看到的，它被分层。您可以在内六角的边缘找到端口。</p><p id="81c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">外层是与外部系统通信的适配器。</p><p id="6672" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">指向中心的箭头表示依赖关系。依赖性从外部到中心。这很重要，因为它声明核心应用程序不应该知道适配器如何工作的细节。这确保了业务逻辑的隔离。</p><p id="7171" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下图中，我们可以看到与<a class="ae kf" href="https://en.wikipedia.org/wiki/Multitier_architecture" rel="noopener ugc nofollow" target="_blank"> n层架构</a>的区别，其中每一层都依赖于下面的一层。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kz"><img src="../Images/62db548901aec6de2e5be10b3728e913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeIjIPqONwyoKOL_evjdVQ.png"/></div></div></figure><p id="92c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我来描述一下每个组件是什么以及它的作用。</p><h1 id="8eb1" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">港口</h1><p id="a9f2" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这些充当层之间的边界。</p><p id="1a1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些组件对于架构来说是必不可少的，您可以将它们称为接口。</p><p id="1285" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当应用程序需要同一类型的多个实现时，我们使用接口。通过指定实现之间的方法，定义各层如何相互通信。</p><p id="313a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">端口可以用作入站或出站接口。</p><p id="d771" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些端口确保核心应用程序独立于任何输入或输出。这也使得交换服务更容易完成。</p><h1 id="b076" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">适配器</h1><p id="40b3" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">适配器是特定技术、协议或系统的实现。</p><p id="6577" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些可以是输入，如在传输层，也可以是输出，如数据源。</p><p id="069c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最常见的传输层是HTTP API，但它也可以是消息总线、队列消息、控制台命令等。</p><p id="d432" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据源是您获取数据的地方。典型的例子有数据库、REST API、文件、GraphQL API等。</p><h1 id="28d1" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">核心应用程序</h1><p id="5896" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">核心应用程序是域的实体、行为和约束所在的地方。</p><p id="e4b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，通过拥有一个专用于核心功能和端口使用的层，我们隔离了业务逻辑。</p><p id="5e33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">支持领域逻辑如<a class="ae kf" href="https://en.wikipedia.org/wiki/Use_case" rel="noopener ugc nofollow" target="_blank">用例</a>、<a class="ae kf" href="https://martinfowler.com/eaaDev/DomainEvent.html" rel="noopener ugc nofollow" target="_blank">领域事件</a>或通过普通对象的逻辑(<a class="ae kf" href="https://en.wikipedia.org/wiki/Plain_old_Java_object" rel="noopener ugc nofollow" target="_blank"> POJO </a>、<a class="ae kf" href="https://dev.to/sulmanweb/plain-old-ruby-objects-poros-in-rails-fat-models-3l7f" rel="noopener ugc nofollow" target="_blank"> PORO </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Plain_old_CLR_object" rel="noopener ugc nofollow" target="_blank"> POCO </a>等。)去这里。</p><p id="86a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要混淆域事件和系统事件，它们通常被用作框架中钩子。</p><p id="440f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，让我们重新绘制架构的可视化表示，使这些概念更加清晰。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es la"><img src="../Images/e34537058bbdbb81ab6eed3e1523035b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22QlxAPBQqimDfdStJFwhQ.png"/></div></div></figure><p id="5fb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您所看到的，适配器的箭头指向核心应用程序，在六边形表示中，依赖关系是从外部到内部的</p><p id="7fb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果数据源的接口被移除，箭头将指向另一个方向。业务逻辑不会被隔离，这使得它依赖于存储库。这种情况的一个例子是应用程序将ORM放在业务逻辑中。这将使它变得不可想象，如果不是不可能的话。</p><p id="9ea5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果请求接口的接口被删除，箭头将仍然指向核心应用程序。那么为什么是界面呢？在我们的例子中，我们只有一个输入，但是如果我们有多个输入，业务逻辑就需要知道每个输入的细节。</p><p id="f19f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还要注意，我们会违反<a class="ae kf" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>，强迫适配器依赖它不会使用的方法。</p><h1 id="3f70" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">测试</h1><h1 id="00f4" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">港口</h1><p id="85be" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">没有必要测试这些。接口不需要测试。</p><h1 id="de33" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">核心应用程序</h1><p id="a0be" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">因此这一层不依赖于外层。</p><p id="26a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这很重要，因为您可以独立于任何外部系统来测试业务逻辑。</p><p id="1f60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以详细测试这一层！</p><p id="13f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我认为强调一个好的测试的需要是很重要的，这个测试覆盖了业务逻辑的行为。</p><p id="2a3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用依赖注入、模拟或任何T2测试方法来替换数据源。</p><h1 id="398d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">适配器</h1><p id="cb35" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">重要的是要知道你可以获得核心应用程序所需的信息。</p><p id="ac5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有必要过度测试这一部分，但重要的是知道在抛出异常时该做什么。</p><p id="ca5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于输入，建议测试整个系统。通过这种方式，您可以确保整个应用程序连接正常。换句话说，做一些<a class="ae kf" href="https://en.wikipedia.org/wiki/Integration_testing" rel="noopener ugc nofollow" target="_blank">集成测试</a>。因为我们已经彻底测试了核心应用程序和数据源，所以您可以将这类测试保持在最低限度。</p><h1 id="3d41" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="4e6a" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这种类型的软件架构将为您提供变更所需的灵活性。由于是独立于框架的，它给你机会去尝试更好的/新的版本，甚至在主要版本之间轻松升级。</p><p id="7337" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它将让您并行处理业务逻辑、服务层和数据源。</p><p id="b609" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记住不要将ORM包含在逻辑层中。</p><p id="beac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管这需要更多的工作，而且看起来像是在复制东西，但从长远来看，这将更有益。</p><p id="9ea6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让更好更简单的测试关注每一层的需求。</p><p id="638a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总是寻找如何以不同的方式做事，并试图不断挑战你所知道的。</p><h1 id="9ab2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><ul class=""><li id="b2d3" class="lb lc hh ig b ih ka il kb ip ld it le ix lf jb lg lh li lj bi translated"><a class="ae kf" href="https://alistair.cockburn.us/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank">https://alistair.cockburn.us/hexagonal-architecture/</a></li><li id="2b90" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/hexagon _ architecture _(软件)</a></li><li id="0bcf" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated">【https://fideloper.com/hexagonal-architecture T4】</li><li id="d804" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated"><a class="ae kf" href="https://blog.octo.com/en/hexagonal-architecture-three-principles-and-an-implementation-example/" rel="noopener ugc nofollow" target="_blank">https://blog . octo . com/en/hexagon-architecture-three-principles-and-an-implementation-example/</a></li><li id="a840" class="lb lc hh ig b ih lk il ll ip lm it ln ix lo jb lg lh li lj bi translated"><a class="ae kf" href="https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749" rel="noopener ugc nofollow" target="_blank">https://netflixtechblog . com/ready-for-changes-with-hexagonal-architecture-b 315 EC 967749</a></li></ul></div></div>    
</body>
</html>