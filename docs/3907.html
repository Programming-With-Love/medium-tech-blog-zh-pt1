<html>
<head>
<title>The secret behind JavaScript’s asynchronous nature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript异步本质背后的秘密</h1>
<blockquote>原文：<a href="https://medium.com/globant/the-secret-behind-javascripts-asynchronous-nature-c9837ed0e723?source=collection_archive---------0-----------------------#2022-07-04">https://medium.com/globant/the-secret-behind-javascripts-asynchronous-nature-c9837ed0e723?source=collection_archive---------0-----------------------#2022-07-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="efad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated">当你学习JavaScript时，你经常会听到人们使用“单线程”、“阻塞”和“异步回调”这样的词。如果你和我一样，点头表示同意，好像一切都很明显，即使你几乎不知道那些术语是如何运作的；然而，像我这样好奇的实体试图找出JavaScript到底是如何工作的，然后让我们深入研究！</p><p id="6561" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">什么是JavaScript？</em> </strong></p><blockquote class="jm jn jo"><p id="cd2b" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">单线程、非阻塞、异步编程语言</p></blockquote><p id="3c95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">啊，单线程的！！</p><p id="11c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">即</em> </strong></p><blockquote class="jm jn jo"><p id="c531" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">一个线程==一个调用堆栈==一次一件事</p></blockquote><p id="bee5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面让我们想象一下调用堆栈是如何一次执行一条程序语句的:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/fe1f89257ea53223bc791979843ae0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gM0sGnM53lXglpRfimPcrg.gif"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 1 Single Threaded</figcaption></figure><p id="c899" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">参考图1: </em> </strong>我们可以看到有几个函数定义最后引擎到了greet()函数调用。</p><ol class=""><li id="e4d2" class="ke kf hh ig b ih ii il im ip kg it kh ix ki jb kj kk kl km bi translated">我们调用greet()函数</li><li id="d012" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">它是<strong class="ig hi"> <em class="jl">把</em> </strong>推到<strong class="ig hi"> <em class="jl">上的调用栈</em> </strong></li><li id="1147" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">打印出“你好”</li><li id="43d4" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">greet()方法将<strong class="ig hi"> <em class="jl">弹出</em> </strong></li><li id="ba5b" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">引擎再次遇到新的调用，即greetWorld()函数</li><li id="f228" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">它是<strong class="ig hi"> <em class="jl">将</em> </strong>推到<strong class="ig hi"> <em class="jl">上的调用栈</em> </strong></li><li id="8ce3" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">打印出“Hello World”</li><li id="0d03" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">greetWorld()方法获取弹出的<strong class="ig hi"><em class="jl"/></strong></li></ol><p id="5b59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可能想知道上图中的<strong class="ig hi"> <em class="jl">调用栈</em> </strong>是什么。</p><blockquote class="jm jn jo"><p id="abd4" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">这是一种数据结构，记录我们在程序中的位置。如果我们进入一个函数，那么这个函数被推到堆栈上，如果我们从一个函数返回，那么我们从堆栈的顶部弹出。</p></blockquote><p id="6386" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">想知道我们在哪里可以找到这个调用栈吗？</em>T49】</strong></p><blockquote class="jm jn jo"><p id="03c3" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">它驻留在<strong class="ig hi"> JavaScript引擎</strong>中，就像<strong class="ig hi"> Chrome V8引擎</strong>一样。<em class="hh">参考下面的图2:</em></p></blockquote><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/0147e73869cdc0b9bac44d6baea5d590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P76zhGUzptwOo4SMg5YANA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 2 The JavaScript Runtime (The Chrome V8 engine)</figcaption></figure><p id="750b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们看到了JavaScript是如何单线程的，你可能会想"<strong class="ig hi"> <em class="jl">是的</em> </strong> " JS在调用栈就位的情况下工作。但是如果我们的代码需要一些时间来执行呢？</p><p id="e8cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">我们到底怎么称呼耗时/慢的代码？</em> </strong></p><blockquote class="jm jn jo"><p id="7dd1" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">啊堵住了！！</p></blockquote><p id="fcf2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">意为:</em> </strong></p><blockquote class="jm jn jo"><p id="cbf4" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">执行速度慢或需要很长时间的事情指的是阻塞代码。</p></blockquote><p id="fda5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">问题陈述:</strong>假设我们想订阅YouTube上的一个频道。如果订阅一个频道花费了超过x的时间会怎样？</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/a92427845dc92505ba1e7cc4ed5abf17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*d2e__3QxYDAzcb-m0D2caw.gif"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 3 Blocking</figcaption></figure><p id="104a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">遇到的问题:</strong>浏览器！！</p><p id="14a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">参考图3: </em> </strong>上面场景的问题是，我们点击订阅按钮后，整个屏幕/浏览器都被卡住了，直到订阅请求完成。</p><p id="ba08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">有什么解决办法？</em> </strong></p><blockquote class="jm jn jo"><p id="2acf" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">异步回调。</p></blockquote><p id="4a2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">啊，异步回调！！</p><p id="7dc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">即</em> </strong></p><blockquote class="jm jn jo"><p id="699e" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">我们运行一些代码，并给它一个回调，这个回调将在稍后的时间点执行。让我们使用下面的调用堆栈来想象一下:</p></blockquote><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/d49add13c781e77feb35cd390b572a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6I2XohHLdOE49XCh3Vgcuw.gif"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 4 Asynchronous callback</figcaption></figure><p id="9877" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">参考图4: </em> </strong>在运行上面的代码片段时我们可以看到:</p><ol class=""><li id="7492" class="ke kf hh ig b ih ii il im ip kg it kh ix ki jb kj kk kl km bi translated">1ˢᵗ console.log()语句将被压入调用堆栈</li><li id="647d" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">打印输出1</li><li id="bee4" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">console.log(1)被弹出</li><li id="ad4e" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">类似地，执行2ⁿᵈ console.log()语句</li><li id="ce13" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">然后将setTimeout函数调用推送到调用堆栈上以打印3，这将在最少2秒 的<strong class="ig hi"> <em class="jl">中执行。因此，setTimeout函数不知何故消失了！！</em></strong></li><li id="a23f" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">那么console.log(4)将被压入调用堆栈</li><li id="0ccb" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">打印输出4</li><li id="ec60" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">console.log(4)被弹出</li><li id="c216" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">几秒钟后，console.log(3)神奇地出现在调用堆栈上，并打印出3</li></ol><p id="dd37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">怎么会这样？</em>T25】</strong></p><blockquote class="jm jn jo"><p id="c3e6" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">JavaScript异步本质背后的秘密:<strong class="ig hi">事件循环！！</strong></p></blockquote><p id="c755" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你现在可能认为JavaScript是一种单线程编程语言<strong class="ig hi"> <em class="jl">但事实并非如此！！</em> </strong></p><blockquote class="jm jn jo"><p id="55a2" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">所以JavaScript运行时(Chrome V8引擎)一次执行一件事。当其他代码正在执行时，它不能发出网络请求/不能设置超时。</p></blockquote><p id="3ef1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，我们如何发出网络请求，或者如何在执行其他代码的同时执行setTimeout呢？ </p><blockquote class="jm jn jo"><p id="ed42" class="ie if jl ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">因为浏览器本身除了JavaScript运行时(Chrome V8引擎)还有很多东西。让我们看看下面的图表，看看还有哪些其他的东西。</p></blockquote><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kx"><img src="../Images/d73577b427bf82a96ec63c575a48353d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJYbv2ITeoCzNq5biK5f9Q.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 5 The bigger picture: Event Loop</figcaption></figure><p id="c4dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们重新看一下异步回调示例的执行，以理解其他组件是什么:<strong class="ig hi"><em class="jl">Web/c++ API、任务队列、事件循环</em> </strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/5d69ee63bc78d7b353197c189ccb57ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4hpFsx9aPvVO3AWR2x2bGw.gif"/></div><figcaption class="ka kb et er es kc kd bd b be z dx">Fig 5 Asynchronous callback with the event loop</figcaption></figure><p id="94e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jl">参考图5: </em> </strong>在运行上面的代码片段我们可以看到:</p><ol class=""><li id="fe4e" class="ke kf hh ig b ih ii il im ip kg it kh ix ki jb kj kk kl km bi translated">1ˢᵗ console.log(1)语句被推送到调用堆栈上</li><li id="4fd8" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">打印输出1</li><li id="adb9" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">console.log(1)被弹出</li><li id="b1ab" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">类似地，执行2ⁿᵈ console.log()语句</li><li id="ab00" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">现在，当setTimeout被压入堆栈时，它在调用堆栈<strong class="ig hi"> <em class="jl">之外执行，即由浏览器的Web API</em></strong>执行。所以浏览器为我们启动了计时器，现在它将处理它的执行。由于setTimeout的执行没有完成，我们将它从堆栈中弹出。</li><li id="715e" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">我们继续以类似于console.log(1)和console.log(2)的方式执行console.log(4)的代码片段</li><li id="b7ee" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">一旦Web API完成setTimeout语句的执行，它就将结果推送到任务队列中。最后，我们得到“<strong class="ig hi"> <em class="jl">事件循环</em> </strong>”。事件循环就像“<em class="jl">嘿，我终于有任务了。如果是空的，让我看一下堆栈。哦，是的，它是！因此，让我将1ˢᵗ的东西从任务队列推到调用堆栈，即回调</em>。</li><li id="dbfb" class="ke kf hh ig b ih kn il ko ip kp it kq ix kr jb kj kk kl km bi translated">然后，回调的结果被打印到控制台上，即数字3，并弹出调用堆栈。</li></ol><p id="f6c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="2749" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经了解了“单线程”、“阻塞”和“异步回调”等词的含义，事件循环是一个持续运行的过程，它监控调用堆栈和队列之间的任务，以实现JS的异步特性。</p><p id="e81b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望这能让你对事件循环的概念更加熟悉。</p><p id="20a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jl">本文受</em> <a class="ae ky" href="http://latentflip.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jl">菲利普·罗伯茨</em> </a> <em class="jl">的影响较大，在</em> <a class="ae ky" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank"> <em class="jl"> JS事件循环上</em> </a> <em class="jl">。谢谢菲利普·罗伯茨的视频，它帮助我更好地理解JavaScript。</em></p></div></div>    
</body>
</html>