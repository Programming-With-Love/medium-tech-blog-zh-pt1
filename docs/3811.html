<html>
<head>
<title>Elasticsearch REST Java Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elasticsearch REST Java客户端</h1>
<blockquote>原文：<a href="https://medium.com/globant/elasticsearch-rest-java-client-4ebc23b9ecb6?source=collection_archive---------0-----------------------#2022-01-10">https://medium.com/globant/elasticsearch-rest-java-client-4ebc23b9ecb6?source=collection_archive---------0-----------------------#2022-01-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5a22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Elasticsearch是一个基于文档的数据库和基于Lucene库的搜索引擎。它还提供了许多功能，如模糊搜索，聚合，排序，点击等。Elasticsearch是分布式的，索引可以被分成碎片，每个碎片都可以有副本。</p><p id="22b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我们将讨论以下几点</p><ul class=""><li id="3c8b" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">使用java连接到Elasticsearch的选项</li><li id="caf2" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">与微服务集成</li><li id="50c4" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">记录API</li><li id="5c4a" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">同步和异步调用</li></ul></div><div class="ab cl jq jr go js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="ha hb hc hd he"><p id="6864" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用java连接到Elasticsearch的选项</strong></p><p id="8f39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。</strong> <strong class="ig hi">运输客户端:</strong></p><p id="5a52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在引入用于弹性搜索的Java客户端之前，使用传输客户端。这使用HTTP上的REST API。在这种情况下，用户必须付出额外的努力来编组请求和解组响应。</p><p id="1043" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。</strong> <strong class="ig hi">休息低级客户端</strong>:</p><p id="4e03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">RestLowLevelClient在内部使用Apache HTTP异步客户端。它使用最少数量的依赖项。这还会给用户带来额外的工作来编组和解组请求和响应。这将提供以下功能。</p><p id="1183" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">负载平衡</p><p id="1119" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">故障切换</p><p id="9498" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">持久连接</p><p id="bc0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">跟踪日志记录请求和响应</p><p id="2299" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最小依赖性</p><p id="13a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。</strong> <strong class="ig hi"> Rest高级客户端:</strong></p><p id="030f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">RestHighLevelClient构建在RestLowLevelClient之上。这增加了一些弹性搜索依赖，然后是低级客户端。它公开了负责获取请求对象和返回响应对象的API特定方法。高级客户端负责编组请求和解组响应，这使我们的编码更容易。这是弹性搜索的默认客户端。</p></div><div class="ab cl jq jr go js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="ha hb hc hd he"><p id="3efe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">与微服务的集成</strong></p><ol class=""><li id="0264" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jx ji jj jk bi translated"><strong class="ig hi"> Maven依赖关系</strong></li></ol><p id="cdaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步是将maven依赖项添加到pom.xml，如下所述。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="afe5" class="kh ki hh kd b fi kj kk l kl km">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;<br/>  &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;<br/>  &lt;version&gt;7.14.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="ba15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要java 1.8和更高版本来支持这种依赖性。参考<a class="ae kn" href="https://mvnrepository.com/artifact/org.elasticsearch.client/elasticsearch-rest-high-level-client" rel="noopener ugc nofollow" target="_blank">此处</a>了解最新版本的弹性搜索。</p><p id="da5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。初始化RestHighLevelClient: </strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="f139" class="kh ki hh kd b fi kj kk l kl km">RestHighLevelClient client = new RestHighLevelClient(<br/>       RestClient.builder(new HttpHost("localhost", 9200, "http"),<br/>                          new HttpHost("localhost", 9201, "http")));</span></pre><p id="a073" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将创建一个RestHighLevelClient实例，该实例将在内部创建一些低级客户端的实例。高级客户端将维护一些低级客户端连接的池。一旦使用完高级客户端，不要忘记使用client.close()关闭它。这将释放低级客户端连接。使用close方法关闭连接。</p></div><div class="ab cl jq jr go js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="ha hb hc hd he"><p id="dfa8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">记录API的</strong></p><ol class=""><li id="4670" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jx ji jj jk bi translated"><strong class="ig hi">索引一个文档</strong>:</li></ol><p id="63a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要创建一个如下的IndexRequest。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="1abb" class="kh ki hh kd b fi kj kk l kl km">Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();<br/>jsonMap.put("user", "kimchy");<br/>jsonMap.put("postDate", new Date());<br/>jsonMap.put("message", "trying out Elasticsearch");<br/>IndexRequest indexRequest = new IndexRequest("myIndex")<br/>                             .id("1").source(jsonMap);</span></pre><p id="0b13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里‘myIndex’是索引名，而‘1’是文档的id。我们也可以传递json字符串来代替map，如下所示。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="8abe" class="kh ki hh kd b fi kj kk l kl km">String jsonString = "{" +<br/>   "\"user\":\"kimchy\"," +<br/>   "\"postDate\":\"2013-01-30\"," +<br/>   "\"message\":\"trying out Elasticsearch\"" +<br/>   "}";<br/>request.source(jsonString, XContentType.JSON);</span></pre><p id="bde0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按如下方式执行请求。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="1b8a" class="kh ki hh kd b fi kj kk l kl km">IndexResponse indexResponse = client.index(request,<br/>     RequestOptions.DEFAULT);</span></pre><p id="1a43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在执行请求时，程序将暂停，直到弹性搜索没有返回IndexResponse。</p><p id="81cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2) </strong> <strong class="ig hi">获取一个文档:</strong></p><p id="9526" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如下创建Get请求。其中“myIndex”是索引名称，“1”是文档id。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="2fd1" class="kh ki hh kd b fi kj kk l kl km">GetRequest getRequest = new GetRequest(  "myIndex",   "1");</span></pre><p id="a05e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要执行请求，请使用客户端。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="e19f" class="kh ki hh kd b fi kj kk l kl km">GetResponse getResponse = client.get(getRequest,  <br/>    RequestOptions.DEFAULT);</span></pre><p id="6025" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以使用以下GetResponse方法获取该文档</p><p id="fdc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">-getresponse . getsourceasstring():-这将以字符串形式返回文档。</p><p id="7691" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">-getresponse . getsourceasmap():-这将返回一张<string object="">的地图</string></p><p id="8bcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">-getresponse . getsourceasbytes():-这将返回一个字节数组。</p><p id="f7d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">3)</strong>T7】删除一个文档:</p><p id="d781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用“myIndex”作为索引，使用“1”作为文档id，可以如下构造DeleteRequest。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="bc4c" class="kh ki hh kd b fi kj kk l kl km">DeleteRequest request = new DeleteRequest( "myIndex", "1");</span></pre><p id="87d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用我们的高级客户端来执行请求。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="4921" class="kh ki hh kd b fi kj kk l kl km">DeleteResponse deleteResponse = client.delete(request, <br/>      RequestOptions.DEFAULT);</span></pre><p id="a8fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">4)</strong>T11】更新文档:</p><p id="be26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">UpdateRequest构建如下。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="4896" class="kh ki hh kd b fi kj kk l kl km">UpdateRequest request = new UpdateRequest( "myIndex", "1");</span></pre><p id="d80c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里“myIndex”是索引,“1”是需要更新的文档的id。创建一个更新字段的映射，并将其设置在doc下，如下所示。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="4ab9" class="kh ki hh kd b fi kj kk l kl km">Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();<br/>jsonMap.put("updated", new Date());<br/>jsonMap.put("reason", "daily update");<br/>UpdateRequest request = new UpdateRequest("myIndex", "1")  <br/>   .doc(jsonMap);</span></pre><p id="5fc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按如下方式执行请求。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="4e90" class="kh ki hh kd b fi kj kk l kl km">UpdateResponse updateResponse = client.update(request, <br/>     RequestOptions.DEFAULT);</span></pre></div><div class="ab cl jq jr go js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="ha hb hc hd he"><p id="88cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">同步和异步调用</strong></p><p id="0a44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面提到的所有创建、更新、删除和get调用都是异步调用。高级客户端也为它们中的每一个提供同步调用方法。我们只需要向同步调用方法写入后缀异步字，例如:client.update()是同步方法，而as client.updateAsync()是异步方法。</p><p id="b316" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还必须添加一个ActionListener来获得响应。执行异步调用的代码片段如下。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="f632" class="kh ki hh kd b fi kj kk l kl km">ActionListener listener = new ActionListener&lt;UpdateResponse&gt;() {<br/>    @Override<br/>    public void onResponse(UpdateResponse updateResponse) {<br/>        <br/>    }<br/><br/>    @Override<br/>    public void onFailure(Exception e) {<br/>        <br/>    }<br/>};</span><span id="0540" class="kh ki hh kd b fi ko kk l kl km">client.updateAsync(request, RequestOptions.DEFAULT, listener);</span></pre><p id="47c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们必须创建一个侦听器，并将引用传递给updateAsync调用。每当调用执行完成时，就触发onResponse或onFailure方法。</p><p id="8d60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="4fc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们看到了如何使用Java客户端来执行一些常见的Elasticsearch特性。</p></div></div>    
</body>
</html>