<html>
<head>
<title>Exploring Firebase MLKit on Android: Landmark Detection (Part Four)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Android上的Firebase MLKit:地标检测(第四部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-firebase-mlkit-on-android-landmark-detection-part-four-5e86b8deac3a?source=collection_archive---------1-----------------------#2018-07-27">https://medium.com/google-developer-experts/exploring-firebase-mlkit-on-android-landmark-detection-part-four-5e86b8deac3a?source=collection_archive---------1-----------------------#2018-07-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7ca8fa010a27a0741d8bcd8b0d816493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Hol3oph5n_Lxsk0mBkIJA.png"/></div></div></figure><p id="0ba3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在今年的Google I/O上，我们看到了Firebase MLKit的推出，这是Firebase套件的一部分，旨在让我们的应用程序能够更轻松地支持智能功能。随之而来的是地标识别特性，它使我们能够检测输入提要中的已知地标，以便在屏幕上向用户显示这些地标信息。在这篇文章中，我想深入探讨如何在我们的应用程序中实现这个特性。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="4036" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">地标识别可能并不适用于所有应用，但当需要时，它可能是一个难以实现的功能——在这些情况下，有许多不同的事情需要考虑和分析。虽然我们可能知道设备的位置，但分析图像中的结构仍然是一项困难的任务。然而，Firebase MLKit中这一功能的目的是使我们作为开发人员的这一过程更加简单。使用地标识别功能，我们可以将一个图像实例传递给Firebase MLKit视觉参考，并返回有关该识别的数据，以便在我们的应用程序中使用。</p><p id="569d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们为什么要这么做？地标识别有多种用途。例如，我们可能在应用程序中进行图像标记，并希望通过标记这些图像中的地标/位置来平滑这一过程。也许我们的图像应用程序利用了图像元数据，我们希望通过提供地标数据来扩展这些数据。或者，我们分享应用程序的内容，发送消息或进行视频通话，我们希望通过在这些体验中提供这些额外数据来进一步个性化这些体验。我敢肯定，这种功能还有很多其他的使用案例，也许你在亲自体验过这个API之后就会发现🙂</p><p id="b31d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>要知道MLKit地标识别只作为云功能提供，意味着不能进行离线识别。这是因为需要Google Cloud Vision API来执行识别过程。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="ccf5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在开始使用MLKit的地标识别特性之前，我们需要先将依赖项添加到我们的项目级build.gradle文件中:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1104" class="kd ke hh jz b fi kf kg l kh ki">implementation 'com.google.firebase:firebase-ml-vision:16.0.0'</span></pre><p id="fdf9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们需要做的下一件事是启用云视觉API，因为这是使用这一识别功能所必需的。首先，我们需要将我们的Firebase项目升级到Blaze计划，这是因为云识别API只适用于付费计划。Blaze是一个现收现付的计划，所以如果你想试用这个API，你可以在试用完成后随时降级这个计划。</p><p id="d348" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>您可以免费使用识别程序多达1000次。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kj"><img src="../Images/1c71516d5ca2597f1eb93d0b1e7a8b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yt4zVS-atNQUIo0f0kjYw.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Upgrading your Firebase project to the Blaze plan</figcaption></figure><p id="25a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们需要在Google API控制台中为我们的Firebase项目启用云视觉API。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/7f3002536888bd4060e7c182d8d941e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zhktOJUfVmYBeAGfugcsw.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx">Enabling the Cloud Vision API for your chosen firebase project in the Google API Console</figcaption></figure><p id="fbcf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在这已经完成了，我们可以在我们的Firebase项目中使用Cloud Vision API。在利用地标识别之前，您必须这样做，直到您这样做，detectInImage()函数将返回一个错误，指出您需要在firebase项目中启用计费。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="b670" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在进行识别时，识别器将使用默认的识别模型(称为<strong class="ir hi">稳定</strong>)，该模型将为我们返回流程的前10个结果。然而，我们可以通过提供一个用于识别过程的<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/cloud/FirebaseVisionCloudDetectorOptions" rel="noopener ugc nofollow" target="_blank">FirebaseVisionCloudDetectorOptions</a>实例来定制它:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7d56" class="kd ke hh jz b fi kf kg l kh ki">val options = FirebaseVisionCloudDetectorOptions.Builder()<br/>      .setModelType(FirebaseVisionCloudDetectorOptions.<em class="kq">LATEST_MODEL</em>)<br/>      .setMaxResults(15)<br/>      .build()</span></pre><p id="1216" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这种方式，我们可以定制在对图像进行识别时希望收到的结果的最大数量。您可能希望最小化通过请求返回的结果，或者允许返回更大的数量，以便您可以分析更大范围的结果。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="9b15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经建立了选项，我们可以继续在我们的认可流程中使用它们。我们希望使用这些选项来创建一个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/common/FirebaseVisionImage" rel="noopener ugc nofollow" target="_blank"> FirebaseVisionImage </a>的实例——这是一个保存图像数据的类，为识别过程做好准备。现在，我们需要这个实例，然后才能执行任何形式的识别，为了创建这个实例，我们需要使用我们的图像数据，这可以通过以下五种方式之一来完成:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/faf1963b0d715ecaefb892b04bf508e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-7EDr_BOVoEoGHKlevaUA.png"/></div></div></figure><h2 id="3a93" class="kd ke hh bd ks kt ku kv kw kx ky kz la ja lb lc ld je le lf lg ji lh li lj lk bi translated">位图</h2><p id="b968" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">首先，我们可以使用一个位图实例创建一个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/common/FirebaseVisionImage" rel="noopener ugc nofollow" target="_blank"> FirebaseVisionImage </a>的实例。我们可以通过将一个<strong class="ir hi">直立</strong>位图传递到fromBitmap()函数中来实现——这将返回一个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/common/FirebaseVisionImage" rel="noopener ugc nofollow" target="_blank"> FirebaseVisionImage </a></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="62be" class="kd ke hh jz b fi kf kg l kh ki">val image = FirebaseVisionImage.fromBitmap(bitmap);</span></pre><h2 id="bf28" class="kd ke hh bd ks kt ku kv kw kx ky kz la ja lb lc ld je le lf lg ji lh li lj lk bi translated">媒体。图像</h2><p id="36b8" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">我们也可以通过媒体来实现。图像实例—这可能发生在从设备的摄像头捕捉图像时。这样做时，我们必须传递这个图像的实例以及它的旋转，所以这必须在调用fromMediaImage()函数之前进行计算。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e87e" class="kd ke hh jz b fi kf kg l kh ki">val image = FirebaseVisionImage.fromMediaImage(mediaImage,    <br/>                rotation);</span></pre><h2 id="f7db" class="kd ke hh bd ks kt ku kv kw kx ky kz la ja lb lc ld je le lf lg ji lh li lj lk bi translated">字节缓冲器</h2><p id="cccd" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">也可以使用ByteBuffer创建实例。为此，我们必须首先创建一个FirebaseVisionImageMetadata的实例。这包含构建视觉图像所需的数据，例如旋转和测量。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="48df" class="kd ke hh jz b fi kf kg l kh ki">FirebaseVisionImageMetadata metadata = new <br/>    FirebaseVisionImageMetadata.Builder()<br/>        .setWidth(1280)<br/>        .setHeight(720)<br/>        .setFormat(FirebaseVisionImageMetadata.IMAGE_FORMAT_NV21)<br/>        .setRotation(rotation)<br/>        .build();</span></pre><p id="26ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们可以将它与ByteBuffer一起传递，以创建实例:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="43ca" class="kd ke hh jz b fi kf kg l kh ki">val image = FirebaseVisionImage.fromByteBuffer(buffer, metadata);</span></pre><h2 id="b7a3" class="kd ke hh bd ks kt ku kv kw kx ky kz la ja lb lc ld je le lf lg ji lh li lj lk bi translated">ByteArray</h2><p id="25aa" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">从ByteArray创建图像的方式与ByteBuffer相同，只是我们必须使用fromByteArray()函数:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4eb3" class="kd ke hh jz b fi kf kg l kh ki">val image = FirebaseVisionImage.fromByteArray(byteArray, metadata);</span></pre><h2 id="2df7" class="kd ke hh bd ks kt ku kv kw kx ky kz la ja lb lc ld je le lf lg ji lh li lj lk bi translated">文件</h2><p id="db97" class="pw-post-body-paragraph ip iq hh ir b is ll iu iv iw lm iy iz ja ln jc jd je lo jg jh ji lp jk jl jm ha bi translated">通过使用上下文和期望的URI调用fromFilePath()函数，可以从文件创建视觉图像实例。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a030" class="kd ke hh jz b fi kf kg l kh ki">val image: FirebaseVisionImage?<br/>try {<br/>    image = FirebaseVisionImage.fromFilePath(context, uri);<br/>} catch (IOException e) {<br/>    e.printStackTrace();<br/>}</span></pre></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="33fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们有了想要分析的图像实例，我们就可以执行地标识别了。无论我们是否提供选项的实例，我们都可以准备FirebaseVision检测器。如果我们使用默认选项，我们可以简单地按原样检索实例:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2083" class="kd ke hh jz b fi kf kg l kh ki">val detector = FirebaseVision.getInstance()<br/>        .<em class="kq">visionCloudLandmarkDetector</em></span></pre><p id="4654" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">否则，我们可以在检索检测器时传入我们的选项引用:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="06e7" class="kd ke hh jz b fi kf kg l kh ki">val detector = FirebaseVision.getInstance()<br/>        .getVisionCloudLandmarkDetector(options)</span></pre><p id="c8d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们只需要在我们的检测器实例上调用detectInImage()函数，传入对我们之前准备的图像的引用:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a62b" class="kd ke hh jz b fi kf kg l kh ki">detector.detectInImage(image)<br/>    .addOnSuccessListener <strong class="jz hi">{<br/>         </strong>// Task succeeded!<br/>        for (landmark in <strong class="jz hi">it</strong>) {<br/>            // Do something with landmark<br/>        }<br/>    <strong class="jz hi">}<br/>    </strong>.addOnFailureListener <strong class="jz hi">{<br/>        </strong>// Task failed with an exception<br/>    <strong class="jz hi">}</strong></span></pre><p id="b236" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果这个调用成功，那么我们将得到一个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/cloud/landmark/FirebaseVisionCloudLandmark" rel="noopener ugc nofollow" target="_blank">FirebaseVisionCloudLandmark</a>实例的列表。如果没有检测到地标，那么这将是空的，因此如果出现这种情况，您需要处理它。否则，我们可以访问我们现在需要做一些事情的地标集合。对于每个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/cloud/landmark/FirebaseVisionCloudLandmark" rel="noopener ugc nofollow" target="_blank">FirebaseVisionCloudLandmark</a>实例，我们可以访问一组可以在这里使用的属性:</p><ul class=""><li id="c5ee" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><strong class="ir hi"> getBoundingBox() </strong> —检索包含已识别地标的图像区域</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1386" class="kd ke hh jz b fi kf kg l kh ki">val bounds = landmark.<em class="kq">boundingBox</em></span></pre><ul class=""><li id="21f0" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><strong class="ir hi"> getLandmark() </strong> —检索检测到的地标的名称</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="bbd2" class="kd ke hh jz b fi kf kg l kh ki">val landmarkName = landmark.<em class="kq">landmark</em></span></pre><ul class=""><li id="d7d8" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><strong class="ir hi"> getConfidence() </strong> —检索给定结果与提供的图像匹配的置信度</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a89c" class="kd ke hh jz b fi kf kg l kh ki">val confidence = landmark.<em class="kq">confidence</em></span></pre><ul class=""><li id="dae9" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><strong class="ir hi"> getLocations() </strong> —检索一个<a class="ae ko" href="https://firebase.google.com/docs/reference/android/com/google/firebase/ml/vision/common/FirebaseVisionLatLng" rel="noopener ugc nofollow" target="_blank">firebasevisionlating</a>实例的列表，该列表表示诸如地标位置和照片拍摄位置之类的位置。</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d50d" class="kd ke hh jz b fi kf kg l kh ki">val locations = landmark.<em class="kq">locations</em></span></pre><ul class=""><li id="df59" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><strong class="ir hi"> getEntityId() </strong> —检索识别过程的给定Id</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d084" class="kd ke hh jz b fi kf kg l kh ki">val entityId = landmark.<em class="kq">entityId</em></span></pre><p id="361f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们通过这个识别流程运行一些图像，我们可以看到我们从一些众所周知的地标得到的结果:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/aae9e015ed9c37cd02a778dffab2d049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0gy5WMp7N1bK0Z8XiVrfA.png"/></div></div></figure><p id="aed9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来MLKit对它的结果很有信心。我已经使用边界框在识别的地标周围绘制，然后简单地显示了下面的landmarkName和confidence属性。让我们试着在识别器里放一张大本钟的照片:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/a1b86aad2b96c2a08c89722c9e1b3a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKSiK_umo94hpG8gUGdnAQ.png"/></div></div></figure><p id="3cc7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对这个不太有信心，我们还可以看到有多个已经检测到的地标实例。因为我正在循环通过地标，所以地标的最后一个实例被用于显示置信度。让我们再试一次，但只看第一个结果:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/11e126de273ae7cdb648727458d2d220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6BJt7R5tp0LcIWUVYpQKg.png"/></div></div></figure><p id="ef53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里稍微好一点，这里只有一个边界框也更容易。在这里，您可能要做的是从已识别的地标获取所有结果，并操纵置信度集合，以在您的应用程序中为该地标做出置信度决定。</p><p id="af11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，让我们运行另一个图像:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/e658bc0b72022cf8026167ff1821b6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqOBmeyvpYcxlOK4OFTVGQ.png"/></div></div></figure><p id="7e6e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我想运行这个，这样我们就可以测试一下，如果我们只显示部分图像，MLKit是否还能识别这个著名的地标:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/1c63b53667a564e924b02cdc60609333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLO6hz69tLKjFUVlNfEEXA.png"/></div></div></figure><p id="ffbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我知道这个地标非常有名，所以这可能是为什么仍然有一个部分图像的高可信度，但很高兴看到它仍然有能力在这种状态下识别地标(实际上它更有信心地标是埃菲尔铁塔！).</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="2e1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望通过这篇文章，您能够了解什么是Firebase MLKit地标识别，以及我们如何设置它，以便在我们的应用中使用它。如果这是一个您可以(或确实)利用的特性，那么在您的应用程序中尝试一下地标识别绝对是值得的。不幸的是，这需要一个Firebase的付费帐户，但根据使用情况，这对一些人来说可能不是问题。</p><p id="920c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我很想知道你是如何使用这个API的——如果你有任何想法、问题或评论，请联系我们🙂</p><div class="ma mb ez fb mc md"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hi fi z dy mi ea eb mj ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android主管和高级工程师。@缓冲。谷歌开发专家…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">twitter.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr in md"/></div></div></a></div></div></div>    
</body>
</html>