<html>
<head>
<title>Getting Started with Purescript!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Purescript入门！</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/getting-started-with-purescript-cd3ed3b275b5?source=collection_archive---------0-----------------------#2018-11-26">https://medium.com/quick-code/getting-started-with-purescript-cd3ed3b275b5?source=collection_archive---------0-----------------------#2018-11-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/9e156ab12697f04fda655138b42b8130.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*q1jXC5mVvPoaaIpp2wOFZg.png"/></div></figure><p id="b2bb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们的<a class="ae jj" href="https://www.mmhaskell.com/elm-1" rel="noopener ugc nofollow" target="_blank"> Elm系列</a>是我们在周一早上第一次潜入前端web开发的世界。我们没有使用众多库中的一个来实现纯Haskell方法，而是尝试了一种更适合Web的不同函数式语言。</p><p id="ee10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">延续这一趋势，我们将在接下来的几周时间里关注Purescript。像Elm一样，它的语法也像Haskell的一样，并且它包含了许多功能纯洁性的元素。但是它可以编译成Javascript，因此有一些特性似乎更适合用这种语言。</p><p id="2fd2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本周，我们将从探索Purescript的基础开始。我们将看到它和Haskell之间的一些主要的相同点和不同点。我们会发现Purescript拥有很多Elm所没有的Haskell语言特性。我们将用Purescript制作一个web前端，并看看如何将它连接到Haskell后端，这将是本系列的高潮。</p><p id="3028" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Purescript只是在产品中使用函数式语言的冰山一角！查看我们的<a class="ae jj" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>中一些令人敬畏的Haskell库！</p><h1 id="193f" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">入门指南</h1><p id="3def" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">因为Purescript是它自己的语言，我们需要一些新的工具。你可以按照<a class="ae jj" href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md" rel="noopener ugc nofollow" target="_blank"> Purescript网站</a>上的说明去做，不过这里是要点。</p><ol class=""><li id="7517" class="kn ko hh in b io ip is it iw kp ja kq je kr ji ks kt ku kv bi translated">安装Node.js和NPM，Node.js包管理器</li><li id="971c" class="kn ko hh in b io kw is kx iw ky ja kz je la ji ks kt ku kv bi translated">运行<code class="du lb lc ld le b">npm install -g purescript</code></li><li id="c741" class="kn ko hh in b io kw is kx iw ky ja kz je la ji ks kt ku kv bi translated">运行<code class="du lb lc ld le b">npm install -g pulp bower</code></li><li id="6e25" class="kn ko hh in b io kw is kx iw ky ja kz je la ji ks kt ku kv bi translated">创建您的项目目录并运行<code class="du lb lc ld le b">pulp init</code>。</li><li id="e865" class="kn ko hh in b io kw is kx iw ky ja kz je la ji ks kt ku kv bi translated">然后你可以用<code class="du lb lc ld le b">pulp build</code>和<code class="du lb lc ld le b">pulp test</code>构建和测试代码。</li><li id="8af0" class="kn ko hh in b io kw is kx iw ky ja kz je la ji ks kt ku kv bi translated">您还可以使用PSCI作为控制台，类似于GHCI。</li></ol><p id="a32c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，我们需要NPM。Purescript是它自己的语言，但是我们想把它编译成可以在浏览器中使用的Javascript，所以我们需要Node.js。我们还会安装<code class="du lb lc ld le b">pulp</code>和<code class="du lb lc ld le b">bower</code>。纸浆将成为我们的建筑工具，就像阴谋集团一样。</p><p id="feb7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Bower是一个类似Hackage的包存储库。要在我们的程序中加入额外的库，可以使用<code class="du lb lc ld le b">bower</code>命令。例如，在本文后面的解决方案中，我们需要<code class="du lb lc ld le b">purescript-integers</code>。为此，运行以下命令:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="636f" class="ln jl hh le b fi lo lp l lq lr">bower install --save purescript-integers</span></pre><h1 id="ded5" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">简单的例子</h1><p id="8f43" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">一旦设置好了，就该开始涉猎这门语言了。虽然Purescript编译成Javascript，但语言本身看起来更像Haskell！我们将通过比较来检验这一点。假设我们想找出所有毕达哥拉斯三元组的总和小于100。下面是我们如何用Haskell编写这个解决方案:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="df95" class="ln jl hh le b fi lo lp l lq lr">sourceList :: [Int]<br/>sourceList = [1..100]</span><span id="ef11" class="ln jl hh le b fi ls lp l lq lr">allTriples :: [(Int, Int, Int)]<br/>allTriples =<br/>  [(a, b, c) | a &lt;- sourceList, b &lt;- sourceList, c &lt;- sourceList]</span><span id="e254" class="ln jl hh le b fi ls lp l lq lr">isPythagorean :: (Int, Int, Int) -&gt; Bool<br/>isPythagorean (a, b, c) = a ^ 2 + b ^ 2 == c ^ 2</span><span id="000f" class="ln jl hh le b fi ls lp l lq lr">isSmallEnough :: (Int, Int, Int) -&gt; Bool<br/>isSmallEnough (a, b, c) = a + b + c &lt; 100</span><span id="a417" class="ln jl hh le b fi ls lp l lq lr">finalAnswer :: [(Int, Int, Int)]<br/>finalAnswer = filter <br/>  (\t -&gt; isPythagorean t &amp;&amp; isSmallEnough t)<br/>    allTriples</span></pre><p id="df0b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们用Purescript制作一个模块来解决同样的问题。我们将从编写一个模块<code class="du lb lc ld le b">Pythagoras.purs</code>开始。下面是我们要编写的与上面的Haskell匹配的代码。我们将在下面逐一检查具体细节。</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="0e5a" class="ln jl hh le b fi lo lp l lq lr">module Pythagoras where</span><span id="1ee0" class="ln jl hh le b fi ls lp l lq lr">import Data.List (List, range, filter)<br/>import Data.Int (pow)<br/>import Prelude</span><span id="ac80" class="ln jl hh le b fi ls lp l lq lr">sourceList :: List Int<br/>sourceList = range 1 100</span><span id="901e" class="ln jl hh le b fi ls lp l lq lr">data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  }</span><span id="b972" class="ln jl hh le b fi ls lp l lq lr">allTriples :: List Triple<br/>allTriples = do<br/>  a &lt;- sourceList<br/>  b &lt;- sourceList<br/>  c &lt;- sourceList<br/>  pure $ Triple {a: a, b: b, c: c}</span><span id="0d7c" class="ln jl hh le b fi ls lp l lq lr">isPythagorean :: Triple -&gt; Boolean<br/>isPythagorean (Triple triple) =<br/>  (pow triple.a 2) + (pow triple.b 2) == (pow triple.c 2)</span><span id="a5eb" class="ln jl hh le b fi ls lp l lq lr">isSmallEnough :: Triple -&gt; Boolean<br/>isSmallEnough (Triple triple) =<br/>  (triple.a) + (triple.b) + (triple.c) &lt; 100</span><span id="53a5" class="ln jl hh le b fi ls lp l lq lr">finalAnswer :: List Triple<br/>finalAnswer = filter<br/>  (\triple -&gt; isPythagorean triple &amp;&amp; isSmallEnough triple) <br/>  allTriples</span></pre><p id="35ae" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">绝大多数情况下，事情都很相似！我们还有表情。这些表达式有类型签名。我们使用了很多类似的元素，比如列表和过滤器。总的来说，Purescript看起来更像Haskell而不是Javascript。但是有一些关键的区别。让我们从更高层次的概念开始探索这些。</p><h1 id="4de7" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">差异</h1><p id="6194" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">您在代码语法中看不到的一个区别是，Purescript不会被延迟评估。Javascript天生就是一种渴望的语言。因此，首先从一门渴望的语言开始，编译成JS要容易得多。</p><p id="d14c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是现在让我们考虑一下我们可以从代码中看到的一些不同之处。首先，我们必须进口更多的东西。默认情况下，Purescript不会导入一个<code class="du lb lc ld le b">Prelude</code>。你必须总是明确地把它带进来。我们还需要基本列表功能的导入。</p><p id="409a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">说到列表，Purescript缺少Haskell所拥有的语法优势。例如，我们需要使用<code class="du lb lc ld le b">List Int</code>而不是<code class="du lb lc ld le b">[Int]</code>。我们不能使用<code class="du lb lc ld le b">..</code>来创建范围，而是求助于<code class="du lb lc ld le b">range</code>功能。</p><p id="2799" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们也不能使用列表理解。相反，为了生成我们最初的三元组列表，我们使用列表单子。与列表一样，我们必须使用术语<code class="du lb lc ld le b">Unit</code>而不是<code class="du lb lc ld le b">()</code>:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="88e6" class="ln jl hh le b fi lo lp l lq lr">-- Comparable to main :: IO ()<br/>main :: Effect Unit<br/>main = do<br/>  log "Hello World!"</span></pre><p id="fe62" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下周，我们将讨论Purescript中的<code class="du lb lc ld le b">Effect</code>和Haskell中的<code class="du lb lc ld le b">IO</code>等一元结构之间的区别。</p><p id="4a20" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一个烦恼是多态类型签名更复杂。而在Haskell中，我们创建类型签名<code class="du lb lc ld le b">[a] -&gt; Int</code>没有问题，这在Purescript中将会失败。相反，我们必须始终使用<code class="du lb lc ld le b">forall</code>关键字:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="0e66" class="ln jl hh le b fi lo lp l lq lr">myListFunction :: forall a. List a -&gt; Int</span></pre><p id="e468" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个例子中没有出现的另一个东西是<code class="du lb lc ld le b">Number</code>类型。我们可以像在Haskell中一样在Purescript中使用<code class="du lb lc ld le b">Int</code>。但是除此之外，唯一重要的数字类型是<code class="du lb lc ld le b">Number</code>。这种类型也可以表示浮点值。这两者都被翻译成Javascript中的<code class="du lb lc ld le b">number</code>类型。</p><h1 id="1e77" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Purescript数据类型</h1><p id="dd55" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">但是现在让我们来看看我们的例子之间更明显的区别。在Purescript中，我们需要创建一个单独的<code class="du lb lc ld le b">Triple</code>类型，而不是使用一个简单的三元组。让我们通过考虑一般的数据类型来看看出现这种情况的原因。</p><p id="80f7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们愿意，我们可以像在Haskell中一样创建Purescript数据类型。因此，我们可以创建一个数据类型来表示毕达哥拉斯三元组:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="b834" class="ln jl hh le b fi lo lp l lq lr">data Triple = Triple a b c</span></pre><p id="73f9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这在Purescript中运行良好。但是，每当我们想从这个元素中提取一个单独的值时，它迫使我们使用模式匹配。我们可以在Haskell中解决这个问题，方法是使用记录语法为我们自己提供访问器函数:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="68c3" class="ln jl hh le b fi lo lp l lq lr">data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  }</span></pre><p id="f866" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种语法在Purescript中仍然有效，但是它的含义有所不同。在Elm中，Purescript记录是它自己的类型，就像普通的Javascript对象一样。例如，我们可以将它作为类型同义词，而不是完整的数据类型:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="de92" class="ln jl hh le b fi lo lp l lq lr">type Triple = { a :: Int, b :: Int, c :: Int}</span><span id="8ae8" class="ln jl hh le b fi ls lp l lq lr">oneTriple :: Triple<br/>oneTriple = { a: 5, b: 12, c: 13}</span></pre><p id="baec" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们不像在Javascript中那样使用字段名，而是使用“点语法”。下面是我们的类型同义词定义的样子:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="521c" class="ln jl hh le b fi lo lp l lq lr">type Triple = { a :: Int, b :: Int, c :: Int}</span><span id="91a8" class="ln jl hh le b fi ls lp l lq lr">oneTriple :: Triple<br/>oneTriple = { a: 5, b: 12, c: 13}</span><span id="fb0f" class="ln jl hh le b fi ls lp l lq lr">sumAB :: Triple -&gt; Int<br/>sumAB triple = triple.a + triple.b</span></pre><p id="732a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是令人困惑的地方。如果我们使用带有记录语法的完整数据类型，Purescript不再将它视为一个包含3个字段的项目。相反，我们会有一个只有一个字段的数据类型，而这个字段就是一条记录。因此，在使用访问函数之前，我们需要使用模式匹配来打开记录。</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="587f" class="ln jl hh le b fi lo lp l lq lr">data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  }</span><span id="2a58" class="ln jl hh le b fi ls lp l lq lr">oneTriple :: Triple<br/>oneTriple = Triple { a: 5, b: 12, c: 13}</span><span id="0918" class="ln jl hh le b fi ls lp l lq lr">sumAB :: Triple -&gt; Int<br/>sumAB (Triple triple) = triple.a + triple.b</span><span id="fa28" class="ln jl hh le b fi ls lp l lq lr">-- This is wrong!<br/>sumAB :: Triple -&gt; Int<br/>sumAB triple = triple.a + triple.b</span></pre><p id="6f18" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是一个相当大的陷阱。犯这个错误得到的编译器错误有点混乱，所以要小心！</p><h1 id="4fe5" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">纯手稿中的毕达哥拉斯</h1><p id="bdfb" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">有了这样的理解，上面的Purescript代码应该更有意义。但是我们会再看一遍，指出一些小细节。</p><p id="c242" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，让我们列出我们的资源清单。我们没有范围语法糖，但是我们仍然可以使用<code class="du lb lc ld le b">range</code>函数:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="6272" class="ln jl hh le b fi lo lp l lq lr">import Data.List (List, range, filter)</span><span id="7027" class="ln jl hh le b fi ls lp l lq lr">data Triple = Triple<br/>  { a :: Int<br/>  , b :: Int<br/>  , c :: Int<br/>  }</span><span id="7e18" class="ln jl hh le b fi ls lp l lq lr">sourceList :: List Int<br/>sourceList = range 1 100</span></pre><p id="ff7a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们没有列表理解。但是我们可以用do语法代替列表来获得同样的效果。注意，要在Purescript中使用do语法，我们必须导入<code class="du lb lc ld le b">Prelude</code>。特别是，我们需要<code class="du lb lc ld le b">bind</code>函数来实现它。现在让我们生成所有可能的三元组。</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="03b1" class="ln jl hh le b fi lo lp l lq lr">import Prelude</span><span id="cecb" class="ln jl hh le b fi ls lp l lq lr">…</span><span id="6504" class="ln jl hh le b fi ls lp l lq lr">allTriples :: List Triple<br/>allTriples = do<br/>  a &lt;- sourceList<br/>  b &lt;- sourceList<br/>  c &lt;- sourceList<br/>  pure $ Triple {a: a, b: b, c: c}</span></pre><p id="6d78" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">还要注意我们用<code class="du lb lc ld le b">pure</code>代替<code class="du lb lc ld le b">return</code>。现在让我们写过滤函数。这些将使用上面提到的记录模式匹配和访问。</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="8581" class="ln jl hh le b fi lo lp l lq lr">isPythagorean :: Triple -&gt; Boolean<br/>isPythagorean (Triple triple) = <br/>  (pow triple.a 2) + (pow triple.b 2) == (pow triple.c 2)</span><span id="ad55" class="ln jl hh le b fi ls lp l lq lr">isSmallEnough :: Triple -&gt; Boolean<br/>isSmallEnough (Triple triple) =<br/>  (triple.a) + (triple.b) + (triple.c) &lt; 100</span></pre><p id="0e59" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，我们可以像在Haskell中一样用<code class="du lb lc ld le b">filter</code>将它们结合起来:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="10a7" class="ln jl hh le b fi lo lp l lq lr">finalAnswer :: List Triple<br/>finalAnswer = filter <br/>  (\triple -&gt; isPythagorean triple &amp;&amp; isSmallEnough triple)<br/>  allTriples</span></pre><p id="c071" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们的解决方案将会奏效！</p><h1 id="a6c8" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="ee08" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">本周我们开始探索Purescript。从语法上来说，Purescript是Haskell的近亲。但是我们在这里强调了一些关于语言本质的关键区别。</p><p id="48a7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下周，我们将看看类型系统中其他一些重要的区别。我们将看到Purescript如何处理类型类和单子。之后，我们将会看到如何使用Purescript来构建一个web前端，并具有一些固体类型系统的安全性。</p><p id="eccc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下载我们的<a class="ae jj" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">制作清单</a>以获得更多你可以使用的酷库创意！</p></div></div>    
</body>
</html>