<html>
<head>
<title>Modularization Using Auto-Generated Pipeline With DataBathing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自动生成的流水线和数据清洗的模块化</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/modularization-using-auto-generated-pipeline-with-databathing-8f78b94dad08?source=collection_archive---------5-----------------------#2022-05-24">https://medium.com/walmartglobaltech/modularization-using-auto-generated-pipeline-with-databathing-8f78b94dad08?source=collection_archive---------5-----------------------#2022-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="01e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据管道微服务设计小指南(三)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d9445f76dae303706d940d3161ed9da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzHS4ms2pyBQwZgVe-OPQQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo credit: Pixabay</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="cae7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jz translated"><span class="l ka kb kc bm kd ke kf kg kh di">在</span>第一部分，<a class="ae ki" rel="noopener" href="/walmartglobaltech/modularization-using-python-and-docker-for-data-pipeline-1193bba7c207"> <strong class="ig hi">模块化使用Python和Docker进行数据管道</strong> </a>，<strong class="ig hi"> </strong>和第二部分<strong class="ig hi">，</strong> <a class="ae ki" rel="noopener" href="/walmartglobaltech/modularization-using-graph-style-serverless-pipeline-framework-fd41498c7769"> <strong class="ig hi">模块化使用图形风格的无服务器管道框架</strong> </a>中，我们有更多关于使用Docker或无服务器设计来采用数据管道的想法。然而，我们仍然需要编写Python代码来实现那些设计中所需的逻辑。</p><p id="7796" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我脑海中有一个声音说，我们能有一个<strong class="ig hi"> <em class="kj">自动驾驶</em> </strong>类型的框架来支持ETL工作吗？我们能从Apache Spark的强大功能和以SQL为中心的工具的简单性中获益吗？创建并使用<a class="ae ki" rel="noopener" href="/walmartglobaltech/databathing-a-framework-for-transferring-the-query-to-spark-code-484957a7e049">数据打包</a>后，我们就有了我们的<strong class="ig hi"> <em class="kj">自动驾驶</em> </strong>版本流水线框架现在<strong class="ig hi"> <em class="kj">。</em> </strong></p><p id="2235" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="kj">让我们一起来认识下生成器自动生成的管道框架吧！！！</em> </strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="49d6" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">议程</h1><ul class=""><li id="7e83" class="li lj hh ig b ih lk il ll ip lm it ln ix lo jb lp lq lr ls bi translated">数据管道的<strong class="ig hi"> <em class="kj">自动驾驶</em> </strong>是什么？</li><li id="ddf6" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">自动生成的管道框架</li><li id="ea3c" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">英雄:数据交换！！！</li><li id="b253" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">小演示</li><li id="64ca" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">当前支持的功能</li><li id="c64e" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">下一个路线图</li><li id="431b" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">贡献</li><li id="7184" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">摘要</li></ul></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="08b6" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是数据管道自动驾驶？</h1><p id="5c83" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">首先让我们看看汽车目前的自动驾驶仪是什么。根据我的理解有两个关键点。第一个是它可以帮助司机转向，加速和刹车，司机不需要采取额外的行动。二是安全建议仍需监管。简而言之，汽车可以处理大多数工作，只需要司机很少的投入。</p><blockquote class="mb mc md"><p id="75e5" class="ie if kj ig b ih ii ij ik il im in io me iq ir is mf iu iv iw mg iy iz ja jb ha bi translated">Autopilot能让你的车在车道内自动转向、加速和刹车。当前的自动驾驶功能需要主动的驾驶员监督，并且不能使车辆自主。</p></blockquote><p id="1f4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想用一些从汽车自动驾驶到<strong class="ig hi"> <em class="kj">自动数据管道</em> </strong>的概念。<strong class="ig hi"/></p><h1 id="529a" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">自动生成的管道框架</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mm"><img src="../Images/acbcc7b516dd750ceb40fa5cc9f213c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5T_0F5zozhB2Y3PDx7KuUg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 1. <em class="mn">Auto-Generated Pipeline Framework</em></figcaption></figure><p id="ec53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的框架是<strong class="ig hi"> <em class="kj">中的一个</em> </strong>。基于提取器、转换器和加载器的Yaml文件，该框架可以解析文件，自动生成数据管道，并自行触发管道。在图1中，我们可以在框架中找到三个不同的区域或特性。我将在下面逐一讨论:</p><h2 id="262e" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">解析引擎</h2><p id="f9e3" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">解析部分有三种不同的引擎。这些解析引擎可以将这些Yaml输入视为逻辑，并将逻辑转换为数据帧计算流，这些数据帧计算流将被发送到下一个引擎——Auto Gen Pipeln引擎。对于三种不同的YAML输入，我们有一些标准化的规则，并将在演示会议中进行更多解释。</p><h2 id="4475" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">汽车发电机管道发动机</h2><p id="336d" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">当Auto Gen Pipeln引擎获得数据框架计算流程时，它将根据流程和逻辑的顺序自动生成数据管道。任务运行引擎将拾取并运行整个Spark作业，无需用户输入任何代码。</p><h2 id="a32a" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">运行引擎的任务</h2><p id="e69b" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">在获得Spark作业序列后，这个正在运行的引擎将触发所有任务。它也没有任何工程输入。</p><p id="8cfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于这三种类型的引擎，我们可以发现，对于我们的<strong class="ig hi"> <em class="kj">自动数据流水线</em> </strong>，用户可以专注于逻辑本身(YAML)而不是编码和调试。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es nc"><img src="../Images/b57055db1d1cf631b0939630f83e7924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNQdWw164ItEt2UiUPcxyw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 2— <em class="mn">Auto-Generated Pipeline Framework with DataBathing</em></figcaption></figure><p id="2283" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图2是展示自动生成的工作流服务、数据打包服务和气流之间的关系和数据流的高级图表。因为我们正在像可重用组件一样构建所有这些服务，所以很容易插入和退出我们当前的流程。</p><h1 id="876e" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">英雄:数据交换！！！</h1><p id="01b6" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">我们可以找一个工具库(<strong class="ig hi">DataBathing<em class="kj">:</em></strong><a class="ae ki" rel="noopener" href="/walmartglobaltech/databathing-a-framework-for-transferring-the-query-to-spark-code-484957a7e049"><strong class="ig hi"><em class="kj">Blog</em></strong></a><strong class="ig hi"><em class="kj">，</em></strong><a class="ae ki" href="https://pypi.org/project/databathing/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="kj">Pypi</em></strong></a><strong class="ig hi"><em class="kj">，以及</em></strong><strong class="ig hi"><em class="kj">Github</em></strong>)。主要思想是将SQL查询解析成Spark代码。有兴趣的话可以看看博客和Github。否则，我们可以把它当作一个黑盒，我们框架的一部分。</p><h1 id="583e" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">小演示</h1><p id="1eb4" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">在这个演示中，我将介绍一个例子，这个例子已经在图1中讨论过了。这个ETL过程读取四个orc，转换并加载所需的结果。</p><h2 id="1dd9" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">0.先决条件</h2><p id="f425" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">请安装我们演示所需的DataBathing和所有软件包。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="d40d" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">1.采掘性企业</h2><p id="8b66" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">在下面的YAML中，我们在sources下面有三个不同的键:name、type和path。</p><ul class=""><li id="1f31" class="li lj hh ig b ih ii il im ip nf it ng ix nh jb lp lq lr ls bi translated">名称:这是将要加载的数据帧名称。</li><li id="457a" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">类型:来源，可以是orc、excel、MySQL等。</li><li id="f67e" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">路径或查询:源的位置或我们需要从数据库中获取的查询。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="b388" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">2.变形金刚(电影名)</h2><p id="99e7" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">我们可以通过两种不同的方式将它用于我们的逻辑设计:多个查询或带有语句的“<em class="kj">”。我们将在下面逐一讨论。此外，我们可以将它们结合起来。</em></p><ul class=""><li id="c073" class="li lj hh ig b ih ii il im ip nf it ng ix nh jb lp lq lr ls bi translated">steps:这是一个字典列表，提供了逻辑计算的步骤。</li><li id="0441" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">查询:我们有一个查询，需要在每个步骤中传递给逻辑设计。</li><li id="7945" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">名称:这是查询结果的数据框架的最终名称。</li><li id="205f" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">share_df:这是全局共享的数据帧列表，可以被其他组件使用。</li></ul><p id="b2d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="kj">多个查询</em> </strong></p><p id="4897" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的git中，第一步，我们计算一些事务数据，并将结果保存为fact_dim_df。在第二步中，通过使用fact_dim_df，我们生成聚合结果。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="7274" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="kj">同语句</em> </strong></p><p id="5954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逻辑链接的另一种方法是使用<em class="kj">“with statement”</em>。我们可以找到下面的例子。在<em class="kj">“with statement”</em>中，我们可以定义数据谱系。对于那些中间件结果，如步骤1、步骤2等。，我们将它们保存在管道中以备将来使用；您可以检查share_df变量。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="74d2" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">3.装载机</h2><p id="095c" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">在最后一个YAML中，我们在目标下有四个不同的键，它们与提取器非常相似:名称、类型、模式和路径。</p><ul class=""><li id="ea48" class="li lj hh ig b ih ii il im ip nf it ng ix nh jb lp lq lr ls bi translated">名称:我们在前面的步骤中处理的数据帧的名称。</li><li id="88ac" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">类型:我们需要保存的文件类型。</li><li id="0a9f" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">模式:所需的保存模式。</li><li id="f6b9" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">路径:所需的文件路径。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="1ffd" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated"><strong class="ak"> 4 .运行</strong></h2><p id="3211" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">我们有一个入口点，即workflowRunner，采用三个YAML文件来触发自动数据管道。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h1 id="efc1" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">当前支持的功能</h1><p id="6adf" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">所有功能将被分为三个领域:提取器、转换或加载器。利用这个带有数据绑定的框架实现了转换特性。对于Exactors和Loaders，我们需要在下一步中对连接特性进行更多的扩展。</p><h2 id="b7d9" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated"><strong class="ak">提取者:</strong></h2><ul class=""><li id="18d1" class="li lj hh ig b ih lk il ll ip lm it ln ix lo jb lp lq lr ls bi translated">大查询功能</li><li id="c229" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">谷歌云存储功能</li></ul><h2 id="c9b3" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">转换:</h2><ul class=""><li id="bb14" class="li lj hh ig b ih lk il ll ip lm it ln ix lo jb lp lq lr ls bi translated">自动检测到的功能</li><li id="495c" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">解析YAML特征—提取器、转换和加载器。</li><li id="4ce9" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">管道DAG功能</li></ul><h2 id="e46f" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">装载机:</h2><ul class=""><li id="09b5" class="li lj hh ig b ih lk il ll ip lm it ln ix lo jb lp lq lr ls bi translated">大查询功能</li><li id="de33" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">谷歌云存储功能</li></ul><h1 id="9751" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">下一个路线图</h1><p id="5537" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">我们需要做的一切就是将我们的逻辑输入三个Yaml文件。在这种情况下，我们可以创建一个用户界面，它将链接到服务的框架。在图3中，我们可以看到这个PAA的高级设计。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ni"><img src="../Images/088ebf5ce6bc3e4381f485a312b746f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4DSzs2aeGkaKtpcF2ic2w.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 3: Platform as a Service</figcaption></figure><p id="48b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了平台即服务计划之外，大部分即将推出的功能将侧重于与不同来源和目标的链接。我将其中一些写在下面:</p><h2 id="e8c7" class="mo kl hh bd km mp mq mr kq ms mt mu ku ip mv mw ky it mx my lc ix mz na lg nb bi translated">提取器和加载器:</h2><ul class=""><li id="6d3d" class="li lj hh ig b ih lk il ll ip lm it ln ix lo jb lp lq lr ls bi translated">MySql功能</li><li id="ff60" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">Azure SQL功能</li><li id="9005" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">MFT特色</li><li id="59d8" class="li lj hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">CSV/EXCEL</li></ul><h1 id="de41" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">贡献</h1><p id="e0f4" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">如果您需要更多自动生成的功能，您可以通过提出可以显示错误的问题，或创建具有新功能和描述问题的测试的PR来帮助改善这一点。如果你也提交了一个补丁，那么我也会感谢你。</p><p id="2c02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在下面的GitHub主页上找到我们自动生成的管道框架:</p><div class="nj nk ez fb nl nm"><a href="https://github.com/jason-jz-zhu/auto-generated-pipeline-framework/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hi fi z dy nr ea eb ns ed ef hg bi translated">GitHub-Jason-JZ-Zhu/自动生成管道框架</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">请安装数据隔离pip安装数据隔离片配置文件。片状CMD报告上传CMD主报告…</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jm nm"/></div></div></a></div><h1 id="4266" class="kk kl hh bd km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh bi translated">摘要</h1><p id="10ab" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip ly ir is it lz iv iw ix ma iz ja jb ha bi translated">通过使用这个<strong class="ig hi"> <em class="kj"> Next Generator自动生成的流水线框架</em> </strong>，你可以专注于领域逻辑本身，而不是花更多的时间在编码和调试上。</p></div></div>    
</body>
</html>