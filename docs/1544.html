<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison (Part 2): Cancelling Execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和rx Java——异步比较(第2部分):取消执行</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068?source=collection_archive---------0-----------------------#2018-04-11">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068?source=collection_archive---------0-----------------------#2018-04-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ba36fb284f19247ffafe5837b4dc1a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mUIl93pc1jwGi-Hn_N4Ew.png"/></div></div></figure><div class=""/><h1 id="e06d" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="8ba2" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这个博客系列中，我将比较<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>和<a class="ae kl" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，因为它们都试图解决Android开发中的一个常见问题:异步编程。</p><p id="6525" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在第1部分中，我们学习了如何在后台执行繁重的计算任务。如果我们想中断计算呢？</p><p id="ba04" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">第二部分是关于<strong class="jp ht">取消执行</strong>。</p><h1 id="aedd" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">取消执行是什么意思？</h1><p id="6bbf" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们希望能够取消用RxJava或协程创建的计算的执行。这个计算可以是异步的，也可以不是。</p><p id="9205" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这在Android开发的不同用例中是很重要的——最常见的可能是视图将要被销毁的时候。如果发生这种情况，我们可能希望取消正在进行的执行，比如网络请求、重对象初始化等。</p><h1 id="fc4a" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">RxJava</h1><p id="296c" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">和第1部分一样，我们将省略传输元素流的能力。如何用RxJava取消执行？</p><p id="fecf" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们想象我们用<a class="ae kl" href="http://reactivex.io/documentation/operators/interval.html" rel="noopener ugc nofollow" target="_blank">间隔操作符</a>创建一个<strong class="jp ht">计时器</strong>。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c9ab" class="la iq hs kw b fi lb lc l ld le">Observable.interval(1, TimeUnit.SECONDS)</span></pre><p id="9cf4" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">当您订阅这个可观察对象时，计时器将开始计时，它会在订阅后每秒钟向订阅者发送一个事件。</p><h2 id="4106" class="la iq hs bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">你怎么能取消那个计时器？</h2><p id="59f8" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当你订阅定时器(调用<code class="du ls lt lu kw b">.subscribe()</code>)时，它返回一个<code class="du ls lt lu kw b"><a class="ae kl" href="http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/Disposable.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">Disposable</strong></a></code> <strong class="jp ht">对象</strong>。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a9a2" class="la iq hs kw b fi lb lc l ld le"><strong class="kw ht">val disposable: Disposable</strong> = <br/>    Observable.interval(1, TimeUnit.SECONDS).<strong class="kw ht">subscribe()</strong></span></pre><p id="54b5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">您可以调用</strong> <code class="du ls lt lu kw b"><strong class="jp ht">dispose()</strong></code> <strong class="jp ht">对一次性对象取消执行</strong>。被观察者将完成发射物品。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3619" class="la iq hs kw b fi lb lc l ld le"><strong class="kw ht">disposable.dispose()</strong></span></pre><p id="b280" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">就是这样！我们已经取消了可观测数据所产生的异步计算。</p><h2 id="4af3" class="la iq hs bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">警告</h2><p id="ca92" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果您不使用任何create操作符(比如interval)手动创建自己的可观察对象，您不需要自己处理计算的取消。</p><p id="131e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这种可观察性是不会被取消的。如果我们想让它发生，<strong class="jp ht">我们需要在调用它之前检查发射器是否仍然被订阅。</strong></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="568d" class="la iq hs kw b fi lb lc l ld le">Observable.create&lt;Int&gt; <strong class="kw ht">{ </strong>emitter <strong class="kw ht">-&gt;<br/>   </strong>for (i in 1..5) {<br/>       <strong class="kw ht">if (!emitter.isDisposed) {<br/>           </strong>emitter.onNext(i)<br/>       } else {<br/>           <strong class="kw ht">break</strong><br/>       }<br/>   }<strong class="kw ht"><br/>       <br/>   </strong>emitter.onComplete()<br/>}</span></pre><p id="e53b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果订户不在那里，我们可以跳过发送其余的项目。如果我们不这样做，代码将继续运行，并根据<code class="du ls lt lu kw b"><a class="ae kl" href="https://github.com/ReactiveX/RxJava/blob/v2.1.12/src/main/java/io/reactivex/internal/operators/observable/ObservableCreate.java" rel="noopener ugc nofollow" target="_blank">Observable.create</a></code> <a class="ae kl" href="https://github.com/ReactiveX/RxJava/blob/v2.1.12/src/main/java/io/reactivex/internal/operators/observable/ObservableCreate.java" rel="noopener ugc nofollow" target="_blank">源代码</a>忽略<code class="du ls lt lu kw b">emitter.onNext(i)</code>调用。</p><h1 id="562c" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">协同程序</h1><p id="b2e5" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">协程是计算本身的一个实例。取消协程意味着停止执行它的暂停lambda。</p><blockquote class="lv"><p id="4955" class="lw lx hs bd ly lz ma mb mc md me kk dx translated">我们可以用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/" rel="noopener ugc nofollow" target="_blank">协程作业</a>取消执行，它是<a class="ae kl" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/" rel="noopener ugc nofollow" target="_blank">协程上下文</a>的一部分。</p></blockquote><p id="b4c2" class="pw-post-body-paragraph jn jo hs jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ha bi translated"><strong class="jp ht">协程作业公开了取消协程执行的方法</strong>。正如我们所料，这种方法被称为<code class="du ls lt lu kw b">cancel()</code>。</p><p id="4c3d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">例如，<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" rel="noopener ugc nofollow" target="_blank">协程生成器<strong class="jp ht"> <em class="mk"> launch </em> </strong> </a>返回它创建的协程的作业。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="688d" class="la iq hs kw b fi lb lc l ld le"><strong class="kw ht">val job</strong> = <strong class="kw ht"><em class="mk">launch</em></strong>(CommonPool) {<br/>    // my suspending block<br/>}</span></pre><p id="7c2a" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以给它赋值并调用cancel。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2e48" class="la iq hs kw b fi lb lc l ld le"><strong class="kw ht">job.cancel()</strong></span></pre><p id="8ce1" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这是一个从协程获取工作并取消它的例子。你能用不同的方法做它吗？是的，你也可以<strong class="jp ht">指定协程</strong>的工作。你可以通过多种方式做到这一点。</p><p id="3a74" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">一些协程构建器(例如launch和async)采用一个名为 <code class="du ls lt lu kw b"><strong class="jp ht">parent</strong></code>的<strong class="jp ht">命名参数，您可以用它为将要创建的协程设置作业。</strong></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ad44" class="la iq hs kw b fi lb lc l ld le">val parentJob = <em class="mk">Job</em>()</span><span id="fdd5" class="la iq hs kw b fi ml lc l ld le"><em class="mk">async</em>(CommonPool, <strong class="kw ht">parent = parentJob</strong>) {<strong class="kw ht"><br/>   </strong>// my suspending block<br/>}</span><span id="f0bb" class="la iq hs kw b fi ml lc l ld le">parentJob.cancel()</span></pre><p id="3fec" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这种方法的一个好处是，你可以与多个协程共享那个 <code class="du ls lt lu kw b"><strong class="jp ht">parentJob</strong></code> <strong class="jp ht">实例，所以当你调用<code class="du ls lt lu kw b">parentJob.cancel()</code>时，你将取消那些以<code class="du ls lt lu kw b">parentJob</code>为工作的协程的执行。</strong></p><p id="3a34" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这种方法<strong class="jp ht">类似于rx Java</strong><a class="ae kl" href="http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/CompositeDisposable.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">composited disposable</strong></a>，使用它可以一次处理多个订阅。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="749c" class="la iq hs kw b fi lb lc l ld le">val parentJob = <em class="mk">Job</em>()</span><span id="9996" class="la iq hs kw b fi ml lc l ld le">val deferred1<em class="mk"> = async</em>(CommonPool, <strong class="kw ht">parent = parentJob</strong>) {<strong class="kw ht"><br/>    </strong>// my suspending block<br/>}</span><span id="59bc" class="la iq hs kw b fi ml lc l ld le">val deferred2 = <em class="mk">async</em>(CommonPool, <strong class="kw ht">parent = parentJob</strong>) {<strong class="kw ht"><br/>    </strong>// my suspending block<br/>}</span><span id="4647" class="la iq hs kw b fi ml lc l ld le">parentJob.cancel() <strong class="kw ht">// Cancels both Coroutines</strong></span></pre><p id="dc9e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">注意:在不同的协程之间共享作业时，您应该小心。<strong class="jp ht">取消作业时，需要重新分配。您不能用作业</strong>启动另一个协程，您必须创建一个新的协程。</p><blockquote class="lv"><p id="19c9" class="lw lx hs bd ly lz ma mb mc md me kk dx translated">当您取消作业时，您需要重新分配它。</p></blockquote><p id="1770" class="pw-post-body-paragraph jn jo hs jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ha bi translated">另一种方法是结合协程上下文。您可以使用加号运算符来完成此操作。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fe26" class="la iq hs kw b fi lb lc l ld le">val parentJob = <em class="mk">Job</em>()</span><span id="155c" class="la iq hs kw b fi ml lc l ld le"><em class="mk">launch</em>(<strong class="kw ht">parentJob + CommonPool</strong>) {<strong class="kw ht"><br/>   </strong>// my suspending block<br/>}</span><span id="dc20" class="la iq hs kw b fi ml lc l ld le">parentJob.cancel()</span></pre><p id="97ec" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在这种情况下，<strong class="jp ht">该协程的结果协程上下文是</strong> <code class="du ls lt lu kw b"><strong class="jp ht">parentJob</strong></code> <strong class="jp ht">和</strong> <code class="du ls lt lu kw b"><strong class="jp ht">CommonPool</strong></code>的组合。线程策略将由<code class="du ls lt lu kw b">CommonPool</code>定义，作业值由<code class="du ls lt lu kw b">parentJob</code>定义。</p><p id="f6d6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果你想了解更多关于组合上下文的知识，你可以阅读Kotlin协同程序文档的这一部分。</p><h2 id="e236" class="la iq hs bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">警告</h2><p id="206c" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就像RxJava一样，你必须考虑协程中的取消。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fc4b" class="la iq hs kw b fi lb lc l ld le">val job = <em class="mk">launch</em>(CommonPool) {<strong class="kw ht"><br/>    </strong>for (i in 1..5) {<br/>        heavyComputation()<br/>    }<br/>}</span><span id="9340" class="la iq hs kw b fi ml lc l ld le">job.cancel()</span></pre><p id="3b5d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果我们尝试执行这个代码，它将重复繁重的计算5次，因为<strong class="jp ht">代码还没有准备好被取消</strong>。</p><p id="8894" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们该如何改进它？</p><p id="eb00" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">与我们检查订阅者是否在RxJava中一样，我们需要检查协程是否是活动的。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fd08" class="la iq hs kw b fi lb lc l ld le">val job = <em class="mk">launch</em>(CommonPool) {<strong class="kw ht"><br/>    </strong>for (i in 1..5) {<br/><strong class="kw ht">        if (!isActive) { break }<br/></strong>        heavyComputation()<br/>    }<br/>}</span><span id="970e" class="la iq hs kw b fi ml lc l ld le">job.cancel()</span></pre><p id="c53d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><code class="du ls lt lu kw b"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/is-active.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">isActive</strong></a></code>是一个可以在协程内部访问的内部变量(<code class="du ls lt lu kw b"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/coroutine-context.html" rel="noopener ugc nofollow" target="_blank">coroutineContext</a></code>是另一个变量)。</p><p id="8dc6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">标准协程库中的一些挂起函数为我们处理取消。我们来看看<code class="du ls lt lu kw b">delay</code>。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8692" class="la iq hs kw b fi lb lc l ld le">val job = <em class="mk">launch</em>(CommonPool) {<strong class="kw ht"><br/>    </strong>doSomething()<br/><strong class="kw ht">    delay(300) // It’s going to cancel at this point</strong><br/>    doSomething()<br/>}</span><span id="4298" class="la iq hs kw b fi ml lc l ld le">job.cancel()</span></pre><p id="2f8c" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-delay/" rel="noopener ugc nofollow" target="_blank"> Delay </a>是一个暂停函数，可以为我们处理取消。但是，如果你使用<code class="du ls lt lu kw b">Thread.sleep</code>而不是<code class="du ls lt lu kw b">delay</code>，因为它阻塞了线程，没有挂起协程，所以它不会取消它。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c810" class="la iq hs kw b fi lb lc l ld le">val job = <em class="mk">launch</em>(CommonPool) {<strong class="kw ht"><br/>    </strong>doSomething()<br/><strong class="kw ht">    Thread.sleep(300) // It’s NOT going to cancel execution<br/></strong>    doSomething()<br/>}</span><span id="944c" class="la iq hs kw b fi ml lc l ld le">job.cancel()</span></pre><p id="cbdd" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><code class="du ls lt lu kw b">Thread.sleep</code>并没有取消对我们的处决。它甚至不是一个暂停功能！即使我们调用了<code class="du ls lt lu kw b">job.cancel()</code>，那个协程也不会被取消。</p><p id="ce21" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在这种情况下，不应该使用<code class="du ls lt lu kw b">Thread.sleep</code>。如果你真的需要，取消协程的一个方法是检查它是否在线程阻塞之前和之后都是活动的。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="95e2" class="la iq hs kw b fi lb lc l ld le">val job = <em class="mk">launch</em>(CommonPool) {<strong class="kw ht"><br/>    </strong>doSomething()<br/><strong class="kw ht">    if (!isActive) return</strong><br/>    Thread.sleep(300) // It’s NOT going to cancel execution<strong class="kw ht"><br/>    if (!isActive) return</strong><br/>    doSomething()<br/>}</span><span id="aa6c" class="la iq hs kw b fi ml lc l ld le">job.cancel()</span></pre></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><h1 id="9fef" class="ip iq hs bd ir is mt iu iv iw mu iy iz ja mv jc jd je mw jg jh ji mx jk jl jm bi translated">接下来会发生什么？</h1><p id="5958" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">本系列的第三部分<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791">将是关于<strong class="jp ht">传输元素流</strong>。</a></p><p id="49ac" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">可观察和通道有什么区别？题材和播出渠道？</strong>下周不要错过第三部。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><h1 id="e963" class="ip iq hs bd ir is mt iu iv iw mu iy iz ja mv jc jd je mw jg jh ji mx jk jl jm bi translated">更多教育</h1><p id="2fe6" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">您是否错过了<strong class="jp ht">协程和RxJava比较第1部分</strong>？</p><div class="hg hh ez fb hi my"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd ht fi z dy nd ea eb ne ed ef hr bi translated">协程和rx Java——异步比较(第1部分):异步编程</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">第1部分—异步编程</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ho my"/></div></div></a></div><p id="887f" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">你想了解更多关于科特林的事吗？看看这篇文章！</p><div class="hg hh ez fb hi my"><a href="https://proandroiddev.com/kotlin-education-d0b958740d6a" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd ht fi z dy nd ea eb ne ed ef hr bi translated">科特林教育</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">超越基础</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">proandroiddev.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm ho my"/></div></div></a></div><p id="968d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">感谢阅读，</p><p id="e42b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>