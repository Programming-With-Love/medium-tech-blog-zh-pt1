<html>
<head>
<title>A small leak will sink a great ship</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个小漏洞会使一艘大船沉没</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/a-small-leak-will-sink-a-great-ship-efbae00f9a0f?source=collection_archive---------0-----------------------#2015-08-20">https://medium.com/square-corner-blog/a-small-leak-will-sink-a-great-ship-efbae00f9a0f?source=collection_archive---------0-----------------------#2015-08-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="132c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在Android Lollipop之前，警告对话框可能会导致Android应用程序中的内存泄漏。</h2></div><p id="66a5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">作者写的</em><a class="ae jt" href="https://twitter.com/Piwai" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">。</em></p><blockquote class="ju"><p id="9245" class="jv jw hh bd jx jy jz ka kb kc kd jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jt" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="5e77" class="pw-post-body-paragraph iw ix hh iy b iz ke ii jb jc kf il je jf kg jh ji jj kh jl jm jn ki jp jq jr ha bi translated"><em class="js">当我在构建LeakCanary的时候，这篇文章是作为一个内部邮件线程开始的。我发现了一个奇怪的内存泄漏，并开始挖掘，以找出发生了什么。</em></p><p id="24cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">TL；DR:在Android Lollipop之前，警告对话框可能会导致你的Android应用程序内存泄漏。</p><h1 id="ed63" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">艺术家</h1><p id="55b1" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">我收到来自<a class="ae jt" href="http://squ.re/leakcanary" rel="noopener ugc nofollow" target="_blank"> LeakCanary </a>的内存泄漏报告:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e26e" class="lp kk hh ll b fi lq lr l ls lt">* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;<br/>* references android.os.Message.obj<br/>* references com.example.MyActivity$MyDialogClickListener.this$0<br/>* leaks com.example.MyActivity.MainActivity instance</span></pre><p id="ae82" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简单地说:Picasso线程将消息实例作为堆栈上的局部变量。该消息引用了一个对话接口。OnClickListener，它本身引用了一个销毁的活动。</p><p id="46cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">局部变量通常是短命的，因为它们只存在于堆栈中。在线程上调用方法时，会分配一个堆栈帧。当该方法返回时，堆栈帧被清除，其所有局部变量被垃圾回收。如果一个局部变量导致了泄漏，那么这通常意味着一个线程正在循环或阻塞，并在这样做的同时保持对一个消息实例的引用。</p><p id="1786" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dimitris和我看了毕加索的源代码。</p><p id="1215" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调度员。DispatcherThread是一个简单的处理程序Thread:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="22a6" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">class</strong> <strong class="ll hi">DispatcherThread</strong> <strong class="ll hi">extends</strong> HandlerThread <strong class="ll hi">{</strong><br/>  DispatcherThread<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">super(</strong>Utils<strong class="ll hi">.</strong>THREAD_PREFIX <strong class="ll hi">+</strong> DISPATCHER_THREAD_NAME<strong class="ll hi">,</strong> THREAD_PRIORITY_BACKGROUND<strong class="ll hi">);</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="77e0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该线程通过以非常标准的方式实现的处理程序接收消息:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="765b" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">private</strong> <strong class="ll hi">static</strong> <strong class="ll hi">class</strong> <strong class="ll hi">DispatcherHandler</strong> <strong class="ll hi">extends</strong> Handler <strong class="ll hi">{</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">final</strong> Dispatcher dispatcher<strong class="ll hi">;</strong></span><span id="9ecb" class="lp kk hh ll b fi lu lr l ls lt">  <strong class="ll hi">public</strong> <strong class="ll hi">DispatcherHandler(</strong>Looper looper<strong class="ll hi">,</strong> Dispatcher dispatcher<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">super(</strong>looper<strong class="ll hi">);</strong><br/>    <strong class="ll hi">this.</strong>dispatcher <strong class="ll hi">=</strong> dispatcher<strong class="ll hi">;</strong><br/>  <strong class="ll hi">}</strong></span><span id="67c5" class="lp kk hh ll b fi lu lr l ls lt">  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">handleMessage(final</strong> Message msg<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">switch</strong> <strong class="ll hi">(</strong>msg<strong class="ll hi">.</strong>what<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>      <strong class="ll hi">case</strong> REQUEST_SUBMIT: <strong class="ll hi">{</strong><br/>        Action action <strong class="ll hi">=</strong> <strong class="ll hi">(</strong>Action<strong class="ll hi">)</strong> msg<strong class="ll hi">.</strong>obj<strong class="ll hi">;</strong><br/>        dispatcher<strong class="ll hi">.</strong>performSubmit<strong class="ll hi">(</strong>action<strong class="ll hi">);</strong><br/>        <strong class="ll hi">break;</strong><br/>      <strong class="ll hi">}</strong><br/>      <em class="js">// ... handles other types of messages</em><br/>    <strong class="ll hi">}</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="5fe2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个死胡同。Dispatcher中没有明显的bug。dispatcher handler . handle Message()，它通过局部变量以某种方式保存对消息的引用。</p><h1 id="a400" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">队列提示</h1><p id="d2e3" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">最终，出现了更多的内存泄漏报告。不仅仅是毕加索。我们会从各种类型的线程中得到局部变量泄漏，并且总会涉及到一个对话框点击监听器。泄漏线程有一个共同的特征:它们是工作线程，通过某种阻塞队列接收任务。</p><p id="219d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看HandlerThread是如何工作的:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="25ab" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">for</strong> <strong class="ll hi">(;;)</strong> <strong class="ll hi">{</strong><br/>    Message msg <strong class="ll hi">=</strong> queue<strong class="ll hi">.</strong>next<strong class="ll hi">();</strong> <em class="js">// might block</em><br/>    <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>msg <strong class="ll hi">==</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">return;</strong><br/>    <strong class="ll hi">}</strong><br/>    msg<strong class="ll hi">.</strong>target<strong class="ll hi">.</strong>dispatchMessage<strong class="ll hi">(</strong>msg<strong class="ll hi">);</strong><br/>    msg<strong class="ll hi">.</strong>recycleUnchecked<strong class="ll hi">();</strong><br/><strong class="ll hi">}</strong></span></pre><p id="c1ae" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">肯定有一个引用消息的局部变量。然而，它应该是非常短暂的，一旦循环迭代就被清除。</p><p id="2f93" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们试图通过编写一个带有阻塞队列的基本工作线程并只向它发送一条消息来进行复制:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="eb84" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">class</strong> <strong class="ll hi">MyMessage</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">final</strong> String message<strong class="ll hi">;</strong><br/>  MyMessage<strong class="ll hi">(</strong>String message<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">this.</strong>message <strong class="ll hi">=</strong> message<strong class="ll hi">;</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span><span id="638f" class="lp kk hh ll b fi lu lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">void</strong> <strong class="ll hi">startThread()</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">final</strong> BlockingQueue<strong class="ll hi">&lt;</strong>MyMessage<strong class="ll hi">&gt;</strong> queue <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> LinkedBlockingQueue<strong class="ll hi">&lt;&gt;();</strong><br/>  MyMessage message <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> <strong class="ll hi">MyMessage(</strong>"Hello Leaking World"<strong class="ll hi">);</strong><br/>  queue<strong class="ll hi">.</strong>offer<strong class="ll hi">(</strong>message<strong class="ll hi">);</strong><br/>  <strong class="ll hi">new</strong> <strong class="ll hi">Thread()</strong> <strong class="ll hi">{</strong><br/>    @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">run()</strong> <strong class="ll hi">{</strong><br/>      <strong class="ll hi">try</strong> <strong class="ll hi">{</strong><br/>        loop<strong class="ll hi">(</strong>queue<strong class="ll hi">);</strong><br/>      <strong class="ll hi">}</strong> <strong class="ll hi">catch</strong> <strong class="ll hi">(</strong>InterruptedException e<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">throw</strong> <strong class="ll hi">new</strong> <strong class="ll hi">RuntimeException(</strong>e<strong class="ll hi">);</strong><br/>      <strong class="ll hi">}</strong><br/>    <strong class="ll hi">}</strong><br/>  <strong class="ll hi">}.</strong>start<strong class="ll hi">();</strong><br/><strong class="ll hi">}</strong></span><span id="7467" class="lp kk hh ll b fi lu lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">void</strong> <strong class="ll hi">loop(</strong>BlockingQueue<strong class="ll hi">&lt;</strong>MyMessage<strong class="ll hi">&gt;</strong> queue<strong class="ll hi">)</strong> <strong class="ll hi">throws</strong> InterruptedException <strong class="ll hi">{</strong><br/>  <strong class="ll hi">while</strong> <strong class="ll hi">(true)</strong> <strong class="ll hi">{</strong><br/>    MyMessage message <strong class="ll hi">=</strong> queue<strong class="ll hi">.</strong>take<strong class="ll hi">();</strong><br/>    System<strong class="ll hi">.</strong>out<strong class="ll hi">.</strong>println<strong class="ll hi">(</strong>"Received: " <strong class="ll hi">+</strong> message<strong class="ll hi">);</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="1600" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦消息被打印到日志中，我们期望MyMessage实例被垃圾收集。</p><p id="ab21" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">LeakCanary不同意:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ce5a" class="lp kk hh ll b fi lq lr l ls lt">* GC ROOT thread com.example.MyActivity$2.&lt;Java Local&gt; (named 'Thread-110')<br/>* leaks com.example.MyActivity$MyMessage instance</span></pre><p id="1355" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们向队列发送新消息时，之前的消息被垃圾收集，新消息现在正在泄漏。</p><p id="d3e5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在VM中，每个堆栈帧都有一组局部变量。垃圾收集器是保守的:如果有一个引用可能是活的，它不会收集它。</p><p id="475e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">迭代之后，局部变量不再可达，但是它仍然保存对消息的引用。一旦引用不再可达，解释器/JIT就可以手动将它置空，但它只是保持引用活动，并假设不会造成任何损害。</p><p id="2dff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了证实这一理论，我们手动将引用设置为null并再次打印，这样null就不会被优化掉:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4d6d" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">void</strong> <strong class="ll hi">loop(</strong>BlockingQueue<strong class="ll hi">&lt;</strong>MyMessage<strong class="ll hi">&gt;</strong> queue<strong class="ll hi">)</strong> <strong class="ll hi">throws</strong> InterruptedException <strong class="ll hi">{</strong><br/>  <strong class="ll hi">while</strong> <strong class="ll hi">(true)</strong> <strong class="ll hi">{</strong><br/>    MyMessage message <strong class="ll hi">=</strong> queue<strong class="ll hi">.</strong>take<strong class="ll hi">();</strong><br/>    System<strong class="ll hi">.</strong>out<strong class="ll hi">.</strong>println<strong class="ll hi">(</strong>"Received: " <strong class="ll hi">+</strong> message<strong class="ll hi">);</strong><br/>    message <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>    System<strong class="ll hi">.</strong>out<strong class="ll hi">.</strong>println<strong class="ll hi">(</strong>"Now null: " <strong class="ll hi">+</strong> message<strong class="ll hi">);</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="daf1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在测试上述更改时，我们看到在Message设置为null后，MyMessage实例立即被垃圾收集。我们关于VM忽略本地消息变量的理论似乎得到了证实。</p><p id="839a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于这种泄漏可能在各种线程和队列实现中重现，我们现在可以肯定这是一个VM错误。最重要的是，我们只能在Dalvik虚拟机上复制它，而不是在ART虚拟机或JVM上。</p><h1 id="e13c" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">(回收)瓶中的信息</h1><p id="0ade" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">我们发现了一个bug，但是它会造成巨大的内存泄漏吗？让我们再来看看我们最初的泄漏:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5b7c" class="lp kk hh ll b fi lq lr l ls lt">* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;<br/>* references android.os.Message.obj<br/>* references com.example.MyActivity$MyDialogClickListener.this$0<br/>* leaks com.example.MyActivity.MainActivity instance</span></pre><p id="f44e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们发送给Picasso dispatcher线程的消息中，我们从未将Message.objto设置为dialog interface . onclick listener。它怎么会出现在那里呢？</p><p id="36db" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，在消息被处理后，它立即被回收，Message.obj被设置为null。只有这样，HandlerThread才会等待下一条消息，并暂时泄漏前一条消息:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="270f" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">for</strong> <strong class="ll hi">(;;)</strong> <strong class="ll hi">{</strong><br/>    Message msg <strong class="ll hi">=</strong> queue<strong class="ll hi">.</strong>next<strong class="ll hi">();</strong> <em class="js">// might block</em><br/>    <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>msg <strong class="ll hi">==</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">return;</strong><br/>    <strong class="ll hi">}</strong><br/>    msg<strong class="ll hi">.</strong>target<strong class="ll hi">.</strong>dispatchMessage<strong class="ll hi">(</strong>msg<strong class="ll hi">);</strong><br/>    msg<strong class="ll hi">.</strong>recycleUnchecked<strong class="ll hi">();</strong><br/><strong class="ll hi">}</strong></span></pre><p id="48aa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就这一点而言，我们知道泄漏的消息已被回收，因此不会保留其先前的内容。</p><p id="f931" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦回收，消息将返回到静态池中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d9cc" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">void</strong> <strong class="ll hi">recycleUnchecked()</strong> <strong class="ll hi">{</strong><br/>    <em class="js">// Mark the message as in use while it remains in the recycled object pool.</em><br/>    <em class="js">// Clear out all other details.</em><br/>    flags <strong class="ll hi">=</strong> FLAG_IN_USE<strong class="ll hi">;</strong><br/>    what <strong class="ll hi">=</strong> 0<strong class="ll hi">;</strong><br/>    arg1 <strong class="ll hi">=</strong> 0<strong class="ll hi">;</strong><br/>    arg2 <strong class="ll hi">=</strong> 0<strong class="ll hi">;</strong><br/>    obj <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>    replyTo <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>    sendingUid <strong class="ll hi">=</strong> <strong class="ll hi">-</strong>1<strong class="ll hi">;</strong><br/>    when <strong class="ll hi">=</strong> 0<strong class="ll hi">;</strong><br/>    target <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>    callback <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>    data <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong></span><span id="5b34" class="lp kk hh ll b fi lu lr l ls lt">    <strong class="ll hi">synchronized</strong> <strong class="ll hi">(</strong>sPoolSync<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>sPoolSize <strong class="ll hi">&lt;</strong> MAX_POOL_SIZE<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>            next <strong class="ll hi">=</strong> sPool<strong class="ll hi">;</strong><br/>            sPool <strong class="ll hi">=</strong> <strong class="ll hi">this;</strong><br/>            sPoolSize<strong class="ll hi">++;</strong><br/>        <strong class="ll hi">}</strong><br/>    <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="9a3e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有一个泄漏的空消息，可能会被重用并填充不同的内容。消息总是以相同的方式使用:从池中分离，填充内容，放入MessageQueue，然后处理，最后回收并放回池中。</p><p id="b337" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，它不应该长时间保存其内容。为什么我们最后总是泄露DialogInterface。OnClickListener实例？</p><h1 id="51f1" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">警报对话框</h1><p id="d19d" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">让我们创建一个简单的警告对话框:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8473" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">new</strong> AlertDialog<strong class="ll hi">.</strong>Builder<strong class="ll hi">(this)</strong><br/>    <strong class="ll hi">.</strong>setPositiveButton<strong class="ll hi">(</strong>"Baguette"<strong class="ll hi">,</strong> <strong class="ll hi">new</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>      @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>DialogInterface dialog<strong class="ll hi">,</strong> <strong class="ll hi">int</strong> which<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>        MyActivity<strong class="ll hi">.</strong>this<strong class="ll hi">.</strong>makeBread<strong class="ll hi">();</strong><br/>      <strong class="ll hi">}</strong><br/>    <strong class="ll hi">})</strong><br/>    <strong class="ll hi">.</strong>show<strong class="ll hi">();</strong></span></pre><p id="0dd6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，点击侦听器有一个对活动的引用。匿名类被翻译成以下代码:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ebbc" class="lp kk hh ll b fi lq lr l ls lt"><em class="js">// First anonymous class of MyActivity.</em><br/><strong class="ll hi">class</strong> <strong class="ll hi">MyActivity$0</strong> <strong class="ll hi">implements</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener <strong class="ll hi">{</strong><br/>  <strong class="ll hi">final</strong> MyActivity <strong class="ll hi">this</strong>$0<strong class="ll hi">;</strong><br/>  MyActivity$0<strong class="ll hi">(</strong>MyActivity <strong class="ll hi">this</strong>$0<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">this.</strong>this$0 <strong class="ll hi">=</strong> <strong class="ll hi">this</strong>$0<strong class="ll hi">;</strong><br/>  <strong class="ll hi">}</strong><br/>  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>DialogInterface dialog<strong class="ll hi">,</strong> <strong class="ll hi">int</strong> which<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">this</strong>$0<strong class="ll hi">.</strong>makeBread<strong class="ll hi">();</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span><span id="f820" class="lp kk hh ll b fi lu lr l ls lt"><strong class="ll hi">new</strong> AlertDialog<strong class="ll hi">.</strong>Builder<strong class="ll hi">(this)</strong><br/>    <strong class="ll hi">.</strong>setPositiveButton<strong class="ll hi">(</strong>"Baguette"<strong class="ll hi">,</strong> <strong class="ll hi">new</strong> <strong class="ll hi">MyActivity$0(this));</strong><br/>    <strong class="ll hi">.</strong>show<strong class="ll hi">();</strong></span></pre><p id="2a80" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在内部，AlertDialog将工作委托给AlertController:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0872" class="lp kk hh ll b fi lq lr l ls lt"><em class="js">/**</em><br/><em class="js"> * Sets a click listener or a message to be sent when the button is clicked.</em><br/><em class="js"> * You only need to pass one of {@code listener} or {@code msg}.</em><br/><em class="js"> */</em><br/><strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">setButton(int</strong> whichButton<strong class="ll hi">,</strong> CharSequence text<strong class="ll hi">,</strong><br/>        DialogInterface<strong class="ll hi">.</strong>OnClickListener listener<strong class="ll hi">,</strong> Message msg<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>msg <strong class="ll hi">==</strong> <strong class="ll hi">null</strong> <strong class="ll hi">&amp;&amp;</strong> listener <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>        msg <strong class="ll hi">=</strong> mHandler<strong class="ll hi">.</strong>obtainMessage<strong class="ll hi">(</strong>whichButton<strong class="ll hi">,</strong> listener<strong class="ll hi">);</strong><br/>    <strong class="ll hi">}</strong><br/>    <strong class="ll hi">switch</strong> <strong class="ll hi">(</strong>whichButton<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">case</strong> DialogInterface<strong class="ll hi">.</strong>BUTTON_POSITIVE<strong class="ll hi">:</strong><br/>            mButtonPositiveText <strong class="ll hi">=</strong> text<strong class="ll hi">;</strong><br/>            mButtonPositiveMessage <strong class="ll hi">=</strong> msg<strong class="ll hi">;</strong><br/>            <strong class="ll hi">break;</strong><br/>        <strong class="ll hi">case</strong> DialogInterface<strong class="ll hi">.</strong>BUTTON_NEGATIVE<strong class="ll hi">:</strong><br/>            mButtonNegativeText <strong class="ll hi">=</strong> text<strong class="ll hi">;</strong><br/>            mButtonNegativeMessage <strong class="ll hi">=</strong> msg<strong class="ll hi">;</strong><br/>            <strong class="ll hi">break;</strong><br/>        <strong class="ll hi">case</strong> DialogInterface<strong class="ll hi">.</strong>BUTTON_NEUTRAL<strong class="ll hi">:</strong><br/>            mButtonNeutralText <strong class="ll hi">=</strong> text<strong class="ll hi">;</strong><br/>            mButtonNeutralMessage <strong class="ll hi">=</strong> msg<strong class="ll hi">;</strong><br/>            <strong class="ll hi">break;</strong><br/>    <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="727a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，OnClickListener被包装在一个消息中，并被设置为alert controller . mbuttonpositivemessage。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4fef" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">private</strong> <strong class="ll hi">final</strong> View<strong class="ll hi">.</strong>OnClickListener mButtonHandler <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> View<strong class="ll hi">.</strong>OnClickListener<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>    @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>View v<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">final</strong> Message m<strong class="ll hi">;</strong><br/>        <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>v <strong class="ll hi">==</strong> mButtonPositive <strong class="ll hi">&amp;&amp;</strong> mButtonPositiveMessage <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>            m <strong class="ll hi">=</strong> Message<strong class="ll hi">.</strong>obtain<strong class="ll hi">(</strong>mButtonPositiveMessage<strong class="ll hi">);</strong><br/>        <strong class="ll hi">}</strong> <strong class="ll hi">else</strong> <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>v <strong class="ll hi">==</strong> mButtonNegative <strong class="ll hi">&amp;&amp;</strong> mButtonNegativeMessage <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>            m <strong class="ll hi">=</strong> Message<strong class="ll hi">.</strong>obtain<strong class="ll hi">(</strong>mButtonNegativeMessage<strong class="ll hi">);</strong><br/>        <strong class="ll hi">}</strong> <strong class="ll hi">else</strong> <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>v <strong class="ll hi">==</strong> mButtonNeutral <strong class="ll hi">&amp;&amp;</strong> mButtonNeutralMessage <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>            m <strong class="ll hi">=</strong> Message<strong class="ll hi">.</strong>obtain<strong class="ll hi">(</strong>mButtonNeutralMessage<strong class="ll hi">);</strong><br/>        <strong class="ll hi">}</strong> <strong class="ll hi">else</strong> <strong class="ll hi">{</strong><br/>            m <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>        <strong class="ll hi">}</strong><br/>        <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>m <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>            m<strong class="ll hi">.</strong>sendToTarget<strong class="ll hi">();</strong><br/>        <strong class="ll hi">}</strong><br/>        <em class="js">// Post a message so we dismiss after the above handlers are executed.</em><br/>        mHandler<strong class="ll hi">.</strong>obtainMessage<strong class="ll hi">(</strong>ButtonHandler<strong class="ll hi">.</strong>MSG_DISMISS_DIALOG<strong class="ll hi">,</strong> mDialogInterface<strong class="ll hi">)</strong><br/>                <strong class="ll hi">.</strong>sendToTarget<strong class="ll hi">();</strong><br/>    <strong class="ll hi">}</strong><br/><strong class="ll hi">};</strong></span></pre><p id="4c3f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意:m = message . obtain(mButtonPositiveMessage)。</p><p id="272a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">消息被克隆，其副本被发送。这意味着原始消息永远不会被发送，因此永远不会被回收。所以它会永远保存它的内容，直到垃圾被收集。</p><p id="d5a2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们假设，由于HandlerThread本地引用，该消息在从回收池获得之前已经泄漏了。该对话框最终被垃圾回收，并释放对mButtonPositiveMessage保存的消息的引用。</p><p id="df2d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，由于消息已经泄漏，它不会被垃圾收集。它的内容、OnClickListener以及活动也是如此。</p><h1 id="f9b7" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">犯罪的确凿证据</h1><p id="c53a" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">我们能证明我们的理论吗？</p><p id="3f09" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要向HandlerThread发送一条消息，让它被消费和回收，而不要向那个线程发送任何其他消息，以免它泄漏最后一条消息。然后，我们需要显示一个带有按钮的对话框，并希望这个对话框将从池中获得相同的消息。这很有可能发生，因为一旦回收，消息将成为池中的第一个。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9835" class="lp kk hh ll b fi lq lr l ls lt">HandlerThread background <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> <strong class="ll hi">HandlerThread(</strong>"BackgroundThread"<strong class="ll hi">);</strong><br/>background<strong class="ll hi">.</strong>start<strong class="ll hi">();</strong><br/>Handler backgroundhandler <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> <strong class="ll hi">Handler(</strong>background<strong class="ll hi">.</strong>getLooper<strong class="ll hi">());</strong><br/><strong class="ll hi">final</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener clickListener <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>DialogInterface dialog<strong class="ll hi">,</strong> <strong class="ll hi">int</strong> which<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    MyActivity<strong class="ll hi">.</strong>this<strong class="ll hi">.</strong>makeCroissants<strong class="ll hi">();</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">};</strong><br/>backgroundhandler<strong class="ll hi">.</strong>post<strong class="ll hi">(new</strong> <strong class="ll hi">Runnable()</strong> <strong class="ll hi">{</strong><br/>  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">run()</strong> <strong class="ll hi">{</strong><br/>    runOnUiThread<strong class="ll hi">(new</strong> <strong class="ll hi">Runnable()</strong> <strong class="ll hi">{</strong><br/>      @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">run()</strong> <strong class="ll hi">{</strong><br/>        <strong class="ll hi">new</strong> AlertDialog<strong class="ll hi">.</strong>Builder<strong class="ll hi">(</strong>MyActivity<strong class="ll hi">.</strong>this<strong class="ll hi">)</strong> <em class="js">//</em><br/>            <strong class="ll hi">.</strong>setPositiveButton<strong class="ll hi">(</strong>"Baguette"<strong class="ll hi">,</strong> clickListener<strong class="ll hi">)</strong> <em class="js">//</em><br/>            <strong class="ll hi">.</strong>show<strong class="ll hi">();</strong><br/>      <strong class="ll hi">}</strong><br/>    <strong class="ll hi">});</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">});</strong></span></pre><p id="ff91" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们运行上面的代码，然后旋转屏幕来破坏活动，这个活动很有可能会泄漏。</p><p id="1116" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">LeakCanary正确地检测到泄漏:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c3a6" class="lp kk hh ll b fi lq lr l ls lt">* GC ROOT thread android.os.HandlerThread.&lt;Java Local&gt; (named 'BackgroundThread')<br/>* references android.os.Message.obj<br/>* references com.example.MyActivity$1.this$0 (anonymous class implements android.content.DialogInterface$OnClickListener)<br/>* leaks com.example.MyActivity instance</span></pre><p id="4a9a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经正确地再现了它，让我们看看我们能做些什么来修复它。</p><h1 id="18fa" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">启动修复</h1><p id="d056" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">只支持使用ART VM的设备，即Android 5+。不再有虫子了！还有，没有更多的用户。</p><h1 id="8e74" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">这个修不好</h1><p id="e172" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">您还可以假设这些泄漏的影响有限，您有更好的事情要做，或者可能有更简单的泄漏要修复。LeakCanary默认忽略所有message leaks<a class="ae jt" href="https://github.com/square/leakcanary/blob/v1.3.1/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java#L112" rel="noopener ugc nofollow" target="_blank"/>。但是要注意，一个活动在内存中保存了它的整个视图层次结构，可以保留几兆字节。</p><h1 id="52b7" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">应用程序修复</h1><p id="59f2" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">确保您的对话界面。OnClickListener实例不保存对活动实例的强引用，例如，在分离对话框窗口时清除对侦听器的引用。这里有一个包装类来简化它:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3b36" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">public</strong> <strong class="ll hi">final</strong> <strong class="ll hi">class</strong> <strong class="ll hi">DetachableClickListener</strong> <strong class="ll hi">implements</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener <strong class="ll hi">{</strong></span><span id="ef69" class="lp kk hh ll b fi lu lr l ls lt">  <strong class="ll hi">public</strong> <strong class="ll hi">static</strong> DetachableClickListener <strong class="ll hi">wrap(</strong>DialogInterface<strong class="ll hi">.</strong>OnClickListener delegate<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">return</strong> <strong class="ll hi">new</strong> <strong class="ll hi">DetachableClickListener(</strong>delegate<strong class="ll hi">);</strong><br/>  <strong class="ll hi">}</strong></span><span id="10dd" class="lp kk hh ll b fi lu lr l ls lt">  <strong class="ll hi">private</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener delegateOrNull<strong class="ll hi">;</strong></span><span id="cc67" class="lp kk hh ll b fi lu lr l ls lt">  <strong class="ll hi">private</strong> <strong class="ll hi">DetachableClickListener(</strong>DialogInterface<strong class="ll hi">.</strong>OnClickListener delegate<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">this.</strong>delegateOrNull <strong class="ll hi">=</strong> delegate<strong class="ll hi">;</strong><br/>  <strong class="ll hi">}</strong></span><span id="b581" class="lp kk hh ll b fi lu lr l ls lt">  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>DialogInterface dialog<strong class="ll hi">,</strong> <strong class="ll hi">int</strong> which<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    <strong class="ll hi">if</strong> <strong class="ll hi">(</strong>delegateOrNull <strong class="ll hi">!=</strong> <strong class="ll hi">null)</strong> <strong class="ll hi">{</strong><br/>      delegateOrNull<strong class="ll hi">.</strong>onClick<strong class="ll hi">(</strong>dialog<strong class="ll hi">,</strong> which<strong class="ll hi">);</strong><br/>    <strong class="ll hi">}</strong><br/>  <strong class="ll hi">}</strong></span><span id="7c2f" class="lp kk hh ll b fi lu lr l ls lt">  <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">clearOnDetach(</strong>Dialog dialog<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    dialog<strong class="ll hi">.</strong>getWindow<strong class="ll hi">()</strong><br/>        <strong class="ll hi">.</strong>getDecorView<strong class="ll hi">()</strong><br/>        <strong class="ll hi">.</strong>getViewTreeObserver<strong class="ll hi">()</strong><br/>        <strong class="ll hi">.</strong>addOnWindowAttachListener<strong class="ll hi">(new</strong> <strong class="ll hi">OnWindowAttachListener()</strong> <strong class="ll hi">{</strong><br/>          @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onWindowAttached()</strong> <strong class="ll hi">{</strong> <strong class="ll hi">}</strong><br/>          @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onWindowDetached()</strong> <strong class="ll hi">{</strong><br/>            delegateOrNull <strong class="ll hi">=</strong> <strong class="ll hi">null;</strong><br/>          <strong class="ll hi">}</strong><br/>        <strong class="ll hi">});</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">}</strong></span></pre><p id="f77f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后您可以包装所有OnClickListener实例:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d766" class="lp kk hh ll b fi lq lr l ls lt">DetachableClickListener clickListener <strong class="ll hi">=</strong> wrap<strong class="ll hi">(new</strong> DialogInterface<strong class="ll hi">.</strong>OnClickListener<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>  @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">onClick(</strong>DialogInterface dialog<strong class="ll hi">,</strong> <strong class="ll hi">int</strong> which<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>    MyActivity<strong class="ll hi">.</strong>this<strong class="ll hi">.</strong>makeCroissants<strong class="ll hi">();</strong><br/>  <strong class="ll hi">}</strong><br/><strong class="ll hi">});</strong></span><span id="a7c5" class="lp kk hh ll b fi lu lr l ls lt">AlertDialog dialog <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> AlertDialog<strong class="ll hi">.</strong>Builder<strong class="ll hi">(this)</strong> <em class="js">//</em><br/>    <strong class="ll hi">.</strong>setPositiveButton<strong class="ll hi">(</strong>"Baguette"<strong class="ll hi">,</strong> clickListener<strong class="ll hi">)</strong> <em class="js">//</em><br/>    <strong class="ll hi">.</strong>create<strong class="ll hi">();</strong><br/>clickListener<strong class="ll hi">.</strong>clearOnDetach<strong class="ll hi">(</strong>dialog<strong class="ll hi">);</strong><br/>dialog<strong class="ll hi">.</strong>show<strong class="ll hi">();</strong></span></pre><h1 id="33dc" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">水管工的修理</h1><p id="c01e" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">定期刷新工作线程:当处理线程空闲时发送一条空消息，以确保没有消息长时间泄漏。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7f86" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">static</strong> <strong class="ll hi">void</strong> <strong class="ll hi">flushStackLocalLeaks(</strong>Looper looper<strong class="ll hi">)</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">final</strong> Handler handler <strong class="ll hi">=</strong> <strong class="ll hi">new</strong> <strong class="ll hi">Handler(</strong>looper<strong class="ll hi">);</strong><br/>  handler<strong class="ll hi">.</strong>post<strong class="ll hi">(new</strong> <strong class="ll hi">Runnable()</strong> <strong class="ll hi">{</strong><br/>    @Override <strong class="ll hi">public</strong> <strong class="ll hi">void</strong> <strong class="ll hi">run()</strong> <strong class="ll hi">{</strong><br/>      Looper<strong class="ll hi">.</strong>myQueue<strong class="ll hi">().</strong>addIdleHandler<strong class="ll hi">(new</strong> MessageQueue<strong class="ll hi">.</strong>IdleHandler<strong class="ll hi">()</strong> <strong class="ll hi">{</strong><br/>        @Override <strong class="ll hi">public</strong> <strong class="ll hi">boolean</strong> <strong class="ll hi">queueIdle()</strong> <strong class="ll hi">{</strong><br/>          handler<strong class="ll hi">.</strong>sendMessageDelayed<strong class="ll hi">(</strong>handler<strong class="ll hi">.</strong>obtainMessage<strong class="ll hi">(),</strong> 1000<strong class="ll hi">);</strong><br/>          <strong class="ll hi">return</strong> <strong class="ll hi">true;</strong><br/>        <strong class="ll hi">}</strong><br/>      <strong class="ll hi">});</strong><br/>    <strong class="ll hi">}</strong><br/>  <strong class="ll hi">});</strong><br/><strong class="ll hi">}</strong></span></pre><p id="f3e3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这对库很有用，因为你不能控制开发人员要用对话框做什么。我们在Picasso中使用了它，并为其他类型的工作线程做了类似的<a class="ae jt" href="https://github.com/square/picasso/pull/932" rel="noopener ugc nofollow" target="_blank">修复</a>。</p><h1 id="98cb" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">结论</h1><p id="11d6" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">正如我们所看到的，一个微妙的和意想不到的虚拟机行为可能会造成一个小的泄漏，最终占用大量内存，最终导致您的应用程序崩溃，出现out of memory错误。一个小漏洞会使一艘大船沉没。</p><p id="ac44" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">非常感谢<a class="ae jt" href="https://twitter.com/jhumphries_sq" rel="noopener ugc nofollow" target="_blank">乔希·汉弗莱斯</a>、<a class="ae jt" href="https://twitter.com/jessewilson" rel="noopener ugc nofollow" target="_blank">杰西·威尔森</a>、<a class="ae jt" href="https://twitter.com/maniksurtani" rel="noopener ugc nofollow" target="_blank">马尼克·苏尔塔尼</a>和<a class="ae jt" href="https://twitter.com/WouterCoekaerts" rel="noopener ugc nofollow" target="_blank">沃特·科卡耶茨</a>在我们的内部邮件线程中给予的帮助。</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><div class="lg lh li lj fd mc"><a href="https://twitter.com/Piwai" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hi fi z dy mh ea eb mi ed ef hg bi translated">皮埃尔-伊夫·里考(@皮瓦伊)|推特</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">Pierre-Yves Ricau (@Piwai)的最新推文。安卓贝克@广场。巴黎/旧金山</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">twitter.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq mr mc"/></div></div></a></div></div></div>    
</body>
</html>