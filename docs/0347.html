<html>
<head>
<title>RxJava to Kotlin coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJava到Kotlin协同程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/rxjava-to-kotlin-coroutines-1204c896a700?source=collection_archive---------0-----------------------#2018-05-02">https://medium.com/androiddevelopers/rxjava-to-kotlin-coroutines-1204c896a700?source=collection_archive---------0-----------------------#2018-05-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e30c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">观察吊带</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/9b70afbd676d30efd44663d704c596f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0lCKiqsFBjlWOLYdQSUfw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://flic.kr/p/7TkwCt" rel="noopener ugc nofollow" target="_blank">Threads</a> by <a class="ae jm" href="https://www.flickr.com/photos/46435106@N06/" rel="noopener ugc nofollow" target="_blank">Eric LaMontagne</a></figcaption></figure><p id="5822" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">好吧，我知道这是一个有点扣人心弦的标题，但这是我能想到的最好的了。这篇文章总结了我如何将一个大量使用<a class="ae jm" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>的应用重构为一个也使用Kotlin <a class="ae jm" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank">协程</a>的应用。具体来说，我将讨论将<a class="ae jm" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank">单个</a> / <a class="ae jm" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html" rel="noopener ugc nofollow" target="_blank">可能是</a> / <a class="ae jm" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html" rel="noopener ugc nofollow" target="_blank">可完成的</a>源代码切换到协程。</p><h2 id="2ea2" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">该应用程序</h2><p id="a0fc" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">首先，简单介绍一下<a class="ae jm" href="https://github.com/chrisbanes/tivi" rel="noopener ugc nofollow" target="_blank">应用</a>的架构。我的大部分业务逻辑都建立在所谓的'<a class="ae jm" href="https://github.com/chrisbanes/tivi/blob/master/calls/src/main/java/me/banes/chris/tivi/calls/Call.kt" rel="noopener ugc nofollow" target="_blank">调用</a>'中:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="d792" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">interface </strong>Call&lt;<strong class="lk hi">in </strong>Param, Output&gt; {<br/>    <strong class="lk hi">fun </strong>data(param: Param): Flowable&lt;Output&gt;<br/>    <strong class="lk hi">fun </strong>refresh(param: Param): Completable<br/>}</span></pre><p id="58b4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如您所见，每个电话有两个主要职责:</p><ol class=""><li id="3c82" class="ls lt hh jp b jq jr jt ju jw lu ka lv ke lw ki lx ly lz ma bi translated">它的<code class="du mb mc md lk b">data()</code>方法公开了与调用相关的数据流。这就返回了一个<a class="ae jm" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" rel="noopener ugc nofollow" target="_blank">易流</a>，而大部分时候只是一个易流从<a class="ae jm" href="https://developer.android.com/reference/android/arch/persistence/room/Dao.html" rel="noopener ugc nofollow" target="_blank">室捣</a>。然后一个视图模型订阅它并将数据传递给UI，等等。</li><li id="db38" class="ls lt hh jp b jq me jt mf jw mg ka mh ke mi ki lx ly lz ma bi translated">其<code class="du mb mc md lk b">refresh()</code>法。希望这是不言自明的，它触发了数据的刷新。大多数实现将从网络获取、映射实体，然后更新<a class="ae jm" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank">房间</a>数据库。这是当前返回的一个<a class="ae jm" href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html" rel="noopener ugc nofollow" target="_blank">Completable </a>,<a class="ae jm" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank">ViewModel</a>将订阅该Completable以启动“动作”。</li></ol><h2 id="ddc1" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">那么我打算在哪里安装协程呢？</h2><p id="a0b0" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">我的目标是让<code class="du mb mc md lk b">refresh()</code>成为一个暂停函数:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="ce62" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">interface </strong>Call&lt;<strong class="lk hi">in </strong>Param, Output&gt; {<br/>    <strong class="lk hi">fun </strong>data(param: Param): Flowable&lt;Output&gt;<br/>    <strong class="lk hi">suspend fun </strong>refresh(param: Param)<br/>}</span></pre><p id="096f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">一旦我做了那个改变，所有的调用实现都开始抱怨，因为函数签名改变了。幸运的是，<a class="ae jm" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx2" rel="noopener ugc nofollow" target="_blank"><strong class="jp hi">kot linx-coroutines-rx2</strong></a>扩展库为RxJava类single类型提供了扩展方法，允许我们<code class="du mb mc md lk b">await()</code>它们的完成。因此，在每个实现的Rx链末端快速粘贴<code class="du mb mc md lk b">.await()</code>就可以修复构建。</p><p id="2511" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们现在对协程的使用非常粗糙和愚蠢！但是，嘿，这是一个开始，一切仍然工作。</p><p id="0656" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">下一步是开始转换<code class="du mb mc md lk b">refresh()</code>协程感知下的所有代码，并移除不需要的RxJava。在这一点上，你可能想知道我说的“协程感知”是什么意思，这都与线程有关。</p><h2 id="8deb" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">穿线</h2><p id="0cfe" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">使用RxJava，我有不同的<a class="ae jm" href="https://github.com/ReactiveX/RxJava/wiki/Scheduler" rel="noopener ugc nofollow" target="_blank">调度器</a>用于不同类型的任务。这是用一个数据类实现的，这个数据类被注入到将Rx操作符链接在一起的任何地方。</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="c162" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">data class </strong>AppRxSchedulers(<br/>    <strong class="lk hi">val database</strong>: Scheduler,<br/>    <strong class="lk hi">val disk</strong>: Scheduler,<br/>    <strong class="lk hi">val network</strong>: Scheduler,<br/>    <strong class="lk hi">val main</strong>: Scheduler<br/>)</span><span id="3d28" class="kj kk hh lk b fi mj lp l lq lr">@Singleton<br/>@Provides<br/><strong class="lk hi">fun </strong>provideRxSchedulers() = AppRxSchedulers(<br/>        <em class="mk">database</em> = Schedulers.single(),<br/>        <em class="mk">disk</em> = Schedulers.io(),<br/>        <em class="mk">network</em> = Schedulers.io(),<br/>        <em class="mk">main</em> = AndroidSchedulers.mainThread()<br/>)</span></pre><p id="6a55" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我认为最重要的是数据库调度程序。这是因为我想强制单线程读取，确保数据完整性，不锁定SQLite。</p><p id="2c22" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">对于协程，我想做同样的事情，确保RxJava和协程都使用相同的线程池。事实证明，使用<a class="ae jm" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx2" rel="noopener ugc nofollow" target="_blank"><strong class="jp hi">kot linx-coroutines-rx2</strong></a>扩展库相对容易。它在Scheduler上添加了一个扩展方法，将它包装到一个协同调度器中。使用它，我将我的调度程序转换成调度程序，并注入它们。</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="5e8e" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">data class </strong>AppCoroutineDispatchers(<br/>    <strong class="lk hi">val database</strong>: CoroutineDispatcher,<br/>    <strong class="lk hi">val disk</strong>: CoroutineDispatcher,<br/>    <strong class="lk hi">val network</strong>: CoroutineDispatcher,<br/>    <strong class="lk hi">val main</strong>: CoroutineDispatcher<br/>)</span><span id="4706" class="kj kk hh lk b fi mj lp l lq lr">@Singleton<br/>@Provides<br/><strong class="lk hi">fun </strong>provideDispatchers(schedulers: AppRxSchedulers) = <br/>    AppCoroutineDispatchers(<br/>        <em class="mk">database</em> = schedulers.<strong class="lk hi">database</strong>.<em class="mk">asCoroutineDispatcher</em>(),<br/>        <em class="mk">disk</em> = schedulers.<strong class="lk hi">disk</strong>.<em class="mk">asCoroutineDispatcher</em>(),<br/>        <em class="mk">network</em> = schedulers.<strong class="lk hi">network</strong>.<em class="mk">asCoroutineDispatcher</em>(),<br/>        <em class="mk">main</em> = <em class="mk">UI<br/>    </em>)</span></pre><p id="f65d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如您所见，我目前使用RxJava调度程序作为源代码。将来，我可能会把它调换一下，让调度程序从调度程序中派生出来。</p><h2 id="3241" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">更换线程</h2><p id="e0c1" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">所以我让我的调度程序和调度程序共享相同的线程，但是在我们的操作中使用它们怎么样呢？</p><p id="b0db" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">RxJava通过它的<code class="du mb mc md lk b">subscribeOn()</code>和<code class="du mb mc md lk b">observeOn()</code>方法使得将不同的线程观察器链接在一起变得非常容易。这里有一个<code class="du mb mc md lk b">refresh()</code>方法的例子，其中我使用我的<code class="du mb mc md lk b">network</code>调度程序获取网络响应并将其映射到内部实体，然后使用<code class="du mb mc md lk b">database</code>调度程序存储结果。</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="c4ea" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">override fun </strong>refresh(): Completable {<br/>    <strong class="lk hi">return </strong>trakt.users().profile(UserSlug.ME).toRxSingle()<br/>            .subscribeOn(schedulers.network)<br/>            .map <strong class="lk hi">{<br/>                </strong>TraktUser(username = <strong class="lk hi">it</strong>.<strong class="lk hi">username</strong>, name = <strong class="lk hi">it</strong>.<strong class="lk hi">name</strong>)<br/>            <strong class="lk hi">}</strong><br/>            .observeOn(schedulers.database)<br/>            .doOnSuccess <strong class="lk hi">{<br/>                dao</strong>.insert(it)<br/>            <strong class="lk hi">}</strong><br/>            .toCompletable()<br/>}<br/><br/><strong class="lk hi">override fun </strong>data(): Flowable&lt;TraktUser&gt; {<br/>    <strong class="lk hi">return </strong>dao.getTraktUser()<br/>            .subscribeOn(schedulers.database)<br/>}</span></pre><p id="d64f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">希望你能看到这是非常标准的RxJava代码。现在我需要将它转换成协程。</p><h2 id="b36e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">第一次尝试</h2><p id="9be4" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">在您阅读完<a class="ae jm" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md" rel="noopener ugc nofollow" target="_blank">协程指南</a>之后，您可能会想到两个函数:<code class="du mb mc md lk b"><a class="ae jm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" rel="noopener ugc nofollow" target="_blank">launch()</a></code>和<code class="du mb mc md lk b"><a class="ae jm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" rel="noopener ugc nofollow" target="_blank">async()</a></code>。正如你可能猜到的，我的第一次尝试集中在使用这些链接在一起:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="04e4" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">override suspend fun </strong>refresh(param: Unit) {<br/>    <em class="mk">// Fetch network response on network dispatcher<br/>    </em><strong class="lk hi">val </strong>networkResponse = <em class="mk">async</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">network</strong>) <strong class="lk hi">{<br/>        trakt</strong>.users().profile(UserSlug.<em class="mk">ME</em>).execute().body()<br/>    <strong class="lk hi">}</strong>.await() <em class="mk">// await the result</em></span><span id="f33a" class="kj kk hh lk b fi mj lp l lq lr"><em class="mk">    // Map to our entity</em><strong class="lk hi"><br/>    val </strong>entity = TraktUser(<br/>        username = networkResponse.<strong class="lk hi">username</strong>,<br/>        name = networkResponse.<strong class="lk hi">name<br/>    </strong>)<br/><br/>    <em class="mk">// Save to the database on the database dispatcher<br/>    async</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">database</strong>) <strong class="lk hi">{<br/>        dao</strong>.insert(entity)<br/>    <strong class="lk hi">}</strong>.await()  <em class="mk">// Wait for the insert to finish</em><br/>}</span></pre><p id="5e16" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这实际上是可行的，但是有点浪费。这里我们实际上启动了三个协程:1)网络调用，2)数据库调用，3)主机协程调用<code class="du mb mc md lk b">data()</code>(在视图模型中)。</p><p id="eddb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我相信你可以想象出一个更复杂的Rx链，它会做像<code class="du mb mc md lk b">flatMap</code>ing<code class="du mb mc md lk b">Iterable</code>或其他疯狂的事情。当不总是需要时，您将要创建的协程的数量会显著增加，就像上面的例子一样。我们在这里做的一切都是顺序的，所以没有必要启动一个新的协程。我们需要的是改变dispatcher的方法，幸运的是，coroutines团队为我们提供了一种方法:<code class="du mb mc md lk b"><a class="ae jm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" rel="noopener ugc nofollow" target="_blank">withContext()</a></code>。</p><h2 id="14e2" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">第二次尝试</h2><p id="2404" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">我在<a class="ae jm" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#thread-confinement-fine-grained" rel="noopener ugc nofollow" target="_blank">协程指南</a>的一个小代码示例中偶然发现了<code class="du mb mc md lk b"><a class="ae jm" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" rel="noopener ugc nofollow" target="_blank">withContext()</a></code>。我的第二个(也是当前的)尝试集中在用<code class="du mb mc md lk b">withContext()</code>代替<code class="du mb mc md lk b">subscribeOn()</code>和<code class="du mb mc md lk b">observeOn()</code>，因为它确实做了我们想要的:</p><blockquote class="ml mm mn"><p id="4b22" class="jn jo mk jp b jq jr ii js jt ju il jv mo jx jy jz mp kb kc kd mq kf kg kh ki ha bi translated">这个函数立即从新的上下文应用dispatcher，将块的执行转移到块内的不同线程中，并在完成时返回。</p></blockquote><p id="0138" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">考虑到这一点，示例变成了:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="9f88" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">override suspend fun </strong>refresh(param: Unit) {<br/>    <em class="mk">// Fetch network response on network dispatcher<br/>    </em><strong class="lk hi">val </strong>networkResponse = <em class="mk">withContext</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">network</strong>) <strong class="lk hi">{<br/>        trakt</strong>.users().profile(UserSlug.<em class="mk">ME</em>).execute().body()<br/>    <strong class="lk hi">}</strong></span><span id="a690" class="kj kk hh lk b fi mj lp l lq lr"><em class="mk">    // Map to our entity</em><strong class="lk hi"><br/>    val </strong>entity = TraktUser(<br/>        username = networkResponse.<strong class="lk hi">username</strong>,<br/>        name = networkResponse.<strong class="lk hi">name<br/>    </strong>)<br/><br/>    <em class="mk">// Save to the database on the database dispatcher<br/>    withContext</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">database</strong>) <strong class="lk hi">{<br/>        dao</strong>.insert(entity)<br/>    <strong class="lk hi">}<br/></strong>}</span></pre><p id="c8c2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可以看到我们现在已经移除了<code class="du mb mc md lk b">async</code>调用，这意味着我们不再创建任何新的协程。我们只是移动主机协程来使用我们特定的调度程序(和线程)。</p><h2 id="a91e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">但是医生说协程是非常轻量级的。为什么我不能异步/启动？</h2><p id="3546" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">协程是非常轻量级的，但是创建它们仍然是有成本的。你应该记得在Android上我们运行在一个资源受限的系统上，所以我们需要尽一切可能减少我们的足迹。与使用<code class="du mb mc md lk b">async</code>或<code class="du mb mc md lk b">launch</code>创建一个新的协程相比，使用<code class="du mb mc md lk b">withContext</code>只需一次函数调用和最少的对象分配就能满足我们的需求。</p><p id="4cfc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">还有一个事实是，<code class="du mb mc md lk b">async</code>和<code class="du mb mc md lk b">launch</code>是针对异步任务的。大多数情况下，您会有一个异步的主任务，但是在其中您会调用同步的子任务。通过使用<code class="du mb mc md lk b">async</code>和<code class="du mb mc md lk b">launch</code>，你被迫做额外的<code class="du mb mc md lk b">await()</code>或<code class="du mb mc md lk b">join()</code>，这是不必要的复杂阅读。</p><p id="521b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">另一方面，如果您的子任务是不相关的，那么让它们用“async”并发运行是一种有效的方法。</p><h2 id="eae8" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">更复杂的Rx链呢？</h2><p id="8a00" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">这里有一个例子，每当我看到它时，我都会感到困惑:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="f8e9" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">override fun </strong>refresh(param: Unit): Completable {<br/>    <strong class="lk hi">trakt</strong>.users().watchedShows(UserSlug.<em class="mk">ME</em>).<em class="mk">toRxSingle</em>()<br/>            .subscribeOn(<strong class="lk hi">schedulers</strong>.<strong class="lk hi">network</strong>)<br/>            .toFlowable()<br/>            .flatMapIterable <strong class="lk hi">{ it }<br/>            </strong>.flatMapSingle <strong class="lk hi">{<br/>                showFetcher</strong>.load(<strong class="lk hi">it</strong>)<strong class="lk hi"><br/>            }<br/>            </strong>.toList()<br/>            .observeOn(<strong class="lk hi">schedulers</strong>.<strong class="lk hi">database</strong>)<br/>            .doOnSuccess <strong class="lk hi">{<br/>                databaseTransactionRunner</strong>.runInTransaction <strong class="lk hi">{<br/>                    dao</strong>.deleteAll()<br/>                    <strong class="lk hi">it</strong>.<em class="mk">forEach </em><strong class="lk hi">{ dao</strong>.insert(<strong class="lk hi">it</strong>) <strong class="lk hi">}<br/>                }<br/>            }<br/>            </strong>.<em class="mk">toCompletable</em>()<br/>}</span></pre><p id="b6a6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当你分解它时，它实际上并不比我们上面使用的例子复杂多少。最大的区别在于，它处理的是实体的集合，而不是单一的实体。为此，它使用Flowable的<code class="du mb mc md lk b"><a class="ae jm" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">flatMapIterable()</a></code>为每个项目展开地图，然后使用<code class="du mb mc md lk b"><a class="ae jm" href="http://reactivex.io/documentation/operators/to.html" rel="noopener ugc nofollow" target="_blank">toList()</a></code>将所有结果再次组合到一个列表中，然后保存到数据库中。</p><p id="74d4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><em class="mk">我实际上使用了一个不同的类(</em> <code class="du mb mc md lk b"><em class="mk">showFetcher</em></code> <em class="mk">)来为扇出提供操作符，在这种情况下，它返回一个Single。暂时忽略这一点。</em></p><p id="6331" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们在这里实际描述的是一个并行图，其中每个<code class="du mb mc md lk b">map()</code>都是并发运行的。JDK 8提供了与<code class="du mb mc md lk b">list.parallel().map(<em class="mk">/* map function */</em>).collect(toList())</code>类似的东西。我们可以使用那个功能，但是我们不会使用协程！</p><p id="7a70" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Kotlin中没有使用协程的内置版本(我能找到)，但幸运的是它很容易实现:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="4ef8" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">suspend fun </strong>&lt;A, B&gt; Collection&lt;A&gt;.parallelMap(<br/>    context: CoroutineContext = DefaultDispatcher,<br/>    block: <strong class="lk hi">suspend </strong>(A) -&gt; B<br/>): Collection&lt;B&gt; {<br/>    <strong class="lk hi">return </strong>map <strong class="lk hi">{<br/>        // Use async to start a coroutine for each item<br/>        </strong>async(context) <strong class="lk hi">{<br/>            </strong>block(it)<br/>        <strong class="lk hi">}<br/>    }</strong>.map <strong class="lk hi">{<br/>        // We now have a map of Deferred&lt;T&gt; so we await() each            <br/>        </strong>it.await()<br/>    <strong class="lk hi">}<br/></strong>}</span></pre><p id="9509" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><em class="mk">注意:这可能不是一个完美的实现。不过，对我来说很有效。</em></p><p id="9749" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">通过使用<code class="du mb mc md lk b">parallelMap()</code>，我们复杂的RxJava链变成如下:</p><pre class="ix iy iz ja fd lj lk ll lm aw ln bi"><span id="de8b" class="kj kk hh lk b fi lo lp l lq lr"><strong class="lk hi">override suspend fun </strong>refresh(param: Unit) {<br/>    <strong class="lk hi">val </strong>networkResponse = <em class="mk">withContext</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">network</strong>) <strong class="lk hi">{<br/>        trakt</strong>.users().watchedShows(UserSlug.<em class="mk">ME</em>).execute().body()<br/>    <strong class="lk hi">}<br/><br/>    val </strong>shows = networkResponse.<em class="mk">parallelMap </em><strong class="lk hi">{<br/>        showFetcher</strong>.load(<strong class="lk hi">it</strong>)<br/>    <strong class="lk hi">}<br/><br/>    </strong><em class="mk">// Now save the list to the database<br/>    withContext</em>(<strong class="lk hi">dispatchers</strong>.<strong class="lk hi">database</strong>) <strong class="lk hi">{<br/>        databaseTransactionRunner</strong>.runInTransaction <strong class="lk hi">{<br/>            dao</strong>.deleteAll()<br/>            shows.<em class="mk">forEach </em><strong class="lk hi">{ dao</strong>.insert(<strong class="lk hi">it</strong>) <strong class="lk hi">}<br/>        }<br/>    }<br/></strong>}</span></pre><p id="1ce6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">希望你可以看到，这是一个更清晰的阅读。这个<code class="du mb mc md lk b">showFetcher</code>职业仍然需要被转换，但是现在它可以<em class="mk"> a </em>等待。🤦</p></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><p id="6ce0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果你感兴趣，你可以在这里看到将应用程序转换成协程的PR:</p><div class="my mz ez fb na nb"><a href="https://github.com/chrisbanes/tivi/pull/135/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hi fi z dy ng ea eb nh ed ef hg bi translated">通过chrisbanes Pull请求#135 chrisbanes/tivi从RxJava迁移到协程</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">GitHub是2000多万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jg nb"/></div></div></a></div><h2 id="d369" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">后续步骤</h2><p id="ccbb" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">希望您可以看到，从RxJava的Single/Maybe/Completable切换到协程实际上是相对容易的。</p><p id="2fe2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">目前，我仍在使用RxJava进行流媒体观看，但我可能会转向单独使用<a class="ae jm" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>或<a class="ae jm" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#channels" rel="noopener ugc nofollow" target="_blank">协程频道</a>。不过这是下一次的任务。</p></div></div>    
</body>
</html>