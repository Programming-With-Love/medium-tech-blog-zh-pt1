<html>
<head>
<title>Diving deeper into the Java transient modifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究Java瞬态修饰符</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/diving-deeper-into-the-java-transient-modifier-3b16eff68f42?source=collection_archive---------4-----------------------#2016-11-25">https://medium.com/google-developer-experts/diving-deeper-into-the-java-transient-modifier-3b16eff68f42?source=collection_archive---------4-----------------------#2016-11-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/63900ad7385dc103976c4ea86298c222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GmBEwjZ4TLv-dXzMCcPdg.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Nothing is tied forever. Neither are transient variables.</figcaption></figure><div class=""/><p id="dba0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">上周我发表了一篇文章来帮助你理解Java中的引用是如何工作的。它被广泛接受，我得到了很多建设性的反馈。这就是我热爱软件社区的原因。</p><p id="bd4d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">今天我想给你看另一篇文章，深入到一个没有被广泛使用的话题:T2瞬态T3修改器。就我个人而言，当我开始使用它时，我记得我能够很快掌握它的理论方面，尽管应用是一个不同性质的问题。让我们仔细检查一下</p><h1 id="851b" class="js jt hw bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">瞬变修改器</h1><blockquote class="kq kr ks"><p id="537c" class="it iu kt iv b iw ix iy iz ja jb jc jd ku jf jg jh kv jj jk jl kw jn jo jp jq ha bi translated">应用于字段的<strong class="iv hx">瞬态</strong>修饰符告诉Java，当对象被序列化时，这个属性应该被排除。当对象被反序列化时，该字段将使用其默认值进行初始化(对于引用类型，这通常是一个<em class="hw"> null </em>值，如果对象是基元类型，则为<em class="hw"> zero </em> / <em class="hw"> false </em>)。</p></blockquote><p id="b453" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你会同意我的观点:理论很简单，但是我们最初没有看到实际的一面。我们应该在哪里应用瞬变修改器？什么时候会有用？除非你以前用过，否则很难想出一个真实的例子。就像狗追尾巴一样，我们找不到用例，因此我们不能将<a class="ae jr" rel="noopener" href="/@enriquelopezmanas/the-theoretical-animal-4f6901aaf571#.w9db0bi8k">实践应用于理论</a>。</p><p id="9752" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我写这篇文章的目的是帮助你打破这种恶性循环。让我们看几个实际的例子。</p><p id="667d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">想想一个<strong class="iv hx">用户</strong>对象。该<strong class="iv hx">用户</strong>的所有属性中包含<em class="kt">登录</em>、<em class="kt">电子邮件</em>和<em class="kt">密码</em>。当数据被序列化并通过网络传输时，我们可以想到一些安全原因，为什么我们不愿意将字段<em class="kt">密码</em>与整个对象一起发送。在这种情况下，将字段标记为<strong class="iv hx">瞬态</strong>将解决这个安全问题。这在代码中会是什么样子？</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="f513" class="lg jt hw lc b fi lh li l lj lk">@Data    <br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>public class User implements Serializable {<br/><br/>    private static final long serialVersionUID = 123456789L;<br/><br/>    private String login;<br/>    private String email;<br/>    private transient String password;<br/><br/>    public void printInfo() {<br/>        System.out.println("Login is: " + login);<br/>        System.out.println("Email is: " + email);<br/>        System.out.println("Password is: " + password);<br/>    }<br/>}</span></pre><p id="db2e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，这个对象正在实现接口<em class="kt"> Serializable </em>，当您打算序列化一个对象时，这是必需的。如果这个接口没有实现，你会收到一个<em class="kt">NotSerializableException</em>。还要注意声明的字段<em class="kt"> serialVersionUID </em>。如果您使用任何主要的开发环境或Eclipse，它通常会被自动重新创建。</p><p id="4af1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您现在序列化然后反序列化一个User类型的对象，那么值password将会是null，因为它已经被标记为transient。</p><blockquote class="kq kr ks"><p id="0cc6" class="it iu kt iv b iw ix iy iz ja jb jc jd ku jf jg jh kv jj jk jl kw jn jo jp jq ha bi translated">看到注释@Data、@NoArgsConstructor和@AllArgsConstructor？它们是由<a class="ae jr" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>提供的，这是一个让事情变得更简单的Java库。虽然在2016年Lombok不像以前那么有用(现在像Kotlin这样的语言会自动生成setters和getters，在任何主要的开发环境和Eclipse中，你只需双击就可以做到这一点)，但我仍然喜欢在某些领域中使用它，以保持一个干净的领域模型集合。</p></blockquote><p id="dce2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当使用<strong class="iv hx">瞬态</strong>修饰符时，我还能想到另一个用例:当一个对象从另一个派生时。在这种情况下，我们可以通过将派生字段<strong class="iv hx">转换为瞬态字段</strong>来提高代码的效率。</p><p id="059d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们来看看这段代码:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a39c" class="lg jt hw lc b fi lh li l lj lk">@Data    <br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>public class GalleryImage implements Serializable {</span><span id="d73c" class="lg jt hw lc b fi ll li l lj lk">    private static final long serialVersionUID = 123456789L;<br/>    <br/>    private Image image;<br/>    private transient Image thumbnailImage;<br/><br/>    private void generateThumbnail() {<br/>        // This method will derive the thumbnail from the main image<br/>    }<br/><br/>    private void readObject(ObjectInputStream inputStream)<br/>            throws IOException, ClassNotFoundException {<br/>        inputStream.defaultReadObject();<br/>        generateThumbnail();<br/>    }    <br/>}</span></pre><p id="2db7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，该类包含一个主<em class="kt">图像</em>和一个<em class="kt">缩略图图像</em>字段。最新的字段将从前者派生而来。如果我们能让<em class="kt">thumbnail image</em><strong class="iv hx">transient</strong>成为我们的代码，我们会更有效率:当对象被序列化时，从另一个字段派生的字段将不会被传递。</p><p id="0242" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">文末的一个小观点:可以想象，一个<strong class="iv hx">瞬态</strong>变量不可能是<strong class="iv hx">静态</strong>(或者如果是也没有太大意义)。<strong class="iv hx">静态</strong>字段是隐式<strong class="iv hx">瞬态</strong>，不会被序列化。</p><blockquote class="kq kr ks"><p id="9665" class="it iu kt iv b iw ix iy iz ja jb jc jd ku jf jg jh kv jj jk jl kw jn jo jp jq ha bi translated">摘要:当一个对象包含您不想传输的敏感数据，或者当它包含您可以从其他元素获得的数据时，使用<strong class="iv hx"> transient </strong>。<strong class="iv hx">静态</strong>字段是隐式<strong class="iv hx">瞬态</strong>。</p></blockquote><p id="c1e1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我在我的推特账户上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它确实帮助了你，请随意分享和/或留下评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>