<html>
<head>
<title>Data Binding Library: Great UI’s with Less code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据绑定库:代码更少的伟大用户界面</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/data-binding-library-great-ui-s-with-less-code-f2575e0c588e?source=collection_archive---------4-----------------------#2015-12-10">https://medium.com/google-developer-experts/data-binding-library-great-ui-s-with-less-code-f2575e0c588e?source=collection_archive---------4-----------------------#2015-12-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c3b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几个月前，随着代号为Marshmallow的android 6.0的发布，这个版本中添加了许多新东西，老实说，在从事其他项目的同时跟上这些新东西可能是一项艰巨的任务。在一整套新的API中，比如fingerprint、doze、新的权限模型，真正引起我注意的新事物之一是数据绑定库。</p><p id="66cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，“数据绑定库帮助您编写声明性布局，并最大限度地减少绑定应用程序逻辑和布局所需的粘合代码”。为了使这句话更清楚，我将不得不回到图书馆之前的事情是如何做的。</p><p id="edbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们举一个简单的例子，我们想创建一个简单的应用程序，它在EditText上接收一个用户名，单击一个按钮，它就会在Toast上显示这个名称。</p><p id="9c27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们已经通过了在Android studio上创建新应用程序的向导(<a class="ae jc" href="http://tools.android.com/download/studio/builds/2-0-preview" rel="noopener ugc nofollow" target="_blank">顺便说一下，在这里获得2.0版本</a>)，并且我们有一个自动生成的活动和布局资源文件，我们将经历以下步骤:</p><ol class=""><li id="a488" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">打开活动的布局资源文件，添加一个编辑文本和一个按钮，不要忘记为每个视图分配一个惟一的id。</li><li id="ccfd" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">转到主活动java类，并创建视图的java实例。</li><li id="9786" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">使用findViewById方法，使用我们在1中定义的每个视图的惟一Id来查找视图。</li><li id="6021" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">最后，我们可以开始在代码中处理视图属性了，比如获取用户文本输入，设置监听器等等。</li></ol><p id="1f16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这4个步骤是我们每次在应用程序UI上添加或更改东西时都必须遵循的。起初，当我们在做简单的UI时，看着这4个步骤并对它们偷懒可能看起来很傻，但是当UI复杂性增加时，boiler plate代码的数量会急剧增加。</p><p id="309e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回到我们的句子，数据绑定库的主要目标是削减这些步骤，减少代码量，使其更具可读性。</p><h1 id="b5a7" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">但是它是怎么做到的呢？</h1><p id="fe71" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">关于这个库是如何工作的，没有太多要说的，因为在一个高层次的概念中，它只为我们做我之前提到的步骤，为了更深入的理解，有一个必须观看的演讲，由@YigitBoyar在android dev峰会期间详细解释了它是如何工作的。</p><h1 id="f285" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">一些代码的时间:)</h1><p id="e160" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">跳到有趣的部分，要开始使用数据绑定库，我们首先要为它配置您的项目，为此我们只需将数据绑定元素添加到我们的应用程序模块build.gradle文件中，如下所示:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ae94" class="ld js hh kz b fi le lf l lg lh">dataBinding{<br/>    enabled = true<br/>}</span></pre><p id="b29a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同步你的gradle文件，然后<em class="li">瞧</em>你就可以开始在你的应用程序上使用这个库了。</p><p id="9ebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要在您的项目中实际应用它，有3个关键部分需要考虑:</p><ol class=""><li id="9a51" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">布局文件:布局文件是我们要看的第一个组件，因为它与之前相比有一些变化。为了编写支持绑定的UI，布局文件根标签通常是一个视图组，它将变成标签“<strong class="ig hi">布局</strong>”，其中包含2个孩子、<strong class="ig hi">数据</strong>标签和我们的常规<strong class="ig hi">视图组</strong>以及UI代码的其余部分。<strong class="ig hi">数据</strong>标签是我们现在声明可能要在绑定表达式中使用的变量的地方。要为属性编写一个简单的表达式，我们必须按如下方式设置属性值:@ {&lt;expression go here&gt;}就像下面的代码一样，我们将字符串url变量设置为image view app:loadImage属性。数据绑定库知道当表达式被传递到公共属性时如何正确解析，例如我们用来在EditText上设置文本的android:text或用来设置视图可见性的android:visibility，但是正如我们将在后面看到的，有些情况下我们需要自己指定如何设置数据。</li></ol><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="337b" class="ld js hh kz b fi le lf l lg lh">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;layout  xmlns:android="http://schemas.android.com/apk/res/android"<br/>         xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/><br/>    &lt;data&gt;<br/>        &lt;variable name="imageUrl" type="String"/&gt;<br/>    &lt;/data&gt;<br/><br/>    &lt;LinearLayout<br/>        android:orientation="vertical" <br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"&gt;<br/><br/>        &lt;ImageView<br/>            android:layout_width="190dp"<br/>            android:layout_height="280dp"<br/>            app:imagesource="@{imageUrl}"<br/>            /&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/>&lt;/layout&gt;</span></pre><p id="33bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.一旦我们构建了我们的项目，就会生成一个绑定类，它的作用是提供方法让我们从java代码到UI进行实际的绑定。</p><p id="d1c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.使用binding类进行实际绑定并传递数据是最后一步，这是通过创建在上一步中自动生成的binding类的新实例，并使用DataBindingUtil类来扩展布局文件来实现的，这可以通过使用该类提供的方法在不同情况下以多种不同方式发生。</p><p id="79f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几个常用的方法是<strong class="ig hi">databindingutil . setcontentview(r . layout)</strong>当我们想直接设置活动内容视图并返回相关联的绑定时使用，<strong class="ig hi">databindingutil . inflate(layoutin flater，layoutId，viewgroup，boolean flag) </strong>当我们创建片段视图时通常可以使用。文档中提供了更多的方法，我真的建议去看看。</p><p id="8d5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要next来获取绑定类实例，并使用从我们在布局的数据标签上定义的变量中生成的setters来将数据绑定到UI。将活动布局绑定到用户数据对象的java文件中的简单代码如下所示:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7a70" class="ld js hh kz b fi le lf l lg lh">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>   super.onCreate(savedInstanceState);<br/>   MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity);<br/>   User user = new User("Test", "User");<br/>   binding.setUser(user);<br/>}</span></pre><h1 id="9d09" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">超越基础</strong></h1><p id="8aef" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">开始使用数据绑定库非常简单，但是还有很多很酷的事情要做。为了涵盖一些有趣和深刻的东西，本文的剩余部分将主要讲述我如何使用数据绑定库来修改Udacity的android nanodegree的My Movie应用程序的一些部分。</p><h2 id="3c0c" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">一张电影海报</h2><p id="4445" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">该应用程序的第一个屏幕是一个简单的电影海报缩略图网格，可以通过流行度，评级过滤。</p><figure class="ku kv kw kx fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/490e98cb353d0dc00c74b290993e14b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g09C82vuWCA75Ge0hcWlew.png"/></div></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="488f" class="ld js hh kz b fi le lf l lg lh">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;layout  xmlns:android="http://schemas.android.com/apk/res/android"<br/>         xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/><br/>    &lt;data&gt;<br/>        &lt;variable name="imageUrl" type="String"/&gt;<br/>    &lt;/data&gt;<br/><br/>    &lt;LinearLayout<br/>        android:orientation="vertical"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"&gt;<br/><br/>        &lt;ImageView<br/>            android:id="@+id/movie_thumbnail"<br/>            android:layout_width="190dp"<br/>            android:layout_height="280dp"<br/>            app:imagesource="@{imageUrl}"<br/>            /&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/>&lt;/layout&gt;</span></pre><p id="ab47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的布局和代码与我们看到的布局完全一样，但这里最大的不同是我们如何将图像缩略图设置到网格上的每个项目。正如我前面提到的，这个库知道如何处理为一些属性传递的数据，因为它在后面做的只是将一组数据传递给那个对象。<br/>对于像文本这样的情况，设置一个字符串是非常直接的，但是对于更具体的情况，比如将图像加载到imageview，我们只有现成的android:src方法，基本上遵循相同的类比，当使用库时，它为我们提供了一个drawable的setter，这不是我们所需要的，因为我们通常希望从url或任何其他源加载图像，就像这个例子。为了解决这个问题，我们只需要添加一个类和一个新方法，将其注释为一个绑定适配器，并指定我们想要使用的属性的名称，该名称可以是像我一样的自定义名称，也可以简单地覆盖现有的属性，如android:src。<br/>对于这个方法签名，我们传递ImageView和第二个参数，ImageView是我们想要设置图像的组件，第二个参数将是我们想要加载的图像的url。实现非常简单，我们只需从imageview获取上下文，并使用picasso(我经常使用)或其他图像加载器库，开始将图像加载到imageview。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8c5c" class="ld js hh kz b fi le lf l lg lh">@BindingAdapter("app:imagesource") // could also be "android:src"<br/>public static void loadGridImage(ImageView image,String imageUrl){<br/>    //we do all the magic with Picasso or any other lib here<br/>    Picasso.with(image.getContext()).load(imageUrl).into(image);<br/>}</span></pre><h2 id="18bf" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">电影海报网格</h2><p id="924d" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">是时候把所有的海报放在一个网格上了，就像上面的截图一样，然后把图片绑定到每一张海报上。正如我们在向ListView、GridView或RecyclerView填充数据时所做的那样，我们首先需要创建一个适配器，将数据传递给它，然后将适配器设置为返回给它。这个过程没有改变，但是关于如何做的代码可能会略有不同。</p><ol class=""><li id="c64c" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">首先改变的是海报视图的视图持有者，当我们滚动浏览时，它持有一个引用，这样视图就不会被重新创建。这个视图容器曾经包含了我们布局中所有视图的实例，在我们构建视图的时候，我们曾经通过这个视图的id来查找视图。由于我们正在使用数据绑定库，我们不再需要通过id查找视图，因为我们已经有了在编译时自动生成的绑定类供我们使用，就像本文开始时的第一种情况一样。这里的问题是，由于我们可以有一个包含不同项目的元素列表或网格，为某个类型指定确切生成的布局绑定类并不是一个好主意，并且会给我们带来一些额外的工作，检查我们可能希望在列表中出现的不同类型的视图。其思想是，在ViewHolder中，我们创建一个基本绑定类<strong class="ig hi"> ViewDataBinding，</strong>的对象，使用DataBindingUtil类中的bind方法从ViewHolder构造器上传递的视图中获取一个绑定(假设我们不知道将会是什么),并公开一个getter方法来访问该绑定，如下面的代码所示。</li></ol><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="aea4" class="ld js hh kz b fi le lf l lg lh">public class MoviesGridViewHolder extends RecyclerView.ViewHolder {<br/><br/>    private ViewDataBinding bindingView;<br/><br/>    public MoviesGridViewHolder(View itemView) {<br/>        super(itemView);<br/>        bindingView = DataBindingUtil.<em class="li">bind</em>(itemView);<br/>    }<br/><br/>    public ViewDataBinding getBindingView(){<br/>        return bindingView;<br/>    }<br/><br/>}</span></pre><p id="06f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在适配器内部，与RecyclerView相比，list和grid视图的实现可能稍有不同，但背景思想是相同的，第一次创建视图时，我们创建视图持有人，随后的时间我们一直使用视图持有人。说到我们的回收器视图适配器，我们首先在方法<strong class="ig hi"> onCreateViewHolder上创建视图持有者。</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="44f1" class="ld js hh kz b fi le lf l lg lh">@Override<br/>public MoviesGridViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {<br/>    LayoutInflater inflater = LayoutInflater.<em class="li">from</em>(parent.getContext());<br/>    View view= inflater.inflate(R.layout.<em class="li">layout_single_movie_poster</em>, parent, false);<br/>    MoviesGridViewHolder holder = new MoviesGridViewHolder(view);<br/>    return holder;<br/>}</span></pre><p id="8b59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在创建视图容器之后，下一个重要的时刻是我们最终将数据绑定到UI的时候。我们在适配器的<strong class="ig hi"> onBindViewHolder </strong>方法中这样做，方法是使用视图持有者中的getter方法来获取基本绑定类，然后调用方法setVariable(int variableId，Object ),该方法接收两个参数，即变量Id和我们要设置的对象的值。</p><p id="e471" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里需要理解的非常重要的一点是，当我们编译项目时，传递的变量Id是自动生成的，并作为自动生成的类BR的字段添加，BR的工作方式与R处理视图和任何其他资源上的Id的方式相同。</p><p id="91cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在将所有数据data设置到各自的变量后，我们必须调用<strong class="ig hi"> executePendingBindings </strong>，以便将所有视图与我们的模型同步，并防止在试图修复之前动画帧上可能发生的任何布局错误时创建两个布局。这主要是因为当数据改变时，数据绑定库不会立即更新视图，而是跟踪它们，并且只在下一个动画帧上进行改变。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5de8" class="ld js hh kz b fi le lf l lg lh">@Override<br/>public void onBindViewHolder(MoviesGridViewHolder holder, final int position) {<br/>    final Movie movie = movies.get(position);<br/>    holder.getBindingView().setVariable(BR.<em class="li">movie</em>,movie);<br/>    holder.getBindingView().setVariable(BR.<em class="li">clickHandler</em>,movie.getPosterUrl());<br/>    holder.getBindingView().executePendingBindings();<br/>}</span></pre><h2 id="ac5b" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">单击缩略图打开详细信息</h2><p id="f185" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">网格就位后，我们要做的下一件事就是点击相应的缩略图打开一个电影细节屏幕。如果您对不使用findViewById方法的事实非常怀疑，那么当您开始考虑这一点时，您可能已经找到了“啊哈”的时刻。</p><p id="4f55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但幸运的是，我将不得不给出一个坏消息，即有一种方法可以在没有findViewById的情况下处理click事件。实际上，这并不是什么新东西，因为在数据绑定库之前，我们就可以为视图设置一个onClick属性，然后创建一个方法，将视图作为参数传递，并在单击指定视图时实现我们可能想要做的所有事情。</p><p id="40cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用数据绑定库，我们只需创建一个简单的类class(让我们将其命名为handler)，编写一个具有与我刚才解释的相同签名的方法，在布局文件的数据标签内创建一个具有handler类的变量，该布局文件带有我们想要添加的单击行为的视图，最后添加onClick属性，并在它的值上传递一个表达式，在该表达式中我们调用处理程序所需的方法，如下面的代码片段所示。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="703c" class="ld js hh kz b fi le lf l lg lh">public class BindingClickHandlers {</span><span id="186f" class="ld js hh kz b fi me lf l lg lh">   public void onThumbnailClick(View view){<br/>       context = view.getContext();<br/>       intent = new Intent(context, MovieDetails.class);<br/>       bundle = new Bundle();<br/>       bundle.putParcelable("movie",movie);<br/>       intent.putExtras(bundle);<br/>       context.startActivity(intent);<br/>   }</span><span id="fe93" class="ld js hh kz b fi me lf l lg lh">}</span><span id="5655" class="ld js hh kz b fi me lf l lg lh">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;layout  xmlns:android="http://schemas.android.com/apk/res/android"<br/>         xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/><br/>    &lt;data&gt;<br/>        &lt;variable name="imageUrl" type="String"/&gt;<br/>        &lt;variable name="clickHandler" type="com.app.mymooviapp.bindingAdapters.BindingClickHandlers"/&gt;<br/>    &lt;/data&gt;<br/><br/>    &lt;LinearLayout<br/>        android:orientation="vertical"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:padding="8dp"<br/>        android:onClick="@{clickHandler.onThumbnailClick}"<br/>        &gt;<br/><br/>        &lt;ImageView<br/>            android:id="@+id/movie_thumbnail"<br/>            android:layout_width="190dp"<br/>            android:layout_height="280dp"<br/>            app:imagesource="@{imageUrl}"<br/>            /&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/>&lt;/layout&gt;</span></pre><p id="e7ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您一直关注代码片段，您可能会注意到最后两个代码片段中的两件事情。</p><ol class=""><li id="2d7e" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">方法实现将一个电影对象传递给似乎不知从哪里来的intent。</li><li id="cea3" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">与第一点思路相同，你应该已经注意到，当我们调用方法时，我们不传递任何额外的参数，正确的原因是因为我们不能。</li></ol><p id="e201" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里最大的问题是我们如何把那个物体带到那里？</p><p id="b81c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嗯，我不能说这是否是最终和最好的实现，但这里是我如何设法工作。由于我们的处理程序将主要是一个我们在布局代码的最后一个片段中声明的变量，我们可以用类中的电影和一个静态工厂方法创建一个变量，我们将在这个方法中构造处理程序，设置电影对象，并像以前一样在代码中使用它。我完整实现的整个类会是这样的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ceb6" class="ld js hh kz b fi le lf l lg lh">public class BindingClickHandlers {<br/><br/>    private Movie movie;<br/><br/>    private Context context;<br/><br/>    private Intent intent;<br/><br/>    private Bundle bundle;<br/><br/>    public BindingClickHandlers(){}<br/><br/>    //construct a binding class for movie thumbnail click<br/>    public static  BindingClickHandlers newThumbnailClickHandler(Movie movie){<br/>        BindingClickHandlers handler = new BindingClickHandlers();<br/>        handler.setMovie(movie);<br/>        return handler;<br/>    }<br/><br/><br/>    public void onThumbnailClick(View view){<br/>        context = view.getContext();<br/>        intent = new Intent(context, MovieDetails.class);<br/>        bundle = new Bundle();<br/>        bundle.putParcelable("movie",movie);<br/>        intent.putExtras(bundle);<br/>        context.startActivity(intent);<br/>    }<br/><br/>    public void setMovie(Movie movie){<br/>        this.movie = movie;<br/>    }<br/>}</span></pre><p id="b90a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们只需在适配器中添加几行代码，并像这样设置处理程序:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5558" class="ld js hh kz b fi le lf l lg lh">final Movie movie = movies.get(position);<br/>final BindingClickHandlers handler = BindingClickHandlers.<em class="li">newThumbnailClickHandler</em>(movie);<br/>holder.getBinding().setVariable(BR.<em class="li">clickHandler</em>,handler);</span></pre><h2 id="0003" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">更多精彩—电影详情屏幕</h2><figure class="ku kv kw kx fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/d4abd3bd5906c89cfca42fd5fe49def7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgXEp4dLskEP5L3Xl4wyIg.png"/></div></div></figure><p id="fd4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在点击一个电影缩略图后，该应用程序应该会打开一个新的活动，并显示电影的细节。正如我们在图中看到的，与第一种布局相比，这种布局稍微复杂一些，除了可能必须在另一种布局中包含一些布局之外，您可能会在片段中包含一些大代码，以便将数据设置到这些代码中，等等。</p><p id="bbe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，有了数据绑定，使用一些很酷的特性，您的问题可以减少到几乎没有，例如:</p><p id="8a6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">将数据绑定到包含的布局</strong></p><p id="9259" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽可能简单地说，库允许您将根布局上的某个变量绑定到包含布局，条件是包含布局在其文件上也有一个同名变量的声明。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="370e" class="ld js hh kz b fi le lf l lg lh">&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:bind="http://schemas.android.com/apk/res-auto"&gt;<br/><br/>    &lt;data&gt;<br/>        &lt;variable name="movie" type="com.app.mymooviapp"/&gt;<br/>    &lt;/data&gt;<br/><br/>    &lt;android.support.v4.widget.NestedScrollView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        &gt;<br/><br/>        &lt;FrameLayout<br/>            android:orientation="vertical"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent"<br/>            &gt;<br/><br/>            &lt;include layout="@layout/layout_details_content"<br/>                android:id="@+id/layout_details"<br/>                bind:movie="@{movie}"<br/>                /&gt;</span><span id="aab9" class="ld js hh kz b fi me lf l lg lh">&lt;!-- REST OF THE LAYoUT CODE</span></pre><p id="745d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">导入类并在表达式中使用它们</strong></p><p id="7dee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看电影评级的详细信息屏幕的标题，我们可以看到当前电影评级显示了它可以达到的总评级，但对于一些评级为10分的罕见电影，我认为显示删除10分是很酷的，因为我们已经达到了峰值。为了做到这一点，我们必须通过它们的id找到两个textviews，并实现您的逻辑来实现它。</p><p id="9bd2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在事情变得更小了，因为数据绑定让您可以导入类以用于布局文件中的表达式。这种导入发生在数据标记内部，它是通过一行简单的代码完成的，如下所示:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f8b6" class="ld js hh kz b fi le lf l lg lh">&lt;import type="android.view.View"/&gt;</span></pre><p id="dcea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要注意的一点是，类型应该是类所在的包的全名，如果我们想要导入两个同名的类，我们可以定义一个别名，通过添加一个别名属性来区分两个类，并将值设置为所需的名称。</p><p id="975a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以在导入类之后，我们可以用它来声明一个变量的类型，或者直接在表达式中使用。对于我刚才提到的rating的例子，通过导入View类，我们可以使用它根据用户等级的值来设置视图的可见性。下面是一个布局示例，展示了在表达式中导入和使用类的方式</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8957" class="ld js hh kz b fi le lf l lg lh">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;layout  xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/><br/>    &lt;data&gt;<br/>        &lt;import type="android.view.View"/&gt;<br/><br/>        &lt;variable name="backdropPath" type="String"/&gt;<br/>        &lt;variable name="movieRating" type="int"/&gt;<br/><br/>    &lt;/data&gt;<br/><br/>    &lt;FrameLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="250dp"<br/>        &gt;<br/><br/>        &lt;ImageView<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent"<br/>            android:id="@+id/header"<br/>            android:scaleType="centerCrop"<br/>            /&gt;<br/><br/>        &lt;TextView<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:id="@+id/current_rating"<br/>            android:textSize="56sp"<br/>            android:layout_gravity="center"<br/>            android:textColor="@color/white"<br/>            android:text="@{movieRating}"<br/>            /&gt;<br/><br/>        &lt;TextView<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_marginLeft="56dp"<br/>            android:id="@+id/max_rating"<br/>            android:layout_marginTop="16dp"<br/>            android:layout_gravity="center"<br/>            android:textColor="@color/white"<br/>            android:text=" / 10"<br/>            android:visibility="@{movieRating == 10 ? View.GONE : View.VISIBLE}"<br/>            /&gt;<br/><br/>    &lt;/FrameLayout&gt;<br/><br/>&lt;/layout&gt;</span></pre><p id="d6bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章是一个简短的说明，展示了我认为关于这个库的一些非常基本和有趣的东西，但是你可以肯定还有很多东西需要探索，到最终发布的时候，我们可能会有一些新的东西。</p><p id="7071" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要了解更多信息，我建议在Android开发峰会期间看看Yigit Boyar的<a class="ae jc" href="http://developer.android.com/tools/data-binding/guide.html" rel="noopener ugc nofollow" target="_blank">入门</a>指南、javadoc和<a class="ae jc" href="https://www.youtube.com/watch?v=NBbeQMOcnZ0" rel="noopener ugc nofollow" target="_blank">演讲</a>。</p><p id="fd4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望在评论中听到你对这个话题的看法，如果你喜欢这个帖子，推荐给一些可能也会对此感兴趣的朋友:)</p><p id="dcda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分米</p></div></div>    
</body>
</html>