<html>
<head>
<title>Graduating from Minimal to Rich Java APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从最简到丰富的Java APIs</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/graduating-from-minimal-to-rich-java-apis-c50192c8322f?source=collection_archive---------3-----------------------#2019-05-28">https://medium.com/oracledevs/graduating-from-minimal-to-rich-java-apis-c50192c8322f?source=collection_archive---------3-----------------------#2019-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f933" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将简单易学与减少代码重复相结合，以提高生产率。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/6ca26592eb64f2cdc51ea165d6b87524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-3rHigMPF3FM53M8rESgg.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Happy Birthday Java!</figcaption></figure><h1 id="82a4" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">生日快乐，爪哇</h1><p id="18ba" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">2019年5月23日Java满24岁。对于一门成功的编程语言来说，这是一段令人印象深刻的时间，同时也是继续发展其开发者社区的时间。Java在不断发展，Java社区也在不断创新和成长。</p><p id="c615" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">直到Java 8(2014年发布)之前，Java或多或少都遵循着最小API设计理念。这对于Java来说效果非常好，因为最小化的API设计往往会降低初始学习曲线，并且通过只要求开发人员学习一些基本概念来提高采用率。</p><h1 id="b8c6" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">集合的最小API设计</h1><p id="60a1" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">自从1998年12月Java 2发布以来,<code class="du kv kw kx ky b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener ugc nofollow" target="_blank">Collection</a></code>接口就可以在Java中使用了。<code class="du kv kw kx ky b">Collection</code>有几种变异方式，包括<code class="du kv kw kx ky b">add</code>、<code class="du kv kw kx ky b">addAll</code>、<code class="du kv kw kx ky b">remove</code>、<code class="du kv kw kx ky b">removeAll</code>、<code class="du kv kw kx ky b">retainAll</code>、<code class="du kv kw kx ky b">clear</code>。有几种测试方法，包括<code class="du kv kw kx ky b">contains</code>、<code class="du kv kw kx ky b">containsAll</code>、<code class="du kv kw kx ky b">isEmpty</code>和<code class="du kv kw kx ky b">size</code>。每个<code class="du kv kw kx ky b">Collection</code>都可以使用方法<code class="du kv kw kx ky b">toArray</code>返回其内容。方法<code class="du kv kw kx ky b">iterator</code>允许使用for循环或while循环实现任何迭代模式。2014年3月，Java 8发布，<code class="du kv kw kx ky b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">Stream</a></code>接口增加了内置迭代模式(如<code class="du kv kw kx ky b">filter</code>、<code class="du kv kw kx ky b">map</code>、<code class="du kv kw kx ky b">reduce</code>)。更新了<code class="du kv kw kx ky b">Collection</code>界面，以包含新的默认方法，包括<code class="du kv kw kx ky b">forEach</code>、<code class="du kv kw kx ky b">stream</code>和<code class="du kv kw kx ky b">parallelStream</code>方法。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es la"><img src="../Images/c9f915865d1bb585fce9d81befe5ab86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTxgoa2NbaQdIAj3vGCI0g.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Collection API (1998), and Stream API (2014), with new default methods added on Collection</figcaption></figure><h1 id="3dc8" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">升级到更高级别的API</h1><p id="15a7" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">随着编程语言的成熟和被广泛采用，满足更有经验的开发人员的需求并保持与更新、更灵活的编程语言的竞争力变得非常重要，这些编程语言可能不太关心保持版本之间的向后兼容性。Java开发人员(估计现在大约有1200万人)已经非常熟悉Java Collections API，它已经存在了20多年。Java是一种优秀的通用编程语言，它为开发人员提供了创建优秀应用程序所需的基本工具。自从Java 8发布以来，Java已经开始引入更高级别的API，尤其是在集合领域。Java 8中添加的<code class="du kv kw kx ky b">Stream</code> API增加了与现有的<code class="du kv kw kx ky b">Collection</code>接口一起工作的函数方法。</p><p id="b58b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从Java 8开始，<code class="du kv kw kx ky b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" rel="noopener ugc nofollow" target="_blank">List</a></code>接口也增加了一些新的默认方法。例如，我们终于有了一个直接在<code class="du kv kw kx ky b">List</code>上可用的<code class="du kv kw kx ky b">sort</code>方法。从Java 2开始，开发人员就一直使用<code class="du kv kw kx ky b">Collections</code>类对<code class="du kv kw kx ky b">List</code>的实例进行排序。下面是Java 8以后的<code class="du kv kw kx ky b">List</code>界面。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lb"><img src="../Images/dba6009d2c1f7875a96b081632946fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyEwOnwVEgiN7Vpul0IMMw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">List interface (December 1998) with default methods added (March 2014)</figcaption></figure><p id="6962" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java 8中为<code class="du kv kw kx ky b">Collection</code>和<code class="du kv kw kx ky b">List</code>提供的大多数新功能都可以通过调用<code class="du kv kw kx ky b">stream</code>方法，然后调用<code class="du kv kw kx ky b">Stream</code>接口上可用的适当方法来实现。在<code class="du kv kw kx ky b">Stream</code>界面上可用的行为被<code class="du kv kw kx ky b">collect</code>方法进一步扩展，该方法可以被传递一个<code class="du kv kw kx ky b">Collector</code>。在<code class="du kv kw kx ky b">Stream</code>上名为<code class="du kv kw kx ky b">collect</code>的方法通常被描述为<em class="lc">可变归约</em>。从Java 8开始，在<code class="du kv kw kx ky b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" rel="noopener ugc nofollow" target="_blank">Collectors</a></code>类上有一组可用的<code class="du kv kw kx ky b">Collector</code>实现。<a class="ae kz" href="https://github.com/donraab/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections </a>在其<code class="du kv kw kx ky b"><a class="ae kz" href="https://www.eclipse.org/collections/javadoc/9.2.0/org/eclipse/collections/impl/collector/Collectors2.html" rel="noopener ugc nofollow" target="_blank">Collectors2</a></code>类中添加了自己的一组<code class="du kv kw kx ky b">Collector</code>实现。</p><p id="dc0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们将<code class="du kv kw kx ky b">List</code>、<code class="du kv kw kx ky b">Stream</code>和<code class="du kv kw kx ky b">Collectors</code>类中所有可用的功能结合起来，您将看到从旧的最小API设计到新的更丰富的API设计的演变。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ld"><img src="../Images/eed8f4fa875b0d764975c600f0c0e25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zY7B_wJfTFvCEOB0Z2QVUw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Combining the List, Stream and Collectors APIs</figcaption></figure><p id="d94d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将<code class="du kv kw kx ky b">List</code>、<code class="du kv kw kx ky b">Stream</code>和<code class="du kv kw kx ky b">Collectors</code>的组合API与<a class="ae kz" href="https://github.com/donraab/eclipse-collections" rel="noopener ugc nofollow" target="_blank">Eclipse Collections</a><code class="du kv kw kx ky b"><a class="ae kz" href="https://www.eclipse.org/collections/javadoc/9.2.0/org/eclipse/collections/api/list/MutableList.html" rel="noopener ugc nofollow" target="_blank">MutableList</a></code>类中已有的丰富API设计进行比较，你会开始看到它们之间的一些共同模式(有时名称不同)。这些模式并不新鲜。它们在不同的编程语言中已经存在了很长时间，但是现在才被Java开发人员社区发现和学习。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es le"><img src="../Images/010022e2f028966de4335722946bb643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9xRYAcS7NeGVJBXqJpp6w.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">MutableList methods in Eclipse Collections</figcaption></figure><p id="0b7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更高级别的API帮助开发人员解决一个基本问题，最小的API可以帮助创建——<strong class="ig hi">代码复制</strong>。在<a class="ae kz" href="https://github.com/donraab/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections </a> <code class="du kv kw kx ky b">MutableList</code>接口中可以看到，有大量的迭代模式没有包含在Java <code class="du kv kw kx ky b">List</code>接口最初的最小API设计中。因为这些迭代模式没有随语言一起在高级Java APIs中提供，所以开发人员需要使用迭代器和索引列表访问的基本构建块来自己实现这些模式。</p><p id="8eed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参见我之前关于<a class="ae kz" rel="noopener" href="/@donraab/code-duplication-1e1f759a7fe3">代码复制</a>的博客，了解更多关于迭代模式的知识。</p><h1 id="edfe" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">高级学习与基本复制</h1><p id="8463" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">最小API设计的支持者通常会认为最小API更容易学习。这是真的。如果你认为用集合编写代码只需要一个迭代器和一个for循环，那你就对了。但是，如果你只有一个迭代器，你将不得不反复迭代相同的模式(锤子，遇见钉子)。更重要的是，你将会留下重复的代码给将来的读者阅读。</p><blockquote class="lf lg lh"><p id="2385" class="ie if lc ig b ih ii ij ik il im in io li iq ir is lj iu iv iw lk iy iz ja jb ha bi translated">你要写的代码越多，别人要读的代码就越多。</p></blockquote><p id="c7ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最小的API设计导致应用程序开发人员必须编写、测试和维护更多的代码。丰富的API设计导致库开发人员必须编写、测试和维护更多的代码。如果我们对世界上编写的所有代码都拥有共享的代码所有权，我们可能会同意成本最低的替代方案是在适当的时候依靠库和语言开发人员来提供丰富的API供开发人员使用。</p><blockquote class="lf lg lh"><p id="4e93" class="ie if lc ig b ih ii ij ik il im in io li iq ir is lj iu iv iw lk iy iz ja jb ha bi translated">一旦你知道了基础知识，学习更高级的概念是一件好事</p></blockquote><p id="32ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Java的前24年里，最小API设计很好地服务了它的目的。它导致了Java编程语言的广泛采用。Java开发人员已经学习了使用迭代器的基本模式，并且准备好并愿意学习和逐步过渡到使用更高级别的API。</p><h1 id="b2f8" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">太少=贫血&amp;&amp;太多=臃肿</h1><p id="79b5" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">API太少或太多都有可能。在中间的某个地方，一个API会觉得“刚刚好”。Java同时支持对象和原语类型，这使得API设计者的目标变得复杂。</p><p id="e6a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Eclipse集合在Java中提供了尽可能多的对象和基本类型之间的互操作性。这有时会导致所需的接口、类和方法的数量成倍增加。例如，<code class="du kv kw kx ky b">MutableList</code>上的<code class="du kv kw kx ky b">collect</code>和<code class="du kv kw kx ky b">sort</code>方法都有每种基本类型的基本版本。如果我们将方法的总数减少到核心概念的总数，那么开发人员需要学习的新概念的数量会更合理。例如，如果您学习了Eclipse集合中的<code class="du kv kw kx ky b">collect</code>模式，这是一个核心概念，您将已经知道所有的<code class="du kv kw kx ky b">collect</code> <em class="lc"> * </em>(例如<code class="du kv kw kx ky b">collectInt</code>、<code class="du kv kw kx ky b">collectShort</code>等等。)方法管用。</p><p id="051b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下图中，我只包含了MutableList的核心概念API。我已经放弃了所有的"<code class="du kv kw kx ky b">With</code>"方法和除了"<code class="du kv kw kx ky b">Int</code>"之外的所有原始方法。这总共从输出中删除了大约40个方法。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ll"><img src="../Images/6e0eb144b1d7be26d51c3f10f2707720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNVLf6TZQlBTvGAF91JzNw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">MutableList Core Concepts</figcaption></figure><p id="53c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了理解所有其他基本方法是如何工作的，知道一个基本方法是如何工作的就足够了。如果一个API的开发者有<a class="ae kz" rel="noopener" href="/@donraab/symmetric-sympathy-2c59d4541d60">对称的同情心</a>，你将能够容易地理解和使用每一个核心概念。</p><h1 id="00bb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Java日期和时间的演变</h1><p id="7fbd" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">从最小API到丰富API的进化变化的另一个例子是在Java时间库中。比较Java 8以来可用的<code class="du kv kw kx ky b">Date</code>类和<code class="du kv kw kx ky b">LocalDate</code>类上的方法。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lm"><img src="../Images/04348b22cbf0731497ad94474bb669f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgLwggED-S8HzFyAhDiXKQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Date compared to LocalDate</figcaption></figure><p id="80c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java时间库有一个更加人性化的API来处理日期和时间。它很好地平衡了丰富性和极简主义。</p><h1 id="5b7e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">来源的来源</h1><p id="bc9f" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">下面的源代码用于输出上述接口和类中的所有方法。你可以用它输出你想要的任何类的任何方法。尝试更改分组的函数，以获得类或接口的API的不同视图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ln"><img src="../Images/ea57cbf62015eb41222826aec962a3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghO9ZlT1EIpHC8Q1bBNzHA.png"/></div></div></figure><pre class="jd je jf jg fd lo ky lp lq aw lr bi"><span id="03af" class="ls jt hh ky b fi lt lu l lv lw">public void outputMethodsByFirstLetter(Class&lt;?&gt;... classes)<br/>{<br/>    Function&lt;Method, Character&gt; firstLetter =<br/>            method -&gt; Character.<em class="lc">valueOf</em>(method.getName().charAt(0));<br/><br/>    String classNamesString =<br/>            ArrayIterate.<em class="lc">collect</em>(classes, Class::getSimpleName)<br/>                    .makeString();<br/><br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<br/>            classNamesString);<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<br/>            StringIterate.<em class="lc">repeat</em>(<strong class="ky hi">'-'</strong>, classNamesString.length()));<br/><br/>    MutableList&lt;Method&gt; methods =<br/>            ArrayIterate.<em class="lc">flatCollect</em>(<br/>                    classes,<br/>                    each -&gt; ArrayAdapter.<em class="lc">adapt</em>(each.getMethods()));<br/><br/>    String output = methods.groupBy(firstLetter)<br/>            .collectValues(<br/>                    Method::getName,<br/>                    TreeSortedSetMultimap.<em class="lc">newMultimap</em>())<br/>            .keyMultiValuePairsView()<br/>            .toSortedListBy(Pair::getOne)<br/>            .makeString(<strong class="ky hi">"\n"</strong>);<br/><br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(output);<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println();<br/>}</span></pre><h2 id="47f2" class="ls jt hh bd ju lx ly lz jy ma mb mc kc ip md me kg it mf mg kk ix mh mi ko mj bi translated">更新:2019年6月3日</h2><p id="cba2" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">下面的源代码将向您展示两个类中方法的对称差异和交集。只需在第一个方法中改变你想要比较的两个类。</p><pre class="jd je jf jg fd lo ky lp lq aw lr bi"><span id="b88b" class="ls jt hh ky b fi lt lu l lv lw">@Test<br/>public void symmetricDifferenceAndIntersectionOfApis()<br/>{<br/>    this.symmetricDiffAndIntersectionOfApis(Collectors.class, Collectors2.class);<br/>}<br/><br/>public void symmetricDiffAndIntersectionOfApis(Class&lt;?&gt; classOne, Class&lt;?&gt; classTwo)<br/>{<br/>    MutableSet&lt;String&gt; leftMethods =<br/>            Sets.<strong class="ky hi"><em class="lc">mutable</em></strong>.with(classOne.getMethods())<br/>                    .collect(this::methodNamePlusParms);<br/>    MutableSet&lt;String&gt; rightMethods =<br/>            Sets.<strong class="ky hi"><em class="lc">mutable</em></strong>.with(classTwo.getMethods())<br/>                    .collect(this::methodNamePlusParms);<br/><br/>    String classNames = classOne.getSimpleName() + <br/>            <strong class="ky hi">", " </strong>+ <br/>            classTwo.getSimpleName();<br/>    this.symmetricDifference(leftMethods, rightMethods, classNames);<br/>    this.intersection(leftMethods, rightMethods, classNames);<br/>}<br/><br/>private String methodNamePlusParms(Method method)<br/>{<br/>    return method.getName() + <strong class="ky hi">"(" </strong>+<br/>            ArrayIterate.<em class="lc">collect</em>(method.getParameters(), Parameter::getType)<br/>                    .collect(Class::getSimpleName)<br/>                    .makeString() + <strong class="ky hi">")"</strong>;<br/>}<br/><br/>private void symmetricDifference(<br/>        MutableSet&lt;String&gt; leftMethods,<br/>        MutableSet&lt;String&gt; rightMethods,<br/>        String classNames)<br/>{<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<strong class="ky hi">"Symmetric Difference (" </strong>+ classNames + <strong class="ky hi">")"</strong>);<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<br/>            StringIterate.<em class="lc">repeat</em>(<strong class="ky hi">'-'</strong>, <br/>                    (<strong class="ky hi">"Symmetric Difference (" </strong>+ classNames + <strong class="ky hi">")"</strong>)<br/>                    .length()));<br/>    this.outputGroupByToString(leftMethods.symmetricDifference(rightMethods));<br/>}<br/><br/>private void intersection(<br/>        MutableSet&lt;String&gt; leftMethods,<br/>        MutableSet&lt;String&gt; rightMethods,<br/>        String classNames)<br/>{<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<strong class="ky hi">"Intersection (" </strong>+ classNames + <strong class="ky hi">")"</strong>);<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(<br/>            StringIterate.<em class="lc">repeat</em>(<strong class="ky hi">'-'</strong>, <br/>                    (<strong class="ky hi">"Intersection (" </strong>+ classNames + <strong class="ky hi">")"</strong>)<br/>                    .length()));<br/>    this.outputGroupByToString(leftMethods.intersect(rightMethods));<br/>}<br/><br/>private void outputGroupByToString(RichIterable&lt;String&gt; methods)<br/>{<br/>    Function&lt;String, Character&gt; firstLetter = string -&gt; Character.<em class="lc">valueOf</em>(string.charAt(0));<br/><br/>    String output = methods.groupBy(firstLetter)<br/>            .collectValues(<br/>                    each -&gt; each,<br/>                    TreeSortedSetMultimap.<em class="lc">newMultimap</em>())<br/>            .keyMultiValuePairsView()<br/>            .toSortedListBy(Pair::getOne)<br/>            .makeString(<strong class="ky hi">"\n"</strong>);<br/><br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println(output);<br/>    System.<strong class="ky hi"><em class="lc">out</em></strong>.println();<br/>}</span></pre><h2 id="da49" class="ls jt hh bd ju lx ly lz jy ma mb mc kc ip md me kg it mf mg kk ix mh mi ko mj bi translated">更新:2019年6月5日</h2><p id="cc68" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">我重构了计算对称差和交集的代码，用<code class="du kv kw kx ky b">MutableSortedSet</code>代替<code class="du kv kw kx ky b">MutableSet</code>。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="a235" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">每天都学些新东西</h1><p id="e9c3" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">一些开发人员可能会觉得像Eclipse Collections这样全面的API令人生畏。好消息是，有了Eclipse集合，您可以按照自己的节奏学习和使用API。例如，<code class="du kv kw kx ky b">MutableList</code>扩展了<code class="du kv kw kx ky b">java.util.List</code>，所以如果您熟悉Java中的<code class="du kv kw kx ky b">List</code> API，那么您已经熟悉了Eclipse集合中的<code class="du kv kw kx ky b">MutableList</code> API的基础。如果您已经投资学习Java <code class="du kv kw kx ky b">Stream</code>和<code class="du kv kw kx ky b">Collectors</code>，您也可以将这些概念用于Eclipse集合类型。还有更方便的直接在集合类型上使用的方法，比如<code class="du kv kw kx ky b">MutableList</code>本身。如果Eclipse集合中的一些不同方法名称看起来很奇怪，不要担心，有一个<a class="ae kz" rel="noopener" href="/@donraab/a-rose-by-any-other-name-e15060d4c98e">博客可以帮助您将Streams方法名称转换为Eclipse集合方法名称</a>。</p><p id="0483" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">学习像迭代模式这样的新事物将帮助你成为一个更好的开发人员，不管你用什么语言编程。这些年来，我在Smalltalk、Ruby、Scala、Groovy、Haskell、Clojure、Python和JavaScript中学习并尝试了迭代模式API。我还写过比较五种不同Java集合框架的katas。这使得我在处理集合时可以更容易地在这些语言和库之间转换。</p><p id="433f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lc">我是</em><a class="ae kz" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lc">Eclipse Collections</em></a><em class="lc">OSS项目在</em><a class="ae kz" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lc">Eclipse Foundation</em></a><em class="lc">的项目负责人和提交人。</em> <a class="ae kz" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lc">月食收藏</em> </a> <em class="lc">为</em> <a class="ae kz" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lc">投稿</em> </a> <em class="lc">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>