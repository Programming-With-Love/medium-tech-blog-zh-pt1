# ReactJS SSR 分析和缓存

> 原文：<https://medium.com/walmartglobaltech/reactjs-ssr-profiling-and-caching-5d8e9e49240c?source=collection_archive---------1----------------------->

![](img/2f7b34d6a0c1baa107d18e4524c72e06.png)

arielrobin (Public Domain) [https://pixabay.com/en/measure-yardstick-tape-ruler-1509707/](https://pixabay.com/en/measure-yardstick-tape-ruler-1509707/)

# 介绍

在沃尔玛，我们一直忙于迁移我们的[电子商务](http://careers.walmart.com/about-us/ecommerce/)网站，以使用 [ReactJS](http://reactjs.net/) 。通过其声明式和基于组件的方法来创建交互式 ui，我们的开发人员对这种采用反应非常积极。

由于我们的网站主要是电子商务，搜索引擎优化是一个重要的要求，这意味着从服务器返回 HTML。通过内置的服务器端呈现(SSR)，ReactJS 允许我们构建可以在服务器和客户端上呈现的同构代码。不幸的是，SSR 的一个缺点是对复杂组件的巨大性能影响，我们一直在努力改进 SSR 时间。

[萨沙·艾金](https://medium.com/u/1dcba27e6a5c?source=post_page-----5d8e9e49240c--------------------------------)做了一个[精彩的演讲](https://www.youtube.com/watch?v=PnpfGy7q96U)，提供了加速 SSR 的技巧和诀窍。在应用了他的所有技巧之后，性能得到了实质性的提高，但是我们仍然看到我们的服务器在同步 *renderToString* 方法中花费了超过 100 毫秒的时间。Sasha 还做了一个组件缓存的快速演示，将时间减少到个位数。尽管缓存可能很棘手，但是为了进一步减少我们的 SSR 时间，我们求助于缓存。

我们有多个开发人员从事 SSR 性能和缓存的不同方面的工作。在这篇博客中，我将详细介绍我在 SSR 组件缓存、性能分析、创建自定义缓存配置文件及其验证以及组件缓存能力方面的经验。

# SSR 组件缓存

这个想法很简单。在 Sasha 的版本中，由于他分叉并修补了 React 的代码来做流，所以他在[*mountcomponentsync*方法中为*ReactCompositeComponent*](https://github.com/aickin/react/blob/streaming-render-0.5/src/renderers/shared/reconciler/ReactCompositeComponent.js#L446-L457)处理缓存。

由于我们使用的是原始的 React 模块，我们可以直接修补*ReactCompositeComponent*来包装它的 *mountComponent* 方法，如下面的代码所示。

Patch ReactCompositeComponent to do component caching for React SSR.

接下来，我们需要生成缓存键的策略。有两种方法:“简单”和“模板”。从技术上讲，还有第三种方法可以称为“定制”它基本上允许每个组件提供一个返回缓存键的自定义函数，我不会详细讨论这个函数。

简单的策略就是直接散列道具。这适用于很少有变体的组件，比如我们的*页眉*和*页脚*组件，但不适用于更动态的组件。

例如，[Walmart.com 网站](http://www.walmart.com)上的每件商品都有自己的属性，如名称和价格。如果我们缓存所有的条目，那么缓存的大小会太大，因为我们有数百万个条目。

我们的收藏和分类页面在一个页面上列出了许多项目，他们需要 SSR。由于每个项目需要几毫秒的时间来呈现，在一些大的集合页面上，SSR 时间可能是 200 毫秒或更长。

为了解决这个问题，我们通过模板化 props 来生成缓存键。

# 模板组件道具

“模板”策略是用特殊令牌替换道具值，而不是直接使用原来的道具。使用模板属性，我们使用 hash 创建缓存键，然后呈现组件。React SSR *renderToString* 返回内部带有这些特殊标记的 HTML 字符串，可以认为是一个模板 HTML。只要一个组件使用模板或实际道具来呈现相同的 HTML 结构，我们就能够缓存和重用模板 HTML。我们只需要使用字符串替换来将令牌更改为真实值。我认为它是从 React 组件中生成类似无逻辑把手模板的东西。

例如，下面是我们的一个收藏页面的截图，产品卡以红色突出显示。

![](img/3e76d63ea9e110b3c7c5746c4ee05120.png)

如果我们用像 **{1}、{2}、{3}** 等标记来替换价格和标题。，那么我们可以得到一个产品卡的 HTML 模板，看起来可能像下面的图片。

![](img/0852486b98282ea465059cac2220b6fb.png)

下一张图片是一个代码样本，展示了*将一个道具变成一个模板*的样子。请注意，它没有使用字符串 JSON 路径作为模板 props 中的值，而是使用了一个间接的查询表来引用 JSON 路径，以从 props 中获取原始值。

查找表增加了更多的保证，字符串 JSON 路径不会在生成的 HTML 模板中受到影响，这将更小、更干净。它还允许将 JSON 路径保存为数组，而不是字符串。下面是这个过程的一个例子。

A sample of a template for a props. When calling the original mountComponent, template is passed in instead of props.

这就是两种缓存策略。有些组件与其中一个配合得很好，有些则与另一个配合得更好。

为了提高 SSR 的缓存性能，我首先需要弄清楚哪些组件可以被缓存，以及要使用的策略。为此，我首先对 SSR 进行了一些分析。

# SSR 性能分析

如果您有适合“简单”策略的组件，它们应该很容易被挑选出来。我们没有很多这样的页面，但是像页面上的*页眉*和*页脚*都是很好的页面。

由于“模板”策略需要一些处理来生成模板和恢复值，所以最好是将它与更昂贵的组件一起使用。为了找出花费最长时间渲染的组件，我们可以在修补的 *mountComponent* 方法中跟踪它们的渲染时间，如下面的代码所示。

Wrap mountComponent to collect render timing for composite component.

我会用上面的代码对收集的数据运行一次 SSR，但我会在关闭概要分析的情况下运行几次，以便 V8 引擎优化预热。在对收集数据运行 SSR 之后，我收集了计时信息并将数据记录到一个文件中。以下是 YAML 格式数据的部分示例。

A partial sample of the profileData collect with our collections page.

有了这些数据，我挑选了一些组件来开发一个定制的模板配置文件，以测试缓存它们。

# 自定义缓存配置文件和验证

为了提供数据来应用“模板”策略缓存一些复合组件，在我的完整概要分析代码中，我还捕获并保存了属性。有了这些数据，我对一些昂贵的组件进行了缓存实验，并发现了一些运行良好的缓存配置文件。尽管许多组件不支持缓存，但我们的产品收集组件在所有收集数据上的 SSR 时间*平均提高了 50%或更多*。

为了找到适合模板策略缓存的组件，我在缓存代码中添加了自动验证代码。代码将使用真实的道具进行渲染，然后查找缓存的版本。如果它们匹配，那么组件可以被缓存。当然，最初很少(事实上，没有)匹配。我手动保存 HTML 字符串，并使用 [kDiff3](http://kdiff3.sourceforge.net/) 对它们进行比较，以微调各个组件的散列。在微调时，我在两种缓存策略中都应用了一种技术，即手动分析组件属性，以识别和忽略一些不会影响渲染输出的关键点。

为了验证缓存是否正常工作，我从我们的数据库下载了所有的集合数据，并在有缓存和没有缓存的情况下对它们进行了渲染。然后我比较结果，以确保它们是相同的。为了进行比较，我首先从 HTML 字符串中删除了所有的*数据反应 id* 和*数据反应校验和*属性。

我发现字符串值的一些问题是，组件可能会对字符串应用编码，但并不总是如此。一个例子是当字符串值被用作 HTML 标签中的属性值时，如果字符串包含单引号或双引号，&，，那么它们将被编码。另一种情况是当值是一个 URL 时，组件将从它们中删除任何 **http:** 或 **https:** 前缀。对于这些，当恢复属性值时，我检测它们并格式化这些值。

尽管如此，许多组件根本无法缓存。这是因为它们的渲染逻辑严重依赖于实际的属性值。我称之为“组件缓存能力”，这需要通过缓存来提高我们的集合页面的性能。

# 组件缓存能力

开箱即用，大多数组件都不适合缓存。如果组件 props 包含*子对象*，我们避免缓存它们。

具有变化较大的道具的组件，不适合“简单”策略，可能是“模板”策略的候选，这也限制了可以应用什么组件。

对于“模板”策略，组件不能被缓存的一些基本原因是:

*很难(或不可能)模板化非字符串属性，因为代码更可能具有依赖于这些值的逻辑。例如基于布尔值的两个执行路径，或者基于具有不同值的数字的循环。即使使用字符串属性，代码也会根据值的不同而表现不同。例如，收集状态可以是“已发布”或“未发布”此外，代码可以对字符串值应用格式。*

如果一个复杂的组件将依赖于属性值的逻辑与其他呈现代码混合在一起，那么整个组件都不可缓存。例如，我们有一个组件，可以根据客户对产品的评论显示星级。对于任何大于 0.4 的部分十进制值，该组件都显示一个半星号。基于 HTML 结构，大约有 10 种不同的渲染输出。对于“简单”策略来说，这是一个很好的选择，但是它是不可缓存的，因为平均审查值是一个小数，并且有很大的变化。对于决定是否显示半星号的组件逻辑来说，这很重要。

这个组件的道具只有两个属性:*总星*和*平均化*。为了使用“简单”策略使这个组件可缓存，我们可以对*进行计算，平均化*以首先找到完整恒星和部分恒星的数量，然后我们可以将昂贵的渲染逻辑分离到另一个容易缓存的组件中。

现在，我们有了一个新的*评级*组件，它仍然不可缓存，但具有轻量级逻辑。具有昂贵渲染逻辑的 *Stars* 组件现在可以使用“简单”策略进行缓存，因为 *avgFloor* 是 1-5 范围内的整数(如果*total Stars*= = 5)*部分*为*真*或*假*仅*。*

我们有一个非常复杂的组件，它应该是“模板”策略的一个很好的候选者，那就是产品卡组件。它用图像、产品名称和价格来显示产品。图像 URL 和产品名称可以很容易地转换成模板，但价格却不能，因为组件将价格分解成美元和美分的数量，并以不同的样式显示它们。如果我们创建一个新的组件，它包含首先分离价格的逻辑，那么呈现组件将只显示，然后用“模板”策略缓存。

# 结论

ReactJS 为 web 开发提供了一种全新的方法，支持同构，但同步服务器端呈现性能是复杂组件的一个问题。我们正在通过组件缓存来改善这一点。

web 组件上任何类型的缓存都是危险和棘手的。如果页面上有用户特定的个性化信息，那么在缓存时就要格外小心。对于像[Walmart.com](http://www.walmart.com)这样的电子商务网站，我们以相似的格式展示数百万件产品，组件缓存是有帮助的。

尽管如此，缓存仍然很棘手，需要对不同的组件应用不同的缓存策略和配置文件。组件缓存能力很重要，它有助于在编写组件时牢记这一点。

# 其他新闻和更新

感谢您的阅读。如果你想了解更多我们正在做的事情，请查看我们的其他帖子，如[企业级建筑反应堆](/walmartlabs/building-react-js-at-enterprise-scale-17c17a36fd1f#.lhdfx4h1i)。

非常感谢:[马克西姆·纳吉姆](https://medium.com/u/7ac90020ff3b?source=post_page-----5d8e9e49240c--------------------------------)，[亚历克斯·格里戈良](https://medium.com/u/54a709eacdb7?source=post_page-----5d8e9e49240c--------------------------------)(推特: [@lexgrigoryan](http://twitter.com/lexgrigoryan) )，以及[阿潘·纳纳瓦提](https://medium.com/u/d8fa8407b711?source=post_page-----5d8e9e49240c--------------------------------)(推特:[@纳纳瓦提阿潘](http://twitter.com/nanavatiarpan))。