<html>
<head>
<title>Migrating to the new coroutines 1.6 test APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迁移到新的协程1.6测试API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-to-the-new-coroutines-1-6-test-apis-b99f7fc47774?source=collection_archive---------5-----------------------#2022-06-29">https://medium.com/androiddevelopers/migrating-to-the-new-coroutines-1-6-test-apis-b99f7fc47774?source=collection_archive---------5-----------------------#2022-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c280add9ed9ca9f364efa932861a872b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQmi35H84FdYhY_ONP6ntQ.png"/></div></div></figure><div class=""/><p id="7e28" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><code class="du jo jp jq jr b"><a class="ae js" href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0" rel="noopener ugc nofollow" target="_blank">kotlinx.coroutines</a></code> <a class="ae js" href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0" rel="noopener ugc nofollow" target="_blank"> 1.6 </a>引入了一组新的测试API，之前的测试API现在已经被弃用。使用旧的API将很快产生弃用错误，它们计划在2022年底左右被完全移除。</p><p id="1241" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们最近发布了一个关于如何使用新的测试API的<a class="ae js" href="https://developer.android.com/kotlin/coroutines/test" rel="noopener ugc nofollow" target="_blank">指南，详细解释了它们是如何工作的。在这篇文章中，我们将通过查看我们如何迁移我们自己的一些示例来关注从旧API的迁移。你可以在这篇文章的末尾找到链接来查看完整的差异。</a></p><p id="b741" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们采取的迁移步骤应该涵盖了大多数Android项目的许多必要工作。如果您发现这些对您的项目来说还不够，您可以看看JetBrains的详细的<a class="ae js" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md" rel="noopener ugc nofollow" target="_blank">迁移指南</a>，它也涵盖了测试API的高级用法。</p><h2 id="0672" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">从运行测试开始</strong></h2><p id="6401" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">让我们从新测试API的入口点开始，<code class="du jo jp jq jr b"><a class="ae js" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html" rel="noopener ugc nofollow" target="_blank">runTest</a></code>协程构建器。这取代了旧API中的<code class="du jo jp jq jr b">runBlockingTest</code>,它可以作为顶级函数被调用，但是它也经常在测试范围、测试调度程序或者测试规则中被调用。</p><p id="5447" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们已经用对顶级<code class="du jo jp jq jr b">runTest</code>函数的调用替换了所有这些:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="38b4" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果你还没有使用表达式体(直接从函数返回<code class="du jo jp jq jr b">runTest</code>的结果),现在也是采用这个约定的好时机！这对于一致性来说很好，如果您在多平台项目中使用带有KotlinJS目标的协程测试API，这是必需的。</p><p id="5416" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在一些高级情况下，您可能仍然希望<a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#creating-your-own-testscope" rel="noopener ugc nofollow" target="_blank">创建自己的</a> <code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#creating-your-own-testscope" rel="noopener ugc nofollow" target="_blank">TestScope</a></code>，但是大多数测试只需要单独调用<code class="du jo jp jq jr b">runTest</code>。</p><h2 id="4fca" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">处理主线程</strong></h2><p id="0061" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">由于Android UI线程在单元测试中不可用，任何依赖于<code class="du jo jp jq jr b">Main</code> dispatcher的测试都需要在测试期间用一个<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#testdispatchers" rel="noopener ugc nofollow" target="_blank">TestDispatcher</a></code>实现来替换它。你可以像其他调度器一样<a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#injecting-test-dispatchers" rel="noopener ugc nofollow" target="_blank">注入，或者用<code class="du jo jp jq jr b"><a class="ae js" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.setMain</a></code>替换。使用<code class="du jo jp jq jr b">setMain</code>以静态的方式取代了调度程序，这意味着您可以在测试中使用依赖于硬编码<code class="du jo jp jq jr b">Main</code>调度程序的构造，比如<code class="du jo jp jq jr b"><a class="ae js" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">viewModelScope</a></code>。</a></p><p id="a547" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">一种常用的方法是将替换<code class="du jo jp jq jr b">Main</code>的代码放入一个可重用的<a class="ae js" href="https://junit.org/junit4/javadoc/4.12/org/junit/rules/TestRule.html" rel="noopener ugc nofollow" target="_blank"> JUnit测试规则</a>(或者对于JUnit 5，一个测试扩展)。你可以在iosched项目中看到这样一个规则的例子。如果您使用旧的API有这样的规则，请按如下方式更新它:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="fe4f" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然后，像这样使用规则，作为测试类的一个属性(与以前没有变化):</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="a12a" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">更加渴望:收集流量</strong></h2><p id="8890" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">测试通常会启动新的协同程序从流中收集值。这些测试倾向于依赖这些急切启动的新协程，以便无论何时流发出一个值，收集器都已经准备好处理它。</p><p id="e228" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当<code class="du jo jp jq jr b">runBlockingTest</code>急切地启动在测试中创建的新协程时，<code class="du jo jp jq jr b">runTest</code>却懒洋洋地启动它们，因为默认情况下它使用一个<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#standardtestdispatcher" rel="noopener ugc nofollow" target="_blank">StandardTestDispatcher</a></code>用于测试协程。</p><p id="2801" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了让测试中的流收集协程再次急切地启动，创建一个新的<code class="du jo jp jq jr b">UnconfinedTestDispatcher</code>，并将其传递给创建收集协程的构建器:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="3f03" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">注意，在这个代码片段中，创建了一个新的<code class="du jo jp jq jr b">TestDispatcher</code>,而没有显式地传入调度程序。只有当<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#setting-main-dispatcher" rel="noopener ugc nofollow" target="_blank">Main</a></code> <a class="ae js" href="https://developer.android.com/kotlin/coroutines/test#setting-main-dispatcher" rel="noopener ugc nofollow" target="_blank">调度程序已经被<code class="du jo jp jq jr b">TestDispatcher</code>取代</a>时，这样做才是安全的，这使得调度程序共享是自动的。否则，您必须将现有的调度程序传递给您创建的任何<code class="du jo jp jq jr b">TestDispatchers</code>:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4cb3" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">同样值得记住的是，显式调用collect并不是收集流的唯一方法，其他方法如<code class="du jo jp jq jr b"><a class="ae js" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">Flow.toList()</a></code>也在内部收集流。如果您正在使用这样的方法，您可能还想在以<code class="du jo jp jq jr b">UnconfinedTestDispatcher</code>开头的新协程中调用它们。</p><h2 id="2e79" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">不要急于求成:主调度员执行</strong></h2><p id="77b1" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">正如您在上面的<code class="du jo jp jq jr b">MainDispatcherRule</code>实现中看到的，我们默认使用<code class="du jo jp jq jr b">UnconfinedTestDispatcher</code>让<code class="du jo jp jq jr b">Main</code>调度程序急切地启动协程。这在测试视图模型时很有用，当从主线程调用时，在生产代码中使用<code class="du jo jp jq jr b">Dispatchers.Main.immediate</code>会有类似的急切行为。</p><p id="f19e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然而，<a class="ae js" href="https://github.com/android/architecture-samples/blob/f042c781a6cb959426c4606160cf9d2da50eb045/app/src/test/java/com/example/android/architecture/blueprints/todoapp/statistics/StatisticsViewModelTest.kt#L102-L118" rel="noopener ugc nofollow" target="_blank">我们样本中的一些测试</a>需要<code class="du jo jp jq jr b">Main</code> dispatcher协程的惰性调度。通常，这将用于需要断言ViewModel的中间加载状态的测试，其中急切地启动数据加载协程将意味着测试只能观察最终的加载状态。对于旧的API，这些测试使用<code class="du jo jp jq jr b">pauseDispatcher</code>来防止新的协程过早执行，就像这样:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="3740" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了对新的API执行相同的测试，需要将<code class="du jo jp jq jr b">Main</code> dispatcher设置为<code class="du jo jp jq jr b">StandardTestDispatcher</code>，因此我们需要一个不同于规则默认使用的<code class="du jo jp jq jr b">TestDispatcher</code>类型。由于用于<code class="du jo jp jq jr b">MainDispatcherRule</code>的<code class="du jo jp jq jr b">TestDispatcher</code>的类型影响测试类中的所有测试，我们有两个选择:</p><ul class=""><li id="dd53" class="kz la hs is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">根据每个测试所需的<code class="du jo jp jq jr b">Main</code>调度程序的类型，将测试分成两个测试类，在两个测试类中使用不同类型调度程序的规则，或者</li><li id="9409" class="kz la hs is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">继续使用单个类，规则总是为<code class="du jo jp jq jr b">Main</code>设置一个<code class="du jo jp jq jr b">UnconfinedTestDispatcher</code>，然后在一些需要不同类型的测试中覆盖<code class="du jo jp jq jr b">Main</code> dispatcher的类型。</li></ul><p id="290c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们选择了后一种解决方案，通过用新的<code class="du jo jp jq jr b">StandardTestDispatcher</code>替换<code class="du jo jp jq jr b">Main</code>中已经被替换的<code class="du jo jp jq jr b">TestDispatcher</code>来开始这些测试，从而在<code class="du jo jp jq jr b">Main</code>上延迟启动新的协程。然后，在稍后的测试代码中，当我们用旧的API调用<code class="du jo jp jq jr b">resumeDispatcher</code>时，我们可以通过使用<code class="du jo jp jq jr b">advanceUntilIdle</code>来改进这些协程。</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0d9d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这种方法将属于同一个测试类的测试保留在一起，使得代码库更容易导航，代价是一些测试必须包含额外的代码来用期望类型的<code class="du jo jp jq jr b">TestDispatcher</code>替换<code class="du jo jp jq jr b">Main</code>。</p><h2 id="5518" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">清理那个清理代码</h2><p id="ddb1" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">最后，做一些快速整理。iosched样本有一些<a class="ae js" href="https://github.com/google/iosched/blob/69db6ea7772093fc286df5d1f317aff8f3b02c5d/mobile/src/test/java/com/google/samples/apps/iosched/ui/feed/FeedViewModelTest.kt#L104-L105" rel="noopener ugc nofollow" target="_blank">测试代码，这些代码在测试结束之前明确地等待</a>协程在<code class="du jo jp jq jr b">TestCoroutineDispatcher</code>上完成:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0da5" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然而，<code class="du jo jp jq jr b">runTest</code>自动等待所有已知的协同程序，包括测试协同程序的子进程和任何运行在<code class="du jo jp jq jr b">TestDispatchers</code>上的协同程序。这意味着您可以删除任何等待一些松散协程完成的清理代码！</p><h2 id="a6ae" class="jt ju hs bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">总结</strong></h2><p id="2d98" class="pw-post-body-paragraph iq ir hs is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn ha bi translated">这些迁移步骤应该让您基本上能够使用新的协程测试API。如需了解更多信息，您可以查看我们在样本中所做的所有更改:</p><ul class=""><li id="7bd9" class="kz la hs is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated"><a class="ae js" href="https://github.com/google/iosched/pull/404" rel="noopener ugc nofollow" target="_blank">丢失公关</a>(还有一个小<a class="ae js" href="https://github.com/google/iosched/pull/428" rel="noopener ugc nofollow" target="_blank">后续</a>)</li><li id="b0b4" class="kz la hs is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><a class="ae js" href="https://github.com/android/architecture-samples/pull/825" rel="noopener ugc nofollow" target="_blank">建筑-样品公关</a></li><li id="62fe" class="kz la hs is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><a class="ae js" href="https://github.com/android/trackr/pull/45" rel="noopener ugc nofollow" target="_blank">跟踪公关</a></li></ul><p id="4a81" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当然，Android示例应用中的新<a class="ae js" href="https://github.com/android/nowinandroid" rel="noopener ugc nofollow" target="_blank">已经使用了新的测试API进行测试！</a></p><p id="8167" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最后，如果您在迁移方面需要更多帮助，请查看JetBrains的官方<a class="ae js" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md" rel="noopener ugc nofollow" target="_blank">迁移指南</a>，其中涵盖了复杂的协程测试API。</p></div></div>    
</body>
</html>