<html>
<head>
<title>How to Transfer a Large Amount of Files From MongoDB to an S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将大量文件从MongoDB传输到S3</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-transfer-a-good-amount-of-files-from-mongodb-to-an-s3-ce5266ab8c9?source=collection_archive---------1-----------------------#2019-12-17">https://medium.com/quick-code/how-to-transfer-a-good-amount-of-files-from-mongodb-to-an-s3-ce5266ab8c9?source=collection_archive---------1-----------------------#2019-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6246" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">一天内迁移大量文件</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/e166f7155d21230aa59a20ea8b2c834b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bi17jbyUfbLiK8tDUXT66g.png"/></div></div></figure><blockquote class="ji"><p id="ef39" class="jj jk hh bd jl jm jn jo jp jq jr js dx translated">在这个故事中，也是我的第一个故事，我们将深入到将MongoDB文件迁移到S3对象存储的过程中(尽管如果您想将它们迁移到其他地方，您可以遵循迁移之前的所有步骤)。</p><p id="8a2b" class="jj jk hh bd jl jm jt ju jv jw jx js dx translated">我们将简要介绍mongo如何存储文件以及如何访问它们。然后，我们将了解如何将这些文件导出到您的服务器磁盘，最后，如何将它们上传到您的S3实例。</p><p id="c4e8" class="jj jk hh bd jl jm jt ju jv jw jx js dx translated">但是首先，有一点背景故事关于我如何结束需要转移41GB的300K图像文件。</p><p id="0984" class="jj jk hh bd jl jm jt ju jv jw jx js dx translated">(为了坚持到底，如果您对Linux生态系统有一个基本的了解将会有所帮助)</p></blockquote></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><p id="6398" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">几年前，我们开始开发一个社交移动应用，它使用<a class="ae la" href="https://github.com/parse-community/parse-server" rel="noopener ugc nofollow" target="_blank">解析服务器</a>作为后端。对于那些不知道的人来说，Parse Server是一个<code class="du lb lc ld le b">Node.js</code>基础设施，它利用了<code class="du lb lc ld le b">express</code>框架的优点，并将<code class="du lb lc ld le b">MongoDB</code>用作数据库。</p><p id="2812" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">默认情况下，Parse Server有一个文件适配器，可以让你非常容易地将应用程序文件直接存储到MongoDB中<em class="lf">(他们也提供S3和GCS文件适配器)</em>。于是负责后端的无知的过去的自己，以及app的iOS部分，认为让它保持默认的方式是一个非常方便/省钱的想法。</p><p id="d138" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">两年和<strong class="kh hi"> 30万个图像文件</strong>之后，我们的应用程序增长了很多，我们决定将所有这些文件存储到我们的MongoDB，这可能不是最好的主意！就这样，我们的文件传输之旅开始了！</p><h1 id="84d4" class="lg lh hh bd li lj lk ll lm ln lo lp lq in lr io ls iq lt ir lu it lv iu lw lx bi translated">首先，MongoDB到底是怎么存储文件的？</h1><p id="0f58" class="pw-post-body-paragraph kf kg hh kh b ki ly ii kk kl lz il kn ko ma kq kr ks mb ku kv kw mc ky kz js ha bi translated">嗯，经过一些研究，我发现MongoDB有一个名为<code class="du lb lc ld le b">GridFS</code>的文件系统，它负责存储和检索文件。它是这样工作的。共有两个系列，<code class="du lb lc ld le b">fs.files</code>和<code class="du lb lc ld le b">fs.chunks</code>。第一个包含您存储的每个文件的元数据，如其名称和创建日期。后者包含——除了别的以外——二进制格式的文件的实际数据。</p><p id="94cd" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">下面是文件在<strong class="kh hi"> fs.files </strong>中的实际样子:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="43a0" class="mh lh hh le b fi mi mj l mk ml">{<br/>  "_id" : ObjectId("5ae97922c1dabec8d2d0bdb0"),<br/>  "filename" : "2b57455f3878d11dabc9c984da7de314_postImage.jpeg",<br/>  "contentType" : "binary/octet-stream",<br/>  "length" : 2291623,<br/>  "chunkSize" : 261120,<br/>  "uploadDate" : ISODate("2018-05-02T08:38:58.549Z"),<br/>  "aliases" : null,<br/>  "metadata" : null,<br/>  "md5" : "9ad420eaa7c28a73e449199430627802"<br/>}</span></pre><p id="bec5" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">下面是它在<strong class="kh hi"> fs.chunks </strong>中的样子:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="e8ee" class="mh lh hh le b fi mi mj l mk ml">{<br/>  "_id" : ObjectId("5ae2d77f6616b4a9d93cb4b1"),<br/>  "files_id" : ObjectId("5ae97922c1dabec8d2d0bdb0"),<br/>  "n" : 0,<br/>  "data": BinData(0,"iVBORw0KGgoAAAANSUhEUgAAAuAAAAJvCAYAAAA6OGQEAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRher38tcAAAAASUVORK5CYII=....")<br/>}</span></pre><p id="cf5d" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">那么，我们现在到底在看什么？</p><p id="c84a" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated"><strong class="kh hi"> fs.files </strong>非常简单，让我们从那里开始吧。每个文档有9个标准字段，其中3个是我们现在关心的:<code class="du lb lc ld le b">_id</code>、<code class="du lb lc ld le b">filename</code>和<code class="du lb lc ld le b">uploadDate</code>。那三个字段以后会派上用场。</p><p id="db95" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">现在让我们来看看<strong class="kh hi"> fs.chunks </strong>。我们看到它有一个<code class="du lb lc ld le b">_id</code>字段，就像mongo中的任何其他文档一样。接下来，我们看到它有一个<code class="du lb lc ld le b">files_id</code>字段。这是其关联的<code class="du lb lc ld le b">fs.files</code>文档的id引用。接下来是<code class="du lb lc ld le b">n</code>字段，它是块的序列号。现在，如果你是MongoDB的初学者，你可能会说“老兄，你把我搞糊涂了！”。你看，mongo不仅仅是把一个文件放到一个文档中。它实际上把它分成几部分——或者几大块😉—每个255kB。因此，如果你去存储一个400kB的文件，它将创建2个<code class="du lb lc ld le b">fs.chunks</code>文档…一个255kB，值为0，另一个145kB，值为1。最后，我们有<code class="du lb lc ld le b">data</code>字段，它包含文件的部分数据(取决于文件是否被分割成1个以上的块。如果不是，则包含全部。).</p><blockquote class="mm mn mo"><p id="8971" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated">如果您想亲眼看看您的文件在mongo中的样子，请连接到您的mongo shell并键入:</p></blockquote><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="4cf3" class="mh lh hh le b fi mi mj l mk ml">use your_db_name<br/>db.fs.files.findOne()</span></pre><blockquote class="mm mn mo"><p id="f344" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated">要查找相关的块，请键入:</p></blockquote><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="9055" class="mh lh hh le b fi mi mj l mk ml">db.fs.chunks.find( { files_id: ObjectId('the _id your fs.files document has') } )</span></pre><p id="c0eb" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">现在我们已经很好地理解了MongoDB中文件的结构，让我们进入下一部分！</p><h1 id="ccc5" class="lg lh hh bd li lj lk ll lm ln lo lp lq in lr io ls iq lt ir lu it lv iu lw lx bi translated">如何将文件从数据库导出到磁盘？</h1><p id="3e6c" class="pw-post-body-paragraph kf kg hh kh b ki ly ii kk kl lz il kn ko ma kq kr ks mb ku kv kw mc ky kz js ha bi translated">那是我最纠结的部分！在这之前，我对mongo没有很好的了解，所以我做了每个开发人员发现自己走进死胡同时都会做的事情… google我的出路！</p><p id="09c6" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">显然，mongo提供了一个非常方便的命令行工具——这意味着您可以从bash shell而不是mongo shell运行它——称为<code class="du lb lc ld le b">mongofiles</code>。它所做的事情之一，是在本地导出您要求的实际文件，无论指定在哪里。</p><p id="9d5c" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">让我们先看一个更简单的例子:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="a115" class="mh lh hh le b fi mi mj l mk ml">mongofiles -d db_name list</span></pre><p id="7f4a" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">它将向您显示一个列表——仅仅是文件名和它们的大小，<strong class="kh hi">而不是实际的文件</strong>——所有您存储在数据库中的文件。</p><blockquote class="mm mn mo"><p id="29d3" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注意:</strong>如果您已经启用了对数据库的认证访问，这意味着您已经设置了用户名和密码，您将需要在命令中包含以下参数:</p><p id="9b6b" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><code class="du lb lc ld le b">-u</code>:用户名<br/> <code class="du lb lc ld le b">-p</code>:密码<br/> <code class="du lb lc ld le b">--authenticationDatabase</code> : auth_db_name <strong class="kh hi"> //大概管理员</strong></p></blockquote><p id="83c9" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">现在来看看更有趣的东西:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="be26" class="mh lh hh le b fi mi mj l mk ml">mongofiles -d db_name get filename.jpeg</span></pre><p id="aed5" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">这里我们<strong class="kh hi">实际上从数据库中导出了一个名为<code class="du lb lc ld le b">filename.jpeg</code>的文件</strong>，并将其存储到当前目录中。很简单，对吧？好吧，如果我们只想要一个文件，是的！但是我们想要导出每一个，所以事情变得有点复杂！你看，因为我们需要我们想要导出的每个文件的名称，我们必须先得到它们，然后为每个文件调用<code class="du lb lc ld le b">mongofiles get</code>。那么我们该怎么做呢？</p><p id="1769" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">我们可以像以前一样使用<code class="du lb lc ld le b">list</code>参数来获取每个文件名，但是我们将面临三个问题:</p><ol class=""><li id="1410" class="ms mt hh kh b ki kj kl km ko mu ks mv kw mw js mx my mz na bi translated">通过使用<code class="du lb lc ld le b">list</code>，我们实际上从数据库中请求每一个文件名！如果我们有一千或两千个文件，当然…继续！但是如果你有100K呢？20万？你需要等待相当长的时间来获取文件名，并且要花很长时间来导出它们。我实际计算了一下，对于我的机器来说，导出41GB的300K文件大约需要10个小时！</li><li id="d707" class="ms mt hh kh b ki nb kl nc ko nd ks ne kw nf js mx my mz na bi translated">我们必须解析出每个文件的返回大小，因为我们只需要文件名。</li><li id="cccc" class="ms mt hh kh b ki nb kl nc ko nd ks ne kw nf js mx my mz na bi translated">当我们导出所有这些文件时，新的文件随时可能被存储！尤其是如果你的应用有很多流量，它们可能太多了！那些会怎么样？我们不能只说“谁在乎？别管他们了！”我们也不能一遍又一遍地重复整个过程。</li></ol><p id="02b6" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">显然这不是一个可行的解决方案，<strong class="kh hi">所以这是我决定要做的:</strong>我使用了<code class="du lb lc ld le b">mongoexport</code>命令行工具，根据文件名的<code class="du lb lc ld le b">uploadDate</code>来获取文件名(<code class="du lb lc ld le b">mongoexport</code>提供了一个查询参数，所以我们可以非常具体地搜索什么文件)。这样，我可以将文件名从<code class="du lb lc ld le b">uploadDate</code>导出到<code class="du lb lc ld le b">uploadDate</code>。比如在<code class="du lb lc ld le b">2018–07–01</code>和<br/>T10之间。之后，我会将它们上传到我的S3——稍后会详细介绍——然后，我会从<code class="du lb lc ld le b">2018–12–02</code>和<code class="du lb lc ld le b">2019–03–01</code>导出文件名。我重复这个循环，直到我找到最后一天的文件。</p><p id="695b" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">下面是我如何使用<code class="du lb lc ld le b">mongoexport</code>:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="f228" class="mh lh hh le b fi mi mj l mk ml">mongoexport -d db_name -c fs.files -f filename -q '{ uploadDate: { $gte: new Date("2019-12-01T00:00:00.000Z"), $lt: new Date("2019-12-16T16:35:00.000Z") } }' --csv -o 2019-12-01-to-2019-12-16.csv</span></pre><blockquote class="mm mn mo"><p id="cf42" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注1: </strong>同样，如果您已经启用了对数据库的认证访问，您将需要在命令中包含<code class="du lb lc ld le b">-u</code>、<code class="du lb lc ld le b">-p</code>和<code class="du lb lc ld le b">--authenticationDatabase</code>参数。</p><p id="74eb" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注2: </strong>在我们运行这个命令之后，我们将得到一个导出文档数量的提示(在我们的例子中只是文件名)。记住这个数字很有帮助，可以在以后用导出文件的数量进行交叉验证。</p></blockquote><p id="57fb" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">让我们快速浏览一下我们使用的论点:</p><blockquote class="mm mn mo"><p id="a4d3" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><code class="du lb lc ld le b">-d</code>:数据库名称<br/> <code class="du lb lc ld le b">-c</code>:我们要搜索的集合(在我们的例子中是<code class="du lb lc ld le b">fs.files</code>)<br/><code class="du lb lc ld le b">-f</code>:我们要导出的字段(因为我们只需要<code class="du lb lc ld le b">filename</code> s，这就是我们要设置的)<br/> <code class="du lb lc ld le b">-q</code>:搜索<code class="du lb lc ld le b">fs.files</code>集合所基于的查询<br/> <code class="du lb lc ld le b">--csv</code>:文件名要导出到的文件的类型<strong class="kh hi"> //我们使用csv，因为它最适合我们</strong><br/><code class="du lb lc ld le b">-o</code>:<code class="du lb lc ld le b">-o</code></p></blockquote><p id="9faa" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">所以我们有了我们想要的文件名。如果我们<code class="du lb lc ld le b">cat</code>这个<code class="du lb lc ld le b">.csv</code>文件，我们会看到那个列表。</p><p id="4fc8" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">现在是时候使用那个列表，并最终从数据库中导出我们的文件了！</p><p id="9d2b" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">为此，我们将创建一个名为<code class="du lb lc ld le b">export_files.sh</code>的<code class="du lb lc ld le b">bash script</code>。我们就是这样做的，<em class="lf"> </em>，因为这是一个更好的实践，而不是每次只键入命令:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="b2d8" class="mh lh hh le b fi mi mj l mk ml">#!/bin/bash</span><span id="eae5" class="mh lh hh le b fi ng mj l mk ml"># Define a timestamp function</span><span id="2d9a" class="mh lh hh le b fi ng mj l mk ml">timestamp() {<br/>    date +"%T"<br/>}</span><span id="fb91" class="mh lh hh le b fi ng mj l mk ml">MONGO_DATABASE="db_name"<br/>MONGO_HOST="127.0.0.1"<br/>MONGO_PORT="27017"<br/>DATABASE_USERNAME="username"<br/>DATABASE_PWD="password"<br/>DATABASE_AUTH_DB="admin"</span><span id="18fe" class="mh lh hh le b fi ng mj l mk ml">echo "Started at $(timestamp)"</span><span id="dc88" class="mh lh hh le b fi ng mj l mk ml">xargs &lt;"$1" -P$(nproc) -n1 sudo mongofiles -h "$MONGO_HOST" -d "$MONGO_DATABASE" -u "$DATABASE_USERNAME" -p "$DATABASE_PWD" --authenticationDatabase "$DATABASE_AUTH_DB" --quiet get</span><span id="ef1f" class="mh lh hh le b fi ng mj l mk ml">echo "Finished at $(timestamp)"</span></pre><p id="26f3" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">代码的简要描述:</p><ul class=""><li id="db43" class="ms mt hh kh b ki kj kl km ko mu ks mv kw mw js nh my mz na bi translated">我们首先声明一个timestamp函数，我们将在开始导出文件之前和完成之后调用它，只是为了了解它花费了多少时间。</li><li id="d852" class="ms mt hh kh b ki nb kl nc ko nd ks ne kw nf js nh my mz na bi translated">然后我们声明一些必要的变量，我们需要使用它们作为<code class="du lb lc ld le b">mongofiles</code>命令的参数。</li><li id="9fa8" class="ms mt hh kh b ki nb kl nc ko nd ks ne kw nf js nh my mz na bi translated">接下来，有趣的事情！在这里，我们将把命令分成两部分:</li></ul><ol class=""><li id="e7e7" class="ms mt hh kh b ki kj kl km ko mu ks mv kw mw js mx my mz na bi translated"><code class="du lb lc ld le b">xargs &lt;”$1" -P$(nproc) -n1</code> : <code class="du lb lc ld le b">xargs</code>逐行读取输入(<code class="du lb lc ld le b">“$1”</code>)，并将每行(文件名)作为参数传递给进程。<code class="du lb lc ld le b">-n1</code>告诉xargs为每一行/文件名运行命令。<code class="du lb lc ld le b">nproc</code>是一个获取CPU数量的linux实用程序，该选项被传递给<code class="du lb lc ld le b">-P</code>，后者指定并发运行的进程数量。</li><li id="c3a7" class="ms mt hh kh b ki nb kl nc ko nd ks ne kw nf js mx my mz na bi translated"><code class="du lb lc ld le b">sudo mongofiles -h “$MONGO_HOST” -d “$MONGO_DATABASE” -u “$DATABASE_USERNAME” -p “$DATABASE_PWD” — authenticationDatabase “$DATABASE_AUTH_DB” --quiet get</code>:这将每个文件名作为命令前一部分的输入，并最终将其导出。</li></ol><blockquote class="mm mn mo"><p id="da68" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注意:</strong>为了运行上面的脚本，你需要给它执行权限，像这样:<code class="du lb lc ld le b">chmod +x export_files.sh</code>。</p></blockquote><p id="3b06" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">如果您继续运行<code class="du lb lc ld le b">./export_files.sh filenames.sh</code>，导出将开始！<em class="lf">(记住，你指定导出的文件越多，花费的时间就越多)</em></p><p id="3319" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">脚本完成后，运行<code class="du lb lc ld le b">ls</code>来查看所有导出的文件。接下来，您可以运行<code class="du lb lc ld le b">find . -type f | wc -l</code>来确保导出文件的数量等于导出到。csv文件(记住，我之前提过)。如果你想查看这些文件的总大小，运行<br/> <code class="du lb lc ld le b">du -h .</code>。</p><blockquote class="mm mn mo"><p id="5d11" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">提示:</strong>确保您创建了一个目录，所有文件都将导出到该目录。我所做的是为我要导出的每组文件创建目录。所以保持干净！相信我，你不会想在你的主目录中有成千上万的文件的！</p></blockquote><p id="12cb" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">该解决方案有许多优势，例如，如果需要，我可以随时停止，然后从我停止的地方继续，我不必让我的服务器连续10个小时处于这种压力下，更重要的是，我可以非常轻松地传输最后剩余的文件，即那些在我们导出时创建的文件。此外，通过使用<code class="du lb lc ld le b">xargs</code>，我们有能力运行的东西更快，所以这绝对是一个加号！</p><p id="d963" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">所以我们得到了文件…现在让我们把它们转移到我们的S3！</p><h1 id="3e34" class="lg lh hh bd li lj lk ll lm ln lo lp lq in lr io ls iq lt ir lu it lv iu lw lx bi translated">如何将这些文件传输到我的S3兼容对象存储器？</h1><blockquote class="mm mn mo"><p id="4a15" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注:</strong>注意到我在标题中使用的<strong class="kh hi">兼容</strong>关键字了吗？原来，不仅亚马逊提供S3对象存储服务…还有数字海洋，还有其他的！</p></blockquote><p id="98c1" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">所以我们开始吧！我们的最后一步！如果你能走到这一步，相信我，这很容易！</p><p id="694b" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">为了将文件从您的服务器传输到您的S3，我们需要一个工具来完成这项工作。如果你谷歌一下，你会发现很多！甚至有这方面的浏览器！我们要用的工具，叫做<a class="ae la" href="https://github.com/mishudark/s3-parallel-put" rel="noopener ugc nofollow" target="_blank"><strong class="kh hi">S3-并行-放</strong> </a> <strong class="kh hi">。</strong>(点击查看安装方法)</p><p id="1433" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">我之所以选择这个工具，是因为——顾名思义——它可以并行传输文件。如果您有多个GB的数据，这一点非常重要！在我们使用s3-parallel-put之前，请确保您已经安装了它，并且位于正确的目录中——导出文件的位置——并且没有任何其他不想传输的文件，比如bash脚本。</p><p id="4eaf" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">准备好了吗？键入以下内容:</p><pre class="ix iy iz ja fd md le me mf aw mg bi"><span id="6bcd" class="mh lh hh le b fi mi mj l mk ml">s3-parallel-put --bucket=bucketName --bucket_region=region --host=region.host.com --put=stupid --processes=13 --grant=public-read .</span></pre><p id="81d1" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">简单吧？让我们来看看如何使用它:</p><blockquote class="mm mn mo"><p id="3702" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><code class="du lb lc ld le b">--bucket</code>:那是你的S3桶的名字<br/> <code class="du lb lc ld le b">--bucket_region</code>:你为你的桶选择的地区，像<code class="du lb lc ld le b">us-east-1</code>，或者<code class="du lb lc ld le b">fra1</code>等<br/> <code class="du lb lc ld le b">--host</code>:你提供的主机名，像<code class="du lb lc ld le b">s3.amazonaws.com</code>或者<code class="du lb lc ld le b">digitaloceanspaces.com<br/>--processes</code>:那是它可以创建多少个进程，为了更快的传输文件。这个数字取决于你的机器有多少个CPU * 3。(3不是“正确”的数字…您应该用不同的值来测试它，以找出哪个数字更适合您)<br/> <code class="du lb lc ld le b">--grant=public-read</code>:您的文件应该具有的访问类型<br/> <code class="du lb lc ld le b">.</code>:您导出的文件所在的本地目录(在我的例子中是当前目录)</p></blockquote><p id="0324" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">就是这样！文件传输需要一些时间，但是我们已经完成了(至少对于当前的一批文件来说)。没那么难，对吧？你现在所要做的，就是对剩下的文件重复导出和上传的步骤，直到你完成！</p><h1 id="28e7" class="lg lh hh bd li lj lk ll lm ln lo lp lq in lr io ls iq lt ir lu it lv iu lw lx bi translated">最后的想法</h1><p id="5aa5" class="pw-post-body-paragraph kf kg hh kh b ki ly ii kk kl lz il kn ko ma kq kr ks mb ku kv kw mc ky kz js ha bi translated">现在我们完成了，让我们总结一下所有需要的步骤:<br/>首先，我们必须根据文件名的<code class="du lb lc ld le b">uploadDate</code>找到文件名。我们使用了<code class="du lb lc ld le b">mongoexport</code>命令。接下来，使用<code class="du lb lc ld le b">bash script</code>导出这些文件。最后，使用<code class="du lb lc ld le b">s3-parallel-put</code>上传导出的文件。重复一遍。</p><p id="8d11" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">我还想提一下<a class="ae la" href="https://s3tools.org/s3cmd" rel="noopener ugc nofollow" target="_blank"> s3cmd </a>，这是一个可以在S3上轻松搜索、删除甚至上传文件的工具，尽管我们不会用它来上传，因为它会慢很多。我想你会发现它很有用，万一出了问题，需要重新开始(希望不会)。</p><blockquote class="mm mn mo"><p id="f4df" class="kf kg lf kh b ki kj ii kk kl km il kn mp kp kq kr mq kt ku kv mr kx ky kz js ha bi translated"><strong class="kh hi">注意:</strong>请记住，您可能需要用来自S3的新URL替换数据库中存储的文件URL，因为它们不再托管在您的数据库中。谢天谢地，我不用处理它…解析服务器的文件适配器处理了它。</p></blockquote><p id="aa66" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">当我不得不做这个改变的时候，我找不到一个完整的指南来指导我怎么做！我找了又找，我不得不到处收集碎片…这太令人沮丧和疲惫了！所以我希望读这篇文章时，你会发现它比我更容易！</p><p id="911e" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz js ha bi translated">祝你好运！🙏</p></div></div>    
</body>
</html>