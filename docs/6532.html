<html>
<head>
<title>Elm III: Adding Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Elm III:添加效果</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/elm-iii-building-a-bridge-adding-effects-574d22ede3e8?source=collection_archive---------0-----------------------#2018-11-05">https://medium.com/quick-code/elm-iii-building-a-bridge-adding-effects-574d22ede3e8?source=collection_archive---------0-----------------------#2018-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/eaa531b33f1f5b0990719c299bed934a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eGS5svOaZy30byWHJDWsuw.jpeg"/></div></figure><p id="6546" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上周，我们深入探讨了Elm的使用。我们看到了如何构建一个更复杂的web页面，形成一个待办事项列表应用程序。我们学习了Elm架构，并了解了如何使用几个简单的函数来构建我们的页面。我们为将效果带入我们的系统打下了基础，但是没有使用这些。</p><p id="6589" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本周，我们将为我们的Elm技能集添加一些有用的东西。我们将看到如何在我们的系统中加入更多的效果，特别是随机性和HTTP请求。</p><p id="75b6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要了解更多关于为你的系统构建后端的知识，你应该阅读我们的<a class="ae jj" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell网络系列</a>。它会教你一些东西，比如连接到数据库和制作HTTP服务器。</p><h1 id="7b0a" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">合并效果</h1><p id="cafd" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">上周，我们探索了如何使用<code class="du kn ko kp kq b">element</code>表达式来构建我们的应用程序。与<code class="du kn ko kp kq b">sandbox</code>不同，这允许我们添加命令，从而产生副作用。但是我们没有使用任何命令。让我们检查一下我们可以在应用程序中使用的几种不同的效果。</p><p id="d759" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以产生的一个简单效果是得到一个随机数。从我们到目前为止的代码来看，这可能不明显，但是目前我们还不能在我们的Todo应用程序中实现它！我们的<code class="du kn ko kp kq b">update</code>功能是纯粹的！这意味着它不能访问<code class="du kn ko kp kq b">IO</code>。它能做的是发送命令作为输出的一部分。命令可以触发信息，并在过程中加入效果。</p><h1 id="9e28" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">制作随机任务</h1><p id="8bf4" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">我们将在应用程序中添加一个按钮。这个按钮将产生一个随机的任务名称，并将其添加到我们的列表中。首先，我们将添加一个新的消息类型进行处理:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="1393" class="kz jl hh kq b fi la lb l lc ld">type TodoListMessage =<br/>  AddedTodo Todo |<br/>  FinishedTodo Todo |<br/>  UpdatedNewTodo (Maybe Todo) |<br/>  AddRandomTodo</span></pre><p id="3d22" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是发送新消息的HTML元素。我们可以将它添加到视图的元素列表中:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="76dd" class="kz jl hh kq b fi la lb l lc ld">randomTaskButton : Html TodoListMessage<br/>randomTaskButton = button [onClick AddRandomTodo] [text "Random"]</span></pre><p id="5e62" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们需要将新消息添加到更新函数中。我们需要一个案例:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="641e" class="kz jl hh kq b fi la lb l lc ld">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  …<br/>  AddRandomTodo -&gt;<br/>    (TodoListState { todoList = todoList, newTodo = newTodo}, …)</span></pre><p id="765f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以第一次，我们要填入<code class="du kn ko kp kq b">Cmd</code>元素！为了产生随机性，我们需要来自<code class="du kn ko kp kq b"><a class="ae jj" href="https://package.elm-lang.org/packages/elm/random/latest/Random" rel="noopener ugc nofollow" target="_blank">Random</a></code>模块的<code class="du kn ko kp kq b">generate</code>函数。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="24f3" class="kz jl hh kq b fi la lb l lc ld">generate : (a -&gt; msg) -&gt; Generator a -&gt; Cmd msg</span></pre><p id="37a5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们需要两个参数来使用它。第二个参数是特定类型的随机生成器<code class="du kn ko kp kq b">a</code>。第一个参数是从这个类型到我们的消息的函数。在我们的例子中，我们想要生成一个<code class="du kn ko kp kq b">String</code>。我们将使用<code class="du kn ko kp kq b">elm-community/random-extra</code>包中的一些功能。见<a class="ae jj" href="https://package.elm-lang.org/packages/elm-community/random-extra/latest/Random-String" rel="noopener ugc nofollow" target="_blank">随机。字符串</a>和<a class="ae jj" href="https://package.elm-lang.org/packages/elm-community/random-extra/latest/Random-Char" rel="noopener ugc nofollow" target="_blank">随机。Char </a>了解详情。我们的字符串将有10个字母长，并且只使用小写字母。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="9790" class="kz jl hh kq b fi la lb l lc ld">genString : Generator String<br/>genString = string 10 lowerCaseLatin</span></pre><p id="a767" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们可以很容易地将它转换成新的信息。我们生成字符串，然后将其作为Todo添加:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="6094" class="kz jl hh kq b fi la lb l lc ld">addTaskMsg : String -&gt; TodoListMessage<br/>addTaskMsg name = AddedTodo (Todo {todoName = name})</span></pre><p id="984d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们可以将这些插入到我们的更新函数中，这样我们就有了正常运行的随机命令！</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="e075" class="kz jl hh kq b fi la lb l lc ld">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  …<br/>  AddRandomTodo -&gt;<br/>    (..., generate addTaskMsg genString)</span></pre><p id="8f6f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在点击随机按钮将会产生一个随机任务并添加到我们的列表中！</p><h1 id="5450" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">发送HTTP请求</h1><p id="d267" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">我们可以添加的一个更复杂的效果是发送一个HTTP请求。我们将使用Elm的<code class="du kn ko kp kq b"><a class="ae jj" href="https://package.elm-lang.org/packages/elm/http/latest/Http" rel="noopener ugc nofollow" target="_blank">Http</a></code> <a class="ae jj" href="https://package.elm-lang.org/packages/elm/http/latest/Http" rel="noopener ugc nofollow" target="_blank">库</a>。每当我们完成一项任务时，我们都会向某个端点发送一个请求，该请求的正文中包含该任务的名称。</p><p id="5c27" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将挂钩到我们目前的行动为<code class="du kn ko kp kq b">FinishedTodo</code>。目前，这将返回<code class="du kn ko kp kq b">None</code>命令及其更新。我们将让它发送一个触发post请求的命令。这个post请求将依次挂钩到另一个消息类型，我们将创建这个消息类型来处理响应。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="498b" class="kz jl hh kq b fi la lb l lc ld">todoUpdate : TodoListMessage -&gt; TodoListState -&gt; (TodoListState, Cmd TodoListMessage)<br/>todoUpdate msg (TodoListState { todoList, newTodo}) = case msg of<br/>  …<br/>  (FinishedTodo doneTodo) -&gt;<br/>    (..., postFinishedTodo doneTodo)<br/>  ReceivedFinishedResponse -&gt; ...</span><span id="05f3" class="kz jl hh kq b fi le lb l lc ld">postFinishedTodo : Todo -&gt; Cmd TodoListMessage<br/>postFinishedTodo = ...</span></pre><p id="0933" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们使用<code class="du kn ko kp kq b">send</code>函数创建HTTP命令。它需要两个参数:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="ad76" class="kz jl hh kq b fi la lb l lc ld">send : (Result Error a -&gt; msg) -&gt; Request a -&gt; Cmd Msg</span></pre><p id="c16d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第一个是解释服务器响应并给我们发送新消息的函数。第二个是期望某种类型结果的请求<code class="du kn ko kp kq b">a</code>。让我们为这些参数绘制更多的代码框架。我们会想象我们的响应得到了一个<code class="du kn ko kp kq b">String</code>，但这无关紧要。不管怎样，我们都会传达同样的信息:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="123c" class="kz jl hh kq b fi la lb l lc ld">postFinishedTodo : Todo -&gt; Cmd TodoListMessage<br/>postFinishedTodo todo = send interpretResponse (postRequest todo)</span><span id="1a2b" class="kz jl hh kq b fi le lb l lc ld">interpretResponse : Result Error String -&gt; TodoListMessage<br/>interpretResposne _ = ReceivedFinishedResponse</span><span id="ff35" class="kz jl hh kq b fi le lb l lc ld">postRequest : Todo -&gt; Request String<br/>postRequest = ...</span></pre><p id="45a0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们所需要的就是使用<code class="du kn ko kp kq b">post</code>函数创建我们的post请求:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="1286" class="kz jl hh kq b fi la lb l lc ld">post : String -&gt; Body -&gt; Decoder a -&gt; Request a</span></pre><p id="a8a4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们又有三个参数需要填充。第一个是我们发送请求的URL。第二个是我们的身体。第三个是响应的解码器。我们的解码器将是<code class="du kn ko kp kq b">Json.Decode.string</code>，一个库函数。我们将假设我们正在为URL运行一个本地服务器。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="149b" class="kz jl hh kq b fi la lb l lc ld">postRequest : Todo -&gt; Request String<br/>postRequest todo = post "localhost:8081/api/finish" … Json.Decode.string</span></pre><p id="3586" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们现在需要做的就是在post请求体中编码to do。这很简单。我们将使用<code class="du kn ko kp kq b">Json.Encode.object </code>函数，它接受一个元组列表。然后我们将在todo名称上使用<code class="du kn ko kp kq b">string</code>编码器。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="b895" class="kz jl hh kq b fi la lb l lc ld">jsonEncTodo : Todo -&gt; Value<br/>jsonEncTodo (Todo todo) = Json.Encode.object<br/>  [ ("todoName", Json.Encode.string todo.todoName) ]</span></pre><p id="f664" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将它与<code class="du kn ko kp kq b">jsonBody</code>功能一起使用。然后我们就完事了！</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="8afe" class="kz jl hh kq b fi la lb l lc ld">postRequest : Todo -&gt; Request String<br/>postRequest todo = post<br/>  "localhost:8081/api/finish"<br/>  (jsonBody (jsonEncTodo todo))<br/>  Json.Decode.string</span></pre><p id="58d5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">提醒一下，最后一部分中的大多数类型和助手函数来自Elm的HTTP库<a class="ae jj" href="https://package.elm-lang.org/packages/elm/http/latest/Http" rel="noopener ugc nofollow" target="_blank">。然后，我们可以在我们的<code class="du kn ko kp kq b">interpretResponse</code>函数中进一步处理响应。如果我们得到一个错误，我们可以发送不同的消息。不管怎样，我们最终可以在我们的<code class="du kn ko kp kq b">update</code>函数中做更多的更新。</a></p><h1 id="e22e" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="9663" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">这是我们关于Elm系列的第3部分！我们看了一些漂亮的方法来为我们的Elm项目添加额外的效果。我们看到了如何在我们的Elm项目中引入随机性，以及如何发送HTTP请求。下周，我们将探索导航，这是任何web应用程序的重要部分。我们将看到Elm架构如何支持多页面应用程序。然后，我们将看到如何在不同的页面之间有效地移动，而不需要每次都重新加载我们的Elm代码。</p><p id="ff44" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">既然你已经知道了如何编写一个功能性的前端，你应该学习更多关于后端的知识！阅读我们的<a class="ae jj" href="https://www.mmhaskell.com/haskell-web" rel="noopener ugc nofollow" target="_blank"> Haskell Web系列</a>来获得一些关于如何做到这一点的教程。您也可以下载我们的<a class="ae jj" href="https://www.mmhaskell.com/production-checklist" rel="noopener ugc nofollow" target="_blank">生产清单</a>以获得更多创意！</p></div></div>    
</body>
</html>