<html>
<head>
<title>Asynchronous calls in Spring Boot using @Async annotation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用@Async注释在Spring Boot进行异步调用</h1>
<blockquote>原文：<a href="https://medium.com/globant/asynchronous-calls-in-spring-boot-using-async-annotation-d34d8a82a60c?source=collection_archive---------0-----------------------#2021-06-29">https://medium.com/globant/asynchronous-calls-in-spring-boot-using-async-annotation-d34d8a82a60c?source=collection_archive---------0-----------------------#2021-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3bde87eee2e4fb7b88d740d4d0d1d951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*imb_-9IxJXC0lYtD"/></div></div></figure><p id="f4b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章是关于如何在spring boot中实现异步行为的。但是首先我们来看看同步和异步的区别。</p><ul class=""><li id="d6da" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">同步编程:在同步编程中，一次执行一个任务，只有当一个任务完成时，下一个任务才被解除阻塞。</li><li id="f758" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">异步编程:</strong>在异步编程中，可以同时执行多个任务。在前一个任务完成之前，您可以移动到另一个任务。</li></ul><figure class="kc kd ke kf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kb"><img src="../Images/e56bf4319ce3da8e9ff16622ce2b4cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkwwhFNl7w-kYVC8O0g4HQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Figure 1.1</figcaption></figure><p id="606b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在spring boot中，我们可以使用@Async注释实现异步行为。但是仅仅@Async注释是不行的。为此，您需要理解@Async内部是如何工作的。</p><p id="7a4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">先决条件:</strong></p><p id="dcf3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">必须通过使用@EnableAsync批注来批注主应用程序类或任何直接或间接的异步方法调用方类，从而启用异步支持。默认模式是代理，另一种是AspectJ。在本帖中，我们将讨论代理模式。代理模式只允许通过代理拦截呼叫。永远不要从定义异步方法的同一个类中调用异步方法，这将不起作用。</p><p id="a55b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">@ Async注释是如何工作的？</strong></p><p id="a71d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，用@Async注释该方法。当您使用@Async批注来批注方法时，它会基于“proxyTargetClass”属性为该对象创建一个代理。</p><p id="86eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当spring执行这个方法时，默认情况下，它会搜索相关的线程池定义。上下文中唯一的spring framework TaskExecutor bean或名为“task Executor”的Executor bean。如果这两个都不可解析，默认情况下它将使用spring framework simpleasynctaskmexecutor来处理异步方法执行。</p><p id="07c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">AsyncService.java</strong></p><pre class="kc kd ke kf fd kk kl km kn aw ko bi"><span id="73f6" class="kp kq hh kl b fi kr ks l kt ku">package com.example.demo.service;</span><span id="5787" class="kp kq hh kl b fi kv ks l kt ku">public interface AsyncService {<br/>    void asyncMethod() throws InterruptedException;<br/>}</span></pre><p id="cf25" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">AsyncServiceImpl.java</strong></p><pre class="kc kd ke kf fd kk kl km kn aw ko bi"><span id="f926" class="kp kq hh kl b fi kr ks l kt ku">package com.example.demo.service;</span><span id="645d" class="kp kq hh kl b fi kv ks l kt ku">import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;</span><span id="2dfb" class="kp kq hh kl b fi kv ks l kt ku">@Service<br/>public class AsyncServiceImpl implements AsyncService {<br/>   @Async<br/>   @Override<br/>   public void asyncMethod() throws InterruptedException {<br/>      Thread.sleep(3000);<br/>      System.out.println("Calling other service..");<br/>      System.out.println("Thread: " +<br/>          Thread.currentThread().getName());<br/>   }<br/>}</span></pre><p id="7dac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AsyncServiceImpl应该是spring管理的bean。此外，您的异步方法必须是公共的，以便它可以被代理。就异步方法签名而言，任何参数类型都受支持。但是，返回类型被限制为void或Future。</p><p id="cecf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AsyncController.java</p><pre class="kc kd ke kf fd kk kl km kn aw ko bi"><span id="cfa1" class="kp kq hh kl b fi kr ks l kt ku">package com.example.demo.controller;</span><span id="d45d" class="kp kq hh kl b fi kv ks l kt ku">import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.scheduling.annotation.EnableAsync;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RestController;</span><span id="78d0" class="kp kq hh kl b fi kv ks l kt ku">import com.example.demo.service.AsyncService;</span><span id="d74c" class="kp kq hh kl b fi kv ks l kt ku">@RestController<br/>@EnableAsync<br/>public class AsyncController {<br/>   @Autowired<br/>   AsyncService asyncService;<br/>   @GetMapping("/async")<br/>   public String asyncCallerMethod() throws InterruptedException {<br/>      long start = System.currentTimeMillis();<br/>      asyncService.asyncMethod();<br/>      String response = "task completes in :" + <br/>      (start -   System.currentTimeMillis()) + "milliseconds";<br/>      return response;<br/>   }<br/>}</span></pre><p id="9ca4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我用@EnableAsync注释了这个类。当您运行服务并到达端点时，asyncMethod()将由默认任务执行器创建的另一个线程执行。主线程不需要等待完成异步方法的执行。</p><p id="4bbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以自定义自己的任务执行器。我们将在讨论如何处理异步方法中出现的异常时看到它。</p><p id="bcdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">异步方法中的异常处理:</strong></p><p id="48e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在异步方法中处理异常，我们需要配置AsyncUncaughtExceptionHandler，如下所示。</p><p id="9b09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">AsynConfiguration.java</strong></p><pre class="kc kd ke kf fd kk kl km kn aw ko bi"><span id="f21f" class="kp kq hh kl b fi kr ks l kt ku">package com.example.demo.config;</span><span id="f998" class="kp kq hh kl b fi kv ks l kt ku">import java.lang.reflect.Method;<br/>import java.util.concurrent.Executor;</span><span id="3d99" class="kp kq hh kl b fi kv ks l kt ku">import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.scheduling.annotation.AsyncConfigurerSupport;<br/>import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><span id="e3e0" class="kp kq hh kl b fi kv ks l kt ku">@Configuration<br/>public class AsynConfiguration extends AsyncConfigurerSupport {<br/>   @Override<br/>   public Executor getAsyncExecutor() {<br/>      ThreadPoolTaskExecutor executor = new <br/>                ThreadPoolTaskExecutor();<br/>      executor.setCorePoolSize(3);<br/>      executor.setMaxPoolSize(4);<br/>      executor.setThreadNamePrefix("asyn-task-thread-");<br/>      executor.setWaitForTasksToCompleteOnShutdown(true);<br/>      executor.initialize();<br/>      return executor;<br/>  }<br/>  @Override<br/>  public AsyncUncaughtExceptionHandler  <br/>         getAsyncUncaughtExceptionHandler() {<br/>     return new AsyncUncaughtExceptionHandler() {<br/>   <br/>        @Override<br/>        public void handleUncaughtException(Throwable ex, <br/>           Method method, Object... params) {<br/>           System.out.println("Exception: " + ex.getMessage());<br/>           System.out.println("Method Name: " + method.getName());<br/>           ex.printStackTrace();<br/>        }<br/>    };<br/>  }<br/>}</span></pre><p id="d77b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">AsyncServiceImpl.java</strong></p><pre class="kc kd ke kf fd kk kl km kn aw ko bi"><span id="ca28" class="kp kq hh kl b fi kr ks l kt ku">package com.example.demo.service;</span><span id="82a3" class="kp kq hh kl b fi kv ks l kt ku">import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;</span><span id="3316" class="kp kq hh kl b fi kv ks l kt ku">@Service<br/>public class AsyncServiceImpl implements AsyncService {<br/> <br/>   @Async<br/>   @Override<br/>   public void asyncMethod() throws InterruptedException {<br/>      int a = 1;<br/>      int b = 0;<br/>      System.out.println(a/b);<br/>   }<br/>}</span></pre><p id="2ee9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行应用程序并点击端点<a class="ae kw" href="http://localhost:8080/async" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">http://localhost:8080/async</strong></a><strong class="ir hi"/><strong class="ir hi"/>浏览器将在AsyncController类中显示响应字符串return，并且算术异常(被零除)将被记录在控制台中。</p><p id="0612" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">控制台日志:</strong></p><figure class="kc kd ke kf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kx"><img src="../Images/96aadfaeb5c9b1e8c84862ceff95b9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWab9106FYFys9dYxOTD2g.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Figure 1.2</figcaption></figure><p id="5def" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">结论:</strong></p><p id="2ef1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们看到了在spring boot中使用@Async注释和Async方法中的异常处理来实现异步行为的方法之一。</p><p id="a1ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你觉得这很有用，或者有什么建议，请在评论中告诉我。另外，请随时在LinkedIn上联系我。</p></div></div>    
</body>
</html>