<html>
<head>
<title>A Zoological guide to kernel data structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据结构动物学指南</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/a-zoological-guide-to-kernel-data-structures-4c68207e186b?source=collection_archive---------5-----------------------#2021-01-14">https://medium.com/oracledevs/a-zoological-guide-to-kernel-data-structures-4c68207e186b?source=collection_archive---------5-----------------------#2021-01-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="5e4c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">内核数据结构有多种形状和大小。Oracle Linux内核工程师Alan Maguire对Linux内核中的数据结构大小进行了统计分析。</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/973d8616906faa9d519cb0efee6ed396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iz-bFB0KTHBoZSJlazegXA.png"/></div></div></figure><p id="3d9c" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">最近，我正在开发一个BPF特性，它旨在提供一种机制来显示任何内核数据结构，以供调试之用。作为努力的一部分，我想知道极限是什么。最大的内核数据结构有多大？典型的内核数据结构大小是多少？</p><p id="bfae" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们将尝试回答的基本问题是</p><ul class=""><li id="9429" class="kn ko hh jr b js jt jw jx ka kp ke kq ki kr km ks kt ku kv bi translated">有多少种数据结构，在内核版本之间可以观察到哪些模式？</li><li id="5dda" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated">最小和最大的数据结构是什么，为什么？</li><li id="1939" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated">给定内核版本的结构大小的总体模式是什么？这在不同版本之间有什么变化？</li></ul><p id="7236" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们读到的很多关于Linux内核的文章都谈到了大小，但是是在代码行数、文件数、提交数等等的上下文中。这些都是有趣的指标，但这里我们将重点关注数据结构，我们将在调查中使用两个神奇的工具:</p><ul class=""><li id="4ee7" class="kn ko hh jr b js jt jw jx ka kp ke kq ki kr km ks kt ku kv bi translated"><strong class="jr hi"> <em class="lb"> pahole </em> </strong>(戳孔):根据手册页，<strong class="jr hi"> <em class="lb"> pahole </em> </strong>显示和操作数据结构布局。这只是暗示了它能做什么。出于我们的目的，<strong class="jr hi"> <em class="lb"> pahole </em> </strong>可以获取一个内核映像，并向我们显示其中使用的各种结构的布局和大小。<strong class="jr hi"> <em class="lb"> pahole </em> </strong>通常在矮人套装内提供；如果做不到，可以通过<a class="ae lc" href="https://github.com/acmel/dwarves" rel="noopener ugc nofollow" target="_blank">https://github.com/acmel/dwarves</a>从源代码构建。</li><li id="2b02" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated"><strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>:如果你以前没用过，我希望你会看到它有多强大。不仅仅是一个绘图工具，我们还可以用它来拟合函数，以构建我们绘制的数据模型。稍后我将提供一个这样做的例子。详见<a class="ae lc" href="http://www.gnuplot.info/" rel="noopener ugc nofollow" target="_blank">http://www . gnuplot . info</a>。</li></ul><p id="38d4" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们的目标是鸟瞰数据结构的大小。有哪些模式？这里我们将把自己局限于静态分析；换句话说，我们不会考虑内核运行时特定数据结构的使用频率。一个更注重动态的分析当然也很有趣！</p><p id="091b" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">另一个规则是——为了保持简单(并且可以跨内核版本进行比较),我们将使用“make allyesconfig”来生成。用于内核构建的配置文件。显然，选择更多/更少的特性会影响数据结构的大小，所以为了简单起见，我们现在忽略这一点。</p><p id="1658" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">这是我用来为31个从v4.0到v5.9发布的内核构建vmlinux二进制文件的kbuild.sh脚本，时间跨度为2015年中期到2020年10月。</p><p id="9484" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">该脚本应该在没有来自内核源代码git树顶层的参数的情况下运行。假设所有的工具和包都支持内核构建。</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="d319" class="li if hh le b fi lj lk l ll lm">#!/usr/bin/bash<br/># Copyright (c) 2020, Oracle and/or its affiliates.<br/>#<br/># The Universal Permissive License (UPL), Version 1.0<br/>#<br/># Subject to the condition set forth below, permission is hereby granted to any<br/># person obtaining a copy of this software, associated documentation and/or data<br/># (collectively the "Software"), free of charge and under any and all copyright<br/># rights in the Software, and any and all patent rights owned or freely<br/># licensable by each licensor hereunder covering either (i) the unmodified<br/># Software as contributed to or provided by such licensor, or (ii) the Larger<br/># Works (as defined below), to deal in both<br/>#<br/># (a) the Software, and<br/># (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if<br/># one is included with the Software (each a "Larger Work" to which the Software<br/># is contributed by such licensors),<br/>#<br/># without restriction, including without limitation the rights to copy, create<br/># derivative works of, display, perform, and distribute the Software and make,<br/># use, sell, offer for sale, import, export, have made, and have sold the<br/># Software and the Larger Work(s), and to sublicense the foregoing rights on<br/># either these or other terms.<br/>#<br/># This license is subject to the following condition:<br/># The above copyright notice and either this complete permission notice or at<br/># a minimum a reference to the UPL must be included in all copies or<br/># substantial portions of the Software.<br/>#<br/># THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br/># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br/># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br/># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br/># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br/># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br/># SOFTWARE.<br/>#<br/> <br/>set -e<br/> <br/># Extract released tags, not rcs, sorted by version number<br/>TAGS=$(git tag | awk '/^v[45]\.[0-9]+$/ { print $1 }' |sort -V)<br/> <br/># Now build vmlinux for each release, saving it to vmlinux.&lt;release&gt;<br/>CFG=$(pwd)/.config<br/>NPROCS="$(nproc)"<br/>KBUILD="make -j${NPROCS}"<br/> <br/># Add space-separated problematic kernel versions here<br/>SKIPLIST=" "<br/> <br/>for TAG in $TAGS ; do<br/>        # In case we need to restart, skip already build vmlinux versions.<br/>        if [[ -f vmlinux.${TAG} ]]; then<br/>                continue<br/>        fi<br/>        if [[ $SKIPLIST =~ "$TAG " ]]; then<br/>                 echo "Skipping $TAG..."<br/>                 continue<br/>        fi<br/>        git checkout $TAG<br/>        $KBUILD allyesconfig<br/>        echo "CONFIG_COMPILE_TEST=n" &gt;&gt; $CFG<br/>        echo "CONFIG_DEBUG_KERNEL=y" &gt;&gt; $CFG<br/>        echo "CONFIG_DEBUG_INFO=y" &gt;&gt;  $CFG<br/>        OLDTARGET=oldconfig<br/>        set +e<br/>        HAVE_OLDDEFCONFIG=$(grep olddefconfig scripts/kconfig/Makefile)<br/>        set -e<br/>        if [[ -n "$HAVE_OLDDEFCONFIG" ]]; then<br/>                OLDTARGET=olddefconfig<br/>        fi<br/>        $KBUILD $OLDTARGET<br/>        $KBUILD<br/>        cp vmlinux vmlinux.${TAG}<br/>        pahole -s vmlinux.${TAG} | sort -nk 2 &gt; struct_sizes.vmlinux.${TAG}<br/>        rm vmlinux.${TAG}<br/>done</span><span id="92a9" class="li if hh le b fi ln lk l ll lm"><strong class="le hi">done</strong></span></pre><p id="5589" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">这是一些内核可能需要应用的补丁，以确保buld进程不会因为内核映像太大而终止。如果您看到错误消息“内核映像大于内核映像大小”,请应用以下补丁来删除断言，因为我们不需要担心内核在这里是否可用:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="3fdf" class="li if hh le b fi lj lk l ll lm">diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S<br/>index 795f3a8..712f670 100644<br/>--- a/arch/x86/kernel/vmlinux.lds.S<br/>+++ b/arch/x86/kernel/vmlinux.lds.S<br/>@@ -393,12 +393,6 @@ SECTIONS<br/> INIT_PER_CPU(gdt_page);<br/> INIT_PER_CPU(irq_stack_union);<br/> <br/>-/*<br/>- * Build-time check on the image size:<br/>- */        <br/>-. = ASSERT((_end - _text &lt;= KERNEL_IMAGE_SIZE),<br/>-          "kernel image bigger than KERNEL_IMAGE_SIZE");<br/>-<br/> #ifdef CONFIG_SMP<br/> . = ASSERT((irq_stack_union == 0),<br/>            "irq_stack_union is not at start of per-cpu area");</span></pre><p id="bbb6" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">现在我们已经构建了我们的内核，并将我们的数据结构大小放入一个按大小排序的每个内核的数据文件中；每个都称为struct _ sizes . vmlinux . v { VERSION }。</p><p id="7db4" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">现在开始回答一些关于Linux中数据结构的问题吧！</p><h1 id="208e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">有多少数据结构？</h1><p id="e55c" class="pw-post-body-paragraph jp jq hh jr b js lo ju jv jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km ha bi translated">关于第一个问题，我们来拿数字。这些可以通过跑步来收集</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="1b3b" class="li if hh le b fi lj lk l ll lm">#  wc -l struct_sizes.vmlinux.v* | egrep -v total | sed 's/struct_sizes.vmlinux.v//' | sort -V | awk '{ print NR" "$1" "$2 }' &gt; total_sizes.dat</span></pre><p id="fafc" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">…哪个</p><ul class=""><li id="0c19" class="kn ko hh jr b js jt jw jx ka kp ke kq ki kr km ks kt ku kv bi translated">获取包含结构名称及其大小的每个struct_sizes.vmlinux.vVERSION文件；和</li><li id="fc43" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated">通过wc获取每个文件中的行数，不包括总数(即数据结构数)；</li><li id="e99d" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated">修剪“struct_sizes.vmlinux.v”前缀；和</li><li id="5ef2" class="kn ko hh jr b js kw jw kx ka ky ke kz ki la km ks kt ku kv bi translated">打印索引，后跟结构的数量，然后是版本</li></ul><p id="ff70" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">对于<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>来说，拥有这种形式的数据很方便，因为索引(而不是版本号)更容易适应函数。</p><p id="3e7c" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">现在让我们使用<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>来绘制这些。</p><p id="0d91" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">以下是total_sizes.plot脚本。它只是设置样式、值、总图像大小(1600x800)并指定输出文件是输入文件的名称加上一个“.”。png”后缀。</p><p id="20fe" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">然后total_sizes.dat中的第一列被绘制为X值(它是数据值的简单索引)，第二列是Y值(发布的数据结构的数量)。</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="ac89" class="li if hh le b fi lj lk l ll lm">set style fill solid<br/>set boxwidth 0.5<br/>set terminal png size 1600,800<br/>set output datafile.'.png'<br/>unset key<br/> <br/>set xtics nomirror<br/>unset xtics<br/>set title 'Number of Data Structures in Linux Releases v4.0-5.9'<br/> <br/>plot datafile using 1:2 with boxes</span></pre><p id="67bb" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">上面应该运行为</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="af2c" class="li if hh le b fi lj lk l ll lm"># gnuplot -e "datafile='total_sizes.dat'" total_sizes.plot</span></pre><p id="e361" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">…如果一切顺利，我们将有一个total_sizes.dat.png文件。</p><p id="08eb" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">看起来是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/dd4b2f60dcd7901ff1f5c4a5bab35b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QEfLRT4YZaWdSeNH.png"/></div></div></figure><p id="ccd7" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">但是，除了简单地可视化数据，我们还可以做更多的事情！<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>也将让我们对数据拟合一个模型。因此，让我们用一个简单的线性模型来展示Linux内核版本之间数据结构的数量是如何增加的。</p><p id="74ca" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">以下是我们如何扩展total_sizes.plot以包括线性拟合。</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="2c23" class="li if hh le b fi lj lk l ll lm">set style fill solid<br/>set boxwidth 0.5<br/>set terminal png size 1600,800<br/>set output datafile.'.fit.png'<br/>set multiplot<br/>unset key<br/> <br/>set xtics nomirror<br/>unset xtics<br/>set title 'Number of Data Structures in Linux Releases v4.0-5.9'<br/> <br/>plot datafile using 1:2 with boxes<br/> <br/>lin(x) = (m*x) + c<br/>fit [1:32] lin(x) datafile using 1:2  via m,c<br/>replot lin(x)</span></pre><p id="7af5" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">最后三行(和“set multiplot”允许多个图)是唯一的区别。当它运行时，我们看到<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>符合如下值:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="f8b1" class="li if hh le b fi lj lk l ll lm"># gnuplot -e "datafile='total_sizes.dat'" total_sizes_fit.plot<br/>[some fitting output omitted here]<br/>...<br/> <br/>Final set of parameters            Asymptotic Standard Error<br/>=======================            ==========================<br/> <br/>m               = 712.369          +/- 11.54        (1.62%)<br/>c               = 36072.2          +/- 211.5        (0.5864%)</span></pre><p id="66a9" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们可以在这里看到结果，拟合线叠加在条形图上。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/5ae28e1da1d831580ffe467bd1398c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3YA7srbk_j8n00Ax.png"/></div></div></figure><p id="a51f" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">这告诉我们，线性拟合的标准误差很小，斜率(m以上)约为712。因此，假设线性拟合仍然适用，这允许我们预测未来版本中将有多少数据结构。</p><p id="8af9" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">因此，假设5.10是第32个版本(x=32)，我们可以计算</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="92f5" class="li if hh le b fi lj lk l ll lm">lin(x) = (m*x) + c<br/>lin(32) = (712.369*32) + 36072.2 ~= 58868</span></pre><p id="4851" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">…预测v5.10中大约有58868个数据结构(再次假设线性拟合仍然适用)。请注意，如果我们只是将斜率值712加到5.9(57827)上，我们会得到一个略有不同的答案，因为在前一种情况下，我们正在拟合，并且直线会预测到5.9值的一个略有不同的值(实际上是58156)。</p><p id="a3cd" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">因此，使用<strong class="jr hi"> <em class="lb"> pahole </em> </strong>和<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>，我们了解到数据结构的增长大约是每个版本712个新类型，并且大致是线性的。</p><h1 id="7480" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">最小的结构是什么？</h1><p id="a082" class="pw-post-body-paragraph jp jq hh jr b js lo ju jv jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km ha bi translated">关于第二个问题，最小的数据结构大小为0。让我们看一些例子，看看0大小的数据结构为什么有用。</p><p id="48cb" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">对于“struct arch_elf_state”这种情况，该结构包含一些体系结构的数据，但对于x86_64并不需要。但是它需要被定义，所以fs/binfmt_elf.c将其定义为空结构。</p><p id="f563" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">许多其他情况是长度为0的数组，例如“struct bpf_raw_tracepoint_args”:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="0919" class="li if hh le b fi lj lk l ll lm">struct bpf_raw_tracepoint_args {<br/>    __u64 args[0];<br/>};</span></pre><p id="a4df" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在这种情况下，原始跟踪点有不同数量的参数，但我们想很容易地访问u64值。所以定义一个零长度数组允许BPF程序利用该数组轻松地获取参数。</p><h1 id="e4cb" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">最大的建筑是什么？</h1><p id="15d9" class="pw-post-body-paragraph jp jq hh jr b js lo ju jv jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km ha bi translated">这些内核版本中最大的数据结构是巨大的“struct rcu_state”，从4280320 (v4.0)到6414336字节(v5.9)。它存储RCU (Read-Copy-Update，一种非常聪明的同步机制)全局状态，其大小的原因是它包含一个“struct rcu_node”数组。</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="39d7" class="li if hh le b fi lj lk l ll lm"># pahole -C "rcu_state" vmlinux.v5.9<br/>struct rcu_state {<br/>    struct rcu_node            node[521] __attribute__((__aligned__(4096))); /*     0 6402048 */<br/>    /* --- cacheline 100032 boundary (6402048 bytes) --- */<br/>    ...</span></pre><p id="523f" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">每个结构rcu_node在4k边界上对齐，并填充到12k(因为这是最近的4k边界)，521个结构的数组占用6402048字节。这占了struct rcu_state的6414336字节的大部分。</p><p id="fe99" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">另一个值得注意的结构是“struct task_struct”，这是Linux中进程管理的核心。在v4.1中为10688字节，到v5.9时增长到16576字节。</p><p id="c469" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在这个时间尺度上缩小的一个结构是“struct sk_buff ”,尽管幅度很小。在4.0版中是232字节，在5.9版中是224字节。再次假定由TCP/IP栈处理的每个分组利用“struct sk_buff ”,这使得该结构非常重要；事实上，快速数据路径(XDP)技术的卖点之一是<em class="lb">而不是</em>具有这种每包元数据开销！还值得一提的是，像这样的收缩，虽然看起来不大，但需要大量的工作，特别是因为sk_buff结构被大量的功能使用，所以必须携带一个覆盖大量不同需求的表示。大卫·米勒使用一些非常聪明的方法，推动了一场勇敢的努力来削减它的规模——你可以在这里跟踪结果:【http://vger.kernel.org/~davem/skb_size.html<a class="ae lc" href="http://vger.kernel.org/~davem/skb_size.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="68ac" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">接下来，为了获得一个总体的视图，我们将为每个内核版本绘制结构大小，以感受各种大小的结构的分布。</p><h1 id="dcab" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">版本中结构尺寸的分布</h1><p id="b6f5" class="pw-post-body-paragraph jp jq hh jr b js lo ju jv jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km ha bi translated">我们还没有感觉到的一件事是数据结构大小的总体分布。我们希望看到发布版本中数据结构大小的模式，比如大多数数据结构是否很小。同样，起点是用<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>可视化事物。</p><p id="13ec" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在这种情况下，为了有助于可视化，我们将使用值的频率图；也就是说，0大小的数据结构出现了多少次？1码的？结果将显示在条形图中。</p><p id="7340" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">为此，我们使用“平滑频率”图，其中<strong class="jr hi"> <em class="lb"> gnuplot </em> </strong>计算x值出现的次数，然后对相关的y值求和。这里，我们希望每次看到一个特定的结构大小时加1，所以我们的y值就是1。这是我们的struct_sizes.plot文件:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="a614" class="li if hh le b fi lj lk l ll lm">set key off<br/>set border 3<br/>set style fill solid<br/> <br/>set xrange [0:4096]<br/>set terminal png size 1000,600<br/>set output datafile.'.png'<br/> <br/>set title 'Frequency of Linux kernel '.datafile offset 0,-10 font ",10"<br/> <br/>set table 'freq.tmp'<br/>plot datafile using ($2):(1) smooth frequency with boxes<br/>unset table<br/>plot 'freq.tmp' smooth frequency with boxes</span></pre><p id="ebf3" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">上面应该运行为</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="cd87" class="li if hh le b fi lj lk l ll lm"># gnuplot -e "datafile='struct_sizes.vmlinux.v5.9'" struct_sizes.plot</span></pre><p id="2d92" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们可以看到，在最初的早期峰值之后，观察到经典的指数衰减模式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/beb4227f586e79129bfd2ae0ea7550af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IEcXMl0piC5_oK65.png"/></div></div></figure><p id="6878" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们可以检查上面创建的临时文件freq.tmp，查看峰值是针对16字节结构(5825个结构)的，并且观察到一个有趣的模式。每4个字节我们得到一个大值，中间穿插着小值。例如，在下面的示例中，第一列是字节数，第二列是出现的频率，我们看到:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="d4ae" class="li if hh le b fi lj lk l ll lm">8  4488  8  8  i<br/>9  130  9  9  i<br/>10  231  10  10  i<br/>11  73  11  11  i<br/>12  2094  12  12  i<br/>13  64  13  13  i<br/>14  113  14  14  i<br/>15  55  15  15  i<br/>16  5825  16  16  i<br/>17  60  17  17  i<br/>18  120  18  18  i<br/>19  28  19  19  i<br/>20  1121  20  20  i<br/>21  36  21  21  i<br/>22  55  22  22  i<br/>23  21  23  23  i<br/>24  4125  24  24  i</span></pre><p id="a526" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在这里，我们看到可被4个字节整除的大小(8，12，16，20，24)都有更大数量的结构(4488，2094，5825，1121，4125)，而在它们之间我们有更小的值。为什么会这样？答案很可能是，一个结构以至少4字节对齐(例如，一个整数)或8字节对齐的值(例如，一个指针)结尾的概率很高，因为这些值非常常用。此外，请记住，许多内核数据结构指定了对齐要求，因此将相应地填充它们的结构。这很有意义，因为可被8整除的结构尺寸的频率往往比可被4整除的大得多。我们还看到4096字节的大量数据结构，对齐很可能被强制到1页的边界(见大小为4096的122个结构):</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="404e" class="li if hh le b fi lj lk l ll lm">4095  1  4095  4095  i<br/>4096  122  4096  4096  i<br/>4098  3  4098  4098  o</span></pre><p id="9637" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在调查的所有内核版本中观察到了相同的模式，这里是4.0:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/bc871006d4ae056e46b73119e4393a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*By6eKtsrtVZ3ynqx.png"/></div></div></figure><p id="afd6" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">…和4.14:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/042086a23a01dbf2595f982cb2f4ef70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dW-VYB8rubx9EYUE.png"/></div></div></figure><p id="b355" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">为了更清楚地了解给定大小或更小的数据结构占总数据结构的百分比，我们可以使用累积频率曲线，其中曲线的高度代表数据结构的数量&lt;= the current x value size. This just requires one small tweak to our plot to show a cumulative frequency:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="1d30" class="li if hh le b fi lj lk l ll lm">set key off<br/>set border 3<br/>set style fill solid<br/>set boxwidth 1 absolute<br/> <br/>set xrange [0:8192]<br/>set terminal png size 1000,600<br/>set output datafile.'.cumulative.png'<br/> <br/>set title 'Cumulative frequency of Linux kernel '.datafile offset 0,-10 font ",10"<br/> <br/>set table 'freq.tmp'<br/>plot datafile using ($2):(1) smooth frequency with boxes<br/>unset table<br/>plot 'freq.tmp' smooth cumulative</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/0f45529abe3898b13fd732c928568299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3vRPqu-4gybcKVsi.png"/></div></div></figure><p id="8891" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">We can see that for the 5.9 kernel, the vast majority (&gt; 50，000(总数57827)小于1000字节。</p><p id="52f1" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">再次缩小，关于结构大小频率模式有趣的是，它似乎反映了大数据结构的固有成本；他们在内存利用率方面付出了代价，所以当我们看到许多小数据结构时，随着我们接近更大的尺寸，这种下降是相当大的。</p><p id="6082" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">这种模式在其他地方也观察到了，这让我们回到了这篇文章的动物学标题。如果我们观察按大小分组的动物物种的频率，当我们从较小的物种到较大的物种时，我们会看到类似的指数衰减模式。更多信息参见<a class="ae lc" href="https://en.wikipedia.org/wiki/Body_size_and_species_richness" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Body _ size _ and _ species _ richity</a>。如果代谢成本是决定这种模式的一个因素，那么对于Linux内核中更大的数据结构，我们也可以在内存利用率方面观察到类似的“代谢成本”。一个相关的观察结果——自然界中较小的物种(如昆虫)比较大的物种存在的数量要多得多——对于Linux内核的研究将是有趣的，但是这将需要观察运行系统中的数据结构利用率，这是另外一天的工作！</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="6f15" class="pw-post-body-paragraph jp jq hh jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><em class="lb">最初发表于</em><a class="ae lc" href="https://blogs.oracle.com/linux/a-zoological-guide-to-kernel-data-structures" rel="noopener ugc nofollow" target="_blank"><em class="lb">【https://blogs.oracle.com】</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>