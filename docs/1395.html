<html>
<head>
<title>A Beginner’s Guide to Scripting in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift脚本初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/a-beginners-guide-to-scripting-in-swift-aeda4dd3e67?source=collection_archive---------0-----------------------#2016-05-18">https://medium.com/capital-one-tech/a-beginners-guide-to-scripting-in-swift-aeda4dd3e67?source=collection_archive---------0-----------------------#2016-05-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/62ab8b66e237a1cb2636f73f883b4088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91-E_TIGhZP8DOJSGy-6Jg.png"/></div></div></figure><p id="a9c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从苹果在2014年推出Swift以来，大多数程序员都专注于使用它来编写iOS/Mac OS X应用程序。这是我们许多人学习语言时的第一本能。事实上，这是斯威夫特第一次出柜那天我唯一的直觉。直到七个月后，我才意识到它比看起来更强大，而且用Swift编写脚本不仅是可能的，而且相当容易！</p><h1 id="841a" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">故事…</h1><p id="bd22" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">2015年从Swift 1.1到Swift 1.2的迁移是一件大事。这次更新改变了语言的语法，在新的Xcode测试版中运行时，项目似乎出现了上千个错误。值得这么做的是Swift编译器的增强。特别是，我说的是每次开始构建时，将每个 Swift文件<em class="kq">的<em class="kq">重新编译更改为增量编译的增强功能。</em></em></p><p id="216b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当时，我正在进行一个大型的成熟项目，编译时间快让我们受不了了。我们看到平均15分钟的编译时间，即使唯一的变化是一个注释。相比之下，Swift 1.2中的新Swift编译器平均每次编译时间为1-3分钟。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/9d77ce50bc77cbbb79e7b4e72126b353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9yuAQAnbro1sy8MMFqF6Q.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx"><em class="la">Compiling Swift Source Files.</em></figcaption></figure><p id="0d4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">长话短说，我们想使用测试版来开发(因为编译时间)，但如果我们用Swift 1.2编写代码，由于测试版的限制，我们不能发布到应用商店。解决方案是什么？嗯，我们决定同时编写Swift 1.2代码和Swift 1.1代码。它看起来像这样:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="2d1f" class="lg jo hh lc b fi lh li l lj lk">//====================Swift 1.2 Code===================="        <br/>//let kraken = mythicalBeast as! Kraken        <br/>//====================Old Swift Code====================" //       <br/>let kraken = mythicalBeast as Kraken<br/>//==========================End========================="</span></pre><p id="11f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于发布时间，我们需要编写一个脚本，为开发周期注释掉Swift 1.2代码并取消旧的Swift 1.1代码的注释(反之亦然)。当时，我唯一知道的脚本语言是Python。在谷歌上快速搜索其他脚本语言给了我<a class="ae ll" href="http://www.tutorialspoint.com/python/python_basic_syntax.htm" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="b5e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你注意一下那个页面上的内容，你会注意到它提到了一个交互模式，并在顶部创建了一个带有一行<a class="ae ll" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> Shebang </a>的Python文件。这种交互模式启动了所谓的Python REPL(读取-评估-打印-循环)。等等，那是什么？REPL吗？</p><p id="31bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="kq">斯威夫特有一个！！！</em>T11】</strong></p><p id="59b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实证明，您可以使用Swift REPL来做同样的事情！所以让我们开始…</p><h1 id="7d5c" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">实际上在SWIFT中编写脚本</h1><p id="7c79" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">首先，我们需要一个易于编码的环境。创建一个Swift文件是一项简单的任务，但是当你写你的脚本时，记住你需要语法高亮、快速类查找、文档等等。您总是可以在终端中触摸MyScript.swift，然后使用Vim从那里开始，但是，这个示例适合于不太精通编程的人。</p><p id="625c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以让我们开始吧。首先，您需要从一个新的Xcode OS X命令行工具应用程序开始:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/02820c33e1220f450be9bab2af50117a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBGpCsrtm1_8YnFfvnqEVg.png"/></div></div></figure><p id="98b6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要明白重命名文件并不理想，但是Xcode在除了<em class="kq"> main.swift </em>文件之外的任何其他文件中都不识别Shebang。将它放在任何其他未命名为“<em class="kq"> main.swift </em>的文件的顶部，会给出以下警告:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/2d2dc9eb0325db380c9b1162a01686e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*OYhtToC_wHHQ4yrfXay9CA.png"/></div></div></figure><p id="bb08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当你的脚本准备好运行的时候，让我们把重命名你的<em class="kq"> main.swift </em>文件留到最后。现在，在您的<em class="kq"> main.swift </em>文件中，删除任何生成的代码和注释，并将这行代码添加到swift文件的第一行:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="9aaf" class="lg jo hh lc b fi lh li l lj lk">#!/usr/bin/swift</span></pre><p id="d47e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一行实际上首先启动Swift REPL，因此文件的其余部分实际上在Swift环境中编译。</p><p id="1a5f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步是使您的<em class="kq"> main.swift </em>文件可执行。打开终端，导航到您的<em class="kq"> main.swift </em>文件的目录，并执行以下命令:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="fded" class="lg jo hh lc b fi lh li l lj lk">$ chmod +x main.swift</span></pre><p id="a3dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从这里，回到Xcode，开始工作。文件的其余部分可以像任何常规的Swift文件一样处理。这里最酷的部分是你甚至可以导入像<a class="ae ll" href="http://foundation.zurb.com/" rel="noopener ugc nofollow" target="_blank"> Foundation </a>这样的框架。使用Foundation可以做的任何事情都可以放到脚本中——这包括文件I/O、字符串操作等等。唯一需要记住的“问题”是，Swift中的脚本遵循与C语言中的程序或Xcode游乐场中的项目相同的原则——任何函数、类或声明都需要高于它们的用法，如下所示:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="eea6" class="lg jo hh lc b fi lh li l lj lk">#!/usr/bin/swift <br/><br/>import Foundation <br/>class MythicalBeast { <br/>    func whatsMyName() { <br/>        println("I don't know what I am, but I'm the stuff of legends.") <br/>    } <br/>} <br/><br/>class Kraken: MythicalBeast { <br/>    override func whatsMyName() { <br/>        println("I'm the Kraken, yo!") <br/>    } <br/>} <br/><br/>//can't use the Kraken class until after the declaration <br/>let kraken = Kraken() kraken.whatsMyName()</span></pre><p id="cc76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦您准备好脚本，运行它就是一件简单的事情，导航到您的Swift脚本并在终端中执行它，如下所示:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="0654" class="lg jo hh lc b fi lh li l lj lk">$./main.swift <br/>I'm the Kraken, yo!</span></pre><p id="49e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您的脚本甚至可以接受参数。只需在执行命令后添加您想要的任何内容，就像常规脚本一样添加您的参数:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="077c" class="lg jo hh lc b fi lh li l lj lk">$ ./main.swift firstArgument secondArgument thirdArgument</span></pre><p id="348b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在脚本中读取这些参数，您可以使用Swift标准库中的enum流程，如下所示:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="da13" class="lg jo hh lc b fi lh li l lj lk">dump(Process.arguments)</span></pre><p id="64d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用我们刚刚编写的终端命令，上面的代码将在新的行上将每个参数打印到终端，如下所示:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="193d" class="lg jo hh lc b fi lh li l lj lk">$ ./main.swift firstArgument secondArgument thirdArgument <br/>▿ 4 elements<br/>    - [0]: ./main.swift   <br/>    - [1]: firstArgument   <br/>    - [2]: secondArgument   <br/>    - [3]: thirdArgument</span></pre><p id="5bd6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就对了。这应该是你需要知道的一切。现在小心点-</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/07f733eeb1aab507bac2843b3e7cb7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyH-MISoNL4s9XTzRC6jkQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx"><em class="la">With great power comes great responsibility.</em></figcaption></figure><p id="120a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注:如果你想看我的第一个Swift脚本的非更新版本，请查看<a class="ae ll" href="https://github.com/hectormatos2011/SwiftOnePointTwoConverter" rel="noopener ugc nofollow" target="_blank">这个回购</a>。那个回购包含我在这篇文章顶部的故事中写的脚本。</p><h1 id="86c7" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用SWIFTC让事情变得更简单</h1><p id="2e29" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我收到了一条来自<a class="ae ll" href="https://twitter.com/eneko" rel="noopener ugc nofollow" target="_blank"> @eneko </a>的推文，说你也可以在终端中使用Swift编译器，<em class="kq"> swiftc </em>(仅限于Xcode 6.1和Yosemite)，将你的Swift文件编译成可执行的二进制文件。这跳过了chmod +x调用，直接使用我们熟悉和喜爱的工具:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="6a08" class="lg jo hh lc b fi lh li l lj lk">$ swiftc main.swift -o kraken //The parameter after -o is the name you really want your script to be called other than "main".</span></pre><p id="009c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用swiftc的唯一问题是，根据您的环境，如果您试图将Foundation之类的框架导入到您的Swift脚本中，您可能需要在终端命令之前运行<em class="kq"> xcrun sdk macosx swiftc </em>:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="27d2" class="lg jo hh lc b fi lh li l lj lk">$ xcrun -sdk macosx swiftc kraken.swift -o kraken</span></pre><p id="5c3c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">只有当您的控制台中出现如下所示的错误时，才需要这样做:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="d452" class="lg jo hh lc b fi lh li l lj lk">&lt;unknown&gt;:0: error: cannot load underlying module for 'CoreGraphics'<br/>&lt;unknown&gt;:0: note: did you forget to set an SDK using -sdk or SDKROOT?<br/>&lt;unknown&gt;:0: note: use "xcrun -sdk macosx swift" to select the default OS X SDK installed with Xcode</span></pre><p id="bc35" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果代码看起来很难看并且很难记住，您可以通过将这一行放入您的<em class="kq">中来为xcrun行起别名。bash_profile </em>:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="e41b" class="lg jo hh lc b fi lh li l lj lk">alias swiftc='xcrun -sdk macosx swiftc'</span></pre><p id="2e9d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">保存您的。<em class="kq"> bash_profile </em>，打开一个新的终端窗口，瞧！这个漂亮的命令现在应该可以正常工作了:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="f7fe" class="lg jo hh lc b fi lh li l lj lk">$ swiftc main.swift -o kraken</span></pre><p id="5014" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">成功编译后，您应该能够像这样执行您的可执行二进制文件:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="bdd7" class="lg jo hh lc b fi lh li l lj lk">$ ./kraken</span></pre><h1 id="cfc0" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">专业建议#1</h1><p id="33f3" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">使用该命令还可以让您一起编译多个Swift文件。如果您的Swift脚本变得有点太长，并且您想要在几个文件之间分割功能，您可能需要这个。只要在<em class="kq"> -o </em>参数前加上你要一起编译的文件就应该设置好了！</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="07be" class="lg jo hh lc b fi lh li l lj lk">$ swiftc one.swift two.swift three.swift -o combined.swift</span></pre><h1 id="0907" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">专业建议#2</h1><p id="679c" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">如果你想变得更有趣，并且如果你有sudo权限，将你的二进制文件移动到<em class="kq"> /usr/bin </em>文件夹会使你的脚本通用，并且可以在终端的任何目录中使用。它还消除了用<em class="kq">调用脚本的需要。/ </em>。你可以这样移动你的可执行文件:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="0f66" class="lg jo hh lc b fi lh li l lj lk">$ sudo cp kraken /usr/bin</span></pre><p id="58f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使该脚本的未来命令如下所示，这进一步简化了脚本的执行:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="35be" class="lg jo hh lc b fi lh li l lj lk">$ kraken firstArgument secondArgument etc</span></pre><h1 id="70dd" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">卡托——一个整洁的图书馆</h1><p id="cee4" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我也鼓励你去看看<a class="ae ll" href="https://github.com/neonichu/cato" rel="noopener ugc nofollow" target="_blank">Cocoapods</a>的Boris的这颗大红宝石。这是一个使您的脚本版本化的好方法，它让您能够指定您的脚本是用哪个版本的Swift编写的，等等！</p><h1 id="5bb4" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="bfa3" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">脚本是一种强大的资产，是任何程序员工具箱中的有用工具。对于很多iOS开发者来说，Swift或者Objective-C是他们唯一知道的语言。如果他们知道Swift，那么在为任何自动化流程编写简单的脚本时，就没有必要学习Python或另一种脚本语言。这甚至包括持续集成。在自动部署应用程序时，我甚至和Jenkins一起使用过它。希望有了这个指南，你可以在自动化列车上走得更远。编码快乐！</p><p id="639a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="kq">改编自最初出现在</em></strong><a class="ae ll" href="http://krakendev.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="kq">krakendev . io</em></strong></a>上的一篇博文</p></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><p id="fb84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。<a class="ae ll" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="kq"/></a></p></div></div>    
</body>
</html>