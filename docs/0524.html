<html>
<head>
<title>Scoping in Android and Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android和Hilt中的范围</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0?source=collection_archive---------0-----------------------#2020-07-21">https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0?source=collection_archive---------0-----------------------#2020-07-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/859499c14f0c0376a98497b2190e4e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqsETASsCZHY2m0XyEYTMQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="82a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">将</strong>一个对象<code class="du js jt ju jv b">A</code>限定为另一个对象<code class="du js jt ju jv b">B</code>意味着在<code class="du js jt ju jv b">B</code>的整个生命周期中，它将始终拥有同一个<code class="du js jt ju jv b">A</code>实例。当谈到依赖注入(DI)时，一个作用于容器的对象<code class="du js jt ju jv b">A</code>意味着容器将一直提供相同的<code class="du js jt ju jv b">A</code>实例，直到容器被销毁。</p><p id="4735" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Hilt中，您可以使用注释将类型的范围扩大到容器或组件。例如，假设您的应用程序有一个处理登录和注销的<code class="du js jt ju jv b">UserManager</code>类型。您可以使用<code class="du js jt ju jv b">@Singleton</code>注释将此类型的范围扩大到<code class="du js jt ju jv b">ApplicationComponent</code>(这是一个由应用程序生命周期管理的容器)。应用程序组件中的作用域类型沿着组件层次结构向下流动:在本例中，相同的<code class="du js jt ju jv b">UserManager</code>实例将被提供给层次结构中的其余<a class="ae hu" href="https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy" rel="noopener ugc nofollow" target="_blank">句柄组件。应用程序中依赖于<code class="du js jt ju jv b">UserManager</code>的任何类型都将接收相同的实例。</a></p><blockquote class="jw jx jy"><p id="46a1" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">注意:默认情况下，刀柄绑定为<strong class="iw hy"> <em class="hx">未绑定</em> </strong>。它们不是任何构件的一部分，可以在整个项目中访问。每次请求时，都会提供该类型的不同实例。当您将绑定范围限定到组件时，它会限制该绑定的使用位置以及该类型可以拥有的依赖项。</p></blockquote><p id="9cf3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Android中，你可以通过使用Android框架，在没有阿迪库的情况下手动确定范围。让我们看看你如何做到这一点，以及如何映射到范围与柄。最后，我们将比较用Android框架手动确定范围和用Hilt确定范围之间的区别。</p><h1 id="ee42" class="kd ke hx bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Android中的范围</h1><p id="981b" class="pw-post-body-paragraph iu iv hx iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">根据上面的定义，你可以说你可以通过在一个特定的类中使用一个该类型的实例变量来确定一个类型的范围，这是真的！没有DI，您可以这样做:</p><pre class="lg lh li lj fd lk jv ll lm aw ln bi"><span id="70fb" class="lo ke hx jv b fi lp lq l lr ls">class ExampleActivity : AppCompatActivity() {<br/>  private val analyticsAdapter = AnalyticsAdapter()<br/>  ...<br/>}</span></pre><p id="0be3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">analyticsAdapter</code>变量的作用域是<code class="du js jt ju jv b">ExampleActivity</code>的生命周期，这意味着只要这个活动没有被销毁，它就是同一个实例。如果另一个类由于某种原因需要访问这个限定了作用域的变量，它们每次也会得到相同的实例。当<code class="du js jt ju jv b">ExampleActivity</code>的一个新实例被创建时(例如，活动经历了一个配置变更)，一个<code class="du js jt ju jv b">AnalyticsAdapter</code>的新实例将被创建。</p><p id="0aa1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于Hilt，等效代码是:</p><pre class="lg lh li lj fd lk jv ll lm aw ln bi"><span id="e03f" class="lo ke hx jv b fi lp lq l lr ls"><strong class="jv hy">@ActivityScoped</strong><br/>class AnalyticsAdapter @Inject constructor() { ... }</span><span id="c103" class="lo ke hx jv b fi lt lq l lr ls">@AndroidEntryPoint<br/>class ExampleActivity : AppCompatActivity() {</span><span id="6777" class="lo ke hx jv b fi lt lq l lr ls">  <strong class="jv hy">@Inject</strong> lateinit var analyticsAdapter: AnalyticsAdapter</span><span id="b10f" class="lo ke hx jv b fi lt lq l lr ls">}</span></pre><p id="4eb9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每次创建<code class="du js jt ju jv b">ExampleActivity</code>时，它都会保存一个<code class="du js jt ju jv b">ActivityComponent</code> DI容器的<em class="jz">新</em>实例，该实例将为<a class="ae hu" href="https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy" rel="noopener ugc nofollow" target="_blank">组件层次结构</a>中位于其下的依赖项提供相同的<code class="du js jt ju jv b">AnalyticsAdapter</code>实例，直到活动被销毁。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/41475143fa1e50c4de0467baef5590cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bKpss_Sf-OkopJ7Y"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="lv">You get a new instance of AnalyticsAdapter and MainActivity after a configuration change</em></figcaption></figure><h1 id="86eb" class="kd ke hx bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用ViewModel确定范围</h1><p id="631c" class="pw-post-body-paragraph iu iv hx iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">然而，我们可能希望<code class="du js jt ju jv b">AnalyticsAdapter</code>在配置改变后仍然存在！我们可以说，我们希望将该实例的范围扩大到活动，直到用户离开它。</p><p id="0797" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，您可以使用一个<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">架构组件视图模型</a>,因为它能够经受住配置的变化。</p><p id="5978" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果没有依赖注入，您可能会有这样的代码:</p><pre class="lg lh li lj fd lk jv ll lm aw ln bi"><span id="ec08" class="lo ke hx jv b fi lp lq l lr ls">class AnalyticsAdapter() { ... }</span><span id="a433" class="lo ke hx jv b fi lt lq l lr ls">class <strong class="jv hy">ExampleViewModel() : ViewModel()</strong> {<br/>  val analyticsAdapter = AnalyticsAdapter()<br/>}</span><span id="40f1" class="lo ke hx jv b fi lt lq l lr ls">class ExampleActivity : AppCompatActivity() {</span><span id="5349" class="lo ke hx jv b fi lt lq l lr ls">  private val viewModel: <strong class="jv hy">ExampleViewModel by viewModels()</strong><br/>  private val analyticsAdapter = viewModel.analyticsAdapter</span><span id="cad3" class="lo ke hx jv b fi lt lq l lr ls">}</span></pre><p id="425a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过这种方式，您可以将<code class="du js jt ju jv b">AnalyticsAdapter</code>限定到视图模型。因为活动可以访问ViewModel，所以它总是可以获取同一个<code class="du js jt ju jv b">AnalyticsAdapter</code>实例。</p><p id="cbcb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用Hilt，您可以通过将<code class="du js jt ju jv b">AnalyticsAdapter</code>作用于<code class="du js jt ju jv b">ActivityRetainedComponent</code>来实现相同的行为，这也可以在配置更改后保持不变:</p><pre class="lg lh li lj fd lk jv ll lm aw ln bi"><span id="1736" class="lo ke hx jv b fi lp lq l lr ls"><strong class="jv hy">@ActivityRetainedScoped<br/></strong>class AnalyticsAdapter @Inject constructor() { ... }</span><span id="5a30" class="lo ke hx jv b fi lt lq l lr ls">@AndroidEntryPoint<br/>class ExampleActivity : AppCompatActivity() {</span><span id="9fbc" class="lo ke hx jv b fi lt lq l lr ls">  <strong class="jv hy">@Inject</strong> lateinit var analyticsAdapter: AnalyticsAdapter</span><span id="ea9d" class="lo ke hx jv b fi lt lq l lr ls">}</span></pre><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/5a33cab2c5d48a7068455004fb5e068b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-krz5hOvEfVnbGOJ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="lv">You get the same instance of AnalyticsAdapter after a configuration change using ViewModel or Hilt’s ActivityRetainedScope annotation</em></figcaption></figure><p id="c1dd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您仍然希望保留ViewModel，因为它需要在遵循良好的DI实践的同时执行一些视图逻辑，那么您可以按照<a class="ae hu" href="https://developer.android.com/training/dependency-injection/hilt-jetpack#viewmodels" rel="noopener ugc nofollow" target="_blank">文档</a>中的说明，使用<code class="du js jt ju jv b">@ViewModelInject</code>来提供ViewModel依赖项。这一次，<code class="du js jt ju jv b">AnalyticsAdapter</code>不需要作用于<code class="du js jt ju jv b">ActivityRetainedComponent</code>，因为它现在被手动作用于ViewModel:</p><pre class="lg lh li lj fd lk jv ll lm aw ln bi"><span id="3d89" class="lo ke hx jv b fi lp lq l lr ls">class AnalyticsAdapter <strong class="jv hy">@Inject</strong> constructor() { ... }</span><span id="7839" class="lo ke hx jv b fi lt lq l lr ls">class ExampleViewModel <strong class="jv hy">@ViewModelInject</strong> constructor(<br/>  val analyticsAdapter: AnalyticsAdapter<br/>) : ViewModel() { ... }</span><span id="8225" class="lo ke hx jv b fi lt lq l lr ls">@AndroidEntryPoint<br/>class ExampleActivity : AppCompatActivity() {</span><span id="bec4" class="lo ke hx jv b fi lt lq l lr ls">  private val viewModel: <strong class="jv hy">ExampleViewModel by viewModels()</strong><br/>  private val analyticsAdapter = viewModel.analyticsAdapter</span><span id="dc12" class="lo ke hx jv b fi lt lq l lr ls">}</span></pre><p id="80ca" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，我们所看到的可以应用于所有由Android框架生命周期类管理的Hilt组件；参见<a class="ae hu" href="https://developer.android.com/training/dependency-injection/hilt-android#component-scopes" rel="noopener ugc nofollow" target="_blank">此处提供的示波器完整列表</a>。回到我们最初的例子，作用于<code class="du js jt ju jv b">ApplicationComponent</code>与在application类中有一个该类型的实例而不使用DI原则是一样的。</p><h1 id="2310" class="kd ke hx bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用Hilt和ViewModel确定范围</h1><p id="37b2" class="pw-post-body-paragraph iu iv hx iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">用Hilt限定范围的优点是，限定范围的类型在Hilt组件层次结构中是可用的，而用ViewModel，您必须从ViewModel手动访问限定范围的类型。</p><p id="f10b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用ViewModel确定范围的优点是您可以在应用程序中拥有任何<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" rel="noopener ugc nofollow" target="_blank">LifecycleOwner</a></code>对象的ViewModel。例如，如果您使用<a class="ae hu" href="https://developer.android.com/guide/navigation/navigation-getting-started" rel="noopener ugc nofollow" target="_blank"> Jetpack导航库</a>，您可以在<a class="ae hu" href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment" rel="noopener ugc nofollow" target="_blank">导航图</a>上附加一个视图模型。</p><p id="eac6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">希尔特提供了有限数量的范围。您可能会发现您没有特定用例的范围——例如，当使用嵌套片段时。在这种情况下，您可以使用ViewModel来确定范围。</p><h1 id="3457" class="kd ke hx bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">用柄注入视图模型</h1><p id="8df2" class="pw-post-body-paragraph iu iv hx iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">如上所述，您可以使用<code class="du js jt ju jv b">@ViewModelInject</code>将依赖项注入视图模型。在幕后，这些绑定保存在<code class="du js jt ju jv b">ActivityRetainedComponent</code>中，这就是为什么您只能注入未被划分范围的类型，或者范围为<code class="du js jt ju jv b">ActivityRetainedComponent</code>或<code class="du js jt ju jv b">ApplicationComponent</code>的类型。</p><p id="4d78" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Hilt生成的ViewModel工厂在<code class="du js jt ju jv b">@AndroidEntryPoint</code>的<code class="du js jt ju jv b">getDefaultViewModelProviderFactory()</code>方法中可用——带注释的活动和片段。这为您提供了更多的灵活性，因为您可以在<code class="du js jt ju jv b">ViewModelProvider</code>中使用它来获得其他视图模型，例如那些作用于<code class="du js jt ju jv b">BackStackEntry</code>的视图模型。</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="15f2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作用域的开销可能很大，因为提供的对象会一直留在内存中，直到持有者被销毁。在应用程序中使用作用域对象时要考虑周全。合适的范围是具有需要使用相同实例的内部状态的对象、需要同步的对象或您认为创建成本很高的对象。</p><p id="f14a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，当你需要确定范围时，你可以直接使用Hilt的范围注释或者Android框架。</p></div></div>    
</body>
</html>