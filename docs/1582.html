<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison (Part 6): Threading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和rx Java——异步比较(第6部分):线程</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-6-threading-2aa5e9c52c94?source=collection_archive---------1-----------------------#2018-07-17">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-6-threading-2aa5e9c52c94?source=collection_archive---------1-----------------------#2018-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/8c337d20bac26e82d53b7c797782b5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVm0BusvVj6ZY7-hhHBq5Q.png"/></div></div></figure><div class=""/><h1 id="4308" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="90ba" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这个博客系列中，我将比较<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>和<a class="ae kl" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，因为它们都试图解决Android开发中的一个常见问题:<strong class="jp ht">异步编程</strong>。</p><p id="009d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">作为本系列的一部分，我们已经讨论了许多不同的主题:<a class="ae kl" rel="noopener" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a">异步编程</a>、<a class="ae kl" rel="noopener" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068">取消执行</a>、<a class="ae kl" rel="noopener" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791">传输值流</a>、<a class="ae kl" rel="noopener" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-4-interop-library-4a2439a690f9">互操作库</a>和<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-5-operators-2603a8ecaa5f">操作符</a>。</p><p id="765f" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">因为我们要比较的最新话题是<strong class="jp ht">线程</strong>！</p><h1 id="6525" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">缓慢渲染</h1><p id="27bc" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在Android应用程序中，如果你想有一个反应灵敏的用户界面，你需要控制你的代码在哪个线程中执行。</p><p id="cc5a" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">你不希望你的应用程序跳帧，给用户不好的体验。这被称为<a class="ae kl" href="https://developer.android.com/topic/performance/vitals/render.html" rel="noopener ugc nofollow" target="_blank">慢速渲染</a>，通常发生在Android UI线程中有大量处理正在进行时。</p><p id="d1e3" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">所有的UI操作都必须在UI线程上运行(例如，设置TextView的文本),但其他操作不需要。这就是为什么我们想要<strong class="jp ht">减少UI线程的负载(为了平滑渲染)并在后台线程中运行非UI操作</strong>。</p><blockquote class="kr"><p id="8633" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">注意，如果你担心你在UI线程上做了太多的工作，有不同的方法<a class="ae kl" href="https://developer.android.com/studio/profile/index.html" rel="noopener ugc nofollow" target="_blank">用Android Studio </a>分析你的应用。</p></blockquote><h1 id="b732" class="ip iq hs bd ir is it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm bi translated">RxJava中的线程</h1><p id="d586" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">RxJava中的线程由两个操作符控制:<code class="du le lf lg lh b"><a class="ae kl" href="http://reactivex.io/documentation/operators/subscribeon.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">subscribeOn()</strong></a></code>和<code class="du le lf lg lh b"><a class="ae kl" href="http://reactivex.io/documentation/operators/observeon.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">observeOn()</strong></a></code>。</p><p id="ea05" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">简而言之，<strong class="jp ht">subscribe</strong>指定一个可观察对象将在其上执行其<code class="du le lf lg lh b">.create</code>方法的调度程序，而<strong class="jp ht">observe</strong>指定一个观察者将在其上消费可观察对象发出的项目的调度程序。</p><p id="3c0d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><a class="ae kl" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Scheduler.html" rel="noopener ugc nofollow" target="_blank">调度器<strong class="jp ht"/></a>是一个调度要执行的动作的工具。有一些<a class="ae kl" href="http://reactivex.io/RxJava/javadoc/io/reactivex/schedulers/Schedulers.html" rel="noopener ugc nofollow" target="_blank">预定义的调度器</a>，但是你也可以创建你自己的调度器，传递一个ExecutorService(可以包含你自己的线程池)。</p><p id="b9de" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们来看一段RxJava代码。我们将利用这些操作符，同时用一个<code class="du le lf lg lh b">Single.zip</code>操作符转换我们发送的元素。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es li"><img src="../Images/8c14d926b4830da00957ac97b7b71793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-IaBn8COCF8WdlHO4TxSQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">RxJava code to study</figcaption></figure><p id="67d6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们把这些都分解开来。你可能已经注意到了<code class="du le lf lg lh b">subscribeOn()</code>操作符。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/51fd66950d9aed7bdb29a3852fe55b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muG1TavXBWRX3O4LsIyeqA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">subscribeOn defines on which Scheduler the Observable will execute its create method</figcaption></figure><p id="7aa6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">它定义了<code class="du le lf lg lh b">Single.create</code>将在哪个调度程序上执行。这种情况下，<code class="du le lf lg lh b">Schedulers.computation()</code>。</p><blockquote class="kr"><p id="6fc2" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">请注意，所有创建观察值的RxJava操作符(即<code class="du le lf lg lh b">Single.just</code>、<code class="du le lf lg lh b">Single.zip</code>等)都在内部使用<code class="du le lf lg lh b">Single.create</code>。</p></blockquote><figure class="lt lu lv lw lx hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/c41211580f7d0460c0032840c30e3a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNDfqCxbpgbSC6bSZVx21A.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The emission of the item will happen on Schedulers.computation()</figcaption></figure><p id="62c5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">发出该项目后，我们将对该对象进行转换。为了在不同的线程中执行它们，我们必须在不同的调度器上观察项目。我们通过<code class="du le lf lg lh b">observeOn()</code>操作符实现了这一点。</p><blockquote class="kr"><p id="127f" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">请注意，我们在应用转换之前使用observeOn操作符，在创建可观察对象之后使用subscribeOn操作符</p></blockquote><figure class="lt lu lv lw lx hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/b2785274fbc25c4b2a362bcefb81282f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO0U8uSFzk4_KVMx9Ul0yg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Usage of observeOn to execute transformations/observe items in different threads</figcaption></figure><p id="fd79" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">第一个转换包括发出那个数字的平方，我们希望它发生在<code class="du le lf lg lh b">Schedulers.io()</code>。</p><blockquote class="kr"><p id="4569" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">请注意，这不是你在应用程序中会做的事情。我只是切换到不同的调度器来展示我们如何做到这一点，以及线程在RxJava中是如何工作的。</p></blockquote><figure class="lt lu lv lw lx hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/1005ffe58d21c7c626d1fbc9b0f2e40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6umLr-iNNgxY6UlsYMV3YA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Transforming the item on Schedulers.io()</figcaption></figure><p id="9415" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如您所见，我们调用<code class="du le lf lg lh b">observeOn(Schedulers.io())</code>来决定我们希望哪个调度程序来消费该项目。然后，我们使用<code class="du le lf lg lh b">flatMap</code>操作符返回一个Single，它发出我们收到的数字的平方。</p><blockquote class="kr"><p id="92bf" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">注意一个<code class="du le lf lg lh b">map</code>操作员也会在这里工作来转换物品。我用<code class="du le lf lg lh b">flatMap</code>来展示RxJava中线程的强大。</p></blockquote><p id="9bf5" class="pw-post-body-paragraph jn jo hs jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ha bi translated">下一个转换将发出我们接收到的数字(我们从上一个转换中得到的原始数字的平方)减去1。由于我们再次切换到<code class="du le lf lg lh b">Schedulers.computation()</code>，转换将在那个调度程序上执行。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mf"><img src="../Images/e702b8c8168cfad35a56d97809c79052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkJEfyE8MMXrfjoVtUevWQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Transforming the item on Schedulers.computation()</figcaption></figure><p id="1a81" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">现在我们想消费这个项目。因为我们假设会做一些用户界面的改变，我们希望这发生在Android主线程中。和以前一样，我们使用<code class="du le lf lg lh b">observeOn()</code>操作符传入<code class="du le lf lg lh b">AndroidSchedulers.mainThread()</code>。</p><blockquote class="mg mh mi"><p id="139c" class="jn jo mj jp b jq km js jt ju kn jw jx mk ko ka kb ml kp ke kf mm kq ki kj kk ha bi translated"><code class="du le lf lg lh b">AndroidSchedulers.mainThread()</code>是<a class="ae kl" href="https://github.com/ReactiveX/RxAndroid" rel="noopener ugc nofollow" target="_blank"> RxAndroid </a>的Android专用调度器部分。</p></blockquote><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mn"><img src="../Images/69d048eb21a7905e2fcaf2db39c5d28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtHN7phTAia8rtjh-e8GEg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Consuming the item in the Android Main Thread</figcaption></figure><p id="cf2a" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在这个例子中，我们打印是为了安慰我们消费的商品。由于这发生在Android UI线程中，我们也可以修改屏幕上的任何UI小部件。</p><p id="8430" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">至此，我认为我们已经对RxJava中的线程化有了足够的了解，可以将其与协程中的线程化进行比较。</p><h1 id="1a64" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">协程中的线程</h1><p id="11f5" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">协程中的线程是在协程上下文中定义的。<a class="ae kl" rel="noopener" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068">在之前的文章</a>中，我们说过协程上下文是用户定义对象的<code class="du le lf lg lh b"><strong class="jp ht">set</strong></code>。线程在键<a class="ae kl" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation-interceptor/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">continuation interceptor</strong></a>的值中定义。</p><blockquote class="mg mh mi"><p id="c0e3" class="jn jo mj jp b jq km js jt ju kn jw jx mk ko ka kb ml kp ke kf mm kq ki kj kk ha bi translated">做一些类似于<code class="du le lf lg lh b">coroutineContext[ContinuationInterceptor] = threadingPolicy</code>的事情将会改变特定协程的线程策略。</p></blockquote><p id="98cb" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">该值的类型为<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">协程调度器</strong> </a>。您可以拥有一个带有单线程或线程池的协同调度程序。与RxJava线程一样，协程带有一些预定义的值，您可以开箱即用。其中一些是:</p><ul class=""><li id="855a" class="mo mp hs jp b jq km ju kn jy mq kc mr kg ms kk mt mu mv mw bi translated"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/" rel="noopener ugc nofollow" target="_blank">公共池</a>。这类似于RxJava中的<code class="du le lf lg lh b">Schedulers.computation()</code>。微小的区别在于<code class="du le lf lg lh b">computation()</code>是一个大小数量的CPU的池，而CommonPool是一个大小数量的CPU减1的池(这意味着对于双核设备，你只能得到1个线程),正如<a class="mx my ge" href="https://medium.com/u/a575ffc02c7d?source=post_page-----2aa5e9c52c94--------------------------------" rel="noopener" target="_blank"> Nick Capurso </a>在<a class="ae kl" rel="noopener" href="/capital-one-developers/kotlin-coroutines-on-android-things-i-wish-i-knew-at-the-beginning-c2f0b1f16cff">他的帖子</a>中所说。</li><li id="4b23" class="mo mp hs jp b jq mz ju na jy nb kc nc kg nd kk mt mu mv mw bi translated"><a class="ae kl" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/kotlinx-coroutines-android/src/main/kotlin/kotlinx/coroutines/experimental/android/HandlerContext.kt#L29" rel="noopener ugc nofollow" target="_blank"> UI </a>(安卓)。在Android主UI线程上调度执行。</li><li id="78b2" class="mo mp hs jp b jq mz ju na jy nb kc nc kg nd kk mt mu mv mw bi translated"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-unconfined/" rel="noopener ugc nofollow" target="_blank">无约束</a>。如果您想使用这个特性，请仔细阅读文档。如果协程通过了一个暂停点，它可能会在另一个协程调度程序上恢复。</li></ul><blockquote class="kr"><p id="f844" class="ks kt hs bd ku kv ne nf ng nh ni kk dx translated">Schedulers.computation是一个大小= CPU的池，CommonPool是一个大小= CPU-1的池</p></blockquote><h2 id="63c6" class="nj iq hs bd ir nk nl nm iv nn no np iz jy nq nr jd kc ns nt jh kg nu nv jl nw bi translated">创建您自己的协程调度程序</h2><p id="4dbc" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">您可以使用<code class="du le lf lg lh b"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-single-thread-context.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">newSingleThreadContext</strong></a></code>创建一个单线程的协同调度程序。</p><pre class="lj lk ll lm fd nx lh ny nz aw oa bi"><span id="5762" class="nj iq hs lh b fi ob oc l od oe">val coroutineDispatcher = <strong class="lh ht">newSingleThreadContext</strong>("ThreadName")</span></pre><p id="68e5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">并且还可以使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-fixed-thread-pool-context.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">newFixedThreadPoolContext</strong></a>创建一个具有固定大小线程池的协同调度器。</p><pre class="lj lk ll lm fd nx lh ny nz aw oa bi"><span id="aae7" class="nj iq hs lh b fi ob oc l od oe">val coroutineDispatcher = <strong class="lh ht">newFixedThreadPoolContext</strong>(4, "PoolName")</span></pre><p id="9aab" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这将创建一个具有由四个线程组成的线程池的CoroutineDispatcher。</p><h2 id="83bf" class="nj iq hs bd ir nk of nm iv nn og np iz jy oh nr jd kc oi nt jh kg oj nv jl nw bi translated">实践中的穿线</h2><p id="21ce" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">现在是时候以RxJava为例，使用协程完成一个类似的例子了。</p><p id="d257" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们来看看下面的协程:</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ok"><img src="../Images/93f387bc93477847b3223ffed79cc1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GshGYxLur6VDHkOpcuWIXw.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Coroutine code to study</figcaption></figure><p id="95b5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如您所见，在第一行中，我们用协程构建器<code class="du le lf lg lh b">launch</code>启动了一个协程，并将<code class="du le lf lg lh b">CommonPool</code>作为协程上下文传递。这将覆盖我们刚刚创建的协程的ContinuationInterceptor值。这将使我们的协程在后台运行。</p><blockquote class="kr"><p id="a8ed" class="ks kt hs bd ku kv kw kx ky kz la kk dx translated">协程中的代码将在后台线程中执行。</p></blockquote><p id="9273" class="pw-post-body-paragraph jn jo hs jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ha bi translated"><strong class="jp ht"> CommonPool是CoroutineContext中ContinuationInterceptor键的默认</strong>值。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ol"><img src="../Images/9aa62b2238e7bfb30ea59cda811a6ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYUpyr8aTPcAeYeXJ2-_sw.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Using the CoroutineContext of the parent coroutine</figcaption></figure><p id="e8d6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在接下来的几行中，我们创建了另外两个协程来模仿我们在RxJava代码中对<code class="du le lf lg lh b">Single.zip</code>所做的事情。然后，我们只需等待两个协程完成，对它们返回的数字求和，并将其赋给<code class="du le lf lg lh b">result</code>变量。</p><p id="7459" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">新的两个协同程序的代码在哪里执行？如您所见，我们将<code class="du le lf lg lh b">coroutineContext</code>作为参数传递给<code class="du le lf lg lh b">async</code>协程构建器。<code class="du le lf lg lh b">coroutineContext</code>是每个协程都有的变量，<strong class="jp ht">是指父协程</strong>的上下文，即我们在第一行用<code class="du le lf lg lh b">launch</code>创建的协程的上下文。因此，异步协同例程有效地使用父协同例程的协同上下文:<code class="du le lf lg lh b">CommonPool</code>。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es om"><img src="../Images/6428b10902173e36a25ef7ddd26dabe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEaaDWHDVJzbf8cd3lggBg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The code will be executed in the CommonPool since we use the parent CoroutineContext</figcaption></figure><p id="1966" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">所有代码都将在<code class="du le lf lg lh b">CommonPool</code>中执行，因为那是主协程的ContinuationInterceptor值。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es on"><img src="../Images/b587743bcef194fcd51323e93dca159e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZie-KD0RJylIMUFquKiqQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Use of newSingleThreadContext</figcaption></figure><p id="d4a6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">下一步是什么？我们希望像在RxJava代码中那样应用转换。我们正在创建另一个协程来转换变量<code class="du le lf lg lh b">result</code>的值。为此，我们使用协程构建器<code class="du le lf lg lh b">launch</code>并调用<code class="du le lf lg lh b">.join()</code>，因此父协程等待这个协程完成。</p><p id="1e38" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如您所见，我们正在使用<code class="du le lf lg lh b">newSingleThreadContext</code>，这将创建一个新线程来执行这个协程中的代码。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oo"><img src="../Images/cfbe8abeeffb547fe59e7c06059e69c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDMcUv7P7xhJWz3WGGVdNA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The coroutine will be executed in a new thread we just created to run it</figcaption></figure><p id="6469" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">协程中的代码将在一个名为<code class="du le lf lg lh b">CustomThread</code>的新线程中执行。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es op"><img src="../Images/539436e55bf8a93f22d4e460c8c61f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZCaYuPPmAU9P_wHp0DtDA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Another way of swapping threads with Coroutines</figcaption></figure><p id="d889" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">对于最后一个例子，我们使用<code class="du le lf lg lh b"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-context.html" rel="noopener ugc nofollow" target="_blank">withContext</a></code>。如果我们假设想要运行Android UI主线程中的代码来进行一些UI更改，我们将不得不使用UI CoroutineDispatcher。</p><p id="551e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><code class="du le lf lg lh b">withContext</code>是一个挂起函数，它将在不同的上下文中运行其中的挂起代码。在继续执行之前，父协程将等待它返回。</p><figure class="lj lk ll lm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oq"><img src="../Images/09b57991a4be978fe6965539f3642e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BIVaHCqXRCKcRP-lereoA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">The code is executed in the context defined as a parameter</figcaption></figure><p id="205e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">挂起函数中的代码将在Android UI线程中执行。</p><h2 id="9269" class="nj iq hs bd ir nk of nm iv nn og np iz jy oh nr jd kc oi nt jh kg oj nv jl nw bi translated">withContext vs launch.join</h2><p id="1519" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">什么时候必须用<code class="du le lf lg lh b">withContext</code> vs <code class="du le lf lg lh b">launch{}.join()</code>？在这两种情况下，调用这些方法的父协程将等待它们完成。然而，<code class="du le lf lg lh b">launch</code>会创建一个新的协程，而<code class="du le lf lg lh b">withContext</code>不会。<code class="du le lf lg lh b">launch</code>会增加创建新协程的额外成本。</p><p id="9e79" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">此时，我会根据可读性做出决定。如果要执行的任务与协程相关，我会使用<code class="du le lf lg lh b">withContext</code>。如无关联，<code class="du le lf lg lh b">launch</code>。</p><h1 id="0a44" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="8097" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这一系列即将结束，这是我们最后一次就某一特定主题进行比较。我们已经看到了<strong class="jp ht">两个库如何为异步编程的每个方面提供解决方案</strong>。</p><p id="6863" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我想提出几个结论:</p><ul class=""><li id="5fe9" class="mo mp hs jp b jq km ju kn jy mq kc mr kg ms kk mt mu mv mw bi translated">RxJava和协程之间没有赢家/输家。用适合你项目的，你最喜欢的。这可能会有所不同，对您和您的项目来说是独一无二的。</li><li id="3998" class="mo mp hs jp b jq mz ju na jy nb kc nc kg nd kk mt mu mv mw bi translated">这两个库都提供了进行异步编程的好方法。</li><li id="7b25" class="mo mp hs jp b jq mz ju na jy nb kc nc kg nd kk mt mu mv mw bi translated">如果你是RxJava专家，没必要切换。你可以继续你正在做的事情。</li><li id="b706" class="mo mp hs jp b jq mz ju na jy nb kc nc kg nd kk mt mu mv mw bi translated">如果你正在纠结RxJava或者是一个新的Android开发者，那么协程是你可以尝试的另一个选择。协程应该有一个较低的学习曲线。</li></ul><h1 id="eefc" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">更多教育</h1><p id="2fe6" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">关于RxJava 2的文章</p><div class="hg hh ez fb hi or"><a rel="noopener follow" target="_blank" href="/capital-one-developers/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e"><div class="os ab dw"><div class="ot ab ou cl cj ov"><h2 class="bd ht fi z dy ow ea eb ox ed ef hr bi translated">RxJava 2: Android MVVM生命周期应用程序结构与改进2</h2><div class="oy l"><h3 class="bd b fi z dy ow ea eb ox ed ef dx translated">自从我写了关于MVVM、RxJava和翻新的文章已经两年多了。我们来更新一下。</h3></div><div class="oz l"><p class="bd b fp z dy ow ea eb ox ed ef dx translated">medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ho or"/></div></div></a></div><p id="22da" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">本系列的前几部分</p><div class="hg hh ez fb hi or"><a rel="noopener follow" target="_blank" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a"><div class="os ab dw"><div class="ot ab ou cl cj ov"><h2 class="bd ht fi z dy ow ea eb ox ed ef hr bi translated">协程和rx Java——异步比较(第1部分):异步编程</h2><div class="oy l"><h3 class="bd b fi z dy ow ea eb ox ed ef dx translated">异步编程</h3></div><div class="oz l"><p class="bd b fp z dy ow ea eb ox ed ef dx translated">异步Programmingmedium.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ho or"/></div></div></a></div><div class="hg hh ez fb hi or"><a rel="noopener follow" target="_blank" href="/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068"><div class="os ab dw"><div class="ot ab ou cl cj ov"><h2 class="bd ht fi z dy ow ea eb ox ed ef hr bi translated">协程和rx Java——异步比较(第2部分):取消执行</h2><div class="oy l"><h3 class="bd b fi z dy ow ea eb ox ed ef dx translated">第2部分—取消执行</h3></div><div class="oz l"><p class="bd b fp z dy ow ea eb ox ed ef dx translated">medium.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ho or"/></div></div></a></div><p id="0c6e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">感谢阅读，</p><p id="9302" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>